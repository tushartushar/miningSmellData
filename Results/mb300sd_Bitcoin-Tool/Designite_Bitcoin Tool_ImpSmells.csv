Implementation smell,Namespace,Class,File,Method,Description
Long Method,Bitcoin_Tool.Scripts,Script,C:\repos\mb300sd_Bitcoin-Tool\Bitcoin Tool\Scripts\Script.cs,Evaluate,The method has 782 lines of code.
Long Method,Bitcoin_Tool,Program,C:\repos\mb300sd_Bitcoin-Tool\Bitcoin Tool\Program.cs,_Main,The method has 122 lines of code.
Complex Method,Bitcoin_Tool.Apps,ComputeUnspentTxOuts,C:\repos\mb300sd_Bitcoin-Tool\Bitcoin Tool\Apps\ComputeUnspentTxOuts.cs,Main,Cyclomatic complexity of the method is 9
Complex Method,Bitcoin_Tool.Scripts,Script,C:\repos\mb300sd_Bitcoin-Tool\Bitcoin Tool\Scripts\Script.cs,Evaluate,Cyclomatic complexity of the method is 8
Long Parameter List,Bitcoin_Tool.Scripts,SigningExtensions,C:\repos\mb300sd_Bitcoin-Tool\Bitcoin Tool\Scripts\SigningExtensions.cs,Sign,The method has 6 parameters. Parameters: txin' tx' prevOut' key' hashType' redeemScript
Long Parameter List,Bitcoin_Tool.Scripts,Script,C:\repos\mb300sd_Bitcoin-Tool\Bitcoin Tool\Scripts\Script.cs,CheckSig,The method has 5 parameters. Parameters: sig' pubKey' txInIndex' subScript' tx
Long Statement,Bitcoin_Tool.Apps,BlockQueue,C:\repos\mb300sd_Bitcoin-Tool\Bitcoin Tool\Apps\MakeBootstrap.cs,readNext,The length of the statement  "							fs = new FileStream(@"C:\Users\Administrator\AppData\Roaming\Bitcoin\blocks\blk" + blockFileNum.ToString("D5") + ".dat"' FileMode.Open); " is 136.
Long Statement,Bitcoin_Tool.Util,BlockFileReader,C:\repos\mb300sd_Bitcoin-Tool\Bitcoin Tool\Util\BlockFileReader.cs,getNext,The length of the statement  "							fs = new FileStream(@"C:\Users\Administrator\AppData\Roaming\Bitcoin\blocks\blk" + blockFileNum.ToString("D5") + ".dat"' FileMode.Open); " is 136.
Long Statement,Bitcoin_Tool,Program,C:\repos\mb300sd_Bitcoin-Tool\Bitcoin Tool\Program.cs,_Main,The length of the statement  "			//Tx tx = new Tx(HexString.ToByteArray("0100000001b924de36d37e9b46171036c2380dd3f86c33de7868b95f295c79d057abb876c9000000006c493046022100d35d290d515b2310a81850b14522f3965982ad059b08b7d6646372c9f6f98642022100d2d0fa06f8afa2a9df7bf7e06f901f08fc40882f486b292c217c96706912f23a012103b5091600a12d971b056170a682ea596b6680dd8a784f2960b1bfdc891155db44ffffffff0100ae4c2d000000001976a91443e86640aa84e2a53597e79109e912f8f9ebda1188ac00000000")); " is 430.
Long Statement,Bitcoin_Tool,Program,C:\repos\mb300sd_Bitcoin-Tool\Bitcoin Tool\Program.cs,_Main,The length of the statement  "			Transaction txUnspent = new Transaction(HexString.ToByteArray("0100000001f165b1179cb8ed7057540375884214287cf1592f2325080364f0bd8ef51d638b010000006a47304402207cf76bb48434e70ff0ea86a949ec4191fff0c31fdbbf6441c28293a09cb6841d022039906ff8b98761aa0d113e975c7af277d091a3cb9aaceae07dffe91f13fd65830121031adaac125ad58a48d1289bd44624d569b3ace8f9c59e02557e8ad00787dc7e06ffffffff0100ae4c2d00000000232102004066b81e658b2535b951c309edc4807a5260d9f1387e5dfda2d91355e562efac00000000")); " is 469.
Long Statement,Bitcoin_Tool,Program,C:\repos\mb300sd_Bitcoin-Tool\Bitcoin Tool\Program.cs,_Main,The length of the statement  "			FileStream fs = new FileStream(@"C:\Users\Administrator\AppData\Roaming\Bitcoin\blocks\blk" + blockFileNum.ToString("D5") + ".dat"' FileMode.Open); " is 147.
Long Statement,Bitcoin_Tool,Program,C:\repos\mb300sd_Bitcoin-Tool\Bitcoin Tool\Program.cs,_Main,The length of the statement  "						fs = new FileStream(@"C:\Users\Administrator\AppData\Roaming\Bitcoin\blocks\blk" + blockFileNum.ToString("D5") + ".dat"' FileMode.Open); " is 136.
Complex Conditional,Bitcoin_Tool.Scripts,Script,C:\repos\mb300sd_Bitcoin-Tool\Bitcoin Tool\Scripts\Script.cs,Evaluate,The conditional expression  "(ifExec.First() == IfElseExec.SKIP_IF && !(se.opCode == OpCode.OP_ELSE || se.opCode == OpCode.OP_ENDIF)) ||  						(ifExec.First() == IfElseExec.SKIP_ELSE && !(se.opCode == OpCode.OP_ENDIF))"  is complex.
Complex Conditional,Bitcoin_Tool.Scripts,Script,C:\repos\mb300sd_Bitcoin-Tool\Bitcoin Tool\Scripts\Script.cs,Evaluate,The conditional expression  "(se.opCode == OpCode.OP_IF && !stackIsZero) || (se.opCode == OpCode.OP_NOTIF && stackIsZero)"  is complex.
Complex Conditional,Bitcoin_Tool.Scripts,Script,C:\repos\mb300sd_Bitcoin-Tool\Bitcoin Tool\Scripts\Script.cs,ToBytes,The conditional expression  "se.data.Length == 1 && se.data[0].Equals((Byte)se.opCode) &&  							(se.opCode == OpCode.OP_NEGATE || (OpCode.OP_1 <= se.opCode && se.opCode <= OpCode.OP_16))"  is complex.
Virtual Method Call from Constructor,Bitcoin_Tool.Structs,Block,C:\repos\mb300sd_Bitcoin-Tool\Bitcoin Tool\Structs\Block.cs,Block,The constructor "Block" calls a virtual method "Read".
Empty Catch Block,Bitcoin_Tool.Structs.Other,UnspentTxOutList,C:\repos\mb300sd_Bitcoin-Tool\Bitcoin Tool\Structs\Other\UnspentTxOutList.cs,Write,The method has an empty catch block.
Magic Number,Bitcoin_Tool.Apps,ComputeAddressBalances,C:\repos\mb300sd_Bitcoin-Tool\Bitcoin Tool\Apps\ComputeAddressBalances.cs,Main,The following statement contains a magic number: using (FileStream fs = new FileStream(@"D:\utxo.dat"' FileMode.Open))  			{  				BinaryReader br = new BinaryReader(fs);  				lastBlockHash = br.ReadBytes(32);  				utxo = UnspentTxOutList.FromStream(fs);  			}
Magic Number,Bitcoin_Tool.Apps,ComputeUnspentTxOuts,C:\repos\mb300sd_Bitcoin-Tool\Bitcoin Tool\Apps\ComputeUnspentTxOuts.cs,Main,The following statement contains a magic number: if (File.Exists(outFile))  			{  				using (FileStream fs = new FileStream(outFile' FileMode.Open))  				{  					BinaryReader br = new BinaryReader(fs);  					lastBlockHash = br.ReadBytes(32);  					utxo = UnspentTxOutList.FromStream(fs);  				}  			}
Magic Number,Bitcoin_Tool.Apps,ComputeUnspentTxOuts,C:\repos\mb300sd_Bitcoin-Tool\Bitcoin Tool\Apps\ComputeUnspentTxOuts.cs,Main,The following statement contains a magic number: using (FileStream fs = new FileStream(outFile' FileMode.Create))  			{  				BinaryWriter bw = new BinaryWriter(fs);  				bw.Write(lastBlock.Hash' 0' 32);  				utxo.Write(fs);  			}
Magic Number,Bitcoin_Tool.Apps,FindFirstOrphan,C:\repos\mb300sd_Bitcoin-Tool\Bitcoin Tool\Apps\FindFirstOrphan.cs,Main,The following statement contains a magic number: Hash prevHash = new Byte[32];
Magic Number,Bitcoin_Tool.Apps,MakeBootstrap,C:\repos\mb300sd_Bitcoin-Tool\Bitcoin Tool\Apps\MakeBootstrap.cs,Main,The following statement contains a magic number: while (q.Count > 0)  			{  				Block_Disk b = q.Dequeue();  //				diskBlocks.Add(index' b);  				diskBlockIndex.Add(b.Hash' index);    				if (first)  				{  					chains.Single().Enqueue(b.Hash);  					first = false;  				}  				else  				{  					int ci = chains.FindIndex(x => x.ToList().Contains(b.prev_block));  					if (ci < 0){  						Console.WriteLine(HexString.FromByteArrayReversed(b.Hash));  						Console.WriteLine(HexString.FromByteArrayReversed(b.prev_block));  						Console.WriteLine(HexString.FromByteArrayReversed(chains[ci].Last()));  						throw new Exception("Invalid PrevBlock!");  					}  					if (chains[ci].Last().Equals(b.prev_block))  					{  						// Add to chain  						chains[ci].Enqueue(b.Hash);  					}  					else  					{  						// not last block in chain' duplicate and add  						List<Hash> l = chains[ci].ToList();  						int bi = l.FindIndex(x => x.Equals(b.prev_block));  						l.RemoveRange(bi + 1' l.Count - (bi + 1));  						l.Add(b.Hash);  						chains.Add(makeQueue(l));  					}    					int longestChain = chains.Max(x => x.Count);  					chains.RemoveAll(x => x.Count < (longestChain - MAX_ORPHAN_DEPTH));    					while (chains.Max(x => x.Count) > MAX_ORPHAN_DEPTH * 2)  					{  						bestChain.Enqueue(chains.First(x => x.Count == chains.Max(y => y.Count)).Peek());  						chains.ForEach(c => c.Dequeue());  						chains.RemoveAll(c => c.Count == 0);  					}  				}  				index++;  			}
Magic Number,Bitcoin_Tool.Apps,BlockQueue,C:\repos\mb300sd_Bitcoin-Tool\Bitcoin Tool\Apps\MakeBootstrap.cs,fill,The following statement contains a magic number: while (this.Count < 5) {  					Block_Disk b = readNext();  					if (b == null)  						return;  					base.Enqueue(b);  				}
Magic Number,Bitcoin_Tool.Scripts,ValidationExtensions,C:\repos\mb300sd_Bitcoin-Tool\Bitcoin Tool\Scripts\ValidationExtensions.cs,Validate,The following statement contains a magic number: for (uint i = 0; i < tx.inputs.Length; i++)  			{  				TxIn txin = tx.inputs[i];  			  				Script scriptSig = new Script(txin.scriptSig);  				Script scriptPubKey = new Script(prevOuts[new TxOutId(txin.prevOut' txin.prevOutIndex)].scriptPubKey);  				  				Script s = new Script(scriptSig' scriptPubKey);    				if (!s.Evaluate(tx' i))  					return false;  				  				if (scriptPubKey.IsPayToScriptHash() &&  					scriptSig.elements.Count == 2)  				{  					Script serializedScript = new Script(scriptSig.elements[1].data);  					scriptSig.elements.RemoveAt(1);  					s = new Script(scriptSig' serializedScript);  				  					if (!s.Evaluate(tx' i))  						return false;  				}  			}
Magic Number,Bitcoin_Tool.Scripts,Script,C:\repos\mb300sd_Bitcoin-Tool\Bitcoin Tool\Scripts\Script.cs,Evaluate,The following statement contains a magic number: for (int index = 0; index < elements.Count; index++)  			{  				ScriptElement se = elements[index];  				if (ifExec.Count > 0)  					if ((ifExec.First() == IfElseExec.SKIP_IF && !(se.opCode == OpCode.OP_ELSE || se.opCode == OpCode.OP_ENDIF)) ||  						(ifExec.First() == IfElseExec.SKIP_ELSE && !(se.opCode == OpCode.OP_ENDIF)))  						continue;    				if (se.isData)  				{  					stack.Push(se.data);  					continue;  				}    				switch (se.opCode)  				{  					case OpCode.OP_RESERVED:  						{  							return false;  						}  					case OpCode.OP_NOP:  						{  							// NOP' Dump stack for debug  							/*  							stack.ToList().ForEach(x => Console.WriteLine(HexString.FromByteArray(x)));  							Console.WriteLine("---------------------------");  							*/  							break;  						}  					case OpCode.OP_VER:  						{  							return false;  						}  					case OpCode.OP_IF:  					case OpCode.OP_NOTIF:  						{  							if (stack.Count < 1)  								return false;  							Boolean stackIsZero = new ScriptVarInt(stack.Pop()).value.IsZero;  							if ((se.opCode == OpCode.OP_IF && !stackIsZero) || (se.opCode == OpCode.OP_NOTIF && stackIsZero))  							{  								// Run to else or endif  								ifExec.Push(IfElseExec.RUN_IF);  							}  							else  							{  								// Skip to else or endif  								ifExec.Push(IfElseExec.SKIP_IF);  							}  							break;  						}  					case OpCode.OP_VERIF:  					case OpCode.OP_VERNOTIF:  						{  							return false;  						}  					case OpCode.OP_ELSE:  						{  							if (ifExec.Count == 0)  								// No preceding if statement!  								return false;  							if (ifExec.First() == IfElseExec.RUN_IF)  							{  								// If ran' skip else  								ifExec.Push(IfElseExec.SKIP_ELSE);  							}  							else if (ifExec.First() == IfElseExec.SKIP_IF)  							{  								// If did not run' run else  								ifExec.Push(IfElseExec.RUN_ELSE);  							}  							break;  						}  					case OpCode.OP_ENDIF:  						{  							if (ifExec.Count == 0)  								// No preceding if statement!  								return false;  							if (ifExec.First() == IfElseExec.RUN_IF ||  								ifExec.First() == IfElseExec.SKIP_IF)  							{  								ifExec.Pop();  							}  							else if (ifExec.First() == IfElseExec.RUN_ELSE ||  							   ifExec.First() == IfElseExec.SKIP_ELSE)  							{  								ifExec.Pop();  								ifExec.Pop();  							}  							break;  						}  					case OpCode.OP_VERIFY:  						{  							if (stack.Count < 1 || new ScriptVarInt(stack.First()).value.IsZero)  								return false;  							stack.Pop();  							break;  						}  					case OpCode.OP_RETURN:  						{  							return false;  						}  					case OpCode.OP_TOALTSTACK:  						{  							if (stack.Count < 1)  								return false;  							altstack.Push(stack.Pop());  							break;  						}  					case OpCode.OP_FROMALTSTACK:  						{  							if (altstack.Count < 1)  								return false;  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_2DROP:  						{  							if (stack.Count < 2)  								return false;  							stack.Pop();  							stack.Pop();  							break;  						}  					case OpCode.OP_2DUP:  						{  							if (stack.Count < 2)  								return false;  							stack.Push(stack.Skip(1).First());  							stack.Push(stack.Skip(1).First());  							break;  						}  					case OpCode.OP_3DUP:  						{  							if (stack.Count < 3)  								return false;  							stack.Push(stack.Skip(2).First());  							stack.Push(stack.Skip(2).First());  							stack.Push(stack.Skip(2).First());  							break;  						}  					case OpCode.OP_2OVER:  						{  							if (stack.Count < 4)  								return false;  							stack.Push(stack.Skip(3).First());  							stack.Push(stack.Skip(3).First());  							break;  						}  					case OpCode.OP_2ROT:  						{  							if (stack.Count < 6)  								return false;  							altstack.Push(stack.Skip(4).First());  							altstack.Push(stack.Skip(5).First());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_2SWAP:  						{  							if (stack.Count < 4)  								return false;  							altstack.Push(stack.Skip(2).First());  							altstack.Push(stack.Skip(3).First());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_IFDUP:  						{  							if (stack.Count < 1)  								return false;  							if (!new ScriptVarInt(stack.First()).value.IsZero)  								stack.Push(stack.First());  							break;  						}  					case OpCode.OP_DEPTH:  						{  							stack.Push(new ScriptVarInt((UInt64)stack.Count).ToBytes());  							break;  						}  					case OpCode.OP_DROP:  						{  							if (stack.Count < 1)  								return false;  							stack.Pop();  							break;  						}  					case OpCode.OP_DUP:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(stack.First());  							break;  						}  					case OpCode.OP_NIP:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_OVER:  						{  							if (stack.Count < 2)  								return false;  							stack.Push(stack.Skip(1).First());  							break;  						}  					case OpCode.OP_PICK:  						{  							if (stack.Count < 2)  								return false;  							int pick = new ScriptVarInt(stack.Pop()).intValue;  							if (pick < 0 || stack.Count <= pick)  								return false;  							stack.Push(stack.Skip(pick).First());  							break;  						}  					case OpCode.OP_ROLL:  						{  							if (stack.Count < 2)  								return false;  							int roll = new ScriptVarInt(stack.Pop()).intValue;  							if (roll < 0 || stack.Count <= roll)  								return false;  							altstack.Push(stack.Skip(roll).First());  							for (int i = 0; i < roll; i++)  								altstack.Push(stack.Pop());  							stack.Pop();  							for (int i = 0; i < roll + 1; i++)  								stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_ROT:  						{  							if (stack.Count < 3)  								return false;  							altstack.Push(stack.Skip(2).First());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_SWAP:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Skip(1).First());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_TUCK:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Push(altstack.Skip(1).First());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_CAT:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Skip(1).First().Concat(stack.First()).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_SUBSTR:  						{  							if (stack.Count < 3)  								return false;  							altstack.Push(stack.Skip(2).First()  								.Skip(new ScriptVarInt(stack.Skip(1).First()).intValue)  								.Take(new ScriptVarInt(stack.First()).intValue).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_LEFT:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Skip(1).First()  								.Take(new ScriptVarInt(stack.First()).intValue).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_RIGHT:  						{  							if (stack.Count < 2)  								return false;  							int count = new ScriptVarInt(stack.First()).intValue;  							altstack.Push(stack.Skip(1).First()  								.Skip(stack.Skip(1).First().Length - count).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_SIZE:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(new ScriptVarInt((UInt64)stack.First().Length).ToBytes());  							break;  						}  					case OpCode.OP_INVERT:  						{  							if (stack.Count < 1)  								return false;  							Byte[] data = stack.Pop();  							for (int i = 0; i < data.Length; i++)  								data[i] ^= 0xFF;  							stack.Push(data);  							break;  						}  					case OpCode.OP_AND:  					case OpCode.OP_OR:  					case OpCode.OP_XOR:  						{  							if (stack.Count < 2)  								return false;  							Byte[] data = stack.Pop();  							Byte[] data2 = stack.Pop();  							int length = new int[] { data.Length' data2.Length }.Max();  							data = data.Concat(new Byte[length - data.Length]).ToArray();  							data2 = data2.Concat(new Byte[length - data2.Length]).ToArray();  							switch (se.opCode)  							{  								case OpCode.OP_AND:  									{  										for (int i = 0; i < length; i++)  											data[i] &= data2[i];  										break;  									}  								case OpCode.OP_OR:  									{  										for (int i = 0; i < length; i++)  											data[i] |= data2[i];  										break;  									}  								case OpCode.OP_XOR:  									{  										for (int i = 0; i < length; i++)  											data[i] ^= data2[i];  										break;  									}  							}  							stack.Push(data);  							break;  						}  					case OpCode.OP_EQUAL:  					case OpCode.OP_EQUALVERIFY:  						{  							if (stack.Count < 2)  								return false;  							if (stack.Pop().SequenceEqual(stack.Pop()))  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });    							if (se.opCode == OpCode.OP_EQUALVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_RESERVED1:  					case OpCode.OP_RESERVED2:  						{  							return false;  						}  					case OpCode.OP_1ADD:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Add(new ScriptVarInt(stack.Pop())' 1)).ToBytes());  							break;  						}  					case OpCode.OP_1SUB:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Subtract(new ScriptVarInt(stack.Pop())' 1)).ToBytes());  							break;  						}  					case OpCode.OP_2MUL:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Multiply(new ScriptVarInt(stack.Pop())' 2)).ToBytes());  							break;  						}  					case OpCode.OP_2DIV:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Divide(new ScriptVarInt(stack.Pop())' 2)).ToBytes());  							break;  						}  					case OpCode.OP_NEGATE:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Negate(new ScriptVarInt(stack.Pop()))).ToBytes());  							break;  						}  					case OpCode.OP_ABS:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Abs(new ScriptVarInt(stack.Pop()))).ToBytes());  							break;  						}  					case OpCode.OP_NOT:  						{  							if (stack.Count < 1)  								return false;  							if (new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_0NOTEQUAL:  						{  							if (stack.Count < 1)  								return false;  							if (new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x00 });  							else  								stack.Push(new Byte[] { 0x01 });  							break;  						}  					case OpCode.OP_ADD:  					case OpCode.OP_SUB:  					case OpCode.OP_MUL:  					case OpCode.OP_DIV:  					case OpCode.OP_MOD:  					case OpCode.OP_LSHIFT:  					case OpCode.OP_RSHIFT:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							switch (se.opCode)  							{  								case OpCode.OP_ADD:  									a = (BigInteger)a + b;  									break;  								case OpCode.OP_SUB:  									a = (BigInteger)a - b;  									break;  								case OpCode.OP_MUL:  									a = (BigInteger)a * b;  									break;  								case OpCode.OP_DIV:  									a = (BigInteger)a / b;  									break;  								case OpCode.OP_MOD:  									a = (BigInteger)a % b;  									break;  								case OpCode.OP_LSHIFT:  									a = (BigInteger)a << b.intValue;  									break;  								case OpCode.OP_RSHIFT:  									a = (BigInteger)a >> b.intValue;  									break;  							}  							stack.Push(a.ToBytes());  							break;  						}  					case OpCode.OP_BOOLAND:  						{  							if (stack.Count < 2)  								return false;  							if (!new ScriptVarInt(stack.Pop()).value.IsZero && !new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_BOOLOR:  						{  							if (stack.Count < 2)  								return false;  							if (!new ScriptVarInt(stack.Pop()).value.IsZero || !new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_NUMEQUAL:  					case OpCode.OP_NUMEQUALVERIFY:  						{  							if (stack.Count < 2)  								return false;  							if (new ScriptVarInt(stack.Pop()).value == new ScriptVarInt(stack.Pop()).value)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							if (se.opCode == OpCode.OP_NUMEQUALVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_NUMNOTEQUAL:  						{  							if (stack.Count < 2)  								return false;  							if (new ScriptVarInt(stack.Pop()).value != new ScriptVarInt(stack.Pop()).value)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_LESSTHAN:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a < b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_GREATERTHAN:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a > b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_LESSTHANOREQUAL:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a <= b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_GREATERTHANOREQUAL:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a >= b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_MIN:  						{  							if (stack.Count < 2)  								return false;  							Byte[] b = stack.Pop();  							Byte[] a = stack.Pop();  							if (new ScriptVarInt(a).value < new ScriptVarInt(b).value)  								stack.Push(a);  							else  								stack.Push(b);  							break;  						}  					case OpCode.OP_MAX:  						{  							if (stack.Count < 2)  								return false;  							Byte[] b = stack.Pop();  							Byte[] a = stack.Pop();  							if (new ScriptVarInt(a).value > new ScriptVarInt(b).value)  								stack.Push(a);  							else  								stack.Push(b);  							break;  						}  					case OpCode.OP_WITHIN:  						{  							if (stack.Count < 3)  								return false;  							ScriptVarInt max = new ScriptVarInt(stack.Pop());  							ScriptVarInt min = new ScriptVarInt(stack.Pop());  							ScriptVarInt x = new ScriptVarInt(stack.Pop());  							if ((BigInteger)min <= x && (BigInteger)x <= max)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_RIPEMD160:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(ripemd160.ComputeHash(stack.Pop()));  							break;  						}  					case OpCode.OP_SHA1:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(sha1.ComputeHash(stack.Pop()));  							break;  						}  					case OpCode.OP_SHA256:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(sha256.ComputeHash(stack.Pop()));  							break;  						}  					case OpCode.OP_HASH160:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(ripemd160.ComputeHash(sha256.ComputeHash(stack.Pop())));  							break;  						}  					case OpCode.OP_HASH256:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(sha256.ComputeHash(sha256.ComputeHash(stack.Pop())));  							break;  						}  					case OpCode.OP_CODESEPARATOR:  						{  							lastCodeSeperator = index;  							break;  						}  					case OpCode.OP_CHECKSIG:  					case OpCode.OP_CHECKSIGVERIFY:  						{  							if (tx == null)  								throw new ArgumentNullException("Transaction is required if script contains OP_CHECKSIG[VERIFY]");  							if (stack.Count < 2)  								return false;    							PublicKey pubKey = new PublicKey(stack.Pop());  							Byte[] sig = stack.Pop();    							Script subScript = new Script(elements.Skip(lastCodeSeperator)  								.Where(x => x.opCode != OpCode.OP_CODESEPARATOR).ToArray());    							stack.Push(new ScriptVarInt(CheckSig(sig' pubKey' txInIndex' subScript' tx) ? 1 : 0).ToBytes());    							if (se.opCode == OpCode.OP_CHECKSIGVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_CHECKMULTISIG:  					case OpCode.OP_CHECKMULTISIGVERIFY:  						{  							if (tx == null)  								throw new ArgumentNullException("Transaction is required if script contains OP_CHECKMULTISIG[VERIFY]");  							if (stack.Count < 2)  								return false;    							PublicKey[] pubKeys = new PublicKey[new ScriptVarInt(stack.Pop()).intValue];    							if (stack.Count < pubKeys.Length + 1)  								return false;    							for (int i = 0; i < pubKeys.Length; i++)  							{  								pubKeys[i] = new PublicKey(stack.Pop());  							}    							Byte[][] sigs = new Byte[new ScriptVarInt(stack.Pop()).intValue][];    							if (stack.Count < sigs.Length)  								return false;    							for (int i = 0; i < sigs.Length; i++)  							{  								sigs[i] = stack.Pop();  							}    							// Remove extra unused value from stack  							stack.Pop();    							Script subScript = new Script(elements.Skip(lastCodeSeperator)  								.Where(x => x.opCode != OpCode.OP_CODESEPARATOR).ToArray());    							int validSigs = 0;  							foreach (Byte[] sig in sigs)  							{  								foreach (PublicKey pubKey in pubKeys)  								{  									if (CheckSig(sig' pubKey' txInIndex' subScript' tx))  									{  										pubKeys = pubKeys.Where(x => x != pubKey).ToArray();  										validSigs++;  										break;  									}  								}  							}    							stack.Push(new ScriptVarInt((validSigs >= sigs.Length) ? 1 : 0).ToBytes());    							if (se.opCode == OpCode.OP_CHECKMULTISIGVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_NOP1:  					case OpCode.OP_NOP2:  					case OpCode.OP_NOP3:  					case OpCode.OP_NOP4:  					case OpCode.OP_NOP5:  					case OpCode.OP_NOP6:  					case OpCode.OP_NOP7:  					case OpCode.OP_NOP8:  					case OpCode.OP_NOP9:  					case OpCode.OP_NOP10:  						{  							break;  						}  					case OpCode.OP_SMALLINTEGER:  					case OpCode.OP_PUBKEYS:  					case OpCode.OP_PUBKEYHASH:  					case OpCode.OP_PUBKEY:  					case OpCode.OP_INVALIDOPCODE:  					default:  						{  							return false;  						}    				}  			}
Magic Number,Bitcoin_Tool.Scripts,Script,C:\repos\mb300sd_Bitcoin-Tool\Bitcoin Tool\Scripts\Script.cs,Evaluate,The following statement contains a magic number: for (int index = 0; index < elements.Count; index++)  			{  				ScriptElement se = elements[index];  				if (ifExec.Count > 0)  					if ((ifExec.First() == IfElseExec.SKIP_IF && !(se.opCode == OpCode.OP_ELSE || se.opCode == OpCode.OP_ENDIF)) ||  						(ifExec.First() == IfElseExec.SKIP_ELSE && !(se.opCode == OpCode.OP_ENDIF)))  						continue;    				if (se.isData)  				{  					stack.Push(se.data);  					continue;  				}    				switch (se.opCode)  				{  					case OpCode.OP_RESERVED:  						{  							return false;  						}  					case OpCode.OP_NOP:  						{  							// NOP' Dump stack for debug  							/*  							stack.ToList().ForEach(x => Console.WriteLine(HexString.FromByteArray(x)));  							Console.WriteLine("---------------------------");  							*/  							break;  						}  					case OpCode.OP_VER:  						{  							return false;  						}  					case OpCode.OP_IF:  					case OpCode.OP_NOTIF:  						{  							if (stack.Count < 1)  								return false;  							Boolean stackIsZero = new ScriptVarInt(stack.Pop()).value.IsZero;  							if ((se.opCode == OpCode.OP_IF && !stackIsZero) || (se.opCode == OpCode.OP_NOTIF && stackIsZero))  							{  								// Run to else or endif  								ifExec.Push(IfElseExec.RUN_IF);  							}  							else  							{  								// Skip to else or endif  								ifExec.Push(IfElseExec.SKIP_IF);  							}  							break;  						}  					case OpCode.OP_VERIF:  					case OpCode.OP_VERNOTIF:  						{  							return false;  						}  					case OpCode.OP_ELSE:  						{  							if (ifExec.Count == 0)  								// No preceding if statement!  								return false;  							if (ifExec.First() == IfElseExec.RUN_IF)  							{  								// If ran' skip else  								ifExec.Push(IfElseExec.SKIP_ELSE);  							}  							else if (ifExec.First() == IfElseExec.SKIP_IF)  							{  								// If did not run' run else  								ifExec.Push(IfElseExec.RUN_ELSE);  							}  							break;  						}  					case OpCode.OP_ENDIF:  						{  							if (ifExec.Count == 0)  								// No preceding if statement!  								return false;  							if (ifExec.First() == IfElseExec.RUN_IF ||  								ifExec.First() == IfElseExec.SKIP_IF)  							{  								ifExec.Pop();  							}  							else if (ifExec.First() == IfElseExec.RUN_ELSE ||  							   ifExec.First() == IfElseExec.SKIP_ELSE)  							{  								ifExec.Pop();  								ifExec.Pop();  							}  							break;  						}  					case OpCode.OP_VERIFY:  						{  							if (stack.Count < 1 || new ScriptVarInt(stack.First()).value.IsZero)  								return false;  							stack.Pop();  							break;  						}  					case OpCode.OP_RETURN:  						{  							return false;  						}  					case OpCode.OP_TOALTSTACK:  						{  							if (stack.Count < 1)  								return false;  							altstack.Push(stack.Pop());  							break;  						}  					case OpCode.OP_FROMALTSTACK:  						{  							if (altstack.Count < 1)  								return false;  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_2DROP:  						{  							if (stack.Count < 2)  								return false;  							stack.Pop();  							stack.Pop();  							break;  						}  					case OpCode.OP_2DUP:  						{  							if (stack.Count < 2)  								return false;  							stack.Push(stack.Skip(1).First());  							stack.Push(stack.Skip(1).First());  							break;  						}  					case OpCode.OP_3DUP:  						{  							if (stack.Count < 3)  								return false;  							stack.Push(stack.Skip(2).First());  							stack.Push(stack.Skip(2).First());  							stack.Push(stack.Skip(2).First());  							break;  						}  					case OpCode.OP_2OVER:  						{  							if (stack.Count < 4)  								return false;  							stack.Push(stack.Skip(3).First());  							stack.Push(stack.Skip(3).First());  							break;  						}  					case OpCode.OP_2ROT:  						{  							if (stack.Count < 6)  								return false;  							altstack.Push(stack.Skip(4).First());  							altstack.Push(stack.Skip(5).First());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_2SWAP:  						{  							if (stack.Count < 4)  								return false;  							altstack.Push(stack.Skip(2).First());  							altstack.Push(stack.Skip(3).First());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_IFDUP:  						{  							if (stack.Count < 1)  								return false;  							if (!new ScriptVarInt(stack.First()).value.IsZero)  								stack.Push(stack.First());  							break;  						}  					case OpCode.OP_DEPTH:  						{  							stack.Push(new ScriptVarInt((UInt64)stack.Count).ToBytes());  							break;  						}  					case OpCode.OP_DROP:  						{  							if (stack.Count < 1)  								return false;  							stack.Pop();  							break;  						}  					case OpCode.OP_DUP:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(stack.First());  							break;  						}  					case OpCode.OP_NIP:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_OVER:  						{  							if (stack.Count < 2)  								return false;  							stack.Push(stack.Skip(1).First());  							break;  						}  					case OpCode.OP_PICK:  						{  							if (stack.Count < 2)  								return false;  							int pick = new ScriptVarInt(stack.Pop()).intValue;  							if (pick < 0 || stack.Count <= pick)  								return false;  							stack.Push(stack.Skip(pick).First());  							break;  						}  					case OpCode.OP_ROLL:  						{  							if (stack.Count < 2)  								return false;  							int roll = new ScriptVarInt(stack.Pop()).intValue;  							if (roll < 0 || stack.Count <= roll)  								return false;  							altstack.Push(stack.Skip(roll).First());  							for (int i = 0; i < roll; i++)  								altstack.Push(stack.Pop());  							stack.Pop();  							for (int i = 0; i < roll + 1; i++)  								stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_ROT:  						{  							if (stack.Count < 3)  								return false;  							altstack.Push(stack.Skip(2).First());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_SWAP:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Skip(1).First());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_TUCK:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Push(altstack.Skip(1).First());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_CAT:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Skip(1).First().Concat(stack.First()).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_SUBSTR:  						{  							if (stack.Count < 3)  								return false;  							altstack.Push(stack.Skip(2).First()  								.Skip(new ScriptVarInt(stack.Skip(1).First()).intValue)  								.Take(new ScriptVarInt(stack.First()).intValue).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_LEFT:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Skip(1).First()  								.Take(new ScriptVarInt(stack.First()).intValue).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_RIGHT:  						{  							if (stack.Count < 2)  								return false;  							int count = new ScriptVarInt(stack.First()).intValue;  							altstack.Push(stack.Skip(1).First()  								.Skip(stack.Skip(1).First().Length - count).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_SIZE:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(new ScriptVarInt((UInt64)stack.First().Length).ToBytes());  							break;  						}  					case OpCode.OP_INVERT:  						{  							if (stack.Count < 1)  								return false;  							Byte[] data = stack.Pop();  							for (int i = 0; i < data.Length; i++)  								data[i] ^= 0xFF;  							stack.Push(data);  							break;  						}  					case OpCode.OP_AND:  					case OpCode.OP_OR:  					case OpCode.OP_XOR:  						{  							if (stack.Count < 2)  								return false;  							Byte[] data = stack.Pop();  							Byte[] data2 = stack.Pop();  							int length = new int[] { data.Length' data2.Length }.Max();  							data = data.Concat(new Byte[length - data.Length]).ToArray();  							data2 = data2.Concat(new Byte[length - data2.Length]).ToArray();  							switch (se.opCode)  							{  								case OpCode.OP_AND:  									{  										for (int i = 0; i < length; i++)  											data[i] &= data2[i];  										break;  									}  								case OpCode.OP_OR:  									{  										for (int i = 0; i < length; i++)  											data[i] |= data2[i];  										break;  									}  								case OpCode.OP_XOR:  									{  										for (int i = 0; i < length; i++)  											data[i] ^= data2[i];  										break;  									}  							}  							stack.Push(data);  							break;  						}  					case OpCode.OP_EQUAL:  					case OpCode.OP_EQUALVERIFY:  						{  							if (stack.Count < 2)  								return false;  							if (stack.Pop().SequenceEqual(stack.Pop()))  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });    							if (se.opCode == OpCode.OP_EQUALVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_RESERVED1:  					case OpCode.OP_RESERVED2:  						{  							return false;  						}  					case OpCode.OP_1ADD:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Add(new ScriptVarInt(stack.Pop())' 1)).ToBytes());  							break;  						}  					case OpCode.OP_1SUB:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Subtract(new ScriptVarInt(stack.Pop())' 1)).ToBytes());  							break;  						}  					case OpCode.OP_2MUL:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Multiply(new ScriptVarInt(stack.Pop())' 2)).ToBytes());  							break;  						}  					case OpCode.OP_2DIV:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Divide(new ScriptVarInt(stack.Pop())' 2)).ToBytes());  							break;  						}  					case OpCode.OP_NEGATE:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Negate(new ScriptVarInt(stack.Pop()))).ToBytes());  							break;  						}  					case OpCode.OP_ABS:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Abs(new ScriptVarInt(stack.Pop()))).ToBytes());  							break;  						}  					case OpCode.OP_NOT:  						{  							if (stack.Count < 1)  								return false;  							if (new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_0NOTEQUAL:  						{  							if (stack.Count < 1)  								return false;  							if (new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x00 });  							else  								stack.Push(new Byte[] { 0x01 });  							break;  						}  					case OpCode.OP_ADD:  					case OpCode.OP_SUB:  					case OpCode.OP_MUL:  					case OpCode.OP_DIV:  					case OpCode.OP_MOD:  					case OpCode.OP_LSHIFT:  					case OpCode.OP_RSHIFT:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							switch (se.opCode)  							{  								case OpCode.OP_ADD:  									a = (BigInteger)a + b;  									break;  								case OpCode.OP_SUB:  									a = (BigInteger)a - b;  									break;  								case OpCode.OP_MUL:  									a = (BigInteger)a * b;  									break;  								case OpCode.OP_DIV:  									a = (BigInteger)a / b;  									break;  								case OpCode.OP_MOD:  									a = (BigInteger)a % b;  									break;  								case OpCode.OP_LSHIFT:  									a = (BigInteger)a << b.intValue;  									break;  								case OpCode.OP_RSHIFT:  									a = (BigInteger)a >> b.intValue;  									break;  							}  							stack.Push(a.ToBytes());  							break;  						}  					case OpCode.OP_BOOLAND:  						{  							if (stack.Count < 2)  								return false;  							if (!new ScriptVarInt(stack.Pop()).value.IsZero && !new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_BOOLOR:  						{  							if (stack.Count < 2)  								return false;  							if (!new ScriptVarInt(stack.Pop()).value.IsZero || !new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_NUMEQUAL:  					case OpCode.OP_NUMEQUALVERIFY:  						{  							if (stack.Count < 2)  								return false;  							if (new ScriptVarInt(stack.Pop()).value == new ScriptVarInt(stack.Pop()).value)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							if (se.opCode == OpCode.OP_NUMEQUALVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_NUMNOTEQUAL:  						{  							if (stack.Count < 2)  								return false;  							if (new ScriptVarInt(stack.Pop()).value != new ScriptVarInt(stack.Pop()).value)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_LESSTHAN:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a < b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_GREATERTHAN:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a > b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_LESSTHANOREQUAL:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a <= b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_GREATERTHANOREQUAL:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a >= b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_MIN:  						{  							if (stack.Count < 2)  								return false;  							Byte[] b = stack.Pop();  							Byte[] a = stack.Pop();  							if (new ScriptVarInt(a).value < new ScriptVarInt(b).value)  								stack.Push(a);  							else  								stack.Push(b);  							break;  						}  					case OpCode.OP_MAX:  						{  							if (stack.Count < 2)  								return false;  							Byte[] b = stack.Pop();  							Byte[] a = stack.Pop();  							if (new ScriptVarInt(a).value > new ScriptVarInt(b).value)  								stack.Push(a);  							else  								stack.Push(b);  							break;  						}  					case OpCode.OP_WITHIN:  						{  							if (stack.Count < 3)  								return false;  							ScriptVarInt max = new ScriptVarInt(stack.Pop());  							ScriptVarInt min = new ScriptVarInt(stack.Pop());  							ScriptVarInt x = new ScriptVarInt(stack.Pop());  							if ((BigInteger)min <= x && (BigInteger)x <= max)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_RIPEMD160:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(ripemd160.ComputeHash(stack.Pop()));  							break;  						}  					case OpCode.OP_SHA1:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(sha1.ComputeHash(stack.Pop()));  							break;  						}  					case OpCode.OP_SHA256:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(sha256.ComputeHash(stack.Pop()));  							break;  						}  					case OpCode.OP_HASH160:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(ripemd160.ComputeHash(sha256.ComputeHash(stack.Pop())));  							break;  						}  					case OpCode.OP_HASH256:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(sha256.ComputeHash(sha256.ComputeHash(stack.Pop())));  							break;  						}  					case OpCode.OP_CODESEPARATOR:  						{  							lastCodeSeperator = index;  							break;  						}  					case OpCode.OP_CHECKSIG:  					case OpCode.OP_CHECKSIGVERIFY:  						{  							if (tx == null)  								throw new ArgumentNullException("Transaction is required if script contains OP_CHECKSIG[VERIFY]");  							if (stack.Count < 2)  								return false;    							PublicKey pubKey = new PublicKey(stack.Pop());  							Byte[] sig = stack.Pop();    							Script subScript = new Script(elements.Skip(lastCodeSeperator)  								.Where(x => x.opCode != OpCode.OP_CODESEPARATOR).ToArray());    							stack.Push(new ScriptVarInt(CheckSig(sig' pubKey' txInIndex' subScript' tx) ? 1 : 0).ToBytes());    							if (se.opCode == OpCode.OP_CHECKSIGVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_CHECKMULTISIG:  					case OpCode.OP_CHECKMULTISIGVERIFY:  						{  							if (tx == null)  								throw new ArgumentNullException("Transaction is required if script contains OP_CHECKMULTISIG[VERIFY]");  							if (stack.Count < 2)  								return false;    							PublicKey[] pubKeys = new PublicKey[new ScriptVarInt(stack.Pop()).intValue];    							if (stack.Count < pubKeys.Length + 1)  								return false;    							for (int i = 0; i < pubKeys.Length; i++)  							{  								pubKeys[i] = new PublicKey(stack.Pop());  							}    							Byte[][] sigs = new Byte[new ScriptVarInt(stack.Pop()).intValue][];    							if (stack.Count < sigs.Length)  								return false;    							for (int i = 0; i < sigs.Length; i++)  							{  								sigs[i] = stack.Pop();  							}    							// Remove extra unused value from stack  							stack.Pop();    							Script subScript = new Script(elements.Skip(lastCodeSeperator)  								.Where(x => x.opCode != OpCode.OP_CODESEPARATOR).ToArray());    							int validSigs = 0;  							foreach (Byte[] sig in sigs)  							{  								foreach (PublicKey pubKey in pubKeys)  								{  									if (CheckSig(sig' pubKey' txInIndex' subScript' tx))  									{  										pubKeys = pubKeys.Where(x => x != pubKey).ToArray();  										validSigs++;  										break;  									}  								}  							}    							stack.Push(new ScriptVarInt((validSigs >= sigs.Length) ? 1 : 0).ToBytes());    							if (se.opCode == OpCode.OP_CHECKMULTISIGVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_NOP1:  					case OpCode.OP_NOP2:  					case OpCode.OP_NOP3:  					case OpCode.OP_NOP4:  					case OpCode.OP_NOP5:  					case OpCode.OP_NOP6:  					case OpCode.OP_NOP7:  					case OpCode.OP_NOP8:  					case OpCode.OP_NOP9:  					case OpCode.OP_NOP10:  						{  							break;  						}  					case OpCode.OP_SMALLINTEGER:  					case OpCode.OP_PUBKEYS:  					case OpCode.OP_PUBKEYHASH:  					case OpCode.OP_PUBKEY:  					case OpCode.OP_INVALIDOPCODE:  					default:  						{  							return false;  						}    				}  			}
Magic Number,Bitcoin_Tool.Scripts,Script,C:\repos\mb300sd_Bitcoin-Tool\Bitcoin Tool\Scripts\Script.cs,Evaluate,The following statement contains a magic number: for (int index = 0; index < elements.Count; index++)  			{  				ScriptElement se = elements[index];  				if (ifExec.Count > 0)  					if ((ifExec.First() == IfElseExec.SKIP_IF && !(se.opCode == OpCode.OP_ELSE || se.opCode == OpCode.OP_ENDIF)) ||  						(ifExec.First() == IfElseExec.SKIP_ELSE && !(se.opCode == OpCode.OP_ENDIF)))  						continue;    				if (se.isData)  				{  					stack.Push(se.data);  					continue;  				}    				switch (se.opCode)  				{  					case OpCode.OP_RESERVED:  						{  							return false;  						}  					case OpCode.OP_NOP:  						{  							// NOP' Dump stack for debug  							/*  							stack.ToList().ForEach(x => Console.WriteLine(HexString.FromByteArray(x)));  							Console.WriteLine("---------------------------");  							*/  							break;  						}  					case OpCode.OP_VER:  						{  							return false;  						}  					case OpCode.OP_IF:  					case OpCode.OP_NOTIF:  						{  							if (stack.Count < 1)  								return false;  							Boolean stackIsZero = new ScriptVarInt(stack.Pop()).value.IsZero;  							if ((se.opCode == OpCode.OP_IF && !stackIsZero) || (se.opCode == OpCode.OP_NOTIF && stackIsZero))  							{  								// Run to else or endif  								ifExec.Push(IfElseExec.RUN_IF);  							}  							else  							{  								// Skip to else or endif  								ifExec.Push(IfElseExec.SKIP_IF);  							}  							break;  						}  					case OpCode.OP_VERIF:  					case OpCode.OP_VERNOTIF:  						{  							return false;  						}  					case OpCode.OP_ELSE:  						{  							if (ifExec.Count == 0)  								// No preceding if statement!  								return false;  							if (ifExec.First() == IfElseExec.RUN_IF)  							{  								// If ran' skip else  								ifExec.Push(IfElseExec.SKIP_ELSE);  							}  							else if (ifExec.First() == IfElseExec.SKIP_IF)  							{  								// If did not run' run else  								ifExec.Push(IfElseExec.RUN_ELSE);  							}  							break;  						}  					case OpCode.OP_ENDIF:  						{  							if (ifExec.Count == 0)  								// No preceding if statement!  								return false;  							if (ifExec.First() == IfElseExec.RUN_IF ||  								ifExec.First() == IfElseExec.SKIP_IF)  							{  								ifExec.Pop();  							}  							else if (ifExec.First() == IfElseExec.RUN_ELSE ||  							   ifExec.First() == IfElseExec.SKIP_ELSE)  							{  								ifExec.Pop();  								ifExec.Pop();  							}  							break;  						}  					case OpCode.OP_VERIFY:  						{  							if (stack.Count < 1 || new ScriptVarInt(stack.First()).value.IsZero)  								return false;  							stack.Pop();  							break;  						}  					case OpCode.OP_RETURN:  						{  							return false;  						}  					case OpCode.OP_TOALTSTACK:  						{  							if (stack.Count < 1)  								return false;  							altstack.Push(stack.Pop());  							break;  						}  					case OpCode.OP_FROMALTSTACK:  						{  							if (altstack.Count < 1)  								return false;  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_2DROP:  						{  							if (stack.Count < 2)  								return false;  							stack.Pop();  							stack.Pop();  							break;  						}  					case OpCode.OP_2DUP:  						{  							if (stack.Count < 2)  								return false;  							stack.Push(stack.Skip(1).First());  							stack.Push(stack.Skip(1).First());  							break;  						}  					case OpCode.OP_3DUP:  						{  							if (stack.Count < 3)  								return false;  							stack.Push(stack.Skip(2).First());  							stack.Push(stack.Skip(2).First());  							stack.Push(stack.Skip(2).First());  							break;  						}  					case OpCode.OP_2OVER:  						{  							if (stack.Count < 4)  								return false;  							stack.Push(stack.Skip(3).First());  							stack.Push(stack.Skip(3).First());  							break;  						}  					case OpCode.OP_2ROT:  						{  							if (stack.Count < 6)  								return false;  							altstack.Push(stack.Skip(4).First());  							altstack.Push(stack.Skip(5).First());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_2SWAP:  						{  							if (stack.Count < 4)  								return false;  							altstack.Push(stack.Skip(2).First());  							altstack.Push(stack.Skip(3).First());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_IFDUP:  						{  							if (stack.Count < 1)  								return false;  							if (!new ScriptVarInt(stack.First()).value.IsZero)  								stack.Push(stack.First());  							break;  						}  					case OpCode.OP_DEPTH:  						{  							stack.Push(new ScriptVarInt((UInt64)stack.Count).ToBytes());  							break;  						}  					case OpCode.OP_DROP:  						{  							if (stack.Count < 1)  								return false;  							stack.Pop();  							break;  						}  					case OpCode.OP_DUP:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(stack.First());  							break;  						}  					case OpCode.OP_NIP:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_OVER:  						{  							if (stack.Count < 2)  								return false;  							stack.Push(stack.Skip(1).First());  							break;  						}  					case OpCode.OP_PICK:  						{  							if (stack.Count < 2)  								return false;  							int pick = new ScriptVarInt(stack.Pop()).intValue;  							if (pick < 0 || stack.Count <= pick)  								return false;  							stack.Push(stack.Skip(pick).First());  							break;  						}  					case OpCode.OP_ROLL:  						{  							if (stack.Count < 2)  								return false;  							int roll = new ScriptVarInt(stack.Pop()).intValue;  							if (roll < 0 || stack.Count <= roll)  								return false;  							altstack.Push(stack.Skip(roll).First());  							for (int i = 0; i < roll; i++)  								altstack.Push(stack.Pop());  							stack.Pop();  							for (int i = 0; i < roll + 1; i++)  								stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_ROT:  						{  							if (stack.Count < 3)  								return false;  							altstack.Push(stack.Skip(2).First());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_SWAP:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Skip(1).First());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_TUCK:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Push(altstack.Skip(1).First());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_CAT:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Skip(1).First().Concat(stack.First()).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_SUBSTR:  						{  							if (stack.Count < 3)  								return false;  							altstack.Push(stack.Skip(2).First()  								.Skip(new ScriptVarInt(stack.Skip(1).First()).intValue)  								.Take(new ScriptVarInt(stack.First()).intValue).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_LEFT:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Skip(1).First()  								.Take(new ScriptVarInt(stack.First()).intValue).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_RIGHT:  						{  							if (stack.Count < 2)  								return false;  							int count = new ScriptVarInt(stack.First()).intValue;  							altstack.Push(stack.Skip(1).First()  								.Skip(stack.Skip(1).First().Length - count).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_SIZE:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(new ScriptVarInt((UInt64)stack.First().Length).ToBytes());  							break;  						}  					case OpCode.OP_INVERT:  						{  							if (stack.Count < 1)  								return false;  							Byte[] data = stack.Pop();  							for (int i = 0; i < data.Length; i++)  								data[i] ^= 0xFF;  							stack.Push(data);  							break;  						}  					case OpCode.OP_AND:  					case OpCode.OP_OR:  					case OpCode.OP_XOR:  						{  							if (stack.Count < 2)  								return false;  							Byte[] data = stack.Pop();  							Byte[] data2 = stack.Pop();  							int length = new int[] { data.Length' data2.Length }.Max();  							data = data.Concat(new Byte[length - data.Length]).ToArray();  							data2 = data2.Concat(new Byte[length - data2.Length]).ToArray();  							switch (se.opCode)  							{  								case OpCode.OP_AND:  									{  										for (int i = 0; i < length; i++)  											data[i] &= data2[i];  										break;  									}  								case OpCode.OP_OR:  									{  										for (int i = 0; i < length; i++)  											data[i] |= data2[i];  										break;  									}  								case OpCode.OP_XOR:  									{  										for (int i = 0; i < length; i++)  											data[i] ^= data2[i];  										break;  									}  							}  							stack.Push(data);  							break;  						}  					case OpCode.OP_EQUAL:  					case OpCode.OP_EQUALVERIFY:  						{  							if (stack.Count < 2)  								return false;  							if (stack.Pop().SequenceEqual(stack.Pop()))  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });    							if (se.opCode == OpCode.OP_EQUALVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_RESERVED1:  					case OpCode.OP_RESERVED2:  						{  							return false;  						}  					case OpCode.OP_1ADD:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Add(new ScriptVarInt(stack.Pop())' 1)).ToBytes());  							break;  						}  					case OpCode.OP_1SUB:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Subtract(new ScriptVarInt(stack.Pop())' 1)).ToBytes());  							break;  						}  					case OpCode.OP_2MUL:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Multiply(new ScriptVarInt(stack.Pop())' 2)).ToBytes());  							break;  						}  					case OpCode.OP_2DIV:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Divide(new ScriptVarInt(stack.Pop())' 2)).ToBytes());  							break;  						}  					case OpCode.OP_NEGATE:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Negate(new ScriptVarInt(stack.Pop()))).ToBytes());  							break;  						}  					case OpCode.OP_ABS:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Abs(new ScriptVarInt(stack.Pop()))).ToBytes());  							break;  						}  					case OpCode.OP_NOT:  						{  							if (stack.Count < 1)  								return false;  							if (new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_0NOTEQUAL:  						{  							if (stack.Count < 1)  								return false;  							if (new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x00 });  							else  								stack.Push(new Byte[] { 0x01 });  							break;  						}  					case OpCode.OP_ADD:  					case OpCode.OP_SUB:  					case OpCode.OP_MUL:  					case OpCode.OP_DIV:  					case OpCode.OP_MOD:  					case OpCode.OP_LSHIFT:  					case OpCode.OP_RSHIFT:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							switch (se.opCode)  							{  								case OpCode.OP_ADD:  									a = (BigInteger)a + b;  									break;  								case OpCode.OP_SUB:  									a = (BigInteger)a - b;  									break;  								case OpCode.OP_MUL:  									a = (BigInteger)a * b;  									break;  								case OpCode.OP_DIV:  									a = (BigInteger)a / b;  									break;  								case OpCode.OP_MOD:  									a = (BigInteger)a % b;  									break;  								case OpCode.OP_LSHIFT:  									a = (BigInteger)a << b.intValue;  									break;  								case OpCode.OP_RSHIFT:  									a = (BigInteger)a >> b.intValue;  									break;  							}  							stack.Push(a.ToBytes());  							break;  						}  					case OpCode.OP_BOOLAND:  						{  							if (stack.Count < 2)  								return false;  							if (!new ScriptVarInt(stack.Pop()).value.IsZero && !new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_BOOLOR:  						{  							if (stack.Count < 2)  								return false;  							if (!new ScriptVarInt(stack.Pop()).value.IsZero || !new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_NUMEQUAL:  					case OpCode.OP_NUMEQUALVERIFY:  						{  							if (stack.Count < 2)  								return false;  							if (new ScriptVarInt(stack.Pop()).value == new ScriptVarInt(stack.Pop()).value)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							if (se.opCode == OpCode.OP_NUMEQUALVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_NUMNOTEQUAL:  						{  							if (stack.Count < 2)  								return false;  							if (new ScriptVarInt(stack.Pop()).value != new ScriptVarInt(stack.Pop()).value)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_LESSTHAN:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a < b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_GREATERTHAN:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a > b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_LESSTHANOREQUAL:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a <= b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_GREATERTHANOREQUAL:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a >= b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_MIN:  						{  							if (stack.Count < 2)  								return false;  							Byte[] b = stack.Pop();  							Byte[] a = stack.Pop();  							if (new ScriptVarInt(a).value < new ScriptVarInt(b).value)  								stack.Push(a);  							else  								stack.Push(b);  							break;  						}  					case OpCode.OP_MAX:  						{  							if (stack.Count < 2)  								return false;  							Byte[] b = stack.Pop();  							Byte[] a = stack.Pop();  							if (new ScriptVarInt(a).value > new ScriptVarInt(b).value)  								stack.Push(a);  							else  								stack.Push(b);  							break;  						}  					case OpCode.OP_WITHIN:  						{  							if (stack.Count < 3)  								return false;  							ScriptVarInt max = new ScriptVarInt(stack.Pop());  							ScriptVarInt min = new ScriptVarInt(stack.Pop());  							ScriptVarInt x = new ScriptVarInt(stack.Pop());  							if ((BigInteger)min <= x && (BigInteger)x <= max)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_RIPEMD160:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(ripemd160.ComputeHash(stack.Pop()));  							break;  						}  					case OpCode.OP_SHA1:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(sha1.ComputeHash(stack.Pop()));  							break;  						}  					case OpCode.OP_SHA256:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(sha256.ComputeHash(stack.Pop()));  							break;  						}  					case OpCode.OP_HASH160:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(ripemd160.ComputeHash(sha256.ComputeHash(stack.Pop())));  							break;  						}  					case OpCode.OP_HASH256:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(sha256.ComputeHash(sha256.ComputeHash(stack.Pop())));  							break;  						}  					case OpCode.OP_CODESEPARATOR:  						{  							lastCodeSeperator = index;  							break;  						}  					case OpCode.OP_CHECKSIG:  					case OpCode.OP_CHECKSIGVERIFY:  						{  							if (tx == null)  								throw new ArgumentNullException("Transaction is required if script contains OP_CHECKSIG[VERIFY]");  							if (stack.Count < 2)  								return false;    							PublicKey pubKey = new PublicKey(stack.Pop());  							Byte[] sig = stack.Pop();    							Script subScript = new Script(elements.Skip(lastCodeSeperator)  								.Where(x => x.opCode != OpCode.OP_CODESEPARATOR).ToArray());    							stack.Push(new ScriptVarInt(CheckSig(sig' pubKey' txInIndex' subScript' tx) ? 1 : 0).ToBytes());    							if (se.opCode == OpCode.OP_CHECKSIGVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_CHECKMULTISIG:  					case OpCode.OP_CHECKMULTISIGVERIFY:  						{  							if (tx == null)  								throw new ArgumentNullException("Transaction is required if script contains OP_CHECKMULTISIG[VERIFY]");  							if (stack.Count < 2)  								return false;    							PublicKey[] pubKeys = new PublicKey[new ScriptVarInt(stack.Pop()).intValue];    							if (stack.Count < pubKeys.Length + 1)  								return false;    							for (int i = 0; i < pubKeys.Length; i++)  							{  								pubKeys[i] = new PublicKey(stack.Pop());  							}    							Byte[][] sigs = new Byte[new ScriptVarInt(stack.Pop()).intValue][];    							if (stack.Count < sigs.Length)  								return false;    							for (int i = 0; i < sigs.Length; i++)  							{  								sigs[i] = stack.Pop();  							}    							// Remove extra unused value from stack  							stack.Pop();    							Script subScript = new Script(elements.Skip(lastCodeSeperator)  								.Where(x => x.opCode != OpCode.OP_CODESEPARATOR).ToArray());    							int validSigs = 0;  							foreach (Byte[] sig in sigs)  							{  								foreach (PublicKey pubKey in pubKeys)  								{  									if (CheckSig(sig' pubKey' txInIndex' subScript' tx))  									{  										pubKeys = pubKeys.Where(x => x != pubKey).ToArray();  										validSigs++;  										break;  									}  								}  							}    							stack.Push(new ScriptVarInt((validSigs >= sigs.Length) ? 1 : 0).ToBytes());    							if (se.opCode == OpCode.OP_CHECKMULTISIGVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_NOP1:  					case OpCode.OP_NOP2:  					case OpCode.OP_NOP3:  					case OpCode.OP_NOP4:  					case OpCode.OP_NOP5:  					case OpCode.OP_NOP6:  					case OpCode.OP_NOP7:  					case OpCode.OP_NOP8:  					case OpCode.OP_NOP9:  					case OpCode.OP_NOP10:  						{  							break;  						}  					case OpCode.OP_SMALLINTEGER:  					case OpCode.OP_PUBKEYS:  					case OpCode.OP_PUBKEYHASH:  					case OpCode.OP_PUBKEY:  					case OpCode.OP_INVALIDOPCODE:  					default:  						{  							return false;  						}    				}  			}
Magic Number,Bitcoin_Tool.Scripts,Script,C:\repos\mb300sd_Bitcoin-Tool\Bitcoin Tool\Scripts\Script.cs,Evaluate,The following statement contains a magic number: for (int index = 0; index < elements.Count; index++)  			{  				ScriptElement se = elements[index];  				if (ifExec.Count > 0)  					if ((ifExec.First() == IfElseExec.SKIP_IF && !(se.opCode == OpCode.OP_ELSE || se.opCode == OpCode.OP_ENDIF)) ||  						(ifExec.First() == IfElseExec.SKIP_ELSE && !(se.opCode == OpCode.OP_ENDIF)))  						continue;    				if (se.isData)  				{  					stack.Push(se.data);  					continue;  				}    				switch (se.opCode)  				{  					case OpCode.OP_RESERVED:  						{  							return false;  						}  					case OpCode.OP_NOP:  						{  							// NOP' Dump stack for debug  							/*  							stack.ToList().ForEach(x => Console.WriteLine(HexString.FromByteArray(x)));  							Console.WriteLine("---------------------------");  							*/  							break;  						}  					case OpCode.OP_VER:  						{  							return false;  						}  					case OpCode.OP_IF:  					case OpCode.OP_NOTIF:  						{  							if (stack.Count < 1)  								return false;  							Boolean stackIsZero = new ScriptVarInt(stack.Pop()).value.IsZero;  							if ((se.opCode == OpCode.OP_IF && !stackIsZero) || (se.opCode == OpCode.OP_NOTIF && stackIsZero))  							{  								// Run to else or endif  								ifExec.Push(IfElseExec.RUN_IF);  							}  							else  							{  								// Skip to else or endif  								ifExec.Push(IfElseExec.SKIP_IF);  							}  							break;  						}  					case OpCode.OP_VERIF:  					case OpCode.OP_VERNOTIF:  						{  							return false;  						}  					case OpCode.OP_ELSE:  						{  							if (ifExec.Count == 0)  								// No preceding if statement!  								return false;  							if (ifExec.First() == IfElseExec.RUN_IF)  							{  								// If ran' skip else  								ifExec.Push(IfElseExec.SKIP_ELSE);  							}  							else if (ifExec.First() == IfElseExec.SKIP_IF)  							{  								// If did not run' run else  								ifExec.Push(IfElseExec.RUN_ELSE);  							}  							break;  						}  					case OpCode.OP_ENDIF:  						{  							if (ifExec.Count == 0)  								// No preceding if statement!  								return false;  							if (ifExec.First() == IfElseExec.RUN_IF ||  								ifExec.First() == IfElseExec.SKIP_IF)  							{  								ifExec.Pop();  							}  							else if (ifExec.First() == IfElseExec.RUN_ELSE ||  							   ifExec.First() == IfElseExec.SKIP_ELSE)  							{  								ifExec.Pop();  								ifExec.Pop();  							}  							break;  						}  					case OpCode.OP_VERIFY:  						{  							if (stack.Count < 1 || new ScriptVarInt(stack.First()).value.IsZero)  								return false;  							stack.Pop();  							break;  						}  					case OpCode.OP_RETURN:  						{  							return false;  						}  					case OpCode.OP_TOALTSTACK:  						{  							if (stack.Count < 1)  								return false;  							altstack.Push(stack.Pop());  							break;  						}  					case OpCode.OP_FROMALTSTACK:  						{  							if (altstack.Count < 1)  								return false;  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_2DROP:  						{  							if (stack.Count < 2)  								return false;  							stack.Pop();  							stack.Pop();  							break;  						}  					case OpCode.OP_2DUP:  						{  							if (stack.Count < 2)  								return false;  							stack.Push(stack.Skip(1).First());  							stack.Push(stack.Skip(1).First());  							break;  						}  					case OpCode.OP_3DUP:  						{  							if (stack.Count < 3)  								return false;  							stack.Push(stack.Skip(2).First());  							stack.Push(stack.Skip(2).First());  							stack.Push(stack.Skip(2).First());  							break;  						}  					case OpCode.OP_2OVER:  						{  							if (stack.Count < 4)  								return false;  							stack.Push(stack.Skip(3).First());  							stack.Push(stack.Skip(3).First());  							break;  						}  					case OpCode.OP_2ROT:  						{  							if (stack.Count < 6)  								return false;  							altstack.Push(stack.Skip(4).First());  							altstack.Push(stack.Skip(5).First());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_2SWAP:  						{  							if (stack.Count < 4)  								return false;  							altstack.Push(stack.Skip(2).First());  							altstack.Push(stack.Skip(3).First());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_IFDUP:  						{  							if (stack.Count < 1)  								return false;  							if (!new ScriptVarInt(stack.First()).value.IsZero)  								stack.Push(stack.First());  							break;  						}  					case OpCode.OP_DEPTH:  						{  							stack.Push(new ScriptVarInt((UInt64)stack.Count).ToBytes());  							break;  						}  					case OpCode.OP_DROP:  						{  							if (stack.Count < 1)  								return false;  							stack.Pop();  							break;  						}  					case OpCode.OP_DUP:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(stack.First());  							break;  						}  					case OpCode.OP_NIP:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_OVER:  						{  							if (stack.Count < 2)  								return false;  							stack.Push(stack.Skip(1).First());  							break;  						}  					case OpCode.OP_PICK:  						{  							if (stack.Count < 2)  								return false;  							int pick = new ScriptVarInt(stack.Pop()).intValue;  							if (pick < 0 || stack.Count <= pick)  								return false;  							stack.Push(stack.Skip(pick).First());  							break;  						}  					case OpCode.OP_ROLL:  						{  							if (stack.Count < 2)  								return false;  							int roll = new ScriptVarInt(stack.Pop()).intValue;  							if (roll < 0 || stack.Count <= roll)  								return false;  							altstack.Push(stack.Skip(roll).First());  							for (int i = 0; i < roll; i++)  								altstack.Push(stack.Pop());  							stack.Pop();  							for (int i = 0; i < roll + 1; i++)  								stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_ROT:  						{  							if (stack.Count < 3)  								return false;  							altstack.Push(stack.Skip(2).First());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_SWAP:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Skip(1).First());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_TUCK:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Push(altstack.Skip(1).First());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_CAT:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Skip(1).First().Concat(stack.First()).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_SUBSTR:  						{  							if (stack.Count < 3)  								return false;  							altstack.Push(stack.Skip(2).First()  								.Skip(new ScriptVarInt(stack.Skip(1).First()).intValue)  								.Take(new ScriptVarInt(stack.First()).intValue).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_LEFT:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Skip(1).First()  								.Take(new ScriptVarInt(stack.First()).intValue).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_RIGHT:  						{  							if (stack.Count < 2)  								return false;  							int count = new ScriptVarInt(stack.First()).intValue;  							altstack.Push(stack.Skip(1).First()  								.Skip(stack.Skip(1).First().Length - count).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_SIZE:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(new ScriptVarInt((UInt64)stack.First().Length).ToBytes());  							break;  						}  					case OpCode.OP_INVERT:  						{  							if (stack.Count < 1)  								return false;  							Byte[] data = stack.Pop();  							for (int i = 0; i < data.Length; i++)  								data[i] ^= 0xFF;  							stack.Push(data);  							break;  						}  					case OpCode.OP_AND:  					case OpCode.OP_OR:  					case OpCode.OP_XOR:  						{  							if (stack.Count < 2)  								return false;  							Byte[] data = stack.Pop();  							Byte[] data2 = stack.Pop();  							int length = new int[] { data.Length' data2.Length }.Max();  							data = data.Concat(new Byte[length - data.Length]).ToArray();  							data2 = data2.Concat(new Byte[length - data2.Length]).ToArray();  							switch (se.opCode)  							{  								case OpCode.OP_AND:  									{  										for (int i = 0; i < length; i++)  											data[i] &= data2[i];  										break;  									}  								case OpCode.OP_OR:  									{  										for (int i = 0; i < length; i++)  											data[i] |= data2[i];  										break;  									}  								case OpCode.OP_XOR:  									{  										for (int i = 0; i < length; i++)  											data[i] ^= data2[i];  										break;  									}  							}  							stack.Push(data);  							break;  						}  					case OpCode.OP_EQUAL:  					case OpCode.OP_EQUALVERIFY:  						{  							if (stack.Count < 2)  								return false;  							if (stack.Pop().SequenceEqual(stack.Pop()))  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });    							if (se.opCode == OpCode.OP_EQUALVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_RESERVED1:  					case OpCode.OP_RESERVED2:  						{  							return false;  						}  					case OpCode.OP_1ADD:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Add(new ScriptVarInt(stack.Pop())' 1)).ToBytes());  							break;  						}  					case OpCode.OP_1SUB:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Subtract(new ScriptVarInt(stack.Pop())' 1)).ToBytes());  							break;  						}  					case OpCode.OP_2MUL:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Multiply(new ScriptVarInt(stack.Pop())' 2)).ToBytes());  							break;  						}  					case OpCode.OP_2DIV:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Divide(new ScriptVarInt(stack.Pop())' 2)).ToBytes());  							break;  						}  					case OpCode.OP_NEGATE:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Negate(new ScriptVarInt(stack.Pop()))).ToBytes());  							break;  						}  					case OpCode.OP_ABS:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Abs(new ScriptVarInt(stack.Pop()))).ToBytes());  							break;  						}  					case OpCode.OP_NOT:  						{  							if (stack.Count < 1)  								return false;  							if (new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_0NOTEQUAL:  						{  							if (stack.Count < 1)  								return false;  							if (new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x00 });  							else  								stack.Push(new Byte[] { 0x01 });  							break;  						}  					case OpCode.OP_ADD:  					case OpCode.OP_SUB:  					case OpCode.OP_MUL:  					case OpCode.OP_DIV:  					case OpCode.OP_MOD:  					case OpCode.OP_LSHIFT:  					case OpCode.OP_RSHIFT:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							switch (se.opCode)  							{  								case OpCode.OP_ADD:  									a = (BigInteger)a + b;  									break;  								case OpCode.OP_SUB:  									a = (BigInteger)a - b;  									break;  								case OpCode.OP_MUL:  									a = (BigInteger)a * b;  									break;  								case OpCode.OP_DIV:  									a = (BigInteger)a / b;  									break;  								case OpCode.OP_MOD:  									a = (BigInteger)a % b;  									break;  								case OpCode.OP_LSHIFT:  									a = (BigInteger)a << b.intValue;  									break;  								case OpCode.OP_RSHIFT:  									a = (BigInteger)a >> b.intValue;  									break;  							}  							stack.Push(a.ToBytes());  							break;  						}  					case OpCode.OP_BOOLAND:  						{  							if (stack.Count < 2)  								return false;  							if (!new ScriptVarInt(stack.Pop()).value.IsZero && !new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_BOOLOR:  						{  							if (stack.Count < 2)  								return false;  							if (!new ScriptVarInt(stack.Pop()).value.IsZero || !new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_NUMEQUAL:  					case OpCode.OP_NUMEQUALVERIFY:  						{  							if (stack.Count < 2)  								return false;  							if (new ScriptVarInt(stack.Pop()).value == new ScriptVarInt(stack.Pop()).value)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							if (se.opCode == OpCode.OP_NUMEQUALVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_NUMNOTEQUAL:  						{  							if (stack.Count < 2)  								return false;  							if (new ScriptVarInt(stack.Pop()).value != new ScriptVarInt(stack.Pop()).value)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_LESSTHAN:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a < b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_GREATERTHAN:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a > b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_LESSTHANOREQUAL:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a <= b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_GREATERTHANOREQUAL:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a >= b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_MIN:  						{  							if (stack.Count < 2)  								return false;  							Byte[] b = stack.Pop();  							Byte[] a = stack.Pop();  							if (new ScriptVarInt(a).value < new ScriptVarInt(b).value)  								stack.Push(a);  							else  								stack.Push(b);  							break;  						}  					case OpCode.OP_MAX:  						{  							if (stack.Count < 2)  								return false;  							Byte[] b = stack.Pop();  							Byte[] a = stack.Pop();  							if (new ScriptVarInt(a).value > new ScriptVarInt(b).value)  								stack.Push(a);  							else  								stack.Push(b);  							break;  						}  					case OpCode.OP_WITHIN:  						{  							if (stack.Count < 3)  								return false;  							ScriptVarInt max = new ScriptVarInt(stack.Pop());  							ScriptVarInt min = new ScriptVarInt(stack.Pop());  							ScriptVarInt x = new ScriptVarInt(stack.Pop());  							if ((BigInteger)min <= x && (BigInteger)x <= max)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_RIPEMD160:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(ripemd160.ComputeHash(stack.Pop()));  							break;  						}  					case OpCode.OP_SHA1:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(sha1.ComputeHash(stack.Pop()));  							break;  						}  					case OpCode.OP_SHA256:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(sha256.ComputeHash(stack.Pop()));  							break;  						}  					case OpCode.OP_HASH160:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(ripemd160.ComputeHash(sha256.ComputeHash(stack.Pop())));  							break;  						}  					case OpCode.OP_HASH256:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(sha256.ComputeHash(sha256.ComputeHash(stack.Pop())));  							break;  						}  					case OpCode.OP_CODESEPARATOR:  						{  							lastCodeSeperator = index;  							break;  						}  					case OpCode.OP_CHECKSIG:  					case OpCode.OP_CHECKSIGVERIFY:  						{  							if (tx == null)  								throw new ArgumentNullException("Transaction is required if script contains OP_CHECKSIG[VERIFY]");  							if (stack.Count < 2)  								return false;    							PublicKey pubKey = new PublicKey(stack.Pop());  							Byte[] sig = stack.Pop();    							Script subScript = new Script(elements.Skip(lastCodeSeperator)  								.Where(x => x.opCode != OpCode.OP_CODESEPARATOR).ToArray());    							stack.Push(new ScriptVarInt(CheckSig(sig' pubKey' txInIndex' subScript' tx) ? 1 : 0).ToBytes());    							if (se.opCode == OpCode.OP_CHECKSIGVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_CHECKMULTISIG:  					case OpCode.OP_CHECKMULTISIGVERIFY:  						{  							if (tx == null)  								throw new ArgumentNullException("Transaction is required if script contains OP_CHECKMULTISIG[VERIFY]");  							if (stack.Count < 2)  								return false;    							PublicKey[] pubKeys = new PublicKey[new ScriptVarInt(stack.Pop()).intValue];    							if (stack.Count < pubKeys.Length + 1)  								return false;    							for (int i = 0; i < pubKeys.Length; i++)  							{  								pubKeys[i] = new PublicKey(stack.Pop());  							}    							Byte[][] sigs = new Byte[new ScriptVarInt(stack.Pop()).intValue][];    							if (stack.Count < sigs.Length)  								return false;    							for (int i = 0; i < sigs.Length; i++)  							{  								sigs[i] = stack.Pop();  							}    							// Remove extra unused value from stack  							stack.Pop();    							Script subScript = new Script(elements.Skip(lastCodeSeperator)  								.Where(x => x.opCode != OpCode.OP_CODESEPARATOR).ToArray());    							int validSigs = 0;  							foreach (Byte[] sig in sigs)  							{  								foreach (PublicKey pubKey in pubKeys)  								{  									if (CheckSig(sig' pubKey' txInIndex' subScript' tx))  									{  										pubKeys = pubKeys.Where(x => x != pubKey).ToArray();  										validSigs++;  										break;  									}  								}  							}    							stack.Push(new ScriptVarInt((validSigs >= sigs.Length) ? 1 : 0).ToBytes());    							if (se.opCode == OpCode.OP_CHECKMULTISIGVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_NOP1:  					case OpCode.OP_NOP2:  					case OpCode.OP_NOP3:  					case OpCode.OP_NOP4:  					case OpCode.OP_NOP5:  					case OpCode.OP_NOP6:  					case OpCode.OP_NOP7:  					case OpCode.OP_NOP8:  					case OpCode.OP_NOP9:  					case OpCode.OP_NOP10:  						{  							break;  						}  					case OpCode.OP_SMALLINTEGER:  					case OpCode.OP_PUBKEYS:  					case OpCode.OP_PUBKEYHASH:  					case OpCode.OP_PUBKEY:  					case OpCode.OP_INVALIDOPCODE:  					default:  						{  							return false;  						}    				}  			}
Magic Number,Bitcoin_Tool.Scripts,Script,C:\repos\mb300sd_Bitcoin-Tool\Bitcoin Tool\Scripts\Script.cs,Evaluate,The following statement contains a magic number: for (int index = 0; index < elements.Count; index++)  			{  				ScriptElement se = elements[index];  				if (ifExec.Count > 0)  					if ((ifExec.First() == IfElseExec.SKIP_IF && !(se.opCode == OpCode.OP_ELSE || se.opCode == OpCode.OP_ENDIF)) ||  						(ifExec.First() == IfElseExec.SKIP_ELSE && !(se.opCode == OpCode.OP_ENDIF)))  						continue;    				if (se.isData)  				{  					stack.Push(se.data);  					continue;  				}    				switch (se.opCode)  				{  					case OpCode.OP_RESERVED:  						{  							return false;  						}  					case OpCode.OP_NOP:  						{  							// NOP' Dump stack for debug  							/*  							stack.ToList().ForEach(x => Console.WriteLine(HexString.FromByteArray(x)));  							Console.WriteLine("---------------------------");  							*/  							break;  						}  					case OpCode.OP_VER:  						{  							return false;  						}  					case OpCode.OP_IF:  					case OpCode.OP_NOTIF:  						{  							if (stack.Count < 1)  								return false;  							Boolean stackIsZero = new ScriptVarInt(stack.Pop()).value.IsZero;  							if ((se.opCode == OpCode.OP_IF && !stackIsZero) || (se.opCode == OpCode.OP_NOTIF && stackIsZero))  							{  								// Run to else or endif  								ifExec.Push(IfElseExec.RUN_IF);  							}  							else  							{  								// Skip to else or endif  								ifExec.Push(IfElseExec.SKIP_IF);  							}  							break;  						}  					case OpCode.OP_VERIF:  					case OpCode.OP_VERNOTIF:  						{  							return false;  						}  					case OpCode.OP_ELSE:  						{  							if (ifExec.Count == 0)  								// No preceding if statement!  								return false;  							if (ifExec.First() == IfElseExec.RUN_IF)  							{  								// If ran' skip else  								ifExec.Push(IfElseExec.SKIP_ELSE);  							}  							else if (ifExec.First() == IfElseExec.SKIP_IF)  							{  								// If did not run' run else  								ifExec.Push(IfElseExec.RUN_ELSE);  							}  							break;  						}  					case OpCode.OP_ENDIF:  						{  							if (ifExec.Count == 0)  								// No preceding if statement!  								return false;  							if (ifExec.First() == IfElseExec.RUN_IF ||  								ifExec.First() == IfElseExec.SKIP_IF)  							{  								ifExec.Pop();  							}  							else if (ifExec.First() == IfElseExec.RUN_ELSE ||  							   ifExec.First() == IfElseExec.SKIP_ELSE)  							{  								ifExec.Pop();  								ifExec.Pop();  							}  							break;  						}  					case OpCode.OP_VERIFY:  						{  							if (stack.Count < 1 || new ScriptVarInt(stack.First()).value.IsZero)  								return false;  							stack.Pop();  							break;  						}  					case OpCode.OP_RETURN:  						{  							return false;  						}  					case OpCode.OP_TOALTSTACK:  						{  							if (stack.Count < 1)  								return false;  							altstack.Push(stack.Pop());  							break;  						}  					case OpCode.OP_FROMALTSTACK:  						{  							if (altstack.Count < 1)  								return false;  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_2DROP:  						{  							if (stack.Count < 2)  								return false;  							stack.Pop();  							stack.Pop();  							break;  						}  					case OpCode.OP_2DUP:  						{  							if (stack.Count < 2)  								return false;  							stack.Push(stack.Skip(1).First());  							stack.Push(stack.Skip(1).First());  							break;  						}  					case OpCode.OP_3DUP:  						{  							if (stack.Count < 3)  								return false;  							stack.Push(stack.Skip(2).First());  							stack.Push(stack.Skip(2).First());  							stack.Push(stack.Skip(2).First());  							break;  						}  					case OpCode.OP_2OVER:  						{  							if (stack.Count < 4)  								return false;  							stack.Push(stack.Skip(3).First());  							stack.Push(stack.Skip(3).First());  							break;  						}  					case OpCode.OP_2ROT:  						{  							if (stack.Count < 6)  								return false;  							altstack.Push(stack.Skip(4).First());  							altstack.Push(stack.Skip(5).First());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_2SWAP:  						{  							if (stack.Count < 4)  								return false;  							altstack.Push(stack.Skip(2).First());  							altstack.Push(stack.Skip(3).First());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_IFDUP:  						{  							if (stack.Count < 1)  								return false;  							if (!new ScriptVarInt(stack.First()).value.IsZero)  								stack.Push(stack.First());  							break;  						}  					case OpCode.OP_DEPTH:  						{  							stack.Push(new ScriptVarInt((UInt64)stack.Count).ToBytes());  							break;  						}  					case OpCode.OP_DROP:  						{  							if (stack.Count < 1)  								return false;  							stack.Pop();  							break;  						}  					case OpCode.OP_DUP:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(stack.First());  							break;  						}  					case OpCode.OP_NIP:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_OVER:  						{  							if (stack.Count < 2)  								return false;  							stack.Push(stack.Skip(1).First());  							break;  						}  					case OpCode.OP_PICK:  						{  							if (stack.Count < 2)  								return false;  							int pick = new ScriptVarInt(stack.Pop()).intValue;  							if (pick < 0 || stack.Count <= pick)  								return false;  							stack.Push(stack.Skip(pick).First());  							break;  						}  					case OpCode.OP_ROLL:  						{  							if (stack.Count < 2)  								return false;  							int roll = new ScriptVarInt(stack.Pop()).intValue;  							if (roll < 0 || stack.Count <= roll)  								return false;  							altstack.Push(stack.Skip(roll).First());  							for (int i = 0; i < roll; i++)  								altstack.Push(stack.Pop());  							stack.Pop();  							for (int i = 0; i < roll + 1; i++)  								stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_ROT:  						{  							if (stack.Count < 3)  								return false;  							altstack.Push(stack.Skip(2).First());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_SWAP:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Skip(1).First());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_TUCK:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Push(altstack.Skip(1).First());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_CAT:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Skip(1).First().Concat(stack.First()).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_SUBSTR:  						{  							if (stack.Count < 3)  								return false;  							altstack.Push(stack.Skip(2).First()  								.Skip(new ScriptVarInt(stack.Skip(1).First()).intValue)  								.Take(new ScriptVarInt(stack.First()).intValue).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_LEFT:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Skip(1).First()  								.Take(new ScriptVarInt(stack.First()).intValue).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_RIGHT:  						{  							if (stack.Count < 2)  								return false;  							int count = new ScriptVarInt(stack.First()).intValue;  							altstack.Push(stack.Skip(1).First()  								.Skip(stack.Skip(1).First().Length - count).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_SIZE:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(new ScriptVarInt((UInt64)stack.First().Length).ToBytes());  							break;  						}  					case OpCode.OP_INVERT:  						{  							if (stack.Count < 1)  								return false;  							Byte[] data = stack.Pop();  							for (int i = 0; i < data.Length; i++)  								data[i] ^= 0xFF;  							stack.Push(data);  							break;  						}  					case OpCode.OP_AND:  					case OpCode.OP_OR:  					case OpCode.OP_XOR:  						{  							if (stack.Count < 2)  								return false;  							Byte[] data = stack.Pop();  							Byte[] data2 = stack.Pop();  							int length = new int[] { data.Length' data2.Length }.Max();  							data = data.Concat(new Byte[length - data.Length]).ToArray();  							data2 = data2.Concat(new Byte[length - data2.Length]).ToArray();  							switch (se.opCode)  							{  								case OpCode.OP_AND:  									{  										for (int i = 0; i < length; i++)  											data[i] &= data2[i];  										break;  									}  								case OpCode.OP_OR:  									{  										for (int i = 0; i < length; i++)  											data[i] |= data2[i];  										break;  									}  								case OpCode.OP_XOR:  									{  										for (int i = 0; i < length; i++)  											data[i] ^= data2[i];  										break;  									}  							}  							stack.Push(data);  							break;  						}  					case OpCode.OP_EQUAL:  					case OpCode.OP_EQUALVERIFY:  						{  							if (stack.Count < 2)  								return false;  							if (stack.Pop().SequenceEqual(stack.Pop()))  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });    							if (se.opCode == OpCode.OP_EQUALVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_RESERVED1:  					case OpCode.OP_RESERVED2:  						{  							return false;  						}  					case OpCode.OP_1ADD:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Add(new ScriptVarInt(stack.Pop())' 1)).ToBytes());  							break;  						}  					case OpCode.OP_1SUB:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Subtract(new ScriptVarInt(stack.Pop())' 1)).ToBytes());  							break;  						}  					case OpCode.OP_2MUL:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Multiply(new ScriptVarInt(stack.Pop())' 2)).ToBytes());  							break;  						}  					case OpCode.OP_2DIV:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Divide(new ScriptVarInt(stack.Pop())' 2)).ToBytes());  							break;  						}  					case OpCode.OP_NEGATE:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Negate(new ScriptVarInt(stack.Pop()))).ToBytes());  							break;  						}  					case OpCode.OP_ABS:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Abs(new ScriptVarInt(stack.Pop()))).ToBytes());  							break;  						}  					case OpCode.OP_NOT:  						{  							if (stack.Count < 1)  								return false;  							if (new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_0NOTEQUAL:  						{  							if (stack.Count < 1)  								return false;  							if (new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x00 });  							else  								stack.Push(new Byte[] { 0x01 });  							break;  						}  					case OpCode.OP_ADD:  					case OpCode.OP_SUB:  					case OpCode.OP_MUL:  					case OpCode.OP_DIV:  					case OpCode.OP_MOD:  					case OpCode.OP_LSHIFT:  					case OpCode.OP_RSHIFT:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							switch (se.opCode)  							{  								case OpCode.OP_ADD:  									a = (BigInteger)a + b;  									break;  								case OpCode.OP_SUB:  									a = (BigInteger)a - b;  									break;  								case OpCode.OP_MUL:  									a = (BigInteger)a * b;  									break;  								case OpCode.OP_DIV:  									a = (BigInteger)a / b;  									break;  								case OpCode.OP_MOD:  									a = (BigInteger)a % b;  									break;  								case OpCode.OP_LSHIFT:  									a = (BigInteger)a << b.intValue;  									break;  								case OpCode.OP_RSHIFT:  									a = (BigInteger)a >> b.intValue;  									break;  							}  							stack.Push(a.ToBytes());  							break;  						}  					case OpCode.OP_BOOLAND:  						{  							if (stack.Count < 2)  								return false;  							if (!new ScriptVarInt(stack.Pop()).value.IsZero && !new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_BOOLOR:  						{  							if (stack.Count < 2)  								return false;  							if (!new ScriptVarInt(stack.Pop()).value.IsZero || !new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_NUMEQUAL:  					case OpCode.OP_NUMEQUALVERIFY:  						{  							if (stack.Count < 2)  								return false;  							if (new ScriptVarInt(stack.Pop()).value == new ScriptVarInt(stack.Pop()).value)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							if (se.opCode == OpCode.OP_NUMEQUALVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_NUMNOTEQUAL:  						{  							if (stack.Count < 2)  								return false;  							if (new ScriptVarInt(stack.Pop()).value != new ScriptVarInt(stack.Pop()).value)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_LESSTHAN:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a < b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_GREATERTHAN:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a > b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_LESSTHANOREQUAL:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a <= b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_GREATERTHANOREQUAL:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a >= b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_MIN:  						{  							if (stack.Count < 2)  								return false;  							Byte[] b = stack.Pop();  							Byte[] a = stack.Pop();  							if (new ScriptVarInt(a).value < new ScriptVarInt(b).value)  								stack.Push(a);  							else  								stack.Push(b);  							break;  						}  					case OpCode.OP_MAX:  						{  							if (stack.Count < 2)  								return false;  							Byte[] b = stack.Pop();  							Byte[] a = stack.Pop();  							if (new ScriptVarInt(a).value > new ScriptVarInt(b).value)  								stack.Push(a);  							else  								stack.Push(b);  							break;  						}  					case OpCode.OP_WITHIN:  						{  							if (stack.Count < 3)  								return false;  							ScriptVarInt max = new ScriptVarInt(stack.Pop());  							ScriptVarInt min = new ScriptVarInt(stack.Pop());  							ScriptVarInt x = new ScriptVarInt(stack.Pop());  							if ((BigInteger)min <= x && (BigInteger)x <= max)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_RIPEMD160:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(ripemd160.ComputeHash(stack.Pop()));  							break;  						}  					case OpCode.OP_SHA1:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(sha1.ComputeHash(stack.Pop()));  							break;  						}  					case OpCode.OP_SHA256:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(sha256.ComputeHash(stack.Pop()));  							break;  						}  					case OpCode.OP_HASH160:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(ripemd160.ComputeHash(sha256.ComputeHash(stack.Pop())));  							break;  						}  					case OpCode.OP_HASH256:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(sha256.ComputeHash(sha256.ComputeHash(stack.Pop())));  							break;  						}  					case OpCode.OP_CODESEPARATOR:  						{  							lastCodeSeperator = index;  							break;  						}  					case OpCode.OP_CHECKSIG:  					case OpCode.OP_CHECKSIGVERIFY:  						{  							if (tx == null)  								throw new ArgumentNullException("Transaction is required if script contains OP_CHECKSIG[VERIFY]");  							if (stack.Count < 2)  								return false;    							PublicKey pubKey = new PublicKey(stack.Pop());  							Byte[] sig = stack.Pop();    							Script subScript = new Script(elements.Skip(lastCodeSeperator)  								.Where(x => x.opCode != OpCode.OP_CODESEPARATOR).ToArray());    							stack.Push(new ScriptVarInt(CheckSig(sig' pubKey' txInIndex' subScript' tx) ? 1 : 0).ToBytes());    							if (se.opCode == OpCode.OP_CHECKSIGVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_CHECKMULTISIG:  					case OpCode.OP_CHECKMULTISIGVERIFY:  						{  							if (tx == null)  								throw new ArgumentNullException("Transaction is required if script contains OP_CHECKMULTISIG[VERIFY]");  							if (stack.Count < 2)  								return false;    							PublicKey[] pubKeys = new PublicKey[new ScriptVarInt(stack.Pop()).intValue];    							if (stack.Count < pubKeys.Length + 1)  								return false;    							for (int i = 0; i < pubKeys.Length; i++)  							{  								pubKeys[i] = new PublicKey(stack.Pop());  							}    							Byte[][] sigs = new Byte[new ScriptVarInt(stack.Pop()).intValue][];    							if (stack.Count < sigs.Length)  								return false;    							for (int i = 0; i < sigs.Length; i++)  							{  								sigs[i] = stack.Pop();  							}    							// Remove extra unused value from stack  							stack.Pop();    							Script subScript = new Script(elements.Skip(lastCodeSeperator)  								.Where(x => x.opCode != OpCode.OP_CODESEPARATOR).ToArray());    							int validSigs = 0;  							foreach (Byte[] sig in sigs)  							{  								foreach (PublicKey pubKey in pubKeys)  								{  									if (CheckSig(sig' pubKey' txInIndex' subScript' tx))  									{  										pubKeys = pubKeys.Where(x => x != pubKey).ToArray();  										validSigs++;  										break;  									}  								}  							}    							stack.Push(new ScriptVarInt((validSigs >= sigs.Length) ? 1 : 0).ToBytes());    							if (se.opCode == OpCode.OP_CHECKMULTISIGVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_NOP1:  					case OpCode.OP_NOP2:  					case OpCode.OP_NOP3:  					case OpCode.OP_NOP4:  					case OpCode.OP_NOP5:  					case OpCode.OP_NOP6:  					case OpCode.OP_NOP7:  					case OpCode.OP_NOP8:  					case OpCode.OP_NOP9:  					case OpCode.OP_NOP10:  						{  							break;  						}  					case OpCode.OP_SMALLINTEGER:  					case OpCode.OP_PUBKEYS:  					case OpCode.OP_PUBKEYHASH:  					case OpCode.OP_PUBKEY:  					case OpCode.OP_INVALIDOPCODE:  					default:  						{  							return false;  						}    				}  			}
Magic Number,Bitcoin_Tool.Scripts,Script,C:\repos\mb300sd_Bitcoin-Tool\Bitcoin Tool\Scripts\Script.cs,Evaluate,The following statement contains a magic number: for (int index = 0; index < elements.Count; index++)  			{  				ScriptElement se = elements[index];  				if (ifExec.Count > 0)  					if ((ifExec.First() == IfElseExec.SKIP_IF && !(se.opCode == OpCode.OP_ELSE || se.opCode == OpCode.OP_ENDIF)) ||  						(ifExec.First() == IfElseExec.SKIP_ELSE && !(se.opCode == OpCode.OP_ENDIF)))  						continue;    				if (se.isData)  				{  					stack.Push(se.data);  					continue;  				}    				switch (se.opCode)  				{  					case OpCode.OP_RESERVED:  						{  							return false;  						}  					case OpCode.OP_NOP:  						{  							// NOP' Dump stack for debug  							/*  							stack.ToList().ForEach(x => Console.WriteLine(HexString.FromByteArray(x)));  							Console.WriteLine("---------------------------");  							*/  							break;  						}  					case OpCode.OP_VER:  						{  							return false;  						}  					case OpCode.OP_IF:  					case OpCode.OP_NOTIF:  						{  							if (stack.Count < 1)  								return false;  							Boolean stackIsZero = new ScriptVarInt(stack.Pop()).value.IsZero;  							if ((se.opCode == OpCode.OP_IF && !stackIsZero) || (se.opCode == OpCode.OP_NOTIF && stackIsZero))  							{  								// Run to else or endif  								ifExec.Push(IfElseExec.RUN_IF);  							}  							else  							{  								// Skip to else or endif  								ifExec.Push(IfElseExec.SKIP_IF);  							}  							break;  						}  					case OpCode.OP_VERIF:  					case OpCode.OP_VERNOTIF:  						{  							return false;  						}  					case OpCode.OP_ELSE:  						{  							if (ifExec.Count == 0)  								// No preceding if statement!  								return false;  							if (ifExec.First() == IfElseExec.RUN_IF)  							{  								// If ran' skip else  								ifExec.Push(IfElseExec.SKIP_ELSE);  							}  							else if (ifExec.First() == IfElseExec.SKIP_IF)  							{  								// If did not run' run else  								ifExec.Push(IfElseExec.RUN_ELSE);  							}  							break;  						}  					case OpCode.OP_ENDIF:  						{  							if (ifExec.Count == 0)  								// No preceding if statement!  								return false;  							if (ifExec.First() == IfElseExec.RUN_IF ||  								ifExec.First() == IfElseExec.SKIP_IF)  							{  								ifExec.Pop();  							}  							else if (ifExec.First() == IfElseExec.RUN_ELSE ||  							   ifExec.First() == IfElseExec.SKIP_ELSE)  							{  								ifExec.Pop();  								ifExec.Pop();  							}  							break;  						}  					case OpCode.OP_VERIFY:  						{  							if (stack.Count < 1 || new ScriptVarInt(stack.First()).value.IsZero)  								return false;  							stack.Pop();  							break;  						}  					case OpCode.OP_RETURN:  						{  							return false;  						}  					case OpCode.OP_TOALTSTACK:  						{  							if (stack.Count < 1)  								return false;  							altstack.Push(stack.Pop());  							break;  						}  					case OpCode.OP_FROMALTSTACK:  						{  							if (altstack.Count < 1)  								return false;  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_2DROP:  						{  							if (stack.Count < 2)  								return false;  							stack.Pop();  							stack.Pop();  							break;  						}  					case OpCode.OP_2DUP:  						{  							if (stack.Count < 2)  								return false;  							stack.Push(stack.Skip(1).First());  							stack.Push(stack.Skip(1).First());  							break;  						}  					case OpCode.OP_3DUP:  						{  							if (stack.Count < 3)  								return false;  							stack.Push(stack.Skip(2).First());  							stack.Push(stack.Skip(2).First());  							stack.Push(stack.Skip(2).First());  							break;  						}  					case OpCode.OP_2OVER:  						{  							if (stack.Count < 4)  								return false;  							stack.Push(stack.Skip(3).First());  							stack.Push(stack.Skip(3).First());  							break;  						}  					case OpCode.OP_2ROT:  						{  							if (stack.Count < 6)  								return false;  							altstack.Push(stack.Skip(4).First());  							altstack.Push(stack.Skip(5).First());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_2SWAP:  						{  							if (stack.Count < 4)  								return false;  							altstack.Push(stack.Skip(2).First());  							altstack.Push(stack.Skip(3).First());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_IFDUP:  						{  							if (stack.Count < 1)  								return false;  							if (!new ScriptVarInt(stack.First()).value.IsZero)  								stack.Push(stack.First());  							break;  						}  					case OpCode.OP_DEPTH:  						{  							stack.Push(new ScriptVarInt((UInt64)stack.Count).ToBytes());  							break;  						}  					case OpCode.OP_DROP:  						{  							if (stack.Count < 1)  								return false;  							stack.Pop();  							break;  						}  					case OpCode.OP_DUP:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(stack.First());  							break;  						}  					case OpCode.OP_NIP:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_OVER:  						{  							if (stack.Count < 2)  								return false;  							stack.Push(stack.Skip(1).First());  							break;  						}  					case OpCode.OP_PICK:  						{  							if (stack.Count < 2)  								return false;  							int pick = new ScriptVarInt(stack.Pop()).intValue;  							if (pick < 0 || stack.Count <= pick)  								return false;  							stack.Push(stack.Skip(pick).First());  							break;  						}  					case OpCode.OP_ROLL:  						{  							if (stack.Count < 2)  								return false;  							int roll = new ScriptVarInt(stack.Pop()).intValue;  							if (roll < 0 || stack.Count <= roll)  								return false;  							altstack.Push(stack.Skip(roll).First());  							for (int i = 0; i < roll; i++)  								altstack.Push(stack.Pop());  							stack.Pop();  							for (int i = 0; i < roll + 1; i++)  								stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_ROT:  						{  							if (stack.Count < 3)  								return false;  							altstack.Push(stack.Skip(2).First());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_SWAP:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Skip(1).First());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_TUCK:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Push(altstack.Skip(1).First());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_CAT:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Skip(1).First().Concat(stack.First()).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_SUBSTR:  						{  							if (stack.Count < 3)  								return false;  							altstack.Push(stack.Skip(2).First()  								.Skip(new ScriptVarInt(stack.Skip(1).First()).intValue)  								.Take(new ScriptVarInt(stack.First()).intValue).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_LEFT:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Skip(1).First()  								.Take(new ScriptVarInt(stack.First()).intValue).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_RIGHT:  						{  							if (stack.Count < 2)  								return false;  							int count = new ScriptVarInt(stack.First()).intValue;  							altstack.Push(stack.Skip(1).First()  								.Skip(stack.Skip(1).First().Length - count).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_SIZE:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(new ScriptVarInt((UInt64)stack.First().Length).ToBytes());  							break;  						}  					case OpCode.OP_INVERT:  						{  							if (stack.Count < 1)  								return false;  							Byte[] data = stack.Pop();  							for (int i = 0; i < data.Length; i++)  								data[i] ^= 0xFF;  							stack.Push(data);  							break;  						}  					case OpCode.OP_AND:  					case OpCode.OP_OR:  					case OpCode.OP_XOR:  						{  							if (stack.Count < 2)  								return false;  							Byte[] data = stack.Pop();  							Byte[] data2 = stack.Pop();  							int length = new int[] { data.Length' data2.Length }.Max();  							data = data.Concat(new Byte[length - data.Length]).ToArray();  							data2 = data2.Concat(new Byte[length - data2.Length]).ToArray();  							switch (se.opCode)  							{  								case OpCode.OP_AND:  									{  										for (int i = 0; i < length; i++)  											data[i] &= data2[i];  										break;  									}  								case OpCode.OP_OR:  									{  										for (int i = 0; i < length; i++)  											data[i] |= data2[i];  										break;  									}  								case OpCode.OP_XOR:  									{  										for (int i = 0; i < length; i++)  											data[i] ^= data2[i];  										break;  									}  							}  							stack.Push(data);  							break;  						}  					case OpCode.OP_EQUAL:  					case OpCode.OP_EQUALVERIFY:  						{  							if (stack.Count < 2)  								return false;  							if (stack.Pop().SequenceEqual(stack.Pop()))  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });    							if (se.opCode == OpCode.OP_EQUALVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_RESERVED1:  					case OpCode.OP_RESERVED2:  						{  							return false;  						}  					case OpCode.OP_1ADD:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Add(new ScriptVarInt(stack.Pop())' 1)).ToBytes());  							break;  						}  					case OpCode.OP_1SUB:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Subtract(new ScriptVarInt(stack.Pop())' 1)).ToBytes());  							break;  						}  					case OpCode.OP_2MUL:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Multiply(new ScriptVarInt(stack.Pop())' 2)).ToBytes());  							break;  						}  					case OpCode.OP_2DIV:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Divide(new ScriptVarInt(stack.Pop())' 2)).ToBytes());  							break;  						}  					case OpCode.OP_NEGATE:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Negate(new ScriptVarInt(stack.Pop()))).ToBytes());  							break;  						}  					case OpCode.OP_ABS:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Abs(new ScriptVarInt(stack.Pop()))).ToBytes());  							break;  						}  					case OpCode.OP_NOT:  						{  							if (stack.Count < 1)  								return false;  							if (new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_0NOTEQUAL:  						{  							if (stack.Count < 1)  								return false;  							if (new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x00 });  							else  								stack.Push(new Byte[] { 0x01 });  							break;  						}  					case OpCode.OP_ADD:  					case OpCode.OP_SUB:  					case OpCode.OP_MUL:  					case OpCode.OP_DIV:  					case OpCode.OP_MOD:  					case OpCode.OP_LSHIFT:  					case OpCode.OP_RSHIFT:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							switch (se.opCode)  							{  								case OpCode.OP_ADD:  									a = (BigInteger)a + b;  									break;  								case OpCode.OP_SUB:  									a = (BigInteger)a - b;  									break;  								case OpCode.OP_MUL:  									a = (BigInteger)a * b;  									break;  								case OpCode.OP_DIV:  									a = (BigInteger)a / b;  									break;  								case OpCode.OP_MOD:  									a = (BigInteger)a % b;  									break;  								case OpCode.OP_LSHIFT:  									a = (BigInteger)a << b.intValue;  									break;  								case OpCode.OP_RSHIFT:  									a = (BigInteger)a >> b.intValue;  									break;  							}  							stack.Push(a.ToBytes());  							break;  						}  					case OpCode.OP_BOOLAND:  						{  							if (stack.Count < 2)  								return false;  							if (!new ScriptVarInt(stack.Pop()).value.IsZero && !new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_BOOLOR:  						{  							if (stack.Count < 2)  								return false;  							if (!new ScriptVarInt(stack.Pop()).value.IsZero || !new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_NUMEQUAL:  					case OpCode.OP_NUMEQUALVERIFY:  						{  							if (stack.Count < 2)  								return false;  							if (new ScriptVarInt(stack.Pop()).value == new ScriptVarInt(stack.Pop()).value)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							if (se.opCode == OpCode.OP_NUMEQUALVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_NUMNOTEQUAL:  						{  							if (stack.Count < 2)  								return false;  							if (new ScriptVarInt(stack.Pop()).value != new ScriptVarInt(stack.Pop()).value)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_LESSTHAN:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a < b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_GREATERTHAN:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a > b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_LESSTHANOREQUAL:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a <= b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_GREATERTHANOREQUAL:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a >= b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_MIN:  						{  							if (stack.Count < 2)  								return false;  							Byte[] b = stack.Pop();  							Byte[] a = stack.Pop();  							if (new ScriptVarInt(a).value < new ScriptVarInt(b).value)  								stack.Push(a);  							else  								stack.Push(b);  							break;  						}  					case OpCode.OP_MAX:  						{  							if (stack.Count < 2)  								return false;  							Byte[] b = stack.Pop();  							Byte[] a = stack.Pop();  							if (new ScriptVarInt(a).value > new ScriptVarInt(b).value)  								stack.Push(a);  							else  								stack.Push(b);  							break;  						}  					case OpCode.OP_WITHIN:  						{  							if (stack.Count < 3)  								return false;  							ScriptVarInt max = new ScriptVarInt(stack.Pop());  							ScriptVarInt min = new ScriptVarInt(stack.Pop());  							ScriptVarInt x = new ScriptVarInt(stack.Pop());  							if ((BigInteger)min <= x && (BigInteger)x <= max)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_RIPEMD160:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(ripemd160.ComputeHash(stack.Pop()));  							break;  						}  					case OpCode.OP_SHA1:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(sha1.ComputeHash(stack.Pop()));  							break;  						}  					case OpCode.OP_SHA256:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(sha256.ComputeHash(stack.Pop()));  							break;  						}  					case OpCode.OP_HASH160:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(ripemd160.ComputeHash(sha256.ComputeHash(stack.Pop())));  							break;  						}  					case OpCode.OP_HASH256:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(sha256.ComputeHash(sha256.ComputeHash(stack.Pop())));  							break;  						}  					case OpCode.OP_CODESEPARATOR:  						{  							lastCodeSeperator = index;  							break;  						}  					case OpCode.OP_CHECKSIG:  					case OpCode.OP_CHECKSIGVERIFY:  						{  							if (tx == null)  								throw new ArgumentNullException("Transaction is required if script contains OP_CHECKSIG[VERIFY]");  							if (stack.Count < 2)  								return false;    							PublicKey pubKey = new PublicKey(stack.Pop());  							Byte[] sig = stack.Pop();    							Script subScript = new Script(elements.Skip(lastCodeSeperator)  								.Where(x => x.opCode != OpCode.OP_CODESEPARATOR).ToArray());    							stack.Push(new ScriptVarInt(CheckSig(sig' pubKey' txInIndex' subScript' tx) ? 1 : 0).ToBytes());    							if (se.opCode == OpCode.OP_CHECKSIGVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_CHECKMULTISIG:  					case OpCode.OP_CHECKMULTISIGVERIFY:  						{  							if (tx == null)  								throw new ArgumentNullException("Transaction is required if script contains OP_CHECKMULTISIG[VERIFY]");  							if (stack.Count < 2)  								return false;    							PublicKey[] pubKeys = new PublicKey[new ScriptVarInt(stack.Pop()).intValue];    							if (stack.Count < pubKeys.Length + 1)  								return false;    							for (int i = 0; i < pubKeys.Length; i++)  							{  								pubKeys[i] = new PublicKey(stack.Pop());  							}    							Byte[][] sigs = new Byte[new ScriptVarInt(stack.Pop()).intValue][];    							if (stack.Count < sigs.Length)  								return false;    							for (int i = 0; i < sigs.Length; i++)  							{  								sigs[i] = stack.Pop();  							}    							// Remove extra unused value from stack  							stack.Pop();    							Script subScript = new Script(elements.Skip(lastCodeSeperator)  								.Where(x => x.opCode != OpCode.OP_CODESEPARATOR).ToArray());    							int validSigs = 0;  							foreach (Byte[] sig in sigs)  							{  								foreach (PublicKey pubKey in pubKeys)  								{  									if (CheckSig(sig' pubKey' txInIndex' subScript' tx))  									{  										pubKeys = pubKeys.Where(x => x != pubKey).ToArray();  										validSigs++;  										break;  									}  								}  							}    							stack.Push(new ScriptVarInt((validSigs >= sigs.Length) ? 1 : 0).ToBytes());    							if (se.opCode == OpCode.OP_CHECKMULTISIGVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_NOP1:  					case OpCode.OP_NOP2:  					case OpCode.OP_NOP3:  					case OpCode.OP_NOP4:  					case OpCode.OP_NOP5:  					case OpCode.OP_NOP6:  					case OpCode.OP_NOP7:  					case OpCode.OP_NOP8:  					case OpCode.OP_NOP9:  					case OpCode.OP_NOP10:  						{  							break;  						}  					case OpCode.OP_SMALLINTEGER:  					case OpCode.OP_PUBKEYS:  					case OpCode.OP_PUBKEYHASH:  					case OpCode.OP_PUBKEY:  					case OpCode.OP_INVALIDOPCODE:  					default:  						{  							return false;  						}    				}  			}
Magic Number,Bitcoin_Tool.Scripts,Script,C:\repos\mb300sd_Bitcoin-Tool\Bitcoin Tool\Scripts\Script.cs,Evaluate,The following statement contains a magic number: for (int index = 0; index < elements.Count; index++)  			{  				ScriptElement se = elements[index];  				if (ifExec.Count > 0)  					if ((ifExec.First() == IfElseExec.SKIP_IF && !(se.opCode == OpCode.OP_ELSE || se.opCode == OpCode.OP_ENDIF)) ||  						(ifExec.First() == IfElseExec.SKIP_ELSE && !(se.opCode == OpCode.OP_ENDIF)))  						continue;    				if (se.isData)  				{  					stack.Push(se.data);  					continue;  				}    				switch (se.opCode)  				{  					case OpCode.OP_RESERVED:  						{  							return false;  						}  					case OpCode.OP_NOP:  						{  							// NOP' Dump stack for debug  							/*  							stack.ToList().ForEach(x => Console.WriteLine(HexString.FromByteArray(x)));  							Console.WriteLine("---------------------------");  							*/  							break;  						}  					case OpCode.OP_VER:  						{  							return false;  						}  					case OpCode.OP_IF:  					case OpCode.OP_NOTIF:  						{  							if (stack.Count < 1)  								return false;  							Boolean stackIsZero = new ScriptVarInt(stack.Pop()).value.IsZero;  							if ((se.opCode == OpCode.OP_IF && !stackIsZero) || (se.opCode == OpCode.OP_NOTIF && stackIsZero))  							{  								// Run to else or endif  								ifExec.Push(IfElseExec.RUN_IF);  							}  							else  							{  								// Skip to else or endif  								ifExec.Push(IfElseExec.SKIP_IF);  							}  							break;  						}  					case OpCode.OP_VERIF:  					case OpCode.OP_VERNOTIF:  						{  							return false;  						}  					case OpCode.OP_ELSE:  						{  							if (ifExec.Count == 0)  								// No preceding if statement!  								return false;  							if (ifExec.First() == IfElseExec.RUN_IF)  							{  								// If ran' skip else  								ifExec.Push(IfElseExec.SKIP_ELSE);  							}  							else if (ifExec.First() == IfElseExec.SKIP_IF)  							{  								// If did not run' run else  								ifExec.Push(IfElseExec.RUN_ELSE);  							}  							break;  						}  					case OpCode.OP_ENDIF:  						{  							if (ifExec.Count == 0)  								// No preceding if statement!  								return false;  							if (ifExec.First() == IfElseExec.RUN_IF ||  								ifExec.First() == IfElseExec.SKIP_IF)  							{  								ifExec.Pop();  							}  							else if (ifExec.First() == IfElseExec.RUN_ELSE ||  							   ifExec.First() == IfElseExec.SKIP_ELSE)  							{  								ifExec.Pop();  								ifExec.Pop();  							}  							break;  						}  					case OpCode.OP_VERIFY:  						{  							if (stack.Count < 1 || new ScriptVarInt(stack.First()).value.IsZero)  								return false;  							stack.Pop();  							break;  						}  					case OpCode.OP_RETURN:  						{  							return false;  						}  					case OpCode.OP_TOALTSTACK:  						{  							if (stack.Count < 1)  								return false;  							altstack.Push(stack.Pop());  							break;  						}  					case OpCode.OP_FROMALTSTACK:  						{  							if (altstack.Count < 1)  								return false;  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_2DROP:  						{  							if (stack.Count < 2)  								return false;  							stack.Pop();  							stack.Pop();  							break;  						}  					case OpCode.OP_2DUP:  						{  							if (stack.Count < 2)  								return false;  							stack.Push(stack.Skip(1).First());  							stack.Push(stack.Skip(1).First());  							break;  						}  					case OpCode.OP_3DUP:  						{  							if (stack.Count < 3)  								return false;  							stack.Push(stack.Skip(2).First());  							stack.Push(stack.Skip(2).First());  							stack.Push(stack.Skip(2).First());  							break;  						}  					case OpCode.OP_2OVER:  						{  							if (stack.Count < 4)  								return false;  							stack.Push(stack.Skip(3).First());  							stack.Push(stack.Skip(3).First());  							break;  						}  					case OpCode.OP_2ROT:  						{  							if (stack.Count < 6)  								return false;  							altstack.Push(stack.Skip(4).First());  							altstack.Push(stack.Skip(5).First());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_2SWAP:  						{  							if (stack.Count < 4)  								return false;  							altstack.Push(stack.Skip(2).First());  							altstack.Push(stack.Skip(3).First());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_IFDUP:  						{  							if (stack.Count < 1)  								return false;  							if (!new ScriptVarInt(stack.First()).value.IsZero)  								stack.Push(stack.First());  							break;  						}  					case OpCode.OP_DEPTH:  						{  							stack.Push(new ScriptVarInt((UInt64)stack.Count).ToBytes());  							break;  						}  					case OpCode.OP_DROP:  						{  							if (stack.Count < 1)  								return false;  							stack.Pop();  							break;  						}  					case OpCode.OP_DUP:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(stack.First());  							break;  						}  					case OpCode.OP_NIP:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_OVER:  						{  							if (stack.Count < 2)  								return false;  							stack.Push(stack.Skip(1).First());  							break;  						}  					case OpCode.OP_PICK:  						{  							if (stack.Count < 2)  								return false;  							int pick = new ScriptVarInt(stack.Pop()).intValue;  							if (pick < 0 || stack.Count <= pick)  								return false;  							stack.Push(stack.Skip(pick).First());  							break;  						}  					case OpCode.OP_ROLL:  						{  							if (stack.Count < 2)  								return false;  							int roll = new ScriptVarInt(stack.Pop()).intValue;  							if (roll < 0 || stack.Count <= roll)  								return false;  							altstack.Push(stack.Skip(roll).First());  							for (int i = 0; i < roll; i++)  								altstack.Push(stack.Pop());  							stack.Pop();  							for (int i = 0; i < roll + 1; i++)  								stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_ROT:  						{  							if (stack.Count < 3)  								return false;  							altstack.Push(stack.Skip(2).First());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_SWAP:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Skip(1).First());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_TUCK:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Push(altstack.Skip(1).First());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_CAT:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Skip(1).First().Concat(stack.First()).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_SUBSTR:  						{  							if (stack.Count < 3)  								return false;  							altstack.Push(stack.Skip(2).First()  								.Skip(new ScriptVarInt(stack.Skip(1).First()).intValue)  								.Take(new ScriptVarInt(stack.First()).intValue).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_LEFT:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Skip(1).First()  								.Take(new ScriptVarInt(stack.First()).intValue).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_RIGHT:  						{  							if (stack.Count < 2)  								return false;  							int count = new ScriptVarInt(stack.First()).intValue;  							altstack.Push(stack.Skip(1).First()  								.Skip(stack.Skip(1).First().Length - count).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_SIZE:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(new ScriptVarInt((UInt64)stack.First().Length).ToBytes());  							break;  						}  					case OpCode.OP_INVERT:  						{  							if (stack.Count < 1)  								return false;  							Byte[] data = stack.Pop();  							for (int i = 0; i < data.Length; i++)  								data[i] ^= 0xFF;  							stack.Push(data);  							break;  						}  					case OpCode.OP_AND:  					case OpCode.OP_OR:  					case OpCode.OP_XOR:  						{  							if (stack.Count < 2)  								return false;  							Byte[] data = stack.Pop();  							Byte[] data2 = stack.Pop();  							int length = new int[] { data.Length' data2.Length }.Max();  							data = data.Concat(new Byte[length - data.Length]).ToArray();  							data2 = data2.Concat(new Byte[length - data2.Length]).ToArray();  							switch (se.opCode)  							{  								case OpCode.OP_AND:  									{  										for (int i = 0; i < length; i++)  											data[i] &= data2[i];  										break;  									}  								case OpCode.OP_OR:  									{  										for (int i = 0; i < length; i++)  											data[i] |= data2[i];  										break;  									}  								case OpCode.OP_XOR:  									{  										for (int i = 0; i < length; i++)  											data[i] ^= data2[i];  										break;  									}  							}  							stack.Push(data);  							break;  						}  					case OpCode.OP_EQUAL:  					case OpCode.OP_EQUALVERIFY:  						{  							if (stack.Count < 2)  								return false;  							if (stack.Pop().SequenceEqual(stack.Pop()))  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });    							if (se.opCode == OpCode.OP_EQUALVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_RESERVED1:  					case OpCode.OP_RESERVED2:  						{  							return false;  						}  					case OpCode.OP_1ADD:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Add(new ScriptVarInt(stack.Pop())' 1)).ToBytes());  							break;  						}  					case OpCode.OP_1SUB:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Subtract(new ScriptVarInt(stack.Pop())' 1)).ToBytes());  							break;  						}  					case OpCode.OP_2MUL:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Multiply(new ScriptVarInt(stack.Pop())' 2)).ToBytes());  							break;  						}  					case OpCode.OP_2DIV:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Divide(new ScriptVarInt(stack.Pop())' 2)).ToBytes());  							break;  						}  					case OpCode.OP_NEGATE:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Negate(new ScriptVarInt(stack.Pop()))).ToBytes());  							break;  						}  					case OpCode.OP_ABS:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Abs(new ScriptVarInt(stack.Pop()))).ToBytes());  							break;  						}  					case OpCode.OP_NOT:  						{  							if (stack.Count < 1)  								return false;  							if (new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_0NOTEQUAL:  						{  							if (stack.Count < 1)  								return false;  							if (new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x00 });  							else  								stack.Push(new Byte[] { 0x01 });  							break;  						}  					case OpCode.OP_ADD:  					case OpCode.OP_SUB:  					case OpCode.OP_MUL:  					case OpCode.OP_DIV:  					case OpCode.OP_MOD:  					case OpCode.OP_LSHIFT:  					case OpCode.OP_RSHIFT:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							switch (se.opCode)  							{  								case OpCode.OP_ADD:  									a = (BigInteger)a + b;  									break;  								case OpCode.OP_SUB:  									a = (BigInteger)a - b;  									break;  								case OpCode.OP_MUL:  									a = (BigInteger)a * b;  									break;  								case OpCode.OP_DIV:  									a = (BigInteger)a / b;  									break;  								case OpCode.OP_MOD:  									a = (BigInteger)a % b;  									break;  								case OpCode.OP_LSHIFT:  									a = (BigInteger)a << b.intValue;  									break;  								case OpCode.OP_RSHIFT:  									a = (BigInteger)a >> b.intValue;  									break;  							}  							stack.Push(a.ToBytes());  							break;  						}  					case OpCode.OP_BOOLAND:  						{  							if (stack.Count < 2)  								return false;  							if (!new ScriptVarInt(stack.Pop()).value.IsZero && !new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_BOOLOR:  						{  							if (stack.Count < 2)  								return false;  							if (!new ScriptVarInt(stack.Pop()).value.IsZero || !new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_NUMEQUAL:  					case OpCode.OP_NUMEQUALVERIFY:  						{  							if (stack.Count < 2)  								return false;  							if (new ScriptVarInt(stack.Pop()).value == new ScriptVarInt(stack.Pop()).value)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							if (se.opCode == OpCode.OP_NUMEQUALVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_NUMNOTEQUAL:  						{  							if (stack.Count < 2)  								return false;  							if (new ScriptVarInt(stack.Pop()).value != new ScriptVarInt(stack.Pop()).value)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_LESSTHAN:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a < b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_GREATERTHAN:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a > b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_LESSTHANOREQUAL:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a <= b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_GREATERTHANOREQUAL:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a >= b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_MIN:  						{  							if (stack.Count < 2)  								return false;  							Byte[] b = stack.Pop();  							Byte[] a = stack.Pop();  							if (new ScriptVarInt(a).value < new ScriptVarInt(b).value)  								stack.Push(a);  							else  								stack.Push(b);  							break;  						}  					case OpCode.OP_MAX:  						{  							if (stack.Count < 2)  								return false;  							Byte[] b = stack.Pop();  							Byte[] a = stack.Pop();  							if (new ScriptVarInt(a).value > new ScriptVarInt(b).value)  								stack.Push(a);  							else  								stack.Push(b);  							break;  						}  					case OpCode.OP_WITHIN:  						{  							if (stack.Count < 3)  								return false;  							ScriptVarInt max = new ScriptVarInt(stack.Pop());  							ScriptVarInt min = new ScriptVarInt(stack.Pop());  							ScriptVarInt x = new ScriptVarInt(stack.Pop());  							if ((BigInteger)min <= x && (BigInteger)x <= max)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_RIPEMD160:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(ripemd160.ComputeHash(stack.Pop()));  							break;  						}  					case OpCode.OP_SHA1:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(sha1.ComputeHash(stack.Pop()));  							break;  						}  					case OpCode.OP_SHA256:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(sha256.ComputeHash(stack.Pop()));  							break;  						}  					case OpCode.OP_HASH160:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(ripemd160.ComputeHash(sha256.ComputeHash(stack.Pop())));  							break;  						}  					case OpCode.OP_HASH256:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(sha256.ComputeHash(sha256.ComputeHash(stack.Pop())));  							break;  						}  					case OpCode.OP_CODESEPARATOR:  						{  							lastCodeSeperator = index;  							break;  						}  					case OpCode.OP_CHECKSIG:  					case OpCode.OP_CHECKSIGVERIFY:  						{  							if (tx == null)  								throw new ArgumentNullException("Transaction is required if script contains OP_CHECKSIG[VERIFY]");  							if (stack.Count < 2)  								return false;    							PublicKey pubKey = new PublicKey(stack.Pop());  							Byte[] sig = stack.Pop();    							Script subScript = new Script(elements.Skip(lastCodeSeperator)  								.Where(x => x.opCode != OpCode.OP_CODESEPARATOR).ToArray());    							stack.Push(new ScriptVarInt(CheckSig(sig' pubKey' txInIndex' subScript' tx) ? 1 : 0).ToBytes());    							if (se.opCode == OpCode.OP_CHECKSIGVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_CHECKMULTISIG:  					case OpCode.OP_CHECKMULTISIGVERIFY:  						{  							if (tx == null)  								throw new ArgumentNullException("Transaction is required if script contains OP_CHECKMULTISIG[VERIFY]");  							if (stack.Count < 2)  								return false;    							PublicKey[] pubKeys = new PublicKey[new ScriptVarInt(stack.Pop()).intValue];    							if (stack.Count < pubKeys.Length + 1)  								return false;    							for (int i = 0; i < pubKeys.Length; i++)  							{  								pubKeys[i] = new PublicKey(stack.Pop());  							}    							Byte[][] sigs = new Byte[new ScriptVarInt(stack.Pop()).intValue][];    							if (stack.Count < sigs.Length)  								return false;    							for (int i = 0; i < sigs.Length; i++)  							{  								sigs[i] = stack.Pop();  							}    							// Remove extra unused value from stack  							stack.Pop();    							Script subScript = new Script(elements.Skip(lastCodeSeperator)  								.Where(x => x.opCode != OpCode.OP_CODESEPARATOR).ToArray());    							int validSigs = 0;  							foreach (Byte[] sig in sigs)  							{  								foreach (PublicKey pubKey in pubKeys)  								{  									if (CheckSig(sig' pubKey' txInIndex' subScript' tx))  									{  										pubKeys = pubKeys.Where(x => x != pubKey).ToArray();  										validSigs++;  										break;  									}  								}  							}    							stack.Push(new ScriptVarInt((validSigs >= sigs.Length) ? 1 : 0).ToBytes());    							if (se.opCode == OpCode.OP_CHECKMULTISIGVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_NOP1:  					case OpCode.OP_NOP2:  					case OpCode.OP_NOP3:  					case OpCode.OP_NOP4:  					case OpCode.OP_NOP5:  					case OpCode.OP_NOP6:  					case OpCode.OP_NOP7:  					case OpCode.OP_NOP8:  					case OpCode.OP_NOP9:  					case OpCode.OP_NOP10:  						{  							break;  						}  					case OpCode.OP_SMALLINTEGER:  					case OpCode.OP_PUBKEYS:  					case OpCode.OP_PUBKEYHASH:  					case OpCode.OP_PUBKEY:  					case OpCode.OP_INVALIDOPCODE:  					default:  						{  							return false;  						}    				}  			}
Magic Number,Bitcoin_Tool.Scripts,Script,C:\repos\mb300sd_Bitcoin-Tool\Bitcoin Tool\Scripts\Script.cs,Evaluate,The following statement contains a magic number: for (int index = 0; index < elements.Count; index++)  			{  				ScriptElement se = elements[index];  				if (ifExec.Count > 0)  					if ((ifExec.First() == IfElseExec.SKIP_IF && !(se.opCode == OpCode.OP_ELSE || se.opCode == OpCode.OP_ENDIF)) ||  						(ifExec.First() == IfElseExec.SKIP_ELSE && !(se.opCode == OpCode.OP_ENDIF)))  						continue;    				if (se.isData)  				{  					stack.Push(se.data);  					continue;  				}    				switch (se.opCode)  				{  					case OpCode.OP_RESERVED:  						{  							return false;  						}  					case OpCode.OP_NOP:  						{  							// NOP' Dump stack for debug  							/*  							stack.ToList().ForEach(x => Console.WriteLine(HexString.FromByteArray(x)));  							Console.WriteLine("---------------------------");  							*/  							break;  						}  					case OpCode.OP_VER:  						{  							return false;  						}  					case OpCode.OP_IF:  					case OpCode.OP_NOTIF:  						{  							if (stack.Count < 1)  								return false;  							Boolean stackIsZero = new ScriptVarInt(stack.Pop()).value.IsZero;  							if ((se.opCode == OpCode.OP_IF && !stackIsZero) || (se.opCode == OpCode.OP_NOTIF && stackIsZero))  							{  								// Run to else or endif  								ifExec.Push(IfElseExec.RUN_IF);  							}  							else  							{  								// Skip to else or endif  								ifExec.Push(IfElseExec.SKIP_IF);  							}  							break;  						}  					case OpCode.OP_VERIF:  					case OpCode.OP_VERNOTIF:  						{  							return false;  						}  					case OpCode.OP_ELSE:  						{  							if (ifExec.Count == 0)  								// No preceding if statement!  								return false;  							if (ifExec.First() == IfElseExec.RUN_IF)  							{  								// If ran' skip else  								ifExec.Push(IfElseExec.SKIP_ELSE);  							}  							else if (ifExec.First() == IfElseExec.SKIP_IF)  							{  								// If did not run' run else  								ifExec.Push(IfElseExec.RUN_ELSE);  							}  							break;  						}  					case OpCode.OP_ENDIF:  						{  							if (ifExec.Count == 0)  								// No preceding if statement!  								return false;  							if (ifExec.First() == IfElseExec.RUN_IF ||  								ifExec.First() == IfElseExec.SKIP_IF)  							{  								ifExec.Pop();  							}  							else if (ifExec.First() == IfElseExec.RUN_ELSE ||  							   ifExec.First() == IfElseExec.SKIP_ELSE)  							{  								ifExec.Pop();  								ifExec.Pop();  							}  							break;  						}  					case OpCode.OP_VERIFY:  						{  							if (stack.Count < 1 || new ScriptVarInt(stack.First()).value.IsZero)  								return false;  							stack.Pop();  							break;  						}  					case OpCode.OP_RETURN:  						{  							return false;  						}  					case OpCode.OP_TOALTSTACK:  						{  							if (stack.Count < 1)  								return false;  							altstack.Push(stack.Pop());  							break;  						}  					case OpCode.OP_FROMALTSTACK:  						{  							if (altstack.Count < 1)  								return false;  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_2DROP:  						{  							if (stack.Count < 2)  								return false;  							stack.Pop();  							stack.Pop();  							break;  						}  					case OpCode.OP_2DUP:  						{  							if (stack.Count < 2)  								return false;  							stack.Push(stack.Skip(1).First());  							stack.Push(stack.Skip(1).First());  							break;  						}  					case OpCode.OP_3DUP:  						{  							if (stack.Count < 3)  								return false;  							stack.Push(stack.Skip(2).First());  							stack.Push(stack.Skip(2).First());  							stack.Push(stack.Skip(2).First());  							break;  						}  					case OpCode.OP_2OVER:  						{  							if (stack.Count < 4)  								return false;  							stack.Push(stack.Skip(3).First());  							stack.Push(stack.Skip(3).First());  							break;  						}  					case OpCode.OP_2ROT:  						{  							if (stack.Count < 6)  								return false;  							altstack.Push(stack.Skip(4).First());  							altstack.Push(stack.Skip(5).First());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_2SWAP:  						{  							if (stack.Count < 4)  								return false;  							altstack.Push(stack.Skip(2).First());  							altstack.Push(stack.Skip(3).First());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_IFDUP:  						{  							if (stack.Count < 1)  								return false;  							if (!new ScriptVarInt(stack.First()).value.IsZero)  								stack.Push(stack.First());  							break;  						}  					case OpCode.OP_DEPTH:  						{  							stack.Push(new ScriptVarInt((UInt64)stack.Count).ToBytes());  							break;  						}  					case OpCode.OP_DROP:  						{  							if (stack.Count < 1)  								return false;  							stack.Pop();  							break;  						}  					case OpCode.OP_DUP:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(stack.First());  							break;  						}  					case OpCode.OP_NIP:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_OVER:  						{  							if (stack.Count < 2)  								return false;  							stack.Push(stack.Skip(1).First());  							break;  						}  					case OpCode.OP_PICK:  						{  							if (stack.Count < 2)  								return false;  							int pick = new ScriptVarInt(stack.Pop()).intValue;  							if (pick < 0 || stack.Count <= pick)  								return false;  							stack.Push(stack.Skip(pick).First());  							break;  						}  					case OpCode.OP_ROLL:  						{  							if (stack.Count < 2)  								return false;  							int roll = new ScriptVarInt(stack.Pop()).intValue;  							if (roll < 0 || stack.Count <= roll)  								return false;  							altstack.Push(stack.Skip(roll).First());  							for (int i = 0; i < roll; i++)  								altstack.Push(stack.Pop());  							stack.Pop();  							for (int i = 0; i < roll + 1; i++)  								stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_ROT:  						{  							if (stack.Count < 3)  								return false;  							altstack.Push(stack.Skip(2).First());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_SWAP:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Skip(1).First());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_TUCK:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Push(altstack.Skip(1).First());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_CAT:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Skip(1).First().Concat(stack.First()).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_SUBSTR:  						{  							if (stack.Count < 3)  								return false;  							altstack.Push(stack.Skip(2).First()  								.Skip(new ScriptVarInt(stack.Skip(1).First()).intValue)  								.Take(new ScriptVarInt(stack.First()).intValue).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_LEFT:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Skip(1).First()  								.Take(new ScriptVarInt(stack.First()).intValue).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_RIGHT:  						{  							if (stack.Count < 2)  								return false;  							int count = new ScriptVarInt(stack.First()).intValue;  							altstack.Push(stack.Skip(1).First()  								.Skip(stack.Skip(1).First().Length - count).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_SIZE:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(new ScriptVarInt((UInt64)stack.First().Length).ToBytes());  							break;  						}  					case OpCode.OP_INVERT:  						{  							if (stack.Count < 1)  								return false;  							Byte[] data = stack.Pop();  							for (int i = 0; i < data.Length; i++)  								data[i] ^= 0xFF;  							stack.Push(data);  							break;  						}  					case OpCode.OP_AND:  					case OpCode.OP_OR:  					case OpCode.OP_XOR:  						{  							if (stack.Count < 2)  								return false;  							Byte[] data = stack.Pop();  							Byte[] data2 = stack.Pop();  							int length = new int[] { data.Length' data2.Length }.Max();  							data = data.Concat(new Byte[length - data.Length]).ToArray();  							data2 = data2.Concat(new Byte[length - data2.Length]).ToArray();  							switch (se.opCode)  							{  								case OpCode.OP_AND:  									{  										for (int i = 0; i < length; i++)  											data[i] &= data2[i];  										break;  									}  								case OpCode.OP_OR:  									{  										for (int i = 0; i < length; i++)  											data[i] |= data2[i];  										break;  									}  								case OpCode.OP_XOR:  									{  										for (int i = 0; i < length; i++)  											data[i] ^= data2[i];  										break;  									}  							}  							stack.Push(data);  							break;  						}  					case OpCode.OP_EQUAL:  					case OpCode.OP_EQUALVERIFY:  						{  							if (stack.Count < 2)  								return false;  							if (stack.Pop().SequenceEqual(stack.Pop()))  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });    							if (se.opCode == OpCode.OP_EQUALVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_RESERVED1:  					case OpCode.OP_RESERVED2:  						{  							return false;  						}  					case OpCode.OP_1ADD:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Add(new ScriptVarInt(stack.Pop())' 1)).ToBytes());  							break;  						}  					case OpCode.OP_1SUB:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Subtract(new ScriptVarInt(stack.Pop())' 1)).ToBytes());  							break;  						}  					case OpCode.OP_2MUL:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Multiply(new ScriptVarInt(stack.Pop())' 2)).ToBytes());  							break;  						}  					case OpCode.OP_2DIV:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Divide(new ScriptVarInt(stack.Pop())' 2)).ToBytes());  							break;  						}  					case OpCode.OP_NEGATE:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Negate(new ScriptVarInt(stack.Pop()))).ToBytes());  							break;  						}  					case OpCode.OP_ABS:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Abs(new ScriptVarInt(stack.Pop()))).ToBytes());  							break;  						}  					case OpCode.OP_NOT:  						{  							if (stack.Count < 1)  								return false;  							if (new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_0NOTEQUAL:  						{  							if (stack.Count < 1)  								return false;  							if (new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x00 });  							else  								stack.Push(new Byte[] { 0x01 });  							break;  						}  					case OpCode.OP_ADD:  					case OpCode.OP_SUB:  					case OpCode.OP_MUL:  					case OpCode.OP_DIV:  					case OpCode.OP_MOD:  					case OpCode.OP_LSHIFT:  					case OpCode.OP_RSHIFT:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							switch (se.opCode)  							{  								case OpCode.OP_ADD:  									a = (BigInteger)a + b;  									break;  								case OpCode.OP_SUB:  									a = (BigInteger)a - b;  									break;  								case OpCode.OP_MUL:  									a = (BigInteger)a * b;  									break;  								case OpCode.OP_DIV:  									a = (BigInteger)a / b;  									break;  								case OpCode.OP_MOD:  									a = (BigInteger)a % b;  									break;  								case OpCode.OP_LSHIFT:  									a = (BigInteger)a << b.intValue;  									break;  								case OpCode.OP_RSHIFT:  									a = (BigInteger)a >> b.intValue;  									break;  							}  							stack.Push(a.ToBytes());  							break;  						}  					case OpCode.OP_BOOLAND:  						{  							if (stack.Count < 2)  								return false;  							if (!new ScriptVarInt(stack.Pop()).value.IsZero && !new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_BOOLOR:  						{  							if (stack.Count < 2)  								return false;  							if (!new ScriptVarInt(stack.Pop()).value.IsZero || !new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_NUMEQUAL:  					case OpCode.OP_NUMEQUALVERIFY:  						{  							if (stack.Count < 2)  								return false;  							if (new ScriptVarInt(stack.Pop()).value == new ScriptVarInt(stack.Pop()).value)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							if (se.opCode == OpCode.OP_NUMEQUALVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_NUMNOTEQUAL:  						{  							if (stack.Count < 2)  								return false;  							if (new ScriptVarInt(stack.Pop()).value != new ScriptVarInt(stack.Pop()).value)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_LESSTHAN:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a < b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_GREATERTHAN:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a > b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_LESSTHANOREQUAL:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a <= b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_GREATERTHANOREQUAL:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a >= b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_MIN:  						{  							if (stack.Count < 2)  								return false;  							Byte[] b = stack.Pop();  							Byte[] a = stack.Pop();  							if (new ScriptVarInt(a).value < new ScriptVarInt(b).value)  								stack.Push(a);  							else  								stack.Push(b);  							break;  						}  					case OpCode.OP_MAX:  						{  							if (stack.Count < 2)  								return false;  							Byte[] b = stack.Pop();  							Byte[] a = stack.Pop();  							if (new ScriptVarInt(a).value > new ScriptVarInt(b).value)  								stack.Push(a);  							else  								stack.Push(b);  							break;  						}  					case OpCode.OP_WITHIN:  						{  							if (stack.Count < 3)  								return false;  							ScriptVarInt max = new ScriptVarInt(stack.Pop());  							ScriptVarInt min = new ScriptVarInt(stack.Pop());  							ScriptVarInt x = new ScriptVarInt(stack.Pop());  							if ((BigInteger)min <= x && (BigInteger)x <= max)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_RIPEMD160:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(ripemd160.ComputeHash(stack.Pop()));  							break;  						}  					case OpCode.OP_SHA1:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(sha1.ComputeHash(stack.Pop()));  							break;  						}  					case OpCode.OP_SHA256:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(sha256.ComputeHash(stack.Pop()));  							break;  						}  					case OpCode.OP_HASH160:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(ripemd160.ComputeHash(sha256.ComputeHash(stack.Pop())));  							break;  						}  					case OpCode.OP_HASH256:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(sha256.ComputeHash(sha256.ComputeHash(stack.Pop())));  							break;  						}  					case OpCode.OP_CODESEPARATOR:  						{  							lastCodeSeperator = index;  							break;  						}  					case OpCode.OP_CHECKSIG:  					case OpCode.OP_CHECKSIGVERIFY:  						{  							if (tx == null)  								throw new ArgumentNullException("Transaction is required if script contains OP_CHECKSIG[VERIFY]");  							if (stack.Count < 2)  								return false;    							PublicKey pubKey = new PublicKey(stack.Pop());  							Byte[] sig = stack.Pop();    							Script subScript = new Script(elements.Skip(lastCodeSeperator)  								.Where(x => x.opCode != OpCode.OP_CODESEPARATOR).ToArray());    							stack.Push(new ScriptVarInt(CheckSig(sig' pubKey' txInIndex' subScript' tx) ? 1 : 0).ToBytes());    							if (se.opCode == OpCode.OP_CHECKSIGVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_CHECKMULTISIG:  					case OpCode.OP_CHECKMULTISIGVERIFY:  						{  							if (tx == null)  								throw new ArgumentNullException("Transaction is required if script contains OP_CHECKMULTISIG[VERIFY]");  							if (stack.Count < 2)  								return false;    							PublicKey[] pubKeys = new PublicKey[new ScriptVarInt(stack.Pop()).intValue];    							if (stack.Count < pubKeys.Length + 1)  								return false;    							for (int i = 0; i < pubKeys.Length; i++)  							{  								pubKeys[i] = new PublicKey(stack.Pop());  							}    							Byte[][] sigs = new Byte[new ScriptVarInt(stack.Pop()).intValue][];    							if (stack.Count < sigs.Length)  								return false;    							for (int i = 0; i < sigs.Length; i++)  							{  								sigs[i] = stack.Pop();  							}    							// Remove extra unused value from stack  							stack.Pop();    							Script subScript = new Script(elements.Skip(lastCodeSeperator)  								.Where(x => x.opCode != OpCode.OP_CODESEPARATOR).ToArray());    							int validSigs = 0;  							foreach (Byte[] sig in sigs)  							{  								foreach (PublicKey pubKey in pubKeys)  								{  									if (CheckSig(sig' pubKey' txInIndex' subScript' tx))  									{  										pubKeys = pubKeys.Where(x => x != pubKey).ToArray();  										validSigs++;  										break;  									}  								}  							}    							stack.Push(new ScriptVarInt((validSigs >= sigs.Length) ? 1 : 0).ToBytes());    							if (se.opCode == OpCode.OP_CHECKMULTISIGVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_NOP1:  					case OpCode.OP_NOP2:  					case OpCode.OP_NOP3:  					case OpCode.OP_NOP4:  					case OpCode.OP_NOP5:  					case OpCode.OP_NOP6:  					case OpCode.OP_NOP7:  					case OpCode.OP_NOP8:  					case OpCode.OP_NOP9:  					case OpCode.OP_NOP10:  						{  							break;  						}  					case OpCode.OP_SMALLINTEGER:  					case OpCode.OP_PUBKEYS:  					case OpCode.OP_PUBKEYHASH:  					case OpCode.OP_PUBKEY:  					case OpCode.OP_INVALIDOPCODE:  					default:  						{  							return false;  						}    				}  			}
Magic Number,Bitcoin_Tool.Scripts,Script,C:\repos\mb300sd_Bitcoin-Tool\Bitcoin Tool\Scripts\Script.cs,Evaluate,The following statement contains a magic number: for (int index = 0; index < elements.Count; index++)  			{  				ScriptElement se = elements[index];  				if (ifExec.Count > 0)  					if ((ifExec.First() == IfElseExec.SKIP_IF && !(se.opCode == OpCode.OP_ELSE || se.opCode == OpCode.OP_ENDIF)) ||  						(ifExec.First() == IfElseExec.SKIP_ELSE && !(se.opCode == OpCode.OP_ENDIF)))  						continue;    				if (se.isData)  				{  					stack.Push(se.data);  					continue;  				}    				switch (se.opCode)  				{  					case OpCode.OP_RESERVED:  						{  							return false;  						}  					case OpCode.OP_NOP:  						{  							// NOP' Dump stack for debug  							/*  							stack.ToList().ForEach(x => Console.WriteLine(HexString.FromByteArray(x)));  							Console.WriteLine("---------------------------");  							*/  							break;  						}  					case OpCode.OP_VER:  						{  							return false;  						}  					case OpCode.OP_IF:  					case OpCode.OP_NOTIF:  						{  							if (stack.Count < 1)  								return false;  							Boolean stackIsZero = new ScriptVarInt(stack.Pop()).value.IsZero;  							if ((se.opCode == OpCode.OP_IF && !stackIsZero) || (se.opCode == OpCode.OP_NOTIF && stackIsZero))  							{  								// Run to else or endif  								ifExec.Push(IfElseExec.RUN_IF);  							}  							else  							{  								// Skip to else or endif  								ifExec.Push(IfElseExec.SKIP_IF);  							}  							break;  						}  					case OpCode.OP_VERIF:  					case OpCode.OP_VERNOTIF:  						{  							return false;  						}  					case OpCode.OP_ELSE:  						{  							if (ifExec.Count == 0)  								// No preceding if statement!  								return false;  							if (ifExec.First() == IfElseExec.RUN_IF)  							{  								// If ran' skip else  								ifExec.Push(IfElseExec.SKIP_ELSE);  							}  							else if (ifExec.First() == IfElseExec.SKIP_IF)  							{  								// If did not run' run else  								ifExec.Push(IfElseExec.RUN_ELSE);  							}  							break;  						}  					case OpCode.OP_ENDIF:  						{  							if (ifExec.Count == 0)  								// No preceding if statement!  								return false;  							if (ifExec.First() == IfElseExec.RUN_IF ||  								ifExec.First() == IfElseExec.SKIP_IF)  							{  								ifExec.Pop();  							}  							else if (ifExec.First() == IfElseExec.RUN_ELSE ||  							   ifExec.First() == IfElseExec.SKIP_ELSE)  							{  								ifExec.Pop();  								ifExec.Pop();  							}  							break;  						}  					case OpCode.OP_VERIFY:  						{  							if (stack.Count < 1 || new ScriptVarInt(stack.First()).value.IsZero)  								return false;  							stack.Pop();  							break;  						}  					case OpCode.OP_RETURN:  						{  							return false;  						}  					case OpCode.OP_TOALTSTACK:  						{  							if (stack.Count < 1)  								return false;  							altstack.Push(stack.Pop());  							break;  						}  					case OpCode.OP_FROMALTSTACK:  						{  							if (altstack.Count < 1)  								return false;  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_2DROP:  						{  							if (stack.Count < 2)  								return false;  							stack.Pop();  							stack.Pop();  							break;  						}  					case OpCode.OP_2DUP:  						{  							if (stack.Count < 2)  								return false;  							stack.Push(stack.Skip(1).First());  							stack.Push(stack.Skip(1).First());  							break;  						}  					case OpCode.OP_3DUP:  						{  							if (stack.Count < 3)  								return false;  							stack.Push(stack.Skip(2).First());  							stack.Push(stack.Skip(2).First());  							stack.Push(stack.Skip(2).First());  							break;  						}  					case OpCode.OP_2OVER:  						{  							if (stack.Count < 4)  								return false;  							stack.Push(stack.Skip(3).First());  							stack.Push(stack.Skip(3).First());  							break;  						}  					case OpCode.OP_2ROT:  						{  							if (stack.Count < 6)  								return false;  							altstack.Push(stack.Skip(4).First());  							altstack.Push(stack.Skip(5).First());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_2SWAP:  						{  							if (stack.Count < 4)  								return false;  							altstack.Push(stack.Skip(2).First());  							altstack.Push(stack.Skip(3).First());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_IFDUP:  						{  							if (stack.Count < 1)  								return false;  							if (!new ScriptVarInt(stack.First()).value.IsZero)  								stack.Push(stack.First());  							break;  						}  					case OpCode.OP_DEPTH:  						{  							stack.Push(new ScriptVarInt((UInt64)stack.Count).ToBytes());  							break;  						}  					case OpCode.OP_DROP:  						{  							if (stack.Count < 1)  								return false;  							stack.Pop();  							break;  						}  					case OpCode.OP_DUP:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(stack.First());  							break;  						}  					case OpCode.OP_NIP:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_OVER:  						{  							if (stack.Count < 2)  								return false;  							stack.Push(stack.Skip(1).First());  							break;  						}  					case OpCode.OP_PICK:  						{  							if (stack.Count < 2)  								return false;  							int pick = new ScriptVarInt(stack.Pop()).intValue;  							if (pick < 0 || stack.Count <= pick)  								return false;  							stack.Push(stack.Skip(pick).First());  							break;  						}  					case OpCode.OP_ROLL:  						{  							if (stack.Count < 2)  								return false;  							int roll = new ScriptVarInt(stack.Pop()).intValue;  							if (roll < 0 || stack.Count <= roll)  								return false;  							altstack.Push(stack.Skip(roll).First());  							for (int i = 0; i < roll; i++)  								altstack.Push(stack.Pop());  							stack.Pop();  							for (int i = 0; i < roll + 1; i++)  								stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_ROT:  						{  							if (stack.Count < 3)  								return false;  							altstack.Push(stack.Skip(2).First());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_SWAP:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Skip(1).First());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_TUCK:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Push(altstack.Skip(1).First());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_CAT:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Skip(1).First().Concat(stack.First()).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_SUBSTR:  						{  							if (stack.Count < 3)  								return false;  							altstack.Push(stack.Skip(2).First()  								.Skip(new ScriptVarInt(stack.Skip(1).First()).intValue)  								.Take(new ScriptVarInt(stack.First()).intValue).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_LEFT:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Skip(1).First()  								.Take(new ScriptVarInt(stack.First()).intValue).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_RIGHT:  						{  							if (stack.Count < 2)  								return false;  							int count = new ScriptVarInt(stack.First()).intValue;  							altstack.Push(stack.Skip(1).First()  								.Skip(stack.Skip(1).First().Length - count).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_SIZE:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(new ScriptVarInt((UInt64)stack.First().Length).ToBytes());  							break;  						}  					case OpCode.OP_INVERT:  						{  							if (stack.Count < 1)  								return false;  							Byte[] data = stack.Pop();  							for (int i = 0; i < data.Length; i++)  								data[i] ^= 0xFF;  							stack.Push(data);  							break;  						}  					case OpCode.OP_AND:  					case OpCode.OP_OR:  					case OpCode.OP_XOR:  						{  							if (stack.Count < 2)  								return false;  							Byte[] data = stack.Pop();  							Byte[] data2 = stack.Pop();  							int length = new int[] { data.Length' data2.Length }.Max();  							data = data.Concat(new Byte[length - data.Length]).ToArray();  							data2 = data2.Concat(new Byte[length - data2.Length]).ToArray();  							switch (se.opCode)  							{  								case OpCode.OP_AND:  									{  										for (int i = 0; i < length; i++)  											data[i] &= data2[i];  										break;  									}  								case OpCode.OP_OR:  									{  										for (int i = 0; i < length; i++)  											data[i] |= data2[i];  										break;  									}  								case OpCode.OP_XOR:  									{  										for (int i = 0; i < length; i++)  											data[i] ^= data2[i];  										break;  									}  							}  							stack.Push(data);  							break;  						}  					case OpCode.OP_EQUAL:  					case OpCode.OP_EQUALVERIFY:  						{  							if (stack.Count < 2)  								return false;  							if (stack.Pop().SequenceEqual(stack.Pop()))  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });    							if (se.opCode == OpCode.OP_EQUALVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_RESERVED1:  					case OpCode.OP_RESERVED2:  						{  							return false;  						}  					case OpCode.OP_1ADD:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Add(new ScriptVarInt(stack.Pop())' 1)).ToBytes());  							break;  						}  					case OpCode.OP_1SUB:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Subtract(new ScriptVarInt(stack.Pop())' 1)).ToBytes());  							break;  						}  					case OpCode.OP_2MUL:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Multiply(new ScriptVarInt(stack.Pop())' 2)).ToBytes());  							break;  						}  					case OpCode.OP_2DIV:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Divide(new ScriptVarInt(stack.Pop())' 2)).ToBytes());  							break;  						}  					case OpCode.OP_NEGATE:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Negate(new ScriptVarInt(stack.Pop()))).ToBytes());  							break;  						}  					case OpCode.OP_ABS:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Abs(new ScriptVarInt(stack.Pop()))).ToBytes());  							break;  						}  					case OpCode.OP_NOT:  						{  							if (stack.Count < 1)  								return false;  							if (new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_0NOTEQUAL:  						{  							if (stack.Count < 1)  								return false;  							if (new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x00 });  							else  								stack.Push(new Byte[] { 0x01 });  							break;  						}  					case OpCode.OP_ADD:  					case OpCode.OP_SUB:  					case OpCode.OP_MUL:  					case OpCode.OP_DIV:  					case OpCode.OP_MOD:  					case OpCode.OP_LSHIFT:  					case OpCode.OP_RSHIFT:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							switch (se.opCode)  							{  								case OpCode.OP_ADD:  									a = (BigInteger)a + b;  									break;  								case OpCode.OP_SUB:  									a = (BigInteger)a - b;  									break;  								case OpCode.OP_MUL:  									a = (BigInteger)a * b;  									break;  								case OpCode.OP_DIV:  									a = (BigInteger)a / b;  									break;  								case OpCode.OP_MOD:  									a = (BigInteger)a % b;  									break;  								case OpCode.OP_LSHIFT:  									a = (BigInteger)a << b.intValue;  									break;  								case OpCode.OP_RSHIFT:  									a = (BigInteger)a >> b.intValue;  									break;  							}  							stack.Push(a.ToBytes());  							break;  						}  					case OpCode.OP_BOOLAND:  						{  							if (stack.Count < 2)  								return false;  							if (!new ScriptVarInt(stack.Pop()).value.IsZero && !new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_BOOLOR:  						{  							if (stack.Count < 2)  								return false;  							if (!new ScriptVarInt(stack.Pop()).value.IsZero || !new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_NUMEQUAL:  					case OpCode.OP_NUMEQUALVERIFY:  						{  							if (stack.Count < 2)  								return false;  							if (new ScriptVarInt(stack.Pop()).value == new ScriptVarInt(stack.Pop()).value)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							if (se.opCode == OpCode.OP_NUMEQUALVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_NUMNOTEQUAL:  						{  							if (stack.Count < 2)  								return false;  							if (new ScriptVarInt(stack.Pop()).value != new ScriptVarInt(stack.Pop()).value)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_LESSTHAN:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a < b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_GREATERTHAN:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a > b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_LESSTHANOREQUAL:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a <= b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_GREATERTHANOREQUAL:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a >= b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_MIN:  						{  							if (stack.Count < 2)  								return false;  							Byte[] b = stack.Pop();  							Byte[] a = stack.Pop();  							if (new ScriptVarInt(a).value < new ScriptVarInt(b).value)  								stack.Push(a);  							else  								stack.Push(b);  							break;  						}  					case OpCode.OP_MAX:  						{  							if (stack.Count < 2)  								return false;  							Byte[] b = stack.Pop();  							Byte[] a = stack.Pop();  							if (new ScriptVarInt(a).value > new ScriptVarInt(b).value)  								stack.Push(a);  							else  								stack.Push(b);  							break;  						}  					case OpCode.OP_WITHIN:  						{  							if (stack.Count < 3)  								return false;  							ScriptVarInt max = new ScriptVarInt(stack.Pop());  							ScriptVarInt min = new ScriptVarInt(stack.Pop());  							ScriptVarInt x = new ScriptVarInt(stack.Pop());  							if ((BigInteger)min <= x && (BigInteger)x <= max)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_RIPEMD160:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(ripemd160.ComputeHash(stack.Pop()));  							break;  						}  					case OpCode.OP_SHA1:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(sha1.ComputeHash(stack.Pop()));  							break;  						}  					case OpCode.OP_SHA256:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(sha256.ComputeHash(stack.Pop()));  							break;  						}  					case OpCode.OP_HASH160:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(ripemd160.ComputeHash(sha256.ComputeHash(stack.Pop())));  							break;  						}  					case OpCode.OP_HASH256:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(sha256.ComputeHash(sha256.ComputeHash(stack.Pop())));  							break;  						}  					case OpCode.OP_CODESEPARATOR:  						{  							lastCodeSeperator = index;  							break;  						}  					case OpCode.OP_CHECKSIG:  					case OpCode.OP_CHECKSIGVERIFY:  						{  							if (tx == null)  								throw new ArgumentNullException("Transaction is required if script contains OP_CHECKSIG[VERIFY]");  							if (stack.Count < 2)  								return false;    							PublicKey pubKey = new PublicKey(stack.Pop());  							Byte[] sig = stack.Pop();    							Script subScript = new Script(elements.Skip(lastCodeSeperator)  								.Where(x => x.opCode != OpCode.OP_CODESEPARATOR).ToArray());    							stack.Push(new ScriptVarInt(CheckSig(sig' pubKey' txInIndex' subScript' tx) ? 1 : 0).ToBytes());    							if (se.opCode == OpCode.OP_CHECKSIGVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_CHECKMULTISIG:  					case OpCode.OP_CHECKMULTISIGVERIFY:  						{  							if (tx == null)  								throw new ArgumentNullException("Transaction is required if script contains OP_CHECKMULTISIG[VERIFY]");  							if (stack.Count < 2)  								return false;    							PublicKey[] pubKeys = new PublicKey[new ScriptVarInt(stack.Pop()).intValue];    							if (stack.Count < pubKeys.Length + 1)  								return false;    							for (int i = 0; i < pubKeys.Length; i++)  							{  								pubKeys[i] = new PublicKey(stack.Pop());  							}    							Byte[][] sigs = new Byte[new ScriptVarInt(stack.Pop()).intValue][];    							if (stack.Count < sigs.Length)  								return false;    							for (int i = 0; i < sigs.Length; i++)  							{  								sigs[i] = stack.Pop();  							}    							// Remove extra unused value from stack  							stack.Pop();    							Script subScript = new Script(elements.Skip(lastCodeSeperator)  								.Where(x => x.opCode != OpCode.OP_CODESEPARATOR).ToArray());    							int validSigs = 0;  							foreach (Byte[] sig in sigs)  							{  								foreach (PublicKey pubKey in pubKeys)  								{  									if (CheckSig(sig' pubKey' txInIndex' subScript' tx))  									{  										pubKeys = pubKeys.Where(x => x != pubKey).ToArray();  										validSigs++;  										break;  									}  								}  							}    							stack.Push(new ScriptVarInt((validSigs >= sigs.Length) ? 1 : 0).ToBytes());    							if (se.opCode == OpCode.OP_CHECKMULTISIGVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_NOP1:  					case OpCode.OP_NOP2:  					case OpCode.OP_NOP3:  					case OpCode.OP_NOP4:  					case OpCode.OP_NOP5:  					case OpCode.OP_NOP6:  					case OpCode.OP_NOP7:  					case OpCode.OP_NOP8:  					case OpCode.OP_NOP9:  					case OpCode.OP_NOP10:  						{  							break;  						}  					case OpCode.OP_SMALLINTEGER:  					case OpCode.OP_PUBKEYS:  					case OpCode.OP_PUBKEYHASH:  					case OpCode.OP_PUBKEY:  					case OpCode.OP_INVALIDOPCODE:  					default:  						{  							return false;  						}    				}  			}
Magic Number,Bitcoin_Tool.Scripts,Script,C:\repos\mb300sd_Bitcoin-Tool\Bitcoin Tool\Scripts\Script.cs,Evaluate,The following statement contains a magic number: for (int index = 0; index < elements.Count; index++)  			{  				ScriptElement se = elements[index];  				if (ifExec.Count > 0)  					if ((ifExec.First() == IfElseExec.SKIP_IF && !(se.opCode == OpCode.OP_ELSE || se.opCode == OpCode.OP_ENDIF)) ||  						(ifExec.First() == IfElseExec.SKIP_ELSE && !(se.opCode == OpCode.OP_ENDIF)))  						continue;    				if (se.isData)  				{  					stack.Push(se.data);  					continue;  				}    				switch (se.opCode)  				{  					case OpCode.OP_RESERVED:  						{  							return false;  						}  					case OpCode.OP_NOP:  						{  							// NOP' Dump stack for debug  							/*  							stack.ToList().ForEach(x => Console.WriteLine(HexString.FromByteArray(x)));  							Console.WriteLine("---------------------------");  							*/  							break;  						}  					case OpCode.OP_VER:  						{  							return false;  						}  					case OpCode.OP_IF:  					case OpCode.OP_NOTIF:  						{  							if (stack.Count < 1)  								return false;  							Boolean stackIsZero = new ScriptVarInt(stack.Pop()).value.IsZero;  							if ((se.opCode == OpCode.OP_IF && !stackIsZero) || (se.opCode == OpCode.OP_NOTIF && stackIsZero))  							{  								// Run to else or endif  								ifExec.Push(IfElseExec.RUN_IF);  							}  							else  							{  								// Skip to else or endif  								ifExec.Push(IfElseExec.SKIP_IF);  							}  							break;  						}  					case OpCode.OP_VERIF:  					case OpCode.OP_VERNOTIF:  						{  							return false;  						}  					case OpCode.OP_ELSE:  						{  							if (ifExec.Count == 0)  								// No preceding if statement!  								return false;  							if (ifExec.First() == IfElseExec.RUN_IF)  							{  								// If ran' skip else  								ifExec.Push(IfElseExec.SKIP_ELSE);  							}  							else if (ifExec.First() == IfElseExec.SKIP_IF)  							{  								// If did not run' run else  								ifExec.Push(IfElseExec.RUN_ELSE);  							}  							break;  						}  					case OpCode.OP_ENDIF:  						{  							if (ifExec.Count == 0)  								// No preceding if statement!  								return false;  							if (ifExec.First() == IfElseExec.RUN_IF ||  								ifExec.First() == IfElseExec.SKIP_IF)  							{  								ifExec.Pop();  							}  							else if (ifExec.First() == IfElseExec.RUN_ELSE ||  							   ifExec.First() == IfElseExec.SKIP_ELSE)  							{  								ifExec.Pop();  								ifExec.Pop();  							}  							break;  						}  					case OpCode.OP_VERIFY:  						{  							if (stack.Count < 1 || new ScriptVarInt(stack.First()).value.IsZero)  								return false;  							stack.Pop();  							break;  						}  					case OpCode.OP_RETURN:  						{  							return false;  						}  					case OpCode.OP_TOALTSTACK:  						{  							if (stack.Count < 1)  								return false;  							altstack.Push(stack.Pop());  							break;  						}  					case OpCode.OP_FROMALTSTACK:  						{  							if (altstack.Count < 1)  								return false;  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_2DROP:  						{  							if (stack.Count < 2)  								return false;  							stack.Pop();  							stack.Pop();  							break;  						}  					case OpCode.OP_2DUP:  						{  							if (stack.Count < 2)  								return false;  							stack.Push(stack.Skip(1).First());  							stack.Push(stack.Skip(1).First());  							break;  						}  					case OpCode.OP_3DUP:  						{  							if (stack.Count < 3)  								return false;  							stack.Push(stack.Skip(2).First());  							stack.Push(stack.Skip(2).First());  							stack.Push(stack.Skip(2).First());  							break;  						}  					case OpCode.OP_2OVER:  						{  							if (stack.Count < 4)  								return false;  							stack.Push(stack.Skip(3).First());  							stack.Push(stack.Skip(3).First());  							break;  						}  					case OpCode.OP_2ROT:  						{  							if (stack.Count < 6)  								return false;  							altstack.Push(stack.Skip(4).First());  							altstack.Push(stack.Skip(5).First());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_2SWAP:  						{  							if (stack.Count < 4)  								return false;  							altstack.Push(stack.Skip(2).First());  							altstack.Push(stack.Skip(3).First());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_IFDUP:  						{  							if (stack.Count < 1)  								return false;  							if (!new ScriptVarInt(stack.First()).value.IsZero)  								stack.Push(stack.First());  							break;  						}  					case OpCode.OP_DEPTH:  						{  							stack.Push(new ScriptVarInt((UInt64)stack.Count).ToBytes());  							break;  						}  					case OpCode.OP_DROP:  						{  							if (stack.Count < 1)  								return false;  							stack.Pop();  							break;  						}  					case OpCode.OP_DUP:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(stack.First());  							break;  						}  					case OpCode.OP_NIP:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_OVER:  						{  							if (stack.Count < 2)  								return false;  							stack.Push(stack.Skip(1).First());  							break;  						}  					case OpCode.OP_PICK:  						{  							if (stack.Count < 2)  								return false;  							int pick = new ScriptVarInt(stack.Pop()).intValue;  							if (pick < 0 || stack.Count <= pick)  								return false;  							stack.Push(stack.Skip(pick).First());  							break;  						}  					case OpCode.OP_ROLL:  						{  							if (stack.Count < 2)  								return false;  							int roll = new ScriptVarInt(stack.Pop()).intValue;  							if (roll < 0 || stack.Count <= roll)  								return false;  							altstack.Push(stack.Skip(roll).First());  							for (int i = 0; i < roll; i++)  								altstack.Push(stack.Pop());  							stack.Pop();  							for (int i = 0; i < roll + 1; i++)  								stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_ROT:  						{  							if (stack.Count < 3)  								return false;  							altstack.Push(stack.Skip(2).First());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_SWAP:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Skip(1).First());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_TUCK:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Push(altstack.Skip(1).First());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_CAT:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Skip(1).First().Concat(stack.First()).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_SUBSTR:  						{  							if (stack.Count < 3)  								return false;  							altstack.Push(stack.Skip(2).First()  								.Skip(new ScriptVarInt(stack.Skip(1).First()).intValue)  								.Take(new ScriptVarInt(stack.First()).intValue).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_LEFT:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Skip(1).First()  								.Take(new ScriptVarInt(stack.First()).intValue).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_RIGHT:  						{  							if (stack.Count < 2)  								return false;  							int count = new ScriptVarInt(stack.First()).intValue;  							altstack.Push(stack.Skip(1).First()  								.Skip(stack.Skip(1).First().Length - count).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_SIZE:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(new ScriptVarInt((UInt64)stack.First().Length).ToBytes());  							break;  						}  					case OpCode.OP_INVERT:  						{  							if (stack.Count < 1)  								return false;  							Byte[] data = stack.Pop();  							for (int i = 0; i < data.Length; i++)  								data[i] ^= 0xFF;  							stack.Push(data);  							break;  						}  					case OpCode.OP_AND:  					case OpCode.OP_OR:  					case OpCode.OP_XOR:  						{  							if (stack.Count < 2)  								return false;  							Byte[] data = stack.Pop();  							Byte[] data2 = stack.Pop();  							int length = new int[] { data.Length' data2.Length }.Max();  							data = data.Concat(new Byte[length - data.Length]).ToArray();  							data2 = data2.Concat(new Byte[length - data2.Length]).ToArray();  							switch (se.opCode)  							{  								case OpCode.OP_AND:  									{  										for (int i = 0; i < length; i++)  											data[i] &= data2[i];  										break;  									}  								case OpCode.OP_OR:  									{  										for (int i = 0; i < length; i++)  											data[i] |= data2[i];  										break;  									}  								case OpCode.OP_XOR:  									{  										for (int i = 0; i < length; i++)  											data[i] ^= data2[i];  										break;  									}  							}  							stack.Push(data);  							break;  						}  					case OpCode.OP_EQUAL:  					case OpCode.OP_EQUALVERIFY:  						{  							if (stack.Count < 2)  								return false;  							if (stack.Pop().SequenceEqual(stack.Pop()))  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });    							if (se.opCode == OpCode.OP_EQUALVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_RESERVED1:  					case OpCode.OP_RESERVED2:  						{  							return false;  						}  					case OpCode.OP_1ADD:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Add(new ScriptVarInt(stack.Pop())' 1)).ToBytes());  							break;  						}  					case OpCode.OP_1SUB:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Subtract(new ScriptVarInt(stack.Pop())' 1)).ToBytes());  							break;  						}  					case OpCode.OP_2MUL:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Multiply(new ScriptVarInt(stack.Pop())' 2)).ToBytes());  							break;  						}  					case OpCode.OP_2DIV:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Divide(new ScriptVarInt(stack.Pop())' 2)).ToBytes());  							break;  						}  					case OpCode.OP_NEGATE:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Negate(new ScriptVarInt(stack.Pop()))).ToBytes());  							break;  						}  					case OpCode.OP_ABS:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Abs(new ScriptVarInt(stack.Pop()))).ToBytes());  							break;  						}  					case OpCode.OP_NOT:  						{  							if (stack.Count < 1)  								return false;  							if (new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_0NOTEQUAL:  						{  							if (stack.Count < 1)  								return false;  							if (new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x00 });  							else  								stack.Push(new Byte[] { 0x01 });  							break;  						}  					case OpCode.OP_ADD:  					case OpCode.OP_SUB:  					case OpCode.OP_MUL:  					case OpCode.OP_DIV:  					case OpCode.OP_MOD:  					case OpCode.OP_LSHIFT:  					case OpCode.OP_RSHIFT:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							switch (se.opCode)  							{  								case OpCode.OP_ADD:  									a = (BigInteger)a + b;  									break;  								case OpCode.OP_SUB:  									a = (BigInteger)a - b;  									break;  								case OpCode.OP_MUL:  									a = (BigInteger)a * b;  									break;  								case OpCode.OP_DIV:  									a = (BigInteger)a / b;  									break;  								case OpCode.OP_MOD:  									a = (BigInteger)a % b;  									break;  								case OpCode.OP_LSHIFT:  									a = (BigInteger)a << b.intValue;  									break;  								case OpCode.OP_RSHIFT:  									a = (BigInteger)a >> b.intValue;  									break;  							}  							stack.Push(a.ToBytes());  							break;  						}  					case OpCode.OP_BOOLAND:  						{  							if (stack.Count < 2)  								return false;  							if (!new ScriptVarInt(stack.Pop()).value.IsZero && !new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_BOOLOR:  						{  							if (stack.Count < 2)  								return false;  							if (!new ScriptVarInt(stack.Pop()).value.IsZero || !new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_NUMEQUAL:  					case OpCode.OP_NUMEQUALVERIFY:  						{  							if (stack.Count < 2)  								return false;  							if (new ScriptVarInt(stack.Pop()).value == new ScriptVarInt(stack.Pop()).value)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							if (se.opCode == OpCode.OP_NUMEQUALVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_NUMNOTEQUAL:  						{  							if (stack.Count < 2)  								return false;  							if (new ScriptVarInt(stack.Pop()).value != new ScriptVarInt(stack.Pop()).value)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_LESSTHAN:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a < b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_GREATERTHAN:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a > b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_LESSTHANOREQUAL:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a <= b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_GREATERTHANOREQUAL:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a >= b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_MIN:  						{  							if (stack.Count < 2)  								return false;  							Byte[] b = stack.Pop();  							Byte[] a = stack.Pop();  							if (new ScriptVarInt(a).value < new ScriptVarInt(b).value)  								stack.Push(a);  							else  								stack.Push(b);  							break;  						}  					case OpCode.OP_MAX:  						{  							if (stack.Count < 2)  								return false;  							Byte[] b = stack.Pop();  							Byte[] a = stack.Pop();  							if (new ScriptVarInt(a).value > new ScriptVarInt(b).value)  								stack.Push(a);  							else  								stack.Push(b);  							break;  						}  					case OpCode.OP_WITHIN:  						{  							if (stack.Count < 3)  								return false;  							ScriptVarInt max = new ScriptVarInt(stack.Pop());  							ScriptVarInt min = new ScriptVarInt(stack.Pop());  							ScriptVarInt x = new ScriptVarInt(stack.Pop());  							if ((BigInteger)min <= x && (BigInteger)x <= max)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_RIPEMD160:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(ripemd160.ComputeHash(stack.Pop()));  							break;  						}  					case OpCode.OP_SHA1:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(sha1.ComputeHash(stack.Pop()));  							break;  						}  					case OpCode.OP_SHA256:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(sha256.ComputeHash(stack.Pop()));  							break;  						}  					case OpCode.OP_HASH160:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(ripemd160.ComputeHash(sha256.ComputeHash(stack.Pop())));  							break;  						}  					case OpCode.OP_HASH256:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(sha256.ComputeHash(sha256.ComputeHash(stack.Pop())));  							break;  						}  					case OpCode.OP_CODESEPARATOR:  						{  							lastCodeSeperator = index;  							break;  						}  					case OpCode.OP_CHECKSIG:  					case OpCode.OP_CHECKSIGVERIFY:  						{  							if (tx == null)  								throw new ArgumentNullException("Transaction is required if script contains OP_CHECKSIG[VERIFY]");  							if (stack.Count < 2)  								return false;    							PublicKey pubKey = new PublicKey(stack.Pop());  							Byte[] sig = stack.Pop();    							Script subScript = new Script(elements.Skip(lastCodeSeperator)  								.Where(x => x.opCode != OpCode.OP_CODESEPARATOR).ToArray());    							stack.Push(new ScriptVarInt(CheckSig(sig' pubKey' txInIndex' subScript' tx) ? 1 : 0).ToBytes());    							if (se.opCode == OpCode.OP_CHECKSIGVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_CHECKMULTISIG:  					case OpCode.OP_CHECKMULTISIGVERIFY:  						{  							if (tx == null)  								throw new ArgumentNullException("Transaction is required if script contains OP_CHECKMULTISIG[VERIFY]");  							if (stack.Count < 2)  								return false;    							PublicKey[] pubKeys = new PublicKey[new ScriptVarInt(stack.Pop()).intValue];    							if (stack.Count < pubKeys.Length + 1)  								return false;    							for (int i = 0; i < pubKeys.Length; i++)  							{  								pubKeys[i] = new PublicKey(stack.Pop());  							}    							Byte[][] sigs = new Byte[new ScriptVarInt(stack.Pop()).intValue][];    							if (stack.Count < sigs.Length)  								return false;    							for (int i = 0; i < sigs.Length; i++)  							{  								sigs[i] = stack.Pop();  							}    							// Remove extra unused value from stack  							stack.Pop();    							Script subScript = new Script(elements.Skip(lastCodeSeperator)  								.Where(x => x.opCode != OpCode.OP_CODESEPARATOR).ToArray());    							int validSigs = 0;  							foreach (Byte[] sig in sigs)  							{  								foreach (PublicKey pubKey in pubKeys)  								{  									if (CheckSig(sig' pubKey' txInIndex' subScript' tx))  									{  										pubKeys = pubKeys.Where(x => x != pubKey).ToArray();  										validSigs++;  										break;  									}  								}  							}    							stack.Push(new ScriptVarInt((validSigs >= sigs.Length) ? 1 : 0).ToBytes());    							if (se.opCode == OpCode.OP_CHECKMULTISIGVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_NOP1:  					case OpCode.OP_NOP2:  					case OpCode.OP_NOP3:  					case OpCode.OP_NOP4:  					case OpCode.OP_NOP5:  					case OpCode.OP_NOP6:  					case OpCode.OP_NOP7:  					case OpCode.OP_NOP8:  					case OpCode.OP_NOP9:  					case OpCode.OP_NOP10:  						{  							break;  						}  					case OpCode.OP_SMALLINTEGER:  					case OpCode.OP_PUBKEYS:  					case OpCode.OP_PUBKEYHASH:  					case OpCode.OP_PUBKEY:  					case OpCode.OP_INVALIDOPCODE:  					default:  						{  							return false;  						}    				}  			}
Magic Number,Bitcoin_Tool.Scripts,Script,C:\repos\mb300sd_Bitcoin-Tool\Bitcoin Tool\Scripts\Script.cs,Evaluate,The following statement contains a magic number: for (int index = 0; index < elements.Count; index++)  			{  				ScriptElement se = elements[index];  				if (ifExec.Count > 0)  					if ((ifExec.First() == IfElseExec.SKIP_IF && !(se.opCode == OpCode.OP_ELSE || se.opCode == OpCode.OP_ENDIF)) ||  						(ifExec.First() == IfElseExec.SKIP_ELSE && !(se.opCode == OpCode.OP_ENDIF)))  						continue;    				if (se.isData)  				{  					stack.Push(se.data);  					continue;  				}    				switch (se.opCode)  				{  					case OpCode.OP_RESERVED:  						{  							return false;  						}  					case OpCode.OP_NOP:  						{  							// NOP' Dump stack for debug  							/*  							stack.ToList().ForEach(x => Console.WriteLine(HexString.FromByteArray(x)));  							Console.WriteLine("---------------------------");  							*/  							break;  						}  					case OpCode.OP_VER:  						{  							return false;  						}  					case OpCode.OP_IF:  					case OpCode.OP_NOTIF:  						{  							if (stack.Count < 1)  								return false;  							Boolean stackIsZero = new ScriptVarInt(stack.Pop()).value.IsZero;  							if ((se.opCode == OpCode.OP_IF && !stackIsZero) || (se.opCode == OpCode.OP_NOTIF && stackIsZero))  							{  								// Run to else or endif  								ifExec.Push(IfElseExec.RUN_IF);  							}  							else  							{  								// Skip to else or endif  								ifExec.Push(IfElseExec.SKIP_IF);  							}  							break;  						}  					case OpCode.OP_VERIF:  					case OpCode.OP_VERNOTIF:  						{  							return false;  						}  					case OpCode.OP_ELSE:  						{  							if (ifExec.Count == 0)  								// No preceding if statement!  								return false;  							if (ifExec.First() == IfElseExec.RUN_IF)  							{  								// If ran' skip else  								ifExec.Push(IfElseExec.SKIP_ELSE);  							}  							else if (ifExec.First() == IfElseExec.SKIP_IF)  							{  								// If did not run' run else  								ifExec.Push(IfElseExec.RUN_ELSE);  							}  							break;  						}  					case OpCode.OP_ENDIF:  						{  							if (ifExec.Count == 0)  								// No preceding if statement!  								return false;  							if (ifExec.First() == IfElseExec.RUN_IF ||  								ifExec.First() == IfElseExec.SKIP_IF)  							{  								ifExec.Pop();  							}  							else if (ifExec.First() == IfElseExec.RUN_ELSE ||  							   ifExec.First() == IfElseExec.SKIP_ELSE)  							{  								ifExec.Pop();  								ifExec.Pop();  							}  							break;  						}  					case OpCode.OP_VERIFY:  						{  							if (stack.Count < 1 || new ScriptVarInt(stack.First()).value.IsZero)  								return false;  							stack.Pop();  							break;  						}  					case OpCode.OP_RETURN:  						{  							return false;  						}  					case OpCode.OP_TOALTSTACK:  						{  							if (stack.Count < 1)  								return false;  							altstack.Push(stack.Pop());  							break;  						}  					case OpCode.OP_FROMALTSTACK:  						{  							if (altstack.Count < 1)  								return false;  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_2DROP:  						{  							if (stack.Count < 2)  								return false;  							stack.Pop();  							stack.Pop();  							break;  						}  					case OpCode.OP_2DUP:  						{  							if (stack.Count < 2)  								return false;  							stack.Push(stack.Skip(1).First());  							stack.Push(stack.Skip(1).First());  							break;  						}  					case OpCode.OP_3DUP:  						{  							if (stack.Count < 3)  								return false;  							stack.Push(stack.Skip(2).First());  							stack.Push(stack.Skip(2).First());  							stack.Push(stack.Skip(2).First());  							break;  						}  					case OpCode.OP_2OVER:  						{  							if (stack.Count < 4)  								return false;  							stack.Push(stack.Skip(3).First());  							stack.Push(stack.Skip(3).First());  							break;  						}  					case OpCode.OP_2ROT:  						{  							if (stack.Count < 6)  								return false;  							altstack.Push(stack.Skip(4).First());  							altstack.Push(stack.Skip(5).First());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_2SWAP:  						{  							if (stack.Count < 4)  								return false;  							altstack.Push(stack.Skip(2).First());  							altstack.Push(stack.Skip(3).First());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_IFDUP:  						{  							if (stack.Count < 1)  								return false;  							if (!new ScriptVarInt(stack.First()).value.IsZero)  								stack.Push(stack.First());  							break;  						}  					case OpCode.OP_DEPTH:  						{  							stack.Push(new ScriptVarInt((UInt64)stack.Count).ToBytes());  							break;  						}  					case OpCode.OP_DROP:  						{  							if (stack.Count < 1)  								return false;  							stack.Pop();  							break;  						}  					case OpCode.OP_DUP:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(stack.First());  							break;  						}  					case OpCode.OP_NIP:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_OVER:  						{  							if (stack.Count < 2)  								return false;  							stack.Push(stack.Skip(1).First());  							break;  						}  					case OpCode.OP_PICK:  						{  							if (stack.Count < 2)  								return false;  							int pick = new ScriptVarInt(stack.Pop()).intValue;  							if (pick < 0 || stack.Count <= pick)  								return false;  							stack.Push(stack.Skip(pick).First());  							break;  						}  					case OpCode.OP_ROLL:  						{  							if (stack.Count < 2)  								return false;  							int roll = new ScriptVarInt(stack.Pop()).intValue;  							if (roll < 0 || stack.Count <= roll)  								return false;  							altstack.Push(stack.Skip(roll).First());  							for (int i = 0; i < roll; i++)  								altstack.Push(stack.Pop());  							stack.Pop();  							for (int i = 0; i < roll + 1; i++)  								stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_ROT:  						{  							if (stack.Count < 3)  								return false;  							altstack.Push(stack.Skip(2).First());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_SWAP:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Skip(1).First());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_TUCK:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Push(altstack.Skip(1).First());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_CAT:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Skip(1).First().Concat(stack.First()).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_SUBSTR:  						{  							if (stack.Count < 3)  								return false;  							altstack.Push(stack.Skip(2).First()  								.Skip(new ScriptVarInt(stack.Skip(1).First()).intValue)  								.Take(new ScriptVarInt(stack.First()).intValue).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_LEFT:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Skip(1).First()  								.Take(new ScriptVarInt(stack.First()).intValue).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_RIGHT:  						{  							if (stack.Count < 2)  								return false;  							int count = new ScriptVarInt(stack.First()).intValue;  							altstack.Push(stack.Skip(1).First()  								.Skip(stack.Skip(1).First().Length - count).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_SIZE:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(new ScriptVarInt((UInt64)stack.First().Length).ToBytes());  							break;  						}  					case OpCode.OP_INVERT:  						{  							if (stack.Count < 1)  								return false;  							Byte[] data = stack.Pop();  							for (int i = 0; i < data.Length; i++)  								data[i] ^= 0xFF;  							stack.Push(data);  							break;  						}  					case OpCode.OP_AND:  					case OpCode.OP_OR:  					case OpCode.OP_XOR:  						{  							if (stack.Count < 2)  								return false;  							Byte[] data = stack.Pop();  							Byte[] data2 = stack.Pop();  							int length = new int[] { data.Length' data2.Length }.Max();  							data = data.Concat(new Byte[length - data.Length]).ToArray();  							data2 = data2.Concat(new Byte[length - data2.Length]).ToArray();  							switch (se.opCode)  							{  								case OpCode.OP_AND:  									{  										for (int i = 0; i < length; i++)  											data[i] &= data2[i];  										break;  									}  								case OpCode.OP_OR:  									{  										for (int i = 0; i < length; i++)  											data[i] |= data2[i];  										break;  									}  								case OpCode.OP_XOR:  									{  										for (int i = 0; i < length; i++)  											data[i] ^= data2[i];  										break;  									}  							}  							stack.Push(data);  							break;  						}  					case OpCode.OP_EQUAL:  					case OpCode.OP_EQUALVERIFY:  						{  							if (stack.Count < 2)  								return false;  							if (stack.Pop().SequenceEqual(stack.Pop()))  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });    							if (se.opCode == OpCode.OP_EQUALVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_RESERVED1:  					case OpCode.OP_RESERVED2:  						{  							return false;  						}  					case OpCode.OP_1ADD:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Add(new ScriptVarInt(stack.Pop())' 1)).ToBytes());  							break;  						}  					case OpCode.OP_1SUB:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Subtract(new ScriptVarInt(stack.Pop())' 1)).ToBytes());  							break;  						}  					case OpCode.OP_2MUL:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Multiply(new ScriptVarInt(stack.Pop())' 2)).ToBytes());  							break;  						}  					case OpCode.OP_2DIV:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Divide(new ScriptVarInt(stack.Pop())' 2)).ToBytes());  							break;  						}  					case OpCode.OP_NEGATE:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Negate(new ScriptVarInt(stack.Pop()))).ToBytes());  							break;  						}  					case OpCode.OP_ABS:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Abs(new ScriptVarInt(stack.Pop()))).ToBytes());  							break;  						}  					case OpCode.OP_NOT:  						{  							if (stack.Count < 1)  								return false;  							if (new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_0NOTEQUAL:  						{  							if (stack.Count < 1)  								return false;  							if (new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x00 });  							else  								stack.Push(new Byte[] { 0x01 });  							break;  						}  					case OpCode.OP_ADD:  					case OpCode.OP_SUB:  					case OpCode.OP_MUL:  					case OpCode.OP_DIV:  					case OpCode.OP_MOD:  					case OpCode.OP_LSHIFT:  					case OpCode.OP_RSHIFT:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							switch (se.opCode)  							{  								case OpCode.OP_ADD:  									a = (BigInteger)a + b;  									break;  								case OpCode.OP_SUB:  									a = (BigInteger)a - b;  									break;  								case OpCode.OP_MUL:  									a = (BigInteger)a * b;  									break;  								case OpCode.OP_DIV:  									a = (BigInteger)a / b;  									break;  								case OpCode.OP_MOD:  									a = (BigInteger)a % b;  									break;  								case OpCode.OP_LSHIFT:  									a = (BigInteger)a << b.intValue;  									break;  								case OpCode.OP_RSHIFT:  									a = (BigInteger)a >> b.intValue;  									break;  							}  							stack.Push(a.ToBytes());  							break;  						}  					case OpCode.OP_BOOLAND:  						{  							if (stack.Count < 2)  								return false;  							if (!new ScriptVarInt(stack.Pop()).value.IsZero && !new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_BOOLOR:  						{  							if (stack.Count < 2)  								return false;  							if (!new ScriptVarInt(stack.Pop()).value.IsZero || !new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_NUMEQUAL:  					case OpCode.OP_NUMEQUALVERIFY:  						{  							if (stack.Count < 2)  								return false;  							if (new ScriptVarInt(stack.Pop()).value == new ScriptVarInt(stack.Pop()).value)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							if (se.opCode == OpCode.OP_NUMEQUALVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_NUMNOTEQUAL:  						{  							if (stack.Count < 2)  								return false;  							if (new ScriptVarInt(stack.Pop()).value != new ScriptVarInt(stack.Pop()).value)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_LESSTHAN:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a < b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_GREATERTHAN:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a > b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_LESSTHANOREQUAL:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a <= b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_GREATERTHANOREQUAL:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a >= b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_MIN:  						{  							if (stack.Count < 2)  								return false;  							Byte[] b = stack.Pop();  							Byte[] a = stack.Pop();  							if (new ScriptVarInt(a).value < new ScriptVarInt(b).value)  								stack.Push(a);  							else  								stack.Push(b);  							break;  						}  					case OpCode.OP_MAX:  						{  							if (stack.Count < 2)  								return false;  							Byte[] b = stack.Pop();  							Byte[] a = stack.Pop();  							if (new ScriptVarInt(a).value > new ScriptVarInt(b).value)  								stack.Push(a);  							else  								stack.Push(b);  							break;  						}  					case OpCode.OP_WITHIN:  						{  							if (stack.Count < 3)  								return false;  							ScriptVarInt max = new ScriptVarInt(stack.Pop());  							ScriptVarInt min = new ScriptVarInt(stack.Pop());  							ScriptVarInt x = new ScriptVarInt(stack.Pop());  							if ((BigInteger)min <= x && (BigInteger)x <= max)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_RIPEMD160:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(ripemd160.ComputeHash(stack.Pop()));  							break;  						}  					case OpCode.OP_SHA1:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(sha1.ComputeHash(stack.Pop()));  							break;  						}  					case OpCode.OP_SHA256:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(sha256.ComputeHash(stack.Pop()));  							break;  						}  					case OpCode.OP_HASH160:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(ripemd160.ComputeHash(sha256.ComputeHash(stack.Pop())));  							break;  						}  					case OpCode.OP_HASH256:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(sha256.ComputeHash(sha256.ComputeHash(stack.Pop())));  							break;  						}  					case OpCode.OP_CODESEPARATOR:  						{  							lastCodeSeperator = index;  							break;  						}  					case OpCode.OP_CHECKSIG:  					case OpCode.OP_CHECKSIGVERIFY:  						{  							if (tx == null)  								throw new ArgumentNullException("Transaction is required if script contains OP_CHECKSIG[VERIFY]");  							if (stack.Count < 2)  								return false;    							PublicKey pubKey = new PublicKey(stack.Pop());  							Byte[] sig = stack.Pop();    							Script subScript = new Script(elements.Skip(lastCodeSeperator)  								.Where(x => x.opCode != OpCode.OP_CODESEPARATOR).ToArray());    							stack.Push(new ScriptVarInt(CheckSig(sig' pubKey' txInIndex' subScript' tx) ? 1 : 0).ToBytes());    							if (se.opCode == OpCode.OP_CHECKSIGVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_CHECKMULTISIG:  					case OpCode.OP_CHECKMULTISIGVERIFY:  						{  							if (tx == null)  								throw new ArgumentNullException("Transaction is required if script contains OP_CHECKMULTISIG[VERIFY]");  							if (stack.Count < 2)  								return false;    							PublicKey[] pubKeys = new PublicKey[new ScriptVarInt(stack.Pop()).intValue];    							if (stack.Count < pubKeys.Length + 1)  								return false;    							for (int i = 0; i < pubKeys.Length; i++)  							{  								pubKeys[i] = new PublicKey(stack.Pop());  							}    							Byte[][] sigs = new Byte[new ScriptVarInt(stack.Pop()).intValue][];    							if (stack.Count < sigs.Length)  								return false;    							for (int i = 0; i < sigs.Length; i++)  							{  								sigs[i] = stack.Pop();  							}    							// Remove extra unused value from stack  							stack.Pop();    							Script subScript = new Script(elements.Skip(lastCodeSeperator)  								.Where(x => x.opCode != OpCode.OP_CODESEPARATOR).ToArray());    							int validSigs = 0;  							foreach (Byte[] sig in sigs)  							{  								foreach (PublicKey pubKey in pubKeys)  								{  									if (CheckSig(sig' pubKey' txInIndex' subScript' tx))  									{  										pubKeys = pubKeys.Where(x => x != pubKey).ToArray();  										validSigs++;  										break;  									}  								}  							}    							stack.Push(new ScriptVarInt((validSigs >= sigs.Length) ? 1 : 0).ToBytes());    							if (se.opCode == OpCode.OP_CHECKMULTISIGVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_NOP1:  					case OpCode.OP_NOP2:  					case OpCode.OP_NOP3:  					case OpCode.OP_NOP4:  					case OpCode.OP_NOP5:  					case OpCode.OP_NOP6:  					case OpCode.OP_NOP7:  					case OpCode.OP_NOP8:  					case OpCode.OP_NOP9:  					case OpCode.OP_NOP10:  						{  							break;  						}  					case OpCode.OP_SMALLINTEGER:  					case OpCode.OP_PUBKEYS:  					case OpCode.OP_PUBKEYHASH:  					case OpCode.OP_PUBKEY:  					case OpCode.OP_INVALIDOPCODE:  					default:  						{  							return false;  						}    				}  			}
Magic Number,Bitcoin_Tool.Scripts,Script,C:\repos\mb300sd_Bitcoin-Tool\Bitcoin Tool\Scripts\Script.cs,Evaluate,The following statement contains a magic number: for (int index = 0; index < elements.Count; index++)  			{  				ScriptElement se = elements[index];  				if (ifExec.Count > 0)  					if ((ifExec.First() == IfElseExec.SKIP_IF && !(se.opCode == OpCode.OP_ELSE || se.opCode == OpCode.OP_ENDIF)) ||  						(ifExec.First() == IfElseExec.SKIP_ELSE && !(se.opCode == OpCode.OP_ENDIF)))  						continue;    				if (se.isData)  				{  					stack.Push(se.data);  					continue;  				}    				switch (se.opCode)  				{  					case OpCode.OP_RESERVED:  						{  							return false;  						}  					case OpCode.OP_NOP:  						{  							// NOP' Dump stack for debug  							/*  							stack.ToList().ForEach(x => Console.WriteLine(HexString.FromByteArray(x)));  							Console.WriteLine("---------------------------");  							*/  							break;  						}  					case OpCode.OP_VER:  						{  							return false;  						}  					case OpCode.OP_IF:  					case OpCode.OP_NOTIF:  						{  							if (stack.Count < 1)  								return false;  							Boolean stackIsZero = new ScriptVarInt(stack.Pop()).value.IsZero;  							if ((se.opCode == OpCode.OP_IF && !stackIsZero) || (se.opCode == OpCode.OP_NOTIF && stackIsZero))  							{  								// Run to else or endif  								ifExec.Push(IfElseExec.RUN_IF);  							}  							else  							{  								// Skip to else or endif  								ifExec.Push(IfElseExec.SKIP_IF);  							}  							break;  						}  					case OpCode.OP_VERIF:  					case OpCode.OP_VERNOTIF:  						{  							return false;  						}  					case OpCode.OP_ELSE:  						{  							if (ifExec.Count == 0)  								// No preceding if statement!  								return false;  							if (ifExec.First() == IfElseExec.RUN_IF)  							{  								// If ran' skip else  								ifExec.Push(IfElseExec.SKIP_ELSE);  							}  							else if (ifExec.First() == IfElseExec.SKIP_IF)  							{  								// If did not run' run else  								ifExec.Push(IfElseExec.RUN_ELSE);  							}  							break;  						}  					case OpCode.OP_ENDIF:  						{  							if (ifExec.Count == 0)  								// No preceding if statement!  								return false;  							if (ifExec.First() == IfElseExec.RUN_IF ||  								ifExec.First() == IfElseExec.SKIP_IF)  							{  								ifExec.Pop();  							}  							else if (ifExec.First() == IfElseExec.RUN_ELSE ||  							   ifExec.First() == IfElseExec.SKIP_ELSE)  							{  								ifExec.Pop();  								ifExec.Pop();  							}  							break;  						}  					case OpCode.OP_VERIFY:  						{  							if (stack.Count < 1 || new ScriptVarInt(stack.First()).value.IsZero)  								return false;  							stack.Pop();  							break;  						}  					case OpCode.OP_RETURN:  						{  							return false;  						}  					case OpCode.OP_TOALTSTACK:  						{  							if (stack.Count < 1)  								return false;  							altstack.Push(stack.Pop());  							break;  						}  					case OpCode.OP_FROMALTSTACK:  						{  							if (altstack.Count < 1)  								return false;  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_2DROP:  						{  							if (stack.Count < 2)  								return false;  							stack.Pop();  							stack.Pop();  							break;  						}  					case OpCode.OP_2DUP:  						{  							if (stack.Count < 2)  								return false;  							stack.Push(stack.Skip(1).First());  							stack.Push(stack.Skip(1).First());  							break;  						}  					case OpCode.OP_3DUP:  						{  							if (stack.Count < 3)  								return false;  							stack.Push(stack.Skip(2).First());  							stack.Push(stack.Skip(2).First());  							stack.Push(stack.Skip(2).First());  							break;  						}  					case OpCode.OP_2OVER:  						{  							if (stack.Count < 4)  								return false;  							stack.Push(stack.Skip(3).First());  							stack.Push(stack.Skip(3).First());  							break;  						}  					case OpCode.OP_2ROT:  						{  							if (stack.Count < 6)  								return false;  							altstack.Push(stack.Skip(4).First());  							altstack.Push(stack.Skip(5).First());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_2SWAP:  						{  							if (stack.Count < 4)  								return false;  							altstack.Push(stack.Skip(2).First());  							altstack.Push(stack.Skip(3).First());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_IFDUP:  						{  							if (stack.Count < 1)  								return false;  							if (!new ScriptVarInt(stack.First()).value.IsZero)  								stack.Push(stack.First());  							break;  						}  					case OpCode.OP_DEPTH:  						{  							stack.Push(new ScriptVarInt((UInt64)stack.Count).ToBytes());  							break;  						}  					case OpCode.OP_DROP:  						{  							if (stack.Count < 1)  								return false;  							stack.Pop();  							break;  						}  					case OpCode.OP_DUP:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(stack.First());  							break;  						}  					case OpCode.OP_NIP:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_OVER:  						{  							if (stack.Count < 2)  								return false;  							stack.Push(stack.Skip(1).First());  							break;  						}  					case OpCode.OP_PICK:  						{  							if (stack.Count < 2)  								return false;  							int pick = new ScriptVarInt(stack.Pop()).intValue;  							if (pick < 0 || stack.Count <= pick)  								return false;  							stack.Push(stack.Skip(pick).First());  							break;  						}  					case OpCode.OP_ROLL:  						{  							if (stack.Count < 2)  								return false;  							int roll = new ScriptVarInt(stack.Pop()).intValue;  							if (roll < 0 || stack.Count <= roll)  								return false;  							altstack.Push(stack.Skip(roll).First());  							for (int i = 0; i < roll; i++)  								altstack.Push(stack.Pop());  							stack.Pop();  							for (int i = 0; i < roll + 1; i++)  								stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_ROT:  						{  							if (stack.Count < 3)  								return false;  							altstack.Push(stack.Skip(2).First());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_SWAP:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Skip(1).First());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_TUCK:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Push(altstack.Skip(1).First());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_CAT:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Skip(1).First().Concat(stack.First()).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_SUBSTR:  						{  							if (stack.Count < 3)  								return false;  							altstack.Push(stack.Skip(2).First()  								.Skip(new ScriptVarInt(stack.Skip(1).First()).intValue)  								.Take(new ScriptVarInt(stack.First()).intValue).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_LEFT:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Skip(1).First()  								.Take(new ScriptVarInt(stack.First()).intValue).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_RIGHT:  						{  							if (stack.Count < 2)  								return false;  							int count = new ScriptVarInt(stack.First()).intValue;  							altstack.Push(stack.Skip(1).First()  								.Skip(stack.Skip(1).First().Length - count).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_SIZE:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(new ScriptVarInt((UInt64)stack.First().Length).ToBytes());  							break;  						}  					case OpCode.OP_INVERT:  						{  							if (stack.Count < 1)  								return false;  							Byte[] data = stack.Pop();  							for (int i = 0; i < data.Length; i++)  								data[i] ^= 0xFF;  							stack.Push(data);  							break;  						}  					case OpCode.OP_AND:  					case OpCode.OP_OR:  					case OpCode.OP_XOR:  						{  							if (stack.Count < 2)  								return false;  							Byte[] data = stack.Pop();  							Byte[] data2 = stack.Pop();  							int length = new int[] { data.Length' data2.Length }.Max();  							data = data.Concat(new Byte[length - data.Length]).ToArray();  							data2 = data2.Concat(new Byte[length - data2.Length]).ToArray();  							switch (se.opCode)  							{  								case OpCode.OP_AND:  									{  										for (int i = 0; i < length; i++)  											data[i] &= data2[i];  										break;  									}  								case OpCode.OP_OR:  									{  										for (int i = 0; i < length; i++)  											data[i] |= data2[i];  										break;  									}  								case OpCode.OP_XOR:  									{  										for (int i = 0; i < length; i++)  											data[i] ^= data2[i];  										break;  									}  							}  							stack.Push(data);  							break;  						}  					case OpCode.OP_EQUAL:  					case OpCode.OP_EQUALVERIFY:  						{  							if (stack.Count < 2)  								return false;  							if (stack.Pop().SequenceEqual(stack.Pop()))  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });    							if (se.opCode == OpCode.OP_EQUALVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_RESERVED1:  					case OpCode.OP_RESERVED2:  						{  							return false;  						}  					case OpCode.OP_1ADD:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Add(new ScriptVarInt(stack.Pop())' 1)).ToBytes());  							break;  						}  					case OpCode.OP_1SUB:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Subtract(new ScriptVarInt(stack.Pop())' 1)).ToBytes());  							break;  						}  					case OpCode.OP_2MUL:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Multiply(new ScriptVarInt(stack.Pop())' 2)).ToBytes());  							break;  						}  					case OpCode.OP_2DIV:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Divide(new ScriptVarInt(stack.Pop())' 2)).ToBytes());  							break;  						}  					case OpCode.OP_NEGATE:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Negate(new ScriptVarInt(stack.Pop()))).ToBytes());  							break;  						}  					case OpCode.OP_ABS:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Abs(new ScriptVarInt(stack.Pop()))).ToBytes());  							break;  						}  					case OpCode.OP_NOT:  						{  							if (stack.Count < 1)  								return false;  							if (new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_0NOTEQUAL:  						{  							if (stack.Count < 1)  								return false;  							if (new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x00 });  							else  								stack.Push(new Byte[] { 0x01 });  							break;  						}  					case OpCode.OP_ADD:  					case OpCode.OP_SUB:  					case OpCode.OP_MUL:  					case OpCode.OP_DIV:  					case OpCode.OP_MOD:  					case OpCode.OP_LSHIFT:  					case OpCode.OP_RSHIFT:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							switch (se.opCode)  							{  								case OpCode.OP_ADD:  									a = (BigInteger)a + b;  									break;  								case OpCode.OP_SUB:  									a = (BigInteger)a - b;  									break;  								case OpCode.OP_MUL:  									a = (BigInteger)a * b;  									break;  								case OpCode.OP_DIV:  									a = (BigInteger)a / b;  									break;  								case OpCode.OP_MOD:  									a = (BigInteger)a % b;  									break;  								case OpCode.OP_LSHIFT:  									a = (BigInteger)a << b.intValue;  									break;  								case OpCode.OP_RSHIFT:  									a = (BigInteger)a >> b.intValue;  									break;  							}  							stack.Push(a.ToBytes());  							break;  						}  					case OpCode.OP_BOOLAND:  						{  							if (stack.Count < 2)  								return false;  							if (!new ScriptVarInt(stack.Pop()).value.IsZero && !new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_BOOLOR:  						{  							if (stack.Count < 2)  								return false;  							if (!new ScriptVarInt(stack.Pop()).value.IsZero || !new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_NUMEQUAL:  					case OpCode.OP_NUMEQUALVERIFY:  						{  							if (stack.Count < 2)  								return false;  							if (new ScriptVarInt(stack.Pop()).value == new ScriptVarInt(stack.Pop()).value)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							if (se.opCode == OpCode.OP_NUMEQUALVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_NUMNOTEQUAL:  						{  							if (stack.Count < 2)  								return false;  							if (new ScriptVarInt(stack.Pop()).value != new ScriptVarInt(stack.Pop()).value)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_LESSTHAN:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a < b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_GREATERTHAN:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a > b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_LESSTHANOREQUAL:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a <= b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_GREATERTHANOREQUAL:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a >= b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_MIN:  						{  							if (stack.Count < 2)  								return false;  							Byte[] b = stack.Pop();  							Byte[] a = stack.Pop();  							if (new ScriptVarInt(a).value < new ScriptVarInt(b).value)  								stack.Push(a);  							else  								stack.Push(b);  							break;  						}  					case OpCode.OP_MAX:  						{  							if (stack.Count < 2)  								return false;  							Byte[] b = stack.Pop();  							Byte[] a = stack.Pop();  							if (new ScriptVarInt(a).value > new ScriptVarInt(b).value)  								stack.Push(a);  							else  								stack.Push(b);  							break;  						}  					case OpCode.OP_WITHIN:  						{  							if (stack.Count < 3)  								return false;  							ScriptVarInt max = new ScriptVarInt(stack.Pop());  							ScriptVarInt min = new ScriptVarInt(stack.Pop());  							ScriptVarInt x = new ScriptVarInt(stack.Pop());  							if ((BigInteger)min <= x && (BigInteger)x <= max)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_RIPEMD160:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(ripemd160.ComputeHash(stack.Pop()));  							break;  						}  					case OpCode.OP_SHA1:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(sha1.ComputeHash(stack.Pop()));  							break;  						}  					case OpCode.OP_SHA256:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(sha256.ComputeHash(stack.Pop()));  							break;  						}  					case OpCode.OP_HASH160:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(ripemd160.ComputeHash(sha256.ComputeHash(stack.Pop())));  							break;  						}  					case OpCode.OP_HASH256:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(sha256.ComputeHash(sha256.ComputeHash(stack.Pop())));  							break;  						}  					case OpCode.OP_CODESEPARATOR:  						{  							lastCodeSeperator = index;  							break;  						}  					case OpCode.OP_CHECKSIG:  					case OpCode.OP_CHECKSIGVERIFY:  						{  							if (tx == null)  								throw new ArgumentNullException("Transaction is required if script contains OP_CHECKSIG[VERIFY]");  							if (stack.Count < 2)  								return false;    							PublicKey pubKey = new PublicKey(stack.Pop());  							Byte[] sig = stack.Pop();    							Script subScript = new Script(elements.Skip(lastCodeSeperator)  								.Where(x => x.opCode != OpCode.OP_CODESEPARATOR).ToArray());    							stack.Push(new ScriptVarInt(CheckSig(sig' pubKey' txInIndex' subScript' tx) ? 1 : 0).ToBytes());    							if (se.opCode == OpCode.OP_CHECKSIGVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_CHECKMULTISIG:  					case OpCode.OP_CHECKMULTISIGVERIFY:  						{  							if (tx == null)  								throw new ArgumentNullException("Transaction is required if script contains OP_CHECKMULTISIG[VERIFY]");  							if (stack.Count < 2)  								return false;    							PublicKey[] pubKeys = new PublicKey[new ScriptVarInt(stack.Pop()).intValue];    							if (stack.Count < pubKeys.Length + 1)  								return false;    							for (int i = 0; i < pubKeys.Length; i++)  							{  								pubKeys[i] = new PublicKey(stack.Pop());  							}    							Byte[][] sigs = new Byte[new ScriptVarInt(stack.Pop()).intValue][];    							if (stack.Count < sigs.Length)  								return false;    							for (int i = 0; i < sigs.Length; i++)  							{  								sigs[i] = stack.Pop();  							}    							// Remove extra unused value from stack  							stack.Pop();    							Script subScript = new Script(elements.Skip(lastCodeSeperator)  								.Where(x => x.opCode != OpCode.OP_CODESEPARATOR).ToArray());    							int validSigs = 0;  							foreach (Byte[] sig in sigs)  							{  								foreach (PublicKey pubKey in pubKeys)  								{  									if (CheckSig(sig' pubKey' txInIndex' subScript' tx))  									{  										pubKeys = pubKeys.Where(x => x != pubKey).ToArray();  										validSigs++;  										break;  									}  								}  							}    							stack.Push(new ScriptVarInt((validSigs >= sigs.Length) ? 1 : 0).ToBytes());    							if (se.opCode == OpCode.OP_CHECKMULTISIGVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_NOP1:  					case OpCode.OP_NOP2:  					case OpCode.OP_NOP3:  					case OpCode.OP_NOP4:  					case OpCode.OP_NOP5:  					case OpCode.OP_NOP6:  					case OpCode.OP_NOP7:  					case OpCode.OP_NOP8:  					case OpCode.OP_NOP9:  					case OpCode.OP_NOP10:  						{  							break;  						}  					case OpCode.OP_SMALLINTEGER:  					case OpCode.OP_PUBKEYS:  					case OpCode.OP_PUBKEYHASH:  					case OpCode.OP_PUBKEY:  					case OpCode.OP_INVALIDOPCODE:  					default:  						{  							return false;  						}    				}  			}
Magic Number,Bitcoin_Tool.Scripts,Script,C:\repos\mb300sd_Bitcoin-Tool\Bitcoin Tool\Scripts\Script.cs,Evaluate,The following statement contains a magic number: for (int index = 0; index < elements.Count; index++)  			{  				ScriptElement se = elements[index];  				if (ifExec.Count > 0)  					if ((ifExec.First() == IfElseExec.SKIP_IF && !(se.opCode == OpCode.OP_ELSE || se.opCode == OpCode.OP_ENDIF)) ||  						(ifExec.First() == IfElseExec.SKIP_ELSE && !(se.opCode == OpCode.OP_ENDIF)))  						continue;    				if (se.isData)  				{  					stack.Push(se.data);  					continue;  				}    				switch (se.opCode)  				{  					case OpCode.OP_RESERVED:  						{  							return false;  						}  					case OpCode.OP_NOP:  						{  							// NOP' Dump stack for debug  							/*  							stack.ToList().ForEach(x => Console.WriteLine(HexString.FromByteArray(x)));  							Console.WriteLine("---------------------------");  							*/  							break;  						}  					case OpCode.OP_VER:  						{  							return false;  						}  					case OpCode.OP_IF:  					case OpCode.OP_NOTIF:  						{  							if (stack.Count < 1)  								return false;  							Boolean stackIsZero = new ScriptVarInt(stack.Pop()).value.IsZero;  							if ((se.opCode == OpCode.OP_IF && !stackIsZero) || (se.opCode == OpCode.OP_NOTIF && stackIsZero))  							{  								// Run to else or endif  								ifExec.Push(IfElseExec.RUN_IF);  							}  							else  							{  								// Skip to else or endif  								ifExec.Push(IfElseExec.SKIP_IF);  							}  							break;  						}  					case OpCode.OP_VERIF:  					case OpCode.OP_VERNOTIF:  						{  							return false;  						}  					case OpCode.OP_ELSE:  						{  							if (ifExec.Count == 0)  								// No preceding if statement!  								return false;  							if (ifExec.First() == IfElseExec.RUN_IF)  							{  								// If ran' skip else  								ifExec.Push(IfElseExec.SKIP_ELSE);  							}  							else if (ifExec.First() == IfElseExec.SKIP_IF)  							{  								// If did not run' run else  								ifExec.Push(IfElseExec.RUN_ELSE);  							}  							break;  						}  					case OpCode.OP_ENDIF:  						{  							if (ifExec.Count == 0)  								// No preceding if statement!  								return false;  							if (ifExec.First() == IfElseExec.RUN_IF ||  								ifExec.First() == IfElseExec.SKIP_IF)  							{  								ifExec.Pop();  							}  							else if (ifExec.First() == IfElseExec.RUN_ELSE ||  							   ifExec.First() == IfElseExec.SKIP_ELSE)  							{  								ifExec.Pop();  								ifExec.Pop();  							}  							break;  						}  					case OpCode.OP_VERIFY:  						{  							if (stack.Count < 1 || new ScriptVarInt(stack.First()).value.IsZero)  								return false;  							stack.Pop();  							break;  						}  					case OpCode.OP_RETURN:  						{  							return false;  						}  					case OpCode.OP_TOALTSTACK:  						{  							if (stack.Count < 1)  								return false;  							altstack.Push(stack.Pop());  							break;  						}  					case OpCode.OP_FROMALTSTACK:  						{  							if (altstack.Count < 1)  								return false;  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_2DROP:  						{  							if (stack.Count < 2)  								return false;  							stack.Pop();  							stack.Pop();  							break;  						}  					case OpCode.OP_2DUP:  						{  							if (stack.Count < 2)  								return false;  							stack.Push(stack.Skip(1).First());  							stack.Push(stack.Skip(1).First());  							break;  						}  					case OpCode.OP_3DUP:  						{  							if (stack.Count < 3)  								return false;  							stack.Push(stack.Skip(2).First());  							stack.Push(stack.Skip(2).First());  							stack.Push(stack.Skip(2).First());  							break;  						}  					case OpCode.OP_2OVER:  						{  							if (stack.Count < 4)  								return false;  							stack.Push(stack.Skip(3).First());  							stack.Push(stack.Skip(3).First());  							break;  						}  					case OpCode.OP_2ROT:  						{  							if (stack.Count < 6)  								return false;  							altstack.Push(stack.Skip(4).First());  							altstack.Push(stack.Skip(5).First());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_2SWAP:  						{  							if (stack.Count < 4)  								return false;  							altstack.Push(stack.Skip(2).First());  							altstack.Push(stack.Skip(3).First());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_IFDUP:  						{  							if (stack.Count < 1)  								return false;  							if (!new ScriptVarInt(stack.First()).value.IsZero)  								stack.Push(stack.First());  							break;  						}  					case OpCode.OP_DEPTH:  						{  							stack.Push(new ScriptVarInt((UInt64)stack.Count).ToBytes());  							break;  						}  					case OpCode.OP_DROP:  						{  							if (stack.Count < 1)  								return false;  							stack.Pop();  							break;  						}  					case OpCode.OP_DUP:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(stack.First());  							break;  						}  					case OpCode.OP_NIP:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_OVER:  						{  							if (stack.Count < 2)  								return false;  							stack.Push(stack.Skip(1).First());  							break;  						}  					case OpCode.OP_PICK:  						{  							if (stack.Count < 2)  								return false;  							int pick = new ScriptVarInt(stack.Pop()).intValue;  							if (pick < 0 || stack.Count <= pick)  								return false;  							stack.Push(stack.Skip(pick).First());  							break;  						}  					case OpCode.OP_ROLL:  						{  							if (stack.Count < 2)  								return false;  							int roll = new ScriptVarInt(stack.Pop()).intValue;  							if (roll < 0 || stack.Count <= roll)  								return false;  							altstack.Push(stack.Skip(roll).First());  							for (int i = 0; i < roll; i++)  								altstack.Push(stack.Pop());  							stack.Pop();  							for (int i = 0; i < roll + 1; i++)  								stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_ROT:  						{  							if (stack.Count < 3)  								return false;  							altstack.Push(stack.Skip(2).First());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_SWAP:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Skip(1).First());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_TUCK:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Push(altstack.Skip(1).First());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_CAT:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Skip(1).First().Concat(stack.First()).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_SUBSTR:  						{  							if (stack.Count < 3)  								return false;  							altstack.Push(stack.Skip(2).First()  								.Skip(new ScriptVarInt(stack.Skip(1).First()).intValue)  								.Take(new ScriptVarInt(stack.First()).intValue).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_LEFT:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Skip(1).First()  								.Take(new ScriptVarInt(stack.First()).intValue).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_RIGHT:  						{  							if (stack.Count < 2)  								return false;  							int count = new ScriptVarInt(stack.First()).intValue;  							altstack.Push(stack.Skip(1).First()  								.Skip(stack.Skip(1).First().Length - count).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_SIZE:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(new ScriptVarInt((UInt64)stack.First().Length).ToBytes());  							break;  						}  					case OpCode.OP_INVERT:  						{  							if (stack.Count < 1)  								return false;  							Byte[] data = stack.Pop();  							for (int i = 0; i < data.Length; i++)  								data[i] ^= 0xFF;  							stack.Push(data);  							break;  						}  					case OpCode.OP_AND:  					case OpCode.OP_OR:  					case OpCode.OP_XOR:  						{  							if (stack.Count < 2)  								return false;  							Byte[] data = stack.Pop();  							Byte[] data2 = stack.Pop();  							int length = new int[] { data.Length' data2.Length }.Max();  							data = data.Concat(new Byte[length - data.Length]).ToArray();  							data2 = data2.Concat(new Byte[length - data2.Length]).ToArray();  							switch (se.opCode)  							{  								case OpCode.OP_AND:  									{  										for (int i = 0; i < length; i++)  											data[i] &= data2[i];  										break;  									}  								case OpCode.OP_OR:  									{  										for (int i = 0; i < length; i++)  											data[i] |= data2[i];  										break;  									}  								case OpCode.OP_XOR:  									{  										for (int i = 0; i < length; i++)  											data[i] ^= data2[i];  										break;  									}  							}  							stack.Push(data);  							break;  						}  					case OpCode.OP_EQUAL:  					case OpCode.OP_EQUALVERIFY:  						{  							if (stack.Count < 2)  								return false;  							if (stack.Pop().SequenceEqual(stack.Pop()))  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });    							if (se.opCode == OpCode.OP_EQUALVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_RESERVED1:  					case OpCode.OP_RESERVED2:  						{  							return false;  						}  					case OpCode.OP_1ADD:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Add(new ScriptVarInt(stack.Pop())' 1)).ToBytes());  							break;  						}  					case OpCode.OP_1SUB:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Subtract(new ScriptVarInt(stack.Pop())' 1)).ToBytes());  							break;  						}  					case OpCode.OP_2MUL:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Multiply(new ScriptVarInt(stack.Pop())' 2)).ToBytes());  							break;  						}  					case OpCode.OP_2DIV:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Divide(new ScriptVarInt(stack.Pop())' 2)).ToBytes());  							break;  						}  					case OpCode.OP_NEGATE:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Negate(new ScriptVarInt(stack.Pop()))).ToBytes());  							break;  						}  					case OpCode.OP_ABS:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Abs(new ScriptVarInt(stack.Pop()))).ToBytes());  							break;  						}  					case OpCode.OP_NOT:  						{  							if (stack.Count < 1)  								return false;  							if (new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_0NOTEQUAL:  						{  							if (stack.Count < 1)  								return false;  							if (new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x00 });  							else  								stack.Push(new Byte[] { 0x01 });  							break;  						}  					case OpCode.OP_ADD:  					case OpCode.OP_SUB:  					case OpCode.OP_MUL:  					case OpCode.OP_DIV:  					case OpCode.OP_MOD:  					case OpCode.OP_LSHIFT:  					case OpCode.OP_RSHIFT:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							switch (se.opCode)  							{  								case OpCode.OP_ADD:  									a = (BigInteger)a + b;  									break;  								case OpCode.OP_SUB:  									a = (BigInteger)a - b;  									break;  								case OpCode.OP_MUL:  									a = (BigInteger)a * b;  									break;  								case OpCode.OP_DIV:  									a = (BigInteger)a / b;  									break;  								case OpCode.OP_MOD:  									a = (BigInteger)a % b;  									break;  								case OpCode.OP_LSHIFT:  									a = (BigInteger)a << b.intValue;  									break;  								case OpCode.OP_RSHIFT:  									a = (BigInteger)a >> b.intValue;  									break;  							}  							stack.Push(a.ToBytes());  							break;  						}  					case OpCode.OP_BOOLAND:  						{  							if (stack.Count < 2)  								return false;  							if (!new ScriptVarInt(stack.Pop()).value.IsZero && !new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_BOOLOR:  						{  							if (stack.Count < 2)  								return false;  							if (!new ScriptVarInt(stack.Pop()).value.IsZero || !new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_NUMEQUAL:  					case OpCode.OP_NUMEQUALVERIFY:  						{  							if (stack.Count < 2)  								return false;  							if (new ScriptVarInt(stack.Pop()).value == new ScriptVarInt(stack.Pop()).value)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							if (se.opCode == OpCode.OP_NUMEQUALVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_NUMNOTEQUAL:  						{  							if (stack.Count < 2)  								return false;  							if (new ScriptVarInt(stack.Pop()).value != new ScriptVarInt(stack.Pop()).value)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_LESSTHAN:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a < b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_GREATERTHAN:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a > b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_LESSTHANOREQUAL:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a <= b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_GREATERTHANOREQUAL:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a >= b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_MIN:  						{  							if (stack.Count < 2)  								return false;  							Byte[] b = stack.Pop();  							Byte[] a = stack.Pop();  							if (new ScriptVarInt(a).value < new ScriptVarInt(b).value)  								stack.Push(a);  							else  								stack.Push(b);  							break;  						}  					case OpCode.OP_MAX:  						{  							if (stack.Count < 2)  								return false;  							Byte[] b = stack.Pop();  							Byte[] a = stack.Pop();  							if (new ScriptVarInt(a).value > new ScriptVarInt(b).value)  								stack.Push(a);  							else  								stack.Push(b);  							break;  						}  					case OpCode.OP_WITHIN:  						{  							if (stack.Count < 3)  								return false;  							ScriptVarInt max = new ScriptVarInt(stack.Pop());  							ScriptVarInt min = new ScriptVarInt(stack.Pop());  							ScriptVarInt x = new ScriptVarInt(stack.Pop());  							if ((BigInteger)min <= x && (BigInteger)x <= max)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_RIPEMD160:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(ripemd160.ComputeHash(stack.Pop()));  							break;  						}  					case OpCode.OP_SHA1:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(sha1.ComputeHash(stack.Pop()));  							break;  						}  					case OpCode.OP_SHA256:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(sha256.ComputeHash(stack.Pop()));  							break;  						}  					case OpCode.OP_HASH160:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(ripemd160.ComputeHash(sha256.ComputeHash(stack.Pop())));  							break;  						}  					case OpCode.OP_HASH256:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(sha256.ComputeHash(sha256.ComputeHash(stack.Pop())));  							break;  						}  					case OpCode.OP_CODESEPARATOR:  						{  							lastCodeSeperator = index;  							break;  						}  					case OpCode.OP_CHECKSIG:  					case OpCode.OP_CHECKSIGVERIFY:  						{  							if (tx == null)  								throw new ArgumentNullException("Transaction is required if script contains OP_CHECKSIG[VERIFY]");  							if (stack.Count < 2)  								return false;    							PublicKey pubKey = new PublicKey(stack.Pop());  							Byte[] sig = stack.Pop();    							Script subScript = new Script(elements.Skip(lastCodeSeperator)  								.Where(x => x.opCode != OpCode.OP_CODESEPARATOR).ToArray());    							stack.Push(new ScriptVarInt(CheckSig(sig' pubKey' txInIndex' subScript' tx) ? 1 : 0).ToBytes());    							if (se.opCode == OpCode.OP_CHECKSIGVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_CHECKMULTISIG:  					case OpCode.OP_CHECKMULTISIGVERIFY:  						{  							if (tx == null)  								throw new ArgumentNullException("Transaction is required if script contains OP_CHECKMULTISIG[VERIFY]");  							if (stack.Count < 2)  								return false;    							PublicKey[] pubKeys = new PublicKey[new ScriptVarInt(stack.Pop()).intValue];    							if (stack.Count < pubKeys.Length + 1)  								return false;    							for (int i = 0; i < pubKeys.Length; i++)  							{  								pubKeys[i] = new PublicKey(stack.Pop());  							}    							Byte[][] sigs = new Byte[new ScriptVarInt(stack.Pop()).intValue][];    							if (stack.Count < sigs.Length)  								return false;    							for (int i = 0; i < sigs.Length; i++)  							{  								sigs[i] = stack.Pop();  							}    							// Remove extra unused value from stack  							stack.Pop();    							Script subScript = new Script(elements.Skip(lastCodeSeperator)  								.Where(x => x.opCode != OpCode.OP_CODESEPARATOR).ToArray());    							int validSigs = 0;  							foreach (Byte[] sig in sigs)  							{  								foreach (PublicKey pubKey in pubKeys)  								{  									if (CheckSig(sig' pubKey' txInIndex' subScript' tx))  									{  										pubKeys = pubKeys.Where(x => x != pubKey).ToArray();  										validSigs++;  										break;  									}  								}  							}    							stack.Push(new ScriptVarInt((validSigs >= sigs.Length) ? 1 : 0).ToBytes());    							if (se.opCode == OpCode.OP_CHECKMULTISIGVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_NOP1:  					case OpCode.OP_NOP2:  					case OpCode.OP_NOP3:  					case OpCode.OP_NOP4:  					case OpCode.OP_NOP5:  					case OpCode.OP_NOP6:  					case OpCode.OP_NOP7:  					case OpCode.OP_NOP8:  					case OpCode.OP_NOP9:  					case OpCode.OP_NOP10:  						{  							break;  						}  					case OpCode.OP_SMALLINTEGER:  					case OpCode.OP_PUBKEYS:  					case OpCode.OP_PUBKEYHASH:  					case OpCode.OP_PUBKEY:  					case OpCode.OP_INVALIDOPCODE:  					default:  						{  							return false;  						}    				}  			}
Magic Number,Bitcoin_Tool.Scripts,Script,C:\repos\mb300sd_Bitcoin-Tool\Bitcoin Tool\Scripts\Script.cs,Evaluate,The following statement contains a magic number: for (int index = 0; index < elements.Count; index++)  			{  				ScriptElement se = elements[index];  				if (ifExec.Count > 0)  					if ((ifExec.First() == IfElseExec.SKIP_IF && !(se.opCode == OpCode.OP_ELSE || se.opCode == OpCode.OP_ENDIF)) ||  						(ifExec.First() == IfElseExec.SKIP_ELSE && !(se.opCode == OpCode.OP_ENDIF)))  						continue;    				if (se.isData)  				{  					stack.Push(se.data);  					continue;  				}    				switch (se.opCode)  				{  					case OpCode.OP_RESERVED:  						{  							return false;  						}  					case OpCode.OP_NOP:  						{  							// NOP' Dump stack for debug  							/*  							stack.ToList().ForEach(x => Console.WriteLine(HexString.FromByteArray(x)));  							Console.WriteLine("---------------------------");  							*/  							break;  						}  					case OpCode.OP_VER:  						{  							return false;  						}  					case OpCode.OP_IF:  					case OpCode.OP_NOTIF:  						{  							if (stack.Count < 1)  								return false;  							Boolean stackIsZero = new ScriptVarInt(stack.Pop()).value.IsZero;  							if ((se.opCode == OpCode.OP_IF && !stackIsZero) || (se.opCode == OpCode.OP_NOTIF && stackIsZero))  							{  								// Run to else or endif  								ifExec.Push(IfElseExec.RUN_IF);  							}  							else  							{  								// Skip to else or endif  								ifExec.Push(IfElseExec.SKIP_IF);  							}  							break;  						}  					case OpCode.OP_VERIF:  					case OpCode.OP_VERNOTIF:  						{  							return false;  						}  					case OpCode.OP_ELSE:  						{  							if (ifExec.Count == 0)  								// No preceding if statement!  								return false;  							if (ifExec.First() == IfElseExec.RUN_IF)  							{  								// If ran' skip else  								ifExec.Push(IfElseExec.SKIP_ELSE);  							}  							else if (ifExec.First() == IfElseExec.SKIP_IF)  							{  								// If did not run' run else  								ifExec.Push(IfElseExec.RUN_ELSE);  							}  							break;  						}  					case OpCode.OP_ENDIF:  						{  							if (ifExec.Count == 0)  								// No preceding if statement!  								return false;  							if (ifExec.First() == IfElseExec.RUN_IF ||  								ifExec.First() == IfElseExec.SKIP_IF)  							{  								ifExec.Pop();  							}  							else if (ifExec.First() == IfElseExec.RUN_ELSE ||  							   ifExec.First() == IfElseExec.SKIP_ELSE)  							{  								ifExec.Pop();  								ifExec.Pop();  							}  							break;  						}  					case OpCode.OP_VERIFY:  						{  							if (stack.Count < 1 || new ScriptVarInt(stack.First()).value.IsZero)  								return false;  							stack.Pop();  							break;  						}  					case OpCode.OP_RETURN:  						{  							return false;  						}  					case OpCode.OP_TOALTSTACK:  						{  							if (stack.Count < 1)  								return false;  							altstack.Push(stack.Pop());  							break;  						}  					case OpCode.OP_FROMALTSTACK:  						{  							if (altstack.Count < 1)  								return false;  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_2DROP:  						{  							if (stack.Count < 2)  								return false;  							stack.Pop();  							stack.Pop();  							break;  						}  					case OpCode.OP_2DUP:  						{  							if (stack.Count < 2)  								return false;  							stack.Push(stack.Skip(1).First());  							stack.Push(stack.Skip(1).First());  							break;  						}  					case OpCode.OP_3DUP:  						{  							if (stack.Count < 3)  								return false;  							stack.Push(stack.Skip(2).First());  							stack.Push(stack.Skip(2).First());  							stack.Push(stack.Skip(2).First());  							break;  						}  					case OpCode.OP_2OVER:  						{  							if (stack.Count < 4)  								return false;  							stack.Push(stack.Skip(3).First());  							stack.Push(stack.Skip(3).First());  							break;  						}  					case OpCode.OP_2ROT:  						{  							if (stack.Count < 6)  								return false;  							altstack.Push(stack.Skip(4).First());  							altstack.Push(stack.Skip(5).First());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_2SWAP:  						{  							if (stack.Count < 4)  								return false;  							altstack.Push(stack.Skip(2).First());  							altstack.Push(stack.Skip(3).First());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_IFDUP:  						{  							if (stack.Count < 1)  								return false;  							if (!new ScriptVarInt(stack.First()).value.IsZero)  								stack.Push(stack.First());  							break;  						}  					case OpCode.OP_DEPTH:  						{  							stack.Push(new ScriptVarInt((UInt64)stack.Count).ToBytes());  							break;  						}  					case OpCode.OP_DROP:  						{  							if (stack.Count < 1)  								return false;  							stack.Pop();  							break;  						}  					case OpCode.OP_DUP:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(stack.First());  							break;  						}  					case OpCode.OP_NIP:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_OVER:  						{  							if (stack.Count < 2)  								return false;  							stack.Push(stack.Skip(1).First());  							break;  						}  					case OpCode.OP_PICK:  						{  							if (stack.Count < 2)  								return false;  							int pick = new ScriptVarInt(stack.Pop()).intValue;  							if (pick < 0 || stack.Count <= pick)  								return false;  							stack.Push(stack.Skip(pick).First());  							break;  						}  					case OpCode.OP_ROLL:  						{  							if (stack.Count < 2)  								return false;  							int roll = new ScriptVarInt(stack.Pop()).intValue;  							if (roll < 0 || stack.Count <= roll)  								return false;  							altstack.Push(stack.Skip(roll).First());  							for (int i = 0; i < roll; i++)  								altstack.Push(stack.Pop());  							stack.Pop();  							for (int i = 0; i < roll + 1; i++)  								stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_ROT:  						{  							if (stack.Count < 3)  								return false;  							altstack.Push(stack.Skip(2).First());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_SWAP:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Skip(1).First());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_TUCK:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Push(altstack.Skip(1).First());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_CAT:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Skip(1).First().Concat(stack.First()).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_SUBSTR:  						{  							if (stack.Count < 3)  								return false;  							altstack.Push(stack.Skip(2).First()  								.Skip(new ScriptVarInt(stack.Skip(1).First()).intValue)  								.Take(new ScriptVarInt(stack.First()).intValue).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_LEFT:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Skip(1).First()  								.Take(new ScriptVarInt(stack.First()).intValue).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_RIGHT:  						{  							if (stack.Count < 2)  								return false;  							int count = new ScriptVarInt(stack.First()).intValue;  							altstack.Push(stack.Skip(1).First()  								.Skip(stack.Skip(1).First().Length - count).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_SIZE:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(new ScriptVarInt((UInt64)stack.First().Length).ToBytes());  							break;  						}  					case OpCode.OP_INVERT:  						{  							if (stack.Count < 1)  								return false;  							Byte[] data = stack.Pop();  							for (int i = 0; i < data.Length; i++)  								data[i] ^= 0xFF;  							stack.Push(data);  							break;  						}  					case OpCode.OP_AND:  					case OpCode.OP_OR:  					case OpCode.OP_XOR:  						{  							if (stack.Count < 2)  								return false;  							Byte[] data = stack.Pop();  							Byte[] data2 = stack.Pop();  							int length = new int[] { data.Length' data2.Length }.Max();  							data = data.Concat(new Byte[length - data.Length]).ToArray();  							data2 = data2.Concat(new Byte[length - data2.Length]).ToArray();  							switch (se.opCode)  							{  								case OpCode.OP_AND:  									{  										for (int i = 0; i < length; i++)  											data[i] &= data2[i];  										break;  									}  								case OpCode.OP_OR:  									{  										for (int i = 0; i < length; i++)  											data[i] |= data2[i];  										break;  									}  								case OpCode.OP_XOR:  									{  										for (int i = 0; i < length; i++)  											data[i] ^= data2[i];  										break;  									}  							}  							stack.Push(data);  							break;  						}  					case OpCode.OP_EQUAL:  					case OpCode.OP_EQUALVERIFY:  						{  							if (stack.Count < 2)  								return false;  							if (stack.Pop().SequenceEqual(stack.Pop()))  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });    							if (se.opCode == OpCode.OP_EQUALVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_RESERVED1:  					case OpCode.OP_RESERVED2:  						{  							return false;  						}  					case OpCode.OP_1ADD:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Add(new ScriptVarInt(stack.Pop())' 1)).ToBytes());  							break;  						}  					case OpCode.OP_1SUB:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Subtract(new ScriptVarInt(stack.Pop())' 1)).ToBytes());  							break;  						}  					case OpCode.OP_2MUL:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Multiply(new ScriptVarInt(stack.Pop())' 2)).ToBytes());  							break;  						}  					case OpCode.OP_2DIV:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Divide(new ScriptVarInt(stack.Pop())' 2)).ToBytes());  							break;  						}  					case OpCode.OP_NEGATE:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Negate(new ScriptVarInt(stack.Pop()))).ToBytes());  							break;  						}  					case OpCode.OP_ABS:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Abs(new ScriptVarInt(stack.Pop()))).ToBytes());  							break;  						}  					case OpCode.OP_NOT:  						{  							if (stack.Count < 1)  								return false;  							if (new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_0NOTEQUAL:  						{  							if (stack.Count < 1)  								return false;  							if (new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x00 });  							else  								stack.Push(new Byte[] { 0x01 });  							break;  						}  					case OpCode.OP_ADD:  					case OpCode.OP_SUB:  					case OpCode.OP_MUL:  					case OpCode.OP_DIV:  					case OpCode.OP_MOD:  					case OpCode.OP_LSHIFT:  					case OpCode.OP_RSHIFT:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							switch (se.opCode)  							{  								case OpCode.OP_ADD:  									a = (BigInteger)a + b;  									break;  								case OpCode.OP_SUB:  									a = (BigInteger)a - b;  									break;  								case OpCode.OP_MUL:  									a = (BigInteger)a * b;  									break;  								case OpCode.OP_DIV:  									a = (BigInteger)a / b;  									break;  								case OpCode.OP_MOD:  									a = (BigInteger)a % b;  									break;  								case OpCode.OP_LSHIFT:  									a = (BigInteger)a << b.intValue;  									break;  								case OpCode.OP_RSHIFT:  									a = (BigInteger)a >> b.intValue;  									break;  							}  							stack.Push(a.ToBytes());  							break;  						}  					case OpCode.OP_BOOLAND:  						{  							if (stack.Count < 2)  								return false;  							if (!new ScriptVarInt(stack.Pop()).value.IsZero && !new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_BOOLOR:  						{  							if (stack.Count < 2)  								return false;  							if (!new ScriptVarInt(stack.Pop()).value.IsZero || !new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_NUMEQUAL:  					case OpCode.OP_NUMEQUALVERIFY:  						{  							if (stack.Count < 2)  								return false;  							if (new ScriptVarInt(stack.Pop()).value == new ScriptVarInt(stack.Pop()).value)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							if (se.opCode == OpCode.OP_NUMEQUALVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_NUMNOTEQUAL:  						{  							if (stack.Count < 2)  								return false;  							if (new ScriptVarInt(stack.Pop()).value != new ScriptVarInt(stack.Pop()).value)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_LESSTHAN:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a < b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_GREATERTHAN:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a > b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_LESSTHANOREQUAL:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a <= b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_GREATERTHANOREQUAL:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a >= b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_MIN:  						{  							if (stack.Count < 2)  								return false;  							Byte[] b = stack.Pop();  							Byte[] a = stack.Pop();  							if (new ScriptVarInt(a).value < new ScriptVarInt(b).value)  								stack.Push(a);  							else  								stack.Push(b);  							break;  						}  					case OpCode.OP_MAX:  						{  							if (stack.Count < 2)  								return false;  							Byte[] b = stack.Pop();  							Byte[] a = stack.Pop();  							if (new ScriptVarInt(a).value > new ScriptVarInt(b).value)  								stack.Push(a);  							else  								stack.Push(b);  							break;  						}  					case OpCode.OP_WITHIN:  						{  							if (stack.Count < 3)  								return false;  							ScriptVarInt max = new ScriptVarInt(stack.Pop());  							ScriptVarInt min = new ScriptVarInt(stack.Pop());  							ScriptVarInt x = new ScriptVarInt(stack.Pop());  							if ((BigInteger)min <= x && (BigInteger)x <= max)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_RIPEMD160:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(ripemd160.ComputeHash(stack.Pop()));  							break;  						}  					case OpCode.OP_SHA1:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(sha1.ComputeHash(stack.Pop()));  							break;  						}  					case OpCode.OP_SHA256:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(sha256.ComputeHash(stack.Pop()));  							break;  						}  					case OpCode.OP_HASH160:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(ripemd160.ComputeHash(sha256.ComputeHash(stack.Pop())));  							break;  						}  					case OpCode.OP_HASH256:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(sha256.ComputeHash(sha256.ComputeHash(stack.Pop())));  							break;  						}  					case OpCode.OP_CODESEPARATOR:  						{  							lastCodeSeperator = index;  							break;  						}  					case OpCode.OP_CHECKSIG:  					case OpCode.OP_CHECKSIGVERIFY:  						{  							if (tx == null)  								throw new ArgumentNullException("Transaction is required if script contains OP_CHECKSIG[VERIFY]");  							if (stack.Count < 2)  								return false;    							PublicKey pubKey = new PublicKey(stack.Pop());  							Byte[] sig = stack.Pop();    							Script subScript = new Script(elements.Skip(lastCodeSeperator)  								.Where(x => x.opCode != OpCode.OP_CODESEPARATOR).ToArray());    							stack.Push(new ScriptVarInt(CheckSig(sig' pubKey' txInIndex' subScript' tx) ? 1 : 0).ToBytes());    							if (se.opCode == OpCode.OP_CHECKSIGVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_CHECKMULTISIG:  					case OpCode.OP_CHECKMULTISIGVERIFY:  						{  							if (tx == null)  								throw new ArgumentNullException("Transaction is required if script contains OP_CHECKMULTISIG[VERIFY]");  							if (stack.Count < 2)  								return false;    							PublicKey[] pubKeys = new PublicKey[new ScriptVarInt(stack.Pop()).intValue];    							if (stack.Count < pubKeys.Length + 1)  								return false;    							for (int i = 0; i < pubKeys.Length; i++)  							{  								pubKeys[i] = new PublicKey(stack.Pop());  							}    							Byte[][] sigs = new Byte[new ScriptVarInt(stack.Pop()).intValue][];    							if (stack.Count < sigs.Length)  								return false;    							for (int i = 0; i < sigs.Length; i++)  							{  								sigs[i] = stack.Pop();  							}    							// Remove extra unused value from stack  							stack.Pop();    							Script subScript = new Script(elements.Skip(lastCodeSeperator)  								.Where(x => x.opCode != OpCode.OP_CODESEPARATOR).ToArray());    							int validSigs = 0;  							foreach (Byte[] sig in sigs)  							{  								foreach (PublicKey pubKey in pubKeys)  								{  									if (CheckSig(sig' pubKey' txInIndex' subScript' tx))  									{  										pubKeys = pubKeys.Where(x => x != pubKey).ToArray();  										validSigs++;  										break;  									}  								}  							}    							stack.Push(new ScriptVarInt((validSigs >= sigs.Length) ? 1 : 0).ToBytes());    							if (se.opCode == OpCode.OP_CHECKMULTISIGVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_NOP1:  					case OpCode.OP_NOP2:  					case OpCode.OP_NOP3:  					case OpCode.OP_NOP4:  					case OpCode.OP_NOP5:  					case OpCode.OP_NOP6:  					case OpCode.OP_NOP7:  					case OpCode.OP_NOP8:  					case OpCode.OP_NOP9:  					case OpCode.OP_NOP10:  						{  							break;  						}  					case OpCode.OP_SMALLINTEGER:  					case OpCode.OP_PUBKEYS:  					case OpCode.OP_PUBKEYHASH:  					case OpCode.OP_PUBKEY:  					case OpCode.OP_INVALIDOPCODE:  					default:  						{  							return false;  						}    				}  			}
Magic Number,Bitcoin_Tool.Scripts,Script,C:\repos\mb300sd_Bitcoin-Tool\Bitcoin Tool\Scripts\Script.cs,Evaluate,The following statement contains a magic number: for (int index = 0; index < elements.Count; index++)  			{  				ScriptElement se = elements[index];  				if (ifExec.Count > 0)  					if ((ifExec.First() == IfElseExec.SKIP_IF && !(se.opCode == OpCode.OP_ELSE || se.opCode == OpCode.OP_ENDIF)) ||  						(ifExec.First() == IfElseExec.SKIP_ELSE && !(se.opCode == OpCode.OP_ENDIF)))  						continue;    				if (se.isData)  				{  					stack.Push(se.data);  					continue;  				}    				switch (se.opCode)  				{  					case OpCode.OP_RESERVED:  						{  							return false;  						}  					case OpCode.OP_NOP:  						{  							// NOP' Dump stack for debug  							/*  							stack.ToList().ForEach(x => Console.WriteLine(HexString.FromByteArray(x)));  							Console.WriteLine("---------------------------");  							*/  							break;  						}  					case OpCode.OP_VER:  						{  							return false;  						}  					case OpCode.OP_IF:  					case OpCode.OP_NOTIF:  						{  							if (stack.Count < 1)  								return false;  							Boolean stackIsZero = new ScriptVarInt(stack.Pop()).value.IsZero;  							if ((se.opCode == OpCode.OP_IF && !stackIsZero) || (se.opCode == OpCode.OP_NOTIF && stackIsZero))  							{  								// Run to else or endif  								ifExec.Push(IfElseExec.RUN_IF);  							}  							else  							{  								// Skip to else or endif  								ifExec.Push(IfElseExec.SKIP_IF);  							}  							break;  						}  					case OpCode.OP_VERIF:  					case OpCode.OP_VERNOTIF:  						{  							return false;  						}  					case OpCode.OP_ELSE:  						{  							if (ifExec.Count == 0)  								// No preceding if statement!  								return false;  							if (ifExec.First() == IfElseExec.RUN_IF)  							{  								// If ran' skip else  								ifExec.Push(IfElseExec.SKIP_ELSE);  							}  							else if (ifExec.First() == IfElseExec.SKIP_IF)  							{  								// If did not run' run else  								ifExec.Push(IfElseExec.RUN_ELSE);  							}  							break;  						}  					case OpCode.OP_ENDIF:  						{  							if (ifExec.Count == 0)  								// No preceding if statement!  								return false;  							if (ifExec.First() == IfElseExec.RUN_IF ||  								ifExec.First() == IfElseExec.SKIP_IF)  							{  								ifExec.Pop();  							}  							else if (ifExec.First() == IfElseExec.RUN_ELSE ||  							   ifExec.First() == IfElseExec.SKIP_ELSE)  							{  								ifExec.Pop();  								ifExec.Pop();  							}  							break;  						}  					case OpCode.OP_VERIFY:  						{  							if (stack.Count < 1 || new ScriptVarInt(stack.First()).value.IsZero)  								return false;  							stack.Pop();  							break;  						}  					case OpCode.OP_RETURN:  						{  							return false;  						}  					case OpCode.OP_TOALTSTACK:  						{  							if (stack.Count < 1)  								return false;  							altstack.Push(stack.Pop());  							break;  						}  					case OpCode.OP_FROMALTSTACK:  						{  							if (altstack.Count < 1)  								return false;  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_2DROP:  						{  							if (stack.Count < 2)  								return false;  							stack.Pop();  							stack.Pop();  							break;  						}  					case OpCode.OP_2DUP:  						{  							if (stack.Count < 2)  								return false;  							stack.Push(stack.Skip(1).First());  							stack.Push(stack.Skip(1).First());  							break;  						}  					case OpCode.OP_3DUP:  						{  							if (stack.Count < 3)  								return false;  							stack.Push(stack.Skip(2).First());  							stack.Push(stack.Skip(2).First());  							stack.Push(stack.Skip(2).First());  							break;  						}  					case OpCode.OP_2OVER:  						{  							if (stack.Count < 4)  								return false;  							stack.Push(stack.Skip(3).First());  							stack.Push(stack.Skip(3).First());  							break;  						}  					case OpCode.OP_2ROT:  						{  							if (stack.Count < 6)  								return false;  							altstack.Push(stack.Skip(4).First());  							altstack.Push(stack.Skip(5).First());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_2SWAP:  						{  							if (stack.Count < 4)  								return false;  							altstack.Push(stack.Skip(2).First());  							altstack.Push(stack.Skip(3).First());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_IFDUP:  						{  							if (stack.Count < 1)  								return false;  							if (!new ScriptVarInt(stack.First()).value.IsZero)  								stack.Push(stack.First());  							break;  						}  					case OpCode.OP_DEPTH:  						{  							stack.Push(new ScriptVarInt((UInt64)stack.Count).ToBytes());  							break;  						}  					case OpCode.OP_DROP:  						{  							if (stack.Count < 1)  								return false;  							stack.Pop();  							break;  						}  					case OpCode.OP_DUP:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(stack.First());  							break;  						}  					case OpCode.OP_NIP:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_OVER:  						{  							if (stack.Count < 2)  								return false;  							stack.Push(stack.Skip(1).First());  							break;  						}  					case OpCode.OP_PICK:  						{  							if (stack.Count < 2)  								return false;  							int pick = new ScriptVarInt(stack.Pop()).intValue;  							if (pick < 0 || stack.Count <= pick)  								return false;  							stack.Push(stack.Skip(pick).First());  							break;  						}  					case OpCode.OP_ROLL:  						{  							if (stack.Count < 2)  								return false;  							int roll = new ScriptVarInt(stack.Pop()).intValue;  							if (roll < 0 || stack.Count <= roll)  								return false;  							altstack.Push(stack.Skip(roll).First());  							for (int i = 0; i < roll; i++)  								altstack.Push(stack.Pop());  							stack.Pop();  							for (int i = 0; i < roll + 1; i++)  								stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_ROT:  						{  							if (stack.Count < 3)  								return false;  							altstack.Push(stack.Skip(2).First());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_SWAP:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Skip(1).First());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_TUCK:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Push(altstack.Skip(1).First());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_CAT:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Skip(1).First().Concat(stack.First()).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_SUBSTR:  						{  							if (stack.Count < 3)  								return false;  							altstack.Push(stack.Skip(2).First()  								.Skip(new ScriptVarInt(stack.Skip(1).First()).intValue)  								.Take(new ScriptVarInt(stack.First()).intValue).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_LEFT:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Skip(1).First()  								.Take(new ScriptVarInt(stack.First()).intValue).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_RIGHT:  						{  							if (stack.Count < 2)  								return false;  							int count = new ScriptVarInt(stack.First()).intValue;  							altstack.Push(stack.Skip(1).First()  								.Skip(stack.Skip(1).First().Length - count).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_SIZE:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(new ScriptVarInt((UInt64)stack.First().Length).ToBytes());  							break;  						}  					case OpCode.OP_INVERT:  						{  							if (stack.Count < 1)  								return false;  							Byte[] data = stack.Pop();  							for (int i = 0; i < data.Length; i++)  								data[i] ^= 0xFF;  							stack.Push(data);  							break;  						}  					case OpCode.OP_AND:  					case OpCode.OP_OR:  					case OpCode.OP_XOR:  						{  							if (stack.Count < 2)  								return false;  							Byte[] data = stack.Pop();  							Byte[] data2 = stack.Pop();  							int length = new int[] { data.Length' data2.Length }.Max();  							data = data.Concat(new Byte[length - data.Length]).ToArray();  							data2 = data2.Concat(new Byte[length - data2.Length]).ToArray();  							switch (se.opCode)  							{  								case OpCode.OP_AND:  									{  										for (int i = 0; i < length; i++)  											data[i] &= data2[i];  										break;  									}  								case OpCode.OP_OR:  									{  										for (int i = 0; i < length; i++)  											data[i] |= data2[i];  										break;  									}  								case OpCode.OP_XOR:  									{  										for (int i = 0; i < length; i++)  											data[i] ^= data2[i];  										break;  									}  							}  							stack.Push(data);  							break;  						}  					case OpCode.OP_EQUAL:  					case OpCode.OP_EQUALVERIFY:  						{  							if (stack.Count < 2)  								return false;  							if (stack.Pop().SequenceEqual(stack.Pop()))  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });    							if (se.opCode == OpCode.OP_EQUALVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_RESERVED1:  					case OpCode.OP_RESERVED2:  						{  							return false;  						}  					case OpCode.OP_1ADD:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Add(new ScriptVarInt(stack.Pop())' 1)).ToBytes());  							break;  						}  					case OpCode.OP_1SUB:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Subtract(new ScriptVarInt(stack.Pop())' 1)).ToBytes());  							break;  						}  					case OpCode.OP_2MUL:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Multiply(new ScriptVarInt(stack.Pop())' 2)).ToBytes());  							break;  						}  					case OpCode.OP_2DIV:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Divide(new ScriptVarInt(stack.Pop())' 2)).ToBytes());  							break;  						}  					case OpCode.OP_NEGATE:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Negate(new ScriptVarInt(stack.Pop()))).ToBytes());  							break;  						}  					case OpCode.OP_ABS:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Abs(new ScriptVarInt(stack.Pop()))).ToBytes());  							break;  						}  					case OpCode.OP_NOT:  						{  							if (stack.Count < 1)  								return false;  							if (new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_0NOTEQUAL:  						{  							if (stack.Count < 1)  								return false;  							if (new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x00 });  							else  								stack.Push(new Byte[] { 0x01 });  							break;  						}  					case OpCode.OP_ADD:  					case OpCode.OP_SUB:  					case OpCode.OP_MUL:  					case OpCode.OP_DIV:  					case OpCode.OP_MOD:  					case OpCode.OP_LSHIFT:  					case OpCode.OP_RSHIFT:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							switch (se.opCode)  							{  								case OpCode.OP_ADD:  									a = (BigInteger)a + b;  									break;  								case OpCode.OP_SUB:  									a = (BigInteger)a - b;  									break;  								case OpCode.OP_MUL:  									a = (BigInteger)a * b;  									break;  								case OpCode.OP_DIV:  									a = (BigInteger)a / b;  									break;  								case OpCode.OP_MOD:  									a = (BigInteger)a % b;  									break;  								case OpCode.OP_LSHIFT:  									a = (BigInteger)a << b.intValue;  									break;  								case OpCode.OP_RSHIFT:  									a = (BigInteger)a >> b.intValue;  									break;  							}  							stack.Push(a.ToBytes());  							break;  						}  					case OpCode.OP_BOOLAND:  						{  							if (stack.Count < 2)  								return false;  							if (!new ScriptVarInt(stack.Pop()).value.IsZero && !new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_BOOLOR:  						{  							if (stack.Count < 2)  								return false;  							if (!new ScriptVarInt(stack.Pop()).value.IsZero || !new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_NUMEQUAL:  					case OpCode.OP_NUMEQUALVERIFY:  						{  							if (stack.Count < 2)  								return false;  							if (new ScriptVarInt(stack.Pop()).value == new ScriptVarInt(stack.Pop()).value)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							if (se.opCode == OpCode.OP_NUMEQUALVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_NUMNOTEQUAL:  						{  							if (stack.Count < 2)  								return false;  							if (new ScriptVarInt(stack.Pop()).value != new ScriptVarInt(stack.Pop()).value)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_LESSTHAN:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a < b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_GREATERTHAN:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a > b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_LESSTHANOREQUAL:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a <= b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_GREATERTHANOREQUAL:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a >= b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_MIN:  						{  							if (stack.Count < 2)  								return false;  							Byte[] b = stack.Pop();  							Byte[] a = stack.Pop();  							if (new ScriptVarInt(a).value < new ScriptVarInt(b).value)  								stack.Push(a);  							else  								stack.Push(b);  							break;  						}  					case OpCode.OP_MAX:  						{  							if (stack.Count < 2)  								return false;  							Byte[] b = stack.Pop();  							Byte[] a = stack.Pop();  							if (new ScriptVarInt(a).value > new ScriptVarInt(b).value)  								stack.Push(a);  							else  								stack.Push(b);  							break;  						}  					case OpCode.OP_WITHIN:  						{  							if (stack.Count < 3)  								return false;  							ScriptVarInt max = new ScriptVarInt(stack.Pop());  							ScriptVarInt min = new ScriptVarInt(stack.Pop());  							ScriptVarInt x = new ScriptVarInt(stack.Pop());  							if ((BigInteger)min <= x && (BigInteger)x <= max)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_RIPEMD160:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(ripemd160.ComputeHash(stack.Pop()));  							break;  						}  					case OpCode.OP_SHA1:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(sha1.ComputeHash(stack.Pop()));  							break;  						}  					case OpCode.OP_SHA256:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(sha256.ComputeHash(stack.Pop()));  							break;  						}  					case OpCode.OP_HASH160:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(ripemd160.ComputeHash(sha256.ComputeHash(stack.Pop())));  							break;  						}  					case OpCode.OP_HASH256:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(sha256.ComputeHash(sha256.ComputeHash(stack.Pop())));  							break;  						}  					case OpCode.OP_CODESEPARATOR:  						{  							lastCodeSeperator = index;  							break;  						}  					case OpCode.OP_CHECKSIG:  					case OpCode.OP_CHECKSIGVERIFY:  						{  							if (tx == null)  								throw new ArgumentNullException("Transaction is required if script contains OP_CHECKSIG[VERIFY]");  							if (stack.Count < 2)  								return false;    							PublicKey pubKey = new PublicKey(stack.Pop());  							Byte[] sig = stack.Pop();    							Script subScript = new Script(elements.Skip(lastCodeSeperator)  								.Where(x => x.opCode != OpCode.OP_CODESEPARATOR).ToArray());    							stack.Push(new ScriptVarInt(CheckSig(sig' pubKey' txInIndex' subScript' tx) ? 1 : 0).ToBytes());    							if (se.opCode == OpCode.OP_CHECKSIGVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_CHECKMULTISIG:  					case OpCode.OP_CHECKMULTISIGVERIFY:  						{  							if (tx == null)  								throw new ArgumentNullException("Transaction is required if script contains OP_CHECKMULTISIG[VERIFY]");  							if (stack.Count < 2)  								return false;    							PublicKey[] pubKeys = new PublicKey[new ScriptVarInt(stack.Pop()).intValue];    							if (stack.Count < pubKeys.Length + 1)  								return false;    							for (int i = 0; i < pubKeys.Length; i++)  							{  								pubKeys[i] = new PublicKey(stack.Pop());  							}    							Byte[][] sigs = new Byte[new ScriptVarInt(stack.Pop()).intValue][];    							if (stack.Count < sigs.Length)  								return false;    							for (int i = 0; i < sigs.Length; i++)  							{  								sigs[i] = stack.Pop();  							}    							// Remove extra unused value from stack  							stack.Pop();    							Script subScript = new Script(elements.Skip(lastCodeSeperator)  								.Where(x => x.opCode != OpCode.OP_CODESEPARATOR).ToArray());    							int validSigs = 0;  							foreach (Byte[] sig in sigs)  							{  								foreach (PublicKey pubKey in pubKeys)  								{  									if (CheckSig(sig' pubKey' txInIndex' subScript' tx))  									{  										pubKeys = pubKeys.Where(x => x != pubKey).ToArray();  										validSigs++;  										break;  									}  								}  							}    							stack.Push(new ScriptVarInt((validSigs >= sigs.Length) ? 1 : 0).ToBytes());    							if (se.opCode == OpCode.OP_CHECKMULTISIGVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_NOP1:  					case OpCode.OP_NOP2:  					case OpCode.OP_NOP3:  					case OpCode.OP_NOP4:  					case OpCode.OP_NOP5:  					case OpCode.OP_NOP6:  					case OpCode.OP_NOP7:  					case OpCode.OP_NOP8:  					case OpCode.OP_NOP9:  					case OpCode.OP_NOP10:  						{  							break;  						}  					case OpCode.OP_SMALLINTEGER:  					case OpCode.OP_PUBKEYS:  					case OpCode.OP_PUBKEYHASH:  					case OpCode.OP_PUBKEY:  					case OpCode.OP_INVALIDOPCODE:  					default:  						{  							return false;  						}    				}  			}
Magic Number,Bitcoin_Tool.Scripts,Script,C:\repos\mb300sd_Bitcoin-Tool\Bitcoin Tool\Scripts\Script.cs,Evaluate,The following statement contains a magic number: for (int index = 0; index < elements.Count; index++)  			{  				ScriptElement se = elements[index];  				if (ifExec.Count > 0)  					if ((ifExec.First() == IfElseExec.SKIP_IF && !(se.opCode == OpCode.OP_ELSE || se.opCode == OpCode.OP_ENDIF)) ||  						(ifExec.First() == IfElseExec.SKIP_ELSE && !(se.opCode == OpCode.OP_ENDIF)))  						continue;    				if (se.isData)  				{  					stack.Push(se.data);  					continue;  				}    				switch (se.opCode)  				{  					case OpCode.OP_RESERVED:  						{  							return false;  						}  					case OpCode.OP_NOP:  						{  							// NOP' Dump stack for debug  							/*  							stack.ToList().ForEach(x => Console.WriteLine(HexString.FromByteArray(x)));  							Console.WriteLine("---------------------------");  							*/  							break;  						}  					case OpCode.OP_VER:  						{  							return false;  						}  					case OpCode.OP_IF:  					case OpCode.OP_NOTIF:  						{  							if (stack.Count < 1)  								return false;  							Boolean stackIsZero = new ScriptVarInt(stack.Pop()).value.IsZero;  							if ((se.opCode == OpCode.OP_IF && !stackIsZero) || (se.opCode == OpCode.OP_NOTIF && stackIsZero))  							{  								// Run to else or endif  								ifExec.Push(IfElseExec.RUN_IF);  							}  							else  							{  								// Skip to else or endif  								ifExec.Push(IfElseExec.SKIP_IF);  							}  							break;  						}  					case OpCode.OP_VERIF:  					case OpCode.OP_VERNOTIF:  						{  							return false;  						}  					case OpCode.OP_ELSE:  						{  							if (ifExec.Count == 0)  								// No preceding if statement!  								return false;  							if (ifExec.First() == IfElseExec.RUN_IF)  							{  								// If ran' skip else  								ifExec.Push(IfElseExec.SKIP_ELSE);  							}  							else if (ifExec.First() == IfElseExec.SKIP_IF)  							{  								// If did not run' run else  								ifExec.Push(IfElseExec.RUN_ELSE);  							}  							break;  						}  					case OpCode.OP_ENDIF:  						{  							if (ifExec.Count == 0)  								// No preceding if statement!  								return false;  							if (ifExec.First() == IfElseExec.RUN_IF ||  								ifExec.First() == IfElseExec.SKIP_IF)  							{  								ifExec.Pop();  							}  							else if (ifExec.First() == IfElseExec.RUN_ELSE ||  							   ifExec.First() == IfElseExec.SKIP_ELSE)  							{  								ifExec.Pop();  								ifExec.Pop();  							}  							break;  						}  					case OpCode.OP_VERIFY:  						{  							if (stack.Count < 1 || new ScriptVarInt(stack.First()).value.IsZero)  								return false;  							stack.Pop();  							break;  						}  					case OpCode.OP_RETURN:  						{  							return false;  						}  					case OpCode.OP_TOALTSTACK:  						{  							if (stack.Count < 1)  								return false;  							altstack.Push(stack.Pop());  							break;  						}  					case OpCode.OP_FROMALTSTACK:  						{  							if (altstack.Count < 1)  								return false;  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_2DROP:  						{  							if (stack.Count < 2)  								return false;  							stack.Pop();  							stack.Pop();  							break;  						}  					case OpCode.OP_2DUP:  						{  							if (stack.Count < 2)  								return false;  							stack.Push(stack.Skip(1).First());  							stack.Push(stack.Skip(1).First());  							break;  						}  					case OpCode.OP_3DUP:  						{  							if (stack.Count < 3)  								return false;  							stack.Push(stack.Skip(2).First());  							stack.Push(stack.Skip(2).First());  							stack.Push(stack.Skip(2).First());  							break;  						}  					case OpCode.OP_2OVER:  						{  							if (stack.Count < 4)  								return false;  							stack.Push(stack.Skip(3).First());  							stack.Push(stack.Skip(3).First());  							break;  						}  					case OpCode.OP_2ROT:  						{  							if (stack.Count < 6)  								return false;  							altstack.Push(stack.Skip(4).First());  							altstack.Push(stack.Skip(5).First());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_2SWAP:  						{  							if (stack.Count < 4)  								return false;  							altstack.Push(stack.Skip(2).First());  							altstack.Push(stack.Skip(3).First());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_IFDUP:  						{  							if (stack.Count < 1)  								return false;  							if (!new ScriptVarInt(stack.First()).value.IsZero)  								stack.Push(stack.First());  							break;  						}  					case OpCode.OP_DEPTH:  						{  							stack.Push(new ScriptVarInt((UInt64)stack.Count).ToBytes());  							break;  						}  					case OpCode.OP_DROP:  						{  							if (stack.Count < 1)  								return false;  							stack.Pop();  							break;  						}  					case OpCode.OP_DUP:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(stack.First());  							break;  						}  					case OpCode.OP_NIP:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_OVER:  						{  							if (stack.Count < 2)  								return false;  							stack.Push(stack.Skip(1).First());  							break;  						}  					case OpCode.OP_PICK:  						{  							if (stack.Count < 2)  								return false;  							int pick = new ScriptVarInt(stack.Pop()).intValue;  							if (pick < 0 || stack.Count <= pick)  								return false;  							stack.Push(stack.Skip(pick).First());  							break;  						}  					case OpCode.OP_ROLL:  						{  							if (stack.Count < 2)  								return false;  							int roll = new ScriptVarInt(stack.Pop()).intValue;  							if (roll < 0 || stack.Count <= roll)  								return false;  							altstack.Push(stack.Skip(roll).First());  							for (int i = 0; i < roll; i++)  								altstack.Push(stack.Pop());  							stack.Pop();  							for (int i = 0; i < roll + 1; i++)  								stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_ROT:  						{  							if (stack.Count < 3)  								return false;  							altstack.Push(stack.Skip(2).First());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_SWAP:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Skip(1).First());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_TUCK:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Push(altstack.Skip(1).First());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_CAT:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Skip(1).First().Concat(stack.First()).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_SUBSTR:  						{  							if (stack.Count < 3)  								return false;  							altstack.Push(stack.Skip(2).First()  								.Skip(new ScriptVarInt(stack.Skip(1).First()).intValue)  								.Take(new ScriptVarInt(stack.First()).intValue).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_LEFT:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Skip(1).First()  								.Take(new ScriptVarInt(stack.First()).intValue).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_RIGHT:  						{  							if (stack.Count < 2)  								return false;  							int count = new ScriptVarInt(stack.First()).intValue;  							altstack.Push(stack.Skip(1).First()  								.Skip(stack.Skip(1).First().Length - count).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_SIZE:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(new ScriptVarInt((UInt64)stack.First().Length).ToBytes());  							break;  						}  					case OpCode.OP_INVERT:  						{  							if (stack.Count < 1)  								return false;  							Byte[] data = stack.Pop();  							for (int i = 0; i < data.Length; i++)  								data[i] ^= 0xFF;  							stack.Push(data);  							break;  						}  					case OpCode.OP_AND:  					case OpCode.OP_OR:  					case OpCode.OP_XOR:  						{  							if (stack.Count < 2)  								return false;  							Byte[] data = stack.Pop();  							Byte[] data2 = stack.Pop();  							int length = new int[] { data.Length' data2.Length }.Max();  							data = data.Concat(new Byte[length - data.Length]).ToArray();  							data2 = data2.Concat(new Byte[length - data2.Length]).ToArray();  							switch (se.opCode)  							{  								case OpCode.OP_AND:  									{  										for (int i = 0; i < length; i++)  											data[i] &= data2[i];  										break;  									}  								case OpCode.OP_OR:  									{  										for (int i = 0; i < length; i++)  											data[i] |= data2[i];  										break;  									}  								case OpCode.OP_XOR:  									{  										for (int i = 0; i < length; i++)  											data[i] ^= data2[i];  										break;  									}  							}  							stack.Push(data);  							break;  						}  					case OpCode.OP_EQUAL:  					case OpCode.OP_EQUALVERIFY:  						{  							if (stack.Count < 2)  								return false;  							if (stack.Pop().SequenceEqual(stack.Pop()))  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });    							if (se.opCode == OpCode.OP_EQUALVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_RESERVED1:  					case OpCode.OP_RESERVED2:  						{  							return false;  						}  					case OpCode.OP_1ADD:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Add(new ScriptVarInt(stack.Pop())' 1)).ToBytes());  							break;  						}  					case OpCode.OP_1SUB:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Subtract(new ScriptVarInt(stack.Pop())' 1)).ToBytes());  							break;  						}  					case OpCode.OP_2MUL:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Multiply(new ScriptVarInt(stack.Pop())' 2)).ToBytes());  							break;  						}  					case OpCode.OP_2DIV:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Divide(new ScriptVarInt(stack.Pop())' 2)).ToBytes());  							break;  						}  					case OpCode.OP_NEGATE:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Negate(new ScriptVarInt(stack.Pop()))).ToBytes());  							break;  						}  					case OpCode.OP_ABS:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Abs(new ScriptVarInt(stack.Pop()))).ToBytes());  							break;  						}  					case OpCode.OP_NOT:  						{  							if (stack.Count < 1)  								return false;  							if (new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_0NOTEQUAL:  						{  							if (stack.Count < 1)  								return false;  							if (new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x00 });  							else  								stack.Push(new Byte[] { 0x01 });  							break;  						}  					case OpCode.OP_ADD:  					case OpCode.OP_SUB:  					case OpCode.OP_MUL:  					case OpCode.OP_DIV:  					case OpCode.OP_MOD:  					case OpCode.OP_LSHIFT:  					case OpCode.OP_RSHIFT:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							switch (se.opCode)  							{  								case OpCode.OP_ADD:  									a = (BigInteger)a + b;  									break;  								case OpCode.OP_SUB:  									a = (BigInteger)a - b;  									break;  								case OpCode.OP_MUL:  									a = (BigInteger)a * b;  									break;  								case OpCode.OP_DIV:  									a = (BigInteger)a / b;  									break;  								case OpCode.OP_MOD:  									a = (BigInteger)a % b;  									break;  								case OpCode.OP_LSHIFT:  									a = (BigInteger)a << b.intValue;  									break;  								case OpCode.OP_RSHIFT:  									a = (BigInteger)a >> b.intValue;  									break;  							}  							stack.Push(a.ToBytes());  							break;  						}  					case OpCode.OP_BOOLAND:  						{  							if (stack.Count < 2)  								return false;  							if (!new ScriptVarInt(stack.Pop()).value.IsZero && !new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_BOOLOR:  						{  							if (stack.Count < 2)  								return false;  							if (!new ScriptVarInt(stack.Pop()).value.IsZero || !new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_NUMEQUAL:  					case OpCode.OP_NUMEQUALVERIFY:  						{  							if (stack.Count < 2)  								return false;  							if (new ScriptVarInt(stack.Pop()).value == new ScriptVarInt(stack.Pop()).value)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							if (se.opCode == OpCode.OP_NUMEQUALVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_NUMNOTEQUAL:  						{  							if (stack.Count < 2)  								return false;  							if (new ScriptVarInt(stack.Pop()).value != new ScriptVarInt(stack.Pop()).value)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_LESSTHAN:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a < b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_GREATERTHAN:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a > b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_LESSTHANOREQUAL:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a <= b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_GREATERTHANOREQUAL:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a >= b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_MIN:  						{  							if (stack.Count < 2)  								return false;  							Byte[] b = stack.Pop();  							Byte[] a = stack.Pop();  							if (new ScriptVarInt(a).value < new ScriptVarInt(b).value)  								stack.Push(a);  							else  								stack.Push(b);  							break;  						}  					case OpCode.OP_MAX:  						{  							if (stack.Count < 2)  								return false;  							Byte[] b = stack.Pop();  							Byte[] a = stack.Pop();  							if (new ScriptVarInt(a).value > new ScriptVarInt(b).value)  								stack.Push(a);  							else  								stack.Push(b);  							break;  						}  					case OpCode.OP_WITHIN:  						{  							if (stack.Count < 3)  								return false;  							ScriptVarInt max = new ScriptVarInt(stack.Pop());  							ScriptVarInt min = new ScriptVarInt(stack.Pop());  							ScriptVarInt x = new ScriptVarInt(stack.Pop());  							if ((BigInteger)min <= x && (BigInteger)x <= max)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_RIPEMD160:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(ripemd160.ComputeHash(stack.Pop()));  							break;  						}  					case OpCode.OP_SHA1:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(sha1.ComputeHash(stack.Pop()));  							break;  						}  					case OpCode.OP_SHA256:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(sha256.ComputeHash(stack.Pop()));  							break;  						}  					case OpCode.OP_HASH160:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(ripemd160.ComputeHash(sha256.ComputeHash(stack.Pop())));  							break;  						}  					case OpCode.OP_HASH256:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(sha256.ComputeHash(sha256.ComputeHash(stack.Pop())));  							break;  						}  					case OpCode.OP_CODESEPARATOR:  						{  							lastCodeSeperator = index;  							break;  						}  					case OpCode.OP_CHECKSIG:  					case OpCode.OP_CHECKSIGVERIFY:  						{  							if (tx == null)  								throw new ArgumentNullException("Transaction is required if script contains OP_CHECKSIG[VERIFY]");  							if (stack.Count < 2)  								return false;    							PublicKey pubKey = new PublicKey(stack.Pop());  							Byte[] sig = stack.Pop();    							Script subScript = new Script(elements.Skip(lastCodeSeperator)  								.Where(x => x.opCode != OpCode.OP_CODESEPARATOR).ToArray());    							stack.Push(new ScriptVarInt(CheckSig(sig' pubKey' txInIndex' subScript' tx) ? 1 : 0).ToBytes());    							if (se.opCode == OpCode.OP_CHECKSIGVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_CHECKMULTISIG:  					case OpCode.OP_CHECKMULTISIGVERIFY:  						{  							if (tx == null)  								throw new ArgumentNullException("Transaction is required if script contains OP_CHECKMULTISIG[VERIFY]");  							if (stack.Count < 2)  								return false;    							PublicKey[] pubKeys = new PublicKey[new ScriptVarInt(stack.Pop()).intValue];    							if (stack.Count < pubKeys.Length + 1)  								return false;    							for (int i = 0; i < pubKeys.Length; i++)  							{  								pubKeys[i] = new PublicKey(stack.Pop());  							}    							Byte[][] sigs = new Byte[new ScriptVarInt(stack.Pop()).intValue][];    							if (stack.Count < sigs.Length)  								return false;    							for (int i = 0; i < sigs.Length; i++)  							{  								sigs[i] = stack.Pop();  							}    							// Remove extra unused value from stack  							stack.Pop();    							Script subScript = new Script(elements.Skip(lastCodeSeperator)  								.Where(x => x.opCode != OpCode.OP_CODESEPARATOR).ToArray());    							int validSigs = 0;  							foreach (Byte[] sig in sigs)  							{  								foreach (PublicKey pubKey in pubKeys)  								{  									if (CheckSig(sig' pubKey' txInIndex' subScript' tx))  									{  										pubKeys = pubKeys.Where(x => x != pubKey).ToArray();  										validSigs++;  										break;  									}  								}  							}    							stack.Push(new ScriptVarInt((validSigs >= sigs.Length) ? 1 : 0).ToBytes());    							if (se.opCode == OpCode.OP_CHECKMULTISIGVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_NOP1:  					case OpCode.OP_NOP2:  					case OpCode.OP_NOP3:  					case OpCode.OP_NOP4:  					case OpCode.OP_NOP5:  					case OpCode.OP_NOP6:  					case OpCode.OP_NOP7:  					case OpCode.OP_NOP8:  					case OpCode.OP_NOP9:  					case OpCode.OP_NOP10:  						{  							break;  						}  					case OpCode.OP_SMALLINTEGER:  					case OpCode.OP_PUBKEYS:  					case OpCode.OP_PUBKEYHASH:  					case OpCode.OP_PUBKEY:  					case OpCode.OP_INVALIDOPCODE:  					default:  						{  							return false;  						}    				}  			}
Magic Number,Bitcoin_Tool.Scripts,Script,C:\repos\mb300sd_Bitcoin-Tool\Bitcoin Tool\Scripts\Script.cs,Evaluate,The following statement contains a magic number: for (int index = 0; index < elements.Count; index++)  			{  				ScriptElement se = elements[index];  				if (ifExec.Count > 0)  					if ((ifExec.First() == IfElseExec.SKIP_IF && !(se.opCode == OpCode.OP_ELSE || se.opCode == OpCode.OP_ENDIF)) ||  						(ifExec.First() == IfElseExec.SKIP_ELSE && !(se.opCode == OpCode.OP_ENDIF)))  						continue;    				if (se.isData)  				{  					stack.Push(se.data);  					continue;  				}    				switch (se.opCode)  				{  					case OpCode.OP_RESERVED:  						{  							return false;  						}  					case OpCode.OP_NOP:  						{  							// NOP' Dump stack for debug  							/*  							stack.ToList().ForEach(x => Console.WriteLine(HexString.FromByteArray(x)));  							Console.WriteLine("---------------------------");  							*/  							break;  						}  					case OpCode.OP_VER:  						{  							return false;  						}  					case OpCode.OP_IF:  					case OpCode.OP_NOTIF:  						{  							if (stack.Count < 1)  								return false;  							Boolean stackIsZero = new ScriptVarInt(stack.Pop()).value.IsZero;  							if ((se.opCode == OpCode.OP_IF && !stackIsZero) || (se.opCode == OpCode.OP_NOTIF && stackIsZero))  							{  								// Run to else or endif  								ifExec.Push(IfElseExec.RUN_IF);  							}  							else  							{  								// Skip to else or endif  								ifExec.Push(IfElseExec.SKIP_IF);  							}  							break;  						}  					case OpCode.OP_VERIF:  					case OpCode.OP_VERNOTIF:  						{  							return false;  						}  					case OpCode.OP_ELSE:  						{  							if (ifExec.Count == 0)  								// No preceding if statement!  								return false;  							if (ifExec.First() == IfElseExec.RUN_IF)  							{  								// If ran' skip else  								ifExec.Push(IfElseExec.SKIP_ELSE);  							}  							else if (ifExec.First() == IfElseExec.SKIP_IF)  							{  								// If did not run' run else  								ifExec.Push(IfElseExec.RUN_ELSE);  							}  							break;  						}  					case OpCode.OP_ENDIF:  						{  							if (ifExec.Count == 0)  								// No preceding if statement!  								return false;  							if (ifExec.First() == IfElseExec.RUN_IF ||  								ifExec.First() == IfElseExec.SKIP_IF)  							{  								ifExec.Pop();  							}  							else if (ifExec.First() == IfElseExec.RUN_ELSE ||  							   ifExec.First() == IfElseExec.SKIP_ELSE)  							{  								ifExec.Pop();  								ifExec.Pop();  							}  							break;  						}  					case OpCode.OP_VERIFY:  						{  							if (stack.Count < 1 || new ScriptVarInt(stack.First()).value.IsZero)  								return false;  							stack.Pop();  							break;  						}  					case OpCode.OP_RETURN:  						{  							return false;  						}  					case OpCode.OP_TOALTSTACK:  						{  							if (stack.Count < 1)  								return false;  							altstack.Push(stack.Pop());  							break;  						}  					case OpCode.OP_FROMALTSTACK:  						{  							if (altstack.Count < 1)  								return false;  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_2DROP:  						{  							if (stack.Count < 2)  								return false;  							stack.Pop();  							stack.Pop();  							break;  						}  					case OpCode.OP_2DUP:  						{  							if (stack.Count < 2)  								return false;  							stack.Push(stack.Skip(1).First());  							stack.Push(stack.Skip(1).First());  							break;  						}  					case OpCode.OP_3DUP:  						{  							if (stack.Count < 3)  								return false;  							stack.Push(stack.Skip(2).First());  							stack.Push(stack.Skip(2).First());  							stack.Push(stack.Skip(2).First());  							break;  						}  					case OpCode.OP_2OVER:  						{  							if (stack.Count < 4)  								return false;  							stack.Push(stack.Skip(3).First());  							stack.Push(stack.Skip(3).First());  							break;  						}  					case OpCode.OP_2ROT:  						{  							if (stack.Count < 6)  								return false;  							altstack.Push(stack.Skip(4).First());  							altstack.Push(stack.Skip(5).First());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_2SWAP:  						{  							if (stack.Count < 4)  								return false;  							altstack.Push(stack.Skip(2).First());  							altstack.Push(stack.Skip(3).First());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_IFDUP:  						{  							if (stack.Count < 1)  								return false;  							if (!new ScriptVarInt(stack.First()).value.IsZero)  								stack.Push(stack.First());  							break;  						}  					case OpCode.OP_DEPTH:  						{  							stack.Push(new ScriptVarInt((UInt64)stack.Count).ToBytes());  							break;  						}  					case OpCode.OP_DROP:  						{  							if (stack.Count < 1)  								return false;  							stack.Pop();  							break;  						}  					case OpCode.OP_DUP:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(stack.First());  							break;  						}  					case OpCode.OP_NIP:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_OVER:  						{  							if (stack.Count < 2)  								return false;  							stack.Push(stack.Skip(1).First());  							break;  						}  					case OpCode.OP_PICK:  						{  							if (stack.Count < 2)  								return false;  							int pick = new ScriptVarInt(stack.Pop()).intValue;  							if (pick < 0 || stack.Count <= pick)  								return false;  							stack.Push(stack.Skip(pick).First());  							break;  						}  					case OpCode.OP_ROLL:  						{  							if (stack.Count < 2)  								return false;  							int roll = new ScriptVarInt(stack.Pop()).intValue;  							if (roll < 0 || stack.Count <= roll)  								return false;  							altstack.Push(stack.Skip(roll).First());  							for (int i = 0; i < roll; i++)  								altstack.Push(stack.Pop());  							stack.Pop();  							for (int i = 0; i < roll + 1; i++)  								stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_ROT:  						{  							if (stack.Count < 3)  								return false;  							altstack.Push(stack.Skip(2).First());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_SWAP:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Skip(1).First());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_TUCK:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Push(altstack.Skip(1).First());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_CAT:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Skip(1).First().Concat(stack.First()).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_SUBSTR:  						{  							if (stack.Count < 3)  								return false;  							altstack.Push(stack.Skip(2).First()  								.Skip(new ScriptVarInt(stack.Skip(1).First()).intValue)  								.Take(new ScriptVarInt(stack.First()).intValue).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_LEFT:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Skip(1).First()  								.Take(new ScriptVarInt(stack.First()).intValue).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_RIGHT:  						{  							if (stack.Count < 2)  								return false;  							int count = new ScriptVarInt(stack.First()).intValue;  							altstack.Push(stack.Skip(1).First()  								.Skip(stack.Skip(1).First().Length - count).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_SIZE:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(new ScriptVarInt((UInt64)stack.First().Length).ToBytes());  							break;  						}  					case OpCode.OP_INVERT:  						{  							if (stack.Count < 1)  								return false;  							Byte[] data = stack.Pop();  							for (int i = 0; i < data.Length; i++)  								data[i] ^= 0xFF;  							stack.Push(data);  							break;  						}  					case OpCode.OP_AND:  					case OpCode.OP_OR:  					case OpCode.OP_XOR:  						{  							if (stack.Count < 2)  								return false;  							Byte[] data = stack.Pop();  							Byte[] data2 = stack.Pop();  							int length = new int[] { data.Length' data2.Length }.Max();  							data = data.Concat(new Byte[length - data.Length]).ToArray();  							data2 = data2.Concat(new Byte[length - data2.Length]).ToArray();  							switch (se.opCode)  							{  								case OpCode.OP_AND:  									{  										for (int i = 0; i < length; i++)  											data[i] &= data2[i];  										break;  									}  								case OpCode.OP_OR:  									{  										for (int i = 0; i < length; i++)  											data[i] |= data2[i];  										break;  									}  								case OpCode.OP_XOR:  									{  										for (int i = 0; i < length; i++)  											data[i] ^= data2[i];  										break;  									}  							}  							stack.Push(data);  							break;  						}  					case OpCode.OP_EQUAL:  					case OpCode.OP_EQUALVERIFY:  						{  							if (stack.Count < 2)  								return false;  							if (stack.Pop().SequenceEqual(stack.Pop()))  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });    							if (se.opCode == OpCode.OP_EQUALVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_RESERVED1:  					case OpCode.OP_RESERVED2:  						{  							return false;  						}  					case OpCode.OP_1ADD:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Add(new ScriptVarInt(stack.Pop())' 1)).ToBytes());  							break;  						}  					case OpCode.OP_1SUB:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Subtract(new ScriptVarInt(stack.Pop())' 1)).ToBytes());  							break;  						}  					case OpCode.OP_2MUL:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Multiply(new ScriptVarInt(stack.Pop())' 2)).ToBytes());  							break;  						}  					case OpCode.OP_2DIV:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Divide(new ScriptVarInt(stack.Pop())' 2)).ToBytes());  							break;  						}  					case OpCode.OP_NEGATE:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Negate(new ScriptVarInt(stack.Pop()))).ToBytes());  							break;  						}  					case OpCode.OP_ABS:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Abs(new ScriptVarInt(stack.Pop()))).ToBytes());  							break;  						}  					case OpCode.OP_NOT:  						{  							if (stack.Count < 1)  								return false;  							if (new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_0NOTEQUAL:  						{  							if (stack.Count < 1)  								return false;  							if (new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x00 });  							else  								stack.Push(new Byte[] { 0x01 });  							break;  						}  					case OpCode.OP_ADD:  					case OpCode.OP_SUB:  					case OpCode.OP_MUL:  					case OpCode.OP_DIV:  					case OpCode.OP_MOD:  					case OpCode.OP_LSHIFT:  					case OpCode.OP_RSHIFT:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							switch (se.opCode)  							{  								case OpCode.OP_ADD:  									a = (BigInteger)a + b;  									break;  								case OpCode.OP_SUB:  									a = (BigInteger)a - b;  									break;  								case OpCode.OP_MUL:  									a = (BigInteger)a * b;  									break;  								case OpCode.OP_DIV:  									a = (BigInteger)a / b;  									break;  								case OpCode.OP_MOD:  									a = (BigInteger)a % b;  									break;  								case OpCode.OP_LSHIFT:  									a = (BigInteger)a << b.intValue;  									break;  								case OpCode.OP_RSHIFT:  									a = (BigInteger)a >> b.intValue;  									break;  							}  							stack.Push(a.ToBytes());  							break;  						}  					case OpCode.OP_BOOLAND:  						{  							if (stack.Count < 2)  								return false;  							if (!new ScriptVarInt(stack.Pop()).value.IsZero && !new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_BOOLOR:  						{  							if (stack.Count < 2)  								return false;  							if (!new ScriptVarInt(stack.Pop()).value.IsZero || !new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_NUMEQUAL:  					case OpCode.OP_NUMEQUALVERIFY:  						{  							if (stack.Count < 2)  								return false;  							if (new ScriptVarInt(stack.Pop()).value == new ScriptVarInt(stack.Pop()).value)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							if (se.opCode == OpCode.OP_NUMEQUALVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_NUMNOTEQUAL:  						{  							if (stack.Count < 2)  								return false;  							if (new ScriptVarInt(stack.Pop()).value != new ScriptVarInt(stack.Pop()).value)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_LESSTHAN:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a < b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_GREATERTHAN:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a > b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_LESSTHANOREQUAL:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a <= b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_GREATERTHANOREQUAL:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a >= b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_MIN:  						{  							if (stack.Count < 2)  								return false;  							Byte[] b = stack.Pop();  							Byte[] a = stack.Pop();  							if (new ScriptVarInt(a).value < new ScriptVarInt(b).value)  								stack.Push(a);  							else  								stack.Push(b);  							break;  						}  					case OpCode.OP_MAX:  						{  							if (stack.Count < 2)  								return false;  							Byte[] b = stack.Pop();  							Byte[] a = stack.Pop();  							if (new ScriptVarInt(a).value > new ScriptVarInt(b).value)  								stack.Push(a);  							else  								stack.Push(b);  							break;  						}  					case OpCode.OP_WITHIN:  						{  							if (stack.Count < 3)  								return false;  							ScriptVarInt max = new ScriptVarInt(stack.Pop());  							ScriptVarInt min = new ScriptVarInt(stack.Pop());  							ScriptVarInt x = new ScriptVarInt(stack.Pop());  							if ((BigInteger)min <= x && (BigInteger)x <= max)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_RIPEMD160:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(ripemd160.ComputeHash(stack.Pop()));  							break;  						}  					case OpCode.OP_SHA1:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(sha1.ComputeHash(stack.Pop()));  							break;  						}  					case OpCode.OP_SHA256:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(sha256.ComputeHash(stack.Pop()));  							break;  						}  					case OpCode.OP_HASH160:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(ripemd160.ComputeHash(sha256.ComputeHash(stack.Pop())));  							break;  						}  					case OpCode.OP_HASH256:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(sha256.ComputeHash(sha256.ComputeHash(stack.Pop())));  							break;  						}  					case OpCode.OP_CODESEPARATOR:  						{  							lastCodeSeperator = index;  							break;  						}  					case OpCode.OP_CHECKSIG:  					case OpCode.OP_CHECKSIGVERIFY:  						{  							if (tx == null)  								throw new ArgumentNullException("Transaction is required if script contains OP_CHECKSIG[VERIFY]");  							if (stack.Count < 2)  								return false;    							PublicKey pubKey = new PublicKey(stack.Pop());  							Byte[] sig = stack.Pop();    							Script subScript = new Script(elements.Skip(lastCodeSeperator)  								.Where(x => x.opCode != OpCode.OP_CODESEPARATOR).ToArray());    							stack.Push(new ScriptVarInt(CheckSig(sig' pubKey' txInIndex' subScript' tx) ? 1 : 0).ToBytes());    							if (se.opCode == OpCode.OP_CHECKSIGVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_CHECKMULTISIG:  					case OpCode.OP_CHECKMULTISIGVERIFY:  						{  							if (tx == null)  								throw new ArgumentNullException("Transaction is required if script contains OP_CHECKMULTISIG[VERIFY]");  							if (stack.Count < 2)  								return false;    							PublicKey[] pubKeys = new PublicKey[new ScriptVarInt(stack.Pop()).intValue];    							if (stack.Count < pubKeys.Length + 1)  								return false;    							for (int i = 0; i < pubKeys.Length; i++)  							{  								pubKeys[i] = new PublicKey(stack.Pop());  							}    							Byte[][] sigs = new Byte[new ScriptVarInt(stack.Pop()).intValue][];    							if (stack.Count < sigs.Length)  								return false;    							for (int i = 0; i < sigs.Length; i++)  							{  								sigs[i] = stack.Pop();  							}    							// Remove extra unused value from stack  							stack.Pop();    							Script subScript = new Script(elements.Skip(lastCodeSeperator)  								.Where(x => x.opCode != OpCode.OP_CODESEPARATOR).ToArray());    							int validSigs = 0;  							foreach (Byte[] sig in sigs)  							{  								foreach (PublicKey pubKey in pubKeys)  								{  									if (CheckSig(sig' pubKey' txInIndex' subScript' tx))  									{  										pubKeys = pubKeys.Where(x => x != pubKey).ToArray();  										validSigs++;  										break;  									}  								}  							}    							stack.Push(new ScriptVarInt((validSigs >= sigs.Length) ? 1 : 0).ToBytes());    							if (se.opCode == OpCode.OP_CHECKMULTISIGVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_NOP1:  					case OpCode.OP_NOP2:  					case OpCode.OP_NOP3:  					case OpCode.OP_NOP4:  					case OpCode.OP_NOP5:  					case OpCode.OP_NOP6:  					case OpCode.OP_NOP7:  					case OpCode.OP_NOP8:  					case OpCode.OP_NOP9:  					case OpCode.OP_NOP10:  						{  							break;  						}  					case OpCode.OP_SMALLINTEGER:  					case OpCode.OP_PUBKEYS:  					case OpCode.OP_PUBKEYHASH:  					case OpCode.OP_PUBKEY:  					case OpCode.OP_INVALIDOPCODE:  					default:  						{  							return false;  						}    				}  			}
Magic Number,Bitcoin_Tool.Scripts,Script,C:\repos\mb300sd_Bitcoin-Tool\Bitcoin Tool\Scripts\Script.cs,Evaluate,The following statement contains a magic number: for (int index = 0; index < elements.Count; index++)  			{  				ScriptElement se = elements[index];  				if (ifExec.Count > 0)  					if ((ifExec.First() == IfElseExec.SKIP_IF && !(se.opCode == OpCode.OP_ELSE || se.opCode == OpCode.OP_ENDIF)) ||  						(ifExec.First() == IfElseExec.SKIP_ELSE && !(se.opCode == OpCode.OP_ENDIF)))  						continue;    				if (se.isData)  				{  					stack.Push(se.data);  					continue;  				}    				switch (se.opCode)  				{  					case OpCode.OP_RESERVED:  						{  							return false;  						}  					case OpCode.OP_NOP:  						{  							// NOP' Dump stack for debug  							/*  							stack.ToList().ForEach(x => Console.WriteLine(HexString.FromByteArray(x)));  							Console.WriteLine("---------------------------");  							*/  							break;  						}  					case OpCode.OP_VER:  						{  							return false;  						}  					case OpCode.OP_IF:  					case OpCode.OP_NOTIF:  						{  							if (stack.Count < 1)  								return false;  							Boolean stackIsZero = new ScriptVarInt(stack.Pop()).value.IsZero;  							if ((se.opCode == OpCode.OP_IF && !stackIsZero) || (se.opCode == OpCode.OP_NOTIF && stackIsZero))  							{  								// Run to else or endif  								ifExec.Push(IfElseExec.RUN_IF);  							}  							else  							{  								// Skip to else or endif  								ifExec.Push(IfElseExec.SKIP_IF);  							}  							break;  						}  					case OpCode.OP_VERIF:  					case OpCode.OP_VERNOTIF:  						{  							return false;  						}  					case OpCode.OP_ELSE:  						{  							if (ifExec.Count == 0)  								// No preceding if statement!  								return false;  							if (ifExec.First() == IfElseExec.RUN_IF)  							{  								// If ran' skip else  								ifExec.Push(IfElseExec.SKIP_ELSE);  							}  							else if (ifExec.First() == IfElseExec.SKIP_IF)  							{  								// If did not run' run else  								ifExec.Push(IfElseExec.RUN_ELSE);  							}  							break;  						}  					case OpCode.OP_ENDIF:  						{  							if (ifExec.Count == 0)  								// No preceding if statement!  								return false;  							if (ifExec.First() == IfElseExec.RUN_IF ||  								ifExec.First() == IfElseExec.SKIP_IF)  							{  								ifExec.Pop();  							}  							else if (ifExec.First() == IfElseExec.RUN_ELSE ||  							   ifExec.First() == IfElseExec.SKIP_ELSE)  							{  								ifExec.Pop();  								ifExec.Pop();  							}  							break;  						}  					case OpCode.OP_VERIFY:  						{  							if (stack.Count < 1 || new ScriptVarInt(stack.First()).value.IsZero)  								return false;  							stack.Pop();  							break;  						}  					case OpCode.OP_RETURN:  						{  							return false;  						}  					case OpCode.OP_TOALTSTACK:  						{  							if (stack.Count < 1)  								return false;  							altstack.Push(stack.Pop());  							break;  						}  					case OpCode.OP_FROMALTSTACK:  						{  							if (altstack.Count < 1)  								return false;  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_2DROP:  						{  							if (stack.Count < 2)  								return false;  							stack.Pop();  							stack.Pop();  							break;  						}  					case OpCode.OP_2DUP:  						{  							if (stack.Count < 2)  								return false;  							stack.Push(stack.Skip(1).First());  							stack.Push(stack.Skip(1).First());  							break;  						}  					case OpCode.OP_3DUP:  						{  							if (stack.Count < 3)  								return false;  							stack.Push(stack.Skip(2).First());  							stack.Push(stack.Skip(2).First());  							stack.Push(stack.Skip(2).First());  							break;  						}  					case OpCode.OP_2OVER:  						{  							if (stack.Count < 4)  								return false;  							stack.Push(stack.Skip(3).First());  							stack.Push(stack.Skip(3).First());  							break;  						}  					case OpCode.OP_2ROT:  						{  							if (stack.Count < 6)  								return false;  							altstack.Push(stack.Skip(4).First());  							altstack.Push(stack.Skip(5).First());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_2SWAP:  						{  							if (stack.Count < 4)  								return false;  							altstack.Push(stack.Skip(2).First());  							altstack.Push(stack.Skip(3).First());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_IFDUP:  						{  							if (stack.Count < 1)  								return false;  							if (!new ScriptVarInt(stack.First()).value.IsZero)  								stack.Push(stack.First());  							break;  						}  					case OpCode.OP_DEPTH:  						{  							stack.Push(new ScriptVarInt((UInt64)stack.Count).ToBytes());  							break;  						}  					case OpCode.OP_DROP:  						{  							if (stack.Count < 1)  								return false;  							stack.Pop();  							break;  						}  					case OpCode.OP_DUP:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(stack.First());  							break;  						}  					case OpCode.OP_NIP:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_OVER:  						{  							if (stack.Count < 2)  								return false;  							stack.Push(stack.Skip(1).First());  							break;  						}  					case OpCode.OP_PICK:  						{  							if (stack.Count < 2)  								return false;  							int pick = new ScriptVarInt(stack.Pop()).intValue;  							if (pick < 0 || stack.Count <= pick)  								return false;  							stack.Push(stack.Skip(pick).First());  							break;  						}  					case OpCode.OP_ROLL:  						{  							if (stack.Count < 2)  								return false;  							int roll = new ScriptVarInt(stack.Pop()).intValue;  							if (roll < 0 || stack.Count <= roll)  								return false;  							altstack.Push(stack.Skip(roll).First());  							for (int i = 0; i < roll; i++)  								altstack.Push(stack.Pop());  							stack.Pop();  							for (int i = 0; i < roll + 1; i++)  								stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_ROT:  						{  							if (stack.Count < 3)  								return false;  							altstack.Push(stack.Skip(2).First());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_SWAP:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Skip(1).First());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_TUCK:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Push(altstack.Skip(1).First());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_CAT:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Skip(1).First().Concat(stack.First()).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_SUBSTR:  						{  							if (stack.Count < 3)  								return false;  							altstack.Push(stack.Skip(2).First()  								.Skip(new ScriptVarInt(stack.Skip(1).First()).intValue)  								.Take(new ScriptVarInt(stack.First()).intValue).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_LEFT:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Skip(1).First()  								.Take(new ScriptVarInt(stack.First()).intValue).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_RIGHT:  						{  							if (stack.Count < 2)  								return false;  							int count = new ScriptVarInt(stack.First()).intValue;  							altstack.Push(stack.Skip(1).First()  								.Skip(stack.Skip(1).First().Length - count).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_SIZE:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(new ScriptVarInt((UInt64)stack.First().Length).ToBytes());  							break;  						}  					case OpCode.OP_INVERT:  						{  							if (stack.Count < 1)  								return false;  							Byte[] data = stack.Pop();  							for (int i = 0; i < data.Length; i++)  								data[i] ^= 0xFF;  							stack.Push(data);  							break;  						}  					case OpCode.OP_AND:  					case OpCode.OP_OR:  					case OpCode.OP_XOR:  						{  							if (stack.Count < 2)  								return false;  							Byte[] data = stack.Pop();  							Byte[] data2 = stack.Pop();  							int length = new int[] { data.Length' data2.Length }.Max();  							data = data.Concat(new Byte[length - data.Length]).ToArray();  							data2 = data2.Concat(new Byte[length - data2.Length]).ToArray();  							switch (se.opCode)  							{  								case OpCode.OP_AND:  									{  										for (int i = 0; i < length; i++)  											data[i] &= data2[i];  										break;  									}  								case OpCode.OP_OR:  									{  										for (int i = 0; i < length; i++)  											data[i] |= data2[i];  										break;  									}  								case OpCode.OP_XOR:  									{  										for (int i = 0; i < length; i++)  											data[i] ^= data2[i];  										break;  									}  							}  							stack.Push(data);  							break;  						}  					case OpCode.OP_EQUAL:  					case OpCode.OP_EQUALVERIFY:  						{  							if (stack.Count < 2)  								return false;  							if (stack.Pop().SequenceEqual(stack.Pop()))  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });    							if (se.opCode == OpCode.OP_EQUALVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_RESERVED1:  					case OpCode.OP_RESERVED2:  						{  							return false;  						}  					case OpCode.OP_1ADD:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Add(new ScriptVarInt(stack.Pop())' 1)).ToBytes());  							break;  						}  					case OpCode.OP_1SUB:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Subtract(new ScriptVarInt(stack.Pop())' 1)).ToBytes());  							break;  						}  					case OpCode.OP_2MUL:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Multiply(new ScriptVarInt(stack.Pop())' 2)).ToBytes());  							break;  						}  					case OpCode.OP_2DIV:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Divide(new ScriptVarInt(stack.Pop())' 2)).ToBytes());  							break;  						}  					case OpCode.OP_NEGATE:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Negate(new ScriptVarInt(stack.Pop()))).ToBytes());  							break;  						}  					case OpCode.OP_ABS:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Abs(new ScriptVarInt(stack.Pop()))).ToBytes());  							break;  						}  					case OpCode.OP_NOT:  						{  							if (stack.Count < 1)  								return false;  							if (new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_0NOTEQUAL:  						{  							if (stack.Count < 1)  								return false;  							if (new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x00 });  							else  								stack.Push(new Byte[] { 0x01 });  							break;  						}  					case OpCode.OP_ADD:  					case OpCode.OP_SUB:  					case OpCode.OP_MUL:  					case OpCode.OP_DIV:  					case OpCode.OP_MOD:  					case OpCode.OP_LSHIFT:  					case OpCode.OP_RSHIFT:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							switch (se.opCode)  							{  								case OpCode.OP_ADD:  									a = (BigInteger)a + b;  									break;  								case OpCode.OP_SUB:  									a = (BigInteger)a - b;  									break;  								case OpCode.OP_MUL:  									a = (BigInteger)a * b;  									break;  								case OpCode.OP_DIV:  									a = (BigInteger)a / b;  									break;  								case OpCode.OP_MOD:  									a = (BigInteger)a % b;  									break;  								case OpCode.OP_LSHIFT:  									a = (BigInteger)a << b.intValue;  									break;  								case OpCode.OP_RSHIFT:  									a = (BigInteger)a >> b.intValue;  									break;  							}  							stack.Push(a.ToBytes());  							break;  						}  					case OpCode.OP_BOOLAND:  						{  							if (stack.Count < 2)  								return false;  							if (!new ScriptVarInt(stack.Pop()).value.IsZero && !new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_BOOLOR:  						{  							if (stack.Count < 2)  								return false;  							if (!new ScriptVarInt(stack.Pop()).value.IsZero || !new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_NUMEQUAL:  					case OpCode.OP_NUMEQUALVERIFY:  						{  							if (stack.Count < 2)  								return false;  							if (new ScriptVarInt(stack.Pop()).value == new ScriptVarInt(stack.Pop()).value)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							if (se.opCode == OpCode.OP_NUMEQUALVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_NUMNOTEQUAL:  						{  							if (stack.Count < 2)  								return false;  							if (new ScriptVarInt(stack.Pop()).value != new ScriptVarInt(stack.Pop()).value)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_LESSTHAN:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a < b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_GREATERTHAN:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a > b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_LESSTHANOREQUAL:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a <= b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_GREATERTHANOREQUAL:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a >= b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_MIN:  						{  							if (stack.Count < 2)  								return false;  							Byte[] b = stack.Pop();  							Byte[] a = stack.Pop();  							if (new ScriptVarInt(a).value < new ScriptVarInt(b).value)  								stack.Push(a);  							else  								stack.Push(b);  							break;  						}  					case OpCode.OP_MAX:  						{  							if (stack.Count < 2)  								return false;  							Byte[] b = stack.Pop();  							Byte[] a = stack.Pop();  							if (new ScriptVarInt(a).value > new ScriptVarInt(b).value)  								stack.Push(a);  							else  								stack.Push(b);  							break;  						}  					case OpCode.OP_WITHIN:  						{  							if (stack.Count < 3)  								return false;  							ScriptVarInt max = new ScriptVarInt(stack.Pop());  							ScriptVarInt min = new ScriptVarInt(stack.Pop());  							ScriptVarInt x = new ScriptVarInt(stack.Pop());  							if ((BigInteger)min <= x && (BigInteger)x <= max)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_RIPEMD160:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(ripemd160.ComputeHash(stack.Pop()));  							break;  						}  					case OpCode.OP_SHA1:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(sha1.ComputeHash(stack.Pop()));  							break;  						}  					case OpCode.OP_SHA256:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(sha256.ComputeHash(stack.Pop()));  							break;  						}  					case OpCode.OP_HASH160:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(ripemd160.ComputeHash(sha256.ComputeHash(stack.Pop())));  							break;  						}  					case OpCode.OP_HASH256:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(sha256.ComputeHash(sha256.ComputeHash(stack.Pop())));  							break;  						}  					case OpCode.OP_CODESEPARATOR:  						{  							lastCodeSeperator = index;  							break;  						}  					case OpCode.OP_CHECKSIG:  					case OpCode.OP_CHECKSIGVERIFY:  						{  							if (tx == null)  								throw new ArgumentNullException("Transaction is required if script contains OP_CHECKSIG[VERIFY]");  							if (stack.Count < 2)  								return false;    							PublicKey pubKey = new PublicKey(stack.Pop());  							Byte[] sig = stack.Pop();    							Script subScript = new Script(elements.Skip(lastCodeSeperator)  								.Where(x => x.opCode != OpCode.OP_CODESEPARATOR).ToArray());    							stack.Push(new ScriptVarInt(CheckSig(sig' pubKey' txInIndex' subScript' tx) ? 1 : 0).ToBytes());    							if (se.opCode == OpCode.OP_CHECKSIGVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_CHECKMULTISIG:  					case OpCode.OP_CHECKMULTISIGVERIFY:  						{  							if (tx == null)  								throw new ArgumentNullException("Transaction is required if script contains OP_CHECKMULTISIG[VERIFY]");  							if (stack.Count < 2)  								return false;    							PublicKey[] pubKeys = new PublicKey[new ScriptVarInt(stack.Pop()).intValue];    							if (stack.Count < pubKeys.Length + 1)  								return false;    							for (int i = 0; i < pubKeys.Length; i++)  							{  								pubKeys[i] = new PublicKey(stack.Pop());  							}    							Byte[][] sigs = new Byte[new ScriptVarInt(stack.Pop()).intValue][];    							if (stack.Count < sigs.Length)  								return false;    							for (int i = 0; i < sigs.Length; i++)  							{  								sigs[i] = stack.Pop();  							}    							// Remove extra unused value from stack  							stack.Pop();    							Script subScript = new Script(elements.Skip(lastCodeSeperator)  								.Where(x => x.opCode != OpCode.OP_CODESEPARATOR).ToArray());    							int validSigs = 0;  							foreach (Byte[] sig in sigs)  							{  								foreach (PublicKey pubKey in pubKeys)  								{  									if (CheckSig(sig' pubKey' txInIndex' subScript' tx))  									{  										pubKeys = pubKeys.Where(x => x != pubKey).ToArray();  										validSigs++;  										break;  									}  								}  							}    							stack.Push(new ScriptVarInt((validSigs >= sigs.Length) ? 1 : 0).ToBytes());    							if (se.opCode == OpCode.OP_CHECKMULTISIGVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_NOP1:  					case OpCode.OP_NOP2:  					case OpCode.OP_NOP3:  					case OpCode.OP_NOP4:  					case OpCode.OP_NOP5:  					case OpCode.OP_NOP6:  					case OpCode.OP_NOP7:  					case OpCode.OP_NOP8:  					case OpCode.OP_NOP9:  					case OpCode.OP_NOP10:  						{  							break;  						}  					case OpCode.OP_SMALLINTEGER:  					case OpCode.OP_PUBKEYS:  					case OpCode.OP_PUBKEYHASH:  					case OpCode.OP_PUBKEY:  					case OpCode.OP_INVALIDOPCODE:  					default:  						{  							return false;  						}    				}  			}
Magic Number,Bitcoin_Tool.Scripts,Script,C:\repos\mb300sd_Bitcoin-Tool\Bitcoin Tool\Scripts\Script.cs,Evaluate,The following statement contains a magic number: for (int index = 0; index < elements.Count; index++)  			{  				ScriptElement se = elements[index];  				if (ifExec.Count > 0)  					if ((ifExec.First() == IfElseExec.SKIP_IF && !(se.opCode == OpCode.OP_ELSE || se.opCode == OpCode.OP_ENDIF)) ||  						(ifExec.First() == IfElseExec.SKIP_ELSE && !(se.opCode == OpCode.OP_ENDIF)))  						continue;    				if (se.isData)  				{  					stack.Push(se.data);  					continue;  				}    				switch (se.opCode)  				{  					case OpCode.OP_RESERVED:  						{  							return false;  						}  					case OpCode.OP_NOP:  						{  							// NOP' Dump stack for debug  							/*  							stack.ToList().ForEach(x => Console.WriteLine(HexString.FromByteArray(x)));  							Console.WriteLine("---------------------------");  							*/  							break;  						}  					case OpCode.OP_VER:  						{  							return false;  						}  					case OpCode.OP_IF:  					case OpCode.OP_NOTIF:  						{  							if (stack.Count < 1)  								return false;  							Boolean stackIsZero = new ScriptVarInt(stack.Pop()).value.IsZero;  							if ((se.opCode == OpCode.OP_IF && !stackIsZero) || (se.opCode == OpCode.OP_NOTIF && stackIsZero))  							{  								// Run to else or endif  								ifExec.Push(IfElseExec.RUN_IF);  							}  							else  							{  								// Skip to else or endif  								ifExec.Push(IfElseExec.SKIP_IF);  							}  							break;  						}  					case OpCode.OP_VERIF:  					case OpCode.OP_VERNOTIF:  						{  							return false;  						}  					case OpCode.OP_ELSE:  						{  							if (ifExec.Count == 0)  								// No preceding if statement!  								return false;  							if (ifExec.First() == IfElseExec.RUN_IF)  							{  								// If ran' skip else  								ifExec.Push(IfElseExec.SKIP_ELSE);  							}  							else if (ifExec.First() == IfElseExec.SKIP_IF)  							{  								// If did not run' run else  								ifExec.Push(IfElseExec.RUN_ELSE);  							}  							break;  						}  					case OpCode.OP_ENDIF:  						{  							if (ifExec.Count == 0)  								// No preceding if statement!  								return false;  							if (ifExec.First() == IfElseExec.RUN_IF ||  								ifExec.First() == IfElseExec.SKIP_IF)  							{  								ifExec.Pop();  							}  							else if (ifExec.First() == IfElseExec.RUN_ELSE ||  							   ifExec.First() == IfElseExec.SKIP_ELSE)  							{  								ifExec.Pop();  								ifExec.Pop();  							}  							break;  						}  					case OpCode.OP_VERIFY:  						{  							if (stack.Count < 1 || new ScriptVarInt(stack.First()).value.IsZero)  								return false;  							stack.Pop();  							break;  						}  					case OpCode.OP_RETURN:  						{  							return false;  						}  					case OpCode.OP_TOALTSTACK:  						{  							if (stack.Count < 1)  								return false;  							altstack.Push(stack.Pop());  							break;  						}  					case OpCode.OP_FROMALTSTACK:  						{  							if (altstack.Count < 1)  								return false;  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_2DROP:  						{  							if (stack.Count < 2)  								return false;  							stack.Pop();  							stack.Pop();  							break;  						}  					case OpCode.OP_2DUP:  						{  							if (stack.Count < 2)  								return false;  							stack.Push(stack.Skip(1).First());  							stack.Push(stack.Skip(1).First());  							break;  						}  					case OpCode.OP_3DUP:  						{  							if (stack.Count < 3)  								return false;  							stack.Push(stack.Skip(2).First());  							stack.Push(stack.Skip(2).First());  							stack.Push(stack.Skip(2).First());  							break;  						}  					case OpCode.OP_2OVER:  						{  							if (stack.Count < 4)  								return false;  							stack.Push(stack.Skip(3).First());  							stack.Push(stack.Skip(3).First());  							break;  						}  					case OpCode.OP_2ROT:  						{  							if (stack.Count < 6)  								return false;  							altstack.Push(stack.Skip(4).First());  							altstack.Push(stack.Skip(5).First());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_2SWAP:  						{  							if (stack.Count < 4)  								return false;  							altstack.Push(stack.Skip(2).First());  							altstack.Push(stack.Skip(3).First());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_IFDUP:  						{  							if (stack.Count < 1)  								return false;  							if (!new ScriptVarInt(stack.First()).value.IsZero)  								stack.Push(stack.First());  							break;  						}  					case OpCode.OP_DEPTH:  						{  							stack.Push(new ScriptVarInt((UInt64)stack.Count).ToBytes());  							break;  						}  					case OpCode.OP_DROP:  						{  							if (stack.Count < 1)  								return false;  							stack.Pop();  							break;  						}  					case OpCode.OP_DUP:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(stack.First());  							break;  						}  					case OpCode.OP_NIP:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_OVER:  						{  							if (stack.Count < 2)  								return false;  							stack.Push(stack.Skip(1).First());  							break;  						}  					case OpCode.OP_PICK:  						{  							if (stack.Count < 2)  								return false;  							int pick = new ScriptVarInt(stack.Pop()).intValue;  							if (pick < 0 || stack.Count <= pick)  								return false;  							stack.Push(stack.Skip(pick).First());  							break;  						}  					case OpCode.OP_ROLL:  						{  							if (stack.Count < 2)  								return false;  							int roll = new ScriptVarInt(stack.Pop()).intValue;  							if (roll < 0 || stack.Count <= roll)  								return false;  							altstack.Push(stack.Skip(roll).First());  							for (int i = 0; i < roll; i++)  								altstack.Push(stack.Pop());  							stack.Pop();  							for (int i = 0; i < roll + 1; i++)  								stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_ROT:  						{  							if (stack.Count < 3)  								return false;  							altstack.Push(stack.Skip(2).First());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_SWAP:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Skip(1).First());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_TUCK:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Push(altstack.Skip(1).First());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_CAT:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Skip(1).First().Concat(stack.First()).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_SUBSTR:  						{  							if (stack.Count < 3)  								return false;  							altstack.Push(stack.Skip(2).First()  								.Skip(new ScriptVarInt(stack.Skip(1).First()).intValue)  								.Take(new ScriptVarInt(stack.First()).intValue).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_LEFT:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Skip(1).First()  								.Take(new ScriptVarInt(stack.First()).intValue).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_RIGHT:  						{  							if (stack.Count < 2)  								return false;  							int count = new ScriptVarInt(stack.First()).intValue;  							altstack.Push(stack.Skip(1).First()  								.Skip(stack.Skip(1).First().Length - count).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_SIZE:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(new ScriptVarInt((UInt64)stack.First().Length).ToBytes());  							break;  						}  					case OpCode.OP_INVERT:  						{  							if (stack.Count < 1)  								return false;  							Byte[] data = stack.Pop();  							for (int i = 0; i < data.Length; i++)  								data[i] ^= 0xFF;  							stack.Push(data);  							break;  						}  					case OpCode.OP_AND:  					case OpCode.OP_OR:  					case OpCode.OP_XOR:  						{  							if (stack.Count < 2)  								return false;  							Byte[] data = stack.Pop();  							Byte[] data2 = stack.Pop();  							int length = new int[] { data.Length' data2.Length }.Max();  							data = data.Concat(new Byte[length - data.Length]).ToArray();  							data2 = data2.Concat(new Byte[length - data2.Length]).ToArray();  							switch (se.opCode)  							{  								case OpCode.OP_AND:  									{  										for (int i = 0; i < length; i++)  											data[i] &= data2[i];  										break;  									}  								case OpCode.OP_OR:  									{  										for (int i = 0; i < length; i++)  											data[i] |= data2[i];  										break;  									}  								case OpCode.OP_XOR:  									{  										for (int i = 0; i < length; i++)  											data[i] ^= data2[i];  										break;  									}  							}  							stack.Push(data);  							break;  						}  					case OpCode.OP_EQUAL:  					case OpCode.OP_EQUALVERIFY:  						{  							if (stack.Count < 2)  								return false;  							if (stack.Pop().SequenceEqual(stack.Pop()))  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });    							if (se.opCode == OpCode.OP_EQUALVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_RESERVED1:  					case OpCode.OP_RESERVED2:  						{  							return false;  						}  					case OpCode.OP_1ADD:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Add(new ScriptVarInt(stack.Pop())' 1)).ToBytes());  							break;  						}  					case OpCode.OP_1SUB:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Subtract(new ScriptVarInt(stack.Pop())' 1)).ToBytes());  							break;  						}  					case OpCode.OP_2MUL:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Multiply(new ScriptVarInt(stack.Pop())' 2)).ToBytes());  							break;  						}  					case OpCode.OP_2DIV:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Divide(new ScriptVarInt(stack.Pop())' 2)).ToBytes());  							break;  						}  					case OpCode.OP_NEGATE:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Negate(new ScriptVarInt(stack.Pop()))).ToBytes());  							break;  						}  					case OpCode.OP_ABS:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Abs(new ScriptVarInt(stack.Pop()))).ToBytes());  							break;  						}  					case OpCode.OP_NOT:  						{  							if (stack.Count < 1)  								return false;  							if (new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_0NOTEQUAL:  						{  							if (stack.Count < 1)  								return false;  							if (new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x00 });  							else  								stack.Push(new Byte[] { 0x01 });  							break;  						}  					case OpCode.OP_ADD:  					case OpCode.OP_SUB:  					case OpCode.OP_MUL:  					case OpCode.OP_DIV:  					case OpCode.OP_MOD:  					case OpCode.OP_LSHIFT:  					case OpCode.OP_RSHIFT:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							switch (se.opCode)  							{  								case OpCode.OP_ADD:  									a = (BigInteger)a + b;  									break;  								case OpCode.OP_SUB:  									a = (BigInteger)a - b;  									break;  								case OpCode.OP_MUL:  									a = (BigInteger)a * b;  									break;  								case OpCode.OP_DIV:  									a = (BigInteger)a / b;  									break;  								case OpCode.OP_MOD:  									a = (BigInteger)a % b;  									break;  								case OpCode.OP_LSHIFT:  									a = (BigInteger)a << b.intValue;  									break;  								case OpCode.OP_RSHIFT:  									a = (BigInteger)a >> b.intValue;  									break;  							}  							stack.Push(a.ToBytes());  							break;  						}  					case OpCode.OP_BOOLAND:  						{  							if (stack.Count < 2)  								return false;  							if (!new ScriptVarInt(stack.Pop()).value.IsZero && !new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_BOOLOR:  						{  							if (stack.Count < 2)  								return false;  							if (!new ScriptVarInt(stack.Pop()).value.IsZero || !new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_NUMEQUAL:  					case OpCode.OP_NUMEQUALVERIFY:  						{  							if (stack.Count < 2)  								return false;  							if (new ScriptVarInt(stack.Pop()).value == new ScriptVarInt(stack.Pop()).value)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							if (se.opCode == OpCode.OP_NUMEQUALVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_NUMNOTEQUAL:  						{  							if (stack.Count < 2)  								return false;  							if (new ScriptVarInt(stack.Pop()).value != new ScriptVarInt(stack.Pop()).value)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_LESSTHAN:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a < b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_GREATERTHAN:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a > b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_LESSTHANOREQUAL:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a <= b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_GREATERTHANOREQUAL:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a >= b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_MIN:  						{  							if (stack.Count < 2)  								return false;  							Byte[] b = stack.Pop();  							Byte[] a = stack.Pop();  							if (new ScriptVarInt(a).value < new ScriptVarInt(b).value)  								stack.Push(a);  							else  								stack.Push(b);  							break;  						}  					case OpCode.OP_MAX:  						{  							if (stack.Count < 2)  								return false;  							Byte[] b = stack.Pop();  							Byte[] a = stack.Pop();  							if (new ScriptVarInt(a).value > new ScriptVarInt(b).value)  								stack.Push(a);  							else  								stack.Push(b);  							break;  						}  					case OpCode.OP_WITHIN:  						{  							if (stack.Count < 3)  								return false;  							ScriptVarInt max = new ScriptVarInt(stack.Pop());  							ScriptVarInt min = new ScriptVarInt(stack.Pop());  							ScriptVarInt x = new ScriptVarInt(stack.Pop());  							if ((BigInteger)min <= x && (BigInteger)x <= max)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_RIPEMD160:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(ripemd160.ComputeHash(stack.Pop()));  							break;  						}  					case OpCode.OP_SHA1:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(sha1.ComputeHash(stack.Pop()));  							break;  						}  					case OpCode.OP_SHA256:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(sha256.ComputeHash(stack.Pop()));  							break;  						}  					case OpCode.OP_HASH160:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(ripemd160.ComputeHash(sha256.ComputeHash(stack.Pop())));  							break;  						}  					case OpCode.OP_HASH256:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(sha256.ComputeHash(sha256.ComputeHash(stack.Pop())));  							break;  						}  					case OpCode.OP_CODESEPARATOR:  						{  							lastCodeSeperator = index;  							break;  						}  					case OpCode.OP_CHECKSIG:  					case OpCode.OP_CHECKSIGVERIFY:  						{  							if (tx == null)  								throw new ArgumentNullException("Transaction is required if script contains OP_CHECKSIG[VERIFY]");  							if (stack.Count < 2)  								return false;    							PublicKey pubKey = new PublicKey(stack.Pop());  							Byte[] sig = stack.Pop();    							Script subScript = new Script(elements.Skip(lastCodeSeperator)  								.Where(x => x.opCode != OpCode.OP_CODESEPARATOR).ToArray());    							stack.Push(new ScriptVarInt(CheckSig(sig' pubKey' txInIndex' subScript' tx) ? 1 : 0).ToBytes());    							if (se.opCode == OpCode.OP_CHECKSIGVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_CHECKMULTISIG:  					case OpCode.OP_CHECKMULTISIGVERIFY:  						{  							if (tx == null)  								throw new ArgumentNullException("Transaction is required if script contains OP_CHECKMULTISIG[VERIFY]");  							if (stack.Count < 2)  								return false;    							PublicKey[] pubKeys = new PublicKey[new ScriptVarInt(stack.Pop()).intValue];    							if (stack.Count < pubKeys.Length + 1)  								return false;    							for (int i = 0; i < pubKeys.Length; i++)  							{  								pubKeys[i] = new PublicKey(stack.Pop());  							}    							Byte[][] sigs = new Byte[new ScriptVarInt(stack.Pop()).intValue][];    							if (stack.Count < sigs.Length)  								return false;    							for (int i = 0; i < sigs.Length; i++)  							{  								sigs[i] = stack.Pop();  							}    							// Remove extra unused value from stack  							stack.Pop();    							Script subScript = new Script(elements.Skip(lastCodeSeperator)  								.Where(x => x.opCode != OpCode.OP_CODESEPARATOR).ToArray());    							int validSigs = 0;  							foreach (Byte[] sig in sigs)  							{  								foreach (PublicKey pubKey in pubKeys)  								{  									if (CheckSig(sig' pubKey' txInIndex' subScript' tx))  									{  										pubKeys = pubKeys.Where(x => x != pubKey).ToArray();  										validSigs++;  										break;  									}  								}  							}    							stack.Push(new ScriptVarInt((validSigs >= sigs.Length) ? 1 : 0).ToBytes());    							if (se.opCode == OpCode.OP_CHECKMULTISIGVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_NOP1:  					case OpCode.OP_NOP2:  					case OpCode.OP_NOP3:  					case OpCode.OP_NOP4:  					case OpCode.OP_NOP5:  					case OpCode.OP_NOP6:  					case OpCode.OP_NOP7:  					case OpCode.OP_NOP8:  					case OpCode.OP_NOP9:  					case OpCode.OP_NOP10:  						{  							break;  						}  					case OpCode.OP_SMALLINTEGER:  					case OpCode.OP_PUBKEYS:  					case OpCode.OP_PUBKEYHASH:  					case OpCode.OP_PUBKEY:  					case OpCode.OP_INVALIDOPCODE:  					default:  						{  							return false;  						}    				}  			}
Magic Number,Bitcoin_Tool.Scripts,Script,C:\repos\mb300sd_Bitcoin-Tool\Bitcoin Tool\Scripts\Script.cs,Evaluate,The following statement contains a magic number: for (int index = 0; index < elements.Count; index++)  			{  				ScriptElement se = elements[index];  				if (ifExec.Count > 0)  					if ((ifExec.First() == IfElseExec.SKIP_IF && !(se.opCode == OpCode.OP_ELSE || se.opCode == OpCode.OP_ENDIF)) ||  						(ifExec.First() == IfElseExec.SKIP_ELSE && !(se.opCode == OpCode.OP_ENDIF)))  						continue;    				if (se.isData)  				{  					stack.Push(se.data);  					continue;  				}    				switch (se.opCode)  				{  					case OpCode.OP_RESERVED:  						{  							return false;  						}  					case OpCode.OP_NOP:  						{  							// NOP' Dump stack for debug  							/*  							stack.ToList().ForEach(x => Console.WriteLine(HexString.FromByteArray(x)));  							Console.WriteLine("---------------------------");  							*/  							break;  						}  					case OpCode.OP_VER:  						{  							return false;  						}  					case OpCode.OP_IF:  					case OpCode.OP_NOTIF:  						{  							if (stack.Count < 1)  								return false;  							Boolean stackIsZero = new ScriptVarInt(stack.Pop()).value.IsZero;  							if ((se.opCode == OpCode.OP_IF && !stackIsZero) || (se.opCode == OpCode.OP_NOTIF && stackIsZero))  							{  								// Run to else or endif  								ifExec.Push(IfElseExec.RUN_IF);  							}  							else  							{  								// Skip to else or endif  								ifExec.Push(IfElseExec.SKIP_IF);  							}  							break;  						}  					case OpCode.OP_VERIF:  					case OpCode.OP_VERNOTIF:  						{  							return false;  						}  					case OpCode.OP_ELSE:  						{  							if (ifExec.Count == 0)  								// No preceding if statement!  								return false;  							if (ifExec.First() == IfElseExec.RUN_IF)  							{  								// If ran' skip else  								ifExec.Push(IfElseExec.SKIP_ELSE);  							}  							else if (ifExec.First() == IfElseExec.SKIP_IF)  							{  								// If did not run' run else  								ifExec.Push(IfElseExec.RUN_ELSE);  							}  							break;  						}  					case OpCode.OP_ENDIF:  						{  							if (ifExec.Count == 0)  								// No preceding if statement!  								return false;  							if (ifExec.First() == IfElseExec.RUN_IF ||  								ifExec.First() == IfElseExec.SKIP_IF)  							{  								ifExec.Pop();  							}  							else if (ifExec.First() == IfElseExec.RUN_ELSE ||  							   ifExec.First() == IfElseExec.SKIP_ELSE)  							{  								ifExec.Pop();  								ifExec.Pop();  							}  							break;  						}  					case OpCode.OP_VERIFY:  						{  							if (stack.Count < 1 || new ScriptVarInt(stack.First()).value.IsZero)  								return false;  							stack.Pop();  							break;  						}  					case OpCode.OP_RETURN:  						{  							return false;  						}  					case OpCode.OP_TOALTSTACK:  						{  							if (stack.Count < 1)  								return false;  							altstack.Push(stack.Pop());  							break;  						}  					case OpCode.OP_FROMALTSTACK:  						{  							if (altstack.Count < 1)  								return false;  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_2DROP:  						{  							if (stack.Count < 2)  								return false;  							stack.Pop();  							stack.Pop();  							break;  						}  					case OpCode.OP_2DUP:  						{  							if (stack.Count < 2)  								return false;  							stack.Push(stack.Skip(1).First());  							stack.Push(stack.Skip(1).First());  							break;  						}  					case OpCode.OP_3DUP:  						{  							if (stack.Count < 3)  								return false;  							stack.Push(stack.Skip(2).First());  							stack.Push(stack.Skip(2).First());  							stack.Push(stack.Skip(2).First());  							break;  						}  					case OpCode.OP_2OVER:  						{  							if (stack.Count < 4)  								return false;  							stack.Push(stack.Skip(3).First());  							stack.Push(stack.Skip(3).First());  							break;  						}  					case OpCode.OP_2ROT:  						{  							if (stack.Count < 6)  								return false;  							altstack.Push(stack.Skip(4).First());  							altstack.Push(stack.Skip(5).First());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_2SWAP:  						{  							if (stack.Count < 4)  								return false;  							altstack.Push(stack.Skip(2).First());  							altstack.Push(stack.Skip(3).First());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_IFDUP:  						{  							if (stack.Count < 1)  								return false;  							if (!new ScriptVarInt(stack.First()).value.IsZero)  								stack.Push(stack.First());  							break;  						}  					case OpCode.OP_DEPTH:  						{  							stack.Push(new ScriptVarInt((UInt64)stack.Count).ToBytes());  							break;  						}  					case OpCode.OP_DROP:  						{  							if (stack.Count < 1)  								return false;  							stack.Pop();  							break;  						}  					case OpCode.OP_DUP:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(stack.First());  							break;  						}  					case OpCode.OP_NIP:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_OVER:  						{  							if (stack.Count < 2)  								return false;  							stack.Push(stack.Skip(1).First());  							break;  						}  					case OpCode.OP_PICK:  						{  							if (stack.Count < 2)  								return false;  							int pick = new ScriptVarInt(stack.Pop()).intValue;  							if (pick < 0 || stack.Count <= pick)  								return false;  							stack.Push(stack.Skip(pick).First());  							break;  						}  					case OpCode.OP_ROLL:  						{  							if (stack.Count < 2)  								return false;  							int roll = new ScriptVarInt(stack.Pop()).intValue;  							if (roll < 0 || stack.Count <= roll)  								return false;  							altstack.Push(stack.Skip(roll).First());  							for (int i = 0; i < roll; i++)  								altstack.Push(stack.Pop());  							stack.Pop();  							for (int i = 0; i < roll + 1; i++)  								stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_ROT:  						{  							if (stack.Count < 3)  								return false;  							altstack.Push(stack.Skip(2).First());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_SWAP:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Skip(1).First());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_TUCK:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Push(altstack.Skip(1).First());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_CAT:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Skip(1).First().Concat(stack.First()).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_SUBSTR:  						{  							if (stack.Count < 3)  								return false;  							altstack.Push(stack.Skip(2).First()  								.Skip(new ScriptVarInt(stack.Skip(1).First()).intValue)  								.Take(new ScriptVarInt(stack.First()).intValue).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_LEFT:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Skip(1).First()  								.Take(new ScriptVarInt(stack.First()).intValue).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_RIGHT:  						{  							if (stack.Count < 2)  								return false;  							int count = new ScriptVarInt(stack.First()).intValue;  							altstack.Push(stack.Skip(1).First()  								.Skip(stack.Skip(1).First().Length - count).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_SIZE:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(new ScriptVarInt((UInt64)stack.First().Length).ToBytes());  							break;  						}  					case OpCode.OP_INVERT:  						{  							if (stack.Count < 1)  								return false;  							Byte[] data = stack.Pop();  							for (int i = 0; i < data.Length; i++)  								data[i] ^= 0xFF;  							stack.Push(data);  							break;  						}  					case OpCode.OP_AND:  					case OpCode.OP_OR:  					case OpCode.OP_XOR:  						{  							if (stack.Count < 2)  								return false;  							Byte[] data = stack.Pop();  							Byte[] data2 = stack.Pop();  							int length = new int[] { data.Length' data2.Length }.Max();  							data = data.Concat(new Byte[length - data.Length]).ToArray();  							data2 = data2.Concat(new Byte[length - data2.Length]).ToArray();  							switch (se.opCode)  							{  								case OpCode.OP_AND:  									{  										for (int i = 0; i < length; i++)  											data[i] &= data2[i];  										break;  									}  								case OpCode.OP_OR:  									{  										for (int i = 0; i < length; i++)  											data[i] |= data2[i];  										break;  									}  								case OpCode.OP_XOR:  									{  										for (int i = 0; i < length; i++)  											data[i] ^= data2[i];  										break;  									}  							}  							stack.Push(data);  							break;  						}  					case OpCode.OP_EQUAL:  					case OpCode.OP_EQUALVERIFY:  						{  							if (stack.Count < 2)  								return false;  							if (stack.Pop().SequenceEqual(stack.Pop()))  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });    							if (se.opCode == OpCode.OP_EQUALVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_RESERVED1:  					case OpCode.OP_RESERVED2:  						{  							return false;  						}  					case OpCode.OP_1ADD:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Add(new ScriptVarInt(stack.Pop())' 1)).ToBytes());  							break;  						}  					case OpCode.OP_1SUB:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Subtract(new ScriptVarInt(stack.Pop())' 1)).ToBytes());  							break;  						}  					case OpCode.OP_2MUL:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Multiply(new ScriptVarInt(stack.Pop())' 2)).ToBytes());  							break;  						}  					case OpCode.OP_2DIV:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Divide(new ScriptVarInt(stack.Pop())' 2)).ToBytes());  							break;  						}  					case OpCode.OP_NEGATE:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Negate(new ScriptVarInt(stack.Pop()))).ToBytes());  							break;  						}  					case OpCode.OP_ABS:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Abs(new ScriptVarInt(stack.Pop()))).ToBytes());  							break;  						}  					case OpCode.OP_NOT:  						{  							if (stack.Count < 1)  								return false;  							if (new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_0NOTEQUAL:  						{  							if (stack.Count < 1)  								return false;  							if (new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x00 });  							else  								stack.Push(new Byte[] { 0x01 });  							break;  						}  					case OpCode.OP_ADD:  					case OpCode.OP_SUB:  					case OpCode.OP_MUL:  					case OpCode.OP_DIV:  					case OpCode.OP_MOD:  					case OpCode.OP_LSHIFT:  					case OpCode.OP_RSHIFT:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							switch (se.opCode)  							{  								case OpCode.OP_ADD:  									a = (BigInteger)a + b;  									break;  								case OpCode.OP_SUB:  									a = (BigInteger)a - b;  									break;  								case OpCode.OP_MUL:  									a = (BigInteger)a * b;  									break;  								case OpCode.OP_DIV:  									a = (BigInteger)a / b;  									break;  								case OpCode.OP_MOD:  									a = (BigInteger)a % b;  									break;  								case OpCode.OP_LSHIFT:  									a = (BigInteger)a << b.intValue;  									break;  								case OpCode.OP_RSHIFT:  									a = (BigInteger)a >> b.intValue;  									break;  							}  							stack.Push(a.ToBytes());  							break;  						}  					case OpCode.OP_BOOLAND:  						{  							if (stack.Count < 2)  								return false;  							if (!new ScriptVarInt(stack.Pop()).value.IsZero && !new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_BOOLOR:  						{  							if (stack.Count < 2)  								return false;  							if (!new ScriptVarInt(stack.Pop()).value.IsZero || !new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_NUMEQUAL:  					case OpCode.OP_NUMEQUALVERIFY:  						{  							if (stack.Count < 2)  								return false;  							if (new ScriptVarInt(stack.Pop()).value == new ScriptVarInt(stack.Pop()).value)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							if (se.opCode == OpCode.OP_NUMEQUALVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_NUMNOTEQUAL:  						{  							if (stack.Count < 2)  								return false;  							if (new ScriptVarInt(stack.Pop()).value != new ScriptVarInt(stack.Pop()).value)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_LESSTHAN:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a < b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_GREATERTHAN:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a > b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_LESSTHANOREQUAL:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a <= b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_GREATERTHANOREQUAL:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a >= b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_MIN:  						{  							if (stack.Count < 2)  								return false;  							Byte[] b = stack.Pop();  							Byte[] a = stack.Pop();  							if (new ScriptVarInt(a).value < new ScriptVarInt(b).value)  								stack.Push(a);  							else  								stack.Push(b);  							break;  						}  					case OpCode.OP_MAX:  						{  							if (stack.Count < 2)  								return false;  							Byte[] b = stack.Pop();  							Byte[] a = stack.Pop();  							if (new ScriptVarInt(a).value > new ScriptVarInt(b).value)  								stack.Push(a);  							else  								stack.Push(b);  							break;  						}  					case OpCode.OP_WITHIN:  						{  							if (stack.Count < 3)  								return false;  							ScriptVarInt max = new ScriptVarInt(stack.Pop());  							ScriptVarInt min = new ScriptVarInt(stack.Pop());  							ScriptVarInt x = new ScriptVarInt(stack.Pop());  							if ((BigInteger)min <= x && (BigInteger)x <= max)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_RIPEMD160:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(ripemd160.ComputeHash(stack.Pop()));  							break;  						}  					case OpCode.OP_SHA1:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(sha1.ComputeHash(stack.Pop()));  							break;  						}  					case OpCode.OP_SHA256:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(sha256.ComputeHash(stack.Pop()));  							break;  						}  					case OpCode.OP_HASH160:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(ripemd160.ComputeHash(sha256.ComputeHash(stack.Pop())));  							break;  						}  					case OpCode.OP_HASH256:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(sha256.ComputeHash(sha256.ComputeHash(stack.Pop())));  							break;  						}  					case OpCode.OP_CODESEPARATOR:  						{  							lastCodeSeperator = index;  							break;  						}  					case OpCode.OP_CHECKSIG:  					case OpCode.OP_CHECKSIGVERIFY:  						{  							if (tx == null)  								throw new ArgumentNullException("Transaction is required if script contains OP_CHECKSIG[VERIFY]");  							if (stack.Count < 2)  								return false;    							PublicKey pubKey = new PublicKey(stack.Pop());  							Byte[] sig = stack.Pop();    							Script subScript = new Script(elements.Skip(lastCodeSeperator)  								.Where(x => x.opCode != OpCode.OP_CODESEPARATOR).ToArray());    							stack.Push(new ScriptVarInt(CheckSig(sig' pubKey' txInIndex' subScript' tx) ? 1 : 0).ToBytes());    							if (se.opCode == OpCode.OP_CHECKSIGVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_CHECKMULTISIG:  					case OpCode.OP_CHECKMULTISIGVERIFY:  						{  							if (tx == null)  								throw new ArgumentNullException("Transaction is required if script contains OP_CHECKMULTISIG[VERIFY]");  							if (stack.Count < 2)  								return false;    							PublicKey[] pubKeys = new PublicKey[new ScriptVarInt(stack.Pop()).intValue];    							if (stack.Count < pubKeys.Length + 1)  								return false;    							for (int i = 0; i < pubKeys.Length; i++)  							{  								pubKeys[i] = new PublicKey(stack.Pop());  							}    							Byte[][] sigs = new Byte[new ScriptVarInt(stack.Pop()).intValue][];    							if (stack.Count < sigs.Length)  								return false;    							for (int i = 0; i < sigs.Length; i++)  							{  								sigs[i] = stack.Pop();  							}    							// Remove extra unused value from stack  							stack.Pop();    							Script subScript = new Script(elements.Skip(lastCodeSeperator)  								.Where(x => x.opCode != OpCode.OP_CODESEPARATOR).ToArray());    							int validSigs = 0;  							foreach (Byte[] sig in sigs)  							{  								foreach (PublicKey pubKey in pubKeys)  								{  									if (CheckSig(sig' pubKey' txInIndex' subScript' tx))  									{  										pubKeys = pubKeys.Where(x => x != pubKey).ToArray();  										validSigs++;  										break;  									}  								}  							}    							stack.Push(new ScriptVarInt((validSigs >= sigs.Length) ? 1 : 0).ToBytes());    							if (se.opCode == OpCode.OP_CHECKMULTISIGVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_NOP1:  					case OpCode.OP_NOP2:  					case OpCode.OP_NOP3:  					case OpCode.OP_NOP4:  					case OpCode.OP_NOP5:  					case OpCode.OP_NOP6:  					case OpCode.OP_NOP7:  					case OpCode.OP_NOP8:  					case OpCode.OP_NOP9:  					case OpCode.OP_NOP10:  						{  							break;  						}  					case OpCode.OP_SMALLINTEGER:  					case OpCode.OP_PUBKEYS:  					case OpCode.OP_PUBKEYHASH:  					case OpCode.OP_PUBKEY:  					case OpCode.OP_INVALIDOPCODE:  					default:  						{  							return false;  						}    				}  			}
Magic Number,Bitcoin_Tool.Scripts,Script,C:\repos\mb300sd_Bitcoin-Tool\Bitcoin Tool\Scripts\Script.cs,Evaluate,The following statement contains a magic number: for (int index = 0; index < elements.Count; index++)  			{  				ScriptElement se = elements[index];  				if (ifExec.Count > 0)  					if ((ifExec.First() == IfElseExec.SKIP_IF && !(se.opCode == OpCode.OP_ELSE || se.opCode == OpCode.OP_ENDIF)) ||  						(ifExec.First() == IfElseExec.SKIP_ELSE && !(se.opCode == OpCode.OP_ENDIF)))  						continue;    				if (se.isData)  				{  					stack.Push(se.data);  					continue;  				}    				switch (se.opCode)  				{  					case OpCode.OP_RESERVED:  						{  							return false;  						}  					case OpCode.OP_NOP:  						{  							// NOP' Dump stack for debug  							/*  							stack.ToList().ForEach(x => Console.WriteLine(HexString.FromByteArray(x)));  							Console.WriteLine("---------------------------");  							*/  							break;  						}  					case OpCode.OP_VER:  						{  							return false;  						}  					case OpCode.OP_IF:  					case OpCode.OP_NOTIF:  						{  							if (stack.Count < 1)  								return false;  							Boolean stackIsZero = new ScriptVarInt(stack.Pop()).value.IsZero;  							if ((se.opCode == OpCode.OP_IF && !stackIsZero) || (se.opCode == OpCode.OP_NOTIF && stackIsZero))  							{  								// Run to else or endif  								ifExec.Push(IfElseExec.RUN_IF);  							}  							else  							{  								// Skip to else or endif  								ifExec.Push(IfElseExec.SKIP_IF);  							}  							break;  						}  					case OpCode.OP_VERIF:  					case OpCode.OP_VERNOTIF:  						{  							return false;  						}  					case OpCode.OP_ELSE:  						{  							if (ifExec.Count == 0)  								// No preceding if statement!  								return false;  							if (ifExec.First() == IfElseExec.RUN_IF)  							{  								// If ran' skip else  								ifExec.Push(IfElseExec.SKIP_ELSE);  							}  							else if (ifExec.First() == IfElseExec.SKIP_IF)  							{  								// If did not run' run else  								ifExec.Push(IfElseExec.RUN_ELSE);  							}  							break;  						}  					case OpCode.OP_ENDIF:  						{  							if (ifExec.Count == 0)  								// No preceding if statement!  								return false;  							if (ifExec.First() == IfElseExec.RUN_IF ||  								ifExec.First() == IfElseExec.SKIP_IF)  							{  								ifExec.Pop();  							}  							else if (ifExec.First() == IfElseExec.RUN_ELSE ||  							   ifExec.First() == IfElseExec.SKIP_ELSE)  							{  								ifExec.Pop();  								ifExec.Pop();  							}  							break;  						}  					case OpCode.OP_VERIFY:  						{  							if (stack.Count < 1 || new ScriptVarInt(stack.First()).value.IsZero)  								return false;  							stack.Pop();  							break;  						}  					case OpCode.OP_RETURN:  						{  							return false;  						}  					case OpCode.OP_TOALTSTACK:  						{  							if (stack.Count < 1)  								return false;  							altstack.Push(stack.Pop());  							break;  						}  					case OpCode.OP_FROMALTSTACK:  						{  							if (altstack.Count < 1)  								return false;  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_2DROP:  						{  							if (stack.Count < 2)  								return false;  							stack.Pop();  							stack.Pop();  							break;  						}  					case OpCode.OP_2DUP:  						{  							if (stack.Count < 2)  								return false;  							stack.Push(stack.Skip(1).First());  							stack.Push(stack.Skip(1).First());  							break;  						}  					case OpCode.OP_3DUP:  						{  							if (stack.Count < 3)  								return false;  							stack.Push(stack.Skip(2).First());  							stack.Push(stack.Skip(2).First());  							stack.Push(stack.Skip(2).First());  							break;  						}  					case OpCode.OP_2OVER:  						{  							if (stack.Count < 4)  								return false;  							stack.Push(stack.Skip(3).First());  							stack.Push(stack.Skip(3).First());  							break;  						}  					case OpCode.OP_2ROT:  						{  							if (stack.Count < 6)  								return false;  							altstack.Push(stack.Skip(4).First());  							altstack.Push(stack.Skip(5).First());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_2SWAP:  						{  							if (stack.Count < 4)  								return false;  							altstack.Push(stack.Skip(2).First());  							altstack.Push(stack.Skip(3).First());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_IFDUP:  						{  							if (stack.Count < 1)  								return false;  							if (!new ScriptVarInt(stack.First()).value.IsZero)  								stack.Push(stack.First());  							break;  						}  					case OpCode.OP_DEPTH:  						{  							stack.Push(new ScriptVarInt((UInt64)stack.Count).ToBytes());  							break;  						}  					case OpCode.OP_DROP:  						{  							if (stack.Count < 1)  								return false;  							stack.Pop();  							break;  						}  					case OpCode.OP_DUP:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(stack.First());  							break;  						}  					case OpCode.OP_NIP:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_OVER:  						{  							if (stack.Count < 2)  								return false;  							stack.Push(stack.Skip(1).First());  							break;  						}  					case OpCode.OP_PICK:  						{  							if (stack.Count < 2)  								return false;  							int pick = new ScriptVarInt(stack.Pop()).intValue;  							if (pick < 0 || stack.Count <= pick)  								return false;  							stack.Push(stack.Skip(pick).First());  							break;  						}  					case OpCode.OP_ROLL:  						{  							if (stack.Count < 2)  								return false;  							int roll = new ScriptVarInt(stack.Pop()).intValue;  							if (roll < 0 || stack.Count <= roll)  								return false;  							altstack.Push(stack.Skip(roll).First());  							for (int i = 0; i < roll; i++)  								altstack.Push(stack.Pop());  							stack.Pop();  							for (int i = 0; i < roll + 1; i++)  								stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_ROT:  						{  							if (stack.Count < 3)  								return false;  							altstack.Push(stack.Skip(2).First());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_SWAP:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Skip(1).First());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_TUCK:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Push(altstack.Skip(1).First());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_CAT:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Skip(1).First().Concat(stack.First()).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_SUBSTR:  						{  							if (stack.Count < 3)  								return false;  							altstack.Push(stack.Skip(2).First()  								.Skip(new ScriptVarInt(stack.Skip(1).First()).intValue)  								.Take(new ScriptVarInt(stack.First()).intValue).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_LEFT:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Skip(1).First()  								.Take(new ScriptVarInt(stack.First()).intValue).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_RIGHT:  						{  							if (stack.Count < 2)  								return false;  							int count = new ScriptVarInt(stack.First()).intValue;  							altstack.Push(stack.Skip(1).First()  								.Skip(stack.Skip(1).First().Length - count).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_SIZE:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(new ScriptVarInt((UInt64)stack.First().Length).ToBytes());  							break;  						}  					case OpCode.OP_INVERT:  						{  							if (stack.Count < 1)  								return false;  							Byte[] data = stack.Pop();  							for (int i = 0; i < data.Length; i++)  								data[i] ^= 0xFF;  							stack.Push(data);  							break;  						}  					case OpCode.OP_AND:  					case OpCode.OP_OR:  					case OpCode.OP_XOR:  						{  							if (stack.Count < 2)  								return false;  							Byte[] data = stack.Pop();  							Byte[] data2 = stack.Pop();  							int length = new int[] { data.Length' data2.Length }.Max();  							data = data.Concat(new Byte[length - data.Length]).ToArray();  							data2 = data2.Concat(new Byte[length - data2.Length]).ToArray();  							switch (se.opCode)  							{  								case OpCode.OP_AND:  									{  										for (int i = 0; i < length; i++)  											data[i] &= data2[i];  										break;  									}  								case OpCode.OP_OR:  									{  										for (int i = 0; i < length; i++)  											data[i] |= data2[i];  										break;  									}  								case OpCode.OP_XOR:  									{  										for (int i = 0; i < length; i++)  											data[i] ^= data2[i];  										break;  									}  							}  							stack.Push(data);  							break;  						}  					case OpCode.OP_EQUAL:  					case OpCode.OP_EQUALVERIFY:  						{  							if (stack.Count < 2)  								return false;  							if (stack.Pop().SequenceEqual(stack.Pop()))  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });    							if (se.opCode == OpCode.OP_EQUALVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_RESERVED1:  					case OpCode.OP_RESERVED2:  						{  							return false;  						}  					case OpCode.OP_1ADD:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Add(new ScriptVarInt(stack.Pop())' 1)).ToBytes());  							break;  						}  					case OpCode.OP_1SUB:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Subtract(new ScriptVarInt(stack.Pop())' 1)).ToBytes());  							break;  						}  					case OpCode.OP_2MUL:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Multiply(new ScriptVarInt(stack.Pop())' 2)).ToBytes());  							break;  						}  					case OpCode.OP_2DIV:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Divide(new ScriptVarInt(stack.Pop())' 2)).ToBytes());  							break;  						}  					case OpCode.OP_NEGATE:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Negate(new ScriptVarInt(stack.Pop()))).ToBytes());  							break;  						}  					case OpCode.OP_ABS:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Abs(new ScriptVarInt(stack.Pop()))).ToBytes());  							break;  						}  					case OpCode.OP_NOT:  						{  							if (stack.Count < 1)  								return false;  							if (new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_0NOTEQUAL:  						{  							if (stack.Count < 1)  								return false;  							if (new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x00 });  							else  								stack.Push(new Byte[] { 0x01 });  							break;  						}  					case OpCode.OP_ADD:  					case OpCode.OP_SUB:  					case OpCode.OP_MUL:  					case OpCode.OP_DIV:  					case OpCode.OP_MOD:  					case OpCode.OP_LSHIFT:  					case OpCode.OP_RSHIFT:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							switch (se.opCode)  							{  								case OpCode.OP_ADD:  									a = (BigInteger)a + b;  									break;  								case OpCode.OP_SUB:  									a = (BigInteger)a - b;  									break;  								case OpCode.OP_MUL:  									a = (BigInteger)a * b;  									break;  								case OpCode.OP_DIV:  									a = (BigInteger)a / b;  									break;  								case OpCode.OP_MOD:  									a = (BigInteger)a % b;  									break;  								case OpCode.OP_LSHIFT:  									a = (BigInteger)a << b.intValue;  									break;  								case OpCode.OP_RSHIFT:  									a = (BigInteger)a >> b.intValue;  									break;  							}  							stack.Push(a.ToBytes());  							break;  						}  					case OpCode.OP_BOOLAND:  						{  							if (stack.Count < 2)  								return false;  							if (!new ScriptVarInt(stack.Pop()).value.IsZero && !new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_BOOLOR:  						{  							if (stack.Count < 2)  								return false;  							if (!new ScriptVarInt(stack.Pop()).value.IsZero || !new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_NUMEQUAL:  					case OpCode.OP_NUMEQUALVERIFY:  						{  							if (stack.Count < 2)  								return false;  							if (new ScriptVarInt(stack.Pop()).value == new ScriptVarInt(stack.Pop()).value)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							if (se.opCode == OpCode.OP_NUMEQUALVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_NUMNOTEQUAL:  						{  							if (stack.Count < 2)  								return false;  							if (new ScriptVarInt(stack.Pop()).value != new ScriptVarInt(stack.Pop()).value)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_LESSTHAN:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a < b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_GREATERTHAN:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a > b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_LESSTHANOREQUAL:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a <= b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_GREATERTHANOREQUAL:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a >= b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_MIN:  						{  							if (stack.Count < 2)  								return false;  							Byte[] b = stack.Pop();  							Byte[] a = stack.Pop();  							if (new ScriptVarInt(a).value < new ScriptVarInt(b).value)  								stack.Push(a);  							else  								stack.Push(b);  							break;  						}  					case OpCode.OP_MAX:  						{  							if (stack.Count < 2)  								return false;  							Byte[] b = stack.Pop();  							Byte[] a = stack.Pop();  							if (new ScriptVarInt(a).value > new ScriptVarInt(b).value)  								stack.Push(a);  							else  								stack.Push(b);  							break;  						}  					case OpCode.OP_WITHIN:  						{  							if (stack.Count < 3)  								return false;  							ScriptVarInt max = new ScriptVarInt(stack.Pop());  							ScriptVarInt min = new ScriptVarInt(stack.Pop());  							ScriptVarInt x = new ScriptVarInt(stack.Pop());  							if ((BigInteger)min <= x && (BigInteger)x <= max)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_RIPEMD160:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(ripemd160.ComputeHash(stack.Pop()));  							break;  						}  					case OpCode.OP_SHA1:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(sha1.ComputeHash(stack.Pop()));  							break;  						}  					case OpCode.OP_SHA256:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(sha256.ComputeHash(stack.Pop()));  							break;  						}  					case OpCode.OP_HASH160:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(ripemd160.ComputeHash(sha256.ComputeHash(stack.Pop())));  							break;  						}  					case OpCode.OP_HASH256:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(sha256.ComputeHash(sha256.ComputeHash(stack.Pop())));  							break;  						}  					case OpCode.OP_CODESEPARATOR:  						{  							lastCodeSeperator = index;  							break;  						}  					case OpCode.OP_CHECKSIG:  					case OpCode.OP_CHECKSIGVERIFY:  						{  							if (tx == null)  								throw new ArgumentNullException("Transaction is required if script contains OP_CHECKSIG[VERIFY]");  							if (stack.Count < 2)  								return false;    							PublicKey pubKey = new PublicKey(stack.Pop());  							Byte[] sig = stack.Pop();    							Script subScript = new Script(elements.Skip(lastCodeSeperator)  								.Where(x => x.opCode != OpCode.OP_CODESEPARATOR).ToArray());    							stack.Push(new ScriptVarInt(CheckSig(sig' pubKey' txInIndex' subScript' tx) ? 1 : 0).ToBytes());    							if (se.opCode == OpCode.OP_CHECKSIGVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_CHECKMULTISIG:  					case OpCode.OP_CHECKMULTISIGVERIFY:  						{  							if (tx == null)  								throw new ArgumentNullException("Transaction is required if script contains OP_CHECKMULTISIG[VERIFY]");  							if (stack.Count < 2)  								return false;    							PublicKey[] pubKeys = new PublicKey[new ScriptVarInt(stack.Pop()).intValue];    							if (stack.Count < pubKeys.Length + 1)  								return false;    							for (int i = 0; i < pubKeys.Length; i++)  							{  								pubKeys[i] = new PublicKey(stack.Pop());  							}    							Byte[][] sigs = new Byte[new ScriptVarInt(stack.Pop()).intValue][];    							if (stack.Count < sigs.Length)  								return false;    							for (int i = 0; i < sigs.Length; i++)  							{  								sigs[i] = stack.Pop();  							}    							// Remove extra unused value from stack  							stack.Pop();    							Script subScript = new Script(elements.Skip(lastCodeSeperator)  								.Where(x => x.opCode != OpCode.OP_CODESEPARATOR).ToArray());    							int validSigs = 0;  							foreach (Byte[] sig in sigs)  							{  								foreach (PublicKey pubKey in pubKeys)  								{  									if (CheckSig(sig' pubKey' txInIndex' subScript' tx))  									{  										pubKeys = pubKeys.Where(x => x != pubKey).ToArray();  										validSigs++;  										break;  									}  								}  							}    							stack.Push(new ScriptVarInt((validSigs >= sigs.Length) ? 1 : 0).ToBytes());    							if (se.opCode == OpCode.OP_CHECKMULTISIGVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_NOP1:  					case OpCode.OP_NOP2:  					case OpCode.OP_NOP3:  					case OpCode.OP_NOP4:  					case OpCode.OP_NOP5:  					case OpCode.OP_NOP6:  					case OpCode.OP_NOP7:  					case OpCode.OP_NOP8:  					case OpCode.OP_NOP9:  					case OpCode.OP_NOP10:  						{  							break;  						}  					case OpCode.OP_SMALLINTEGER:  					case OpCode.OP_PUBKEYS:  					case OpCode.OP_PUBKEYHASH:  					case OpCode.OP_PUBKEY:  					case OpCode.OP_INVALIDOPCODE:  					default:  						{  							return false;  						}    				}  			}
Magic Number,Bitcoin_Tool.Scripts,Script,C:\repos\mb300sd_Bitcoin-Tool\Bitcoin Tool\Scripts\Script.cs,Evaluate,The following statement contains a magic number: for (int index = 0; index < elements.Count; index++)  			{  				ScriptElement se = elements[index];  				if (ifExec.Count > 0)  					if ((ifExec.First() == IfElseExec.SKIP_IF && !(se.opCode == OpCode.OP_ELSE || se.opCode == OpCode.OP_ENDIF)) ||  						(ifExec.First() == IfElseExec.SKIP_ELSE && !(se.opCode == OpCode.OP_ENDIF)))  						continue;    				if (se.isData)  				{  					stack.Push(se.data);  					continue;  				}    				switch (se.opCode)  				{  					case OpCode.OP_RESERVED:  						{  							return false;  						}  					case OpCode.OP_NOP:  						{  							// NOP' Dump stack for debug  							/*  							stack.ToList().ForEach(x => Console.WriteLine(HexString.FromByteArray(x)));  							Console.WriteLine("---------------------------");  							*/  							break;  						}  					case OpCode.OP_VER:  						{  							return false;  						}  					case OpCode.OP_IF:  					case OpCode.OP_NOTIF:  						{  							if (stack.Count < 1)  								return false;  							Boolean stackIsZero = new ScriptVarInt(stack.Pop()).value.IsZero;  							if ((se.opCode == OpCode.OP_IF && !stackIsZero) || (se.opCode == OpCode.OP_NOTIF && stackIsZero))  							{  								// Run to else or endif  								ifExec.Push(IfElseExec.RUN_IF);  							}  							else  							{  								// Skip to else or endif  								ifExec.Push(IfElseExec.SKIP_IF);  							}  							break;  						}  					case OpCode.OP_VERIF:  					case OpCode.OP_VERNOTIF:  						{  							return false;  						}  					case OpCode.OP_ELSE:  						{  							if (ifExec.Count == 0)  								// No preceding if statement!  								return false;  							if (ifExec.First() == IfElseExec.RUN_IF)  							{  								// If ran' skip else  								ifExec.Push(IfElseExec.SKIP_ELSE);  							}  							else if (ifExec.First() == IfElseExec.SKIP_IF)  							{  								// If did not run' run else  								ifExec.Push(IfElseExec.RUN_ELSE);  							}  							break;  						}  					case OpCode.OP_ENDIF:  						{  							if (ifExec.Count == 0)  								// No preceding if statement!  								return false;  							if (ifExec.First() == IfElseExec.RUN_IF ||  								ifExec.First() == IfElseExec.SKIP_IF)  							{  								ifExec.Pop();  							}  							else if (ifExec.First() == IfElseExec.RUN_ELSE ||  							   ifExec.First() == IfElseExec.SKIP_ELSE)  							{  								ifExec.Pop();  								ifExec.Pop();  							}  							break;  						}  					case OpCode.OP_VERIFY:  						{  							if (stack.Count < 1 || new ScriptVarInt(stack.First()).value.IsZero)  								return false;  							stack.Pop();  							break;  						}  					case OpCode.OP_RETURN:  						{  							return false;  						}  					case OpCode.OP_TOALTSTACK:  						{  							if (stack.Count < 1)  								return false;  							altstack.Push(stack.Pop());  							break;  						}  					case OpCode.OP_FROMALTSTACK:  						{  							if (altstack.Count < 1)  								return false;  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_2DROP:  						{  							if (stack.Count < 2)  								return false;  							stack.Pop();  							stack.Pop();  							break;  						}  					case OpCode.OP_2DUP:  						{  							if (stack.Count < 2)  								return false;  							stack.Push(stack.Skip(1).First());  							stack.Push(stack.Skip(1).First());  							break;  						}  					case OpCode.OP_3DUP:  						{  							if (stack.Count < 3)  								return false;  							stack.Push(stack.Skip(2).First());  							stack.Push(stack.Skip(2).First());  							stack.Push(stack.Skip(2).First());  							break;  						}  					case OpCode.OP_2OVER:  						{  							if (stack.Count < 4)  								return false;  							stack.Push(stack.Skip(3).First());  							stack.Push(stack.Skip(3).First());  							break;  						}  					case OpCode.OP_2ROT:  						{  							if (stack.Count < 6)  								return false;  							altstack.Push(stack.Skip(4).First());  							altstack.Push(stack.Skip(5).First());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_2SWAP:  						{  							if (stack.Count < 4)  								return false;  							altstack.Push(stack.Skip(2).First());  							altstack.Push(stack.Skip(3).First());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_IFDUP:  						{  							if (stack.Count < 1)  								return false;  							if (!new ScriptVarInt(stack.First()).value.IsZero)  								stack.Push(stack.First());  							break;  						}  					case OpCode.OP_DEPTH:  						{  							stack.Push(new ScriptVarInt((UInt64)stack.Count).ToBytes());  							break;  						}  					case OpCode.OP_DROP:  						{  							if (stack.Count < 1)  								return false;  							stack.Pop();  							break;  						}  					case OpCode.OP_DUP:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(stack.First());  							break;  						}  					case OpCode.OP_NIP:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_OVER:  						{  							if (stack.Count < 2)  								return false;  							stack.Push(stack.Skip(1).First());  							break;  						}  					case OpCode.OP_PICK:  						{  							if (stack.Count < 2)  								return false;  							int pick = new ScriptVarInt(stack.Pop()).intValue;  							if (pick < 0 || stack.Count <= pick)  								return false;  							stack.Push(stack.Skip(pick).First());  							break;  						}  					case OpCode.OP_ROLL:  						{  							if (stack.Count < 2)  								return false;  							int roll = new ScriptVarInt(stack.Pop()).intValue;  							if (roll < 0 || stack.Count <= roll)  								return false;  							altstack.Push(stack.Skip(roll).First());  							for (int i = 0; i < roll; i++)  								altstack.Push(stack.Pop());  							stack.Pop();  							for (int i = 0; i < roll + 1; i++)  								stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_ROT:  						{  							if (stack.Count < 3)  								return false;  							altstack.Push(stack.Skip(2).First());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_SWAP:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Skip(1).First());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_TUCK:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Push(altstack.Skip(1).First());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_CAT:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Skip(1).First().Concat(stack.First()).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_SUBSTR:  						{  							if (stack.Count < 3)  								return false;  							altstack.Push(stack.Skip(2).First()  								.Skip(new ScriptVarInt(stack.Skip(1).First()).intValue)  								.Take(new ScriptVarInt(stack.First()).intValue).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_LEFT:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Skip(1).First()  								.Take(new ScriptVarInt(stack.First()).intValue).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_RIGHT:  						{  							if (stack.Count < 2)  								return false;  							int count = new ScriptVarInt(stack.First()).intValue;  							altstack.Push(stack.Skip(1).First()  								.Skip(stack.Skip(1).First().Length - count).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_SIZE:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(new ScriptVarInt((UInt64)stack.First().Length).ToBytes());  							break;  						}  					case OpCode.OP_INVERT:  						{  							if (stack.Count < 1)  								return false;  							Byte[] data = stack.Pop();  							for (int i = 0; i < data.Length; i++)  								data[i] ^= 0xFF;  							stack.Push(data);  							break;  						}  					case OpCode.OP_AND:  					case OpCode.OP_OR:  					case OpCode.OP_XOR:  						{  							if (stack.Count < 2)  								return false;  							Byte[] data = stack.Pop();  							Byte[] data2 = stack.Pop();  							int length = new int[] { data.Length' data2.Length }.Max();  							data = data.Concat(new Byte[length - data.Length]).ToArray();  							data2 = data2.Concat(new Byte[length - data2.Length]).ToArray();  							switch (se.opCode)  							{  								case OpCode.OP_AND:  									{  										for (int i = 0; i < length; i++)  											data[i] &= data2[i];  										break;  									}  								case OpCode.OP_OR:  									{  										for (int i = 0; i < length; i++)  											data[i] |= data2[i];  										break;  									}  								case OpCode.OP_XOR:  									{  										for (int i = 0; i < length; i++)  											data[i] ^= data2[i];  										break;  									}  							}  							stack.Push(data);  							break;  						}  					case OpCode.OP_EQUAL:  					case OpCode.OP_EQUALVERIFY:  						{  							if (stack.Count < 2)  								return false;  							if (stack.Pop().SequenceEqual(stack.Pop()))  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });    							if (se.opCode == OpCode.OP_EQUALVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_RESERVED1:  					case OpCode.OP_RESERVED2:  						{  							return false;  						}  					case OpCode.OP_1ADD:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Add(new ScriptVarInt(stack.Pop())' 1)).ToBytes());  							break;  						}  					case OpCode.OP_1SUB:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Subtract(new ScriptVarInt(stack.Pop())' 1)).ToBytes());  							break;  						}  					case OpCode.OP_2MUL:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Multiply(new ScriptVarInt(stack.Pop())' 2)).ToBytes());  							break;  						}  					case OpCode.OP_2DIV:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Divide(new ScriptVarInt(stack.Pop())' 2)).ToBytes());  							break;  						}  					case OpCode.OP_NEGATE:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Negate(new ScriptVarInt(stack.Pop()))).ToBytes());  							break;  						}  					case OpCode.OP_ABS:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Abs(new ScriptVarInt(stack.Pop()))).ToBytes());  							break;  						}  					case OpCode.OP_NOT:  						{  							if (stack.Count < 1)  								return false;  							if (new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_0NOTEQUAL:  						{  							if (stack.Count < 1)  								return false;  							if (new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x00 });  							else  								stack.Push(new Byte[] { 0x01 });  							break;  						}  					case OpCode.OP_ADD:  					case OpCode.OP_SUB:  					case OpCode.OP_MUL:  					case OpCode.OP_DIV:  					case OpCode.OP_MOD:  					case OpCode.OP_LSHIFT:  					case OpCode.OP_RSHIFT:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							switch (se.opCode)  							{  								case OpCode.OP_ADD:  									a = (BigInteger)a + b;  									break;  								case OpCode.OP_SUB:  									a = (BigInteger)a - b;  									break;  								case OpCode.OP_MUL:  									a = (BigInteger)a * b;  									break;  								case OpCode.OP_DIV:  									a = (BigInteger)a / b;  									break;  								case OpCode.OP_MOD:  									a = (BigInteger)a % b;  									break;  								case OpCode.OP_LSHIFT:  									a = (BigInteger)a << b.intValue;  									break;  								case OpCode.OP_RSHIFT:  									a = (BigInteger)a >> b.intValue;  									break;  							}  							stack.Push(a.ToBytes());  							break;  						}  					case OpCode.OP_BOOLAND:  						{  							if (stack.Count < 2)  								return false;  							if (!new ScriptVarInt(stack.Pop()).value.IsZero && !new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_BOOLOR:  						{  							if (stack.Count < 2)  								return false;  							if (!new ScriptVarInt(stack.Pop()).value.IsZero || !new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_NUMEQUAL:  					case OpCode.OP_NUMEQUALVERIFY:  						{  							if (stack.Count < 2)  								return false;  							if (new ScriptVarInt(stack.Pop()).value == new ScriptVarInt(stack.Pop()).value)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							if (se.opCode == OpCode.OP_NUMEQUALVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_NUMNOTEQUAL:  						{  							if (stack.Count < 2)  								return false;  							if (new ScriptVarInt(stack.Pop()).value != new ScriptVarInt(stack.Pop()).value)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_LESSTHAN:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a < b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_GREATERTHAN:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a > b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_LESSTHANOREQUAL:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a <= b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_GREATERTHANOREQUAL:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a >= b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_MIN:  						{  							if (stack.Count < 2)  								return false;  							Byte[] b = stack.Pop();  							Byte[] a = stack.Pop();  							if (new ScriptVarInt(a).value < new ScriptVarInt(b).value)  								stack.Push(a);  							else  								stack.Push(b);  							break;  						}  					case OpCode.OP_MAX:  						{  							if (stack.Count < 2)  								return false;  							Byte[] b = stack.Pop();  							Byte[] a = stack.Pop();  							if (new ScriptVarInt(a).value > new ScriptVarInt(b).value)  								stack.Push(a);  							else  								stack.Push(b);  							break;  						}  					case OpCode.OP_WITHIN:  						{  							if (stack.Count < 3)  								return false;  							ScriptVarInt max = new ScriptVarInt(stack.Pop());  							ScriptVarInt min = new ScriptVarInt(stack.Pop());  							ScriptVarInt x = new ScriptVarInt(stack.Pop());  							if ((BigInteger)min <= x && (BigInteger)x <= max)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_RIPEMD160:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(ripemd160.ComputeHash(stack.Pop()));  							break;  						}  					case OpCode.OP_SHA1:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(sha1.ComputeHash(stack.Pop()));  							break;  						}  					case OpCode.OP_SHA256:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(sha256.ComputeHash(stack.Pop()));  							break;  						}  					case OpCode.OP_HASH160:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(ripemd160.ComputeHash(sha256.ComputeHash(stack.Pop())));  							break;  						}  					case OpCode.OP_HASH256:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(sha256.ComputeHash(sha256.ComputeHash(stack.Pop())));  							break;  						}  					case OpCode.OP_CODESEPARATOR:  						{  							lastCodeSeperator = index;  							break;  						}  					case OpCode.OP_CHECKSIG:  					case OpCode.OP_CHECKSIGVERIFY:  						{  							if (tx == null)  								throw new ArgumentNullException("Transaction is required if script contains OP_CHECKSIG[VERIFY]");  							if (stack.Count < 2)  								return false;    							PublicKey pubKey = new PublicKey(stack.Pop());  							Byte[] sig = stack.Pop();    							Script subScript = new Script(elements.Skip(lastCodeSeperator)  								.Where(x => x.opCode != OpCode.OP_CODESEPARATOR).ToArray());    							stack.Push(new ScriptVarInt(CheckSig(sig' pubKey' txInIndex' subScript' tx) ? 1 : 0).ToBytes());    							if (se.opCode == OpCode.OP_CHECKSIGVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_CHECKMULTISIG:  					case OpCode.OP_CHECKMULTISIGVERIFY:  						{  							if (tx == null)  								throw new ArgumentNullException("Transaction is required if script contains OP_CHECKMULTISIG[VERIFY]");  							if (stack.Count < 2)  								return false;    							PublicKey[] pubKeys = new PublicKey[new ScriptVarInt(stack.Pop()).intValue];    							if (stack.Count < pubKeys.Length + 1)  								return false;    							for (int i = 0; i < pubKeys.Length; i++)  							{  								pubKeys[i] = new PublicKey(stack.Pop());  							}    							Byte[][] sigs = new Byte[new ScriptVarInt(stack.Pop()).intValue][];    							if (stack.Count < sigs.Length)  								return false;    							for (int i = 0; i < sigs.Length; i++)  							{  								sigs[i] = stack.Pop();  							}    							// Remove extra unused value from stack  							stack.Pop();    							Script subScript = new Script(elements.Skip(lastCodeSeperator)  								.Where(x => x.opCode != OpCode.OP_CODESEPARATOR).ToArray());    							int validSigs = 0;  							foreach (Byte[] sig in sigs)  							{  								foreach (PublicKey pubKey in pubKeys)  								{  									if (CheckSig(sig' pubKey' txInIndex' subScript' tx))  									{  										pubKeys = pubKeys.Where(x => x != pubKey).ToArray();  										validSigs++;  										break;  									}  								}  							}    							stack.Push(new ScriptVarInt((validSigs >= sigs.Length) ? 1 : 0).ToBytes());    							if (se.opCode == OpCode.OP_CHECKMULTISIGVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_NOP1:  					case OpCode.OP_NOP2:  					case OpCode.OP_NOP3:  					case OpCode.OP_NOP4:  					case OpCode.OP_NOP5:  					case OpCode.OP_NOP6:  					case OpCode.OP_NOP7:  					case OpCode.OP_NOP8:  					case OpCode.OP_NOP9:  					case OpCode.OP_NOP10:  						{  							break;  						}  					case OpCode.OP_SMALLINTEGER:  					case OpCode.OP_PUBKEYS:  					case OpCode.OP_PUBKEYHASH:  					case OpCode.OP_PUBKEY:  					case OpCode.OP_INVALIDOPCODE:  					default:  						{  							return false;  						}    				}  			}
Magic Number,Bitcoin_Tool.Scripts,Script,C:\repos\mb300sd_Bitcoin-Tool\Bitcoin Tool\Scripts\Script.cs,Evaluate,The following statement contains a magic number: for (int index = 0; index < elements.Count; index++)  			{  				ScriptElement se = elements[index];  				if (ifExec.Count > 0)  					if ((ifExec.First() == IfElseExec.SKIP_IF && !(se.opCode == OpCode.OP_ELSE || se.opCode == OpCode.OP_ENDIF)) ||  						(ifExec.First() == IfElseExec.SKIP_ELSE && !(se.opCode == OpCode.OP_ENDIF)))  						continue;    				if (se.isData)  				{  					stack.Push(se.data);  					continue;  				}    				switch (se.opCode)  				{  					case OpCode.OP_RESERVED:  						{  							return false;  						}  					case OpCode.OP_NOP:  						{  							// NOP' Dump stack for debug  							/*  							stack.ToList().ForEach(x => Console.WriteLine(HexString.FromByteArray(x)));  							Console.WriteLine("---------------------------");  							*/  							break;  						}  					case OpCode.OP_VER:  						{  							return false;  						}  					case OpCode.OP_IF:  					case OpCode.OP_NOTIF:  						{  							if (stack.Count < 1)  								return false;  							Boolean stackIsZero = new ScriptVarInt(stack.Pop()).value.IsZero;  							if ((se.opCode == OpCode.OP_IF && !stackIsZero) || (se.opCode == OpCode.OP_NOTIF && stackIsZero))  							{  								// Run to else or endif  								ifExec.Push(IfElseExec.RUN_IF);  							}  							else  							{  								// Skip to else or endif  								ifExec.Push(IfElseExec.SKIP_IF);  							}  							break;  						}  					case OpCode.OP_VERIF:  					case OpCode.OP_VERNOTIF:  						{  							return false;  						}  					case OpCode.OP_ELSE:  						{  							if (ifExec.Count == 0)  								// No preceding if statement!  								return false;  							if (ifExec.First() == IfElseExec.RUN_IF)  							{  								// If ran' skip else  								ifExec.Push(IfElseExec.SKIP_ELSE);  							}  							else if (ifExec.First() == IfElseExec.SKIP_IF)  							{  								// If did not run' run else  								ifExec.Push(IfElseExec.RUN_ELSE);  							}  							break;  						}  					case OpCode.OP_ENDIF:  						{  							if (ifExec.Count == 0)  								// No preceding if statement!  								return false;  							if (ifExec.First() == IfElseExec.RUN_IF ||  								ifExec.First() == IfElseExec.SKIP_IF)  							{  								ifExec.Pop();  							}  							else if (ifExec.First() == IfElseExec.RUN_ELSE ||  							   ifExec.First() == IfElseExec.SKIP_ELSE)  							{  								ifExec.Pop();  								ifExec.Pop();  							}  							break;  						}  					case OpCode.OP_VERIFY:  						{  							if (stack.Count < 1 || new ScriptVarInt(stack.First()).value.IsZero)  								return false;  							stack.Pop();  							break;  						}  					case OpCode.OP_RETURN:  						{  							return false;  						}  					case OpCode.OP_TOALTSTACK:  						{  							if (stack.Count < 1)  								return false;  							altstack.Push(stack.Pop());  							break;  						}  					case OpCode.OP_FROMALTSTACK:  						{  							if (altstack.Count < 1)  								return false;  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_2DROP:  						{  							if (stack.Count < 2)  								return false;  							stack.Pop();  							stack.Pop();  							break;  						}  					case OpCode.OP_2DUP:  						{  							if (stack.Count < 2)  								return false;  							stack.Push(stack.Skip(1).First());  							stack.Push(stack.Skip(1).First());  							break;  						}  					case OpCode.OP_3DUP:  						{  							if (stack.Count < 3)  								return false;  							stack.Push(stack.Skip(2).First());  							stack.Push(stack.Skip(2).First());  							stack.Push(stack.Skip(2).First());  							break;  						}  					case OpCode.OP_2OVER:  						{  							if (stack.Count < 4)  								return false;  							stack.Push(stack.Skip(3).First());  							stack.Push(stack.Skip(3).First());  							break;  						}  					case OpCode.OP_2ROT:  						{  							if (stack.Count < 6)  								return false;  							altstack.Push(stack.Skip(4).First());  							altstack.Push(stack.Skip(5).First());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_2SWAP:  						{  							if (stack.Count < 4)  								return false;  							altstack.Push(stack.Skip(2).First());  							altstack.Push(stack.Skip(3).First());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_IFDUP:  						{  							if (stack.Count < 1)  								return false;  							if (!new ScriptVarInt(stack.First()).value.IsZero)  								stack.Push(stack.First());  							break;  						}  					case OpCode.OP_DEPTH:  						{  							stack.Push(new ScriptVarInt((UInt64)stack.Count).ToBytes());  							break;  						}  					case OpCode.OP_DROP:  						{  							if (stack.Count < 1)  								return false;  							stack.Pop();  							break;  						}  					case OpCode.OP_DUP:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(stack.First());  							break;  						}  					case OpCode.OP_NIP:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_OVER:  						{  							if (stack.Count < 2)  								return false;  							stack.Push(stack.Skip(1).First());  							break;  						}  					case OpCode.OP_PICK:  						{  							if (stack.Count < 2)  								return false;  							int pick = new ScriptVarInt(stack.Pop()).intValue;  							if (pick < 0 || stack.Count <= pick)  								return false;  							stack.Push(stack.Skip(pick).First());  							break;  						}  					case OpCode.OP_ROLL:  						{  							if (stack.Count < 2)  								return false;  							int roll = new ScriptVarInt(stack.Pop()).intValue;  							if (roll < 0 || stack.Count <= roll)  								return false;  							altstack.Push(stack.Skip(roll).First());  							for (int i = 0; i < roll; i++)  								altstack.Push(stack.Pop());  							stack.Pop();  							for (int i = 0; i < roll + 1; i++)  								stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_ROT:  						{  							if (stack.Count < 3)  								return false;  							altstack.Push(stack.Skip(2).First());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_SWAP:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Skip(1).First());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_TUCK:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Push(altstack.Skip(1).First());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_CAT:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Skip(1).First().Concat(stack.First()).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_SUBSTR:  						{  							if (stack.Count < 3)  								return false;  							altstack.Push(stack.Skip(2).First()  								.Skip(new ScriptVarInt(stack.Skip(1).First()).intValue)  								.Take(new ScriptVarInt(stack.First()).intValue).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_LEFT:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Skip(1).First()  								.Take(new ScriptVarInt(stack.First()).intValue).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_RIGHT:  						{  							if (stack.Count < 2)  								return false;  							int count = new ScriptVarInt(stack.First()).intValue;  							altstack.Push(stack.Skip(1).First()  								.Skip(stack.Skip(1).First().Length - count).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_SIZE:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(new ScriptVarInt((UInt64)stack.First().Length).ToBytes());  							break;  						}  					case OpCode.OP_INVERT:  						{  							if (stack.Count < 1)  								return false;  							Byte[] data = stack.Pop();  							for (int i = 0; i < data.Length; i++)  								data[i] ^= 0xFF;  							stack.Push(data);  							break;  						}  					case OpCode.OP_AND:  					case OpCode.OP_OR:  					case OpCode.OP_XOR:  						{  							if (stack.Count < 2)  								return false;  							Byte[] data = stack.Pop();  							Byte[] data2 = stack.Pop();  							int length = new int[] { data.Length' data2.Length }.Max();  							data = data.Concat(new Byte[length - data.Length]).ToArray();  							data2 = data2.Concat(new Byte[length - data2.Length]).ToArray();  							switch (se.opCode)  							{  								case OpCode.OP_AND:  									{  										for (int i = 0; i < length; i++)  											data[i] &= data2[i];  										break;  									}  								case OpCode.OP_OR:  									{  										for (int i = 0; i < length; i++)  											data[i] |= data2[i];  										break;  									}  								case OpCode.OP_XOR:  									{  										for (int i = 0; i < length; i++)  											data[i] ^= data2[i];  										break;  									}  							}  							stack.Push(data);  							break;  						}  					case OpCode.OP_EQUAL:  					case OpCode.OP_EQUALVERIFY:  						{  							if (stack.Count < 2)  								return false;  							if (stack.Pop().SequenceEqual(stack.Pop()))  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });    							if (se.opCode == OpCode.OP_EQUALVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_RESERVED1:  					case OpCode.OP_RESERVED2:  						{  							return false;  						}  					case OpCode.OP_1ADD:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Add(new ScriptVarInt(stack.Pop())' 1)).ToBytes());  							break;  						}  					case OpCode.OP_1SUB:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Subtract(new ScriptVarInt(stack.Pop())' 1)).ToBytes());  							break;  						}  					case OpCode.OP_2MUL:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Multiply(new ScriptVarInt(stack.Pop())' 2)).ToBytes());  							break;  						}  					case OpCode.OP_2DIV:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Divide(new ScriptVarInt(stack.Pop())' 2)).ToBytes());  							break;  						}  					case OpCode.OP_NEGATE:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Negate(new ScriptVarInt(stack.Pop()))).ToBytes());  							break;  						}  					case OpCode.OP_ABS:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Abs(new ScriptVarInt(stack.Pop()))).ToBytes());  							break;  						}  					case OpCode.OP_NOT:  						{  							if (stack.Count < 1)  								return false;  							if (new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_0NOTEQUAL:  						{  							if (stack.Count < 1)  								return false;  							if (new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x00 });  							else  								stack.Push(new Byte[] { 0x01 });  							break;  						}  					case OpCode.OP_ADD:  					case OpCode.OP_SUB:  					case OpCode.OP_MUL:  					case OpCode.OP_DIV:  					case OpCode.OP_MOD:  					case OpCode.OP_LSHIFT:  					case OpCode.OP_RSHIFT:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							switch (se.opCode)  							{  								case OpCode.OP_ADD:  									a = (BigInteger)a + b;  									break;  								case OpCode.OP_SUB:  									a = (BigInteger)a - b;  									break;  								case OpCode.OP_MUL:  									a = (BigInteger)a * b;  									break;  								case OpCode.OP_DIV:  									a = (BigInteger)a / b;  									break;  								case OpCode.OP_MOD:  									a = (BigInteger)a % b;  									break;  								case OpCode.OP_LSHIFT:  									a = (BigInteger)a << b.intValue;  									break;  								case OpCode.OP_RSHIFT:  									a = (BigInteger)a >> b.intValue;  									break;  							}  							stack.Push(a.ToBytes());  							break;  						}  					case OpCode.OP_BOOLAND:  						{  							if (stack.Count < 2)  								return false;  							if (!new ScriptVarInt(stack.Pop()).value.IsZero && !new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_BOOLOR:  						{  							if (stack.Count < 2)  								return false;  							if (!new ScriptVarInt(stack.Pop()).value.IsZero || !new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_NUMEQUAL:  					case OpCode.OP_NUMEQUALVERIFY:  						{  							if (stack.Count < 2)  								return false;  							if (new ScriptVarInt(stack.Pop()).value == new ScriptVarInt(stack.Pop()).value)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							if (se.opCode == OpCode.OP_NUMEQUALVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_NUMNOTEQUAL:  						{  							if (stack.Count < 2)  								return false;  							if (new ScriptVarInt(stack.Pop()).value != new ScriptVarInt(stack.Pop()).value)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_LESSTHAN:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a < b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_GREATERTHAN:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a > b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_LESSTHANOREQUAL:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a <= b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_GREATERTHANOREQUAL:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a >= b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_MIN:  						{  							if (stack.Count < 2)  								return false;  							Byte[] b = stack.Pop();  							Byte[] a = stack.Pop();  							if (new ScriptVarInt(a).value < new ScriptVarInt(b).value)  								stack.Push(a);  							else  								stack.Push(b);  							break;  						}  					case OpCode.OP_MAX:  						{  							if (stack.Count < 2)  								return false;  							Byte[] b = stack.Pop();  							Byte[] a = stack.Pop();  							if (new ScriptVarInt(a).value > new ScriptVarInt(b).value)  								stack.Push(a);  							else  								stack.Push(b);  							break;  						}  					case OpCode.OP_WITHIN:  						{  							if (stack.Count < 3)  								return false;  							ScriptVarInt max = new ScriptVarInt(stack.Pop());  							ScriptVarInt min = new ScriptVarInt(stack.Pop());  							ScriptVarInt x = new ScriptVarInt(stack.Pop());  							if ((BigInteger)min <= x && (BigInteger)x <= max)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_RIPEMD160:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(ripemd160.ComputeHash(stack.Pop()));  							break;  						}  					case OpCode.OP_SHA1:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(sha1.ComputeHash(stack.Pop()));  							break;  						}  					case OpCode.OP_SHA256:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(sha256.ComputeHash(stack.Pop()));  							break;  						}  					case OpCode.OP_HASH160:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(ripemd160.ComputeHash(sha256.ComputeHash(stack.Pop())));  							break;  						}  					case OpCode.OP_HASH256:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(sha256.ComputeHash(sha256.ComputeHash(stack.Pop())));  							break;  						}  					case OpCode.OP_CODESEPARATOR:  						{  							lastCodeSeperator = index;  							break;  						}  					case OpCode.OP_CHECKSIG:  					case OpCode.OP_CHECKSIGVERIFY:  						{  							if (tx == null)  								throw new ArgumentNullException("Transaction is required if script contains OP_CHECKSIG[VERIFY]");  							if (stack.Count < 2)  								return false;    							PublicKey pubKey = new PublicKey(stack.Pop());  							Byte[] sig = stack.Pop();    							Script subScript = new Script(elements.Skip(lastCodeSeperator)  								.Where(x => x.opCode != OpCode.OP_CODESEPARATOR).ToArray());    							stack.Push(new ScriptVarInt(CheckSig(sig' pubKey' txInIndex' subScript' tx) ? 1 : 0).ToBytes());    							if (se.opCode == OpCode.OP_CHECKSIGVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_CHECKMULTISIG:  					case OpCode.OP_CHECKMULTISIGVERIFY:  						{  							if (tx == null)  								throw new ArgumentNullException("Transaction is required if script contains OP_CHECKMULTISIG[VERIFY]");  							if (stack.Count < 2)  								return false;    							PublicKey[] pubKeys = new PublicKey[new ScriptVarInt(stack.Pop()).intValue];    							if (stack.Count < pubKeys.Length + 1)  								return false;    							for (int i = 0; i < pubKeys.Length; i++)  							{  								pubKeys[i] = new PublicKey(stack.Pop());  							}    							Byte[][] sigs = new Byte[new ScriptVarInt(stack.Pop()).intValue][];    							if (stack.Count < sigs.Length)  								return false;    							for (int i = 0; i < sigs.Length; i++)  							{  								sigs[i] = stack.Pop();  							}    							// Remove extra unused value from stack  							stack.Pop();    							Script subScript = new Script(elements.Skip(lastCodeSeperator)  								.Where(x => x.opCode != OpCode.OP_CODESEPARATOR).ToArray());    							int validSigs = 0;  							foreach (Byte[] sig in sigs)  							{  								foreach (PublicKey pubKey in pubKeys)  								{  									if (CheckSig(sig' pubKey' txInIndex' subScript' tx))  									{  										pubKeys = pubKeys.Where(x => x != pubKey).ToArray();  										validSigs++;  										break;  									}  								}  							}    							stack.Push(new ScriptVarInt((validSigs >= sigs.Length) ? 1 : 0).ToBytes());    							if (se.opCode == OpCode.OP_CHECKMULTISIGVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_NOP1:  					case OpCode.OP_NOP2:  					case OpCode.OP_NOP3:  					case OpCode.OP_NOP4:  					case OpCode.OP_NOP5:  					case OpCode.OP_NOP6:  					case OpCode.OP_NOP7:  					case OpCode.OP_NOP8:  					case OpCode.OP_NOP9:  					case OpCode.OP_NOP10:  						{  							break;  						}  					case OpCode.OP_SMALLINTEGER:  					case OpCode.OP_PUBKEYS:  					case OpCode.OP_PUBKEYHASH:  					case OpCode.OP_PUBKEY:  					case OpCode.OP_INVALIDOPCODE:  					default:  						{  							return false;  						}    				}  			}
Magic Number,Bitcoin_Tool.Scripts,Script,C:\repos\mb300sd_Bitcoin-Tool\Bitcoin Tool\Scripts\Script.cs,Evaluate,The following statement contains a magic number: for (int index = 0; index < elements.Count; index++)  			{  				ScriptElement se = elements[index];  				if (ifExec.Count > 0)  					if ((ifExec.First() == IfElseExec.SKIP_IF && !(se.opCode == OpCode.OP_ELSE || se.opCode == OpCode.OP_ENDIF)) ||  						(ifExec.First() == IfElseExec.SKIP_ELSE && !(se.opCode == OpCode.OP_ENDIF)))  						continue;    				if (se.isData)  				{  					stack.Push(se.data);  					continue;  				}    				switch (se.opCode)  				{  					case OpCode.OP_RESERVED:  						{  							return false;  						}  					case OpCode.OP_NOP:  						{  							// NOP' Dump stack for debug  							/*  							stack.ToList().ForEach(x => Console.WriteLine(HexString.FromByteArray(x)));  							Console.WriteLine("---------------------------");  							*/  							break;  						}  					case OpCode.OP_VER:  						{  							return false;  						}  					case OpCode.OP_IF:  					case OpCode.OP_NOTIF:  						{  							if (stack.Count < 1)  								return false;  							Boolean stackIsZero = new ScriptVarInt(stack.Pop()).value.IsZero;  							if ((se.opCode == OpCode.OP_IF && !stackIsZero) || (se.opCode == OpCode.OP_NOTIF && stackIsZero))  							{  								// Run to else or endif  								ifExec.Push(IfElseExec.RUN_IF);  							}  							else  							{  								// Skip to else or endif  								ifExec.Push(IfElseExec.SKIP_IF);  							}  							break;  						}  					case OpCode.OP_VERIF:  					case OpCode.OP_VERNOTIF:  						{  							return false;  						}  					case OpCode.OP_ELSE:  						{  							if (ifExec.Count == 0)  								// No preceding if statement!  								return false;  							if (ifExec.First() == IfElseExec.RUN_IF)  							{  								// If ran' skip else  								ifExec.Push(IfElseExec.SKIP_ELSE);  							}  							else if (ifExec.First() == IfElseExec.SKIP_IF)  							{  								// If did not run' run else  								ifExec.Push(IfElseExec.RUN_ELSE);  							}  							break;  						}  					case OpCode.OP_ENDIF:  						{  							if (ifExec.Count == 0)  								// No preceding if statement!  								return false;  							if (ifExec.First() == IfElseExec.RUN_IF ||  								ifExec.First() == IfElseExec.SKIP_IF)  							{  								ifExec.Pop();  							}  							else if (ifExec.First() == IfElseExec.RUN_ELSE ||  							   ifExec.First() == IfElseExec.SKIP_ELSE)  							{  								ifExec.Pop();  								ifExec.Pop();  							}  							break;  						}  					case OpCode.OP_VERIFY:  						{  							if (stack.Count < 1 || new ScriptVarInt(stack.First()).value.IsZero)  								return false;  							stack.Pop();  							break;  						}  					case OpCode.OP_RETURN:  						{  							return false;  						}  					case OpCode.OP_TOALTSTACK:  						{  							if (stack.Count < 1)  								return false;  							altstack.Push(stack.Pop());  							break;  						}  					case OpCode.OP_FROMALTSTACK:  						{  							if (altstack.Count < 1)  								return false;  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_2DROP:  						{  							if (stack.Count < 2)  								return false;  							stack.Pop();  							stack.Pop();  							break;  						}  					case OpCode.OP_2DUP:  						{  							if (stack.Count < 2)  								return false;  							stack.Push(stack.Skip(1).First());  							stack.Push(stack.Skip(1).First());  							break;  						}  					case OpCode.OP_3DUP:  						{  							if (stack.Count < 3)  								return false;  							stack.Push(stack.Skip(2).First());  							stack.Push(stack.Skip(2).First());  							stack.Push(stack.Skip(2).First());  							break;  						}  					case OpCode.OP_2OVER:  						{  							if (stack.Count < 4)  								return false;  							stack.Push(stack.Skip(3).First());  							stack.Push(stack.Skip(3).First());  							break;  						}  					case OpCode.OP_2ROT:  						{  							if (stack.Count < 6)  								return false;  							altstack.Push(stack.Skip(4).First());  							altstack.Push(stack.Skip(5).First());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_2SWAP:  						{  							if (stack.Count < 4)  								return false;  							altstack.Push(stack.Skip(2).First());  							altstack.Push(stack.Skip(3).First());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_IFDUP:  						{  							if (stack.Count < 1)  								return false;  							if (!new ScriptVarInt(stack.First()).value.IsZero)  								stack.Push(stack.First());  							break;  						}  					case OpCode.OP_DEPTH:  						{  							stack.Push(new ScriptVarInt((UInt64)stack.Count).ToBytes());  							break;  						}  					case OpCode.OP_DROP:  						{  							if (stack.Count < 1)  								return false;  							stack.Pop();  							break;  						}  					case OpCode.OP_DUP:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(stack.First());  							break;  						}  					case OpCode.OP_NIP:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_OVER:  						{  							if (stack.Count < 2)  								return false;  							stack.Push(stack.Skip(1).First());  							break;  						}  					case OpCode.OP_PICK:  						{  							if (stack.Count < 2)  								return false;  							int pick = new ScriptVarInt(stack.Pop()).intValue;  							if (pick < 0 || stack.Count <= pick)  								return false;  							stack.Push(stack.Skip(pick).First());  							break;  						}  					case OpCode.OP_ROLL:  						{  							if (stack.Count < 2)  								return false;  							int roll = new ScriptVarInt(stack.Pop()).intValue;  							if (roll < 0 || stack.Count <= roll)  								return false;  							altstack.Push(stack.Skip(roll).First());  							for (int i = 0; i < roll; i++)  								altstack.Push(stack.Pop());  							stack.Pop();  							for (int i = 0; i < roll + 1; i++)  								stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_ROT:  						{  							if (stack.Count < 3)  								return false;  							altstack.Push(stack.Skip(2).First());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_SWAP:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Skip(1).First());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_TUCK:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Push(altstack.Skip(1).First());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_CAT:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Skip(1).First().Concat(stack.First()).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_SUBSTR:  						{  							if (stack.Count < 3)  								return false;  							altstack.Push(stack.Skip(2).First()  								.Skip(new ScriptVarInt(stack.Skip(1).First()).intValue)  								.Take(new ScriptVarInt(stack.First()).intValue).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_LEFT:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Skip(1).First()  								.Take(new ScriptVarInt(stack.First()).intValue).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_RIGHT:  						{  							if (stack.Count < 2)  								return false;  							int count = new ScriptVarInt(stack.First()).intValue;  							altstack.Push(stack.Skip(1).First()  								.Skip(stack.Skip(1).First().Length - count).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_SIZE:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(new ScriptVarInt((UInt64)stack.First().Length).ToBytes());  							break;  						}  					case OpCode.OP_INVERT:  						{  							if (stack.Count < 1)  								return false;  							Byte[] data = stack.Pop();  							for (int i = 0; i < data.Length; i++)  								data[i] ^= 0xFF;  							stack.Push(data);  							break;  						}  					case OpCode.OP_AND:  					case OpCode.OP_OR:  					case OpCode.OP_XOR:  						{  							if (stack.Count < 2)  								return false;  							Byte[] data = stack.Pop();  							Byte[] data2 = stack.Pop();  							int length = new int[] { data.Length' data2.Length }.Max();  							data = data.Concat(new Byte[length - data.Length]).ToArray();  							data2 = data2.Concat(new Byte[length - data2.Length]).ToArray();  							switch (se.opCode)  							{  								case OpCode.OP_AND:  									{  										for (int i = 0; i < length; i++)  											data[i] &= data2[i];  										break;  									}  								case OpCode.OP_OR:  									{  										for (int i = 0; i < length; i++)  											data[i] |= data2[i];  										break;  									}  								case OpCode.OP_XOR:  									{  										for (int i = 0; i < length; i++)  											data[i] ^= data2[i];  										break;  									}  							}  							stack.Push(data);  							break;  						}  					case OpCode.OP_EQUAL:  					case OpCode.OP_EQUALVERIFY:  						{  							if (stack.Count < 2)  								return false;  							if (stack.Pop().SequenceEqual(stack.Pop()))  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });    							if (se.opCode == OpCode.OP_EQUALVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_RESERVED1:  					case OpCode.OP_RESERVED2:  						{  							return false;  						}  					case OpCode.OP_1ADD:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Add(new ScriptVarInt(stack.Pop())' 1)).ToBytes());  							break;  						}  					case OpCode.OP_1SUB:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Subtract(new ScriptVarInt(stack.Pop())' 1)).ToBytes());  							break;  						}  					case OpCode.OP_2MUL:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Multiply(new ScriptVarInt(stack.Pop())' 2)).ToBytes());  							break;  						}  					case OpCode.OP_2DIV:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Divide(new ScriptVarInt(stack.Pop())' 2)).ToBytes());  							break;  						}  					case OpCode.OP_NEGATE:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Negate(new ScriptVarInt(stack.Pop()))).ToBytes());  							break;  						}  					case OpCode.OP_ABS:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Abs(new ScriptVarInt(stack.Pop()))).ToBytes());  							break;  						}  					case OpCode.OP_NOT:  						{  							if (stack.Count < 1)  								return false;  							if (new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_0NOTEQUAL:  						{  							if (stack.Count < 1)  								return false;  							if (new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x00 });  							else  								stack.Push(new Byte[] { 0x01 });  							break;  						}  					case OpCode.OP_ADD:  					case OpCode.OP_SUB:  					case OpCode.OP_MUL:  					case OpCode.OP_DIV:  					case OpCode.OP_MOD:  					case OpCode.OP_LSHIFT:  					case OpCode.OP_RSHIFT:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							switch (se.opCode)  							{  								case OpCode.OP_ADD:  									a = (BigInteger)a + b;  									break;  								case OpCode.OP_SUB:  									a = (BigInteger)a - b;  									break;  								case OpCode.OP_MUL:  									a = (BigInteger)a * b;  									break;  								case OpCode.OP_DIV:  									a = (BigInteger)a / b;  									break;  								case OpCode.OP_MOD:  									a = (BigInteger)a % b;  									break;  								case OpCode.OP_LSHIFT:  									a = (BigInteger)a << b.intValue;  									break;  								case OpCode.OP_RSHIFT:  									a = (BigInteger)a >> b.intValue;  									break;  							}  							stack.Push(a.ToBytes());  							break;  						}  					case OpCode.OP_BOOLAND:  						{  							if (stack.Count < 2)  								return false;  							if (!new ScriptVarInt(stack.Pop()).value.IsZero && !new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_BOOLOR:  						{  							if (stack.Count < 2)  								return false;  							if (!new ScriptVarInt(stack.Pop()).value.IsZero || !new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_NUMEQUAL:  					case OpCode.OP_NUMEQUALVERIFY:  						{  							if (stack.Count < 2)  								return false;  							if (new ScriptVarInt(stack.Pop()).value == new ScriptVarInt(stack.Pop()).value)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							if (se.opCode == OpCode.OP_NUMEQUALVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_NUMNOTEQUAL:  						{  							if (stack.Count < 2)  								return false;  							if (new ScriptVarInt(stack.Pop()).value != new ScriptVarInt(stack.Pop()).value)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_LESSTHAN:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a < b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_GREATERTHAN:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a > b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_LESSTHANOREQUAL:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a <= b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_GREATERTHANOREQUAL:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a >= b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_MIN:  						{  							if (stack.Count < 2)  								return false;  							Byte[] b = stack.Pop();  							Byte[] a = stack.Pop();  							if (new ScriptVarInt(a).value < new ScriptVarInt(b).value)  								stack.Push(a);  							else  								stack.Push(b);  							break;  						}  					case OpCode.OP_MAX:  						{  							if (stack.Count < 2)  								return false;  							Byte[] b = stack.Pop();  							Byte[] a = stack.Pop();  							if (new ScriptVarInt(a).value > new ScriptVarInt(b).value)  								stack.Push(a);  							else  								stack.Push(b);  							break;  						}  					case OpCode.OP_WITHIN:  						{  							if (stack.Count < 3)  								return false;  							ScriptVarInt max = new ScriptVarInt(stack.Pop());  							ScriptVarInt min = new ScriptVarInt(stack.Pop());  							ScriptVarInt x = new ScriptVarInt(stack.Pop());  							if ((BigInteger)min <= x && (BigInteger)x <= max)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_RIPEMD160:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(ripemd160.ComputeHash(stack.Pop()));  							break;  						}  					case OpCode.OP_SHA1:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(sha1.ComputeHash(stack.Pop()));  							break;  						}  					case OpCode.OP_SHA256:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(sha256.ComputeHash(stack.Pop()));  							break;  						}  					case OpCode.OP_HASH160:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(ripemd160.ComputeHash(sha256.ComputeHash(stack.Pop())));  							break;  						}  					case OpCode.OP_HASH256:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(sha256.ComputeHash(sha256.ComputeHash(stack.Pop())));  							break;  						}  					case OpCode.OP_CODESEPARATOR:  						{  							lastCodeSeperator = index;  							break;  						}  					case OpCode.OP_CHECKSIG:  					case OpCode.OP_CHECKSIGVERIFY:  						{  							if (tx == null)  								throw new ArgumentNullException("Transaction is required if script contains OP_CHECKSIG[VERIFY]");  							if (stack.Count < 2)  								return false;    							PublicKey pubKey = new PublicKey(stack.Pop());  							Byte[] sig = stack.Pop();    							Script subScript = new Script(elements.Skip(lastCodeSeperator)  								.Where(x => x.opCode != OpCode.OP_CODESEPARATOR).ToArray());    							stack.Push(new ScriptVarInt(CheckSig(sig' pubKey' txInIndex' subScript' tx) ? 1 : 0).ToBytes());    							if (se.opCode == OpCode.OP_CHECKSIGVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_CHECKMULTISIG:  					case OpCode.OP_CHECKMULTISIGVERIFY:  						{  							if (tx == null)  								throw new ArgumentNullException("Transaction is required if script contains OP_CHECKMULTISIG[VERIFY]");  							if (stack.Count < 2)  								return false;    							PublicKey[] pubKeys = new PublicKey[new ScriptVarInt(stack.Pop()).intValue];    							if (stack.Count < pubKeys.Length + 1)  								return false;    							for (int i = 0; i < pubKeys.Length; i++)  							{  								pubKeys[i] = new PublicKey(stack.Pop());  							}    							Byte[][] sigs = new Byte[new ScriptVarInt(stack.Pop()).intValue][];    							if (stack.Count < sigs.Length)  								return false;    							for (int i = 0; i < sigs.Length; i++)  							{  								sigs[i] = stack.Pop();  							}    							// Remove extra unused value from stack  							stack.Pop();    							Script subScript = new Script(elements.Skip(lastCodeSeperator)  								.Where(x => x.opCode != OpCode.OP_CODESEPARATOR).ToArray());    							int validSigs = 0;  							foreach (Byte[] sig in sigs)  							{  								foreach (PublicKey pubKey in pubKeys)  								{  									if (CheckSig(sig' pubKey' txInIndex' subScript' tx))  									{  										pubKeys = pubKeys.Where(x => x != pubKey).ToArray();  										validSigs++;  										break;  									}  								}  							}    							stack.Push(new ScriptVarInt((validSigs >= sigs.Length) ? 1 : 0).ToBytes());    							if (se.opCode == OpCode.OP_CHECKMULTISIGVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_NOP1:  					case OpCode.OP_NOP2:  					case OpCode.OP_NOP3:  					case OpCode.OP_NOP4:  					case OpCode.OP_NOP5:  					case OpCode.OP_NOP6:  					case OpCode.OP_NOP7:  					case OpCode.OP_NOP8:  					case OpCode.OP_NOP9:  					case OpCode.OP_NOP10:  						{  							break;  						}  					case OpCode.OP_SMALLINTEGER:  					case OpCode.OP_PUBKEYS:  					case OpCode.OP_PUBKEYHASH:  					case OpCode.OP_PUBKEY:  					case OpCode.OP_INVALIDOPCODE:  					default:  						{  							return false;  						}    				}  			}
Magic Number,Bitcoin_Tool.Scripts,Script,C:\repos\mb300sd_Bitcoin-Tool\Bitcoin Tool\Scripts\Script.cs,Evaluate,The following statement contains a magic number: for (int index = 0; index < elements.Count; index++)  			{  				ScriptElement se = elements[index];  				if (ifExec.Count > 0)  					if ((ifExec.First() == IfElseExec.SKIP_IF && !(se.opCode == OpCode.OP_ELSE || se.opCode == OpCode.OP_ENDIF)) ||  						(ifExec.First() == IfElseExec.SKIP_ELSE && !(se.opCode == OpCode.OP_ENDIF)))  						continue;    				if (se.isData)  				{  					stack.Push(se.data);  					continue;  				}    				switch (se.opCode)  				{  					case OpCode.OP_RESERVED:  						{  							return false;  						}  					case OpCode.OP_NOP:  						{  							// NOP' Dump stack for debug  							/*  							stack.ToList().ForEach(x => Console.WriteLine(HexString.FromByteArray(x)));  							Console.WriteLine("---------------------------");  							*/  							break;  						}  					case OpCode.OP_VER:  						{  							return false;  						}  					case OpCode.OP_IF:  					case OpCode.OP_NOTIF:  						{  							if (stack.Count < 1)  								return false;  							Boolean stackIsZero = new ScriptVarInt(stack.Pop()).value.IsZero;  							if ((se.opCode == OpCode.OP_IF && !stackIsZero) || (se.opCode == OpCode.OP_NOTIF && stackIsZero))  							{  								// Run to else or endif  								ifExec.Push(IfElseExec.RUN_IF);  							}  							else  							{  								// Skip to else or endif  								ifExec.Push(IfElseExec.SKIP_IF);  							}  							break;  						}  					case OpCode.OP_VERIF:  					case OpCode.OP_VERNOTIF:  						{  							return false;  						}  					case OpCode.OP_ELSE:  						{  							if (ifExec.Count == 0)  								// No preceding if statement!  								return false;  							if (ifExec.First() == IfElseExec.RUN_IF)  							{  								// If ran' skip else  								ifExec.Push(IfElseExec.SKIP_ELSE);  							}  							else if (ifExec.First() == IfElseExec.SKIP_IF)  							{  								// If did not run' run else  								ifExec.Push(IfElseExec.RUN_ELSE);  							}  							break;  						}  					case OpCode.OP_ENDIF:  						{  							if (ifExec.Count == 0)  								// No preceding if statement!  								return false;  							if (ifExec.First() == IfElseExec.RUN_IF ||  								ifExec.First() == IfElseExec.SKIP_IF)  							{  								ifExec.Pop();  							}  							else if (ifExec.First() == IfElseExec.RUN_ELSE ||  							   ifExec.First() == IfElseExec.SKIP_ELSE)  							{  								ifExec.Pop();  								ifExec.Pop();  							}  							break;  						}  					case OpCode.OP_VERIFY:  						{  							if (stack.Count < 1 || new ScriptVarInt(stack.First()).value.IsZero)  								return false;  							stack.Pop();  							break;  						}  					case OpCode.OP_RETURN:  						{  							return false;  						}  					case OpCode.OP_TOALTSTACK:  						{  							if (stack.Count < 1)  								return false;  							altstack.Push(stack.Pop());  							break;  						}  					case OpCode.OP_FROMALTSTACK:  						{  							if (altstack.Count < 1)  								return false;  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_2DROP:  						{  							if (stack.Count < 2)  								return false;  							stack.Pop();  							stack.Pop();  							break;  						}  					case OpCode.OP_2DUP:  						{  							if (stack.Count < 2)  								return false;  							stack.Push(stack.Skip(1).First());  							stack.Push(stack.Skip(1).First());  							break;  						}  					case OpCode.OP_3DUP:  						{  							if (stack.Count < 3)  								return false;  							stack.Push(stack.Skip(2).First());  							stack.Push(stack.Skip(2).First());  							stack.Push(stack.Skip(2).First());  							break;  						}  					case OpCode.OP_2OVER:  						{  							if (stack.Count < 4)  								return false;  							stack.Push(stack.Skip(3).First());  							stack.Push(stack.Skip(3).First());  							break;  						}  					case OpCode.OP_2ROT:  						{  							if (stack.Count < 6)  								return false;  							altstack.Push(stack.Skip(4).First());  							altstack.Push(stack.Skip(5).First());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_2SWAP:  						{  							if (stack.Count < 4)  								return false;  							altstack.Push(stack.Skip(2).First());  							altstack.Push(stack.Skip(3).First());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_IFDUP:  						{  							if (stack.Count < 1)  								return false;  							if (!new ScriptVarInt(stack.First()).value.IsZero)  								stack.Push(stack.First());  							break;  						}  					case OpCode.OP_DEPTH:  						{  							stack.Push(new ScriptVarInt((UInt64)stack.Count).ToBytes());  							break;  						}  					case OpCode.OP_DROP:  						{  							if (stack.Count < 1)  								return false;  							stack.Pop();  							break;  						}  					case OpCode.OP_DUP:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(stack.First());  							break;  						}  					case OpCode.OP_NIP:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_OVER:  						{  							if (stack.Count < 2)  								return false;  							stack.Push(stack.Skip(1).First());  							break;  						}  					case OpCode.OP_PICK:  						{  							if (stack.Count < 2)  								return false;  							int pick = new ScriptVarInt(stack.Pop()).intValue;  							if (pick < 0 || stack.Count <= pick)  								return false;  							stack.Push(stack.Skip(pick).First());  							break;  						}  					case OpCode.OP_ROLL:  						{  							if (stack.Count < 2)  								return false;  							int roll = new ScriptVarInt(stack.Pop()).intValue;  							if (roll < 0 || stack.Count <= roll)  								return false;  							altstack.Push(stack.Skip(roll).First());  							for (int i = 0; i < roll; i++)  								altstack.Push(stack.Pop());  							stack.Pop();  							for (int i = 0; i < roll + 1; i++)  								stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_ROT:  						{  							if (stack.Count < 3)  								return false;  							altstack.Push(stack.Skip(2).First());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_SWAP:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Skip(1).First());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_TUCK:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Push(altstack.Skip(1).First());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_CAT:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Skip(1).First().Concat(stack.First()).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_SUBSTR:  						{  							if (stack.Count < 3)  								return false;  							altstack.Push(stack.Skip(2).First()  								.Skip(new ScriptVarInt(stack.Skip(1).First()).intValue)  								.Take(new ScriptVarInt(stack.First()).intValue).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_LEFT:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Skip(1).First()  								.Take(new ScriptVarInt(stack.First()).intValue).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_RIGHT:  						{  							if (stack.Count < 2)  								return false;  							int count = new ScriptVarInt(stack.First()).intValue;  							altstack.Push(stack.Skip(1).First()  								.Skip(stack.Skip(1).First().Length - count).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_SIZE:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(new ScriptVarInt((UInt64)stack.First().Length).ToBytes());  							break;  						}  					case OpCode.OP_INVERT:  						{  							if (stack.Count < 1)  								return false;  							Byte[] data = stack.Pop();  							for (int i = 0; i < data.Length; i++)  								data[i] ^= 0xFF;  							stack.Push(data);  							break;  						}  					case OpCode.OP_AND:  					case OpCode.OP_OR:  					case OpCode.OP_XOR:  						{  							if (stack.Count < 2)  								return false;  							Byte[] data = stack.Pop();  							Byte[] data2 = stack.Pop();  							int length = new int[] { data.Length' data2.Length }.Max();  							data = data.Concat(new Byte[length - data.Length]).ToArray();  							data2 = data2.Concat(new Byte[length - data2.Length]).ToArray();  							switch (se.opCode)  							{  								case OpCode.OP_AND:  									{  										for (int i = 0; i < length; i++)  											data[i] &= data2[i];  										break;  									}  								case OpCode.OP_OR:  									{  										for (int i = 0; i < length; i++)  											data[i] |= data2[i];  										break;  									}  								case OpCode.OP_XOR:  									{  										for (int i = 0; i < length; i++)  											data[i] ^= data2[i];  										break;  									}  							}  							stack.Push(data);  							break;  						}  					case OpCode.OP_EQUAL:  					case OpCode.OP_EQUALVERIFY:  						{  							if (stack.Count < 2)  								return false;  							if (stack.Pop().SequenceEqual(stack.Pop()))  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });    							if (se.opCode == OpCode.OP_EQUALVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_RESERVED1:  					case OpCode.OP_RESERVED2:  						{  							return false;  						}  					case OpCode.OP_1ADD:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Add(new ScriptVarInt(stack.Pop())' 1)).ToBytes());  							break;  						}  					case OpCode.OP_1SUB:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Subtract(new ScriptVarInt(stack.Pop())' 1)).ToBytes());  							break;  						}  					case OpCode.OP_2MUL:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Multiply(new ScriptVarInt(stack.Pop())' 2)).ToBytes());  							break;  						}  					case OpCode.OP_2DIV:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Divide(new ScriptVarInt(stack.Pop())' 2)).ToBytes());  							break;  						}  					case OpCode.OP_NEGATE:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Negate(new ScriptVarInt(stack.Pop()))).ToBytes());  							break;  						}  					case OpCode.OP_ABS:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Abs(new ScriptVarInt(stack.Pop()))).ToBytes());  							break;  						}  					case OpCode.OP_NOT:  						{  							if (stack.Count < 1)  								return false;  							if (new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_0NOTEQUAL:  						{  							if (stack.Count < 1)  								return false;  							if (new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x00 });  							else  								stack.Push(new Byte[] { 0x01 });  							break;  						}  					case OpCode.OP_ADD:  					case OpCode.OP_SUB:  					case OpCode.OP_MUL:  					case OpCode.OP_DIV:  					case OpCode.OP_MOD:  					case OpCode.OP_LSHIFT:  					case OpCode.OP_RSHIFT:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							switch (se.opCode)  							{  								case OpCode.OP_ADD:  									a = (BigInteger)a + b;  									break;  								case OpCode.OP_SUB:  									a = (BigInteger)a - b;  									break;  								case OpCode.OP_MUL:  									a = (BigInteger)a * b;  									break;  								case OpCode.OP_DIV:  									a = (BigInteger)a / b;  									break;  								case OpCode.OP_MOD:  									a = (BigInteger)a % b;  									break;  								case OpCode.OP_LSHIFT:  									a = (BigInteger)a << b.intValue;  									break;  								case OpCode.OP_RSHIFT:  									a = (BigInteger)a >> b.intValue;  									break;  							}  							stack.Push(a.ToBytes());  							break;  						}  					case OpCode.OP_BOOLAND:  						{  							if (stack.Count < 2)  								return false;  							if (!new ScriptVarInt(stack.Pop()).value.IsZero && !new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_BOOLOR:  						{  							if (stack.Count < 2)  								return false;  							if (!new ScriptVarInt(stack.Pop()).value.IsZero || !new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_NUMEQUAL:  					case OpCode.OP_NUMEQUALVERIFY:  						{  							if (stack.Count < 2)  								return false;  							if (new ScriptVarInt(stack.Pop()).value == new ScriptVarInt(stack.Pop()).value)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							if (se.opCode == OpCode.OP_NUMEQUALVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_NUMNOTEQUAL:  						{  							if (stack.Count < 2)  								return false;  							if (new ScriptVarInt(stack.Pop()).value != new ScriptVarInt(stack.Pop()).value)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_LESSTHAN:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a < b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_GREATERTHAN:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a > b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_LESSTHANOREQUAL:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a <= b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_GREATERTHANOREQUAL:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a >= b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_MIN:  						{  							if (stack.Count < 2)  								return false;  							Byte[] b = stack.Pop();  							Byte[] a = stack.Pop();  							if (new ScriptVarInt(a).value < new ScriptVarInt(b).value)  								stack.Push(a);  							else  								stack.Push(b);  							break;  						}  					case OpCode.OP_MAX:  						{  							if (stack.Count < 2)  								return false;  							Byte[] b = stack.Pop();  							Byte[] a = stack.Pop();  							if (new ScriptVarInt(a).value > new ScriptVarInt(b).value)  								stack.Push(a);  							else  								stack.Push(b);  							break;  						}  					case OpCode.OP_WITHIN:  						{  							if (stack.Count < 3)  								return false;  							ScriptVarInt max = new ScriptVarInt(stack.Pop());  							ScriptVarInt min = new ScriptVarInt(stack.Pop());  							ScriptVarInt x = new ScriptVarInt(stack.Pop());  							if ((BigInteger)min <= x && (BigInteger)x <= max)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_RIPEMD160:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(ripemd160.ComputeHash(stack.Pop()));  							break;  						}  					case OpCode.OP_SHA1:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(sha1.ComputeHash(stack.Pop()));  							break;  						}  					case OpCode.OP_SHA256:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(sha256.ComputeHash(stack.Pop()));  							break;  						}  					case OpCode.OP_HASH160:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(ripemd160.ComputeHash(sha256.ComputeHash(stack.Pop())));  							break;  						}  					case OpCode.OP_HASH256:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(sha256.ComputeHash(sha256.ComputeHash(stack.Pop())));  							break;  						}  					case OpCode.OP_CODESEPARATOR:  						{  							lastCodeSeperator = index;  							break;  						}  					case OpCode.OP_CHECKSIG:  					case OpCode.OP_CHECKSIGVERIFY:  						{  							if (tx == null)  								throw new ArgumentNullException("Transaction is required if script contains OP_CHECKSIG[VERIFY]");  							if (stack.Count < 2)  								return false;    							PublicKey pubKey = new PublicKey(stack.Pop());  							Byte[] sig = stack.Pop();    							Script subScript = new Script(elements.Skip(lastCodeSeperator)  								.Where(x => x.opCode != OpCode.OP_CODESEPARATOR).ToArray());    							stack.Push(new ScriptVarInt(CheckSig(sig' pubKey' txInIndex' subScript' tx) ? 1 : 0).ToBytes());    							if (se.opCode == OpCode.OP_CHECKSIGVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_CHECKMULTISIG:  					case OpCode.OP_CHECKMULTISIGVERIFY:  						{  							if (tx == null)  								throw new ArgumentNullException("Transaction is required if script contains OP_CHECKMULTISIG[VERIFY]");  							if (stack.Count < 2)  								return false;    							PublicKey[] pubKeys = new PublicKey[new ScriptVarInt(stack.Pop()).intValue];    							if (stack.Count < pubKeys.Length + 1)  								return false;    							for (int i = 0; i < pubKeys.Length; i++)  							{  								pubKeys[i] = new PublicKey(stack.Pop());  							}    							Byte[][] sigs = new Byte[new ScriptVarInt(stack.Pop()).intValue][];    							if (stack.Count < sigs.Length)  								return false;    							for (int i = 0; i < sigs.Length; i++)  							{  								sigs[i] = stack.Pop();  							}    							// Remove extra unused value from stack  							stack.Pop();    							Script subScript = new Script(elements.Skip(lastCodeSeperator)  								.Where(x => x.opCode != OpCode.OP_CODESEPARATOR).ToArray());    							int validSigs = 0;  							foreach (Byte[] sig in sigs)  							{  								foreach (PublicKey pubKey in pubKeys)  								{  									if (CheckSig(sig' pubKey' txInIndex' subScript' tx))  									{  										pubKeys = pubKeys.Where(x => x != pubKey).ToArray();  										validSigs++;  										break;  									}  								}  							}    							stack.Push(new ScriptVarInt((validSigs >= sigs.Length) ? 1 : 0).ToBytes());    							if (se.opCode == OpCode.OP_CHECKMULTISIGVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_NOP1:  					case OpCode.OP_NOP2:  					case OpCode.OP_NOP3:  					case OpCode.OP_NOP4:  					case OpCode.OP_NOP5:  					case OpCode.OP_NOP6:  					case OpCode.OP_NOP7:  					case OpCode.OP_NOP8:  					case OpCode.OP_NOP9:  					case OpCode.OP_NOP10:  						{  							break;  						}  					case OpCode.OP_SMALLINTEGER:  					case OpCode.OP_PUBKEYS:  					case OpCode.OP_PUBKEYHASH:  					case OpCode.OP_PUBKEY:  					case OpCode.OP_INVALIDOPCODE:  					default:  						{  							return false;  						}    				}  			}
Magic Number,Bitcoin_Tool.Scripts,Script,C:\repos\mb300sd_Bitcoin-Tool\Bitcoin Tool\Scripts\Script.cs,Evaluate,The following statement contains a magic number: for (int index = 0; index < elements.Count; index++)  			{  				ScriptElement se = elements[index];  				if (ifExec.Count > 0)  					if ((ifExec.First() == IfElseExec.SKIP_IF && !(se.opCode == OpCode.OP_ELSE || se.opCode == OpCode.OP_ENDIF)) ||  						(ifExec.First() == IfElseExec.SKIP_ELSE && !(se.opCode == OpCode.OP_ENDIF)))  						continue;    				if (se.isData)  				{  					stack.Push(se.data);  					continue;  				}    				switch (se.opCode)  				{  					case OpCode.OP_RESERVED:  						{  							return false;  						}  					case OpCode.OP_NOP:  						{  							// NOP' Dump stack for debug  							/*  							stack.ToList().ForEach(x => Console.WriteLine(HexString.FromByteArray(x)));  							Console.WriteLine("---------------------------");  							*/  							break;  						}  					case OpCode.OP_VER:  						{  							return false;  						}  					case OpCode.OP_IF:  					case OpCode.OP_NOTIF:  						{  							if (stack.Count < 1)  								return false;  							Boolean stackIsZero = new ScriptVarInt(stack.Pop()).value.IsZero;  							if ((se.opCode == OpCode.OP_IF && !stackIsZero) || (se.opCode == OpCode.OP_NOTIF && stackIsZero))  							{  								// Run to else or endif  								ifExec.Push(IfElseExec.RUN_IF);  							}  							else  							{  								// Skip to else or endif  								ifExec.Push(IfElseExec.SKIP_IF);  							}  							break;  						}  					case OpCode.OP_VERIF:  					case OpCode.OP_VERNOTIF:  						{  							return false;  						}  					case OpCode.OP_ELSE:  						{  							if (ifExec.Count == 0)  								// No preceding if statement!  								return false;  							if (ifExec.First() == IfElseExec.RUN_IF)  							{  								// If ran' skip else  								ifExec.Push(IfElseExec.SKIP_ELSE);  							}  							else if (ifExec.First() == IfElseExec.SKIP_IF)  							{  								// If did not run' run else  								ifExec.Push(IfElseExec.RUN_ELSE);  							}  							break;  						}  					case OpCode.OP_ENDIF:  						{  							if (ifExec.Count == 0)  								// No preceding if statement!  								return false;  							if (ifExec.First() == IfElseExec.RUN_IF ||  								ifExec.First() == IfElseExec.SKIP_IF)  							{  								ifExec.Pop();  							}  							else if (ifExec.First() == IfElseExec.RUN_ELSE ||  							   ifExec.First() == IfElseExec.SKIP_ELSE)  							{  								ifExec.Pop();  								ifExec.Pop();  							}  							break;  						}  					case OpCode.OP_VERIFY:  						{  							if (stack.Count < 1 || new ScriptVarInt(stack.First()).value.IsZero)  								return false;  							stack.Pop();  							break;  						}  					case OpCode.OP_RETURN:  						{  							return false;  						}  					case OpCode.OP_TOALTSTACK:  						{  							if (stack.Count < 1)  								return false;  							altstack.Push(stack.Pop());  							break;  						}  					case OpCode.OP_FROMALTSTACK:  						{  							if (altstack.Count < 1)  								return false;  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_2DROP:  						{  							if (stack.Count < 2)  								return false;  							stack.Pop();  							stack.Pop();  							break;  						}  					case OpCode.OP_2DUP:  						{  							if (stack.Count < 2)  								return false;  							stack.Push(stack.Skip(1).First());  							stack.Push(stack.Skip(1).First());  							break;  						}  					case OpCode.OP_3DUP:  						{  							if (stack.Count < 3)  								return false;  							stack.Push(stack.Skip(2).First());  							stack.Push(stack.Skip(2).First());  							stack.Push(stack.Skip(2).First());  							break;  						}  					case OpCode.OP_2OVER:  						{  							if (stack.Count < 4)  								return false;  							stack.Push(stack.Skip(3).First());  							stack.Push(stack.Skip(3).First());  							break;  						}  					case OpCode.OP_2ROT:  						{  							if (stack.Count < 6)  								return false;  							altstack.Push(stack.Skip(4).First());  							altstack.Push(stack.Skip(5).First());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_2SWAP:  						{  							if (stack.Count < 4)  								return false;  							altstack.Push(stack.Skip(2).First());  							altstack.Push(stack.Skip(3).First());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_IFDUP:  						{  							if (stack.Count < 1)  								return false;  							if (!new ScriptVarInt(stack.First()).value.IsZero)  								stack.Push(stack.First());  							break;  						}  					case OpCode.OP_DEPTH:  						{  							stack.Push(new ScriptVarInt((UInt64)stack.Count).ToBytes());  							break;  						}  					case OpCode.OP_DROP:  						{  							if (stack.Count < 1)  								return false;  							stack.Pop();  							break;  						}  					case OpCode.OP_DUP:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(stack.First());  							break;  						}  					case OpCode.OP_NIP:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_OVER:  						{  							if (stack.Count < 2)  								return false;  							stack.Push(stack.Skip(1).First());  							break;  						}  					case OpCode.OP_PICK:  						{  							if (stack.Count < 2)  								return false;  							int pick = new ScriptVarInt(stack.Pop()).intValue;  							if (pick < 0 || stack.Count <= pick)  								return false;  							stack.Push(stack.Skip(pick).First());  							break;  						}  					case OpCode.OP_ROLL:  						{  							if (stack.Count < 2)  								return false;  							int roll = new ScriptVarInt(stack.Pop()).intValue;  							if (roll < 0 || stack.Count <= roll)  								return false;  							altstack.Push(stack.Skip(roll).First());  							for (int i = 0; i < roll; i++)  								altstack.Push(stack.Pop());  							stack.Pop();  							for (int i = 0; i < roll + 1; i++)  								stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_ROT:  						{  							if (stack.Count < 3)  								return false;  							altstack.Push(stack.Skip(2).First());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_SWAP:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Skip(1).First());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_TUCK:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Push(altstack.Skip(1).First());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_CAT:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Skip(1).First().Concat(stack.First()).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_SUBSTR:  						{  							if (stack.Count < 3)  								return false;  							altstack.Push(stack.Skip(2).First()  								.Skip(new ScriptVarInt(stack.Skip(1).First()).intValue)  								.Take(new ScriptVarInt(stack.First()).intValue).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_LEFT:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Skip(1).First()  								.Take(new ScriptVarInt(stack.First()).intValue).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_RIGHT:  						{  							if (stack.Count < 2)  								return false;  							int count = new ScriptVarInt(stack.First()).intValue;  							altstack.Push(stack.Skip(1).First()  								.Skip(stack.Skip(1).First().Length - count).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_SIZE:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(new ScriptVarInt((UInt64)stack.First().Length).ToBytes());  							break;  						}  					case OpCode.OP_INVERT:  						{  							if (stack.Count < 1)  								return false;  							Byte[] data = stack.Pop();  							for (int i = 0; i < data.Length; i++)  								data[i] ^= 0xFF;  							stack.Push(data);  							break;  						}  					case OpCode.OP_AND:  					case OpCode.OP_OR:  					case OpCode.OP_XOR:  						{  							if (stack.Count < 2)  								return false;  							Byte[] data = stack.Pop();  							Byte[] data2 = stack.Pop();  							int length = new int[] { data.Length' data2.Length }.Max();  							data = data.Concat(new Byte[length - data.Length]).ToArray();  							data2 = data2.Concat(new Byte[length - data2.Length]).ToArray();  							switch (se.opCode)  							{  								case OpCode.OP_AND:  									{  										for (int i = 0; i < length; i++)  											data[i] &= data2[i];  										break;  									}  								case OpCode.OP_OR:  									{  										for (int i = 0; i < length; i++)  											data[i] |= data2[i];  										break;  									}  								case OpCode.OP_XOR:  									{  										for (int i = 0; i < length; i++)  											data[i] ^= data2[i];  										break;  									}  							}  							stack.Push(data);  							break;  						}  					case OpCode.OP_EQUAL:  					case OpCode.OP_EQUALVERIFY:  						{  							if (stack.Count < 2)  								return false;  							if (stack.Pop().SequenceEqual(stack.Pop()))  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });    							if (se.opCode == OpCode.OP_EQUALVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_RESERVED1:  					case OpCode.OP_RESERVED2:  						{  							return false;  						}  					case OpCode.OP_1ADD:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Add(new ScriptVarInt(stack.Pop())' 1)).ToBytes());  							break;  						}  					case OpCode.OP_1SUB:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Subtract(new ScriptVarInt(stack.Pop())' 1)).ToBytes());  							break;  						}  					case OpCode.OP_2MUL:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Multiply(new ScriptVarInt(stack.Pop())' 2)).ToBytes());  							break;  						}  					case OpCode.OP_2DIV:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Divide(new ScriptVarInt(stack.Pop())' 2)).ToBytes());  							break;  						}  					case OpCode.OP_NEGATE:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Negate(new ScriptVarInt(stack.Pop()))).ToBytes());  							break;  						}  					case OpCode.OP_ABS:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Abs(new ScriptVarInt(stack.Pop()))).ToBytes());  							break;  						}  					case OpCode.OP_NOT:  						{  							if (stack.Count < 1)  								return false;  							if (new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_0NOTEQUAL:  						{  							if (stack.Count < 1)  								return false;  							if (new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x00 });  							else  								stack.Push(new Byte[] { 0x01 });  							break;  						}  					case OpCode.OP_ADD:  					case OpCode.OP_SUB:  					case OpCode.OP_MUL:  					case OpCode.OP_DIV:  					case OpCode.OP_MOD:  					case OpCode.OP_LSHIFT:  					case OpCode.OP_RSHIFT:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							switch (se.opCode)  							{  								case OpCode.OP_ADD:  									a = (BigInteger)a + b;  									break;  								case OpCode.OP_SUB:  									a = (BigInteger)a - b;  									break;  								case OpCode.OP_MUL:  									a = (BigInteger)a * b;  									break;  								case OpCode.OP_DIV:  									a = (BigInteger)a / b;  									break;  								case OpCode.OP_MOD:  									a = (BigInteger)a % b;  									break;  								case OpCode.OP_LSHIFT:  									a = (BigInteger)a << b.intValue;  									break;  								case OpCode.OP_RSHIFT:  									a = (BigInteger)a >> b.intValue;  									break;  							}  							stack.Push(a.ToBytes());  							break;  						}  					case OpCode.OP_BOOLAND:  						{  							if (stack.Count < 2)  								return false;  							if (!new ScriptVarInt(stack.Pop()).value.IsZero && !new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_BOOLOR:  						{  							if (stack.Count < 2)  								return false;  							if (!new ScriptVarInt(stack.Pop()).value.IsZero || !new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_NUMEQUAL:  					case OpCode.OP_NUMEQUALVERIFY:  						{  							if (stack.Count < 2)  								return false;  							if (new ScriptVarInt(stack.Pop()).value == new ScriptVarInt(stack.Pop()).value)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							if (se.opCode == OpCode.OP_NUMEQUALVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_NUMNOTEQUAL:  						{  							if (stack.Count < 2)  								return false;  							if (new ScriptVarInt(stack.Pop()).value != new ScriptVarInt(stack.Pop()).value)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_LESSTHAN:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a < b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_GREATERTHAN:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a > b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_LESSTHANOREQUAL:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a <= b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_GREATERTHANOREQUAL:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a >= b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_MIN:  						{  							if (stack.Count < 2)  								return false;  							Byte[] b = stack.Pop();  							Byte[] a = stack.Pop();  							if (new ScriptVarInt(a).value < new ScriptVarInt(b).value)  								stack.Push(a);  							else  								stack.Push(b);  							break;  						}  					case OpCode.OP_MAX:  						{  							if (stack.Count < 2)  								return false;  							Byte[] b = stack.Pop();  							Byte[] a = stack.Pop();  							if (new ScriptVarInt(a).value > new ScriptVarInt(b).value)  								stack.Push(a);  							else  								stack.Push(b);  							break;  						}  					case OpCode.OP_WITHIN:  						{  							if (stack.Count < 3)  								return false;  							ScriptVarInt max = new ScriptVarInt(stack.Pop());  							ScriptVarInt min = new ScriptVarInt(stack.Pop());  							ScriptVarInt x = new ScriptVarInt(stack.Pop());  							if ((BigInteger)min <= x && (BigInteger)x <= max)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_RIPEMD160:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(ripemd160.ComputeHash(stack.Pop()));  							break;  						}  					case OpCode.OP_SHA1:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(sha1.ComputeHash(stack.Pop()));  							break;  						}  					case OpCode.OP_SHA256:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(sha256.ComputeHash(stack.Pop()));  							break;  						}  					case OpCode.OP_HASH160:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(ripemd160.ComputeHash(sha256.ComputeHash(stack.Pop())));  							break;  						}  					case OpCode.OP_HASH256:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(sha256.ComputeHash(sha256.ComputeHash(stack.Pop())));  							break;  						}  					case OpCode.OP_CODESEPARATOR:  						{  							lastCodeSeperator = index;  							break;  						}  					case OpCode.OP_CHECKSIG:  					case OpCode.OP_CHECKSIGVERIFY:  						{  							if (tx == null)  								throw new ArgumentNullException("Transaction is required if script contains OP_CHECKSIG[VERIFY]");  							if (stack.Count < 2)  								return false;    							PublicKey pubKey = new PublicKey(stack.Pop());  							Byte[] sig = stack.Pop();    							Script subScript = new Script(elements.Skip(lastCodeSeperator)  								.Where(x => x.opCode != OpCode.OP_CODESEPARATOR).ToArray());    							stack.Push(new ScriptVarInt(CheckSig(sig' pubKey' txInIndex' subScript' tx) ? 1 : 0).ToBytes());    							if (se.opCode == OpCode.OP_CHECKSIGVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_CHECKMULTISIG:  					case OpCode.OP_CHECKMULTISIGVERIFY:  						{  							if (tx == null)  								throw new ArgumentNullException("Transaction is required if script contains OP_CHECKMULTISIG[VERIFY]");  							if (stack.Count < 2)  								return false;    							PublicKey[] pubKeys = new PublicKey[new ScriptVarInt(stack.Pop()).intValue];    							if (stack.Count < pubKeys.Length + 1)  								return false;    							for (int i = 0; i < pubKeys.Length; i++)  							{  								pubKeys[i] = new PublicKey(stack.Pop());  							}    							Byte[][] sigs = new Byte[new ScriptVarInt(stack.Pop()).intValue][];    							if (stack.Count < sigs.Length)  								return false;    							for (int i = 0; i < sigs.Length; i++)  							{  								sigs[i] = stack.Pop();  							}    							// Remove extra unused value from stack  							stack.Pop();    							Script subScript = new Script(elements.Skip(lastCodeSeperator)  								.Where(x => x.opCode != OpCode.OP_CODESEPARATOR).ToArray());    							int validSigs = 0;  							foreach (Byte[] sig in sigs)  							{  								foreach (PublicKey pubKey in pubKeys)  								{  									if (CheckSig(sig' pubKey' txInIndex' subScript' tx))  									{  										pubKeys = pubKeys.Where(x => x != pubKey).ToArray();  										validSigs++;  										break;  									}  								}  							}    							stack.Push(new ScriptVarInt((validSigs >= sigs.Length) ? 1 : 0).ToBytes());    							if (se.opCode == OpCode.OP_CHECKMULTISIGVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_NOP1:  					case OpCode.OP_NOP2:  					case OpCode.OP_NOP3:  					case OpCode.OP_NOP4:  					case OpCode.OP_NOP5:  					case OpCode.OP_NOP6:  					case OpCode.OP_NOP7:  					case OpCode.OP_NOP8:  					case OpCode.OP_NOP9:  					case OpCode.OP_NOP10:  						{  							break;  						}  					case OpCode.OP_SMALLINTEGER:  					case OpCode.OP_PUBKEYS:  					case OpCode.OP_PUBKEYHASH:  					case OpCode.OP_PUBKEY:  					case OpCode.OP_INVALIDOPCODE:  					default:  						{  							return false;  						}    				}  			}
Magic Number,Bitcoin_Tool.Scripts,Script,C:\repos\mb300sd_Bitcoin-Tool\Bitcoin Tool\Scripts\Script.cs,Evaluate,The following statement contains a magic number: for (int index = 0; index < elements.Count; index++)  			{  				ScriptElement se = elements[index];  				if (ifExec.Count > 0)  					if ((ifExec.First() == IfElseExec.SKIP_IF && !(se.opCode == OpCode.OP_ELSE || se.opCode == OpCode.OP_ENDIF)) ||  						(ifExec.First() == IfElseExec.SKIP_ELSE && !(se.opCode == OpCode.OP_ENDIF)))  						continue;    				if (se.isData)  				{  					stack.Push(se.data);  					continue;  				}    				switch (se.opCode)  				{  					case OpCode.OP_RESERVED:  						{  							return false;  						}  					case OpCode.OP_NOP:  						{  							// NOP' Dump stack for debug  							/*  							stack.ToList().ForEach(x => Console.WriteLine(HexString.FromByteArray(x)));  							Console.WriteLine("---------------------------");  							*/  							break;  						}  					case OpCode.OP_VER:  						{  							return false;  						}  					case OpCode.OP_IF:  					case OpCode.OP_NOTIF:  						{  							if (stack.Count < 1)  								return false;  							Boolean stackIsZero = new ScriptVarInt(stack.Pop()).value.IsZero;  							if ((se.opCode == OpCode.OP_IF && !stackIsZero) || (se.opCode == OpCode.OP_NOTIF && stackIsZero))  							{  								// Run to else or endif  								ifExec.Push(IfElseExec.RUN_IF);  							}  							else  							{  								// Skip to else or endif  								ifExec.Push(IfElseExec.SKIP_IF);  							}  							break;  						}  					case OpCode.OP_VERIF:  					case OpCode.OP_VERNOTIF:  						{  							return false;  						}  					case OpCode.OP_ELSE:  						{  							if (ifExec.Count == 0)  								// No preceding if statement!  								return false;  							if (ifExec.First() == IfElseExec.RUN_IF)  							{  								// If ran' skip else  								ifExec.Push(IfElseExec.SKIP_ELSE);  							}  							else if (ifExec.First() == IfElseExec.SKIP_IF)  							{  								// If did not run' run else  								ifExec.Push(IfElseExec.RUN_ELSE);  							}  							break;  						}  					case OpCode.OP_ENDIF:  						{  							if (ifExec.Count == 0)  								// No preceding if statement!  								return false;  							if (ifExec.First() == IfElseExec.RUN_IF ||  								ifExec.First() == IfElseExec.SKIP_IF)  							{  								ifExec.Pop();  							}  							else if (ifExec.First() == IfElseExec.RUN_ELSE ||  							   ifExec.First() == IfElseExec.SKIP_ELSE)  							{  								ifExec.Pop();  								ifExec.Pop();  							}  							break;  						}  					case OpCode.OP_VERIFY:  						{  							if (stack.Count < 1 || new ScriptVarInt(stack.First()).value.IsZero)  								return false;  							stack.Pop();  							break;  						}  					case OpCode.OP_RETURN:  						{  							return false;  						}  					case OpCode.OP_TOALTSTACK:  						{  							if (stack.Count < 1)  								return false;  							altstack.Push(stack.Pop());  							break;  						}  					case OpCode.OP_FROMALTSTACK:  						{  							if (altstack.Count < 1)  								return false;  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_2DROP:  						{  							if (stack.Count < 2)  								return false;  							stack.Pop();  							stack.Pop();  							break;  						}  					case OpCode.OP_2DUP:  						{  							if (stack.Count < 2)  								return false;  							stack.Push(stack.Skip(1).First());  							stack.Push(stack.Skip(1).First());  							break;  						}  					case OpCode.OP_3DUP:  						{  							if (stack.Count < 3)  								return false;  							stack.Push(stack.Skip(2).First());  							stack.Push(stack.Skip(2).First());  							stack.Push(stack.Skip(2).First());  							break;  						}  					case OpCode.OP_2OVER:  						{  							if (stack.Count < 4)  								return false;  							stack.Push(stack.Skip(3).First());  							stack.Push(stack.Skip(3).First());  							break;  						}  					case OpCode.OP_2ROT:  						{  							if (stack.Count < 6)  								return false;  							altstack.Push(stack.Skip(4).First());  							altstack.Push(stack.Skip(5).First());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_2SWAP:  						{  							if (stack.Count < 4)  								return false;  							altstack.Push(stack.Skip(2).First());  							altstack.Push(stack.Skip(3).First());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_IFDUP:  						{  							if (stack.Count < 1)  								return false;  							if (!new ScriptVarInt(stack.First()).value.IsZero)  								stack.Push(stack.First());  							break;  						}  					case OpCode.OP_DEPTH:  						{  							stack.Push(new ScriptVarInt((UInt64)stack.Count).ToBytes());  							break;  						}  					case OpCode.OP_DROP:  						{  							if (stack.Count < 1)  								return false;  							stack.Pop();  							break;  						}  					case OpCode.OP_DUP:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(stack.First());  							break;  						}  					case OpCode.OP_NIP:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_OVER:  						{  							if (stack.Count < 2)  								return false;  							stack.Push(stack.Skip(1).First());  							break;  						}  					case OpCode.OP_PICK:  						{  							if (stack.Count < 2)  								return false;  							int pick = new ScriptVarInt(stack.Pop()).intValue;  							if (pick < 0 || stack.Count <= pick)  								return false;  							stack.Push(stack.Skip(pick).First());  							break;  						}  					case OpCode.OP_ROLL:  						{  							if (stack.Count < 2)  								return false;  							int roll = new ScriptVarInt(stack.Pop()).intValue;  							if (roll < 0 || stack.Count <= roll)  								return false;  							altstack.Push(stack.Skip(roll).First());  							for (int i = 0; i < roll; i++)  								altstack.Push(stack.Pop());  							stack.Pop();  							for (int i = 0; i < roll + 1; i++)  								stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_ROT:  						{  							if (stack.Count < 3)  								return false;  							altstack.Push(stack.Skip(2).First());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_SWAP:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Skip(1).First());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_TUCK:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Push(altstack.Skip(1).First());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_CAT:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Skip(1).First().Concat(stack.First()).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_SUBSTR:  						{  							if (stack.Count < 3)  								return false;  							altstack.Push(stack.Skip(2).First()  								.Skip(new ScriptVarInt(stack.Skip(1).First()).intValue)  								.Take(new ScriptVarInt(stack.First()).intValue).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_LEFT:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Skip(1).First()  								.Take(new ScriptVarInt(stack.First()).intValue).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_RIGHT:  						{  							if (stack.Count < 2)  								return false;  							int count = new ScriptVarInt(stack.First()).intValue;  							altstack.Push(stack.Skip(1).First()  								.Skip(stack.Skip(1).First().Length - count).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_SIZE:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(new ScriptVarInt((UInt64)stack.First().Length).ToBytes());  							break;  						}  					case OpCode.OP_INVERT:  						{  							if (stack.Count < 1)  								return false;  							Byte[] data = stack.Pop();  							for (int i = 0; i < data.Length; i++)  								data[i] ^= 0xFF;  							stack.Push(data);  							break;  						}  					case OpCode.OP_AND:  					case OpCode.OP_OR:  					case OpCode.OP_XOR:  						{  							if (stack.Count < 2)  								return false;  							Byte[] data = stack.Pop();  							Byte[] data2 = stack.Pop();  							int length = new int[] { data.Length' data2.Length }.Max();  							data = data.Concat(new Byte[length - data.Length]).ToArray();  							data2 = data2.Concat(new Byte[length - data2.Length]).ToArray();  							switch (se.opCode)  							{  								case OpCode.OP_AND:  									{  										for (int i = 0; i < length; i++)  											data[i] &= data2[i];  										break;  									}  								case OpCode.OP_OR:  									{  										for (int i = 0; i < length; i++)  											data[i] |= data2[i];  										break;  									}  								case OpCode.OP_XOR:  									{  										for (int i = 0; i < length; i++)  											data[i] ^= data2[i];  										break;  									}  							}  							stack.Push(data);  							break;  						}  					case OpCode.OP_EQUAL:  					case OpCode.OP_EQUALVERIFY:  						{  							if (stack.Count < 2)  								return false;  							if (stack.Pop().SequenceEqual(stack.Pop()))  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });    							if (se.opCode == OpCode.OP_EQUALVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_RESERVED1:  					case OpCode.OP_RESERVED2:  						{  							return false;  						}  					case OpCode.OP_1ADD:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Add(new ScriptVarInt(stack.Pop())' 1)).ToBytes());  							break;  						}  					case OpCode.OP_1SUB:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Subtract(new ScriptVarInt(stack.Pop())' 1)).ToBytes());  							break;  						}  					case OpCode.OP_2MUL:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Multiply(new ScriptVarInt(stack.Pop())' 2)).ToBytes());  							break;  						}  					case OpCode.OP_2DIV:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Divide(new ScriptVarInt(stack.Pop())' 2)).ToBytes());  							break;  						}  					case OpCode.OP_NEGATE:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Negate(new ScriptVarInt(stack.Pop()))).ToBytes());  							break;  						}  					case OpCode.OP_ABS:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Abs(new ScriptVarInt(stack.Pop()))).ToBytes());  							break;  						}  					case OpCode.OP_NOT:  						{  							if (stack.Count < 1)  								return false;  							if (new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_0NOTEQUAL:  						{  							if (stack.Count < 1)  								return false;  							if (new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x00 });  							else  								stack.Push(new Byte[] { 0x01 });  							break;  						}  					case OpCode.OP_ADD:  					case OpCode.OP_SUB:  					case OpCode.OP_MUL:  					case OpCode.OP_DIV:  					case OpCode.OP_MOD:  					case OpCode.OP_LSHIFT:  					case OpCode.OP_RSHIFT:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							switch (se.opCode)  							{  								case OpCode.OP_ADD:  									a = (BigInteger)a + b;  									break;  								case OpCode.OP_SUB:  									a = (BigInteger)a - b;  									break;  								case OpCode.OP_MUL:  									a = (BigInteger)a * b;  									break;  								case OpCode.OP_DIV:  									a = (BigInteger)a / b;  									break;  								case OpCode.OP_MOD:  									a = (BigInteger)a % b;  									break;  								case OpCode.OP_LSHIFT:  									a = (BigInteger)a << b.intValue;  									break;  								case OpCode.OP_RSHIFT:  									a = (BigInteger)a >> b.intValue;  									break;  							}  							stack.Push(a.ToBytes());  							break;  						}  					case OpCode.OP_BOOLAND:  						{  							if (stack.Count < 2)  								return false;  							if (!new ScriptVarInt(stack.Pop()).value.IsZero && !new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_BOOLOR:  						{  							if (stack.Count < 2)  								return false;  							if (!new ScriptVarInt(stack.Pop()).value.IsZero || !new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_NUMEQUAL:  					case OpCode.OP_NUMEQUALVERIFY:  						{  							if (stack.Count < 2)  								return false;  							if (new ScriptVarInt(stack.Pop()).value == new ScriptVarInt(stack.Pop()).value)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							if (se.opCode == OpCode.OP_NUMEQUALVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_NUMNOTEQUAL:  						{  							if (stack.Count < 2)  								return false;  							if (new ScriptVarInt(stack.Pop()).value != new ScriptVarInt(stack.Pop()).value)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_LESSTHAN:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a < b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_GREATERTHAN:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a > b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_LESSTHANOREQUAL:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a <= b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_GREATERTHANOREQUAL:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a >= b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_MIN:  						{  							if (stack.Count < 2)  								return false;  							Byte[] b = stack.Pop();  							Byte[] a = stack.Pop();  							if (new ScriptVarInt(a).value < new ScriptVarInt(b).value)  								stack.Push(a);  							else  								stack.Push(b);  							break;  						}  					case OpCode.OP_MAX:  						{  							if (stack.Count < 2)  								return false;  							Byte[] b = stack.Pop();  							Byte[] a = stack.Pop();  							if (new ScriptVarInt(a).value > new ScriptVarInt(b).value)  								stack.Push(a);  							else  								stack.Push(b);  							break;  						}  					case OpCode.OP_WITHIN:  						{  							if (stack.Count < 3)  								return false;  							ScriptVarInt max = new ScriptVarInt(stack.Pop());  							ScriptVarInt min = new ScriptVarInt(stack.Pop());  							ScriptVarInt x = new ScriptVarInt(stack.Pop());  							if ((BigInteger)min <= x && (BigInteger)x <= max)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_RIPEMD160:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(ripemd160.ComputeHash(stack.Pop()));  							break;  						}  					case OpCode.OP_SHA1:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(sha1.ComputeHash(stack.Pop()));  							break;  						}  					case OpCode.OP_SHA256:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(sha256.ComputeHash(stack.Pop()));  							break;  						}  					case OpCode.OP_HASH160:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(ripemd160.ComputeHash(sha256.ComputeHash(stack.Pop())));  							break;  						}  					case OpCode.OP_HASH256:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(sha256.ComputeHash(sha256.ComputeHash(stack.Pop())));  							break;  						}  					case OpCode.OP_CODESEPARATOR:  						{  							lastCodeSeperator = index;  							break;  						}  					case OpCode.OP_CHECKSIG:  					case OpCode.OP_CHECKSIGVERIFY:  						{  							if (tx == null)  								throw new ArgumentNullException("Transaction is required if script contains OP_CHECKSIG[VERIFY]");  							if (stack.Count < 2)  								return false;    							PublicKey pubKey = new PublicKey(stack.Pop());  							Byte[] sig = stack.Pop();    							Script subScript = new Script(elements.Skip(lastCodeSeperator)  								.Where(x => x.opCode != OpCode.OP_CODESEPARATOR).ToArray());    							stack.Push(new ScriptVarInt(CheckSig(sig' pubKey' txInIndex' subScript' tx) ? 1 : 0).ToBytes());    							if (se.opCode == OpCode.OP_CHECKSIGVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_CHECKMULTISIG:  					case OpCode.OP_CHECKMULTISIGVERIFY:  						{  							if (tx == null)  								throw new ArgumentNullException("Transaction is required if script contains OP_CHECKMULTISIG[VERIFY]");  							if (stack.Count < 2)  								return false;    							PublicKey[] pubKeys = new PublicKey[new ScriptVarInt(stack.Pop()).intValue];    							if (stack.Count < pubKeys.Length + 1)  								return false;    							for (int i = 0; i < pubKeys.Length; i++)  							{  								pubKeys[i] = new PublicKey(stack.Pop());  							}    							Byte[][] sigs = new Byte[new ScriptVarInt(stack.Pop()).intValue][];    							if (stack.Count < sigs.Length)  								return false;    							for (int i = 0; i < sigs.Length; i++)  							{  								sigs[i] = stack.Pop();  							}    							// Remove extra unused value from stack  							stack.Pop();    							Script subScript = new Script(elements.Skip(lastCodeSeperator)  								.Where(x => x.opCode != OpCode.OP_CODESEPARATOR).ToArray());    							int validSigs = 0;  							foreach (Byte[] sig in sigs)  							{  								foreach (PublicKey pubKey in pubKeys)  								{  									if (CheckSig(sig' pubKey' txInIndex' subScript' tx))  									{  										pubKeys = pubKeys.Where(x => x != pubKey).ToArray();  										validSigs++;  										break;  									}  								}  							}    							stack.Push(new ScriptVarInt((validSigs >= sigs.Length) ? 1 : 0).ToBytes());    							if (se.opCode == OpCode.OP_CHECKMULTISIGVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_NOP1:  					case OpCode.OP_NOP2:  					case OpCode.OP_NOP3:  					case OpCode.OP_NOP4:  					case OpCode.OP_NOP5:  					case OpCode.OP_NOP6:  					case OpCode.OP_NOP7:  					case OpCode.OP_NOP8:  					case OpCode.OP_NOP9:  					case OpCode.OP_NOP10:  						{  							break;  						}  					case OpCode.OP_SMALLINTEGER:  					case OpCode.OP_PUBKEYS:  					case OpCode.OP_PUBKEYHASH:  					case OpCode.OP_PUBKEY:  					case OpCode.OP_INVALIDOPCODE:  					default:  						{  							return false;  						}    				}  			}
Magic Number,Bitcoin_Tool.Scripts,Script,C:\repos\mb300sd_Bitcoin-Tool\Bitcoin Tool\Scripts\Script.cs,Evaluate,The following statement contains a magic number: for (int index = 0; index < elements.Count; index++)  			{  				ScriptElement se = elements[index];  				if (ifExec.Count > 0)  					if ((ifExec.First() == IfElseExec.SKIP_IF && !(se.opCode == OpCode.OP_ELSE || se.opCode == OpCode.OP_ENDIF)) ||  						(ifExec.First() == IfElseExec.SKIP_ELSE && !(se.opCode == OpCode.OP_ENDIF)))  						continue;    				if (se.isData)  				{  					stack.Push(se.data);  					continue;  				}    				switch (se.opCode)  				{  					case OpCode.OP_RESERVED:  						{  							return false;  						}  					case OpCode.OP_NOP:  						{  							// NOP' Dump stack for debug  							/*  							stack.ToList().ForEach(x => Console.WriteLine(HexString.FromByteArray(x)));  							Console.WriteLine("---------------------------");  							*/  							break;  						}  					case OpCode.OP_VER:  						{  							return false;  						}  					case OpCode.OP_IF:  					case OpCode.OP_NOTIF:  						{  							if (stack.Count < 1)  								return false;  							Boolean stackIsZero = new ScriptVarInt(stack.Pop()).value.IsZero;  							if ((se.opCode == OpCode.OP_IF && !stackIsZero) || (se.opCode == OpCode.OP_NOTIF && stackIsZero))  							{  								// Run to else or endif  								ifExec.Push(IfElseExec.RUN_IF);  							}  							else  							{  								// Skip to else or endif  								ifExec.Push(IfElseExec.SKIP_IF);  							}  							break;  						}  					case OpCode.OP_VERIF:  					case OpCode.OP_VERNOTIF:  						{  							return false;  						}  					case OpCode.OP_ELSE:  						{  							if (ifExec.Count == 0)  								// No preceding if statement!  								return false;  							if (ifExec.First() == IfElseExec.RUN_IF)  							{  								// If ran' skip else  								ifExec.Push(IfElseExec.SKIP_ELSE);  							}  							else if (ifExec.First() == IfElseExec.SKIP_IF)  							{  								// If did not run' run else  								ifExec.Push(IfElseExec.RUN_ELSE);  							}  							break;  						}  					case OpCode.OP_ENDIF:  						{  							if (ifExec.Count == 0)  								// No preceding if statement!  								return false;  							if (ifExec.First() == IfElseExec.RUN_IF ||  								ifExec.First() == IfElseExec.SKIP_IF)  							{  								ifExec.Pop();  							}  							else if (ifExec.First() == IfElseExec.RUN_ELSE ||  							   ifExec.First() == IfElseExec.SKIP_ELSE)  							{  								ifExec.Pop();  								ifExec.Pop();  							}  							break;  						}  					case OpCode.OP_VERIFY:  						{  							if (stack.Count < 1 || new ScriptVarInt(stack.First()).value.IsZero)  								return false;  							stack.Pop();  							break;  						}  					case OpCode.OP_RETURN:  						{  							return false;  						}  					case OpCode.OP_TOALTSTACK:  						{  							if (stack.Count < 1)  								return false;  							altstack.Push(stack.Pop());  							break;  						}  					case OpCode.OP_FROMALTSTACK:  						{  							if (altstack.Count < 1)  								return false;  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_2DROP:  						{  							if (stack.Count < 2)  								return false;  							stack.Pop();  							stack.Pop();  							break;  						}  					case OpCode.OP_2DUP:  						{  							if (stack.Count < 2)  								return false;  							stack.Push(stack.Skip(1).First());  							stack.Push(stack.Skip(1).First());  							break;  						}  					case OpCode.OP_3DUP:  						{  							if (stack.Count < 3)  								return false;  							stack.Push(stack.Skip(2).First());  							stack.Push(stack.Skip(2).First());  							stack.Push(stack.Skip(2).First());  							break;  						}  					case OpCode.OP_2OVER:  						{  							if (stack.Count < 4)  								return false;  							stack.Push(stack.Skip(3).First());  							stack.Push(stack.Skip(3).First());  							break;  						}  					case OpCode.OP_2ROT:  						{  							if (stack.Count < 6)  								return false;  							altstack.Push(stack.Skip(4).First());  							altstack.Push(stack.Skip(5).First());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_2SWAP:  						{  							if (stack.Count < 4)  								return false;  							altstack.Push(stack.Skip(2).First());  							altstack.Push(stack.Skip(3).First());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_IFDUP:  						{  							if (stack.Count < 1)  								return false;  							if (!new ScriptVarInt(stack.First()).value.IsZero)  								stack.Push(stack.First());  							break;  						}  					case OpCode.OP_DEPTH:  						{  							stack.Push(new ScriptVarInt((UInt64)stack.Count).ToBytes());  							break;  						}  					case OpCode.OP_DROP:  						{  							if (stack.Count < 1)  								return false;  							stack.Pop();  							break;  						}  					case OpCode.OP_DUP:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(stack.First());  							break;  						}  					case OpCode.OP_NIP:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_OVER:  						{  							if (stack.Count < 2)  								return false;  							stack.Push(stack.Skip(1).First());  							break;  						}  					case OpCode.OP_PICK:  						{  							if (stack.Count < 2)  								return false;  							int pick = new ScriptVarInt(stack.Pop()).intValue;  							if (pick < 0 || stack.Count <= pick)  								return false;  							stack.Push(stack.Skip(pick).First());  							break;  						}  					case OpCode.OP_ROLL:  						{  							if (stack.Count < 2)  								return false;  							int roll = new ScriptVarInt(stack.Pop()).intValue;  							if (roll < 0 || stack.Count <= roll)  								return false;  							altstack.Push(stack.Skip(roll).First());  							for (int i = 0; i < roll; i++)  								altstack.Push(stack.Pop());  							stack.Pop();  							for (int i = 0; i < roll + 1; i++)  								stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_ROT:  						{  							if (stack.Count < 3)  								return false;  							altstack.Push(stack.Skip(2).First());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_SWAP:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Skip(1).First());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_TUCK:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Push(altstack.Skip(1).First());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_CAT:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Skip(1).First().Concat(stack.First()).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_SUBSTR:  						{  							if (stack.Count < 3)  								return false;  							altstack.Push(stack.Skip(2).First()  								.Skip(new ScriptVarInt(stack.Skip(1).First()).intValue)  								.Take(new ScriptVarInt(stack.First()).intValue).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_LEFT:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Skip(1).First()  								.Take(new ScriptVarInt(stack.First()).intValue).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_RIGHT:  						{  							if (stack.Count < 2)  								return false;  							int count = new ScriptVarInt(stack.First()).intValue;  							altstack.Push(stack.Skip(1).First()  								.Skip(stack.Skip(1).First().Length - count).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_SIZE:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(new ScriptVarInt((UInt64)stack.First().Length).ToBytes());  							break;  						}  					case OpCode.OP_INVERT:  						{  							if (stack.Count < 1)  								return false;  							Byte[] data = stack.Pop();  							for (int i = 0; i < data.Length; i++)  								data[i] ^= 0xFF;  							stack.Push(data);  							break;  						}  					case OpCode.OP_AND:  					case OpCode.OP_OR:  					case OpCode.OP_XOR:  						{  							if (stack.Count < 2)  								return false;  							Byte[] data = stack.Pop();  							Byte[] data2 = stack.Pop();  							int length = new int[] { data.Length' data2.Length }.Max();  							data = data.Concat(new Byte[length - data.Length]).ToArray();  							data2 = data2.Concat(new Byte[length - data2.Length]).ToArray();  							switch (se.opCode)  							{  								case OpCode.OP_AND:  									{  										for (int i = 0; i < length; i++)  											data[i] &= data2[i];  										break;  									}  								case OpCode.OP_OR:  									{  										for (int i = 0; i < length; i++)  											data[i] |= data2[i];  										break;  									}  								case OpCode.OP_XOR:  									{  										for (int i = 0; i < length; i++)  											data[i] ^= data2[i];  										break;  									}  							}  							stack.Push(data);  							break;  						}  					case OpCode.OP_EQUAL:  					case OpCode.OP_EQUALVERIFY:  						{  							if (stack.Count < 2)  								return false;  							if (stack.Pop().SequenceEqual(stack.Pop()))  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });    							if (se.opCode == OpCode.OP_EQUALVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_RESERVED1:  					case OpCode.OP_RESERVED2:  						{  							return false;  						}  					case OpCode.OP_1ADD:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Add(new ScriptVarInt(stack.Pop())' 1)).ToBytes());  							break;  						}  					case OpCode.OP_1SUB:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Subtract(new ScriptVarInt(stack.Pop())' 1)).ToBytes());  							break;  						}  					case OpCode.OP_2MUL:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Multiply(new ScriptVarInt(stack.Pop())' 2)).ToBytes());  							break;  						}  					case OpCode.OP_2DIV:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Divide(new ScriptVarInt(stack.Pop())' 2)).ToBytes());  							break;  						}  					case OpCode.OP_NEGATE:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Negate(new ScriptVarInt(stack.Pop()))).ToBytes());  							break;  						}  					case OpCode.OP_ABS:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Abs(new ScriptVarInt(stack.Pop()))).ToBytes());  							break;  						}  					case OpCode.OP_NOT:  						{  							if (stack.Count < 1)  								return false;  							if (new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_0NOTEQUAL:  						{  							if (stack.Count < 1)  								return false;  							if (new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x00 });  							else  								stack.Push(new Byte[] { 0x01 });  							break;  						}  					case OpCode.OP_ADD:  					case OpCode.OP_SUB:  					case OpCode.OP_MUL:  					case OpCode.OP_DIV:  					case OpCode.OP_MOD:  					case OpCode.OP_LSHIFT:  					case OpCode.OP_RSHIFT:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							switch (se.opCode)  							{  								case OpCode.OP_ADD:  									a = (BigInteger)a + b;  									break;  								case OpCode.OP_SUB:  									a = (BigInteger)a - b;  									break;  								case OpCode.OP_MUL:  									a = (BigInteger)a * b;  									break;  								case OpCode.OP_DIV:  									a = (BigInteger)a / b;  									break;  								case OpCode.OP_MOD:  									a = (BigInteger)a % b;  									break;  								case OpCode.OP_LSHIFT:  									a = (BigInteger)a << b.intValue;  									break;  								case OpCode.OP_RSHIFT:  									a = (BigInteger)a >> b.intValue;  									break;  							}  							stack.Push(a.ToBytes());  							break;  						}  					case OpCode.OP_BOOLAND:  						{  							if (stack.Count < 2)  								return false;  							if (!new ScriptVarInt(stack.Pop()).value.IsZero && !new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_BOOLOR:  						{  							if (stack.Count < 2)  								return false;  							if (!new ScriptVarInt(stack.Pop()).value.IsZero || !new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_NUMEQUAL:  					case OpCode.OP_NUMEQUALVERIFY:  						{  							if (stack.Count < 2)  								return false;  							if (new ScriptVarInt(stack.Pop()).value == new ScriptVarInt(stack.Pop()).value)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							if (se.opCode == OpCode.OP_NUMEQUALVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_NUMNOTEQUAL:  						{  							if (stack.Count < 2)  								return false;  							if (new ScriptVarInt(stack.Pop()).value != new ScriptVarInt(stack.Pop()).value)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_LESSTHAN:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a < b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_GREATERTHAN:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a > b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_LESSTHANOREQUAL:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a <= b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_GREATERTHANOREQUAL:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a >= b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_MIN:  						{  							if (stack.Count < 2)  								return false;  							Byte[] b = stack.Pop();  							Byte[] a = stack.Pop();  							if (new ScriptVarInt(a).value < new ScriptVarInt(b).value)  								stack.Push(a);  							else  								stack.Push(b);  							break;  						}  					case OpCode.OP_MAX:  						{  							if (stack.Count < 2)  								return false;  							Byte[] b = stack.Pop();  							Byte[] a = stack.Pop();  							if (new ScriptVarInt(a).value > new ScriptVarInt(b).value)  								stack.Push(a);  							else  								stack.Push(b);  							break;  						}  					case OpCode.OP_WITHIN:  						{  							if (stack.Count < 3)  								return false;  							ScriptVarInt max = new ScriptVarInt(stack.Pop());  							ScriptVarInt min = new ScriptVarInt(stack.Pop());  							ScriptVarInt x = new ScriptVarInt(stack.Pop());  							if ((BigInteger)min <= x && (BigInteger)x <= max)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_RIPEMD160:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(ripemd160.ComputeHash(stack.Pop()));  							break;  						}  					case OpCode.OP_SHA1:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(sha1.ComputeHash(stack.Pop()));  							break;  						}  					case OpCode.OP_SHA256:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(sha256.ComputeHash(stack.Pop()));  							break;  						}  					case OpCode.OP_HASH160:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(ripemd160.ComputeHash(sha256.ComputeHash(stack.Pop())));  							break;  						}  					case OpCode.OP_HASH256:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(sha256.ComputeHash(sha256.ComputeHash(stack.Pop())));  							break;  						}  					case OpCode.OP_CODESEPARATOR:  						{  							lastCodeSeperator = index;  							break;  						}  					case OpCode.OP_CHECKSIG:  					case OpCode.OP_CHECKSIGVERIFY:  						{  							if (tx == null)  								throw new ArgumentNullException("Transaction is required if script contains OP_CHECKSIG[VERIFY]");  							if (stack.Count < 2)  								return false;    							PublicKey pubKey = new PublicKey(stack.Pop());  							Byte[] sig = stack.Pop();    							Script subScript = new Script(elements.Skip(lastCodeSeperator)  								.Where(x => x.opCode != OpCode.OP_CODESEPARATOR).ToArray());    							stack.Push(new ScriptVarInt(CheckSig(sig' pubKey' txInIndex' subScript' tx) ? 1 : 0).ToBytes());    							if (se.opCode == OpCode.OP_CHECKSIGVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_CHECKMULTISIG:  					case OpCode.OP_CHECKMULTISIGVERIFY:  						{  							if (tx == null)  								throw new ArgumentNullException("Transaction is required if script contains OP_CHECKMULTISIG[VERIFY]");  							if (stack.Count < 2)  								return false;    							PublicKey[] pubKeys = new PublicKey[new ScriptVarInt(stack.Pop()).intValue];    							if (stack.Count < pubKeys.Length + 1)  								return false;    							for (int i = 0; i < pubKeys.Length; i++)  							{  								pubKeys[i] = new PublicKey(stack.Pop());  							}    							Byte[][] sigs = new Byte[new ScriptVarInt(stack.Pop()).intValue][];    							if (stack.Count < sigs.Length)  								return false;    							for (int i = 0; i < sigs.Length; i++)  							{  								sigs[i] = stack.Pop();  							}    							// Remove extra unused value from stack  							stack.Pop();    							Script subScript = new Script(elements.Skip(lastCodeSeperator)  								.Where(x => x.opCode != OpCode.OP_CODESEPARATOR).ToArray());    							int validSigs = 0;  							foreach (Byte[] sig in sigs)  							{  								foreach (PublicKey pubKey in pubKeys)  								{  									if (CheckSig(sig' pubKey' txInIndex' subScript' tx))  									{  										pubKeys = pubKeys.Where(x => x != pubKey).ToArray();  										validSigs++;  										break;  									}  								}  							}    							stack.Push(new ScriptVarInt((validSigs >= sigs.Length) ? 1 : 0).ToBytes());    							if (se.opCode == OpCode.OP_CHECKMULTISIGVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_NOP1:  					case OpCode.OP_NOP2:  					case OpCode.OP_NOP3:  					case OpCode.OP_NOP4:  					case OpCode.OP_NOP5:  					case OpCode.OP_NOP6:  					case OpCode.OP_NOP7:  					case OpCode.OP_NOP8:  					case OpCode.OP_NOP9:  					case OpCode.OP_NOP10:  						{  							break;  						}  					case OpCode.OP_SMALLINTEGER:  					case OpCode.OP_PUBKEYS:  					case OpCode.OP_PUBKEYHASH:  					case OpCode.OP_PUBKEY:  					case OpCode.OP_INVALIDOPCODE:  					default:  						{  							return false;  						}    				}  			}
Magic Number,Bitcoin_Tool.Scripts,Script,C:\repos\mb300sd_Bitcoin-Tool\Bitcoin Tool\Scripts\Script.cs,Evaluate,The following statement contains a magic number: for (int index = 0; index < elements.Count; index++)  			{  				ScriptElement se = elements[index];  				if (ifExec.Count > 0)  					if ((ifExec.First() == IfElseExec.SKIP_IF && !(se.opCode == OpCode.OP_ELSE || se.opCode == OpCode.OP_ENDIF)) ||  						(ifExec.First() == IfElseExec.SKIP_ELSE && !(se.opCode == OpCode.OP_ENDIF)))  						continue;    				if (se.isData)  				{  					stack.Push(se.data);  					continue;  				}    				switch (se.opCode)  				{  					case OpCode.OP_RESERVED:  						{  							return false;  						}  					case OpCode.OP_NOP:  						{  							// NOP' Dump stack for debug  							/*  							stack.ToList().ForEach(x => Console.WriteLine(HexString.FromByteArray(x)));  							Console.WriteLine("---------------------------");  							*/  							break;  						}  					case OpCode.OP_VER:  						{  							return false;  						}  					case OpCode.OP_IF:  					case OpCode.OP_NOTIF:  						{  							if (stack.Count < 1)  								return false;  							Boolean stackIsZero = new ScriptVarInt(stack.Pop()).value.IsZero;  							if ((se.opCode == OpCode.OP_IF && !stackIsZero) || (se.opCode == OpCode.OP_NOTIF && stackIsZero))  							{  								// Run to else or endif  								ifExec.Push(IfElseExec.RUN_IF);  							}  							else  							{  								// Skip to else or endif  								ifExec.Push(IfElseExec.SKIP_IF);  							}  							break;  						}  					case OpCode.OP_VERIF:  					case OpCode.OP_VERNOTIF:  						{  							return false;  						}  					case OpCode.OP_ELSE:  						{  							if (ifExec.Count == 0)  								// No preceding if statement!  								return false;  							if (ifExec.First() == IfElseExec.RUN_IF)  							{  								// If ran' skip else  								ifExec.Push(IfElseExec.SKIP_ELSE);  							}  							else if (ifExec.First() == IfElseExec.SKIP_IF)  							{  								// If did not run' run else  								ifExec.Push(IfElseExec.RUN_ELSE);  							}  							break;  						}  					case OpCode.OP_ENDIF:  						{  							if (ifExec.Count == 0)  								// No preceding if statement!  								return false;  							if (ifExec.First() == IfElseExec.RUN_IF ||  								ifExec.First() == IfElseExec.SKIP_IF)  							{  								ifExec.Pop();  							}  							else if (ifExec.First() == IfElseExec.RUN_ELSE ||  							   ifExec.First() == IfElseExec.SKIP_ELSE)  							{  								ifExec.Pop();  								ifExec.Pop();  							}  							break;  						}  					case OpCode.OP_VERIFY:  						{  							if (stack.Count < 1 || new ScriptVarInt(stack.First()).value.IsZero)  								return false;  							stack.Pop();  							break;  						}  					case OpCode.OP_RETURN:  						{  							return false;  						}  					case OpCode.OP_TOALTSTACK:  						{  							if (stack.Count < 1)  								return false;  							altstack.Push(stack.Pop());  							break;  						}  					case OpCode.OP_FROMALTSTACK:  						{  							if (altstack.Count < 1)  								return false;  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_2DROP:  						{  							if (stack.Count < 2)  								return false;  							stack.Pop();  							stack.Pop();  							break;  						}  					case OpCode.OP_2DUP:  						{  							if (stack.Count < 2)  								return false;  							stack.Push(stack.Skip(1).First());  							stack.Push(stack.Skip(1).First());  							break;  						}  					case OpCode.OP_3DUP:  						{  							if (stack.Count < 3)  								return false;  							stack.Push(stack.Skip(2).First());  							stack.Push(stack.Skip(2).First());  							stack.Push(stack.Skip(2).First());  							break;  						}  					case OpCode.OP_2OVER:  						{  							if (stack.Count < 4)  								return false;  							stack.Push(stack.Skip(3).First());  							stack.Push(stack.Skip(3).First());  							break;  						}  					case OpCode.OP_2ROT:  						{  							if (stack.Count < 6)  								return false;  							altstack.Push(stack.Skip(4).First());  							altstack.Push(stack.Skip(5).First());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_2SWAP:  						{  							if (stack.Count < 4)  								return false;  							altstack.Push(stack.Skip(2).First());  							altstack.Push(stack.Skip(3).First());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_IFDUP:  						{  							if (stack.Count < 1)  								return false;  							if (!new ScriptVarInt(stack.First()).value.IsZero)  								stack.Push(stack.First());  							break;  						}  					case OpCode.OP_DEPTH:  						{  							stack.Push(new ScriptVarInt((UInt64)stack.Count).ToBytes());  							break;  						}  					case OpCode.OP_DROP:  						{  							if (stack.Count < 1)  								return false;  							stack.Pop();  							break;  						}  					case OpCode.OP_DUP:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(stack.First());  							break;  						}  					case OpCode.OP_NIP:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_OVER:  						{  							if (stack.Count < 2)  								return false;  							stack.Push(stack.Skip(1).First());  							break;  						}  					case OpCode.OP_PICK:  						{  							if (stack.Count < 2)  								return false;  							int pick = new ScriptVarInt(stack.Pop()).intValue;  							if (pick < 0 || stack.Count <= pick)  								return false;  							stack.Push(stack.Skip(pick).First());  							break;  						}  					case OpCode.OP_ROLL:  						{  							if (stack.Count < 2)  								return false;  							int roll = new ScriptVarInt(stack.Pop()).intValue;  							if (roll < 0 || stack.Count <= roll)  								return false;  							altstack.Push(stack.Skip(roll).First());  							for (int i = 0; i < roll; i++)  								altstack.Push(stack.Pop());  							stack.Pop();  							for (int i = 0; i < roll + 1; i++)  								stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_ROT:  						{  							if (stack.Count < 3)  								return false;  							altstack.Push(stack.Skip(2).First());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_SWAP:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Skip(1).First());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_TUCK:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Push(altstack.Skip(1).First());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_CAT:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Skip(1).First().Concat(stack.First()).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_SUBSTR:  						{  							if (stack.Count < 3)  								return false;  							altstack.Push(stack.Skip(2).First()  								.Skip(new ScriptVarInt(stack.Skip(1).First()).intValue)  								.Take(new ScriptVarInt(stack.First()).intValue).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_LEFT:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Skip(1).First()  								.Take(new ScriptVarInt(stack.First()).intValue).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_RIGHT:  						{  							if (stack.Count < 2)  								return false;  							int count = new ScriptVarInt(stack.First()).intValue;  							altstack.Push(stack.Skip(1).First()  								.Skip(stack.Skip(1).First().Length - count).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_SIZE:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(new ScriptVarInt((UInt64)stack.First().Length).ToBytes());  							break;  						}  					case OpCode.OP_INVERT:  						{  							if (stack.Count < 1)  								return false;  							Byte[] data = stack.Pop();  							for (int i = 0; i < data.Length; i++)  								data[i] ^= 0xFF;  							stack.Push(data);  							break;  						}  					case OpCode.OP_AND:  					case OpCode.OP_OR:  					case OpCode.OP_XOR:  						{  							if (stack.Count < 2)  								return false;  							Byte[] data = stack.Pop();  							Byte[] data2 = stack.Pop();  							int length = new int[] { data.Length' data2.Length }.Max();  							data = data.Concat(new Byte[length - data.Length]).ToArray();  							data2 = data2.Concat(new Byte[length - data2.Length]).ToArray();  							switch (se.opCode)  							{  								case OpCode.OP_AND:  									{  										for (int i = 0; i < length; i++)  											data[i] &= data2[i];  										break;  									}  								case OpCode.OP_OR:  									{  										for (int i = 0; i < length; i++)  											data[i] |= data2[i];  										break;  									}  								case OpCode.OP_XOR:  									{  										for (int i = 0; i < length; i++)  											data[i] ^= data2[i];  										break;  									}  							}  							stack.Push(data);  							break;  						}  					case OpCode.OP_EQUAL:  					case OpCode.OP_EQUALVERIFY:  						{  							if (stack.Count < 2)  								return false;  							if (stack.Pop().SequenceEqual(stack.Pop()))  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });    							if (se.opCode == OpCode.OP_EQUALVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_RESERVED1:  					case OpCode.OP_RESERVED2:  						{  							return false;  						}  					case OpCode.OP_1ADD:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Add(new ScriptVarInt(stack.Pop())' 1)).ToBytes());  							break;  						}  					case OpCode.OP_1SUB:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Subtract(new ScriptVarInt(stack.Pop())' 1)).ToBytes());  							break;  						}  					case OpCode.OP_2MUL:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Multiply(new ScriptVarInt(stack.Pop())' 2)).ToBytes());  							break;  						}  					case OpCode.OP_2DIV:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Divide(new ScriptVarInt(stack.Pop())' 2)).ToBytes());  							break;  						}  					case OpCode.OP_NEGATE:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Negate(new ScriptVarInt(stack.Pop()))).ToBytes());  							break;  						}  					case OpCode.OP_ABS:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Abs(new ScriptVarInt(stack.Pop()))).ToBytes());  							break;  						}  					case OpCode.OP_NOT:  						{  							if (stack.Count < 1)  								return false;  							if (new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_0NOTEQUAL:  						{  							if (stack.Count < 1)  								return false;  							if (new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x00 });  							else  								stack.Push(new Byte[] { 0x01 });  							break;  						}  					case OpCode.OP_ADD:  					case OpCode.OP_SUB:  					case OpCode.OP_MUL:  					case OpCode.OP_DIV:  					case OpCode.OP_MOD:  					case OpCode.OP_LSHIFT:  					case OpCode.OP_RSHIFT:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							switch (se.opCode)  							{  								case OpCode.OP_ADD:  									a = (BigInteger)a + b;  									break;  								case OpCode.OP_SUB:  									a = (BigInteger)a - b;  									break;  								case OpCode.OP_MUL:  									a = (BigInteger)a * b;  									break;  								case OpCode.OP_DIV:  									a = (BigInteger)a / b;  									break;  								case OpCode.OP_MOD:  									a = (BigInteger)a % b;  									break;  								case OpCode.OP_LSHIFT:  									a = (BigInteger)a << b.intValue;  									break;  								case OpCode.OP_RSHIFT:  									a = (BigInteger)a >> b.intValue;  									break;  							}  							stack.Push(a.ToBytes());  							break;  						}  					case OpCode.OP_BOOLAND:  						{  							if (stack.Count < 2)  								return false;  							if (!new ScriptVarInt(stack.Pop()).value.IsZero && !new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_BOOLOR:  						{  							if (stack.Count < 2)  								return false;  							if (!new ScriptVarInt(stack.Pop()).value.IsZero || !new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_NUMEQUAL:  					case OpCode.OP_NUMEQUALVERIFY:  						{  							if (stack.Count < 2)  								return false;  							if (new ScriptVarInt(stack.Pop()).value == new ScriptVarInt(stack.Pop()).value)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							if (se.opCode == OpCode.OP_NUMEQUALVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_NUMNOTEQUAL:  						{  							if (stack.Count < 2)  								return false;  							if (new ScriptVarInt(stack.Pop()).value != new ScriptVarInt(stack.Pop()).value)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_LESSTHAN:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a < b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_GREATERTHAN:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a > b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_LESSTHANOREQUAL:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a <= b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_GREATERTHANOREQUAL:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a >= b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_MIN:  						{  							if (stack.Count < 2)  								return false;  							Byte[] b = stack.Pop();  							Byte[] a = stack.Pop();  							if (new ScriptVarInt(a).value < new ScriptVarInt(b).value)  								stack.Push(a);  							else  								stack.Push(b);  							break;  						}  					case OpCode.OP_MAX:  						{  							if (stack.Count < 2)  								return false;  							Byte[] b = stack.Pop();  							Byte[] a = stack.Pop();  							if (new ScriptVarInt(a).value > new ScriptVarInt(b).value)  								stack.Push(a);  							else  								stack.Push(b);  							break;  						}  					case OpCode.OP_WITHIN:  						{  							if (stack.Count < 3)  								return false;  							ScriptVarInt max = new ScriptVarInt(stack.Pop());  							ScriptVarInt min = new ScriptVarInt(stack.Pop());  							ScriptVarInt x = new ScriptVarInt(stack.Pop());  							if ((BigInteger)min <= x && (BigInteger)x <= max)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_RIPEMD160:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(ripemd160.ComputeHash(stack.Pop()));  							break;  						}  					case OpCode.OP_SHA1:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(sha1.ComputeHash(stack.Pop()));  							break;  						}  					case OpCode.OP_SHA256:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(sha256.ComputeHash(stack.Pop()));  							break;  						}  					case OpCode.OP_HASH160:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(ripemd160.ComputeHash(sha256.ComputeHash(stack.Pop())));  							break;  						}  					case OpCode.OP_HASH256:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(sha256.ComputeHash(sha256.ComputeHash(stack.Pop())));  							break;  						}  					case OpCode.OP_CODESEPARATOR:  						{  							lastCodeSeperator = index;  							break;  						}  					case OpCode.OP_CHECKSIG:  					case OpCode.OP_CHECKSIGVERIFY:  						{  							if (tx == null)  								throw new ArgumentNullException("Transaction is required if script contains OP_CHECKSIG[VERIFY]");  							if (stack.Count < 2)  								return false;    							PublicKey pubKey = new PublicKey(stack.Pop());  							Byte[] sig = stack.Pop();    							Script subScript = new Script(elements.Skip(lastCodeSeperator)  								.Where(x => x.opCode != OpCode.OP_CODESEPARATOR).ToArray());    							stack.Push(new ScriptVarInt(CheckSig(sig' pubKey' txInIndex' subScript' tx) ? 1 : 0).ToBytes());    							if (se.opCode == OpCode.OP_CHECKSIGVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_CHECKMULTISIG:  					case OpCode.OP_CHECKMULTISIGVERIFY:  						{  							if (tx == null)  								throw new ArgumentNullException("Transaction is required if script contains OP_CHECKMULTISIG[VERIFY]");  							if (stack.Count < 2)  								return false;    							PublicKey[] pubKeys = new PublicKey[new ScriptVarInt(stack.Pop()).intValue];    							if (stack.Count < pubKeys.Length + 1)  								return false;    							for (int i = 0; i < pubKeys.Length; i++)  							{  								pubKeys[i] = new PublicKey(stack.Pop());  							}    							Byte[][] sigs = new Byte[new ScriptVarInt(stack.Pop()).intValue][];    							if (stack.Count < sigs.Length)  								return false;    							for (int i = 0; i < sigs.Length; i++)  							{  								sigs[i] = stack.Pop();  							}    							// Remove extra unused value from stack  							stack.Pop();    							Script subScript = new Script(elements.Skip(lastCodeSeperator)  								.Where(x => x.opCode != OpCode.OP_CODESEPARATOR).ToArray());    							int validSigs = 0;  							foreach (Byte[] sig in sigs)  							{  								foreach (PublicKey pubKey in pubKeys)  								{  									if (CheckSig(sig' pubKey' txInIndex' subScript' tx))  									{  										pubKeys = pubKeys.Where(x => x != pubKey).ToArray();  										validSigs++;  										break;  									}  								}  							}    							stack.Push(new ScriptVarInt((validSigs >= sigs.Length) ? 1 : 0).ToBytes());    							if (se.opCode == OpCode.OP_CHECKMULTISIGVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_NOP1:  					case OpCode.OP_NOP2:  					case OpCode.OP_NOP3:  					case OpCode.OP_NOP4:  					case OpCode.OP_NOP5:  					case OpCode.OP_NOP6:  					case OpCode.OP_NOP7:  					case OpCode.OP_NOP8:  					case OpCode.OP_NOP9:  					case OpCode.OP_NOP10:  						{  							break;  						}  					case OpCode.OP_SMALLINTEGER:  					case OpCode.OP_PUBKEYS:  					case OpCode.OP_PUBKEYHASH:  					case OpCode.OP_PUBKEY:  					case OpCode.OP_INVALIDOPCODE:  					default:  						{  							return false;  						}    				}  			}
Magic Number,Bitcoin_Tool.Scripts,Script,C:\repos\mb300sd_Bitcoin-Tool\Bitcoin Tool\Scripts\Script.cs,Evaluate,The following statement contains a magic number: for (int index = 0; index < elements.Count; index++)  			{  				ScriptElement se = elements[index];  				if (ifExec.Count > 0)  					if ((ifExec.First() == IfElseExec.SKIP_IF && !(se.opCode == OpCode.OP_ELSE || se.opCode == OpCode.OP_ENDIF)) ||  						(ifExec.First() == IfElseExec.SKIP_ELSE && !(se.opCode == OpCode.OP_ENDIF)))  						continue;    				if (se.isData)  				{  					stack.Push(se.data);  					continue;  				}    				switch (se.opCode)  				{  					case OpCode.OP_RESERVED:  						{  							return false;  						}  					case OpCode.OP_NOP:  						{  							// NOP' Dump stack for debug  							/*  							stack.ToList().ForEach(x => Console.WriteLine(HexString.FromByteArray(x)));  							Console.WriteLine("---------------------------");  							*/  							break;  						}  					case OpCode.OP_VER:  						{  							return false;  						}  					case OpCode.OP_IF:  					case OpCode.OP_NOTIF:  						{  							if (stack.Count < 1)  								return false;  							Boolean stackIsZero = new ScriptVarInt(stack.Pop()).value.IsZero;  							if ((se.opCode == OpCode.OP_IF && !stackIsZero) || (se.opCode == OpCode.OP_NOTIF && stackIsZero))  							{  								// Run to else or endif  								ifExec.Push(IfElseExec.RUN_IF);  							}  							else  							{  								// Skip to else or endif  								ifExec.Push(IfElseExec.SKIP_IF);  							}  							break;  						}  					case OpCode.OP_VERIF:  					case OpCode.OP_VERNOTIF:  						{  							return false;  						}  					case OpCode.OP_ELSE:  						{  							if (ifExec.Count == 0)  								// No preceding if statement!  								return false;  							if (ifExec.First() == IfElseExec.RUN_IF)  							{  								// If ran' skip else  								ifExec.Push(IfElseExec.SKIP_ELSE);  							}  							else if (ifExec.First() == IfElseExec.SKIP_IF)  							{  								// If did not run' run else  								ifExec.Push(IfElseExec.RUN_ELSE);  							}  							break;  						}  					case OpCode.OP_ENDIF:  						{  							if (ifExec.Count == 0)  								// No preceding if statement!  								return false;  							if (ifExec.First() == IfElseExec.RUN_IF ||  								ifExec.First() == IfElseExec.SKIP_IF)  							{  								ifExec.Pop();  							}  							else if (ifExec.First() == IfElseExec.RUN_ELSE ||  							   ifExec.First() == IfElseExec.SKIP_ELSE)  							{  								ifExec.Pop();  								ifExec.Pop();  							}  							break;  						}  					case OpCode.OP_VERIFY:  						{  							if (stack.Count < 1 || new ScriptVarInt(stack.First()).value.IsZero)  								return false;  							stack.Pop();  							break;  						}  					case OpCode.OP_RETURN:  						{  							return false;  						}  					case OpCode.OP_TOALTSTACK:  						{  							if (stack.Count < 1)  								return false;  							altstack.Push(stack.Pop());  							break;  						}  					case OpCode.OP_FROMALTSTACK:  						{  							if (altstack.Count < 1)  								return false;  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_2DROP:  						{  							if (stack.Count < 2)  								return false;  							stack.Pop();  							stack.Pop();  							break;  						}  					case OpCode.OP_2DUP:  						{  							if (stack.Count < 2)  								return false;  							stack.Push(stack.Skip(1).First());  							stack.Push(stack.Skip(1).First());  							break;  						}  					case OpCode.OP_3DUP:  						{  							if (stack.Count < 3)  								return false;  							stack.Push(stack.Skip(2).First());  							stack.Push(stack.Skip(2).First());  							stack.Push(stack.Skip(2).First());  							break;  						}  					case OpCode.OP_2OVER:  						{  							if (stack.Count < 4)  								return false;  							stack.Push(stack.Skip(3).First());  							stack.Push(stack.Skip(3).First());  							break;  						}  					case OpCode.OP_2ROT:  						{  							if (stack.Count < 6)  								return false;  							altstack.Push(stack.Skip(4).First());  							altstack.Push(stack.Skip(5).First());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_2SWAP:  						{  							if (stack.Count < 4)  								return false;  							altstack.Push(stack.Skip(2).First());  							altstack.Push(stack.Skip(3).First());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_IFDUP:  						{  							if (stack.Count < 1)  								return false;  							if (!new ScriptVarInt(stack.First()).value.IsZero)  								stack.Push(stack.First());  							break;  						}  					case OpCode.OP_DEPTH:  						{  							stack.Push(new ScriptVarInt((UInt64)stack.Count).ToBytes());  							break;  						}  					case OpCode.OP_DROP:  						{  							if (stack.Count < 1)  								return false;  							stack.Pop();  							break;  						}  					case OpCode.OP_DUP:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(stack.First());  							break;  						}  					case OpCode.OP_NIP:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_OVER:  						{  							if (stack.Count < 2)  								return false;  							stack.Push(stack.Skip(1).First());  							break;  						}  					case OpCode.OP_PICK:  						{  							if (stack.Count < 2)  								return false;  							int pick = new ScriptVarInt(stack.Pop()).intValue;  							if (pick < 0 || stack.Count <= pick)  								return false;  							stack.Push(stack.Skip(pick).First());  							break;  						}  					case OpCode.OP_ROLL:  						{  							if (stack.Count < 2)  								return false;  							int roll = new ScriptVarInt(stack.Pop()).intValue;  							if (roll < 0 || stack.Count <= roll)  								return false;  							altstack.Push(stack.Skip(roll).First());  							for (int i = 0; i < roll; i++)  								altstack.Push(stack.Pop());  							stack.Pop();  							for (int i = 0; i < roll + 1; i++)  								stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_ROT:  						{  							if (stack.Count < 3)  								return false;  							altstack.Push(stack.Skip(2).First());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_SWAP:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Skip(1).First());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_TUCK:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Push(altstack.Skip(1).First());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_CAT:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Skip(1).First().Concat(stack.First()).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_SUBSTR:  						{  							if (stack.Count < 3)  								return false;  							altstack.Push(stack.Skip(2).First()  								.Skip(new ScriptVarInt(stack.Skip(1).First()).intValue)  								.Take(new ScriptVarInt(stack.First()).intValue).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_LEFT:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Skip(1).First()  								.Take(new ScriptVarInt(stack.First()).intValue).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_RIGHT:  						{  							if (stack.Count < 2)  								return false;  							int count = new ScriptVarInt(stack.First()).intValue;  							altstack.Push(stack.Skip(1).First()  								.Skip(stack.Skip(1).First().Length - count).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_SIZE:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(new ScriptVarInt((UInt64)stack.First().Length).ToBytes());  							break;  						}  					case OpCode.OP_INVERT:  						{  							if (stack.Count < 1)  								return false;  							Byte[] data = stack.Pop();  							for (int i = 0; i < data.Length; i++)  								data[i] ^= 0xFF;  							stack.Push(data);  							break;  						}  					case OpCode.OP_AND:  					case OpCode.OP_OR:  					case OpCode.OP_XOR:  						{  							if (stack.Count < 2)  								return false;  							Byte[] data = stack.Pop();  							Byte[] data2 = stack.Pop();  							int length = new int[] { data.Length' data2.Length }.Max();  							data = data.Concat(new Byte[length - data.Length]).ToArray();  							data2 = data2.Concat(new Byte[length - data2.Length]).ToArray();  							switch (se.opCode)  							{  								case OpCode.OP_AND:  									{  										for (int i = 0; i < length; i++)  											data[i] &= data2[i];  										break;  									}  								case OpCode.OP_OR:  									{  										for (int i = 0; i < length; i++)  											data[i] |= data2[i];  										break;  									}  								case OpCode.OP_XOR:  									{  										for (int i = 0; i < length; i++)  											data[i] ^= data2[i];  										break;  									}  							}  							stack.Push(data);  							break;  						}  					case OpCode.OP_EQUAL:  					case OpCode.OP_EQUALVERIFY:  						{  							if (stack.Count < 2)  								return false;  							if (stack.Pop().SequenceEqual(stack.Pop()))  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });    							if (se.opCode == OpCode.OP_EQUALVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_RESERVED1:  					case OpCode.OP_RESERVED2:  						{  							return false;  						}  					case OpCode.OP_1ADD:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Add(new ScriptVarInt(stack.Pop())' 1)).ToBytes());  							break;  						}  					case OpCode.OP_1SUB:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Subtract(new ScriptVarInt(stack.Pop())' 1)).ToBytes());  							break;  						}  					case OpCode.OP_2MUL:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Multiply(new ScriptVarInt(stack.Pop())' 2)).ToBytes());  							break;  						}  					case OpCode.OP_2DIV:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Divide(new ScriptVarInt(stack.Pop())' 2)).ToBytes());  							break;  						}  					case OpCode.OP_NEGATE:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Negate(new ScriptVarInt(stack.Pop()))).ToBytes());  							break;  						}  					case OpCode.OP_ABS:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Abs(new ScriptVarInt(stack.Pop()))).ToBytes());  							break;  						}  					case OpCode.OP_NOT:  						{  							if (stack.Count < 1)  								return false;  							if (new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_0NOTEQUAL:  						{  							if (stack.Count < 1)  								return false;  							if (new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x00 });  							else  								stack.Push(new Byte[] { 0x01 });  							break;  						}  					case OpCode.OP_ADD:  					case OpCode.OP_SUB:  					case OpCode.OP_MUL:  					case OpCode.OP_DIV:  					case OpCode.OP_MOD:  					case OpCode.OP_LSHIFT:  					case OpCode.OP_RSHIFT:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							switch (se.opCode)  							{  								case OpCode.OP_ADD:  									a = (BigInteger)a + b;  									break;  								case OpCode.OP_SUB:  									a = (BigInteger)a - b;  									break;  								case OpCode.OP_MUL:  									a = (BigInteger)a * b;  									break;  								case OpCode.OP_DIV:  									a = (BigInteger)a / b;  									break;  								case OpCode.OP_MOD:  									a = (BigInteger)a % b;  									break;  								case OpCode.OP_LSHIFT:  									a = (BigInteger)a << b.intValue;  									break;  								case OpCode.OP_RSHIFT:  									a = (BigInteger)a >> b.intValue;  									break;  							}  							stack.Push(a.ToBytes());  							break;  						}  					case OpCode.OP_BOOLAND:  						{  							if (stack.Count < 2)  								return false;  							if (!new ScriptVarInt(stack.Pop()).value.IsZero && !new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_BOOLOR:  						{  							if (stack.Count < 2)  								return false;  							if (!new ScriptVarInt(stack.Pop()).value.IsZero || !new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_NUMEQUAL:  					case OpCode.OP_NUMEQUALVERIFY:  						{  							if (stack.Count < 2)  								return false;  							if (new ScriptVarInt(stack.Pop()).value == new ScriptVarInt(stack.Pop()).value)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							if (se.opCode == OpCode.OP_NUMEQUALVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_NUMNOTEQUAL:  						{  							if (stack.Count < 2)  								return false;  							if (new ScriptVarInt(stack.Pop()).value != new ScriptVarInt(stack.Pop()).value)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_LESSTHAN:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a < b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_GREATERTHAN:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a > b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_LESSTHANOREQUAL:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a <= b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_GREATERTHANOREQUAL:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a >= b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_MIN:  						{  							if (stack.Count < 2)  								return false;  							Byte[] b = stack.Pop();  							Byte[] a = stack.Pop();  							if (new ScriptVarInt(a).value < new ScriptVarInt(b).value)  								stack.Push(a);  							else  								stack.Push(b);  							break;  						}  					case OpCode.OP_MAX:  						{  							if (stack.Count < 2)  								return false;  							Byte[] b = stack.Pop();  							Byte[] a = stack.Pop();  							if (new ScriptVarInt(a).value > new ScriptVarInt(b).value)  								stack.Push(a);  							else  								stack.Push(b);  							break;  						}  					case OpCode.OP_WITHIN:  						{  							if (stack.Count < 3)  								return false;  							ScriptVarInt max = new ScriptVarInt(stack.Pop());  							ScriptVarInt min = new ScriptVarInt(stack.Pop());  							ScriptVarInt x = new ScriptVarInt(stack.Pop());  							if ((BigInteger)min <= x && (BigInteger)x <= max)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_RIPEMD160:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(ripemd160.ComputeHash(stack.Pop()));  							break;  						}  					case OpCode.OP_SHA1:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(sha1.ComputeHash(stack.Pop()));  							break;  						}  					case OpCode.OP_SHA256:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(sha256.ComputeHash(stack.Pop()));  							break;  						}  					case OpCode.OP_HASH160:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(ripemd160.ComputeHash(sha256.ComputeHash(stack.Pop())));  							break;  						}  					case OpCode.OP_HASH256:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(sha256.ComputeHash(sha256.ComputeHash(stack.Pop())));  							break;  						}  					case OpCode.OP_CODESEPARATOR:  						{  							lastCodeSeperator = index;  							break;  						}  					case OpCode.OP_CHECKSIG:  					case OpCode.OP_CHECKSIGVERIFY:  						{  							if (tx == null)  								throw new ArgumentNullException("Transaction is required if script contains OP_CHECKSIG[VERIFY]");  							if (stack.Count < 2)  								return false;    							PublicKey pubKey = new PublicKey(stack.Pop());  							Byte[] sig = stack.Pop();    							Script subScript = new Script(elements.Skip(lastCodeSeperator)  								.Where(x => x.opCode != OpCode.OP_CODESEPARATOR).ToArray());    							stack.Push(new ScriptVarInt(CheckSig(sig' pubKey' txInIndex' subScript' tx) ? 1 : 0).ToBytes());    							if (se.opCode == OpCode.OP_CHECKSIGVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_CHECKMULTISIG:  					case OpCode.OP_CHECKMULTISIGVERIFY:  						{  							if (tx == null)  								throw new ArgumentNullException("Transaction is required if script contains OP_CHECKMULTISIG[VERIFY]");  							if (stack.Count < 2)  								return false;    							PublicKey[] pubKeys = new PublicKey[new ScriptVarInt(stack.Pop()).intValue];    							if (stack.Count < pubKeys.Length + 1)  								return false;    							for (int i = 0; i < pubKeys.Length; i++)  							{  								pubKeys[i] = new PublicKey(stack.Pop());  							}    							Byte[][] sigs = new Byte[new ScriptVarInt(stack.Pop()).intValue][];    							if (stack.Count < sigs.Length)  								return false;    							for (int i = 0; i < sigs.Length; i++)  							{  								sigs[i] = stack.Pop();  							}    							// Remove extra unused value from stack  							stack.Pop();    							Script subScript = new Script(elements.Skip(lastCodeSeperator)  								.Where(x => x.opCode != OpCode.OP_CODESEPARATOR).ToArray());    							int validSigs = 0;  							foreach (Byte[] sig in sigs)  							{  								foreach (PublicKey pubKey in pubKeys)  								{  									if (CheckSig(sig' pubKey' txInIndex' subScript' tx))  									{  										pubKeys = pubKeys.Where(x => x != pubKey).ToArray();  										validSigs++;  										break;  									}  								}  							}    							stack.Push(new ScriptVarInt((validSigs >= sigs.Length) ? 1 : 0).ToBytes());    							if (se.opCode == OpCode.OP_CHECKMULTISIGVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_NOP1:  					case OpCode.OP_NOP2:  					case OpCode.OP_NOP3:  					case OpCode.OP_NOP4:  					case OpCode.OP_NOP5:  					case OpCode.OP_NOP6:  					case OpCode.OP_NOP7:  					case OpCode.OP_NOP8:  					case OpCode.OP_NOP9:  					case OpCode.OP_NOP10:  						{  							break;  						}  					case OpCode.OP_SMALLINTEGER:  					case OpCode.OP_PUBKEYS:  					case OpCode.OP_PUBKEYHASH:  					case OpCode.OP_PUBKEY:  					case OpCode.OP_INVALIDOPCODE:  					default:  						{  							return false;  						}    				}  			}
Magic Number,Bitcoin_Tool.Scripts,Script,C:\repos\mb300sd_Bitcoin-Tool\Bitcoin Tool\Scripts\Script.cs,Evaluate,The following statement contains a magic number: for (int index = 0; index < elements.Count; index++)  			{  				ScriptElement se = elements[index];  				if (ifExec.Count > 0)  					if ((ifExec.First() == IfElseExec.SKIP_IF && !(se.opCode == OpCode.OP_ELSE || se.opCode == OpCode.OP_ENDIF)) ||  						(ifExec.First() == IfElseExec.SKIP_ELSE && !(se.opCode == OpCode.OP_ENDIF)))  						continue;    				if (se.isData)  				{  					stack.Push(se.data);  					continue;  				}    				switch (se.opCode)  				{  					case OpCode.OP_RESERVED:  						{  							return false;  						}  					case OpCode.OP_NOP:  						{  							// NOP' Dump stack for debug  							/*  							stack.ToList().ForEach(x => Console.WriteLine(HexString.FromByteArray(x)));  							Console.WriteLine("---------------------------");  							*/  							break;  						}  					case OpCode.OP_VER:  						{  							return false;  						}  					case OpCode.OP_IF:  					case OpCode.OP_NOTIF:  						{  							if (stack.Count < 1)  								return false;  							Boolean stackIsZero = new ScriptVarInt(stack.Pop()).value.IsZero;  							if ((se.opCode == OpCode.OP_IF && !stackIsZero) || (se.opCode == OpCode.OP_NOTIF && stackIsZero))  							{  								// Run to else or endif  								ifExec.Push(IfElseExec.RUN_IF);  							}  							else  							{  								// Skip to else or endif  								ifExec.Push(IfElseExec.SKIP_IF);  							}  							break;  						}  					case OpCode.OP_VERIF:  					case OpCode.OP_VERNOTIF:  						{  							return false;  						}  					case OpCode.OP_ELSE:  						{  							if (ifExec.Count == 0)  								// No preceding if statement!  								return false;  							if (ifExec.First() == IfElseExec.RUN_IF)  							{  								// If ran' skip else  								ifExec.Push(IfElseExec.SKIP_ELSE);  							}  							else if (ifExec.First() == IfElseExec.SKIP_IF)  							{  								// If did not run' run else  								ifExec.Push(IfElseExec.RUN_ELSE);  							}  							break;  						}  					case OpCode.OP_ENDIF:  						{  							if (ifExec.Count == 0)  								// No preceding if statement!  								return false;  							if (ifExec.First() == IfElseExec.RUN_IF ||  								ifExec.First() == IfElseExec.SKIP_IF)  							{  								ifExec.Pop();  							}  							else if (ifExec.First() == IfElseExec.RUN_ELSE ||  							   ifExec.First() == IfElseExec.SKIP_ELSE)  							{  								ifExec.Pop();  								ifExec.Pop();  							}  							break;  						}  					case OpCode.OP_VERIFY:  						{  							if (stack.Count < 1 || new ScriptVarInt(stack.First()).value.IsZero)  								return false;  							stack.Pop();  							break;  						}  					case OpCode.OP_RETURN:  						{  							return false;  						}  					case OpCode.OP_TOALTSTACK:  						{  							if (stack.Count < 1)  								return false;  							altstack.Push(stack.Pop());  							break;  						}  					case OpCode.OP_FROMALTSTACK:  						{  							if (altstack.Count < 1)  								return false;  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_2DROP:  						{  							if (stack.Count < 2)  								return false;  							stack.Pop();  							stack.Pop();  							break;  						}  					case OpCode.OP_2DUP:  						{  							if (stack.Count < 2)  								return false;  							stack.Push(stack.Skip(1).First());  							stack.Push(stack.Skip(1).First());  							break;  						}  					case OpCode.OP_3DUP:  						{  							if (stack.Count < 3)  								return false;  							stack.Push(stack.Skip(2).First());  							stack.Push(stack.Skip(2).First());  							stack.Push(stack.Skip(2).First());  							break;  						}  					case OpCode.OP_2OVER:  						{  							if (stack.Count < 4)  								return false;  							stack.Push(stack.Skip(3).First());  							stack.Push(stack.Skip(3).First());  							break;  						}  					case OpCode.OP_2ROT:  						{  							if (stack.Count < 6)  								return false;  							altstack.Push(stack.Skip(4).First());  							altstack.Push(stack.Skip(5).First());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_2SWAP:  						{  							if (stack.Count < 4)  								return false;  							altstack.Push(stack.Skip(2).First());  							altstack.Push(stack.Skip(3).First());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_IFDUP:  						{  							if (stack.Count < 1)  								return false;  							if (!new ScriptVarInt(stack.First()).value.IsZero)  								stack.Push(stack.First());  							break;  						}  					case OpCode.OP_DEPTH:  						{  							stack.Push(new ScriptVarInt((UInt64)stack.Count).ToBytes());  							break;  						}  					case OpCode.OP_DROP:  						{  							if (stack.Count < 1)  								return false;  							stack.Pop();  							break;  						}  					case OpCode.OP_DUP:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(stack.First());  							break;  						}  					case OpCode.OP_NIP:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_OVER:  						{  							if (stack.Count < 2)  								return false;  							stack.Push(stack.Skip(1).First());  							break;  						}  					case OpCode.OP_PICK:  						{  							if (stack.Count < 2)  								return false;  							int pick = new ScriptVarInt(stack.Pop()).intValue;  							if (pick < 0 || stack.Count <= pick)  								return false;  							stack.Push(stack.Skip(pick).First());  							break;  						}  					case OpCode.OP_ROLL:  						{  							if (stack.Count < 2)  								return false;  							int roll = new ScriptVarInt(stack.Pop()).intValue;  							if (roll < 0 || stack.Count <= roll)  								return false;  							altstack.Push(stack.Skip(roll).First());  							for (int i = 0; i < roll; i++)  								altstack.Push(stack.Pop());  							stack.Pop();  							for (int i = 0; i < roll + 1; i++)  								stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_ROT:  						{  							if (stack.Count < 3)  								return false;  							altstack.Push(stack.Skip(2).First());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_SWAP:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Skip(1).First());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_TUCK:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Push(altstack.Skip(1).First());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_CAT:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Skip(1).First().Concat(stack.First()).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_SUBSTR:  						{  							if (stack.Count < 3)  								return false;  							altstack.Push(stack.Skip(2).First()  								.Skip(new ScriptVarInt(stack.Skip(1).First()).intValue)  								.Take(new ScriptVarInt(stack.First()).intValue).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_LEFT:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Skip(1).First()  								.Take(new ScriptVarInt(stack.First()).intValue).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_RIGHT:  						{  							if (stack.Count < 2)  								return false;  							int count = new ScriptVarInt(stack.First()).intValue;  							altstack.Push(stack.Skip(1).First()  								.Skip(stack.Skip(1).First().Length - count).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_SIZE:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(new ScriptVarInt((UInt64)stack.First().Length).ToBytes());  							break;  						}  					case OpCode.OP_INVERT:  						{  							if (stack.Count < 1)  								return false;  							Byte[] data = stack.Pop();  							for (int i = 0; i < data.Length; i++)  								data[i] ^= 0xFF;  							stack.Push(data);  							break;  						}  					case OpCode.OP_AND:  					case OpCode.OP_OR:  					case OpCode.OP_XOR:  						{  							if (stack.Count < 2)  								return false;  							Byte[] data = stack.Pop();  							Byte[] data2 = stack.Pop();  							int length = new int[] { data.Length' data2.Length }.Max();  							data = data.Concat(new Byte[length - data.Length]).ToArray();  							data2 = data2.Concat(new Byte[length - data2.Length]).ToArray();  							switch (se.opCode)  							{  								case OpCode.OP_AND:  									{  										for (int i = 0; i < length; i++)  											data[i] &= data2[i];  										break;  									}  								case OpCode.OP_OR:  									{  										for (int i = 0; i < length; i++)  											data[i] |= data2[i];  										break;  									}  								case OpCode.OP_XOR:  									{  										for (int i = 0; i < length; i++)  											data[i] ^= data2[i];  										break;  									}  							}  							stack.Push(data);  							break;  						}  					case OpCode.OP_EQUAL:  					case OpCode.OP_EQUALVERIFY:  						{  							if (stack.Count < 2)  								return false;  							if (stack.Pop().SequenceEqual(stack.Pop()))  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });    							if (se.opCode == OpCode.OP_EQUALVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_RESERVED1:  					case OpCode.OP_RESERVED2:  						{  							return false;  						}  					case OpCode.OP_1ADD:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Add(new ScriptVarInt(stack.Pop())' 1)).ToBytes());  							break;  						}  					case OpCode.OP_1SUB:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Subtract(new ScriptVarInt(stack.Pop())' 1)).ToBytes());  							break;  						}  					case OpCode.OP_2MUL:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Multiply(new ScriptVarInt(stack.Pop())' 2)).ToBytes());  							break;  						}  					case OpCode.OP_2DIV:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Divide(new ScriptVarInt(stack.Pop())' 2)).ToBytes());  							break;  						}  					case OpCode.OP_NEGATE:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Negate(new ScriptVarInt(stack.Pop()))).ToBytes());  							break;  						}  					case OpCode.OP_ABS:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Abs(new ScriptVarInt(stack.Pop()))).ToBytes());  							break;  						}  					case OpCode.OP_NOT:  						{  							if (stack.Count < 1)  								return false;  							if (new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_0NOTEQUAL:  						{  							if (stack.Count < 1)  								return false;  							if (new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x00 });  							else  								stack.Push(new Byte[] { 0x01 });  							break;  						}  					case OpCode.OP_ADD:  					case OpCode.OP_SUB:  					case OpCode.OP_MUL:  					case OpCode.OP_DIV:  					case OpCode.OP_MOD:  					case OpCode.OP_LSHIFT:  					case OpCode.OP_RSHIFT:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							switch (se.opCode)  							{  								case OpCode.OP_ADD:  									a = (BigInteger)a + b;  									break;  								case OpCode.OP_SUB:  									a = (BigInteger)a - b;  									break;  								case OpCode.OP_MUL:  									a = (BigInteger)a * b;  									break;  								case OpCode.OP_DIV:  									a = (BigInteger)a / b;  									break;  								case OpCode.OP_MOD:  									a = (BigInteger)a % b;  									break;  								case OpCode.OP_LSHIFT:  									a = (BigInteger)a << b.intValue;  									break;  								case OpCode.OP_RSHIFT:  									a = (BigInteger)a >> b.intValue;  									break;  							}  							stack.Push(a.ToBytes());  							break;  						}  					case OpCode.OP_BOOLAND:  						{  							if (stack.Count < 2)  								return false;  							if (!new ScriptVarInt(stack.Pop()).value.IsZero && !new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_BOOLOR:  						{  							if (stack.Count < 2)  								return false;  							if (!new ScriptVarInt(stack.Pop()).value.IsZero || !new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_NUMEQUAL:  					case OpCode.OP_NUMEQUALVERIFY:  						{  							if (stack.Count < 2)  								return false;  							if (new ScriptVarInt(stack.Pop()).value == new ScriptVarInt(stack.Pop()).value)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							if (se.opCode == OpCode.OP_NUMEQUALVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_NUMNOTEQUAL:  						{  							if (stack.Count < 2)  								return false;  							if (new ScriptVarInt(stack.Pop()).value != new ScriptVarInt(stack.Pop()).value)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_LESSTHAN:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a < b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_GREATERTHAN:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a > b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_LESSTHANOREQUAL:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a <= b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_GREATERTHANOREQUAL:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a >= b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_MIN:  						{  							if (stack.Count < 2)  								return false;  							Byte[] b = stack.Pop();  							Byte[] a = stack.Pop();  							if (new ScriptVarInt(a).value < new ScriptVarInt(b).value)  								stack.Push(a);  							else  								stack.Push(b);  							break;  						}  					case OpCode.OP_MAX:  						{  							if (stack.Count < 2)  								return false;  							Byte[] b = stack.Pop();  							Byte[] a = stack.Pop();  							if (new ScriptVarInt(a).value > new ScriptVarInt(b).value)  								stack.Push(a);  							else  								stack.Push(b);  							break;  						}  					case OpCode.OP_WITHIN:  						{  							if (stack.Count < 3)  								return false;  							ScriptVarInt max = new ScriptVarInt(stack.Pop());  							ScriptVarInt min = new ScriptVarInt(stack.Pop());  							ScriptVarInt x = new ScriptVarInt(stack.Pop());  							if ((BigInteger)min <= x && (BigInteger)x <= max)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_RIPEMD160:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(ripemd160.ComputeHash(stack.Pop()));  							break;  						}  					case OpCode.OP_SHA1:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(sha1.ComputeHash(stack.Pop()));  							break;  						}  					case OpCode.OP_SHA256:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(sha256.ComputeHash(stack.Pop()));  							break;  						}  					case OpCode.OP_HASH160:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(ripemd160.ComputeHash(sha256.ComputeHash(stack.Pop())));  							break;  						}  					case OpCode.OP_HASH256:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(sha256.ComputeHash(sha256.ComputeHash(stack.Pop())));  							break;  						}  					case OpCode.OP_CODESEPARATOR:  						{  							lastCodeSeperator = index;  							break;  						}  					case OpCode.OP_CHECKSIG:  					case OpCode.OP_CHECKSIGVERIFY:  						{  							if (tx == null)  								throw new ArgumentNullException("Transaction is required if script contains OP_CHECKSIG[VERIFY]");  							if (stack.Count < 2)  								return false;    							PublicKey pubKey = new PublicKey(stack.Pop());  							Byte[] sig = stack.Pop();    							Script subScript = new Script(elements.Skip(lastCodeSeperator)  								.Where(x => x.opCode != OpCode.OP_CODESEPARATOR).ToArray());    							stack.Push(new ScriptVarInt(CheckSig(sig' pubKey' txInIndex' subScript' tx) ? 1 : 0).ToBytes());    							if (se.opCode == OpCode.OP_CHECKSIGVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_CHECKMULTISIG:  					case OpCode.OP_CHECKMULTISIGVERIFY:  						{  							if (tx == null)  								throw new ArgumentNullException("Transaction is required if script contains OP_CHECKMULTISIG[VERIFY]");  							if (stack.Count < 2)  								return false;    							PublicKey[] pubKeys = new PublicKey[new ScriptVarInt(stack.Pop()).intValue];    							if (stack.Count < pubKeys.Length + 1)  								return false;    							for (int i = 0; i < pubKeys.Length; i++)  							{  								pubKeys[i] = new PublicKey(stack.Pop());  							}    							Byte[][] sigs = new Byte[new ScriptVarInt(stack.Pop()).intValue][];    							if (stack.Count < sigs.Length)  								return false;    							for (int i = 0; i < sigs.Length; i++)  							{  								sigs[i] = stack.Pop();  							}    							// Remove extra unused value from stack  							stack.Pop();    							Script subScript = new Script(elements.Skip(lastCodeSeperator)  								.Where(x => x.opCode != OpCode.OP_CODESEPARATOR).ToArray());    							int validSigs = 0;  							foreach (Byte[] sig in sigs)  							{  								foreach (PublicKey pubKey in pubKeys)  								{  									if (CheckSig(sig' pubKey' txInIndex' subScript' tx))  									{  										pubKeys = pubKeys.Where(x => x != pubKey).ToArray();  										validSigs++;  										break;  									}  								}  							}    							stack.Push(new ScriptVarInt((validSigs >= sigs.Length) ? 1 : 0).ToBytes());    							if (se.opCode == OpCode.OP_CHECKMULTISIGVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_NOP1:  					case OpCode.OP_NOP2:  					case OpCode.OP_NOP3:  					case OpCode.OP_NOP4:  					case OpCode.OP_NOP5:  					case OpCode.OP_NOP6:  					case OpCode.OP_NOP7:  					case OpCode.OP_NOP8:  					case OpCode.OP_NOP9:  					case OpCode.OP_NOP10:  						{  							break;  						}  					case OpCode.OP_SMALLINTEGER:  					case OpCode.OP_PUBKEYS:  					case OpCode.OP_PUBKEYHASH:  					case OpCode.OP_PUBKEY:  					case OpCode.OP_INVALIDOPCODE:  					default:  						{  							return false;  						}    				}  			}
Magic Number,Bitcoin_Tool.Scripts,Script,C:\repos\mb300sd_Bitcoin-Tool\Bitcoin Tool\Scripts\Script.cs,Evaluate,The following statement contains a magic number: for (int index = 0; index < elements.Count; index++)  			{  				ScriptElement se = elements[index];  				if (ifExec.Count > 0)  					if ((ifExec.First() == IfElseExec.SKIP_IF && !(se.opCode == OpCode.OP_ELSE || se.opCode == OpCode.OP_ENDIF)) ||  						(ifExec.First() == IfElseExec.SKIP_ELSE && !(se.opCode == OpCode.OP_ENDIF)))  						continue;    				if (se.isData)  				{  					stack.Push(se.data);  					continue;  				}    				switch (se.opCode)  				{  					case OpCode.OP_RESERVED:  						{  							return false;  						}  					case OpCode.OP_NOP:  						{  							// NOP' Dump stack for debug  							/*  							stack.ToList().ForEach(x => Console.WriteLine(HexString.FromByteArray(x)));  							Console.WriteLine("---------------------------");  							*/  							break;  						}  					case OpCode.OP_VER:  						{  							return false;  						}  					case OpCode.OP_IF:  					case OpCode.OP_NOTIF:  						{  							if (stack.Count < 1)  								return false;  							Boolean stackIsZero = new ScriptVarInt(stack.Pop()).value.IsZero;  							if ((se.opCode == OpCode.OP_IF && !stackIsZero) || (se.opCode == OpCode.OP_NOTIF && stackIsZero))  							{  								// Run to else or endif  								ifExec.Push(IfElseExec.RUN_IF);  							}  							else  							{  								// Skip to else or endif  								ifExec.Push(IfElseExec.SKIP_IF);  							}  							break;  						}  					case OpCode.OP_VERIF:  					case OpCode.OP_VERNOTIF:  						{  							return false;  						}  					case OpCode.OP_ELSE:  						{  							if (ifExec.Count == 0)  								// No preceding if statement!  								return false;  							if (ifExec.First() == IfElseExec.RUN_IF)  							{  								// If ran' skip else  								ifExec.Push(IfElseExec.SKIP_ELSE);  							}  							else if (ifExec.First() == IfElseExec.SKIP_IF)  							{  								// If did not run' run else  								ifExec.Push(IfElseExec.RUN_ELSE);  							}  							break;  						}  					case OpCode.OP_ENDIF:  						{  							if (ifExec.Count == 0)  								// No preceding if statement!  								return false;  							if (ifExec.First() == IfElseExec.RUN_IF ||  								ifExec.First() == IfElseExec.SKIP_IF)  							{  								ifExec.Pop();  							}  							else if (ifExec.First() == IfElseExec.RUN_ELSE ||  							   ifExec.First() == IfElseExec.SKIP_ELSE)  							{  								ifExec.Pop();  								ifExec.Pop();  							}  							break;  						}  					case OpCode.OP_VERIFY:  						{  							if (stack.Count < 1 || new ScriptVarInt(stack.First()).value.IsZero)  								return false;  							stack.Pop();  							break;  						}  					case OpCode.OP_RETURN:  						{  							return false;  						}  					case OpCode.OP_TOALTSTACK:  						{  							if (stack.Count < 1)  								return false;  							altstack.Push(stack.Pop());  							break;  						}  					case OpCode.OP_FROMALTSTACK:  						{  							if (altstack.Count < 1)  								return false;  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_2DROP:  						{  							if (stack.Count < 2)  								return false;  							stack.Pop();  							stack.Pop();  							break;  						}  					case OpCode.OP_2DUP:  						{  							if (stack.Count < 2)  								return false;  							stack.Push(stack.Skip(1).First());  							stack.Push(stack.Skip(1).First());  							break;  						}  					case OpCode.OP_3DUP:  						{  							if (stack.Count < 3)  								return false;  							stack.Push(stack.Skip(2).First());  							stack.Push(stack.Skip(2).First());  							stack.Push(stack.Skip(2).First());  							break;  						}  					case OpCode.OP_2OVER:  						{  							if (stack.Count < 4)  								return false;  							stack.Push(stack.Skip(3).First());  							stack.Push(stack.Skip(3).First());  							break;  						}  					case OpCode.OP_2ROT:  						{  							if (stack.Count < 6)  								return false;  							altstack.Push(stack.Skip(4).First());  							altstack.Push(stack.Skip(5).First());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_2SWAP:  						{  							if (stack.Count < 4)  								return false;  							altstack.Push(stack.Skip(2).First());  							altstack.Push(stack.Skip(3).First());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_IFDUP:  						{  							if (stack.Count < 1)  								return false;  							if (!new ScriptVarInt(stack.First()).value.IsZero)  								stack.Push(stack.First());  							break;  						}  					case OpCode.OP_DEPTH:  						{  							stack.Push(new ScriptVarInt((UInt64)stack.Count).ToBytes());  							break;  						}  					case OpCode.OP_DROP:  						{  							if (stack.Count < 1)  								return false;  							stack.Pop();  							break;  						}  					case OpCode.OP_DUP:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(stack.First());  							break;  						}  					case OpCode.OP_NIP:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_OVER:  						{  							if (stack.Count < 2)  								return false;  							stack.Push(stack.Skip(1).First());  							break;  						}  					case OpCode.OP_PICK:  						{  							if (stack.Count < 2)  								return false;  							int pick = new ScriptVarInt(stack.Pop()).intValue;  							if (pick < 0 || stack.Count <= pick)  								return false;  							stack.Push(stack.Skip(pick).First());  							break;  						}  					case OpCode.OP_ROLL:  						{  							if (stack.Count < 2)  								return false;  							int roll = new ScriptVarInt(stack.Pop()).intValue;  							if (roll < 0 || stack.Count <= roll)  								return false;  							altstack.Push(stack.Skip(roll).First());  							for (int i = 0; i < roll; i++)  								altstack.Push(stack.Pop());  							stack.Pop();  							for (int i = 0; i < roll + 1; i++)  								stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_ROT:  						{  							if (stack.Count < 3)  								return false;  							altstack.Push(stack.Skip(2).First());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_SWAP:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Skip(1).First());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_TUCK:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Push(altstack.Skip(1).First());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_CAT:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Skip(1).First().Concat(stack.First()).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_SUBSTR:  						{  							if (stack.Count < 3)  								return false;  							altstack.Push(stack.Skip(2).First()  								.Skip(new ScriptVarInt(stack.Skip(1).First()).intValue)  								.Take(new ScriptVarInt(stack.First()).intValue).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_LEFT:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Skip(1).First()  								.Take(new ScriptVarInt(stack.First()).intValue).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_RIGHT:  						{  							if (stack.Count < 2)  								return false;  							int count = new ScriptVarInt(stack.First()).intValue;  							altstack.Push(stack.Skip(1).First()  								.Skip(stack.Skip(1).First().Length - count).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_SIZE:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(new ScriptVarInt((UInt64)stack.First().Length).ToBytes());  							break;  						}  					case OpCode.OP_INVERT:  						{  							if (stack.Count < 1)  								return false;  							Byte[] data = stack.Pop();  							for (int i = 0; i < data.Length; i++)  								data[i] ^= 0xFF;  							stack.Push(data);  							break;  						}  					case OpCode.OP_AND:  					case OpCode.OP_OR:  					case OpCode.OP_XOR:  						{  							if (stack.Count < 2)  								return false;  							Byte[] data = stack.Pop();  							Byte[] data2 = stack.Pop();  							int length = new int[] { data.Length' data2.Length }.Max();  							data = data.Concat(new Byte[length - data.Length]).ToArray();  							data2 = data2.Concat(new Byte[length - data2.Length]).ToArray();  							switch (se.opCode)  							{  								case OpCode.OP_AND:  									{  										for (int i = 0; i < length; i++)  											data[i] &= data2[i];  										break;  									}  								case OpCode.OP_OR:  									{  										for (int i = 0; i < length; i++)  											data[i] |= data2[i];  										break;  									}  								case OpCode.OP_XOR:  									{  										for (int i = 0; i < length; i++)  											data[i] ^= data2[i];  										break;  									}  							}  							stack.Push(data);  							break;  						}  					case OpCode.OP_EQUAL:  					case OpCode.OP_EQUALVERIFY:  						{  							if (stack.Count < 2)  								return false;  							if (stack.Pop().SequenceEqual(stack.Pop()))  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });    							if (se.opCode == OpCode.OP_EQUALVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_RESERVED1:  					case OpCode.OP_RESERVED2:  						{  							return false;  						}  					case OpCode.OP_1ADD:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Add(new ScriptVarInt(stack.Pop())' 1)).ToBytes());  							break;  						}  					case OpCode.OP_1SUB:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Subtract(new ScriptVarInt(stack.Pop())' 1)).ToBytes());  							break;  						}  					case OpCode.OP_2MUL:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Multiply(new ScriptVarInt(stack.Pop())' 2)).ToBytes());  							break;  						}  					case OpCode.OP_2DIV:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Divide(new ScriptVarInt(stack.Pop())' 2)).ToBytes());  							break;  						}  					case OpCode.OP_NEGATE:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Negate(new ScriptVarInt(stack.Pop()))).ToBytes());  							break;  						}  					case OpCode.OP_ABS:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Abs(new ScriptVarInt(stack.Pop()))).ToBytes());  							break;  						}  					case OpCode.OP_NOT:  						{  							if (stack.Count < 1)  								return false;  							if (new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_0NOTEQUAL:  						{  							if (stack.Count < 1)  								return false;  							if (new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x00 });  							else  								stack.Push(new Byte[] { 0x01 });  							break;  						}  					case OpCode.OP_ADD:  					case OpCode.OP_SUB:  					case OpCode.OP_MUL:  					case OpCode.OP_DIV:  					case OpCode.OP_MOD:  					case OpCode.OP_LSHIFT:  					case OpCode.OP_RSHIFT:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							switch (se.opCode)  							{  								case OpCode.OP_ADD:  									a = (BigInteger)a + b;  									break;  								case OpCode.OP_SUB:  									a = (BigInteger)a - b;  									break;  								case OpCode.OP_MUL:  									a = (BigInteger)a * b;  									break;  								case OpCode.OP_DIV:  									a = (BigInteger)a / b;  									break;  								case OpCode.OP_MOD:  									a = (BigInteger)a % b;  									break;  								case OpCode.OP_LSHIFT:  									a = (BigInteger)a << b.intValue;  									break;  								case OpCode.OP_RSHIFT:  									a = (BigInteger)a >> b.intValue;  									break;  							}  							stack.Push(a.ToBytes());  							break;  						}  					case OpCode.OP_BOOLAND:  						{  							if (stack.Count < 2)  								return false;  							if (!new ScriptVarInt(stack.Pop()).value.IsZero && !new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_BOOLOR:  						{  							if (stack.Count < 2)  								return false;  							if (!new ScriptVarInt(stack.Pop()).value.IsZero || !new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_NUMEQUAL:  					case OpCode.OP_NUMEQUALVERIFY:  						{  							if (stack.Count < 2)  								return false;  							if (new ScriptVarInt(stack.Pop()).value == new ScriptVarInt(stack.Pop()).value)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							if (se.opCode == OpCode.OP_NUMEQUALVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_NUMNOTEQUAL:  						{  							if (stack.Count < 2)  								return false;  							if (new ScriptVarInt(stack.Pop()).value != new ScriptVarInt(stack.Pop()).value)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_LESSTHAN:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a < b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_GREATERTHAN:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a > b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_LESSTHANOREQUAL:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a <= b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_GREATERTHANOREQUAL:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a >= b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_MIN:  						{  							if (stack.Count < 2)  								return false;  							Byte[] b = stack.Pop();  							Byte[] a = stack.Pop();  							if (new ScriptVarInt(a).value < new ScriptVarInt(b).value)  								stack.Push(a);  							else  								stack.Push(b);  							break;  						}  					case OpCode.OP_MAX:  						{  							if (stack.Count < 2)  								return false;  							Byte[] b = stack.Pop();  							Byte[] a = stack.Pop();  							if (new ScriptVarInt(a).value > new ScriptVarInt(b).value)  								stack.Push(a);  							else  								stack.Push(b);  							break;  						}  					case OpCode.OP_WITHIN:  						{  							if (stack.Count < 3)  								return false;  							ScriptVarInt max = new ScriptVarInt(stack.Pop());  							ScriptVarInt min = new ScriptVarInt(stack.Pop());  							ScriptVarInt x = new ScriptVarInt(stack.Pop());  							if ((BigInteger)min <= x && (BigInteger)x <= max)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_RIPEMD160:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(ripemd160.ComputeHash(stack.Pop()));  							break;  						}  					case OpCode.OP_SHA1:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(sha1.ComputeHash(stack.Pop()));  							break;  						}  					case OpCode.OP_SHA256:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(sha256.ComputeHash(stack.Pop()));  							break;  						}  					case OpCode.OP_HASH160:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(ripemd160.ComputeHash(sha256.ComputeHash(stack.Pop())));  							break;  						}  					case OpCode.OP_HASH256:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(sha256.ComputeHash(sha256.ComputeHash(stack.Pop())));  							break;  						}  					case OpCode.OP_CODESEPARATOR:  						{  							lastCodeSeperator = index;  							break;  						}  					case OpCode.OP_CHECKSIG:  					case OpCode.OP_CHECKSIGVERIFY:  						{  							if (tx == null)  								throw new ArgumentNullException("Transaction is required if script contains OP_CHECKSIG[VERIFY]");  							if (stack.Count < 2)  								return false;    							PublicKey pubKey = new PublicKey(stack.Pop());  							Byte[] sig = stack.Pop();    							Script subScript = new Script(elements.Skip(lastCodeSeperator)  								.Where(x => x.opCode != OpCode.OP_CODESEPARATOR).ToArray());    							stack.Push(new ScriptVarInt(CheckSig(sig' pubKey' txInIndex' subScript' tx) ? 1 : 0).ToBytes());    							if (se.opCode == OpCode.OP_CHECKSIGVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_CHECKMULTISIG:  					case OpCode.OP_CHECKMULTISIGVERIFY:  						{  							if (tx == null)  								throw new ArgumentNullException("Transaction is required if script contains OP_CHECKMULTISIG[VERIFY]");  							if (stack.Count < 2)  								return false;    							PublicKey[] pubKeys = new PublicKey[new ScriptVarInt(stack.Pop()).intValue];    							if (stack.Count < pubKeys.Length + 1)  								return false;    							for (int i = 0; i < pubKeys.Length; i++)  							{  								pubKeys[i] = new PublicKey(stack.Pop());  							}    							Byte[][] sigs = new Byte[new ScriptVarInt(stack.Pop()).intValue][];    							if (stack.Count < sigs.Length)  								return false;    							for (int i = 0; i < sigs.Length; i++)  							{  								sigs[i] = stack.Pop();  							}    							// Remove extra unused value from stack  							stack.Pop();    							Script subScript = new Script(elements.Skip(lastCodeSeperator)  								.Where(x => x.opCode != OpCode.OP_CODESEPARATOR).ToArray());    							int validSigs = 0;  							foreach (Byte[] sig in sigs)  							{  								foreach (PublicKey pubKey in pubKeys)  								{  									if (CheckSig(sig' pubKey' txInIndex' subScript' tx))  									{  										pubKeys = pubKeys.Where(x => x != pubKey).ToArray();  										validSigs++;  										break;  									}  								}  							}    							stack.Push(new ScriptVarInt((validSigs >= sigs.Length) ? 1 : 0).ToBytes());    							if (se.opCode == OpCode.OP_CHECKMULTISIGVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_NOP1:  					case OpCode.OP_NOP2:  					case OpCode.OP_NOP3:  					case OpCode.OP_NOP4:  					case OpCode.OP_NOP5:  					case OpCode.OP_NOP6:  					case OpCode.OP_NOP7:  					case OpCode.OP_NOP8:  					case OpCode.OP_NOP9:  					case OpCode.OP_NOP10:  						{  							break;  						}  					case OpCode.OP_SMALLINTEGER:  					case OpCode.OP_PUBKEYS:  					case OpCode.OP_PUBKEYHASH:  					case OpCode.OP_PUBKEY:  					case OpCode.OP_INVALIDOPCODE:  					default:  						{  							return false;  						}    				}  			}
Magic Number,Bitcoin_Tool.Scripts,Script,C:\repos\mb300sd_Bitcoin-Tool\Bitcoin Tool\Scripts\Script.cs,Evaluate,The following statement contains a magic number: for (int index = 0; index < elements.Count; index++)  			{  				ScriptElement se = elements[index];  				if (ifExec.Count > 0)  					if ((ifExec.First() == IfElseExec.SKIP_IF && !(se.opCode == OpCode.OP_ELSE || se.opCode == OpCode.OP_ENDIF)) ||  						(ifExec.First() == IfElseExec.SKIP_ELSE && !(se.opCode == OpCode.OP_ENDIF)))  						continue;    				if (se.isData)  				{  					stack.Push(se.data);  					continue;  				}    				switch (se.opCode)  				{  					case OpCode.OP_RESERVED:  						{  							return false;  						}  					case OpCode.OP_NOP:  						{  							// NOP' Dump stack for debug  							/*  							stack.ToList().ForEach(x => Console.WriteLine(HexString.FromByteArray(x)));  							Console.WriteLine("---------------------------");  							*/  							break;  						}  					case OpCode.OP_VER:  						{  							return false;  						}  					case OpCode.OP_IF:  					case OpCode.OP_NOTIF:  						{  							if (stack.Count < 1)  								return false;  							Boolean stackIsZero = new ScriptVarInt(stack.Pop()).value.IsZero;  							if ((se.opCode == OpCode.OP_IF && !stackIsZero) || (se.opCode == OpCode.OP_NOTIF && stackIsZero))  							{  								// Run to else or endif  								ifExec.Push(IfElseExec.RUN_IF);  							}  							else  							{  								// Skip to else or endif  								ifExec.Push(IfElseExec.SKIP_IF);  							}  							break;  						}  					case OpCode.OP_VERIF:  					case OpCode.OP_VERNOTIF:  						{  							return false;  						}  					case OpCode.OP_ELSE:  						{  							if (ifExec.Count == 0)  								// No preceding if statement!  								return false;  							if (ifExec.First() == IfElseExec.RUN_IF)  							{  								// If ran' skip else  								ifExec.Push(IfElseExec.SKIP_ELSE);  							}  							else if (ifExec.First() == IfElseExec.SKIP_IF)  							{  								// If did not run' run else  								ifExec.Push(IfElseExec.RUN_ELSE);  							}  							break;  						}  					case OpCode.OP_ENDIF:  						{  							if (ifExec.Count == 0)  								// No preceding if statement!  								return false;  							if (ifExec.First() == IfElseExec.RUN_IF ||  								ifExec.First() == IfElseExec.SKIP_IF)  							{  								ifExec.Pop();  							}  							else if (ifExec.First() == IfElseExec.RUN_ELSE ||  							   ifExec.First() == IfElseExec.SKIP_ELSE)  							{  								ifExec.Pop();  								ifExec.Pop();  							}  							break;  						}  					case OpCode.OP_VERIFY:  						{  							if (stack.Count < 1 || new ScriptVarInt(stack.First()).value.IsZero)  								return false;  							stack.Pop();  							break;  						}  					case OpCode.OP_RETURN:  						{  							return false;  						}  					case OpCode.OP_TOALTSTACK:  						{  							if (stack.Count < 1)  								return false;  							altstack.Push(stack.Pop());  							break;  						}  					case OpCode.OP_FROMALTSTACK:  						{  							if (altstack.Count < 1)  								return false;  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_2DROP:  						{  							if (stack.Count < 2)  								return false;  							stack.Pop();  							stack.Pop();  							break;  						}  					case OpCode.OP_2DUP:  						{  							if (stack.Count < 2)  								return false;  							stack.Push(stack.Skip(1).First());  							stack.Push(stack.Skip(1).First());  							break;  						}  					case OpCode.OP_3DUP:  						{  							if (stack.Count < 3)  								return false;  							stack.Push(stack.Skip(2).First());  							stack.Push(stack.Skip(2).First());  							stack.Push(stack.Skip(2).First());  							break;  						}  					case OpCode.OP_2OVER:  						{  							if (stack.Count < 4)  								return false;  							stack.Push(stack.Skip(3).First());  							stack.Push(stack.Skip(3).First());  							break;  						}  					case OpCode.OP_2ROT:  						{  							if (stack.Count < 6)  								return false;  							altstack.Push(stack.Skip(4).First());  							altstack.Push(stack.Skip(5).First());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_2SWAP:  						{  							if (stack.Count < 4)  								return false;  							altstack.Push(stack.Skip(2).First());  							altstack.Push(stack.Skip(3).First());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_IFDUP:  						{  							if (stack.Count < 1)  								return false;  							if (!new ScriptVarInt(stack.First()).value.IsZero)  								stack.Push(stack.First());  							break;  						}  					case OpCode.OP_DEPTH:  						{  							stack.Push(new ScriptVarInt((UInt64)stack.Count).ToBytes());  							break;  						}  					case OpCode.OP_DROP:  						{  							if (stack.Count < 1)  								return false;  							stack.Pop();  							break;  						}  					case OpCode.OP_DUP:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(stack.First());  							break;  						}  					case OpCode.OP_NIP:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_OVER:  						{  							if (stack.Count < 2)  								return false;  							stack.Push(stack.Skip(1).First());  							break;  						}  					case OpCode.OP_PICK:  						{  							if (stack.Count < 2)  								return false;  							int pick = new ScriptVarInt(stack.Pop()).intValue;  							if (pick < 0 || stack.Count <= pick)  								return false;  							stack.Push(stack.Skip(pick).First());  							break;  						}  					case OpCode.OP_ROLL:  						{  							if (stack.Count < 2)  								return false;  							int roll = new ScriptVarInt(stack.Pop()).intValue;  							if (roll < 0 || stack.Count <= roll)  								return false;  							altstack.Push(stack.Skip(roll).First());  							for (int i = 0; i < roll; i++)  								altstack.Push(stack.Pop());  							stack.Pop();  							for (int i = 0; i < roll + 1; i++)  								stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_ROT:  						{  							if (stack.Count < 3)  								return false;  							altstack.Push(stack.Skip(2).First());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_SWAP:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Skip(1).First());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_TUCK:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Push(altstack.Skip(1).First());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_CAT:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Skip(1).First().Concat(stack.First()).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_SUBSTR:  						{  							if (stack.Count < 3)  								return false;  							altstack.Push(stack.Skip(2).First()  								.Skip(new ScriptVarInt(stack.Skip(1).First()).intValue)  								.Take(new ScriptVarInt(stack.First()).intValue).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_LEFT:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Skip(1).First()  								.Take(new ScriptVarInt(stack.First()).intValue).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_RIGHT:  						{  							if (stack.Count < 2)  								return false;  							int count = new ScriptVarInt(stack.First()).intValue;  							altstack.Push(stack.Skip(1).First()  								.Skip(stack.Skip(1).First().Length - count).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_SIZE:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(new ScriptVarInt((UInt64)stack.First().Length).ToBytes());  							break;  						}  					case OpCode.OP_INVERT:  						{  							if (stack.Count < 1)  								return false;  							Byte[] data = stack.Pop();  							for (int i = 0; i < data.Length; i++)  								data[i] ^= 0xFF;  							stack.Push(data);  							break;  						}  					case OpCode.OP_AND:  					case OpCode.OP_OR:  					case OpCode.OP_XOR:  						{  							if (stack.Count < 2)  								return false;  							Byte[] data = stack.Pop();  							Byte[] data2 = stack.Pop();  							int length = new int[] { data.Length' data2.Length }.Max();  							data = data.Concat(new Byte[length - data.Length]).ToArray();  							data2 = data2.Concat(new Byte[length - data2.Length]).ToArray();  							switch (se.opCode)  							{  								case OpCode.OP_AND:  									{  										for (int i = 0; i < length; i++)  											data[i] &= data2[i];  										break;  									}  								case OpCode.OP_OR:  									{  										for (int i = 0; i < length; i++)  											data[i] |= data2[i];  										break;  									}  								case OpCode.OP_XOR:  									{  										for (int i = 0; i < length; i++)  											data[i] ^= data2[i];  										break;  									}  							}  							stack.Push(data);  							break;  						}  					case OpCode.OP_EQUAL:  					case OpCode.OP_EQUALVERIFY:  						{  							if (stack.Count < 2)  								return false;  							if (stack.Pop().SequenceEqual(stack.Pop()))  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });    							if (se.opCode == OpCode.OP_EQUALVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_RESERVED1:  					case OpCode.OP_RESERVED2:  						{  							return false;  						}  					case OpCode.OP_1ADD:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Add(new ScriptVarInt(stack.Pop())' 1)).ToBytes());  							break;  						}  					case OpCode.OP_1SUB:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Subtract(new ScriptVarInt(stack.Pop())' 1)).ToBytes());  							break;  						}  					case OpCode.OP_2MUL:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Multiply(new ScriptVarInt(stack.Pop())' 2)).ToBytes());  							break;  						}  					case OpCode.OP_2DIV:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Divide(new ScriptVarInt(stack.Pop())' 2)).ToBytes());  							break;  						}  					case OpCode.OP_NEGATE:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Negate(new ScriptVarInt(stack.Pop()))).ToBytes());  							break;  						}  					case OpCode.OP_ABS:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Abs(new ScriptVarInt(stack.Pop()))).ToBytes());  							break;  						}  					case OpCode.OP_NOT:  						{  							if (stack.Count < 1)  								return false;  							if (new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_0NOTEQUAL:  						{  							if (stack.Count < 1)  								return false;  							if (new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x00 });  							else  								stack.Push(new Byte[] { 0x01 });  							break;  						}  					case OpCode.OP_ADD:  					case OpCode.OP_SUB:  					case OpCode.OP_MUL:  					case OpCode.OP_DIV:  					case OpCode.OP_MOD:  					case OpCode.OP_LSHIFT:  					case OpCode.OP_RSHIFT:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							switch (se.opCode)  							{  								case OpCode.OP_ADD:  									a = (BigInteger)a + b;  									break;  								case OpCode.OP_SUB:  									a = (BigInteger)a - b;  									break;  								case OpCode.OP_MUL:  									a = (BigInteger)a * b;  									break;  								case OpCode.OP_DIV:  									a = (BigInteger)a / b;  									break;  								case OpCode.OP_MOD:  									a = (BigInteger)a % b;  									break;  								case OpCode.OP_LSHIFT:  									a = (BigInteger)a << b.intValue;  									break;  								case OpCode.OP_RSHIFT:  									a = (BigInteger)a >> b.intValue;  									break;  							}  							stack.Push(a.ToBytes());  							break;  						}  					case OpCode.OP_BOOLAND:  						{  							if (stack.Count < 2)  								return false;  							if (!new ScriptVarInt(stack.Pop()).value.IsZero && !new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_BOOLOR:  						{  							if (stack.Count < 2)  								return false;  							if (!new ScriptVarInt(stack.Pop()).value.IsZero || !new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_NUMEQUAL:  					case OpCode.OP_NUMEQUALVERIFY:  						{  							if (stack.Count < 2)  								return false;  							if (new ScriptVarInt(stack.Pop()).value == new ScriptVarInt(stack.Pop()).value)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							if (se.opCode == OpCode.OP_NUMEQUALVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_NUMNOTEQUAL:  						{  							if (stack.Count < 2)  								return false;  							if (new ScriptVarInt(stack.Pop()).value != new ScriptVarInt(stack.Pop()).value)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_LESSTHAN:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a < b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_GREATERTHAN:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a > b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_LESSTHANOREQUAL:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a <= b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_GREATERTHANOREQUAL:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a >= b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_MIN:  						{  							if (stack.Count < 2)  								return false;  							Byte[] b = stack.Pop();  							Byte[] a = stack.Pop();  							if (new ScriptVarInt(a).value < new ScriptVarInt(b).value)  								stack.Push(a);  							else  								stack.Push(b);  							break;  						}  					case OpCode.OP_MAX:  						{  							if (stack.Count < 2)  								return false;  							Byte[] b = stack.Pop();  							Byte[] a = stack.Pop();  							if (new ScriptVarInt(a).value > new ScriptVarInt(b).value)  								stack.Push(a);  							else  								stack.Push(b);  							break;  						}  					case OpCode.OP_WITHIN:  						{  							if (stack.Count < 3)  								return false;  							ScriptVarInt max = new ScriptVarInt(stack.Pop());  							ScriptVarInt min = new ScriptVarInt(stack.Pop());  							ScriptVarInt x = new ScriptVarInt(stack.Pop());  							if ((BigInteger)min <= x && (BigInteger)x <= max)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_RIPEMD160:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(ripemd160.ComputeHash(stack.Pop()));  							break;  						}  					case OpCode.OP_SHA1:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(sha1.ComputeHash(stack.Pop()));  							break;  						}  					case OpCode.OP_SHA256:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(sha256.ComputeHash(stack.Pop()));  							break;  						}  					case OpCode.OP_HASH160:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(ripemd160.ComputeHash(sha256.ComputeHash(stack.Pop())));  							break;  						}  					case OpCode.OP_HASH256:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(sha256.ComputeHash(sha256.ComputeHash(stack.Pop())));  							break;  						}  					case OpCode.OP_CODESEPARATOR:  						{  							lastCodeSeperator = index;  							break;  						}  					case OpCode.OP_CHECKSIG:  					case OpCode.OP_CHECKSIGVERIFY:  						{  							if (tx == null)  								throw new ArgumentNullException("Transaction is required if script contains OP_CHECKSIG[VERIFY]");  							if (stack.Count < 2)  								return false;    							PublicKey pubKey = new PublicKey(stack.Pop());  							Byte[] sig = stack.Pop();    							Script subScript = new Script(elements.Skip(lastCodeSeperator)  								.Where(x => x.opCode != OpCode.OP_CODESEPARATOR).ToArray());    							stack.Push(new ScriptVarInt(CheckSig(sig' pubKey' txInIndex' subScript' tx) ? 1 : 0).ToBytes());    							if (se.opCode == OpCode.OP_CHECKSIGVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_CHECKMULTISIG:  					case OpCode.OP_CHECKMULTISIGVERIFY:  						{  							if (tx == null)  								throw new ArgumentNullException("Transaction is required if script contains OP_CHECKMULTISIG[VERIFY]");  							if (stack.Count < 2)  								return false;    							PublicKey[] pubKeys = new PublicKey[new ScriptVarInt(stack.Pop()).intValue];    							if (stack.Count < pubKeys.Length + 1)  								return false;    							for (int i = 0; i < pubKeys.Length; i++)  							{  								pubKeys[i] = new PublicKey(stack.Pop());  							}    							Byte[][] sigs = new Byte[new ScriptVarInt(stack.Pop()).intValue][];    							if (stack.Count < sigs.Length)  								return false;    							for (int i = 0; i < sigs.Length; i++)  							{  								sigs[i] = stack.Pop();  							}    							// Remove extra unused value from stack  							stack.Pop();    							Script subScript = new Script(elements.Skip(lastCodeSeperator)  								.Where(x => x.opCode != OpCode.OP_CODESEPARATOR).ToArray());    							int validSigs = 0;  							foreach (Byte[] sig in sigs)  							{  								foreach (PublicKey pubKey in pubKeys)  								{  									if (CheckSig(sig' pubKey' txInIndex' subScript' tx))  									{  										pubKeys = pubKeys.Where(x => x != pubKey).ToArray();  										validSigs++;  										break;  									}  								}  							}    							stack.Push(new ScriptVarInt((validSigs >= sigs.Length) ? 1 : 0).ToBytes());    							if (se.opCode == OpCode.OP_CHECKMULTISIGVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_NOP1:  					case OpCode.OP_NOP2:  					case OpCode.OP_NOP3:  					case OpCode.OP_NOP4:  					case OpCode.OP_NOP5:  					case OpCode.OP_NOP6:  					case OpCode.OP_NOP7:  					case OpCode.OP_NOP8:  					case OpCode.OP_NOP9:  					case OpCode.OP_NOP10:  						{  							break;  						}  					case OpCode.OP_SMALLINTEGER:  					case OpCode.OP_PUBKEYS:  					case OpCode.OP_PUBKEYHASH:  					case OpCode.OP_PUBKEY:  					case OpCode.OP_INVALIDOPCODE:  					default:  						{  							return false;  						}    				}  			}
Magic Number,Bitcoin_Tool.Scripts,Script,C:\repos\mb300sd_Bitcoin-Tool\Bitcoin Tool\Scripts\Script.cs,Evaluate,The following statement contains a magic number: for (int index = 0; index < elements.Count; index++)  			{  				ScriptElement se = elements[index];  				if (ifExec.Count > 0)  					if ((ifExec.First() == IfElseExec.SKIP_IF && !(se.opCode == OpCode.OP_ELSE || se.opCode == OpCode.OP_ENDIF)) ||  						(ifExec.First() == IfElseExec.SKIP_ELSE && !(se.opCode == OpCode.OP_ENDIF)))  						continue;    				if (se.isData)  				{  					stack.Push(se.data);  					continue;  				}    				switch (se.opCode)  				{  					case OpCode.OP_RESERVED:  						{  							return false;  						}  					case OpCode.OP_NOP:  						{  							// NOP' Dump stack for debug  							/*  							stack.ToList().ForEach(x => Console.WriteLine(HexString.FromByteArray(x)));  							Console.WriteLine("---------------------------");  							*/  							break;  						}  					case OpCode.OP_VER:  						{  							return false;  						}  					case OpCode.OP_IF:  					case OpCode.OP_NOTIF:  						{  							if (stack.Count < 1)  								return false;  							Boolean stackIsZero = new ScriptVarInt(stack.Pop()).value.IsZero;  							if ((se.opCode == OpCode.OP_IF && !stackIsZero) || (se.opCode == OpCode.OP_NOTIF && stackIsZero))  							{  								// Run to else or endif  								ifExec.Push(IfElseExec.RUN_IF);  							}  							else  							{  								// Skip to else or endif  								ifExec.Push(IfElseExec.SKIP_IF);  							}  							break;  						}  					case OpCode.OP_VERIF:  					case OpCode.OP_VERNOTIF:  						{  							return false;  						}  					case OpCode.OP_ELSE:  						{  							if (ifExec.Count == 0)  								// No preceding if statement!  								return false;  							if (ifExec.First() == IfElseExec.RUN_IF)  							{  								// If ran' skip else  								ifExec.Push(IfElseExec.SKIP_ELSE);  							}  							else if (ifExec.First() == IfElseExec.SKIP_IF)  							{  								// If did not run' run else  								ifExec.Push(IfElseExec.RUN_ELSE);  							}  							break;  						}  					case OpCode.OP_ENDIF:  						{  							if (ifExec.Count == 0)  								// No preceding if statement!  								return false;  							if (ifExec.First() == IfElseExec.RUN_IF ||  								ifExec.First() == IfElseExec.SKIP_IF)  							{  								ifExec.Pop();  							}  							else if (ifExec.First() == IfElseExec.RUN_ELSE ||  							   ifExec.First() == IfElseExec.SKIP_ELSE)  							{  								ifExec.Pop();  								ifExec.Pop();  							}  							break;  						}  					case OpCode.OP_VERIFY:  						{  							if (stack.Count < 1 || new ScriptVarInt(stack.First()).value.IsZero)  								return false;  							stack.Pop();  							break;  						}  					case OpCode.OP_RETURN:  						{  							return false;  						}  					case OpCode.OP_TOALTSTACK:  						{  							if (stack.Count < 1)  								return false;  							altstack.Push(stack.Pop());  							break;  						}  					case OpCode.OP_FROMALTSTACK:  						{  							if (altstack.Count < 1)  								return false;  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_2DROP:  						{  							if (stack.Count < 2)  								return false;  							stack.Pop();  							stack.Pop();  							break;  						}  					case OpCode.OP_2DUP:  						{  							if (stack.Count < 2)  								return false;  							stack.Push(stack.Skip(1).First());  							stack.Push(stack.Skip(1).First());  							break;  						}  					case OpCode.OP_3DUP:  						{  							if (stack.Count < 3)  								return false;  							stack.Push(stack.Skip(2).First());  							stack.Push(stack.Skip(2).First());  							stack.Push(stack.Skip(2).First());  							break;  						}  					case OpCode.OP_2OVER:  						{  							if (stack.Count < 4)  								return false;  							stack.Push(stack.Skip(3).First());  							stack.Push(stack.Skip(3).First());  							break;  						}  					case OpCode.OP_2ROT:  						{  							if (stack.Count < 6)  								return false;  							altstack.Push(stack.Skip(4).First());  							altstack.Push(stack.Skip(5).First());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_2SWAP:  						{  							if (stack.Count < 4)  								return false;  							altstack.Push(stack.Skip(2).First());  							altstack.Push(stack.Skip(3).First());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_IFDUP:  						{  							if (stack.Count < 1)  								return false;  							if (!new ScriptVarInt(stack.First()).value.IsZero)  								stack.Push(stack.First());  							break;  						}  					case OpCode.OP_DEPTH:  						{  							stack.Push(new ScriptVarInt((UInt64)stack.Count).ToBytes());  							break;  						}  					case OpCode.OP_DROP:  						{  							if (stack.Count < 1)  								return false;  							stack.Pop();  							break;  						}  					case OpCode.OP_DUP:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(stack.First());  							break;  						}  					case OpCode.OP_NIP:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_OVER:  						{  							if (stack.Count < 2)  								return false;  							stack.Push(stack.Skip(1).First());  							break;  						}  					case OpCode.OP_PICK:  						{  							if (stack.Count < 2)  								return false;  							int pick = new ScriptVarInt(stack.Pop()).intValue;  							if (pick < 0 || stack.Count <= pick)  								return false;  							stack.Push(stack.Skip(pick).First());  							break;  						}  					case OpCode.OP_ROLL:  						{  							if (stack.Count < 2)  								return false;  							int roll = new ScriptVarInt(stack.Pop()).intValue;  							if (roll < 0 || stack.Count <= roll)  								return false;  							altstack.Push(stack.Skip(roll).First());  							for (int i = 0; i < roll; i++)  								altstack.Push(stack.Pop());  							stack.Pop();  							for (int i = 0; i < roll + 1; i++)  								stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_ROT:  						{  							if (stack.Count < 3)  								return false;  							altstack.Push(stack.Skip(2).First());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_SWAP:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Skip(1).First());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_TUCK:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Push(altstack.Skip(1).First());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_CAT:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Skip(1).First().Concat(stack.First()).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_SUBSTR:  						{  							if (stack.Count < 3)  								return false;  							altstack.Push(stack.Skip(2).First()  								.Skip(new ScriptVarInt(stack.Skip(1).First()).intValue)  								.Take(new ScriptVarInt(stack.First()).intValue).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_LEFT:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Skip(1).First()  								.Take(new ScriptVarInt(stack.First()).intValue).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_RIGHT:  						{  							if (stack.Count < 2)  								return false;  							int count = new ScriptVarInt(stack.First()).intValue;  							altstack.Push(stack.Skip(1).First()  								.Skip(stack.Skip(1).First().Length - count).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_SIZE:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(new ScriptVarInt((UInt64)stack.First().Length).ToBytes());  							break;  						}  					case OpCode.OP_INVERT:  						{  							if (stack.Count < 1)  								return false;  							Byte[] data = stack.Pop();  							for (int i = 0; i < data.Length; i++)  								data[i] ^= 0xFF;  							stack.Push(data);  							break;  						}  					case OpCode.OP_AND:  					case OpCode.OP_OR:  					case OpCode.OP_XOR:  						{  							if (stack.Count < 2)  								return false;  							Byte[] data = stack.Pop();  							Byte[] data2 = stack.Pop();  							int length = new int[] { data.Length' data2.Length }.Max();  							data = data.Concat(new Byte[length - data.Length]).ToArray();  							data2 = data2.Concat(new Byte[length - data2.Length]).ToArray();  							switch (se.opCode)  							{  								case OpCode.OP_AND:  									{  										for (int i = 0; i < length; i++)  											data[i] &= data2[i];  										break;  									}  								case OpCode.OP_OR:  									{  										for (int i = 0; i < length; i++)  											data[i] |= data2[i];  										break;  									}  								case OpCode.OP_XOR:  									{  										for (int i = 0; i < length; i++)  											data[i] ^= data2[i];  										break;  									}  							}  							stack.Push(data);  							break;  						}  					case OpCode.OP_EQUAL:  					case OpCode.OP_EQUALVERIFY:  						{  							if (stack.Count < 2)  								return false;  							if (stack.Pop().SequenceEqual(stack.Pop()))  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });    							if (se.opCode == OpCode.OP_EQUALVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_RESERVED1:  					case OpCode.OP_RESERVED2:  						{  							return false;  						}  					case OpCode.OP_1ADD:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Add(new ScriptVarInt(stack.Pop())' 1)).ToBytes());  							break;  						}  					case OpCode.OP_1SUB:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Subtract(new ScriptVarInt(stack.Pop())' 1)).ToBytes());  							break;  						}  					case OpCode.OP_2MUL:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Multiply(new ScriptVarInt(stack.Pop())' 2)).ToBytes());  							break;  						}  					case OpCode.OP_2DIV:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Divide(new ScriptVarInt(stack.Pop())' 2)).ToBytes());  							break;  						}  					case OpCode.OP_NEGATE:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Negate(new ScriptVarInt(stack.Pop()))).ToBytes());  							break;  						}  					case OpCode.OP_ABS:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Abs(new ScriptVarInt(stack.Pop()))).ToBytes());  							break;  						}  					case OpCode.OP_NOT:  						{  							if (stack.Count < 1)  								return false;  							if (new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_0NOTEQUAL:  						{  							if (stack.Count < 1)  								return false;  							if (new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x00 });  							else  								stack.Push(new Byte[] { 0x01 });  							break;  						}  					case OpCode.OP_ADD:  					case OpCode.OP_SUB:  					case OpCode.OP_MUL:  					case OpCode.OP_DIV:  					case OpCode.OP_MOD:  					case OpCode.OP_LSHIFT:  					case OpCode.OP_RSHIFT:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							switch (se.opCode)  							{  								case OpCode.OP_ADD:  									a = (BigInteger)a + b;  									break;  								case OpCode.OP_SUB:  									a = (BigInteger)a - b;  									break;  								case OpCode.OP_MUL:  									a = (BigInteger)a * b;  									break;  								case OpCode.OP_DIV:  									a = (BigInteger)a / b;  									break;  								case OpCode.OP_MOD:  									a = (BigInteger)a % b;  									break;  								case OpCode.OP_LSHIFT:  									a = (BigInteger)a << b.intValue;  									break;  								case OpCode.OP_RSHIFT:  									a = (BigInteger)a >> b.intValue;  									break;  							}  							stack.Push(a.ToBytes());  							break;  						}  					case OpCode.OP_BOOLAND:  						{  							if (stack.Count < 2)  								return false;  							if (!new ScriptVarInt(stack.Pop()).value.IsZero && !new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_BOOLOR:  						{  							if (stack.Count < 2)  								return false;  							if (!new ScriptVarInt(stack.Pop()).value.IsZero || !new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_NUMEQUAL:  					case OpCode.OP_NUMEQUALVERIFY:  						{  							if (stack.Count < 2)  								return false;  							if (new ScriptVarInt(stack.Pop()).value == new ScriptVarInt(stack.Pop()).value)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							if (se.opCode == OpCode.OP_NUMEQUALVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_NUMNOTEQUAL:  						{  							if (stack.Count < 2)  								return false;  							if (new ScriptVarInt(stack.Pop()).value != new ScriptVarInt(stack.Pop()).value)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_LESSTHAN:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a < b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_GREATERTHAN:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a > b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_LESSTHANOREQUAL:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a <= b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_GREATERTHANOREQUAL:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a >= b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_MIN:  						{  							if (stack.Count < 2)  								return false;  							Byte[] b = stack.Pop();  							Byte[] a = stack.Pop();  							if (new ScriptVarInt(a).value < new ScriptVarInt(b).value)  								stack.Push(a);  							else  								stack.Push(b);  							break;  						}  					case OpCode.OP_MAX:  						{  							if (stack.Count < 2)  								return false;  							Byte[] b = stack.Pop();  							Byte[] a = stack.Pop();  							if (new ScriptVarInt(a).value > new ScriptVarInt(b).value)  								stack.Push(a);  							else  								stack.Push(b);  							break;  						}  					case OpCode.OP_WITHIN:  						{  							if (stack.Count < 3)  								return false;  							ScriptVarInt max = new ScriptVarInt(stack.Pop());  							ScriptVarInt min = new ScriptVarInt(stack.Pop());  							ScriptVarInt x = new ScriptVarInt(stack.Pop());  							if ((BigInteger)min <= x && (BigInteger)x <= max)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_RIPEMD160:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(ripemd160.ComputeHash(stack.Pop()));  							break;  						}  					case OpCode.OP_SHA1:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(sha1.ComputeHash(stack.Pop()));  							break;  						}  					case OpCode.OP_SHA256:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(sha256.ComputeHash(stack.Pop()));  							break;  						}  					case OpCode.OP_HASH160:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(ripemd160.ComputeHash(sha256.ComputeHash(stack.Pop())));  							break;  						}  					case OpCode.OP_HASH256:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(sha256.ComputeHash(sha256.ComputeHash(stack.Pop())));  							break;  						}  					case OpCode.OP_CODESEPARATOR:  						{  							lastCodeSeperator = index;  							break;  						}  					case OpCode.OP_CHECKSIG:  					case OpCode.OP_CHECKSIGVERIFY:  						{  							if (tx == null)  								throw new ArgumentNullException("Transaction is required if script contains OP_CHECKSIG[VERIFY]");  							if (stack.Count < 2)  								return false;    							PublicKey pubKey = new PublicKey(stack.Pop());  							Byte[] sig = stack.Pop();    							Script subScript = new Script(elements.Skip(lastCodeSeperator)  								.Where(x => x.opCode != OpCode.OP_CODESEPARATOR).ToArray());    							stack.Push(new ScriptVarInt(CheckSig(sig' pubKey' txInIndex' subScript' tx) ? 1 : 0).ToBytes());    							if (se.opCode == OpCode.OP_CHECKSIGVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_CHECKMULTISIG:  					case OpCode.OP_CHECKMULTISIGVERIFY:  						{  							if (tx == null)  								throw new ArgumentNullException("Transaction is required if script contains OP_CHECKMULTISIG[VERIFY]");  							if (stack.Count < 2)  								return false;    							PublicKey[] pubKeys = new PublicKey[new ScriptVarInt(stack.Pop()).intValue];    							if (stack.Count < pubKeys.Length + 1)  								return false;    							for (int i = 0; i < pubKeys.Length; i++)  							{  								pubKeys[i] = new PublicKey(stack.Pop());  							}    							Byte[][] sigs = new Byte[new ScriptVarInt(stack.Pop()).intValue][];    							if (stack.Count < sigs.Length)  								return false;    							for (int i = 0; i < sigs.Length; i++)  							{  								sigs[i] = stack.Pop();  							}    							// Remove extra unused value from stack  							stack.Pop();    							Script subScript = new Script(elements.Skip(lastCodeSeperator)  								.Where(x => x.opCode != OpCode.OP_CODESEPARATOR).ToArray());    							int validSigs = 0;  							foreach (Byte[] sig in sigs)  							{  								foreach (PublicKey pubKey in pubKeys)  								{  									if (CheckSig(sig' pubKey' txInIndex' subScript' tx))  									{  										pubKeys = pubKeys.Where(x => x != pubKey).ToArray();  										validSigs++;  										break;  									}  								}  							}    							stack.Push(new ScriptVarInt((validSigs >= sigs.Length) ? 1 : 0).ToBytes());    							if (se.opCode == OpCode.OP_CHECKMULTISIGVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_NOP1:  					case OpCode.OP_NOP2:  					case OpCode.OP_NOP3:  					case OpCode.OP_NOP4:  					case OpCode.OP_NOP5:  					case OpCode.OP_NOP6:  					case OpCode.OP_NOP7:  					case OpCode.OP_NOP8:  					case OpCode.OP_NOP9:  					case OpCode.OP_NOP10:  						{  							break;  						}  					case OpCode.OP_SMALLINTEGER:  					case OpCode.OP_PUBKEYS:  					case OpCode.OP_PUBKEYHASH:  					case OpCode.OP_PUBKEY:  					case OpCode.OP_INVALIDOPCODE:  					default:  						{  							return false;  						}    				}  			}
Magic Number,Bitcoin_Tool.Scripts,Script,C:\repos\mb300sd_Bitcoin-Tool\Bitcoin Tool\Scripts\Script.cs,Evaluate,The following statement contains a magic number: for (int index = 0; index < elements.Count; index++)  			{  				ScriptElement se = elements[index];  				if (ifExec.Count > 0)  					if ((ifExec.First() == IfElseExec.SKIP_IF && !(se.opCode == OpCode.OP_ELSE || se.opCode == OpCode.OP_ENDIF)) ||  						(ifExec.First() == IfElseExec.SKIP_ELSE && !(se.opCode == OpCode.OP_ENDIF)))  						continue;    				if (se.isData)  				{  					stack.Push(se.data);  					continue;  				}    				switch (se.opCode)  				{  					case OpCode.OP_RESERVED:  						{  							return false;  						}  					case OpCode.OP_NOP:  						{  							// NOP' Dump stack for debug  							/*  							stack.ToList().ForEach(x => Console.WriteLine(HexString.FromByteArray(x)));  							Console.WriteLine("---------------------------");  							*/  							break;  						}  					case OpCode.OP_VER:  						{  							return false;  						}  					case OpCode.OP_IF:  					case OpCode.OP_NOTIF:  						{  							if (stack.Count < 1)  								return false;  							Boolean stackIsZero = new ScriptVarInt(stack.Pop()).value.IsZero;  							if ((se.opCode == OpCode.OP_IF && !stackIsZero) || (se.opCode == OpCode.OP_NOTIF && stackIsZero))  							{  								// Run to else or endif  								ifExec.Push(IfElseExec.RUN_IF);  							}  							else  							{  								// Skip to else or endif  								ifExec.Push(IfElseExec.SKIP_IF);  							}  							break;  						}  					case OpCode.OP_VERIF:  					case OpCode.OP_VERNOTIF:  						{  							return false;  						}  					case OpCode.OP_ELSE:  						{  							if (ifExec.Count == 0)  								// No preceding if statement!  								return false;  							if (ifExec.First() == IfElseExec.RUN_IF)  							{  								// If ran' skip else  								ifExec.Push(IfElseExec.SKIP_ELSE);  							}  							else if (ifExec.First() == IfElseExec.SKIP_IF)  							{  								// If did not run' run else  								ifExec.Push(IfElseExec.RUN_ELSE);  							}  							break;  						}  					case OpCode.OP_ENDIF:  						{  							if (ifExec.Count == 0)  								// No preceding if statement!  								return false;  							if (ifExec.First() == IfElseExec.RUN_IF ||  								ifExec.First() == IfElseExec.SKIP_IF)  							{  								ifExec.Pop();  							}  							else if (ifExec.First() == IfElseExec.RUN_ELSE ||  							   ifExec.First() == IfElseExec.SKIP_ELSE)  							{  								ifExec.Pop();  								ifExec.Pop();  							}  							break;  						}  					case OpCode.OP_VERIFY:  						{  							if (stack.Count < 1 || new ScriptVarInt(stack.First()).value.IsZero)  								return false;  							stack.Pop();  							break;  						}  					case OpCode.OP_RETURN:  						{  							return false;  						}  					case OpCode.OP_TOALTSTACK:  						{  							if (stack.Count < 1)  								return false;  							altstack.Push(stack.Pop());  							break;  						}  					case OpCode.OP_FROMALTSTACK:  						{  							if (altstack.Count < 1)  								return false;  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_2DROP:  						{  							if (stack.Count < 2)  								return false;  							stack.Pop();  							stack.Pop();  							break;  						}  					case OpCode.OP_2DUP:  						{  							if (stack.Count < 2)  								return false;  							stack.Push(stack.Skip(1).First());  							stack.Push(stack.Skip(1).First());  							break;  						}  					case OpCode.OP_3DUP:  						{  							if (stack.Count < 3)  								return false;  							stack.Push(stack.Skip(2).First());  							stack.Push(stack.Skip(2).First());  							stack.Push(stack.Skip(2).First());  							break;  						}  					case OpCode.OP_2OVER:  						{  							if (stack.Count < 4)  								return false;  							stack.Push(stack.Skip(3).First());  							stack.Push(stack.Skip(3).First());  							break;  						}  					case OpCode.OP_2ROT:  						{  							if (stack.Count < 6)  								return false;  							altstack.Push(stack.Skip(4).First());  							altstack.Push(stack.Skip(5).First());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_2SWAP:  						{  							if (stack.Count < 4)  								return false;  							altstack.Push(stack.Skip(2).First());  							altstack.Push(stack.Skip(3).First());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_IFDUP:  						{  							if (stack.Count < 1)  								return false;  							if (!new ScriptVarInt(stack.First()).value.IsZero)  								stack.Push(stack.First());  							break;  						}  					case OpCode.OP_DEPTH:  						{  							stack.Push(new ScriptVarInt((UInt64)stack.Count).ToBytes());  							break;  						}  					case OpCode.OP_DROP:  						{  							if (stack.Count < 1)  								return false;  							stack.Pop();  							break;  						}  					case OpCode.OP_DUP:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(stack.First());  							break;  						}  					case OpCode.OP_NIP:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_OVER:  						{  							if (stack.Count < 2)  								return false;  							stack.Push(stack.Skip(1).First());  							break;  						}  					case OpCode.OP_PICK:  						{  							if (stack.Count < 2)  								return false;  							int pick = new ScriptVarInt(stack.Pop()).intValue;  							if (pick < 0 || stack.Count <= pick)  								return false;  							stack.Push(stack.Skip(pick).First());  							break;  						}  					case OpCode.OP_ROLL:  						{  							if (stack.Count < 2)  								return false;  							int roll = new ScriptVarInt(stack.Pop()).intValue;  							if (roll < 0 || stack.Count <= roll)  								return false;  							altstack.Push(stack.Skip(roll).First());  							for (int i = 0; i < roll; i++)  								altstack.Push(stack.Pop());  							stack.Pop();  							for (int i = 0; i < roll + 1; i++)  								stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_ROT:  						{  							if (stack.Count < 3)  								return false;  							altstack.Push(stack.Skip(2).First());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_SWAP:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Skip(1).First());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_TUCK:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Push(altstack.Skip(1).First());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_CAT:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Skip(1).First().Concat(stack.First()).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_SUBSTR:  						{  							if (stack.Count < 3)  								return false;  							altstack.Push(stack.Skip(2).First()  								.Skip(new ScriptVarInt(stack.Skip(1).First()).intValue)  								.Take(new ScriptVarInt(stack.First()).intValue).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_LEFT:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Skip(1).First()  								.Take(new ScriptVarInt(stack.First()).intValue).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_RIGHT:  						{  							if (stack.Count < 2)  								return false;  							int count = new ScriptVarInt(stack.First()).intValue;  							altstack.Push(stack.Skip(1).First()  								.Skip(stack.Skip(1).First().Length - count).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_SIZE:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(new ScriptVarInt((UInt64)stack.First().Length).ToBytes());  							break;  						}  					case OpCode.OP_INVERT:  						{  							if (stack.Count < 1)  								return false;  							Byte[] data = stack.Pop();  							for (int i = 0; i < data.Length; i++)  								data[i] ^= 0xFF;  							stack.Push(data);  							break;  						}  					case OpCode.OP_AND:  					case OpCode.OP_OR:  					case OpCode.OP_XOR:  						{  							if (stack.Count < 2)  								return false;  							Byte[] data = stack.Pop();  							Byte[] data2 = stack.Pop();  							int length = new int[] { data.Length' data2.Length }.Max();  							data = data.Concat(new Byte[length - data.Length]).ToArray();  							data2 = data2.Concat(new Byte[length - data2.Length]).ToArray();  							switch (se.opCode)  							{  								case OpCode.OP_AND:  									{  										for (int i = 0; i < length; i++)  											data[i] &= data2[i];  										break;  									}  								case OpCode.OP_OR:  									{  										for (int i = 0; i < length; i++)  											data[i] |= data2[i];  										break;  									}  								case OpCode.OP_XOR:  									{  										for (int i = 0; i < length; i++)  											data[i] ^= data2[i];  										break;  									}  							}  							stack.Push(data);  							break;  						}  					case OpCode.OP_EQUAL:  					case OpCode.OP_EQUALVERIFY:  						{  							if (stack.Count < 2)  								return false;  							if (stack.Pop().SequenceEqual(stack.Pop()))  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });    							if (se.opCode == OpCode.OP_EQUALVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_RESERVED1:  					case OpCode.OP_RESERVED2:  						{  							return false;  						}  					case OpCode.OP_1ADD:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Add(new ScriptVarInt(stack.Pop())' 1)).ToBytes());  							break;  						}  					case OpCode.OP_1SUB:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Subtract(new ScriptVarInt(stack.Pop())' 1)).ToBytes());  							break;  						}  					case OpCode.OP_2MUL:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Multiply(new ScriptVarInt(stack.Pop())' 2)).ToBytes());  							break;  						}  					case OpCode.OP_2DIV:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Divide(new ScriptVarInt(stack.Pop())' 2)).ToBytes());  							break;  						}  					case OpCode.OP_NEGATE:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Negate(new ScriptVarInt(stack.Pop()))).ToBytes());  							break;  						}  					case OpCode.OP_ABS:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Abs(new ScriptVarInt(stack.Pop()))).ToBytes());  							break;  						}  					case OpCode.OP_NOT:  						{  							if (stack.Count < 1)  								return false;  							if (new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_0NOTEQUAL:  						{  							if (stack.Count < 1)  								return false;  							if (new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x00 });  							else  								stack.Push(new Byte[] { 0x01 });  							break;  						}  					case OpCode.OP_ADD:  					case OpCode.OP_SUB:  					case OpCode.OP_MUL:  					case OpCode.OP_DIV:  					case OpCode.OP_MOD:  					case OpCode.OP_LSHIFT:  					case OpCode.OP_RSHIFT:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							switch (se.opCode)  							{  								case OpCode.OP_ADD:  									a = (BigInteger)a + b;  									break;  								case OpCode.OP_SUB:  									a = (BigInteger)a - b;  									break;  								case OpCode.OP_MUL:  									a = (BigInteger)a * b;  									break;  								case OpCode.OP_DIV:  									a = (BigInteger)a / b;  									break;  								case OpCode.OP_MOD:  									a = (BigInteger)a % b;  									break;  								case OpCode.OP_LSHIFT:  									a = (BigInteger)a << b.intValue;  									break;  								case OpCode.OP_RSHIFT:  									a = (BigInteger)a >> b.intValue;  									break;  							}  							stack.Push(a.ToBytes());  							break;  						}  					case OpCode.OP_BOOLAND:  						{  							if (stack.Count < 2)  								return false;  							if (!new ScriptVarInt(stack.Pop()).value.IsZero && !new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_BOOLOR:  						{  							if (stack.Count < 2)  								return false;  							if (!new ScriptVarInt(stack.Pop()).value.IsZero || !new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_NUMEQUAL:  					case OpCode.OP_NUMEQUALVERIFY:  						{  							if (stack.Count < 2)  								return false;  							if (new ScriptVarInt(stack.Pop()).value == new ScriptVarInt(stack.Pop()).value)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							if (se.opCode == OpCode.OP_NUMEQUALVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_NUMNOTEQUAL:  						{  							if (stack.Count < 2)  								return false;  							if (new ScriptVarInt(stack.Pop()).value != new ScriptVarInt(stack.Pop()).value)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_LESSTHAN:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a < b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_GREATERTHAN:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a > b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_LESSTHANOREQUAL:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a <= b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_GREATERTHANOREQUAL:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a >= b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_MIN:  						{  							if (stack.Count < 2)  								return false;  							Byte[] b = stack.Pop();  							Byte[] a = stack.Pop();  							if (new ScriptVarInt(a).value < new ScriptVarInt(b).value)  								stack.Push(a);  							else  								stack.Push(b);  							break;  						}  					case OpCode.OP_MAX:  						{  							if (stack.Count < 2)  								return false;  							Byte[] b = stack.Pop();  							Byte[] a = stack.Pop();  							if (new ScriptVarInt(a).value > new ScriptVarInt(b).value)  								stack.Push(a);  							else  								stack.Push(b);  							break;  						}  					case OpCode.OP_WITHIN:  						{  							if (stack.Count < 3)  								return false;  							ScriptVarInt max = new ScriptVarInt(stack.Pop());  							ScriptVarInt min = new ScriptVarInt(stack.Pop());  							ScriptVarInt x = new ScriptVarInt(stack.Pop());  							if ((BigInteger)min <= x && (BigInteger)x <= max)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_RIPEMD160:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(ripemd160.ComputeHash(stack.Pop()));  							break;  						}  					case OpCode.OP_SHA1:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(sha1.ComputeHash(stack.Pop()));  							break;  						}  					case OpCode.OP_SHA256:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(sha256.ComputeHash(stack.Pop()));  							break;  						}  					case OpCode.OP_HASH160:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(ripemd160.ComputeHash(sha256.ComputeHash(stack.Pop())));  							break;  						}  					case OpCode.OP_HASH256:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(sha256.ComputeHash(sha256.ComputeHash(stack.Pop())));  							break;  						}  					case OpCode.OP_CODESEPARATOR:  						{  							lastCodeSeperator = index;  							break;  						}  					case OpCode.OP_CHECKSIG:  					case OpCode.OP_CHECKSIGVERIFY:  						{  							if (tx == null)  								throw new ArgumentNullException("Transaction is required if script contains OP_CHECKSIG[VERIFY]");  							if (stack.Count < 2)  								return false;    							PublicKey pubKey = new PublicKey(stack.Pop());  							Byte[] sig = stack.Pop();    							Script subScript = new Script(elements.Skip(lastCodeSeperator)  								.Where(x => x.opCode != OpCode.OP_CODESEPARATOR).ToArray());    							stack.Push(new ScriptVarInt(CheckSig(sig' pubKey' txInIndex' subScript' tx) ? 1 : 0).ToBytes());    							if (se.opCode == OpCode.OP_CHECKSIGVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_CHECKMULTISIG:  					case OpCode.OP_CHECKMULTISIGVERIFY:  						{  							if (tx == null)  								throw new ArgumentNullException("Transaction is required if script contains OP_CHECKMULTISIG[VERIFY]");  							if (stack.Count < 2)  								return false;    							PublicKey[] pubKeys = new PublicKey[new ScriptVarInt(stack.Pop()).intValue];    							if (stack.Count < pubKeys.Length + 1)  								return false;    							for (int i = 0; i < pubKeys.Length; i++)  							{  								pubKeys[i] = new PublicKey(stack.Pop());  							}    							Byte[][] sigs = new Byte[new ScriptVarInt(stack.Pop()).intValue][];    							if (stack.Count < sigs.Length)  								return false;    							for (int i = 0; i < sigs.Length; i++)  							{  								sigs[i] = stack.Pop();  							}    							// Remove extra unused value from stack  							stack.Pop();    							Script subScript = new Script(elements.Skip(lastCodeSeperator)  								.Where(x => x.opCode != OpCode.OP_CODESEPARATOR).ToArray());    							int validSigs = 0;  							foreach (Byte[] sig in sigs)  							{  								foreach (PublicKey pubKey in pubKeys)  								{  									if (CheckSig(sig' pubKey' txInIndex' subScript' tx))  									{  										pubKeys = pubKeys.Where(x => x != pubKey).ToArray();  										validSigs++;  										break;  									}  								}  							}    							stack.Push(new ScriptVarInt((validSigs >= sigs.Length) ? 1 : 0).ToBytes());    							if (se.opCode == OpCode.OP_CHECKMULTISIGVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_NOP1:  					case OpCode.OP_NOP2:  					case OpCode.OP_NOP3:  					case OpCode.OP_NOP4:  					case OpCode.OP_NOP5:  					case OpCode.OP_NOP6:  					case OpCode.OP_NOP7:  					case OpCode.OP_NOP8:  					case OpCode.OP_NOP9:  					case OpCode.OP_NOP10:  						{  							break;  						}  					case OpCode.OP_SMALLINTEGER:  					case OpCode.OP_PUBKEYS:  					case OpCode.OP_PUBKEYHASH:  					case OpCode.OP_PUBKEY:  					case OpCode.OP_INVALIDOPCODE:  					default:  						{  							return false;  						}    				}  			}
Magic Number,Bitcoin_Tool.Scripts,Script,C:\repos\mb300sd_Bitcoin-Tool\Bitcoin Tool\Scripts\Script.cs,Evaluate,The following statement contains a magic number: for (int index = 0; index < elements.Count; index++)  			{  				ScriptElement se = elements[index];  				if (ifExec.Count > 0)  					if ((ifExec.First() == IfElseExec.SKIP_IF && !(se.opCode == OpCode.OP_ELSE || se.opCode == OpCode.OP_ENDIF)) ||  						(ifExec.First() == IfElseExec.SKIP_ELSE && !(se.opCode == OpCode.OP_ENDIF)))  						continue;    				if (se.isData)  				{  					stack.Push(se.data);  					continue;  				}    				switch (se.opCode)  				{  					case OpCode.OP_RESERVED:  						{  							return false;  						}  					case OpCode.OP_NOP:  						{  							// NOP' Dump stack for debug  							/*  							stack.ToList().ForEach(x => Console.WriteLine(HexString.FromByteArray(x)));  							Console.WriteLine("---------------------------");  							*/  							break;  						}  					case OpCode.OP_VER:  						{  							return false;  						}  					case OpCode.OP_IF:  					case OpCode.OP_NOTIF:  						{  							if (stack.Count < 1)  								return false;  							Boolean stackIsZero = new ScriptVarInt(stack.Pop()).value.IsZero;  							if ((se.opCode == OpCode.OP_IF && !stackIsZero) || (se.opCode == OpCode.OP_NOTIF && stackIsZero))  							{  								// Run to else or endif  								ifExec.Push(IfElseExec.RUN_IF);  							}  							else  							{  								// Skip to else or endif  								ifExec.Push(IfElseExec.SKIP_IF);  							}  							break;  						}  					case OpCode.OP_VERIF:  					case OpCode.OP_VERNOTIF:  						{  							return false;  						}  					case OpCode.OP_ELSE:  						{  							if (ifExec.Count == 0)  								// No preceding if statement!  								return false;  							if (ifExec.First() == IfElseExec.RUN_IF)  							{  								// If ran' skip else  								ifExec.Push(IfElseExec.SKIP_ELSE);  							}  							else if (ifExec.First() == IfElseExec.SKIP_IF)  							{  								// If did not run' run else  								ifExec.Push(IfElseExec.RUN_ELSE);  							}  							break;  						}  					case OpCode.OP_ENDIF:  						{  							if (ifExec.Count == 0)  								// No preceding if statement!  								return false;  							if (ifExec.First() == IfElseExec.RUN_IF ||  								ifExec.First() == IfElseExec.SKIP_IF)  							{  								ifExec.Pop();  							}  							else if (ifExec.First() == IfElseExec.RUN_ELSE ||  							   ifExec.First() == IfElseExec.SKIP_ELSE)  							{  								ifExec.Pop();  								ifExec.Pop();  							}  							break;  						}  					case OpCode.OP_VERIFY:  						{  							if (stack.Count < 1 || new ScriptVarInt(stack.First()).value.IsZero)  								return false;  							stack.Pop();  							break;  						}  					case OpCode.OP_RETURN:  						{  							return false;  						}  					case OpCode.OP_TOALTSTACK:  						{  							if (stack.Count < 1)  								return false;  							altstack.Push(stack.Pop());  							break;  						}  					case OpCode.OP_FROMALTSTACK:  						{  							if (altstack.Count < 1)  								return false;  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_2DROP:  						{  							if (stack.Count < 2)  								return false;  							stack.Pop();  							stack.Pop();  							break;  						}  					case OpCode.OP_2DUP:  						{  							if (stack.Count < 2)  								return false;  							stack.Push(stack.Skip(1).First());  							stack.Push(stack.Skip(1).First());  							break;  						}  					case OpCode.OP_3DUP:  						{  							if (stack.Count < 3)  								return false;  							stack.Push(stack.Skip(2).First());  							stack.Push(stack.Skip(2).First());  							stack.Push(stack.Skip(2).First());  							break;  						}  					case OpCode.OP_2OVER:  						{  							if (stack.Count < 4)  								return false;  							stack.Push(stack.Skip(3).First());  							stack.Push(stack.Skip(3).First());  							break;  						}  					case OpCode.OP_2ROT:  						{  							if (stack.Count < 6)  								return false;  							altstack.Push(stack.Skip(4).First());  							altstack.Push(stack.Skip(5).First());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_2SWAP:  						{  							if (stack.Count < 4)  								return false;  							altstack.Push(stack.Skip(2).First());  							altstack.Push(stack.Skip(3).First());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_IFDUP:  						{  							if (stack.Count < 1)  								return false;  							if (!new ScriptVarInt(stack.First()).value.IsZero)  								stack.Push(stack.First());  							break;  						}  					case OpCode.OP_DEPTH:  						{  							stack.Push(new ScriptVarInt((UInt64)stack.Count).ToBytes());  							break;  						}  					case OpCode.OP_DROP:  						{  							if (stack.Count < 1)  								return false;  							stack.Pop();  							break;  						}  					case OpCode.OP_DUP:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(stack.First());  							break;  						}  					case OpCode.OP_NIP:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_OVER:  						{  							if (stack.Count < 2)  								return false;  							stack.Push(stack.Skip(1).First());  							break;  						}  					case OpCode.OP_PICK:  						{  							if (stack.Count < 2)  								return false;  							int pick = new ScriptVarInt(stack.Pop()).intValue;  							if (pick < 0 || stack.Count <= pick)  								return false;  							stack.Push(stack.Skip(pick).First());  							break;  						}  					case OpCode.OP_ROLL:  						{  							if (stack.Count < 2)  								return false;  							int roll = new ScriptVarInt(stack.Pop()).intValue;  							if (roll < 0 || stack.Count <= roll)  								return false;  							altstack.Push(stack.Skip(roll).First());  							for (int i = 0; i < roll; i++)  								altstack.Push(stack.Pop());  							stack.Pop();  							for (int i = 0; i < roll + 1; i++)  								stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_ROT:  						{  							if (stack.Count < 3)  								return false;  							altstack.Push(stack.Skip(2).First());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_SWAP:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Skip(1).First());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_TUCK:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Push(altstack.Skip(1).First());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_CAT:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Skip(1).First().Concat(stack.First()).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_SUBSTR:  						{  							if (stack.Count < 3)  								return false;  							altstack.Push(stack.Skip(2).First()  								.Skip(new ScriptVarInt(stack.Skip(1).First()).intValue)  								.Take(new ScriptVarInt(stack.First()).intValue).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_LEFT:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Skip(1).First()  								.Take(new ScriptVarInt(stack.First()).intValue).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_RIGHT:  						{  							if (stack.Count < 2)  								return false;  							int count = new ScriptVarInt(stack.First()).intValue;  							altstack.Push(stack.Skip(1).First()  								.Skip(stack.Skip(1).First().Length - count).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_SIZE:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(new ScriptVarInt((UInt64)stack.First().Length).ToBytes());  							break;  						}  					case OpCode.OP_INVERT:  						{  							if (stack.Count < 1)  								return false;  							Byte[] data = stack.Pop();  							for (int i = 0; i < data.Length; i++)  								data[i] ^= 0xFF;  							stack.Push(data);  							break;  						}  					case OpCode.OP_AND:  					case OpCode.OP_OR:  					case OpCode.OP_XOR:  						{  							if (stack.Count < 2)  								return false;  							Byte[] data = stack.Pop();  							Byte[] data2 = stack.Pop();  							int length = new int[] { data.Length' data2.Length }.Max();  							data = data.Concat(new Byte[length - data.Length]).ToArray();  							data2 = data2.Concat(new Byte[length - data2.Length]).ToArray();  							switch (se.opCode)  							{  								case OpCode.OP_AND:  									{  										for (int i = 0; i < length; i++)  											data[i] &= data2[i];  										break;  									}  								case OpCode.OP_OR:  									{  										for (int i = 0; i < length; i++)  											data[i] |= data2[i];  										break;  									}  								case OpCode.OP_XOR:  									{  										for (int i = 0; i < length; i++)  											data[i] ^= data2[i];  										break;  									}  							}  							stack.Push(data);  							break;  						}  					case OpCode.OP_EQUAL:  					case OpCode.OP_EQUALVERIFY:  						{  							if (stack.Count < 2)  								return false;  							if (stack.Pop().SequenceEqual(stack.Pop()))  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });    							if (se.opCode == OpCode.OP_EQUALVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_RESERVED1:  					case OpCode.OP_RESERVED2:  						{  							return false;  						}  					case OpCode.OP_1ADD:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Add(new ScriptVarInt(stack.Pop())' 1)).ToBytes());  							break;  						}  					case OpCode.OP_1SUB:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Subtract(new ScriptVarInt(stack.Pop())' 1)).ToBytes());  							break;  						}  					case OpCode.OP_2MUL:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Multiply(new ScriptVarInt(stack.Pop())' 2)).ToBytes());  							break;  						}  					case OpCode.OP_2DIV:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Divide(new ScriptVarInt(stack.Pop())' 2)).ToBytes());  							break;  						}  					case OpCode.OP_NEGATE:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Negate(new ScriptVarInt(stack.Pop()))).ToBytes());  							break;  						}  					case OpCode.OP_ABS:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Abs(new ScriptVarInt(stack.Pop()))).ToBytes());  							break;  						}  					case OpCode.OP_NOT:  						{  							if (stack.Count < 1)  								return false;  							if (new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_0NOTEQUAL:  						{  							if (stack.Count < 1)  								return false;  							if (new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x00 });  							else  								stack.Push(new Byte[] { 0x01 });  							break;  						}  					case OpCode.OP_ADD:  					case OpCode.OP_SUB:  					case OpCode.OP_MUL:  					case OpCode.OP_DIV:  					case OpCode.OP_MOD:  					case OpCode.OP_LSHIFT:  					case OpCode.OP_RSHIFT:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							switch (se.opCode)  							{  								case OpCode.OP_ADD:  									a = (BigInteger)a + b;  									break;  								case OpCode.OP_SUB:  									a = (BigInteger)a - b;  									break;  								case OpCode.OP_MUL:  									a = (BigInteger)a * b;  									break;  								case OpCode.OP_DIV:  									a = (BigInteger)a / b;  									break;  								case OpCode.OP_MOD:  									a = (BigInteger)a % b;  									break;  								case OpCode.OP_LSHIFT:  									a = (BigInteger)a << b.intValue;  									break;  								case OpCode.OP_RSHIFT:  									a = (BigInteger)a >> b.intValue;  									break;  							}  							stack.Push(a.ToBytes());  							break;  						}  					case OpCode.OP_BOOLAND:  						{  							if (stack.Count < 2)  								return false;  							if (!new ScriptVarInt(stack.Pop()).value.IsZero && !new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_BOOLOR:  						{  							if (stack.Count < 2)  								return false;  							if (!new ScriptVarInt(stack.Pop()).value.IsZero || !new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_NUMEQUAL:  					case OpCode.OP_NUMEQUALVERIFY:  						{  							if (stack.Count < 2)  								return false;  							if (new ScriptVarInt(stack.Pop()).value == new ScriptVarInt(stack.Pop()).value)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							if (se.opCode == OpCode.OP_NUMEQUALVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_NUMNOTEQUAL:  						{  							if (stack.Count < 2)  								return false;  							if (new ScriptVarInt(stack.Pop()).value != new ScriptVarInt(stack.Pop()).value)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_LESSTHAN:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a < b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_GREATERTHAN:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a > b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_LESSTHANOREQUAL:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a <= b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_GREATERTHANOREQUAL:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a >= b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_MIN:  						{  							if (stack.Count < 2)  								return false;  							Byte[] b = stack.Pop();  							Byte[] a = stack.Pop();  							if (new ScriptVarInt(a).value < new ScriptVarInt(b).value)  								stack.Push(a);  							else  								stack.Push(b);  							break;  						}  					case OpCode.OP_MAX:  						{  							if (stack.Count < 2)  								return false;  							Byte[] b = stack.Pop();  							Byte[] a = stack.Pop();  							if (new ScriptVarInt(a).value > new ScriptVarInt(b).value)  								stack.Push(a);  							else  								stack.Push(b);  							break;  						}  					case OpCode.OP_WITHIN:  						{  							if (stack.Count < 3)  								return false;  							ScriptVarInt max = new ScriptVarInt(stack.Pop());  							ScriptVarInt min = new ScriptVarInt(stack.Pop());  							ScriptVarInt x = new ScriptVarInt(stack.Pop());  							if ((BigInteger)min <= x && (BigInteger)x <= max)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_RIPEMD160:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(ripemd160.ComputeHash(stack.Pop()));  							break;  						}  					case OpCode.OP_SHA1:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(sha1.ComputeHash(stack.Pop()));  							break;  						}  					case OpCode.OP_SHA256:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(sha256.ComputeHash(stack.Pop()));  							break;  						}  					case OpCode.OP_HASH160:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(ripemd160.ComputeHash(sha256.ComputeHash(stack.Pop())));  							break;  						}  					case OpCode.OP_HASH256:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(sha256.ComputeHash(sha256.ComputeHash(stack.Pop())));  							break;  						}  					case OpCode.OP_CODESEPARATOR:  						{  							lastCodeSeperator = index;  							break;  						}  					case OpCode.OP_CHECKSIG:  					case OpCode.OP_CHECKSIGVERIFY:  						{  							if (tx == null)  								throw new ArgumentNullException("Transaction is required if script contains OP_CHECKSIG[VERIFY]");  							if (stack.Count < 2)  								return false;    							PublicKey pubKey = new PublicKey(stack.Pop());  							Byte[] sig = stack.Pop();    							Script subScript = new Script(elements.Skip(lastCodeSeperator)  								.Where(x => x.opCode != OpCode.OP_CODESEPARATOR).ToArray());    							stack.Push(new ScriptVarInt(CheckSig(sig' pubKey' txInIndex' subScript' tx) ? 1 : 0).ToBytes());    							if (se.opCode == OpCode.OP_CHECKSIGVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_CHECKMULTISIG:  					case OpCode.OP_CHECKMULTISIGVERIFY:  						{  							if (tx == null)  								throw new ArgumentNullException("Transaction is required if script contains OP_CHECKMULTISIG[VERIFY]");  							if (stack.Count < 2)  								return false;    							PublicKey[] pubKeys = new PublicKey[new ScriptVarInt(stack.Pop()).intValue];    							if (stack.Count < pubKeys.Length + 1)  								return false;    							for (int i = 0; i < pubKeys.Length; i++)  							{  								pubKeys[i] = new PublicKey(stack.Pop());  							}    							Byte[][] sigs = new Byte[new ScriptVarInt(stack.Pop()).intValue][];    							if (stack.Count < sigs.Length)  								return false;    							for (int i = 0; i < sigs.Length; i++)  							{  								sigs[i] = stack.Pop();  							}    							// Remove extra unused value from stack  							stack.Pop();    							Script subScript = new Script(elements.Skip(lastCodeSeperator)  								.Where(x => x.opCode != OpCode.OP_CODESEPARATOR).ToArray());    							int validSigs = 0;  							foreach (Byte[] sig in sigs)  							{  								foreach (PublicKey pubKey in pubKeys)  								{  									if (CheckSig(sig' pubKey' txInIndex' subScript' tx))  									{  										pubKeys = pubKeys.Where(x => x != pubKey).ToArray();  										validSigs++;  										break;  									}  								}  							}    							stack.Push(new ScriptVarInt((validSigs >= sigs.Length) ? 1 : 0).ToBytes());    							if (se.opCode == OpCode.OP_CHECKMULTISIGVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_NOP1:  					case OpCode.OP_NOP2:  					case OpCode.OP_NOP3:  					case OpCode.OP_NOP4:  					case OpCode.OP_NOP5:  					case OpCode.OP_NOP6:  					case OpCode.OP_NOP7:  					case OpCode.OP_NOP8:  					case OpCode.OP_NOP9:  					case OpCode.OP_NOP10:  						{  							break;  						}  					case OpCode.OP_SMALLINTEGER:  					case OpCode.OP_PUBKEYS:  					case OpCode.OP_PUBKEYHASH:  					case OpCode.OP_PUBKEY:  					case OpCode.OP_INVALIDOPCODE:  					default:  						{  							return false;  						}    				}  			}
Magic Number,Bitcoin_Tool.Scripts,Script,C:\repos\mb300sd_Bitcoin-Tool\Bitcoin Tool\Scripts\Script.cs,Evaluate,The following statement contains a magic number: for (int index = 0; index < elements.Count; index++)  			{  				ScriptElement se = elements[index];  				if (ifExec.Count > 0)  					if ((ifExec.First() == IfElseExec.SKIP_IF && !(se.opCode == OpCode.OP_ELSE || se.opCode == OpCode.OP_ENDIF)) ||  						(ifExec.First() == IfElseExec.SKIP_ELSE && !(se.opCode == OpCode.OP_ENDIF)))  						continue;    				if (se.isData)  				{  					stack.Push(se.data);  					continue;  				}    				switch (se.opCode)  				{  					case OpCode.OP_RESERVED:  						{  							return false;  						}  					case OpCode.OP_NOP:  						{  							// NOP' Dump stack for debug  							/*  							stack.ToList().ForEach(x => Console.WriteLine(HexString.FromByteArray(x)));  							Console.WriteLine("---------------------------");  							*/  							break;  						}  					case OpCode.OP_VER:  						{  							return false;  						}  					case OpCode.OP_IF:  					case OpCode.OP_NOTIF:  						{  							if (stack.Count < 1)  								return false;  							Boolean stackIsZero = new ScriptVarInt(stack.Pop()).value.IsZero;  							if ((se.opCode == OpCode.OP_IF && !stackIsZero) || (se.opCode == OpCode.OP_NOTIF && stackIsZero))  							{  								// Run to else or endif  								ifExec.Push(IfElseExec.RUN_IF);  							}  							else  							{  								// Skip to else or endif  								ifExec.Push(IfElseExec.SKIP_IF);  							}  							break;  						}  					case OpCode.OP_VERIF:  					case OpCode.OP_VERNOTIF:  						{  							return false;  						}  					case OpCode.OP_ELSE:  						{  							if (ifExec.Count == 0)  								// No preceding if statement!  								return false;  							if (ifExec.First() == IfElseExec.RUN_IF)  							{  								// If ran' skip else  								ifExec.Push(IfElseExec.SKIP_ELSE);  							}  							else if (ifExec.First() == IfElseExec.SKIP_IF)  							{  								// If did not run' run else  								ifExec.Push(IfElseExec.RUN_ELSE);  							}  							break;  						}  					case OpCode.OP_ENDIF:  						{  							if (ifExec.Count == 0)  								// No preceding if statement!  								return false;  							if (ifExec.First() == IfElseExec.RUN_IF ||  								ifExec.First() == IfElseExec.SKIP_IF)  							{  								ifExec.Pop();  							}  							else if (ifExec.First() == IfElseExec.RUN_ELSE ||  							   ifExec.First() == IfElseExec.SKIP_ELSE)  							{  								ifExec.Pop();  								ifExec.Pop();  							}  							break;  						}  					case OpCode.OP_VERIFY:  						{  							if (stack.Count < 1 || new ScriptVarInt(stack.First()).value.IsZero)  								return false;  							stack.Pop();  							break;  						}  					case OpCode.OP_RETURN:  						{  							return false;  						}  					case OpCode.OP_TOALTSTACK:  						{  							if (stack.Count < 1)  								return false;  							altstack.Push(stack.Pop());  							break;  						}  					case OpCode.OP_FROMALTSTACK:  						{  							if (altstack.Count < 1)  								return false;  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_2DROP:  						{  							if (stack.Count < 2)  								return false;  							stack.Pop();  							stack.Pop();  							break;  						}  					case OpCode.OP_2DUP:  						{  							if (stack.Count < 2)  								return false;  							stack.Push(stack.Skip(1).First());  							stack.Push(stack.Skip(1).First());  							break;  						}  					case OpCode.OP_3DUP:  						{  							if (stack.Count < 3)  								return false;  							stack.Push(stack.Skip(2).First());  							stack.Push(stack.Skip(2).First());  							stack.Push(stack.Skip(2).First());  							break;  						}  					case OpCode.OP_2OVER:  						{  							if (stack.Count < 4)  								return false;  							stack.Push(stack.Skip(3).First());  							stack.Push(stack.Skip(3).First());  							break;  						}  					case OpCode.OP_2ROT:  						{  							if (stack.Count < 6)  								return false;  							altstack.Push(stack.Skip(4).First());  							altstack.Push(stack.Skip(5).First());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_2SWAP:  						{  							if (stack.Count < 4)  								return false;  							altstack.Push(stack.Skip(2).First());  							altstack.Push(stack.Skip(3).First());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_IFDUP:  						{  							if (stack.Count < 1)  								return false;  							if (!new ScriptVarInt(stack.First()).value.IsZero)  								stack.Push(stack.First());  							break;  						}  					case OpCode.OP_DEPTH:  						{  							stack.Push(new ScriptVarInt((UInt64)stack.Count).ToBytes());  							break;  						}  					case OpCode.OP_DROP:  						{  							if (stack.Count < 1)  								return false;  							stack.Pop();  							break;  						}  					case OpCode.OP_DUP:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(stack.First());  							break;  						}  					case OpCode.OP_NIP:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_OVER:  						{  							if (stack.Count < 2)  								return false;  							stack.Push(stack.Skip(1).First());  							break;  						}  					case OpCode.OP_PICK:  						{  							if (stack.Count < 2)  								return false;  							int pick = new ScriptVarInt(stack.Pop()).intValue;  							if (pick < 0 || stack.Count <= pick)  								return false;  							stack.Push(stack.Skip(pick).First());  							break;  						}  					case OpCode.OP_ROLL:  						{  							if (stack.Count < 2)  								return false;  							int roll = new ScriptVarInt(stack.Pop()).intValue;  							if (roll < 0 || stack.Count <= roll)  								return false;  							altstack.Push(stack.Skip(roll).First());  							for (int i = 0; i < roll; i++)  								altstack.Push(stack.Pop());  							stack.Pop();  							for (int i = 0; i < roll + 1; i++)  								stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_ROT:  						{  							if (stack.Count < 3)  								return false;  							altstack.Push(stack.Skip(2).First());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_SWAP:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Skip(1).First());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_TUCK:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Push(altstack.Skip(1).First());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_CAT:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Skip(1).First().Concat(stack.First()).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_SUBSTR:  						{  							if (stack.Count < 3)  								return false;  							altstack.Push(stack.Skip(2).First()  								.Skip(new ScriptVarInt(stack.Skip(1).First()).intValue)  								.Take(new ScriptVarInt(stack.First()).intValue).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_LEFT:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Skip(1).First()  								.Take(new ScriptVarInt(stack.First()).intValue).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_RIGHT:  						{  							if (stack.Count < 2)  								return false;  							int count = new ScriptVarInt(stack.First()).intValue;  							altstack.Push(stack.Skip(1).First()  								.Skip(stack.Skip(1).First().Length - count).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_SIZE:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(new ScriptVarInt((UInt64)stack.First().Length).ToBytes());  							break;  						}  					case OpCode.OP_INVERT:  						{  							if (stack.Count < 1)  								return false;  							Byte[] data = stack.Pop();  							for (int i = 0; i < data.Length; i++)  								data[i] ^= 0xFF;  							stack.Push(data);  							break;  						}  					case OpCode.OP_AND:  					case OpCode.OP_OR:  					case OpCode.OP_XOR:  						{  							if (stack.Count < 2)  								return false;  							Byte[] data = stack.Pop();  							Byte[] data2 = stack.Pop();  							int length = new int[] { data.Length' data2.Length }.Max();  							data = data.Concat(new Byte[length - data.Length]).ToArray();  							data2 = data2.Concat(new Byte[length - data2.Length]).ToArray();  							switch (se.opCode)  							{  								case OpCode.OP_AND:  									{  										for (int i = 0; i < length; i++)  											data[i] &= data2[i];  										break;  									}  								case OpCode.OP_OR:  									{  										for (int i = 0; i < length; i++)  											data[i] |= data2[i];  										break;  									}  								case OpCode.OP_XOR:  									{  										for (int i = 0; i < length; i++)  											data[i] ^= data2[i];  										break;  									}  							}  							stack.Push(data);  							break;  						}  					case OpCode.OP_EQUAL:  					case OpCode.OP_EQUALVERIFY:  						{  							if (stack.Count < 2)  								return false;  							if (stack.Pop().SequenceEqual(stack.Pop()))  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });    							if (se.opCode == OpCode.OP_EQUALVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_RESERVED1:  					case OpCode.OP_RESERVED2:  						{  							return false;  						}  					case OpCode.OP_1ADD:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Add(new ScriptVarInt(stack.Pop())' 1)).ToBytes());  							break;  						}  					case OpCode.OP_1SUB:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Subtract(new ScriptVarInt(stack.Pop())' 1)).ToBytes());  							break;  						}  					case OpCode.OP_2MUL:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Multiply(new ScriptVarInt(stack.Pop())' 2)).ToBytes());  							break;  						}  					case OpCode.OP_2DIV:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Divide(new ScriptVarInt(stack.Pop())' 2)).ToBytes());  							break;  						}  					case OpCode.OP_NEGATE:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Negate(new ScriptVarInt(stack.Pop()))).ToBytes());  							break;  						}  					case OpCode.OP_ABS:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Abs(new ScriptVarInt(stack.Pop()))).ToBytes());  							break;  						}  					case OpCode.OP_NOT:  						{  							if (stack.Count < 1)  								return false;  							if (new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_0NOTEQUAL:  						{  							if (stack.Count < 1)  								return false;  							if (new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x00 });  							else  								stack.Push(new Byte[] { 0x01 });  							break;  						}  					case OpCode.OP_ADD:  					case OpCode.OP_SUB:  					case OpCode.OP_MUL:  					case OpCode.OP_DIV:  					case OpCode.OP_MOD:  					case OpCode.OP_LSHIFT:  					case OpCode.OP_RSHIFT:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							switch (se.opCode)  							{  								case OpCode.OP_ADD:  									a = (BigInteger)a + b;  									break;  								case OpCode.OP_SUB:  									a = (BigInteger)a - b;  									break;  								case OpCode.OP_MUL:  									a = (BigInteger)a * b;  									break;  								case OpCode.OP_DIV:  									a = (BigInteger)a / b;  									break;  								case OpCode.OP_MOD:  									a = (BigInteger)a % b;  									break;  								case OpCode.OP_LSHIFT:  									a = (BigInteger)a << b.intValue;  									break;  								case OpCode.OP_RSHIFT:  									a = (BigInteger)a >> b.intValue;  									break;  							}  							stack.Push(a.ToBytes());  							break;  						}  					case OpCode.OP_BOOLAND:  						{  							if (stack.Count < 2)  								return false;  							if (!new ScriptVarInt(stack.Pop()).value.IsZero && !new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_BOOLOR:  						{  							if (stack.Count < 2)  								return false;  							if (!new ScriptVarInt(stack.Pop()).value.IsZero || !new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_NUMEQUAL:  					case OpCode.OP_NUMEQUALVERIFY:  						{  							if (stack.Count < 2)  								return false;  							if (new ScriptVarInt(stack.Pop()).value == new ScriptVarInt(stack.Pop()).value)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							if (se.opCode == OpCode.OP_NUMEQUALVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_NUMNOTEQUAL:  						{  							if (stack.Count < 2)  								return false;  							if (new ScriptVarInt(stack.Pop()).value != new ScriptVarInt(stack.Pop()).value)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_LESSTHAN:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a < b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_GREATERTHAN:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a > b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_LESSTHANOREQUAL:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a <= b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_GREATERTHANOREQUAL:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a >= b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_MIN:  						{  							if (stack.Count < 2)  								return false;  							Byte[] b = stack.Pop();  							Byte[] a = stack.Pop();  							if (new ScriptVarInt(a).value < new ScriptVarInt(b).value)  								stack.Push(a);  							else  								stack.Push(b);  							break;  						}  					case OpCode.OP_MAX:  						{  							if (stack.Count < 2)  								return false;  							Byte[] b = stack.Pop();  							Byte[] a = stack.Pop();  							if (new ScriptVarInt(a).value > new ScriptVarInt(b).value)  								stack.Push(a);  							else  								stack.Push(b);  							break;  						}  					case OpCode.OP_WITHIN:  						{  							if (stack.Count < 3)  								return false;  							ScriptVarInt max = new ScriptVarInt(stack.Pop());  							ScriptVarInt min = new ScriptVarInt(stack.Pop());  							ScriptVarInt x = new ScriptVarInt(stack.Pop());  							if ((BigInteger)min <= x && (BigInteger)x <= max)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_RIPEMD160:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(ripemd160.ComputeHash(stack.Pop()));  							break;  						}  					case OpCode.OP_SHA1:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(sha1.ComputeHash(stack.Pop()));  							break;  						}  					case OpCode.OP_SHA256:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(sha256.ComputeHash(stack.Pop()));  							break;  						}  					case OpCode.OP_HASH160:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(ripemd160.ComputeHash(sha256.ComputeHash(stack.Pop())));  							break;  						}  					case OpCode.OP_HASH256:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(sha256.ComputeHash(sha256.ComputeHash(stack.Pop())));  							break;  						}  					case OpCode.OP_CODESEPARATOR:  						{  							lastCodeSeperator = index;  							break;  						}  					case OpCode.OP_CHECKSIG:  					case OpCode.OP_CHECKSIGVERIFY:  						{  							if (tx == null)  								throw new ArgumentNullException("Transaction is required if script contains OP_CHECKSIG[VERIFY]");  							if (stack.Count < 2)  								return false;    							PublicKey pubKey = new PublicKey(stack.Pop());  							Byte[] sig = stack.Pop();    							Script subScript = new Script(elements.Skip(lastCodeSeperator)  								.Where(x => x.opCode != OpCode.OP_CODESEPARATOR).ToArray());    							stack.Push(new ScriptVarInt(CheckSig(sig' pubKey' txInIndex' subScript' tx) ? 1 : 0).ToBytes());    							if (se.opCode == OpCode.OP_CHECKSIGVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_CHECKMULTISIG:  					case OpCode.OP_CHECKMULTISIGVERIFY:  						{  							if (tx == null)  								throw new ArgumentNullException("Transaction is required if script contains OP_CHECKMULTISIG[VERIFY]");  							if (stack.Count < 2)  								return false;    							PublicKey[] pubKeys = new PublicKey[new ScriptVarInt(stack.Pop()).intValue];    							if (stack.Count < pubKeys.Length + 1)  								return false;    							for (int i = 0; i < pubKeys.Length; i++)  							{  								pubKeys[i] = new PublicKey(stack.Pop());  							}    							Byte[][] sigs = new Byte[new ScriptVarInt(stack.Pop()).intValue][];    							if (stack.Count < sigs.Length)  								return false;    							for (int i = 0; i < sigs.Length; i++)  							{  								sigs[i] = stack.Pop();  							}    							// Remove extra unused value from stack  							stack.Pop();    							Script subScript = new Script(elements.Skip(lastCodeSeperator)  								.Where(x => x.opCode != OpCode.OP_CODESEPARATOR).ToArray());    							int validSigs = 0;  							foreach (Byte[] sig in sigs)  							{  								foreach (PublicKey pubKey in pubKeys)  								{  									if (CheckSig(sig' pubKey' txInIndex' subScript' tx))  									{  										pubKeys = pubKeys.Where(x => x != pubKey).ToArray();  										validSigs++;  										break;  									}  								}  							}    							stack.Push(new ScriptVarInt((validSigs >= sigs.Length) ? 1 : 0).ToBytes());    							if (se.opCode == OpCode.OP_CHECKMULTISIGVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_NOP1:  					case OpCode.OP_NOP2:  					case OpCode.OP_NOP3:  					case OpCode.OP_NOP4:  					case OpCode.OP_NOP5:  					case OpCode.OP_NOP6:  					case OpCode.OP_NOP7:  					case OpCode.OP_NOP8:  					case OpCode.OP_NOP9:  					case OpCode.OP_NOP10:  						{  							break;  						}  					case OpCode.OP_SMALLINTEGER:  					case OpCode.OP_PUBKEYS:  					case OpCode.OP_PUBKEYHASH:  					case OpCode.OP_PUBKEY:  					case OpCode.OP_INVALIDOPCODE:  					default:  						{  							return false;  						}    				}  			}
Magic Number,Bitcoin_Tool.Scripts,Script,C:\repos\mb300sd_Bitcoin-Tool\Bitcoin Tool\Scripts\Script.cs,Evaluate,The following statement contains a magic number: for (int index = 0; index < elements.Count; index++)  			{  				ScriptElement se = elements[index];  				if (ifExec.Count > 0)  					if ((ifExec.First() == IfElseExec.SKIP_IF && !(se.opCode == OpCode.OP_ELSE || se.opCode == OpCode.OP_ENDIF)) ||  						(ifExec.First() == IfElseExec.SKIP_ELSE && !(se.opCode == OpCode.OP_ENDIF)))  						continue;    				if (se.isData)  				{  					stack.Push(se.data);  					continue;  				}    				switch (se.opCode)  				{  					case OpCode.OP_RESERVED:  						{  							return false;  						}  					case OpCode.OP_NOP:  						{  							// NOP' Dump stack for debug  							/*  							stack.ToList().ForEach(x => Console.WriteLine(HexString.FromByteArray(x)));  							Console.WriteLine("---------------------------");  							*/  							break;  						}  					case OpCode.OP_VER:  						{  							return false;  						}  					case OpCode.OP_IF:  					case OpCode.OP_NOTIF:  						{  							if (stack.Count < 1)  								return false;  							Boolean stackIsZero = new ScriptVarInt(stack.Pop()).value.IsZero;  							if ((se.opCode == OpCode.OP_IF && !stackIsZero) || (se.opCode == OpCode.OP_NOTIF && stackIsZero))  							{  								// Run to else or endif  								ifExec.Push(IfElseExec.RUN_IF);  							}  							else  							{  								// Skip to else or endif  								ifExec.Push(IfElseExec.SKIP_IF);  							}  							break;  						}  					case OpCode.OP_VERIF:  					case OpCode.OP_VERNOTIF:  						{  							return false;  						}  					case OpCode.OP_ELSE:  						{  							if (ifExec.Count == 0)  								// No preceding if statement!  								return false;  							if (ifExec.First() == IfElseExec.RUN_IF)  							{  								// If ran' skip else  								ifExec.Push(IfElseExec.SKIP_ELSE);  							}  							else if (ifExec.First() == IfElseExec.SKIP_IF)  							{  								// If did not run' run else  								ifExec.Push(IfElseExec.RUN_ELSE);  							}  							break;  						}  					case OpCode.OP_ENDIF:  						{  							if (ifExec.Count == 0)  								// No preceding if statement!  								return false;  							if (ifExec.First() == IfElseExec.RUN_IF ||  								ifExec.First() == IfElseExec.SKIP_IF)  							{  								ifExec.Pop();  							}  							else if (ifExec.First() == IfElseExec.RUN_ELSE ||  							   ifExec.First() == IfElseExec.SKIP_ELSE)  							{  								ifExec.Pop();  								ifExec.Pop();  							}  							break;  						}  					case OpCode.OP_VERIFY:  						{  							if (stack.Count < 1 || new ScriptVarInt(stack.First()).value.IsZero)  								return false;  							stack.Pop();  							break;  						}  					case OpCode.OP_RETURN:  						{  							return false;  						}  					case OpCode.OP_TOALTSTACK:  						{  							if (stack.Count < 1)  								return false;  							altstack.Push(stack.Pop());  							break;  						}  					case OpCode.OP_FROMALTSTACK:  						{  							if (altstack.Count < 1)  								return false;  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_2DROP:  						{  							if (stack.Count < 2)  								return false;  							stack.Pop();  							stack.Pop();  							break;  						}  					case OpCode.OP_2DUP:  						{  							if (stack.Count < 2)  								return false;  							stack.Push(stack.Skip(1).First());  							stack.Push(stack.Skip(1).First());  							break;  						}  					case OpCode.OP_3DUP:  						{  							if (stack.Count < 3)  								return false;  							stack.Push(stack.Skip(2).First());  							stack.Push(stack.Skip(2).First());  							stack.Push(stack.Skip(2).First());  							break;  						}  					case OpCode.OP_2OVER:  						{  							if (stack.Count < 4)  								return false;  							stack.Push(stack.Skip(3).First());  							stack.Push(stack.Skip(3).First());  							break;  						}  					case OpCode.OP_2ROT:  						{  							if (stack.Count < 6)  								return false;  							altstack.Push(stack.Skip(4).First());  							altstack.Push(stack.Skip(5).First());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_2SWAP:  						{  							if (stack.Count < 4)  								return false;  							altstack.Push(stack.Skip(2).First());  							altstack.Push(stack.Skip(3).First());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_IFDUP:  						{  							if (stack.Count < 1)  								return false;  							if (!new ScriptVarInt(stack.First()).value.IsZero)  								stack.Push(stack.First());  							break;  						}  					case OpCode.OP_DEPTH:  						{  							stack.Push(new ScriptVarInt((UInt64)stack.Count).ToBytes());  							break;  						}  					case OpCode.OP_DROP:  						{  							if (stack.Count < 1)  								return false;  							stack.Pop();  							break;  						}  					case OpCode.OP_DUP:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(stack.First());  							break;  						}  					case OpCode.OP_NIP:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_OVER:  						{  							if (stack.Count < 2)  								return false;  							stack.Push(stack.Skip(1).First());  							break;  						}  					case OpCode.OP_PICK:  						{  							if (stack.Count < 2)  								return false;  							int pick = new ScriptVarInt(stack.Pop()).intValue;  							if (pick < 0 || stack.Count <= pick)  								return false;  							stack.Push(stack.Skip(pick).First());  							break;  						}  					case OpCode.OP_ROLL:  						{  							if (stack.Count < 2)  								return false;  							int roll = new ScriptVarInt(stack.Pop()).intValue;  							if (roll < 0 || stack.Count <= roll)  								return false;  							altstack.Push(stack.Skip(roll).First());  							for (int i = 0; i < roll; i++)  								altstack.Push(stack.Pop());  							stack.Pop();  							for (int i = 0; i < roll + 1; i++)  								stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_ROT:  						{  							if (stack.Count < 3)  								return false;  							altstack.Push(stack.Skip(2).First());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_SWAP:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Skip(1).First());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_TUCK:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Push(altstack.Skip(1).First());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_CAT:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Skip(1).First().Concat(stack.First()).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_SUBSTR:  						{  							if (stack.Count < 3)  								return false;  							altstack.Push(stack.Skip(2).First()  								.Skip(new ScriptVarInt(stack.Skip(1).First()).intValue)  								.Take(new ScriptVarInt(stack.First()).intValue).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_LEFT:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Skip(1).First()  								.Take(new ScriptVarInt(stack.First()).intValue).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_RIGHT:  						{  							if (stack.Count < 2)  								return false;  							int count = new ScriptVarInt(stack.First()).intValue;  							altstack.Push(stack.Skip(1).First()  								.Skip(stack.Skip(1).First().Length - count).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_SIZE:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(new ScriptVarInt((UInt64)stack.First().Length).ToBytes());  							break;  						}  					case OpCode.OP_INVERT:  						{  							if (stack.Count < 1)  								return false;  							Byte[] data = stack.Pop();  							for (int i = 0; i < data.Length; i++)  								data[i] ^= 0xFF;  							stack.Push(data);  							break;  						}  					case OpCode.OP_AND:  					case OpCode.OP_OR:  					case OpCode.OP_XOR:  						{  							if (stack.Count < 2)  								return false;  							Byte[] data = stack.Pop();  							Byte[] data2 = stack.Pop();  							int length = new int[] { data.Length' data2.Length }.Max();  							data = data.Concat(new Byte[length - data.Length]).ToArray();  							data2 = data2.Concat(new Byte[length - data2.Length]).ToArray();  							switch (se.opCode)  							{  								case OpCode.OP_AND:  									{  										for (int i = 0; i < length; i++)  											data[i] &= data2[i];  										break;  									}  								case OpCode.OP_OR:  									{  										for (int i = 0; i < length; i++)  											data[i] |= data2[i];  										break;  									}  								case OpCode.OP_XOR:  									{  										for (int i = 0; i < length; i++)  											data[i] ^= data2[i];  										break;  									}  							}  							stack.Push(data);  							break;  						}  					case OpCode.OP_EQUAL:  					case OpCode.OP_EQUALVERIFY:  						{  							if (stack.Count < 2)  								return false;  							if (stack.Pop().SequenceEqual(stack.Pop()))  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });    							if (se.opCode == OpCode.OP_EQUALVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_RESERVED1:  					case OpCode.OP_RESERVED2:  						{  							return false;  						}  					case OpCode.OP_1ADD:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Add(new ScriptVarInt(stack.Pop())' 1)).ToBytes());  							break;  						}  					case OpCode.OP_1SUB:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Subtract(new ScriptVarInt(stack.Pop())' 1)).ToBytes());  							break;  						}  					case OpCode.OP_2MUL:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Multiply(new ScriptVarInt(stack.Pop())' 2)).ToBytes());  							break;  						}  					case OpCode.OP_2DIV:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Divide(new ScriptVarInt(stack.Pop())' 2)).ToBytes());  							break;  						}  					case OpCode.OP_NEGATE:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Negate(new ScriptVarInt(stack.Pop()))).ToBytes());  							break;  						}  					case OpCode.OP_ABS:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Abs(new ScriptVarInt(stack.Pop()))).ToBytes());  							break;  						}  					case OpCode.OP_NOT:  						{  							if (stack.Count < 1)  								return false;  							if (new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_0NOTEQUAL:  						{  							if (stack.Count < 1)  								return false;  							if (new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x00 });  							else  								stack.Push(new Byte[] { 0x01 });  							break;  						}  					case OpCode.OP_ADD:  					case OpCode.OP_SUB:  					case OpCode.OP_MUL:  					case OpCode.OP_DIV:  					case OpCode.OP_MOD:  					case OpCode.OP_LSHIFT:  					case OpCode.OP_RSHIFT:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							switch (se.opCode)  							{  								case OpCode.OP_ADD:  									a = (BigInteger)a + b;  									break;  								case OpCode.OP_SUB:  									a = (BigInteger)a - b;  									break;  								case OpCode.OP_MUL:  									a = (BigInteger)a * b;  									break;  								case OpCode.OP_DIV:  									a = (BigInteger)a / b;  									break;  								case OpCode.OP_MOD:  									a = (BigInteger)a % b;  									break;  								case OpCode.OP_LSHIFT:  									a = (BigInteger)a << b.intValue;  									break;  								case OpCode.OP_RSHIFT:  									a = (BigInteger)a >> b.intValue;  									break;  							}  							stack.Push(a.ToBytes());  							break;  						}  					case OpCode.OP_BOOLAND:  						{  							if (stack.Count < 2)  								return false;  							if (!new ScriptVarInt(stack.Pop()).value.IsZero && !new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_BOOLOR:  						{  							if (stack.Count < 2)  								return false;  							if (!new ScriptVarInt(stack.Pop()).value.IsZero || !new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_NUMEQUAL:  					case OpCode.OP_NUMEQUALVERIFY:  						{  							if (stack.Count < 2)  								return false;  							if (new ScriptVarInt(stack.Pop()).value == new ScriptVarInt(stack.Pop()).value)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							if (se.opCode == OpCode.OP_NUMEQUALVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_NUMNOTEQUAL:  						{  							if (stack.Count < 2)  								return false;  							if (new ScriptVarInt(stack.Pop()).value != new ScriptVarInt(stack.Pop()).value)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_LESSTHAN:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a < b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_GREATERTHAN:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a > b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_LESSTHANOREQUAL:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a <= b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_GREATERTHANOREQUAL:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a >= b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_MIN:  						{  							if (stack.Count < 2)  								return false;  							Byte[] b = stack.Pop();  							Byte[] a = stack.Pop();  							if (new ScriptVarInt(a).value < new ScriptVarInt(b).value)  								stack.Push(a);  							else  								stack.Push(b);  							break;  						}  					case OpCode.OP_MAX:  						{  							if (stack.Count < 2)  								return false;  							Byte[] b = stack.Pop();  							Byte[] a = stack.Pop();  							if (new ScriptVarInt(a).value > new ScriptVarInt(b).value)  								stack.Push(a);  							else  								stack.Push(b);  							break;  						}  					case OpCode.OP_WITHIN:  						{  							if (stack.Count < 3)  								return false;  							ScriptVarInt max = new ScriptVarInt(stack.Pop());  							ScriptVarInt min = new ScriptVarInt(stack.Pop());  							ScriptVarInt x = new ScriptVarInt(stack.Pop());  							if ((BigInteger)min <= x && (BigInteger)x <= max)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_RIPEMD160:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(ripemd160.ComputeHash(stack.Pop()));  							break;  						}  					case OpCode.OP_SHA1:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(sha1.ComputeHash(stack.Pop()));  							break;  						}  					case OpCode.OP_SHA256:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(sha256.ComputeHash(stack.Pop()));  							break;  						}  					case OpCode.OP_HASH160:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(ripemd160.ComputeHash(sha256.ComputeHash(stack.Pop())));  							break;  						}  					case OpCode.OP_HASH256:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(sha256.ComputeHash(sha256.ComputeHash(stack.Pop())));  							break;  						}  					case OpCode.OP_CODESEPARATOR:  						{  							lastCodeSeperator = index;  							break;  						}  					case OpCode.OP_CHECKSIG:  					case OpCode.OP_CHECKSIGVERIFY:  						{  							if (tx == null)  								throw new ArgumentNullException("Transaction is required if script contains OP_CHECKSIG[VERIFY]");  							if (stack.Count < 2)  								return false;    							PublicKey pubKey = new PublicKey(stack.Pop());  							Byte[] sig = stack.Pop();    							Script subScript = new Script(elements.Skip(lastCodeSeperator)  								.Where(x => x.opCode != OpCode.OP_CODESEPARATOR).ToArray());    							stack.Push(new ScriptVarInt(CheckSig(sig' pubKey' txInIndex' subScript' tx) ? 1 : 0).ToBytes());    							if (se.opCode == OpCode.OP_CHECKSIGVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_CHECKMULTISIG:  					case OpCode.OP_CHECKMULTISIGVERIFY:  						{  							if (tx == null)  								throw new ArgumentNullException("Transaction is required if script contains OP_CHECKMULTISIG[VERIFY]");  							if (stack.Count < 2)  								return false;    							PublicKey[] pubKeys = new PublicKey[new ScriptVarInt(stack.Pop()).intValue];    							if (stack.Count < pubKeys.Length + 1)  								return false;    							for (int i = 0; i < pubKeys.Length; i++)  							{  								pubKeys[i] = new PublicKey(stack.Pop());  							}    							Byte[][] sigs = new Byte[new ScriptVarInt(stack.Pop()).intValue][];    							if (stack.Count < sigs.Length)  								return false;    							for (int i = 0; i < sigs.Length; i++)  							{  								sigs[i] = stack.Pop();  							}    							// Remove extra unused value from stack  							stack.Pop();    							Script subScript = new Script(elements.Skip(lastCodeSeperator)  								.Where(x => x.opCode != OpCode.OP_CODESEPARATOR).ToArray());    							int validSigs = 0;  							foreach (Byte[] sig in sigs)  							{  								foreach (PublicKey pubKey in pubKeys)  								{  									if (CheckSig(sig' pubKey' txInIndex' subScript' tx))  									{  										pubKeys = pubKeys.Where(x => x != pubKey).ToArray();  										validSigs++;  										break;  									}  								}  							}    							stack.Push(new ScriptVarInt((validSigs >= sigs.Length) ? 1 : 0).ToBytes());    							if (se.opCode == OpCode.OP_CHECKMULTISIGVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_NOP1:  					case OpCode.OP_NOP2:  					case OpCode.OP_NOP3:  					case OpCode.OP_NOP4:  					case OpCode.OP_NOP5:  					case OpCode.OP_NOP6:  					case OpCode.OP_NOP7:  					case OpCode.OP_NOP8:  					case OpCode.OP_NOP9:  					case OpCode.OP_NOP10:  						{  							break;  						}  					case OpCode.OP_SMALLINTEGER:  					case OpCode.OP_PUBKEYS:  					case OpCode.OP_PUBKEYHASH:  					case OpCode.OP_PUBKEY:  					case OpCode.OP_INVALIDOPCODE:  					default:  						{  							return false;  						}    				}  			}
Magic Number,Bitcoin_Tool.Scripts,Script,C:\repos\mb300sd_Bitcoin-Tool\Bitcoin Tool\Scripts\Script.cs,Evaluate,The following statement contains a magic number: for (int index = 0; index < elements.Count; index++)  			{  				ScriptElement se = elements[index];  				if (ifExec.Count > 0)  					if ((ifExec.First() == IfElseExec.SKIP_IF && !(se.opCode == OpCode.OP_ELSE || se.opCode == OpCode.OP_ENDIF)) ||  						(ifExec.First() == IfElseExec.SKIP_ELSE && !(se.opCode == OpCode.OP_ENDIF)))  						continue;    				if (se.isData)  				{  					stack.Push(se.data);  					continue;  				}    				switch (se.opCode)  				{  					case OpCode.OP_RESERVED:  						{  							return false;  						}  					case OpCode.OP_NOP:  						{  							// NOP' Dump stack for debug  							/*  							stack.ToList().ForEach(x => Console.WriteLine(HexString.FromByteArray(x)));  							Console.WriteLine("---------------------------");  							*/  							break;  						}  					case OpCode.OP_VER:  						{  							return false;  						}  					case OpCode.OP_IF:  					case OpCode.OP_NOTIF:  						{  							if (stack.Count < 1)  								return false;  							Boolean stackIsZero = new ScriptVarInt(stack.Pop()).value.IsZero;  							if ((se.opCode == OpCode.OP_IF && !stackIsZero) || (se.opCode == OpCode.OP_NOTIF && stackIsZero))  							{  								// Run to else or endif  								ifExec.Push(IfElseExec.RUN_IF);  							}  							else  							{  								// Skip to else or endif  								ifExec.Push(IfElseExec.SKIP_IF);  							}  							break;  						}  					case OpCode.OP_VERIF:  					case OpCode.OP_VERNOTIF:  						{  							return false;  						}  					case OpCode.OP_ELSE:  						{  							if (ifExec.Count == 0)  								// No preceding if statement!  								return false;  							if (ifExec.First() == IfElseExec.RUN_IF)  							{  								// If ran' skip else  								ifExec.Push(IfElseExec.SKIP_ELSE);  							}  							else if (ifExec.First() == IfElseExec.SKIP_IF)  							{  								// If did not run' run else  								ifExec.Push(IfElseExec.RUN_ELSE);  							}  							break;  						}  					case OpCode.OP_ENDIF:  						{  							if (ifExec.Count == 0)  								// No preceding if statement!  								return false;  							if (ifExec.First() == IfElseExec.RUN_IF ||  								ifExec.First() == IfElseExec.SKIP_IF)  							{  								ifExec.Pop();  							}  							else if (ifExec.First() == IfElseExec.RUN_ELSE ||  							   ifExec.First() == IfElseExec.SKIP_ELSE)  							{  								ifExec.Pop();  								ifExec.Pop();  							}  							break;  						}  					case OpCode.OP_VERIFY:  						{  							if (stack.Count < 1 || new ScriptVarInt(stack.First()).value.IsZero)  								return false;  							stack.Pop();  							break;  						}  					case OpCode.OP_RETURN:  						{  							return false;  						}  					case OpCode.OP_TOALTSTACK:  						{  							if (stack.Count < 1)  								return false;  							altstack.Push(stack.Pop());  							break;  						}  					case OpCode.OP_FROMALTSTACK:  						{  							if (altstack.Count < 1)  								return false;  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_2DROP:  						{  							if (stack.Count < 2)  								return false;  							stack.Pop();  							stack.Pop();  							break;  						}  					case OpCode.OP_2DUP:  						{  							if (stack.Count < 2)  								return false;  							stack.Push(stack.Skip(1).First());  							stack.Push(stack.Skip(1).First());  							break;  						}  					case OpCode.OP_3DUP:  						{  							if (stack.Count < 3)  								return false;  							stack.Push(stack.Skip(2).First());  							stack.Push(stack.Skip(2).First());  							stack.Push(stack.Skip(2).First());  							break;  						}  					case OpCode.OP_2OVER:  						{  							if (stack.Count < 4)  								return false;  							stack.Push(stack.Skip(3).First());  							stack.Push(stack.Skip(3).First());  							break;  						}  					case OpCode.OP_2ROT:  						{  							if (stack.Count < 6)  								return false;  							altstack.Push(stack.Skip(4).First());  							altstack.Push(stack.Skip(5).First());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_2SWAP:  						{  							if (stack.Count < 4)  								return false;  							altstack.Push(stack.Skip(2).First());  							altstack.Push(stack.Skip(3).First());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_IFDUP:  						{  							if (stack.Count < 1)  								return false;  							if (!new ScriptVarInt(stack.First()).value.IsZero)  								stack.Push(stack.First());  							break;  						}  					case OpCode.OP_DEPTH:  						{  							stack.Push(new ScriptVarInt((UInt64)stack.Count).ToBytes());  							break;  						}  					case OpCode.OP_DROP:  						{  							if (stack.Count < 1)  								return false;  							stack.Pop();  							break;  						}  					case OpCode.OP_DUP:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(stack.First());  							break;  						}  					case OpCode.OP_NIP:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_OVER:  						{  							if (stack.Count < 2)  								return false;  							stack.Push(stack.Skip(1).First());  							break;  						}  					case OpCode.OP_PICK:  						{  							if (stack.Count < 2)  								return false;  							int pick = new ScriptVarInt(stack.Pop()).intValue;  							if (pick < 0 || stack.Count <= pick)  								return false;  							stack.Push(stack.Skip(pick).First());  							break;  						}  					case OpCode.OP_ROLL:  						{  							if (stack.Count < 2)  								return false;  							int roll = new ScriptVarInt(stack.Pop()).intValue;  							if (roll < 0 || stack.Count <= roll)  								return false;  							altstack.Push(stack.Skip(roll).First());  							for (int i = 0; i < roll; i++)  								altstack.Push(stack.Pop());  							stack.Pop();  							for (int i = 0; i < roll + 1; i++)  								stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_ROT:  						{  							if (stack.Count < 3)  								return false;  							altstack.Push(stack.Skip(2).First());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_SWAP:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Skip(1).First());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_TUCK:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Push(altstack.Skip(1).First());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_CAT:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Skip(1).First().Concat(stack.First()).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_SUBSTR:  						{  							if (stack.Count < 3)  								return false;  							altstack.Push(stack.Skip(2).First()  								.Skip(new ScriptVarInt(stack.Skip(1).First()).intValue)  								.Take(new ScriptVarInt(stack.First()).intValue).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_LEFT:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Skip(1).First()  								.Take(new ScriptVarInt(stack.First()).intValue).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_RIGHT:  						{  							if (stack.Count < 2)  								return false;  							int count = new ScriptVarInt(stack.First()).intValue;  							altstack.Push(stack.Skip(1).First()  								.Skip(stack.Skip(1).First().Length - count).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_SIZE:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(new ScriptVarInt((UInt64)stack.First().Length).ToBytes());  							break;  						}  					case OpCode.OP_INVERT:  						{  							if (stack.Count < 1)  								return false;  							Byte[] data = stack.Pop();  							for (int i = 0; i < data.Length; i++)  								data[i] ^= 0xFF;  							stack.Push(data);  							break;  						}  					case OpCode.OP_AND:  					case OpCode.OP_OR:  					case OpCode.OP_XOR:  						{  							if (stack.Count < 2)  								return false;  							Byte[] data = stack.Pop();  							Byte[] data2 = stack.Pop();  							int length = new int[] { data.Length' data2.Length }.Max();  							data = data.Concat(new Byte[length - data.Length]).ToArray();  							data2 = data2.Concat(new Byte[length - data2.Length]).ToArray();  							switch (se.opCode)  							{  								case OpCode.OP_AND:  									{  										for (int i = 0; i < length; i++)  											data[i] &= data2[i];  										break;  									}  								case OpCode.OP_OR:  									{  										for (int i = 0; i < length; i++)  											data[i] |= data2[i];  										break;  									}  								case OpCode.OP_XOR:  									{  										for (int i = 0; i < length; i++)  											data[i] ^= data2[i];  										break;  									}  							}  							stack.Push(data);  							break;  						}  					case OpCode.OP_EQUAL:  					case OpCode.OP_EQUALVERIFY:  						{  							if (stack.Count < 2)  								return false;  							if (stack.Pop().SequenceEqual(stack.Pop()))  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });    							if (se.opCode == OpCode.OP_EQUALVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_RESERVED1:  					case OpCode.OP_RESERVED2:  						{  							return false;  						}  					case OpCode.OP_1ADD:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Add(new ScriptVarInt(stack.Pop())' 1)).ToBytes());  							break;  						}  					case OpCode.OP_1SUB:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Subtract(new ScriptVarInt(stack.Pop())' 1)).ToBytes());  							break;  						}  					case OpCode.OP_2MUL:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Multiply(new ScriptVarInt(stack.Pop())' 2)).ToBytes());  							break;  						}  					case OpCode.OP_2DIV:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Divide(new ScriptVarInt(stack.Pop())' 2)).ToBytes());  							break;  						}  					case OpCode.OP_NEGATE:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Negate(new ScriptVarInt(stack.Pop()))).ToBytes());  							break;  						}  					case OpCode.OP_ABS:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Abs(new ScriptVarInt(stack.Pop()))).ToBytes());  							break;  						}  					case OpCode.OP_NOT:  						{  							if (stack.Count < 1)  								return false;  							if (new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_0NOTEQUAL:  						{  							if (stack.Count < 1)  								return false;  							if (new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x00 });  							else  								stack.Push(new Byte[] { 0x01 });  							break;  						}  					case OpCode.OP_ADD:  					case OpCode.OP_SUB:  					case OpCode.OP_MUL:  					case OpCode.OP_DIV:  					case OpCode.OP_MOD:  					case OpCode.OP_LSHIFT:  					case OpCode.OP_RSHIFT:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							switch (se.opCode)  							{  								case OpCode.OP_ADD:  									a = (BigInteger)a + b;  									break;  								case OpCode.OP_SUB:  									a = (BigInteger)a - b;  									break;  								case OpCode.OP_MUL:  									a = (BigInteger)a * b;  									break;  								case OpCode.OP_DIV:  									a = (BigInteger)a / b;  									break;  								case OpCode.OP_MOD:  									a = (BigInteger)a % b;  									break;  								case OpCode.OP_LSHIFT:  									a = (BigInteger)a << b.intValue;  									break;  								case OpCode.OP_RSHIFT:  									a = (BigInteger)a >> b.intValue;  									break;  							}  							stack.Push(a.ToBytes());  							break;  						}  					case OpCode.OP_BOOLAND:  						{  							if (stack.Count < 2)  								return false;  							if (!new ScriptVarInt(stack.Pop()).value.IsZero && !new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_BOOLOR:  						{  							if (stack.Count < 2)  								return false;  							if (!new ScriptVarInt(stack.Pop()).value.IsZero || !new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_NUMEQUAL:  					case OpCode.OP_NUMEQUALVERIFY:  						{  							if (stack.Count < 2)  								return false;  							if (new ScriptVarInt(stack.Pop()).value == new ScriptVarInt(stack.Pop()).value)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							if (se.opCode == OpCode.OP_NUMEQUALVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_NUMNOTEQUAL:  						{  							if (stack.Count < 2)  								return false;  							if (new ScriptVarInt(stack.Pop()).value != new ScriptVarInt(stack.Pop()).value)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_LESSTHAN:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a < b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_GREATERTHAN:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a > b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_LESSTHANOREQUAL:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a <= b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_GREATERTHANOREQUAL:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a >= b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_MIN:  						{  							if (stack.Count < 2)  								return false;  							Byte[] b = stack.Pop();  							Byte[] a = stack.Pop();  							if (new ScriptVarInt(a).value < new ScriptVarInt(b).value)  								stack.Push(a);  							else  								stack.Push(b);  							break;  						}  					case OpCode.OP_MAX:  						{  							if (stack.Count < 2)  								return false;  							Byte[] b = stack.Pop();  							Byte[] a = stack.Pop();  							if (new ScriptVarInt(a).value > new ScriptVarInt(b).value)  								stack.Push(a);  							else  								stack.Push(b);  							break;  						}  					case OpCode.OP_WITHIN:  						{  							if (stack.Count < 3)  								return false;  							ScriptVarInt max = new ScriptVarInt(stack.Pop());  							ScriptVarInt min = new ScriptVarInt(stack.Pop());  							ScriptVarInt x = new ScriptVarInt(stack.Pop());  							if ((BigInteger)min <= x && (BigInteger)x <= max)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_RIPEMD160:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(ripemd160.ComputeHash(stack.Pop()));  							break;  						}  					case OpCode.OP_SHA1:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(sha1.ComputeHash(stack.Pop()));  							break;  						}  					case OpCode.OP_SHA256:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(sha256.ComputeHash(stack.Pop()));  							break;  						}  					case OpCode.OP_HASH160:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(ripemd160.ComputeHash(sha256.ComputeHash(stack.Pop())));  							break;  						}  					case OpCode.OP_HASH256:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(sha256.ComputeHash(sha256.ComputeHash(stack.Pop())));  							break;  						}  					case OpCode.OP_CODESEPARATOR:  						{  							lastCodeSeperator = index;  							break;  						}  					case OpCode.OP_CHECKSIG:  					case OpCode.OP_CHECKSIGVERIFY:  						{  							if (tx == null)  								throw new ArgumentNullException("Transaction is required if script contains OP_CHECKSIG[VERIFY]");  							if (stack.Count < 2)  								return false;    							PublicKey pubKey = new PublicKey(stack.Pop());  							Byte[] sig = stack.Pop();    							Script subScript = new Script(elements.Skip(lastCodeSeperator)  								.Where(x => x.opCode != OpCode.OP_CODESEPARATOR).ToArray());    							stack.Push(new ScriptVarInt(CheckSig(sig' pubKey' txInIndex' subScript' tx) ? 1 : 0).ToBytes());    							if (se.opCode == OpCode.OP_CHECKSIGVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_CHECKMULTISIG:  					case OpCode.OP_CHECKMULTISIGVERIFY:  						{  							if (tx == null)  								throw new ArgumentNullException("Transaction is required if script contains OP_CHECKMULTISIG[VERIFY]");  							if (stack.Count < 2)  								return false;    							PublicKey[] pubKeys = new PublicKey[new ScriptVarInt(stack.Pop()).intValue];    							if (stack.Count < pubKeys.Length + 1)  								return false;    							for (int i = 0; i < pubKeys.Length; i++)  							{  								pubKeys[i] = new PublicKey(stack.Pop());  							}    							Byte[][] sigs = new Byte[new ScriptVarInt(stack.Pop()).intValue][];    							if (stack.Count < sigs.Length)  								return false;    							for (int i = 0; i < sigs.Length; i++)  							{  								sigs[i] = stack.Pop();  							}    							// Remove extra unused value from stack  							stack.Pop();    							Script subScript = new Script(elements.Skip(lastCodeSeperator)  								.Where(x => x.opCode != OpCode.OP_CODESEPARATOR).ToArray());    							int validSigs = 0;  							foreach (Byte[] sig in sigs)  							{  								foreach (PublicKey pubKey in pubKeys)  								{  									if (CheckSig(sig' pubKey' txInIndex' subScript' tx))  									{  										pubKeys = pubKeys.Where(x => x != pubKey).ToArray();  										validSigs++;  										break;  									}  								}  							}    							stack.Push(new ScriptVarInt((validSigs >= sigs.Length) ? 1 : 0).ToBytes());    							if (se.opCode == OpCode.OP_CHECKMULTISIGVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_NOP1:  					case OpCode.OP_NOP2:  					case OpCode.OP_NOP3:  					case OpCode.OP_NOP4:  					case OpCode.OP_NOP5:  					case OpCode.OP_NOP6:  					case OpCode.OP_NOP7:  					case OpCode.OP_NOP8:  					case OpCode.OP_NOP9:  					case OpCode.OP_NOP10:  						{  							break;  						}  					case OpCode.OP_SMALLINTEGER:  					case OpCode.OP_PUBKEYS:  					case OpCode.OP_PUBKEYHASH:  					case OpCode.OP_PUBKEY:  					case OpCode.OP_INVALIDOPCODE:  					default:  						{  							return false;  						}    				}  			}
Magic Number,Bitcoin_Tool.Scripts,Script,C:\repos\mb300sd_Bitcoin-Tool\Bitcoin Tool\Scripts\Script.cs,Evaluate,The following statement contains a magic number: for (int index = 0; index < elements.Count; index++)  			{  				ScriptElement se = elements[index];  				if (ifExec.Count > 0)  					if ((ifExec.First() == IfElseExec.SKIP_IF && !(se.opCode == OpCode.OP_ELSE || se.opCode == OpCode.OP_ENDIF)) ||  						(ifExec.First() == IfElseExec.SKIP_ELSE && !(se.opCode == OpCode.OP_ENDIF)))  						continue;    				if (se.isData)  				{  					stack.Push(se.data);  					continue;  				}    				switch (se.opCode)  				{  					case OpCode.OP_RESERVED:  						{  							return false;  						}  					case OpCode.OP_NOP:  						{  							// NOP' Dump stack for debug  							/*  							stack.ToList().ForEach(x => Console.WriteLine(HexString.FromByteArray(x)));  							Console.WriteLine("---------------------------");  							*/  							break;  						}  					case OpCode.OP_VER:  						{  							return false;  						}  					case OpCode.OP_IF:  					case OpCode.OP_NOTIF:  						{  							if (stack.Count < 1)  								return false;  							Boolean stackIsZero = new ScriptVarInt(stack.Pop()).value.IsZero;  							if ((se.opCode == OpCode.OP_IF && !stackIsZero) || (se.opCode == OpCode.OP_NOTIF && stackIsZero))  							{  								// Run to else or endif  								ifExec.Push(IfElseExec.RUN_IF);  							}  							else  							{  								// Skip to else or endif  								ifExec.Push(IfElseExec.SKIP_IF);  							}  							break;  						}  					case OpCode.OP_VERIF:  					case OpCode.OP_VERNOTIF:  						{  							return false;  						}  					case OpCode.OP_ELSE:  						{  							if (ifExec.Count == 0)  								// No preceding if statement!  								return false;  							if (ifExec.First() == IfElseExec.RUN_IF)  							{  								// If ran' skip else  								ifExec.Push(IfElseExec.SKIP_ELSE);  							}  							else if (ifExec.First() == IfElseExec.SKIP_IF)  							{  								// If did not run' run else  								ifExec.Push(IfElseExec.RUN_ELSE);  							}  							break;  						}  					case OpCode.OP_ENDIF:  						{  							if (ifExec.Count == 0)  								// No preceding if statement!  								return false;  							if (ifExec.First() == IfElseExec.RUN_IF ||  								ifExec.First() == IfElseExec.SKIP_IF)  							{  								ifExec.Pop();  							}  							else if (ifExec.First() == IfElseExec.RUN_ELSE ||  							   ifExec.First() == IfElseExec.SKIP_ELSE)  							{  								ifExec.Pop();  								ifExec.Pop();  							}  							break;  						}  					case OpCode.OP_VERIFY:  						{  							if (stack.Count < 1 || new ScriptVarInt(stack.First()).value.IsZero)  								return false;  							stack.Pop();  							break;  						}  					case OpCode.OP_RETURN:  						{  							return false;  						}  					case OpCode.OP_TOALTSTACK:  						{  							if (stack.Count < 1)  								return false;  							altstack.Push(stack.Pop());  							break;  						}  					case OpCode.OP_FROMALTSTACK:  						{  							if (altstack.Count < 1)  								return false;  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_2DROP:  						{  							if (stack.Count < 2)  								return false;  							stack.Pop();  							stack.Pop();  							break;  						}  					case OpCode.OP_2DUP:  						{  							if (stack.Count < 2)  								return false;  							stack.Push(stack.Skip(1).First());  							stack.Push(stack.Skip(1).First());  							break;  						}  					case OpCode.OP_3DUP:  						{  							if (stack.Count < 3)  								return false;  							stack.Push(stack.Skip(2).First());  							stack.Push(stack.Skip(2).First());  							stack.Push(stack.Skip(2).First());  							break;  						}  					case OpCode.OP_2OVER:  						{  							if (stack.Count < 4)  								return false;  							stack.Push(stack.Skip(3).First());  							stack.Push(stack.Skip(3).First());  							break;  						}  					case OpCode.OP_2ROT:  						{  							if (stack.Count < 6)  								return false;  							altstack.Push(stack.Skip(4).First());  							altstack.Push(stack.Skip(5).First());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_2SWAP:  						{  							if (stack.Count < 4)  								return false;  							altstack.Push(stack.Skip(2).First());  							altstack.Push(stack.Skip(3).First());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_IFDUP:  						{  							if (stack.Count < 1)  								return false;  							if (!new ScriptVarInt(stack.First()).value.IsZero)  								stack.Push(stack.First());  							break;  						}  					case OpCode.OP_DEPTH:  						{  							stack.Push(new ScriptVarInt((UInt64)stack.Count).ToBytes());  							break;  						}  					case OpCode.OP_DROP:  						{  							if (stack.Count < 1)  								return false;  							stack.Pop();  							break;  						}  					case OpCode.OP_DUP:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(stack.First());  							break;  						}  					case OpCode.OP_NIP:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_OVER:  						{  							if (stack.Count < 2)  								return false;  							stack.Push(stack.Skip(1).First());  							break;  						}  					case OpCode.OP_PICK:  						{  							if (stack.Count < 2)  								return false;  							int pick = new ScriptVarInt(stack.Pop()).intValue;  							if (pick < 0 || stack.Count <= pick)  								return false;  							stack.Push(stack.Skip(pick).First());  							break;  						}  					case OpCode.OP_ROLL:  						{  							if (stack.Count < 2)  								return false;  							int roll = new ScriptVarInt(stack.Pop()).intValue;  							if (roll < 0 || stack.Count <= roll)  								return false;  							altstack.Push(stack.Skip(roll).First());  							for (int i = 0; i < roll; i++)  								altstack.Push(stack.Pop());  							stack.Pop();  							for (int i = 0; i < roll + 1; i++)  								stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_ROT:  						{  							if (stack.Count < 3)  								return false;  							altstack.Push(stack.Skip(2).First());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_SWAP:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Skip(1).First());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_TUCK:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Push(altstack.Skip(1).First());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_CAT:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Skip(1).First().Concat(stack.First()).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_SUBSTR:  						{  							if (stack.Count < 3)  								return false;  							altstack.Push(stack.Skip(2).First()  								.Skip(new ScriptVarInt(stack.Skip(1).First()).intValue)  								.Take(new ScriptVarInt(stack.First()).intValue).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_LEFT:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Skip(1).First()  								.Take(new ScriptVarInt(stack.First()).intValue).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_RIGHT:  						{  							if (stack.Count < 2)  								return false;  							int count = new ScriptVarInt(stack.First()).intValue;  							altstack.Push(stack.Skip(1).First()  								.Skip(stack.Skip(1).First().Length - count).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_SIZE:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(new ScriptVarInt((UInt64)stack.First().Length).ToBytes());  							break;  						}  					case OpCode.OP_INVERT:  						{  							if (stack.Count < 1)  								return false;  							Byte[] data = stack.Pop();  							for (int i = 0; i < data.Length; i++)  								data[i] ^= 0xFF;  							stack.Push(data);  							break;  						}  					case OpCode.OP_AND:  					case OpCode.OP_OR:  					case OpCode.OP_XOR:  						{  							if (stack.Count < 2)  								return false;  							Byte[] data = stack.Pop();  							Byte[] data2 = stack.Pop();  							int length = new int[] { data.Length' data2.Length }.Max();  							data = data.Concat(new Byte[length - data.Length]).ToArray();  							data2 = data2.Concat(new Byte[length - data2.Length]).ToArray();  							switch (se.opCode)  							{  								case OpCode.OP_AND:  									{  										for (int i = 0; i < length; i++)  											data[i] &= data2[i];  										break;  									}  								case OpCode.OP_OR:  									{  										for (int i = 0; i < length; i++)  											data[i] |= data2[i];  										break;  									}  								case OpCode.OP_XOR:  									{  										for (int i = 0; i < length; i++)  											data[i] ^= data2[i];  										break;  									}  							}  							stack.Push(data);  							break;  						}  					case OpCode.OP_EQUAL:  					case OpCode.OP_EQUALVERIFY:  						{  							if (stack.Count < 2)  								return false;  							if (stack.Pop().SequenceEqual(stack.Pop()))  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });    							if (se.opCode == OpCode.OP_EQUALVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_RESERVED1:  					case OpCode.OP_RESERVED2:  						{  							return false;  						}  					case OpCode.OP_1ADD:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Add(new ScriptVarInt(stack.Pop())' 1)).ToBytes());  							break;  						}  					case OpCode.OP_1SUB:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Subtract(new ScriptVarInt(stack.Pop())' 1)).ToBytes());  							break;  						}  					case OpCode.OP_2MUL:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Multiply(new ScriptVarInt(stack.Pop())' 2)).ToBytes());  							break;  						}  					case OpCode.OP_2DIV:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Divide(new ScriptVarInt(stack.Pop())' 2)).ToBytes());  							break;  						}  					case OpCode.OP_NEGATE:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Negate(new ScriptVarInt(stack.Pop()))).ToBytes());  							break;  						}  					case OpCode.OP_ABS:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Abs(new ScriptVarInt(stack.Pop()))).ToBytes());  							break;  						}  					case OpCode.OP_NOT:  						{  							if (stack.Count < 1)  								return false;  							if (new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_0NOTEQUAL:  						{  							if (stack.Count < 1)  								return false;  							if (new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x00 });  							else  								stack.Push(new Byte[] { 0x01 });  							break;  						}  					case OpCode.OP_ADD:  					case OpCode.OP_SUB:  					case OpCode.OP_MUL:  					case OpCode.OP_DIV:  					case OpCode.OP_MOD:  					case OpCode.OP_LSHIFT:  					case OpCode.OP_RSHIFT:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							switch (se.opCode)  							{  								case OpCode.OP_ADD:  									a = (BigInteger)a + b;  									break;  								case OpCode.OP_SUB:  									a = (BigInteger)a - b;  									break;  								case OpCode.OP_MUL:  									a = (BigInteger)a * b;  									break;  								case OpCode.OP_DIV:  									a = (BigInteger)a / b;  									break;  								case OpCode.OP_MOD:  									a = (BigInteger)a % b;  									break;  								case OpCode.OP_LSHIFT:  									a = (BigInteger)a << b.intValue;  									break;  								case OpCode.OP_RSHIFT:  									a = (BigInteger)a >> b.intValue;  									break;  							}  							stack.Push(a.ToBytes());  							break;  						}  					case OpCode.OP_BOOLAND:  						{  							if (stack.Count < 2)  								return false;  							if (!new ScriptVarInt(stack.Pop()).value.IsZero && !new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_BOOLOR:  						{  							if (stack.Count < 2)  								return false;  							if (!new ScriptVarInt(stack.Pop()).value.IsZero || !new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_NUMEQUAL:  					case OpCode.OP_NUMEQUALVERIFY:  						{  							if (stack.Count < 2)  								return false;  							if (new ScriptVarInt(stack.Pop()).value == new ScriptVarInt(stack.Pop()).value)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							if (se.opCode == OpCode.OP_NUMEQUALVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_NUMNOTEQUAL:  						{  							if (stack.Count < 2)  								return false;  							if (new ScriptVarInt(stack.Pop()).value != new ScriptVarInt(stack.Pop()).value)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_LESSTHAN:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a < b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_GREATERTHAN:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a > b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_LESSTHANOREQUAL:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a <= b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_GREATERTHANOREQUAL:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a >= b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_MIN:  						{  							if (stack.Count < 2)  								return false;  							Byte[] b = stack.Pop();  							Byte[] a = stack.Pop();  							if (new ScriptVarInt(a).value < new ScriptVarInt(b).value)  								stack.Push(a);  							else  								stack.Push(b);  							break;  						}  					case OpCode.OP_MAX:  						{  							if (stack.Count < 2)  								return false;  							Byte[] b = stack.Pop();  							Byte[] a = stack.Pop();  							if (new ScriptVarInt(a).value > new ScriptVarInt(b).value)  								stack.Push(a);  							else  								stack.Push(b);  							break;  						}  					case OpCode.OP_WITHIN:  						{  							if (stack.Count < 3)  								return false;  							ScriptVarInt max = new ScriptVarInt(stack.Pop());  							ScriptVarInt min = new ScriptVarInt(stack.Pop());  							ScriptVarInt x = new ScriptVarInt(stack.Pop());  							if ((BigInteger)min <= x && (BigInteger)x <= max)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_RIPEMD160:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(ripemd160.ComputeHash(stack.Pop()));  							break;  						}  					case OpCode.OP_SHA1:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(sha1.ComputeHash(stack.Pop()));  							break;  						}  					case OpCode.OP_SHA256:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(sha256.ComputeHash(stack.Pop()));  							break;  						}  					case OpCode.OP_HASH160:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(ripemd160.ComputeHash(sha256.ComputeHash(stack.Pop())));  							break;  						}  					case OpCode.OP_HASH256:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(sha256.ComputeHash(sha256.ComputeHash(stack.Pop())));  							break;  						}  					case OpCode.OP_CODESEPARATOR:  						{  							lastCodeSeperator = index;  							break;  						}  					case OpCode.OP_CHECKSIG:  					case OpCode.OP_CHECKSIGVERIFY:  						{  							if (tx == null)  								throw new ArgumentNullException("Transaction is required if script contains OP_CHECKSIG[VERIFY]");  							if (stack.Count < 2)  								return false;    							PublicKey pubKey = new PublicKey(stack.Pop());  							Byte[] sig = stack.Pop();    							Script subScript = new Script(elements.Skip(lastCodeSeperator)  								.Where(x => x.opCode != OpCode.OP_CODESEPARATOR).ToArray());    							stack.Push(new ScriptVarInt(CheckSig(sig' pubKey' txInIndex' subScript' tx) ? 1 : 0).ToBytes());    							if (se.opCode == OpCode.OP_CHECKSIGVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_CHECKMULTISIG:  					case OpCode.OP_CHECKMULTISIGVERIFY:  						{  							if (tx == null)  								throw new ArgumentNullException("Transaction is required if script contains OP_CHECKMULTISIG[VERIFY]");  							if (stack.Count < 2)  								return false;    							PublicKey[] pubKeys = new PublicKey[new ScriptVarInt(stack.Pop()).intValue];    							if (stack.Count < pubKeys.Length + 1)  								return false;    							for (int i = 0; i < pubKeys.Length; i++)  							{  								pubKeys[i] = new PublicKey(stack.Pop());  							}    							Byte[][] sigs = new Byte[new ScriptVarInt(stack.Pop()).intValue][];    							if (stack.Count < sigs.Length)  								return false;    							for (int i = 0; i < sigs.Length; i++)  							{  								sigs[i] = stack.Pop();  							}    							// Remove extra unused value from stack  							stack.Pop();    							Script subScript = new Script(elements.Skip(lastCodeSeperator)  								.Where(x => x.opCode != OpCode.OP_CODESEPARATOR).ToArray());    							int validSigs = 0;  							foreach (Byte[] sig in sigs)  							{  								foreach (PublicKey pubKey in pubKeys)  								{  									if (CheckSig(sig' pubKey' txInIndex' subScript' tx))  									{  										pubKeys = pubKeys.Where(x => x != pubKey).ToArray();  										validSigs++;  										break;  									}  								}  							}    							stack.Push(new ScriptVarInt((validSigs >= sigs.Length) ? 1 : 0).ToBytes());    							if (se.opCode == OpCode.OP_CHECKMULTISIGVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_NOP1:  					case OpCode.OP_NOP2:  					case OpCode.OP_NOP3:  					case OpCode.OP_NOP4:  					case OpCode.OP_NOP5:  					case OpCode.OP_NOP6:  					case OpCode.OP_NOP7:  					case OpCode.OP_NOP8:  					case OpCode.OP_NOP9:  					case OpCode.OP_NOP10:  						{  							break;  						}  					case OpCode.OP_SMALLINTEGER:  					case OpCode.OP_PUBKEYS:  					case OpCode.OP_PUBKEYHASH:  					case OpCode.OP_PUBKEY:  					case OpCode.OP_INVALIDOPCODE:  					default:  						{  							return false;  						}    				}  			}
Magic Number,Bitcoin_Tool.Scripts,Script,C:\repos\mb300sd_Bitcoin-Tool\Bitcoin Tool\Scripts\Script.cs,Evaluate,The following statement contains a magic number: for (int index = 0; index < elements.Count; index++)  			{  				ScriptElement se = elements[index];  				if (ifExec.Count > 0)  					if ((ifExec.First() == IfElseExec.SKIP_IF && !(se.opCode == OpCode.OP_ELSE || se.opCode == OpCode.OP_ENDIF)) ||  						(ifExec.First() == IfElseExec.SKIP_ELSE && !(se.opCode == OpCode.OP_ENDIF)))  						continue;    				if (se.isData)  				{  					stack.Push(se.data);  					continue;  				}    				switch (se.opCode)  				{  					case OpCode.OP_RESERVED:  						{  							return false;  						}  					case OpCode.OP_NOP:  						{  							// NOP' Dump stack for debug  							/*  							stack.ToList().ForEach(x => Console.WriteLine(HexString.FromByteArray(x)));  							Console.WriteLine("---------------------------");  							*/  							break;  						}  					case OpCode.OP_VER:  						{  							return false;  						}  					case OpCode.OP_IF:  					case OpCode.OP_NOTIF:  						{  							if (stack.Count < 1)  								return false;  							Boolean stackIsZero = new ScriptVarInt(stack.Pop()).value.IsZero;  							if ((se.opCode == OpCode.OP_IF && !stackIsZero) || (se.opCode == OpCode.OP_NOTIF && stackIsZero))  							{  								// Run to else or endif  								ifExec.Push(IfElseExec.RUN_IF);  							}  							else  							{  								// Skip to else or endif  								ifExec.Push(IfElseExec.SKIP_IF);  							}  							break;  						}  					case OpCode.OP_VERIF:  					case OpCode.OP_VERNOTIF:  						{  							return false;  						}  					case OpCode.OP_ELSE:  						{  							if (ifExec.Count == 0)  								// No preceding if statement!  								return false;  							if (ifExec.First() == IfElseExec.RUN_IF)  							{  								// If ran' skip else  								ifExec.Push(IfElseExec.SKIP_ELSE);  							}  							else if (ifExec.First() == IfElseExec.SKIP_IF)  							{  								// If did not run' run else  								ifExec.Push(IfElseExec.RUN_ELSE);  							}  							break;  						}  					case OpCode.OP_ENDIF:  						{  							if (ifExec.Count == 0)  								// No preceding if statement!  								return false;  							if (ifExec.First() == IfElseExec.RUN_IF ||  								ifExec.First() == IfElseExec.SKIP_IF)  							{  								ifExec.Pop();  							}  							else if (ifExec.First() == IfElseExec.RUN_ELSE ||  							   ifExec.First() == IfElseExec.SKIP_ELSE)  							{  								ifExec.Pop();  								ifExec.Pop();  							}  							break;  						}  					case OpCode.OP_VERIFY:  						{  							if (stack.Count < 1 || new ScriptVarInt(stack.First()).value.IsZero)  								return false;  							stack.Pop();  							break;  						}  					case OpCode.OP_RETURN:  						{  							return false;  						}  					case OpCode.OP_TOALTSTACK:  						{  							if (stack.Count < 1)  								return false;  							altstack.Push(stack.Pop());  							break;  						}  					case OpCode.OP_FROMALTSTACK:  						{  							if (altstack.Count < 1)  								return false;  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_2DROP:  						{  							if (stack.Count < 2)  								return false;  							stack.Pop();  							stack.Pop();  							break;  						}  					case OpCode.OP_2DUP:  						{  							if (stack.Count < 2)  								return false;  							stack.Push(stack.Skip(1).First());  							stack.Push(stack.Skip(1).First());  							break;  						}  					case OpCode.OP_3DUP:  						{  							if (stack.Count < 3)  								return false;  							stack.Push(stack.Skip(2).First());  							stack.Push(stack.Skip(2).First());  							stack.Push(stack.Skip(2).First());  							break;  						}  					case OpCode.OP_2OVER:  						{  							if (stack.Count < 4)  								return false;  							stack.Push(stack.Skip(3).First());  							stack.Push(stack.Skip(3).First());  							break;  						}  					case OpCode.OP_2ROT:  						{  							if (stack.Count < 6)  								return false;  							altstack.Push(stack.Skip(4).First());  							altstack.Push(stack.Skip(5).First());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_2SWAP:  						{  							if (stack.Count < 4)  								return false;  							altstack.Push(stack.Skip(2).First());  							altstack.Push(stack.Skip(3).First());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_IFDUP:  						{  							if (stack.Count < 1)  								return false;  							if (!new ScriptVarInt(stack.First()).value.IsZero)  								stack.Push(stack.First());  							break;  						}  					case OpCode.OP_DEPTH:  						{  							stack.Push(new ScriptVarInt((UInt64)stack.Count).ToBytes());  							break;  						}  					case OpCode.OP_DROP:  						{  							if (stack.Count < 1)  								return false;  							stack.Pop();  							break;  						}  					case OpCode.OP_DUP:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(stack.First());  							break;  						}  					case OpCode.OP_NIP:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_OVER:  						{  							if (stack.Count < 2)  								return false;  							stack.Push(stack.Skip(1).First());  							break;  						}  					case OpCode.OP_PICK:  						{  							if (stack.Count < 2)  								return false;  							int pick = new ScriptVarInt(stack.Pop()).intValue;  							if (pick < 0 || stack.Count <= pick)  								return false;  							stack.Push(stack.Skip(pick).First());  							break;  						}  					case OpCode.OP_ROLL:  						{  							if (stack.Count < 2)  								return false;  							int roll = new ScriptVarInt(stack.Pop()).intValue;  							if (roll < 0 || stack.Count <= roll)  								return false;  							altstack.Push(stack.Skip(roll).First());  							for (int i = 0; i < roll; i++)  								altstack.Push(stack.Pop());  							stack.Pop();  							for (int i = 0; i < roll + 1; i++)  								stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_ROT:  						{  							if (stack.Count < 3)  								return false;  							altstack.Push(stack.Skip(2).First());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_SWAP:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Skip(1).First());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_TUCK:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Push(altstack.Skip(1).First());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_CAT:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Skip(1).First().Concat(stack.First()).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_SUBSTR:  						{  							if (stack.Count < 3)  								return false;  							altstack.Push(stack.Skip(2).First()  								.Skip(new ScriptVarInt(stack.Skip(1).First()).intValue)  								.Take(new ScriptVarInt(stack.First()).intValue).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_LEFT:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Skip(1).First()  								.Take(new ScriptVarInt(stack.First()).intValue).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_RIGHT:  						{  							if (stack.Count < 2)  								return false;  							int count = new ScriptVarInt(stack.First()).intValue;  							altstack.Push(stack.Skip(1).First()  								.Skip(stack.Skip(1).First().Length - count).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_SIZE:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(new ScriptVarInt((UInt64)stack.First().Length).ToBytes());  							break;  						}  					case OpCode.OP_INVERT:  						{  							if (stack.Count < 1)  								return false;  							Byte[] data = stack.Pop();  							for (int i = 0; i < data.Length; i++)  								data[i] ^= 0xFF;  							stack.Push(data);  							break;  						}  					case OpCode.OP_AND:  					case OpCode.OP_OR:  					case OpCode.OP_XOR:  						{  							if (stack.Count < 2)  								return false;  							Byte[] data = stack.Pop();  							Byte[] data2 = stack.Pop();  							int length = new int[] { data.Length' data2.Length }.Max();  							data = data.Concat(new Byte[length - data.Length]).ToArray();  							data2 = data2.Concat(new Byte[length - data2.Length]).ToArray();  							switch (se.opCode)  							{  								case OpCode.OP_AND:  									{  										for (int i = 0; i < length; i++)  											data[i] &= data2[i];  										break;  									}  								case OpCode.OP_OR:  									{  										for (int i = 0; i < length; i++)  											data[i] |= data2[i];  										break;  									}  								case OpCode.OP_XOR:  									{  										for (int i = 0; i < length; i++)  											data[i] ^= data2[i];  										break;  									}  							}  							stack.Push(data);  							break;  						}  					case OpCode.OP_EQUAL:  					case OpCode.OP_EQUALVERIFY:  						{  							if (stack.Count < 2)  								return false;  							if (stack.Pop().SequenceEqual(stack.Pop()))  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });    							if (se.opCode == OpCode.OP_EQUALVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_RESERVED1:  					case OpCode.OP_RESERVED2:  						{  							return false;  						}  					case OpCode.OP_1ADD:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Add(new ScriptVarInt(stack.Pop())' 1)).ToBytes());  							break;  						}  					case OpCode.OP_1SUB:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Subtract(new ScriptVarInt(stack.Pop())' 1)).ToBytes());  							break;  						}  					case OpCode.OP_2MUL:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Multiply(new ScriptVarInt(stack.Pop())' 2)).ToBytes());  							break;  						}  					case OpCode.OP_2DIV:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Divide(new ScriptVarInt(stack.Pop())' 2)).ToBytes());  							break;  						}  					case OpCode.OP_NEGATE:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Negate(new ScriptVarInt(stack.Pop()))).ToBytes());  							break;  						}  					case OpCode.OP_ABS:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Abs(new ScriptVarInt(stack.Pop()))).ToBytes());  							break;  						}  					case OpCode.OP_NOT:  						{  							if (stack.Count < 1)  								return false;  							if (new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_0NOTEQUAL:  						{  							if (stack.Count < 1)  								return false;  							if (new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x00 });  							else  								stack.Push(new Byte[] { 0x01 });  							break;  						}  					case OpCode.OP_ADD:  					case OpCode.OP_SUB:  					case OpCode.OP_MUL:  					case OpCode.OP_DIV:  					case OpCode.OP_MOD:  					case OpCode.OP_LSHIFT:  					case OpCode.OP_RSHIFT:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							switch (se.opCode)  							{  								case OpCode.OP_ADD:  									a = (BigInteger)a + b;  									break;  								case OpCode.OP_SUB:  									a = (BigInteger)a - b;  									break;  								case OpCode.OP_MUL:  									a = (BigInteger)a * b;  									break;  								case OpCode.OP_DIV:  									a = (BigInteger)a / b;  									break;  								case OpCode.OP_MOD:  									a = (BigInteger)a % b;  									break;  								case OpCode.OP_LSHIFT:  									a = (BigInteger)a << b.intValue;  									break;  								case OpCode.OP_RSHIFT:  									a = (BigInteger)a >> b.intValue;  									break;  							}  							stack.Push(a.ToBytes());  							break;  						}  					case OpCode.OP_BOOLAND:  						{  							if (stack.Count < 2)  								return false;  							if (!new ScriptVarInt(stack.Pop()).value.IsZero && !new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_BOOLOR:  						{  							if (stack.Count < 2)  								return false;  							if (!new ScriptVarInt(stack.Pop()).value.IsZero || !new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_NUMEQUAL:  					case OpCode.OP_NUMEQUALVERIFY:  						{  							if (stack.Count < 2)  								return false;  							if (new ScriptVarInt(stack.Pop()).value == new ScriptVarInt(stack.Pop()).value)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							if (se.opCode == OpCode.OP_NUMEQUALVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_NUMNOTEQUAL:  						{  							if (stack.Count < 2)  								return false;  							if (new ScriptVarInt(stack.Pop()).value != new ScriptVarInt(stack.Pop()).value)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_LESSTHAN:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a < b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_GREATERTHAN:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a > b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_LESSTHANOREQUAL:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a <= b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_GREATERTHANOREQUAL:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a >= b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_MIN:  						{  							if (stack.Count < 2)  								return false;  							Byte[] b = stack.Pop();  							Byte[] a = stack.Pop();  							if (new ScriptVarInt(a).value < new ScriptVarInt(b).value)  								stack.Push(a);  							else  								stack.Push(b);  							break;  						}  					case OpCode.OP_MAX:  						{  							if (stack.Count < 2)  								return false;  							Byte[] b = stack.Pop();  							Byte[] a = stack.Pop();  							if (new ScriptVarInt(a).value > new ScriptVarInt(b).value)  								stack.Push(a);  							else  								stack.Push(b);  							break;  						}  					case OpCode.OP_WITHIN:  						{  							if (stack.Count < 3)  								return false;  							ScriptVarInt max = new ScriptVarInt(stack.Pop());  							ScriptVarInt min = new ScriptVarInt(stack.Pop());  							ScriptVarInt x = new ScriptVarInt(stack.Pop());  							if ((BigInteger)min <= x && (BigInteger)x <= max)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_RIPEMD160:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(ripemd160.ComputeHash(stack.Pop()));  							break;  						}  					case OpCode.OP_SHA1:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(sha1.ComputeHash(stack.Pop()));  							break;  						}  					case OpCode.OP_SHA256:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(sha256.ComputeHash(stack.Pop()));  							break;  						}  					case OpCode.OP_HASH160:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(ripemd160.ComputeHash(sha256.ComputeHash(stack.Pop())));  							break;  						}  					case OpCode.OP_HASH256:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(sha256.ComputeHash(sha256.ComputeHash(stack.Pop())));  							break;  						}  					case OpCode.OP_CODESEPARATOR:  						{  							lastCodeSeperator = index;  							break;  						}  					case OpCode.OP_CHECKSIG:  					case OpCode.OP_CHECKSIGVERIFY:  						{  							if (tx == null)  								throw new ArgumentNullException("Transaction is required if script contains OP_CHECKSIG[VERIFY]");  							if (stack.Count < 2)  								return false;    							PublicKey pubKey = new PublicKey(stack.Pop());  							Byte[] sig = stack.Pop();    							Script subScript = new Script(elements.Skip(lastCodeSeperator)  								.Where(x => x.opCode != OpCode.OP_CODESEPARATOR).ToArray());    							stack.Push(new ScriptVarInt(CheckSig(sig' pubKey' txInIndex' subScript' tx) ? 1 : 0).ToBytes());    							if (se.opCode == OpCode.OP_CHECKSIGVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_CHECKMULTISIG:  					case OpCode.OP_CHECKMULTISIGVERIFY:  						{  							if (tx == null)  								throw new ArgumentNullException("Transaction is required if script contains OP_CHECKMULTISIG[VERIFY]");  							if (stack.Count < 2)  								return false;    							PublicKey[] pubKeys = new PublicKey[new ScriptVarInt(stack.Pop()).intValue];    							if (stack.Count < pubKeys.Length + 1)  								return false;    							for (int i = 0; i < pubKeys.Length; i++)  							{  								pubKeys[i] = new PublicKey(stack.Pop());  							}    							Byte[][] sigs = new Byte[new ScriptVarInt(stack.Pop()).intValue][];    							if (stack.Count < sigs.Length)  								return false;    							for (int i = 0; i < sigs.Length; i++)  							{  								sigs[i] = stack.Pop();  							}    							// Remove extra unused value from stack  							stack.Pop();    							Script subScript = new Script(elements.Skip(lastCodeSeperator)  								.Where(x => x.opCode != OpCode.OP_CODESEPARATOR).ToArray());    							int validSigs = 0;  							foreach (Byte[] sig in sigs)  							{  								foreach (PublicKey pubKey in pubKeys)  								{  									if (CheckSig(sig' pubKey' txInIndex' subScript' tx))  									{  										pubKeys = pubKeys.Where(x => x != pubKey).ToArray();  										validSigs++;  										break;  									}  								}  							}    							stack.Push(new ScriptVarInt((validSigs >= sigs.Length) ? 1 : 0).ToBytes());    							if (se.opCode == OpCode.OP_CHECKMULTISIGVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_NOP1:  					case OpCode.OP_NOP2:  					case OpCode.OP_NOP3:  					case OpCode.OP_NOP4:  					case OpCode.OP_NOP5:  					case OpCode.OP_NOP6:  					case OpCode.OP_NOP7:  					case OpCode.OP_NOP8:  					case OpCode.OP_NOP9:  					case OpCode.OP_NOP10:  						{  							break;  						}  					case OpCode.OP_SMALLINTEGER:  					case OpCode.OP_PUBKEYS:  					case OpCode.OP_PUBKEYHASH:  					case OpCode.OP_PUBKEY:  					case OpCode.OP_INVALIDOPCODE:  					default:  						{  							return false;  						}    				}  			}
Magic Number,Bitcoin_Tool.Scripts,Script,C:\repos\mb300sd_Bitcoin-Tool\Bitcoin Tool\Scripts\Script.cs,Evaluate,The following statement contains a magic number: for (int index = 0; index < elements.Count; index++)  			{  				ScriptElement se = elements[index];  				if (ifExec.Count > 0)  					if ((ifExec.First() == IfElseExec.SKIP_IF && !(se.opCode == OpCode.OP_ELSE || se.opCode == OpCode.OP_ENDIF)) ||  						(ifExec.First() == IfElseExec.SKIP_ELSE && !(se.opCode == OpCode.OP_ENDIF)))  						continue;    				if (se.isData)  				{  					stack.Push(se.data);  					continue;  				}    				switch (se.opCode)  				{  					case OpCode.OP_RESERVED:  						{  							return false;  						}  					case OpCode.OP_NOP:  						{  							// NOP' Dump stack for debug  							/*  							stack.ToList().ForEach(x => Console.WriteLine(HexString.FromByteArray(x)));  							Console.WriteLine("---------------------------");  							*/  							break;  						}  					case OpCode.OP_VER:  						{  							return false;  						}  					case OpCode.OP_IF:  					case OpCode.OP_NOTIF:  						{  							if (stack.Count < 1)  								return false;  							Boolean stackIsZero = new ScriptVarInt(stack.Pop()).value.IsZero;  							if ((se.opCode == OpCode.OP_IF && !stackIsZero) || (se.opCode == OpCode.OP_NOTIF && stackIsZero))  							{  								// Run to else or endif  								ifExec.Push(IfElseExec.RUN_IF);  							}  							else  							{  								// Skip to else or endif  								ifExec.Push(IfElseExec.SKIP_IF);  							}  							break;  						}  					case OpCode.OP_VERIF:  					case OpCode.OP_VERNOTIF:  						{  							return false;  						}  					case OpCode.OP_ELSE:  						{  							if (ifExec.Count == 0)  								// No preceding if statement!  								return false;  							if (ifExec.First() == IfElseExec.RUN_IF)  							{  								// If ran' skip else  								ifExec.Push(IfElseExec.SKIP_ELSE);  							}  							else if (ifExec.First() == IfElseExec.SKIP_IF)  							{  								// If did not run' run else  								ifExec.Push(IfElseExec.RUN_ELSE);  							}  							break;  						}  					case OpCode.OP_ENDIF:  						{  							if (ifExec.Count == 0)  								// No preceding if statement!  								return false;  							if (ifExec.First() == IfElseExec.RUN_IF ||  								ifExec.First() == IfElseExec.SKIP_IF)  							{  								ifExec.Pop();  							}  							else if (ifExec.First() == IfElseExec.RUN_ELSE ||  							   ifExec.First() == IfElseExec.SKIP_ELSE)  							{  								ifExec.Pop();  								ifExec.Pop();  							}  							break;  						}  					case OpCode.OP_VERIFY:  						{  							if (stack.Count < 1 || new ScriptVarInt(stack.First()).value.IsZero)  								return false;  							stack.Pop();  							break;  						}  					case OpCode.OP_RETURN:  						{  							return false;  						}  					case OpCode.OP_TOALTSTACK:  						{  							if (stack.Count < 1)  								return false;  							altstack.Push(stack.Pop());  							break;  						}  					case OpCode.OP_FROMALTSTACK:  						{  							if (altstack.Count < 1)  								return false;  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_2DROP:  						{  							if (stack.Count < 2)  								return false;  							stack.Pop();  							stack.Pop();  							break;  						}  					case OpCode.OP_2DUP:  						{  							if (stack.Count < 2)  								return false;  							stack.Push(stack.Skip(1).First());  							stack.Push(stack.Skip(1).First());  							break;  						}  					case OpCode.OP_3DUP:  						{  							if (stack.Count < 3)  								return false;  							stack.Push(stack.Skip(2).First());  							stack.Push(stack.Skip(2).First());  							stack.Push(stack.Skip(2).First());  							break;  						}  					case OpCode.OP_2OVER:  						{  							if (stack.Count < 4)  								return false;  							stack.Push(stack.Skip(3).First());  							stack.Push(stack.Skip(3).First());  							break;  						}  					case OpCode.OP_2ROT:  						{  							if (stack.Count < 6)  								return false;  							altstack.Push(stack.Skip(4).First());  							altstack.Push(stack.Skip(5).First());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_2SWAP:  						{  							if (stack.Count < 4)  								return false;  							altstack.Push(stack.Skip(2).First());  							altstack.Push(stack.Skip(3).First());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_IFDUP:  						{  							if (stack.Count < 1)  								return false;  							if (!new ScriptVarInt(stack.First()).value.IsZero)  								stack.Push(stack.First());  							break;  						}  					case OpCode.OP_DEPTH:  						{  							stack.Push(new ScriptVarInt((UInt64)stack.Count).ToBytes());  							break;  						}  					case OpCode.OP_DROP:  						{  							if (stack.Count < 1)  								return false;  							stack.Pop();  							break;  						}  					case OpCode.OP_DUP:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(stack.First());  							break;  						}  					case OpCode.OP_NIP:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_OVER:  						{  							if (stack.Count < 2)  								return false;  							stack.Push(stack.Skip(1).First());  							break;  						}  					case OpCode.OP_PICK:  						{  							if (stack.Count < 2)  								return false;  							int pick = new ScriptVarInt(stack.Pop()).intValue;  							if (pick < 0 || stack.Count <= pick)  								return false;  							stack.Push(stack.Skip(pick).First());  							break;  						}  					case OpCode.OP_ROLL:  						{  							if (stack.Count < 2)  								return false;  							int roll = new ScriptVarInt(stack.Pop()).intValue;  							if (roll < 0 || stack.Count <= roll)  								return false;  							altstack.Push(stack.Skip(roll).First());  							for (int i = 0; i < roll; i++)  								altstack.Push(stack.Pop());  							stack.Pop();  							for (int i = 0; i < roll + 1; i++)  								stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_ROT:  						{  							if (stack.Count < 3)  								return false;  							altstack.Push(stack.Skip(2).First());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_SWAP:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Skip(1).First());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_TUCK:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Push(altstack.Skip(1).First());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_CAT:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Skip(1).First().Concat(stack.First()).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_SUBSTR:  						{  							if (stack.Count < 3)  								return false;  							altstack.Push(stack.Skip(2).First()  								.Skip(new ScriptVarInt(stack.Skip(1).First()).intValue)  								.Take(new ScriptVarInt(stack.First()).intValue).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_LEFT:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Skip(1).First()  								.Take(new ScriptVarInt(stack.First()).intValue).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_RIGHT:  						{  							if (stack.Count < 2)  								return false;  							int count = new ScriptVarInt(stack.First()).intValue;  							altstack.Push(stack.Skip(1).First()  								.Skip(stack.Skip(1).First().Length - count).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_SIZE:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(new ScriptVarInt((UInt64)stack.First().Length).ToBytes());  							break;  						}  					case OpCode.OP_INVERT:  						{  							if (stack.Count < 1)  								return false;  							Byte[] data = stack.Pop();  							for (int i = 0; i < data.Length; i++)  								data[i] ^= 0xFF;  							stack.Push(data);  							break;  						}  					case OpCode.OP_AND:  					case OpCode.OP_OR:  					case OpCode.OP_XOR:  						{  							if (stack.Count < 2)  								return false;  							Byte[] data = stack.Pop();  							Byte[] data2 = stack.Pop();  							int length = new int[] { data.Length' data2.Length }.Max();  							data = data.Concat(new Byte[length - data.Length]).ToArray();  							data2 = data2.Concat(new Byte[length - data2.Length]).ToArray();  							switch (se.opCode)  							{  								case OpCode.OP_AND:  									{  										for (int i = 0; i < length; i++)  											data[i] &= data2[i];  										break;  									}  								case OpCode.OP_OR:  									{  										for (int i = 0; i < length; i++)  											data[i] |= data2[i];  										break;  									}  								case OpCode.OP_XOR:  									{  										for (int i = 0; i < length; i++)  											data[i] ^= data2[i];  										break;  									}  							}  							stack.Push(data);  							break;  						}  					case OpCode.OP_EQUAL:  					case OpCode.OP_EQUALVERIFY:  						{  							if (stack.Count < 2)  								return false;  							if (stack.Pop().SequenceEqual(stack.Pop()))  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });    							if (se.opCode == OpCode.OP_EQUALVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_RESERVED1:  					case OpCode.OP_RESERVED2:  						{  							return false;  						}  					case OpCode.OP_1ADD:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Add(new ScriptVarInt(stack.Pop())' 1)).ToBytes());  							break;  						}  					case OpCode.OP_1SUB:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Subtract(new ScriptVarInt(stack.Pop())' 1)).ToBytes());  							break;  						}  					case OpCode.OP_2MUL:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Multiply(new ScriptVarInt(stack.Pop())' 2)).ToBytes());  							break;  						}  					case OpCode.OP_2DIV:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Divide(new ScriptVarInt(stack.Pop())' 2)).ToBytes());  							break;  						}  					case OpCode.OP_NEGATE:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Negate(new ScriptVarInt(stack.Pop()))).ToBytes());  							break;  						}  					case OpCode.OP_ABS:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Abs(new ScriptVarInt(stack.Pop()))).ToBytes());  							break;  						}  					case OpCode.OP_NOT:  						{  							if (stack.Count < 1)  								return false;  							if (new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_0NOTEQUAL:  						{  							if (stack.Count < 1)  								return false;  							if (new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x00 });  							else  								stack.Push(new Byte[] { 0x01 });  							break;  						}  					case OpCode.OP_ADD:  					case OpCode.OP_SUB:  					case OpCode.OP_MUL:  					case OpCode.OP_DIV:  					case OpCode.OP_MOD:  					case OpCode.OP_LSHIFT:  					case OpCode.OP_RSHIFT:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							switch (se.opCode)  							{  								case OpCode.OP_ADD:  									a = (BigInteger)a + b;  									break;  								case OpCode.OP_SUB:  									a = (BigInteger)a - b;  									break;  								case OpCode.OP_MUL:  									a = (BigInteger)a * b;  									break;  								case OpCode.OP_DIV:  									a = (BigInteger)a / b;  									break;  								case OpCode.OP_MOD:  									a = (BigInteger)a % b;  									break;  								case OpCode.OP_LSHIFT:  									a = (BigInteger)a << b.intValue;  									break;  								case OpCode.OP_RSHIFT:  									a = (BigInteger)a >> b.intValue;  									break;  							}  							stack.Push(a.ToBytes());  							break;  						}  					case OpCode.OP_BOOLAND:  						{  							if (stack.Count < 2)  								return false;  							if (!new ScriptVarInt(stack.Pop()).value.IsZero && !new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_BOOLOR:  						{  							if (stack.Count < 2)  								return false;  							if (!new ScriptVarInt(stack.Pop()).value.IsZero || !new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_NUMEQUAL:  					case OpCode.OP_NUMEQUALVERIFY:  						{  							if (stack.Count < 2)  								return false;  							if (new ScriptVarInt(stack.Pop()).value == new ScriptVarInt(stack.Pop()).value)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							if (se.opCode == OpCode.OP_NUMEQUALVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_NUMNOTEQUAL:  						{  							if (stack.Count < 2)  								return false;  							if (new ScriptVarInt(stack.Pop()).value != new ScriptVarInt(stack.Pop()).value)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_LESSTHAN:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a < b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_GREATERTHAN:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a > b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_LESSTHANOREQUAL:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a <= b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_GREATERTHANOREQUAL:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a >= b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_MIN:  						{  							if (stack.Count < 2)  								return false;  							Byte[] b = stack.Pop();  							Byte[] a = stack.Pop();  							if (new ScriptVarInt(a).value < new ScriptVarInt(b).value)  								stack.Push(a);  							else  								stack.Push(b);  							break;  						}  					case OpCode.OP_MAX:  						{  							if (stack.Count < 2)  								return false;  							Byte[] b = stack.Pop();  							Byte[] a = stack.Pop();  							if (new ScriptVarInt(a).value > new ScriptVarInt(b).value)  								stack.Push(a);  							else  								stack.Push(b);  							break;  						}  					case OpCode.OP_WITHIN:  						{  							if (stack.Count < 3)  								return false;  							ScriptVarInt max = new ScriptVarInt(stack.Pop());  							ScriptVarInt min = new ScriptVarInt(stack.Pop());  							ScriptVarInt x = new ScriptVarInt(stack.Pop());  							if ((BigInteger)min <= x && (BigInteger)x <= max)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_RIPEMD160:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(ripemd160.ComputeHash(stack.Pop()));  							break;  						}  					case OpCode.OP_SHA1:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(sha1.ComputeHash(stack.Pop()));  							break;  						}  					case OpCode.OP_SHA256:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(sha256.ComputeHash(stack.Pop()));  							break;  						}  					case OpCode.OP_HASH160:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(ripemd160.ComputeHash(sha256.ComputeHash(stack.Pop())));  							break;  						}  					case OpCode.OP_HASH256:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(sha256.ComputeHash(sha256.ComputeHash(stack.Pop())));  							break;  						}  					case OpCode.OP_CODESEPARATOR:  						{  							lastCodeSeperator = index;  							break;  						}  					case OpCode.OP_CHECKSIG:  					case OpCode.OP_CHECKSIGVERIFY:  						{  							if (tx == null)  								throw new ArgumentNullException("Transaction is required if script contains OP_CHECKSIG[VERIFY]");  							if (stack.Count < 2)  								return false;    							PublicKey pubKey = new PublicKey(stack.Pop());  							Byte[] sig = stack.Pop();    							Script subScript = new Script(elements.Skip(lastCodeSeperator)  								.Where(x => x.opCode != OpCode.OP_CODESEPARATOR).ToArray());    							stack.Push(new ScriptVarInt(CheckSig(sig' pubKey' txInIndex' subScript' tx) ? 1 : 0).ToBytes());    							if (se.opCode == OpCode.OP_CHECKSIGVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_CHECKMULTISIG:  					case OpCode.OP_CHECKMULTISIGVERIFY:  						{  							if (tx == null)  								throw new ArgumentNullException("Transaction is required if script contains OP_CHECKMULTISIG[VERIFY]");  							if (stack.Count < 2)  								return false;    							PublicKey[] pubKeys = new PublicKey[new ScriptVarInt(stack.Pop()).intValue];    							if (stack.Count < pubKeys.Length + 1)  								return false;    							for (int i = 0; i < pubKeys.Length; i++)  							{  								pubKeys[i] = new PublicKey(stack.Pop());  							}    							Byte[][] sigs = new Byte[new ScriptVarInt(stack.Pop()).intValue][];    							if (stack.Count < sigs.Length)  								return false;    							for (int i = 0; i < sigs.Length; i++)  							{  								sigs[i] = stack.Pop();  							}    							// Remove extra unused value from stack  							stack.Pop();    							Script subScript = new Script(elements.Skip(lastCodeSeperator)  								.Where(x => x.opCode != OpCode.OP_CODESEPARATOR).ToArray());    							int validSigs = 0;  							foreach (Byte[] sig in sigs)  							{  								foreach (PublicKey pubKey in pubKeys)  								{  									if (CheckSig(sig' pubKey' txInIndex' subScript' tx))  									{  										pubKeys = pubKeys.Where(x => x != pubKey).ToArray();  										validSigs++;  										break;  									}  								}  							}    							stack.Push(new ScriptVarInt((validSigs >= sigs.Length) ? 1 : 0).ToBytes());    							if (se.opCode == OpCode.OP_CHECKMULTISIGVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_NOP1:  					case OpCode.OP_NOP2:  					case OpCode.OP_NOP3:  					case OpCode.OP_NOP4:  					case OpCode.OP_NOP5:  					case OpCode.OP_NOP6:  					case OpCode.OP_NOP7:  					case OpCode.OP_NOP8:  					case OpCode.OP_NOP9:  					case OpCode.OP_NOP10:  						{  							break;  						}  					case OpCode.OP_SMALLINTEGER:  					case OpCode.OP_PUBKEYS:  					case OpCode.OP_PUBKEYHASH:  					case OpCode.OP_PUBKEY:  					case OpCode.OP_INVALIDOPCODE:  					default:  						{  							return false;  						}    				}  			}
Magic Number,Bitcoin_Tool.Scripts,Script,C:\repos\mb300sd_Bitcoin-Tool\Bitcoin Tool\Scripts\Script.cs,Evaluate,The following statement contains a magic number: for (int index = 0; index < elements.Count; index++)  			{  				ScriptElement se = elements[index];  				if (ifExec.Count > 0)  					if ((ifExec.First() == IfElseExec.SKIP_IF && !(se.opCode == OpCode.OP_ELSE || se.opCode == OpCode.OP_ENDIF)) ||  						(ifExec.First() == IfElseExec.SKIP_ELSE && !(se.opCode == OpCode.OP_ENDIF)))  						continue;    				if (se.isData)  				{  					stack.Push(se.data);  					continue;  				}    				switch (se.opCode)  				{  					case OpCode.OP_RESERVED:  						{  							return false;  						}  					case OpCode.OP_NOP:  						{  							// NOP' Dump stack for debug  							/*  							stack.ToList().ForEach(x => Console.WriteLine(HexString.FromByteArray(x)));  							Console.WriteLine("---------------------------");  							*/  							break;  						}  					case OpCode.OP_VER:  						{  							return false;  						}  					case OpCode.OP_IF:  					case OpCode.OP_NOTIF:  						{  							if (stack.Count < 1)  								return false;  							Boolean stackIsZero = new ScriptVarInt(stack.Pop()).value.IsZero;  							if ((se.opCode == OpCode.OP_IF && !stackIsZero) || (se.opCode == OpCode.OP_NOTIF && stackIsZero))  							{  								// Run to else or endif  								ifExec.Push(IfElseExec.RUN_IF);  							}  							else  							{  								// Skip to else or endif  								ifExec.Push(IfElseExec.SKIP_IF);  							}  							break;  						}  					case OpCode.OP_VERIF:  					case OpCode.OP_VERNOTIF:  						{  							return false;  						}  					case OpCode.OP_ELSE:  						{  							if (ifExec.Count == 0)  								// No preceding if statement!  								return false;  							if (ifExec.First() == IfElseExec.RUN_IF)  							{  								// If ran' skip else  								ifExec.Push(IfElseExec.SKIP_ELSE);  							}  							else if (ifExec.First() == IfElseExec.SKIP_IF)  							{  								// If did not run' run else  								ifExec.Push(IfElseExec.RUN_ELSE);  							}  							break;  						}  					case OpCode.OP_ENDIF:  						{  							if (ifExec.Count == 0)  								// No preceding if statement!  								return false;  							if (ifExec.First() == IfElseExec.RUN_IF ||  								ifExec.First() == IfElseExec.SKIP_IF)  							{  								ifExec.Pop();  							}  							else if (ifExec.First() == IfElseExec.RUN_ELSE ||  							   ifExec.First() == IfElseExec.SKIP_ELSE)  							{  								ifExec.Pop();  								ifExec.Pop();  							}  							break;  						}  					case OpCode.OP_VERIFY:  						{  							if (stack.Count < 1 || new ScriptVarInt(stack.First()).value.IsZero)  								return false;  							stack.Pop();  							break;  						}  					case OpCode.OP_RETURN:  						{  							return false;  						}  					case OpCode.OP_TOALTSTACK:  						{  							if (stack.Count < 1)  								return false;  							altstack.Push(stack.Pop());  							break;  						}  					case OpCode.OP_FROMALTSTACK:  						{  							if (altstack.Count < 1)  								return false;  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_2DROP:  						{  							if (stack.Count < 2)  								return false;  							stack.Pop();  							stack.Pop();  							break;  						}  					case OpCode.OP_2DUP:  						{  							if (stack.Count < 2)  								return false;  							stack.Push(stack.Skip(1).First());  							stack.Push(stack.Skip(1).First());  							break;  						}  					case OpCode.OP_3DUP:  						{  							if (stack.Count < 3)  								return false;  							stack.Push(stack.Skip(2).First());  							stack.Push(stack.Skip(2).First());  							stack.Push(stack.Skip(2).First());  							break;  						}  					case OpCode.OP_2OVER:  						{  							if (stack.Count < 4)  								return false;  							stack.Push(stack.Skip(3).First());  							stack.Push(stack.Skip(3).First());  							break;  						}  					case OpCode.OP_2ROT:  						{  							if (stack.Count < 6)  								return false;  							altstack.Push(stack.Skip(4).First());  							altstack.Push(stack.Skip(5).First());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_2SWAP:  						{  							if (stack.Count < 4)  								return false;  							altstack.Push(stack.Skip(2).First());  							altstack.Push(stack.Skip(3).First());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_IFDUP:  						{  							if (stack.Count < 1)  								return false;  							if (!new ScriptVarInt(stack.First()).value.IsZero)  								stack.Push(stack.First());  							break;  						}  					case OpCode.OP_DEPTH:  						{  							stack.Push(new ScriptVarInt((UInt64)stack.Count).ToBytes());  							break;  						}  					case OpCode.OP_DROP:  						{  							if (stack.Count < 1)  								return false;  							stack.Pop();  							break;  						}  					case OpCode.OP_DUP:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(stack.First());  							break;  						}  					case OpCode.OP_NIP:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_OVER:  						{  							if (stack.Count < 2)  								return false;  							stack.Push(stack.Skip(1).First());  							break;  						}  					case OpCode.OP_PICK:  						{  							if (stack.Count < 2)  								return false;  							int pick = new ScriptVarInt(stack.Pop()).intValue;  							if (pick < 0 || stack.Count <= pick)  								return false;  							stack.Push(stack.Skip(pick).First());  							break;  						}  					case OpCode.OP_ROLL:  						{  							if (stack.Count < 2)  								return false;  							int roll = new ScriptVarInt(stack.Pop()).intValue;  							if (roll < 0 || stack.Count <= roll)  								return false;  							altstack.Push(stack.Skip(roll).First());  							for (int i = 0; i < roll; i++)  								altstack.Push(stack.Pop());  							stack.Pop();  							for (int i = 0; i < roll + 1; i++)  								stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_ROT:  						{  							if (stack.Count < 3)  								return false;  							altstack.Push(stack.Skip(2).First());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_SWAP:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Skip(1).First());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_TUCK:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Push(altstack.Skip(1).First());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_CAT:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Skip(1).First().Concat(stack.First()).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_SUBSTR:  						{  							if (stack.Count < 3)  								return false;  							altstack.Push(stack.Skip(2).First()  								.Skip(new ScriptVarInt(stack.Skip(1).First()).intValue)  								.Take(new ScriptVarInt(stack.First()).intValue).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_LEFT:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Skip(1).First()  								.Take(new ScriptVarInt(stack.First()).intValue).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_RIGHT:  						{  							if (stack.Count < 2)  								return false;  							int count = new ScriptVarInt(stack.First()).intValue;  							altstack.Push(stack.Skip(1).First()  								.Skip(stack.Skip(1).First().Length - count).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_SIZE:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(new ScriptVarInt((UInt64)stack.First().Length).ToBytes());  							break;  						}  					case OpCode.OP_INVERT:  						{  							if (stack.Count < 1)  								return false;  							Byte[] data = stack.Pop();  							for (int i = 0; i < data.Length; i++)  								data[i] ^= 0xFF;  							stack.Push(data);  							break;  						}  					case OpCode.OP_AND:  					case OpCode.OP_OR:  					case OpCode.OP_XOR:  						{  							if (stack.Count < 2)  								return false;  							Byte[] data = stack.Pop();  							Byte[] data2 = stack.Pop();  							int length = new int[] { data.Length' data2.Length }.Max();  							data = data.Concat(new Byte[length - data.Length]).ToArray();  							data2 = data2.Concat(new Byte[length - data2.Length]).ToArray();  							switch (se.opCode)  							{  								case OpCode.OP_AND:  									{  										for (int i = 0; i < length; i++)  											data[i] &= data2[i];  										break;  									}  								case OpCode.OP_OR:  									{  										for (int i = 0; i < length; i++)  											data[i] |= data2[i];  										break;  									}  								case OpCode.OP_XOR:  									{  										for (int i = 0; i < length; i++)  											data[i] ^= data2[i];  										break;  									}  							}  							stack.Push(data);  							break;  						}  					case OpCode.OP_EQUAL:  					case OpCode.OP_EQUALVERIFY:  						{  							if (stack.Count < 2)  								return false;  							if (stack.Pop().SequenceEqual(stack.Pop()))  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });    							if (se.opCode == OpCode.OP_EQUALVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_RESERVED1:  					case OpCode.OP_RESERVED2:  						{  							return false;  						}  					case OpCode.OP_1ADD:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Add(new ScriptVarInt(stack.Pop())' 1)).ToBytes());  							break;  						}  					case OpCode.OP_1SUB:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Subtract(new ScriptVarInt(stack.Pop())' 1)).ToBytes());  							break;  						}  					case OpCode.OP_2MUL:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Multiply(new ScriptVarInt(stack.Pop())' 2)).ToBytes());  							break;  						}  					case OpCode.OP_2DIV:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Divide(new ScriptVarInt(stack.Pop())' 2)).ToBytes());  							break;  						}  					case OpCode.OP_NEGATE:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Negate(new ScriptVarInt(stack.Pop()))).ToBytes());  							break;  						}  					case OpCode.OP_ABS:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Abs(new ScriptVarInt(stack.Pop()))).ToBytes());  							break;  						}  					case OpCode.OP_NOT:  						{  							if (stack.Count < 1)  								return false;  							if (new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_0NOTEQUAL:  						{  							if (stack.Count < 1)  								return false;  							if (new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x00 });  							else  								stack.Push(new Byte[] { 0x01 });  							break;  						}  					case OpCode.OP_ADD:  					case OpCode.OP_SUB:  					case OpCode.OP_MUL:  					case OpCode.OP_DIV:  					case OpCode.OP_MOD:  					case OpCode.OP_LSHIFT:  					case OpCode.OP_RSHIFT:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							switch (se.opCode)  							{  								case OpCode.OP_ADD:  									a = (BigInteger)a + b;  									break;  								case OpCode.OP_SUB:  									a = (BigInteger)a - b;  									break;  								case OpCode.OP_MUL:  									a = (BigInteger)a * b;  									break;  								case OpCode.OP_DIV:  									a = (BigInteger)a / b;  									break;  								case OpCode.OP_MOD:  									a = (BigInteger)a % b;  									break;  								case OpCode.OP_LSHIFT:  									a = (BigInteger)a << b.intValue;  									break;  								case OpCode.OP_RSHIFT:  									a = (BigInteger)a >> b.intValue;  									break;  							}  							stack.Push(a.ToBytes());  							break;  						}  					case OpCode.OP_BOOLAND:  						{  							if (stack.Count < 2)  								return false;  							if (!new ScriptVarInt(stack.Pop()).value.IsZero && !new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_BOOLOR:  						{  							if (stack.Count < 2)  								return false;  							if (!new ScriptVarInt(stack.Pop()).value.IsZero || !new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_NUMEQUAL:  					case OpCode.OP_NUMEQUALVERIFY:  						{  							if (stack.Count < 2)  								return false;  							if (new ScriptVarInt(stack.Pop()).value == new ScriptVarInt(stack.Pop()).value)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							if (se.opCode == OpCode.OP_NUMEQUALVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_NUMNOTEQUAL:  						{  							if (stack.Count < 2)  								return false;  							if (new ScriptVarInt(stack.Pop()).value != new ScriptVarInt(stack.Pop()).value)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_LESSTHAN:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a < b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_GREATERTHAN:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a > b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_LESSTHANOREQUAL:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a <= b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_GREATERTHANOREQUAL:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a >= b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_MIN:  						{  							if (stack.Count < 2)  								return false;  							Byte[] b = stack.Pop();  							Byte[] a = stack.Pop();  							if (new ScriptVarInt(a).value < new ScriptVarInt(b).value)  								stack.Push(a);  							else  								stack.Push(b);  							break;  						}  					case OpCode.OP_MAX:  						{  							if (stack.Count < 2)  								return false;  							Byte[] b = stack.Pop();  							Byte[] a = stack.Pop();  							if (new ScriptVarInt(a).value > new ScriptVarInt(b).value)  								stack.Push(a);  							else  								stack.Push(b);  							break;  						}  					case OpCode.OP_WITHIN:  						{  							if (stack.Count < 3)  								return false;  							ScriptVarInt max = new ScriptVarInt(stack.Pop());  							ScriptVarInt min = new ScriptVarInt(stack.Pop());  							ScriptVarInt x = new ScriptVarInt(stack.Pop());  							if ((BigInteger)min <= x && (BigInteger)x <= max)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_RIPEMD160:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(ripemd160.ComputeHash(stack.Pop()));  							break;  						}  					case OpCode.OP_SHA1:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(sha1.ComputeHash(stack.Pop()));  							break;  						}  					case OpCode.OP_SHA256:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(sha256.ComputeHash(stack.Pop()));  							break;  						}  					case OpCode.OP_HASH160:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(ripemd160.ComputeHash(sha256.ComputeHash(stack.Pop())));  							break;  						}  					case OpCode.OP_HASH256:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(sha256.ComputeHash(sha256.ComputeHash(stack.Pop())));  							break;  						}  					case OpCode.OP_CODESEPARATOR:  						{  							lastCodeSeperator = index;  							break;  						}  					case OpCode.OP_CHECKSIG:  					case OpCode.OP_CHECKSIGVERIFY:  						{  							if (tx == null)  								throw new ArgumentNullException("Transaction is required if script contains OP_CHECKSIG[VERIFY]");  							if (stack.Count < 2)  								return false;    							PublicKey pubKey = new PublicKey(stack.Pop());  							Byte[] sig = stack.Pop();    							Script subScript = new Script(elements.Skip(lastCodeSeperator)  								.Where(x => x.opCode != OpCode.OP_CODESEPARATOR).ToArray());    							stack.Push(new ScriptVarInt(CheckSig(sig' pubKey' txInIndex' subScript' tx) ? 1 : 0).ToBytes());    							if (se.opCode == OpCode.OP_CHECKSIGVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_CHECKMULTISIG:  					case OpCode.OP_CHECKMULTISIGVERIFY:  						{  							if (tx == null)  								throw new ArgumentNullException("Transaction is required if script contains OP_CHECKMULTISIG[VERIFY]");  							if (stack.Count < 2)  								return false;    							PublicKey[] pubKeys = new PublicKey[new ScriptVarInt(stack.Pop()).intValue];    							if (stack.Count < pubKeys.Length + 1)  								return false;    							for (int i = 0; i < pubKeys.Length; i++)  							{  								pubKeys[i] = new PublicKey(stack.Pop());  							}    							Byte[][] sigs = new Byte[new ScriptVarInt(stack.Pop()).intValue][];    							if (stack.Count < sigs.Length)  								return false;    							for (int i = 0; i < sigs.Length; i++)  							{  								sigs[i] = stack.Pop();  							}    							// Remove extra unused value from stack  							stack.Pop();    							Script subScript = new Script(elements.Skip(lastCodeSeperator)  								.Where(x => x.opCode != OpCode.OP_CODESEPARATOR).ToArray());    							int validSigs = 0;  							foreach (Byte[] sig in sigs)  							{  								foreach (PublicKey pubKey in pubKeys)  								{  									if (CheckSig(sig' pubKey' txInIndex' subScript' tx))  									{  										pubKeys = pubKeys.Where(x => x != pubKey).ToArray();  										validSigs++;  										break;  									}  								}  							}    							stack.Push(new ScriptVarInt((validSigs >= sigs.Length) ? 1 : 0).ToBytes());    							if (se.opCode == OpCode.OP_CHECKMULTISIGVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_NOP1:  					case OpCode.OP_NOP2:  					case OpCode.OP_NOP3:  					case OpCode.OP_NOP4:  					case OpCode.OP_NOP5:  					case OpCode.OP_NOP6:  					case OpCode.OP_NOP7:  					case OpCode.OP_NOP8:  					case OpCode.OP_NOP9:  					case OpCode.OP_NOP10:  						{  							break;  						}  					case OpCode.OP_SMALLINTEGER:  					case OpCode.OP_PUBKEYS:  					case OpCode.OP_PUBKEYHASH:  					case OpCode.OP_PUBKEY:  					case OpCode.OP_INVALIDOPCODE:  					default:  						{  							return false;  						}    				}  			}
Magic Number,Bitcoin_Tool.Scripts,Script,C:\repos\mb300sd_Bitcoin-Tool\Bitcoin Tool\Scripts\Script.cs,Evaluate,The following statement contains a magic number: for (int index = 0; index < elements.Count; index++)  			{  				ScriptElement se = elements[index];  				if (ifExec.Count > 0)  					if ((ifExec.First() == IfElseExec.SKIP_IF && !(se.opCode == OpCode.OP_ELSE || se.opCode == OpCode.OP_ENDIF)) ||  						(ifExec.First() == IfElseExec.SKIP_ELSE && !(se.opCode == OpCode.OP_ENDIF)))  						continue;    				if (se.isData)  				{  					stack.Push(se.data);  					continue;  				}    				switch (se.opCode)  				{  					case OpCode.OP_RESERVED:  						{  							return false;  						}  					case OpCode.OP_NOP:  						{  							// NOP' Dump stack for debug  							/*  							stack.ToList().ForEach(x => Console.WriteLine(HexString.FromByteArray(x)));  							Console.WriteLine("---------------------------");  							*/  							break;  						}  					case OpCode.OP_VER:  						{  							return false;  						}  					case OpCode.OP_IF:  					case OpCode.OP_NOTIF:  						{  							if (stack.Count < 1)  								return false;  							Boolean stackIsZero = new ScriptVarInt(stack.Pop()).value.IsZero;  							if ((se.opCode == OpCode.OP_IF && !stackIsZero) || (se.opCode == OpCode.OP_NOTIF && stackIsZero))  							{  								// Run to else or endif  								ifExec.Push(IfElseExec.RUN_IF);  							}  							else  							{  								// Skip to else or endif  								ifExec.Push(IfElseExec.SKIP_IF);  							}  							break;  						}  					case OpCode.OP_VERIF:  					case OpCode.OP_VERNOTIF:  						{  							return false;  						}  					case OpCode.OP_ELSE:  						{  							if (ifExec.Count == 0)  								// No preceding if statement!  								return false;  							if (ifExec.First() == IfElseExec.RUN_IF)  							{  								// If ran' skip else  								ifExec.Push(IfElseExec.SKIP_ELSE);  							}  							else if (ifExec.First() == IfElseExec.SKIP_IF)  							{  								// If did not run' run else  								ifExec.Push(IfElseExec.RUN_ELSE);  							}  							break;  						}  					case OpCode.OP_ENDIF:  						{  							if (ifExec.Count == 0)  								// No preceding if statement!  								return false;  							if (ifExec.First() == IfElseExec.RUN_IF ||  								ifExec.First() == IfElseExec.SKIP_IF)  							{  								ifExec.Pop();  							}  							else if (ifExec.First() == IfElseExec.RUN_ELSE ||  							   ifExec.First() == IfElseExec.SKIP_ELSE)  							{  								ifExec.Pop();  								ifExec.Pop();  							}  							break;  						}  					case OpCode.OP_VERIFY:  						{  							if (stack.Count < 1 || new ScriptVarInt(stack.First()).value.IsZero)  								return false;  							stack.Pop();  							break;  						}  					case OpCode.OP_RETURN:  						{  							return false;  						}  					case OpCode.OP_TOALTSTACK:  						{  							if (stack.Count < 1)  								return false;  							altstack.Push(stack.Pop());  							break;  						}  					case OpCode.OP_FROMALTSTACK:  						{  							if (altstack.Count < 1)  								return false;  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_2DROP:  						{  							if (stack.Count < 2)  								return false;  							stack.Pop();  							stack.Pop();  							break;  						}  					case OpCode.OP_2DUP:  						{  							if (stack.Count < 2)  								return false;  							stack.Push(stack.Skip(1).First());  							stack.Push(stack.Skip(1).First());  							break;  						}  					case OpCode.OP_3DUP:  						{  							if (stack.Count < 3)  								return false;  							stack.Push(stack.Skip(2).First());  							stack.Push(stack.Skip(2).First());  							stack.Push(stack.Skip(2).First());  							break;  						}  					case OpCode.OP_2OVER:  						{  							if (stack.Count < 4)  								return false;  							stack.Push(stack.Skip(3).First());  							stack.Push(stack.Skip(3).First());  							break;  						}  					case OpCode.OP_2ROT:  						{  							if (stack.Count < 6)  								return false;  							altstack.Push(stack.Skip(4).First());  							altstack.Push(stack.Skip(5).First());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_2SWAP:  						{  							if (stack.Count < 4)  								return false;  							altstack.Push(stack.Skip(2).First());  							altstack.Push(stack.Skip(3).First());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_IFDUP:  						{  							if (stack.Count < 1)  								return false;  							if (!new ScriptVarInt(stack.First()).value.IsZero)  								stack.Push(stack.First());  							break;  						}  					case OpCode.OP_DEPTH:  						{  							stack.Push(new ScriptVarInt((UInt64)stack.Count).ToBytes());  							break;  						}  					case OpCode.OP_DROP:  						{  							if (stack.Count < 1)  								return false;  							stack.Pop();  							break;  						}  					case OpCode.OP_DUP:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(stack.First());  							break;  						}  					case OpCode.OP_NIP:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_OVER:  						{  							if (stack.Count < 2)  								return false;  							stack.Push(stack.Skip(1).First());  							break;  						}  					case OpCode.OP_PICK:  						{  							if (stack.Count < 2)  								return false;  							int pick = new ScriptVarInt(stack.Pop()).intValue;  							if (pick < 0 || stack.Count <= pick)  								return false;  							stack.Push(stack.Skip(pick).First());  							break;  						}  					case OpCode.OP_ROLL:  						{  							if (stack.Count < 2)  								return false;  							int roll = new ScriptVarInt(stack.Pop()).intValue;  							if (roll < 0 || stack.Count <= roll)  								return false;  							altstack.Push(stack.Skip(roll).First());  							for (int i = 0; i < roll; i++)  								altstack.Push(stack.Pop());  							stack.Pop();  							for (int i = 0; i < roll + 1; i++)  								stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_ROT:  						{  							if (stack.Count < 3)  								return false;  							altstack.Push(stack.Skip(2).First());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_SWAP:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Skip(1).First());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_TUCK:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Push(altstack.Skip(1).First());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_CAT:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Skip(1).First().Concat(stack.First()).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_SUBSTR:  						{  							if (stack.Count < 3)  								return false;  							altstack.Push(stack.Skip(2).First()  								.Skip(new ScriptVarInt(stack.Skip(1).First()).intValue)  								.Take(new ScriptVarInt(stack.First()).intValue).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_LEFT:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Skip(1).First()  								.Take(new ScriptVarInt(stack.First()).intValue).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_RIGHT:  						{  							if (stack.Count < 2)  								return false;  							int count = new ScriptVarInt(stack.First()).intValue;  							altstack.Push(stack.Skip(1).First()  								.Skip(stack.Skip(1).First().Length - count).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_SIZE:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(new ScriptVarInt((UInt64)stack.First().Length).ToBytes());  							break;  						}  					case OpCode.OP_INVERT:  						{  							if (stack.Count < 1)  								return false;  							Byte[] data = stack.Pop();  							for (int i = 0; i < data.Length; i++)  								data[i] ^= 0xFF;  							stack.Push(data);  							break;  						}  					case OpCode.OP_AND:  					case OpCode.OP_OR:  					case OpCode.OP_XOR:  						{  							if (stack.Count < 2)  								return false;  							Byte[] data = stack.Pop();  							Byte[] data2 = stack.Pop();  							int length = new int[] { data.Length' data2.Length }.Max();  							data = data.Concat(new Byte[length - data.Length]).ToArray();  							data2 = data2.Concat(new Byte[length - data2.Length]).ToArray();  							switch (se.opCode)  							{  								case OpCode.OP_AND:  									{  										for (int i = 0; i < length; i++)  											data[i] &= data2[i];  										break;  									}  								case OpCode.OP_OR:  									{  										for (int i = 0; i < length; i++)  											data[i] |= data2[i];  										break;  									}  								case OpCode.OP_XOR:  									{  										for (int i = 0; i < length; i++)  											data[i] ^= data2[i];  										break;  									}  							}  							stack.Push(data);  							break;  						}  					case OpCode.OP_EQUAL:  					case OpCode.OP_EQUALVERIFY:  						{  							if (stack.Count < 2)  								return false;  							if (stack.Pop().SequenceEqual(stack.Pop()))  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });    							if (se.opCode == OpCode.OP_EQUALVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_RESERVED1:  					case OpCode.OP_RESERVED2:  						{  							return false;  						}  					case OpCode.OP_1ADD:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Add(new ScriptVarInt(stack.Pop())' 1)).ToBytes());  							break;  						}  					case OpCode.OP_1SUB:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Subtract(new ScriptVarInt(stack.Pop())' 1)).ToBytes());  							break;  						}  					case OpCode.OP_2MUL:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Multiply(new ScriptVarInt(stack.Pop())' 2)).ToBytes());  							break;  						}  					case OpCode.OP_2DIV:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Divide(new ScriptVarInt(stack.Pop())' 2)).ToBytes());  							break;  						}  					case OpCode.OP_NEGATE:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Negate(new ScriptVarInt(stack.Pop()))).ToBytes());  							break;  						}  					case OpCode.OP_ABS:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Abs(new ScriptVarInt(stack.Pop()))).ToBytes());  							break;  						}  					case OpCode.OP_NOT:  						{  							if (stack.Count < 1)  								return false;  							if (new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_0NOTEQUAL:  						{  							if (stack.Count < 1)  								return false;  							if (new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x00 });  							else  								stack.Push(new Byte[] { 0x01 });  							break;  						}  					case OpCode.OP_ADD:  					case OpCode.OP_SUB:  					case OpCode.OP_MUL:  					case OpCode.OP_DIV:  					case OpCode.OP_MOD:  					case OpCode.OP_LSHIFT:  					case OpCode.OP_RSHIFT:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							switch (se.opCode)  							{  								case OpCode.OP_ADD:  									a = (BigInteger)a + b;  									break;  								case OpCode.OP_SUB:  									a = (BigInteger)a - b;  									break;  								case OpCode.OP_MUL:  									a = (BigInteger)a * b;  									break;  								case OpCode.OP_DIV:  									a = (BigInteger)a / b;  									break;  								case OpCode.OP_MOD:  									a = (BigInteger)a % b;  									break;  								case OpCode.OP_LSHIFT:  									a = (BigInteger)a << b.intValue;  									break;  								case OpCode.OP_RSHIFT:  									a = (BigInteger)a >> b.intValue;  									break;  							}  							stack.Push(a.ToBytes());  							break;  						}  					case OpCode.OP_BOOLAND:  						{  							if (stack.Count < 2)  								return false;  							if (!new ScriptVarInt(stack.Pop()).value.IsZero && !new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_BOOLOR:  						{  							if (stack.Count < 2)  								return false;  							if (!new ScriptVarInt(stack.Pop()).value.IsZero || !new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_NUMEQUAL:  					case OpCode.OP_NUMEQUALVERIFY:  						{  							if (stack.Count < 2)  								return false;  							if (new ScriptVarInt(stack.Pop()).value == new ScriptVarInt(stack.Pop()).value)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							if (se.opCode == OpCode.OP_NUMEQUALVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_NUMNOTEQUAL:  						{  							if (stack.Count < 2)  								return false;  							if (new ScriptVarInt(stack.Pop()).value != new ScriptVarInt(stack.Pop()).value)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_LESSTHAN:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a < b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_GREATERTHAN:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a > b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_LESSTHANOREQUAL:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a <= b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_GREATERTHANOREQUAL:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a >= b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_MIN:  						{  							if (stack.Count < 2)  								return false;  							Byte[] b = stack.Pop();  							Byte[] a = stack.Pop();  							if (new ScriptVarInt(a).value < new ScriptVarInt(b).value)  								stack.Push(a);  							else  								stack.Push(b);  							break;  						}  					case OpCode.OP_MAX:  						{  							if (stack.Count < 2)  								return false;  							Byte[] b = stack.Pop();  							Byte[] a = stack.Pop();  							if (new ScriptVarInt(a).value > new ScriptVarInt(b).value)  								stack.Push(a);  							else  								stack.Push(b);  							break;  						}  					case OpCode.OP_WITHIN:  						{  							if (stack.Count < 3)  								return false;  							ScriptVarInt max = new ScriptVarInt(stack.Pop());  							ScriptVarInt min = new ScriptVarInt(stack.Pop());  							ScriptVarInt x = new ScriptVarInt(stack.Pop());  							if ((BigInteger)min <= x && (BigInteger)x <= max)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_RIPEMD160:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(ripemd160.ComputeHash(stack.Pop()));  							break;  						}  					case OpCode.OP_SHA1:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(sha1.ComputeHash(stack.Pop()));  							break;  						}  					case OpCode.OP_SHA256:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(sha256.ComputeHash(stack.Pop()));  							break;  						}  					case OpCode.OP_HASH160:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(ripemd160.ComputeHash(sha256.ComputeHash(stack.Pop())));  							break;  						}  					case OpCode.OP_HASH256:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(sha256.ComputeHash(sha256.ComputeHash(stack.Pop())));  							break;  						}  					case OpCode.OP_CODESEPARATOR:  						{  							lastCodeSeperator = index;  							break;  						}  					case OpCode.OP_CHECKSIG:  					case OpCode.OP_CHECKSIGVERIFY:  						{  							if (tx == null)  								throw new ArgumentNullException("Transaction is required if script contains OP_CHECKSIG[VERIFY]");  							if (stack.Count < 2)  								return false;    							PublicKey pubKey = new PublicKey(stack.Pop());  							Byte[] sig = stack.Pop();    							Script subScript = new Script(elements.Skip(lastCodeSeperator)  								.Where(x => x.opCode != OpCode.OP_CODESEPARATOR).ToArray());    							stack.Push(new ScriptVarInt(CheckSig(sig' pubKey' txInIndex' subScript' tx) ? 1 : 0).ToBytes());    							if (se.opCode == OpCode.OP_CHECKSIGVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_CHECKMULTISIG:  					case OpCode.OP_CHECKMULTISIGVERIFY:  						{  							if (tx == null)  								throw new ArgumentNullException("Transaction is required if script contains OP_CHECKMULTISIG[VERIFY]");  							if (stack.Count < 2)  								return false;    							PublicKey[] pubKeys = new PublicKey[new ScriptVarInt(stack.Pop()).intValue];    							if (stack.Count < pubKeys.Length + 1)  								return false;    							for (int i = 0; i < pubKeys.Length; i++)  							{  								pubKeys[i] = new PublicKey(stack.Pop());  							}    							Byte[][] sigs = new Byte[new ScriptVarInt(stack.Pop()).intValue][];    							if (stack.Count < sigs.Length)  								return false;    							for (int i = 0; i < sigs.Length; i++)  							{  								sigs[i] = stack.Pop();  							}    							// Remove extra unused value from stack  							stack.Pop();    							Script subScript = new Script(elements.Skip(lastCodeSeperator)  								.Where(x => x.opCode != OpCode.OP_CODESEPARATOR).ToArray());    							int validSigs = 0;  							foreach (Byte[] sig in sigs)  							{  								foreach (PublicKey pubKey in pubKeys)  								{  									if (CheckSig(sig' pubKey' txInIndex' subScript' tx))  									{  										pubKeys = pubKeys.Where(x => x != pubKey).ToArray();  										validSigs++;  										break;  									}  								}  							}    							stack.Push(new ScriptVarInt((validSigs >= sigs.Length) ? 1 : 0).ToBytes());    							if (se.opCode == OpCode.OP_CHECKMULTISIGVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_NOP1:  					case OpCode.OP_NOP2:  					case OpCode.OP_NOP3:  					case OpCode.OP_NOP4:  					case OpCode.OP_NOP5:  					case OpCode.OP_NOP6:  					case OpCode.OP_NOP7:  					case OpCode.OP_NOP8:  					case OpCode.OP_NOP9:  					case OpCode.OP_NOP10:  						{  							break;  						}  					case OpCode.OP_SMALLINTEGER:  					case OpCode.OP_PUBKEYS:  					case OpCode.OP_PUBKEYHASH:  					case OpCode.OP_PUBKEY:  					case OpCode.OP_INVALIDOPCODE:  					default:  						{  							return false;  						}    				}  			}
Magic Number,Bitcoin_Tool.Scripts,Script,C:\repos\mb300sd_Bitcoin-Tool\Bitcoin Tool\Scripts\Script.cs,Evaluate,The following statement contains a magic number: for (int index = 0; index < elements.Count; index++)  			{  				ScriptElement se = elements[index];  				if (ifExec.Count > 0)  					if ((ifExec.First() == IfElseExec.SKIP_IF && !(se.opCode == OpCode.OP_ELSE || se.opCode == OpCode.OP_ENDIF)) ||  						(ifExec.First() == IfElseExec.SKIP_ELSE && !(se.opCode == OpCode.OP_ENDIF)))  						continue;    				if (se.isData)  				{  					stack.Push(se.data);  					continue;  				}    				switch (se.opCode)  				{  					case OpCode.OP_RESERVED:  						{  							return false;  						}  					case OpCode.OP_NOP:  						{  							// NOP' Dump stack for debug  							/*  							stack.ToList().ForEach(x => Console.WriteLine(HexString.FromByteArray(x)));  							Console.WriteLine("---------------------------");  							*/  							break;  						}  					case OpCode.OP_VER:  						{  							return false;  						}  					case OpCode.OP_IF:  					case OpCode.OP_NOTIF:  						{  							if (stack.Count < 1)  								return false;  							Boolean stackIsZero = new ScriptVarInt(stack.Pop()).value.IsZero;  							if ((se.opCode == OpCode.OP_IF && !stackIsZero) || (se.opCode == OpCode.OP_NOTIF && stackIsZero))  							{  								// Run to else or endif  								ifExec.Push(IfElseExec.RUN_IF);  							}  							else  							{  								// Skip to else or endif  								ifExec.Push(IfElseExec.SKIP_IF);  							}  							break;  						}  					case OpCode.OP_VERIF:  					case OpCode.OP_VERNOTIF:  						{  							return false;  						}  					case OpCode.OP_ELSE:  						{  							if (ifExec.Count == 0)  								// No preceding if statement!  								return false;  							if (ifExec.First() == IfElseExec.RUN_IF)  							{  								// If ran' skip else  								ifExec.Push(IfElseExec.SKIP_ELSE);  							}  							else if (ifExec.First() == IfElseExec.SKIP_IF)  							{  								// If did not run' run else  								ifExec.Push(IfElseExec.RUN_ELSE);  							}  							break;  						}  					case OpCode.OP_ENDIF:  						{  							if (ifExec.Count == 0)  								// No preceding if statement!  								return false;  							if (ifExec.First() == IfElseExec.RUN_IF ||  								ifExec.First() == IfElseExec.SKIP_IF)  							{  								ifExec.Pop();  							}  							else if (ifExec.First() == IfElseExec.RUN_ELSE ||  							   ifExec.First() == IfElseExec.SKIP_ELSE)  							{  								ifExec.Pop();  								ifExec.Pop();  							}  							break;  						}  					case OpCode.OP_VERIFY:  						{  							if (stack.Count < 1 || new ScriptVarInt(stack.First()).value.IsZero)  								return false;  							stack.Pop();  							break;  						}  					case OpCode.OP_RETURN:  						{  							return false;  						}  					case OpCode.OP_TOALTSTACK:  						{  							if (stack.Count < 1)  								return false;  							altstack.Push(stack.Pop());  							break;  						}  					case OpCode.OP_FROMALTSTACK:  						{  							if (altstack.Count < 1)  								return false;  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_2DROP:  						{  							if (stack.Count < 2)  								return false;  							stack.Pop();  							stack.Pop();  							break;  						}  					case OpCode.OP_2DUP:  						{  							if (stack.Count < 2)  								return false;  							stack.Push(stack.Skip(1).First());  							stack.Push(stack.Skip(1).First());  							break;  						}  					case OpCode.OP_3DUP:  						{  							if (stack.Count < 3)  								return false;  							stack.Push(stack.Skip(2).First());  							stack.Push(stack.Skip(2).First());  							stack.Push(stack.Skip(2).First());  							break;  						}  					case OpCode.OP_2OVER:  						{  							if (stack.Count < 4)  								return false;  							stack.Push(stack.Skip(3).First());  							stack.Push(stack.Skip(3).First());  							break;  						}  					case OpCode.OP_2ROT:  						{  							if (stack.Count < 6)  								return false;  							altstack.Push(stack.Skip(4).First());  							altstack.Push(stack.Skip(5).First());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_2SWAP:  						{  							if (stack.Count < 4)  								return false;  							altstack.Push(stack.Skip(2).First());  							altstack.Push(stack.Skip(3).First());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_IFDUP:  						{  							if (stack.Count < 1)  								return false;  							if (!new ScriptVarInt(stack.First()).value.IsZero)  								stack.Push(stack.First());  							break;  						}  					case OpCode.OP_DEPTH:  						{  							stack.Push(new ScriptVarInt((UInt64)stack.Count).ToBytes());  							break;  						}  					case OpCode.OP_DROP:  						{  							if (stack.Count < 1)  								return false;  							stack.Pop();  							break;  						}  					case OpCode.OP_DUP:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(stack.First());  							break;  						}  					case OpCode.OP_NIP:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_OVER:  						{  							if (stack.Count < 2)  								return false;  							stack.Push(stack.Skip(1).First());  							break;  						}  					case OpCode.OP_PICK:  						{  							if (stack.Count < 2)  								return false;  							int pick = new ScriptVarInt(stack.Pop()).intValue;  							if (pick < 0 || stack.Count <= pick)  								return false;  							stack.Push(stack.Skip(pick).First());  							break;  						}  					case OpCode.OP_ROLL:  						{  							if (stack.Count < 2)  								return false;  							int roll = new ScriptVarInt(stack.Pop()).intValue;  							if (roll < 0 || stack.Count <= roll)  								return false;  							altstack.Push(stack.Skip(roll).First());  							for (int i = 0; i < roll; i++)  								altstack.Push(stack.Pop());  							stack.Pop();  							for (int i = 0; i < roll + 1; i++)  								stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_ROT:  						{  							if (stack.Count < 3)  								return false;  							altstack.Push(stack.Skip(2).First());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_SWAP:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Skip(1).First());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_TUCK:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Push(altstack.Skip(1).First());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_CAT:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Skip(1).First().Concat(stack.First()).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_SUBSTR:  						{  							if (stack.Count < 3)  								return false;  							altstack.Push(stack.Skip(2).First()  								.Skip(new ScriptVarInt(stack.Skip(1).First()).intValue)  								.Take(new ScriptVarInt(stack.First()).intValue).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_LEFT:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Skip(1).First()  								.Take(new ScriptVarInt(stack.First()).intValue).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_RIGHT:  						{  							if (stack.Count < 2)  								return false;  							int count = new ScriptVarInt(stack.First()).intValue;  							altstack.Push(stack.Skip(1).First()  								.Skip(stack.Skip(1).First().Length - count).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_SIZE:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(new ScriptVarInt((UInt64)stack.First().Length).ToBytes());  							break;  						}  					case OpCode.OP_INVERT:  						{  							if (stack.Count < 1)  								return false;  							Byte[] data = stack.Pop();  							for (int i = 0; i < data.Length; i++)  								data[i] ^= 0xFF;  							stack.Push(data);  							break;  						}  					case OpCode.OP_AND:  					case OpCode.OP_OR:  					case OpCode.OP_XOR:  						{  							if (stack.Count < 2)  								return false;  							Byte[] data = stack.Pop();  							Byte[] data2 = stack.Pop();  							int length = new int[] { data.Length' data2.Length }.Max();  							data = data.Concat(new Byte[length - data.Length]).ToArray();  							data2 = data2.Concat(new Byte[length - data2.Length]).ToArray();  							switch (se.opCode)  							{  								case OpCode.OP_AND:  									{  										for (int i = 0; i < length; i++)  											data[i] &= data2[i];  										break;  									}  								case OpCode.OP_OR:  									{  										for (int i = 0; i < length; i++)  											data[i] |= data2[i];  										break;  									}  								case OpCode.OP_XOR:  									{  										for (int i = 0; i < length; i++)  											data[i] ^= data2[i];  										break;  									}  							}  							stack.Push(data);  							break;  						}  					case OpCode.OP_EQUAL:  					case OpCode.OP_EQUALVERIFY:  						{  							if (stack.Count < 2)  								return false;  							if (stack.Pop().SequenceEqual(stack.Pop()))  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });    							if (se.opCode == OpCode.OP_EQUALVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_RESERVED1:  					case OpCode.OP_RESERVED2:  						{  							return false;  						}  					case OpCode.OP_1ADD:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Add(new ScriptVarInt(stack.Pop())' 1)).ToBytes());  							break;  						}  					case OpCode.OP_1SUB:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Subtract(new ScriptVarInt(stack.Pop())' 1)).ToBytes());  							break;  						}  					case OpCode.OP_2MUL:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Multiply(new ScriptVarInt(stack.Pop())' 2)).ToBytes());  							break;  						}  					case OpCode.OP_2DIV:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Divide(new ScriptVarInt(stack.Pop())' 2)).ToBytes());  							break;  						}  					case OpCode.OP_NEGATE:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Negate(new ScriptVarInt(stack.Pop()))).ToBytes());  							break;  						}  					case OpCode.OP_ABS:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Abs(new ScriptVarInt(stack.Pop()))).ToBytes());  							break;  						}  					case OpCode.OP_NOT:  						{  							if (stack.Count < 1)  								return false;  							if (new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_0NOTEQUAL:  						{  							if (stack.Count < 1)  								return false;  							if (new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x00 });  							else  								stack.Push(new Byte[] { 0x01 });  							break;  						}  					case OpCode.OP_ADD:  					case OpCode.OP_SUB:  					case OpCode.OP_MUL:  					case OpCode.OP_DIV:  					case OpCode.OP_MOD:  					case OpCode.OP_LSHIFT:  					case OpCode.OP_RSHIFT:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							switch (se.opCode)  							{  								case OpCode.OP_ADD:  									a = (BigInteger)a + b;  									break;  								case OpCode.OP_SUB:  									a = (BigInteger)a - b;  									break;  								case OpCode.OP_MUL:  									a = (BigInteger)a * b;  									break;  								case OpCode.OP_DIV:  									a = (BigInteger)a / b;  									break;  								case OpCode.OP_MOD:  									a = (BigInteger)a % b;  									break;  								case OpCode.OP_LSHIFT:  									a = (BigInteger)a << b.intValue;  									break;  								case OpCode.OP_RSHIFT:  									a = (BigInteger)a >> b.intValue;  									break;  							}  							stack.Push(a.ToBytes());  							break;  						}  					case OpCode.OP_BOOLAND:  						{  							if (stack.Count < 2)  								return false;  							if (!new ScriptVarInt(stack.Pop()).value.IsZero && !new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_BOOLOR:  						{  							if (stack.Count < 2)  								return false;  							if (!new ScriptVarInt(stack.Pop()).value.IsZero || !new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_NUMEQUAL:  					case OpCode.OP_NUMEQUALVERIFY:  						{  							if (stack.Count < 2)  								return false;  							if (new ScriptVarInt(stack.Pop()).value == new ScriptVarInt(stack.Pop()).value)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							if (se.opCode == OpCode.OP_NUMEQUALVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_NUMNOTEQUAL:  						{  							if (stack.Count < 2)  								return false;  							if (new ScriptVarInt(stack.Pop()).value != new ScriptVarInt(stack.Pop()).value)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_LESSTHAN:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a < b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_GREATERTHAN:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a > b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_LESSTHANOREQUAL:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a <= b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_GREATERTHANOREQUAL:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a >= b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_MIN:  						{  							if (stack.Count < 2)  								return false;  							Byte[] b = stack.Pop();  							Byte[] a = stack.Pop();  							if (new ScriptVarInt(a).value < new ScriptVarInt(b).value)  								stack.Push(a);  							else  								stack.Push(b);  							break;  						}  					case OpCode.OP_MAX:  						{  							if (stack.Count < 2)  								return false;  							Byte[] b = stack.Pop();  							Byte[] a = stack.Pop();  							if (new ScriptVarInt(a).value > new ScriptVarInt(b).value)  								stack.Push(a);  							else  								stack.Push(b);  							break;  						}  					case OpCode.OP_WITHIN:  						{  							if (stack.Count < 3)  								return false;  							ScriptVarInt max = new ScriptVarInt(stack.Pop());  							ScriptVarInt min = new ScriptVarInt(stack.Pop());  							ScriptVarInt x = new ScriptVarInt(stack.Pop());  							if ((BigInteger)min <= x && (BigInteger)x <= max)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_RIPEMD160:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(ripemd160.ComputeHash(stack.Pop()));  							break;  						}  					case OpCode.OP_SHA1:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(sha1.ComputeHash(stack.Pop()));  							break;  						}  					case OpCode.OP_SHA256:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(sha256.ComputeHash(stack.Pop()));  							break;  						}  					case OpCode.OP_HASH160:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(ripemd160.ComputeHash(sha256.ComputeHash(stack.Pop())));  							break;  						}  					case OpCode.OP_HASH256:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(sha256.ComputeHash(sha256.ComputeHash(stack.Pop())));  							break;  						}  					case OpCode.OP_CODESEPARATOR:  						{  							lastCodeSeperator = index;  							break;  						}  					case OpCode.OP_CHECKSIG:  					case OpCode.OP_CHECKSIGVERIFY:  						{  							if (tx == null)  								throw new ArgumentNullException("Transaction is required if script contains OP_CHECKSIG[VERIFY]");  							if (stack.Count < 2)  								return false;    							PublicKey pubKey = new PublicKey(stack.Pop());  							Byte[] sig = stack.Pop();    							Script subScript = new Script(elements.Skip(lastCodeSeperator)  								.Where(x => x.opCode != OpCode.OP_CODESEPARATOR).ToArray());    							stack.Push(new ScriptVarInt(CheckSig(sig' pubKey' txInIndex' subScript' tx) ? 1 : 0).ToBytes());    							if (se.opCode == OpCode.OP_CHECKSIGVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_CHECKMULTISIG:  					case OpCode.OP_CHECKMULTISIGVERIFY:  						{  							if (tx == null)  								throw new ArgumentNullException("Transaction is required if script contains OP_CHECKMULTISIG[VERIFY]");  							if (stack.Count < 2)  								return false;    							PublicKey[] pubKeys = new PublicKey[new ScriptVarInt(stack.Pop()).intValue];    							if (stack.Count < pubKeys.Length + 1)  								return false;    							for (int i = 0; i < pubKeys.Length; i++)  							{  								pubKeys[i] = new PublicKey(stack.Pop());  							}    							Byte[][] sigs = new Byte[new ScriptVarInt(stack.Pop()).intValue][];    							if (stack.Count < sigs.Length)  								return false;    							for (int i = 0; i < sigs.Length; i++)  							{  								sigs[i] = stack.Pop();  							}    							// Remove extra unused value from stack  							stack.Pop();    							Script subScript = new Script(elements.Skip(lastCodeSeperator)  								.Where(x => x.opCode != OpCode.OP_CODESEPARATOR).ToArray());    							int validSigs = 0;  							foreach (Byte[] sig in sigs)  							{  								foreach (PublicKey pubKey in pubKeys)  								{  									if (CheckSig(sig' pubKey' txInIndex' subScript' tx))  									{  										pubKeys = pubKeys.Where(x => x != pubKey).ToArray();  										validSigs++;  										break;  									}  								}  							}    							stack.Push(new ScriptVarInt((validSigs >= sigs.Length) ? 1 : 0).ToBytes());    							if (se.opCode == OpCode.OP_CHECKMULTISIGVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_NOP1:  					case OpCode.OP_NOP2:  					case OpCode.OP_NOP3:  					case OpCode.OP_NOP4:  					case OpCode.OP_NOP5:  					case OpCode.OP_NOP6:  					case OpCode.OP_NOP7:  					case OpCode.OP_NOP8:  					case OpCode.OP_NOP9:  					case OpCode.OP_NOP10:  						{  							break;  						}  					case OpCode.OP_SMALLINTEGER:  					case OpCode.OP_PUBKEYS:  					case OpCode.OP_PUBKEYHASH:  					case OpCode.OP_PUBKEY:  					case OpCode.OP_INVALIDOPCODE:  					default:  						{  							return false;  						}    				}  			}
Magic Number,Bitcoin_Tool.Scripts,Script,C:\repos\mb300sd_Bitcoin-Tool\Bitcoin Tool\Scripts\Script.cs,Evaluate,The following statement contains a magic number: for (int index = 0; index < elements.Count; index++)  			{  				ScriptElement se = elements[index];  				if (ifExec.Count > 0)  					if ((ifExec.First() == IfElseExec.SKIP_IF && !(se.opCode == OpCode.OP_ELSE || se.opCode == OpCode.OP_ENDIF)) ||  						(ifExec.First() == IfElseExec.SKIP_ELSE && !(se.opCode == OpCode.OP_ENDIF)))  						continue;    				if (se.isData)  				{  					stack.Push(se.data);  					continue;  				}    				switch (se.opCode)  				{  					case OpCode.OP_RESERVED:  						{  							return false;  						}  					case OpCode.OP_NOP:  						{  							// NOP' Dump stack for debug  							/*  							stack.ToList().ForEach(x => Console.WriteLine(HexString.FromByteArray(x)));  							Console.WriteLine("---------------------------");  							*/  							break;  						}  					case OpCode.OP_VER:  						{  							return false;  						}  					case OpCode.OP_IF:  					case OpCode.OP_NOTIF:  						{  							if (stack.Count < 1)  								return false;  							Boolean stackIsZero = new ScriptVarInt(stack.Pop()).value.IsZero;  							if ((se.opCode == OpCode.OP_IF && !stackIsZero) || (se.opCode == OpCode.OP_NOTIF && stackIsZero))  							{  								// Run to else or endif  								ifExec.Push(IfElseExec.RUN_IF);  							}  							else  							{  								// Skip to else or endif  								ifExec.Push(IfElseExec.SKIP_IF);  							}  							break;  						}  					case OpCode.OP_VERIF:  					case OpCode.OP_VERNOTIF:  						{  							return false;  						}  					case OpCode.OP_ELSE:  						{  							if (ifExec.Count == 0)  								// No preceding if statement!  								return false;  							if (ifExec.First() == IfElseExec.RUN_IF)  							{  								// If ran' skip else  								ifExec.Push(IfElseExec.SKIP_ELSE);  							}  							else if (ifExec.First() == IfElseExec.SKIP_IF)  							{  								// If did not run' run else  								ifExec.Push(IfElseExec.RUN_ELSE);  							}  							break;  						}  					case OpCode.OP_ENDIF:  						{  							if (ifExec.Count == 0)  								// No preceding if statement!  								return false;  							if (ifExec.First() == IfElseExec.RUN_IF ||  								ifExec.First() == IfElseExec.SKIP_IF)  							{  								ifExec.Pop();  							}  							else if (ifExec.First() == IfElseExec.RUN_ELSE ||  							   ifExec.First() == IfElseExec.SKIP_ELSE)  							{  								ifExec.Pop();  								ifExec.Pop();  							}  							break;  						}  					case OpCode.OP_VERIFY:  						{  							if (stack.Count < 1 || new ScriptVarInt(stack.First()).value.IsZero)  								return false;  							stack.Pop();  							break;  						}  					case OpCode.OP_RETURN:  						{  							return false;  						}  					case OpCode.OP_TOALTSTACK:  						{  							if (stack.Count < 1)  								return false;  							altstack.Push(stack.Pop());  							break;  						}  					case OpCode.OP_FROMALTSTACK:  						{  							if (altstack.Count < 1)  								return false;  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_2DROP:  						{  							if (stack.Count < 2)  								return false;  							stack.Pop();  							stack.Pop();  							break;  						}  					case OpCode.OP_2DUP:  						{  							if (stack.Count < 2)  								return false;  							stack.Push(stack.Skip(1).First());  							stack.Push(stack.Skip(1).First());  							break;  						}  					case OpCode.OP_3DUP:  						{  							if (stack.Count < 3)  								return false;  							stack.Push(stack.Skip(2).First());  							stack.Push(stack.Skip(2).First());  							stack.Push(stack.Skip(2).First());  							break;  						}  					case OpCode.OP_2OVER:  						{  							if (stack.Count < 4)  								return false;  							stack.Push(stack.Skip(3).First());  							stack.Push(stack.Skip(3).First());  							break;  						}  					case OpCode.OP_2ROT:  						{  							if (stack.Count < 6)  								return false;  							altstack.Push(stack.Skip(4).First());  							altstack.Push(stack.Skip(5).First());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_2SWAP:  						{  							if (stack.Count < 4)  								return false;  							altstack.Push(stack.Skip(2).First());  							altstack.Push(stack.Skip(3).First());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_IFDUP:  						{  							if (stack.Count < 1)  								return false;  							if (!new ScriptVarInt(stack.First()).value.IsZero)  								stack.Push(stack.First());  							break;  						}  					case OpCode.OP_DEPTH:  						{  							stack.Push(new ScriptVarInt((UInt64)stack.Count).ToBytes());  							break;  						}  					case OpCode.OP_DROP:  						{  							if (stack.Count < 1)  								return false;  							stack.Pop();  							break;  						}  					case OpCode.OP_DUP:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(stack.First());  							break;  						}  					case OpCode.OP_NIP:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_OVER:  						{  							if (stack.Count < 2)  								return false;  							stack.Push(stack.Skip(1).First());  							break;  						}  					case OpCode.OP_PICK:  						{  							if (stack.Count < 2)  								return false;  							int pick = new ScriptVarInt(stack.Pop()).intValue;  							if (pick < 0 || stack.Count <= pick)  								return false;  							stack.Push(stack.Skip(pick).First());  							break;  						}  					case OpCode.OP_ROLL:  						{  							if (stack.Count < 2)  								return false;  							int roll = new ScriptVarInt(stack.Pop()).intValue;  							if (roll < 0 || stack.Count <= roll)  								return false;  							altstack.Push(stack.Skip(roll).First());  							for (int i = 0; i < roll; i++)  								altstack.Push(stack.Pop());  							stack.Pop();  							for (int i = 0; i < roll + 1; i++)  								stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_ROT:  						{  							if (stack.Count < 3)  								return false;  							altstack.Push(stack.Skip(2).First());  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_SWAP:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Skip(1).First());  							altstack.Push(stack.Pop());  							stack.Pop();  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_TUCK:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Pop());  							altstack.Push(stack.Pop());  							stack.Push(altstack.Skip(1).First());  							stack.Push(altstack.Pop());  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_CAT:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Skip(1).First().Concat(stack.First()).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_SUBSTR:  						{  							if (stack.Count < 3)  								return false;  							altstack.Push(stack.Skip(2).First()  								.Skip(new ScriptVarInt(stack.Skip(1).First()).intValue)  								.Take(new ScriptVarInt(stack.First()).intValue).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_LEFT:  						{  							if (stack.Count < 2)  								return false;  							altstack.Push(stack.Skip(1).First()  								.Take(new ScriptVarInt(stack.First()).intValue).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_RIGHT:  						{  							if (stack.Count < 2)  								return false;  							int count = new ScriptVarInt(stack.First()).intValue;  							altstack.Push(stack.Skip(1).First()  								.Skip(stack.Skip(1).First().Length - count).ToArray());  							stack.Pop();  							stack.Pop();  							stack.Push(altstack.Pop());  							break;  						}  					case OpCode.OP_SIZE:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(new ScriptVarInt((UInt64)stack.First().Length).ToBytes());  							break;  						}  					case OpCode.OP_INVERT:  						{  							if (stack.Count < 1)  								return false;  							Byte[] data = stack.Pop();  							for (int i = 0; i < data.Length; i++)  								data[i] ^= 0xFF;  							stack.Push(data);  							break;  						}  					case OpCode.OP_AND:  					case OpCode.OP_OR:  					case OpCode.OP_XOR:  						{  							if (stack.Count < 2)  								return false;  							Byte[] data = stack.Pop();  							Byte[] data2 = stack.Pop();  							int length = new int[] { data.Length' data2.Length }.Max();  							data = data.Concat(new Byte[length - data.Length]).ToArray();  							data2 = data2.Concat(new Byte[length - data2.Length]).ToArray();  							switch (se.opCode)  							{  								case OpCode.OP_AND:  									{  										for (int i = 0; i < length; i++)  											data[i] &= data2[i];  										break;  									}  								case OpCode.OP_OR:  									{  										for (int i = 0; i < length; i++)  											data[i] |= data2[i];  										break;  									}  								case OpCode.OP_XOR:  									{  										for (int i = 0; i < length; i++)  											data[i] ^= data2[i];  										break;  									}  							}  							stack.Push(data);  							break;  						}  					case OpCode.OP_EQUAL:  					case OpCode.OP_EQUALVERIFY:  						{  							if (stack.Count < 2)  								return false;  							if (stack.Pop().SequenceEqual(stack.Pop()))  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });    							if (se.opCode == OpCode.OP_EQUALVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_RESERVED1:  					case OpCode.OP_RESERVED2:  						{  							return false;  						}  					case OpCode.OP_1ADD:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Add(new ScriptVarInt(stack.Pop())' 1)).ToBytes());  							break;  						}  					case OpCode.OP_1SUB:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Subtract(new ScriptVarInt(stack.Pop())' 1)).ToBytes());  							break;  						}  					case OpCode.OP_2MUL:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Multiply(new ScriptVarInt(stack.Pop())' 2)).ToBytes());  							break;  						}  					case OpCode.OP_2DIV:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Divide(new ScriptVarInt(stack.Pop())' 2)).ToBytes());  							break;  						}  					case OpCode.OP_NEGATE:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Negate(new ScriptVarInt(stack.Pop()))).ToBytes());  							break;  						}  					case OpCode.OP_ABS:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(((ScriptVarInt)BigInteger.Abs(new ScriptVarInt(stack.Pop()))).ToBytes());  							break;  						}  					case OpCode.OP_NOT:  						{  							if (stack.Count < 1)  								return false;  							if (new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_0NOTEQUAL:  						{  							if (stack.Count < 1)  								return false;  							if (new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x00 });  							else  								stack.Push(new Byte[] { 0x01 });  							break;  						}  					case OpCode.OP_ADD:  					case OpCode.OP_SUB:  					case OpCode.OP_MUL:  					case OpCode.OP_DIV:  					case OpCode.OP_MOD:  					case OpCode.OP_LSHIFT:  					case OpCode.OP_RSHIFT:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							switch (se.opCode)  							{  								case OpCode.OP_ADD:  									a = (BigInteger)a + b;  									break;  								case OpCode.OP_SUB:  									a = (BigInteger)a - b;  									break;  								case OpCode.OP_MUL:  									a = (BigInteger)a * b;  									break;  								case OpCode.OP_DIV:  									a = (BigInteger)a / b;  									break;  								case OpCode.OP_MOD:  									a = (BigInteger)a % b;  									break;  								case OpCode.OP_LSHIFT:  									a = (BigInteger)a << b.intValue;  									break;  								case OpCode.OP_RSHIFT:  									a = (BigInteger)a >> b.intValue;  									break;  							}  							stack.Push(a.ToBytes());  							break;  						}  					case OpCode.OP_BOOLAND:  						{  							if (stack.Count < 2)  								return false;  							if (!new ScriptVarInt(stack.Pop()).value.IsZero && !new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_BOOLOR:  						{  							if (stack.Count < 2)  								return false;  							if (!new ScriptVarInt(stack.Pop()).value.IsZero || !new ScriptVarInt(stack.Pop()).value.IsZero)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_NUMEQUAL:  					case OpCode.OP_NUMEQUALVERIFY:  						{  							if (stack.Count < 2)  								return false;  							if (new ScriptVarInt(stack.Pop()).value == new ScriptVarInt(stack.Pop()).value)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							if (se.opCode == OpCode.OP_NUMEQUALVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_NUMNOTEQUAL:  						{  							if (stack.Count < 2)  								return false;  							if (new ScriptVarInt(stack.Pop()).value != new ScriptVarInt(stack.Pop()).value)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_LESSTHAN:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a < b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_GREATERTHAN:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a > b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_LESSTHANOREQUAL:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a <= b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_GREATERTHANOREQUAL:  						{  							if (stack.Count < 2)  								return false;  							ScriptVarInt b = new ScriptVarInt(stack.Pop());  							ScriptVarInt a = new ScriptVarInt(stack.Pop());  							if ((BigInteger)a >= b)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_MIN:  						{  							if (stack.Count < 2)  								return false;  							Byte[] b = stack.Pop();  							Byte[] a = stack.Pop();  							if (new ScriptVarInt(a).value < new ScriptVarInt(b).value)  								stack.Push(a);  							else  								stack.Push(b);  							break;  						}  					case OpCode.OP_MAX:  						{  							if (stack.Count < 2)  								return false;  							Byte[] b = stack.Pop();  							Byte[] a = stack.Pop();  							if (new ScriptVarInt(a).value > new ScriptVarInt(b).value)  								stack.Push(a);  							else  								stack.Push(b);  							break;  						}  					case OpCode.OP_WITHIN:  						{  							if (stack.Count < 3)  								return false;  							ScriptVarInt max = new ScriptVarInt(stack.Pop());  							ScriptVarInt min = new ScriptVarInt(stack.Pop());  							ScriptVarInt x = new ScriptVarInt(stack.Pop());  							if ((BigInteger)min <= x && (BigInteger)x <= max)  								stack.Push(new Byte[] { 0x01 });  							else  								stack.Push(new Byte[] { 0x00 });  							break;  						}  					case OpCode.OP_RIPEMD160:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(ripemd160.ComputeHash(stack.Pop()));  							break;  						}  					case OpCode.OP_SHA1:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(sha1.ComputeHash(stack.Pop()));  							break;  						}  					case OpCode.OP_SHA256:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(sha256.ComputeHash(stack.Pop()));  							break;  						}  					case OpCode.OP_HASH160:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(ripemd160.ComputeHash(sha256.ComputeHash(stack.Pop())));  							break;  						}  					case OpCode.OP_HASH256:  						{  							if (stack.Count < 1)  								return false;  							stack.Push(sha256.ComputeHash(sha256.ComputeHash(stack.Pop())));  							break;  						}  					case OpCode.OP_CODESEPARATOR:  						{  							lastCodeSeperator = index;  							break;  						}  					case OpCode.OP_CHECKSIG:  					case OpCode.OP_CHECKSIGVERIFY:  						{  							if (tx == null)  								throw new ArgumentNullException("Transaction is required if script contains OP_CHECKSIG[VERIFY]");  							if (stack.Count < 2)  								return false;    							PublicKey pubKey = new PublicKey(stack.Pop());  							Byte[] sig = stack.Pop();    							Script subScript = new Script(elements.Skip(lastCodeSeperator)  								.Where(x => x.opCode != OpCode.OP_CODESEPARATOR).ToArray());    							stack.Push(new ScriptVarInt(CheckSig(sig' pubKey' txInIndex' subScript' tx) ? 1 : 0).ToBytes());    							if (se.opCode == OpCode.OP_CHECKSIGVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_CHECKMULTISIG:  					case OpCode.OP_CHECKMULTISIGVERIFY:  						{  							if (tx == null)  								throw new ArgumentNullException("Transaction is required if script contains OP_CHECKMULTISIG[VERIFY]");  							if (stack.Count < 2)  								return false;    							PublicKey[] pubKeys = new PublicKey[new ScriptVarInt(stack.Pop()).intValue];    							if (stack.Count < pubKeys.Length + 1)  								return false;    							for (int i = 0; i < pubKeys.Length; i++)  							{  								pubKeys[i] = new PublicKey(stack.Pop());  							}    							Byte[][] sigs = new Byte[new ScriptVarInt(stack.Pop()).intValue][];    							if (stack.Count < sigs.Length)  								return false;    							for (int i = 0; i < sigs.Length; i++)  							{  								sigs[i] = stack.Pop();  							}    							// Remove extra unused value from stack  							stack.Pop();    							Script subScript = new Script(elements.Skip(lastCodeSeperator)  								.Where(x => x.opCode != OpCode.OP_CODESEPARATOR).ToArray());    							int validSigs = 0;  							foreach (Byte[] sig in sigs)  							{  								foreach (PublicKey pubKey in pubKeys)  								{  									if (CheckSig(sig' pubKey' txInIndex' subScript' tx))  									{  										pubKeys = pubKeys.Where(x => x != pubKey).ToArray();  										validSigs++;  										break;  									}  								}  							}    							stack.Push(new ScriptVarInt((validSigs >= sigs.Length) ? 1 : 0).ToBytes());    							if (se.opCode == OpCode.OP_CHECKMULTISIGVERIFY)  							{  								if (stack.First().Single() == 0x00)  									return false;  								stack.Pop();  							}  							break;  						}  					case OpCode.OP_NOP1:  					case OpCode.OP_NOP2:  					case OpCode.OP_NOP3:  					case OpCode.OP_NOP4:  					case OpCode.OP_NOP5:  					case OpCode.OP_NOP6:  					case OpCode.OP_NOP7:  					case OpCode.OP_NOP8:  					case OpCode.OP_NOP9:  					case OpCode.OP_NOP10:  						{  							break;  						}  					case OpCode.OP_SMALLINTEGER:  					case OpCode.OP_PUBKEYS:  					case OpCode.OP_PUBKEYHASH:  					case OpCode.OP_PUBKEY:  					case OpCode.OP_INVALIDOPCODE:  					default:  						{  							return false;  						}    				}  			}
Magic Number,Bitcoin_Tool.Scripts,ScriptTemplate,C:\repos\mb300sd_Bitcoin-Tool\Bitcoin Tool\Scripts\ScriptTemplate.cs,IsPayToPubKeyHash,The following statement contains a magic number: return (  				s.elements.Count >= 5 &&  				s.elements[s.elements.Count - 5].opCode == OpCode.OP_DUP &&  				s.elements[s.elements.Count - 4].opCode == OpCode.OP_HASH160 &&  				s.elements[s.elements.Count - 3].matchesPubKeyHash &&  				s.elements[s.elements.Count - 2].opCode == OpCode.OP_EQUALVERIFY &&  				s.elements[s.elements.Count - 1].opCode == OpCode.OP_CHECKSIG);
Magic Number,Bitcoin_Tool.Scripts,ScriptTemplate,C:\repos\mb300sd_Bitcoin-Tool\Bitcoin Tool\Scripts\ScriptTemplate.cs,IsPayToPubKeyHash,The following statement contains a magic number: return (  				s.elements.Count >= 5 &&  				s.elements[s.elements.Count - 5].opCode == OpCode.OP_DUP &&  				s.elements[s.elements.Count - 4].opCode == OpCode.OP_HASH160 &&  				s.elements[s.elements.Count - 3].matchesPubKeyHash &&  				s.elements[s.elements.Count - 2].opCode == OpCode.OP_EQUALVERIFY &&  				s.elements[s.elements.Count - 1].opCode == OpCode.OP_CHECKSIG);
Magic Number,Bitcoin_Tool.Scripts,ScriptTemplate,C:\repos\mb300sd_Bitcoin-Tool\Bitcoin Tool\Scripts\ScriptTemplate.cs,IsPayToPubKeyHash,The following statement contains a magic number: return (  				s.elements.Count >= 5 &&  				s.elements[s.elements.Count - 5].opCode == OpCode.OP_DUP &&  				s.elements[s.elements.Count - 4].opCode == OpCode.OP_HASH160 &&  				s.elements[s.elements.Count - 3].matchesPubKeyHash &&  				s.elements[s.elements.Count - 2].opCode == OpCode.OP_EQUALVERIFY &&  				s.elements[s.elements.Count - 1].opCode == OpCode.OP_CHECKSIG);
Magic Number,Bitcoin_Tool.Scripts,ScriptTemplate,C:\repos\mb300sd_Bitcoin-Tool\Bitcoin Tool\Scripts\ScriptTemplate.cs,IsPayToPubKeyHash,The following statement contains a magic number: return (  				s.elements.Count >= 5 &&  				s.elements[s.elements.Count - 5].opCode == OpCode.OP_DUP &&  				s.elements[s.elements.Count - 4].opCode == OpCode.OP_HASH160 &&  				s.elements[s.elements.Count - 3].matchesPubKeyHash &&  				s.elements[s.elements.Count - 2].opCode == OpCode.OP_EQUALVERIFY &&  				s.elements[s.elements.Count - 1].opCode == OpCode.OP_CHECKSIG);
Magic Number,Bitcoin_Tool.Scripts,ScriptTemplate,C:\repos\mb300sd_Bitcoin-Tool\Bitcoin Tool\Scripts\ScriptTemplate.cs,IsPayToPubKeyHash,The following statement contains a magic number: return (  				s.elements.Count >= 5 &&  				s.elements[s.elements.Count - 5].opCode == OpCode.OP_DUP &&  				s.elements[s.elements.Count - 4].opCode == OpCode.OP_HASH160 &&  				s.elements[s.elements.Count - 3].matchesPubKeyHash &&  				s.elements[s.elements.Count - 2].opCode == OpCode.OP_EQUALVERIFY &&  				s.elements[s.elements.Count - 1].opCode == OpCode.OP_CHECKSIG);
Magic Number,Bitcoin_Tool.Scripts,ScriptTemplate,C:\repos\mb300sd_Bitcoin-Tool\Bitcoin Tool\Scripts\ScriptTemplate.cs,IsPayToPublicKey,The following statement contains a magic number: return (  				s.elements.Count >= 2 &&  				s.elements[s.elements.Count - 2].matchesPubKey &&  				s.elements[s.elements.Count - 1].opCode == OpCode.OP_CHECKSIG);
Magic Number,Bitcoin_Tool.Scripts,ScriptTemplate,C:\repos\mb300sd_Bitcoin-Tool\Bitcoin Tool\Scripts\ScriptTemplate.cs,IsPayToPublicKey,The following statement contains a magic number: return (  				s.elements.Count >= 2 &&  				s.elements[s.elements.Count - 2].matchesPubKey &&  				s.elements[s.elements.Count - 1].opCode == OpCode.OP_CHECKSIG);
Magic Number,Bitcoin_Tool.Scripts,ScriptTemplate,C:\repos\mb300sd_Bitcoin-Tool\Bitcoin Tool\Scripts\ScriptTemplate.cs,IsPayToScriptHash,The following statement contains a magic number: return (  				s.elements.Count >= 3 &&  				s.elements[s.elements.Count - 3].opCode == OpCode.OP_HASH160 &&  				s.elements[s.elements.Count - 2].matchesScriptHash &&  				s.elements[s.elements.Count - 1].opCode == OpCode.OP_EQUAL);
Magic Number,Bitcoin_Tool.Scripts,ScriptTemplate,C:\repos\mb300sd_Bitcoin-Tool\Bitcoin Tool\Scripts\ScriptTemplate.cs,IsPayToScriptHash,The following statement contains a magic number: return (  				s.elements.Count >= 3 &&  				s.elements[s.elements.Count - 3].opCode == OpCode.OP_HASH160 &&  				s.elements[s.elements.Count - 2].matchesScriptHash &&  				s.elements[s.elements.Count - 1].opCode == OpCode.OP_EQUAL);
Magic Number,Bitcoin_Tool.Scripts,ScriptTemplate,C:\repos\mb300sd_Bitcoin-Tool\Bitcoin Tool\Scripts\ScriptTemplate.cs,IsPayToScriptHash,The following statement contains a magic number: return (  				s.elements.Count >= 3 &&  				s.elements[s.elements.Count - 3].opCode == OpCode.OP_HASH160 &&  				s.elements[s.elements.Count - 2].matchesScriptHash &&  				s.elements[s.elements.Count - 1].opCode == OpCode.OP_EQUAL);
Magic Number,Bitcoin_Tool.Scripts,ScriptVarInt,C:\repos\mb300sd_Bitcoin-Tool\Bitcoin Tool\Scripts\ScriptVarInt.cs,ScriptVarInt,The following statement contains a magic number: for (int i = 0; i < b.Length - 1; i++)  			{  				value += b[i] << (i * 8);  			}
Magic Number,Bitcoin_Tool.Scripts,ScriptVarInt,C:\repos\mb300sd_Bitcoin-Tool\Bitcoin Tool\Scripts\ScriptVarInt.cs,ScriptVarInt,The following statement contains a magic number: value += (b[b.Length - 1] & 0x7F) << ((b.Length - 1) * 8);
Magic Number,Bitcoin_Tool.Scripts,ScriptVarInt,C:\repos\mb300sd_Bitcoin-Tool\Bitcoin Tool\Scripts\ScriptVarInt.cs,ToBytes,The following statement contains a magic number: do  			{  				b.Add((Byte)(val & 0xFF));  				val = val >> 8;  			} while (val > 0);
Magic Number,Bitcoin_Tool.Structs,Hash,C:\repos\mb300sd_Bitcoin-Tool\Bitcoin Tool\Structs\Hash.cs,GetHashCode,The following statement contains a magic number: if (hash.Length >= 4)  				return (hash[0] << 24) | (hash[1] << 16) | (hash[2] << 8) | (hash[3] << 0);
Magic Number,Bitcoin_Tool.Structs,Hash,C:\repos\mb300sd_Bitcoin-Tool\Bitcoin Tool\Structs\Hash.cs,GetHashCode,The following statement contains a magic number: if (hash.Length >= 4)  				return (hash[0] << 24) | (hash[1] << 16) | (hash[2] << 8) | (hash[3] << 0);
Magic Number,Bitcoin_Tool.Structs,Hash,C:\repos\mb300sd_Bitcoin-Tool\Bitcoin Tool\Structs\Hash.cs,GetHashCode,The following statement contains a magic number: if (hash.Length >= 4)  				return (hash[0] << 24) | (hash[1] << 16) | (hash[2] << 8) | (hash[3] << 0);
Magic Number,Bitcoin_Tool.Structs,Hash,C:\repos\mb300sd_Bitcoin-Tool\Bitcoin Tool\Structs\Hash.cs,GetHashCode,The following statement contains a magic number: if (hash.Length >= 4)  				return (hash[0] << 24) | (hash[1] << 16) | (hash[2] << 8) | (hash[3] << 0);
Magic Number,Bitcoin_Tool.Structs,Hash,C:\repos\mb300sd_Bitcoin-Tool\Bitcoin Tool\Structs\Hash.cs,GetHashCode,The following statement contains a magic number: if (hash.Length >= 4)  				return (hash[0] << 24) | (hash[1] << 16) | (hash[2] << 8) | (hash[3] << 0);
Magic Number,Bitcoin_Tool.Structs,Hash,C:\repos\mb300sd_Bitcoin-Tool\Bitcoin Tool\Structs\Hash.cs,GetHashCode,The following statement contains a magic number: if (hash.Length >= 4)  				return (hash[0] << 24) | (hash[1] << 16) | (hash[2] << 8) | (hash[3] << 0);
Magic Number,Bitcoin_Tool.Structs,Block,C:\repos\mb300sd_Bitcoin-Tool\Bitcoin Tool\Structs\Block.cs,Read,The following statement contains a magic number: prev_block = br.ReadBytes(32);
Magic Number,Bitcoin_Tool.Structs,Block,C:\repos\mb300sd_Bitcoin-Tool\Bitcoin Tool\Structs\Block.cs,Read,The following statement contains a magic number: merkle_root = br.ReadBytes(32);
Magic Number,Bitcoin_Tool.Structs,Block,C:\repos\mb300sd_Bitcoin-Tool\Bitcoin Tool\Structs\Block.cs,WriteHeader,The following statement contains a magic number: bw.Write(prev_block' 0' 32);
Magic Number,Bitcoin_Tool.Structs,Block,C:\repos\mb300sd_Bitcoin-Tool\Bitcoin Tool\Structs\Block.cs,WriteHeader,The following statement contains a magic number: bw.Write(merkle_root' 0' 32);
Magic Number,Bitcoin_Tool.Structs,TxIn,C:\repos\mb300sd_Bitcoin-Tool\Bitcoin Tool\Structs\TxIn.cs,Read,The following statement contains a magic number: prevOut = br.ReadBytes(32);
Magic Number,Bitcoin_Tool.Structs,TxIn,C:\repos\mb300sd_Bitcoin-Tool\Bitcoin Tool\Structs\TxIn.cs,Write,The following statement contains a magic number: bw.Write(prevOut' 0' 32);
Magic Number,Bitcoin_Tool.Structs.Net,GetBlocks,C:\repos\mb300sd_Bitcoin-Tool\Bitcoin Tool\Structs\Net\GetBlocks.cs,Read,The following statement contains a magic number: for (int i = 0; i < block_locator_hashes.Length; i++)  				block_locator_hashes[i] = br.ReadBytes(32);
Magic Number,Bitcoin_Tool.Structs.Net,GetBlocks,C:\repos\mb300sd_Bitcoin-Tool\Bitcoin Tool\Structs\Net\GetBlocks.cs,Read,The following statement contains a magic number: hash_stop = br.ReadBytes(32);
Magic Number,Bitcoin_Tool.Structs.Net,GetBlocks,C:\repos\mb300sd_Bitcoin-Tool\Bitcoin Tool\Structs\Net\GetBlocks.cs,Write,The following statement contains a magic number: for (int i = 0; i < block_locator_hashes.Length; i++)  				bw.Write(block_locator_hashes[i]' 0' 32);
Magic Number,Bitcoin_Tool.Structs.Net,GetBlocks,C:\repos\mb300sd_Bitcoin-Tool\Bitcoin Tool\Structs\Net\GetBlocks.cs,Write,The following statement contains a magic number: bw.Write(hash_stop' 0' 32);
Magic Number,Bitcoin_Tool.Structs.Net,GetHeaders,C:\repos\mb300sd_Bitcoin-Tool\Bitcoin Tool\Structs\Net\GetHeaders.cs,Read,The following statement contains a magic number: for (int i = 0; i < block_locator_hashes.Length; i++)  				block_locator_hashes[i] = br.ReadBytes(32);
Magic Number,Bitcoin_Tool.Structs.Net,GetHeaders,C:\repos\mb300sd_Bitcoin-Tool\Bitcoin Tool\Structs\Net\GetHeaders.cs,Read,The following statement contains a magic number: hash_stop = br.ReadBytes(32);
Magic Number,Bitcoin_Tool.Structs.Net,GetHeaders,C:\repos\mb300sd_Bitcoin-Tool\Bitcoin Tool\Structs\Net\GetHeaders.cs,Write,The following statement contains a magic number: for (int i = 0; i < block_locator_hashes.Length; i++)  				bw.Write(block_locator_hashes[i]' 0' 32);
Magic Number,Bitcoin_Tool.Structs.Net,GetHeaders,C:\repos\mb300sd_Bitcoin-Tool\Bitcoin Tool\Structs\Net\GetHeaders.cs,Write,The following statement contains a magic number: bw.Write(hash_stop' 0' 32);
Magic Number,Bitcoin_Tool.Structs.Net,InvVect,C:\repos\mb300sd_Bitcoin-Tool\Bitcoin Tool\Structs\Net\InvVect.cs,Read,The following statement contains a magic number: hash = br.ReadBytes(32);
Magic Number,Bitcoin_Tool.Structs.Net,InvVect,C:\repos\mb300sd_Bitcoin-Tool\Bitcoin Tool\Structs\Net\InvVect.cs,Write,The following statement contains a magic number: bw.Write(hash' 0' 32);
Magic Number,Bitcoin_Tool.Structs.Net,Message,C:\repos\mb300sd_Bitcoin-Tool\Bitcoin Tool\Structs\Net\Message.cs,Message,The following statement contains a magic number: this.command = Encoding.ASCII.GetBytes(command).Concat(new Byte[12 - command.Length]).ToArray();
Magic Number,Bitcoin_Tool.Structs.Net,Message,C:\repos\mb300sd_Bitcoin-Tool\Bitcoin Tool\Structs\Net\Message.cs,Message,The following statement contains a magic number: this.checksum = sha256.ComputeHash(sha256.ComputeHash(payloadBytes)).Take(4).ToArray();
Magic Number,Bitcoin_Tool.Structs.Net,Message,C:\repos\mb300sd_Bitcoin-Tool\Bitcoin Tool\Structs\Net\Message.cs,Read,The following statement contains a magic number: command = br.ReadBytes(12);
Magic Number,Bitcoin_Tool.Structs.Net,Message,C:\repos\mb300sd_Bitcoin-Tool\Bitcoin Tool\Structs\Net\Message.cs,Read,The following statement contains a magic number: checksum = br.ReadBytes(4);
Magic Number,Bitcoin_Tool.Structs.Net,Message,C:\repos\mb300sd_Bitcoin-Tool\Bitcoin Tool\Structs\Net\Message.cs,Write,The following statement contains a magic number: bw.Write(command' 0' 12);
Magic Number,Bitcoin_Tool.Structs.Net,Message,C:\repos\mb300sd_Bitcoin-Tool\Bitcoin Tool\Structs\Net\Message.cs,Write,The following statement contains a magic number: bw.Write(checksum' 0' 4);
Magic Number,Bitcoin_Tool.Structs.Net,NetAddr,C:\repos\mb300sd_Bitcoin-Tool\Bitcoin Tool\Structs\Net\NetAddr.cs,NetAddr,The following statement contains a magic number: if (address.GetAddressBytes().Length != 16)  				this.address = new IPAddress((new Byte[] { 0x00' 0x00' 0x00' 0x00' 0x00' 0x00' 0x00' 0x00' 0x00' 0x00' 0xFF' 0xFF })  					.Concat(address.GetAddressBytes()).ToArray());
Magic Number,Bitcoin_Tool.Structs.Net,NetAddr,C:\repos\mb300sd_Bitcoin-Tool\Bitcoin Tool\Structs\Net\NetAddr.cs,Read,The following statement contains a magic number: Byte[] address = br.ReadBytes(16);
Magic Number,Bitcoin_Tool.Structs.Net,NetAddr,C:\repos\mb300sd_Bitcoin-Tool\Bitcoin Tool\Structs\Net\NetAddr.cs,Write,The following statement contains a magic number: bw.Write(address.GetAddressBytes()' 0' 16);
Magic Number,Bitcoin_Tool.Structs.Net,Version,C:\repos\mb300sd_Bitcoin-Tool\Bitcoin Tool\Structs\Net\Version.cs,Default,The following statement contains a magic number: v.version = 60001;
Magic Number,Bitcoin_Tool.Structs.Net,Version,C:\repos\mb300sd_Bitcoin-Tool\Bitcoin Tool\Structs\Net\Version.cs,Default,The following statement contains a magic number: v.nonce = (((UInt64)rand.Next()) << 32) | (UInt32)rand.Next();
Magic Number,Bitcoin_Tool.Structs.Other,TxOutId,C:\repos\mb300sd_Bitcoin-Tool\Bitcoin Tool\Structs\Other\TxOutId.cs,Read,The following statement contains a magic number: txid = br.ReadBytes(32);
Magic Number,Bitcoin_Tool.Structs.Other,TxOutId,C:\repos\mb300sd_Bitcoin-Tool\Bitcoin Tool\Structs\Other\TxOutId.cs,Write,The following statement contains a magic number: bw.Write(txid' 0' 32);
Magic Number,Bitcoin_Tool.Crypto,Address,C:\repos\mb300sd_Bitcoin-Tool\Bitcoin Tool\Crypto\Address.cs,FromScript,The following statement contains a magic number: if (s.IsPayToPubKeyHash())  				return new Address(s.elements[s.elements.Count - 3].data' PUBKEYHASH);
Magic Number,Bitcoin_Tool.Crypto,Address,C:\repos\mb300sd_Bitcoin-Tool\Bitcoin Tool\Crypto\Address.cs,FromScript,The following statement contains a magic number: if (s.IsPayToScriptHash())  				return new Address(s.elements[s.elements.Count - 2].data' SCRIPTHASH);
Magic Number,Bitcoin_Tool.Crypto,Address,C:\repos\mb300sd_Bitcoin-Tool\Bitcoin Tool\Crypto\Address.cs,FromScript,The following statement contains a magic number: if (s.IsPayToPublicKey())  				return new Address(s.elements[s.elements.Count - 2].data' PUBKEY);
Magic Number,Bitcoin_Tool.Crypto,PrivateKey,C:\repos\mb300sd_Bitcoin-Tool\Bitcoin Tool\Crypto\PrivateKey.cs,PrivateKey,The following statement contains a magic number: Byte[] pk = new Byte[32];
Magic Number,Bitcoin_Tool.Crypto,ECKeyPair,C:\repos\mb300sd_Bitcoin-Tool\Bitcoin Tool\Crypto\ECKeyPair.cs,ECKeyPair,The following statement contains a magic number: if (pubKey != null)  			{  				this.pubKey = pubKey;  				this.isCompressed = pubKey.Length <= 33;  			}  			else  			{  				calcPubKey(compressed);  			}
Magic Number,Bitcoin_Tool.DataConverters,Base58CheckString,C:\repos\mb300sd_Bitcoin-Tool\Bitcoin Tool\DataConverters\Base58CheckString.cs,FromByteArray,The following statement contains a magic number: Byte[] hash = sha256.ComputeHash(sha256.ComputeHash(b)).Take(4).ToArray();
Magic Number,Bitcoin_Tool.DataConverters,Base58CheckString,C:\repos\mb300sd_Bitcoin-Tool\Bitcoin Tool\DataConverters\Base58CheckString.cs,ToByteArray,The following statement contains a magic number: Byte[] hash = sha256.ComputeHash(sha256.ComputeHash(b.Take(b.Length - 4).ToArray()));
Magic Number,Bitcoin_Tool.DataConverters,Base58CheckString,C:\repos\mb300sd_Bitcoin-Tool\Bitcoin Tool\DataConverters\Base58CheckString.cs,ToByteArray,The following statement contains a magic number: if (!hash.Take(4).SequenceEqual(b.Skip(b.Length - 4).Take(4)))  				throw new ArgumentException("Invalid Base58Check String");
Magic Number,Bitcoin_Tool.DataConverters,Base58CheckString,C:\repos\mb300sd_Bitcoin-Tool\Bitcoin Tool\DataConverters\Base58CheckString.cs,ToByteArray,The following statement contains a magic number: if (!hash.Take(4).SequenceEqual(b.Skip(b.Length - 4).Take(4)))  				throw new ArgumentException("Invalid Base58Check String");
Magic Number,Bitcoin_Tool.DataConverters,Base58CheckString,C:\repos\mb300sd_Bitcoin-Tool\Bitcoin Tool\DataConverters\Base58CheckString.cs,ToByteArray,The following statement contains a magic number: if (!hash.Take(4).SequenceEqual(b.Skip(b.Length - 4).Take(4)))  				throw new ArgumentException("Invalid Base58Check String");
Magic Number,Bitcoin_Tool.DataConverters,Base58CheckString,C:\repos\mb300sd_Bitcoin-Tool\Bitcoin Tool\DataConverters\Base58CheckString.cs,ToByteArray,The following statement contains a magic number: return b.Skip(1).Take(b.Length - 5).ToArray();
Magic Number,Bitcoin_Tool.DataConverters,Base58String,C:\repos\mb300sd_Bitcoin-Tool\Bitcoin Tool\DataConverters\Base58String.cs,ToByteArray,The following statement contains a magic number: foreach (Char c in s)  			{  				int charVal = base58chars.IndexOf(c);  				if (charVal >= 0)  				{  					bi *= 58;  					bi += charVal;  				}  			}
Magic Number,Bitcoin_Tool.DataConverters,Base58String,C:\repos\mb300sd_Bitcoin-Tool\Bitcoin Tool\DataConverters\Base58String.cs,FromByteArray,The following statement contains a magic number: while (bi > 0)  			{  				int mod = (int)(bi % 58);  				bi /= 58;  				sb.Insert(0' base58chars[mod]);  			}
Magic Number,Bitcoin_Tool.DataConverters,Base58String,C:\repos\mb300sd_Bitcoin-Tool\Bitcoin Tool\DataConverters\Base58String.cs,FromByteArray,The following statement contains a magic number: while (bi > 0)  			{  				int mod = (int)(bi % 58);  				bi /= 58;  				sb.Insert(0' base58chars[mod]);  			}
Magic Number,Bitcoin_Tool.DataConverters,HexString,C:\repos\mb300sd_Bitcoin-Tool\Bitcoin Tool\DataConverters\HexString.cs,ToByteArray,The following statement contains a magic number: if (s.Length % 2 != 0)  				throw new ArgumentException();
Magic Number,Bitcoin_Tool.DataConverters,HexString,C:\repos\mb300sd_Bitcoin-Tool\Bitcoin Tool\DataConverters\HexString.cs,ToByteArray,The following statement contains a magic number: return Enumerable.Range(0' s.Length / 2)  							 .Select(x => Byte.Parse(s.Substring(2 * x' 2)' System.Globalization.NumberStyles.HexNumber))  							 .ToArray();
Magic Number,Bitcoin_Tool.DataConverters,HexString,C:\repos\mb300sd_Bitcoin-Tool\Bitcoin Tool\DataConverters\HexString.cs,ToByteArray,The following statement contains a magic number: return Enumerable.Range(0' s.Length / 2)  							 .Select(x => Byte.Parse(s.Substring(2 * x' 2)' System.Globalization.NumberStyles.HexNumber))  							 .ToArray();
Magic Number,Bitcoin_Tool.DataConverters,HexString,C:\repos\mb300sd_Bitcoin-Tool\Bitcoin Tool\DataConverters\HexString.cs,ToByteArray,The following statement contains a magic number: return Enumerable.Range(0' s.Length / 2)  							 .Select(x => Byte.Parse(s.Substring(2 * x' 2)' System.Globalization.NumberStyles.HexNumber))  							 .ToArray();
Magic Number,Bitcoin_Tool.DataConverters,HexString,C:\repos\mb300sd_Bitcoin-Tool\Bitcoin Tool\DataConverters\HexString.cs,ToByteArrayReversed,The following statement contains a magic number: if (s.Length % 2 != 0)  				throw new ArgumentException();
Magic Number,Bitcoin_Tool.DataConverters,HexString,C:\repos\mb300sd_Bitcoin-Tool\Bitcoin Tool\DataConverters\HexString.cs,ToByteArrayReversed,The following statement contains a magic number: return Enumerable.Range(0' s.Length / 2)  							 .Select(x => Byte.Parse(s.Substring(2 * x' 2)' System.Globalization.NumberStyles.HexNumber))  							 .Reverse()  							 .ToArray();
Magic Number,Bitcoin_Tool.DataConverters,HexString,C:\repos\mb300sd_Bitcoin-Tool\Bitcoin Tool\DataConverters\HexString.cs,ToByteArrayReversed,The following statement contains a magic number: return Enumerable.Range(0' s.Length / 2)  							 .Select(x => Byte.Parse(s.Substring(2 * x' 2)' System.Globalization.NumberStyles.HexNumber))  							 .Reverse()  							 .ToArray();
Magic Number,Bitcoin_Tool.DataConverters,HexString,C:\repos\mb300sd_Bitcoin-Tool\Bitcoin Tool\DataConverters\HexString.cs,ToByteArrayReversed,The following statement contains a magic number: return Enumerable.Range(0' s.Length / 2)  							 .Select(x => Byte.Parse(s.Substring(2 * x' 2)' System.Globalization.NumberStyles.HexNumber))  							 .Reverse()  							 .ToArray();
Magic Number,Bitcoin_Tool.DataConverters,HexString,C:\repos\mb300sd_Bitcoin-Tool\Bitcoin Tool\DataConverters\HexString.cs,FromByteArray,The following statement contains a magic number: StringBuilder sb = new StringBuilder(b.Length * 2);
Magic Number,Bitcoin_Tool.DataConverters,HexString,C:\repos\mb300sd_Bitcoin-Tool\Bitcoin Tool\DataConverters\HexString.cs,FromByteArrayReversed,The following statement contains a magic number: StringBuilder sb = new StringBuilder(b.Length * 2);
Magic Number,Bitcoin_Tool,Program,C:\repos\mb300sd_Bitcoin-Tool\Bitcoin Tool\Program.cs,_Main,The following statement contains a magic number: TcpClient tcpClient = new TcpClient("10.1.1.10"' 8333);
Missing Default,Bitcoin_Tool.Scripts,Script,C:\repos\mb300sd_Bitcoin-Tool\Bitcoin Tool\Scripts\Script.cs,Evaluate,The following switch statement is missing a default case: switch (se.opCode)  							{  								case OpCode.OP_AND:  									{  										for (int i = 0; i < length; i++)  											data[i] &= data2[i];  										break;  									}  								case OpCode.OP_OR:  									{  										for (int i = 0; i < length; i++)  											data[i] |= data2[i];  										break;  									}  								case OpCode.OP_XOR:  									{  										for (int i = 0; i < length; i++)  											data[i] ^= data2[i];  										break;  									}  							}
Missing Default,Bitcoin_Tool.Scripts,Script,C:\repos\mb300sd_Bitcoin-Tool\Bitcoin Tool\Scripts\Script.cs,Evaluate,The following switch statement is missing a default case: switch (se.opCode)  							{  								case OpCode.OP_ADD:  									a = (BigInteger)a + b;  									break;  								case OpCode.OP_SUB:  									a = (BigInteger)a - b;  									break;  								case OpCode.OP_MUL:  									a = (BigInteger)a * b;  									break;  								case OpCode.OP_DIV:  									a = (BigInteger)a / b;  									break;  								case OpCode.OP_MOD:  									a = (BigInteger)a % b;  									break;  								case OpCode.OP_LSHIFT:  									a = (BigInteger)a << b.intValue;  									break;  								case OpCode.OP_RSHIFT:  									a = (BigInteger)a >> b.intValue;  									break;  							}
Missing Default,Bitcoin_Tool.Crypto,Address,C:\repos\mb300sd_Bitcoin-Tool\Bitcoin Tool\Crypto\Address.cs,Address,The following switch statement is missing a default case: switch (version)  			{  				case PUBKEY:  					pubKeyHash = ripemd160.ComputeHash(sha256.ComputeHash(data));  					version = PUBKEYHASH;  					break;  				case SCRIPT:  					scriptHash = ripemd160.ComputeHash(sha256.ComputeHash(data));  					version = SCRIPTHASH;  					break;  				case PUBKEYHASH:  					pubKeyHash = data;  					break;  				case SCRIPTHASH:  					scriptHash = data;  					break;  			}
Missing Default,Bitcoin_Tool.Crypto,Address,C:\repos\mb300sd_Bitcoin-Tool\Bitcoin Tool\Crypto\Address.cs,calcHash,The following switch statement is missing a default case: switch (version)  			{  				case PUBKEYHASH:  					pubKeyHash = hash;  					break;  				case SCRIPTHASH:  					scriptHash = hash;  					break;  			}
