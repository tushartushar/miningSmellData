Implementation smell,Namespace,Class,File,Method,Description
Long Method,CityTrafficSimulator,AboutBox,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\AboutBox\AboutBox.cs,InitializeComponent,The method has 161 lines of code.
Long Method,CityTrafficSimulator,Routing,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Routing.cs,CalculateShortestConenction,The method has 178 lines of code.
Long Method,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,DaGrid_MouseDown,The method has 263 lines of code.
Long Method,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,DaGrid_MouseMove,The method has 104 lines of code.
Long Method,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,DaGrid_KeyDown,The method has 206 lines of code.
Long Method,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,DaGrid_Paint,The method has 204 lines of code.
Long Method,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The method has 1262 lines of code.
Long Method,CityTrafficSimulator,NodeSteuerung,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\NodeSteuerung.cs,FindLineChangePoints,The method has 117 lines of code.
Long Method,CityTrafficSimulator,NodeSteuerung,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\NodeSteuerung.cs,RenderNetwork,The method has 109 lines of code.
Long Method,CityTrafficSimulator,NodeSteuerung,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\NodeSteuerung.cs,LoadFromFile,The method has 155 lines of code.
Long Method,CityTrafficSimulator.Timeline,TrafficLightForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TrafficLightForm.cs,InitializeComponent,The method has 326 lines of code.
Long Method,CityTrafficSimulator.Vehicle,IVehicle,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\IVehicle.cs,Think,The method has 311 lines of code.
Long Method,CityTrafficSimulator.Vehicle,IVehicle,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\IVehicle.cs,HandleIntersections,The method has 113 lines of code.
Long Method,CityTrafficSimulator.Vehicle,Tram,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Tram.cs,BuildGraphicsPath,The method has 116 lines of code.
Long Method,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The method has 623 lines of code.
Complex Method,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,DaGrid_Paint,Cyclomatic complexity of the method is 9
Complex Method,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,pnlStatistics_Paint,Cyclomatic complexity of the method is 8
Complex Method,CityTrafficSimulator,NodeSteuerung,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\NodeSteuerung.cs,FindLineChangePoints,Cyclomatic complexity of the method is 12
Complex Method,CityTrafficSimulator,NodeSteuerung,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\NodeSteuerung.cs,RenderNetwork,Cyclomatic complexity of the method is 21
Complex Method,CityTrafficSimulator,NodeSteuerung,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\NodeSteuerung.cs,SaveToFile,Cyclomatic complexity of the method is 8
Complex Method,CityTrafficSimulator,NodeSteuerung,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\NodeSteuerung.cs,LoadFromFile,Cyclomatic complexity of the method is 19
Complex Method,CityTrafficSimulator,TrafficLight,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\TrafficLight.cs,RecoverFromLoad,Cyclomatic complexity of the method is 9
Complex Method,CityTrafficSimulator.Timeline,TimelineGroup,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TimelineGroup.cs,UpdateConflictPoints,Cyclomatic complexity of the method is 19
Complex Method,CityTrafficSimulator.Timeline,TimelineSteuerung,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TimelineSteuerung.cs,LoadFromFile,Cyclomatic complexity of the method is 9
Complex Method,CityTrafficSimulator.Vehicle,IVehicle,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\IVehicle.cs,Think,Cyclomatic complexity of the method is 38
Complex Method,CityTrafficSimulator.Vehicle,IVehicle,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\IVehicle.cs,Move,Cyclomatic complexity of the method is 12
Complex Method,CityTrafficSimulator.Vehicle,IVehicle,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\IVehicle.cs,GatherNextIntersectionsOnMyTrack,Cyclomatic complexity of the method is 8
Complex Method,CityTrafficSimulator.Vehicle,IVehicle,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\IVehicle.cs,HandleIntersections,Cyclomatic complexity of the method is 11
Long Parameter List,CityTrafficSimulator,LineNode,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\LineNode.cs,LineNode,The method has 5 parameters. Parameters: Position' inSlope' outSlope' nl' stopSign
Long Parameter List,CityTrafficSimulator,LineSegment,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\LineSegment.cs,LineSegment,The method has 5 parameters. Parameters: arcPosStart' p0' p1' p2' p3
Long Parameter List,CityTrafficSimulator,NodeConnection,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\NodeConnection.cs,NodeConnection,The method has 10 parameters. Parameters: startNode' endNode' ls' priority' targetVelocity' carsAllowed' busAllowed' tramAllowed' enableIncomingLineChange' enableOutgoingLineChange
Long Parameter List,CityTrafficSimulator,NodeSteuerung,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\NodeSteuerung.cs,Connect,The method has 9 parameters. Parameters: from' to' priority' targetVelocity' carsAllowed' busAllowed' tramAllowed' enableIncomingLineChange' enableOutgoingLineChange
Long Parameter List,CityTrafficSimulator,NodeSteuerung,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\NodeSteuerung.cs,MergeIntersectionPairs,The method has 5 parameters. Parameters: correctList' newList' aSegment' bSegment' tolerance
Long Parameter List,CityTrafficSimulator,NodeSteuerung,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\NodeSteuerung.cs,CalculateIntersections,The method has 9 parameters. Parameters: aSegment' bSegment' aTimeStart' aTimeEnd' bTimeStart' bTimeEnd' tolerance' aOriginalSegment' bOriginalSegment
Long Parameter List,CityTrafficSimulator,IDM,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Tools\IDM.cs,CalculateAcceleration,The method has 5 parameters. Parameters: velocity' desiredVelocity' distance' wantedDistance' vDiff
Long Parameter List,CityTrafficSimulator,XmlSaver,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\XmlSaver.cs,SaveToFile,The method has 5 parameters. Parameters: filename' nodeSteuerung' timelineSteuerung' trafficVolumeSteuerung' ps
Long Parameter List,CityTrafficSimulator.Timeline,TimelineEvent,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TimelineEvent.cs,TimelineEvent,The method has 5 parameters. Parameters: time' length' color' startAction' endAction
Long Identifier,CityTrafficSimulator,Constants,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Constants.cs,,The length of the parameter maxDistanceToParallelConnection is 31.
Long Identifier,CityTrafficSimulator,Constants,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Constants.cs,,The length of the parameter maximumAngleBetweenConnectionsForLineChangePoint is 48.
Long Identifier,CityTrafficSimulator,Constants,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Constants.cs,,The length of the parameter defaultLineChangeIntervalDictionaryCapacity is 43.
Long Identifier,CityTrafficSimulator,Constants,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Constants.cs,,The length of the parameter lineChangeBeforeTrafficLightPenalty is 35.
Long Identifier,CityTrafficSimulator,Constants,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Constants.cs,,The length of the parameter maxRatioForVoluntaryLineChange is 30.
Long Identifier,CityTrafficSimulator,Constants,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Constants.cs,,The length of the parameter breakPointBeforeForcedLineChange is 32.
Long Identifier,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,,The length of the parameter doHandleTrafficLightTreeViewSelect is 34.
Long Identifier,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,,The length of the parameter nodeConnectionPrioritySpinEdit is 30.
Long Identifier,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,,The length of the parameter enableOutgoingLineChangeCheckBox is 32.
Long Identifier,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,,The length of the parameter enableIncomingLineChangeCheckBox is 32.
Long Identifier,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,,The length of the parameter backgroundImageScalingSpinEdit is 30.
Long Identifier,CityTrafficSimulator,Intersection,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Intersection.cs,,The length of the parameter m_CalculatedInterferingVehicles is 31.
Long Identifier,CityTrafficSimulator,NodeSteuerung,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\NodeSteuerung.cs,FindLineChangePoints,The length of the parameter maxDistanceToOtherNodeConnection is 32.
Long Identifier,CityTrafficSimulator,NodeSteuerung,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\NodeSteuerung.cs,RemoveLineChangePoints,The length of the parameter removeOutgoingLineChangePoints is 30.
Long Identifier,CityTrafficSimulator,NodeSteuerung,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\NodeSteuerung.cs,RemoveLineChangePoints,The length of the parameter removeIncomingLineChangePoints is 30.
Long Identifier,CityTrafficSimulator.Vehicle,IVehicle,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\IVehicle.cs,Think,The length of the parameter myArcPositionOnOtherConnection is 30.
Long Identifier,CityTrafficSimulator.Vehicle,IVehicle,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\IVehicle.cs,Think,The length of the parameter myAccelerationOnOtherConnection is 31.
Long Identifier,CityTrafficSimulator.Vehicle,IVehicle,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\IVehicle.cs,Think,The length of the parameter forcedAccelerationOfVehicleBehindMeOnOtherConnection is 52.
Long Identifier,CityTrafficSimulator.Vehicle,IVehicle,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\IVehicle.cs,Think,The length of the parameter currentAccelerationOfVehicleBehindMeOnOtherConnection is 53.
Long Identifier,CityTrafficSimulator.Vehicle,IVehicle,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\IVehicle.cs,Think,The length of the parameter myArcPositionOnOtherConnection is 30.
Long Identifier,CityTrafficSimulator.Vehicle,IVehicle,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\IVehicle.cs,Think,The length of the parameter myAccelerationOnOtherConnection is 31.
Long Identifier,CityTrafficSimulator.Vehicle,IVehicle,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\IVehicle.cs,Think,The length of the parameter forcedAccelerationOfVehicleBehindMeOnOtherConnection is 52.
Long Identifier,CityTrafficSimulator.Vehicle,IVehicle,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\IVehicle.cs,Think,The length of the parameter currentAccelerationOfVehicleBehindMeOnOtherConnection is 53.
Long Identifier,CityTrafficSimulator.Vehicle,IVehicle,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\IVehicle.cs,GetNextVehicleOnMyTrack,The length of the parameter arcLengthToLookForParallelVehicles is 34.
Long Identifier,CityTrafficSimulator.Vehicle,IVehicle,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\IVehicle.cs,HandleIntersections,The length of the parameter remainingDistanceToPrevIntersection is 35.
Long Identifier,CityTrafficSimulator.Vehicle,IVehicle,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\IVehicle.cs,,The length of the parameter currentPositionOnLineChangePoint is 32.
Long Identifier,CityTrafficSimulator.Vehicle,IVehicle,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\IVehicle.cs,,The length of the parameter ratioProjectionOnTargetConnectionvsLCPLength is 44.
Long Identifier,CityTrafficSimulator.Vehicle,IVehicle,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\IVehicle.cs,,The length of the parameter temporaryRegisteredIntersections is 32.
Long Identifier,CityTrafficSimulator.Vehicle,Statistics,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\IVehicle.cs,,The length of the parameter arcPositionOfStartOnNodeConnection is 34.
Long Identifier,CityTrafficSimulator.Vehicle,State,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\IVehicle.cs,SetLineChangeVehicleInteraction,The length of the parameter myTailPositionOnTargetConnection is 32.
Long Identifier,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,,The length of the parameter spinGlobalTrafficVolumeMultiplier is 33.
Long Statement,CityTrafficSimulator,AboutBox,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\AboutBox\AboutBox.cs,InitializeComponent,The length of the statement  "            System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(AboutBox)); " is 128.
Long Statement,CityTrafficSimulator,AboutBox,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\AboutBox\AboutBox.cs,InitializeComponent,The length of the statement  "            this.tableLayoutPanel.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle(System.Windows.Forms.SizeType.Percent' 33F)); " is 121.
Long Statement,CityTrafficSimulator,AboutBox,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\AboutBox\AboutBox.cs,InitializeComponent,The length of the statement  "            this.tableLayoutPanel.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle(System.Windows.Forms.SizeType.Percent' 67F)); " is 121.
Long Statement,CityTrafficSimulator,AboutBox,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\AboutBox\AboutBox.cs,InitializeComponent,The length of the statement  "            this.tableLayoutPanel.RowStyles.Add(new System.Windows.Forms.RowStyle(System.Windows.Forms.SizeType.Percent' 7.142857F)); " is 121.
Long Statement,CityTrafficSimulator,AboutBox,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\AboutBox\AboutBox.cs,InitializeComponent,The length of the statement  "            this.tableLayoutPanel.RowStyles.Add(new System.Windows.Forms.RowStyle(System.Windows.Forms.SizeType.Percent' 7.142857F)); " is 121.
Long Statement,CityTrafficSimulator,AboutBox,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\AboutBox\AboutBox.cs,InitializeComponent,The length of the statement  "            this.tableLayoutPanel.RowStyles.Add(new System.Windows.Forms.RowStyle(System.Windows.Forms.SizeType.Percent' 7.142857F)); " is 121.
Long Statement,CityTrafficSimulator,AboutBox,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\AboutBox\AboutBox.cs,InitializeComponent,The length of the statement  "            this.tableLayoutPanel.RowStyles.Add(new System.Windows.Forms.RowStyle(System.Windows.Forms.SizeType.Percent' 7.142857F)); " is 121.
Long Statement,CityTrafficSimulator,AboutBox,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\AboutBox\AboutBox.cs,InitializeComponent,The length of the statement  "            this.tableLayoutPanel.RowStyles.Add(new System.Windows.Forms.RowStyle(System.Windows.Forms.SizeType.Percent' 7.142857F)); " is 121.
Long Statement,CityTrafficSimulator,AboutBox,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\AboutBox\AboutBox.cs,InitializeComponent,The length of the statement  "            this.tableLayoutPanel.RowStyles.Add(new System.Windows.Forms.RowStyle(System.Windows.Forms.SizeType.Percent' 57.14286F)); " is 121.
Long Statement,CityTrafficSimulator,AboutBox,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\AboutBox\AboutBox.cs,InitializeComponent,The length of the statement  "            this.tableLayoutPanel.RowStyles.Add(new System.Windows.Forms.RowStyle(System.Windows.Forms.SizeType.Percent' 7.142857F)); " is 121.
Long Statement,CityTrafficSimulator,AboutBox,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\AboutBox\AboutBox.cs,InitializeComponent,The length of the statement  "            this.okButton.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right))); " is 147.
Long Statement,CityTrafficSimulator,Auftrag,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Auftrag.cs,Tick,The length of the statement  "					zufallsvariable = GlobalRandom.Instance.Next(failedCount' Decimal.ToInt32((decimal)m_häufigkeit / trafficDensityMultiplier)); " is 125.
Long Statement,CityTrafficSimulator,Routing,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Routing.cs,CalculateShortestConenction,The length of the statement  "							toReturn.Push(new RouteSegment(startnode.node.GetNodeConnectionTo(endnode.node)' endnode.node' false' startnode.node.GetNodeConnectionTo(endnode.node).lineSegment.length)); " is 172.
Long Statement,CityTrafficSimulator,Routing,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Routing.cs,CalculateShortestConenction,The length of the statement  "							// Anfangs-/ oder Endknoten des Spurwechsels ist eine Ampel => Kosten-Penalty' da hier verstärktes Verkehrsaufkommen zu erwarten ist " is 132.
Long Statement,CityTrafficSimulator,Routing,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Routing.cs,CalculateShortestConenction,The length of the statement  "								f += (lci.length < 2 * Constants.minimumLineChangeLength) ? 2 * Constants.lineChangePenalty : Constants.lineChangePenalty; " is 122.
Long Statement,CityTrafficSimulator,Routing,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Routing.cs,CalculateShortestConenction,The length of the statement  "								// Anfangs-/ oder Endknoten des Spurwechsels ist eine Ampel => Kosten-Penalty' da hier verstärktes Verkehrsaufkommen zu erwarten ist " is 132.
Long Statement,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,pnlLayers_Resize,The length of the statement  "			btnAddLayer.Location = new System.Drawing.Point(pnlLayers.ClientSize.Width - btnAddLayer.Width - 24' tlpLayers.Height + 8); " is 123.
Long Statement,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,pnlLayers_Resize_1,The length of the statement  "			btnAddLayer.Location = new System.Drawing.Point(pnlLayers.ClientSize.Width - btnAddLayer.Width - 24' tlpLayers.Height + 8); " is 123.
Long Statement,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,thumbGrid_MouseDown,The length of the statement  "				float zoom = Math.Min(1.0f' Math.Min((float)thumbGrid.ClientSize.Width / bounds.Width' (float)thumbGrid.ClientSize.Height / bounds.Height)); " is 140.
Long Statement,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,thumbGrid_MouseUp,The length of the statement  "				float zoom = Math.Min(1.0f' Math.Min((float)thumbGrid.ClientSize.Width / bounds.Width' (float)thumbGrid.ClientSize.Height / bounds.Height)); " is 140.
Long Statement,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,DaGrid_MouseDown,The length of the statement  "								nodesToAdd.Add(new LineNode(DaGrid.DockToGrid(clickedPosition' dockToGrid)' cbNetworkLayer.SelectedItem as NetworkLayer' cbStopSign.Checked)); " is 142.
Long Statement,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,DaGrid_MouseDown,The length of the statement  "									nodesToAdd.Add(new LineNode(DaGrid.DockToGrid(clickedPosition - offset' dockToGrid)' cbNetworkLayer.SelectedItem as NetworkLayer' cbStopSign.Checked)); " is 151.
Long Statement,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,DaGrid_MouseDown,The length of the statement  "								nodesToAdd.Add(new LineNode(DaGrid.DockToGrid(clickedPosition' dockToGrid)' cbNetworkLayer.SelectedItem as NetworkLayer' cbStopSign.Checked)); " is 142.
Long Statement,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,DaGrid_MouseDown,The length of the statement  "									nodesToAdd.Add(new LineNode(DaGrid.DockToGrid(clickedPosition - offset' dockToGrid)' cbNetworkLayer.SelectedItem as NetworkLayer' cbStopSign.Checked)); " is 151.
Long Statement,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,DaGrid_MouseDown,The length of the statement  "							nodesToAdd.Add(new LineNode(DaGrid.DockToGrid(clickedPosition' dockToGrid)' cbNetworkLayer.SelectedItem as NetworkLayer' cbStopSign.Checked)); " is 142.
Long Statement,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,DaGrid_MouseMove,The length of the statement  "						daGridScrollPosition = new Point((int)Math.Round(-clickedPosition.X + daGridRubberband.X)' (int)Math.Round(-clickedPosition.Y + daGridRubberband.Y)); " is 149.
Long Statement,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,DaGrid_MouseMove,The length of the statement  "							double rotation = Math.Atan2(selectedLineNodesMovingOffset[i].Y' selectedLineNodesMovingOffset[i].X) - Math.Atan2(selectedLineNodesMovingOffset[0].Y' selectedLineNodesMovingOffset[0].X); " is 186.
Long Statement,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,DaGrid_MouseMove,The length of the statement  "							m_selectedLineNodes[i].position = m_selectedLineNodes[0].position - (m_selectedLineNodes[0].outSlope.RotateCounterClockwise(rotation).Normalized * selectedLineNodesMovingOffset[i].Abs); " is 185.
Long Statement,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,DaGrid_MouseMove,The length of the statement  "							double streckungsfaktor = Math.Pow((m_selectedLineNodes[i].position - previousSelectedNodePositions[i]).Abs / (m_selectedLineNodes[0].position - previousSelectedNodePositions[0]).Abs' 2); " is 187.
Long Statement,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,DaGrid_MouseMove,The length of the statement  "							double rotation = Math.Atan2(m_selectedLineNodes[0].inSlope.Y' m_selectedLineNodes[0].inSlope.X) - Math.Atan2(originalSlopes[0].Y' originalSlopes[0].X); " is 152.
Long Statement,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,DaGrid_MouseMove,The length of the statement  "							double rotation = Math.Atan2(m_selectedLineNodes[0].outSlope.Y' m_selectedLineNodes[0].outSlope.X) - Math.Atan2(originalSlopes[0].Y' originalSlopes[0].X); " is 154.
Long Statement,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,DaGrid_MouseUp,The length of the statement  "			if ((howToDrag == DragNDrop.CREATE_NODE || howToDrag == DragNDrop.MOVE_NODES || howToDrag == DragNDrop.MOVE_IN_SLOPE || howToDrag == DragNDrop.MOVE_OUT_SLOPE) && m_selectedLineNodes != null) " is 190.
Long Statement,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,DaGrid_MouseWheel,The length of the statement  "				zoomComboBox.SelectedIndex = Math2.Clamp(zoomComboBox.SelectedIndex + (e.Delta / 120)' 0' zoomComboBox.Items.Count - 1); " is 120.
Long Statement,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,DaGrid_KeyDown,The length of the statement  "					nodeSteuerung.FindLineChangePoints(selectedNodeConnection' Constants.maxDistanceToLineChangePoint' Constants.maxDistanceToParallelConnection); " is 142.
Long Statement,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,DaGrid_KeyDown,The length of the statement  "				if (((Control.ModifierKeys & Keys.Control) == Keys.Control) && zoomComboBox.SelectedIndex < zoomComboBox.Items.Count - 1) " is 121.
Long Statement,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,DaGrid_KeyDown,The length of the statement  "				if (((Control.ModifierKeys & Keys.Control) == Keys.Control) && zoomComboBox.SelectedIndex < zoomComboBox.Items.Count - 1) " is 121.
Long Statement,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,DaGrid_Paint,The length of the statement  "				e.Graphics.DrawImageUnscaled(resampledBackgroundImage' new Point((int)Math.Round(-daGridScrollPosition.X * zoomMultipliers[zoomComboBox.SelectedIndex' 0])' (int)Math.Round(-daGridScrollPosition.Y * zoomMultipliers[zoomComboBox.SelectedIndex' 0]))); " is 248.
Long Statement,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,DaGrid_Paint,The length of the statement  "					int countX = (int)Math.Ceiling(DaGrid.ClientSize.Width * zoomMultipliers[zoomComboBox.SelectedIndex' 1] / ((float)spinGridSpacing.Value * 10.0f)); " is 146.
Long Statement,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,DaGrid_Paint,The length of the statement  "					int countY = (int)Math.Ceiling(DaGrid.ClientSize.Height * zoomMultipliers[zoomComboBox.SelectedIndex' 1] / ((float)spinGridSpacing.Value * 10.0f)); " is 147.
Long Statement,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,DaGrid_Paint,The length of the statement  "						e.Graphics.DrawLine(GrayPen' i * (float)spinGridSpacing.Value * 10.0f * zoomMultipliers[zoomComboBox.SelectedIndex' 0]' 0' i * (float)spinGridSpacing.Value * 10.0f * zoomMultipliers[zoomComboBox.SelectedIndex' 0]' DaGrid.ClientSize.Height); " is 240.
Long Statement,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,DaGrid_Paint,The length of the statement  "						e.Graphics.DrawLine(GrayPen' 0' i * (float)spinGridSpacing.Value * 10.0f * zoomMultipliers[zoomComboBox.SelectedIndex' 0]' DaGrid.ClientSize.Width' i * (float)spinGridSpacing.Value * 10.0f * zoomMultipliers[zoomComboBox.SelectedIndex' 0]); " is 239.
Long Statement,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,DaGrid_Paint,The length of the statement  "				-daGridScrollPosition.X * zoomMultipliers[zoomComboBox.SelectedIndex' 0]' -daGridScrollPosition.Y * zoomMultipliers[zoomComboBox.SelectedIndex' 0]); " is 148.
Long Statement,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,DaGrid_Paint,The length of the statement  "					List<Pair<SpecificIntersection' double>> foo = trafficLightForm.selectedEntry.parentGroup.GetConflictPoints(trafficLightForm.selectedEntry); " is 140.
Long Statement,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,DaGrid_Paint,The length of the statement  "						e.Graphics.DrawBezier(prevNodeConnectionsPen' prevNC.lineSegment.p0' prevNC.lineSegment.p1' prevNC.lineSegment.p2' prevNC.lineSegment.p3); " is 138.
Long Statement,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,DaGrid_Paint,The length of the statement  "							e.Graphics.DrawBezier(nextNodeConnectionsPen' nextNC.lineSegment.p0' nextNC.lineSegment.p1' nextNC.lineSegment.p2' nextNC.lineSegment.p3); " is 138.
Long Statement,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,DaGrid_Paint,The length of the statement  "						"thinking time: " + thinkStopwatch.ElapsedMilliseconds + "ms' possible thoughts per second: " + ((thinkStopwatch.ElapsedMilliseconds != 0) ? (1000 / thinkStopwatch.ElapsedMilliseconds).ToString() : "-")' " is 203.
Long Statement,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,DaGrid_Paint,The length of the statement  "						"rendering time: " + renderStopwatch.ElapsedMilliseconds + "ms' possible fps: " + ((renderStopwatch.ElapsedMilliseconds != 0) ? (1000 / renderStopwatch.ElapsedMilliseconds).ToString() : "-")' " is 191.
Long Statement,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,thumbGrid_Paint,The length of the statement  "			float zoom = Math.Min(1.0f' Math.Min((float)thumbGrid.ClientSize.Width / bounds.Width' (float)thumbGrid.ClientSize.Height / bounds.Height)); " is 140.
Long Statement,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,thumbGrid_Paint,The length of the statement  "								e.Graphics.DrawBezier(orangePen' nextNC.lineSegment.p0' nextNC.lineSegment.p1' nextNC.lineSegment.p2' nextNC.lineSegment.p3); " is 125.
Long Statement,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,UpdateDaGridClippingRect,The length of the statement  "				renderOptionsDaGrid.clippingRect.Width = (int)Math.Ceiling(pnlMainGrid.ClientSize.Width * zoomMultipliers[zoomComboBox.SelectedIndex' 1]); " is 138.
Long Statement,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,UpdateDaGridClippingRect,The length of the statement  "				renderOptionsDaGrid.clippingRect.Height = (int)Math.Ceiling(pnlMainGrid.ClientSize.Height * zoomMultipliers[zoomComboBox.SelectedIndex' 1]); " is 140.
Long Statement,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,UpdateDaGridClippingRect,The length of the statement  "				float zoom = Math.Min(1.0f' Math.Min((float)thumbGrid.ClientSize.Width / bounds.Width' (float)thumbGrid.ClientSize.Height / bounds.Height)); " is 140.
Long Statement,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,UpdateDaGridClippingRect,The length of the statement  "				lblScrollPosition.Text = "Canvas Location (dm): (" + daGridScrollPosition.X + "' " + daGridScrollPosition.Y + ") -> (" + (daGridScrollPosition.X + renderOptionsDaGrid.clippingRect.Width) + "' " + (daGridScrollPosition.Y + renderOptionsDaGrid.clippingRect.Height) + ")"; " is 269.
Long Statement,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,LadenButton_Click,The length of the statement  "					Tools.ProgramSettings ps = XmlSaver.LoadFromFile(ofd.FileName' nodeSteuerung' timelineSteuerung' trafficVolumeSteuerung); " is 121.
Long Statement,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,timer1_Tick,The length of the statement  "			if (GlobalTime.Instance.currentTime < (double)spinSimulationDuration.Value && (GlobalTime.Instance.currentTime + tickLength) >= (double)spinSimulationDuration.Value) " is 165.
Long Statement,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,UpdateBackgroundImage,The length of the statement  "					(int)Math.Round(backgroundImage.Width * zoomMultipliers[zoomComboBox.SelectedIndex' 0] * ((float)backgroundImageScalingSpinEdit.Value / 100))' " is 142.
Long Statement,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,UpdateBackgroundImage,The length of the statement  "					(int)Math.Round(backgroundImage.Height * zoomMultipliers[zoomComboBox.SelectedIndex' 0] * ((float)backgroundImageScalingSpinEdit.Value / 100))); " is 144.
Long Statement,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,UpdateConnectionsRenderCache,The length of the statement  "					-daGridScrollPosition.X * zoomMultipliers[zoomComboBox.SelectedIndex' 0]' -daGridScrollPosition.Y * zoomMultipliers[zoomComboBox.SelectedIndex' 0]); " is 148.
Long Statement,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,zoomComboBox_SelectedIndexChanged,The length of the statement  "				(int)Math.Round(daGridViewCenter.X - (pnlMainGrid.ClientSize.Width / 2 * zoomMultipliers[zoomComboBox.SelectedIndex' 1]))' " is 122.
Long Statement,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,zoomComboBox_SelectedIndexChanged,The length of the statement  "				(int)Math.Round(daGridViewCenter.Y - (pnlMainGrid.ClientSize.Height / 2 * zoomMultipliers[zoomComboBox.SelectedIndex' 1]))); " is 124.
Long Statement,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,findLineChangePointsButton_Click,The length of the statement  "					nodeSteuerung.FindLineChangePoints(nc' Constants.maxDistanceToLineChangePoint' Constants.maxDistanceToParallelConnection); " is 122.
Long Statement,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,enableIncomingLineChangeCheckBox_Click,The length of the statement  "							nodeSteuerung.FindLineChangePoints(nc' Constants.maxDistanceToLineChangePoint' Constants.maxDistanceToParallelConnection); " is 122.
Long Statement,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,enableOutgoingLineChangeCheckBox_Click,The length of the statement  "				if (enableOutgoingLineChangeCheckBox.Checked && (m_selectedNodeConnection.carsAllowed || m_selectedNodeConnection.busAllowed)) " is 126.
Long Statement,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,enableOutgoingLineChangeCheckBox_Click,The length of the statement  "					nodeSteuerung.FindLineChangePoints(m_selectedNodeConnection' Constants.maxDistanceToLineChangePoint' Constants.maxDistanceToParallelConnection); " is 144.
Long Statement,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,btnSetWorldCoordinates_Click,The length of the statement  "			string baseUrl = @"http://maps.google.com/maps/api/staticmap?zoom=19&size=635x628&sensor=false&maptype=satellite&center="; " is 122.
Long Statement,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,btnSetWorldCoordinates_Click,The length of the statement  "					satelliteImages[i'j] = DownloadImage(baseUrl + (spinLatitude.Value - (0.001m * i)).ToString(ci) + "'" + (spinLongitude.Value + (0.0017m * j)).ToString(ci)); " is 156.
Long Statement,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,btnSetWorldCoordinates_Click,The length of the statement  "						satelliteImages[i' j] = ResizeBitmap(new Bitmap(satelliteImages[i' j])' (int)(satelliteImages[i' j].Width * 1.739)' (int)(satelliteImages[i' j].Height * 1.739)); " is 161.
Long Statement,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,btnSetWorldCoordinates_Click,The length of the statement  "// 				satelliteImages[0' 0] = DownloadImage(baseUrl + spinLatitude.Value.ToString(ci) + "'" + spinLongitude.Value.ToString(ci)); " is 129.
Long Statement,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,btnSetWorldCoordinates_Click,The length of the statement  "// 			satelliteImages[1' 0] = DownloadImage(baseUrl + (spinLatitude.Value - 0.001m).ToString(ci) + "'" + spinLongitude.Value.ToString(ci)); " is 139.
Long Statement,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,btnSetWorldCoordinates_Click,The length of the statement  "// 			satelliteImages[0' 1] = DownloadImage(baseUrl + spinLatitude.Value.ToString(ci) + "'" + (spinLongitude.Value + 0.0017m).ToString(ci)); " is 140.
Long Statement,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,btnSetWorldCoordinates_Click,The length of the statement  "// 			satelliteImages[1' 1] = DownloadImage(baseUrl + (spinLatitude.Value - 0.001m).ToString(ci) + "'" + (spinLongitude.Value + 0.0017m).ToString(ci)); " is 151.
Long Statement,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,pnlStatistics_Paint,The length of the statement  "				Matrix velocityMatrix = new Matrix((float)pnlStatistics.Width / numBuckets' 0' 0' (float)pnlStatistics.Height / (float)-maxFloat' 0' pnlStatistics.Height - 5); " is 159.
Long Statement,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,pnlStatistics_Paint,The length of the statement  "				Matrix numVehicleMatrix = new Matrix((float)pnlStatistics.Width / numBuckets' 0' 0' (float)pnlStatistics.Height / -maxInt' 0' pnlStatistics.Height - 5); " is 152.
Long Statement,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,cbRenderGrid_SizeChanged,The length of the statement  "			spinGridSpacing.Location = new System.Drawing.Point(cbRenderGrid.Location.X + cbRenderGrid.Width + 5' spinGridSpacing.Location.Y); " is 130.
Long Statement,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,cbRenderGrid_SizeChanged,The length of the statement  "			lblMeters.Location = new System.Drawing.Point(spinGridSpacing.Location.X + spinGridSpacing.Width + 5' lblMeters.Location.Y); " is 124.
Long Statement,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The length of the statement  "			System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(MainForm)); " is 128.
Long Statement,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The length of the statement  "			this.backgroundImageScalingSpinEdit.ValueChanged += new System.EventHandler(this.backgroundImageScalingSpinEdit_ValueChanged); " is 126.
Long Statement,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The length of the statement  "			this.nodeConnectionPrioritySpinEdit.ValueChanged += new System.EventHandler(this.nodeConnectionPrioritySpinEdit_ValueChanged); " is 126.
Long Statement,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The length of the statement  "			this.cmcVelocityMapping.ColorMapChanged += new CityTrafficSimulator.Tools.ColorMapControl.ColorMapChangedEventHandler(this.cmVelocityMapping_ColorMapChanged); " is 158.
Long Statement,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The length of the statement  "			this.trafficLightTreeView.AfterSelect += new System.Windows.Forms.TreeViewEventHandler(this.trafficLightTreeView_AfterSelect); " is 126.
Long Statement,CityTrafficSimulator,Intersection,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Intersection.cs,RegisterVehicle,The length of the statement  "			double blockingStartTime = currentTime + CalculateArrivingTime(v' distance - (_frontWaitingDistance / 2)) - v.SafetyTime/8; " is 123.
Long Statement,CityTrafficSimulator,Intersection,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Intersection.cs,RegisterVehicle,The length of the statement  "				aCrossingVehicles.Add(v' new CrossingVehicleTimes(originalArrivingTime' distance' new Interval<double>(blockingStartTime' blockingEndTime)' false)); " is 148.
Long Statement,CityTrafficSimulator,Intersection,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Intersection.cs,RegisterVehicle,The length of the statement  "				bCrossingVehicles.Add(v' new CrossingVehicleTimes(originalArrivingTime' distance' new Interval<double>(blockingStartTime' blockingEndTime)' false)); " is 148.
Long Statement,CityTrafficSimulator,Intersection,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Intersection.cs,UpdateVehicle,The length of the statement  "			double blockingStartTime = currentTime + CalculateArrivingTime(v' distance - (_frontWaitingDistance / 2)) - v.SafetyTime / 8; " is 125.
Long Statement,CityTrafficSimulator,Intersection,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Intersection.cs,CalculateInterferingVehicles,The length of the statement  "			Dictionary<IVehicle' CrossingVehicleTimes> myCrossingVehicles = (nc == _aConnection ? aCrossingVehicles : bCrossingVehicles); " is 125.
Long Statement,CityTrafficSimulator,Intersection,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Intersection.cs,CalculateInterferingVehicles,The length of the statement  "			Dictionary<IVehicle' CrossingVehicleTimes> otherCrossingVehicles = (nc == _aConnection ? bCrossingVehicles : aCrossingVehicles); " is 128.
Long Statement,CityTrafficSimulator,Intersection,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Intersection.cs,CalculateInterferingVehicles,The length of the statement  "			if (_aConnection.startNode != _bConnection.startNode || (_frontWaitingDistance < aArcPosition && _frontWaitingDistance < bArcPosition)) " is 135.
Long Statement,CityTrafficSimulator,Intersection,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Intersection.cs,CalculateArrivingTime,The length of the statement  "				//double timeToArrive = (v.physics.desiredVelocity * Math2.Acosh (Math.Exp(v.a * distance / Math2.Square(v.physics.desiredVelocity)))) / (10 * v.a); " is 148.
Long Statement,CityTrafficSimulator,LineNode,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\LineNode.cs,InitStopSignEdgeOffsets,The length of the statement  "					_stopSignEdgeOffsets[i] = new PointF((float)(12 * Math.Sin((2 * i + 1) * Math.PI / 8.0))' (float)(12 * Math.Cos((2 * i + 1) * Math.PI / 8.0))); " is 143.
Long Statement,CityTrafficSimulator,LineNode,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\LineNode.cs,UpdateNodeGraphics,The length of the statement  "                _nodeGraphics[0] = new System.Drawing.Drawing2D.GraphicsPath(new PointF[] { inSlopeAbs' position }' new byte[] { 1' 1 }); " is 121.
Long Statement,CityTrafficSimulator,LineNode,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\LineNode.cs,UpdateNodeGraphics,The length of the statement  "                _nodeGraphics[1] = new System.Drawing.Drawing2D.GraphicsPath(new PointF[] { outSlopeAbs' position }' new byte[] { 1' 1 }); " is 122.
Long Statement,CityTrafficSimulator,LineNode,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\LineNode.cs,Draw,The length of the statement  "					poly[i] = new PointF((float)(_position.X + _stopSignEdgeOffsets[i].X)' (float)(_position.Y + _stopSignEdgeOffsets[i].Y)); " is 121.
Long Statement,CityTrafficSimulator,NodeConnection,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\NodeConnection.cs,GetVehiclesAroundArcPosition,The length of the statement  "			return new Pair<VehicleDistance>(GetVehicleBeforeArcPosition(arcPosition' distanceWithin)' GetVehicleBehindArcPosition(arcPosition' distanceWithin)); " is 149.
Long Statement,CityTrafficSimulator,NodeConnection,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\NodeConnection.cs,Handler_VehicleLeftNodeConnection,The length of the statement  "			float averageSpeed = (float)((e.partsUsed.right - e.partsUsed.left) / (10 * (e.timeInterval.right - e.timeInterval.left))); " is 123.
Long Statement,CityTrafficSimulator,NodeConnection,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\NodeConnection.cs,DrawLineChangePoints,The length of the statement  "								g.FillEllipse(orangeBrush' new Rectangle(lcp.otherStart.nc.lineSegment.AtTime(lcp.otherStart.time) - new Vector2(2' 2)' new Size(3' 3))); " is 137.
Long Statement,CityTrafficSimulator,NodeConnection,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\NodeConnection.cs,DrawLineChangePoints,The length of the statement  "								g.FillEllipse(redBrush' new Rectangle(lcp.target.nc.lineSegment.AtTime(lcp.target.time) - new Vector2(2' 2)' new Size(3' 3))); " is 126.
Long Statement,CityTrafficSimulator,NodeConnection,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\NodeConnection.cs,DrawDebugData,The length of the statement  "			g.DrawString(/*"Länge: " + (lineSegment.length/10) + "m\n*/"avg Speed:" + getAverageSpeedOfVehicles() + " m/s"' new Font("Arial"' 9)' new SolidBrush(Color.Black)' lineSegment.AtTime(0.5)); " is 188.
Long Statement,CityTrafficSimulator,NodeSteuerung,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\NodeSteuerung.cs,Connect,The length of the statement  "			NodeConnection nc = new NodeConnection(from' to' null' priority' targetVelocity' carsAllowed' busAllowed' tramAllowed' enableIncomingLineChange' enableOutgoingLineChange); " is 171.
Long Statement,CityTrafficSimulator,NodeSteuerung,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\NodeSteuerung.cs,MergeIntersectionPairs,The length of the statement  "						toReturn[i] = new Pair<double>(toReturn[i].Left + (p.Left - toReturn[i].Left) / 2' toReturn[i].Right + (p.Right - toReturn[i].Right) / 2); " is 138.
Long Statement,CityTrafficSimulator,NodeSteuerung,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\NodeSteuerung.cs,CalculateIntersections,The length of the statement  "					foundIntersections.Add(new Pair<double>(aTimeStart + ((aTimeEnd - aTimeStart) / 2)' bTimeStart + ((bTimeEnd - bTimeStart) / 2))); " is 129.
Long Statement,CityTrafficSimulator,NodeSteuerung,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\NodeSteuerung.cs,FindLineChangePoints,The length of the statement  "				Vector2 leftVector = nc.lineSegment.DerivateAtTime(nc.lineSegment.PosToTime(currentArcPosition - delta)).RotatedClockwise.Normalized; " is 133.
Long Statement,CityTrafficSimulator,NodeSteuerung,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\NodeSteuerung.cs,FindLineChangePoints,The length of the statement  "				Vector2 rightVector = nc.lineSegment.DerivateAtTime(nc.lineSegment.PosToTime(currentArcPosition + delta)).RotatedCounterClockwise.Normalized; " is 141.
Long Statement,CityTrafficSimulator,NodeSteuerung,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\NodeSteuerung.cs,FindLineChangePoints,The length of the statement  "				LineSegment leftLS = new LineSegment(0' startl' startl + 0.25 * maxDistanceToOtherNodeConnection * leftVector' startl + 0.75 * maxDistanceToOtherNodeConnection * leftVector' startl + maxDistanceToOtherNodeConnection * leftVector); " is 230.
Long Statement,CityTrafficSimulator,NodeSteuerung,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\NodeSteuerung.cs,FindLineChangePoints,The length of the statement  "				LineSegment rightLS = new LineSegment(0' startr' startr + 0.25 * maxDistanceToOtherNodeConnection * rightVector' startr + 0.75 * maxDistanceToOtherNodeConnection * rightVector' startr + maxDistanceToOtherNodeConnection * rightVector); " is 234.
Long Statement,CityTrafficSimulator,NodeSteuerung,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\NodeSteuerung.cs,FindLineChangePoints,The length of the statement  "					if (nc2.enableIncomingLineChange && (nc2.carsAllowed || nc2.busAllowed) && nc != nc2 && nc.startNode.networkLayer == nc2.startNode.networkLayer && nc.endNode.networkLayer == nc2.endNode.networkLayer) " is 199.
Long Statement,CityTrafficSimulator,NodeSteuerung,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\NodeSteuerung.cs,FindLineChangePoints,The length of the statement  "						List<Pair<double>> intersectionTimes = CalculateIntersections(leftLS' nc2.lineSegment' 0d' 1d' 0d' 1d' 8' leftLS' nc2.lineSegment); " is 131.
Long Statement,CityTrafficSimulator,NodeSteuerung,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\NodeSteuerung.cs,FindLineChangePoints,The length of the statement  "								if (Vector2.AngleBetween(nc.lineSegment.DerivateAtTime(nc.lineSegment.PosToTime(currentArcPosition - delta))' nc2.lineSegment.DerivateAtTime(p.Right)) < Constants.maximumAngleBetweenConnectionsForLineChangePoint) " is 212.
Long Statement,CityTrafficSimulator,NodeSteuerung,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\NodeSteuerung.cs,FindLineChangePoints,The length of the statement  "								if (Vector2.AngleBetween(nc.lineSegment.DerivateAtTime(nc.lineSegment.PosToTime(currentArcPosition + delta))' nc2.lineSegment.DerivateAtTime(p.Right)) < Constants.maximumAngleBetweenConnectionsForLineChangePoint) " is 212.
Long Statement,CityTrafficSimulator,NodeSteuerung,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\NodeSteuerung.cs,CalculateIntersections,The length of the statement  "					if (   (nc.startNode.networkLayer == nc.endNode.networkLayer && (nc2.startNode.networkLayer == nc.startNode.networkLayer || nc2.endNode.networkLayer == nc.endNode.networkLayer)) " is 177.
Long Statement,CityTrafficSimulator,NodeSteuerung,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\NodeSteuerung.cs,CalculateIntersections,The length of the statement  "						List<Pair<double>> intersectionTimes = CalculateIntersections(nc.lineSegment' nc2.lineSegment' 0d' 1d' 0d' 1d' tolerance' nc.lineSegment' nc2.lineSegment); " is 155.
Long Statement,CityTrafficSimulator,NodeSteuerung,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\NodeSteuerung.cs,UpdateNodeConnection,The length of the statement  "			ncToUpdate.lineSegment = new LineSegment(0' ncToUpdate.startNode.position' ncToUpdate.startNode.outSlopeAbs' ncToUpdate.endNode.inSlopeAbs' ncToUpdate.endNode.position); " is 169.
Long Statement,CityTrafficSimulator,NodeSteuerung,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\NodeSteuerung.cs,SplitNodeConnection,The length of the statement  "			Connect(startNode' middleNode' nc.priority' nc.targetVelocity' nc.carsAllowed' nc.busAllowed' nc.tramAllowed' nc.enableIncomingLineChange' nc.enableOutgoingLineChange); " is 168.
Long Statement,CityTrafficSimulator,NodeSteuerung,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\NodeSteuerung.cs,SplitNodeConnection,The length of the statement  "			Connect(middleNode' endNode' nc.priority' nc.targetVelocity' nc.carsAllowed' nc.busAllowed' nc.tramAllowed' nc.enableIncomingLineChange' nc.enableOutgoingLineChange); " is 166.
Long Statement,CityTrafficSimulator,NodeSteuerung,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\NodeSteuerung.cs,RenderNetwork,The length of the statement  "					if ((nc.startNode.isVisible || nc.endNode.isVisible) && (!options.performClipping || nc.lineSegment.boundingRectangle.IntersectsWith(options.clippingRect))) " is 156.
Long Statement,CityTrafficSimulator,NodeSteuerung,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\NodeSteuerung.cs,RenderNetwork,The length of the statement  "					if ((nc.startNode.isVisible || nc.endNode.isVisible) && (!options.performClipping || nc.lineSegment.boundingRectangle.IntersectsWith(options.clippingRect))) " is 156.
Long Statement,CityTrafficSimulator,NodeSteuerung,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\NodeSteuerung.cs,RenderNetwork,The length of the statement  "								if (i._aConnection.startNode.isVisible || i._aConnection.endNode.isVisible || i._bConnection.startNode.isVisible || i._bConnection.endNode.isVisible) " is 149.
Long Statement,CityTrafficSimulator,NodeSteuerung,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\NodeSteuerung.cs,RenderNetwork,The length of the statement  "									else if (i._aConnection.startNode != i._bConnection.startNode || (i._frontWaitingDistance < i.aArcPosition && i._frontWaitingDistance < i.bArcPosition)) " is 152.
Long Statement,CityTrafficSimulator,NodeSteuerung,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\NodeSteuerung.cs,AddNetworkLayer,The length of the statement  "			InvokeNetworkLayersChanged(new NetworkLayersChangedEventArgs(NetworkLayersChangedEventArgs.InvalidationLevel.COLLECTION_CHANGED)); " is 130.
Long Statement,CityTrafficSimulator,NodeSteuerung,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\NodeSteuerung.cs,RemoveNetworkLayer,The length of the statement  "			InvokeNetworkLayersChanged(new NetworkLayersChangedEventArgs(NetworkLayersChangedEventArgs.InvalidationLevel.COLLECTION_CHANGED)); " is 130.
Long Statement,CityTrafficSimulator,NodeSteuerung,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\NodeSteuerung.cs,nl_VisibleChanged,The length of the statement  "			InvokeNetworkLayersChanged(new NetworkLayersChangedEventArgs(NetworkLayersChangedEventArgs.InvalidationLevel.ONLY_VISIBILITY_CHANGED)); " is 135.
Long Statement,CityTrafficSimulator,NodeSteuerung,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\NodeSteuerung.cs,nl_TitleChanged,The length of the statement  "			InvokeNetworkLayersChanged(new NetworkLayersChangedEventArgs(NetworkLayersChangedEventArgs.InvalidationLevel.ONLY_TITLES_CHANGED)); " is 131.
Long Statement,CityTrafficSimulator,NodeSteuerung,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\NodeSteuerung.cs,LoadFromFile,The length of the statement  "			InvokeNetworkLayersChanged(new NetworkLayersChangedEventArgs(NetworkLayersChangedEventArgs.InvalidationLevel.COLLECTION_CHANGED)); " is 130.
Long Statement,CityTrafficSimulator,NodeSteuerung,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\NodeSteuerung.cs,LoadFromFile,The length of the statement  "				nc.lineSegment = new LineSegment(0' nc.startNode.position' nc.startNode.outSlopeAbs' nc.endNode.inSlopeAbs' nc.endNode.position); " is 129.
Long Statement,CityTrafficSimulator,NodeSteuerung,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\NodeSteuerung.cs,LoadFromFile,The length of the statement  "					// in alten Dateien wurde das Feld häufigkeit statt trafficDensity gespeichert. Da es dieses Feld heute nicht mehr gibt' müssen wir konvertieren: " is 145.
Long Statement,CityTrafficSimulator,NodeSteuerung,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\NodeSteuerung.cs,LoadFromFile,The length of the statement  "						// eigentlich wollte ich hier direkt mit aXmlNode arbeiten' das hat jedoch komische Fehler verursacht (SelectSingleNode) wählt immer den gleichen aus) " is 150.
Long Statement,CityTrafficSimulator,TimelineControl,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TimelineControl.cs,GetTimelineEntryAtControlPosition,The length of the statement  "					&& (position.Y % totalRowHeight <= rowHeight) && (position.Y > 0))	// testen' ob in die Zwischenräume der Entries geklickt wurde " is 128.
Long Statement,CityTrafficSimulator,TimelineControl,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TimelineControl.cs,GetGroupAtClientPosition,The length of the statement  "					&& (headerOnly && clientPosition.Y <= y + rowHeight) || (!headerOnly && clientPosition.Y <= y + ((1 + tg.entries.Count) * totalRowHeight) - rowSpacing)) " is 152.
Long Statement,CityTrafficSimulator,TimelineControl,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TimelineControl.cs,UpdateControlSize,The length of the statement  "				this.ClientSize = new Size((int)Math.Round(m_zoom * steuerung.maxTime) + 5 + totalRowHeight' Math.Max(currentVisibleRowCount * totalRowHeight + 20' 50)); " is 153.
Long Statement,CityTrafficSimulator,TimelineControl,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TimelineControl.cs,TimelineControl_Paint,The length of the statement  "						e.Graphics.DrawLine(blackPen' 2' 1 + (row * totalRowHeight) + rowHeight / 2' rowHeight - 2' 1 + (row * totalRowHeight) + rowHeight / 2); " is 136.
Long Statement,CityTrafficSimulator,TimelineControl,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TimelineControl.cs,TimelineControl_Paint,The length of the statement  "						e.Graphics.DrawLine(blackPen' rowHeight / 2' 1 + (row * totalRowHeight) + 2' rowHeight / 2' 1 + (row * totalRowHeight) + rowHeight - 2); " is 136.
Long Statement,CityTrafficSimulator,TimelineControl,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TimelineControl.cs,TimelineControl_Paint,The length of the statement  "							e.Graphics.FillRectangle(backgroundBrush' 0' 1 + (row * totalRowHeight)' ClientSize.Width' (1 + tg.entries.Count) * totalRowHeight); " is 132.
Long Statement,CityTrafficSimulator,TimelineControl,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TimelineControl.cs,TimelineControl_Paint,The length of the statement  "						e.Graphics.DrawLine(blackPen' 2' 1 + (row * totalRowHeight) + rowHeight / 2' rowHeight - 2' 1 + (row * totalRowHeight) + rowHeight / 2); " is 136.
Long Statement,CityTrafficSimulator,TimelineControl,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TimelineControl.cs,TimelineControl_Paint,The length of the statement  "							e.Graphics.DrawLine(blackPen' rowHeight / 2' row * totalRowHeight + totalRowHeight' rowHeight / 2' (row + tg.entries.Count) * totalRowHeight + totalRowHeight / 2); " is 163.
Long Statement,CityTrafficSimulator,TimelineControl,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TimelineControl.cs,TimelineControl_Paint,The length of the statement  "							e.Graphics.DrawLine(blackPen' totalRowHeight / 2' row * totalRowHeight + totalRowHeight / 2' totalRowHeight / 2 + totalRowHeight / 4' row * totalRowHeight + totalRowHeight / 2); " is 177.
Long Statement,CityTrafficSimulator,TimelineControl,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TimelineControl.cs,TimelineControl_Paint,The length of the statement  "							e.Graphics.FillRectangle(new SolidBrush(te.color)' totalRowHeight + 1' 2 + (row * totalRowHeight)' maxWidth - 1' rowHeight - 1); " is 128.
Long Statement,CityTrafficSimulator,TimelineControl,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TimelineControl.cs,TimelineControl_Paint,The length of the statement  "								e.Graphics.DrawLine(blackPen' startPosition' 2 + (row * totalRowHeight)' startPosition' totalRowHeight - 2 + (row * totalRowHeight)); " is 133.
Long Statement,CityTrafficSimulator,TimelineControl,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TimelineControl.cs,TimelineControl_Paint,The length of the statement  "								e.Graphics.DrawLine(blackPen' startPosition + length' 2 + (row * totalRowHeight)' startPosition + length' totalRowHeight - 2 + (row * totalRowHeight)); " is 151.
Long Statement,CityTrafficSimulator,TimelineControl,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TimelineControl.cs,TimelineControl_Paint,The length of the statement  "					e.Graphics.DrawLine(blackPen' totalRowHeight + i * 10 * zoom' this.Height - 1' totalRowHeight + i * 10 * zoom' this.Height - 7); " is 128.
Long Statement,CityTrafficSimulator,TimelineControl,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TimelineControl.cs,TimelineControl_Paint,The length of the statement  "					e.Graphics.DrawString((i * 10).ToString()' calibriFont' blackBrush' new PointF(totalRowHeight + (i * 10 * zoom) - 8' this.Height - 18)); " is 136.
Long Statement,CityTrafficSimulator,TimelineControl,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TimelineControl.cs,TimelineControl_Paint,The length of the statement  "				e.Graphics.DrawLine(dottedPen' totalRowHeight + (int)Math.Round(timelineBarTime * zoom)' 0' totalRowHeight + (int)Math.Round(timelineBarTime * zoom)' Height); " is 158.
Long Statement,CityTrafficSimulator,TimelineControl,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TimelineControl.cs,TimelineControl_MouseDown,The length of the statement  "								TimelineEvent eventToAdd = new TimelineEvent(time' Math.Min(1' (m_selectedEntry.GetTimeOfNextEvent(time) - time) / 2)' Color.Green' tl.SwitchToGreen' tl.SwitchToRed); " is 166.
Long Statement,CityTrafficSimulator,RechenkaestchenControl,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\RechenkaestchenControl.cs,DockToGrid,The length of the statement  "                Vector2 toreturn = new Vector2((float)Math.Floor(clientPosition.X / this.CellWidth) * this.CellWidth' (float)Math.Floor(clientPosition.Y / this.CellHeight) * this.CellHeight); " is 175.
Long Statement,CityTrafficSimulator,PriorityQueue<TValue;TPriority>,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Tools\PriorityQueue.cs,CopyTo,The length of the statement  "                throw new ArgumentException("The number of elements in the source ICollection is greater than the available space from arrayIndex to the end of the destination array."); " is 169.
Long Statement,CityTrafficSimulator,TrafficLight,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\TrafficLight.cs,RecoverFromLoad,The length of the statement  "			// Alte Versionen konnten nur einen Node pro TrafficLight haben und waren daher anders referenziert' auch darum wollen wir uns kümmern: " is 135.
Long Statement,CityTrafficSimulator.Timeline,TimelineGroup,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TimelineGroup.cs,UpdateConflictPoints,The length of the statement  "						_conflictPoints[i].Add(new Pair<SpecificIntersection' double>(new SpecificIntersection(p.Left' inter)' p.Right + inter.GetMyArcPosition(p.Left))); " is 146.
Long Statement,CityTrafficSimulator.Timeline,TrafficLightForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TrafficLightForm.cs,timelineControl_MouseMove,The length of the statement  "				statusLabel.Text = "Zeitleiste Mausposition: " + timelineControl.GetTimeAtControlPosition(e.Location' false).ToString() + "s"; " is 126.
Long Statement,CityTrafficSimulator.Timeline,TrafficLightForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TrafficLightForm.cs,timelineControl_EventChanged,The length of the statement  "					statusLabel.Text = "verschiebe Event' Start: " + e.handeledEvent.eventTime + "s' Ende: " + (e.handeledEvent.eventTime + e.handeledEvent.eventLength) + "s"; " is 155.
Long Statement,CityTrafficSimulator.Timeline,TrafficLightForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TrafficLightForm.cs,InitializeComponent,The length of the statement  "			this.timelineControl.EventChanged += new CityTrafficSimulator.TimelineControl.EventChangedEventHandler(this.timelineControl_EventChanged); " is 138.
Long Statement,CityTrafficSimulator.Timeline,TimelineEntry,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TimelineEntry.cs,MoveEvent,The length of the statement  "				double max = (lln.Next != null) ? lln.Next.Value.eventTime - eventToMove.eventLength : this.maxTime - eventToMove.eventLength; " is 126.
Long Statement,CityTrafficSimulator.Tools,AlgorithmicGeometry,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Tools\AlgorithmicGeometry.cs,roundedConvexHullPath,The length of the statement  "				toReturn.AddEllipse((float)(convexHull.First.Value.X - radius)' (float)(convexHull.First.Value.Y - radius)' (float)(2 * radius)' (float)(2 * radius)); " is 150.
Long Statement,CityTrafficSimulator.Tools,AlgorithmicGeometry,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Tools\AlgorithmicGeometry.cs,roundedConvexHullPath,The length of the statement  "				toReturn.AddArc((float)(curNode.Next.Value.X - radius)' (float)(curNode.Next.Value.Y - radius)' (float)(2 * radius)' (float)(2 * radius)' start' sweep); " is 152.
Long Statement,CityTrafficSimulator.Tools,ColorMapControl,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Tools\Colormap.cs,ColorMapControl_Paint,The length of the statement  "						using (LinearGradientBrush gradBrush = new LinearGradientBrush(new PointF(0' 0)' new PointF(stepsize' 0)' cm[i]' cm[i + 1])) " is 124.
Long Statement,CityTrafficSimulator.Tools,ColorMapControl,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Tools\Colormap.cs,WorldToIndex,The length of the statement  "			return Math2.Clamp((int)Math.Round(((float)(_colormap.Count - 1) * (float)worldX / (float)ClientSize.Width))' 0' _colormap.Count - 1); " is 134.
Long Statement,CityTrafficSimulator.Vehicle,IVehicle,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\IVehicle.cs,RemoveFromCurrentNodeConnection,The length of the statement  "				OnVehicleLeftNodeConnection(new VehicleLeftNodeConnectionEventArgs(new Interval<double>(statistics.arcPositionOfStartOnNodeConnection' currentPosition)' new Interval<double>(statistics.startTimeOnNodeConnection' GlobalTime.Instance.currentTime))); " is 247.
Long Statement,CityTrafficSimulator.Vehicle,IVehicle,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\IVehicle.cs,InitiateLineChange,The length of the statement  "				ratioProjectionOnTargetConnectionvsLCPLength = (lcp.target.arcPosition - lcp.otherStart.arcPosition) / lcp.lineSegment.length; " is 126.
Long Statement,CityTrafficSimulator.Vehicle,IVehicle,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\IVehicle.cs,InitiateLineChange,The length of the statement  "				ratioProjectionOnTargetConnectionvsLCPLength = (lcp.target.arcPosition + lcp.otherStart.nc.lineSegment.length - lcp.otherStart.arcPosition) / lcp.lineSegment.length; " is 165.
Long Statement,CityTrafficSimulator.Vehicle,IVehicle,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\IVehicle.cs,InitiateLineChange,The length of the statement  "			RemoveFromCurrentNodeConnection(true' lcp.otherStart.nc' lcp.otherStart.arcPosition + arcPositionOffset * ratioProjectionOnTargetConnectionvsLCPLength); " is 152.
Long Statement,CityTrafficSimulator.Vehicle,IVehicle,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\IVehicle.cs,Think,The length of the statement  "				double percentOfLCILeft = (lci == null) ? 0.2 : Math.Max(0.2' (lci.endArcPos - currentPosition - Constants.breakPointBeforeForcedLineChange) / (lci.length - Constants.breakPointBeforeForcedLineChange)); " is 202.
Long Statement,CityTrafficSimulator.Vehicle,IVehicle,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\IVehicle.cs,Think,The length of the statement  "				lowestAcceleration = CalculateAcceleration(physics.velocity' effectiveDesiredVelocity' lookaheadDistance' physics.velocity); " is 124.
Long Statement,CityTrafficSimulator.Vehicle,IVehicle,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\IVehicle.cs,Think,The length of the statement  "				lowestAcceleration = CalculateAcceleration(physics.velocity' effectiveDesiredVelocity' theVehicleInFrontOfMe.distance' physics.velocity - theVehicleInFrontOfMe.vehicle.physics.velocity); " is 186.
Long Statement,CityTrafficSimulator.Vehicle,IVehicle,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\IVehicle.cs,Think,The length of the statement  "				lowestAcceleration = CalculateAcceleration(physics.velocity' effectiveDesiredVelocity' lookaheadDistance' physics.velocity); " is 124.
Long Statement,CityTrafficSimulator.Vehicle,IVehicle,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\IVehicle.cs,Think,The length of the statement  "					lowestAcceleration = CalculateAcceleration(physics.velocity' effectiveDesiredVelocity' nextStopSign.Right' physics.velocity); " is 125.
Long Statement,CityTrafficSimulator.Vehicle,IVehicle,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\IVehicle.cs,Think,The length of the statement  "				lowestAcceleration = CalculateAcceleration(physics.velocity' effectiveDesiredVelocity' lookaheadDistance' physics.velocity); " is 124.
Long Statement,CityTrafficSimulator.Vehicle,IVehicle,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\IVehicle.cs,Think,The length of the statement  "			// (When doing simple calculations' we do not want to unregister at all intersections. Hence' we use a temporary regsitration): " is 127.
Long Statement,CityTrafficSimulator.Vehicle,IVehicle,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\IVehicle.cs,Think,The length of the statement  "			LinkedList<SpecificIntersection> registrationTarget = (onlySimpleCalculations ? temporaryRegisteredIntersections : registeredIntersections); " is 140.
Long Statement,CityTrafficSimulator.Vehicle,IVehicle,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\IVehicle.cs,Think,The length of the statement  "				double newAcceleration = CalculateAcceleration(physics.velocity' effectiveDesiredVelocity' distanceToIntersection' physics.velocity); " is 133.
Long Statement,CityTrafficSimulator.Vehicle,IVehicle,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\IVehicle.cs,Think,The length of the statement  "						if ((myArcPositionOnOtherConnection >= 0) && (Math.Abs(arcPos - lcp.start.arcPosition) < Constants.maxDistanceToLineChangePoint * 1.25)) " is 136.
Long Statement,CityTrafficSimulator.Vehicle,IVehicle,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\IVehicle.cs,Think,The length of the statement  "							Pair<VehicleDistance> otherVehicles = lcp.otherStart.nc.GetVehiclesAroundArcPosition(myArcPositionOnOtherConnection' Constants.lookaheadDistance); " is 146.
Long Statement,CityTrafficSimulator.Vehicle,IVehicle,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\IVehicle.cs,Think,The length of the statement  "								|| otherVehicles.Right.distance > otherVehicles.Right.vehicle.length + CalculateWantedDistance(physics.velocity' physics.velocity - otherVehicles.Right.vehicle.physics.velocity)/2) " is 180.
Long Statement,CityTrafficSimulator.Vehicle,IVehicle,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\IVehicle.cs,Think,The length of the statement  "									|| otherVehicles.Left.distance > length + otherVehicles.Left.vehicle.CalculateWantedDistance(otherVehicles.Left.vehicle.physics.velocity' otherVehicles.Left.vehicle.physics.velocity - physics.velocity)/2) " is 204.
Long Statement,CityTrafficSimulator.Vehicle,IVehicle,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\IVehicle.cs,Think,The length of the statement  "										? CalculateAcceleration(physics.velocity' effectiveDesiredVelocity' otherVehicles.Right.vehicle.currentPosition - myArcPositionOnOtherConnection' physics.velocity - otherVehicles.Right.vehicle.physics.velocity) " is 210.
Long Statement,CityTrafficSimulator.Vehicle,IVehicle,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\IVehicle.cs,Think,The length of the statement  "										? CalculateAcceleration(otherVehicles.Left.vehicle.physics.velocity' otherVehicles.Left.vehicle.effectiveDesiredVelocity' otherVehicles.Left.distance' otherVehicles.Left.vehicle.physics.velocity - physics.velocity) " is 214.
Long Statement,CityTrafficSimulator.Vehicle,IVehicle,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\IVehicle.cs,Think,The length of the statement  "									double currentAccelerationOfVehicleBehindMeOnOtherConnection = (otherVehicles.Left != null) ? otherVehicles.Left.vehicle.physics.acceleration : 0; " is 146.
Long Statement,CityTrafficSimulator.Vehicle,IVehicle,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\IVehicle.cs,Think,The length of the statement  "									//  - My line change must be sufficiently necessary. The closer I come to the end of the LineChangeInterval' the more I may thwart the vehicle behind.  " is 150.
Long Statement,CityTrafficSimulator.Vehicle,IVehicle,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\IVehicle.cs,Think,The length of the statement  "										&& ((arcPos - lci.startArcPos) / lci.length >= (currentAccelerationOfVehicleBehindMeOnOtherConnection - forcedAccelerationOfVehicleBehindMeOnOtherConnection))) " is 159.
Long Statement,CityTrafficSimulator.Vehicle,IVehicle,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\IVehicle.cs,Think,The length of the statement  "									// I do not want to change line yet' but I could position myself better between the two other vehicles on the parallel line. " is 124.
Long Statement,CityTrafficSimulator.Vehicle,IVehicle,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\IVehicle.cs,Think,The length of the statement  "								else if (   otherVehicles.Left.vehicle.physics.velocity / this.physics.velocity < 1.2  // I am not significantly slower than him " is 128.
Long Statement,CityTrafficSimulator.Vehicle,IVehicle,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\IVehicle.cs,Think,The length of the statement  "										 && (otherVehicles.Right == null || otherVehicles.Right.distance > 1.5 * length) // the new vehicle in front is far enough away " is 126.
Long Statement,CityTrafficSimulator.Vehicle,IVehicle,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\IVehicle.cs,Think,The length of the statement  "									lowestAcceleration = Math.Min(lowestAcceleration' CalculateAcceleration(physics.velocity' effectiveDesiredVelocity' lookaheadDistance' physics.velocity)); " is 154.
Long Statement,CityTrafficSimulator.Vehicle,IVehicle,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\IVehicle.cs,Think,The length of the statement  "									_state.SetLineChangeVehicleInteraction(this' otherVehicles.Left.vehicle' lcp.otherStart.nc' myArcPositionOnOtherConnection - _length); " is 134.
Long Statement,CityTrafficSimulator.Vehicle,IVehicle,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\IVehicle.cs,Think,The length of the statement  "							double percentOfLCILeft = Math.Max(0.2' (lci.endArcPos - currentPosition - Constants.breakPointBeforeForcedLineChange) / (lci.length - Constants.breakPointBeforeForcedLineChange)); " is 180.
Long Statement,CityTrafficSimulator.Vehicle,IVehicle,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\IVehicle.cs,Think,The length of the statement  "									VehicleDistance otherBehind = lcp.otherStart.nc.GetVehicleBeforeArcPosition(myArcPositionOnOtherConnection - ((_length + s0))' Constants.lookaheadDistance); " is 156.
Long Statement,CityTrafficSimulator.Vehicle,IVehicle,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\IVehicle.cs,Think,The length of the statement  "									// In rare cases deadlocks may appear when a very long and a short vehicle are driving parallel to each other (and both want to change line): " is 141.
Long Statement,CityTrafficSimulator.Vehicle,IVehicle,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\IVehicle.cs,Think,The length of the statement  "									// Then' none of the two finds a vehicle behind on the parallel connection. Hence' none of the two will wait for the other one " is 126.
Long Statement,CityTrafficSimulator.Vehicle,IVehicle,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\IVehicle.cs,Think,The length of the statement  "									// To avoid this case' if there is no otherBehind' we also look for a parallel vehicle in front of our back (there should be one' otherwise " is 139.
Long Statement,CityTrafficSimulator.Vehicle,IVehicle,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\IVehicle.cs,Think,The length of the statement  "									// something went terribly wrong above). The longer one of the two will wait for the shorter one to make sure' no deadlock will occur. " is 134.
Long Statement,CityTrafficSimulator.Vehicle,IVehicle,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\IVehicle.cs,Think,The length of the statement  "										VehicleDistance otherFront = lcp.otherStart.nc.GetVehicleBehindArcPosition(myArcPositionOnOtherConnection - ((_length + s0))' Constants.lookaheadDistance); " is 155.
Long Statement,CityTrafficSimulator.Vehicle,IVehicle,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\IVehicle.cs,Think,The length of the statement  "									//Pair<VehicleDistance> vd = lcp.otherStart.nc.GetVehiclesAroundArcPosition(myArcPositionOnOtherConnection - ( (_length + s0))' Constants.lookaheadDistance); " is 157.
Long Statement,CityTrafficSimulator.Vehicle,IVehicle,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\IVehicle.cs,Think,The length of the statement  "										_state.SetLineChangeVehicleInteraction(this' otherBehind.vehicle' lcp.otherStart.nc' myArcPositionOnOtherConnection - _length); " is 127.
Long Statement,CityTrafficSimulator.Vehicle,IVehicle,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\IVehicle.cs,Think,The length of the statement  "										// In addition' I need to get behind the vehicle in front of the vehicle which waits for me. Therefore I adapt the desired velocity " is 131.
Long Statement,CityTrafficSimulator.Vehicle,IVehicle,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\IVehicle.cs,Think,The length of the statement  "											VehicleDistance otherBehindForman = _state.vehicleThatLetsMeChangeLine.currentNodeConnection.GetVehicleBehindArcPosition(_state.vehicleThatLetsMeChangeLine.currentPosition' 2 * (length + s0)); " is 192.
Long Statement,CityTrafficSimulator.Vehicle,IVehicle,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\IVehicle.cs,Think,The length of the statement  "												//_physics.multiplierTargetVelocity = Math2.Clamp(Math2.Cubic((otherBehindForman.distance - otherBehind.distance - s0) / (_length + 4 * s0))' 0.3' 1); " is 150.
Long Statement,CityTrafficSimulator.Vehicle,IVehicle,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\IVehicle.cs,Think,The length of the statement  "												double multPerDistance = 1 - Math2.Clamp((otherBehind.distance + _length + s0 - otherBehindForman.distance + otherBehindForman.vehicle._length + s0) / (otherBehindForman.vehicle._length)' 0.2' 0.75); " is 199.
Long Statement,CityTrafficSimulator.Vehicle,IVehicle,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\IVehicle.cs,Think,The length of the statement  "												double multPerSpeedDiff = Math2.Clamp((otherBehindForman.vehicle._physics.velocity - _physics.velocity) / 2' 0.25' 0.8); " is 120.
Long Statement,CityTrafficSimulator.Vehicle,IVehicle,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\IVehicle.cs,Think,The length of the statement  "								lowestAcceleration = Math.Min(lowestAcceleration' CalculateAcceleration(physics.velocity' effectiveDesiredVelocity' lci.endArcPos - Constants.breakPointBeforeForcedLineChange - arcPos' physics.velocity)); " is 204.
Long Statement,CityTrafficSimulator.Vehicle,IVehicle,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\IVehicle.cs,Think,The length of the statement  "				thinkAboutLineChange &= ((GlobalTime.Instance.currentTime - lastLineChangeCheck.Left > 1) || (currentPosition - lastLineChangeCheck.Right > 50)); " is 145.
Long Statement,CityTrafficSimulator.Vehicle,IVehicle,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\IVehicle.cs,Think,The length of the statement  "					if ((lcp.target.nc != null) && (Math.Abs(arcPos - lcp.start.arcPosition) < Constants.maxDistanceToLineChangePoint * 0.67)) " is 122.
Long Statement,CityTrafficSimulator.Vehicle,IVehicle,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\IVehicle.cs,Think,The length of the statement  "						if (alternativeRoute.SegmentCount() > 0 && alternativeRoute.costs / wayToGo.costs < Constants.maxRatioForVoluntaryLineChange && !alternativeRoute.Top().lineChangeNeeded) " is 169.
Long Statement,CityTrafficSimulator.Vehicle,IVehicle,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\IVehicle.cs,Think,The length of the statement  "								Pair<VehicleDistance> otherVehicles = lcp.otherStart.nc.GetVehiclesAroundArcPosition(myArcPositionOnOtherConnection' Constants.lookaheadDistance); " is 146.
Long Statement,CityTrafficSimulator.Vehicle,IVehicle,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\IVehicle.cs,Think,The length of the statement  "										|| otherVehicles.Left.distance > length + otherVehicles.Left.vehicle.CalculateWantedDistance(otherVehicles.Left.vehicle.physics.velocity' otherVehicles.Left.vehicle.physics.velocity - physics.velocity)/2) " is 204.
Long Statement,CityTrafficSimulator.Vehicle,IVehicle,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\IVehicle.cs,Think,The length of the statement  "											? CalculateAcceleration(physics.velocity' effectiveDesiredVelocity' otherVehicles.Right.vehicle.currentPosition - myArcPositionOnOtherConnection' physics.velocity - otherVehicles.Right.vehicle.physics.velocity) " is 210.
Long Statement,CityTrafficSimulator.Vehicle,IVehicle,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\IVehicle.cs,Think,The length of the statement  "											: CalculateAcceleration(physics.velocity' effectiveDesiredVelocity' GetDistanceToNextTrafficLightOnRoute(l' myArcPositionOnOtherConnection' Constants.lookaheadDistance' true)' physics.velocity); " is 194.
Long Statement,CityTrafficSimulator.Vehicle,IVehicle,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\IVehicle.cs,Think,The length of the statement  "											? CalculateAcceleration(otherVehicles.Left.vehicle.physics.velocity' otherVehicles.Left.vehicle.effectiveDesiredVelocity' otherVehicles.Left.distance' otherVehicles.Left.vehicle.physics.velocity - physics.velocity) " is 214.
Long Statement,CityTrafficSimulator.Vehicle,IVehicle,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\IVehicle.cs,Think,The length of the statement  "										double currentAccelerationOfVehicleBehindMeOnOtherConnection = (otherVehicles.Left != null) ? otherVehicles.Left.vehicle.physics.acceleration : 0; " is 146.
Long Statement,CityTrafficSimulator.Vehicle,IVehicle,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\IVehicle.cs,Think,The length of the statement  "											if (myAccelerationOnOtherConnection - lowestAcceleration > p * (currentAccelerationOfVehicleBehindMeOnOtherConnection - forcedAccelerationOfVehicleBehindMeOnOtherConnection) + lineChangeThreshold) " is 196.
Long Statement,CityTrafficSimulator.Vehicle,IVehicle,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\IVehicle.cs,Move,The length of the statement  "					_state.position += arcLengthToMove * ratioProjectionOnTargetConnectionvsLCPLength; // ich muss meine Position auf der Ziel-NodeConnection entsprechend anpassen " is 159.
Long Statement,CityTrafficSimulator.Vehicle,IVehicle,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\IVehicle.cs,GetNextVehicleOnMyTrack,The length of the statement  "						&& (parallelNodeConnection == nc || (arcPos < arcLengthToLookForParallelVehicles && vd.distance < arcLengthToLookForParallelVehicles))) " is 135.
Long Statement,CityTrafficSimulator.Vehicle,IVehicle,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\IVehicle.cs,GatherNextIntersectionsOnMyTrack,The length of the statement  "			LinkedListNode<SpecificIntersection> lln = intersectionRegistration.First;				// current already registered intersection " is 120.
Long Statement,CityTrafficSimulator.Vehicle,IVehicle,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\IVehicle.cs,GatherNextIntersectionsOnMyTrack,The length of the statement  "				startPosition = workingRoute[0].lineSegment.length - (length - currentPosition);	// start position at current NodeConnection " is 124.
Long Statement,CityTrafficSimulator.Vehicle,IVehicle,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\IVehicle.cs,GatherNextIntersectionsOnMyTrack,The length of the statement  "				List<SpecificIntersection> l = nc.GetSortedIntersectionsWithinArcLength(new Interval<double>(startPosition' startPosition + remainingDistance)); " is 144.
Long Statement,CityTrafficSimulator.Vehicle,IVehicle,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\IVehicle.cs,HandleIntersections,The length of the statement  "						double distanceToLookBack = si.intersection.GetCrossingVehicleTimes(this' si.nodeConnection).remainingDistance - _length - s0; " is 126.
Long Statement,CityTrafficSimulator.Vehicle,IVehicle,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\IVehicle.cs,HandleIntersections,The length of the statement  "							double remainingDistanceToPrevIntersection = lln.Previous.Value.intersection.GetCrossingVehicleTimes(this' lln.Previous.Value.nodeConnection).remainingDistance; " is 160.
Long Statement,CityTrafficSimulator.Vehicle,IVehicle,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\IVehicle.cs,HandleIntersections,The length of the statement  "							if (remainingDistanceToPrevIntersection > 0 && remainingDistanceToPrevIntersection + lln.Previous.Value.intersection._rearWaitingDistance > distanceToLookBack) " is 159.
Long Statement,CityTrafficSimulator.Vehicle,IVehicle,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\IVehicle.cs,HandleIntersections,The length of the statement  "					return si.intersection.GetCrossingVehicleTimes(this' si.nodeConnection).remainingDistance - si.intersection._frontWaitingDistance; // si is a Value-Type (copy) " is 159.
Long Statement,CityTrafficSimulator.Vehicle,IVehicle,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\IVehicle.cs,BuildGraphicsPath,The length of the statement  "				Vector2 derivate = currentLineChangePoint.lineSegment.DerivateAtTime(currentLineChangePoint.lineSegment.PosToTime(currentPositionOnLineChangePoint)); " is 149.
Long Statement,CityTrafficSimulator.Vehicle,IVehicle,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\IVehicle.cs,DrawDebugData,The length of the statement  "				g.DrawString("arr.: " + myCvt.originalArrivingTime.ToString("####.##") + "' wait: " + myCvt.willWaitInFrontOfIntersection' debugFont' blackBrush' (state.positionAbs + si.intersection.aPosition) * 0.5); " is 201.
Long Statement,CityTrafficSimulator.Vehicle,IVehicle,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\IVehicle.cs,DrawDebugData,The length of the statement  "			g.DrawString(hashcode.ToString() + " @ " + currentPosition.ToString("####") + "dm - " + physics.velocity.ToString("##.#") + "m/s - Mult.: " + physics.multiplierTargetVelocity.ToString("#.##") + debugData.ToString()' debugFont' blackBrush' state.positionAbs + new Vector2(0' -10)); " is 280.
Long Statement,CityTrafficSimulator.Vehicle,State,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\IVehicle.cs,SetLineChangeVehicleInteraction,The length of the statement  "					// Therefore' we here check die vehicles on the two NodeConnections of the LineChangePoint. This simplifies the algorithm and should be enough here. " is 148.
Long Statement,CityTrafficSimulator.Vehicle,State,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\IVehicle.cs,SetLineChangeVehicleInteraction,The length of the statement  "								// We have found two LineChangeVehicleInteraction crossing each other. To solve the problem' simply let vehicle C wait for me. " is 126.
Long Statement,CityTrafficSimulator.Verkehr,TrafficVolume,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolume.cs,Tick,The length of the statement  "				int randomValue = trafficVolumeCars > 0 ? GlobalRandom.Instance.Next((int)Math.Ceiling(3600.0 / (tickLength * trafficVolumeCars))) : -1; " is 136.
Long Statement,CityTrafficSimulator.Verkehr,TrafficVolume,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolume.cs,Tick,The length of the statement  "				randomValue = trafficVolumeTrucks > 0 ? GlobalRandom.Instance.Next((int)Math.Ceiling(3600.0 / (tickLength * trafficVolumeTrucks))) : -1; " is 136.
Long Statement,CityTrafficSimulator.Verkehr,TrafficVolume,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolume.cs,Tick,The length of the statement  "				randomValue = trafficVolumeBusses > 0 ? GlobalRandom.Instance.Next((int)Math.Ceiling(3600.0 / (tickLength * trafficVolumeBusses))) : -1; " is 136.
Long Statement,CityTrafficSimulator.Verkehr,TrafficVolume,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolume.cs,Tick,The length of the statement  "				randomValue = trafficVolumeTrams > 0 ? GlobalRandom.Instance.Next((int)Math.Ceiling(3600.0 / (tickLength * trafficVolumeTrams))) : -1; " is 134.
Long Statement,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,UpdateListboxLayout,The length of the statement  "			btnSetStartTitle.Location = new System.Drawing.Point(lbStartNodes.Size.Width + lbStartNodes.Location.X - btnSetStartTitle.Width' row1Y); " is 136.
Long Statement,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,UpdateListboxLayout,The length of the statement  "			editStartNodeTitle.Location = new System.Drawing.Point(btnSetStartTitle.Location.X - spacer - editStartNodeTitle.Width' row1Y); " is 127.
Long Statement,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,UpdateListboxLayout,The length of the statement  "			btnSetDestinationTitle.Location = new System.Drawing.Point(lbDestinationNodes.Size.Width + lbDestinationNodes.Location.X - btnSetDestinationTitle.Width' row1Y); " is 160.
Long Statement,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,UpdateListboxLayout,The length of the statement  "			editDestinationNodeTitle.Location = new System.Drawing.Point(btnSetDestinationTitle.Location.X - spacer - editDestinationNodeTitle.Width' row1Y); " is 145.
Long Statement,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,UpdateListboxLayout,The length of the statement  "			lblDestinationTitle.Location = new System.Drawing.Point(editDestinationNodeTitle.Location.X - spacer - lblDestinationTitle.Width' row1Y); " is 137.
Long Statement,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,UpdateListboxLayout,The length of the statement  "			btnRemoveStartNode.Location = new System.Drawing.Point(lbStartNodes.Size.Width + lbStartNodes.Location.X - btnRemoveStartNode.Width' row2Y); " is 140.
Long Statement,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,UpdateListboxLayout,The length of the statement  "			btnUpdateStartNodes.Location = new System.Drawing.Point(btnRemoveStartNode.Location.X - spacer - btnUpdateStartNodes.Width' row2Y); " is 131.
Long Statement,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,UpdateListboxLayout,The length of the statement  "			btnAddStartNode.Location = new System.Drawing.Point(btnUpdateStartNodes.Location.X - spacer - btnAddStartNode.Width' row2Y); " is 124.
Long Statement,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,UpdateListboxLayout,The length of the statement  "			btnRemoveDestinationNode.Location = new System.Drawing.Point(lbDestinationNodes.Size.Width + lbDestinationNodes.Location.X - btnRemoveDestinationNode.Width' row2Y); " is 164.
Long Statement,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,UpdateListboxLayout,The length of the statement  "			btnUpdateDestinationNodes.Location = new System.Drawing.Point(btnRemoveDestinationNode.Location.X - spacer - btnUpdateDestinationNodes.Width' row2Y); " is 149.
Long Statement,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,UpdateListboxLayout,The length of the statement  "			btnAddDestinationNode.Location = new System.Drawing.Point(btnUpdateDestinationNodes.Location.X - spacer - btnAddDestinationNode.Width' row2Y); " is 142.
Long Statement,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,GetTrafficVolume,The length of the statement  "				lblNumVehicles.Text = "Total Vehicles: " + m_currentVolume.statistics.numVehicles + " (" + m_currentVolume.statistics.numVehiclesReachedDestination + " reached Destination)"; " is 174.
Long Statement,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,GetTrafficVolume,The length of the statement  "				lblNumStops.Text = "Average Number of Stops: " + ((float)m_currentVolume.statistics.numStops / m_currentVolume.statistics.numVehicles); " is 135.
Long Statement,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,UpdateTrafficVolume,The length of the statement  "				m_currentVolume.SetTrafficVolume((int)spinCarsVolume.Value' (int)spinTruckVolume.Value' (int)spinBusVolume.Value' (int)spinTramVolume.Value); " is 141.
Long Statement,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The length of the statement  "			this.spinGlobalTrafficVolumeMultiplier.ValueChanged += new System.EventHandler(this.spinGlobalTrafficVolumeMultiplier_ValueChanged); " is 132.
Long Statement,CityTrafficSimulator.Verkehr,VerkehrSteuerung,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\VerkehrSteuerung.cs,ImportOldTrafficVolumeData,The length of the statement  "						tv.SetTrafficVolume((int)(tv.trafficVolumeCars + a.trafficDensity * 0.92)' (int)(tv.trafficVolumeTrucks + a.trafficDensity * 0.08)' tv.trafficVolumeBusses' tv.trafficVolumeTrams); " is 179.
Long Statement,CityTrafficSimulator.Verkehr,VerkehrSteuerung,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\VerkehrSteuerung.cs,ImportOldTrafficVolumeData,The length of the statement  "						tv.SetTrafficVolume(tv.trafficVolumeCars' tv.trafficVolumeTrucks' tv.trafficVolumeBusses + a.trafficDensity' tv.trafficVolumeTrams); " is 132.
Long Statement,CityTrafficSimulator.Verkehr,VerkehrSteuerung,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\VerkehrSteuerung.cs,ImportOldTrafficVolumeData,The length of the statement  "						tv.SetTrafficVolume(tv.trafficVolumeCars' tv.trafficVolumeTrucks' tv.trafficVolumeBusses' tv.trafficVolumeTrams + a.trafficDensity); " is 132.
Long Statement,CityTrafficSimulator.Verkehr,VerkehrSteuerung,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\VerkehrSteuerung.cs,LoadFromFile,The length of the statement  "			XmlNodeList xnlDestinationNodes = xd.SelectNodes("//CityTrafficSimulator/TrafficVolumes/DestinationPoints/BunchOfNodes"); " is 121.
Long Statement,CityTrafficSimulator.Verkehr,VerkehrSteuerung,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\VerkehrSteuerung.cs,LoadFromFile,The length of the statement  "					lf.Log("Error during traffic volume deserialization: Could not dereference start-/end nodes. Traffic volume was dismissed."); " is 125.
Long Statement,CityTrafficSimulator.Verkehr,VerkehrSteuerung,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\VerkehrSteuerung.cs,SpawnVehicle,The length of the statement  "					e.vehicleToSpawn.physics = new IVehicle.Physics(carTargetVelocity + ((GlobalRandom.Instance.NextDouble() - 0.5) * 4)' Math.Min(nc.targetVelocity' carTargetVelocity)' 0); " is 169.
Long Statement,CityTrafficSimulator.Verkehr,VerkehrSteuerung,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\VerkehrSteuerung.cs,SpawnVehicle,The length of the statement  "					e.vehicleToSpawn.physics = new IVehicle.Physics(truckTargetVelocity + ((GlobalRandom.Instance.NextDouble() - 0.5) * 4)' Math.Min(nc.targetVelocity' truckTargetVelocity)' 0); " is 173.
Long Statement,CityTrafficSimulator.Verkehr,VerkehrSteuerung,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\VerkehrSteuerung.cs,SpawnVehicle,The length of the statement  "					e.vehicleToSpawn.physics = new IVehicle.Physics(tramTargetVelocity + ((GlobalRandom.Instance.NextDouble() - 0.5) * 4)' Math.Min(nc.targetVelocity' tramTargetVelocity)' 0); " is 171.
Long Statement,CityTrafficSimulator.Verkehr,VerkehrSteuerung,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\VerkehrSteuerung.cs,SpawnVehicle,The length of the statement  "					e.vehicleToSpawn.physics = new IVehicle.Physics(busTargetVelocity + ((GlobalRandom.Instance.NextDouble() - 0.5) * 4)' Math.Min(nc.targetVelocity' busTargetVelocity)' 0); " is 169.
Long Statement,CityTrafficSimulator.Verkehr,VerkehrSteuerung,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\VerkehrSteuerung.cs,Tick,The length of the statement  "			List<TrafficVolume.VehicleSpawnedEventArgs> failedList = new List<TrafficVolume.VehicleSpawnedEventArgs>(_vehiclesToSpawn.Count); " is 129.
Complex Conditional,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,DaGrid_MouseUp,The conditional expression  "(howToDrag == DragNDrop.CREATE_NODE || howToDrag == DragNDrop.MOVE_NODES || howToDrag == DragNDrop.MOVE_IN_SLOPE || howToDrag == DragNDrop.MOVE_OUT_SLOPE) && m_selectedLineNodes != null"  is complex.
Complex Conditional,CityTrafficSimulator,NodeSteuerung,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\NodeSteuerung.cs,CalculateIntersections,The conditional expression  "(aBounds.Width <= tolerance) && (aBounds.Height <= tolerance)  						&& (bBounds.Width <= tolerance) && (bBounds.Height <= tolerance)"  is complex.
Complex Conditional,CityTrafficSimulator,NodeSteuerung,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\NodeSteuerung.cs,FindLineChangePoints,The conditional expression  "nc2.enableIncomingLineChange && (nc2.carsAllowed || nc2.busAllowed) && nc != nc2 && nc.startNode.networkLayer == nc2.startNode.networkLayer && nc.endNode.networkLayer == nc2.endNode.networkLayer"  is complex.
Complex Conditional,CityTrafficSimulator,NodeSteuerung,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\NodeSteuerung.cs,FindLineChangePoints,The conditional expression  "(diff <= nextNc.lineSegment.length)  												&& (nextNc.enableIncomingLineChange && (nextNc.carsAllowed || nextNc.busAllowed))  												&& (nc != nextNc)"  is complex.
Complex Conditional,CityTrafficSimulator,NodeSteuerung,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\NodeSteuerung.cs,FindLineChangePoints,The conditional expression  "(diff <= nextNc.lineSegment.length)  												&& (nextNc.enableIncomingLineChange && (nextNc.carsAllowed || nextNc.busAllowed))  												&& (nc != nextNc)"  is complex.
Complex Conditional,CityTrafficSimulator,NodeSteuerung,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\NodeSteuerung.cs,CalculateIntersections,The conditional expression  "(nc.startNode.networkLayer == nc.endNode.networkLayer && (nc2.startNode.networkLayer == nc.startNode.networkLayer || nc2.endNode.networkLayer == nc.endNode.networkLayer))  						|| (nc.startNode.networkLayer != nc.endNode.networkLayer && (   nc2.startNode.networkLayer == nc.startNode.networkLayer  																					 || nc2.startNode.networkLayer == nc.endNode.networkLayer  																					 || nc2.endNode.networkLayer == nc.startNode.networkLayer   																					 || nc2.endNode.networkLayer == nc.endNode.networkLayer))"  is complex.
Complex Conditional,CityTrafficSimulator,NodeSteuerung,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\NodeSteuerung.cs,RenderNetwork,The conditional expression  "(nc.startNode.isVisible || nc.endNode.isVisible) && (!options.performClipping || nc.lineSegment.boundingRectangle.IntersectsWith(options.clippingRect))"  is complex.
Complex Conditional,CityTrafficSimulator,NodeSteuerung,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\NodeSteuerung.cs,RenderNetwork,The conditional expression  "(nc.startNode.isVisible || nc.endNode.isVisible) && (!options.performClipping || nc.lineSegment.boundingRectangle.IntersectsWith(options.clippingRect))"  is complex.
Complex Conditional,CityTrafficSimulator,NodeSteuerung,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\NodeSteuerung.cs,RenderNetwork,The conditional expression  "i._aConnection.startNode.isVisible || i._aConnection.endNode.isVisible || i._bConnection.startNode.isVisible || i._bConnection.endNode.isVisible"  is complex.
Complex Conditional,CityTrafficSimulator,TimelineControl,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TimelineControl.cs,GetTimelineEntryAtControlPosition,The conditional expression  "(position.Y >= 0)														// testen' ob position überhaupt zulässig	  					&& (position.Y < currentVisibleRowCount * totalRowHeight)			// testen' ob nicht zu weit unten geklickt wurde  					&& (position.Y % totalRowHeight <= rowHeight) && (position.Y > 0)"  is complex.
Complex Conditional,CityTrafficSimulator,TimelineControl,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TimelineControl.cs,GetGroupAtClientPosition,The conditional expression  "(clientPosition.Y >= y)  					&& (headerOnly && clientPosition.Y <= y + rowHeight) || (!headerOnly && clientPosition.Y <= y + ((1 + tg.entries.Count) * totalRowHeight) - rowSpacing)"  is complex.
Complex Conditional,CityTrafficSimulator,Interval,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Tools\Interval.cs,IntersectsTrue,The conditional expression  "(otherInterval.left.CompareTo(left) < 0 && otherInterval.right.CompareTo(left) > 0)  					|| (otherInterval.left.CompareTo(left) > 0 && otherInterval.right.CompareTo(right) <= 0)  					|| (otherInterval.left.CompareTo(left) >= 0 && otherInterval.right.CompareTo(right) < 0)  					|| (otherInterval.left.CompareTo(right) < 0 && otherInterval.right.CompareTo(right) > 0)"  is complex.
Complex Conditional,CityTrafficSimulator.Vehicle,IVehicle,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\IVehicle.cs,Think,The conditional expression  "otherVehicles.Left.vehicle.physics.velocity / this.physics.velocity < 1.2  // I am not significantly slower than him  										 && (otherVehicles.Right == null || otherVehicles.Right.distance > 1.5 * length) // the new vehicle in front is far enough away  										 && lookaheadDistance > 2 * length			// no vehicle/traffic light/intersection in front  										 && lci.endArcPos - arcPos > 2 * length		// enough space left in LineChangeInterval  										 && lowestAcceleration >= -0.1"  is complex.
Complex Conditional,CityTrafficSimulator.Vehicle,IVehicle,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\IVehicle.cs,GetNextVehicleOnMyTrack,The conditional expression  "(toReturn == null || vd.distance < toReturn.distance)   						&& (parallelNodeConnection == nc || (arcPos < arcLengthToLookForParallelVehicles && vd.distance < arcLengthToLookForParallelVehicles))"  is complex.
Empty Catch Block,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,SetupDockingStuff,The method has an empty catch block.
Magic Number,CityTrafficSimulator,AboutBox,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\AboutBox\AboutBox.cs,InitializeComponent,The following statement contains a magic number: this.tableLayoutPanel.ColumnCount = 2;
Magic Number,CityTrafficSimulator,AboutBox,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\AboutBox\AboutBox.cs,InitializeComponent,The following statement contains a magic number: this.tableLayoutPanel.Controls.Add(this.labelCopyright' 1' 2);
Magic Number,CityTrafficSimulator,AboutBox,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\AboutBox\AboutBox.cs,InitializeComponent,The following statement contains a magic number: this.tableLayoutPanel.Controls.Add(this.labelCompanyName' 1' 3);
Magic Number,CityTrafficSimulator,AboutBox,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\AboutBox\AboutBox.cs,InitializeComponent,The following statement contains a magic number: this.tableLayoutPanel.Controls.Add(this.textBoxDescription' 1' 5);
Magic Number,CityTrafficSimulator,AboutBox,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\AboutBox\AboutBox.cs,InitializeComponent,The following statement contains a magic number: this.tableLayoutPanel.Controls.Add(this.okButton' 1' 6);
Magic Number,CityTrafficSimulator,AboutBox,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\AboutBox\AboutBox.cs,InitializeComponent,The following statement contains a magic number: this.tableLayoutPanel.Controls.Add(this.labelMagicRef' 1' 4);
Magic Number,CityTrafficSimulator,AboutBox,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\AboutBox\AboutBox.cs,InitializeComponent,The following statement contains a magic number: this.tableLayoutPanel.Location = new System.Drawing.Point(9' 9);
Magic Number,CityTrafficSimulator,AboutBox,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\AboutBox\AboutBox.cs,InitializeComponent,The following statement contains a magic number: this.tableLayoutPanel.Location = new System.Drawing.Point(9' 9);
Magic Number,CityTrafficSimulator,AboutBox,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\AboutBox\AboutBox.cs,InitializeComponent,The following statement contains a magic number: this.tableLayoutPanel.RowCount = 7;
Magic Number,CityTrafficSimulator,AboutBox,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\AboutBox\AboutBox.cs,InitializeComponent,The following statement contains a magic number: this.tableLayoutPanel.Size = new System.Drawing.Size(534' 346);
Magic Number,CityTrafficSimulator,AboutBox,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\AboutBox\AboutBox.cs,InitializeComponent,The following statement contains a magic number: this.tableLayoutPanel.Size = new System.Drawing.Size(534' 346);
Magic Number,CityTrafficSimulator,AboutBox,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\AboutBox\AboutBox.cs,InitializeComponent,The following statement contains a magic number: this.logoPictureBox.Location = new System.Drawing.Point(3' 3);
Magic Number,CityTrafficSimulator,AboutBox,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\AboutBox\AboutBox.cs,InitializeComponent,The following statement contains a magic number: this.logoPictureBox.Location = new System.Drawing.Point(3' 3);
Magic Number,CityTrafficSimulator,AboutBox,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\AboutBox\AboutBox.cs,InitializeComponent,The following statement contains a magic number: this.tableLayoutPanel.SetRowSpan(this.logoPictureBox' 7);
Magic Number,CityTrafficSimulator,AboutBox,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\AboutBox\AboutBox.cs,InitializeComponent,The following statement contains a magic number: this.logoPictureBox.Size = new System.Drawing.Size(170' 340);
Magic Number,CityTrafficSimulator,AboutBox,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\AboutBox\AboutBox.cs,InitializeComponent,The following statement contains a magic number: this.logoPictureBox.Size = new System.Drawing.Size(170' 340);
Magic Number,CityTrafficSimulator,AboutBox,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\AboutBox\AboutBox.cs,InitializeComponent,The following statement contains a magic number: this.logoPictureBox.TabIndex = 12;
Magic Number,CityTrafficSimulator,AboutBox,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\AboutBox\AboutBox.cs,InitializeComponent,The following statement contains a magic number: this.labelProductName.Location = new System.Drawing.Point(182' 0);
Magic Number,CityTrafficSimulator,AboutBox,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\AboutBox\AboutBox.cs,InitializeComponent,The following statement contains a magic number: this.labelProductName.Margin = new System.Windows.Forms.Padding(6' 0' 3' 0);
Magic Number,CityTrafficSimulator,AboutBox,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\AboutBox\AboutBox.cs,InitializeComponent,The following statement contains a magic number: this.labelProductName.Margin = new System.Windows.Forms.Padding(6' 0' 3' 0);
Magic Number,CityTrafficSimulator,AboutBox,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\AboutBox\AboutBox.cs,InitializeComponent,The following statement contains a magic number: this.labelProductName.MaximumSize = new System.Drawing.Size(0' 17);
Magic Number,CityTrafficSimulator,AboutBox,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\AboutBox\AboutBox.cs,InitializeComponent,The following statement contains a magic number: this.labelProductName.Size = new System.Drawing.Size(349' 17);
Magic Number,CityTrafficSimulator,AboutBox,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\AboutBox\AboutBox.cs,InitializeComponent,The following statement contains a magic number: this.labelProductName.Size = new System.Drawing.Size(349' 17);
Magic Number,CityTrafficSimulator,AboutBox,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\AboutBox\AboutBox.cs,InitializeComponent,The following statement contains a magic number: this.labelProductName.TabIndex = 19;
Magic Number,CityTrafficSimulator,AboutBox,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\AboutBox\AboutBox.cs,InitializeComponent,The following statement contains a magic number: this.labelVersion.Location = new System.Drawing.Point(182' 24);
Magic Number,CityTrafficSimulator,AboutBox,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\AboutBox\AboutBox.cs,InitializeComponent,The following statement contains a magic number: this.labelVersion.Location = new System.Drawing.Point(182' 24);
Magic Number,CityTrafficSimulator,AboutBox,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\AboutBox\AboutBox.cs,InitializeComponent,The following statement contains a magic number: this.labelVersion.Margin = new System.Windows.Forms.Padding(6' 0' 3' 0);
Magic Number,CityTrafficSimulator,AboutBox,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\AboutBox\AboutBox.cs,InitializeComponent,The following statement contains a magic number: this.labelVersion.Margin = new System.Windows.Forms.Padding(6' 0' 3' 0);
Magic Number,CityTrafficSimulator,AboutBox,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\AboutBox\AboutBox.cs,InitializeComponent,The following statement contains a magic number: this.labelVersion.MaximumSize = new System.Drawing.Size(0' 17);
Magic Number,CityTrafficSimulator,AboutBox,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\AboutBox\AboutBox.cs,InitializeComponent,The following statement contains a magic number: this.labelVersion.Size = new System.Drawing.Size(349' 17);
Magic Number,CityTrafficSimulator,AboutBox,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\AboutBox\AboutBox.cs,InitializeComponent,The following statement contains a magic number: this.labelVersion.Size = new System.Drawing.Size(349' 17);
Magic Number,CityTrafficSimulator,AboutBox,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\AboutBox\AboutBox.cs,InitializeComponent,The following statement contains a magic number: this.labelCopyright.Location = new System.Drawing.Point(182' 48);
Magic Number,CityTrafficSimulator,AboutBox,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\AboutBox\AboutBox.cs,InitializeComponent,The following statement contains a magic number: this.labelCopyright.Location = new System.Drawing.Point(182' 48);
Magic Number,CityTrafficSimulator,AboutBox,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\AboutBox\AboutBox.cs,InitializeComponent,The following statement contains a magic number: this.labelCopyright.Margin = new System.Windows.Forms.Padding(6' 0' 3' 0);
Magic Number,CityTrafficSimulator,AboutBox,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\AboutBox\AboutBox.cs,InitializeComponent,The following statement contains a magic number: this.labelCopyright.Margin = new System.Windows.Forms.Padding(6' 0' 3' 0);
Magic Number,CityTrafficSimulator,AboutBox,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\AboutBox\AboutBox.cs,InitializeComponent,The following statement contains a magic number: this.labelCopyright.MaximumSize = new System.Drawing.Size(0' 17);
Magic Number,CityTrafficSimulator,AboutBox,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\AboutBox\AboutBox.cs,InitializeComponent,The following statement contains a magic number: this.labelCopyright.Size = new System.Drawing.Size(349' 17);
Magic Number,CityTrafficSimulator,AboutBox,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\AboutBox\AboutBox.cs,InitializeComponent,The following statement contains a magic number: this.labelCopyright.Size = new System.Drawing.Size(349' 17);
Magic Number,CityTrafficSimulator,AboutBox,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\AboutBox\AboutBox.cs,InitializeComponent,The following statement contains a magic number: this.labelCopyright.TabIndex = 21;
Magic Number,CityTrafficSimulator,AboutBox,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\AboutBox\AboutBox.cs,InitializeComponent,The following statement contains a magic number: this.labelCompanyName.Location = new System.Drawing.Point(182' 72);
Magic Number,CityTrafficSimulator,AboutBox,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\AboutBox\AboutBox.cs,InitializeComponent,The following statement contains a magic number: this.labelCompanyName.Location = new System.Drawing.Point(182' 72);
Magic Number,CityTrafficSimulator,AboutBox,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\AboutBox\AboutBox.cs,InitializeComponent,The following statement contains a magic number: this.labelCompanyName.Margin = new System.Windows.Forms.Padding(6' 0' 3' 0);
Magic Number,CityTrafficSimulator,AboutBox,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\AboutBox\AboutBox.cs,InitializeComponent,The following statement contains a magic number: this.labelCompanyName.Margin = new System.Windows.Forms.Padding(6' 0' 3' 0);
Magic Number,CityTrafficSimulator,AboutBox,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\AboutBox\AboutBox.cs,InitializeComponent,The following statement contains a magic number: this.labelCompanyName.MaximumSize = new System.Drawing.Size(0' 17);
Magic Number,CityTrafficSimulator,AboutBox,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\AboutBox\AboutBox.cs,InitializeComponent,The following statement contains a magic number: this.labelCompanyName.Size = new System.Drawing.Size(349' 17);
Magic Number,CityTrafficSimulator,AboutBox,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\AboutBox\AboutBox.cs,InitializeComponent,The following statement contains a magic number: this.labelCompanyName.Size = new System.Drawing.Size(349' 17);
Magic Number,CityTrafficSimulator,AboutBox,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\AboutBox\AboutBox.cs,InitializeComponent,The following statement contains a magic number: this.labelCompanyName.TabIndex = 22;
Magic Number,CityTrafficSimulator,AboutBox,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\AboutBox\AboutBox.cs,InitializeComponent,The following statement contains a magic number: this.textBoxDescription.Location = new System.Drawing.Point(182' 123);
Magic Number,CityTrafficSimulator,AboutBox,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\AboutBox\AboutBox.cs,InitializeComponent,The following statement contains a magic number: this.textBoxDescription.Location = new System.Drawing.Point(182' 123);
Magic Number,CityTrafficSimulator,AboutBox,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\AboutBox\AboutBox.cs,InitializeComponent,The following statement contains a magic number: this.textBoxDescription.Margin = new System.Windows.Forms.Padding(6' 3' 3' 3);
Magic Number,CityTrafficSimulator,AboutBox,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\AboutBox\AboutBox.cs,InitializeComponent,The following statement contains a magic number: this.textBoxDescription.Margin = new System.Windows.Forms.Padding(6' 3' 3' 3);
Magic Number,CityTrafficSimulator,AboutBox,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\AboutBox\AboutBox.cs,InitializeComponent,The following statement contains a magic number: this.textBoxDescription.Margin = new System.Windows.Forms.Padding(6' 3' 3' 3);
Magic Number,CityTrafficSimulator,AboutBox,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\AboutBox\AboutBox.cs,InitializeComponent,The following statement contains a magic number: this.textBoxDescription.Margin = new System.Windows.Forms.Padding(6' 3' 3' 3);
Magic Number,CityTrafficSimulator,AboutBox,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\AboutBox\AboutBox.cs,InitializeComponent,The following statement contains a magic number: this.textBoxDescription.Size = new System.Drawing.Size(349' 191);
Magic Number,CityTrafficSimulator,AboutBox,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\AboutBox\AboutBox.cs,InitializeComponent,The following statement contains a magic number: this.textBoxDescription.Size = new System.Drawing.Size(349' 191);
Magic Number,CityTrafficSimulator,AboutBox,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\AboutBox\AboutBox.cs,InitializeComponent,The following statement contains a magic number: this.textBoxDescription.TabIndex = 23;
Magic Number,CityTrafficSimulator,AboutBox,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\AboutBox\AboutBox.cs,InitializeComponent,The following statement contains a magic number: this.okButton.Location = new System.Drawing.Point(456' 320);
Magic Number,CityTrafficSimulator,AboutBox,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\AboutBox\AboutBox.cs,InitializeComponent,The following statement contains a magic number: this.okButton.Location = new System.Drawing.Point(456' 320);
Magic Number,CityTrafficSimulator,AboutBox,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\AboutBox\AboutBox.cs,InitializeComponent,The following statement contains a magic number: this.okButton.Size = new System.Drawing.Size(75' 23);
Magic Number,CityTrafficSimulator,AboutBox,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\AboutBox\AboutBox.cs,InitializeComponent,The following statement contains a magic number: this.okButton.Size = new System.Drawing.Size(75' 23);
Magic Number,CityTrafficSimulator,AboutBox,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\AboutBox\AboutBox.cs,InitializeComponent,The following statement contains a magic number: this.okButton.TabIndex = 24;
Magic Number,CityTrafficSimulator,AboutBox,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\AboutBox\AboutBox.cs,InitializeComponent,The following statement contains a magic number: this.labelMagicRef.Location = new System.Drawing.Point(182' 96);
Magic Number,CityTrafficSimulator,AboutBox,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\AboutBox\AboutBox.cs,InitializeComponent,The following statement contains a magic number: this.labelMagicRef.Location = new System.Drawing.Point(182' 96);
Magic Number,CityTrafficSimulator,AboutBox,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\AboutBox\AboutBox.cs,InitializeComponent,The following statement contains a magic number: this.labelMagicRef.Margin = new System.Windows.Forms.Padding(6' 0' 3' 0);
Magic Number,CityTrafficSimulator,AboutBox,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\AboutBox\AboutBox.cs,InitializeComponent,The following statement contains a magic number: this.labelMagicRef.Margin = new System.Windows.Forms.Padding(6' 0' 3' 0);
Magic Number,CityTrafficSimulator,AboutBox,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\AboutBox\AboutBox.cs,InitializeComponent,The following statement contains a magic number: this.labelMagicRef.Size = new System.Drawing.Size(323' 13);
Magic Number,CityTrafficSimulator,AboutBox,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\AboutBox\AboutBox.cs,InitializeComponent,The following statement contains a magic number: this.labelMagicRef.Size = new System.Drawing.Size(323' 13);
Magic Number,CityTrafficSimulator,AboutBox,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\AboutBox\AboutBox.cs,InitializeComponent,The following statement contains a magic number: this.labelMagicRef.TabIndex = 25;
Magic Number,CityTrafficSimulator,AboutBox,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\AboutBox\AboutBox.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(552' 364);
Magic Number,CityTrafficSimulator,AboutBox,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\AboutBox\AboutBox.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(552' 364);
Magic Number,CityTrafficSimulator,AboutBox,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\AboutBox\AboutBox.cs,InitializeComponent,The following statement contains a magic number: this.Padding = new System.Windows.Forms.Padding(9);
Magic Number,CityTrafficSimulator,Auftrag,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Auftrag.cs,CreateVehicle,The following statement contains a magic number: switch (m_vehicleType)  				{  				case IVehicle.VehicleTypes.CAR:  					if (GlobalRandom.Instance.Next(100) < truckRatio)  						{  						v = new Truck(p);  						}  					else  						{  						v = new Car(p);  						}					  					break;  				case IVehicle.VehicleTypes.TRAM:  					v = new Tram(p);  					break;  				case IVehicle.VehicleTypes.BUS:  					v = new Bus(p);  					break;  				}
Magic Number,CityTrafficSimulator,Auftrag,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Auftrag.cs,RecoverFromLoad,The following statement contains a magic number: if (saveVersion < 1)  				{  				m_wunschgeschwindigkeit *= 2;  				}
Magic Number,CityTrafficSimulator,GlobalRandom,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\GlobalRandom.cs,GlobalRandom,The following statement contains a magic number: _random = new Random(42);
Magic Number,CityTrafficSimulator,GlobalTime,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\GlobalTime.cs,GlobalTime,The following statement contains a magic number: cycleTime = 50;
Magic Number,CityTrafficSimulator,GlobalTime,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\GlobalTime.cs,GlobalTime,The following statement contains a magic number: ticksPerSecond = 15;
Magic Number,CityTrafficSimulator,Routing,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Routing.cs,CalculateShortestConenction,The following statement contains a magic number: do  				{  				// Knoten mit dem geringsten (in diesem Fall größten) f Wert aus der Open List entfernen  				PriorityQueueItem<LineNode.LinkedLineNode' double> currentNode = openlist.Dequeue();    				// wurde das Ziel gefunden?  				if (targetNodes.Contains(currentNode.Value.node))  					{  					// nun noch die closedList in eine Routing umwandeln  					closedlist.Push(currentNode.Value);  					LineNode.LinkedLineNode endnode = closedlist.Pop();  					LineNode.LinkedLineNode startnode = endnode.parent;  					while (startnode != null)  						{  						// einfacher/direkter Weg über eine NodeConnection  						if (!endnode.lineChangeNeeded)  							{  							toReturn.Push(new RouteSegment(startnode.node.GetNodeConnectionTo(endnode.node)' endnode.node' false' startnode.node.GetNodeConnectionTo(endnode.node).lineSegment.length));  							}  						// Spurwechsel nötig  						else  							{  							NodeConnection formerConnection = startnode.parent.node.GetNodeConnectionTo(startnode.node);    							double length = formerConnection.GetLengthToLineNodeViaLineChange(endnode.node) + Constants.lineChangePenalty;  							// Anfangs-/ oder Endknoten des Spurwechsels ist eine Ampel => Kosten-Penalty' da hier verstärktes Verkehrsaufkommen zu erwarten ist  							if ((endnode.node.tLight != null) || (startnode.node.tLight != null))  								length += Constants.lineChangeBeforeTrafficLightPenalty;    							toReturn.Push(new RouteSegment(formerConnection' endnode.node' true' length));    							// TODO:	Erklären: hier wird irgendwas doppelt gemacht - ich meine mich zu Erinnern'  							//			das das so soll' aber nicht warum. Bitte beizeiten analysieren und erklären  							endnode = startnode;  							startnode = startnode.parent;  							}    						endnode = startnode;  						startnode = startnode.parent;  						}  					return toReturn;  					}    				#region Nachfolgeknoten auf die Open List setzen  				// Nachfolgeknoten auf die Open List setzen  				// überprüft alle Nachfolgeknoten und fügt sie der Open List hinzu' wenn entweder  				// - der Nachfolgeknoten zum ersten Mal gefunden wird oder  				// - ein besserer Weg zu diesem Knoten gefunden wird    				#region nächste LineNodes ohne Spurwechsel untersuchen  				foreach (NodeConnection nc in currentNode.Value.node.nextConnections)  					{  					// prüfen' ob ich auf diesem NodeConnection überhaupt fahren darf  					if (!nc.CheckForSuitability(vehicleType))  						continue;    					LineNode.LinkedLineNode successor = new LineNode.LinkedLineNode(nc.endNode' null' false);  					bool nodeInClosedList = false;  					foreach (LineNode.LinkedLineNode lln in closedlist)  						if (lln.node == successor.node)  							{  							nodeInClosedList = true;  							continue;  							}    					// wenn der Nachfolgeknoten bereits auf der Closed List ist - tue nichts  					if (!nodeInClosedList)  						{  						NodeConnection theConnection = currentNode.Value.node.GetNodeConnectionTo(successor.node);  						// f Wert für den neuen Weg berechnen: g Wert des Vorgängers plus die Kosten der  						// gerade benutzten Kante plus die geschätzten Kosten von Nachfolger bis Ziel  						double f = currentNode.Value.length												// exakte Länge des bisher zurückgelegten Weges  							+ theConnection.lineSegment.length;											// exakte Länge des gerade untersuchten Segmentes    						if (currentNode.Value.countOfParents < 3)										// Stau kostet extra' aber nur' wenn innerhalb  							{																			// der nächsten 2 Connections  							f += theConnection.vehicles.Count * Constants.vehicleOnRoutePenalty;  							}  						f += GetMinimumEuklidDistance(successor.node' targetNodes);						// Minimumweg zum Ziel (Luftlinie)  						f *= 14 / theConnection.targetVelocity;  						f *= -1;      						// gucke' ob der Node schon in der Liste drin ist und wenn ja' dann evtl. rausschmeißen  						bool nodeInOpenlist = false;  						foreach (PriorityQueueItem<LineNode.LinkedLineNode' double> pqi in openlist)  							{  							if (pqi.Value.node == successor.node)  								{  								if (f <= pqi.Priority)  									nodeInOpenlist = true;  								else  									openlist.Remove(pqi.Value); // erst entfernen  								break;  								}  							}    						if (!nodeInOpenlist)  							{  							// Vorgängerzeiger setzen  							successor.parent = currentNode.Value;  							openlist.Enqueue(successor' f); // dann neu einfügen  							}  						}  					}  				#endregion    				#region nächste LineNodes mit Spurwechsel untersuchen    				if (currentNode.Value.parent != null)  					{  					NodeConnection currentConnection = currentNode.Value.parent.node.GetNodeConnectionTo(currentNode.Value.node);  					if (currentConnection != null)  						{  						foreach (LineNode ln in currentConnection.viaLineChangeReachableNodes)  							{  							// prüfen' ob ich diesen LineNode überhaupt anfahren darf  							if (!CheckLineNodeForIncomingSuitability(ln' vehicleType))  								continue;    							// neuen LinkedLineNode erstellen  							LineNode.LinkedLineNode successor = new LineNode.LinkedLineNode(ln' null' true);  							bool nodeInClosedList = false;  							foreach (LineNode.LinkedLineNode lln in closedlist)  								if (lln.node == successor.node)  									{  									nodeInClosedList = true;  									break;  									}    							// wenn der Nachfolgeknoten bereits auf der Closed List ist - tue nichts  							if (!nodeInClosedList)  								{  								// passendes LineChangeInterval finden  								NodeConnection.LineChangeInterval lci;  								currentConnection.lineChangeIntervals.TryGetValue(ln.hashcode' out lci);    								if (lci.length < Constants.minimumLineChangeLength)  									break;    								// f-Wert für den neuen Weg berechnen: g Wert des Vorgängers plus die Kosten der  								// gerade benutzten Kante plus die geschätzten Kosten von Nachfolger bis Ziel  								double f = currentNode.Value.parent.length;										// exakte Länge des bisher zurückgelegten Weges  								f += currentConnection.GetLengthToLineNodeViaLineChange(successor.node);    								// Kostenanteil' für den Spurwechsel dazuaddieren  								f += (lci.length < 2 * Constants.minimumLineChangeLength) ? 2 * Constants.lineChangePenalty : Constants.lineChangePenalty;    								// Anfangs-/ oder Endknoten des Spurwechsels ist eine Ampel => Kosten-Penalty' da hier verstärktes Verkehrsaufkommen zu erwarten ist  								if ((lci.targetNode.tLight != null) || (currentConnection.startNode.tLight != null))  									f += Constants.lineChangeBeforeTrafficLightPenalty;    								f += GetMinimumEuklidDistance(successor.node' targetNodes);						// Minimumweg zum Ziel (Luftlinie)  								f *= -1;      								// gucke' ob der Node schon in der Liste drin ist und wenn ja' dann evtl. rausschmeißen  								bool nodeInOpenlist = false;  								foreach (PriorityQueueItem<LineNode.LinkedLineNode' double> pqi in openlist)  									{  									if (pqi.Value.node == successor.node)  										{  										if (f <= pqi.Priority)  											nodeInOpenlist = true;  										else  											openlist.Remove(pqi.Value); // erst entfernen  										break;  										}  									}    								if (!nodeInOpenlist)  									{  									// Vorgängerzeiger setzen  									successor.parent = currentNode.Value;  									openlist.Enqueue(successor' f); // dann neu einfügen  									}  								}  							}  						}  					}      				#endregion    				#endregion    				// der aktuelle Knoten ist nun abschließend untersucht  				closedlist.Push(currentNode.Value);  				}  			while (openlist.Count != 0);
Magic Number,CityTrafficSimulator,Routing,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Routing.cs,CalculateShortestConenction,The following statement contains a magic number: do  				{  				// Knoten mit dem geringsten (in diesem Fall größten) f Wert aus der Open List entfernen  				PriorityQueueItem<LineNode.LinkedLineNode' double> currentNode = openlist.Dequeue();    				// wurde das Ziel gefunden?  				if (targetNodes.Contains(currentNode.Value.node))  					{  					// nun noch die closedList in eine Routing umwandeln  					closedlist.Push(currentNode.Value);  					LineNode.LinkedLineNode endnode = closedlist.Pop();  					LineNode.LinkedLineNode startnode = endnode.parent;  					while (startnode != null)  						{  						// einfacher/direkter Weg über eine NodeConnection  						if (!endnode.lineChangeNeeded)  							{  							toReturn.Push(new RouteSegment(startnode.node.GetNodeConnectionTo(endnode.node)' endnode.node' false' startnode.node.GetNodeConnectionTo(endnode.node).lineSegment.length));  							}  						// Spurwechsel nötig  						else  							{  							NodeConnection formerConnection = startnode.parent.node.GetNodeConnectionTo(startnode.node);    							double length = formerConnection.GetLengthToLineNodeViaLineChange(endnode.node) + Constants.lineChangePenalty;  							// Anfangs-/ oder Endknoten des Spurwechsels ist eine Ampel => Kosten-Penalty' da hier verstärktes Verkehrsaufkommen zu erwarten ist  							if ((endnode.node.tLight != null) || (startnode.node.tLight != null))  								length += Constants.lineChangeBeforeTrafficLightPenalty;    							toReturn.Push(new RouteSegment(formerConnection' endnode.node' true' length));    							// TODO:	Erklären: hier wird irgendwas doppelt gemacht - ich meine mich zu Erinnern'  							//			das das so soll' aber nicht warum. Bitte beizeiten analysieren und erklären  							endnode = startnode;  							startnode = startnode.parent;  							}    						endnode = startnode;  						startnode = startnode.parent;  						}  					return toReturn;  					}    				#region Nachfolgeknoten auf die Open List setzen  				// Nachfolgeknoten auf die Open List setzen  				// überprüft alle Nachfolgeknoten und fügt sie der Open List hinzu' wenn entweder  				// - der Nachfolgeknoten zum ersten Mal gefunden wird oder  				// - ein besserer Weg zu diesem Knoten gefunden wird    				#region nächste LineNodes ohne Spurwechsel untersuchen  				foreach (NodeConnection nc in currentNode.Value.node.nextConnections)  					{  					// prüfen' ob ich auf diesem NodeConnection überhaupt fahren darf  					if (!nc.CheckForSuitability(vehicleType))  						continue;    					LineNode.LinkedLineNode successor = new LineNode.LinkedLineNode(nc.endNode' null' false);  					bool nodeInClosedList = false;  					foreach (LineNode.LinkedLineNode lln in closedlist)  						if (lln.node == successor.node)  							{  							nodeInClosedList = true;  							continue;  							}    					// wenn der Nachfolgeknoten bereits auf der Closed List ist - tue nichts  					if (!nodeInClosedList)  						{  						NodeConnection theConnection = currentNode.Value.node.GetNodeConnectionTo(successor.node);  						// f Wert für den neuen Weg berechnen: g Wert des Vorgängers plus die Kosten der  						// gerade benutzten Kante plus die geschätzten Kosten von Nachfolger bis Ziel  						double f = currentNode.Value.length												// exakte Länge des bisher zurückgelegten Weges  							+ theConnection.lineSegment.length;											// exakte Länge des gerade untersuchten Segmentes    						if (currentNode.Value.countOfParents < 3)										// Stau kostet extra' aber nur' wenn innerhalb  							{																			// der nächsten 2 Connections  							f += theConnection.vehicles.Count * Constants.vehicleOnRoutePenalty;  							}  						f += GetMinimumEuklidDistance(successor.node' targetNodes);						// Minimumweg zum Ziel (Luftlinie)  						f *= 14 / theConnection.targetVelocity;  						f *= -1;      						// gucke' ob der Node schon in der Liste drin ist und wenn ja' dann evtl. rausschmeißen  						bool nodeInOpenlist = false;  						foreach (PriorityQueueItem<LineNode.LinkedLineNode' double> pqi in openlist)  							{  							if (pqi.Value.node == successor.node)  								{  								if (f <= pqi.Priority)  									nodeInOpenlist = true;  								else  									openlist.Remove(pqi.Value); // erst entfernen  								break;  								}  							}    						if (!nodeInOpenlist)  							{  							// Vorgängerzeiger setzen  							successor.parent = currentNode.Value;  							openlist.Enqueue(successor' f); // dann neu einfügen  							}  						}  					}  				#endregion    				#region nächste LineNodes mit Spurwechsel untersuchen    				if (currentNode.Value.parent != null)  					{  					NodeConnection currentConnection = currentNode.Value.parent.node.GetNodeConnectionTo(currentNode.Value.node);  					if (currentConnection != null)  						{  						foreach (LineNode ln in currentConnection.viaLineChangeReachableNodes)  							{  							// prüfen' ob ich diesen LineNode überhaupt anfahren darf  							if (!CheckLineNodeForIncomingSuitability(ln' vehicleType))  								continue;    							// neuen LinkedLineNode erstellen  							LineNode.LinkedLineNode successor = new LineNode.LinkedLineNode(ln' null' true);  							bool nodeInClosedList = false;  							foreach (LineNode.LinkedLineNode lln in closedlist)  								if (lln.node == successor.node)  									{  									nodeInClosedList = true;  									break;  									}    							// wenn der Nachfolgeknoten bereits auf der Closed List ist - tue nichts  							if (!nodeInClosedList)  								{  								// passendes LineChangeInterval finden  								NodeConnection.LineChangeInterval lci;  								currentConnection.lineChangeIntervals.TryGetValue(ln.hashcode' out lci);    								if (lci.length < Constants.minimumLineChangeLength)  									break;    								// f-Wert für den neuen Weg berechnen: g Wert des Vorgängers plus die Kosten der  								// gerade benutzten Kante plus die geschätzten Kosten von Nachfolger bis Ziel  								double f = currentNode.Value.parent.length;										// exakte Länge des bisher zurückgelegten Weges  								f += currentConnection.GetLengthToLineNodeViaLineChange(successor.node);    								// Kostenanteil' für den Spurwechsel dazuaddieren  								f += (lci.length < 2 * Constants.minimumLineChangeLength) ? 2 * Constants.lineChangePenalty : Constants.lineChangePenalty;    								// Anfangs-/ oder Endknoten des Spurwechsels ist eine Ampel => Kosten-Penalty' da hier verstärktes Verkehrsaufkommen zu erwarten ist  								if ((lci.targetNode.tLight != null) || (currentConnection.startNode.tLight != null))  									f += Constants.lineChangeBeforeTrafficLightPenalty;    								f += GetMinimumEuklidDistance(successor.node' targetNodes);						// Minimumweg zum Ziel (Luftlinie)  								f *= -1;      								// gucke' ob der Node schon in der Liste drin ist und wenn ja' dann evtl. rausschmeißen  								bool nodeInOpenlist = false;  								foreach (PriorityQueueItem<LineNode.LinkedLineNode' double> pqi in openlist)  									{  									if (pqi.Value.node == successor.node)  										{  										if (f <= pqi.Priority)  											nodeInOpenlist = true;  										else  											openlist.Remove(pqi.Value); // erst entfernen  										break;  										}  									}    								if (!nodeInOpenlist)  									{  									// Vorgängerzeiger setzen  									successor.parent = currentNode.Value;  									openlist.Enqueue(successor' f); // dann neu einfügen  									}  								}  							}  						}  					}      				#endregion    				#endregion    				// der aktuelle Knoten ist nun abschließend untersucht  				closedlist.Push(currentNode.Value);  				}  			while (openlist.Count != 0);
Magic Number,CityTrafficSimulator,Routing,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Routing.cs,CalculateShortestConenction,The following statement contains a magic number: do  				{  				// Knoten mit dem geringsten (in diesem Fall größten) f Wert aus der Open List entfernen  				PriorityQueueItem<LineNode.LinkedLineNode' double> currentNode = openlist.Dequeue();    				// wurde das Ziel gefunden?  				if (targetNodes.Contains(currentNode.Value.node))  					{  					// nun noch die closedList in eine Routing umwandeln  					closedlist.Push(currentNode.Value);  					LineNode.LinkedLineNode endnode = closedlist.Pop();  					LineNode.LinkedLineNode startnode = endnode.parent;  					while (startnode != null)  						{  						// einfacher/direkter Weg über eine NodeConnection  						if (!endnode.lineChangeNeeded)  							{  							toReturn.Push(new RouteSegment(startnode.node.GetNodeConnectionTo(endnode.node)' endnode.node' false' startnode.node.GetNodeConnectionTo(endnode.node).lineSegment.length));  							}  						// Spurwechsel nötig  						else  							{  							NodeConnection formerConnection = startnode.parent.node.GetNodeConnectionTo(startnode.node);    							double length = formerConnection.GetLengthToLineNodeViaLineChange(endnode.node) + Constants.lineChangePenalty;  							// Anfangs-/ oder Endknoten des Spurwechsels ist eine Ampel => Kosten-Penalty' da hier verstärktes Verkehrsaufkommen zu erwarten ist  							if ((endnode.node.tLight != null) || (startnode.node.tLight != null))  								length += Constants.lineChangeBeforeTrafficLightPenalty;    							toReturn.Push(new RouteSegment(formerConnection' endnode.node' true' length));    							// TODO:	Erklären: hier wird irgendwas doppelt gemacht - ich meine mich zu Erinnern'  							//			das das so soll' aber nicht warum. Bitte beizeiten analysieren und erklären  							endnode = startnode;  							startnode = startnode.parent;  							}    						endnode = startnode;  						startnode = startnode.parent;  						}  					return toReturn;  					}    				#region Nachfolgeknoten auf die Open List setzen  				// Nachfolgeknoten auf die Open List setzen  				// überprüft alle Nachfolgeknoten und fügt sie der Open List hinzu' wenn entweder  				// - der Nachfolgeknoten zum ersten Mal gefunden wird oder  				// - ein besserer Weg zu diesem Knoten gefunden wird    				#region nächste LineNodes ohne Spurwechsel untersuchen  				foreach (NodeConnection nc in currentNode.Value.node.nextConnections)  					{  					// prüfen' ob ich auf diesem NodeConnection überhaupt fahren darf  					if (!nc.CheckForSuitability(vehicleType))  						continue;    					LineNode.LinkedLineNode successor = new LineNode.LinkedLineNode(nc.endNode' null' false);  					bool nodeInClosedList = false;  					foreach (LineNode.LinkedLineNode lln in closedlist)  						if (lln.node == successor.node)  							{  							nodeInClosedList = true;  							continue;  							}    					// wenn der Nachfolgeknoten bereits auf der Closed List ist - tue nichts  					if (!nodeInClosedList)  						{  						NodeConnection theConnection = currentNode.Value.node.GetNodeConnectionTo(successor.node);  						// f Wert für den neuen Weg berechnen: g Wert des Vorgängers plus die Kosten der  						// gerade benutzten Kante plus die geschätzten Kosten von Nachfolger bis Ziel  						double f = currentNode.Value.length												// exakte Länge des bisher zurückgelegten Weges  							+ theConnection.lineSegment.length;											// exakte Länge des gerade untersuchten Segmentes    						if (currentNode.Value.countOfParents < 3)										// Stau kostet extra' aber nur' wenn innerhalb  							{																			// der nächsten 2 Connections  							f += theConnection.vehicles.Count * Constants.vehicleOnRoutePenalty;  							}  						f += GetMinimumEuklidDistance(successor.node' targetNodes);						// Minimumweg zum Ziel (Luftlinie)  						f *= 14 / theConnection.targetVelocity;  						f *= -1;      						// gucke' ob der Node schon in der Liste drin ist und wenn ja' dann evtl. rausschmeißen  						bool nodeInOpenlist = false;  						foreach (PriorityQueueItem<LineNode.LinkedLineNode' double> pqi in openlist)  							{  							if (pqi.Value.node == successor.node)  								{  								if (f <= pqi.Priority)  									nodeInOpenlist = true;  								else  									openlist.Remove(pqi.Value); // erst entfernen  								break;  								}  							}    						if (!nodeInOpenlist)  							{  							// Vorgängerzeiger setzen  							successor.parent = currentNode.Value;  							openlist.Enqueue(successor' f); // dann neu einfügen  							}  						}  					}  				#endregion    				#region nächste LineNodes mit Spurwechsel untersuchen    				if (currentNode.Value.parent != null)  					{  					NodeConnection currentConnection = currentNode.Value.parent.node.GetNodeConnectionTo(currentNode.Value.node);  					if (currentConnection != null)  						{  						foreach (LineNode ln in currentConnection.viaLineChangeReachableNodes)  							{  							// prüfen' ob ich diesen LineNode überhaupt anfahren darf  							if (!CheckLineNodeForIncomingSuitability(ln' vehicleType))  								continue;    							// neuen LinkedLineNode erstellen  							LineNode.LinkedLineNode successor = new LineNode.LinkedLineNode(ln' null' true);  							bool nodeInClosedList = false;  							foreach (LineNode.LinkedLineNode lln in closedlist)  								if (lln.node == successor.node)  									{  									nodeInClosedList = true;  									break;  									}    							// wenn der Nachfolgeknoten bereits auf der Closed List ist - tue nichts  							if (!nodeInClosedList)  								{  								// passendes LineChangeInterval finden  								NodeConnection.LineChangeInterval lci;  								currentConnection.lineChangeIntervals.TryGetValue(ln.hashcode' out lci);    								if (lci.length < Constants.minimumLineChangeLength)  									break;    								// f-Wert für den neuen Weg berechnen: g Wert des Vorgängers plus die Kosten der  								// gerade benutzten Kante plus die geschätzten Kosten von Nachfolger bis Ziel  								double f = currentNode.Value.parent.length;										// exakte Länge des bisher zurückgelegten Weges  								f += currentConnection.GetLengthToLineNodeViaLineChange(successor.node);    								// Kostenanteil' für den Spurwechsel dazuaddieren  								f += (lci.length < 2 * Constants.minimumLineChangeLength) ? 2 * Constants.lineChangePenalty : Constants.lineChangePenalty;    								// Anfangs-/ oder Endknoten des Spurwechsels ist eine Ampel => Kosten-Penalty' da hier verstärktes Verkehrsaufkommen zu erwarten ist  								if ((lci.targetNode.tLight != null) || (currentConnection.startNode.tLight != null))  									f += Constants.lineChangeBeforeTrafficLightPenalty;    								f += GetMinimumEuklidDistance(successor.node' targetNodes);						// Minimumweg zum Ziel (Luftlinie)  								f *= -1;      								// gucke' ob der Node schon in der Liste drin ist und wenn ja' dann evtl. rausschmeißen  								bool nodeInOpenlist = false;  								foreach (PriorityQueueItem<LineNode.LinkedLineNode' double> pqi in openlist)  									{  									if (pqi.Value.node == successor.node)  										{  										if (f <= pqi.Priority)  											nodeInOpenlist = true;  										else  											openlist.Remove(pqi.Value); // erst entfernen  										break;  										}  									}    								if (!nodeInOpenlist)  									{  									// Vorgängerzeiger setzen  									successor.parent = currentNode.Value;  									openlist.Enqueue(successor' f); // dann neu einfügen  									}  								}  							}  						}  					}      				#endregion    				#endregion    				// der aktuelle Knoten ist nun abschließend untersucht  				closedlist.Push(currentNode.Value);  				}  			while (openlist.Count != 0);
Magic Number,CityTrafficSimulator,Routing,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Routing.cs,CalculateShortestConenction,The following statement contains a magic number: do  				{  				// Knoten mit dem geringsten (in diesem Fall größten) f Wert aus der Open List entfernen  				PriorityQueueItem<LineNode.LinkedLineNode' double> currentNode = openlist.Dequeue();    				// wurde das Ziel gefunden?  				if (targetNodes.Contains(currentNode.Value.node))  					{  					// nun noch die closedList in eine Routing umwandeln  					closedlist.Push(currentNode.Value);  					LineNode.LinkedLineNode endnode = closedlist.Pop();  					LineNode.LinkedLineNode startnode = endnode.parent;  					while (startnode != null)  						{  						// einfacher/direkter Weg über eine NodeConnection  						if (!endnode.lineChangeNeeded)  							{  							toReturn.Push(new RouteSegment(startnode.node.GetNodeConnectionTo(endnode.node)' endnode.node' false' startnode.node.GetNodeConnectionTo(endnode.node).lineSegment.length));  							}  						// Spurwechsel nötig  						else  							{  							NodeConnection formerConnection = startnode.parent.node.GetNodeConnectionTo(startnode.node);    							double length = formerConnection.GetLengthToLineNodeViaLineChange(endnode.node) + Constants.lineChangePenalty;  							// Anfangs-/ oder Endknoten des Spurwechsels ist eine Ampel => Kosten-Penalty' da hier verstärktes Verkehrsaufkommen zu erwarten ist  							if ((endnode.node.tLight != null) || (startnode.node.tLight != null))  								length += Constants.lineChangeBeforeTrafficLightPenalty;    							toReturn.Push(new RouteSegment(formerConnection' endnode.node' true' length));    							// TODO:	Erklären: hier wird irgendwas doppelt gemacht - ich meine mich zu Erinnern'  							//			das das so soll' aber nicht warum. Bitte beizeiten analysieren und erklären  							endnode = startnode;  							startnode = startnode.parent;  							}    						endnode = startnode;  						startnode = startnode.parent;  						}  					return toReturn;  					}    				#region Nachfolgeknoten auf die Open List setzen  				// Nachfolgeknoten auf die Open List setzen  				// überprüft alle Nachfolgeknoten und fügt sie der Open List hinzu' wenn entweder  				// - der Nachfolgeknoten zum ersten Mal gefunden wird oder  				// - ein besserer Weg zu diesem Knoten gefunden wird    				#region nächste LineNodes ohne Spurwechsel untersuchen  				foreach (NodeConnection nc in currentNode.Value.node.nextConnections)  					{  					// prüfen' ob ich auf diesem NodeConnection überhaupt fahren darf  					if (!nc.CheckForSuitability(vehicleType))  						continue;    					LineNode.LinkedLineNode successor = new LineNode.LinkedLineNode(nc.endNode' null' false);  					bool nodeInClosedList = false;  					foreach (LineNode.LinkedLineNode lln in closedlist)  						if (lln.node == successor.node)  							{  							nodeInClosedList = true;  							continue;  							}    					// wenn der Nachfolgeknoten bereits auf der Closed List ist - tue nichts  					if (!nodeInClosedList)  						{  						NodeConnection theConnection = currentNode.Value.node.GetNodeConnectionTo(successor.node);  						// f Wert für den neuen Weg berechnen: g Wert des Vorgängers plus die Kosten der  						// gerade benutzten Kante plus die geschätzten Kosten von Nachfolger bis Ziel  						double f = currentNode.Value.length												// exakte Länge des bisher zurückgelegten Weges  							+ theConnection.lineSegment.length;											// exakte Länge des gerade untersuchten Segmentes    						if (currentNode.Value.countOfParents < 3)										// Stau kostet extra' aber nur' wenn innerhalb  							{																			// der nächsten 2 Connections  							f += theConnection.vehicles.Count * Constants.vehicleOnRoutePenalty;  							}  						f += GetMinimumEuklidDistance(successor.node' targetNodes);						// Minimumweg zum Ziel (Luftlinie)  						f *= 14 / theConnection.targetVelocity;  						f *= -1;      						// gucke' ob der Node schon in der Liste drin ist und wenn ja' dann evtl. rausschmeißen  						bool nodeInOpenlist = false;  						foreach (PriorityQueueItem<LineNode.LinkedLineNode' double> pqi in openlist)  							{  							if (pqi.Value.node == successor.node)  								{  								if (f <= pqi.Priority)  									nodeInOpenlist = true;  								else  									openlist.Remove(pqi.Value); // erst entfernen  								break;  								}  							}    						if (!nodeInOpenlist)  							{  							// Vorgängerzeiger setzen  							successor.parent = currentNode.Value;  							openlist.Enqueue(successor' f); // dann neu einfügen  							}  						}  					}  				#endregion    				#region nächste LineNodes mit Spurwechsel untersuchen    				if (currentNode.Value.parent != null)  					{  					NodeConnection currentConnection = currentNode.Value.parent.node.GetNodeConnectionTo(currentNode.Value.node);  					if (currentConnection != null)  						{  						foreach (LineNode ln in currentConnection.viaLineChangeReachableNodes)  							{  							// prüfen' ob ich diesen LineNode überhaupt anfahren darf  							if (!CheckLineNodeForIncomingSuitability(ln' vehicleType))  								continue;    							// neuen LinkedLineNode erstellen  							LineNode.LinkedLineNode successor = new LineNode.LinkedLineNode(ln' null' true);  							bool nodeInClosedList = false;  							foreach (LineNode.LinkedLineNode lln in closedlist)  								if (lln.node == successor.node)  									{  									nodeInClosedList = true;  									break;  									}    							// wenn der Nachfolgeknoten bereits auf der Closed List ist - tue nichts  							if (!nodeInClosedList)  								{  								// passendes LineChangeInterval finden  								NodeConnection.LineChangeInterval lci;  								currentConnection.lineChangeIntervals.TryGetValue(ln.hashcode' out lci);    								if (lci.length < Constants.minimumLineChangeLength)  									break;    								// f-Wert für den neuen Weg berechnen: g Wert des Vorgängers plus die Kosten der  								// gerade benutzten Kante plus die geschätzten Kosten von Nachfolger bis Ziel  								double f = currentNode.Value.parent.length;										// exakte Länge des bisher zurückgelegten Weges  								f += currentConnection.GetLengthToLineNodeViaLineChange(successor.node);    								// Kostenanteil' für den Spurwechsel dazuaddieren  								f += (lci.length < 2 * Constants.minimumLineChangeLength) ? 2 * Constants.lineChangePenalty : Constants.lineChangePenalty;    								// Anfangs-/ oder Endknoten des Spurwechsels ist eine Ampel => Kosten-Penalty' da hier verstärktes Verkehrsaufkommen zu erwarten ist  								if ((lci.targetNode.tLight != null) || (currentConnection.startNode.tLight != null))  									f += Constants.lineChangeBeforeTrafficLightPenalty;    								f += GetMinimumEuklidDistance(successor.node' targetNodes);						// Minimumweg zum Ziel (Luftlinie)  								f *= -1;      								// gucke' ob der Node schon in der Liste drin ist und wenn ja' dann evtl. rausschmeißen  								bool nodeInOpenlist = false;  								foreach (PriorityQueueItem<LineNode.LinkedLineNode' double> pqi in openlist)  									{  									if (pqi.Value.node == successor.node)  										{  										if (f <= pqi.Priority)  											nodeInOpenlist = true;  										else  											openlist.Remove(pqi.Value); // erst entfernen  										break;  										}  									}    								if (!nodeInOpenlist)  									{  									// Vorgängerzeiger setzen  									successor.parent = currentNode.Value;  									openlist.Enqueue(successor' f); // dann neu einfügen  									}  								}  							}  						}  					}      				#endregion    				#endregion    				// der aktuelle Knoten ist nun abschließend untersucht  				closedlist.Push(currentNode.Value);  				}  			while (openlist.Count != 0);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,SetupDockingStuff,The following statement contains a magic number: SetContentDefaultSettings(thumbContent' new Size(150' 150));
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,SetupDockingStuff,The following statement contains a magic number: SetContentDefaultSettings(thumbContent' new Size(150' 150));
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,SetupDockingStuff,The following statement contains a magic number: SetContentDefaultSettings(statisticsContent' new Size(196' 196));
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,SetupDockingStuff,The following statement contains a magic number: SetContentDefaultSettings(statisticsContent' new Size(196' 196));
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,SetupDockingStuff,The following statement contains a magic number: SetContentDefaultSettings(layersContent' new Size(196' 64));
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,SetupDockingStuff,The following statement contains a magic number: SetContentDefaultSettings(layersContent' new Size(196' 64));
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,SetupDockingStuff,The following statement contains a magic number: WindowContent dock2 = _dockingManager.AddContentToZone(thumbContent' dock0.ParentZone' 2) as WindowContent;
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,pnlLayers_Resize,The following statement contains a magic number: tlpLayers.ColumnStyles[0].Width = tlpLayers.ClientSize.Width - 150;
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,pnlLayers_Resize,The following statement contains a magic number: tlpLayers.ColumnStyles[1].Width = 65;
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,pnlLayers_Resize,The following statement contains a magic number: tlpLayers.ColumnStyles[2].SizeType = SizeType.Absolute;
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,pnlLayers_Resize,The following statement contains a magic number: tlpLayers.ColumnStyles[2].Width = 65;
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,pnlLayers_Resize,The following statement contains a magic number: tlpLayers.ColumnStyles[2].Width = 65;
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,pnlLayers_Resize,The following statement contains a magic number: btnAddLayer.Location = new System.Drawing.Point(pnlLayers.ClientSize.Width - btnAddLayer.Width - 24' tlpLayers.Height + 8);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,pnlLayers_Resize,The following statement contains a magic number: btnAddLayer.Location = new System.Drawing.Point(pnlLayers.ClientSize.Width - btnAddLayer.Width - 24' tlpLayers.Height + 8);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,pnlLayers_Resize_1,The following statement contains a magic number: btnAddLayer.Location = new System.Drawing.Point(pnlLayers.ClientSize.Width - btnAddLayer.Width - 24' tlpLayers.Height + 8);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,pnlLayers_Resize_1,The following statement contains a magic number: btnAddLayer.Location = new System.Drawing.Point(pnlLayers.ClientSize.Width - btnAddLayer.Width - 24' tlpLayers.Height + 8);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,nodeSteuerung_NetworkLayersChanged,The following statement contains a magic number: switch (e._invalidationLevel)  				{  				case NodeSteuerung.NetworkLayersChangedEventArgs.InvalidationLevel.ONLY_VISIBILITY_CHANGED:  					Invalidate(InvalidationLevel.ONLY_MAIN_CANVAS);  					break;  				default:  					// fist: update NetworkLayer combo box for LineNode setup  					cbNetworkLayer.Items.Clear();  					foreach (NetworkLayer nl in nodeSteuerung._networkLayers)  						{  						cbNetworkLayer.Items.Add(nl);  						}    					selectedLineNodes = selectedLineNodes;      					// then: update NetworkLayerGUI elements  					_networkLayerGUI.Clear();    					tlpLayers.SuspendLayout();  					tlpLayers.Controls.Clear();  					tlpLayers.RowStyles.Clear();    					tlpLayers.RowCount = nodeSteuerung._networkLayers.Count + 1;  					tlpLayers.Height = (tlpLayers.RowCount + 1) * 28;  					int i = 0;  					foreach (NetworkLayer nl in nodeSteuerung._networkLayers)  						{  						NetworkLayerGUI nlg = new NetworkLayerGUI(nodeSteuerung' nl);  						nlg.AddToPanel(tlpLayers' i);  						_networkLayerGUI.Add(nlg);  						++i;  						}    					tlpLayers.RowStyles.Add(new RowStyle(SizeType.AutoSize' 28));  					tlpLayers.ResumeLayout(true);  					break;  				}
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,nodeSteuerung_NetworkLayersChanged,The following statement contains a magic number: switch (e._invalidationLevel)  				{  				case NodeSteuerung.NetworkLayersChangedEventArgs.InvalidationLevel.ONLY_VISIBILITY_CHANGED:  					Invalidate(InvalidationLevel.ONLY_MAIN_CANVAS);  					break;  				default:  					// fist: update NetworkLayer combo box for LineNode setup  					cbNetworkLayer.Items.Clear();  					foreach (NetworkLayer nl in nodeSteuerung._networkLayers)  						{  						cbNetworkLayer.Items.Add(nl);  						}    					selectedLineNodes = selectedLineNodes;      					// then: update NetworkLayerGUI elements  					_networkLayerGUI.Clear();    					tlpLayers.SuspendLayout();  					tlpLayers.Controls.Clear();  					tlpLayers.RowStyles.Clear();    					tlpLayers.RowCount = nodeSteuerung._networkLayers.Count + 1;  					tlpLayers.Height = (tlpLayers.RowCount + 1) * 28;  					int i = 0;  					foreach (NetworkLayer nl in nodeSteuerung._networkLayers)  						{  						NetworkLayerGUI nlg = new NetworkLayerGUI(nodeSteuerung' nl);  						nlg.AddToPanel(tlpLayers' i);  						_networkLayerGUI.Add(nlg);  						++i;  						}    					tlpLayers.RowStyles.Add(new RowStyle(SizeType.AutoSize' 28));  					tlpLayers.ResumeLayout(true);  					break;  				}
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,MainForm,The following statement contains a magic number: timelineSteuerung.maxTime = 50;
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,MainForm,The following statement contains a magic number: zoomComboBox.SelectedIndex = 7;
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,MainForm,The following statement contains a magic number: renderOptionsDaGrid.clippingRect = new Rectangle(0' 0' 10000' 10000);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,MainForm,The following statement contains a magic number: renderOptionsDaGrid.clippingRect = new Rectangle(0' 0' 10000' 10000);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,thumbGrid_MouseDown,The following statement contains a magic number: if (!thumbGridClientRect.Contains(e.Location))  				{  				RectangleF bounds = nodeSteuerung.GetLineNodeBounds();  				float zoom = Math.Min(1.0f' Math.Min((float)thumbGrid.ClientSize.Width / bounds.Width' (float)thumbGrid.ClientSize.Height / bounds.Height));  				thumbGridClientRect.X = e.Location.X - thumbGridClientRect.Width / 2;  				thumbGridClientRect.Y = e.Location.Y - thumbGridClientRect.Height/2;    				daGridScrollPosition = new Point(  					(int)Math.Round((thumbGridClientRect.X / zoom) + bounds.X)'  					(int)Math.Round((thumbGridClientRect.Y / zoom) + bounds.Y));      				UpdateDaGridClippingRect();  				thumbGrid.Invalidate();  				DaGrid.Invalidate(true);  				}
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,thumbGrid_MouseDown,The following statement contains a magic number: if (!thumbGridClientRect.Contains(e.Location))  				{  				RectangleF bounds = nodeSteuerung.GetLineNodeBounds();  				float zoom = Math.Min(1.0f' Math.Min((float)thumbGrid.ClientSize.Width / bounds.Width' (float)thumbGrid.ClientSize.Height / bounds.Height));  				thumbGridClientRect.X = e.Location.X - thumbGridClientRect.Width / 2;  				thumbGridClientRect.Y = e.Location.Y - thumbGridClientRect.Height/2;    				daGridScrollPosition = new Point(  					(int)Math.Round((thumbGridClientRect.X / zoom) + bounds.X)'  					(int)Math.Round((thumbGridClientRect.Y / zoom) + bounds.Y));      				UpdateDaGridClippingRect();  				thumbGrid.Invalidate();  				DaGrid.Invalidate(true);  				}
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,DaGrid_MouseDown,The following statement contains a magic number: switch (e.Button)  				{  				case MouseButtons.Left:  					this.Cursor = Cursors.Default;    					#region Nodes hinzufügen  					if ((Control.ModifierKeys & Keys.Control) == Keys.Control)  						{  						// LineNode hinzufügen  						List<LineNode> nodesToAdd = new List<LineNode>(m_selectedLineNodes.Count);  						selectedLineNodesMovingOffset.Clear();    						// testen ob ein Node schon markiert ist  						if (selectedLineNodes.Count > 0)  							{  							// Mittelpunkt des selektierten LineNodes ermitteln  							Vector2 midpoint = new Vector2(0' 0);  							foreach (LineNode ln in selectedLineNodes)  								{  								midpoint += ln.position;  								}  							midpoint *= (double)1 / selectedLineNodes.Count;    							// Line Node nach SelectedLineNode einfügen  							if (!((Control.ModifierKeys & Keys.Shift) == Keys.Shift))  								{  								// ersten Line Node erstellen  								nodesToAdd.Add(new LineNode(DaGrid.DockToGrid(clickedPosition' dockToGrid)' cbNetworkLayer.SelectedItem as NetworkLayer' cbStopSign.Checked));  								selectedLineNodesMovingOffset.Add(m_selectedLineNodes[0].outSlope);    								// in/outSlope berechnen  								nodesToAdd[0].outSlope = 30 * Vector2.Normalize(nodesToAdd[0].position - midpoint);  								nodesToAdd[0].inSlope = -1 * nodesToAdd[0].outSlope;    								// Connecten  								nodeSteuerung.Connect(  									m_selectedLineNodes[0]'  									nodesToAdd[0]'  									(int)nodeConnectionPrioritySpinEdit.Value'  									(double)spinTargetVelocity.Value'  									carsAllowedCheckBox.Checked'  									busAllowedCheckBox.Checked'  									tramAllowedCheckBox.Checked'  									enableIncomingLineChangeCheckBox.Checked'  									enableOutgoingLineChangeCheckBox.Checked);      								// nun die restlichen LineNodes parallel erstellen  								for (int i = 1; i < m_selectedLineNodes.Count; i++)  									{  									Vector2 offset = m_selectedLineNodes[0].position - m_selectedLineNodes[i].position;  									selectedLineNodesMovingOffset.Add(offset);    									// Line Node erstellen  									nodesToAdd.Add(new LineNode(DaGrid.DockToGrid(clickedPosition - offset' dockToGrid)' cbNetworkLayer.SelectedItem as NetworkLayer' cbStopSign.Checked));    									// in/outSlope berechnen  									nodesToAdd[i].outSlope = 30 * Vector2.Normalize(nodesToAdd[i].position - midpoint);  									nodesToAdd[i].inSlope = -1 * nodesToAdd[i].outSlope;    									// Connecten  									nodeSteuerung.Connect(  										m_selectedLineNodes[i]'  										nodesToAdd[i]'  										(int)nodeConnectionPrioritySpinEdit.Value'  										(double)spinTargetVelocity.Value'  										carsAllowedCheckBox.Checked'  										busAllowedCheckBox.Checked'  										tramAllowedCheckBox.Checked'  										enableIncomingLineChangeCheckBox.Checked'  										enableOutgoingLineChangeCheckBox.Checked);    									}  								}  							// Line Node vor SelectedLineNode einfügen  							else  								{  								// ersten Line Node erstellen  								nodesToAdd.Add(new LineNode(DaGrid.DockToGrid(clickedPosition' dockToGrid)' cbNetworkLayer.SelectedItem as NetworkLayer' cbStopSign.Checked));  								selectedLineNodesMovingOffset.Add(m_selectedLineNodes[0].outSlope);      								// in/outSlope berechnen  								nodesToAdd[0].outSlope = 30 * Vector2.Normalize(nodesToAdd[0].position - midpoint);  								nodesToAdd[0].inSlope = -1 * nodesToAdd[0].outSlope;    								// Connecten  								nodeSteuerung.Connect(  									nodesToAdd[0]'  									m_selectedLineNodes[0]'  									(int)nodeConnectionPrioritySpinEdit.Value'  									(double)spinTargetVelocity.Value'  									carsAllowedCheckBox.Checked'  									busAllowedCheckBox.Checked'  									tramAllowedCheckBox.Checked'  									enableIncomingLineChangeCheckBox.Checked'  									enableOutgoingLineChangeCheckBox.Checked);      								// nun die restlichen LineNodes parallel erstellen  								for (int i = 1; i < m_selectedLineNodes.Count; i++)  									{  									Vector2 offset = m_selectedLineNodes[0].position - m_selectedLineNodes[i].position;  									selectedLineNodesMovingOffset.Add(offset);    									// Line Node erstellen  									nodesToAdd.Add(new LineNode(DaGrid.DockToGrid(clickedPosition - offset' dockToGrid)' cbNetworkLayer.SelectedItem as NetworkLayer' cbStopSign.Checked));    									// in/outSlope berechnen  									nodesToAdd[i].outSlope = 30 * Vector2.Normalize(nodesToAdd[i].position - midpoint);  									nodesToAdd[i].inSlope = -1 * nodesToAdd[i].outSlope;    									// Connecten  									nodeSteuerung.Connect(  										nodesToAdd[i]'  										m_selectedLineNodes[i]'  										(int)nodeConnectionPrioritySpinEdit.Value'  										(double)spinTargetVelocity.Value'  										carsAllowedCheckBox.Checked'  										busAllowedCheckBox.Checked'  										tramAllowedCheckBox.Checked'  										enableIncomingLineChangeCheckBox.Checked'  										enableOutgoingLineChangeCheckBox.Checked);    									}  								}  							}  						else  							{  							// ersten Line Node erstellen  							nodesToAdd.Add(new LineNode(DaGrid.DockToGrid(clickedPosition' dockToGrid)' cbNetworkLayer.SelectedItem as NetworkLayer' cbStopSign.Checked));  							selectedLineNodesMovingOffset.Add(new Vector2(0' 0));  							}    						previousSelectedNodePositions.Clear();  						foreach (LineNode ln in m_selectedLineNodes)  							{  							previousSelectedNodePositions.Add(ln.position);  							}    						selectedLineNodes.Clear();  						foreach (LineNode ln in nodesToAdd)  							{  							nodeSteuerung.AddLineNode(ln);  							selectedLineNodes.Add(ln);  							}  						howToDrag = DragNDrop.CREATE_NODE;  						}  					#endregion    					#region Nodes Verbinden  					else if (((Control.ModifierKeys & Keys.Alt) == Keys.Alt) && (selectedLineNodes != null))  						{  						LineNode nodeToConnectTo = nodeSteuerung.GetLineNodeAt(clickedPosition);    						if (nodeToConnectTo != null)  							{  							foreach (LineNode ln in selectedLineNodes)  								{  								nodeSteuerung.Connect(  									ln'   									nodeToConnectTo'   									(int)nodeConnectionPrioritySpinEdit.Value'  									(double)spinTargetVelocity.Value'  									carsAllowedCheckBox.Checked'   									busAllowedCheckBox.Checked'   									tramAllowedCheckBox.Checked'   									enableIncomingLineChangeCheckBox.Checked'  									enableOutgoingLineChangeCheckBox.Checked);  								}						  							}  						}  					#endregion    					#region Nodes selektieren bzw. verschieben  					else  						{  						bool found = false;    						if (!lockNodesCheckBox.Checked)  							{  							// erst gucken' ob evtl. In/OutSlopes angeklickt wurden  							if (selectedLineNodes != null && selectedLineNodes.Count >= 1)  								{  									if (m_selectedLineNodes[0].inSlopeRect.Contains(clickedPosition))  										{  										originalSlopes.Clear();  										foreach (LineNode ln in m_selectedLineNodes)  											{  											originalSlopes.Add(ln.inSlope);  											}  										  										howToDrag = DragNDrop.MOVE_IN_SLOPE;  										found = true;  										}  									if (m_selectedLineNodes[0].outSlopeRect.Contains(clickedPosition))  										{  										originalSlopes.Clear();  										foreach (LineNode ln in m_selectedLineNodes)  											{  											originalSlopes.Add(ln.outSlope);  											}    										howToDrag = DragNDrop.MOVE_OUT_SLOPE;  										found = true;  										}  								}  							}    						if (! found)  							{  							LineNode ln = nodeSteuerung.GetLineNodeAt(clickedPosition);  							if (ln != null && !lockNodesCheckBox.Checked)  								{  								if (selectedLineNodes.Contains(ln))  									{  									// MovingOffsets berechnen:  									selectedLineNodesMovingOffset.Clear();  									foreach (LineNode lln in m_selectedLineNodes)  										{  										selectedLineNodesMovingOffset.Add(lln.position - clickedPosition);  										}    									howToDrag = DragNDrop.MOVE_NODES;  									}  								else  									{  									// bei nur einem Punkt brauchen wir keine MovingOffsets  									selectedLineNodesMovingOffset.Clear();  									selectedLineNodesMovingOffset.Add(new Vector2(0' 0));    									// Häßlicher Workaround' um Settermethode für selectedLineNodes aufzurufen  									List<LineNode> foo = new List<LineNode>();   									foo.Add(ln);  									selectedLineNodes = foo;    									howToDrag = DragNDrop.MOVE_NODES;  									}  								}  							else  								{  								howToDrag = DragNDrop.DRAG_RUBBERBAND;    								daGridRubberband.Location = clickedPosition;  								daGridRubberband.Width = 1;  								daGridRubberband.Height = 1;  								}  							}  						}  					#endregion  					break;  				case MouseButtons.Right:  					if ((Control.ModifierKeys & Keys.Control) == Keys.Control)  						{  						#region Nodes löschen  						this.Cursor = Cursors.Default;  						// LineNode entfernen  						LineNode nodeToDelete = nodeSteuerung.GetLineNodeAt(clickedPosition);  						// checken ob gefunden  						if (nodeToDelete != null)  							{  							if (selectedLineNodes.Contains(nodeToDelete))  								{  								selectedLineNodes.Remove(nodeToDelete);  								}  							nodeSteuerung.DeleteLineNode(nodeToDelete);  							}  						#endregion  						}  					else  						{  						#region move main grid  						howToDrag = DragNDrop.MOVE_MAIN_GRID;  						daGridRubberband.Location = clickedPosition;  						this.Cursor = Cursors.SizeAll;  						#endregion  						}    					break;  				case MouseButtons.XButton1:  					daGridScrollPosition.Y += 10 * e.Delta;  					UpdateDaGridClippingRect();  					DaGrid.Invalidate();  					thumbGrid.Invalidate();  					break;  				}
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,DaGrid_MouseDown,The following statement contains a magic number: switch (e.Button)  				{  				case MouseButtons.Left:  					this.Cursor = Cursors.Default;    					#region Nodes hinzufügen  					if ((Control.ModifierKeys & Keys.Control) == Keys.Control)  						{  						// LineNode hinzufügen  						List<LineNode> nodesToAdd = new List<LineNode>(m_selectedLineNodes.Count);  						selectedLineNodesMovingOffset.Clear();    						// testen ob ein Node schon markiert ist  						if (selectedLineNodes.Count > 0)  							{  							// Mittelpunkt des selektierten LineNodes ermitteln  							Vector2 midpoint = new Vector2(0' 0);  							foreach (LineNode ln in selectedLineNodes)  								{  								midpoint += ln.position;  								}  							midpoint *= (double)1 / selectedLineNodes.Count;    							// Line Node nach SelectedLineNode einfügen  							if (!((Control.ModifierKeys & Keys.Shift) == Keys.Shift))  								{  								// ersten Line Node erstellen  								nodesToAdd.Add(new LineNode(DaGrid.DockToGrid(clickedPosition' dockToGrid)' cbNetworkLayer.SelectedItem as NetworkLayer' cbStopSign.Checked));  								selectedLineNodesMovingOffset.Add(m_selectedLineNodes[0].outSlope);    								// in/outSlope berechnen  								nodesToAdd[0].outSlope = 30 * Vector2.Normalize(nodesToAdd[0].position - midpoint);  								nodesToAdd[0].inSlope = -1 * nodesToAdd[0].outSlope;    								// Connecten  								nodeSteuerung.Connect(  									m_selectedLineNodes[0]'  									nodesToAdd[0]'  									(int)nodeConnectionPrioritySpinEdit.Value'  									(double)spinTargetVelocity.Value'  									carsAllowedCheckBox.Checked'  									busAllowedCheckBox.Checked'  									tramAllowedCheckBox.Checked'  									enableIncomingLineChangeCheckBox.Checked'  									enableOutgoingLineChangeCheckBox.Checked);      								// nun die restlichen LineNodes parallel erstellen  								for (int i = 1; i < m_selectedLineNodes.Count; i++)  									{  									Vector2 offset = m_selectedLineNodes[0].position - m_selectedLineNodes[i].position;  									selectedLineNodesMovingOffset.Add(offset);    									// Line Node erstellen  									nodesToAdd.Add(new LineNode(DaGrid.DockToGrid(clickedPosition - offset' dockToGrid)' cbNetworkLayer.SelectedItem as NetworkLayer' cbStopSign.Checked));    									// in/outSlope berechnen  									nodesToAdd[i].outSlope = 30 * Vector2.Normalize(nodesToAdd[i].position - midpoint);  									nodesToAdd[i].inSlope = -1 * nodesToAdd[i].outSlope;    									// Connecten  									nodeSteuerung.Connect(  										m_selectedLineNodes[i]'  										nodesToAdd[i]'  										(int)nodeConnectionPrioritySpinEdit.Value'  										(double)spinTargetVelocity.Value'  										carsAllowedCheckBox.Checked'  										busAllowedCheckBox.Checked'  										tramAllowedCheckBox.Checked'  										enableIncomingLineChangeCheckBox.Checked'  										enableOutgoingLineChangeCheckBox.Checked);    									}  								}  							// Line Node vor SelectedLineNode einfügen  							else  								{  								// ersten Line Node erstellen  								nodesToAdd.Add(new LineNode(DaGrid.DockToGrid(clickedPosition' dockToGrid)' cbNetworkLayer.SelectedItem as NetworkLayer' cbStopSign.Checked));  								selectedLineNodesMovingOffset.Add(m_selectedLineNodes[0].outSlope);      								// in/outSlope berechnen  								nodesToAdd[0].outSlope = 30 * Vector2.Normalize(nodesToAdd[0].position - midpoint);  								nodesToAdd[0].inSlope = -1 * nodesToAdd[0].outSlope;    								// Connecten  								nodeSteuerung.Connect(  									nodesToAdd[0]'  									m_selectedLineNodes[0]'  									(int)nodeConnectionPrioritySpinEdit.Value'  									(double)spinTargetVelocity.Value'  									carsAllowedCheckBox.Checked'  									busAllowedCheckBox.Checked'  									tramAllowedCheckBox.Checked'  									enableIncomingLineChangeCheckBox.Checked'  									enableOutgoingLineChangeCheckBox.Checked);      								// nun die restlichen LineNodes parallel erstellen  								for (int i = 1; i < m_selectedLineNodes.Count; i++)  									{  									Vector2 offset = m_selectedLineNodes[0].position - m_selectedLineNodes[i].position;  									selectedLineNodesMovingOffset.Add(offset);    									// Line Node erstellen  									nodesToAdd.Add(new LineNode(DaGrid.DockToGrid(clickedPosition - offset' dockToGrid)' cbNetworkLayer.SelectedItem as NetworkLayer' cbStopSign.Checked));    									// in/outSlope berechnen  									nodesToAdd[i].outSlope = 30 * Vector2.Normalize(nodesToAdd[i].position - midpoint);  									nodesToAdd[i].inSlope = -1 * nodesToAdd[i].outSlope;    									// Connecten  									nodeSteuerung.Connect(  										nodesToAdd[i]'  										m_selectedLineNodes[i]'  										(int)nodeConnectionPrioritySpinEdit.Value'  										(double)spinTargetVelocity.Value'  										carsAllowedCheckBox.Checked'  										busAllowedCheckBox.Checked'  										tramAllowedCheckBox.Checked'  										enableIncomingLineChangeCheckBox.Checked'  										enableOutgoingLineChangeCheckBox.Checked);    									}  								}  							}  						else  							{  							// ersten Line Node erstellen  							nodesToAdd.Add(new LineNode(DaGrid.DockToGrid(clickedPosition' dockToGrid)' cbNetworkLayer.SelectedItem as NetworkLayer' cbStopSign.Checked));  							selectedLineNodesMovingOffset.Add(new Vector2(0' 0));  							}    						previousSelectedNodePositions.Clear();  						foreach (LineNode ln in m_selectedLineNodes)  							{  							previousSelectedNodePositions.Add(ln.position);  							}    						selectedLineNodes.Clear();  						foreach (LineNode ln in nodesToAdd)  							{  							nodeSteuerung.AddLineNode(ln);  							selectedLineNodes.Add(ln);  							}  						howToDrag = DragNDrop.CREATE_NODE;  						}  					#endregion    					#region Nodes Verbinden  					else if (((Control.ModifierKeys & Keys.Alt) == Keys.Alt) && (selectedLineNodes != null))  						{  						LineNode nodeToConnectTo = nodeSteuerung.GetLineNodeAt(clickedPosition);    						if (nodeToConnectTo != null)  							{  							foreach (LineNode ln in selectedLineNodes)  								{  								nodeSteuerung.Connect(  									ln'   									nodeToConnectTo'   									(int)nodeConnectionPrioritySpinEdit.Value'  									(double)spinTargetVelocity.Value'  									carsAllowedCheckBox.Checked'   									busAllowedCheckBox.Checked'   									tramAllowedCheckBox.Checked'   									enableIncomingLineChangeCheckBox.Checked'  									enableOutgoingLineChangeCheckBox.Checked);  								}						  							}  						}  					#endregion    					#region Nodes selektieren bzw. verschieben  					else  						{  						bool found = false;    						if (!lockNodesCheckBox.Checked)  							{  							// erst gucken' ob evtl. In/OutSlopes angeklickt wurden  							if (selectedLineNodes != null && selectedLineNodes.Count >= 1)  								{  									if (m_selectedLineNodes[0].inSlopeRect.Contains(clickedPosition))  										{  										originalSlopes.Clear();  										foreach (LineNode ln in m_selectedLineNodes)  											{  											originalSlopes.Add(ln.inSlope);  											}  										  										howToDrag = DragNDrop.MOVE_IN_SLOPE;  										found = true;  										}  									if (m_selectedLineNodes[0].outSlopeRect.Contains(clickedPosition))  										{  										originalSlopes.Clear();  										foreach (LineNode ln in m_selectedLineNodes)  											{  											originalSlopes.Add(ln.outSlope);  											}    										howToDrag = DragNDrop.MOVE_OUT_SLOPE;  										found = true;  										}  								}  							}    						if (! found)  							{  							LineNode ln = nodeSteuerung.GetLineNodeAt(clickedPosition);  							if (ln != null && !lockNodesCheckBox.Checked)  								{  								if (selectedLineNodes.Contains(ln))  									{  									// MovingOffsets berechnen:  									selectedLineNodesMovingOffset.Clear();  									foreach (LineNode lln in m_selectedLineNodes)  										{  										selectedLineNodesMovingOffset.Add(lln.position - clickedPosition);  										}    									howToDrag = DragNDrop.MOVE_NODES;  									}  								else  									{  									// bei nur einem Punkt brauchen wir keine MovingOffsets  									selectedLineNodesMovingOffset.Clear();  									selectedLineNodesMovingOffset.Add(new Vector2(0' 0));    									// Häßlicher Workaround' um Settermethode für selectedLineNodes aufzurufen  									List<LineNode> foo = new List<LineNode>();   									foo.Add(ln);  									selectedLineNodes = foo;    									howToDrag = DragNDrop.MOVE_NODES;  									}  								}  							else  								{  								howToDrag = DragNDrop.DRAG_RUBBERBAND;    								daGridRubberband.Location = clickedPosition;  								daGridRubberband.Width = 1;  								daGridRubberband.Height = 1;  								}  							}  						}  					#endregion  					break;  				case MouseButtons.Right:  					if ((Control.ModifierKeys & Keys.Control) == Keys.Control)  						{  						#region Nodes löschen  						this.Cursor = Cursors.Default;  						// LineNode entfernen  						LineNode nodeToDelete = nodeSteuerung.GetLineNodeAt(clickedPosition);  						// checken ob gefunden  						if (nodeToDelete != null)  							{  							if (selectedLineNodes.Contains(nodeToDelete))  								{  								selectedLineNodes.Remove(nodeToDelete);  								}  							nodeSteuerung.DeleteLineNode(nodeToDelete);  							}  						#endregion  						}  					else  						{  						#region move main grid  						howToDrag = DragNDrop.MOVE_MAIN_GRID;  						daGridRubberband.Location = clickedPosition;  						this.Cursor = Cursors.SizeAll;  						#endregion  						}    					break;  				case MouseButtons.XButton1:  					daGridScrollPosition.Y += 10 * e.Delta;  					UpdateDaGridClippingRect();  					DaGrid.Invalidate();  					thumbGrid.Invalidate();  					break;  				}
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,DaGrid_MouseDown,The following statement contains a magic number: switch (e.Button)  				{  				case MouseButtons.Left:  					this.Cursor = Cursors.Default;    					#region Nodes hinzufügen  					if ((Control.ModifierKeys & Keys.Control) == Keys.Control)  						{  						// LineNode hinzufügen  						List<LineNode> nodesToAdd = new List<LineNode>(m_selectedLineNodes.Count);  						selectedLineNodesMovingOffset.Clear();    						// testen ob ein Node schon markiert ist  						if (selectedLineNodes.Count > 0)  							{  							// Mittelpunkt des selektierten LineNodes ermitteln  							Vector2 midpoint = new Vector2(0' 0);  							foreach (LineNode ln in selectedLineNodes)  								{  								midpoint += ln.position;  								}  							midpoint *= (double)1 / selectedLineNodes.Count;    							// Line Node nach SelectedLineNode einfügen  							if (!((Control.ModifierKeys & Keys.Shift) == Keys.Shift))  								{  								// ersten Line Node erstellen  								nodesToAdd.Add(new LineNode(DaGrid.DockToGrid(clickedPosition' dockToGrid)' cbNetworkLayer.SelectedItem as NetworkLayer' cbStopSign.Checked));  								selectedLineNodesMovingOffset.Add(m_selectedLineNodes[0].outSlope);    								// in/outSlope berechnen  								nodesToAdd[0].outSlope = 30 * Vector2.Normalize(nodesToAdd[0].position - midpoint);  								nodesToAdd[0].inSlope = -1 * nodesToAdd[0].outSlope;    								// Connecten  								nodeSteuerung.Connect(  									m_selectedLineNodes[0]'  									nodesToAdd[0]'  									(int)nodeConnectionPrioritySpinEdit.Value'  									(double)spinTargetVelocity.Value'  									carsAllowedCheckBox.Checked'  									busAllowedCheckBox.Checked'  									tramAllowedCheckBox.Checked'  									enableIncomingLineChangeCheckBox.Checked'  									enableOutgoingLineChangeCheckBox.Checked);      								// nun die restlichen LineNodes parallel erstellen  								for (int i = 1; i < m_selectedLineNodes.Count; i++)  									{  									Vector2 offset = m_selectedLineNodes[0].position - m_selectedLineNodes[i].position;  									selectedLineNodesMovingOffset.Add(offset);    									// Line Node erstellen  									nodesToAdd.Add(new LineNode(DaGrid.DockToGrid(clickedPosition - offset' dockToGrid)' cbNetworkLayer.SelectedItem as NetworkLayer' cbStopSign.Checked));    									// in/outSlope berechnen  									nodesToAdd[i].outSlope = 30 * Vector2.Normalize(nodesToAdd[i].position - midpoint);  									nodesToAdd[i].inSlope = -1 * nodesToAdd[i].outSlope;    									// Connecten  									nodeSteuerung.Connect(  										m_selectedLineNodes[i]'  										nodesToAdd[i]'  										(int)nodeConnectionPrioritySpinEdit.Value'  										(double)spinTargetVelocity.Value'  										carsAllowedCheckBox.Checked'  										busAllowedCheckBox.Checked'  										tramAllowedCheckBox.Checked'  										enableIncomingLineChangeCheckBox.Checked'  										enableOutgoingLineChangeCheckBox.Checked);    									}  								}  							// Line Node vor SelectedLineNode einfügen  							else  								{  								// ersten Line Node erstellen  								nodesToAdd.Add(new LineNode(DaGrid.DockToGrid(clickedPosition' dockToGrid)' cbNetworkLayer.SelectedItem as NetworkLayer' cbStopSign.Checked));  								selectedLineNodesMovingOffset.Add(m_selectedLineNodes[0].outSlope);      								// in/outSlope berechnen  								nodesToAdd[0].outSlope = 30 * Vector2.Normalize(nodesToAdd[0].position - midpoint);  								nodesToAdd[0].inSlope = -1 * nodesToAdd[0].outSlope;    								// Connecten  								nodeSteuerung.Connect(  									nodesToAdd[0]'  									m_selectedLineNodes[0]'  									(int)nodeConnectionPrioritySpinEdit.Value'  									(double)spinTargetVelocity.Value'  									carsAllowedCheckBox.Checked'  									busAllowedCheckBox.Checked'  									tramAllowedCheckBox.Checked'  									enableIncomingLineChangeCheckBox.Checked'  									enableOutgoingLineChangeCheckBox.Checked);      								// nun die restlichen LineNodes parallel erstellen  								for (int i = 1; i < m_selectedLineNodes.Count; i++)  									{  									Vector2 offset = m_selectedLineNodes[0].position - m_selectedLineNodes[i].position;  									selectedLineNodesMovingOffset.Add(offset);    									// Line Node erstellen  									nodesToAdd.Add(new LineNode(DaGrid.DockToGrid(clickedPosition - offset' dockToGrid)' cbNetworkLayer.SelectedItem as NetworkLayer' cbStopSign.Checked));    									// in/outSlope berechnen  									nodesToAdd[i].outSlope = 30 * Vector2.Normalize(nodesToAdd[i].position - midpoint);  									nodesToAdd[i].inSlope = -1 * nodesToAdd[i].outSlope;    									// Connecten  									nodeSteuerung.Connect(  										nodesToAdd[i]'  										m_selectedLineNodes[i]'  										(int)nodeConnectionPrioritySpinEdit.Value'  										(double)spinTargetVelocity.Value'  										carsAllowedCheckBox.Checked'  										busAllowedCheckBox.Checked'  										tramAllowedCheckBox.Checked'  										enableIncomingLineChangeCheckBox.Checked'  										enableOutgoingLineChangeCheckBox.Checked);    									}  								}  							}  						else  							{  							// ersten Line Node erstellen  							nodesToAdd.Add(new LineNode(DaGrid.DockToGrid(clickedPosition' dockToGrid)' cbNetworkLayer.SelectedItem as NetworkLayer' cbStopSign.Checked));  							selectedLineNodesMovingOffset.Add(new Vector2(0' 0));  							}    						previousSelectedNodePositions.Clear();  						foreach (LineNode ln in m_selectedLineNodes)  							{  							previousSelectedNodePositions.Add(ln.position);  							}    						selectedLineNodes.Clear();  						foreach (LineNode ln in nodesToAdd)  							{  							nodeSteuerung.AddLineNode(ln);  							selectedLineNodes.Add(ln);  							}  						howToDrag = DragNDrop.CREATE_NODE;  						}  					#endregion    					#region Nodes Verbinden  					else if (((Control.ModifierKeys & Keys.Alt) == Keys.Alt) && (selectedLineNodes != null))  						{  						LineNode nodeToConnectTo = nodeSteuerung.GetLineNodeAt(clickedPosition);    						if (nodeToConnectTo != null)  							{  							foreach (LineNode ln in selectedLineNodes)  								{  								nodeSteuerung.Connect(  									ln'   									nodeToConnectTo'   									(int)nodeConnectionPrioritySpinEdit.Value'  									(double)spinTargetVelocity.Value'  									carsAllowedCheckBox.Checked'   									busAllowedCheckBox.Checked'   									tramAllowedCheckBox.Checked'   									enableIncomingLineChangeCheckBox.Checked'  									enableOutgoingLineChangeCheckBox.Checked);  								}						  							}  						}  					#endregion    					#region Nodes selektieren bzw. verschieben  					else  						{  						bool found = false;    						if (!lockNodesCheckBox.Checked)  							{  							// erst gucken' ob evtl. In/OutSlopes angeklickt wurden  							if (selectedLineNodes != null && selectedLineNodes.Count >= 1)  								{  									if (m_selectedLineNodes[0].inSlopeRect.Contains(clickedPosition))  										{  										originalSlopes.Clear();  										foreach (LineNode ln in m_selectedLineNodes)  											{  											originalSlopes.Add(ln.inSlope);  											}  										  										howToDrag = DragNDrop.MOVE_IN_SLOPE;  										found = true;  										}  									if (m_selectedLineNodes[0].outSlopeRect.Contains(clickedPosition))  										{  										originalSlopes.Clear();  										foreach (LineNode ln in m_selectedLineNodes)  											{  											originalSlopes.Add(ln.outSlope);  											}    										howToDrag = DragNDrop.MOVE_OUT_SLOPE;  										found = true;  										}  								}  							}    						if (! found)  							{  							LineNode ln = nodeSteuerung.GetLineNodeAt(clickedPosition);  							if (ln != null && !lockNodesCheckBox.Checked)  								{  								if (selectedLineNodes.Contains(ln))  									{  									// MovingOffsets berechnen:  									selectedLineNodesMovingOffset.Clear();  									foreach (LineNode lln in m_selectedLineNodes)  										{  										selectedLineNodesMovingOffset.Add(lln.position - clickedPosition);  										}    									howToDrag = DragNDrop.MOVE_NODES;  									}  								else  									{  									// bei nur einem Punkt brauchen wir keine MovingOffsets  									selectedLineNodesMovingOffset.Clear();  									selectedLineNodesMovingOffset.Add(new Vector2(0' 0));    									// Häßlicher Workaround' um Settermethode für selectedLineNodes aufzurufen  									List<LineNode> foo = new List<LineNode>();   									foo.Add(ln);  									selectedLineNodes = foo;    									howToDrag = DragNDrop.MOVE_NODES;  									}  								}  							else  								{  								howToDrag = DragNDrop.DRAG_RUBBERBAND;    								daGridRubberband.Location = clickedPosition;  								daGridRubberband.Width = 1;  								daGridRubberband.Height = 1;  								}  							}  						}  					#endregion  					break;  				case MouseButtons.Right:  					if ((Control.ModifierKeys & Keys.Control) == Keys.Control)  						{  						#region Nodes löschen  						this.Cursor = Cursors.Default;  						// LineNode entfernen  						LineNode nodeToDelete = nodeSteuerung.GetLineNodeAt(clickedPosition);  						// checken ob gefunden  						if (nodeToDelete != null)  							{  							if (selectedLineNodes.Contains(nodeToDelete))  								{  								selectedLineNodes.Remove(nodeToDelete);  								}  							nodeSteuerung.DeleteLineNode(nodeToDelete);  							}  						#endregion  						}  					else  						{  						#region move main grid  						howToDrag = DragNDrop.MOVE_MAIN_GRID;  						daGridRubberband.Location = clickedPosition;  						this.Cursor = Cursors.SizeAll;  						#endregion  						}    					break;  				case MouseButtons.XButton1:  					daGridScrollPosition.Y += 10 * e.Delta;  					UpdateDaGridClippingRect();  					DaGrid.Invalidate();  					thumbGrid.Invalidate();  					break;  				}
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,DaGrid_MouseDown,The following statement contains a magic number: switch (e.Button)  				{  				case MouseButtons.Left:  					this.Cursor = Cursors.Default;    					#region Nodes hinzufügen  					if ((Control.ModifierKeys & Keys.Control) == Keys.Control)  						{  						// LineNode hinzufügen  						List<LineNode> nodesToAdd = new List<LineNode>(m_selectedLineNodes.Count);  						selectedLineNodesMovingOffset.Clear();    						// testen ob ein Node schon markiert ist  						if (selectedLineNodes.Count > 0)  							{  							// Mittelpunkt des selektierten LineNodes ermitteln  							Vector2 midpoint = new Vector2(0' 0);  							foreach (LineNode ln in selectedLineNodes)  								{  								midpoint += ln.position;  								}  							midpoint *= (double)1 / selectedLineNodes.Count;    							// Line Node nach SelectedLineNode einfügen  							if (!((Control.ModifierKeys & Keys.Shift) == Keys.Shift))  								{  								// ersten Line Node erstellen  								nodesToAdd.Add(new LineNode(DaGrid.DockToGrid(clickedPosition' dockToGrid)' cbNetworkLayer.SelectedItem as NetworkLayer' cbStopSign.Checked));  								selectedLineNodesMovingOffset.Add(m_selectedLineNodes[0].outSlope);    								// in/outSlope berechnen  								nodesToAdd[0].outSlope = 30 * Vector2.Normalize(nodesToAdd[0].position - midpoint);  								nodesToAdd[0].inSlope = -1 * nodesToAdd[0].outSlope;    								// Connecten  								nodeSteuerung.Connect(  									m_selectedLineNodes[0]'  									nodesToAdd[0]'  									(int)nodeConnectionPrioritySpinEdit.Value'  									(double)spinTargetVelocity.Value'  									carsAllowedCheckBox.Checked'  									busAllowedCheckBox.Checked'  									tramAllowedCheckBox.Checked'  									enableIncomingLineChangeCheckBox.Checked'  									enableOutgoingLineChangeCheckBox.Checked);      								// nun die restlichen LineNodes parallel erstellen  								for (int i = 1; i < m_selectedLineNodes.Count; i++)  									{  									Vector2 offset = m_selectedLineNodes[0].position - m_selectedLineNodes[i].position;  									selectedLineNodesMovingOffset.Add(offset);    									// Line Node erstellen  									nodesToAdd.Add(new LineNode(DaGrid.DockToGrid(clickedPosition - offset' dockToGrid)' cbNetworkLayer.SelectedItem as NetworkLayer' cbStopSign.Checked));    									// in/outSlope berechnen  									nodesToAdd[i].outSlope = 30 * Vector2.Normalize(nodesToAdd[i].position - midpoint);  									nodesToAdd[i].inSlope = -1 * nodesToAdd[i].outSlope;    									// Connecten  									nodeSteuerung.Connect(  										m_selectedLineNodes[i]'  										nodesToAdd[i]'  										(int)nodeConnectionPrioritySpinEdit.Value'  										(double)spinTargetVelocity.Value'  										carsAllowedCheckBox.Checked'  										busAllowedCheckBox.Checked'  										tramAllowedCheckBox.Checked'  										enableIncomingLineChangeCheckBox.Checked'  										enableOutgoingLineChangeCheckBox.Checked);    									}  								}  							// Line Node vor SelectedLineNode einfügen  							else  								{  								// ersten Line Node erstellen  								nodesToAdd.Add(new LineNode(DaGrid.DockToGrid(clickedPosition' dockToGrid)' cbNetworkLayer.SelectedItem as NetworkLayer' cbStopSign.Checked));  								selectedLineNodesMovingOffset.Add(m_selectedLineNodes[0].outSlope);      								// in/outSlope berechnen  								nodesToAdd[0].outSlope = 30 * Vector2.Normalize(nodesToAdd[0].position - midpoint);  								nodesToAdd[0].inSlope = -1 * nodesToAdd[0].outSlope;    								// Connecten  								nodeSteuerung.Connect(  									nodesToAdd[0]'  									m_selectedLineNodes[0]'  									(int)nodeConnectionPrioritySpinEdit.Value'  									(double)spinTargetVelocity.Value'  									carsAllowedCheckBox.Checked'  									busAllowedCheckBox.Checked'  									tramAllowedCheckBox.Checked'  									enableIncomingLineChangeCheckBox.Checked'  									enableOutgoingLineChangeCheckBox.Checked);      								// nun die restlichen LineNodes parallel erstellen  								for (int i = 1; i < m_selectedLineNodes.Count; i++)  									{  									Vector2 offset = m_selectedLineNodes[0].position - m_selectedLineNodes[i].position;  									selectedLineNodesMovingOffset.Add(offset);    									// Line Node erstellen  									nodesToAdd.Add(new LineNode(DaGrid.DockToGrid(clickedPosition - offset' dockToGrid)' cbNetworkLayer.SelectedItem as NetworkLayer' cbStopSign.Checked));    									// in/outSlope berechnen  									nodesToAdd[i].outSlope = 30 * Vector2.Normalize(nodesToAdd[i].position - midpoint);  									nodesToAdd[i].inSlope = -1 * nodesToAdd[i].outSlope;    									// Connecten  									nodeSteuerung.Connect(  										nodesToAdd[i]'  										m_selectedLineNodes[i]'  										(int)nodeConnectionPrioritySpinEdit.Value'  										(double)spinTargetVelocity.Value'  										carsAllowedCheckBox.Checked'  										busAllowedCheckBox.Checked'  										tramAllowedCheckBox.Checked'  										enableIncomingLineChangeCheckBox.Checked'  										enableOutgoingLineChangeCheckBox.Checked);    									}  								}  							}  						else  							{  							// ersten Line Node erstellen  							nodesToAdd.Add(new LineNode(DaGrid.DockToGrid(clickedPosition' dockToGrid)' cbNetworkLayer.SelectedItem as NetworkLayer' cbStopSign.Checked));  							selectedLineNodesMovingOffset.Add(new Vector2(0' 0));  							}    						previousSelectedNodePositions.Clear();  						foreach (LineNode ln in m_selectedLineNodes)  							{  							previousSelectedNodePositions.Add(ln.position);  							}    						selectedLineNodes.Clear();  						foreach (LineNode ln in nodesToAdd)  							{  							nodeSteuerung.AddLineNode(ln);  							selectedLineNodes.Add(ln);  							}  						howToDrag = DragNDrop.CREATE_NODE;  						}  					#endregion    					#region Nodes Verbinden  					else if (((Control.ModifierKeys & Keys.Alt) == Keys.Alt) && (selectedLineNodes != null))  						{  						LineNode nodeToConnectTo = nodeSteuerung.GetLineNodeAt(clickedPosition);    						if (nodeToConnectTo != null)  							{  							foreach (LineNode ln in selectedLineNodes)  								{  								nodeSteuerung.Connect(  									ln'   									nodeToConnectTo'   									(int)nodeConnectionPrioritySpinEdit.Value'  									(double)spinTargetVelocity.Value'  									carsAllowedCheckBox.Checked'   									busAllowedCheckBox.Checked'   									tramAllowedCheckBox.Checked'   									enableIncomingLineChangeCheckBox.Checked'  									enableOutgoingLineChangeCheckBox.Checked);  								}						  							}  						}  					#endregion    					#region Nodes selektieren bzw. verschieben  					else  						{  						bool found = false;    						if (!lockNodesCheckBox.Checked)  							{  							// erst gucken' ob evtl. In/OutSlopes angeklickt wurden  							if (selectedLineNodes != null && selectedLineNodes.Count >= 1)  								{  									if (m_selectedLineNodes[0].inSlopeRect.Contains(clickedPosition))  										{  										originalSlopes.Clear();  										foreach (LineNode ln in m_selectedLineNodes)  											{  											originalSlopes.Add(ln.inSlope);  											}  										  										howToDrag = DragNDrop.MOVE_IN_SLOPE;  										found = true;  										}  									if (m_selectedLineNodes[0].outSlopeRect.Contains(clickedPosition))  										{  										originalSlopes.Clear();  										foreach (LineNode ln in m_selectedLineNodes)  											{  											originalSlopes.Add(ln.outSlope);  											}    										howToDrag = DragNDrop.MOVE_OUT_SLOPE;  										found = true;  										}  								}  							}    						if (! found)  							{  							LineNode ln = nodeSteuerung.GetLineNodeAt(clickedPosition);  							if (ln != null && !lockNodesCheckBox.Checked)  								{  								if (selectedLineNodes.Contains(ln))  									{  									// MovingOffsets berechnen:  									selectedLineNodesMovingOffset.Clear();  									foreach (LineNode lln in m_selectedLineNodes)  										{  										selectedLineNodesMovingOffset.Add(lln.position - clickedPosition);  										}    									howToDrag = DragNDrop.MOVE_NODES;  									}  								else  									{  									// bei nur einem Punkt brauchen wir keine MovingOffsets  									selectedLineNodesMovingOffset.Clear();  									selectedLineNodesMovingOffset.Add(new Vector2(0' 0));    									// Häßlicher Workaround' um Settermethode für selectedLineNodes aufzurufen  									List<LineNode> foo = new List<LineNode>();   									foo.Add(ln);  									selectedLineNodes = foo;    									howToDrag = DragNDrop.MOVE_NODES;  									}  								}  							else  								{  								howToDrag = DragNDrop.DRAG_RUBBERBAND;    								daGridRubberband.Location = clickedPosition;  								daGridRubberband.Width = 1;  								daGridRubberband.Height = 1;  								}  							}  						}  					#endregion  					break;  				case MouseButtons.Right:  					if ((Control.ModifierKeys & Keys.Control) == Keys.Control)  						{  						#region Nodes löschen  						this.Cursor = Cursors.Default;  						// LineNode entfernen  						LineNode nodeToDelete = nodeSteuerung.GetLineNodeAt(clickedPosition);  						// checken ob gefunden  						if (nodeToDelete != null)  							{  							if (selectedLineNodes.Contains(nodeToDelete))  								{  								selectedLineNodes.Remove(nodeToDelete);  								}  							nodeSteuerung.DeleteLineNode(nodeToDelete);  							}  						#endregion  						}  					else  						{  						#region move main grid  						howToDrag = DragNDrop.MOVE_MAIN_GRID;  						daGridRubberband.Location = clickedPosition;  						this.Cursor = Cursors.SizeAll;  						#endregion  						}    					break;  				case MouseButtons.XButton1:  					daGridScrollPosition.Y += 10 * e.Delta;  					UpdateDaGridClippingRect();  					DaGrid.Invalidate();  					thumbGrid.Invalidate();  					break;  				}
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,DaGrid_MouseDown,The following statement contains a magic number: switch (e.Button)  				{  				case MouseButtons.Left:  					this.Cursor = Cursors.Default;    					#region Nodes hinzufügen  					if ((Control.ModifierKeys & Keys.Control) == Keys.Control)  						{  						// LineNode hinzufügen  						List<LineNode> nodesToAdd = new List<LineNode>(m_selectedLineNodes.Count);  						selectedLineNodesMovingOffset.Clear();    						// testen ob ein Node schon markiert ist  						if (selectedLineNodes.Count > 0)  							{  							// Mittelpunkt des selektierten LineNodes ermitteln  							Vector2 midpoint = new Vector2(0' 0);  							foreach (LineNode ln in selectedLineNodes)  								{  								midpoint += ln.position;  								}  							midpoint *= (double)1 / selectedLineNodes.Count;    							// Line Node nach SelectedLineNode einfügen  							if (!((Control.ModifierKeys & Keys.Shift) == Keys.Shift))  								{  								// ersten Line Node erstellen  								nodesToAdd.Add(new LineNode(DaGrid.DockToGrid(clickedPosition' dockToGrid)' cbNetworkLayer.SelectedItem as NetworkLayer' cbStopSign.Checked));  								selectedLineNodesMovingOffset.Add(m_selectedLineNodes[0].outSlope);    								// in/outSlope berechnen  								nodesToAdd[0].outSlope = 30 * Vector2.Normalize(nodesToAdd[0].position - midpoint);  								nodesToAdd[0].inSlope = -1 * nodesToAdd[0].outSlope;    								// Connecten  								nodeSteuerung.Connect(  									m_selectedLineNodes[0]'  									nodesToAdd[0]'  									(int)nodeConnectionPrioritySpinEdit.Value'  									(double)spinTargetVelocity.Value'  									carsAllowedCheckBox.Checked'  									busAllowedCheckBox.Checked'  									tramAllowedCheckBox.Checked'  									enableIncomingLineChangeCheckBox.Checked'  									enableOutgoingLineChangeCheckBox.Checked);      								// nun die restlichen LineNodes parallel erstellen  								for (int i = 1; i < m_selectedLineNodes.Count; i++)  									{  									Vector2 offset = m_selectedLineNodes[0].position - m_selectedLineNodes[i].position;  									selectedLineNodesMovingOffset.Add(offset);    									// Line Node erstellen  									nodesToAdd.Add(new LineNode(DaGrid.DockToGrid(clickedPosition - offset' dockToGrid)' cbNetworkLayer.SelectedItem as NetworkLayer' cbStopSign.Checked));    									// in/outSlope berechnen  									nodesToAdd[i].outSlope = 30 * Vector2.Normalize(nodesToAdd[i].position - midpoint);  									nodesToAdd[i].inSlope = -1 * nodesToAdd[i].outSlope;    									// Connecten  									nodeSteuerung.Connect(  										m_selectedLineNodes[i]'  										nodesToAdd[i]'  										(int)nodeConnectionPrioritySpinEdit.Value'  										(double)spinTargetVelocity.Value'  										carsAllowedCheckBox.Checked'  										busAllowedCheckBox.Checked'  										tramAllowedCheckBox.Checked'  										enableIncomingLineChangeCheckBox.Checked'  										enableOutgoingLineChangeCheckBox.Checked);    									}  								}  							// Line Node vor SelectedLineNode einfügen  							else  								{  								// ersten Line Node erstellen  								nodesToAdd.Add(new LineNode(DaGrid.DockToGrid(clickedPosition' dockToGrid)' cbNetworkLayer.SelectedItem as NetworkLayer' cbStopSign.Checked));  								selectedLineNodesMovingOffset.Add(m_selectedLineNodes[0].outSlope);      								// in/outSlope berechnen  								nodesToAdd[0].outSlope = 30 * Vector2.Normalize(nodesToAdd[0].position - midpoint);  								nodesToAdd[0].inSlope = -1 * nodesToAdd[0].outSlope;    								// Connecten  								nodeSteuerung.Connect(  									nodesToAdd[0]'  									m_selectedLineNodes[0]'  									(int)nodeConnectionPrioritySpinEdit.Value'  									(double)spinTargetVelocity.Value'  									carsAllowedCheckBox.Checked'  									busAllowedCheckBox.Checked'  									tramAllowedCheckBox.Checked'  									enableIncomingLineChangeCheckBox.Checked'  									enableOutgoingLineChangeCheckBox.Checked);      								// nun die restlichen LineNodes parallel erstellen  								for (int i = 1; i < m_selectedLineNodes.Count; i++)  									{  									Vector2 offset = m_selectedLineNodes[0].position - m_selectedLineNodes[i].position;  									selectedLineNodesMovingOffset.Add(offset);    									// Line Node erstellen  									nodesToAdd.Add(new LineNode(DaGrid.DockToGrid(clickedPosition - offset' dockToGrid)' cbNetworkLayer.SelectedItem as NetworkLayer' cbStopSign.Checked));    									// in/outSlope berechnen  									nodesToAdd[i].outSlope = 30 * Vector2.Normalize(nodesToAdd[i].position - midpoint);  									nodesToAdd[i].inSlope = -1 * nodesToAdd[i].outSlope;    									// Connecten  									nodeSteuerung.Connect(  										nodesToAdd[i]'  										m_selectedLineNodes[i]'  										(int)nodeConnectionPrioritySpinEdit.Value'  										(double)spinTargetVelocity.Value'  										carsAllowedCheckBox.Checked'  										busAllowedCheckBox.Checked'  										tramAllowedCheckBox.Checked'  										enableIncomingLineChangeCheckBox.Checked'  										enableOutgoingLineChangeCheckBox.Checked);    									}  								}  							}  						else  							{  							// ersten Line Node erstellen  							nodesToAdd.Add(new LineNode(DaGrid.DockToGrid(clickedPosition' dockToGrid)' cbNetworkLayer.SelectedItem as NetworkLayer' cbStopSign.Checked));  							selectedLineNodesMovingOffset.Add(new Vector2(0' 0));  							}    						previousSelectedNodePositions.Clear();  						foreach (LineNode ln in m_selectedLineNodes)  							{  							previousSelectedNodePositions.Add(ln.position);  							}    						selectedLineNodes.Clear();  						foreach (LineNode ln in nodesToAdd)  							{  							nodeSteuerung.AddLineNode(ln);  							selectedLineNodes.Add(ln);  							}  						howToDrag = DragNDrop.CREATE_NODE;  						}  					#endregion    					#region Nodes Verbinden  					else if (((Control.ModifierKeys & Keys.Alt) == Keys.Alt) && (selectedLineNodes != null))  						{  						LineNode nodeToConnectTo = nodeSteuerung.GetLineNodeAt(clickedPosition);    						if (nodeToConnectTo != null)  							{  							foreach (LineNode ln in selectedLineNodes)  								{  								nodeSteuerung.Connect(  									ln'   									nodeToConnectTo'   									(int)nodeConnectionPrioritySpinEdit.Value'  									(double)spinTargetVelocity.Value'  									carsAllowedCheckBox.Checked'   									busAllowedCheckBox.Checked'   									tramAllowedCheckBox.Checked'   									enableIncomingLineChangeCheckBox.Checked'  									enableOutgoingLineChangeCheckBox.Checked);  								}						  							}  						}  					#endregion    					#region Nodes selektieren bzw. verschieben  					else  						{  						bool found = false;    						if (!lockNodesCheckBox.Checked)  							{  							// erst gucken' ob evtl. In/OutSlopes angeklickt wurden  							if (selectedLineNodes != null && selectedLineNodes.Count >= 1)  								{  									if (m_selectedLineNodes[0].inSlopeRect.Contains(clickedPosition))  										{  										originalSlopes.Clear();  										foreach (LineNode ln in m_selectedLineNodes)  											{  											originalSlopes.Add(ln.inSlope);  											}  										  										howToDrag = DragNDrop.MOVE_IN_SLOPE;  										found = true;  										}  									if (m_selectedLineNodes[0].outSlopeRect.Contains(clickedPosition))  										{  										originalSlopes.Clear();  										foreach (LineNode ln in m_selectedLineNodes)  											{  											originalSlopes.Add(ln.outSlope);  											}    										howToDrag = DragNDrop.MOVE_OUT_SLOPE;  										found = true;  										}  								}  							}    						if (! found)  							{  							LineNode ln = nodeSteuerung.GetLineNodeAt(clickedPosition);  							if (ln != null && !lockNodesCheckBox.Checked)  								{  								if (selectedLineNodes.Contains(ln))  									{  									// MovingOffsets berechnen:  									selectedLineNodesMovingOffset.Clear();  									foreach (LineNode lln in m_selectedLineNodes)  										{  										selectedLineNodesMovingOffset.Add(lln.position - clickedPosition);  										}    									howToDrag = DragNDrop.MOVE_NODES;  									}  								else  									{  									// bei nur einem Punkt brauchen wir keine MovingOffsets  									selectedLineNodesMovingOffset.Clear();  									selectedLineNodesMovingOffset.Add(new Vector2(0' 0));    									// Häßlicher Workaround' um Settermethode für selectedLineNodes aufzurufen  									List<LineNode> foo = new List<LineNode>();   									foo.Add(ln);  									selectedLineNodes = foo;    									howToDrag = DragNDrop.MOVE_NODES;  									}  								}  							else  								{  								howToDrag = DragNDrop.DRAG_RUBBERBAND;    								daGridRubberband.Location = clickedPosition;  								daGridRubberband.Width = 1;  								daGridRubberband.Height = 1;  								}  							}  						}  					#endregion  					break;  				case MouseButtons.Right:  					if ((Control.ModifierKeys & Keys.Control) == Keys.Control)  						{  						#region Nodes löschen  						this.Cursor = Cursors.Default;  						// LineNode entfernen  						LineNode nodeToDelete = nodeSteuerung.GetLineNodeAt(clickedPosition);  						// checken ob gefunden  						if (nodeToDelete != null)  							{  							if (selectedLineNodes.Contains(nodeToDelete))  								{  								selectedLineNodes.Remove(nodeToDelete);  								}  							nodeSteuerung.DeleteLineNode(nodeToDelete);  							}  						#endregion  						}  					else  						{  						#region move main grid  						howToDrag = DragNDrop.MOVE_MAIN_GRID;  						daGridRubberband.Location = clickedPosition;  						this.Cursor = Cursors.SizeAll;  						#endregion  						}    					break;  				case MouseButtons.XButton1:  					daGridScrollPosition.Y += 10 * e.Delta;  					UpdateDaGridClippingRect();  					DaGrid.Invalidate();  					thumbGrid.Invalidate();  					break;  				}
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,DaGrid_MouseMove,The following statement contains a magic number: lblMouseCoordinates.Text = "Current Mouse Coordinates (m): " + (clickedPosition * 0.1).ToString();
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,DaGrid_MouseMove,The following statement contains a magic number: if (selectedLineNodes != null)  				{  				switch (howToDrag)  					{  					case DragNDrop.MOVE_MAIN_GRID:  						clickedPosition = new Vector2(e.X' e.Y);  						clickedPosition *= zoomMultipliers[zoomComboBox.SelectedIndex' 1];  						daGridScrollPosition = new Point((int)Math.Round(-clickedPosition.X + daGridRubberband.X)' (int)Math.Round(-clickedPosition.Y + daGridRubberband.Y));  						UpdateDaGridClippingRect();  						Invalidate(InvalidationLevel.ONLY_MAIN_CANVAS);  						break;  					case DragNDrop.MOVE_NODES:  						for (int i = 0; i < m_selectedLineNodes.Count; i++)  							{  							m_selectedLineNodes[i].position = DaGrid.DockToGrid(clickedPosition + selectedLineNodesMovingOffset[i]' dockToGrid);  							}    						Invalidate(InvalidationLevel.ONLY_MAIN_CANVAS);  						break;  					case DragNDrop.CREATE_NODE:  						selectedLineNodes[0].outSlopeAbs = DaGrid.DockToGrid(clickedPosition' dockToGrid);  						selectedLineNodes[0].inSlope = -1 * selectedLineNodes[0].outSlope;    						for (int i = 1; i < m_selectedLineNodes.Count; i++)  							{  							// Rotation des offsets im Vergleich zum outSlope berechnen  							double rotation = Math.Atan2(selectedLineNodesMovingOffset[i].Y' selectedLineNodesMovingOffset[i].X) - Math.Atan2(selectedLineNodesMovingOffset[0].Y' selectedLineNodesMovingOffset[0].X);    							m_selectedLineNodes[i].position = m_selectedLineNodes[0].position - (m_selectedLineNodes[0].outSlope.RotateCounterClockwise(rotation).Normalized * selectedLineNodesMovingOffset[i].Abs);    							double streckungsfaktor = Math.Pow((m_selectedLineNodes[i].position - previousSelectedNodePositions[i]).Abs / (m_selectedLineNodes[0].position - previousSelectedNodePositions[0]).Abs' 2);    							m_selectedLineNodes[i].outSlope = m_selectedLineNodes[0].outSlope * streckungsfaktor;  							m_selectedLineNodes[i].inSlope = m_selectedLineNodes[0].inSlope * streckungsfaktor;  							}    						Invalidate(InvalidationLevel.ONLY_MAIN_CANVAS);  						break;  					case DragNDrop.MOVE_IN_SLOPE:  						selectedLineNodes[0].inSlopeAbs = DaGrid.DockToGrid(clickedPosition' dockToGrid);    						// sind mehr als ein LineNode markiert' so sollen die inSlopes aller anderen LineNodes angepasst werden.  						if (m_selectedLineNodes.Count > 1)  							{  							// zur relativen Anpassung eignen sich Polarkoordinaten besonders gut' wir berechnen zunächst die Änderungen  							double streckungsfaktor = m_selectedLineNodes[0].inSlope.Abs / originalSlopes[0].Abs;  							double rotation = Math.Atan2(m_selectedLineNodes[0].inSlope.Y' m_selectedLineNodes[0].inSlope.X) - Math.Atan2(originalSlopes[0].Y' originalSlopes[0].X);    							for (int i = 0; i < m_selectedLineNodes.Count; i++)  								{  								if (i > 0)  									{  									m_selectedLineNodes[i].inSlope = originalSlopes[i].RotateCounterClockwise(rotation);  									m_selectedLineNodes[i].inSlope *= streckungsfaktor;  									}  								}  							}      						if (!((Control.ModifierKeys & Keys.Alt) == Keys.Alt))  							{  							foreach (LineNode ln in m_selectedLineNodes)  								{  								ln.outSlope = -1 * ln.inSlope;  								}  							}  						Invalidate(InvalidationLevel.ONLY_MAIN_CANVAS);  						break;  					case DragNDrop.MOVE_OUT_SLOPE:  						selectedLineNodes[0].outSlopeAbs = DaGrid.DockToGrid(clickedPosition' dockToGrid);    						// sind mehr als ein LineNode markiert' so sollen die outSlopes aller anderen LineNodes angepasst werden.  						if (m_selectedLineNodes.Count > 1)  							{  							// zur relativen Anpassung eignen sich Polarkoordinaten besonders gut' wir berechnen zunächst die Änderungen  							double streckungsfaktor = m_selectedLineNodes[0].outSlope.Abs / originalSlopes[0].Abs;  							double rotation = Math.Atan2(m_selectedLineNodes[0].outSlope.Y' m_selectedLineNodes[0].outSlope.X) - Math.Atan2(originalSlopes[0].Y' originalSlopes[0].X);    							for (int i = 0; i < m_selectedLineNodes.Count; i++)  								{  								if (i > 0)  									{  									m_selectedLineNodes[i].outSlope = originalSlopes[i].RotateCounterClockwise(rotation);  									m_selectedLineNodes[i].outSlope *= streckungsfaktor;  									}  								}  							}    						if (!((Control.ModifierKeys & Keys.Alt) == Keys.Alt))  							{  							foreach (LineNode ln in m_selectedLineNodes)  								{  								ln.inSlope = -1 * ln.outSlope;  								}							  							}  						Invalidate(InvalidationLevel.ONLY_MAIN_CANVAS);  						break;  					case DragNDrop.DRAG_RUBBERBAND:  						daGridRubberband.Width = (int) Math.Round(clickedPosition.X - daGridRubberband.X);  						daGridRubberband.Height = (int) Math.Round(clickedPosition.Y - daGridRubberband.Y);  						Invalidate(InvalidationLevel.ONLY_MAIN_CANVAS);  						break;  					default:  						break;  					}  				}  			else  				{  				}
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,DaGrid_MouseUp,The following statement contains a magic number: switch (howToDrag)  				{  				case DragNDrop.DRAG_RUBBERBAND:  					// nun nochLineNode markieren  					if (Math.Abs(daGridRubberband.Width) > 2 && Math.Abs(daGridRubberband.Height) > 2)  						{  						// Rubberband normalisieren:  						if (daGridRubberband.Width < 0)  							{  							daGridRubberband.X += daGridRubberband.Width;  							daGridRubberband.Width *= -1;  							}  						if (daGridRubberband.Height < 0)  							{  							daGridRubberband.Y += daGridRubberband.Height;  							daGridRubberband.Height *= -1;  							}    						if ((Control.ModifierKeys & Keys.Shift) == Keys.Shift)  							{  							List<LineNode> tmp = nodeSteuerung.GetLineNodesAt(daGridRubberband);  							foreach (LineNode ln in selectedLineNodes)  								{  								if (!tmp.Contains(ln))  									tmp.Add(ln);  								}  							selectedLineNodes = tmp;  							}  						else  							{  							selectedLineNodes = nodeSteuerung.GetLineNodesAt(daGridRubberband);  							}  						}  					else   						{  						selectedLineNodes = new List<LineNode>();  						selectedNodeConnection = nodeSteuerung.GetNodeConnectionAt(clickedPosition);  						selectedVehicle = nodeSteuerung.GetVehicleAt(clickedPosition);  						}  					break;  				case DragNDrop.MOVE_MAIN_GRID:  					thumbGrid.Invalidate();  					break;  				default:  					break;  				}
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,DaGrid_MouseUp,The following statement contains a magic number: switch (howToDrag)  				{  				case DragNDrop.DRAG_RUBBERBAND:  					// nun nochLineNode markieren  					if (Math.Abs(daGridRubberband.Width) > 2 && Math.Abs(daGridRubberband.Height) > 2)  						{  						// Rubberband normalisieren:  						if (daGridRubberband.Width < 0)  							{  							daGridRubberband.X += daGridRubberband.Width;  							daGridRubberband.Width *= -1;  							}  						if (daGridRubberband.Height < 0)  							{  							daGridRubberband.Y += daGridRubberband.Height;  							daGridRubberband.Height *= -1;  							}    						if ((Control.ModifierKeys & Keys.Shift) == Keys.Shift)  							{  							List<LineNode> tmp = nodeSteuerung.GetLineNodesAt(daGridRubberband);  							foreach (LineNode ln in selectedLineNodes)  								{  								if (!tmp.Contains(ln))  									tmp.Add(ln);  								}  							selectedLineNodes = tmp;  							}  						else  							{  							selectedLineNodes = nodeSteuerung.GetLineNodesAt(daGridRubberband);  							}  						}  					else   						{  						selectedLineNodes = new List<LineNode>();  						selectedNodeConnection = nodeSteuerung.GetNodeConnectionAt(clickedPosition);  						selectedVehicle = nodeSteuerung.GetVehicleAt(clickedPosition);  						}  					break;  				case DragNDrop.MOVE_MAIN_GRID:  					thumbGrid.Invalidate();  					break;  				default:  					break;  				}
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,DaGrid_MouseWheel,The following statement contains a magic number: if ((Control.ModifierKeys & Keys.Control) == Keys.Control)  				zoomComboBox.SelectedIndex = Math2.Clamp(zoomComboBox.SelectedIndex + (e.Delta / 120)' 0' zoomComboBox.Items.Count - 1);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,DaGrid_KeyDown,The following statement contains a magic number: switch (e.KeyCode)  				{  			#region Nodes verschieben  			// Node verschieben  			case Keys.Left:  				foreach (LineNode ln in selectedLineNodes)  					{  					ln.position.X -= 1;  					e.Handled = true;  					Invalidate(InvalidationLevel.ONLY_MAIN_CANVAS);  					}  				break;  			case Keys.Right:  				foreach (LineNode ln in selectedLineNodes)  					{  					ln.position.X += 1;  					e.Handled = true;  					Invalidate(InvalidationLevel.ONLY_MAIN_CANVAS);  					}  				break;  			case Keys.Up:  				foreach (LineNode ln in selectedLineNodes)  					{  					ln.position.Y -= 1;  					e.Handled = true;  					Invalidate(InvalidationLevel.ONLY_MAIN_CANVAS);  					}  				break;  			case Keys.Down:  				foreach (LineNode ln in selectedLineNodes)  					{  					ln.position.Y += 1;  					e.Handled = true;  					Invalidate(InvalidationLevel.ONLY_MAIN_CANVAS);  					}  				break;  			#endregion    			#region Nodes durchwandern  			// TODO: nächster Node  			case Keys.PageDown:  				break;  			// TODO: vorheriger Node  			case Keys.PageUp:  				break;  			#endregion    			#region Nodes bearbeiten  			// Node löschen  			case Keys.Delete:  				if (selectedVehicle != null)  					{  					selectedVehicle.currentNodeConnection.RemoveVehicle(selectedVehicle);  					}  				else // do not delete nodes and connections when vehicle selected!  					{  					foreach (LineNode ln in selectedLineNodes)  						{  						nodeSteuerung.DeleteLineNode(ln);  						}  					selectedLineNodes.Clear();  					e.Handled = true;  					Invalidate(InvalidationLevel.ONLY_MAIN_CANVAS);    					if (selectedNodeConnection != null)  						{  						nodeSteuerung.Disconnect(selectedNodeConnection.startNode' selectedNodeConnection.endNode);  						selectedNodeConnection = null;  						e.Handled = true;  						Invalidate(InvalidationLevel.ONLY_MAIN_CANVAS);  						}  					}  				break;    			// LineSegment teilen  			case Keys.S:  				if (selectedNodeConnection != null)  					{  					nodeSteuerung.SplitNodeConnection(selectedNodeConnection);  					selectedNodeConnection = null;  					Invalidate(InvalidationLevel.ONLY_MAIN_CANVAS);  					}  				break;  			case Keys.Return:  				if (selectedNodeConnection != null)  					{  					nodeSteuerung.RemoveLineChangePoints(selectedNodeConnection' true' false);  					nodeSteuerung.FindLineChangePoints(selectedNodeConnection' Constants.maxDistanceToLineChangePoint' Constants.maxDistanceToParallelConnection);  					Invalidate(InvalidationLevel.ONLY_MAIN_CANVAS);  					}  				break;    			case Keys.C:  				if (selectedNodeConnection != null)  					{  					carsAllowedCheckBox.Checked = !carsAllowedCheckBox.Checked;  					}  				break;  			case Keys.B:  				if (selectedNodeConnection != null)  					{  					busAllowedCheckBox.Checked = !busAllowedCheckBox.Checked;  					}  				break;  			case Keys.T:  				if (selectedNodeConnection != null)  					{  					tramAllowedCheckBox.Checked = !tramAllowedCheckBox.Checked;  					}  				break;    			case Keys.O:  				if (selectedNodeConnection != null)  					{  					enableOutgoingLineChangeCheckBox.Checked = !enableOutgoingLineChangeCheckBox.Checked;  					enableOutgoingLineChangeCheckBox_Click(this' new EventArgs());  					}  				break;  			case Keys.I:  				if (selectedNodeConnection != null)  					{  					enableIncomingLineChangeCheckBox.Checked = !enableIncomingLineChangeCheckBox.Checked;  					enableIncomingLineChangeCheckBox_Click(this' new EventArgs());  					}  				break;    			// reset LineNode slopes  			case Keys.R:  				foreach (LineNode ln in selectedLineNodes)  					{  					if (!ln.outSlope.IsZeroVector() && !ln.inSlope.IsZeroVector())  						{  						ln.outSlope = ln.outSlope.Normalized * 32;  						ln.inSlope = ln.inSlope.Normalized * 32;  						}  					}  				Invalidate(InvalidationLevel.ONLY_MAIN_CANVAS);  				break;  			#endregion    			#region from-/toLineNodes setzen    			case Keys.V:  				fromLineNodes.Clear();  				foreach (LineNode ln in selectedLineNodes)  					{  					fromLineNodes.Add(ln);  					}  				Invalidate(InvalidationLevel.ONLY_MAIN_CANVAS);  				break;    			case Keys.N:  				toLineNodes.Clear();  				foreach (LineNode ln in selectedLineNodes)  					{  					toLineNodes.Add(ln);  					}  				Invalidate(InvalidationLevel.ONLY_MAIN_CANVAS);  				break;  			#endregion    			#region Zoomfaktor ändern  			case Keys.P:  				if (selectedNodeConnection != null)  					{  					nodeConnectionPrioritySpinEdit.Value++;  					break;  					}  				if (((Control.ModifierKeys & Keys.Control) == Keys.Control) && zoomComboBox.SelectedIndex < zoomComboBox.Items.Count - 1)  					{  					zoomComboBox.SelectedIndex += 1;  					}  				break;    			case Keys.M:  				if (selectedNodeConnection != null)  					{  					nodeConnectionPrioritySpinEdit.Value--;  					break;  					}  				if (((Control.ModifierKeys & Keys.Control) == Keys.Control) && zoomComboBox.SelectedIndex > 0)  					{  					zoomComboBox.SelectedIndex -= 1;  					}  				break;    			case Keys.Add:  				if (selectedNodeConnection != null)  					{  					nodeConnectionPrioritySpinEdit.Value++;  					break;  					}  				if (((Control.ModifierKeys & Keys.Control) == Keys.Control) && zoomComboBox.SelectedIndex < zoomComboBox.Items.Count - 1)  					{  					zoomComboBox.SelectedIndex += 1;  					}  				break;    			case Keys.Subtract:  				if (selectedNodeConnection != null)  					{  					nodeConnectionPrioritySpinEdit.Value--;  					break;  					}  				if (((Control.ModifierKeys & Keys.Control) == Keys.Control) && zoomComboBox.SelectedIndex > 0)  					{  					zoomComboBox.SelectedIndex -= 1;  					}  				break;    			#endregion      			#region Connections bearbeiten    			#endregion  			case Keys.D:  				  				break;  				}
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,DaGrid_KeyDown,The following statement contains a magic number: switch (e.KeyCode)  				{  			#region Nodes verschieben  			// Node verschieben  			case Keys.Left:  				foreach (LineNode ln in selectedLineNodes)  					{  					ln.position.X -= 1;  					e.Handled = true;  					Invalidate(InvalidationLevel.ONLY_MAIN_CANVAS);  					}  				break;  			case Keys.Right:  				foreach (LineNode ln in selectedLineNodes)  					{  					ln.position.X += 1;  					e.Handled = true;  					Invalidate(InvalidationLevel.ONLY_MAIN_CANVAS);  					}  				break;  			case Keys.Up:  				foreach (LineNode ln in selectedLineNodes)  					{  					ln.position.Y -= 1;  					e.Handled = true;  					Invalidate(InvalidationLevel.ONLY_MAIN_CANVAS);  					}  				break;  			case Keys.Down:  				foreach (LineNode ln in selectedLineNodes)  					{  					ln.position.Y += 1;  					e.Handled = true;  					Invalidate(InvalidationLevel.ONLY_MAIN_CANVAS);  					}  				break;  			#endregion    			#region Nodes durchwandern  			// TODO: nächster Node  			case Keys.PageDown:  				break;  			// TODO: vorheriger Node  			case Keys.PageUp:  				break;  			#endregion    			#region Nodes bearbeiten  			// Node löschen  			case Keys.Delete:  				if (selectedVehicle != null)  					{  					selectedVehicle.currentNodeConnection.RemoveVehicle(selectedVehicle);  					}  				else // do not delete nodes and connections when vehicle selected!  					{  					foreach (LineNode ln in selectedLineNodes)  						{  						nodeSteuerung.DeleteLineNode(ln);  						}  					selectedLineNodes.Clear();  					e.Handled = true;  					Invalidate(InvalidationLevel.ONLY_MAIN_CANVAS);    					if (selectedNodeConnection != null)  						{  						nodeSteuerung.Disconnect(selectedNodeConnection.startNode' selectedNodeConnection.endNode);  						selectedNodeConnection = null;  						e.Handled = true;  						Invalidate(InvalidationLevel.ONLY_MAIN_CANVAS);  						}  					}  				break;    			// LineSegment teilen  			case Keys.S:  				if (selectedNodeConnection != null)  					{  					nodeSteuerung.SplitNodeConnection(selectedNodeConnection);  					selectedNodeConnection = null;  					Invalidate(InvalidationLevel.ONLY_MAIN_CANVAS);  					}  				break;  			case Keys.Return:  				if (selectedNodeConnection != null)  					{  					nodeSteuerung.RemoveLineChangePoints(selectedNodeConnection' true' false);  					nodeSteuerung.FindLineChangePoints(selectedNodeConnection' Constants.maxDistanceToLineChangePoint' Constants.maxDistanceToParallelConnection);  					Invalidate(InvalidationLevel.ONLY_MAIN_CANVAS);  					}  				break;    			case Keys.C:  				if (selectedNodeConnection != null)  					{  					carsAllowedCheckBox.Checked = !carsAllowedCheckBox.Checked;  					}  				break;  			case Keys.B:  				if (selectedNodeConnection != null)  					{  					busAllowedCheckBox.Checked = !busAllowedCheckBox.Checked;  					}  				break;  			case Keys.T:  				if (selectedNodeConnection != null)  					{  					tramAllowedCheckBox.Checked = !tramAllowedCheckBox.Checked;  					}  				break;    			case Keys.O:  				if (selectedNodeConnection != null)  					{  					enableOutgoingLineChangeCheckBox.Checked = !enableOutgoingLineChangeCheckBox.Checked;  					enableOutgoingLineChangeCheckBox_Click(this' new EventArgs());  					}  				break;  			case Keys.I:  				if (selectedNodeConnection != null)  					{  					enableIncomingLineChangeCheckBox.Checked = !enableIncomingLineChangeCheckBox.Checked;  					enableIncomingLineChangeCheckBox_Click(this' new EventArgs());  					}  				break;    			// reset LineNode slopes  			case Keys.R:  				foreach (LineNode ln in selectedLineNodes)  					{  					if (!ln.outSlope.IsZeroVector() && !ln.inSlope.IsZeroVector())  						{  						ln.outSlope = ln.outSlope.Normalized * 32;  						ln.inSlope = ln.inSlope.Normalized * 32;  						}  					}  				Invalidate(InvalidationLevel.ONLY_MAIN_CANVAS);  				break;  			#endregion    			#region from-/toLineNodes setzen    			case Keys.V:  				fromLineNodes.Clear();  				foreach (LineNode ln in selectedLineNodes)  					{  					fromLineNodes.Add(ln);  					}  				Invalidate(InvalidationLevel.ONLY_MAIN_CANVAS);  				break;    			case Keys.N:  				toLineNodes.Clear();  				foreach (LineNode ln in selectedLineNodes)  					{  					toLineNodes.Add(ln);  					}  				Invalidate(InvalidationLevel.ONLY_MAIN_CANVAS);  				break;  			#endregion    			#region Zoomfaktor ändern  			case Keys.P:  				if (selectedNodeConnection != null)  					{  					nodeConnectionPrioritySpinEdit.Value++;  					break;  					}  				if (((Control.ModifierKeys & Keys.Control) == Keys.Control) && zoomComboBox.SelectedIndex < zoomComboBox.Items.Count - 1)  					{  					zoomComboBox.SelectedIndex += 1;  					}  				break;    			case Keys.M:  				if (selectedNodeConnection != null)  					{  					nodeConnectionPrioritySpinEdit.Value--;  					break;  					}  				if (((Control.ModifierKeys & Keys.Control) == Keys.Control) && zoomComboBox.SelectedIndex > 0)  					{  					zoomComboBox.SelectedIndex -= 1;  					}  				break;    			case Keys.Add:  				if (selectedNodeConnection != null)  					{  					nodeConnectionPrioritySpinEdit.Value++;  					break;  					}  				if (((Control.ModifierKeys & Keys.Control) == Keys.Control) && zoomComboBox.SelectedIndex < zoomComboBox.Items.Count - 1)  					{  					zoomComboBox.SelectedIndex += 1;  					}  				break;    			case Keys.Subtract:  				if (selectedNodeConnection != null)  					{  					nodeConnectionPrioritySpinEdit.Value--;  					break;  					}  				if (((Control.ModifierKeys & Keys.Control) == Keys.Control) && zoomComboBox.SelectedIndex > 0)  					{  					zoomComboBox.SelectedIndex -= 1;  					}  				break;    			#endregion      			#region Connections bearbeiten    			#endregion  			case Keys.D:  				  				break;  				}
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,DaGrid_Paint,The following statement contains a magic number: using (Pen BlackPen = new Pen(Color.Black' 1.0F))  				{  				// Zusätzliche Grafiken zeichnen  				foreach (GraphicsPath gp in additionalGraphics)  					{  					e.Graphics.DrawPath(BlackPen' gp);  					}    				nodeSteuerung.RenderNetwork(e.Graphics' renderOptionsDaGrid);    				//to-/fromLineNode malen  				foreach (LineNode ln in toLineNodes)  					{  					RectangleF foo = ln.positionRect;  					foo.Inflate(4' 4);  					e.Graphics.FillEllipse(new SolidBrush(Color.Red)' foo);  					}  				foreach (LineNode ln in fromLineNodes)  					{  					RectangleF foo = ln.positionRect;  					foo.Inflate(4' 4);  					e.Graphics.FillEllipse(new SolidBrush(Color.Green)' foo);  					}  	  				if (selectedLineNodes.Count >= 1)  					{  					if (cbRenderLineNodes.Checked)  						{  						foreach (LineNode ln in selectedLineNodes)  							{  							foreach (GraphicsPath gp in ln.nodeGraphics)  								{  								e.Graphics.DrawPath(BlackPen' gp);  								}    							RectangleF foo = ln.positionRect;  							foo.Inflate(2' 2);  							e.Graphics.FillEllipse(new SolidBrush(Color.Black)' foo);  							}    						RectangleF foo2 = m_selectedLineNodes[0].positionRect;  						foo2.Inflate(4' 4);  						e.Graphics.DrawEllipse(BlackPen' foo2);  						}    					List<Vector2> points = new List<Vector2>(selectedLineNodes.Count);  					foreach (LineNode ln in selectedLineNodes)  						{  						points.Add(ln.position);  						}  					// build convex hull  					GraphicsPath hullPath = AlgorithmicGeometry.roundedConvexHullPath(points' 16);    					using (SolidBrush tmp = new SolidBrush(Color.FromArgb(64' Color.Gold)))  						e.Graphics.FillPath(tmp' hullPath);  					using (Pen tmp = new Pen(Color.Gold' 3))  						e.Graphics.DrawPath(tmp' hullPath);  					}    				if (trafficLightForm.selectedEntry != null)  					{  					List<Pair<SpecificIntersection' double>> foo = trafficLightForm.selectedEntry.parentGroup.GetConflictPoints(trafficLightForm.selectedEntry);  					if (foo != null)  						{  						using (Pen bar = new Pen(Color.Blue' 2))  							{  							foreach (Pair<SpecificIntersection' double> p in foo)  								{  								List<Vector2> l = new List<Vector2>();  								l.Add(p.Left.intersection.aPosition);  								e.Graphics.DrawPath(bar' AlgorithmicGeometry.roundedConvexHullPath(l' 8));  								}  							}  						}  					}    				// selektierte NodeConnection malen  				if (selectedNodeConnection != null)  					{  					selectedNodeConnection.lineSegment.Draw(e.Graphics' BlackPen);  					}    				if (selectedVehicle != null && renderOptionsDaGrid.renderVehicleDebugData)  					{  					Pen prevNodeConnectionsPen = new Pen(Color.Red' 3);  					Pen nextNodeConnectionsPen = new Pen(Color.Green' 3);    					foreach (NodeConnection prevNC in selectedVehicle.visitedNodeConnections)  						{  						e.Graphics.DrawBezier(prevNodeConnectionsPen' prevNC.lineSegment.p0' prevNC.lineSegment.p1' prevNC.lineSegment.p2' prevNC.lineSegment.p3);  						}  					foreach (Routing.RouteSegment rs in selectedVehicle.wayToGo)  						{  						if (!rs.lineChangeNeeded)  							{  							NodeConnection nextNC = rs.startConnection;  							e.Graphics.DrawBezier(nextNodeConnectionsPen' nextNC.lineSegment.p0' nextNC.lineSegment.p1' nextNC.lineSegment.p2' nextNC.lineSegment.p3);  							}  						else  							{  							e.Graphics.DrawLine(nextNodeConnectionsPen' rs.startConnection.startNode.position' rs.nextNode.position);  							}  						}  					}      				// Gummiband zeichnen  				if (howToDrag == DragNDrop.DRAG_RUBBERBAND)  					{  					Point[] points =   						{  							new Point(daGridRubberband.X' daGridRubberband.Y)'  							new Point(daGridRubberband.X + daGridRubberband.Width' daGridRubberband.Y)'  							new Point(daGridRubberband.X + daGridRubberband.Width' daGridRubberband.Y + daGridRubberband.Height)'  							new Point(daGridRubberband.X' daGridRubberband.Y + daGridRubberband.Height)  						};  					using (SolidBrush tmp = new SolidBrush(Color.FromArgb(32' Color.Black)))  						e.Graphics.FillPolygon(tmp' points);  					e.Graphics.DrawPolygon(BlackPen' points);  					}    				additionalGraphics.Clear();      				// Statusinfo zeichnen:  				if (selectedVehicle != null && cbRenderVehiclesDebug.Checked)  					{  					selectedVehicle.DrawDebugData(e.Graphics);  					}    				renderStopwatch.Stop();      				if (cbRenderFps.Checked)  					{  					e.Graphics.Transform = new Matrix(1' 0' 0' 1' 0' 0);  					e.Graphics.DrawString(  						"thinking time: " + thinkStopwatch.ElapsedMilliseconds + "ms' possible thoughts per second: " + ((thinkStopwatch.ElapsedMilliseconds != 0) ? (1000 / thinkStopwatch.ElapsedMilliseconds).ToString() : "-")'  						new Font("Arial"' 10)'  						new SolidBrush(Color.Black)'  						8'  						40);    					e.Graphics.DrawString(  						"rendering time: " + renderStopwatch.ElapsedMilliseconds + "ms' possible fps: " + ((renderStopwatch.ElapsedMilliseconds != 0) ? (1000 / renderStopwatch.ElapsedMilliseconds).ToString() : "-")'  						new Font("Arial"' 10)'  						new SolidBrush(Color.Black)'  						8'  						56);  					}  				}
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,DaGrid_Paint,The following statement contains a magic number: using (Pen BlackPen = new Pen(Color.Black' 1.0F))  				{  				// Zusätzliche Grafiken zeichnen  				foreach (GraphicsPath gp in additionalGraphics)  					{  					e.Graphics.DrawPath(BlackPen' gp);  					}    				nodeSteuerung.RenderNetwork(e.Graphics' renderOptionsDaGrid);    				//to-/fromLineNode malen  				foreach (LineNode ln in toLineNodes)  					{  					RectangleF foo = ln.positionRect;  					foo.Inflate(4' 4);  					e.Graphics.FillEllipse(new SolidBrush(Color.Red)' foo);  					}  				foreach (LineNode ln in fromLineNodes)  					{  					RectangleF foo = ln.positionRect;  					foo.Inflate(4' 4);  					e.Graphics.FillEllipse(new SolidBrush(Color.Green)' foo);  					}  	  				if (selectedLineNodes.Count >= 1)  					{  					if (cbRenderLineNodes.Checked)  						{  						foreach (LineNode ln in selectedLineNodes)  							{  							foreach (GraphicsPath gp in ln.nodeGraphics)  								{  								e.Graphics.DrawPath(BlackPen' gp);  								}    							RectangleF foo = ln.positionRect;  							foo.Inflate(2' 2);  							e.Graphics.FillEllipse(new SolidBrush(Color.Black)' foo);  							}    						RectangleF foo2 = m_selectedLineNodes[0].positionRect;  						foo2.Inflate(4' 4);  						e.Graphics.DrawEllipse(BlackPen' foo2);  						}    					List<Vector2> points = new List<Vector2>(selectedLineNodes.Count);  					foreach (LineNode ln in selectedLineNodes)  						{  						points.Add(ln.position);  						}  					// build convex hull  					GraphicsPath hullPath = AlgorithmicGeometry.roundedConvexHullPath(points' 16);    					using (SolidBrush tmp = new SolidBrush(Color.FromArgb(64' Color.Gold)))  						e.Graphics.FillPath(tmp' hullPath);  					using (Pen tmp = new Pen(Color.Gold' 3))  						e.Graphics.DrawPath(tmp' hullPath);  					}    				if (trafficLightForm.selectedEntry != null)  					{  					List<Pair<SpecificIntersection' double>> foo = trafficLightForm.selectedEntry.parentGroup.GetConflictPoints(trafficLightForm.selectedEntry);  					if (foo != null)  						{  						using (Pen bar = new Pen(Color.Blue' 2))  							{  							foreach (Pair<SpecificIntersection' double> p in foo)  								{  								List<Vector2> l = new List<Vector2>();  								l.Add(p.Left.intersection.aPosition);  								e.Graphics.DrawPath(bar' AlgorithmicGeometry.roundedConvexHullPath(l' 8));  								}  							}  						}  					}    				// selektierte NodeConnection malen  				if (selectedNodeConnection != null)  					{  					selectedNodeConnection.lineSegment.Draw(e.Graphics' BlackPen);  					}    				if (selectedVehicle != null && renderOptionsDaGrid.renderVehicleDebugData)  					{  					Pen prevNodeConnectionsPen = new Pen(Color.Red' 3);  					Pen nextNodeConnectionsPen = new Pen(Color.Green' 3);    					foreach (NodeConnection prevNC in selectedVehicle.visitedNodeConnections)  						{  						e.Graphics.DrawBezier(prevNodeConnectionsPen' prevNC.lineSegment.p0' prevNC.lineSegment.p1' prevNC.lineSegment.p2' prevNC.lineSegment.p3);  						}  					foreach (Routing.RouteSegment rs in selectedVehicle.wayToGo)  						{  						if (!rs.lineChangeNeeded)  							{  							NodeConnection nextNC = rs.startConnection;  							e.Graphics.DrawBezier(nextNodeConnectionsPen' nextNC.lineSegment.p0' nextNC.lineSegment.p1' nextNC.lineSegment.p2' nextNC.lineSegment.p3);  							}  						else  							{  							e.Graphics.DrawLine(nextNodeConnectionsPen' rs.startConnection.startNode.position' rs.nextNode.position);  							}  						}  					}      				// Gummiband zeichnen  				if (howToDrag == DragNDrop.DRAG_RUBBERBAND)  					{  					Point[] points =   						{  							new Point(daGridRubberband.X' daGridRubberband.Y)'  							new Point(daGridRubberband.X + daGridRubberband.Width' daGridRubberband.Y)'  							new Point(daGridRubberband.X + daGridRubberband.Width' daGridRubberband.Y + daGridRubberband.Height)'  							new Point(daGridRubberband.X' daGridRubberband.Y + daGridRubberband.Height)  						};  					using (SolidBrush tmp = new SolidBrush(Color.FromArgb(32' Color.Black)))  						e.Graphics.FillPolygon(tmp' points);  					e.Graphics.DrawPolygon(BlackPen' points);  					}    				additionalGraphics.Clear();      				// Statusinfo zeichnen:  				if (selectedVehicle != null && cbRenderVehiclesDebug.Checked)  					{  					selectedVehicle.DrawDebugData(e.Graphics);  					}    				renderStopwatch.Stop();      				if (cbRenderFps.Checked)  					{  					e.Graphics.Transform = new Matrix(1' 0' 0' 1' 0' 0);  					e.Graphics.DrawString(  						"thinking time: " + thinkStopwatch.ElapsedMilliseconds + "ms' possible thoughts per second: " + ((thinkStopwatch.ElapsedMilliseconds != 0) ? (1000 / thinkStopwatch.ElapsedMilliseconds).ToString() : "-")'  						new Font("Arial"' 10)'  						new SolidBrush(Color.Black)'  						8'  						40);    					e.Graphics.DrawString(  						"rendering time: " + renderStopwatch.ElapsedMilliseconds + "ms' possible fps: " + ((renderStopwatch.ElapsedMilliseconds != 0) ? (1000 / renderStopwatch.ElapsedMilliseconds).ToString() : "-")'  						new Font("Arial"' 10)'  						new SolidBrush(Color.Black)'  						8'  						56);  					}  				}
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,DaGrid_Paint,The following statement contains a magic number: using (Pen BlackPen = new Pen(Color.Black' 1.0F))  				{  				// Zusätzliche Grafiken zeichnen  				foreach (GraphicsPath gp in additionalGraphics)  					{  					e.Graphics.DrawPath(BlackPen' gp);  					}    				nodeSteuerung.RenderNetwork(e.Graphics' renderOptionsDaGrid);    				//to-/fromLineNode malen  				foreach (LineNode ln in toLineNodes)  					{  					RectangleF foo = ln.positionRect;  					foo.Inflate(4' 4);  					e.Graphics.FillEllipse(new SolidBrush(Color.Red)' foo);  					}  				foreach (LineNode ln in fromLineNodes)  					{  					RectangleF foo = ln.positionRect;  					foo.Inflate(4' 4);  					e.Graphics.FillEllipse(new SolidBrush(Color.Green)' foo);  					}  	  				if (selectedLineNodes.Count >= 1)  					{  					if (cbRenderLineNodes.Checked)  						{  						foreach (LineNode ln in selectedLineNodes)  							{  							foreach (GraphicsPath gp in ln.nodeGraphics)  								{  								e.Graphics.DrawPath(BlackPen' gp);  								}    							RectangleF foo = ln.positionRect;  							foo.Inflate(2' 2);  							e.Graphics.FillEllipse(new SolidBrush(Color.Black)' foo);  							}    						RectangleF foo2 = m_selectedLineNodes[0].positionRect;  						foo2.Inflate(4' 4);  						e.Graphics.DrawEllipse(BlackPen' foo2);  						}    					List<Vector2> points = new List<Vector2>(selectedLineNodes.Count);  					foreach (LineNode ln in selectedLineNodes)  						{  						points.Add(ln.position);  						}  					// build convex hull  					GraphicsPath hullPath = AlgorithmicGeometry.roundedConvexHullPath(points' 16);    					using (SolidBrush tmp = new SolidBrush(Color.FromArgb(64' Color.Gold)))  						e.Graphics.FillPath(tmp' hullPath);  					using (Pen tmp = new Pen(Color.Gold' 3))  						e.Graphics.DrawPath(tmp' hullPath);  					}    				if (trafficLightForm.selectedEntry != null)  					{  					List<Pair<SpecificIntersection' double>> foo = trafficLightForm.selectedEntry.parentGroup.GetConflictPoints(trafficLightForm.selectedEntry);  					if (foo != null)  						{  						using (Pen bar = new Pen(Color.Blue' 2))  							{  							foreach (Pair<SpecificIntersection' double> p in foo)  								{  								List<Vector2> l = new List<Vector2>();  								l.Add(p.Left.intersection.aPosition);  								e.Graphics.DrawPath(bar' AlgorithmicGeometry.roundedConvexHullPath(l' 8));  								}  							}  						}  					}    				// selektierte NodeConnection malen  				if (selectedNodeConnection != null)  					{  					selectedNodeConnection.lineSegment.Draw(e.Graphics' BlackPen);  					}    				if (selectedVehicle != null && renderOptionsDaGrid.renderVehicleDebugData)  					{  					Pen prevNodeConnectionsPen = new Pen(Color.Red' 3);  					Pen nextNodeConnectionsPen = new Pen(Color.Green' 3);    					foreach (NodeConnection prevNC in selectedVehicle.visitedNodeConnections)  						{  						e.Graphics.DrawBezier(prevNodeConnectionsPen' prevNC.lineSegment.p0' prevNC.lineSegment.p1' prevNC.lineSegment.p2' prevNC.lineSegment.p3);  						}  					foreach (Routing.RouteSegment rs in selectedVehicle.wayToGo)  						{  						if (!rs.lineChangeNeeded)  							{  							NodeConnection nextNC = rs.startConnection;  							e.Graphics.DrawBezier(nextNodeConnectionsPen' nextNC.lineSegment.p0' nextNC.lineSegment.p1' nextNC.lineSegment.p2' nextNC.lineSegment.p3);  							}  						else  							{  							e.Graphics.DrawLine(nextNodeConnectionsPen' rs.startConnection.startNode.position' rs.nextNode.position);  							}  						}  					}      				// Gummiband zeichnen  				if (howToDrag == DragNDrop.DRAG_RUBBERBAND)  					{  					Point[] points =   						{  							new Point(daGridRubberband.X' daGridRubberband.Y)'  							new Point(daGridRubberband.X + daGridRubberband.Width' daGridRubberband.Y)'  							new Point(daGridRubberband.X + daGridRubberband.Width' daGridRubberband.Y + daGridRubberband.Height)'  							new Point(daGridRubberband.X' daGridRubberband.Y + daGridRubberband.Height)  						};  					using (SolidBrush tmp = new SolidBrush(Color.FromArgb(32' Color.Black)))  						e.Graphics.FillPolygon(tmp' points);  					e.Graphics.DrawPolygon(BlackPen' points);  					}    				additionalGraphics.Clear();      				// Statusinfo zeichnen:  				if (selectedVehicle != null && cbRenderVehiclesDebug.Checked)  					{  					selectedVehicle.DrawDebugData(e.Graphics);  					}    				renderStopwatch.Stop();      				if (cbRenderFps.Checked)  					{  					e.Graphics.Transform = new Matrix(1' 0' 0' 1' 0' 0);  					e.Graphics.DrawString(  						"thinking time: " + thinkStopwatch.ElapsedMilliseconds + "ms' possible thoughts per second: " + ((thinkStopwatch.ElapsedMilliseconds != 0) ? (1000 / thinkStopwatch.ElapsedMilliseconds).ToString() : "-")'  						new Font("Arial"' 10)'  						new SolidBrush(Color.Black)'  						8'  						40);    					e.Graphics.DrawString(  						"rendering time: " + renderStopwatch.ElapsedMilliseconds + "ms' possible fps: " + ((renderStopwatch.ElapsedMilliseconds != 0) ? (1000 / renderStopwatch.ElapsedMilliseconds).ToString() : "-")'  						new Font("Arial"' 10)'  						new SolidBrush(Color.Black)'  						8'  						56);  					}  				}
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,DaGrid_Paint,The following statement contains a magic number: using (Pen BlackPen = new Pen(Color.Black' 1.0F))  				{  				// Zusätzliche Grafiken zeichnen  				foreach (GraphicsPath gp in additionalGraphics)  					{  					e.Graphics.DrawPath(BlackPen' gp);  					}    				nodeSteuerung.RenderNetwork(e.Graphics' renderOptionsDaGrid);    				//to-/fromLineNode malen  				foreach (LineNode ln in toLineNodes)  					{  					RectangleF foo = ln.positionRect;  					foo.Inflate(4' 4);  					e.Graphics.FillEllipse(new SolidBrush(Color.Red)' foo);  					}  				foreach (LineNode ln in fromLineNodes)  					{  					RectangleF foo = ln.positionRect;  					foo.Inflate(4' 4);  					e.Graphics.FillEllipse(new SolidBrush(Color.Green)' foo);  					}  	  				if (selectedLineNodes.Count >= 1)  					{  					if (cbRenderLineNodes.Checked)  						{  						foreach (LineNode ln in selectedLineNodes)  							{  							foreach (GraphicsPath gp in ln.nodeGraphics)  								{  								e.Graphics.DrawPath(BlackPen' gp);  								}    							RectangleF foo = ln.positionRect;  							foo.Inflate(2' 2);  							e.Graphics.FillEllipse(new SolidBrush(Color.Black)' foo);  							}    						RectangleF foo2 = m_selectedLineNodes[0].positionRect;  						foo2.Inflate(4' 4);  						e.Graphics.DrawEllipse(BlackPen' foo2);  						}    					List<Vector2> points = new List<Vector2>(selectedLineNodes.Count);  					foreach (LineNode ln in selectedLineNodes)  						{  						points.Add(ln.position);  						}  					// build convex hull  					GraphicsPath hullPath = AlgorithmicGeometry.roundedConvexHullPath(points' 16);    					using (SolidBrush tmp = new SolidBrush(Color.FromArgb(64' Color.Gold)))  						e.Graphics.FillPath(tmp' hullPath);  					using (Pen tmp = new Pen(Color.Gold' 3))  						e.Graphics.DrawPath(tmp' hullPath);  					}    				if (trafficLightForm.selectedEntry != null)  					{  					List<Pair<SpecificIntersection' double>> foo = trafficLightForm.selectedEntry.parentGroup.GetConflictPoints(trafficLightForm.selectedEntry);  					if (foo != null)  						{  						using (Pen bar = new Pen(Color.Blue' 2))  							{  							foreach (Pair<SpecificIntersection' double> p in foo)  								{  								List<Vector2> l = new List<Vector2>();  								l.Add(p.Left.intersection.aPosition);  								e.Graphics.DrawPath(bar' AlgorithmicGeometry.roundedConvexHullPath(l' 8));  								}  							}  						}  					}    				// selektierte NodeConnection malen  				if (selectedNodeConnection != null)  					{  					selectedNodeConnection.lineSegment.Draw(e.Graphics' BlackPen);  					}    				if (selectedVehicle != null && renderOptionsDaGrid.renderVehicleDebugData)  					{  					Pen prevNodeConnectionsPen = new Pen(Color.Red' 3);  					Pen nextNodeConnectionsPen = new Pen(Color.Green' 3);    					foreach (NodeConnection prevNC in selectedVehicle.visitedNodeConnections)  						{  						e.Graphics.DrawBezier(prevNodeConnectionsPen' prevNC.lineSegment.p0' prevNC.lineSegment.p1' prevNC.lineSegment.p2' prevNC.lineSegment.p3);  						}  					foreach (Routing.RouteSegment rs in selectedVehicle.wayToGo)  						{  						if (!rs.lineChangeNeeded)  							{  							NodeConnection nextNC = rs.startConnection;  							e.Graphics.DrawBezier(nextNodeConnectionsPen' nextNC.lineSegment.p0' nextNC.lineSegment.p1' nextNC.lineSegment.p2' nextNC.lineSegment.p3);  							}  						else  							{  							e.Graphics.DrawLine(nextNodeConnectionsPen' rs.startConnection.startNode.position' rs.nextNode.position);  							}  						}  					}      				// Gummiband zeichnen  				if (howToDrag == DragNDrop.DRAG_RUBBERBAND)  					{  					Point[] points =   						{  							new Point(daGridRubberband.X' daGridRubberband.Y)'  							new Point(daGridRubberband.X + daGridRubberband.Width' daGridRubberband.Y)'  							new Point(daGridRubberband.X + daGridRubberband.Width' daGridRubberband.Y + daGridRubberband.Height)'  							new Point(daGridRubberband.X' daGridRubberband.Y + daGridRubberband.Height)  						};  					using (SolidBrush tmp = new SolidBrush(Color.FromArgb(32' Color.Black)))  						e.Graphics.FillPolygon(tmp' points);  					e.Graphics.DrawPolygon(BlackPen' points);  					}    				additionalGraphics.Clear();      				// Statusinfo zeichnen:  				if (selectedVehicle != null && cbRenderVehiclesDebug.Checked)  					{  					selectedVehicle.DrawDebugData(e.Graphics);  					}    				renderStopwatch.Stop();      				if (cbRenderFps.Checked)  					{  					e.Graphics.Transform = new Matrix(1' 0' 0' 1' 0' 0);  					e.Graphics.DrawString(  						"thinking time: " + thinkStopwatch.ElapsedMilliseconds + "ms' possible thoughts per second: " + ((thinkStopwatch.ElapsedMilliseconds != 0) ? (1000 / thinkStopwatch.ElapsedMilliseconds).ToString() : "-")'  						new Font("Arial"' 10)'  						new SolidBrush(Color.Black)'  						8'  						40);    					e.Graphics.DrawString(  						"rendering time: " + renderStopwatch.ElapsedMilliseconds + "ms' possible fps: " + ((renderStopwatch.ElapsedMilliseconds != 0) ? (1000 / renderStopwatch.ElapsedMilliseconds).ToString() : "-")'  						new Font("Arial"' 10)'  						new SolidBrush(Color.Black)'  						8'  						56);  					}  				}
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,DaGrid_Paint,The following statement contains a magic number: using (Pen BlackPen = new Pen(Color.Black' 1.0F))  				{  				// Zusätzliche Grafiken zeichnen  				foreach (GraphicsPath gp in additionalGraphics)  					{  					e.Graphics.DrawPath(BlackPen' gp);  					}    				nodeSteuerung.RenderNetwork(e.Graphics' renderOptionsDaGrid);    				//to-/fromLineNode malen  				foreach (LineNode ln in toLineNodes)  					{  					RectangleF foo = ln.positionRect;  					foo.Inflate(4' 4);  					e.Graphics.FillEllipse(new SolidBrush(Color.Red)' foo);  					}  				foreach (LineNode ln in fromLineNodes)  					{  					RectangleF foo = ln.positionRect;  					foo.Inflate(4' 4);  					e.Graphics.FillEllipse(new SolidBrush(Color.Green)' foo);  					}  	  				if (selectedLineNodes.Count >= 1)  					{  					if (cbRenderLineNodes.Checked)  						{  						foreach (LineNode ln in selectedLineNodes)  							{  							foreach (GraphicsPath gp in ln.nodeGraphics)  								{  								e.Graphics.DrawPath(BlackPen' gp);  								}    							RectangleF foo = ln.positionRect;  							foo.Inflate(2' 2);  							e.Graphics.FillEllipse(new SolidBrush(Color.Black)' foo);  							}    						RectangleF foo2 = m_selectedLineNodes[0].positionRect;  						foo2.Inflate(4' 4);  						e.Graphics.DrawEllipse(BlackPen' foo2);  						}    					List<Vector2> points = new List<Vector2>(selectedLineNodes.Count);  					foreach (LineNode ln in selectedLineNodes)  						{  						points.Add(ln.position);  						}  					// build convex hull  					GraphicsPath hullPath = AlgorithmicGeometry.roundedConvexHullPath(points' 16);    					using (SolidBrush tmp = new SolidBrush(Color.FromArgb(64' Color.Gold)))  						e.Graphics.FillPath(tmp' hullPath);  					using (Pen tmp = new Pen(Color.Gold' 3))  						e.Graphics.DrawPath(tmp' hullPath);  					}    				if (trafficLightForm.selectedEntry != null)  					{  					List<Pair<SpecificIntersection' double>> foo = trafficLightForm.selectedEntry.parentGroup.GetConflictPoints(trafficLightForm.selectedEntry);  					if (foo != null)  						{  						using (Pen bar = new Pen(Color.Blue' 2))  							{  							foreach (Pair<SpecificIntersection' double> p in foo)  								{  								List<Vector2> l = new List<Vector2>();  								l.Add(p.Left.intersection.aPosition);  								e.Graphics.DrawPath(bar' AlgorithmicGeometry.roundedConvexHullPath(l' 8));  								}  							}  						}  					}    				// selektierte NodeConnection malen  				if (selectedNodeConnection != null)  					{  					selectedNodeConnection.lineSegment.Draw(e.Graphics' BlackPen);  					}    				if (selectedVehicle != null && renderOptionsDaGrid.renderVehicleDebugData)  					{  					Pen prevNodeConnectionsPen = new Pen(Color.Red' 3);  					Pen nextNodeConnectionsPen = new Pen(Color.Green' 3);    					foreach (NodeConnection prevNC in selectedVehicle.visitedNodeConnections)  						{  						e.Graphics.DrawBezier(prevNodeConnectionsPen' prevNC.lineSegment.p0' prevNC.lineSegment.p1' prevNC.lineSegment.p2' prevNC.lineSegment.p3);  						}  					foreach (Routing.RouteSegment rs in selectedVehicle.wayToGo)  						{  						if (!rs.lineChangeNeeded)  							{  							NodeConnection nextNC = rs.startConnection;  							e.Graphics.DrawBezier(nextNodeConnectionsPen' nextNC.lineSegment.p0' nextNC.lineSegment.p1' nextNC.lineSegment.p2' nextNC.lineSegment.p3);  							}  						else  							{  							e.Graphics.DrawLine(nextNodeConnectionsPen' rs.startConnection.startNode.position' rs.nextNode.position);  							}  						}  					}      				// Gummiband zeichnen  				if (howToDrag == DragNDrop.DRAG_RUBBERBAND)  					{  					Point[] points =   						{  							new Point(daGridRubberband.X' daGridRubberband.Y)'  							new Point(daGridRubberband.X + daGridRubberband.Width' daGridRubberband.Y)'  							new Point(daGridRubberband.X + daGridRubberband.Width' daGridRubberband.Y + daGridRubberband.Height)'  							new Point(daGridRubberband.X' daGridRubberband.Y + daGridRubberband.Height)  						};  					using (SolidBrush tmp = new SolidBrush(Color.FromArgb(32' Color.Black)))  						e.Graphics.FillPolygon(tmp' points);  					e.Graphics.DrawPolygon(BlackPen' points);  					}    				additionalGraphics.Clear();      				// Statusinfo zeichnen:  				if (selectedVehicle != null && cbRenderVehiclesDebug.Checked)  					{  					selectedVehicle.DrawDebugData(e.Graphics);  					}    				renderStopwatch.Stop();      				if (cbRenderFps.Checked)  					{  					e.Graphics.Transform = new Matrix(1' 0' 0' 1' 0' 0);  					e.Graphics.DrawString(  						"thinking time: " + thinkStopwatch.ElapsedMilliseconds + "ms' possible thoughts per second: " + ((thinkStopwatch.ElapsedMilliseconds != 0) ? (1000 / thinkStopwatch.ElapsedMilliseconds).ToString() : "-")'  						new Font("Arial"' 10)'  						new SolidBrush(Color.Black)'  						8'  						40);    					e.Graphics.DrawString(  						"rendering time: " + renderStopwatch.ElapsedMilliseconds + "ms' possible fps: " + ((renderStopwatch.ElapsedMilliseconds != 0) ? (1000 / renderStopwatch.ElapsedMilliseconds).ToString() : "-")'  						new Font("Arial"' 10)'  						new SolidBrush(Color.Black)'  						8'  						56);  					}  				}
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,DaGrid_Paint,The following statement contains a magic number: using (Pen BlackPen = new Pen(Color.Black' 1.0F))  				{  				// Zusätzliche Grafiken zeichnen  				foreach (GraphicsPath gp in additionalGraphics)  					{  					e.Graphics.DrawPath(BlackPen' gp);  					}    				nodeSteuerung.RenderNetwork(e.Graphics' renderOptionsDaGrid);    				//to-/fromLineNode malen  				foreach (LineNode ln in toLineNodes)  					{  					RectangleF foo = ln.positionRect;  					foo.Inflate(4' 4);  					e.Graphics.FillEllipse(new SolidBrush(Color.Red)' foo);  					}  				foreach (LineNode ln in fromLineNodes)  					{  					RectangleF foo = ln.positionRect;  					foo.Inflate(4' 4);  					e.Graphics.FillEllipse(new SolidBrush(Color.Green)' foo);  					}  	  				if (selectedLineNodes.Count >= 1)  					{  					if (cbRenderLineNodes.Checked)  						{  						foreach (LineNode ln in selectedLineNodes)  							{  							foreach (GraphicsPath gp in ln.nodeGraphics)  								{  								e.Graphics.DrawPath(BlackPen' gp);  								}    							RectangleF foo = ln.positionRect;  							foo.Inflate(2' 2);  							e.Graphics.FillEllipse(new SolidBrush(Color.Black)' foo);  							}    						RectangleF foo2 = m_selectedLineNodes[0].positionRect;  						foo2.Inflate(4' 4);  						e.Graphics.DrawEllipse(BlackPen' foo2);  						}    					List<Vector2> points = new List<Vector2>(selectedLineNodes.Count);  					foreach (LineNode ln in selectedLineNodes)  						{  						points.Add(ln.position);  						}  					// build convex hull  					GraphicsPath hullPath = AlgorithmicGeometry.roundedConvexHullPath(points' 16);    					using (SolidBrush tmp = new SolidBrush(Color.FromArgb(64' Color.Gold)))  						e.Graphics.FillPath(tmp' hullPath);  					using (Pen tmp = new Pen(Color.Gold' 3))  						e.Graphics.DrawPath(tmp' hullPath);  					}    				if (trafficLightForm.selectedEntry != null)  					{  					List<Pair<SpecificIntersection' double>> foo = trafficLightForm.selectedEntry.parentGroup.GetConflictPoints(trafficLightForm.selectedEntry);  					if (foo != null)  						{  						using (Pen bar = new Pen(Color.Blue' 2))  							{  							foreach (Pair<SpecificIntersection' double> p in foo)  								{  								List<Vector2> l = new List<Vector2>();  								l.Add(p.Left.intersection.aPosition);  								e.Graphics.DrawPath(bar' AlgorithmicGeometry.roundedConvexHullPath(l' 8));  								}  							}  						}  					}    				// selektierte NodeConnection malen  				if (selectedNodeConnection != null)  					{  					selectedNodeConnection.lineSegment.Draw(e.Graphics' BlackPen);  					}    				if (selectedVehicle != null && renderOptionsDaGrid.renderVehicleDebugData)  					{  					Pen prevNodeConnectionsPen = new Pen(Color.Red' 3);  					Pen nextNodeConnectionsPen = new Pen(Color.Green' 3);    					foreach (NodeConnection prevNC in selectedVehicle.visitedNodeConnections)  						{  						e.Graphics.DrawBezier(prevNodeConnectionsPen' prevNC.lineSegment.p0' prevNC.lineSegment.p1' prevNC.lineSegment.p2' prevNC.lineSegment.p3);  						}  					foreach (Routing.RouteSegment rs in selectedVehicle.wayToGo)  						{  						if (!rs.lineChangeNeeded)  							{  							NodeConnection nextNC = rs.startConnection;  							e.Graphics.DrawBezier(nextNodeConnectionsPen' nextNC.lineSegment.p0' nextNC.lineSegment.p1' nextNC.lineSegment.p2' nextNC.lineSegment.p3);  							}  						else  							{  							e.Graphics.DrawLine(nextNodeConnectionsPen' rs.startConnection.startNode.position' rs.nextNode.position);  							}  						}  					}      				// Gummiband zeichnen  				if (howToDrag == DragNDrop.DRAG_RUBBERBAND)  					{  					Point[] points =   						{  							new Point(daGridRubberband.X' daGridRubberband.Y)'  							new Point(daGridRubberband.X + daGridRubberband.Width' daGridRubberband.Y)'  							new Point(daGridRubberband.X + daGridRubberband.Width' daGridRubberband.Y + daGridRubberband.Height)'  							new Point(daGridRubberband.X' daGridRubberband.Y + daGridRubberband.Height)  						};  					using (SolidBrush tmp = new SolidBrush(Color.FromArgb(32' Color.Black)))  						e.Graphics.FillPolygon(tmp' points);  					e.Graphics.DrawPolygon(BlackPen' points);  					}    				additionalGraphics.Clear();      				// Statusinfo zeichnen:  				if (selectedVehicle != null && cbRenderVehiclesDebug.Checked)  					{  					selectedVehicle.DrawDebugData(e.Graphics);  					}    				renderStopwatch.Stop();      				if (cbRenderFps.Checked)  					{  					e.Graphics.Transform = new Matrix(1' 0' 0' 1' 0' 0);  					e.Graphics.DrawString(  						"thinking time: " + thinkStopwatch.ElapsedMilliseconds + "ms' possible thoughts per second: " + ((thinkStopwatch.ElapsedMilliseconds != 0) ? (1000 / thinkStopwatch.ElapsedMilliseconds).ToString() : "-")'  						new Font("Arial"' 10)'  						new SolidBrush(Color.Black)'  						8'  						40);    					e.Graphics.DrawString(  						"rendering time: " + renderStopwatch.ElapsedMilliseconds + "ms' possible fps: " + ((renderStopwatch.ElapsedMilliseconds != 0) ? (1000 / renderStopwatch.ElapsedMilliseconds).ToString() : "-")'  						new Font("Arial"' 10)'  						new SolidBrush(Color.Black)'  						8'  						56);  					}  				}
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,DaGrid_Paint,The following statement contains a magic number: using (Pen BlackPen = new Pen(Color.Black' 1.0F))  				{  				// Zusätzliche Grafiken zeichnen  				foreach (GraphicsPath gp in additionalGraphics)  					{  					e.Graphics.DrawPath(BlackPen' gp);  					}    				nodeSteuerung.RenderNetwork(e.Graphics' renderOptionsDaGrid);    				//to-/fromLineNode malen  				foreach (LineNode ln in toLineNodes)  					{  					RectangleF foo = ln.positionRect;  					foo.Inflate(4' 4);  					e.Graphics.FillEllipse(new SolidBrush(Color.Red)' foo);  					}  				foreach (LineNode ln in fromLineNodes)  					{  					RectangleF foo = ln.positionRect;  					foo.Inflate(4' 4);  					e.Graphics.FillEllipse(new SolidBrush(Color.Green)' foo);  					}  	  				if (selectedLineNodes.Count >= 1)  					{  					if (cbRenderLineNodes.Checked)  						{  						foreach (LineNode ln in selectedLineNodes)  							{  							foreach (GraphicsPath gp in ln.nodeGraphics)  								{  								e.Graphics.DrawPath(BlackPen' gp);  								}    							RectangleF foo = ln.positionRect;  							foo.Inflate(2' 2);  							e.Graphics.FillEllipse(new SolidBrush(Color.Black)' foo);  							}    						RectangleF foo2 = m_selectedLineNodes[0].positionRect;  						foo2.Inflate(4' 4);  						e.Graphics.DrawEllipse(BlackPen' foo2);  						}    					List<Vector2> points = new List<Vector2>(selectedLineNodes.Count);  					foreach (LineNode ln in selectedLineNodes)  						{  						points.Add(ln.position);  						}  					// build convex hull  					GraphicsPath hullPath = AlgorithmicGeometry.roundedConvexHullPath(points' 16);    					using (SolidBrush tmp = new SolidBrush(Color.FromArgb(64' Color.Gold)))  						e.Graphics.FillPath(tmp' hullPath);  					using (Pen tmp = new Pen(Color.Gold' 3))  						e.Graphics.DrawPath(tmp' hullPath);  					}    				if (trafficLightForm.selectedEntry != null)  					{  					List<Pair<SpecificIntersection' double>> foo = trafficLightForm.selectedEntry.parentGroup.GetConflictPoints(trafficLightForm.selectedEntry);  					if (foo != null)  						{  						using (Pen bar = new Pen(Color.Blue' 2))  							{  							foreach (Pair<SpecificIntersection' double> p in foo)  								{  								List<Vector2> l = new List<Vector2>();  								l.Add(p.Left.intersection.aPosition);  								e.Graphics.DrawPath(bar' AlgorithmicGeometry.roundedConvexHullPath(l' 8));  								}  							}  						}  					}    				// selektierte NodeConnection malen  				if (selectedNodeConnection != null)  					{  					selectedNodeConnection.lineSegment.Draw(e.Graphics' BlackPen);  					}    				if (selectedVehicle != null && renderOptionsDaGrid.renderVehicleDebugData)  					{  					Pen prevNodeConnectionsPen = new Pen(Color.Red' 3);  					Pen nextNodeConnectionsPen = new Pen(Color.Green' 3);    					foreach (NodeConnection prevNC in selectedVehicle.visitedNodeConnections)  						{  						e.Graphics.DrawBezier(prevNodeConnectionsPen' prevNC.lineSegment.p0' prevNC.lineSegment.p1' prevNC.lineSegment.p2' prevNC.lineSegment.p3);  						}  					foreach (Routing.RouteSegment rs in selectedVehicle.wayToGo)  						{  						if (!rs.lineChangeNeeded)  							{  							NodeConnection nextNC = rs.startConnection;  							e.Graphics.DrawBezier(nextNodeConnectionsPen' nextNC.lineSegment.p0' nextNC.lineSegment.p1' nextNC.lineSegment.p2' nextNC.lineSegment.p3);  							}  						else  							{  							e.Graphics.DrawLine(nextNodeConnectionsPen' rs.startConnection.startNode.position' rs.nextNode.position);  							}  						}  					}      				// Gummiband zeichnen  				if (howToDrag == DragNDrop.DRAG_RUBBERBAND)  					{  					Point[] points =   						{  							new Point(daGridRubberband.X' daGridRubberband.Y)'  							new Point(daGridRubberband.X + daGridRubberband.Width' daGridRubberband.Y)'  							new Point(daGridRubberband.X + daGridRubberband.Width' daGridRubberband.Y + daGridRubberband.Height)'  							new Point(daGridRubberband.X' daGridRubberband.Y + daGridRubberband.Height)  						};  					using (SolidBrush tmp = new SolidBrush(Color.FromArgb(32' Color.Black)))  						e.Graphics.FillPolygon(tmp' points);  					e.Graphics.DrawPolygon(BlackPen' points);  					}    				additionalGraphics.Clear();      				// Statusinfo zeichnen:  				if (selectedVehicle != null && cbRenderVehiclesDebug.Checked)  					{  					selectedVehicle.DrawDebugData(e.Graphics);  					}    				renderStopwatch.Stop();      				if (cbRenderFps.Checked)  					{  					e.Graphics.Transform = new Matrix(1' 0' 0' 1' 0' 0);  					e.Graphics.DrawString(  						"thinking time: " + thinkStopwatch.ElapsedMilliseconds + "ms' possible thoughts per second: " + ((thinkStopwatch.ElapsedMilliseconds != 0) ? (1000 / thinkStopwatch.ElapsedMilliseconds).ToString() : "-")'  						new Font("Arial"' 10)'  						new SolidBrush(Color.Black)'  						8'  						40);    					e.Graphics.DrawString(  						"rendering time: " + renderStopwatch.ElapsedMilliseconds + "ms' possible fps: " + ((renderStopwatch.ElapsedMilliseconds != 0) ? (1000 / renderStopwatch.ElapsedMilliseconds).ToString() : "-")'  						new Font("Arial"' 10)'  						new SolidBrush(Color.Black)'  						8'  						56);  					}  				}
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,DaGrid_Paint,The following statement contains a magic number: using (Pen BlackPen = new Pen(Color.Black' 1.0F))  				{  				// Zusätzliche Grafiken zeichnen  				foreach (GraphicsPath gp in additionalGraphics)  					{  					e.Graphics.DrawPath(BlackPen' gp);  					}    				nodeSteuerung.RenderNetwork(e.Graphics' renderOptionsDaGrid);    				//to-/fromLineNode malen  				foreach (LineNode ln in toLineNodes)  					{  					RectangleF foo = ln.positionRect;  					foo.Inflate(4' 4);  					e.Graphics.FillEllipse(new SolidBrush(Color.Red)' foo);  					}  				foreach (LineNode ln in fromLineNodes)  					{  					RectangleF foo = ln.positionRect;  					foo.Inflate(4' 4);  					e.Graphics.FillEllipse(new SolidBrush(Color.Green)' foo);  					}  	  				if (selectedLineNodes.Count >= 1)  					{  					if (cbRenderLineNodes.Checked)  						{  						foreach (LineNode ln in selectedLineNodes)  							{  							foreach (GraphicsPath gp in ln.nodeGraphics)  								{  								e.Graphics.DrawPath(BlackPen' gp);  								}    							RectangleF foo = ln.positionRect;  							foo.Inflate(2' 2);  							e.Graphics.FillEllipse(new SolidBrush(Color.Black)' foo);  							}    						RectangleF foo2 = m_selectedLineNodes[0].positionRect;  						foo2.Inflate(4' 4);  						e.Graphics.DrawEllipse(BlackPen' foo2);  						}    					List<Vector2> points = new List<Vector2>(selectedLineNodes.Count);  					foreach (LineNode ln in selectedLineNodes)  						{  						points.Add(ln.position);  						}  					// build convex hull  					GraphicsPath hullPath = AlgorithmicGeometry.roundedConvexHullPath(points' 16);    					using (SolidBrush tmp = new SolidBrush(Color.FromArgb(64' Color.Gold)))  						e.Graphics.FillPath(tmp' hullPath);  					using (Pen tmp = new Pen(Color.Gold' 3))  						e.Graphics.DrawPath(tmp' hullPath);  					}    				if (trafficLightForm.selectedEntry != null)  					{  					List<Pair<SpecificIntersection' double>> foo = trafficLightForm.selectedEntry.parentGroup.GetConflictPoints(trafficLightForm.selectedEntry);  					if (foo != null)  						{  						using (Pen bar = new Pen(Color.Blue' 2))  							{  							foreach (Pair<SpecificIntersection' double> p in foo)  								{  								List<Vector2> l = new List<Vector2>();  								l.Add(p.Left.intersection.aPosition);  								e.Graphics.DrawPath(bar' AlgorithmicGeometry.roundedConvexHullPath(l' 8));  								}  							}  						}  					}    				// selektierte NodeConnection malen  				if (selectedNodeConnection != null)  					{  					selectedNodeConnection.lineSegment.Draw(e.Graphics' BlackPen);  					}    				if (selectedVehicle != null && renderOptionsDaGrid.renderVehicleDebugData)  					{  					Pen prevNodeConnectionsPen = new Pen(Color.Red' 3);  					Pen nextNodeConnectionsPen = new Pen(Color.Green' 3);    					foreach (NodeConnection prevNC in selectedVehicle.visitedNodeConnections)  						{  						e.Graphics.DrawBezier(prevNodeConnectionsPen' prevNC.lineSegment.p0' prevNC.lineSegment.p1' prevNC.lineSegment.p2' prevNC.lineSegment.p3);  						}  					foreach (Routing.RouteSegment rs in selectedVehicle.wayToGo)  						{  						if (!rs.lineChangeNeeded)  							{  							NodeConnection nextNC = rs.startConnection;  							e.Graphics.DrawBezier(nextNodeConnectionsPen' nextNC.lineSegment.p0' nextNC.lineSegment.p1' nextNC.lineSegment.p2' nextNC.lineSegment.p3);  							}  						else  							{  							e.Graphics.DrawLine(nextNodeConnectionsPen' rs.startConnection.startNode.position' rs.nextNode.position);  							}  						}  					}      				// Gummiband zeichnen  				if (howToDrag == DragNDrop.DRAG_RUBBERBAND)  					{  					Point[] points =   						{  							new Point(daGridRubberband.X' daGridRubberband.Y)'  							new Point(daGridRubberband.X + daGridRubberband.Width' daGridRubberband.Y)'  							new Point(daGridRubberband.X + daGridRubberband.Width' daGridRubberband.Y + daGridRubberband.Height)'  							new Point(daGridRubberband.X' daGridRubberband.Y + daGridRubberband.Height)  						};  					using (SolidBrush tmp = new SolidBrush(Color.FromArgb(32' Color.Black)))  						e.Graphics.FillPolygon(tmp' points);  					e.Graphics.DrawPolygon(BlackPen' points);  					}    				additionalGraphics.Clear();      				// Statusinfo zeichnen:  				if (selectedVehicle != null && cbRenderVehiclesDebug.Checked)  					{  					selectedVehicle.DrawDebugData(e.Graphics);  					}    				renderStopwatch.Stop();      				if (cbRenderFps.Checked)  					{  					e.Graphics.Transform = new Matrix(1' 0' 0' 1' 0' 0);  					e.Graphics.DrawString(  						"thinking time: " + thinkStopwatch.ElapsedMilliseconds + "ms' possible thoughts per second: " + ((thinkStopwatch.ElapsedMilliseconds != 0) ? (1000 / thinkStopwatch.ElapsedMilliseconds).ToString() : "-")'  						new Font("Arial"' 10)'  						new SolidBrush(Color.Black)'  						8'  						40);    					e.Graphics.DrawString(  						"rendering time: " + renderStopwatch.ElapsedMilliseconds + "ms' possible fps: " + ((renderStopwatch.ElapsedMilliseconds != 0) ? (1000 / renderStopwatch.ElapsedMilliseconds).ToString() : "-")'  						new Font("Arial"' 10)'  						new SolidBrush(Color.Black)'  						8'  						56);  					}  				}
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,DaGrid_Paint,The following statement contains a magic number: using (Pen BlackPen = new Pen(Color.Black' 1.0F))  				{  				// Zusätzliche Grafiken zeichnen  				foreach (GraphicsPath gp in additionalGraphics)  					{  					e.Graphics.DrawPath(BlackPen' gp);  					}    				nodeSteuerung.RenderNetwork(e.Graphics' renderOptionsDaGrid);    				//to-/fromLineNode malen  				foreach (LineNode ln in toLineNodes)  					{  					RectangleF foo = ln.positionRect;  					foo.Inflate(4' 4);  					e.Graphics.FillEllipse(new SolidBrush(Color.Red)' foo);  					}  				foreach (LineNode ln in fromLineNodes)  					{  					RectangleF foo = ln.positionRect;  					foo.Inflate(4' 4);  					e.Graphics.FillEllipse(new SolidBrush(Color.Green)' foo);  					}  	  				if (selectedLineNodes.Count >= 1)  					{  					if (cbRenderLineNodes.Checked)  						{  						foreach (LineNode ln in selectedLineNodes)  							{  							foreach (GraphicsPath gp in ln.nodeGraphics)  								{  								e.Graphics.DrawPath(BlackPen' gp);  								}    							RectangleF foo = ln.positionRect;  							foo.Inflate(2' 2);  							e.Graphics.FillEllipse(new SolidBrush(Color.Black)' foo);  							}    						RectangleF foo2 = m_selectedLineNodes[0].positionRect;  						foo2.Inflate(4' 4);  						e.Graphics.DrawEllipse(BlackPen' foo2);  						}    					List<Vector2> points = new List<Vector2>(selectedLineNodes.Count);  					foreach (LineNode ln in selectedLineNodes)  						{  						points.Add(ln.position);  						}  					// build convex hull  					GraphicsPath hullPath = AlgorithmicGeometry.roundedConvexHullPath(points' 16);    					using (SolidBrush tmp = new SolidBrush(Color.FromArgb(64' Color.Gold)))  						e.Graphics.FillPath(tmp' hullPath);  					using (Pen tmp = new Pen(Color.Gold' 3))  						e.Graphics.DrawPath(tmp' hullPath);  					}    				if (trafficLightForm.selectedEntry != null)  					{  					List<Pair<SpecificIntersection' double>> foo = trafficLightForm.selectedEntry.parentGroup.GetConflictPoints(trafficLightForm.selectedEntry);  					if (foo != null)  						{  						using (Pen bar = new Pen(Color.Blue' 2))  							{  							foreach (Pair<SpecificIntersection' double> p in foo)  								{  								List<Vector2> l = new List<Vector2>();  								l.Add(p.Left.intersection.aPosition);  								e.Graphics.DrawPath(bar' AlgorithmicGeometry.roundedConvexHullPath(l' 8));  								}  							}  						}  					}    				// selektierte NodeConnection malen  				if (selectedNodeConnection != null)  					{  					selectedNodeConnection.lineSegment.Draw(e.Graphics' BlackPen);  					}    				if (selectedVehicle != null && renderOptionsDaGrid.renderVehicleDebugData)  					{  					Pen prevNodeConnectionsPen = new Pen(Color.Red' 3);  					Pen nextNodeConnectionsPen = new Pen(Color.Green' 3);    					foreach (NodeConnection prevNC in selectedVehicle.visitedNodeConnections)  						{  						e.Graphics.DrawBezier(prevNodeConnectionsPen' prevNC.lineSegment.p0' prevNC.lineSegment.p1' prevNC.lineSegment.p2' prevNC.lineSegment.p3);  						}  					foreach (Routing.RouteSegment rs in selectedVehicle.wayToGo)  						{  						if (!rs.lineChangeNeeded)  							{  							NodeConnection nextNC = rs.startConnection;  							e.Graphics.DrawBezier(nextNodeConnectionsPen' nextNC.lineSegment.p0' nextNC.lineSegment.p1' nextNC.lineSegment.p2' nextNC.lineSegment.p3);  							}  						else  							{  							e.Graphics.DrawLine(nextNodeConnectionsPen' rs.startConnection.startNode.position' rs.nextNode.position);  							}  						}  					}      				// Gummiband zeichnen  				if (howToDrag == DragNDrop.DRAG_RUBBERBAND)  					{  					Point[] points =   						{  							new Point(daGridRubberband.X' daGridRubberband.Y)'  							new Point(daGridRubberband.X + daGridRubberband.Width' daGridRubberband.Y)'  							new Point(daGridRubberband.X + daGridRubberband.Width' daGridRubberband.Y + daGridRubberband.Height)'  							new Point(daGridRubberband.X' daGridRubberband.Y + daGridRubberband.Height)  						};  					using (SolidBrush tmp = new SolidBrush(Color.FromArgb(32' Color.Black)))  						e.Graphics.FillPolygon(tmp' points);  					e.Graphics.DrawPolygon(BlackPen' points);  					}    				additionalGraphics.Clear();      				// Statusinfo zeichnen:  				if (selectedVehicle != null && cbRenderVehiclesDebug.Checked)  					{  					selectedVehicle.DrawDebugData(e.Graphics);  					}    				renderStopwatch.Stop();      				if (cbRenderFps.Checked)  					{  					e.Graphics.Transform = new Matrix(1' 0' 0' 1' 0' 0);  					e.Graphics.DrawString(  						"thinking time: " + thinkStopwatch.ElapsedMilliseconds + "ms' possible thoughts per second: " + ((thinkStopwatch.ElapsedMilliseconds != 0) ? (1000 / thinkStopwatch.ElapsedMilliseconds).ToString() : "-")'  						new Font("Arial"' 10)'  						new SolidBrush(Color.Black)'  						8'  						40);    					e.Graphics.DrawString(  						"rendering time: " + renderStopwatch.ElapsedMilliseconds + "ms' possible fps: " + ((renderStopwatch.ElapsedMilliseconds != 0) ? (1000 / renderStopwatch.ElapsedMilliseconds).ToString() : "-")'  						new Font("Arial"' 10)'  						new SolidBrush(Color.Black)'  						8'  						56);  					}  				}
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,DaGrid_Paint,The following statement contains a magic number: using (Pen BlackPen = new Pen(Color.Black' 1.0F))  				{  				// Zusätzliche Grafiken zeichnen  				foreach (GraphicsPath gp in additionalGraphics)  					{  					e.Graphics.DrawPath(BlackPen' gp);  					}    				nodeSteuerung.RenderNetwork(e.Graphics' renderOptionsDaGrid);    				//to-/fromLineNode malen  				foreach (LineNode ln in toLineNodes)  					{  					RectangleF foo = ln.positionRect;  					foo.Inflate(4' 4);  					e.Graphics.FillEllipse(new SolidBrush(Color.Red)' foo);  					}  				foreach (LineNode ln in fromLineNodes)  					{  					RectangleF foo = ln.positionRect;  					foo.Inflate(4' 4);  					e.Graphics.FillEllipse(new SolidBrush(Color.Green)' foo);  					}  	  				if (selectedLineNodes.Count >= 1)  					{  					if (cbRenderLineNodes.Checked)  						{  						foreach (LineNode ln in selectedLineNodes)  							{  							foreach (GraphicsPath gp in ln.nodeGraphics)  								{  								e.Graphics.DrawPath(BlackPen' gp);  								}    							RectangleF foo = ln.positionRect;  							foo.Inflate(2' 2);  							e.Graphics.FillEllipse(new SolidBrush(Color.Black)' foo);  							}    						RectangleF foo2 = m_selectedLineNodes[0].positionRect;  						foo2.Inflate(4' 4);  						e.Graphics.DrawEllipse(BlackPen' foo2);  						}    					List<Vector2> points = new List<Vector2>(selectedLineNodes.Count);  					foreach (LineNode ln in selectedLineNodes)  						{  						points.Add(ln.position);  						}  					// build convex hull  					GraphicsPath hullPath = AlgorithmicGeometry.roundedConvexHullPath(points' 16);    					using (SolidBrush tmp = new SolidBrush(Color.FromArgb(64' Color.Gold)))  						e.Graphics.FillPath(tmp' hullPath);  					using (Pen tmp = new Pen(Color.Gold' 3))  						e.Graphics.DrawPath(tmp' hullPath);  					}    				if (trafficLightForm.selectedEntry != null)  					{  					List<Pair<SpecificIntersection' double>> foo = trafficLightForm.selectedEntry.parentGroup.GetConflictPoints(trafficLightForm.selectedEntry);  					if (foo != null)  						{  						using (Pen bar = new Pen(Color.Blue' 2))  							{  							foreach (Pair<SpecificIntersection' double> p in foo)  								{  								List<Vector2> l = new List<Vector2>();  								l.Add(p.Left.intersection.aPosition);  								e.Graphics.DrawPath(bar' AlgorithmicGeometry.roundedConvexHullPath(l' 8));  								}  							}  						}  					}    				// selektierte NodeConnection malen  				if (selectedNodeConnection != null)  					{  					selectedNodeConnection.lineSegment.Draw(e.Graphics' BlackPen);  					}    				if (selectedVehicle != null && renderOptionsDaGrid.renderVehicleDebugData)  					{  					Pen prevNodeConnectionsPen = new Pen(Color.Red' 3);  					Pen nextNodeConnectionsPen = new Pen(Color.Green' 3);    					foreach (NodeConnection prevNC in selectedVehicle.visitedNodeConnections)  						{  						e.Graphics.DrawBezier(prevNodeConnectionsPen' prevNC.lineSegment.p0' prevNC.lineSegment.p1' prevNC.lineSegment.p2' prevNC.lineSegment.p3);  						}  					foreach (Routing.RouteSegment rs in selectedVehicle.wayToGo)  						{  						if (!rs.lineChangeNeeded)  							{  							NodeConnection nextNC = rs.startConnection;  							e.Graphics.DrawBezier(nextNodeConnectionsPen' nextNC.lineSegment.p0' nextNC.lineSegment.p1' nextNC.lineSegment.p2' nextNC.lineSegment.p3);  							}  						else  							{  							e.Graphics.DrawLine(nextNodeConnectionsPen' rs.startConnection.startNode.position' rs.nextNode.position);  							}  						}  					}      				// Gummiband zeichnen  				if (howToDrag == DragNDrop.DRAG_RUBBERBAND)  					{  					Point[] points =   						{  							new Point(daGridRubberband.X' daGridRubberband.Y)'  							new Point(daGridRubberband.X + daGridRubberband.Width' daGridRubberband.Y)'  							new Point(daGridRubberband.X + daGridRubberband.Width' daGridRubberband.Y + daGridRubberband.Height)'  							new Point(daGridRubberband.X' daGridRubberband.Y + daGridRubberband.Height)  						};  					using (SolidBrush tmp = new SolidBrush(Color.FromArgb(32' Color.Black)))  						e.Graphics.FillPolygon(tmp' points);  					e.Graphics.DrawPolygon(BlackPen' points);  					}    				additionalGraphics.Clear();      				// Statusinfo zeichnen:  				if (selectedVehicle != null && cbRenderVehiclesDebug.Checked)  					{  					selectedVehicle.DrawDebugData(e.Graphics);  					}    				renderStopwatch.Stop();      				if (cbRenderFps.Checked)  					{  					e.Graphics.Transform = new Matrix(1' 0' 0' 1' 0' 0);  					e.Graphics.DrawString(  						"thinking time: " + thinkStopwatch.ElapsedMilliseconds + "ms' possible thoughts per second: " + ((thinkStopwatch.ElapsedMilliseconds != 0) ? (1000 / thinkStopwatch.ElapsedMilliseconds).ToString() : "-")'  						new Font("Arial"' 10)'  						new SolidBrush(Color.Black)'  						8'  						40);    					e.Graphics.DrawString(  						"rendering time: " + renderStopwatch.ElapsedMilliseconds + "ms' possible fps: " + ((renderStopwatch.ElapsedMilliseconds != 0) ? (1000 / renderStopwatch.ElapsedMilliseconds).ToString() : "-")'  						new Font("Arial"' 10)'  						new SolidBrush(Color.Black)'  						8'  						56);  					}  				}
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,DaGrid_Paint,The following statement contains a magic number: using (Pen BlackPen = new Pen(Color.Black' 1.0F))  				{  				// Zusätzliche Grafiken zeichnen  				foreach (GraphicsPath gp in additionalGraphics)  					{  					e.Graphics.DrawPath(BlackPen' gp);  					}    				nodeSteuerung.RenderNetwork(e.Graphics' renderOptionsDaGrid);    				//to-/fromLineNode malen  				foreach (LineNode ln in toLineNodes)  					{  					RectangleF foo = ln.positionRect;  					foo.Inflate(4' 4);  					e.Graphics.FillEllipse(new SolidBrush(Color.Red)' foo);  					}  				foreach (LineNode ln in fromLineNodes)  					{  					RectangleF foo = ln.positionRect;  					foo.Inflate(4' 4);  					e.Graphics.FillEllipse(new SolidBrush(Color.Green)' foo);  					}  	  				if (selectedLineNodes.Count >= 1)  					{  					if (cbRenderLineNodes.Checked)  						{  						foreach (LineNode ln in selectedLineNodes)  							{  							foreach (GraphicsPath gp in ln.nodeGraphics)  								{  								e.Graphics.DrawPath(BlackPen' gp);  								}    							RectangleF foo = ln.positionRect;  							foo.Inflate(2' 2);  							e.Graphics.FillEllipse(new SolidBrush(Color.Black)' foo);  							}    						RectangleF foo2 = m_selectedLineNodes[0].positionRect;  						foo2.Inflate(4' 4);  						e.Graphics.DrawEllipse(BlackPen' foo2);  						}    					List<Vector2> points = new List<Vector2>(selectedLineNodes.Count);  					foreach (LineNode ln in selectedLineNodes)  						{  						points.Add(ln.position);  						}  					// build convex hull  					GraphicsPath hullPath = AlgorithmicGeometry.roundedConvexHullPath(points' 16);    					using (SolidBrush tmp = new SolidBrush(Color.FromArgb(64' Color.Gold)))  						e.Graphics.FillPath(tmp' hullPath);  					using (Pen tmp = new Pen(Color.Gold' 3))  						e.Graphics.DrawPath(tmp' hullPath);  					}    				if (trafficLightForm.selectedEntry != null)  					{  					List<Pair<SpecificIntersection' double>> foo = trafficLightForm.selectedEntry.parentGroup.GetConflictPoints(trafficLightForm.selectedEntry);  					if (foo != null)  						{  						using (Pen bar = new Pen(Color.Blue' 2))  							{  							foreach (Pair<SpecificIntersection' double> p in foo)  								{  								List<Vector2> l = new List<Vector2>();  								l.Add(p.Left.intersection.aPosition);  								e.Graphics.DrawPath(bar' AlgorithmicGeometry.roundedConvexHullPath(l' 8));  								}  							}  						}  					}    				// selektierte NodeConnection malen  				if (selectedNodeConnection != null)  					{  					selectedNodeConnection.lineSegment.Draw(e.Graphics' BlackPen);  					}    				if (selectedVehicle != null && renderOptionsDaGrid.renderVehicleDebugData)  					{  					Pen prevNodeConnectionsPen = new Pen(Color.Red' 3);  					Pen nextNodeConnectionsPen = new Pen(Color.Green' 3);    					foreach (NodeConnection prevNC in selectedVehicle.visitedNodeConnections)  						{  						e.Graphics.DrawBezier(prevNodeConnectionsPen' prevNC.lineSegment.p0' prevNC.lineSegment.p1' prevNC.lineSegment.p2' prevNC.lineSegment.p3);  						}  					foreach (Routing.RouteSegment rs in selectedVehicle.wayToGo)  						{  						if (!rs.lineChangeNeeded)  							{  							NodeConnection nextNC = rs.startConnection;  							e.Graphics.DrawBezier(nextNodeConnectionsPen' nextNC.lineSegment.p0' nextNC.lineSegment.p1' nextNC.lineSegment.p2' nextNC.lineSegment.p3);  							}  						else  							{  							e.Graphics.DrawLine(nextNodeConnectionsPen' rs.startConnection.startNode.position' rs.nextNode.position);  							}  						}  					}      				// Gummiband zeichnen  				if (howToDrag == DragNDrop.DRAG_RUBBERBAND)  					{  					Point[] points =   						{  							new Point(daGridRubberband.X' daGridRubberband.Y)'  							new Point(daGridRubberband.X + daGridRubberband.Width' daGridRubberband.Y)'  							new Point(daGridRubberband.X + daGridRubberband.Width' daGridRubberband.Y + daGridRubberband.Height)'  							new Point(daGridRubberband.X' daGridRubberband.Y + daGridRubberband.Height)  						};  					using (SolidBrush tmp = new SolidBrush(Color.FromArgb(32' Color.Black)))  						e.Graphics.FillPolygon(tmp' points);  					e.Graphics.DrawPolygon(BlackPen' points);  					}    				additionalGraphics.Clear();      				// Statusinfo zeichnen:  				if (selectedVehicle != null && cbRenderVehiclesDebug.Checked)  					{  					selectedVehicle.DrawDebugData(e.Graphics);  					}    				renderStopwatch.Stop();      				if (cbRenderFps.Checked)  					{  					e.Graphics.Transform = new Matrix(1' 0' 0' 1' 0' 0);  					e.Graphics.DrawString(  						"thinking time: " + thinkStopwatch.ElapsedMilliseconds + "ms' possible thoughts per second: " + ((thinkStopwatch.ElapsedMilliseconds != 0) ? (1000 / thinkStopwatch.ElapsedMilliseconds).ToString() : "-")'  						new Font("Arial"' 10)'  						new SolidBrush(Color.Black)'  						8'  						40);    					e.Graphics.DrawString(  						"rendering time: " + renderStopwatch.ElapsedMilliseconds + "ms' possible fps: " + ((renderStopwatch.ElapsedMilliseconds != 0) ? (1000 / renderStopwatch.ElapsedMilliseconds).ToString() : "-")'  						new Font("Arial"' 10)'  						new SolidBrush(Color.Black)'  						8'  						56);  					}  				}
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,DaGrid_Paint,The following statement contains a magic number: using (Pen BlackPen = new Pen(Color.Black' 1.0F))  				{  				// Zusätzliche Grafiken zeichnen  				foreach (GraphicsPath gp in additionalGraphics)  					{  					e.Graphics.DrawPath(BlackPen' gp);  					}    				nodeSteuerung.RenderNetwork(e.Graphics' renderOptionsDaGrid);    				//to-/fromLineNode malen  				foreach (LineNode ln in toLineNodes)  					{  					RectangleF foo = ln.positionRect;  					foo.Inflate(4' 4);  					e.Graphics.FillEllipse(new SolidBrush(Color.Red)' foo);  					}  				foreach (LineNode ln in fromLineNodes)  					{  					RectangleF foo = ln.positionRect;  					foo.Inflate(4' 4);  					e.Graphics.FillEllipse(new SolidBrush(Color.Green)' foo);  					}  	  				if (selectedLineNodes.Count >= 1)  					{  					if (cbRenderLineNodes.Checked)  						{  						foreach (LineNode ln in selectedLineNodes)  							{  							foreach (GraphicsPath gp in ln.nodeGraphics)  								{  								e.Graphics.DrawPath(BlackPen' gp);  								}    							RectangleF foo = ln.positionRect;  							foo.Inflate(2' 2);  							e.Graphics.FillEllipse(new SolidBrush(Color.Black)' foo);  							}    						RectangleF foo2 = m_selectedLineNodes[0].positionRect;  						foo2.Inflate(4' 4);  						e.Graphics.DrawEllipse(BlackPen' foo2);  						}    					List<Vector2> points = new List<Vector2>(selectedLineNodes.Count);  					foreach (LineNode ln in selectedLineNodes)  						{  						points.Add(ln.position);  						}  					// build convex hull  					GraphicsPath hullPath = AlgorithmicGeometry.roundedConvexHullPath(points' 16);    					using (SolidBrush tmp = new SolidBrush(Color.FromArgb(64' Color.Gold)))  						e.Graphics.FillPath(tmp' hullPath);  					using (Pen tmp = new Pen(Color.Gold' 3))  						e.Graphics.DrawPath(tmp' hullPath);  					}    				if (trafficLightForm.selectedEntry != null)  					{  					List<Pair<SpecificIntersection' double>> foo = trafficLightForm.selectedEntry.parentGroup.GetConflictPoints(trafficLightForm.selectedEntry);  					if (foo != null)  						{  						using (Pen bar = new Pen(Color.Blue' 2))  							{  							foreach (Pair<SpecificIntersection' double> p in foo)  								{  								List<Vector2> l = new List<Vector2>();  								l.Add(p.Left.intersection.aPosition);  								e.Graphics.DrawPath(bar' AlgorithmicGeometry.roundedConvexHullPath(l' 8));  								}  							}  						}  					}    				// selektierte NodeConnection malen  				if (selectedNodeConnection != null)  					{  					selectedNodeConnection.lineSegment.Draw(e.Graphics' BlackPen);  					}    				if (selectedVehicle != null && renderOptionsDaGrid.renderVehicleDebugData)  					{  					Pen prevNodeConnectionsPen = new Pen(Color.Red' 3);  					Pen nextNodeConnectionsPen = new Pen(Color.Green' 3);    					foreach (NodeConnection prevNC in selectedVehicle.visitedNodeConnections)  						{  						e.Graphics.DrawBezier(prevNodeConnectionsPen' prevNC.lineSegment.p0' prevNC.lineSegment.p1' prevNC.lineSegment.p2' prevNC.lineSegment.p3);  						}  					foreach (Routing.RouteSegment rs in selectedVehicle.wayToGo)  						{  						if (!rs.lineChangeNeeded)  							{  							NodeConnection nextNC = rs.startConnection;  							e.Graphics.DrawBezier(nextNodeConnectionsPen' nextNC.lineSegment.p0' nextNC.lineSegment.p1' nextNC.lineSegment.p2' nextNC.lineSegment.p3);  							}  						else  							{  							e.Graphics.DrawLine(nextNodeConnectionsPen' rs.startConnection.startNode.position' rs.nextNode.position);  							}  						}  					}      				// Gummiband zeichnen  				if (howToDrag == DragNDrop.DRAG_RUBBERBAND)  					{  					Point[] points =   						{  							new Point(daGridRubberband.X' daGridRubberband.Y)'  							new Point(daGridRubberband.X + daGridRubberband.Width' daGridRubberband.Y)'  							new Point(daGridRubberband.X + daGridRubberband.Width' daGridRubberband.Y + daGridRubberband.Height)'  							new Point(daGridRubberband.X' daGridRubberband.Y + daGridRubberband.Height)  						};  					using (SolidBrush tmp = new SolidBrush(Color.FromArgb(32' Color.Black)))  						e.Graphics.FillPolygon(tmp' points);  					e.Graphics.DrawPolygon(BlackPen' points);  					}    				additionalGraphics.Clear();      				// Statusinfo zeichnen:  				if (selectedVehicle != null && cbRenderVehiclesDebug.Checked)  					{  					selectedVehicle.DrawDebugData(e.Graphics);  					}    				renderStopwatch.Stop();      				if (cbRenderFps.Checked)  					{  					e.Graphics.Transform = new Matrix(1' 0' 0' 1' 0' 0);  					e.Graphics.DrawString(  						"thinking time: " + thinkStopwatch.ElapsedMilliseconds + "ms' possible thoughts per second: " + ((thinkStopwatch.ElapsedMilliseconds != 0) ? (1000 / thinkStopwatch.ElapsedMilliseconds).ToString() : "-")'  						new Font("Arial"' 10)'  						new SolidBrush(Color.Black)'  						8'  						40);    					e.Graphics.DrawString(  						"rendering time: " + renderStopwatch.ElapsedMilliseconds + "ms' possible fps: " + ((renderStopwatch.ElapsedMilliseconds != 0) ? (1000 / renderStopwatch.ElapsedMilliseconds).ToString() : "-")'  						new Font("Arial"' 10)'  						new SolidBrush(Color.Black)'  						8'  						56);  					}  				}
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,DaGrid_Paint,The following statement contains a magic number: using (Pen BlackPen = new Pen(Color.Black' 1.0F))  				{  				// Zusätzliche Grafiken zeichnen  				foreach (GraphicsPath gp in additionalGraphics)  					{  					e.Graphics.DrawPath(BlackPen' gp);  					}    				nodeSteuerung.RenderNetwork(e.Graphics' renderOptionsDaGrid);    				//to-/fromLineNode malen  				foreach (LineNode ln in toLineNodes)  					{  					RectangleF foo = ln.positionRect;  					foo.Inflate(4' 4);  					e.Graphics.FillEllipse(new SolidBrush(Color.Red)' foo);  					}  				foreach (LineNode ln in fromLineNodes)  					{  					RectangleF foo = ln.positionRect;  					foo.Inflate(4' 4);  					e.Graphics.FillEllipse(new SolidBrush(Color.Green)' foo);  					}  	  				if (selectedLineNodes.Count >= 1)  					{  					if (cbRenderLineNodes.Checked)  						{  						foreach (LineNode ln in selectedLineNodes)  							{  							foreach (GraphicsPath gp in ln.nodeGraphics)  								{  								e.Graphics.DrawPath(BlackPen' gp);  								}    							RectangleF foo = ln.positionRect;  							foo.Inflate(2' 2);  							e.Graphics.FillEllipse(new SolidBrush(Color.Black)' foo);  							}    						RectangleF foo2 = m_selectedLineNodes[0].positionRect;  						foo2.Inflate(4' 4);  						e.Graphics.DrawEllipse(BlackPen' foo2);  						}    					List<Vector2> points = new List<Vector2>(selectedLineNodes.Count);  					foreach (LineNode ln in selectedLineNodes)  						{  						points.Add(ln.position);  						}  					// build convex hull  					GraphicsPath hullPath = AlgorithmicGeometry.roundedConvexHullPath(points' 16);    					using (SolidBrush tmp = new SolidBrush(Color.FromArgb(64' Color.Gold)))  						e.Graphics.FillPath(tmp' hullPath);  					using (Pen tmp = new Pen(Color.Gold' 3))  						e.Graphics.DrawPath(tmp' hullPath);  					}    				if (trafficLightForm.selectedEntry != null)  					{  					List<Pair<SpecificIntersection' double>> foo = trafficLightForm.selectedEntry.parentGroup.GetConflictPoints(trafficLightForm.selectedEntry);  					if (foo != null)  						{  						using (Pen bar = new Pen(Color.Blue' 2))  							{  							foreach (Pair<SpecificIntersection' double> p in foo)  								{  								List<Vector2> l = new List<Vector2>();  								l.Add(p.Left.intersection.aPosition);  								e.Graphics.DrawPath(bar' AlgorithmicGeometry.roundedConvexHullPath(l' 8));  								}  							}  						}  					}    				// selektierte NodeConnection malen  				if (selectedNodeConnection != null)  					{  					selectedNodeConnection.lineSegment.Draw(e.Graphics' BlackPen);  					}    				if (selectedVehicle != null && renderOptionsDaGrid.renderVehicleDebugData)  					{  					Pen prevNodeConnectionsPen = new Pen(Color.Red' 3);  					Pen nextNodeConnectionsPen = new Pen(Color.Green' 3);    					foreach (NodeConnection prevNC in selectedVehicle.visitedNodeConnections)  						{  						e.Graphics.DrawBezier(prevNodeConnectionsPen' prevNC.lineSegment.p0' prevNC.lineSegment.p1' prevNC.lineSegment.p2' prevNC.lineSegment.p3);  						}  					foreach (Routing.RouteSegment rs in selectedVehicle.wayToGo)  						{  						if (!rs.lineChangeNeeded)  							{  							NodeConnection nextNC = rs.startConnection;  							e.Graphics.DrawBezier(nextNodeConnectionsPen' nextNC.lineSegment.p0' nextNC.lineSegment.p1' nextNC.lineSegment.p2' nextNC.lineSegment.p3);  							}  						else  							{  							e.Graphics.DrawLine(nextNodeConnectionsPen' rs.startConnection.startNode.position' rs.nextNode.position);  							}  						}  					}      				// Gummiband zeichnen  				if (howToDrag == DragNDrop.DRAG_RUBBERBAND)  					{  					Point[] points =   						{  							new Point(daGridRubberband.X' daGridRubberband.Y)'  							new Point(daGridRubberband.X + daGridRubberband.Width' daGridRubberband.Y)'  							new Point(daGridRubberband.X + daGridRubberband.Width' daGridRubberband.Y + daGridRubberband.Height)'  							new Point(daGridRubberband.X' daGridRubberband.Y + daGridRubberband.Height)  						};  					using (SolidBrush tmp = new SolidBrush(Color.FromArgb(32' Color.Black)))  						e.Graphics.FillPolygon(tmp' points);  					e.Graphics.DrawPolygon(BlackPen' points);  					}    				additionalGraphics.Clear();      				// Statusinfo zeichnen:  				if (selectedVehicle != null && cbRenderVehiclesDebug.Checked)  					{  					selectedVehicle.DrawDebugData(e.Graphics);  					}    				renderStopwatch.Stop();      				if (cbRenderFps.Checked)  					{  					e.Graphics.Transform = new Matrix(1' 0' 0' 1' 0' 0);  					e.Graphics.DrawString(  						"thinking time: " + thinkStopwatch.ElapsedMilliseconds + "ms' possible thoughts per second: " + ((thinkStopwatch.ElapsedMilliseconds != 0) ? (1000 / thinkStopwatch.ElapsedMilliseconds).ToString() : "-")'  						new Font("Arial"' 10)'  						new SolidBrush(Color.Black)'  						8'  						40);    					e.Graphics.DrawString(  						"rendering time: " + renderStopwatch.ElapsedMilliseconds + "ms' possible fps: " + ((renderStopwatch.ElapsedMilliseconds != 0) ? (1000 / renderStopwatch.ElapsedMilliseconds).ToString() : "-")'  						new Font("Arial"' 10)'  						new SolidBrush(Color.Black)'  						8'  						56);  					}  				}
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,DaGrid_Paint,The following statement contains a magic number: using (Pen BlackPen = new Pen(Color.Black' 1.0F))  				{  				// Zusätzliche Grafiken zeichnen  				foreach (GraphicsPath gp in additionalGraphics)  					{  					e.Graphics.DrawPath(BlackPen' gp);  					}    				nodeSteuerung.RenderNetwork(e.Graphics' renderOptionsDaGrid);    				//to-/fromLineNode malen  				foreach (LineNode ln in toLineNodes)  					{  					RectangleF foo = ln.positionRect;  					foo.Inflate(4' 4);  					e.Graphics.FillEllipse(new SolidBrush(Color.Red)' foo);  					}  				foreach (LineNode ln in fromLineNodes)  					{  					RectangleF foo = ln.positionRect;  					foo.Inflate(4' 4);  					e.Graphics.FillEllipse(new SolidBrush(Color.Green)' foo);  					}  	  				if (selectedLineNodes.Count >= 1)  					{  					if (cbRenderLineNodes.Checked)  						{  						foreach (LineNode ln in selectedLineNodes)  							{  							foreach (GraphicsPath gp in ln.nodeGraphics)  								{  								e.Graphics.DrawPath(BlackPen' gp);  								}    							RectangleF foo = ln.positionRect;  							foo.Inflate(2' 2);  							e.Graphics.FillEllipse(new SolidBrush(Color.Black)' foo);  							}    						RectangleF foo2 = m_selectedLineNodes[0].positionRect;  						foo2.Inflate(4' 4);  						e.Graphics.DrawEllipse(BlackPen' foo2);  						}    					List<Vector2> points = new List<Vector2>(selectedLineNodes.Count);  					foreach (LineNode ln in selectedLineNodes)  						{  						points.Add(ln.position);  						}  					// build convex hull  					GraphicsPath hullPath = AlgorithmicGeometry.roundedConvexHullPath(points' 16);    					using (SolidBrush tmp = new SolidBrush(Color.FromArgb(64' Color.Gold)))  						e.Graphics.FillPath(tmp' hullPath);  					using (Pen tmp = new Pen(Color.Gold' 3))  						e.Graphics.DrawPath(tmp' hullPath);  					}    				if (trafficLightForm.selectedEntry != null)  					{  					List<Pair<SpecificIntersection' double>> foo = trafficLightForm.selectedEntry.parentGroup.GetConflictPoints(trafficLightForm.selectedEntry);  					if (foo != null)  						{  						using (Pen bar = new Pen(Color.Blue' 2))  							{  							foreach (Pair<SpecificIntersection' double> p in foo)  								{  								List<Vector2> l = new List<Vector2>();  								l.Add(p.Left.intersection.aPosition);  								e.Graphics.DrawPath(bar' AlgorithmicGeometry.roundedConvexHullPath(l' 8));  								}  							}  						}  					}    				// selektierte NodeConnection malen  				if (selectedNodeConnection != null)  					{  					selectedNodeConnection.lineSegment.Draw(e.Graphics' BlackPen);  					}    				if (selectedVehicle != null && renderOptionsDaGrid.renderVehicleDebugData)  					{  					Pen prevNodeConnectionsPen = new Pen(Color.Red' 3);  					Pen nextNodeConnectionsPen = new Pen(Color.Green' 3);    					foreach (NodeConnection prevNC in selectedVehicle.visitedNodeConnections)  						{  						e.Graphics.DrawBezier(prevNodeConnectionsPen' prevNC.lineSegment.p0' prevNC.lineSegment.p1' prevNC.lineSegment.p2' prevNC.lineSegment.p3);  						}  					foreach (Routing.RouteSegment rs in selectedVehicle.wayToGo)  						{  						if (!rs.lineChangeNeeded)  							{  							NodeConnection nextNC = rs.startConnection;  							e.Graphics.DrawBezier(nextNodeConnectionsPen' nextNC.lineSegment.p0' nextNC.lineSegment.p1' nextNC.lineSegment.p2' nextNC.lineSegment.p3);  							}  						else  							{  							e.Graphics.DrawLine(nextNodeConnectionsPen' rs.startConnection.startNode.position' rs.nextNode.position);  							}  						}  					}      				// Gummiband zeichnen  				if (howToDrag == DragNDrop.DRAG_RUBBERBAND)  					{  					Point[] points =   						{  							new Point(daGridRubberband.X' daGridRubberband.Y)'  							new Point(daGridRubberband.X + daGridRubberband.Width' daGridRubberband.Y)'  							new Point(daGridRubberband.X + daGridRubberband.Width' daGridRubberband.Y + daGridRubberband.Height)'  							new Point(daGridRubberband.X' daGridRubberband.Y + daGridRubberband.Height)  						};  					using (SolidBrush tmp = new SolidBrush(Color.FromArgb(32' Color.Black)))  						e.Graphics.FillPolygon(tmp' points);  					e.Graphics.DrawPolygon(BlackPen' points);  					}    				additionalGraphics.Clear();      				// Statusinfo zeichnen:  				if (selectedVehicle != null && cbRenderVehiclesDebug.Checked)  					{  					selectedVehicle.DrawDebugData(e.Graphics);  					}    				renderStopwatch.Stop();      				if (cbRenderFps.Checked)  					{  					e.Graphics.Transform = new Matrix(1' 0' 0' 1' 0' 0);  					e.Graphics.DrawString(  						"thinking time: " + thinkStopwatch.ElapsedMilliseconds + "ms' possible thoughts per second: " + ((thinkStopwatch.ElapsedMilliseconds != 0) ? (1000 / thinkStopwatch.ElapsedMilliseconds).ToString() : "-")'  						new Font("Arial"' 10)'  						new SolidBrush(Color.Black)'  						8'  						40);    					e.Graphics.DrawString(  						"rendering time: " + renderStopwatch.ElapsedMilliseconds + "ms' possible fps: " + ((renderStopwatch.ElapsedMilliseconds != 0) ? (1000 / renderStopwatch.ElapsedMilliseconds).ToString() : "-")'  						new Font("Arial"' 10)'  						new SolidBrush(Color.Black)'  						8'  						56);  					}  				}
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,DaGrid_Paint,The following statement contains a magic number: using (Pen BlackPen = new Pen(Color.Black' 1.0F))  				{  				// Zusätzliche Grafiken zeichnen  				foreach (GraphicsPath gp in additionalGraphics)  					{  					e.Graphics.DrawPath(BlackPen' gp);  					}    				nodeSteuerung.RenderNetwork(e.Graphics' renderOptionsDaGrid);    				//to-/fromLineNode malen  				foreach (LineNode ln in toLineNodes)  					{  					RectangleF foo = ln.positionRect;  					foo.Inflate(4' 4);  					e.Graphics.FillEllipse(new SolidBrush(Color.Red)' foo);  					}  				foreach (LineNode ln in fromLineNodes)  					{  					RectangleF foo = ln.positionRect;  					foo.Inflate(4' 4);  					e.Graphics.FillEllipse(new SolidBrush(Color.Green)' foo);  					}  	  				if (selectedLineNodes.Count >= 1)  					{  					if (cbRenderLineNodes.Checked)  						{  						foreach (LineNode ln in selectedLineNodes)  							{  							foreach (GraphicsPath gp in ln.nodeGraphics)  								{  								e.Graphics.DrawPath(BlackPen' gp);  								}    							RectangleF foo = ln.positionRect;  							foo.Inflate(2' 2);  							e.Graphics.FillEllipse(new SolidBrush(Color.Black)' foo);  							}    						RectangleF foo2 = m_selectedLineNodes[0].positionRect;  						foo2.Inflate(4' 4);  						e.Graphics.DrawEllipse(BlackPen' foo2);  						}    					List<Vector2> points = new List<Vector2>(selectedLineNodes.Count);  					foreach (LineNode ln in selectedLineNodes)  						{  						points.Add(ln.position);  						}  					// build convex hull  					GraphicsPath hullPath = AlgorithmicGeometry.roundedConvexHullPath(points' 16);    					using (SolidBrush tmp = new SolidBrush(Color.FromArgb(64' Color.Gold)))  						e.Graphics.FillPath(tmp' hullPath);  					using (Pen tmp = new Pen(Color.Gold' 3))  						e.Graphics.DrawPath(tmp' hullPath);  					}    				if (trafficLightForm.selectedEntry != null)  					{  					List<Pair<SpecificIntersection' double>> foo = trafficLightForm.selectedEntry.parentGroup.GetConflictPoints(trafficLightForm.selectedEntry);  					if (foo != null)  						{  						using (Pen bar = new Pen(Color.Blue' 2))  							{  							foreach (Pair<SpecificIntersection' double> p in foo)  								{  								List<Vector2> l = new List<Vector2>();  								l.Add(p.Left.intersection.aPosition);  								e.Graphics.DrawPath(bar' AlgorithmicGeometry.roundedConvexHullPath(l' 8));  								}  							}  						}  					}    				// selektierte NodeConnection malen  				if (selectedNodeConnection != null)  					{  					selectedNodeConnection.lineSegment.Draw(e.Graphics' BlackPen);  					}    				if (selectedVehicle != null && renderOptionsDaGrid.renderVehicleDebugData)  					{  					Pen prevNodeConnectionsPen = new Pen(Color.Red' 3);  					Pen nextNodeConnectionsPen = new Pen(Color.Green' 3);    					foreach (NodeConnection prevNC in selectedVehicle.visitedNodeConnections)  						{  						e.Graphics.DrawBezier(prevNodeConnectionsPen' prevNC.lineSegment.p0' prevNC.lineSegment.p1' prevNC.lineSegment.p2' prevNC.lineSegment.p3);  						}  					foreach (Routing.RouteSegment rs in selectedVehicle.wayToGo)  						{  						if (!rs.lineChangeNeeded)  							{  							NodeConnection nextNC = rs.startConnection;  							e.Graphics.DrawBezier(nextNodeConnectionsPen' nextNC.lineSegment.p0' nextNC.lineSegment.p1' nextNC.lineSegment.p2' nextNC.lineSegment.p3);  							}  						else  							{  							e.Graphics.DrawLine(nextNodeConnectionsPen' rs.startConnection.startNode.position' rs.nextNode.position);  							}  						}  					}      				// Gummiband zeichnen  				if (howToDrag == DragNDrop.DRAG_RUBBERBAND)  					{  					Point[] points =   						{  							new Point(daGridRubberband.X' daGridRubberband.Y)'  							new Point(daGridRubberband.X + daGridRubberband.Width' daGridRubberband.Y)'  							new Point(daGridRubberband.X + daGridRubberband.Width' daGridRubberband.Y + daGridRubberband.Height)'  							new Point(daGridRubberband.X' daGridRubberband.Y + daGridRubberband.Height)  						};  					using (SolidBrush tmp = new SolidBrush(Color.FromArgb(32' Color.Black)))  						e.Graphics.FillPolygon(tmp' points);  					e.Graphics.DrawPolygon(BlackPen' points);  					}    				additionalGraphics.Clear();      				// Statusinfo zeichnen:  				if (selectedVehicle != null && cbRenderVehiclesDebug.Checked)  					{  					selectedVehicle.DrawDebugData(e.Graphics);  					}    				renderStopwatch.Stop();      				if (cbRenderFps.Checked)  					{  					e.Graphics.Transform = new Matrix(1' 0' 0' 1' 0' 0);  					e.Graphics.DrawString(  						"thinking time: " + thinkStopwatch.ElapsedMilliseconds + "ms' possible thoughts per second: " + ((thinkStopwatch.ElapsedMilliseconds != 0) ? (1000 / thinkStopwatch.ElapsedMilliseconds).ToString() : "-")'  						new Font("Arial"' 10)'  						new SolidBrush(Color.Black)'  						8'  						40);    					e.Graphics.DrawString(  						"rendering time: " + renderStopwatch.ElapsedMilliseconds + "ms' possible fps: " + ((renderStopwatch.ElapsedMilliseconds != 0) ? (1000 / renderStopwatch.ElapsedMilliseconds).ToString() : "-")'  						new Font("Arial"' 10)'  						new SolidBrush(Color.Black)'  						8'  						56);  					}  				}
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,DaGrid_Paint,The following statement contains a magic number: using (Pen BlackPen = new Pen(Color.Black' 1.0F))  				{  				// Zusätzliche Grafiken zeichnen  				foreach (GraphicsPath gp in additionalGraphics)  					{  					e.Graphics.DrawPath(BlackPen' gp);  					}    				nodeSteuerung.RenderNetwork(e.Graphics' renderOptionsDaGrid);    				//to-/fromLineNode malen  				foreach (LineNode ln in toLineNodes)  					{  					RectangleF foo = ln.positionRect;  					foo.Inflate(4' 4);  					e.Graphics.FillEllipse(new SolidBrush(Color.Red)' foo);  					}  				foreach (LineNode ln in fromLineNodes)  					{  					RectangleF foo = ln.positionRect;  					foo.Inflate(4' 4);  					e.Graphics.FillEllipse(new SolidBrush(Color.Green)' foo);  					}  	  				if (selectedLineNodes.Count >= 1)  					{  					if (cbRenderLineNodes.Checked)  						{  						foreach (LineNode ln in selectedLineNodes)  							{  							foreach (GraphicsPath gp in ln.nodeGraphics)  								{  								e.Graphics.DrawPath(BlackPen' gp);  								}    							RectangleF foo = ln.positionRect;  							foo.Inflate(2' 2);  							e.Graphics.FillEllipse(new SolidBrush(Color.Black)' foo);  							}    						RectangleF foo2 = m_selectedLineNodes[0].positionRect;  						foo2.Inflate(4' 4);  						e.Graphics.DrawEllipse(BlackPen' foo2);  						}    					List<Vector2> points = new List<Vector2>(selectedLineNodes.Count);  					foreach (LineNode ln in selectedLineNodes)  						{  						points.Add(ln.position);  						}  					// build convex hull  					GraphicsPath hullPath = AlgorithmicGeometry.roundedConvexHullPath(points' 16);    					using (SolidBrush tmp = new SolidBrush(Color.FromArgb(64' Color.Gold)))  						e.Graphics.FillPath(tmp' hullPath);  					using (Pen tmp = new Pen(Color.Gold' 3))  						e.Graphics.DrawPath(tmp' hullPath);  					}    				if (trafficLightForm.selectedEntry != null)  					{  					List<Pair<SpecificIntersection' double>> foo = trafficLightForm.selectedEntry.parentGroup.GetConflictPoints(trafficLightForm.selectedEntry);  					if (foo != null)  						{  						using (Pen bar = new Pen(Color.Blue' 2))  							{  							foreach (Pair<SpecificIntersection' double> p in foo)  								{  								List<Vector2> l = new List<Vector2>();  								l.Add(p.Left.intersection.aPosition);  								e.Graphics.DrawPath(bar' AlgorithmicGeometry.roundedConvexHullPath(l' 8));  								}  							}  						}  					}    				// selektierte NodeConnection malen  				if (selectedNodeConnection != null)  					{  					selectedNodeConnection.lineSegment.Draw(e.Graphics' BlackPen);  					}    				if (selectedVehicle != null && renderOptionsDaGrid.renderVehicleDebugData)  					{  					Pen prevNodeConnectionsPen = new Pen(Color.Red' 3);  					Pen nextNodeConnectionsPen = new Pen(Color.Green' 3);    					foreach (NodeConnection prevNC in selectedVehicle.visitedNodeConnections)  						{  						e.Graphics.DrawBezier(prevNodeConnectionsPen' prevNC.lineSegment.p0' prevNC.lineSegment.p1' prevNC.lineSegment.p2' prevNC.lineSegment.p3);  						}  					foreach (Routing.RouteSegment rs in selectedVehicle.wayToGo)  						{  						if (!rs.lineChangeNeeded)  							{  							NodeConnection nextNC = rs.startConnection;  							e.Graphics.DrawBezier(nextNodeConnectionsPen' nextNC.lineSegment.p0' nextNC.lineSegment.p1' nextNC.lineSegment.p2' nextNC.lineSegment.p3);  							}  						else  							{  							e.Graphics.DrawLine(nextNodeConnectionsPen' rs.startConnection.startNode.position' rs.nextNode.position);  							}  						}  					}      				// Gummiband zeichnen  				if (howToDrag == DragNDrop.DRAG_RUBBERBAND)  					{  					Point[] points =   						{  							new Point(daGridRubberband.X' daGridRubberband.Y)'  							new Point(daGridRubberband.X + daGridRubberband.Width' daGridRubberband.Y)'  							new Point(daGridRubberband.X + daGridRubberband.Width' daGridRubberband.Y + daGridRubberband.Height)'  							new Point(daGridRubberband.X' daGridRubberband.Y + daGridRubberband.Height)  						};  					using (SolidBrush tmp = new SolidBrush(Color.FromArgb(32' Color.Black)))  						e.Graphics.FillPolygon(tmp' points);  					e.Graphics.DrawPolygon(BlackPen' points);  					}    				additionalGraphics.Clear();      				// Statusinfo zeichnen:  				if (selectedVehicle != null && cbRenderVehiclesDebug.Checked)  					{  					selectedVehicle.DrawDebugData(e.Graphics);  					}    				renderStopwatch.Stop();      				if (cbRenderFps.Checked)  					{  					e.Graphics.Transform = new Matrix(1' 0' 0' 1' 0' 0);  					e.Graphics.DrawString(  						"thinking time: " + thinkStopwatch.ElapsedMilliseconds + "ms' possible thoughts per second: " + ((thinkStopwatch.ElapsedMilliseconds != 0) ? (1000 / thinkStopwatch.ElapsedMilliseconds).ToString() : "-")'  						new Font("Arial"' 10)'  						new SolidBrush(Color.Black)'  						8'  						40);    					e.Graphics.DrawString(  						"rendering time: " + renderStopwatch.ElapsedMilliseconds + "ms' possible fps: " + ((renderStopwatch.ElapsedMilliseconds != 0) ? (1000 / renderStopwatch.ElapsedMilliseconds).ToString() : "-")'  						new Font("Arial"' 10)'  						new SolidBrush(Color.Black)'  						8'  						56);  					}  				}
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,DaGrid_Paint,The following statement contains a magic number: using (Pen BlackPen = new Pen(Color.Black' 1.0F))  				{  				// Zusätzliche Grafiken zeichnen  				foreach (GraphicsPath gp in additionalGraphics)  					{  					e.Graphics.DrawPath(BlackPen' gp);  					}    				nodeSteuerung.RenderNetwork(e.Graphics' renderOptionsDaGrid);    				//to-/fromLineNode malen  				foreach (LineNode ln in toLineNodes)  					{  					RectangleF foo = ln.positionRect;  					foo.Inflate(4' 4);  					e.Graphics.FillEllipse(new SolidBrush(Color.Red)' foo);  					}  				foreach (LineNode ln in fromLineNodes)  					{  					RectangleF foo = ln.positionRect;  					foo.Inflate(4' 4);  					e.Graphics.FillEllipse(new SolidBrush(Color.Green)' foo);  					}  	  				if (selectedLineNodes.Count >= 1)  					{  					if (cbRenderLineNodes.Checked)  						{  						foreach (LineNode ln in selectedLineNodes)  							{  							foreach (GraphicsPath gp in ln.nodeGraphics)  								{  								e.Graphics.DrawPath(BlackPen' gp);  								}    							RectangleF foo = ln.positionRect;  							foo.Inflate(2' 2);  							e.Graphics.FillEllipse(new SolidBrush(Color.Black)' foo);  							}    						RectangleF foo2 = m_selectedLineNodes[0].positionRect;  						foo2.Inflate(4' 4);  						e.Graphics.DrawEllipse(BlackPen' foo2);  						}    					List<Vector2> points = new List<Vector2>(selectedLineNodes.Count);  					foreach (LineNode ln in selectedLineNodes)  						{  						points.Add(ln.position);  						}  					// build convex hull  					GraphicsPath hullPath = AlgorithmicGeometry.roundedConvexHullPath(points' 16);    					using (SolidBrush tmp = new SolidBrush(Color.FromArgb(64' Color.Gold)))  						e.Graphics.FillPath(tmp' hullPath);  					using (Pen tmp = new Pen(Color.Gold' 3))  						e.Graphics.DrawPath(tmp' hullPath);  					}    				if (trafficLightForm.selectedEntry != null)  					{  					List<Pair<SpecificIntersection' double>> foo = trafficLightForm.selectedEntry.parentGroup.GetConflictPoints(trafficLightForm.selectedEntry);  					if (foo != null)  						{  						using (Pen bar = new Pen(Color.Blue' 2))  							{  							foreach (Pair<SpecificIntersection' double> p in foo)  								{  								List<Vector2> l = new List<Vector2>();  								l.Add(p.Left.intersection.aPosition);  								e.Graphics.DrawPath(bar' AlgorithmicGeometry.roundedConvexHullPath(l' 8));  								}  							}  						}  					}    				// selektierte NodeConnection malen  				if (selectedNodeConnection != null)  					{  					selectedNodeConnection.lineSegment.Draw(e.Graphics' BlackPen);  					}    				if (selectedVehicle != null && renderOptionsDaGrid.renderVehicleDebugData)  					{  					Pen prevNodeConnectionsPen = new Pen(Color.Red' 3);  					Pen nextNodeConnectionsPen = new Pen(Color.Green' 3);    					foreach (NodeConnection prevNC in selectedVehicle.visitedNodeConnections)  						{  						e.Graphics.DrawBezier(prevNodeConnectionsPen' prevNC.lineSegment.p0' prevNC.lineSegment.p1' prevNC.lineSegment.p2' prevNC.lineSegment.p3);  						}  					foreach (Routing.RouteSegment rs in selectedVehicle.wayToGo)  						{  						if (!rs.lineChangeNeeded)  							{  							NodeConnection nextNC = rs.startConnection;  							e.Graphics.DrawBezier(nextNodeConnectionsPen' nextNC.lineSegment.p0' nextNC.lineSegment.p1' nextNC.lineSegment.p2' nextNC.lineSegment.p3);  							}  						else  							{  							e.Graphics.DrawLine(nextNodeConnectionsPen' rs.startConnection.startNode.position' rs.nextNode.position);  							}  						}  					}      				// Gummiband zeichnen  				if (howToDrag == DragNDrop.DRAG_RUBBERBAND)  					{  					Point[] points =   						{  							new Point(daGridRubberband.X' daGridRubberband.Y)'  							new Point(daGridRubberband.X + daGridRubberband.Width' daGridRubberband.Y)'  							new Point(daGridRubberband.X + daGridRubberband.Width' daGridRubberband.Y + daGridRubberband.Height)'  							new Point(daGridRubberband.X' daGridRubberband.Y + daGridRubberband.Height)  						};  					using (SolidBrush tmp = new SolidBrush(Color.FromArgb(32' Color.Black)))  						e.Graphics.FillPolygon(tmp' points);  					e.Graphics.DrawPolygon(BlackPen' points);  					}    				additionalGraphics.Clear();      				// Statusinfo zeichnen:  				if (selectedVehicle != null && cbRenderVehiclesDebug.Checked)  					{  					selectedVehicle.DrawDebugData(e.Graphics);  					}    				renderStopwatch.Stop();      				if (cbRenderFps.Checked)  					{  					e.Graphics.Transform = new Matrix(1' 0' 0' 1' 0' 0);  					e.Graphics.DrawString(  						"thinking time: " + thinkStopwatch.ElapsedMilliseconds + "ms' possible thoughts per second: " + ((thinkStopwatch.ElapsedMilliseconds != 0) ? (1000 / thinkStopwatch.ElapsedMilliseconds).ToString() : "-")'  						new Font("Arial"' 10)'  						new SolidBrush(Color.Black)'  						8'  						40);    					e.Graphics.DrawString(  						"rendering time: " + renderStopwatch.ElapsedMilliseconds + "ms' possible fps: " + ((renderStopwatch.ElapsedMilliseconds != 0) ? (1000 / renderStopwatch.ElapsedMilliseconds).ToString() : "-")'  						new Font("Arial"' 10)'  						new SolidBrush(Color.Black)'  						8'  						56);  					}  				}
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,DaGrid_Paint,The following statement contains a magic number: using (Pen BlackPen = new Pen(Color.Black' 1.0F))  				{  				// Zusätzliche Grafiken zeichnen  				foreach (GraphicsPath gp in additionalGraphics)  					{  					e.Graphics.DrawPath(BlackPen' gp);  					}    				nodeSteuerung.RenderNetwork(e.Graphics' renderOptionsDaGrid);    				//to-/fromLineNode malen  				foreach (LineNode ln in toLineNodes)  					{  					RectangleF foo = ln.positionRect;  					foo.Inflate(4' 4);  					e.Graphics.FillEllipse(new SolidBrush(Color.Red)' foo);  					}  				foreach (LineNode ln in fromLineNodes)  					{  					RectangleF foo = ln.positionRect;  					foo.Inflate(4' 4);  					e.Graphics.FillEllipse(new SolidBrush(Color.Green)' foo);  					}  	  				if (selectedLineNodes.Count >= 1)  					{  					if (cbRenderLineNodes.Checked)  						{  						foreach (LineNode ln in selectedLineNodes)  							{  							foreach (GraphicsPath gp in ln.nodeGraphics)  								{  								e.Graphics.DrawPath(BlackPen' gp);  								}    							RectangleF foo = ln.positionRect;  							foo.Inflate(2' 2);  							e.Graphics.FillEllipse(new SolidBrush(Color.Black)' foo);  							}    						RectangleF foo2 = m_selectedLineNodes[0].positionRect;  						foo2.Inflate(4' 4);  						e.Graphics.DrawEllipse(BlackPen' foo2);  						}    					List<Vector2> points = new List<Vector2>(selectedLineNodes.Count);  					foreach (LineNode ln in selectedLineNodes)  						{  						points.Add(ln.position);  						}  					// build convex hull  					GraphicsPath hullPath = AlgorithmicGeometry.roundedConvexHullPath(points' 16);    					using (SolidBrush tmp = new SolidBrush(Color.FromArgb(64' Color.Gold)))  						e.Graphics.FillPath(tmp' hullPath);  					using (Pen tmp = new Pen(Color.Gold' 3))  						e.Graphics.DrawPath(tmp' hullPath);  					}    				if (trafficLightForm.selectedEntry != null)  					{  					List<Pair<SpecificIntersection' double>> foo = trafficLightForm.selectedEntry.parentGroup.GetConflictPoints(trafficLightForm.selectedEntry);  					if (foo != null)  						{  						using (Pen bar = new Pen(Color.Blue' 2))  							{  							foreach (Pair<SpecificIntersection' double> p in foo)  								{  								List<Vector2> l = new List<Vector2>();  								l.Add(p.Left.intersection.aPosition);  								e.Graphics.DrawPath(bar' AlgorithmicGeometry.roundedConvexHullPath(l' 8));  								}  							}  						}  					}    				// selektierte NodeConnection malen  				if (selectedNodeConnection != null)  					{  					selectedNodeConnection.lineSegment.Draw(e.Graphics' BlackPen);  					}    				if (selectedVehicle != null && renderOptionsDaGrid.renderVehicleDebugData)  					{  					Pen prevNodeConnectionsPen = new Pen(Color.Red' 3);  					Pen nextNodeConnectionsPen = new Pen(Color.Green' 3);    					foreach (NodeConnection prevNC in selectedVehicle.visitedNodeConnections)  						{  						e.Graphics.DrawBezier(prevNodeConnectionsPen' prevNC.lineSegment.p0' prevNC.lineSegment.p1' prevNC.lineSegment.p2' prevNC.lineSegment.p3);  						}  					foreach (Routing.RouteSegment rs in selectedVehicle.wayToGo)  						{  						if (!rs.lineChangeNeeded)  							{  							NodeConnection nextNC = rs.startConnection;  							e.Graphics.DrawBezier(nextNodeConnectionsPen' nextNC.lineSegment.p0' nextNC.lineSegment.p1' nextNC.lineSegment.p2' nextNC.lineSegment.p3);  							}  						else  							{  							e.Graphics.DrawLine(nextNodeConnectionsPen' rs.startConnection.startNode.position' rs.nextNode.position);  							}  						}  					}      				// Gummiband zeichnen  				if (howToDrag == DragNDrop.DRAG_RUBBERBAND)  					{  					Point[] points =   						{  							new Point(daGridRubberband.X' daGridRubberband.Y)'  							new Point(daGridRubberband.X + daGridRubberband.Width' daGridRubberband.Y)'  							new Point(daGridRubberband.X + daGridRubberband.Width' daGridRubberband.Y + daGridRubberband.Height)'  							new Point(daGridRubberband.X' daGridRubberband.Y + daGridRubberband.Height)  						};  					using (SolidBrush tmp = new SolidBrush(Color.FromArgb(32' Color.Black)))  						e.Graphics.FillPolygon(tmp' points);  					e.Graphics.DrawPolygon(BlackPen' points);  					}    				additionalGraphics.Clear();      				// Statusinfo zeichnen:  				if (selectedVehicle != null && cbRenderVehiclesDebug.Checked)  					{  					selectedVehicle.DrawDebugData(e.Graphics);  					}    				renderStopwatch.Stop();      				if (cbRenderFps.Checked)  					{  					e.Graphics.Transform = new Matrix(1' 0' 0' 1' 0' 0);  					e.Graphics.DrawString(  						"thinking time: " + thinkStopwatch.ElapsedMilliseconds + "ms' possible thoughts per second: " + ((thinkStopwatch.ElapsedMilliseconds != 0) ? (1000 / thinkStopwatch.ElapsedMilliseconds).ToString() : "-")'  						new Font("Arial"' 10)'  						new SolidBrush(Color.Black)'  						8'  						40);    					e.Graphics.DrawString(  						"rendering time: " + renderStopwatch.ElapsedMilliseconds + "ms' possible fps: " + ((renderStopwatch.ElapsedMilliseconds != 0) ? (1000 / renderStopwatch.ElapsedMilliseconds).ToString() : "-")'  						new Font("Arial"' 10)'  						new SolidBrush(Color.Black)'  						8'  						56);  					}  				}
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,DaGrid_Paint,The following statement contains a magic number: using (Pen BlackPen = new Pen(Color.Black' 1.0F))  				{  				// Zusätzliche Grafiken zeichnen  				foreach (GraphicsPath gp in additionalGraphics)  					{  					e.Graphics.DrawPath(BlackPen' gp);  					}    				nodeSteuerung.RenderNetwork(e.Graphics' renderOptionsDaGrid);    				//to-/fromLineNode malen  				foreach (LineNode ln in toLineNodes)  					{  					RectangleF foo = ln.positionRect;  					foo.Inflate(4' 4);  					e.Graphics.FillEllipse(new SolidBrush(Color.Red)' foo);  					}  				foreach (LineNode ln in fromLineNodes)  					{  					RectangleF foo = ln.positionRect;  					foo.Inflate(4' 4);  					e.Graphics.FillEllipse(new SolidBrush(Color.Green)' foo);  					}  	  				if (selectedLineNodes.Count >= 1)  					{  					if (cbRenderLineNodes.Checked)  						{  						foreach (LineNode ln in selectedLineNodes)  							{  							foreach (GraphicsPath gp in ln.nodeGraphics)  								{  								e.Graphics.DrawPath(BlackPen' gp);  								}    							RectangleF foo = ln.positionRect;  							foo.Inflate(2' 2);  							e.Graphics.FillEllipse(new SolidBrush(Color.Black)' foo);  							}    						RectangleF foo2 = m_selectedLineNodes[0].positionRect;  						foo2.Inflate(4' 4);  						e.Graphics.DrawEllipse(BlackPen' foo2);  						}    					List<Vector2> points = new List<Vector2>(selectedLineNodes.Count);  					foreach (LineNode ln in selectedLineNodes)  						{  						points.Add(ln.position);  						}  					// build convex hull  					GraphicsPath hullPath = AlgorithmicGeometry.roundedConvexHullPath(points' 16);    					using (SolidBrush tmp = new SolidBrush(Color.FromArgb(64' Color.Gold)))  						e.Graphics.FillPath(tmp' hullPath);  					using (Pen tmp = new Pen(Color.Gold' 3))  						e.Graphics.DrawPath(tmp' hullPath);  					}    				if (trafficLightForm.selectedEntry != null)  					{  					List<Pair<SpecificIntersection' double>> foo = trafficLightForm.selectedEntry.parentGroup.GetConflictPoints(trafficLightForm.selectedEntry);  					if (foo != null)  						{  						using (Pen bar = new Pen(Color.Blue' 2))  							{  							foreach (Pair<SpecificIntersection' double> p in foo)  								{  								List<Vector2> l = new List<Vector2>();  								l.Add(p.Left.intersection.aPosition);  								e.Graphics.DrawPath(bar' AlgorithmicGeometry.roundedConvexHullPath(l' 8));  								}  							}  						}  					}    				// selektierte NodeConnection malen  				if (selectedNodeConnection != null)  					{  					selectedNodeConnection.lineSegment.Draw(e.Graphics' BlackPen);  					}    				if (selectedVehicle != null && renderOptionsDaGrid.renderVehicleDebugData)  					{  					Pen prevNodeConnectionsPen = new Pen(Color.Red' 3);  					Pen nextNodeConnectionsPen = new Pen(Color.Green' 3);    					foreach (NodeConnection prevNC in selectedVehicle.visitedNodeConnections)  						{  						e.Graphics.DrawBezier(prevNodeConnectionsPen' prevNC.lineSegment.p0' prevNC.lineSegment.p1' prevNC.lineSegment.p2' prevNC.lineSegment.p3);  						}  					foreach (Routing.RouteSegment rs in selectedVehicle.wayToGo)  						{  						if (!rs.lineChangeNeeded)  							{  							NodeConnection nextNC = rs.startConnection;  							e.Graphics.DrawBezier(nextNodeConnectionsPen' nextNC.lineSegment.p0' nextNC.lineSegment.p1' nextNC.lineSegment.p2' nextNC.lineSegment.p3);  							}  						else  							{  							e.Graphics.DrawLine(nextNodeConnectionsPen' rs.startConnection.startNode.position' rs.nextNode.position);  							}  						}  					}      				// Gummiband zeichnen  				if (howToDrag == DragNDrop.DRAG_RUBBERBAND)  					{  					Point[] points =   						{  							new Point(daGridRubberband.X' daGridRubberband.Y)'  							new Point(daGridRubberband.X + daGridRubberband.Width' daGridRubberband.Y)'  							new Point(daGridRubberband.X + daGridRubberband.Width' daGridRubberband.Y + daGridRubberband.Height)'  							new Point(daGridRubberband.X' daGridRubberband.Y + daGridRubberband.Height)  						};  					using (SolidBrush tmp = new SolidBrush(Color.FromArgb(32' Color.Black)))  						e.Graphics.FillPolygon(tmp' points);  					e.Graphics.DrawPolygon(BlackPen' points);  					}    				additionalGraphics.Clear();      				// Statusinfo zeichnen:  				if (selectedVehicle != null && cbRenderVehiclesDebug.Checked)  					{  					selectedVehicle.DrawDebugData(e.Graphics);  					}    				renderStopwatch.Stop();      				if (cbRenderFps.Checked)  					{  					e.Graphics.Transform = new Matrix(1' 0' 0' 1' 0' 0);  					e.Graphics.DrawString(  						"thinking time: " + thinkStopwatch.ElapsedMilliseconds + "ms' possible thoughts per second: " + ((thinkStopwatch.ElapsedMilliseconds != 0) ? (1000 / thinkStopwatch.ElapsedMilliseconds).ToString() : "-")'  						new Font("Arial"' 10)'  						new SolidBrush(Color.Black)'  						8'  						40);    					e.Graphics.DrawString(  						"rendering time: " + renderStopwatch.ElapsedMilliseconds + "ms' possible fps: " + ((renderStopwatch.ElapsedMilliseconds != 0) ? (1000 / renderStopwatch.ElapsedMilliseconds).ToString() : "-")'  						new Font("Arial"' 10)'  						new SolidBrush(Color.Black)'  						8'  						56);  					}  				}
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,DaGrid_Paint,The following statement contains a magic number: using (Pen BlackPen = new Pen(Color.Black' 1.0F))  				{  				// Zusätzliche Grafiken zeichnen  				foreach (GraphicsPath gp in additionalGraphics)  					{  					e.Graphics.DrawPath(BlackPen' gp);  					}    				nodeSteuerung.RenderNetwork(e.Graphics' renderOptionsDaGrid);    				//to-/fromLineNode malen  				foreach (LineNode ln in toLineNodes)  					{  					RectangleF foo = ln.positionRect;  					foo.Inflate(4' 4);  					e.Graphics.FillEllipse(new SolidBrush(Color.Red)' foo);  					}  				foreach (LineNode ln in fromLineNodes)  					{  					RectangleF foo = ln.positionRect;  					foo.Inflate(4' 4);  					e.Graphics.FillEllipse(new SolidBrush(Color.Green)' foo);  					}  	  				if (selectedLineNodes.Count >= 1)  					{  					if (cbRenderLineNodes.Checked)  						{  						foreach (LineNode ln in selectedLineNodes)  							{  							foreach (GraphicsPath gp in ln.nodeGraphics)  								{  								e.Graphics.DrawPath(BlackPen' gp);  								}    							RectangleF foo = ln.positionRect;  							foo.Inflate(2' 2);  							e.Graphics.FillEllipse(new SolidBrush(Color.Black)' foo);  							}    						RectangleF foo2 = m_selectedLineNodes[0].positionRect;  						foo2.Inflate(4' 4);  						e.Graphics.DrawEllipse(BlackPen' foo2);  						}    					List<Vector2> points = new List<Vector2>(selectedLineNodes.Count);  					foreach (LineNode ln in selectedLineNodes)  						{  						points.Add(ln.position);  						}  					// build convex hull  					GraphicsPath hullPath = AlgorithmicGeometry.roundedConvexHullPath(points' 16);    					using (SolidBrush tmp = new SolidBrush(Color.FromArgb(64' Color.Gold)))  						e.Graphics.FillPath(tmp' hullPath);  					using (Pen tmp = new Pen(Color.Gold' 3))  						e.Graphics.DrawPath(tmp' hullPath);  					}    				if (trafficLightForm.selectedEntry != null)  					{  					List<Pair<SpecificIntersection' double>> foo = trafficLightForm.selectedEntry.parentGroup.GetConflictPoints(trafficLightForm.selectedEntry);  					if (foo != null)  						{  						using (Pen bar = new Pen(Color.Blue' 2))  							{  							foreach (Pair<SpecificIntersection' double> p in foo)  								{  								List<Vector2> l = new List<Vector2>();  								l.Add(p.Left.intersection.aPosition);  								e.Graphics.DrawPath(bar' AlgorithmicGeometry.roundedConvexHullPath(l' 8));  								}  							}  						}  					}    				// selektierte NodeConnection malen  				if (selectedNodeConnection != null)  					{  					selectedNodeConnection.lineSegment.Draw(e.Graphics' BlackPen);  					}    				if (selectedVehicle != null && renderOptionsDaGrid.renderVehicleDebugData)  					{  					Pen prevNodeConnectionsPen = new Pen(Color.Red' 3);  					Pen nextNodeConnectionsPen = new Pen(Color.Green' 3);    					foreach (NodeConnection prevNC in selectedVehicle.visitedNodeConnections)  						{  						e.Graphics.DrawBezier(prevNodeConnectionsPen' prevNC.lineSegment.p0' prevNC.lineSegment.p1' prevNC.lineSegment.p2' prevNC.lineSegment.p3);  						}  					foreach (Routing.RouteSegment rs in selectedVehicle.wayToGo)  						{  						if (!rs.lineChangeNeeded)  							{  							NodeConnection nextNC = rs.startConnection;  							e.Graphics.DrawBezier(nextNodeConnectionsPen' nextNC.lineSegment.p0' nextNC.lineSegment.p1' nextNC.lineSegment.p2' nextNC.lineSegment.p3);  							}  						else  							{  							e.Graphics.DrawLine(nextNodeConnectionsPen' rs.startConnection.startNode.position' rs.nextNode.position);  							}  						}  					}      				// Gummiband zeichnen  				if (howToDrag == DragNDrop.DRAG_RUBBERBAND)  					{  					Point[] points =   						{  							new Point(daGridRubberband.X' daGridRubberband.Y)'  							new Point(daGridRubberband.X + daGridRubberband.Width' daGridRubberband.Y)'  							new Point(daGridRubberband.X + daGridRubberband.Width' daGridRubberband.Y + daGridRubberband.Height)'  							new Point(daGridRubberband.X' daGridRubberband.Y + daGridRubberband.Height)  						};  					using (SolidBrush tmp = new SolidBrush(Color.FromArgb(32' Color.Black)))  						e.Graphics.FillPolygon(tmp' points);  					e.Graphics.DrawPolygon(BlackPen' points);  					}    				additionalGraphics.Clear();      				// Statusinfo zeichnen:  				if (selectedVehicle != null && cbRenderVehiclesDebug.Checked)  					{  					selectedVehicle.DrawDebugData(e.Graphics);  					}    				renderStopwatch.Stop();      				if (cbRenderFps.Checked)  					{  					e.Graphics.Transform = new Matrix(1' 0' 0' 1' 0' 0);  					e.Graphics.DrawString(  						"thinking time: " + thinkStopwatch.ElapsedMilliseconds + "ms' possible thoughts per second: " + ((thinkStopwatch.ElapsedMilliseconds != 0) ? (1000 / thinkStopwatch.ElapsedMilliseconds).ToString() : "-")'  						new Font("Arial"' 10)'  						new SolidBrush(Color.Black)'  						8'  						40);    					e.Graphics.DrawString(  						"rendering time: " + renderStopwatch.ElapsedMilliseconds + "ms' possible fps: " + ((renderStopwatch.ElapsedMilliseconds != 0) ? (1000 / renderStopwatch.ElapsedMilliseconds).ToString() : "-")'  						new Font("Arial"' 10)'  						new SolidBrush(Color.Black)'  						8'  						56);  					}  				}
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,DaGrid_Paint,The following statement contains a magic number: using (Pen BlackPen = new Pen(Color.Black' 1.0F))  				{  				// Zusätzliche Grafiken zeichnen  				foreach (GraphicsPath gp in additionalGraphics)  					{  					e.Graphics.DrawPath(BlackPen' gp);  					}    				nodeSteuerung.RenderNetwork(e.Graphics' renderOptionsDaGrid);    				//to-/fromLineNode malen  				foreach (LineNode ln in toLineNodes)  					{  					RectangleF foo = ln.positionRect;  					foo.Inflate(4' 4);  					e.Graphics.FillEllipse(new SolidBrush(Color.Red)' foo);  					}  				foreach (LineNode ln in fromLineNodes)  					{  					RectangleF foo = ln.positionRect;  					foo.Inflate(4' 4);  					e.Graphics.FillEllipse(new SolidBrush(Color.Green)' foo);  					}  	  				if (selectedLineNodes.Count >= 1)  					{  					if (cbRenderLineNodes.Checked)  						{  						foreach (LineNode ln in selectedLineNodes)  							{  							foreach (GraphicsPath gp in ln.nodeGraphics)  								{  								e.Graphics.DrawPath(BlackPen' gp);  								}    							RectangleF foo = ln.positionRect;  							foo.Inflate(2' 2);  							e.Graphics.FillEllipse(new SolidBrush(Color.Black)' foo);  							}    						RectangleF foo2 = m_selectedLineNodes[0].positionRect;  						foo2.Inflate(4' 4);  						e.Graphics.DrawEllipse(BlackPen' foo2);  						}    					List<Vector2> points = new List<Vector2>(selectedLineNodes.Count);  					foreach (LineNode ln in selectedLineNodes)  						{  						points.Add(ln.position);  						}  					// build convex hull  					GraphicsPath hullPath = AlgorithmicGeometry.roundedConvexHullPath(points' 16);    					using (SolidBrush tmp = new SolidBrush(Color.FromArgb(64' Color.Gold)))  						e.Graphics.FillPath(tmp' hullPath);  					using (Pen tmp = new Pen(Color.Gold' 3))  						e.Graphics.DrawPath(tmp' hullPath);  					}    				if (trafficLightForm.selectedEntry != null)  					{  					List<Pair<SpecificIntersection' double>> foo = trafficLightForm.selectedEntry.parentGroup.GetConflictPoints(trafficLightForm.selectedEntry);  					if (foo != null)  						{  						using (Pen bar = new Pen(Color.Blue' 2))  							{  							foreach (Pair<SpecificIntersection' double> p in foo)  								{  								List<Vector2> l = new List<Vector2>();  								l.Add(p.Left.intersection.aPosition);  								e.Graphics.DrawPath(bar' AlgorithmicGeometry.roundedConvexHullPath(l' 8));  								}  							}  						}  					}    				// selektierte NodeConnection malen  				if (selectedNodeConnection != null)  					{  					selectedNodeConnection.lineSegment.Draw(e.Graphics' BlackPen);  					}    				if (selectedVehicle != null && renderOptionsDaGrid.renderVehicleDebugData)  					{  					Pen prevNodeConnectionsPen = new Pen(Color.Red' 3);  					Pen nextNodeConnectionsPen = new Pen(Color.Green' 3);    					foreach (NodeConnection prevNC in selectedVehicle.visitedNodeConnections)  						{  						e.Graphics.DrawBezier(prevNodeConnectionsPen' prevNC.lineSegment.p0' prevNC.lineSegment.p1' prevNC.lineSegment.p2' prevNC.lineSegment.p3);  						}  					foreach (Routing.RouteSegment rs in selectedVehicle.wayToGo)  						{  						if (!rs.lineChangeNeeded)  							{  							NodeConnection nextNC = rs.startConnection;  							e.Graphics.DrawBezier(nextNodeConnectionsPen' nextNC.lineSegment.p0' nextNC.lineSegment.p1' nextNC.lineSegment.p2' nextNC.lineSegment.p3);  							}  						else  							{  							e.Graphics.DrawLine(nextNodeConnectionsPen' rs.startConnection.startNode.position' rs.nextNode.position);  							}  						}  					}      				// Gummiband zeichnen  				if (howToDrag == DragNDrop.DRAG_RUBBERBAND)  					{  					Point[] points =   						{  							new Point(daGridRubberband.X' daGridRubberband.Y)'  							new Point(daGridRubberband.X + daGridRubberband.Width' daGridRubberband.Y)'  							new Point(daGridRubberband.X + daGridRubberband.Width' daGridRubberband.Y + daGridRubberband.Height)'  							new Point(daGridRubberband.X' daGridRubberband.Y + daGridRubberband.Height)  						};  					using (SolidBrush tmp = new SolidBrush(Color.FromArgb(32' Color.Black)))  						e.Graphics.FillPolygon(tmp' points);  					e.Graphics.DrawPolygon(BlackPen' points);  					}    				additionalGraphics.Clear();      				// Statusinfo zeichnen:  				if (selectedVehicle != null && cbRenderVehiclesDebug.Checked)  					{  					selectedVehicle.DrawDebugData(e.Graphics);  					}    				renderStopwatch.Stop();      				if (cbRenderFps.Checked)  					{  					e.Graphics.Transform = new Matrix(1' 0' 0' 1' 0' 0);  					e.Graphics.DrawString(  						"thinking time: " + thinkStopwatch.ElapsedMilliseconds + "ms' possible thoughts per second: " + ((thinkStopwatch.ElapsedMilliseconds != 0) ? (1000 / thinkStopwatch.ElapsedMilliseconds).ToString() : "-")'  						new Font("Arial"' 10)'  						new SolidBrush(Color.Black)'  						8'  						40);    					e.Graphics.DrawString(  						"rendering time: " + renderStopwatch.ElapsedMilliseconds + "ms' possible fps: " + ((renderStopwatch.ElapsedMilliseconds != 0) ? (1000 / renderStopwatch.ElapsedMilliseconds).ToString() : "-")'  						new Font("Arial"' 10)'  						new SolidBrush(Color.Black)'  						8'  						56);  					}  				}
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,DaGrid_Paint,The following statement contains a magic number: using (Pen BlackPen = new Pen(Color.Black' 1.0F))  				{  				// Zusätzliche Grafiken zeichnen  				foreach (GraphicsPath gp in additionalGraphics)  					{  					e.Graphics.DrawPath(BlackPen' gp);  					}    				nodeSteuerung.RenderNetwork(e.Graphics' renderOptionsDaGrid);    				//to-/fromLineNode malen  				foreach (LineNode ln in toLineNodes)  					{  					RectangleF foo = ln.positionRect;  					foo.Inflate(4' 4);  					e.Graphics.FillEllipse(new SolidBrush(Color.Red)' foo);  					}  				foreach (LineNode ln in fromLineNodes)  					{  					RectangleF foo = ln.positionRect;  					foo.Inflate(4' 4);  					e.Graphics.FillEllipse(new SolidBrush(Color.Green)' foo);  					}  	  				if (selectedLineNodes.Count >= 1)  					{  					if (cbRenderLineNodes.Checked)  						{  						foreach (LineNode ln in selectedLineNodes)  							{  							foreach (GraphicsPath gp in ln.nodeGraphics)  								{  								e.Graphics.DrawPath(BlackPen' gp);  								}    							RectangleF foo = ln.positionRect;  							foo.Inflate(2' 2);  							e.Graphics.FillEllipse(new SolidBrush(Color.Black)' foo);  							}    						RectangleF foo2 = m_selectedLineNodes[0].positionRect;  						foo2.Inflate(4' 4);  						e.Graphics.DrawEllipse(BlackPen' foo2);  						}    					List<Vector2> points = new List<Vector2>(selectedLineNodes.Count);  					foreach (LineNode ln in selectedLineNodes)  						{  						points.Add(ln.position);  						}  					// build convex hull  					GraphicsPath hullPath = AlgorithmicGeometry.roundedConvexHullPath(points' 16);    					using (SolidBrush tmp = new SolidBrush(Color.FromArgb(64' Color.Gold)))  						e.Graphics.FillPath(tmp' hullPath);  					using (Pen tmp = new Pen(Color.Gold' 3))  						e.Graphics.DrawPath(tmp' hullPath);  					}    				if (trafficLightForm.selectedEntry != null)  					{  					List<Pair<SpecificIntersection' double>> foo = trafficLightForm.selectedEntry.parentGroup.GetConflictPoints(trafficLightForm.selectedEntry);  					if (foo != null)  						{  						using (Pen bar = new Pen(Color.Blue' 2))  							{  							foreach (Pair<SpecificIntersection' double> p in foo)  								{  								List<Vector2> l = new List<Vector2>();  								l.Add(p.Left.intersection.aPosition);  								e.Graphics.DrawPath(bar' AlgorithmicGeometry.roundedConvexHullPath(l' 8));  								}  							}  						}  					}    				// selektierte NodeConnection malen  				if (selectedNodeConnection != null)  					{  					selectedNodeConnection.lineSegment.Draw(e.Graphics' BlackPen);  					}    				if (selectedVehicle != null && renderOptionsDaGrid.renderVehicleDebugData)  					{  					Pen prevNodeConnectionsPen = new Pen(Color.Red' 3);  					Pen nextNodeConnectionsPen = new Pen(Color.Green' 3);    					foreach (NodeConnection prevNC in selectedVehicle.visitedNodeConnections)  						{  						e.Graphics.DrawBezier(prevNodeConnectionsPen' prevNC.lineSegment.p0' prevNC.lineSegment.p1' prevNC.lineSegment.p2' prevNC.lineSegment.p3);  						}  					foreach (Routing.RouteSegment rs in selectedVehicle.wayToGo)  						{  						if (!rs.lineChangeNeeded)  							{  							NodeConnection nextNC = rs.startConnection;  							e.Graphics.DrawBezier(nextNodeConnectionsPen' nextNC.lineSegment.p0' nextNC.lineSegment.p1' nextNC.lineSegment.p2' nextNC.lineSegment.p3);  							}  						else  							{  							e.Graphics.DrawLine(nextNodeConnectionsPen' rs.startConnection.startNode.position' rs.nextNode.position);  							}  						}  					}      				// Gummiband zeichnen  				if (howToDrag == DragNDrop.DRAG_RUBBERBAND)  					{  					Point[] points =   						{  							new Point(daGridRubberband.X' daGridRubberband.Y)'  							new Point(daGridRubberband.X + daGridRubberband.Width' daGridRubberband.Y)'  							new Point(daGridRubberband.X + daGridRubberband.Width' daGridRubberband.Y + daGridRubberband.Height)'  							new Point(daGridRubberband.X' daGridRubberband.Y + daGridRubberband.Height)  						};  					using (SolidBrush tmp = new SolidBrush(Color.FromArgb(32' Color.Black)))  						e.Graphics.FillPolygon(tmp' points);  					e.Graphics.DrawPolygon(BlackPen' points);  					}    				additionalGraphics.Clear();      				// Statusinfo zeichnen:  				if (selectedVehicle != null && cbRenderVehiclesDebug.Checked)  					{  					selectedVehicle.DrawDebugData(e.Graphics);  					}    				renderStopwatch.Stop();      				if (cbRenderFps.Checked)  					{  					e.Graphics.Transform = new Matrix(1' 0' 0' 1' 0' 0);  					e.Graphics.DrawString(  						"thinking time: " + thinkStopwatch.ElapsedMilliseconds + "ms' possible thoughts per second: " + ((thinkStopwatch.ElapsedMilliseconds != 0) ? (1000 / thinkStopwatch.ElapsedMilliseconds).ToString() : "-")'  						new Font("Arial"' 10)'  						new SolidBrush(Color.Black)'  						8'  						40);    					e.Graphics.DrawString(  						"rendering time: " + renderStopwatch.ElapsedMilliseconds + "ms' possible fps: " + ((renderStopwatch.ElapsedMilliseconds != 0) ? (1000 / renderStopwatch.ElapsedMilliseconds).ToString() : "-")'  						new Font("Arial"' 10)'  						new SolidBrush(Color.Black)'  						8'  						56);  					}  				}
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,DaGrid_Paint,The following statement contains a magic number: using (Pen BlackPen = new Pen(Color.Black' 1.0F))  				{  				// Zusätzliche Grafiken zeichnen  				foreach (GraphicsPath gp in additionalGraphics)  					{  					e.Graphics.DrawPath(BlackPen' gp);  					}    				nodeSteuerung.RenderNetwork(e.Graphics' renderOptionsDaGrid);    				//to-/fromLineNode malen  				foreach (LineNode ln in toLineNodes)  					{  					RectangleF foo = ln.positionRect;  					foo.Inflate(4' 4);  					e.Graphics.FillEllipse(new SolidBrush(Color.Red)' foo);  					}  				foreach (LineNode ln in fromLineNodes)  					{  					RectangleF foo = ln.positionRect;  					foo.Inflate(4' 4);  					e.Graphics.FillEllipse(new SolidBrush(Color.Green)' foo);  					}  	  				if (selectedLineNodes.Count >= 1)  					{  					if (cbRenderLineNodes.Checked)  						{  						foreach (LineNode ln in selectedLineNodes)  							{  							foreach (GraphicsPath gp in ln.nodeGraphics)  								{  								e.Graphics.DrawPath(BlackPen' gp);  								}    							RectangleF foo = ln.positionRect;  							foo.Inflate(2' 2);  							e.Graphics.FillEllipse(new SolidBrush(Color.Black)' foo);  							}    						RectangleF foo2 = m_selectedLineNodes[0].positionRect;  						foo2.Inflate(4' 4);  						e.Graphics.DrawEllipse(BlackPen' foo2);  						}    					List<Vector2> points = new List<Vector2>(selectedLineNodes.Count);  					foreach (LineNode ln in selectedLineNodes)  						{  						points.Add(ln.position);  						}  					// build convex hull  					GraphicsPath hullPath = AlgorithmicGeometry.roundedConvexHullPath(points' 16);    					using (SolidBrush tmp = new SolidBrush(Color.FromArgb(64' Color.Gold)))  						e.Graphics.FillPath(tmp' hullPath);  					using (Pen tmp = new Pen(Color.Gold' 3))  						e.Graphics.DrawPath(tmp' hullPath);  					}    				if (trafficLightForm.selectedEntry != null)  					{  					List<Pair<SpecificIntersection' double>> foo = trafficLightForm.selectedEntry.parentGroup.GetConflictPoints(trafficLightForm.selectedEntry);  					if (foo != null)  						{  						using (Pen bar = new Pen(Color.Blue' 2))  							{  							foreach (Pair<SpecificIntersection' double> p in foo)  								{  								List<Vector2> l = new List<Vector2>();  								l.Add(p.Left.intersection.aPosition);  								e.Graphics.DrawPath(bar' AlgorithmicGeometry.roundedConvexHullPath(l' 8));  								}  							}  						}  					}    				// selektierte NodeConnection malen  				if (selectedNodeConnection != null)  					{  					selectedNodeConnection.lineSegment.Draw(e.Graphics' BlackPen);  					}    				if (selectedVehicle != null && renderOptionsDaGrid.renderVehicleDebugData)  					{  					Pen prevNodeConnectionsPen = new Pen(Color.Red' 3);  					Pen nextNodeConnectionsPen = new Pen(Color.Green' 3);    					foreach (NodeConnection prevNC in selectedVehicle.visitedNodeConnections)  						{  						e.Graphics.DrawBezier(prevNodeConnectionsPen' prevNC.lineSegment.p0' prevNC.lineSegment.p1' prevNC.lineSegment.p2' prevNC.lineSegment.p3);  						}  					foreach (Routing.RouteSegment rs in selectedVehicle.wayToGo)  						{  						if (!rs.lineChangeNeeded)  							{  							NodeConnection nextNC = rs.startConnection;  							e.Graphics.DrawBezier(nextNodeConnectionsPen' nextNC.lineSegment.p0' nextNC.lineSegment.p1' nextNC.lineSegment.p2' nextNC.lineSegment.p3);  							}  						else  							{  							e.Graphics.DrawLine(nextNodeConnectionsPen' rs.startConnection.startNode.position' rs.nextNode.position);  							}  						}  					}      				// Gummiband zeichnen  				if (howToDrag == DragNDrop.DRAG_RUBBERBAND)  					{  					Point[] points =   						{  							new Point(daGridRubberband.X' daGridRubberband.Y)'  							new Point(daGridRubberband.X + daGridRubberband.Width' daGridRubberband.Y)'  							new Point(daGridRubberband.X + daGridRubberband.Width' daGridRubberband.Y + daGridRubberband.Height)'  							new Point(daGridRubberband.X' daGridRubberband.Y + daGridRubberband.Height)  						};  					using (SolidBrush tmp = new SolidBrush(Color.FromArgb(32' Color.Black)))  						e.Graphics.FillPolygon(tmp' points);  					e.Graphics.DrawPolygon(BlackPen' points);  					}    				additionalGraphics.Clear();      				// Statusinfo zeichnen:  				if (selectedVehicle != null && cbRenderVehiclesDebug.Checked)  					{  					selectedVehicle.DrawDebugData(e.Graphics);  					}    				renderStopwatch.Stop();      				if (cbRenderFps.Checked)  					{  					e.Graphics.Transform = new Matrix(1' 0' 0' 1' 0' 0);  					e.Graphics.DrawString(  						"thinking time: " + thinkStopwatch.ElapsedMilliseconds + "ms' possible thoughts per second: " + ((thinkStopwatch.ElapsedMilliseconds != 0) ? (1000 / thinkStopwatch.ElapsedMilliseconds).ToString() : "-")'  						new Font("Arial"' 10)'  						new SolidBrush(Color.Black)'  						8'  						40);    					e.Graphics.DrawString(  						"rendering time: " + renderStopwatch.ElapsedMilliseconds + "ms' possible fps: " + ((renderStopwatch.ElapsedMilliseconds != 0) ? (1000 / renderStopwatch.ElapsedMilliseconds).ToString() : "-")'  						new Font("Arial"' 10)'  						new SolidBrush(Color.Black)'  						8'  						56);  					}  				}
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,DaGrid_Paint,The following statement contains a magic number: using (Pen BlackPen = new Pen(Color.Black' 1.0F))  				{  				// Zusätzliche Grafiken zeichnen  				foreach (GraphicsPath gp in additionalGraphics)  					{  					e.Graphics.DrawPath(BlackPen' gp);  					}    				nodeSteuerung.RenderNetwork(e.Graphics' renderOptionsDaGrid);    				//to-/fromLineNode malen  				foreach (LineNode ln in toLineNodes)  					{  					RectangleF foo = ln.positionRect;  					foo.Inflate(4' 4);  					e.Graphics.FillEllipse(new SolidBrush(Color.Red)' foo);  					}  				foreach (LineNode ln in fromLineNodes)  					{  					RectangleF foo = ln.positionRect;  					foo.Inflate(4' 4);  					e.Graphics.FillEllipse(new SolidBrush(Color.Green)' foo);  					}  	  				if (selectedLineNodes.Count >= 1)  					{  					if (cbRenderLineNodes.Checked)  						{  						foreach (LineNode ln in selectedLineNodes)  							{  							foreach (GraphicsPath gp in ln.nodeGraphics)  								{  								e.Graphics.DrawPath(BlackPen' gp);  								}    							RectangleF foo = ln.positionRect;  							foo.Inflate(2' 2);  							e.Graphics.FillEllipse(new SolidBrush(Color.Black)' foo);  							}    						RectangleF foo2 = m_selectedLineNodes[0].positionRect;  						foo2.Inflate(4' 4);  						e.Graphics.DrawEllipse(BlackPen' foo2);  						}    					List<Vector2> points = new List<Vector2>(selectedLineNodes.Count);  					foreach (LineNode ln in selectedLineNodes)  						{  						points.Add(ln.position);  						}  					// build convex hull  					GraphicsPath hullPath = AlgorithmicGeometry.roundedConvexHullPath(points' 16);    					using (SolidBrush tmp = new SolidBrush(Color.FromArgb(64' Color.Gold)))  						e.Graphics.FillPath(tmp' hullPath);  					using (Pen tmp = new Pen(Color.Gold' 3))  						e.Graphics.DrawPath(tmp' hullPath);  					}    				if (trafficLightForm.selectedEntry != null)  					{  					List<Pair<SpecificIntersection' double>> foo = trafficLightForm.selectedEntry.parentGroup.GetConflictPoints(trafficLightForm.selectedEntry);  					if (foo != null)  						{  						using (Pen bar = new Pen(Color.Blue' 2))  							{  							foreach (Pair<SpecificIntersection' double> p in foo)  								{  								List<Vector2> l = new List<Vector2>();  								l.Add(p.Left.intersection.aPosition);  								e.Graphics.DrawPath(bar' AlgorithmicGeometry.roundedConvexHullPath(l' 8));  								}  							}  						}  					}    				// selektierte NodeConnection malen  				if (selectedNodeConnection != null)  					{  					selectedNodeConnection.lineSegment.Draw(e.Graphics' BlackPen);  					}    				if (selectedVehicle != null && renderOptionsDaGrid.renderVehicleDebugData)  					{  					Pen prevNodeConnectionsPen = new Pen(Color.Red' 3);  					Pen nextNodeConnectionsPen = new Pen(Color.Green' 3);    					foreach (NodeConnection prevNC in selectedVehicle.visitedNodeConnections)  						{  						e.Graphics.DrawBezier(prevNodeConnectionsPen' prevNC.lineSegment.p0' prevNC.lineSegment.p1' prevNC.lineSegment.p2' prevNC.lineSegment.p3);  						}  					foreach (Routing.RouteSegment rs in selectedVehicle.wayToGo)  						{  						if (!rs.lineChangeNeeded)  							{  							NodeConnection nextNC = rs.startConnection;  							e.Graphics.DrawBezier(nextNodeConnectionsPen' nextNC.lineSegment.p0' nextNC.lineSegment.p1' nextNC.lineSegment.p2' nextNC.lineSegment.p3);  							}  						else  							{  							e.Graphics.DrawLine(nextNodeConnectionsPen' rs.startConnection.startNode.position' rs.nextNode.position);  							}  						}  					}      				// Gummiband zeichnen  				if (howToDrag == DragNDrop.DRAG_RUBBERBAND)  					{  					Point[] points =   						{  							new Point(daGridRubberband.X' daGridRubberband.Y)'  							new Point(daGridRubberband.X + daGridRubberband.Width' daGridRubberband.Y)'  							new Point(daGridRubberband.X + daGridRubberband.Width' daGridRubberband.Y + daGridRubberband.Height)'  							new Point(daGridRubberband.X' daGridRubberband.Y + daGridRubberband.Height)  						};  					using (SolidBrush tmp = new SolidBrush(Color.FromArgb(32' Color.Black)))  						e.Graphics.FillPolygon(tmp' points);  					e.Graphics.DrawPolygon(BlackPen' points);  					}    				additionalGraphics.Clear();      				// Statusinfo zeichnen:  				if (selectedVehicle != null && cbRenderVehiclesDebug.Checked)  					{  					selectedVehicle.DrawDebugData(e.Graphics);  					}    				renderStopwatch.Stop();      				if (cbRenderFps.Checked)  					{  					e.Graphics.Transform = new Matrix(1' 0' 0' 1' 0' 0);  					e.Graphics.DrawString(  						"thinking time: " + thinkStopwatch.ElapsedMilliseconds + "ms' possible thoughts per second: " + ((thinkStopwatch.ElapsedMilliseconds != 0) ? (1000 / thinkStopwatch.ElapsedMilliseconds).ToString() : "-")'  						new Font("Arial"' 10)'  						new SolidBrush(Color.Black)'  						8'  						40);    					e.Graphics.DrawString(  						"rendering time: " + renderStopwatch.ElapsedMilliseconds + "ms' possible fps: " + ((renderStopwatch.ElapsedMilliseconds != 0) ? (1000 / renderStopwatch.ElapsedMilliseconds).ToString() : "-")'  						new Font("Arial"' 10)'  						new SolidBrush(Color.Black)'  						8'  						56);  					}  				}
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,thumbGrid_Paint,The following statement contains a magic number: using (Pen BlackPen = new Pen(Color.Black' 1.0F))  				{  				nodeSteuerung.RenderNetwork(e.Graphics' renderOptionsThumbnail);    				if (fromLineNodes.Count > 0 && toLineNodes.Count > 0)  					{  					Routing route = Routing.CalculateShortestConenction(fromLineNodes[0]' toLineNodes' Vehicle.IVehicle.VehicleTypes.CAR);    					using (Pen orangePen = new Pen(Color.Orange' 4 / zoom))  						{  						foreach (Routing.RouteSegment rs in route)  							{  							if (!rs.lineChangeNeeded)  								{  								NodeConnection nextNC = rs.startConnection;  								e.Graphics.DrawBezier(orangePen' nextNC.lineSegment.p0' nextNC.lineSegment.p1' nextNC.lineSegment.p2' nextNC.lineSegment.p3);  								}  							else  								{  								e.Graphics.DrawLine(orangePen' rs.startConnection.startNode.position' rs.nextNode.position);  								}  							}  						}    					}    				//to-/fromLineNode malen  				foreach (LineNode ln in toLineNodes)  					{  					RectangleF foo = ln.positionRect;  					foo.Inflate(4 / zoom' 4 / zoom);  					e.Graphics.FillEllipse(new SolidBrush(Color.Red)' foo);  					}  				foreach (LineNode ln in fromLineNodes)  					{  					RectangleF foo = ln.positionRect;  					foo.Inflate(4 / zoom' 4 / zoom);  					e.Graphics.FillEllipse(new SolidBrush(Color.Green)' foo);  					}    				e.Graphics.Transform = new Matrix(1' 0' 0' 1' 0' 0);  				e.Graphics.DrawRectangle(BlackPen' thumbGridClientRect);  				}
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,thumbGrid_Paint,The following statement contains a magic number: using (Pen BlackPen = new Pen(Color.Black' 1.0F))  				{  				nodeSteuerung.RenderNetwork(e.Graphics' renderOptionsThumbnail);    				if (fromLineNodes.Count > 0 && toLineNodes.Count > 0)  					{  					Routing route = Routing.CalculateShortestConenction(fromLineNodes[0]' toLineNodes' Vehicle.IVehicle.VehicleTypes.CAR);    					using (Pen orangePen = new Pen(Color.Orange' 4 / zoom))  						{  						foreach (Routing.RouteSegment rs in route)  							{  							if (!rs.lineChangeNeeded)  								{  								NodeConnection nextNC = rs.startConnection;  								e.Graphics.DrawBezier(orangePen' nextNC.lineSegment.p0' nextNC.lineSegment.p1' nextNC.lineSegment.p2' nextNC.lineSegment.p3);  								}  							else  								{  								e.Graphics.DrawLine(orangePen' rs.startConnection.startNode.position' rs.nextNode.position);  								}  							}  						}    					}    				//to-/fromLineNode malen  				foreach (LineNode ln in toLineNodes)  					{  					RectangleF foo = ln.positionRect;  					foo.Inflate(4 / zoom' 4 / zoom);  					e.Graphics.FillEllipse(new SolidBrush(Color.Red)' foo);  					}  				foreach (LineNode ln in fromLineNodes)  					{  					RectangleF foo = ln.positionRect;  					foo.Inflate(4 / zoom' 4 / zoom);  					e.Graphics.FillEllipse(new SolidBrush(Color.Green)' foo);  					}    				e.Graphics.Transform = new Matrix(1' 0' 0' 1' 0' 0);  				e.Graphics.DrawRectangle(BlackPen' thumbGridClientRect);  				}
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,thumbGrid_Paint,The following statement contains a magic number: using (Pen BlackPen = new Pen(Color.Black' 1.0F))  				{  				nodeSteuerung.RenderNetwork(e.Graphics' renderOptionsThumbnail);    				if (fromLineNodes.Count > 0 && toLineNodes.Count > 0)  					{  					Routing route = Routing.CalculateShortestConenction(fromLineNodes[0]' toLineNodes' Vehicle.IVehicle.VehicleTypes.CAR);    					using (Pen orangePen = new Pen(Color.Orange' 4 / zoom))  						{  						foreach (Routing.RouteSegment rs in route)  							{  							if (!rs.lineChangeNeeded)  								{  								NodeConnection nextNC = rs.startConnection;  								e.Graphics.DrawBezier(orangePen' nextNC.lineSegment.p0' nextNC.lineSegment.p1' nextNC.lineSegment.p2' nextNC.lineSegment.p3);  								}  							else  								{  								e.Graphics.DrawLine(orangePen' rs.startConnection.startNode.position' rs.nextNode.position);  								}  							}  						}    					}    				//to-/fromLineNode malen  				foreach (LineNode ln in toLineNodes)  					{  					RectangleF foo = ln.positionRect;  					foo.Inflate(4 / zoom' 4 / zoom);  					e.Graphics.FillEllipse(new SolidBrush(Color.Red)' foo);  					}  				foreach (LineNode ln in fromLineNodes)  					{  					RectangleF foo = ln.positionRect;  					foo.Inflate(4 / zoom' 4 / zoom);  					e.Graphics.FillEllipse(new SolidBrush(Color.Green)' foo);  					}    				e.Graphics.Transform = new Matrix(1' 0' 0' 1' 0' 0);  				e.Graphics.DrawRectangle(BlackPen' thumbGridClientRect);  				}
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,thumbGrid_Paint,The following statement contains a magic number: using (Pen BlackPen = new Pen(Color.Black' 1.0F))  				{  				nodeSteuerung.RenderNetwork(e.Graphics' renderOptionsThumbnail);    				if (fromLineNodes.Count > 0 && toLineNodes.Count > 0)  					{  					Routing route = Routing.CalculateShortestConenction(fromLineNodes[0]' toLineNodes' Vehicle.IVehicle.VehicleTypes.CAR);    					using (Pen orangePen = new Pen(Color.Orange' 4 / zoom))  						{  						foreach (Routing.RouteSegment rs in route)  							{  							if (!rs.lineChangeNeeded)  								{  								NodeConnection nextNC = rs.startConnection;  								e.Graphics.DrawBezier(orangePen' nextNC.lineSegment.p0' nextNC.lineSegment.p1' nextNC.lineSegment.p2' nextNC.lineSegment.p3);  								}  							else  								{  								e.Graphics.DrawLine(orangePen' rs.startConnection.startNode.position' rs.nextNode.position);  								}  							}  						}    					}    				//to-/fromLineNode malen  				foreach (LineNode ln in toLineNodes)  					{  					RectangleF foo = ln.positionRect;  					foo.Inflate(4 / zoom' 4 / zoom);  					e.Graphics.FillEllipse(new SolidBrush(Color.Red)' foo);  					}  				foreach (LineNode ln in fromLineNodes)  					{  					RectangleF foo = ln.positionRect;  					foo.Inflate(4 / zoom' 4 / zoom);  					e.Graphics.FillEllipse(new SolidBrush(Color.Green)' foo);  					}    				e.Graphics.Transform = new Matrix(1' 0' 0' 1' 0' 0);  				e.Graphics.DrawRectangle(BlackPen' thumbGridClientRect);  				}
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,thumbGrid_Paint,The following statement contains a magic number: using (Pen BlackPen = new Pen(Color.Black' 1.0F))  				{  				nodeSteuerung.RenderNetwork(e.Graphics' renderOptionsThumbnail);    				if (fromLineNodes.Count > 0 && toLineNodes.Count > 0)  					{  					Routing route = Routing.CalculateShortestConenction(fromLineNodes[0]' toLineNodes' Vehicle.IVehicle.VehicleTypes.CAR);    					using (Pen orangePen = new Pen(Color.Orange' 4 / zoom))  						{  						foreach (Routing.RouteSegment rs in route)  							{  							if (!rs.lineChangeNeeded)  								{  								NodeConnection nextNC = rs.startConnection;  								e.Graphics.DrawBezier(orangePen' nextNC.lineSegment.p0' nextNC.lineSegment.p1' nextNC.lineSegment.p2' nextNC.lineSegment.p3);  								}  							else  								{  								e.Graphics.DrawLine(orangePen' rs.startConnection.startNode.position' rs.nextNode.position);  								}  							}  						}    					}    				//to-/fromLineNode malen  				foreach (LineNode ln in toLineNodes)  					{  					RectangleF foo = ln.positionRect;  					foo.Inflate(4 / zoom' 4 / zoom);  					e.Graphics.FillEllipse(new SolidBrush(Color.Red)' foo);  					}  				foreach (LineNode ln in fromLineNodes)  					{  					RectangleF foo = ln.positionRect;  					foo.Inflate(4 / zoom' 4 / zoom);  					e.Graphics.FillEllipse(new SolidBrush(Color.Green)' foo);  					}    				e.Graphics.Transform = new Matrix(1' 0' 0' 1' 0' 0);  				e.Graphics.DrawRectangle(BlackPen' thumbGridClientRect);  				}
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,UpdateDaGridClippingRect,The following statement contains a magic number: if (zoomComboBox.SelectedIndex >= 0)  				{  				// daGridClippingRect aktualisieren  				renderOptionsDaGrid.clippingRect.X = daGridScrollPosition.X;  				renderOptionsDaGrid.clippingRect.Y = daGridScrollPosition.Y;  				renderOptionsDaGrid.clippingRect.Width = (int)Math.Ceiling(pnlMainGrid.ClientSize.Width * zoomMultipliers[zoomComboBox.SelectedIndex' 1]);  				renderOptionsDaGrid.clippingRect.Height = (int)Math.Ceiling(pnlMainGrid.ClientSize.Height * zoomMultipliers[zoomComboBox.SelectedIndex' 1]);    				daGridViewCenter = new PointF(  					daGridScrollPosition.X + (pnlMainGrid.ClientSize.Width / 2 * zoomMultipliers[zoomComboBox.SelectedIndex' 1])'  					daGridScrollPosition.Y + (pnlMainGrid.ClientSize.Height / 2 * zoomMultipliers[zoomComboBox.SelectedIndex' 1]));    				RectangleF bounds = nodeSteuerung.GetLineNodeBounds();  				float zoom = Math.Min(1.0f' Math.Min((float)thumbGrid.ClientSize.Width / bounds.Width' (float)thumbGrid.ClientSize.Height / bounds.Height));    				thumbGridClientRect = new Rectangle(  					(int)Math.Round((daGridScrollPosition.X - bounds.X) * zoom)'  					(int)Math.Round((daGridScrollPosition.Y - bounds.Y) * zoom)'  					(int)Math.Round(pnlMainGrid.ClientSize.Width * zoomMultipliers[zoomComboBox.SelectedIndex' 1] * zoom)'  					(int)Math.Round(pnlMainGrid.ClientSize.Height * zoomMultipliers[zoomComboBox.SelectedIndex' 1] * zoom));    				lblScrollPosition.Text = "Canvas Location (dm): (" + daGridScrollPosition.X + "' " + daGridScrollPosition.Y + ") -> (" + (daGridScrollPosition.X + renderOptionsDaGrid.clippingRect.Width) + "' " + (daGridScrollPosition.Y + renderOptionsDaGrid.clippingRect.Height) + ")";    				UpdateConnectionsRenderCache();  				}
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,UpdateDaGridClippingRect,The following statement contains a magic number: if (zoomComboBox.SelectedIndex >= 0)  				{  				// daGridClippingRect aktualisieren  				renderOptionsDaGrid.clippingRect.X = daGridScrollPosition.X;  				renderOptionsDaGrid.clippingRect.Y = daGridScrollPosition.Y;  				renderOptionsDaGrid.clippingRect.Width = (int)Math.Ceiling(pnlMainGrid.ClientSize.Width * zoomMultipliers[zoomComboBox.SelectedIndex' 1]);  				renderOptionsDaGrid.clippingRect.Height = (int)Math.Ceiling(pnlMainGrid.ClientSize.Height * zoomMultipliers[zoomComboBox.SelectedIndex' 1]);    				daGridViewCenter = new PointF(  					daGridScrollPosition.X + (pnlMainGrid.ClientSize.Width / 2 * zoomMultipliers[zoomComboBox.SelectedIndex' 1])'  					daGridScrollPosition.Y + (pnlMainGrid.ClientSize.Height / 2 * zoomMultipliers[zoomComboBox.SelectedIndex' 1]));    				RectangleF bounds = nodeSteuerung.GetLineNodeBounds();  				float zoom = Math.Min(1.0f' Math.Min((float)thumbGrid.ClientSize.Width / bounds.Width' (float)thumbGrid.ClientSize.Height / bounds.Height));    				thumbGridClientRect = new Rectangle(  					(int)Math.Round((daGridScrollPosition.X - bounds.X) * zoom)'  					(int)Math.Round((daGridScrollPosition.Y - bounds.Y) * zoom)'  					(int)Math.Round(pnlMainGrid.ClientSize.Width * zoomMultipliers[zoomComboBox.SelectedIndex' 1] * zoom)'  					(int)Math.Round(pnlMainGrid.ClientSize.Height * zoomMultipliers[zoomComboBox.SelectedIndex' 1] * zoom));    				lblScrollPosition.Text = "Canvas Location (dm): (" + daGridScrollPosition.X + "' " + daGridScrollPosition.Y + ") -> (" + (daGridScrollPosition.X + renderOptionsDaGrid.clippingRect.Width) + "' " + (daGridScrollPosition.Y + renderOptionsDaGrid.clippingRect.Height) + ")";    				UpdateConnectionsRenderCache();  				}
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,UpdateBackgroundImage,The following statement contains a magic number: if (backgroundImage != null)  				{  				if (resampledBackgroundImage != null)  					resampledBackgroundImage.Dispose();  				resampledBackgroundImage = null;  				resampledBackgroundImage = ResizeBitmap(  					backgroundImage'  					(int)Math.Round(backgroundImage.Width * zoomMultipliers[zoomComboBox.SelectedIndex' 0] * ((float)backgroundImageScalingSpinEdit.Value / 100))'  					(int)Math.Round(backgroundImage.Height * zoomMultipliers[zoomComboBox.SelectedIndex' 0] * ((float)backgroundImageScalingSpinEdit.Value / 100)));  				}
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,UpdateBackgroundImage,The following statement contains a magic number: if (backgroundImage != null)  				{  				if (resampledBackgroundImage != null)  					resampledBackgroundImage.Dispose();  				resampledBackgroundImage = null;  				resampledBackgroundImage = ResizeBitmap(  					backgroundImage'  					(int)Math.Round(backgroundImage.Width * zoomMultipliers[zoomComboBox.SelectedIndex' 0] * ((float)backgroundImageScalingSpinEdit.Value / 100))'  					(int)Math.Round(backgroundImage.Height * zoomMultipliers[zoomComboBox.SelectedIndex' 0] * ((float)backgroundImageScalingSpinEdit.Value / 100)));  				}
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,zoomComboBox_SelectedIndexChanged,The following statement contains a magic number: daGridScrollPosition = new Point(  				(int)Math.Round(daGridViewCenter.X - (pnlMainGrid.ClientSize.Width / 2 * zoomMultipliers[zoomComboBox.SelectedIndex' 1]))'  				(int)Math.Round(daGridViewCenter.Y - (pnlMainGrid.ClientSize.Height / 2 * zoomMultipliers[zoomComboBox.SelectedIndex' 1])));
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,zoomComboBox_SelectedIndexChanged,The following statement contains a magic number: daGridScrollPosition = new Point(  				(int)Math.Round(daGridViewCenter.X - (pnlMainGrid.ClientSize.Width / 2 * zoomMultipliers[zoomComboBox.SelectedIndex' 1]))'  				(int)Math.Round(daGridViewCenter.Y - (pnlMainGrid.ClientSize.Height / 2 * zoomMultipliers[zoomComboBox.SelectedIndex' 1])));
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,simulationSpeedSpinEdit_ValueChanged,The following statement contains a magic number: timerSimulation.Interval = (int)(1000 / stepsPerSecondSpinEdit.Value / simulationSpeedSpinEdit.Value);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,stepsPerSecondSpinEdit_ValueChanged,The following statement contains a magic number: timerSimulation.Interval = (int)(1000 / stepsPerSecondSpinEdit.Value / simulationSpeedSpinEdit.Value);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,pnlNetworkInfo_Resize,The following statement contains a magic number: int h = Math.Max(pnlNetworkInfo.ClientSize.Height' 150);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,pnlNetworkInfo_Resize,The following statement contains a magic number: titleEdit.Size = new System.Drawing.Size(w - titleEdit.Location.X - 3' titleEdit.Height);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,pnlNetworkInfo_Resize,The following statement contains a magic number: infoEdit.Size = new System.Drawing.Size(w - 6' h - infoEdit.Location.Y - 61);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,pnlNetworkInfo_Resize,The following statement contains a magic number: infoEdit.Size = new System.Drawing.Size(w - 6' h - infoEdit.Location.Y - 61);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,pnlNetworkInfo_Resize,The following statement contains a magic number: LadenButton.Location = new System.Drawing.Point(w - 85 - 6 - 85 - 3' h - 55);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,pnlNetworkInfo_Resize,The following statement contains a magic number: LadenButton.Location = new System.Drawing.Point(w - 85 - 6 - 85 - 3' h - 55);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,pnlNetworkInfo_Resize,The following statement contains a magic number: LadenButton.Location = new System.Drawing.Point(w - 85 - 6 - 85 - 3' h - 55);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,pnlNetworkInfo_Resize,The following statement contains a magic number: LadenButton.Location = new System.Drawing.Point(w - 85 - 6 - 85 - 3' h - 55);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,pnlNetworkInfo_Resize,The following statement contains a magic number: LadenButton.Location = new System.Drawing.Point(w - 85 - 6 - 85 - 3' h - 55);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,pnlNetworkInfo_Resize,The following statement contains a magic number: SpeichernButton.Location = new System.Drawing.Point(w - 85 - 3' h - 55);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,pnlNetworkInfo_Resize,The following statement contains a magic number: SpeichernButton.Location = new System.Drawing.Point(w - 85 - 3' h - 55);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,pnlNetworkInfo_Resize,The following statement contains a magic number: SpeichernButton.Location = new System.Drawing.Point(w - 85 - 3' h - 55);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,pnlNetworkInfo_Resize,The following statement contains a magic number: aboutBoxButton.Location = new System.Drawing.Point(w - 85 - 6 - 85 - 3' h - 26);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,pnlNetworkInfo_Resize,The following statement contains a magic number: aboutBoxButton.Location = new System.Drawing.Point(w - 85 - 6 - 85 - 3' h - 26);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,pnlNetworkInfo_Resize,The following statement contains a magic number: aboutBoxButton.Location = new System.Drawing.Point(w - 85 - 6 - 85 - 3' h - 26);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,pnlNetworkInfo_Resize,The following statement contains a magic number: aboutBoxButton.Location = new System.Drawing.Point(w - 85 - 6 - 85 - 3' h - 26);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,pnlNetworkInfo_Resize,The following statement contains a magic number: aboutBoxButton.Location = new System.Drawing.Point(w - 85 - 6 - 85 - 3' h - 26);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,pnlSignalAssignment_Resize,The following statement contains a magic number: int h = Math.Max(pnlSignalAssignment.ClientSize.Height' 100);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,pnlSignalAssignment_Resize,The following statement contains a magic number: trafficLightTreeView.Size = new System.Drawing.Size(w - 6' h - 3 - 23 - 6 - 3);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,pnlSignalAssignment_Resize,The following statement contains a magic number: trafficLightTreeView.Size = new System.Drawing.Size(w - 6' h - 3 - 23 - 6 - 3);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,pnlSignalAssignment_Resize,The following statement contains a magic number: trafficLightTreeView.Size = new System.Drawing.Size(w - 6' h - 3 - 23 - 6 - 3);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,pnlSignalAssignment_Resize,The following statement contains a magic number: trafficLightTreeView.Size = new System.Drawing.Size(w - 6' h - 3 - 23 - 6 - 3);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,pnlSignalAssignment_Resize,The following statement contains a magic number: trafficLightTreeView.Size = new System.Drawing.Size(w - 6' h - 3 - 23 - 6 - 3);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,pnlSignalAssignment_Resize,The following statement contains a magic number: freeNodeButton.Location = new System.Drawing.Point(w - 85 - 3' h - 26);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,pnlSignalAssignment_Resize,The following statement contains a magic number: freeNodeButton.Location = new System.Drawing.Point(w - 85 - 3' h - 26);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,pnlSignalAssignment_Resize,The following statement contains a magic number: freeNodeButton.Location = new System.Drawing.Point(w - 85 - 3' h - 26);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,DownloadImage,The following statement contains a magic number: try  				{  				// Open a connection  				System.Net.HttpWebRequest _HttpWebRequest = (System.Net.HttpWebRequest)System.Net.HttpWebRequest.Create(_URL);    				_HttpWebRequest.AllowWriteStreamBuffering = true;    				// You can also specify additional header values like the user agent or the referer: (Optional)  				_HttpWebRequest.UserAgent = "Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1)";  				//_HttpWebRequest.Referer = "http://www.google.com/";    				// set timeout for 20 seconds (Optional)  				_HttpWebRequest.Timeout = 3000;    				// Request response:  				System.Net.WebResponse _WebResponse = _HttpWebRequest.GetResponse();    				// Open data stream:  				System.IO.Stream _WebStream = _WebResponse.GetResponseStream();    				// convert webstream to image  				_tmpImage = Image.FromStream(_WebStream);    				// Cleanup  				_WebResponse.Close();  				_WebResponse.Close();  				}  			catch (Exception _Exception)  				{  				// Error  				Console.WriteLine("Exception caught in process: {0}"' _Exception.ToString());  				return null;  				}
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,btnSetWorldCoordinates_Click,The following statement contains a magic number: int numx = 10;
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,btnSetWorldCoordinates_Click,The following statement contains a magic number: int numy = 10;
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,btnSetWorldCoordinates_Click,The following statement contains a magic number: for (int i = 0; i < numx; ++i)  				{  				for (int j = 0; j < numy; ++j)  					{  					satelliteImages[i'j] = DownloadImage(baseUrl + (spinLatitude.Value - (0.001m * i)).ToString(ci) + "'" + (spinLongitude.Value + (0.0017m * j)).ToString(ci));  					if (satelliteImages[i'j] != null)  						satelliteImages[i' j] = ResizeBitmap(new Bitmap(satelliteImages[i' j])' (int)(satelliteImages[i' j].Width * 1.739)' (int)(satelliteImages[i' j].Height * 1.739));  					}  				}
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,btnSetWorldCoordinates_Click,The following statement contains a magic number: for (int i = 0; i < numx; ++i)  				{  				for (int j = 0; j < numy; ++j)  					{  					satelliteImages[i'j] = DownloadImage(baseUrl + (spinLatitude.Value - (0.001m * i)).ToString(ci) + "'" + (spinLongitude.Value + (0.0017m * j)).ToString(ci));  					if (satelliteImages[i'j] != null)  						satelliteImages[i' j] = ResizeBitmap(new Bitmap(satelliteImages[i' j])' (int)(satelliteImages[i' j].Width * 1.739)' (int)(satelliteImages[i' j].Height * 1.739));  					}  				}
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,pnlStatistics_Paint,The following statement contains a magic number: if (connections.Count > 0)  				{  				int numBuckets = connections[0].statistics.Length;  				int maxInt = 1;  				double maxFloat = 1;    				// merge statistical data into one record  				NodeConnection.Statistics[] merged = new NodeConnection.Statistics[numBuckets];  				for (int i = 0; i < numBuckets; ++i)  					{  					foreach (NodeConnection nc in connections)  						{  						merged[i].numVehicles += nc.statistics[i].numVehicles;  						merged[i].numStoppedVehicles += nc.statistics[i].numStoppedVehicles;  						merged[i].sumOfVehicleVelocities += nc.statistics[i].sumOfVehicleVelocities;  						}  					maxInt = Math.Max(maxInt' merged[i].numVehicles);  					if (merged[i].numVehicles > 0)  						maxFloat = Math.Max(maxFloat' merged[i].sumOfVehicleVelocities / merged[i].numVehicles);  					}    				Pen blackPen = new Pen(Color.Black' 1.5f);  				Brush grayBrush = new SolidBrush(Color.LightGray);  				Brush redBrush = new SolidBrush(Color.Orange);    				// calculate data extent and derive transormation matrices  				maxFloat *= 1.2;  				maxInt *= 2;  				Matrix velocityMatrix = new Matrix((float)pnlStatistics.Width / numBuckets' 0' 0' (float)pnlStatistics.Height / (float)-maxFloat' 0' pnlStatistics.Height - 5);  				Matrix numVehicleMatrix = new Matrix((float)pnlStatistics.Width / numBuckets' 0' 0' (float)pnlStatistics.Height / -maxInt' 0' pnlStatistics.Height - 5);    				// render data  				for (int i = 1; i < numBuckets; ++i)  					{  					NodeConnection.Statistics s1 = merged[i];  					NodeConnection.Statistics s2 = merged[i-1];    					e.Graphics.SmoothingMode = SmoothingMode.HighSpeed;  					e.Graphics.Transform = numVehicleMatrix;  					e.Graphics.FillRectangle(grayBrush' i - 1' 0' 1' s1.numVehicles);  					e.Graphics.FillRectangle(redBrush' i - 1' 0' 1' s1.numStoppedVehicles);    					e.Graphics.SmoothingMode = SmoothingMode.HighQuality;  					e.Graphics.Transform = velocityMatrix;  					float val1 = (s1.numVehicles == 0 ? 0 : (float)s1.sumOfVehicleVelocities / s1.numVehicles);  					float val2 = (s2.numVehicles == 0 ? 0 : (float)s2.sumOfVehicleVelocities / s2.numVehicles);    					e.Graphics.DrawLine(blackPen' i - 1' val1' i' val2);  					}  				}
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,pnlStatistics_Paint,The following statement contains a magic number: if (connections.Count > 0)  				{  				int numBuckets = connections[0].statistics.Length;  				int maxInt = 1;  				double maxFloat = 1;    				// merge statistical data into one record  				NodeConnection.Statistics[] merged = new NodeConnection.Statistics[numBuckets];  				for (int i = 0; i < numBuckets; ++i)  					{  					foreach (NodeConnection nc in connections)  						{  						merged[i].numVehicles += nc.statistics[i].numVehicles;  						merged[i].numStoppedVehicles += nc.statistics[i].numStoppedVehicles;  						merged[i].sumOfVehicleVelocities += nc.statistics[i].sumOfVehicleVelocities;  						}  					maxInt = Math.Max(maxInt' merged[i].numVehicles);  					if (merged[i].numVehicles > 0)  						maxFloat = Math.Max(maxFloat' merged[i].sumOfVehicleVelocities / merged[i].numVehicles);  					}    				Pen blackPen = new Pen(Color.Black' 1.5f);  				Brush grayBrush = new SolidBrush(Color.LightGray);  				Brush redBrush = new SolidBrush(Color.Orange);    				// calculate data extent and derive transormation matrices  				maxFloat *= 1.2;  				maxInt *= 2;  				Matrix velocityMatrix = new Matrix((float)pnlStatistics.Width / numBuckets' 0' 0' (float)pnlStatistics.Height / (float)-maxFloat' 0' pnlStatistics.Height - 5);  				Matrix numVehicleMatrix = new Matrix((float)pnlStatistics.Width / numBuckets' 0' 0' (float)pnlStatistics.Height / -maxInt' 0' pnlStatistics.Height - 5);    				// render data  				for (int i = 1; i < numBuckets; ++i)  					{  					NodeConnection.Statistics s1 = merged[i];  					NodeConnection.Statistics s2 = merged[i-1];    					e.Graphics.SmoothingMode = SmoothingMode.HighSpeed;  					e.Graphics.Transform = numVehicleMatrix;  					e.Graphics.FillRectangle(grayBrush' i - 1' 0' 1' s1.numVehicles);  					e.Graphics.FillRectangle(redBrush' i - 1' 0' 1' s1.numStoppedVehicles);    					e.Graphics.SmoothingMode = SmoothingMode.HighQuality;  					e.Graphics.Transform = velocityMatrix;  					float val1 = (s1.numVehicles == 0 ? 0 : (float)s1.sumOfVehicleVelocities / s1.numVehicles);  					float val2 = (s2.numVehicles == 0 ? 0 : (float)s2.sumOfVehicleVelocities / s2.numVehicles);    					e.Graphics.DrawLine(blackPen' i - 1' val1' i' val2);  					}  				}
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,pnlStatistics_Paint,The following statement contains a magic number: if (connections.Count > 0)  				{  				int numBuckets = connections[0].statistics.Length;  				int maxInt = 1;  				double maxFloat = 1;    				// merge statistical data into one record  				NodeConnection.Statistics[] merged = new NodeConnection.Statistics[numBuckets];  				for (int i = 0; i < numBuckets; ++i)  					{  					foreach (NodeConnection nc in connections)  						{  						merged[i].numVehicles += nc.statistics[i].numVehicles;  						merged[i].numStoppedVehicles += nc.statistics[i].numStoppedVehicles;  						merged[i].sumOfVehicleVelocities += nc.statistics[i].sumOfVehicleVelocities;  						}  					maxInt = Math.Max(maxInt' merged[i].numVehicles);  					if (merged[i].numVehicles > 0)  						maxFloat = Math.Max(maxFloat' merged[i].sumOfVehicleVelocities / merged[i].numVehicles);  					}    				Pen blackPen = new Pen(Color.Black' 1.5f);  				Brush grayBrush = new SolidBrush(Color.LightGray);  				Brush redBrush = new SolidBrush(Color.Orange);    				// calculate data extent and derive transormation matrices  				maxFloat *= 1.2;  				maxInt *= 2;  				Matrix velocityMatrix = new Matrix((float)pnlStatistics.Width / numBuckets' 0' 0' (float)pnlStatistics.Height / (float)-maxFloat' 0' pnlStatistics.Height - 5);  				Matrix numVehicleMatrix = new Matrix((float)pnlStatistics.Width / numBuckets' 0' 0' (float)pnlStatistics.Height / -maxInt' 0' pnlStatistics.Height - 5);    				// render data  				for (int i = 1; i < numBuckets; ++i)  					{  					NodeConnection.Statistics s1 = merged[i];  					NodeConnection.Statistics s2 = merged[i-1];    					e.Graphics.SmoothingMode = SmoothingMode.HighSpeed;  					e.Graphics.Transform = numVehicleMatrix;  					e.Graphics.FillRectangle(grayBrush' i - 1' 0' 1' s1.numVehicles);  					e.Graphics.FillRectangle(redBrush' i - 1' 0' 1' s1.numStoppedVehicles);    					e.Graphics.SmoothingMode = SmoothingMode.HighQuality;  					e.Graphics.Transform = velocityMatrix;  					float val1 = (s1.numVehicles == 0 ? 0 : (float)s1.sumOfVehicleVelocities / s1.numVehicles);  					float val2 = (s2.numVehicles == 0 ? 0 : (float)s2.sumOfVehicleVelocities / s2.numVehicles);    					e.Graphics.DrawLine(blackPen' i - 1' val1' i' val2);  					}  				}
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,pnlStatistics_Paint,The following statement contains a magic number: if (connections.Count > 0)  				{  				int numBuckets = connections[0].statistics.Length;  				int maxInt = 1;  				double maxFloat = 1;    				// merge statistical data into one record  				NodeConnection.Statistics[] merged = new NodeConnection.Statistics[numBuckets];  				for (int i = 0; i < numBuckets; ++i)  					{  					foreach (NodeConnection nc in connections)  						{  						merged[i].numVehicles += nc.statistics[i].numVehicles;  						merged[i].numStoppedVehicles += nc.statistics[i].numStoppedVehicles;  						merged[i].sumOfVehicleVelocities += nc.statistics[i].sumOfVehicleVelocities;  						}  					maxInt = Math.Max(maxInt' merged[i].numVehicles);  					if (merged[i].numVehicles > 0)  						maxFloat = Math.Max(maxFloat' merged[i].sumOfVehicleVelocities / merged[i].numVehicles);  					}    				Pen blackPen = new Pen(Color.Black' 1.5f);  				Brush grayBrush = new SolidBrush(Color.LightGray);  				Brush redBrush = new SolidBrush(Color.Orange);    				// calculate data extent and derive transormation matrices  				maxFloat *= 1.2;  				maxInt *= 2;  				Matrix velocityMatrix = new Matrix((float)pnlStatistics.Width / numBuckets' 0' 0' (float)pnlStatistics.Height / (float)-maxFloat' 0' pnlStatistics.Height - 5);  				Matrix numVehicleMatrix = new Matrix((float)pnlStatistics.Width / numBuckets' 0' 0' (float)pnlStatistics.Height / -maxInt' 0' pnlStatistics.Height - 5);    				// render data  				for (int i = 1; i < numBuckets; ++i)  					{  					NodeConnection.Statistics s1 = merged[i];  					NodeConnection.Statistics s2 = merged[i-1];    					e.Graphics.SmoothingMode = SmoothingMode.HighSpeed;  					e.Graphics.Transform = numVehicleMatrix;  					e.Graphics.FillRectangle(grayBrush' i - 1' 0' 1' s1.numVehicles);  					e.Graphics.FillRectangle(redBrush' i - 1' 0' 1' s1.numStoppedVehicles);    					e.Graphics.SmoothingMode = SmoothingMode.HighQuality;  					e.Graphics.Transform = velocityMatrix;  					float val1 = (s1.numVehicles == 0 ? 0 : (float)s1.sumOfVehicleVelocities / s1.numVehicles);  					float val2 = (s2.numVehicles == 0 ? 0 : (float)s2.sumOfVehicleVelocities / s2.numVehicles);    					e.Graphics.DrawLine(blackPen' i - 1' val1' i' val2);  					}  				}
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,cbRenderGrid_SizeChanged,The following statement contains a magic number: spinGridSpacing.Location = new System.Drawing.Point(cbRenderGrid.Location.X + cbRenderGrid.Width + 5' spinGridSpacing.Location.Y);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,cbRenderGrid_SizeChanged,The following statement contains a magic number: lblMeters.Location = new System.Drawing.Point(spinGridSpacing.Location.X + spinGridSpacing.Width + 5' lblMeters.Location.Y);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.timerSimulation.Interval = 67;
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.pnlSimulationSetup.Location = new System.Drawing.Point(795' 14);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.pnlSimulationSetup.Location = new System.Drawing.Point(795' 14);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.pnlSimulationSetup.Size = new System.Drawing.Size(307' 203);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.pnlSimulationSetup.Size = new System.Drawing.Size(307' 203);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.pnlSimulationSetup.TabIndex = 9;
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.label6.Location = new System.Drawing.Point(3' 83);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.label6.Location = new System.Drawing.Point(3' 83);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.label6.Size = new System.Drawing.Size(78' 13);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.label6.Size = new System.Drawing.Size(78' 13);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.label6.TabIndex = 32;
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.spinRandomSeed.Location = new System.Drawing.Point(188' 81);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.spinRandomSeed.Location = new System.Drawing.Point(188' 81);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.spinRandomSeed.Maximum = new decimal(new int[] {              2147483647'              0'              0'              0});
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.spinRandomSeed.Minimum = new decimal(new int[] {              -2147483648'              0'              0'              -2147483648});
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.spinRandomSeed.Minimum = new decimal(new int[] {              -2147483648'              0'              0'              -2147483648});
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.spinRandomSeed.Size = new System.Drawing.Size(88' 20);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.spinRandomSeed.Size = new System.Drawing.Size(88' 20);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.spinRandomSeed.TabIndex = 31;
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.spinRandomSeed.Value = new decimal(new int[] {              42'              0'              0'              0});
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.btnReset.Location = new System.Drawing.Point(206' 107);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.btnReset.Location = new System.Drawing.Point(206' 107);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.btnReset.Size = new System.Drawing.Size(70' 23);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.btnReset.Size = new System.Drawing.Size(70' 23);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.btnReset.TabIndex = 30;
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.label5.Location = new System.Drawing.Point(3' 57);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.label5.Location = new System.Drawing.Point(3' 57);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.label5.Size = new System.Drawing.Size(64' 13);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.label5.Size = new System.Drawing.Size(64' 13);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.label5.TabIndex = 28;
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.spinSimulationDuration.Location = new System.Drawing.Point(188' 55);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.spinSimulationDuration.Location = new System.Drawing.Point(188' 55);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.spinSimulationDuration.Maximum = new decimal(new int[] {              10000'              0'              0'              0});
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.spinSimulationDuration.Size = new System.Drawing.Size(88' 20);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.spinSimulationDuration.Size = new System.Drawing.Size(88' 20);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.spinSimulationDuration.TabIndex = 27;
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.spinSimulationDuration.Value = new decimal(new int[] {              300'              0'              0'              0});
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.stepsPerSecondSpinEdit.Location = new System.Drawing.Point(188' 29);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.stepsPerSecondSpinEdit.Location = new System.Drawing.Point(188' 29);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.stepsPerSecondSpinEdit.Maximum = new decimal(new int[] {              30'              0'              0'              0});
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.stepsPerSecondSpinEdit.Size = new System.Drawing.Size(88' 20);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.stepsPerSecondSpinEdit.Size = new System.Drawing.Size(88' 20);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.stepsPerSecondSpinEdit.TabIndex = 26;
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.stepsPerSecondSpinEdit.Value = new decimal(new int[] {              15'              0'              0'              0});
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.label11.Location = new System.Drawing.Point(3' 5);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.label11.Location = new System.Drawing.Point(3' 5);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.label11.Size = new System.Drawing.Size(92' 13);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.label11.Size = new System.Drawing.Size(92' 13);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.label11.TabIndex = 24;
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.label12.Location = new System.Drawing.Point(3' 31);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.label12.Location = new System.Drawing.Point(3' 31);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.label12.Size = new System.Drawing.Size(70' 13);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.label12.Size = new System.Drawing.Size(70' 13);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.label12.TabIndex = 25;
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.cbEnableSimulation.Location = new System.Drawing.Point(6' 111);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.cbEnableSimulation.Location = new System.Drawing.Point(6' 111);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.cbEnableSimulation.Size = new System.Drawing.Size(110' 17);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.cbEnableSimulation.Size = new System.Drawing.Size(110' 17);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.cbEnableSimulation.TabIndex = 6;
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.stepButton.Location = new System.Drawing.Point(130' 107);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.stepButton.Location = new System.Drawing.Point(130' 107);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.stepButton.Size = new System.Drawing.Size(70' 23);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.stepButton.Size = new System.Drawing.Size(70' 23);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.stepButton.TabIndex = 9;
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.killAllVehiclesButton.Location = new System.Drawing.Point(130' 138);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.killAllVehiclesButton.Location = new System.Drawing.Point(130' 138);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.killAllVehiclesButton.Size = new System.Drawing.Size(146' 23);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.killAllVehiclesButton.Size = new System.Drawing.Size(146' 23);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.killAllVehiclesButton.TabIndex = 11;
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.simulationSpeedSpinEdit.Location = new System.Drawing.Point(188' 3);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.simulationSpeedSpinEdit.Location = new System.Drawing.Point(188' 3);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.simulationSpeedSpinEdit.Maximum = new decimal(new int[] {              10'              0'              0'              0});
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.simulationSpeedSpinEdit.Size = new System.Drawing.Size(88' 20);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.simulationSpeedSpinEdit.Size = new System.Drawing.Size(88' 20);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.simulationSpeedSpinEdit.TabIndex = 23;
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.pnlMainGrid.Size = new System.Drawing.Size(1090' 651);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.pnlMainGrid.Size = new System.Drawing.Size(1090' 651);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.pnlMainGrid.TabIndex = 8;
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.pnlLayers.Location = new System.Drawing.Point(482' 471);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.pnlLayers.Location = new System.Drawing.Point(482' 471);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.pnlLayers.Size = new System.Drawing.Size(307' 146);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.pnlLayers.Size = new System.Drawing.Size(307' 146);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.pnlLayers.TabIndex = 18;
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.btnAddLayer.Location = new System.Drawing.Point(179' 34);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.btnAddLayer.Location = new System.Drawing.Point(179' 34);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.btnAddLayer.Size = new System.Drawing.Size(85' 23);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.btnAddLayer.Size = new System.Drawing.Size(85' 23);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.btnAddLayer.TabIndex = 18;
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.tlpLayers.ColumnCount = 3;
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.tlpLayers.Size = new System.Drawing.Size(307' 28);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.tlpLayers.Size = new System.Drawing.Size(307' 28);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.tlpLayers.TabIndex = 17;
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.pnlStatistics.Location = new System.Drawing.Point(169' 471);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.pnlStatistics.Location = new System.Drawing.Point(169' 471);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.pnlStatistics.Size = new System.Drawing.Size(307' 108);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.pnlStatistics.Size = new System.Drawing.Size(307' 108);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.pnlStatistics.TabIndex = 16;
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.pnlNetworkInfo.Location = new System.Drawing.Point(169' 14);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.pnlNetworkInfo.Location = new System.Drawing.Point(169' 14);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.pnlNetworkInfo.Size = new System.Drawing.Size(307' 203);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.pnlNetworkInfo.Size = new System.Drawing.Size(307' 203);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.pnlNetworkInfo.TabIndex = 4;
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.SpeichernButton.Location = new System.Drawing.Point(190' 148);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.SpeichernButton.Location = new System.Drawing.Point(190' 148);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.SpeichernButton.Size = new System.Drawing.Size(85' 23);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.SpeichernButton.Size = new System.Drawing.Size(85' 23);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.SpeichernButton.TabIndex = 21;
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.label7.Location = new System.Drawing.Point(0' 11);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.label7.Size = new System.Drawing.Size(30' 13);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.label7.Size = new System.Drawing.Size(30' 13);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.label7.TabIndex = 2;
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.aboutBoxButton.Location = new System.Drawing.Point(99' 177);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.aboutBoxButton.Location = new System.Drawing.Point(99' 177);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.aboutBoxButton.Size = new System.Drawing.Size(176' 23);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.aboutBoxButton.Size = new System.Drawing.Size(176' 23);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.aboutBoxButton.TabIndex = 12;
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.titleEdit.Location = new System.Drawing.Point(39' 8);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.titleEdit.Location = new System.Drawing.Point(39' 8);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.titleEdit.Size = new System.Drawing.Size(237' 20);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.titleEdit.Size = new System.Drawing.Size(237' 20);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.LadenButton.Location = new System.Drawing.Point(99' 148);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.LadenButton.Location = new System.Drawing.Point(99' 148);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.LadenButton.Size = new System.Drawing.Size(85' 23);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.LadenButton.Size = new System.Drawing.Size(85' 23);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.LadenButton.TabIndex = 20;
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.infoEdit.Location = new System.Drawing.Point(3' 34);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.infoEdit.Location = new System.Drawing.Point(3' 34);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.infoEdit.Size = new System.Drawing.Size(273' 108);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.infoEdit.Size = new System.Drawing.Size(273' 108);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.pnlRenderSetup.Location = new System.Drawing.Point(482' 223);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.pnlRenderSetup.Location = new System.Drawing.Point(482' 223);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.pnlRenderSetup.Size = new System.Drawing.Size(307' 231);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.pnlRenderSetup.Size = new System.Drawing.Size(307' 231);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.pnlRenderSetup.TabIndex = 4;
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.label9.Location = new System.Drawing.Point(3' 66);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.label9.Location = new System.Drawing.Point(3' 66);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.label9.Size = new System.Drawing.Size(58' 13);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.label9.Size = new System.Drawing.Size(58' 13);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.label9.TabIndex = 26;
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.cbVehicleVelocityMapping.Location = new System.Drawing.Point(6' 204);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.cbVehicleVelocityMapping.Location = new System.Drawing.Point(6' 204);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.cbVehicleVelocityMapping.Size = new System.Drawing.Size(107' 17);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.cbVehicleVelocityMapping.Size = new System.Drawing.Size(107' 17);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.cbVehicleVelocityMapping.TabIndex = 24;
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.cbRenderFps.Location = new System.Drawing.Point(6' 181);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.cbRenderFps.Location = new System.Drawing.Point(6' 181);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.cbRenderFps.Size = new System.Drawing.Size(105' 17);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.cbRenderFps.Size = new System.Drawing.Size(105' 17);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.cbRenderFps.TabIndex = 23;
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.cbRenderLineChangePoints.Location = new System.Drawing.Point(120' 181);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.cbRenderLineChangePoints.Location = new System.Drawing.Point(120' 181);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.cbRenderLineChangePoints.Size = new System.Drawing.Size(118' 17);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.cbRenderLineChangePoints.Size = new System.Drawing.Size(118' 17);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.cbRenderLineChangePoints.TabIndex = 22;
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.label2.Location = new System.Drawing.Point(3' 9);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.label2.Location = new System.Drawing.Point(3' 9);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.label2.Size = new System.Drawing.Size(37' 13);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.label2.Size = new System.Drawing.Size(37' 13);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.label2.TabIndex = 5;
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.cbRenderIntersections.Location = new System.Drawing.Point(120' 158);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.cbRenderIntersections.Location = new System.Drawing.Point(120' 158);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.cbRenderIntersections.Size = new System.Drawing.Size(86' 17);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.cbRenderIntersections.Size = new System.Drawing.Size(86' 17);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.cbRenderIntersections.TabIndex = 21;
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.zoomComboBox.Location = new System.Drawing.Point(111' 6);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.zoomComboBox.Location = new System.Drawing.Point(111' 6);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.zoomComboBox.Size = new System.Drawing.Size(156' 21);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.zoomComboBox.Size = new System.Drawing.Size(156' 21);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.zoomComboBox.TabIndex = 8;
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.cbRenderVehiclesDebug.Location = new System.Drawing.Point(120' 135);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.cbRenderVehiclesDebug.Location = new System.Drawing.Point(120' 135);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.cbRenderVehiclesDebug.Size = new System.Drawing.Size(156' 17);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.cbRenderVehiclesDebug.Size = new System.Drawing.Size(156' 17);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.cbRenderVehiclesDebug.TabIndex = 20;
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.cbRenderStatistics.Location = new System.Drawing.Point(6' 158);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.cbRenderStatistics.Location = new System.Drawing.Point(6' 158);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.cbRenderStatistics.Size = new System.Drawing.Size(68' 17);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.cbRenderStatistics.Size = new System.Drawing.Size(68' 17);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.cbRenderStatistics.TabIndex = 12;
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.cbRenderVehicles.Location = new System.Drawing.Point(6' 135);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.cbRenderVehicles.Location = new System.Drawing.Point(6' 135);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.cbRenderVehicles.Size = new System.Drawing.Size(66' 17);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.cbRenderVehicles.Size = new System.Drawing.Size(66' 17);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.cbRenderVehicles.TabIndex = 19;
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.renderQualityComboBox.Location = new System.Drawing.Point(111' 33);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.renderQualityComboBox.Location = new System.Drawing.Point(111' 33);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.renderQualityComboBox.Size = new System.Drawing.Size(156' 21);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.renderQualityComboBox.Size = new System.Drawing.Size(156' 21);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.renderQualityComboBox.TabIndex = 13;
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.cbRenderConnectionsDebug.Location = new System.Drawing.Point(120' 112);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.cbRenderConnectionsDebug.Location = new System.Drawing.Point(120' 112);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.cbRenderConnectionsDebug.Size = new System.Drawing.Size(141' 17);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.cbRenderConnectionsDebug.Size = new System.Drawing.Size(141' 17);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.cbRenderConnectionsDebug.TabIndex = 18;
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.label13.Location = new System.Drawing.Point(3' 36);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.label13.Location = new System.Drawing.Point(3' 36);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.label13.Size = new System.Drawing.Size(80' 13);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.label13.Size = new System.Drawing.Size(80' 13);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.label13.TabIndex = 14;
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.cbRenderConnections.Location = new System.Drawing.Point(6' 112);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.cbRenderConnections.Location = new System.Drawing.Point(6' 112);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.cbRenderConnections.Size = new System.Drawing.Size(85' 17);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.cbRenderConnections.Size = new System.Drawing.Size(85' 17);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.cbRenderConnections.TabIndex = 17;
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.cbRenderLineNodes.Location = new System.Drawing.Point(6' 89);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.cbRenderLineNodes.Location = new System.Drawing.Point(6' 89);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.cbRenderLineNodes.Size = new System.Drawing.Size(57' 17);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.cbRenderLineNodes.Size = new System.Drawing.Size(57' 17);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.cbRenderLineNodes.TabIndex = 15;
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.cbRenderLineNodesDebug.Location = new System.Drawing.Point(120' 89);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.cbRenderLineNodesDebug.Location = new System.Drawing.Point(120' 89);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.cbRenderLineNodesDebug.Size = new System.Drawing.Size(147' 17);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.cbRenderLineNodesDebug.Size = new System.Drawing.Size(147' 17);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.cbRenderLineNodesDebug.TabIndex = 16;
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.pnlSignalAssignment.Location = new System.Drawing.Point(482' 14);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.pnlSignalAssignment.Location = new System.Drawing.Point(482' 14);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.pnlSignalAssignment.Size = new System.Drawing.Size(307' 203);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.pnlSignalAssignment.Size = new System.Drawing.Size(307' 203);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.pnlSignalAssignment.TabIndex = 7;
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.freeNodeButton.Location = new System.Drawing.Point(179' 162);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.freeNodeButton.Location = new System.Drawing.Point(179' 162);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.freeNodeButton.Size = new System.Drawing.Size(85' 23);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.freeNodeButton.Size = new System.Drawing.Size(85' 23);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.freeNodeButton.TabIndex = 2;
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.pnlCanvasSetup.Location = new System.Drawing.Point(795' 223);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.pnlCanvasSetup.Location = new System.Drawing.Point(795' 223);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.pnlCanvasSetup.Size = new System.Drawing.Size(307' 311);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.pnlCanvasSetup.Size = new System.Drawing.Size(307' 311);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.pnlCanvasSetup.TabIndex = 5;
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.groupBox1.Location = new System.Drawing.Point(3' 229);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.groupBox1.Location = new System.Drawing.Point(3' 229);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.groupBox1.Size = new System.Drawing.Size(273' 116);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.groupBox1.Size = new System.Drawing.Size(273' 116);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.groupBox1.TabIndex = 24;
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.spinLongitude.DecimalPlaces = 4;
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.spinLongitude.Increment = new decimal(new int[] {              1'              0'              0'              262144});
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.spinLongitude.Location = new System.Drawing.Point(147' 47);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.spinLongitude.Location = new System.Drawing.Point(147' 47);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.spinLongitude.Size = new System.Drawing.Size(120' 20);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.spinLongitude.Size = new System.Drawing.Size(120' 20);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.spinLongitude.TabIndex = 3;
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.spinLongitude.Value = new decimal(new int[] {              9986'              0'              0'              196608});
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.spinLongitude.Value = new decimal(new int[] {              9986'              0'              0'              196608});
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.spinLatitude.DecimalPlaces = 4;
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.spinLatitude.Increment = new decimal(new int[] {              1'              0'              0'              262144});
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.spinLatitude.Location = new System.Drawing.Point(147' 19);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.spinLatitude.Location = new System.Drawing.Point(147' 19);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.spinLatitude.Size = new System.Drawing.Size(120' 20);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.spinLatitude.Size = new System.Drawing.Size(120' 20);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.spinLatitude.TabIndex = 2;
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.spinLatitude.Value = new decimal(new int[] {              53592'              0'              0'              196608});
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.spinLatitude.Value = new decimal(new int[] {              53592'              0'              0'              196608});
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.btnSetWorldCoordinates.Location = new System.Drawing.Point(192' 73);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.btnSetWorldCoordinates.Location = new System.Drawing.Point(192' 73);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.btnSetWorldCoordinates.Size = new System.Drawing.Size(75' 23);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.btnSetWorldCoordinates.Size = new System.Drawing.Size(75' 23);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.groupBox2.Location = new System.Drawing.Point(3' 110);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.groupBox2.Location = new System.Drawing.Point(3' 110);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.groupBox2.Size = new System.Drawing.Size(273' 113);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.groupBox2.Size = new System.Drawing.Size(273' 113);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.groupBox2.TabIndex = 23;
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.lblMeters.Location = new System.Drawing.Point(192' 21);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.lblMeters.Location = new System.Drawing.Point(192' 21);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.lblMeters.Size = new System.Drawing.Size(38' 13);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.lblMeters.Size = new System.Drawing.Size(38' 13);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.lblMeters.TabIndex = 17;
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.cbRenderGrid.Location = new System.Drawing.Point(6' 20);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.cbRenderGrid.Location = new System.Drawing.Point(6' 20);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.cbRenderGrid.Size = new System.Drawing.Size(112' 17);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.cbRenderGrid.Size = new System.Drawing.Size(112' 17);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.cbRenderGrid.TabIndex = 16;
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.spinGridSpacing.Location = new System.Drawing.Point(124' 19);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.spinGridSpacing.Location = new System.Drawing.Point(124' 19);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.spinGridSpacing.Size = new System.Drawing.Size(62' 20);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.spinGridSpacing.Size = new System.Drawing.Size(62' 20);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.spinGridSpacing.TabIndex = 15;
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.spinGridSpacing.Value = new decimal(new int[] {              10'              0'              0'              0});
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.lblMouseCoordinates.Location = new System.Drawing.Point(6' 66);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.lblMouseCoordinates.Location = new System.Drawing.Point(6' 66);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.lblMouseCoordinates.Size = new System.Drawing.Size(138' 13);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.lblMouseCoordinates.Size = new System.Drawing.Size(138' 13);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.lblMouseCoordinates.TabIndex = 14;
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.lblScrollPosition.Location = new System.Drawing.Point(6' 85);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.lblScrollPosition.Location = new System.Drawing.Point(6' 85);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.lblScrollPosition.Size = new System.Drawing.Size(90' 13);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.lblScrollPosition.Size = new System.Drawing.Size(90' 13);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.lblScrollPosition.TabIndex = 2;
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.lockNodesCheckBox.Location = new System.Drawing.Point(6' 43);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.lockNodesCheckBox.Location = new System.Drawing.Point(6' 43);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.lockNodesCheckBox.Size = new System.Drawing.Size(84' 17);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.lockNodesCheckBox.Size = new System.Drawing.Size(84' 17);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.lockNodesCheckBox.TabIndex = 13;
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.HintergrundbildGroupBox.Location = new System.Drawing.Point(3' 3);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.HintergrundbildGroupBox.Location = new System.Drawing.Point(3' 3);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.HintergrundbildGroupBox.Size = new System.Drawing.Size(273' 101);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.HintergrundbildGroupBox.Size = new System.Drawing.Size(273' 101);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.HintergrundbildGroupBox.TabIndex = 22;
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.label8.Location = new System.Drawing.Point(6' 76);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.label8.Location = new System.Drawing.Point(6' 76);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.label8.Size = new System.Drawing.Size(130' 13);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.label8.Size = new System.Drawing.Size(130' 13);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.label8.TabIndex = 4;
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.backgroundImageScalingSpinEdit.Location = new System.Drawing.Point(192' 74);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.backgroundImageScalingSpinEdit.Location = new System.Drawing.Point(192' 74);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.backgroundImageScalingSpinEdit.Maximum = new decimal(new int[] {              400'              0'              0'              0});
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.backgroundImageScalingSpinEdit.Size = new System.Drawing.Size(75' 20);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.backgroundImageScalingSpinEdit.Size = new System.Drawing.Size(75' 20);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.backgroundImageScalingSpinEdit.TabIndex = 3;
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.backgroundImageScalingSpinEdit.Value = new decimal(new int[] {              100'              0'              0'              0});
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.clearBackgroudnImageButton.Location = new System.Drawing.Point(111' 45);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.clearBackgroudnImageButton.Location = new System.Drawing.Point(111' 45);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.clearBackgroudnImageButton.Size = new System.Drawing.Size(75' 23);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.clearBackgroudnImageButton.Size = new System.Drawing.Size(75' 23);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.clearBackgroudnImageButton.TabIndex = 2;
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.BildLadenButton.Location = new System.Drawing.Point(192' 45);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.BildLadenButton.Location = new System.Drawing.Point(192' 45);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.BildLadenButton.Size = new System.Drawing.Size(75' 23);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.BildLadenButton.Size = new System.Drawing.Size(75' 23);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.backgroundImageEdit.Location = new System.Drawing.Point(6' 19);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.backgroundImageEdit.Location = new System.Drawing.Point(6' 19);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.backgroundImageEdit.Size = new System.Drawing.Size(261' 20);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.backgroundImageEdit.Size = new System.Drawing.Size(261' 20);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.pnlConnectionSetup.Location = new System.Drawing.Point(169' 223);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.pnlConnectionSetup.Location = new System.Drawing.Point(169' 223);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.pnlConnectionSetup.Size = new System.Drawing.Size(307' 242);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.pnlConnectionSetup.Size = new System.Drawing.Size(307' 242);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.pnlConnectionSetup.TabIndex = 6;
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.groupBox4.Location = new System.Drawing.Point(4' 154);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.groupBox4.Location = new System.Drawing.Point(4' 154);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.groupBox4.Size = new System.Drawing.Size(271' 69);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.groupBox4.Size = new System.Drawing.Size(271' 69);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.groupBox4.TabIndex = 26;
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.cbStopSign.Location = new System.Drawing.Point(9' 48);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.cbStopSign.Location = new System.Drawing.Point(9' 48);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.cbStopSign.Size = new System.Drawing.Size(72' 17);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.cbStopSign.Size = new System.Drawing.Size(72' 17);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.cbStopSign.TabIndex = 25;
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.cbNetworkLayer.Location = new System.Drawing.Point(154' 19);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.cbNetworkLayer.Location = new System.Drawing.Point(154' 19);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.cbNetworkLayer.Size = new System.Drawing.Size(111' 21);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.cbNetworkLayer.Size = new System.Drawing.Size(111' 21);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.cbNetworkLayer.TabIndex = 23;
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.label3.Location = new System.Drawing.Point(6' 22);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.label3.Location = new System.Drawing.Point(6' 22);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.label3.Size = new System.Drawing.Size(121' 13);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.label3.Size = new System.Drawing.Size(121' 13);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.label3.TabIndex = 24;
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.groupBox3.Location = new System.Drawing.Point(4' 6);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.groupBox3.Location = new System.Drawing.Point(4' 6);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.groupBox3.Size = new System.Drawing.Size(272' 142);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.groupBox3.Size = new System.Drawing.Size(272' 142);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.groupBox3.TabIndex = 25;
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.nodeConnectionPrioritySpinEdit.Location = new System.Drawing.Point(202' 19);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.nodeConnectionPrioritySpinEdit.Location = new System.Drawing.Point(202' 19);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.nodeConnectionPrioritySpinEdit.Size = new System.Drawing.Size(60' 20);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.nodeConnectionPrioritySpinEdit.Size = new System.Drawing.Size(60' 20);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.nodeConnectionPrioritySpinEdit.Value = new decimal(new int[] {              5'              0'              0'              0});
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.spinTargetVelocity.Location = new System.Drawing.Point(202' 45);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.spinTargetVelocity.Location = new System.Drawing.Point(202' 45);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.spinTargetVelocity.Maximum = new decimal(new int[] {              1000'              0'              0'              0});
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.spinTargetVelocity.Size = new System.Drawing.Size(60' 20);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.spinTargetVelocity.Size = new System.Drawing.Size(60' 20);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.spinTargetVelocity.TabIndex = 8;
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.spinTargetVelocity.Value = new decimal(new int[] {              14'              0'              0'              0});
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.label4.Location = new System.Drawing.Point(6' 21);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.label4.Location = new System.Drawing.Point(6' 21);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.label4.Size = new System.Drawing.Size(98' 13);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.label4.Size = new System.Drawing.Size(98' 13);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.enableIncomingLineChangeCheckBox.Location = new System.Drawing.Point(6' 93);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.enableIncomingLineChangeCheckBox.Location = new System.Drawing.Point(6' 93);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.enableIncomingLineChangeCheckBox.Size = new System.Drawing.Size(160' 17);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.enableIncomingLineChangeCheckBox.Size = new System.Drawing.Size(160' 17);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.enableIncomingLineChangeCheckBox.TabIndex = 6;
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.label1.Location = new System.Drawing.Point(6' 47);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.label1.Location = new System.Drawing.Point(6' 47);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.label1.Size = new System.Drawing.Size(108' 13);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.label1.Size = new System.Drawing.Size(108' 13);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.label1.TabIndex = 7;
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.findLineChangePointsButton.Location = new System.Drawing.Point(6' 113);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.findLineChangePointsButton.Location = new System.Drawing.Point(6' 113);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.findLineChangePointsButton.Size = new System.Drawing.Size(160' 23);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.findLineChangePointsButton.Size = new System.Drawing.Size(160' 23);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.findLineChangePointsButton.TabIndex = 22;
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.carsAllowedCheckBox.Location = new System.Drawing.Point(202' 70);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.carsAllowedCheckBox.Location = new System.Drawing.Point(202' 70);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.carsAllowedCheckBox.Size = new System.Drawing.Size(47' 17);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.carsAllowedCheckBox.Size = new System.Drawing.Size(47' 17);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.carsAllowedCheckBox.TabIndex = 2;
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.enableOutgoingLineChangeCheckBox.Location = new System.Drawing.Point(6' 70);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.enableOutgoingLineChangeCheckBox.Location = new System.Drawing.Point(6' 70);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.enableOutgoingLineChangeCheckBox.Size = new System.Drawing.Size(160' 17);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.enableOutgoingLineChangeCheckBox.Size = new System.Drawing.Size(160' 17);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.enableOutgoingLineChangeCheckBox.TabIndex = 5;
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.busAllowedCheckBox.Location = new System.Drawing.Point(202' 93);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.busAllowedCheckBox.Location = new System.Drawing.Point(202' 93);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.busAllowedCheckBox.Size = new System.Drawing.Size(60' 17);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.busAllowedCheckBox.Size = new System.Drawing.Size(60' 17);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.busAllowedCheckBox.TabIndex = 3;
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.tramAllowedCheckBox.Location = new System.Drawing.Point(202' 116);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.tramAllowedCheckBox.Location = new System.Drawing.Point(202' 116);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.tramAllowedCheckBox.Size = new System.Drawing.Size(55' 17);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.tramAllowedCheckBox.Size = new System.Drawing.Size(55' 17);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.tramAllowedCheckBox.TabIndex = 4;
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.statusleiste.Location = new System.Drawing.Point(0' 629);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.statusleiste.Size = new System.Drawing.Size(1090' 22);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.statusleiste.Size = new System.Drawing.Size(1090' 22);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.statusleiste.TabIndex = 8;
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.statusMenu.Size = new System.Drawing.Size(29' 20);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.statusMenu.Size = new System.Drawing.Size(29' 20);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.statusLabel.Size = new System.Drawing.Size(0' 17);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.button1.Location = new System.Drawing.Point(195' 41);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.button1.Location = new System.Drawing.Point(195' 41);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.button1.Size = new System.Drawing.Size(75' 23);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.button1.Size = new System.Drawing.Size(75' 23);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.button1.TabIndex = 21;
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.button2.Location = new System.Drawing.Point(114' 41);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.button2.Location = new System.Drawing.Point(114' 41);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.button2.Size = new System.Drawing.Size(75' 23);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.button2.Size = new System.Drawing.Size(75' 23);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.button2.TabIndex = 20;
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.thumbGrid.Location = new System.Drawing.Point(0' 106);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.thumbGrid.Size = new System.Drawing.Size(139' 127);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.thumbGrid.Size = new System.Drawing.Size(139' 127);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.thumbGrid.TabIndex = 15;
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.DaGrid.CellHeight = 16;
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.DaGrid.CellSize = new System.Drawing.Size(16' 16);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.DaGrid.CellSize = new System.Drawing.Size(16' 16);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.DaGrid.CellWidth = 16;
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.DaGrid.Dimension = new System.Drawing.Point(64' 64);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.DaGrid.Dimension = new System.Drawing.Point(64' 64);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.DaGrid.Max_X = 64;
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.DaGrid.Max_Y = 64;
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.DaGrid.Size = new System.Drawing.Size(100' 100);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.DaGrid.Size = new System.Drawing.Size(100' 100);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.DaGrid.TabIndex = 3;
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.cmcVelocityMapping.Location = new System.Drawing.Point(111' 60);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.cmcVelocityMapping.Location = new System.Drawing.Point(111' 60);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.cmcVelocityMapping.Size = new System.Drawing.Size(156' 23);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.cmcVelocityMapping.Size = new System.Drawing.Size(156' 23);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.cmcVelocityMapping.TabIndex = 25;
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.trafficLightTreeView.Location = new System.Drawing.Point(3' 3);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.trafficLightTreeView.Location = new System.Drawing.Point(3' 3);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.trafficLightTreeView.Size = new System.Drawing.Size(261' 127);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.trafficLightTreeView.Size = new System.Drawing.Size(261' 127);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(1090' 651);
Magic Number,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(1090' 651);
Magic Number,CityTrafficSimulator,NetworkLayerGUI,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,AddToPanel,The following statement contains a magic number: tlp.RowStyles.Add(new RowStyle(SizeType.Absolute' 28));
Magic Number,CityTrafficSimulator,NetworkLayerGUI,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,AddToPanel,The following statement contains a magic number: tlp.Controls.Add(_cbVisible' 2' row);
Magic Number,CityTrafficSimulator,Intersection,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Intersection.cs,Intersection,The following statement contains a magic number: const double stepSize = 8;
Magic Number,CityTrafficSimulator,Intersection,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Intersection.cs,Intersection,The following statement contains a magic number: while (   Vector2.GetDistance(_aConnection.lineSegment.AtPosition(aPos)' _bConnection.lineSegment.AtPosition(bPos)) < 22  				   && aPos > 0 && bPos > 0)  				{  				aPos -= stepSize;  				bPos -= stepSize;  				distance += stepSize;  				}
Magic Number,CityTrafficSimulator,Intersection,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Intersection.cs,Intersection,The following statement contains a magic number: while (Vector2.GetDistance(_aConnection.lineSegment.AtPosition(aPos)' _bConnection.lineSegment.AtPosition(bPos)) < 22  				   && aPos < _aConnection.lineSegment.length && bPos < _bConnection.lineSegment.length)  				{  				aPos += stepSize;  				bPos += stepSize;  				distance += stepSize;  				}
Magic Number,CityTrafficSimulator,Intersection,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Intersection.cs,RegisterVehicle,The following statement contains a magic number: double blockingStartTime = currentTime + CalculateArrivingTime(v' distance - (_frontWaitingDistance / 2)) - v.SafetyTime/8;
Magic Number,CityTrafficSimulator,Intersection,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Intersection.cs,RegisterVehicle,The following statement contains a magic number: double blockingStartTime = currentTime + CalculateArrivingTime(v' distance - (_frontWaitingDistance / 2)) - v.SafetyTime/8;
Magic Number,CityTrafficSimulator,Intersection,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Intersection.cs,RegisterVehicle,The following statement contains a magic number: double blockingEndTime = currentTime + CalculateArrivingTime(v' distance + v.length) + v.SafetyTime/8;
Magic Number,CityTrafficSimulator,Intersection,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Intersection.cs,UpdateVehicle,The following statement contains a magic number: double blockingStartTime = currentTime + CalculateArrivingTime(v' distance - (_frontWaitingDistance / 2)) - v.SafetyTime / 8;
Magic Number,CityTrafficSimulator,Intersection,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Intersection.cs,UpdateVehicle,The following statement contains a magic number: double blockingStartTime = currentTime + CalculateArrivingTime(v' distance - (_frontWaitingDistance / 2)) - v.SafetyTime / 8;
Magic Number,CityTrafficSimulator,Intersection,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Intersection.cs,UpdateVehicle,The following statement contains a magic number: double blockingEndTime = currentTime + CalculateArrivingTime(v' distance + v.length) + v.SafetyTime / 8;
Magic Number,CityTrafficSimulator,LineNode,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\LineNode.cs,InitStopSignEdgeOffsets,The following statement contains a magic number: if (_stopSignEdgeOffsets == null)  				{  				_stopSignEdgeOffsets = new PointF[8];  				for (int i = 0; i < 8; ++i)  					{  					_stopSignEdgeOffsets[i] = new PointF((float)(12 * Math.Sin((2 * i + 1) * Math.PI / 8.0))' (float)(12 * Math.Cos((2 * i + 1) * Math.PI / 8.0)));  					}  				}
Magic Number,CityTrafficSimulator,LineNode,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\LineNode.cs,InitStopSignEdgeOffsets,The following statement contains a magic number: if (_stopSignEdgeOffsets == null)  				{  				_stopSignEdgeOffsets = new PointF[8];  				for (int i = 0; i < 8; ++i)  					{  					_stopSignEdgeOffsets[i] = new PointF((float)(12 * Math.Sin((2 * i + 1) * Math.PI / 8.0))' (float)(12 * Math.Cos((2 * i + 1) * Math.PI / 8.0)));  					}  				}
Magic Number,CityTrafficSimulator,LineNode,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\LineNode.cs,InitStopSignEdgeOffsets,The following statement contains a magic number: if (_stopSignEdgeOffsets == null)  				{  				_stopSignEdgeOffsets = new PointF[8];  				for (int i = 0; i < 8; ++i)  					{  					_stopSignEdgeOffsets[i] = new PointF((float)(12 * Math.Sin((2 * i + 1) * Math.PI / 8.0))' (float)(12 * Math.Cos((2 * i + 1) * Math.PI / 8.0)));  					}  				}
Magic Number,CityTrafficSimulator,LineNode,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\LineNode.cs,InitStopSignEdgeOffsets,The following statement contains a magic number: if (_stopSignEdgeOffsets == null)  				{  				_stopSignEdgeOffsets = new PointF[8];  				for (int i = 0; i < 8; ++i)  					{  					_stopSignEdgeOffsets[i] = new PointF((float)(12 * Math.Sin((2 * i + 1) * Math.PI / 8.0))' (float)(12 * Math.Cos((2 * i + 1) * Math.PI / 8.0)));  					}  				}
Magic Number,CityTrafficSimulator,LineNode,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\LineNode.cs,InitStopSignEdgeOffsets,The following statement contains a magic number: if (_stopSignEdgeOffsets == null)  				{  				_stopSignEdgeOffsets = new PointF[8];  				for (int i = 0; i < 8; ++i)  					{  					_stopSignEdgeOffsets[i] = new PointF((float)(12 * Math.Sin((2 * i + 1) * Math.PI / 8.0))' (float)(12 * Math.Cos((2 * i + 1) * Math.PI / 8.0)));  					}  				}
Magic Number,CityTrafficSimulator,LineNode,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\LineNode.cs,InitStopSignEdgeOffsets,The following statement contains a magic number: if (_stopSignEdgeOffsets == null)  				{  				_stopSignEdgeOffsets = new PointF[8];  				for (int i = 0; i < 8; ++i)  					{  					_stopSignEdgeOffsets[i] = new PointF((float)(12 * Math.Sin((2 * i + 1) * Math.PI / 8.0))' (float)(12 * Math.Cos((2 * i + 1) * Math.PI / 8.0)));  					}  				}
Magic Number,CityTrafficSimulator,LineNode,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\LineNode.cs,InitStopSignEdgeOffsets,The following statement contains a magic number: if (_stopSignEdgeOffsets == null)  				{  				_stopSignEdgeOffsets = new PointF[8];  				for (int i = 0; i < 8; ++i)  					{  					_stopSignEdgeOffsets[i] = new PointF((float)(12 * Math.Sin((2 * i + 1) * Math.PI / 8.0))' (float)(12 * Math.Cos((2 * i + 1) * Math.PI / 8.0)));  					}  				}
Magic Number,CityTrafficSimulator,LineNode,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\LineNode.cs,InitStopSignEdgeOffsets,The following statement contains a magic number: if (_stopSignEdgeOffsets == null)  				{  				_stopSignEdgeOffsets = new PointF[8];  				for (int i = 0; i < 8; ++i)  					{  					_stopSignEdgeOffsets[i] = new PointF((float)(12 * Math.Sin((2 * i + 1) * Math.PI / 8.0))' (float)(12 * Math.Cos((2 * i + 1) * Math.PI / 8.0)));  					}  				}
Magic Number,CityTrafficSimulator,LineNode,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\LineNode.cs,UpdateNodeGraphics,The following statement contains a magic number: if ((position != null) && (inSlope != null) && (outSlope != null))                  {                  // Linien zu den Stützpunkten                  _nodeGraphics[0] = new System.Drawing.Drawing2D.GraphicsPath(new PointF[] { inSlopeAbs' position }' new byte[] { 1' 1 });                  _nodeGraphics[1] = new System.Drawing.Drawing2D.GraphicsPath(new PointF[] { outSlopeAbs' position }' new byte[] { 1' 1 });                    // Stützpunkte                  System.Drawing.Drawing2D.GraphicsPath inPoint = new System.Drawing.Drawing2D.GraphicsPath();                  inPoint.AddEllipse(inSlopeRect);                  _nodeGraphics[2] = inPoint;                    System.Drawing.Drawing2D.GraphicsPath outPoint = new System.Drawing.Drawing2D.GraphicsPath();  				// wir versuchen ein Dreieck zu zeichnen *lol*  				Vector2 dir = outSlope.Normalized;  				outPoint.AddPolygon(  					new PointF[] {   						(6*dir) + outSlopeAbs'   						(6*dir.RotateCounterClockwise(Math.PI * 2 / 3)) + outSlopeAbs'  						(6*dir.RotateCounterClockwise(Math.PI * 4 / 3)) + outSlopeAbs'  						(6*dir) + outSlopeAbs  					});                  _nodeGraphics[3] = outPoint;                  }
Magic Number,CityTrafficSimulator,LineNode,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\LineNode.cs,UpdateNodeGraphics,The following statement contains a magic number: if ((position != null) && (inSlope != null) && (outSlope != null))                  {                  // Linien zu den Stützpunkten                  _nodeGraphics[0] = new System.Drawing.Drawing2D.GraphicsPath(new PointF[] { inSlopeAbs' position }' new byte[] { 1' 1 });                  _nodeGraphics[1] = new System.Drawing.Drawing2D.GraphicsPath(new PointF[] { outSlopeAbs' position }' new byte[] { 1' 1 });                    // Stützpunkte                  System.Drawing.Drawing2D.GraphicsPath inPoint = new System.Drawing.Drawing2D.GraphicsPath();                  inPoint.AddEllipse(inSlopeRect);                  _nodeGraphics[2] = inPoint;                    System.Drawing.Drawing2D.GraphicsPath outPoint = new System.Drawing.Drawing2D.GraphicsPath();  				// wir versuchen ein Dreieck zu zeichnen *lol*  				Vector2 dir = outSlope.Normalized;  				outPoint.AddPolygon(  					new PointF[] {   						(6*dir) + outSlopeAbs'   						(6*dir.RotateCounterClockwise(Math.PI * 2 / 3)) + outSlopeAbs'  						(6*dir.RotateCounterClockwise(Math.PI * 4 / 3)) + outSlopeAbs'  						(6*dir) + outSlopeAbs  					});                  _nodeGraphics[3] = outPoint;                  }
Magic Number,CityTrafficSimulator,LineNode,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\LineNode.cs,UpdateNodeGraphics,The following statement contains a magic number: if ((position != null) && (inSlope != null) && (outSlope != null))                  {                  // Linien zu den Stützpunkten                  _nodeGraphics[0] = new System.Drawing.Drawing2D.GraphicsPath(new PointF[] { inSlopeAbs' position }' new byte[] { 1' 1 });                  _nodeGraphics[1] = new System.Drawing.Drawing2D.GraphicsPath(new PointF[] { outSlopeAbs' position }' new byte[] { 1' 1 });                    // Stützpunkte                  System.Drawing.Drawing2D.GraphicsPath inPoint = new System.Drawing.Drawing2D.GraphicsPath();                  inPoint.AddEllipse(inSlopeRect);                  _nodeGraphics[2] = inPoint;                    System.Drawing.Drawing2D.GraphicsPath outPoint = new System.Drawing.Drawing2D.GraphicsPath();  				// wir versuchen ein Dreieck zu zeichnen *lol*  				Vector2 dir = outSlope.Normalized;  				outPoint.AddPolygon(  					new PointF[] {   						(6*dir) + outSlopeAbs'   						(6*dir.RotateCounterClockwise(Math.PI * 2 / 3)) + outSlopeAbs'  						(6*dir.RotateCounterClockwise(Math.PI * 4 / 3)) + outSlopeAbs'  						(6*dir) + outSlopeAbs  					});                  _nodeGraphics[3] = outPoint;                  }
Magic Number,CityTrafficSimulator,LineNode,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\LineNode.cs,UpdateNodeGraphics,The following statement contains a magic number: if ((position != null) && (inSlope != null) && (outSlope != null))                  {                  // Linien zu den Stützpunkten                  _nodeGraphics[0] = new System.Drawing.Drawing2D.GraphicsPath(new PointF[] { inSlopeAbs' position }' new byte[] { 1' 1 });                  _nodeGraphics[1] = new System.Drawing.Drawing2D.GraphicsPath(new PointF[] { outSlopeAbs' position }' new byte[] { 1' 1 });                    // Stützpunkte                  System.Drawing.Drawing2D.GraphicsPath inPoint = new System.Drawing.Drawing2D.GraphicsPath();                  inPoint.AddEllipse(inSlopeRect);                  _nodeGraphics[2] = inPoint;                    System.Drawing.Drawing2D.GraphicsPath outPoint = new System.Drawing.Drawing2D.GraphicsPath();  				// wir versuchen ein Dreieck zu zeichnen *lol*  				Vector2 dir = outSlope.Normalized;  				outPoint.AddPolygon(  					new PointF[] {   						(6*dir) + outSlopeAbs'   						(6*dir.RotateCounterClockwise(Math.PI * 2 / 3)) + outSlopeAbs'  						(6*dir.RotateCounterClockwise(Math.PI * 4 / 3)) + outSlopeAbs'  						(6*dir) + outSlopeAbs  					});                  _nodeGraphics[3] = outPoint;                  }
Magic Number,CityTrafficSimulator,LineNode,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\LineNode.cs,UpdateNodeGraphics,The following statement contains a magic number: if ((position != null) && (inSlope != null) && (outSlope != null))                  {                  // Linien zu den Stützpunkten                  _nodeGraphics[0] = new System.Drawing.Drawing2D.GraphicsPath(new PointF[] { inSlopeAbs' position }' new byte[] { 1' 1 });                  _nodeGraphics[1] = new System.Drawing.Drawing2D.GraphicsPath(new PointF[] { outSlopeAbs' position }' new byte[] { 1' 1 });                    // Stützpunkte                  System.Drawing.Drawing2D.GraphicsPath inPoint = new System.Drawing.Drawing2D.GraphicsPath();                  inPoint.AddEllipse(inSlopeRect);                  _nodeGraphics[2] = inPoint;                    System.Drawing.Drawing2D.GraphicsPath outPoint = new System.Drawing.Drawing2D.GraphicsPath();  				// wir versuchen ein Dreieck zu zeichnen *lol*  				Vector2 dir = outSlope.Normalized;  				outPoint.AddPolygon(  					new PointF[] {   						(6*dir) + outSlopeAbs'   						(6*dir.RotateCounterClockwise(Math.PI * 2 / 3)) + outSlopeAbs'  						(6*dir.RotateCounterClockwise(Math.PI * 4 / 3)) + outSlopeAbs'  						(6*dir) + outSlopeAbs  					});                  _nodeGraphics[3] = outPoint;                  }
Magic Number,CityTrafficSimulator,LineNode,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\LineNode.cs,UpdateNodeGraphics,The following statement contains a magic number: if ((position != null) && (inSlope != null) && (outSlope != null))                  {                  // Linien zu den Stützpunkten                  _nodeGraphics[0] = new System.Drawing.Drawing2D.GraphicsPath(new PointF[] { inSlopeAbs' position }' new byte[] { 1' 1 });                  _nodeGraphics[1] = new System.Drawing.Drawing2D.GraphicsPath(new PointF[] { outSlopeAbs' position }' new byte[] { 1' 1 });                    // Stützpunkte                  System.Drawing.Drawing2D.GraphicsPath inPoint = new System.Drawing.Drawing2D.GraphicsPath();                  inPoint.AddEllipse(inSlopeRect);                  _nodeGraphics[2] = inPoint;                    System.Drawing.Drawing2D.GraphicsPath outPoint = new System.Drawing.Drawing2D.GraphicsPath();  				// wir versuchen ein Dreieck zu zeichnen *lol*  				Vector2 dir = outSlope.Normalized;  				outPoint.AddPolygon(  					new PointF[] {   						(6*dir) + outSlopeAbs'   						(6*dir.RotateCounterClockwise(Math.PI * 2 / 3)) + outSlopeAbs'  						(6*dir.RotateCounterClockwise(Math.PI * 4 / 3)) + outSlopeAbs'  						(6*dir) + outSlopeAbs  					});                  _nodeGraphics[3] = outPoint;                  }
Magic Number,CityTrafficSimulator,LineNode,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\LineNode.cs,UpdateNodeGraphics,The following statement contains a magic number: if ((position != null) && (inSlope != null) && (outSlope != null))                  {                  // Linien zu den Stützpunkten                  _nodeGraphics[0] = new System.Drawing.Drawing2D.GraphicsPath(new PointF[] { inSlopeAbs' position }' new byte[] { 1' 1 });                  _nodeGraphics[1] = new System.Drawing.Drawing2D.GraphicsPath(new PointF[] { outSlopeAbs' position }' new byte[] { 1' 1 });                    // Stützpunkte                  System.Drawing.Drawing2D.GraphicsPath inPoint = new System.Drawing.Drawing2D.GraphicsPath();                  inPoint.AddEllipse(inSlopeRect);                  _nodeGraphics[2] = inPoint;                    System.Drawing.Drawing2D.GraphicsPath outPoint = new System.Drawing.Drawing2D.GraphicsPath();  				// wir versuchen ein Dreieck zu zeichnen *lol*  				Vector2 dir = outSlope.Normalized;  				outPoint.AddPolygon(  					new PointF[] {   						(6*dir) + outSlopeAbs'   						(6*dir.RotateCounterClockwise(Math.PI * 2 / 3)) + outSlopeAbs'  						(6*dir.RotateCounterClockwise(Math.PI * 4 / 3)) + outSlopeAbs'  						(6*dir) + outSlopeAbs  					});                  _nodeGraphics[3] = outPoint;                  }
Magic Number,CityTrafficSimulator,LineNode,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\LineNode.cs,UpdateNodeGraphics,The following statement contains a magic number: if ((position != null) && (inSlope != null) && (outSlope != null))                  {                  // Linien zu den Stützpunkten                  _nodeGraphics[0] = new System.Drawing.Drawing2D.GraphicsPath(new PointF[] { inSlopeAbs' position }' new byte[] { 1' 1 });                  _nodeGraphics[1] = new System.Drawing.Drawing2D.GraphicsPath(new PointF[] { outSlopeAbs' position }' new byte[] { 1' 1 });                    // Stützpunkte                  System.Drawing.Drawing2D.GraphicsPath inPoint = new System.Drawing.Drawing2D.GraphicsPath();                  inPoint.AddEllipse(inSlopeRect);                  _nodeGraphics[2] = inPoint;                    System.Drawing.Drawing2D.GraphicsPath outPoint = new System.Drawing.Drawing2D.GraphicsPath();  				// wir versuchen ein Dreieck zu zeichnen *lol*  				Vector2 dir = outSlope.Normalized;  				outPoint.AddPolygon(  					new PointF[] {   						(6*dir) + outSlopeAbs'   						(6*dir.RotateCounterClockwise(Math.PI * 2 / 3)) + outSlopeAbs'  						(6*dir.RotateCounterClockwise(Math.PI * 4 / 3)) + outSlopeAbs'  						(6*dir) + outSlopeAbs  					});                  _nodeGraphics[3] = outPoint;                  }
Magic Number,CityTrafficSimulator,LineNode,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\LineNode.cs,UpdateNodeGraphics,The following statement contains a magic number: if ((position != null) && (inSlope != null) && (outSlope != null))                  {                  // Linien zu den Stützpunkten                  _nodeGraphics[0] = new System.Drawing.Drawing2D.GraphicsPath(new PointF[] { inSlopeAbs' position }' new byte[] { 1' 1 });                  _nodeGraphics[1] = new System.Drawing.Drawing2D.GraphicsPath(new PointF[] { outSlopeAbs' position }' new byte[] { 1' 1 });                    // Stützpunkte                  System.Drawing.Drawing2D.GraphicsPath inPoint = new System.Drawing.Drawing2D.GraphicsPath();                  inPoint.AddEllipse(inSlopeRect);                  _nodeGraphics[2] = inPoint;                    System.Drawing.Drawing2D.GraphicsPath outPoint = new System.Drawing.Drawing2D.GraphicsPath();  				// wir versuchen ein Dreieck zu zeichnen *lol*  				Vector2 dir = outSlope.Normalized;  				outPoint.AddPolygon(  					new PointF[] {   						(6*dir) + outSlopeAbs'   						(6*dir.RotateCounterClockwise(Math.PI * 2 / 3)) + outSlopeAbs'  						(6*dir.RotateCounterClockwise(Math.PI * 4 / 3)) + outSlopeAbs'  						(6*dir) + outSlopeAbs  					});                  _nodeGraphics[3] = outPoint;                  }
Magic Number,CityTrafficSimulator,LineNode,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\LineNode.cs,UpdateNodeGraphics,The following statement contains a magic number: if ((position != null) && (inSlope != null) && (outSlope != null))                  {                  // Linien zu den Stützpunkten                  _nodeGraphics[0] = new System.Drawing.Drawing2D.GraphicsPath(new PointF[] { inSlopeAbs' position }' new byte[] { 1' 1 });                  _nodeGraphics[1] = new System.Drawing.Drawing2D.GraphicsPath(new PointF[] { outSlopeAbs' position }' new byte[] { 1' 1 });                    // Stützpunkte                  System.Drawing.Drawing2D.GraphicsPath inPoint = new System.Drawing.Drawing2D.GraphicsPath();                  inPoint.AddEllipse(inSlopeRect);                  _nodeGraphics[2] = inPoint;                    System.Drawing.Drawing2D.GraphicsPath outPoint = new System.Drawing.Drawing2D.GraphicsPath();  				// wir versuchen ein Dreieck zu zeichnen *lol*  				Vector2 dir = outSlope.Normalized;  				outPoint.AddPolygon(  					new PointF[] {   						(6*dir) + outSlopeAbs'   						(6*dir.RotateCounterClockwise(Math.PI * 2 / 3)) + outSlopeAbs'  						(6*dir.RotateCounterClockwise(Math.PI * 4 / 3)) + outSlopeAbs'  						(6*dir) + outSlopeAbs  					});                  _nodeGraphics[3] = outPoint;                  }
Magic Number,CityTrafficSimulator,LineNode,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\LineNode.cs,Draw,The following statement contains a magic number: if (_stopSign)  				{  				PointF[] poly = new PointF[8];  				for (int i = 0; i < 8; ++i)  					{  					poly[i] = new PointF((float)(_position.X + _stopSignEdgeOffsets[i].X)' (float)(_position.Y + _stopSignEdgeOffsets[i].Y));  					}  				g.FillPolygon(redBrush' poly);  				g.DrawPolygon(blackPen' poly);  				}  			else  				{  				// Node malen  				g.DrawRectangle(blackPen' positionRect.X' positionRect.Y' positionRect.Width' positionRect.Height);  				}
Magic Number,CityTrafficSimulator,LineNode,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\LineNode.cs,Draw,The following statement contains a magic number: if (_stopSign)  				{  				PointF[] poly = new PointF[8];  				for (int i = 0; i < 8; ++i)  					{  					poly[i] = new PointF((float)(_position.X + _stopSignEdgeOffsets[i].X)' (float)(_position.Y + _stopSignEdgeOffsets[i].Y));  					}  				g.FillPolygon(redBrush' poly);  				g.DrawPolygon(blackPen' poly);  				}  			else  				{  				// Node malen  				g.DrawRectangle(blackPen' positionRect.X' positionRect.Y' positionRect.Width' positionRect.Height);  				}
Magic Number,CityTrafficSimulator,LineNode,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\LineNode.cs,DrawDebugData,The following statement contains a magic number: g.DrawString(hashcode.ToString()' new Font("Arial"' 8)' blackBrush' position);
Magic Number,CityTrafficSimulator,LineSegment,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\LineSegment.cs,AtTime,The following statement contains a magic number: double x = -(p0.X * tt3) + t * (3 * p1.X * tt2 + t * (3 * p2.X - 3 * p2.X * t + p3.X * t));
Magic Number,CityTrafficSimulator,LineSegment,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\LineSegment.cs,AtTime,The following statement contains a magic number: double x = -(p0.X * tt3) + t * (3 * p1.X * tt2 + t * (3 * p2.X - 3 * p2.X * t + p3.X * t));
Magic Number,CityTrafficSimulator,LineSegment,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\LineSegment.cs,AtTime,The following statement contains a magic number: double x = -(p0.X * tt3) + t * (3 * p1.X * tt2 + t * (3 * p2.X - 3 * p2.X * t + p3.X * t));
Magic Number,CityTrafficSimulator,LineSegment,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\LineSegment.cs,AtTime,The following statement contains a magic number: double y = -(p0.Y * tt3) + t * (3 * p1.Y * tt2 + t * (3 * p2.Y - 3 * p2.Y * t + p3.Y * t));
Magic Number,CityTrafficSimulator,LineSegment,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\LineSegment.cs,AtTime,The following statement contains a magic number: double y = -(p0.Y * tt3) + t * (3 * p1.Y * tt2 + t * (3 * p2.Y - 3 * p2.Y * t + p3.Y * t));
Magic Number,CityTrafficSimulator,LineSegment,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\LineSegment.cs,AtTime,The following statement contains a magic number: double y = -(p0.Y * tt3) + t * (3 * p1.Y * tt2 + t * (3 * p2.Y - 3 * p2.Y * t + p3.Y * t));
Magic Number,CityTrafficSimulator,LineSegment,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\LineSegment.cs,DerivateAtTime,The following statement contains a magic number: double x = 3 * (-p0.X + p1.X + 2 * (p0.X - 2 * p1.X + p2.X) * t + (-p0.X + 3 * p1.X - 3 * p2.X + p3.X) * t * t);
Magic Number,CityTrafficSimulator,LineSegment,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\LineSegment.cs,DerivateAtTime,The following statement contains a magic number: double x = 3 * (-p0.X + p1.X + 2 * (p0.X - 2 * p1.X + p2.X) * t + (-p0.X + 3 * p1.X - 3 * p2.X + p3.X) * t * t);
Magic Number,CityTrafficSimulator,LineSegment,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\LineSegment.cs,DerivateAtTime,The following statement contains a magic number: double x = 3 * (-p0.X + p1.X + 2 * (p0.X - 2 * p1.X + p2.X) * t + (-p0.X + 3 * p1.X - 3 * p2.X + p3.X) * t * t);
Magic Number,CityTrafficSimulator,LineSegment,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\LineSegment.cs,DerivateAtTime,The following statement contains a magic number: double x = 3 * (-p0.X + p1.X + 2 * (p0.X - 2 * p1.X + p2.X) * t + (-p0.X + 3 * p1.X - 3 * p2.X + p3.X) * t * t);
Magic Number,CityTrafficSimulator,LineSegment,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\LineSegment.cs,DerivateAtTime,The following statement contains a magic number: double x = 3 * (-p0.X + p1.X + 2 * (p0.X - 2 * p1.X + p2.X) * t + (-p0.X + 3 * p1.X - 3 * p2.X + p3.X) * t * t);
Magic Number,CityTrafficSimulator,LineSegment,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\LineSegment.cs,DerivateAtTime,The following statement contains a magic number: double y = 3 * (-p0.Y + p1.Y + 2 * (p0.Y - 2 * p1.Y + p2.Y) * t + (-p0.Y + 3 * p1.Y - 3 * p2.Y + p3.Y) * t * t);
Magic Number,CityTrafficSimulator,LineSegment,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\LineSegment.cs,DerivateAtTime,The following statement contains a magic number: double y = 3 * (-p0.Y + p1.Y + 2 * (p0.Y - 2 * p1.Y + p2.Y) * t + (-p0.Y + 3 * p1.Y - 3 * p2.Y + p3.Y) * t * t);
Magic Number,CityTrafficSimulator,LineSegment,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\LineSegment.cs,DerivateAtTime,The following statement contains a magic number: double y = 3 * (-p0.Y + p1.Y + 2 * (p0.Y - 2 * p1.Y + p2.Y) * t + (-p0.Y + 3 * p1.Y - 3 * p2.Y + p3.Y) * t * t);
Magic Number,CityTrafficSimulator,LineSegment,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\LineSegment.cs,DerivateAtTime,The following statement contains a magic number: double y = 3 * (-p0.Y + p1.Y + 2 * (p0.Y - 2 * p1.Y + p2.Y) * t + (-p0.Y + 3 * p1.Y - 3 * p2.Y + p3.Y) * t * t);
Magic Number,CityTrafficSimulator,LineSegment,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\LineSegment.cs,DerivateAtTime,The following statement contains a magic number: double y = 3 * (-p0.Y + p1.Y + 2 * (p0.Y - 2 * p1.Y + p2.Y) * t + (-p0.Y + 3 * p1.Y - 3 * p2.Y + p3.Y) * t * t);
Magic Number,CityTrafficSimulator,LineSegment,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\LineSegment.cs,PosToTime,The following statement contains a magic number: if (Position < length)                  {                  // Approximiere die gesuchte Position                  int lborder = 0;                  int rborder = lengthList.Length - 1;                    // Finde zunächst die gespeicherten Einträge' die die gesuchte Position umranden                  while (rborder - lborder > 1)                      {                      int i = (lborder + rborder) / 2;                        if (Position == lengthList[i])                          {                          lborder = i;                          break;                          }                      else if (Position < lengthList[i])                          rborder = i;                      else                          lborder = i;                      }                    // Nun berechne' wo ungefähr dazwischen die gesuchte Position ist                  double diff = lengthList[rborder] - lengthList[lborder];                  return (double)(lborder + ((double)1 / diff) * (Position - lengthList[lborder])) / feinheit;                  }              else                  return 1;
Magic Number,CityTrafficSimulator,LineSegment,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\LineSegment.cs,GetBounds,The following statement contains a magic number: return new RectangleF(  				_boundingRectangle.X - pixelsToAdd'   				_boundingRectangle.Y - pixelsToAdd'   				_boundingRectangle.Width + 2*pixelsToAdd'   				_boundingRectangle.Height + 2*pixelsToAdd);
Magic Number,CityTrafficSimulator,LineSegment,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\LineSegment.cs,GetBounds,The following statement contains a magic number: return new RectangleF(  				_boundingRectangle.X - pixelsToAdd'   				_boundingRectangle.Y - pixelsToAdd'   				_boundingRectangle.Width + 2*pixelsToAdd'   				_boundingRectangle.Height + 2*pixelsToAdd);
Magic Number,CityTrafficSimulator,LineSegment,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\LineSegment.cs,Contains,The following statement contains a magic number: if (tolerance < 2 * lineWidth)  				{  				tolerance = 2 * lineWidth + 1;  				}
Magic Number,CityTrafficSimulator,LineSegment,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\LineSegment.cs,Contains,The following statement contains a magic number: if (tolerance < 2 * lineWidth)  				{  				tolerance = 2 * lineWidth + 1;  				}
Magic Number,CityTrafficSimulator,LineSegment,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\LineSegment.cs,Contains,The following statement contains a magic number: return Contains(position' 4' 11);
Magic Number,CityTrafficSimulator,LineSegment,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\LineSegment.cs,Contains,The following statement contains a magic number: return Contains(position' 4' 11);
Magic Number,CityTrafficSimulator,NodeConnection,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\NodeConnection.cs,UpdatePen,The following statement contains a magic number: if (_visualizeAverageSpeed)  				{  				float averageSpeed = getAverageSpeedOfVehicles();  				drawingPen = new Pen(_colormap.GetInterpolatedColor(averageSpeed / _targetVelocity)' 12);  				}  			else  				{  				if (_carsAllowed && !_busAllowed && !_tramAllowed)  					{  					drawingPen = new Pen(Color.LightGray' priority);  					}  				else if (!_carsAllowed && _busAllowed && !_tramAllowed)  					{  					drawingPen = new Pen(Color.LightBlue' priority);  					}  				else if (!_carsAllowed && !_busAllowed && _tramAllowed)  					{  					drawingPen = new Pen(Color.Black' priority);  					}    				else if (_carsAllowed && !_busAllowed && _tramAllowed)  					{  					drawingPen = new Pen(new HatchBrush(HatchStyle.LargeConfetti' Color.Black' Color.LightGray)' _priority);  					}  				else if (_carsAllowed && _busAllowed && !_tramAllowed)  					{  					drawingPen = new Pen(new HatchBrush(HatchStyle.LargeConfetti' Color.LightBlue' Color.LightGray)' _priority);  					}  				else if (!_carsAllowed && _busAllowed && _tramAllowed)  					{  					drawingPen = new Pen(new HatchBrush(HatchStyle.LargeConfetti' Color.Black' Color.LightBlue)' _priority);  					}    				else  					{  					drawingPen = new Pen(Color.DarkBlue' priority);  					}  				}
Magic Number,CityTrafficSimulator,NodeConnection,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\NodeConnection.cs,GetPrevLineChangePoint,The following statement contains a magic number: if (_lineChangePoints.Count > 0 && _lineChangePoints[0].start.arcPosition < arcPosition)  				{  				int lBorder = 0;  				int rBorder = _lineChangePoints.Count - 1;    				while (rBorder - lBorder > 1)  					{  					int i = (rBorder + lBorder) / 2;    					if (arcPosition == _lineChangePoints[i].start.arcPosition)  						{  						return _lineChangePoints[i];  						}  					else if (_lineChangePoints[i].start.arcPosition < arcPosition)  						{  						lBorder = i ;  						}  					else  						{  						rBorder = i - 1;  						}  					}    				return _lineChangePoints[lBorder];  				}  			else  				{  				return new LineChangePoint();  				}
Magic Number,CityTrafficSimulator,NodeConnection,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\NodeConnection.cs,GetNextLineChangePoint,The following statement contains a magic number: if (_lineChangePoints.Count > 0 && _lineChangePoints[0].start.arcPosition < arcPosition)  				{  				int lBorder = 0;  				int rBorder = _lineChangePoints.Count - 1;    				while (rBorder - lBorder > 1)  					{  					int i = (rBorder + lBorder) / 2;    					if (arcPosition == _lineChangePoints[i].start.arcPosition)  						{  						return _lineChangePoints[i];  						}  					else if (_lineChangePoints[i].start.arcPosition < arcPosition)  						{  						lBorder = i+1;  						}  					else  						{  						rBorder = i;  						}  					}    				return _lineChangePoints[rBorder];  				}  			else  				{  				return new LineChangePoint();  				}
Magic Number,CityTrafficSimulator,NodeConnection,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\NodeConnection.cs,CanSpawnVehicleAt,The following statement contains a magic number: LinkedListNode<IVehicle> lln = GetVehicleListNodeBehindArcPosition(arcPosition - 0.1);
Magic Number,CityTrafficSimulator,NodeConnection,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\NodeConnection.cs,Handler_VehicleLeftNodeConnection,The following statement contains a magic number: float averageSpeed = (float)((e.partsUsed.right - e.partsUsed.left) / (10 * (e.timeInterval.right - e.timeInterval.left)));
Magic Number,CityTrafficSimulator,NodeConnection,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\NodeConnection.cs,DrawLineChangePoints,The following statement contains a magic number: using (Pen orangePen = new Pen(Color.Orange' 1))  				{  				using (Brush greenBrush = new SolidBrush(Color.Green))  					{  					using (Brush orangeBrush = new SolidBrush(Color.Orange))  						{  						using (Brush redBrush = new SolidBrush(Color.Red))  							{  							foreach (LineChangePoint lcp in _lineChangePoints)  								{  								// LineChangePoints malen:  								lcp.lineSegment.Draw(g' orangePen);  								g.FillEllipse(greenBrush' new Rectangle(lineSegment.AtTime(lcp.start.time) - new Vector2(2' 2)' new Size(3' 3)));  								g.FillEllipse(orangeBrush' new Rectangle(lcp.otherStart.nc.lineSegment.AtTime(lcp.otherStart.time) - new Vector2(2' 2)' new Size(3' 3)));  								g.FillEllipse(redBrush' new Rectangle(lcp.target.nc.lineSegment.AtTime(lcp.target.time) - new Vector2(2' 2)' new Size(3' 3)));  								}  							}  						}  					}  				}
Magic Number,CityTrafficSimulator,NodeConnection,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\NodeConnection.cs,DrawLineChangePoints,The following statement contains a magic number: using (Pen orangePen = new Pen(Color.Orange' 1))  				{  				using (Brush greenBrush = new SolidBrush(Color.Green))  					{  					using (Brush orangeBrush = new SolidBrush(Color.Orange))  						{  						using (Brush redBrush = new SolidBrush(Color.Red))  							{  							foreach (LineChangePoint lcp in _lineChangePoints)  								{  								// LineChangePoints malen:  								lcp.lineSegment.Draw(g' orangePen);  								g.FillEllipse(greenBrush' new Rectangle(lineSegment.AtTime(lcp.start.time) - new Vector2(2' 2)' new Size(3' 3)));  								g.FillEllipse(orangeBrush' new Rectangle(lcp.otherStart.nc.lineSegment.AtTime(lcp.otherStart.time) - new Vector2(2' 2)' new Size(3' 3)));  								g.FillEllipse(redBrush' new Rectangle(lcp.target.nc.lineSegment.AtTime(lcp.target.time) - new Vector2(2' 2)' new Size(3' 3)));  								}  							}  						}  					}  				}
Magic Number,CityTrafficSimulator,NodeConnection,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\NodeConnection.cs,DrawLineChangePoints,The following statement contains a magic number: using (Pen orangePen = new Pen(Color.Orange' 1))  				{  				using (Brush greenBrush = new SolidBrush(Color.Green))  					{  					using (Brush orangeBrush = new SolidBrush(Color.Orange))  						{  						using (Brush redBrush = new SolidBrush(Color.Red))  							{  							foreach (LineChangePoint lcp in _lineChangePoints)  								{  								// LineChangePoints malen:  								lcp.lineSegment.Draw(g' orangePen);  								g.FillEllipse(greenBrush' new Rectangle(lineSegment.AtTime(lcp.start.time) - new Vector2(2' 2)' new Size(3' 3)));  								g.FillEllipse(orangeBrush' new Rectangle(lcp.otherStart.nc.lineSegment.AtTime(lcp.otherStart.time) - new Vector2(2' 2)' new Size(3' 3)));  								g.FillEllipse(redBrush' new Rectangle(lcp.target.nc.lineSegment.AtTime(lcp.target.time) - new Vector2(2' 2)' new Size(3' 3)));  								}  							}  						}  					}  				}
Magic Number,CityTrafficSimulator,NodeConnection,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\NodeConnection.cs,DrawLineChangePoints,The following statement contains a magic number: using (Pen orangePen = new Pen(Color.Orange' 1))  				{  				using (Brush greenBrush = new SolidBrush(Color.Green))  					{  					using (Brush orangeBrush = new SolidBrush(Color.Orange))  						{  						using (Brush redBrush = new SolidBrush(Color.Red))  							{  							foreach (LineChangePoint lcp in _lineChangePoints)  								{  								// LineChangePoints malen:  								lcp.lineSegment.Draw(g' orangePen);  								g.FillEllipse(greenBrush' new Rectangle(lineSegment.AtTime(lcp.start.time) - new Vector2(2' 2)' new Size(3' 3)));  								g.FillEllipse(orangeBrush' new Rectangle(lcp.otherStart.nc.lineSegment.AtTime(lcp.otherStart.time) - new Vector2(2' 2)' new Size(3' 3)));  								g.FillEllipse(redBrush' new Rectangle(lcp.target.nc.lineSegment.AtTime(lcp.target.time) - new Vector2(2' 2)' new Size(3' 3)));  								}  							}  						}  					}  				}
Magic Number,CityTrafficSimulator,NodeConnection,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\NodeConnection.cs,DrawLineChangePoints,The following statement contains a magic number: using (Pen orangePen = new Pen(Color.Orange' 1))  				{  				using (Brush greenBrush = new SolidBrush(Color.Green))  					{  					using (Brush orangeBrush = new SolidBrush(Color.Orange))  						{  						using (Brush redBrush = new SolidBrush(Color.Red))  							{  							foreach (LineChangePoint lcp in _lineChangePoints)  								{  								// LineChangePoints malen:  								lcp.lineSegment.Draw(g' orangePen);  								g.FillEllipse(greenBrush' new Rectangle(lineSegment.AtTime(lcp.start.time) - new Vector2(2' 2)' new Size(3' 3)));  								g.FillEllipse(orangeBrush' new Rectangle(lcp.otherStart.nc.lineSegment.AtTime(lcp.otherStart.time) - new Vector2(2' 2)' new Size(3' 3)));  								g.FillEllipse(redBrush' new Rectangle(lcp.target.nc.lineSegment.AtTime(lcp.target.time) - new Vector2(2' 2)' new Size(3' 3)));  								}  							}  						}  					}  				}
Magic Number,CityTrafficSimulator,NodeConnection,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\NodeConnection.cs,DrawLineChangePoints,The following statement contains a magic number: using (Pen orangePen = new Pen(Color.Orange' 1))  				{  				using (Brush greenBrush = new SolidBrush(Color.Green))  					{  					using (Brush orangeBrush = new SolidBrush(Color.Orange))  						{  						using (Brush redBrush = new SolidBrush(Color.Red))  							{  							foreach (LineChangePoint lcp in _lineChangePoints)  								{  								// LineChangePoints malen:  								lcp.lineSegment.Draw(g' orangePen);  								g.FillEllipse(greenBrush' new Rectangle(lineSegment.AtTime(lcp.start.time) - new Vector2(2' 2)' new Size(3' 3)));  								g.FillEllipse(orangeBrush' new Rectangle(lcp.otherStart.nc.lineSegment.AtTime(lcp.otherStart.time) - new Vector2(2' 2)' new Size(3' 3)));  								g.FillEllipse(redBrush' new Rectangle(lcp.target.nc.lineSegment.AtTime(lcp.target.time) - new Vector2(2' 2)' new Size(3' 3)));  								}  							}  						}  					}  				}
Magic Number,CityTrafficSimulator,NodeConnection,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\NodeConnection.cs,DrawLineChangePoints,The following statement contains a magic number: using (Pen orangePen = new Pen(Color.Orange' 1))  				{  				using (Brush greenBrush = new SolidBrush(Color.Green))  					{  					using (Brush orangeBrush = new SolidBrush(Color.Orange))  						{  						using (Brush redBrush = new SolidBrush(Color.Red))  							{  							foreach (LineChangePoint lcp in _lineChangePoints)  								{  								// LineChangePoints malen:  								lcp.lineSegment.Draw(g' orangePen);  								g.FillEllipse(greenBrush' new Rectangle(lineSegment.AtTime(lcp.start.time) - new Vector2(2' 2)' new Size(3' 3)));  								g.FillEllipse(orangeBrush' new Rectangle(lcp.otherStart.nc.lineSegment.AtTime(lcp.otherStart.time) - new Vector2(2' 2)' new Size(3' 3)));  								g.FillEllipse(redBrush' new Rectangle(lcp.target.nc.lineSegment.AtTime(lcp.target.time) - new Vector2(2' 2)' new Size(3' 3)));  								}  							}  						}  					}  				}
Magic Number,CityTrafficSimulator,NodeConnection,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\NodeConnection.cs,DrawLineChangePoints,The following statement contains a magic number: using (Pen orangePen = new Pen(Color.Orange' 1))  				{  				using (Brush greenBrush = new SolidBrush(Color.Green))  					{  					using (Brush orangeBrush = new SolidBrush(Color.Orange))  						{  						using (Brush redBrush = new SolidBrush(Color.Red))  							{  							foreach (LineChangePoint lcp in _lineChangePoints)  								{  								// LineChangePoints malen:  								lcp.lineSegment.Draw(g' orangePen);  								g.FillEllipse(greenBrush' new Rectangle(lineSegment.AtTime(lcp.start.time) - new Vector2(2' 2)' new Size(3' 3)));  								g.FillEllipse(orangeBrush' new Rectangle(lcp.otherStart.nc.lineSegment.AtTime(lcp.otherStart.time) - new Vector2(2' 2)' new Size(3' 3)));  								g.FillEllipse(redBrush' new Rectangle(lcp.target.nc.lineSegment.AtTime(lcp.target.time) - new Vector2(2' 2)' new Size(3' 3)));  								}  							}  						}  					}  				}
Magic Number,CityTrafficSimulator,NodeConnection,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\NodeConnection.cs,DrawLineChangePoints,The following statement contains a magic number: using (Pen orangePen = new Pen(Color.Orange' 1))  				{  				using (Brush greenBrush = new SolidBrush(Color.Green))  					{  					using (Brush orangeBrush = new SolidBrush(Color.Orange))  						{  						using (Brush redBrush = new SolidBrush(Color.Red))  							{  							foreach (LineChangePoint lcp in _lineChangePoints)  								{  								// LineChangePoints malen:  								lcp.lineSegment.Draw(g' orangePen);  								g.FillEllipse(greenBrush' new Rectangle(lineSegment.AtTime(lcp.start.time) - new Vector2(2' 2)' new Size(3' 3)));  								g.FillEllipse(orangeBrush' new Rectangle(lcp.otherStart.nc.lineSegment.AtTime(lcp.otherStart.time) - new Vector2(2' 2)' new Size(3' 3)));  								g.FillEllipse(redBrush' new Rectangle(lcp.target.nc.lineSegment.AtTime(lcp.target.time) - new Vector2(2' 2)' new Size(3' 3)));  								}  							}  						}  					}  				}
Magic Number,CityTrafficSimulator,NodeConnection,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\NodeConnection.cs,DrawLineChangePoints,The following statement contains a magic number: using (Pen orangePen = new Pen(Color.Orange' 1))  				{  				using (Brush greenBrush = new SolidBrush(Color.Green))  					{  					using (Brush orangeBrush = new SolidBrush(Color.Orange))  						{  						using (Brush redBrush = new SolidBrush(Color.Red))  							{  							foreach (LineChangePoint lcp in _lineChangePoints)  								{  								// LineChangePoints malen:  								lcp.lineSegment.Draw(g' orangePen);  								g.FillEllipse(greenBrush' new Rectangle(lineSegment.AtTime(lcp.start.time) - new Vector2(2' 2)' new Size(3' 3)));  								g.FillEllipse(orangeBrush' new Rectangle(lcp.otherStart.nc.lineSegment.AtTime(lcp.otherStart.time) - new Vector2(2' 2)' new Size(3' 3)));  								g.FillEllipse(redBrush' new Rectangle(lcp.target.nc.lineSegment.AtTime(lcp.target.time) - new Vector2(2' 2)' new Size(3' 3)));  								}  							}  						}  					}  				}
Magic Number,CityTrafficSimulator,NodeConnection,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\NodeConnection.cs,DrawLineChangePoints,The following statement contains a magic number: using (Pen orangePen = new Pen(Color.Orange' 1))  				{  				using (Brush greenBrush = new SolidBrush(Color.Green))  					{  					using (Brush orangeBrush = new SolidBrush(Color.Orange))  						{  						using (Brush redBrush = new SolidBrush(Color.Red))  							{  							foreach (LineChangePoint lcp in _lineChangePoints)  								{  								// LineChangePoints malen:  								lcp.lineSegment.Draw(g' orangePen);  								g.FillEllipse(greenBrush' new Rectangle(lineSegment.AtTime(lcp.start.time) - new Vector2(2' 2)' new Size(3' 3)));  								g.FillEllipse(orangeBrush' new Rectangle(lcp.otherStart.nc.lineSegment.AtTime(lcp.otherStart.time) - new Vector2(2' 2)' new Size(3' 3)));  								g.FillEllipse(redBrush' new Rectangle(lcp.target.nc.lineSegment.AtTime(lcp.target.time) - new Vector2(2' 2)' new Size(3' 3)));  								}  							}  						}  					}  				}
Magic Number,CityTrafficSimulator,NodeConnection,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\NodeConnection.cs,DrawLineChangePoints,The following statement contains a magic number: using (Pen orangePen = new Pen(Color.Orange' 1))  				{  				using (Brush greenBrush = new SolidBrush(Color.Green))  					{  					using (Brush orangeBrush = new SolidBrush(Color.Orange))  						{  						using (Brush redBrush = new SolidBrush(Color.Red))  							{  							foreach (LineChangePoint lcp in _lineChangePoints)  								{  								// LineChangePoints malen:  								lcp.lineSegment.Draw(g' orangePen);  								g.FillEllipse(greenBrush' new Rectangle(lineSegment.AtTime(lcp.start.time) - new Vector2(2' 2)' new Size(3' 3)));  								g.FillEllipse(orangeBrush' new Rectangle(lcp.otherStart.nc.lineSegment.AtTime(lcp.otherStart.time) - new Vector2(2' 2)' new Size(3' 3)));  								g.FillEllipse(redBrush' new Rectangle(lcp.target.nc.lineSegment.AtTime(lcp.target.time) - new Vector2(2' 2)' new Size(3' 3)));  								}  							}  						}  					}  				}
Magic Number,CityTrafficSimulator,NodeConnection,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\NodeConnection.cs,DrawDebugData,The following statement contains a magic number: g.DrawString(/*"Länge: " + (lineSegment.length/10) + "m\n*/"avg Speed:" + getAverageSpeedOfVehicles() + " m/s"' new Font("Arial"' 9)' new SolidBrush(Color.Black)' lineSegment.AtTime(0.5));
Magic Number,CityTrafficSimulator,NodeConnection,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\NodeConnection.cs,DrawDebugData,The following statement contains a magic number: g.DrawString(/*"Länge: " + (lineSegment.length/10) + "m\n*/"avg Speed:" + getAverageSpeedOfVehicles() + " m/s"' new Font("Arial"' 9)' new SolidBrush(Color.Black)' lineSegment.AtTime(0.5));
Magic Number,CityTrafficSimulator,NodeSteuerung,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\NodeSteuerung.cs,MergeIntersectionPairs,The following statement contains a magic number: foreach (Pair<double> p in newList)  				{  				// Position der Intersection feststellen...  				Vector2 positionOfP = aSegment.AtTime(p.Left);  				bool doInsert = true;    				// ...mit Position jeder Intersection in correctList vergleichen...  				for (int i = 0; doInsert && i < correctList.Count; i++)  					{  					Vector2 foo = aSegment.AtTime(toReturn[i].Left);  					if ((foo - positionOfP).Abs <= 8*tolerance)  						{  						// Wir haben einen doppelten gefunden' dann lass uns den Schnittpunkt in die Mitte verschieben  						doInsert = false;    						toReturn[i] = new Pair<double>(toReturn[i].Left + (p.Left - toReturn[i].Left) / 2' toReturn[i].Right + (p.Right - toReturn[i].Right) / 2);  						}  					}    				// ...und evtl. einfügen :)  				if (doInsert)   					toReturn.Add(p);  				}
Magic Number,CityTrafficSimulator,NodeSteuerung,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\NodeSteuerung.cs,MergeIntersectionPairs,The following statement contains a magic number: foreach (Pair<double> p in newList)  				{  				// Position der Intersection feststellen...  				Vector2 positionOfP = aSegment.AtTime(p.Left);  				bool doInsert = true;    				// ...mit Position jeder Intersection in correctList vergleichen...  				for (int i = 0; doInsert && i < correctList.Count; i++)  					{  					Vector2 foo = aSegment.AtTime(toReturn[i].Left);  					if ((foo - positionOfP).Abs <= 8*tolerance)  						{  						// Wir haben einen doppelten gefunden' dann lass uns den Schnittpunkt in die Mitte verschieben  						doInsert = false;    						toReturn[i] = new Pair<double>(toReturn[i].Left + (p.Left - toReturn[i].Left) / 2' toReturn[i].Right + (p.Right - toReturn[i].Right) / 2);  						}  					}    				// ...und evtl. einfügen :)  				if (doInsert)   					toReturn.Add(p);  				}
Magic Number,CityTrafficSimulator,NodeSteuerung,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\NodeSteuerung.cs,MergeIntersectionPairs,The following statement contains a magic number: foreach (Pair<double> p in newList)  				{  				// Position der Intersection feststellen...  				Vector2 positionOfP = aSegment.AtTime(p.Left);  				bool doInsert = true;    				// ...mit Position jeder Intersection in correctList vergleichen...  				for (int i = 0; doInsert && i < correctList.Count; i++)  					{  					Vector2 foo = aSegment.AtTime(toReturn[i].Left);  					if ((foo - positionOfP).Abs <= 8*tolerance)  						{  						// Wir haben einen doppelten gefunden' dann lass uns den Schnittpunkt in die Mitte verschieben  						doInsert = false;    						toReturn[i] = new Pair<double>(toReturn[i].Left + (p.Left - toReturn[i].Left) / 2' toReturn[i].Right + (p.Right - toReturn[i].Right) / 2);  						}  					}    				// ...und evtl. einfügen :)  				if (doInsert)   					toReturn.Add(p);  				}
Magic Number,CityTrafficSimulator,NodeSteuerung,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\NodeSteuerung.cs,CalculateIntersections,The following statement contains a magic number: if (IntersectsTrue(aBounds' bBounds)) // aBounds.IntersectsWith(bBounds)) //IntersectsTrue(aBounds' bBounds)) //   				{  				// sind beide BoundingBoxen schon kleiner als tolerance' dann haben wir einen Schnittpunkt gefunden  				if ((aBounds.Width <= tolerance) && (aBounds.Height <= tolerance)  						&& (bBounds.Width <= tolerance) && (bBounds.Height <= tolerance))  					{  					foundIntersections.Add(new Pair<double>(aTimeStart + ((aTimeEnd - aTimeStart) / 2)' bTimeStart + ((bTimeEnd - bTimeStart) / 2)));  					}    				// BoundingBox A ist schon klein genug' aber BoundingBox B sollte nochmal näher untersucht werden:  				else if ((aBounds.Width <= tolerance) && (aBounds.Height <= tolerance))  					{  					double bTimeMiddle = bTimeStart + ((bTimeEnd - bTimeStart) / 2);    					foundIntersections = MergeIntersectionPairs(foundIntersections' CalculateIntersections(  							aSegment' bSegment.subdividedFirst'  							aTimeStart' aTimeEnd'  							bTimeStart' bTimeMiddle'  							tolerance'  							aOriginalSegment' bOriginalSegment)' aOriginalSegment' bOriginalSegment' 2*tolerance);    					foundIntersections = MergeIntersectionPairs(foundIntersections' CalculateIntersections(  							aSegment' bSegment.subdividedSecond'  							aTimeStart' aTimeEnd'  							bTimeMiddle' bTimeEnd'  							tolerance'  							aOriginalSegment' bOriginalSegment)' aOriginalSegment' bOriginalSegment' 2*tolerance);  					}    				// BoundingBox B ist schon klein genug' aber BoundingBox A sollte nochmal näher untersucht werden:  				else if ((bBounds.Width <= tolerance) && (bBounds.Height <= tolerance))  					{  					double aTimeMiddle = aTimeStart + ((aTimeEnd - aTimeStart) / 2);    					foundIntersections = MergeIntersectionPairs(foundIntersections' CalculateIntersections(  							aSegment.subdividedFirst' bSegment'  							aTimeStart' aTimeMiddle'  							bTimeStart' bTimeEnd'  							tolerance'  							aOriginalSegment' bOriginalSegment)' aOriginalSegment' bOriginalSegment' 2 * tolerance);  					foundIntersections = MergeIntersectionPairs(foundIntersections' CalculateIntersections(  							aSegment.subdividedSecond' bSegment'  							aTimeMiddle' aTimeEnd'  							bTimeStart' bTimeEnd'  							tolerance'  							aOriginalSegment' bOriginalSegment)' aOriginalSegment' bOriginalSegment' 2 * tolerance);  					}    				// die BoundingBoxen sind noch zu groß - Linie aufteilen und die 2x2 Teile auf Schnittpunkte untersuchen  				else  					{  					double aTimeMiddle = aTimeStart + ((aTimeEnd - aTimeStart) / 2);  					double bTimeMiddle = bTimeStart + ((bTimeEnd - bTimeStart) / 2);    					foundIntersections = MergeIntersectionPairs(foundIntersections' CalculateIntersections(  							aSegment.subdividedFirst' bSegment.subdividedFirst'  							aTimeStart' aTimeMiddle'  							bTimeStart' bTimeMiddle'  							tolerance'  							aOriginalSegment' bOriginalSegment)' aOriginalSegment' bOriginalSegment' 2 * tolerance);  					foundIntersections = MergeIntersectionPairs(foundIntersections' CalculateIntersections(  							aSegment.subdividedSecond' bSegment.subdividedFirst'  							aTimeMiddle' aTimeEnd'  							bTimeStart' bTimeMiddle'  							tolerance'  							aOriginalSegment' bOriginalSegment)' aOriginalSegment' bOriginalSegment' 2 * tolerance);    					foundIntersections = MergeIntersectionPairs(foundIntersections' CalculateIntersections(  							aSegment.subdividedFirst' bSegment.subdividedSecond'  							aTimeStart' aTimeMiddle'  							bTimeMiddle' bTimeEnd'  							tolerance'  							aOriginalSegment' bOriginalSegment)' aOriginalSegment' bOriginalSegment' 2 * tolerance);  					foundIntersections = MergeIntersectionPairs(foundIntersections' CalculateIntersections(  							aSegment.subdividedSecond' bSegment.subdividedSecond'  							aTimeMiddle' aTimeEnd'  							bTimeMiddle' bTimeEnd'  							tolerance'  							aOriginalSegment' bOriginalSegment)' aOriginalSegment' bOriginalSegment' 2 * tolerance);    					}  				}
Magic Number,CityTrafficSimulator,NodeSteuerung,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\NodeSteuerung.cs,CalculateIntersections,The following statement contains a magic number: if (IntersectsTrue(aBounds' bBounds)) // aBounds.IntersectsWith(bBounds)) //IntersectsTrue(aBounds' bBounds)) //   				{  				// sind beide BoundingBoxen schon kleiner als tolerance' dann haben wir einen Schnittpunkt gefunden  				if ((aBounds.Width <= tolerance) && (aBounds.Height <= tolerance)  						&& (bBounds.Width <= tolerance) && (bBounds.Height <= tolerance))  					{  					foundIntersections.Add(new Pair<double>(aTimeStart + ((aTimeEnd - aTimeStart) / 2)' bTimeStart + ((bTimeEnd - bTimeStart) / 2)));  					}    				// BoundingBox A ist schon klein genug' aber BoundingBox B sollte nochmal näher untersucht werden:  				else if ((aBounds.Width <= tolerance) && (aBounds.Height <= tolerance))  					{  					double bTimeMiddle = bTimeStart + ((bTimeEnd - bTimeStart) / 2);    					foundIntersections = MergeIntersectionPairs(foundIntersections' CalculateIntersections(  							aSegment' bSegment.subdividedFirst'  							aTimeStart' aTimeEnd'  							bTimeStart' bTimeMiddle'  							tolerance'  							aOriginalSegment' bOriginalSegment)' aOriginalSegment' bOriginalSegment' 2*tolerance);    					foundIntersections = MergeIntersectionPairs(foundIntersections' CalculateIntersections(  							aSegment' bSegment.subdividedSecond'  							aTimeStart' aTimeEnd'  							bTimeMiddle' bTimeEnd'  							tolerance'  							aOriginalSegment' bOriginalSegment)' aOriginalSegment' bOriginalSegment' 2*tolerance);  					}    				// BoundingBox B ist schon klein genug' aber BoundingBox A sollte nochmal näher untersucht werden:  				else if ((bBounds.Width <= tolerance) && (bBounds.Height <= tolerance))  					{  					double aTimeMiddle = aTimeStart + ((aTimeEnd - aTimeStart) / 2);    					foundIntersections = MergeIntersectionPairs(foundIntersections' CalculateIntersections(  							aSegment.subdividedFirst' bSegment'  							aTimeStart' aTimeMiddle'  							bTimeStart' bTimeEnd'  							tolerance'  							aOriginalSegment' bOriginalSegment)' aOriginalSegment' bOriginalSegment' 2 * tolerance);  					foundIntersections = MergeIntersectionPairs(foundIntersections' CalculateIntersections(  							aSegment.subdividedSecond' bSegment'  							aTimeMiddle' aTimeEnd'  							bTimeStart' bTimeEnd'  							tolerance'  							aOriginalSegment' bOriginalSegment)' aOriginalSegment' bOriginalSegment' 2 * tolerance);  					}    				// die BoundingBoxen sind noch zu groß - Linie aufteilen und die 2x2 Teile auf Schnittpunkte untersuchen  				else  					{  					double aTimeMiddle = aTimeStart + ((aTimeEnd - aTimeStart) / 2);  					double bTimeMiddle = bTimeStart + ((bTimeEnd - bTimeStart) / 2);    					foundIntersections = MergeIntersectionPairs(foundIntersections' CalculateIntersections(  							aSegment.subdividedFirst' bSegment.subdividedFirst'  							aTimeStart' aTimeMiddle'  							bTimeStart' bTimeMiddle'  							tolerance'  							aOriginalSegment' bOriginalSegment)' aOriginalSegment' bOriginalSegment' 2 * tolerance);  					foundIntersections = MergeIntersectionPairs(foundIntersections' CalculateIntersections(  							aSegment.subdividedSecond' bSegment.subdividedFirst'  							aTimeMiddle' aTimeEnd'  							bTimeStart' bTimeMiddle'  							tolerance'  							aOriginalSegment' bOriginalSegment)' aOriginalSegment' bOriginalSegment' 2 * tolerance);    					foundIntersections = MergeIntersectionPairs(foundIntersections' CalculateIntersections(  							aSegment.subdividedFirst' bSegment.subdividedSecond'  							aTimeStart' aTimeMiddle'  							bTimeMiddle' bTimeEnd'  							tolerance'  							aOriginalSegment' bOriginalSegment)' aOriginalSegment' bOriginalSegment' 2 * tolerance);  					foundIntersections = MergeIntersectionPairs(foundIntersections' CalculateIntersections(  							aSegment.subdividedSecond' bSegment.subdividedSecond'  							aTimeMiddle' aTimeEnd'  							bTimeMiddle' bTimeEnd'  							tolerance'  							aOriginalSegment' bOriginalSegment)' aOriginalSegment' bOriginalSegment' 2 * tolerance);    					}  				}
Magic Number,CityTrafficSimulator,NodeSteuerung,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\NodeSteuerung.cs,CalculateIntersections,The following statement contains a magic number: if (IntersectsTrue(aBounds' bBounds)) // aBounds.IntersectsWith(bBounds)) //IntersectsTrue(aBounds' bBounds)) //   				{  				// sind beide BoundingBoxen schon kleiner als tolerance' dann haben wir einen Schnittpunkt gefunden  				if ((aBounds.Width <= tolerance) && (aBounds.Height <= tolerance)  						&& (bBounds.Width <= tolerance) && (bBounds.Height <= tolerance))  					{  					foundIntersections.Add(new Pair<double>(aTimeStart + ((aTimeEnd - aTimeStart) / 2)' bTimeStart + ((bTimeEnd - bTimeStart) / 2)));  					}    				// BoundingBox A ist schon klein genug' aber BoundingBox B sollte nochmal näher untersucht werden:  				else if ((aBounds.Width <= tolerance) && (aBounds.Height <= tolerance))  					{  					double bTimeMiddle = bTimeStart + ((bTimeEnd - bTimeStart) / 2);    					foundIntersections = MergeIntersectionPairs(foundIntersections' CalculateIntersections(  							aSegment' bSegment.subdividedFirst'  							aTimeStart' aTimeEnd'  							bTimeStart' bTimeMiddle'  							tolerance'  							aOriginalSegment' bOriginalSegment)' aOriginalSegment' bOriginalSegment' 2*tolerance);    					foundIntersections = MergeIntersectionPairs(foundIntersections' CalculateIntersections(  							aSegment' bSegment.subdividedSecond'  							aTimeStart' aTimeEnd'  							bTimeMiddle' bTimeEnd'  							tolerance'  							aOriginalSegment' bOriginalSegment)' aOriginalSegment' bOriginalSegment' 2*tolerance);  					}    				// BoundingBox B ist schon klein genug' aber BoundingBox A sollte nochmal näher untersucht werden:  				else if ((bBounds.Width <= tolerance) && (bBounds.Height <= tolerance))  					{  					double aTimeMiddle = aTimeStart + ((aTimeEnd - aTimeStart) / 2);    					foundIntersections = MergeIntersectionPairs(foundIntersections' CalculateIntersections(  							aSegment.subdividedFirst' bSegment'  							aTimeStart' aTimeMiddle'  							bTimeStart' bTimeEnd'  							tolerance'  							aOriginalSegment' bOriginalSegment)' aOriginalSegment' bOriginalSegment' 2 * tolerance);  					foundIntersections = MergeIntersectionPairs(foundIntersections' CalculateIntersections(  							aSegment.subdividedSecond' bSegment'  							aTimeMiddle' aTimeEnd'  							bTimeStart' bTimeEnd'  							tolerance'  							aOriginalSegment' bOriginalSegment)' aOriginalSegment' bOriginalSegment' 2 * tolerance);  					}    				// die BoundingBoxen sind noch zu groß - Linie aufteilen und die 2x2 Teile auf Schnittpunkte untersuchen  				else  					{  					double aTimeMiddle = aTimeStart + ((aTimeEnd - aTimeStart) / 2);  					double bTimeMiddle = bTimeStart + ((bTimeEnd - bTimeStart) / 2);    					foundIntersections = MergeIntersectionPairs(foundIntersections' CalculateIntersections(  							aSegment.subdividedFirst' bSegment.subdividedFirst'  							aTimeStart' aTimeMiddle'  							bTimeStart' bTimeMiddle'  							tolerance'  							aOriginalSegment' bOriginalSegment)' aOriginalSegment' bOriginalSegment' 2 * tolerance);  					foundIntersections = MergeIntersectionPairs(foundIntersections' CalculateIntersections(  							aSegment.subdividedSecond' bSegment.subdividedFirst'  							aTimeMiddle' aTimeEnd'  							bTimeStart' bTimeMiddle'  							tolerance'  							aOriginalSegment' bOriginalSegment)' aOriginalSegment' bOriginalSegment' 2 * tolerance);    					foundIntersections = MergeIntersectionPairs(foundIntersections' CalculateIntersections(  							aSegment.subdividedFirst' bSegment.subdividedSecond'  							aTimeStart' aTimeMiddle'  							bTimeMiddle' bTimeEnd'  							tolerance'  							aOriginalSegment' bOriginalSegment)' aOriginalSegment' bOriginalSegment' 2 * tolerance);  					foundIntersections = MergeIntersectionPairs(foundIntersections' CalculateIntersections(  							aSegment.subdividedSecond' bSegment.subdividedSecond'  							aTimeMiddle' aTimeEnd'  							bTimeMiddle' bTimeEnd'  							tolerance'  							aOriginalSegment' bOriginalSegment)' aOriginalSegment' bOriginalSegment' 2 * tolerance);    					}  				}
Magic Number,CityTrafficSimulator,NodeSteuerung,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\NodeSteuerung.cs,CalculateIntersections,The following statement contains a magic number: if (IntersectsTrue(aBounds' bBounds)) // aBounds.IntersectsWith(bBounds)) //IntersectsTrue(aBounds' bBounds)) //   				{  				// sind beide BoundingBoxen schon kleiner als tolerance' dann haben wir einen Schnittpunkt gefunden  				if ((aBounds.Width <= tolerance) && (aBounds.Height <= tolerance)  						&& (bBounds.Width <= tolerance) && (bBounds.Height <= tolerance))  					{  					foundIntersections.Add(new Pair<double>(aTimeStart + ((aTimeEnd - aTimeStart) / 2)' bTimeStart + ((bTimeEnd - bTimeStart) / 2)));  					}    				// BoundingBox A ist schon klein genug' aber BoundingBox B sollte nochmal näher untersucht werden:  				else if ((aBounds.Width <= tolerance) && (aBounds.Height <= tolerance))  					{  					double bTimeMiddle = bTimeStart + ((bTimeEnd - bTimeStart) / 2);    					foundIntersections = MergeIntersectionPairs(foundIntersections' CalculateIntersections(  							aSegment' bSegment.subdividedFirst'  							aTimeStart' aTimeEnd'  							bTimeStart' bTimeMiddle'  							tolerance'  							aOriginalSegment' bOriginalSegment)' aOriginalSegment' bOriginalSegment' 2*tolerance);    					foundIntersections = MergeIntersectionPairs(foundIntersections' CalculateIntersections(  							aSegment' bSegment.subdividedSecond'  							aTimeStart' aTimeEnd'  							bTimeMiddle' bTimeEnd'  							tolerance'  							aOriginalSegment' bOriginalSegment)' aOriginalSegment' bOriginalSegment' 2*tolerance);  					}    				// BoundingBox B ist schon klein genug' aber BoundingBox A sollte nochmal näher untersucht werden:  				else if ((bBounds.Width <= tolerance) && (bBounds.Height <= tolerance))  					{  					double aTimeMiddle = aTimeStart + ((aTimeEnd - aTimeStart) / 2);    					foundIntersections = MergeIntersectionPairs(foundIntersections' CalculateIntersections(  							aSegment.subdividedFirst' bSegment'  							aTimeStart' aTimeMiddle'  							bTimeStart' bTimeEnd'  							tolerance'  							aOriginalSegment' bOriginalSegment)' aOriginalSegment' bOriginalSegment' 2 * tolerance);  					foundIntersections = MergeIntersectionPairs(foundIntersections' CalculateIntersections(  							aSegment.subdividedSecond' bSegment'  							aTimeMiddle' aTimeEnd'  							bTimeStart' bTimeEnd'  							tolerance'  							aOriginalSegment' bOriginalSegment)' aOriginalSegment' bOriginalSegment' 2 * tolerance);  					}    				// die BoundingBoxen sind noch zu groß - Linie aufteilen und die 2x2 Teile auf Schnittpunkte untersuchen  				else  					{  					double aTimeMiddle = aTimeStart + ((aTimeEnd - aTimeStart) / 2);  					double bTimeMiddle = bTimeStart + ((bTimeEnd - bTimeStart) / 2);    					foundIntersections = MergeIntersectionPairs(foundIntersections' CalculateIntersections(  							aSegment.subdividedFirst' bSegment.subdividedFirst'  							aTimeStart' aTimeMiddle'  							bTimeStart' bTimeMiddle'  							tolerance'  							aOriginalSegment' bOriginalSegment)' aOriginalSegment' bOriginalSegment' 2 * tolerance);  					foundIntersections = MergeIntersectionPairs(foundIntersections' CalculateIntersections(  							aSegment.subdividedSecond' bSegment.subdividedFirst'  							aTimeMiddle' aTimeEnd'  							bTimeStart' bTimeMiddle'  							tolerance'  							aOriginalSegment' bOriginalSegment)' aOriginalSegment' bOriginalSegment' 2 * tolerance);    					foundIntersections = MergeIntersectionPairs(foundIntersections' CalculateIntersections(  							aSegment.subdividedFirst' bSegment.subdividedSecond'  							aTimeStart' aTimeMiddle'  							bTimeMiddle' bTimeEnd'  							tolerance'  							aOriginalSegment' bOriginalSegment)' aOriginalSegment' bOriginalSegment' 2 * tolerance);  					foundIntersections = MergeIntersectionPairs(foundIntersections' CalculateIntersections(  							aSegment.subdividedSecond' bSegment.subdividedSecond'  							aTimeMiddle' aTimeEnd'  							bTimeMiddle' bTimeEnd'  							tolerance'  							aOriginalSegment' bOriginalSegment)' aOriginalSegment' bOriginalSegment' 2 * tolerance);    					}  				}
Magic Number,CityTrafficSimulator,NodeSteuerung,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\NodeSteuerung.cs,CalculateIntersections,The following statement contains a magic number: if (IntersectsTrue(aBounds' bBounds)) // aBounds.IntersectsWith(bBounds)) //IntersectsTrue(aBounds' bBounds)) //   				{  				// sind beide BoundingBoxen schon kleiner als tolerance' dann haben wir einen Schnittpunkt gefunden  				if ((aBounds.Width <= tolerance) && (aBounds.Height <= tolerance)  						&& (bBounds.Width <= tolerance) && (bBounds.Height <= tolerance))  					{  					foundIntersections.Add(new Pair<double>(aTimeStart + ((aTimeEnd - aTimeStart) / 2)' bTimeStart + ((bTimeEnd - bTimeStart) / 2)));  					}    				// BoundingBox A ist schon klein genug' aber BoundingBox B sollte nochmal näher untersucht werden:  				else if ((aBounds.Width <= tolerance) && (aBounds.Height <= tolerance))  					{  					double bTimeMiddle = bTimeStart + ((bTimeEnd - bTimeStart) / 2);    					foundIntersections = MergeIntersectionPairs(foundIntersections' CalculateIntersections(  							aSegment' bSegment.subdividedFirst'  							aTimeStart' aTimeEnd'  							bTimeStart' bTimeMiddle'  							tolerance'  							aOriginalSegment' bOriginalSegment)' aOriginalSegment' bOriginalSegment' 2*tolerance);    					foundIntersections = MergeIntersectionPairs(foundIntersections' CalculateIntersections(  							aSegment' bSegment.subdividedSecond'  							aTimeStart' aTimeEnd'  							bTimeMiddle' bTimeEnd'  							tolerance'  							aOriginalSegment' bOriginalSegment)' aOriginalSegment' bOriginalSegment' 2*tolerance);  					}    				// BoundingBox B ist schon klein genug' aber BoundingBox A sollte nochmal näher untersucht werden:  				else if ((bBounds.Width <= tolerance) && (bBounds.Height <= tolerance))  					{  					double aTimeMiddle = aTimeStart + ((aTimeEnd - aTimeStart) / 2);    					foundIntersections = MergeIntersectionPairs(foundIntersections' CalculateIntersections(  							aSegment.subdividedFirst' bSegment'  							aTimeStart' aTimeMiddle'  							bTimeStart' bTimeEnd'  							tolerance'  							aOriginalSegment' bOriginalSegment)' aOriginalSegment' bOriginalSegment' 2 * tolerance);  					foundIntersections = MergeIntersectionPairs(foundIntersections' CalculateIntersections(  							aSegment.subdividedSecond' bSegment'  							aTimeMiddle' aTimeEnd'  							bTimeStart' bTimeEnd'  							tolerance'  							aOriginalSegment' bOriginalSegment)' aOriginalSegment' bOriginalSegment' 2 * tolerance);  					}    				// die BoundingBoxen sind noch zu groß - Linie aufteilen und die 2x2 Teile auf Schnittpunkte untersuchen  				else  					{  					double aTimeMiddle = aTimeStart + ((aTimeEnd - aTimeStart) / 2);  					double bTimeMiddle = bTimeStart + ((bTimeEnd - bTimeStart) / 2);    					foundIntersections = MergeIntersectionPairs(foundIntersections' CalculateIntersections(  							aSegment.subdividedFirst' bSegment.subdividedFirst'  							aTimeStart' aTimeMiddle'  							bTimeStart' bTimeMiddle'  							tolerance'  							aOriginalSegment' bOriginalSegment)' aOriginalSegment' bOriginalSegment' 2 * tolerance);  					foundIntersections = MergeIntersectionPairs(foundIntersections' CalculateIntersections(  							aSegment.subdividedSecond' bSegment.subdividedFirst'  							aTimeMiddle' aTimeEnd'  							bTimeStart' bTimeMiddle'  							tolerance'  							aOriginalSegment' bOriginalSegment)' aOriginalSegment' bOriginalSegment' 2 * tolerance);    					foundIntersections = MergeIntersectionPairs(foundIntersections' CalculateIntersections(  							aSegment.subdividedFirst' bSegment.subdividedSecond'  							aTimeStart' aTimeMiddle'  							bTimeMiddle' bTimeEnd'  							tolerance'  							aOriginalSegment' bOriginalSegment)' aOriginalSegment' bOriginalSegment' 2 * tolerance);  					foundIntersections = MergeIntersectionPairs(foundIntersections' CalculateIntersections(  							aSegment.subdividedSecond' bSegment.subdividedSecond'  							aTimeMiddle' aTimeEnd'  							bTimeMiddle' bTimeEnd'  							tolerance'  							aOriginalSegment' bOriginalSegment)' aOriginalSegment' bOriginalSegment' 2 * tolerance);    					}  				}
Magic Number,CityTrafficSimulator,NodeSteuerung,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\NodeSteuerung.cs,CalculateIntersections,The following statement contains a magic number: if (IntersectsTrue(aBounds' bBounds)) // aBounds.IntersectsWith(bBounds)) //IntersectsTrue(aBounds' bBounds)) //   				{  				// sind beide BoundingBoxen schon kleiner als tolerance' dann haben wir einen Schnittpunkt gefunden  				if ((aBounds.Width <= tolerance) && (aBounds.Height <= tolerance)  						&& (bBounds.Width <= tolerance) && (bBounds.Height <= tolerance))  					{  					foundIntersections.Add(new Pair<double>(aTimeStart + ((aTimeEnd - aTimeStart) / 2)' bTimeStart + ((bTimeEnd - bTimeStart) / 2)));  					}    				// BoundingBox A ist schon klein genug' aber BoundingBox B sollte nochmal näher untersucht werden:  				else if ((aBounds.Width <= tolerance) && (aBounds.Height <= tolerance))  					{  					double bTimeMiddle = bTimeStart + ((bTimeEnd - bTimeStart) / 2);    					foundIntersections = MergeIntersectionPairs(foundIntersections' CalculateIntersections(  							aSegment' bSegment.subdividedFirst'  							aTimeStart' aTimeEnd'  							bTimeStart' bTimeMiddle'  							tolerance'  							aOriginalSegment' bOriginalSegment)' aOriginalSegment' bOriginalSegment' 2*tolerance);    					foundIntersections = MergeIntersectionPairs(foundIntersections' CalculateIntersections(  							aSegment' bSegment.subdividedSecond'  							aTimeStart' aTimeEnd'  							bTimeMiddle' bTimeEnd'  							tolerance'  							aOriginalSegment' bOriginalSegment)' aOriginalSegment' bOriginalSegment' 2*tolerance);  					}    				// BoundingBox B ist schon klein genug' aber BoundingBox A sollte nochmal näher untersucht werden:  				else if ((bBounds.Width <= tolerance) && (bBounds.Height <= tolerance))  					{  					double aTimeMiddle = aTimeStart + ((aTimeEnd - aTimeStart) / 2);    					foundIntersections = MergeIntersectionPairs(foundIntersections' CalculateIntersections(  							aSegment.subdividedFirst' bSegment'  							aTimeStart' aTimeMiddle'  							bTimeStart' bTimeEnd'  							tolerance'  							aOriginalSegment' bOriginalSegment)' aOriginalSegment' bOriginalSegment' 2 * tolerance);  					foundIntersections = MergeIntersectionPairs(foundIntersections' CalculateIntersections(  							aSegment.subdividedSecond' bSegment'  							aTimeMiddle' aTimeEnd'  							bTimeStart' bTimeEnd'  							tolerance'  							aOriginalSegment' bOriginalSegment)' aOriginalSegment' bOriginalSegment' 2 * tolerance);  					}    				// die BoundingBoxen sind noch zu groß - Linie aufteilen und die 2x2 Teile auf Schnittpunkte untersuchen  				else  					{  					double aTimeMiddle = aTimeStart + ((aTimeEnd - aTimeStart) / 2);  					double bTimeMiddle = bTimeStart + ((bTimeEnd - bTimeStart) / 2);    					foundIntersections = MergeIntersectionPairs(foundIntersections' CalculateIntersections(  							aSegment.subdividedFirst' bSegment.subdividedFirst'  							aTimeStart' aTimeMiddle'  							bTimeStart' bTimeMiddle'  							tolerance'  							aOriginalSegment' bOriginalSegment)' aOriginalSegment' bOriginalSegment' 2 * tolerance);  					foundIntersections = MergeIntersectionPairs(foundIntersections' CalculateIntersections(  							aSegment.subdividedSecond' bSegment.subdividedFirst'  							aTimeMiddle' aTimeEnd'  							bTimeStart' bTimeMiddle'  							tolerance'  							aOriginalSegment' bOriginalSegment)' aOriginalSegment' bOriginalSegment' 2 * tolerance);    					foundIntersections = MergeIntersectionPairs(foundIntersections' CalculateIntersections(  							aSegment.subdividedFirst' bSegment.subdividedSecond'  							aTimeStart' aTimeMiddle'  							bTimeMiddle' bTimeEnd'  							tolerance'  							aOriginalSegment' bOriginalSegment)' aOriginalSegment' bOriginalSegment' 2 * tolerance);  					foundIntersections = MergeIntersectionPairs(foundIntersections' CalculateIntersections(  							aSegment.subdividedSecond' bSegment.subdividedSecond'  							aTimeMiddle' aTimeEnd'  							bTimeMiddle' bTimeEnd'  							tolerance'  							aOriginalSegment' bOriginalSegment)' aOriginalSegment' bOriginalSegment' 2 * tolerance);    					}  				}
Magic Number,CityTrafficSimulator,NodeSteuerung,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\NodeSteuerung.cs,CalculateIntersections,The following statement contains a magic number: if (IntersectsTrue(aBounds' bBounds)) // aBounds.IntersectsWith(bBounds)) //IntersectsTrue(aBounds' bBounds)) //   				{  				// sind beide BoundingBoxen schon kleiner als tolerance' dann haben wir einen Schnittpunkt gefunden  				if ((aBounds.Width <= tolerance) && (aBounds.Height <= tolerance)  						&& (bBounds.Width <= tolerance) && (bBounds.Height <= tolerance))  					{  					foundIntersections.Add(new Pair<double>(aTimeStart + ((aTimeEnd - aTimeStart) / 2)' bTimeStart + ((bTimeEnd - bTimeStart) / 2)));  					}    				// BoundingBox A ist schon klein genug' aber BoundingBox B sollte nochmal näher untersucht werden:  				else if ((aBounds.Width <= tolerance) && (aBounds.Height <= tolerance))  					{  					double bTimeMiddle = bTimeStart + ((bTimeEnd - bTimeStart) / 2);    					foundIntersections = MergeIntersectionPairs(foundIntersections' CalculateIntersections(  							aSegment' bSegment.subdividedFirst'  							aTimeStart' aTimeEnd'  							bTimeStart' bTimeMiddle'  							tolerance'  							aOriginalSegment' bOriginalSegment)' aOriginalSegment' bOriginalSegment' 2*tolerance);    					foundIntersections = MergeIntersectionPairs(foundIntersections' CalculateIntersections(  							aSegment' bSegment.subdividedSecond'  							aTimeStart' aTimeEnd'  							bTimeMiddle' bTimeEnd'  							tolerance'  							aOriginalSegment' bOriginalSegment)' aOriginalSegment' bOriginalSegment' 2*tolerance);  					}    				// BoundingBox B ist schon klein genug' aber BoundingBox A sollte nochmal näher untersucht werden:  				else if ((bBounds.Width <= tolerance) && (bBounds.Height <= tolerance))  					{  					double aTimeMiddle = aTimeStart + ((aTimeEnd - aTimeStart) / 2);    					foundIntersections = MergeIntersectionPairs(foundIntersections' CalculateIntersections(  							aSegment.subdividedFirst' bSegment'  							aTimeStart' aTimeMiddle'  							bTimeStart' bTimeEnd'  							tolerance'  							aOriginalSegment' bOriginalSegment)' aOriginalSegment' bOriginalSegment' 2 * tolerance);  					foundIntersections = MergeIntersectionPairs(foundIntersections' CalculateIntersections(  							aSegment.subdividedSecond' bSegment'  							aTimeMiddle' aTimeEnd'  							bTimeStart' bTimeEnd'  							tolerance'  							aOriginalSegment' bOriginalSegment)' aOriginalSegment' bOriginalSegment' 2 * tolerance);  					}    				// die BoundingBoxen sind noch zu groß - Linie aufteilen und die 2x2 Teile auf Schnittpunkte untersuchen  				else  					{  					double aTimeMiddle = aTimeStart + ((aTimeEnd - aTimeStart) / 2);  					double bTimeMiddle = bTimeStart + ((bTimeEnd - bTimeStart) / 2);    					foundIntersections = MergeIntersectionPairs(foundIntersections' CalculateIntersections(  							aSegment.subdividedFirst' bSegment.subdividedFirst'  							aTimeStart' aTimeMiddle'  							bTimeStart' bTimeMiddle'  							tolerance'  							aOriginalSegment' bOriginalSegment)' aOriginalSegment' bOriginalSegment' 2 * tolerance);  					foundIntersections = MergeIntersectionPairs(foundIntersections' CalculateIntersections(  							aSegment.subdividedSecond' bSegment.subdividedFirst'  							aTimeMiddle' aTimeEnd'  							bTimeStart' bTimeMiddle'  							tolerance'  							aOriginalSegment' bOriginalSegment)' aOriginalSegment' bOriginalSegment' 2 * tolerance);    					foundIntersections = MergeIntersectionPairs(foundIntersections' CalculateIntersections(  							aSegment.subdividedFirst' bSegment.subdividedSecond'  							aTimeStart' aTimeMiddle'  							bTimeMiddle' bTimeEnd'  							tolerance'  							aOriginalSegment' bOriginalSegment)' aOriginalSegment' bOriginalSegment' 2 * tolerance);  					foundIntersections = MergeIntersectionPairs(foundIntersections' CalculateIntersections(  							aSegment.subdividedSecond' bSegment.subdividedSecond'  							aTimeMiddle' aTimeEnd'  							bTimeMiddle' bTimeEnd'  							tolerance'  							aOriginalSegment' bOriginalSegment)' aOriginalSegment' bOriginalSegment' 2 * tolerance);    					}  				}
Magic Number,CityTrafficSimulator,NodeSteuerung,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\NodeSteuerung.cs,CalculateIntersections,The following statement contains a magic number: if (IntersectsTrue(aBounds' bBounds)) // aBounds.IntersectsWith(bBounds)) //IntersectsTrue(aBounds' bBounds)) //   				{  				// sind beide BoundingBoxen schon kleiner als tolerance' dann haben wir einen Schnittpunkt gefunden  				if ((aBounds.Width <= tolerance) && (aBounds.Height <= tolerance)  						&& (bBounds.Width <= tolerance) && (bBounds.Height <= tolerance))  					{  					foundIntersections.Add(new Pair<double>(aTimeStart + ((aTimeEnd - aTimeStart) / 2)' bTimeStart + ((bTimeEnd - bTimeStart) / 2)));  					}    				// BoundingBox A ist schon klein genug' aber BoundingBox B sollte nochmal näher untersucht werden:  				else if ((aBounds.Width <= tolerance) && (aBounds.Height <= tolerance))  					{  					double bTimeMiddle = bTimeStart + ((bTimeEnd - bTimeStart) / 2);    					foundIntersections = MergeIntersectionPairs(foundIntersections' CalculateIntersections(  							aSegment' bSegment.subdividedFirst'  							aTimeStart' aTimeEnd'  							bTimeStart' bTimeMiddle'  							tolerance'  							aOriginalSegment' bOriginalSegment)' aOriginalSegment' bOriginalSegment' 2*tolerance);    					foundIntersections = MergeIntersectionPairs(foundIntersections' CalculateIntersections(  							aSegment' bSegment.subdividedSecond'  							aTimeStart' aTimeEnd'  							bTimeMiddle' bTimeEnd'  							tolerance'  							aOriginalSegment' bOriginalSegment)' aOriginalSegment' bOriginalSegment' 2*tolerance);  					}    				// BoundingBox B ist schon klein genug' aber BoundingBox A sollte nochmal näher untersucht werden:  				else if ((bBounds.Width <= tolerance) && (bBounds.Height <= tolerance))  					{  					double aTimeMiddle = aTimeStart + ((aTimeEnd - aTimeStart) / 2);    					foundIntersections = MergeIntersectionPairs(foundIntersections' CalculateIntersections(  							aSegment.subdividedFirst' bSegment'  							aTimeStart' aTimeMiddle'  							bTimeStart' bTimeEnd'  							tolerance'  							aOriginalSegment' bOriginalSegment)' aOriginalSegment' bOriginalSegment' 2 * tolerance);  					foundIntersections = MergeIntersectionPairs(foundIntersections' CalculateIntersections(  							aSegment.subdividedSecond' bSegment'  							aTimeMiddle' aTimeEnd'  							bTimeStart' bTimeEnd'  							tolerance'  							aOriginalSegment' bOriginalSegment)' aOriginalSegment' bOriginalSegment' 2 * tolerance);  					}    				// die BoundingBoxen sind noch zu groß - Linie aufteilen und die 2x2 Teile auf Schnittpunkte untersuchen  				else  					{  					double aTimeMiddle = aTimeStart + ((aTimeEnd - aTimeStart) / 2);  					double bTimeMiddle = bTimeStart + ((bTimeEnd - bTimeStart) / 2);    					foundIntersections = MergeIntersectionPairs(foundIntersections' CalculateIntersections(  							aSegment.subdividedFirst' bSegment.subdividedFirst'  							aTimeStart' aTimeMiddle'  							bTimeStart' bTimeMiddle'  							tolerance'  							aOriginalSegment' bOriginalSegment)' aOriginalSegment' bOriginalSegment' 2 * tolerance);  					foundIntersections = MergeIntersectionPairs(foundIntersections' CalculateIntersections(  							aSegment.subdividedSecond' bSegment.subdividedFirst'  							aTimeMiddle' aTimeEnd'  							bTimeStart' bTimeMiddle'  							tolerance'  							aOriginalSegment' bOriginalSegment)' aOriginalSegment' bOriginalSegment' 2 * tolerance);    					foundIntersections = MergeIntersectionPairs(foundIntersections' CalculateIntersections(  							aSegment.subdividedFirst' bSegment.subdividedSecond'  							aTimeStart' aTimeMiddle'  							bTimeMiddle' bTimeEnd'  							tolerance'  							aOriginalSegment' bOriginalSegment)' aOriginalSegment' bOriginalSegment' 2 * tolerance);  					foundIntersections = MergeIntersectionPairs(foundIntersections' CalculateIntersections(  							aSegment.subdividedSecond' bSegment.subdividedSecond'  							aTimeMiddle' aTimeEnd'  							bTimeMiddle' bTimeEnd'  							tolerance'  							aOriginalSegment' bOriginalSegment)' aOriginalSegment' bOriginalSegment' 2 * tolerance);    					}  				}
Magic Number,CityTrafficSimulator,NodeSteuerung,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\NodeSteuerung.cs,CalculateIntersections,The following statement contains a magic number: if (IntersectsTrue(aBounds' bBounds)) // aBounds.IntersectsWith(bBounds)) //IntersectsTrue(aBounds' bBounds)) //   				{  				// sind beide BoundingBoxen schon kleiner als tolerance' dann haben wir einen Schnittpunkt gefunden  				if ((aBounds.Width <= tolerance) && (aBounds.Height <= tolerance)  						&& (bBounds.Width <= tolerance) && (bBounds.Height <= tolerance))  					{  					foundIntersections.Add(new Pair<double>(aTimeStart + ((aTimeEnd - aTimeStart) / 2)' bTimeStart + ((bTimeEnd - bTimeStart) / 2)));  					}    				// BoundingBox A ist schon klein genug' aber BoundingBox B sollte nochmal näher untersucht werden:  				else if ((aBounds.Width <= tolerance) && (aBounds.Height <= tolerance))  					{  					double bTimeMiddle = bTimeStart + ((bTimeEnd - bTimeStart) / 2);    					foundIntersections = MergeIntersectionPairs(foundIntersections' CalculateIntersections(  							aSegment' bSegment.subdividedFirst'  							aTimeStart' aTimeEnd'  							bTimeStart' bTimeMiddle'  							tolerance'  							aOriginalSegment' bOriginalSegment)' aOriginalSegment' bOriginalSegment' 2*tolerance);    					foundIntersections = MergeIntersectionPairs(foundIntersections' CalculateIntersections(  							aSegment' bSegment.subdividedSecond'  							aTimeStart' aTimeEnd'  							bTimeMiddle' bTimeEnd'  							tolerance'  							aOriginalSegment' bOriginalSegment)' aOriginalSegment' bOriginalSegment' 2*tolerance);  					}    				// BoundingBox B ist schon klein genug' aber BoundingBox A sollte nochmal näher untersucht werden:  				else if ((bBounds.Width <= tolerance) && (bBounds.Height <= tolerance))  					{  					double aTimeMiddle = aTimeStart + ((aTimeEnd - aTimeStart) / 2);    					foundIntersections = MergeIntersectionPairs(foundIntersections' CalculateIntersections(  							aSegment.subdividedFirst' bSegment'  							aTimeStart' aTimeMiddle'  							bTimeStart' bTimeEnd'  							tolerance'  							aOriginalSegment' bOriginalSegment)' aOriginalSegment' bOriginalSegment' 2 * tolerance);  					foundIntersections = MergeIntersectionPairs(foundIntersections' CalculateIntersections(  							aSegment.subdividedSecond' bSegment'  							aTimeMiddle' aTimeEnd'  							bTimeStart' bTimeEnd'  							tolerance'  							aOriginalSegment' bOriginalSegment)' aOriginalSegment' bOriginalSegment' 2 * tolerance);  					}    				// die BoundingBoxen sind noch zu groß - Linie aufteilen und die 2x2 Teile auf Schnittpunkte untersuchen  				else  					{  					double aTimeMiddle = aTimeStart + ((aTimeEnd - aTimeStart) / 2);  					double bTimeMiddle = bTimeStart + ((bTimeEnd - bTimeStart) / 2);    					foundIntersections = MergeIntersectionPairs(foundIntersections' CalculateIntersections(  							aSegment.subdividedFirst' bSegment.subdividedFirst'  							aTimeStart' aTimeMiddle'  							bTimeStart' bTimeMiddle'  							tolerance'  							aOriginalSegment' bOriginalSegment)' aOriginalSegment' bOriginalSegment' 2 * tolerance);  					foundIntersections = MergeIntersectionPairs(foundIntersections' CalculateIntersections(  							aSegment.subdividedSecond' bSegment.subdividedFirst'  							aTimeMiddle' aTimeEnd'  							bTimeStart' bTimeMiddle'  							tolerance'  							aOriginalSegment' bOriginalSegment)' aOriginalSegment' bOriginalSegment' 2 * tolerance);    					foundIntersections = MergeIntersectionPairs(foundIntersections' CalculateIntersections(  							aSegment.subdividedFirst' bSegment.subdividedSecond'  							aTimeStart' aTimeMiddle'  							bTimeMiddle' bTimeEnd'  							tolerance'  							aOriginalSegment' bOriginalSegment)' aOriginalSegment' bOriginalSegment' 2 * tolerance);  					foundIntersections = MergeIntersectionPairs(foundIntersections' CalculateIntersections(  							aSegment.subdividedSecond' bSegment.subdividedSecond'  							aTimeMiddle' aTimeEnd'  							bTimeMiddle' bTimeEnd'  							tolerance'  							aOriginalSegment' bOriginalSegment)' aOriginalSegment' bOriginalSegment' 2 * tolerance);    					}  				}
Magic Number,CityTrafficSimulator,NodeSteuerung,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\NodeSteuerung.cs,CalculateIntersections,The following statement contains a magic number: if (IntersectsTrue(aBounds' bBounds)) // aBounds.IntersectsWith(bBounds)) //IntersectsTrue(aBounds' bBounds)) //   				{  				// sind beide BoundingBoxen schon kleiner als tolerance' dann haben wir einen Schnittpunkt gefunden  				if ((aBounds.Width <= tolerance) && (aBounds.Height <= tolerance)  						&& (bBounds.Width <= tolerance) && (bBounds.Height <= tolerance))  					{  					foundIntersections.Add(new Pair<double>(aTimeStart + ((aTimeEnd - aTimeStart) / 2)' bTimeStart + ((bTimeEnd - bTimeStart) / 2)));  					}    				// BoundingBox A ist schon klein genug' aber BoundingBox B sollte nochmal näher untersucht werden:  				else if ((aBounds.Width <= tolerance) && (aBounds.Height <= tolerance))  					{  					double bTimeMiddle = bTimeStart + ((bTimeEnd - bTimeStart) / 2);    					foundIntersections = MergeIntersectionPairs(foundIntersections' CalculateIntersections(  							aSegment' bSegment.subdividedFirst'  							aTimeStart' aTimeEnd'  							bTimeStart' bTimeMiddle'  							tolerance'  							aOriginalSegment' bOriginalSegment)' aOriginalSegment' bOriginalSegment' 2*tolerance);    					foundIntersections = MergeIntersectionPairs(foundIntersections' CalculateIntersections(  							aSegment' bSegment.subdividedSecond'  							aTimeStart' aTimeEnd'  							bTimeMiddle' bTimeEnd'  							tolerance'  							aOriginalSegment' bOriginalSegment)' aOriginalSegment' bOriginalSegment' 2*tolerance);  					}    				// BoundingBox B ist schon klein genug' aber BoundingBox A sollte nochmal näher untersucht werden:  				else if ((bBounds.Width <= tolerance) && (bBounds.Height <= tolerance))  					{  					double aTimeMiddle = aTimeStart + ((aTimeEnd - aTimeStart) / 2);    					foundIntersections = MergeIntersectionPairs(foundIntersections' CalculateIntersections(  							aSegment.subdividedFirst' bSegment'  							aTimeStart' aTimeMiddle'  							bTimeStart' bTimeEnd'  							tolerance'  							aOriginalSegment' bOriginalSegment)' aOriginalSegment' bOriginalSegment' 2 * tolerance);  					foundIntersections = MergeIntersectionPairs(foundIntersections' CalculateIntersections(  							aSegment.subdividedSecond' bSegment'  							aTimeMiddle' aTimeEnd'  							bTimeStart' bTimeEnd'  							tolerance'  							aOriginalSegment' bOriginalSegment)' aOriginalSegment' bOriginalSegment' 2 * tolerance);  					}    				// die BoundingBoxen sind noch zu groß - Linie aufteilen und die 2x2 Teile auf Schnittpunkte untersuchen  				else  					{  					double aTimeMiddle = aTimeStart + ((aTimeEnd - aTimeStart) / 2);  					double bTimeMiddle = bTimeStart + ((bTimeEnd - bTimeStart) / 2);    					foundIntersections = MergeIntersectionPairs(foundIntersections' CalculateIntersections(  							aSegment.subdividedFirst' bSegment.subdividedFirst'  							aTimeStart' aTimeMiddle'  							bTimeStart' bTimeMiddle'  							tolerance'  							aOriginalSegment' bOriginalSegment)' aOriginalSegment' bOriginalSegment' 2 * tolerance);  					foundIntersections = MergeIntersectionPairs(foundIntersections' CalculateIntersections(  							aSegment.subdividedSecond' bSegment.subdividedFirst'  							aTimeMiddle' aTimeEnd'  							bTimeStart' bTimeMiddle'  							tolerance'  							aOriginalSegment' bOriginalSegment)' aOriginalSegment' bOriginalSegment' 2 * tolerance);    					foundIntersections = MergeIntersectionPairs(foundIntersections' CalculateIntersections(  							aSegment.subdividedFirst' bSegment.subdividedSecond'  							aTimeStart' aTimeMiddle'  							bTimeMiddle' bTimeEnd'  							tolerance'  							aOriginalSegment' bOriginalSegment)' aOriginalSegment' bOriginalSegment' 2 * tolerance);  					foundIntersections = MergeIntersectionPairs(foundIntersections' CalculateIntersections(  							aSegment.subdividedSecond' bSegment.subdividedSecond'  							aTimeMiddle' aTimeEnd'  							bTimeMiddle' bTimeEnd'  							tolerance'  							aOriginalSegment' bOriginalSegment)' aOriginalSegment' bOriginalSegment' 2 * tolerance);    					}  				}
Magic Number,CityTrafficSimulator,NodeSteuerung,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\NodeSteuerung.cs,CalculateIntersections,The following statement contains a magic number: if (IntersectsTrue(aBounds' bBounds)) // aBounds.IntersectsWith(bBounds)) //IntersectsTrue(aBounds' bBounds)) //   				{  				// sind beide BoundingBoxen schon kleiner als tolerance' dann haben wir einen Schnittpunkt gefunden  				if ((aBounds.Width <= tolerance) && (aBounds.Height <= tolerance)  						&& (bBounds.Width <= tolerance) && (bBounds.Height <= tolerance))  					{  					foundIntersections.Add(new Pair<double>(aTimeStart + ((aTimeEnd - aTimeStart) / 2)' bTimeStart + ((bTimeEnd - bTimeStart) / 2)));  					}    				// BoundingBox A ist schon klein genug' aber BoundingBox B sollte nochmal näher untersucht werden:  				else if ((aBounds.Width <= tolerance) && (aBounds.Height <= tolerance))  					{  					double bTimeMiddle = bTimeStart + ((bTimeEnd - bTimeStart) / 2);    					foundIntersections = MergeIntersectionPairs(foundIntersections' CalculateIntersections(  							aSegment' bSegment.subdividedFirst'  							aTimeStart' aTimeEnd'  							bTimeStart' bTimeMiddle'  							tolerance'  							aOriginalSegment' bOriginalSegment)' aOriginalSegment' bOriginalSegment' 2*tolerance);    					foundIntersections = MergeIntersectionPairs(foundIntersections' CalculateIntersections(  							aSegment' bSegment.subdividedSecond'  							aTimeStart' aTimeEnd'  							bTimeMiddle' bTimeEnd'  							tolerance'  							aOriginalSegment' bOriginalSegment)' aOriginalSegment' bOriginalSegment' 2*tolerance);  					}    				// BoundingBox B ist schon klein genug' aber BoundingBox A sollte nochmal näher untersucht werden:  				else if ((bBounds.Width <= tolerance) && (bBounds.Height <= tolerance))  					{  					double aTimeMiddle = aTimeStart + ((aTimeEnd - aTimeStart) / 2);    					foundIntersections = MergeIntersectionPairs(foundIntersections' CalculateIntersections(  							aSegment.subdividedFirst' bSegment'  							aTimeStart' aTimeMiddle'  							bTimeStart' bTimeEnd'  							tolerance'  							aOriginalSegment' bOriginalSegment)' aOriginalSegment' bOriginalSegment' 2 * tolerance);  					foundIntersections = MergeIntersectionPairs(foundIntersections' CalculateIntersections(  							aSegment.subdividedSecond' bSegment'  							aTimeMiddle' aTimeEnd'  							bTimeStart' bTimeEnd'  							tolerance'  							aOriginalSegment' bOriginalSegment)' aOriginalSegment' bOriginalSegment' 2 * tolerance);  					}    				// die BoundingBoxen sind noch zu groß - Linie aufteilen und die 2x2 Teile auf Schnittpunkte untersuchen  				else  					{  					double aTimeMiddle = aTimeStart + ((aTimeEnd - aTimeStart) / 2);  					double bTimeMiddle = bTimeStart + ((bTimeEnd - bTimeStart) / 2);    					foundIntersections = MergeIntersectionPairs(foundIntersections' CalculateIntersections(  							aSegment.subdividedFirst' bSegment.subdividedFirst'  							aTimeStart' aTimeMiddle'  							bTimeStart' bTimeMiddle'  							tolerance'  							aOriginalSegment' bOriginalSegment)' aOriginalSegment' bOriginalSegment' 2 * tolerance);  					foundIntersections = MergeIntersectionPairs(foundIntersections' CalculateIntersections(  							aSegment.subdividedSecond' bSegment.subdividedFirst'  							aTimeMiddle' aTimeEnd'  							bTimeStart' bTimeMiddle'  							tolerance'  							aOriginalSegment' bOriginalSegment)' aOriginalSegment' bOriginalSegment' 2 * tolerance);    					foundIntersections = MergeIntersectionPairs(foundIntersections' CalculateIntersections(  							aSegment.subdividedFirst' bSegment.subdividedSecond'  							aTimeStart' aTimeMiddle'  							bTimeMiddle' bTimeEnd'  							tolerance'  							aOriginalSegment' bOriginalSegment)' aOriginalSegment' bOriginalSegment' 2 * tolerance);  					foundIntersections = MergeIntersectionPairs(foundIntersections' CalculateIntersections(  							aSegment.subdividedSecond' bSegment.subdividedSecond'  							aTimeMiddle' aTimeEnd'  							bTimeMiddle' bTimeEnd'  							tolerance'  							aOriginalSegment' bOriginalSegment)' aOriginalSegment' bOriginalSegment' 2 * tolerance);    					}  				}
Magic Number,CityTrafficSimulator,NodeSteuerung,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\NodeSteuerung.cs,CalculateIntersections,The following statement contains a magic number: if (IntersectsTrue(aBounds' bBounds)) // aBounds.IntersectsWith(bBounds)) //IntersectsTrue(aBounds' bBounds)) //   				{  				// sind beide BoundingBoxen schon kleiner als tolerance' dann haben wir einen Schnittpunkt gefunden  				if ((aBounds.Width <= tolerance) && (aBounds.Height <= tolerance)  						&& (bBounds.Width <= tolerance) && (bBounds.Height <= tolerance))  					{  					foundIntersections.Add(new Pair<double>(aTimeStart + ((aTimeEnd - aTimeStart) / 2)' bTimeStart + ((bTimeEnd - bTimeStart) / 2)));  					}    				// BoundingBox A ist schon klein genug' aber BoundingBox B sollte nochmal näher untersucht werden:  				else if ((aBounds.Width <= tolerance) && (aBounds.Height <= tolerance))  					{  					double bTimeMiddle = bTimeStart + ((bTimeEnd - bTimeStart) / 2);    					foundIntersections = MergeIntersectionPairs(foundIntersections' CalculateIntersections(  							aSegment' bSegment.subdividedFirst'  							aTimeStart' aTimeEnd'  							bTimeStart' bTimeMiddle'  							tolerance'  							aOriginalSegment' bOriginalSegment)' aOriginalSegment' bOriginalSegment' 2*tolerance);    					foundIntersections = MergeIntersectionPairs(foundIntersections' CalculateIntersections(  							aSegment' bSegment.subdividedSecond'  							aTimeStart' aTimeEnd'  							bTimeMiddle' bTimeEnd'  							tolerance'  							aOriginalSegment' bOriginalSegment)' aOriginalSegment' bOriginalSegment' 2*tolerance);  					}    				// BoundingBox B ist schon klein genug' aber BoundingBox A sollte nochmal näher untersucht werden:  				else if ((bBounds.Width <= tolerance) && (bBounds.Height <= tolerance))  					{  					double aTimeMiddle = aTimeStart + ((aTimeEnd - aTimeStart) / 2);    					foundIntersections = MergeIntersectionPairs(foundIntersections' CalculateIntersections(  							aSegment.subdividedFirst' bSegment'  							aTimeStart' aTimeMiddle'  							bTimeStart' bTimeEnd'  							tolerance'  							aOriginalSegment' bOriginalSegment)' aOriginalSegment' bOriginalSegment' 2 * tolerance);  					foundIntersections = MergeIntersectionPairs(foundIntersections' CalculateIntersections(  							aSegment.subdividedSecond' bSegment'  							aTimeMiddle' aTimeEnd'  							bTimeStart' bTimeEnd'  							tolerance'  							aOriginalSegment' bOriginalSegment)' aOriginalSegment' bOriginalSegment' 2 * tolerance);  					}    				// die BoundingBoxen sind noch zu groß - Linie aufteilen und die 2x2 Teile auf Schnittpunkte untersuchen  				else  					{  					double aTimeMiddle = aTimeStart + ((aTimeEnd - aTimeStart) / 2);  					double bTimeMiddle = bTimeStart + ((bTimeEnd - bTimeStart) / 2);    					foundIntersections = MergeIntersectionPairs(foundIntersections' CalculateIntersections(  							aSegment.subdividedFirst' bSegment.subdividedFirst'  							aTimeStart' aTimeMiddle'  							bTimeStart' bTimeMiddle'  							tolerance'  							aOriginalSegment' bOriginalSegment)' aOriginalSegment' bOriginalSegment' 2 * tolerance);  					foundIntersections = MergeIntersectionPairs(foundIntersections' CalculateIntersections(  							aSegment.subdividedSecond' bSegment.subdividedFirst'  							aTimeMiddle' aTimeEnd'  							bTimeStart' bTimeMiddle'  							tolerance'  							aOriginalSegment' bOriginalSegment)' aOriginalSegment' bOriginalSegment' 2 * tolerance);    					foundIntersections = MergeIntersectionPairs(foundIntersections' CalculateIntersections(  							aSegment.subdividedFirst' bSegment.subdividedSecond'  							aTimeStart' aTimeMiddle'  							bTimeMiddle' bTimeEnd'  							tolerance'  							aOriginalSegment' bOriginalSegment)' aOriginalSegment' bOriginalSegment' 2 * tolerance);  					foundIntersections = MergeIntersectionPairs(foundIntersections' CalculateIntersections(  							aSegment.subdividedSecond' bSegment.subdividedSecond'  							aTimeMiddle' aTimeEnd'  							bTimeMiddle' bTimeEnd'  							tolerance'  							aOriginalSegment' bOriginalSegment)' aOriginalSegment' bOriginalSegment' 2 * tolerance);    					}  				}
Magic Number,CityTrafficSimulator,NodeSteuerung,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\NodeSteuerung.cs,CalculateIntersections,The following statement contains a magic number: if (IntersectsTrue(aBounds' bBounds)) // aBounds.IntersectsWith(bBounds)) //IntersectsTrue(aBounds' bBounds)) //   				{  				// sind beide BoundingBoxen schon kleiner als tolerance' dann haben wir einen Schnittpunkt gefunden  				if ((aBounds.Width <= tolerance) && (aBounds.Height <= tolerance)  						&& (bBounds.Width <= tolerance) && (bBounds.Height <= tolerance))  					{  					foundIntersections.Add(new Pair<double>(aTimeStart + ((aTimeEnd - aTimeStart) / 2)' bTimeStart + ((bTimeEnd - bTimeStart) / 2)));  					}    				// BoundingBox A ist schon klein genug' aber BoundingBox B sollte nochmal näher untersucht werden:  				else if ((aBounds.Width <= tolerance) && (aBounds.Height <= tolerance))  					{  					double bTimeMiddle = bTimeStart + ((bTimeEnd - bTimeStart) / 2);    					foundIntersections = MergeIntersectionPairs(foundIntersections' CalculateIntersections(  							aSegment' bSegment.subdividedFirst'  							aTimeStart' aTimeEnd'  							bTimeStart' bTimeMiddle'  							tolerance'  							aOriginalSegment' bOriginalSegment)' aOriginalSegment' bOriginalSegment' 2*tolerance);    					foundIntersections = MergeIntersectionPairs(foundIntersections' CalculateIntersections(  							aSegment' bSegment.subdividedSecond'  							aTimeStart' aTimeEnd'  							bTimeMiddle' bTimeEnd'  							tolerance'  							aOriginalSegment' bOriginalSegment)' aOriginalSegment' bOriginalSegment' 2*tolerance);  					}    				// BoundingBox B ist schon klein genug' aber BoundingBox A sollte nochmal näher untersucht werden:  				else if ((bBounds.Width <= tolerance) && (bBounds.Height <= tolerance))  					{  					double aTimeMiddle = aTimeStart + ((aTimeEnd - aTimeStart) / 2);    					foundIntersections = MergeIntersectionPairs(foundIntersections' CalculateIntersections(  							aSegment.subdividedFirst' bSegment'  							aTimeStart' aTimeMiddle'  							bTimeStart' bTimeEnd'  							tolerance'  							aOriginalSegment' bOriginalSegment)' aOriginalSegment' bOriginalSegment' 2 * tolerance);  					foundIntersections = MergeIntersectionPairs(foundIntersections' CalculateIntersections(  							aSegment.subdividedSecond' bSegment'  							aTimeMiddle' aTimeEnd'  							bTimeStart' bTimeEnd'  							tolerance'  							aOriginalSegment' bOriginalSegment)' aOriginalSegment' bOriginalSegment' 2 * tolerance);  					}    				// die BoundingBoxen sind noch zu groß - Linie aufteilen und die 2x2 Teile auf Schnittpunkte untersuchen  				else  					{  					double aTimeMiddle = aTimeStart + ((aTimeEnd - aTimeStart) / 2);  					double bTimeMiddle = bTimeStart + ((bTimeEnd - bTimeStart) / 2);    					foundIntersections = MergeIntersectionPairs(foundIntersections' CalculateIntersections(  							aSegment.subdividedFirst' bSegment.subdividedFirst'  							aTimeStart' aTimeMiddle'  							bTimeStart' bTimeMiddle'  							tolerance'  							aOriginalSegment' bOriginalSegment)' aOriginalSegment' bOriginalSegment' 2 * tolerance);  					foundIntersections = MergeIntersectionPairs(foundIntersections' CalculateIntersections(  							aSegment.subdividedSecond' bSegment.subdividedFirst'  							aTimeMiddle' aTimeEnd'  							bTimeStart' bTimeMiddle'  							tolerance'  							aOriginalSegment' bOriginalSegment)' aOriginalSegment' bOriginalSegment' 2 * tolerance);    					foundIntersections = MergeIntersectionPairs(foundIntersections' CalculateIntersections(  							aSegment.subdividedFirst' bSegment.subdividedSecond'  							aTimeStart' aTimeMiddle'  							bTimeMiddle' bTimeEnd'  							tolerance'  							aOriginalSegment' bOriginalSegment)' aOriginalSegment' bOriginalSegment' 2 * tolerance);  					foundIntersections = MergeIntersectionPairs(foundIntersections' CalculateIntersections(  							aSegment.subdividedSecond' bSegment.subdividedSecond'  							aTimeMiddle' aTimeEnd'  							bTimeMiddle' bTimeEnd'  							tolerance'  							aOriginalSegment' bOriginalSegment)' aOriginalSegment' bOriginalSegment' 2 * tolerance);    					}  				}
Magic Number,CityTrafficSimulator,NodeSteuerung,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\NodeSteuerung.cs,CalculateIntersections,The following statement contains a magic number: if (IntersectsTrue(aBounds' bBounds)) // aBounds.IntersectsWith(bBounds)) //IntersectsTrue(aBounds' bBounds)) //   				{  				// sind beide BoundingBoxen schon kleiner als tolerance' dann haben wir einen Schnittpunkt gefunden  				if ((aBounds.Width <= tolerance) && (aBounds.Height <= tolerance)  						&& (bBounds.Width <= tolerance) && (bBounds.Height <= tolerance))  					{  					foundIntersections.Add(new Pair<double>(aTimeStart + ((aTimeEnd - aTimeStart) / 2)' bTimeStart + ((bTimeEnd - bTimeStart) / 2)));  					}    				// BoundingBox A ist schon klein genug' aber BoundingBox B sollte nochmal näher untersucht werden:  				else if ((aBounds.Width <= tolerance) && (aBounds.Height <= tolerance))  					{  					double bTimeMiddle = bTimeStart + ((bTimeEnd - bTimeStart) / 2);    					foundIntersections = MergeIntersectionPairs(foundIntersections' CalculateIntersections(  							aSegment' bSegment.subdividedFirst'  							aTimeStart' aTimeEnd'  							bTimeStart' bTimeMiddle'  							tolerance'  							aOriginalSegment' bOriginalSegment)' aOriginalSegment' bOriginalSegment' 2*tolerance);    					foundIntersections = MergeIntersectionPairs(foundIntersections' CalculateIntersections(  							aSegment' bSegment.subdividedSecond'  							aTimeStart' aTimeEnd'  							bTimeMiddle' bTimeEnd'  							tolerance'  							aOriginalSegment' bOriginalSegment)' aOriginalSegment' bOriginalSegment' 2*tolerance);  					}    				// BoundingBox B ist schon klein genug' aber BoundingBox A sollte nochmal näher untersucht werden:  				else if ((bBounds.Width <= tolerance) && (bBounds.Height <= tolerance))  					{  					double aTimeMiddle = aTimeStart + ((aTimeEnd - aTimeStart) / 2);    					foundIntersections = MergeIntersectionPairs(foundIntersections' CalculateIntersections(  							aSegment.subdividedFirst' bSegment'  							aTimeStart' aTimeMiddle'  							bTimeStart' bTimeEnd'  							tolerance'  							aOriginalSegment' bOriginalSegment)' aOriginalSegment' bOriginalSegment' 2 * tolerance);  					foundIntersections = MergeIntersectionPairs(foundIntersections' CalculateIntersections(  							aSegment.subdividedSecond' bSegment'  							aTimeMiddle' aTimeEnd'  							bTimeStart' bTimeEnd'  							tolerance'  							aOriginalSegment' bOriginalSegment)' aOriginalSegment' bOriginalSegment' 2 * tolerance);  					}    				// die BoundingBoxen sind noch zu groß - Linie aufteilen und die 2x2 Teile auf Schnittpunkte untersuchen  				else  					{  					double aTimeMiddle = aTimeStart + ((aTimeEnd - aTimeStart) / 2);  					double bTimeMiddle = bTimeStart + ((bTimeEnd - bTimeStart) / 2);    					foundIntersections = MergeIntersectionPairs(foundIntersections' CalculateIntersections(  							aSegment.subdividedFirst' bSegment.subdividedFirst'  							aTimeStart' aTimeMiddle'  							bTimeStart' bTimeMiddle'  							tolerance'  							aOriginalSegment' bOriginalSegment)' aOriginalSegment' bOriginalSegment' 2 * tolerance);  					foundIntersections = MergeIntersectionPairs(foundIntersections' CalculateIntersections(  							aSegment.subdividedSecond' bSegment.subdividedFirst'  							aTimeMiddle' aTimeEnd'  							bTimeStart' bTimeMiddle'  							tolerance'  							aOriginalSegment' bOriginalSegment)' aOriginalSegment' bOriginalSegment' 2 * tolerance);    					foundIntersections = MergeIntersectionPairs(foundIntersections' CalculateIntersections(  							aSegment.subdividedFirst' bSegment.subdividedSecond'  							aTimeStart' aTimeMiddle'  							bTimeMiddle' bTimeEnd'  							tolerance'  							aOriginalSegment' bOriginalSegment)' aOriginalSegment' bOriginalSegment' 2 * tolerance);  					foundIntersections = MergeIntersectionPairs(foundIntersections' CalculateIntersections(  							aSegment.subdividedSecond' bSegment.subdividedSecond'  							aTimeMiddle' aTimeEnd'  							bTimeMiddle' bTimeEnd'  							tolerance'  							aOriginalSegment' bOriginalSegment)' aOriginalSegment' bOriginalSegment' 2 * tolerance);    					}  				}
Magic Number,CityTrafficSimulator,NodeSteuerung,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\NodeSteuerung.cs,FindLineChangePoints,The following statement contains a magic number: double currentArcPosition = distanceBetweenChangePoints/2;
Magic Number,CityTrafficSimulator,NodeSteuerung,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\NodeSteuerung.cs,FindLineChangePoints,The following statement contains a magic number: double delta = distanceBetweenChangePoints / 4;
Magic Number,CityTrafficSimulator,NodeSteuerung,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\NodeSteuerung.cs,FindLineChangePoints,The following statement contains a magic number: while (currentArcPosition < nc.lineSegment.length - distanceBetweenChangePoints/2)  				{  				Vector2 startl = nc.lineSegment.AtPosition(currentArcPosition - delta);  				Vector2 startr = nc.lineSegment.AtPosition(currentArcPosition + delta);    				Vector2 leftVector = nc.lineSegment.DerivateAtTime(nc.lineSegment.PosToTime(currentArcPosition - delta)).RotatedClockwise.Normalized;  				Vector2 rightVector = nc.lineSegment.DerivateAtTime(nc.lineSegment.PosToTime(currentArcPosition + delta)).RotatedCounterClockwise.Normalized;    				// Faule Implementierung:	statt Schnittpunkt Gerade/Bezierkurve zu berechnen nutzen wir vorhandenen  				//							Code und Berechnen den Schnittpunkt zwischen zwei Bezierkurven.  				// TODO:	Sollte das hier zu langsam sein' muss eben neuer optimierter Code her für die Berechnung  				//			von Schnittpunkten Gerade/Bezierkurve  				LineSegment leftLS = new LineSegment(0' startl' startl + 0.25 * maxDistanceToOtherNodeConnection * leftVector' startl + 0.75 * maxDistanceToOtherNodeConnection * leftVector' startl + maxDistanceToOtherNodeConnection * leftVector);  				LineSegment rightLS = new LineSegment(0' startr' startr + 0.25 * maxDistanceToOtherNodeConnection * rightVector' startr + 0.75 * maxDistanceToOtherNodeConnection * rightVector' startr + maxDistanceToOtherNodeConnection * rightVector);    				foreach (NodeConnection nc2 in _connections)  					{  					if (nc2.enableIncomingLineChange && (nc2.carsAllowed || nc2.busAllowed) && nc != nc2 && nc.startNode.networkLayer == nc2.startNode.networkLayer && nc.endNode.networkLayer == nc2.endNode.networkLayer)  						{  						// LINKS: Zeitparameterpaare ermitteln   						List<Pair<double>> intersectionTimes = CalculateIntersections(leftLS' nc2.lineSegment' 0d' 1d' 0d' 1d' 8' leftLS' nc2.lineSegment);  						if (intersectionTimes != null)  							{  							// Startposition  							NodeConnection.SpecificPosition start = new NodeConnection.SpecificPosition(currentArcPosition - delta' nc);    							// LineChangePoints erstellen  							foreach (Pair<double> p in intersectionTimes)  								{  								// Winkel überprüfen  								if (Vector2.AngleBetween(nc.lineSegment.DerivateAtTime(nc.lineSegment.PosToTime(currentArcPosition - delta))' nc2.lineSegment.DerivateAtTime(p.Right)) < Constants.maximumAngleBetweenConnectionsForLineChangePoint)  									{  									NodeConnection.SpecificPosition otherStart = new NodeConnection.SpecificPosition(nc2' p.Right);    									// Einfädelpunkt des Fahrzeugs bestimmen und evtl. auf nächste NodeConnection weiterverfolgen:  									double distance = (nc.lineSegment.AtPosition(currentArcPosition - delta) - nc2.lineSegment.AtTime(p.Right)).Abs;    									// Einfädelpunkt:  									double arcPositionTarget = nc2.lineSegment.TimeToArcPosition(p.Right) + 3 * distance;    									if (arcPositionTarget <= nc2.lineSegment.length)  										{  										NodeConnection.SpecificPosition target = new NodeConnection.SpecificPosition(arcPositionTarget' nc2);  										nc.AddLineChangePoint(new NodeConnection.LineChangePoint(start' target' otherStart));  										}  									else  										{  										double diff = arcPositionTarget - nc2.lineSegment.length;  										foreach (NodeConnection nextNc in nc2.endNode.nextConnections)  											{  											if (   (diff <= nextNc.lineSegment.length)  												&& (nextNc.enableIncomingLineChange && (nextNc.carsAllowed || nextNc.busAllowed))  												&& (nc != nextNc))  												{  												NodeConnection.SpecificPosition target = new NodeConnection.SpecificPosition(diff' nextNc);  												nc.AddLineChangePoint(new NodeConnection.LineChangePoint(start' target' otherStart));  												}  											}  										}    									break;  									}  								}  							}    						// RECHTS: Zeitparameterpaare ermitteln  						intersectionTimes = CalculateIntersections(rightLS' nc2.lineSegment' 0d' 1d' 0d' 1d' 8' leftLS' nc2.lineSegment);  						if (intersectionTimes != null)  							{  							// Startposition  							NodeConnection.SpecificPosition start = new NodeConnection.SpecificPosition(currentArcPosition + delta' nc);    							// LineChangePoints erstellen  							foreach (Pair<double> p in intersectionTimes)  								{  								// Winkel überprüfen  								if (Vector2.AngleBetween(nc.lineSegment.DerivateAtTime(nc.lineSegment.PosToTime(currentArcPosition + delta))' nc2.lineSegment.DerivateAtTime(p.Right)) < Constants.maximumAngleBetweenConnectionsForLineChangePoint)  									{  									NodeConnection.SpecificPosition otherStart = new NodeConnection.SpecificPosition(nc2' p.Right);    									// Einfädelpunkt des Fahrzeugs bestimmen und evtl. auf nächste NodeConnection weiterverfolgen:  									double distance = (nc.lineSegment.AtPosition(currentArcPosition + delta) - nc2.lineSegment.AtTime(p.Right)).Abs;    									// Einfädelpunkt:  									double arcPositionTarget = nc2.lineSegment.TimeToArcPosition(p.Right) + 3 * distance;    									if (arcPositionTarget <= nc2.lineSegment.length)  										{  										NodeConnection.SpecificPosition target = new NodeConnection.SpecificPosition(arcPositionTarget' nc2);  										nc.AddLineChangePoint(new NodeConnection.LineChangePoint(start' target' otherStart));  										}  									else  										{  										double diff = arcPositionTarget - nc2.lineSegment.length;  										foreach (NodeConnection nextNc in nc2.endNode.nextConnections)  											{  											if ((diff <= nextNc.lineSegment.length)  												&& (nextNc.enableIncomingLineChange && (nextNc.carsAllowed || nextNc.busAllowed))  												&& (nc != nextNc))  												{  												NodeConnection.SpecificPosition target = new NodeConnection.SpecificPosition(diff' nextNc);  												nc.AddLineChangePoint(new NodeConnection.LineChangePoint(start' target' otherStart));  												}  											}  										}    									break;  									}  								}  							}  						}  					}    				currentArcPosition += distanceBetweenChangePoints;  				}
Magic Number,CityTrafficSimulator,NodeSteuerung,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\NodeSteuerung.cs,FindLineChangePoints,The following statement contains a magic number: while (currentArcPosition < nc.lineSegment.length - distanceBetweenChangePoints/2)  				{  				Vector2 startl = nc.lineSegment.AtPosition(currentArcPosition - delta);  				Vector2 startr = nc.lineSegment.AtPosition(currentArcPosition + delta);    				Vector2 leftVector = nc.lineSegment.DerivateAtTime(nc.lineSegment.PosToTime(currentArcPosition - delta)).RotatedClockwise.Normalized;  				Vector2 rightVector = nc.lineSegment.DerivateAtTime(nc.lineSegment.PosToTime(currentArcPosition + delta)).RotatedCounterClockwise.Normalized;    				// Faule Implementierung:	statt Schnittpunkt Gerade/Bezierkurve zu berechnen nutzen wir vorhandenen  				//							Code und Berechnen den Schnittpunkt zwischen zwei Bezierkurven.  				// TODO:	Sollte das hier zu langsam sein' muss eben neuer optimierter Code her für die Berechnung  				//			von Schnittpunkten Gerade/Bezierkurve  				LineSegment leftLS = new LineSegment(0' startl' startl + 0.25 * maxDistanceToOtherNodeConnection * leftVector' startl + 0.75 * maxDistanceToOtherNodeConnection * leftVector' startl + maxDistanceToOtherNodeConnection * leftVector);  				LineSegment rightLS = new LineSegment(0' startr' startr + 0.25 * maxDistanceToOtherNodeConnection * rightVector' startr + 0.75 * maxDistanceToOtherNodeConnection * rightVector' startr + maxDistanceToOtherNodeConnection * rightVector);    				foreach (NodeConnection nc2 in _connections)  					{  					if (nc2.enableIncomingLineChange && (nc2.carsAllowed || nc2.busAllowed) && nc != nc2 && nc.startNode.networkLayer == nc2.startNode.networkLayer && nc.endNode.networkLayer == nc2.endNode.networkLayer)  						{  						// LINKS: Zeitparameterpaare ermitteln   						List<Pair<double>> intersectionTimes = CalculateIntersections(leftLS' nc2.lineSegment' 0d' 1d' 0d' 1d' 8' leftLS' nc2.lineSegment);  						if (intersectionTimes != null)  							{  							// Startposition  							NodeConnection.SpecificPosition start = new NodeConnection.SpecificPosition(currentArcPosition - delta' nc);    							// LineChangePoints erstellen  							foreach (Pair<double> p in intersectionTimes)  								{  								// Winkel überprüfen  								if (Vector2.AngleBetween(nc.lineSegment.DerivateAtTime(nc.lineSegment.PosToTime(currentArcPosition - delta))' nc2.lineSegment.DerivateAtTime(p.Right)) < Constants.maximumAngleBetweenConnectionsForLineChangePoint)  									{  									NodeConnection.SpecificPosition otherStart = new NodeConnection.SpecificPosition(nc2' p.Right);    									// Einfädelpunkt des Fahrzeugs bestimmen und evtl. auf nächste NodeConnection weiterverfolgen:  									double distance = (nc.lineSegment.AtPosition(currentArcPosition - delta) - nc2.lineSegment.AtTime(p.Right)).Abs;    									// Einfädelpunkt:  									double arcPositionTarget = nc2.lineSegment.TimeToArcPosition(p.Right) + 3 * distance;    									if (arcPositionTarget <= nc2.lineSegment.length)  										{  										NodeConnection.SpecificPosition target = new NodeConnection.SpecificPosition(arcPositionTarget' nc2);  										nc.AddLineChangePoint(new NodeConnection.LineChangePoint(start' target' otherStart));  										}  									else  										{  										double diff = arcPositionTarget - nc2.lineSegment.length;  										foreach (NodeConnection nextNc in nc2.endNode.nextConnections)  											{  											if (   (diff <= nextNc.lineSegment.length)  												&& (nextNc.enableIncomingLineChange && (nextNc.carsAllowed || nextNc.busAllowed))  												&& (nc != nextNc))  												{  												NodeConnection.SpecificPosition target = new NodeConnection.SpecificPosition(diff' nextNc);  												nc.AddLineChangePoint(new NodeConnection.LineChangePoint(start' target' otherStart));  												}  											}  										}    									break;  									}  								}  							}    						// RECHTS: Zeitparameterpaare ermitteln  						intersectionTimes = CalculateIntersections(rightLS' nc2.lineSegment' 0d' 1d' 0d' 1d' 8' leftLS' nc2.lineSegment);  						if (intersectionTimes != null)  							{  							// Startposition  							NodeConnection.SpecificPosition start = new NodeConnection.SpecificPosition(currentArcPosition + delta' nc);    							// LineChangePoints erstellen  							foreach (Pair<double> p in intersectionTimes)  								{  								// Winkel überprüfen  								if (Vector2.AngleBetween(nc.lineSegment.DerivateAtTime(nc.lineSegment.PosToTime(currentArcPosition + delta))' nc2.lineSegment.DerivateAtTime(p.Right)) < Constants.maximumAngleBetweenConnectionsForLineChangePoint)  									{  									NodeConnection.SpecificPosition otherStart = new NodeConnection.SpecificPosition(nc2' p.Right);    									// Einfädelpunkt des Fahrzeugs bestimmen und evtl. auf nächste NodeConnection weiterverfolgen:  									double distance = (nc.lineSegment.AtPosition(currentArcPosition + delta) - nc2.lineSegment.AtTime(p.Right)).Abs;    									// Einfädelpunkt:  									double arcPositionTarget = nc2.lineSegment.TimeToArcPosition(p.Right) + 3 * distance;    									if (arcPositionTarget <= nc2.lineSegment.length)  										{  										NodeConnection.SpecificPosition target = new NodeConnection.SpecificPosition(arcPositionTarget' nc2);  										nc.AddLineChangePoint(new NodeConnection.LineChangePoint(start' target' otherStart));  										}  									else  										{  										double diff = arcPositionTarget - nc2.lineSegment.length;  										foreach (NodeConnection nextNc in nc2.endNode.nextConnections)  											{  											if ((diff <= nextNc.lineSegment.length)  												&& (nextNc.enableIncomingLineChange && (nextNc.carsAllowed || nextNc.busAllowed))  												&& (nc != nextNc))  												{  												NodeConnection.SpecificPosition target = new NodeConnection.SpecificPosition(diff' nextNc);  												nc.AddLineChangePoint(new NodeConnection.LineChangePoint(start' target' otherStart));  												}  											}  										}    									break;  									}  								}  							}  						}  					}    				currentArcPosition += distanceBetweenChangePoints;  				}
Magic Number,CityTrafficSimulator,NodeSteuerung,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\NodeSteuerung.cs,FindLineChangePoints,The following statement contains a magic number: while (currentArcPosition < nc.lineSegment.length - distanceBetweenChangePoints/2)  				{  				Vector2 startl = nc.lineSegment.AtPosition(currentArcPosition - delta);  				Vector2 startr = nc.lineSegment.AtPosition(currentArcPosition + delta);    				Vector2 leftVector = nc.lineSegment.DerivateAtTime(nc.lineSegment.PosToTime(currentArcPosition - delta)).RotatedClockwise.Normalized;  				Vector2 rightVector = nc.lineSegment.DerivateAtTime(nc.lineSegment.PosToTime(currentArcPosition + delta)).RotatedCounterClockwise.Normalized;    				// Faule Implementierung:	statt Schnittpunkt Gerade/Bezierkurve zu berechnen nutzen wir vorhandenen  				//							Code und Berechnen den Schnittpunkt zwischen zwei Bezierkurven.  				// TODO:	Sollte das hier zu langsam sein' muss eben neuer optimierter Code her für die Berechnung  				//			von Schnittpunkten Gerade/Bezierkurve  				LineSegment leftLS = new LineSegment(0' startl' startl + 0.25 * maxDistanceToOtherNodeConnection * leftVector' startl + 0.75 * maxDistanceToOtherNodeConnection * leftVector' startl + maxDistanceToOtherNodeConnection * leftVector);  				LineSegment rightLS = new LineSegment(0' startr' startr + 0.25 * maxDistanceToOtherNodeConnection * rightVector' startr + 0.75 * maxDistanceToOtherNodeConnection * rightVector' startr + maxDistanceToOtherNodeConnection * rightVector);    				foreach (NodeConnection nc2 in _connections)  					{  					if (nc2.enableIncomingLineChange && (nc2.carsAllowed || nc2.busAllowed) && nc != nc2 && nc.startNode.networkLayer == nc2.startNode.networkLayer && nc.endNode.networkLayer == nc2.endNode.networkLayer)  						{  						// LINKS: Zeitparameterpaare ermitteln   						List<Pair<double>> intersectionTimes = CalculateIntersections(leftLS' nc2.lineSegment' 0d' 1d' 0d' 1d' 8' leftLS' nc2.lineSegment);  						if (intersectionTimes != null)  							{  							// Startposition  							NodeConnection.SpecificPosition start = new NodeConnection.SpecificPosition(currentArcPosition - delta' nc);    							// LineChangePoints erstellen  							foreach (Pair<double> p in intersectionTimes)  								{  								// Winkel überprüfen  								if (Vector2.AngleBetween(nc.lineSegment.DerivateAtTime(nc.lineSegment.PosToTime(currentArcPosition - delta))' nc2.lineSegment.DerivateAtTime(p.Right)) < Constants.maximumAngleBetweenConnectionsForLineChangePoint)  									{  									NodeConnection.SpecificPosition otherStart = new NodeConnection.SpecificPosition(nc2' p.Right);    									// Einfädelpunkt des Fahrzeugs bestimmen und evtl. auf nächste NodeConnection weiterverfolgen:  									double distance = (nc.lineSegment.AtPosition(currentArcPosition - delta) - nc2.lineSegment.AtTime(p.Right)).Abs;    									// Einfädelpunkt:  									double arcPositionTarget = nc2.lineSegment.TimeToArcPosition(p.Right) + 3 * distance;    									if (arcPositionTarget <= nc2.lineSegment.length)  										{  										NodeConnection.SpecificPosition target = new NodeConnection.SpecificPosition(arcPositionTarget' nc2);  										nc.AddLineChangePoint(new NodeConnection.LineChangePoint(start' target' otherStart));  										}  									else  										{  										double diff = arcPositionTarget - nc2.lineSegment.length;  										foreach (NodeConnection nextNc in nc2.endNode.nextConnections)  											{  											if (   (diff <= nextNc.lineSegment.length)  												&& (nextNc.enableIncomingLineChange && (nextNc.carsAllowed || nextNc.busAllowed))  												&& (nc != nextNc))  												{  												NodeConnection.SpecificPosition target = new NodeConnection.SpecificPosition(diff' nextNc);  												nc.AddLineChangePoint(new NodeConnection.LineChangePoint(start' target' otherStart));  												}  											}  										}    									break;  									}  								}  							}    						// RECHTS: Zeitparameterpaare ermitteln  						intersectionTimes = CalculateIntersections(rightLS' nc2.lineSegment' 0d' 1d' 0d' 1d' 8' leftLS' nc2.lineSegment);  						if (intersectionTimes != null)  							{  							// Startposition  							NodeConnection.SpecificPosition start = new NodeConnection.SpecificPosition(currentArcPosition + delta' nc);    							// LineChangePoints erstellen  							foreach (Pair<double> p in intersectionTimes)  								{  								// Winkel überprüfen  								if (Vector2.AngleBetween(nc.lineSegment.DerivateAtTime(nc.lineSegment.PosToTime(currentArcPosition + delta))' nc2.lineSegment.DerivateAtTime(p.Right)) < Constants.maximumAngleBetweenConnectionsForLineChangePoint)  									{  									NodeConnection.SpecificPosition otherStart = new NodeConnection.SpecificPosition(nc2' p.Right);    									// Einfädelpunkt des Fahrzeugs bestimmen und evtl. auf nächste NodeConnection weiterverfolgen:  									double distance = (nc.lineSegment.AtPosition(currentArcPosition + delta) - nc2.lineSegment.AtTime(p.Right)).Abs;    									// Einfädelpunkt:  									double arcPositionTarget = nc2.lineSegment.TimeToArcPosition(p.Right) + 3 * distance;    									if (arcPositionTarget <= nc2.lineSegment.length)  										{  										NodeConnection.SpecificPosition target = new NodeConnection.SpecificPosition(arcPositionTarget' nc2);  										nc.AddLineChangePoint(new NodeConnection.LineChangePoint(start' target' otherStart));  										}  									else  										{  										double diff = arcPositionTarget - nc2.lineSegment.length;  										foreach (NodeConnection nextNc in nc2.endNode.nextConnections)  											{  											if ((diff <= nextNc.lineSegment.length)  												&& (nextNc.enableIncomingLineChange && (nextNc.carsAllowed || nextNc.busAllowed))  												&& (nc != nextNc))  												{  												NodeConnection.SpecificPosition target = new NodeConnection.SpecificPosition(diff' nextNc);  												nc.AddLineChangePoint(new NodeConnection.LineChangePoint(start' target' otherStart));  												}  											}  										}    									break;  									}  								}  							}  						}  					}    				currentArcPosition += distanceBetweenChangePoints;  				}
Magic Number,CityTrafficSimulator,NodeSteuerung,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\NodeSteuerung.cs,FindLineChangePoints,The following statement contains a magic number: while (currentArcPosition < nc.lineSegment.length - distanceBetweenChangePoints/2)  				{  				Vector2 startl = nc.lineSegment.AtPosition(currentArcPosition - delta);  				Vector2 startr = nc.lineSegment.AtPosition(currentArcPosition + delta);    				Vector2 leftVector = nc.lineSegment.DerivateAtTime(nc.lineSegment.PosToTime(currentArcPosition - delta)).RotatedClockwise.Normalized;  				Vector2 rightVector = nc.lineSegment.DerivateAtTime(nc.lineSegment.PosToTime(currentArcPosition + delta)).RotatedCounterClockwise.Normalized;    				// Faule Implementierung:	statt Schnittpunkt Gerade/Bezierkurve zu berechnen nutzen wir vorhandenen  				//							Code und Berechnen den Schnittpunkt zwischen zwei Bezierkurven.  				// TODO:	Sollte das hier zu langsam sein' muss eben neuer optimierter Code her für die Berechnung  				//			von Schnittpunkten Gerade/Bezierkurve  				LineSegment leftLS = new LineSegment(0' startl' startl + 0.25 * maxDistanceToOtherNodeConnection * leftVector' startl + 0.75 * maxDistanceToOtherNodeConnection * leftVector' startl + maxDistanceToOtherNodeConnection * leftVector);  				LineSegment rightLS = new LineSegment(0' startr' startr + 0.25 * maxDistanceToOtherNodeConnection * rightVector' startr + 0.75 * maxDistanceToOtherNodeConnection * rightVector' startr + maxDistanceToOtherNodeConnection * rightVector);    				foreach (NodeConnection nc2 in _connections)  					{  					if (nc2.enableIncomingLineChange && (nc2.carsAllowed || nc2.busAllowed) && nc != nc2 && nc.startNode.networkLayer == nc2.startNode.networkLayer && nc.endNode.networkLayer == nc2.endNode.networkLayer)  						{  						// LINKS: Zeitparameterpaare ermitteln   						List<Pair<double>> intersectionTimes = CalculateIntersections(leftLS' nc2.lineSegment' 0d' 1d' 0d' 1d' 8' leftLS' nc2.lineSegment);  						if (intersectionTimes != null)  							{  							// Startposition  							NodeConnection.SpecificPosition start = new NodeConnection.SpecificPosition(currentArcPosition - delta' nc);    							// LineChangePoints erstellen  							foreach (Pair<double> p in intersectionTimes)  								{  								// Winkel überprüfen  								if (Vector2.AngleBetween(nc.lineSegment.DerivateAtTime(nc.lineSegment.PosToTime(currentArcPosition - delta))' nc2.lineSegment.DerivateAtTime(p.Right)) < Constants.maximumAngleBetweenConnectionsForLineChangePoint)  									{  									NodeConnection.SpecificPosition otherStart = new NodeConnection.SpecificPosition(nc2' p.Right);    									// Einfädelpunkt des Fahrzeugs bestimmen und evtl. auf nächste NodeConnection weiterverfolgen:  									double distance = (nc.lineSegment.AtPosition(currentArcPosition - delta) - nc2.lineSegment.AtTime(p.Right)).Abs;    									// Einfädelpunkt:  									double arcPositionTarget = nc2.lineSegment.TimeToArcPosition(p.Right) + 3 * distance;    									if (arcPositionTarget <= nc2.lineSegment.length)  										{  										NodeConnection.SpecificPosition target = new NodeConnection.SpecificPosition(arcPositionTarget' nc2);  										nc.AddLineChangePoint(new NodeConnection.LineChangePoint(start' target' otherStart));  										}  									else  										{  										double diff = arcPositionTarget - nc2.lineSegment.length;  										foreach (NodeConnection nextNc in nc2.endNode.nextConnections)  											{  											if (   (diff <= nextNc.lineSegment.length)  												&& (nextNc.enableIncomingLineChange && (nextNc.carsAllowed || nextNc.busAllowed))  												&& (nc != nextNc))  												{  												NodeConnection.SpecificPosition target = new NodeConnection.SpecificPosition(diff' nextNc);  												nc.AddLineChangePoint(new NodeConnection.LineChangePoint(start' target' otherStart));  												}  											}  										}    									break;  									}  								}  							}    						// RECHTS: Zeitparameterpaare ermitteln  						intersectionTimes = CalculateIntersections(rightLS' nc2.lineSegment' 0d' 1d' 0d' 1d' 8' leftLS' nc2.lineSegment);  						if (intersectionTimes != null)  							{  							// Startposition  							NodeConnection.SpecificPosition start = new NodeConnection.SpecificPosition(currentArcPosition + delta' nc);    							// LineChangePoints erstellen  							foreach (Pair<double> p in intersectionTimes)  								{  								// Winkel überprüfen  								if (Vector2.AngleBetween(nc.lineSegment.DerivateAtTime(nc.lineSegment.PosToTime(currentArcPosition + delta))' nc2.lineSegment.DerivateAtTime(p.Right)) < Constants.maximumAngleBetweenConnectionsForLineChangePoint)  									{  									NodeConnection.SpecificPosition otherStart = new NodeConnection.SpecificPosition(nc2' p.Right);    									// Einfädelpunkt des Fahrzeugs bestimmen und evtl. auf nächste NodeConnection weiterverfolgen:  									double distance = (nc.lineSegment.AtPosition(currentArcPosition + delta) - nc2.lineSegment.AtTime(p.Right)).Abs;    									// Einfädelpunkt:  									double arcPositionTarget = nc2.lineSegment.TimeToArcPosition(p.Right) + 3 * distance;    									if (arcPositionTarget <= nc2.lineSegment.length)  										{  										NodeConnection.SpecificPosition target = new NodeConnection.SpecificPosition(arcPositionTarget' nc2);  										nc.AddLineChangePoint(new NodeConnection.LineChangePoint(start' target' otherStart));  										}  									else  										{  										double diff = arcPositionTarget - nc2.lineSegment.length;  										foreach (NodeConnection nextNc in nc2.endNode.nextConnections)  											{  											if ((diff <= nextNc.lineSegment.length)  												&& (nextNc.enableIncomingLineChange && (nextNc.carsAllowed || nextNc.busAllowed))  												&& (nc != nextNc))  												{  												NodeConnection.SpecificPosition target = new NodeConnection.SpecificPosition(diff' nextNc);  												nc.AddLineChangePoint(new NodeConnection.LineChangePoint(start' target' otherStart));  												}  											}  										}    									break;  									}  								}  							}  						}  					}    				currentArcPosition += distanceBetweenChangePoints;  				}
Magic Number,CityTrafficSimulator,NodeSteuerung,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\NodeSteuerung.cs,FindLineChangePoints,The following statement contains a magic number: while (currentArcPosition < nc.lineSegment.length - distanceBetweenChangePoints/2)  				{  				Vector2 startl = nc.lineSegment.AtPosition(currentArcPosition - delta);  				Vector2 startr = nc.lineSegment.AtPosition(currentArcPosition + delta);    				Vector2 leftVector = nc.lineSegment.DerivateAtTime(nc.lineSegment.PosToTime(currentArcPosition - delta)).RotatedClockwise.Normalized;  				Vector2 rightVector = nc.lineSegment.DerivateAtTime(nc.lineSegment.PosToTime(currentArcPosition + delta)).RotatedCounterClockwise.Normalized;    				// Faule Implementierung:	statt Schnittpunkt Gerade/Bezierkurve zu berechnen nutzen wir vorhandenen  				//							Code und Berechnen den Schnittpunkt zwischen zwei Bezierkurven.  				// TODO:	Sollte das hier zu langsam sein' muss eben neuer optimierter Code her für die Berechnung  				//			von Schnittpunkten Gerade/Bezierkurve  				LineSegment leftLS = new LineSegment(0' startl' startl + 0.25 * maxDistanceToOtherNodeConnection * leftVector' startl + 0.75 * maxDistanceToOtherNodeConnection * leftVector' startl + maxDistanceToOtherNodeConnection * leftVector);  				LineSegment rightLS = new LineSegment(0' startr' startr + 0.25 * maxDistanceToOtherNodeConnection * rightVector' startr + 0.75 * maxDistanceToOtherNodeConnection * rightVector' startr + maxDistanceToOtherNodeConnection * rightVector);    				foreach (NodeConnection nc2 in _connections)  					{  					if (nc2.enableIncomingLineChange && (nc2.carsAllowed || nc2.busAllowed) && nc != nc2 && nc.startNode.networkLayer == nc2.startNode.networkLayer && nc.endNode.networkLayer == nc2.endNode.networkLayer)  						{  						// LINKS: Zeitparameterpaare ermitteln   						List<Pair<double>> intersectionTimes = CalculateIntersections(leftLS' nc2.lineSegment' 0d' 1d' 0d' 1d' 8' leftLS' nc2.lineSegment);  						if (intersectionTimes != null)  							{  							// Startposition  							NodeConnection.SpecificPosition start = new NodeConnection.SpecificPosition(currentArcPosition - delta' nc);    							// LineChangePoints erstellen  							foreach (Pair<double> p in intersectionTimes)  								{  								// Winkel überprüfen  								if (Vector2.AngleBetween(nc.lineSegment.DerivateAtTime(nc.lineSegment.PosToTime(currentArcPosition - delta))' nc2.lineSegment.DerivateAtTime(p.Right)) < Constants.maximumAngleBetweenConnectionsForLineChangePoint)  									{  									NodeConnection.SpecificPosition otherStart = new NodeConnection.SpecificPosition(nc2' p.Right);    									// Einfädelpunkt des Fahrzeugs bestimmen und evtl. auf nächste NodeConnection weiterverfolgen:  									double distance = (nc.lineSegment.AtPosition(currentArcPosition - delta) - nc2.lineSegment.AtTime(p.Right)).Abs;    									// Einfädelpunkt:  									double arcPositionTarget = nc2.lineSegment.TimeToArcPosition(p.Right) + 3 * distance;    									if (arcPositionTarget <= nc2.lineSegment.length)  										{  										NodeConnection.SpecificPosition target = new NodeConnection.SpecificPosition(arcPositionTarget' nc2);  										nc.AddLineChangePoint(new NodeConnection.LineChangePoint(start' target' otherStart));  										}  									else  										{  										double diff = arcPositionTarget - nc2.lineSegment.length;  										foreach (NodeConnection nextNc in nc2.endNode.nextConnections)  											{  											if (   (diff <= nextNc.lineSegment.length)  												&& (nextNc.enableIncomingLineChange && (nextNc.carsAllowed || nextNc.busAllowed))  												&& (nc != nextNc))  												{  												NodeConnection.SpecificPosition target = new NodeConnection.SpecificPosition(diff' nextNc);  												nc.AddLineChangePoint(new NodeConnection.LineChangePoint(start' target' otherStart));  												}  											}  										}    									break;  									}  								}  							}    						// RECHTS: Zeitparameterpaare ermitteln  						intersectionTimes = CalculateIntersections(rightLS' nc2.lineSegment' 0d' 1d' 0d' 1d' 8' leftLS' nc2.lineSegment);  						if (intersectionTimes != null)  							{  							// Startposition  							NodeConnection.SpecificPosition start = new NodeConnection.SpecificPosition(currentArcPosition + delta' nc);    							// LineChangePoints erstellen  							foreach (Pair<double> p in intersectionTimes)  								{  								// Winkel überprüfen  								if (Vector2.AngleBetween(nc.lineSegment.DerivateAtTime(nc.lineSegment.PosToTime(currentArcPosition + delta))' nc2.lineSegment.DerivateAtTime(p.Right)) < Constants.maximumAngleBetweenConnectionsForLineChangePoint)  									{  									NodeConnection.SpecificPosition otherStart = new NodeConnection.SpecificPosition(nc2' p.Right);    									// Einfädelpunkt des Fahrzeugs bestimmen und evtl. auf nächste NodeConnection weiterverfolgen:  									double distance = (nc.lineSegment.AtPosition(currentArcPosition + delta) - nc2.lineSegment.AtTime(p.Right)).Abs;    									// Einfädelpunkt:  									double arcPositionTarget = nc2.lineSegment.TimeToArcPosition(p.Right) + 3 * distance;    									if (arcPositionTarget <= nc2.lineSegment.length)  										{  										NodeConnection.SpecificPosition target = new NodeConnection.SpecificPosition(arcPositionTarget' nc2);  										nc.AddLineChangePoint(new NodeConnection.LineChangePoint(start' target' otherStart));  										}  									else  										{  										double diff = arcPositionTarget - nc2.lineSegment.length;  										foreach (NodeConnection nextNc in nc2.endNode.nextConnections)  											{  											if ((diff <= nextNc.lineSegment.length)  												&& (nextNc.enableIncomingLineChange && (nextNc.carsAllowed || nextNc.busAllowed))  												&& (nc != nextNc))  												{  												NodeConnection.SpecificPosition target = new NodeConnection.SpecificPosition(diff' nextNc);  												nc.AddLineChangePoint(new NodeConnection.LineChangePoint(start' target' otherStart));  												}  											}  										}    									break;  									}  								}  							}  						}  					}    				currentArcPosition += distanceBetweenChangePoints;  				}
Magic Number,CityTrafficSimulator,NodeSteuerung,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\NodeSteuerung.cs,FindLineChangePoints,The following statement contains a magic number: while (currentArcPosition < nc.lineSegment.length - distanceBetweenChangePoints/2)  				{  				Vector2 startl = nc.lineSegment.AtPosition(currentArcPosition - delta);  				Vector2 startr = nc.lineSegment.AtPosition(currentArcPosition + delta);    				Vector2 leftVector = nc.lineSegment.DerivateAtTime(nc.lineSegment.PosToTime(currentArcPosition - delta)).RotatedClockwise.Normalized;  				Vector2 rightVector = nc.lineSegment.DerivateAtTime(nc.lineSegment.PosToTime(currentArcPosition + delta)).RotatedCounterClockwise.Normalized;    				// Faule Implementierung:	statt Schnittpunkt Gerade/Bezierkurve zu berechnen nutzen wir vorhandenen  				//							Code und Berechnen den Schnittpunkt zwischen zwei Bezierkurven.  				// TODO:	Sollte das hier zu langsam sein' muss eben neuer optimierter Code her für die Berechnung  				//			von Schnittpunkten Gerade/Bezierkurve  				LineSegment leftLS = new LineSegment(0' startl' startl + 0.25 * maxDistanceToOtherNodeConnection * leftVector' startl + 0.75 * maxDistanceToOtherNodeConnection * leftVector' startl + maxDistanceToOtherNodeConnection * leftVector);  				LineSegment rightLS = new LineSegment(0' startr' startr + 0.25 * maxDistanceToOtherNodeConnection * rightVector' startr + 0.75 * maxDistanceToOtherNodeConnection * rightVector' startr + maxDistanceToOtherNodeConnection * rightVector);    				foreach (NodeConnection nc2 in _connections)  					{  					if (nc2.enableIncomingLineChange && (nc2.carsAllowed || nc2.busAllowed) && nc != nc2 && nc.startNode.networkLayer == nc2.startNode.networkLayer && nc.endNode.networkLayer == nc2.endNode.networkLayer)  						{  						// LINKS: Zeitparameterpaare ermitteln   						List<Pair<double>> intersectionTimes = CalculateIntersections(leftLS' nc2.lineSegment' 0d' 1d' 0d' 1d' 8' leftLS' nc2.lineSegment);  						if (intersectionTimes != null)  							{  							// Startposition  							NodeConnection.SpecificPosition start = new NodeConnection.SpecificPosition(currentArcPosition - delta' nc);    							// LineChangePoints erstellen  							foreach (Pair<double> p in intersectionTimes)  								{  								// Winkel überprüfen  								if (Vector2.AngleBetween(nc.lineSegment.DerivateAtTime(nc.lineSegment.PosToTime(currentArcPosition - delta))' nc2.lineSegment.DerivateAtTime(p.Right)) < Constants.maximumAngleBetweenConnectionsForLineChangePoint)  									{  									NodeConnection.SpecificPosition otherStart = new NodeConnection.SpecificPosition(nc2' p.Right);    									// Einfädelpunkt des Fahrzeugs bestimmen und evtl. auf nächste NodeConnection weiterverfolgen:  									double distance = (nc.lineSegment.AtPosition(currentArcPosition - delta) - nc2.lineSegment.AtTime(p.Right)).Abs;    									// Einfädelpunkt:  									double arcPositionTarget = nc2.lineSegment.TimeToArcPosition(p.Right) + 3 * distance;    									if (arcPositionTarget <= nc2.lineSegment.length)  										{  										NodeConnection.SpecificPosition target = new NodeConnection.SpecificPosition(arcPositionTarget' nc2);  										nc.AddLineChangePoint(new NodeConnection.LineChangePoint(start' target' otherStart));  										}  									else  										{  										double diff = arcPositionTarget - nc2.lineSegment.length;  										foreach (NodeConnection nextNc in nc2.endNode.nextConnections)  											{  											if (   (diff <= nextNc.lineSegment.length)  												&& (nextNc.enableIncomingLineChange && (nextNc.carsAllowed || nextNc.busAllowed))  												&& (nc != nextNc))  												{  												NodeConnection.SpecificPosition target = new NodeConnection.SpecificPosition(diff' nextNc);  												nc.AddLineChangePoint(new NodeConnection.LineChangePoint(start' target' otherStart));  												}  											}  										}    									break;  									}  								}  							}    						// RECHTS: Zeitparameterpaare ermitteln  						intersectionTimes = CalculateIntersections(rightLS' nc2.lineSegment' 0d' 1d' 0d' 1d' 8' leftLS' nc2.lineSegment);  						if (intersectionTimes != null)  							{  							// Startposition  							NodeConnection.SpecificPosition start = new NodeConnection.SpecificPosition(currentArcPosition + delta' nc);    							// LineChangePoints erstellen  							foreach (Pair<double> p in intersectionTimes)  								{  								// Winkel überprüfen  								if (Vector2.AngleBetween(nc.lineSegment.DerivateAtTime(nc.lineSegment.PosToTime(currentArcPosition + delta))' nc2.lineSegment.DerivateAtTime(p.Right)) < Constants.maximumAngleBetweenConnectionsForLineChangePoint)  									{  									NodeConnection.SpecificPosition otherStart = new NodeConnection.SpecificPosition(nc2' p.Right);    									// Einfädelpunkt des Fahrzeugs bestimmen und evtl. auf nächste NodeConnection weiterverfolgen:  									double distance = (nc.lineSegment.AtPosition(currentArcPosition + delta) - nc2.lineSegment.AtTime(p.Right)).Abs;    									// Einfädelpunkt:  									double arcPositionTarget = nc2.lineSegment.TimeToArcPosition(p.Right) + 3 * distance;    									if (arcPositionTarget <= nc2.lineSegment.length)  										{  										NodeConnection.SpecificPosition target = new NodeConnection.SpecificPosition(arcPositionTarget' nc2);  										nc.AddLineChangePoint(new NodeConnection.LineChangePoint(start' target' otherStart));  										}  									else  										{  										double diff = arcPositionTarget - nc2.lineSegment.length;  										foreach (NodeConnection nextNc in nc2.endNode.nextConnections)  											{  											if ((diff <= nextNc.lineSegment.length)  												&& (nextNc.enableIncomingLineChange && (nextNc.carsAllowed || nextNc.busAllowed))  												&& (nc != nextNc))  												{  												NodeConnection.SpecificPosition target = new NodeConnection.SpecificPosition(diff' nextNc);  												nc.AddLineChangePoint(new NodeConnection.LineChangePoint(start' target' otherStart));  												}  											}  										}    									break;  									}  								}  							}  						}  					}    				currentArcPosition += distanceBetweenChangePoints;  				}
Magic Number,CityTrafficSimulator,NodeSteuerung,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\NodeSteuerung.cs,FindLineChangePoints,The following statement contains a magic number: while (currentArcPosition < nc.lineSegment.length - distanceBetweenChangePoints/2)  				{  				Vector2 startl = nc.lineSegment.AtPosition(currentArcPosition - delta);  				Vector2 startr = nc.lineSegment.AtPosition(currentArcPosition + delta);    				Vector2 leftVector = nc.lineSegment.DerivateAtTime(nc.lineSegment.PosToTime(currentArcPosition - delta)).RotatedClockwise.Normalized;  				Vector2 rightVector = nc.lineSegment.DerivateAtTime(nc.lineSegment.PosToTime(currentArcPosition + delta)).RotatedCounterClockwise.Normalized;    				// Faule Implementierung:	statt Schnittpunkt Gerade/Bezierkurve zu berechnen nutzen wir vorhandenen  				//							Code und Berechnen den Schnittpunkt zwischen zwei Bezierkurven.  				// TODO:	Sollte das hier zu langsam sein' muss eben neuer optimierter Code her für die Berechnung  				//			von Schnittpunkten Gerade/Bezierkurve  				LineSegment leftLS = new LineSegment(0' startl' startl + 0.25 * maxDistanceToOtherNodeConnection * leftVector' startl + 0.75 * maxDistanceToOtherNodeConnection * leftVector' startl + maxDistanceToOtherNodeConnection * leftVector);  				LineSegment rightLS = new LineSegment(0' startr' startr + 0.25 * maxDistanceToOtherNodeConnection * rightVector' startr + 0.75 * maxDistanceToOtherNodeConnection * rightVector' startr + maxDistanceToOtherNodeConnection * rightVector);    				foreach (NodeConnection nc2 in _connections)  					{  					if (nc2.enableIncomingLineChange && (nc2.carsAllowed || nc2.busAllowed) && nc != nc2 && nc.startNode.networkLayer == nc2.startNode.networkLayer && nc.endNode.networkLayer == nc2.endNode.networkLayer)  						{  						// LINKS: Zeitparameterpaare ermitteln   						List<Pair<double>> intersectionTimes = CalculateIntersections(leftLS' nc2.lineSegment' 0d' 1d' 0d' 1d' 8' leftLS' nc2.lineSegment);  						if (intersectionTimes != null)  							{  							// Startposition  							NodeConnection.SpecificPosition start = new NodeConnection.SpecificPosition(currentArcPosition - delta' nc);    							// LineChangePoints erstellen  							foreach (Pair<double> p in intersectionTimes)  								{  								// Winkel überprüfen  								if (Vector2.AngleBetween(nc.lineSegment.DerivateAtTime(nc.lineSegment.PosToTime(currentArcPosition - delta))' nc2.lineSegment.DerivateAtTime(p.Right)) < Constants.maximumAngleBetweenConnectionsForLineChangePoint)  									{  									NodeConnection.SpecificPosition otherStart = new NodeConnection.SpecificPosition(nc2' p.Right);    									// Einfädelpunkt des Fahrzeugs bestimmen und evtl. auf nächste NodeConnection weiterverfolgen:  									double distance = (nc.lineSegment.AtPosition(currentArcPosition - delta) - nc2.lineSegment.AtTime(p.Right)).Abs;    									// Einfädelpunkt:  									double arcPositionTarget = nc2.lineSegment.TimeToArcPosition(p.Right) + 3 * distance;    									if (arcPositionTarget <= nc2.lineSegment.length)  										{  										NodeConnection.SpecificPosition target = new NodeConnection.SpecificPosition(arcPositionTarget' nc2);  										nc.AddLineChangePoint(new NodeConnection.LineChangePoint(start' target' otherStart));  										}  									else  										{  										double diff = arcPositionTarget - nc2.lineSegment.length;  										foreach (NodeConnection nextNc in nc2.endNode.nextConnections)  											{  											if (   (diff <= nextNc.lineSegment.length)  												&& (nextNc.enableIncomingLineChange && (nextNc.carsAllowed || nextNc.busAllowed))  												&& (nc != nextNc))  												{  												NodeConnection.SpecificPosition target = new NodeConnection.SpecificPosition(diff' nextNc);  												nc.AddLineChangePoint(new NodeConnection.LineChangePoint(start' target' otherStart));  												}  											}  										}    									break;  									}  								}  							}    						// RECHTS: Zeitparameterpaare ermitteln  						intersectionTimes = CalculateIntersections(rightLS' nc2.lineSegment' 0d' 1d' 0d' 1d' 8' leftLS' nc2.lineSegment);  						if (intersectionTimes != null)  							{  							// Startposition  							NodeConnection.SpecificPosition start = new NodeConnection.SpecificPosition(currentArcPosition + delta' nc);    							// LineChangePoints erstellen  							foreach (Pair<double> p in intersectionTimes)  								{  								// Winkel überprüfen  								if (Vector2.AngleBetween(nc.lineSegment.DerivateAtTime(nc.lineSegment.PosToTime(currentArcPosition + delta))' nc2.lineSegment.DerivateAtTime(p.Right)) < Constants.maximumAngleBetweenConnectionsForLineChangePoint)  									{  									NodeConnection.SpecificPosition otherStart = new NodeConnection.SpecificPosition(nc2' p.Right);    									// Einfädelpunkt des Fahrzeugs bestimmen und evtl. auf nächste NodeConnection weiterverfolgen:  									double distance = (nc.lineSegment.AtPosition(currentArcPosition + delta) - nc2.lineSegment.AtTime(p.Right)).Abs;    									// Einfädelpunkt:  									double arcPositionTarget = nc2.lineSegment.TimeToArcPosition(p.Right) + 3 * distance;    									if (arcPositionTarget <= nc2.lineSegment.length)  										{  										NodeConnection.SpecificPosition target = new NodeConnection.SpecificPosition(arcPositionTarget' nc2);  										nc.AddLineChangePoint(new NodeConnection.LineChangePoint(start' target' otherStart));  										}  									else  										{  										double diff = arcPositionTarget - nc2.lineSegment.length;  										foreach (NodeConnection nextNc in nc2.endNode.nextConnections)  											{  											if ((diff <= nextNc.lineSegment.length)  												&& (nextNc.enableIncomingLineChange && (nextNc.carsAllowed || nextNc.busAllowed))  												&& (nc != nextNc))  												{  												NodeConnection.SpecificPosition target = new NodeConnection.SpecificPosition(diff' nextNc);  												nc.AddLineChangePoint(new NodeConnection.LineChangePoint(start' target' otherStart));  												}  											}  										}    									break;  									}  								}  							}  						}  					}    				currentArcPosition += distanceBetweenChangePoints;  				}
Magic Number,CityTrafficSimulator,NodeSteuerung,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\NodeSteuerung.cs,FindLineChangePoints,The following statement contains a magic number: while (currentArcPosition < nc.lineSegment.length - distanceBetweenChangePoints/2)  				{  				Vector2 startl = nc.lineSegment.AtPosition(currentArcPosition - delta);  				Vector2 startr = nc.lineSegment.AtPosition(currentArcPosition + delta);    				Vector2 leftVector = nc.lineSegment.DerivateAtTime(nc.lineSegment.PosToTime(currentArcPosition - delta)).RotatedClockwise.Normalized;  				Vector2 rightVector = nc.lineSegment.DerivateAtTime(nc.lineSegment.PosToTime(currentArcPosition + delta)).RotatedCounterClockwise.Normalized;    				// Faule Implementierung:	statt Schnittpunkt Gerade/Bezierkurve zu berechnen nutzen wir vorhandenen  				//							Code und Berechnen den Schnittpunkt zwischen zwei Bezierkurven.  				// TODO:	Sollte das hier zu langsam sein' muss eben neuer optimierter Code her für die Berechnung  				//			von Schnittpunkten Gerade/Bezierkurve  				LineSegment leftLS = new LineSegment(0' startl' startl + 0.25 * maxDistanceToOtherNodeConnection * leftVector' startl + 0.75 * maxDistanceToOtherNodeConnection * leftVector' startl + maxDistanceToOtherNodeConnection * leftVector);  				LineSegment rightLS = new LineSegment(0' startr' startr + 0.25 * maxDistanceToOtherNodeConnection * rightVector' startr + 0.75 * maxDistanceToOtherNodeConnection * rightVector' startr + maxDistanceToOtherNodeConnection * rightVector);    				foreach (NodeConnection nc2 in _connections)  					{  					if (nc2.enableIncomingLineChange && (nc2.carsAllowed || nc2.busAllowed) && nc != nc2 && nc.startNode.networkLayer == nc2.startNode.networkLayer && nc.endNode.networkLayer == nc2.endNode.networkLayer)  						{  						// LINKS: Zeitparameterpaare ermitteln   						List<Pair<double>> intersectionTimes = CalculateIntersections(leftLS' nc2.lineSegment' 0d' 1d' 0d' 1d' 8' leftLS' nc2.lineSegment);  						if (intersectionTimes != null)  							{  							// Startposition  							NodeConnection.SpecificPosition start = new NodeConnection.SpecificPosition(currentArcPosition - delta' nc);    							// LineChangePoints erstellen  							foreach (Pair<double> p in intersectionTimes)  								{  								// Winkel überprüfen  								if (Vector2.AngleBetween(nc.lineSegment.DerivateAtTime(nc.lineSegment.PosToTime(currentArcPosition - delta))' nc2.lineSegment.DerivateAtTime(p.Right)) < Constants.maximumAngleBetweenConnectionsForLineChangePoint)  									{  									NodeConnection.SpecificPosition otherStart = new NodeConnection.SpecificPosition(nc2' p.Right);    									// Einfädelpunkt des Fahrzeugs bestimmen und evtl. auf nächste NodeConnection weiterverfolgen:  									double distance = (nc.lineSegment.AtPosition(currentArcPosition - delta) - nc2.lineSegment.AtTime(p.Right)).Abs;    									// Einfädelpunkt:  									double arcPositionTarget = nc2.lineSegment.TimeToArcPosition(p.Right) + 3 * distance;    									if (arcPositionTarget <= nc2.lineSegment.length)  										{  										NodeConnection.SpecificPosition target = new NodeConnection.SpecificPosition(arcPositionTarget' nc2);  										nc.AddLineChangePoint(new NodeConnection.LineChangePoint(start' target' otherStart));  										}  									else  										{  										double diff = arcPositionTarget - nc2.lineSegment.length;  										foreach (NodeConnection nextNc in nc2.endNode.nextConnections)  											{  											if (   (diff <= nextNc.lineSegment.length)  												&& (nextNc.enableIncomingLineChange && (nextNc.carsAllowed || nextNc.busAllowed))  												&& (nc != nextNc))  												{  												NodeConnection.SpecificPosition target = new NodeConnection.SpecificPosition(diff' nextNc);  												nc.AddLineChangePoint(new NodeConnection.LineChangePoint(start' target' otherStart));  												}  											}  										}    									break;  									}  								}  							}    						// RECHTS: Zeitparameterpaare ermitteln  						intersectionTimes = CalculateIntersections(rightLS' nc2.lineSegment' 0d' 1d' 0d' 1d' 8' leftLS' nc2.lineSegment);  						if (intersectionTimes != null)  							{  							// Startposition  							NodeConnection.SpecificPosition start = new NodeConnection.SpecificPosition(currentArcPosition + delta' nc);    							// LineChangePoints erstellen  							foreach (Pair<double> p in intersectionTimes)  								{  								// Winkel überprüfen  								if (Vector2.AngleBetween(nc.lineSegment.DerivateAtTime(nc.lineSegment.PosToTime(currentArcPosition + delta))' nc2.lineSegment.DerivateAtTime(p.Right)) < Constants.maximumAngleBetweenConnectionsForLineChangePoint)  									{  									NodeConnection.SpecificPosition otherStart = new NodeConnection.SpecificPosition(nc2' p.Right);    									// Einfädelpunkt des Fahrzeugs bestimmen und evtl. auf nächste NodeConnection weiterverfolgen:  									double distance = (nc.lineSegment.AtPosition(currentArcPosition + delta) - nc2.lineSegment.AtTime(p.Right)).Abs;    									// Einfädelpunkt:  									double arcPositionTarget = nc2.lineSegment.TimeToArcPosition(p.Right) + 3 * distance;    									if (arcPositionTarget <= nc2.lineSegment.length)  										{  										NodeConnection.SpecificPosition target = new NodeConnection.SpecificPosition(arcPositionTarget' nc2);  										nc.AddLineChangePoint(new NodeConnection.LineChangePoint(start' target' otherStart));  										}  									else  										{  										double diff = arcPositionTarget - nc2.lineSegment.length;  										foreach (NodeConnection nextNc in nc2.endNode.nextConnections)  											{  											if ((diff <= nextNc.lineSegment.length)  												&& (nextNc.enableIncomingLineChange && (nextNc.carsAllowed || nextNc.busAllowed))  												&& (nc != nextNc))  												{  												NodeConnection.SpecificPosition target = new NodeConnection.SpecificPosition(diff' nextNc);  												nc.AddLineChangePoint(new NodeConnection.LineChangePoint(start' target' otherStart));  												}  											}  										}    									break;  									}  								}  							}  						}  					}    				currentArcPosition += distanceBetweenChangePoints;  				}
Magic Number,CityTrafficSimulator,NodeSteuerung,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\NodeSteuerung.cs,FindLineChangePoints,The following statement contains a magic number: while (currentArcPosition < nc.lineSegment.length - distanceBetweenChangePoints/2)  				{  				Vector2 startl = nc.lineSegment.AtPosition(currentArcPosition - delta);  				Vector2 startr = nc.lineSegment.AtPosition(currentArcPosition + delta);    				Vector2 leftVector = nc.lineSegment.DerivateAtTime(nc.lineSegment.PosToTime(currentArcPosition - delta)).RotatedClockwise.Normalized;  				Vector2 rightVector = nc.lineSegment.DerivateAtTime(nc.lineSegment.PosToTime(currentArcPosition + delta)).RotatedCounterClockwise.Normalized;    				// Faule Implementierung:	statt Schnittpunkt Gerade/Bezierkurve zu berechnen nutzen wir vorhandenen  				//							Code und Berechnen den Schnittpunkt zwischen zwei Bezierkurven.  				// TODO:	Sollte das hier zu langsam sein' muss eben neuer optimierter Code her für die Berechnung  				//			von Schnittpunkten Gerade/Bezierkurve  				LineSegment leftLS = new LineSegment(0' startl' startl + 0.25 * maxDistanceToOtherNodeConnection * leftVector' startl + 0.75 * maxDistanceToOtherNodeConnection * leftVector' startl + maxDistanceToOtherNodeConnection * leftVector);  				LineSegment rightLS = new LineSegment(0' startr' startr + 0.25 * maxDistanceToOtherNodeConnection * rightVector' startr + 0.75 * maxDistanceToOtherNodeConnection * rightVector' startr + maxDistanceToOtherNodeConnection * rightVector);    				foreach (NodeConnection nc2 in _connections)  					{  					if (nc2.enableIncomingLineChange && (nc2.carsAllowed || nc2.busAllowed) && nc != nc2 && nc.startNode.networkLayer == nc2.startNode.networkLayer && nc.endNode.networkLayer == nc2.endNode.networkLayer)  						{  						// LINKS: Zeitparameterpaare ermitteln   						List<Pair<double>> intersectionTimes = CalculateIntersections(leftLS' nc2.lineSegment' 0d' 1d' 0d' 1d' 8' leftLS' nc2.lineSegment);  						if (intersectionTimes != null)  							{  							// Startposition  							NodeConnection.SpecificPosition start = new NodeConnection.SpecificPosition(currentArcPosition - delta' nc);    							// LineChangePoints erstellen  							foreach (Pair<double> p in intersectionTimes)  								{  								// Winkel überprüfen  								if (Vector2.AngleBetween(nc.lineSegment.DerivateAtTime(nc.lineSegment.PosToTime(currentArcPosition - delta))' nc2.lineSegment.DerivateAtTime(p.Right)) < Constants.maximumAngleBetweenConnectionsForLineChangePoint)  									{  									NodeConnection.SpecificPosition otherStart = new NodeConnection.SpecificPosition(nc2' p.Right);    									// Einfädelpunkt des Fahrzeugs bestimmen und evtl. auf nächste NodeConnection weiterverfolgen:  									double distance = (nc.lineSegment.AtPosition(currentArcPosition - delta) - nc2.lineSegment.AtTime(p.Right)).Abs;    									// Einfädelpunkt:  									double arcPositionTarget = nc2.lineSegment.TimeToArcPosition(p.Right) + 3 * distance;    									if (arcPositionTarget <= nc2.lineSegment.length)  										{  										NodeConnection.SpecificPosition target = new NodeConnection.SpecificPosition(arcPositionTarget' nc2);  										nc.AddLineChangePoint(new NodeConnection.LineChangePoint(start' target' otherStart));  										}  									else  										{  										double diff = arcPositionTarget - nc2.lineSegment.length;  										foreach (NodeConnection nextNc in nc2.endNode.nextConnections)  											{  											if (   (diff <= nextNc.lineSegment.length)  												&& (nextNc.enableIncomingLineChange && (nextNc.carsAllowed || nextNc.busAllowed))  												&& (nc != nextNc))  												{  												NodeConnection.SpecificPosition target = new NodeConnection.SpecificPosition(diff' nextNc);  												nc.AddLineChangePoint(new NodeConnection.LineChangePoint(start' target' otherStart));  												}  											}  										}    									break;  									}  								}  							}    						// RECHTS: Zeitparameterpaare ermitteln  						intersectionTimes = CalculateIntersections(rightLS' nc2.lineSegment' 0d' 1d' 0d' 1d' 8' leftLS' nc2.lineSegment);  						if (intersectionTimes != null)  							{  							// Startposition  							NodeConnection.SpecificPosition start = new NodeConnection.SpecificPosition(currentArcPosition + delta' nc);    							// LineChangePoints erstellen  							foreach (Pair<double> p in intersectionTimes)  								{  								// Winkel überprüfen  								if (Vector2.AngleBetween(nc.lineSegment.DerivateAtTime(nc.lineSegment.PosToTime(currentArcPosition + delta))' nc2.lineSegment.DerivateAtTime(p.Right)) < Constants.maximumAngleBetweenConnectionsForLineChangePoint)  									{  									NodeConnection.SpecificPosition otherStart = new NodeConnection.SpecificPosition(nc2' p.Right);    									// Einfädelpunkt des Fahrzeugs bestimmen und evtl. auf nächste NodeConnection weiterverfolgen:  									double distance = (nc.lineSegment.AtPosition(currentArcPosition + delta) - nc2.lineSegment.AtTime(p.Right)).Abs;    									// Einfädelpunkt:  									double arcPositionTarget = nc2.lineSegment.TimeToArcPosition(p.Right) + 3 * distance;    									if (arcPositionTarget <= nc2.lineSegment.length)  										{  										NodeConnection.SpecificPosition target = new NodeConnection.SpecificPosition(arcPositionTarget' nc2);  										nc.AddLineChangePoint(new NodeConnection.LineChangePoint(start' target' otherStart));  										}  									else  										{  										double diff = arcPositionTarget - nc2.lineSegment.length;  										foreach (NodeConnection nextNc in nc2.endNode.nextConnections)  											{  											if ((diff <= nextNc.lineSegment.length)  												&& (nextNc.enableIncomingLineChange && (nextNc.carsAllowed || nextNc.busAllowed))  												&& (nc != nextNc))  												{  												NodeConnection.SpecificPosition target = new NodeConnection.SpecificPosition(diff' nextNc);  												nc.AddLineChangePoint(new NodeConnection.LineChangePoint(start' target' otherStart));  												}  											}  										}    									break;  									}  								}  							}  						}  					}    				currentArcPosition += distanceBetweenChangePoints;  				}
Magic Number,CityTrafficSimulator,NodeSteuerung,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\NodeSteuerung.cs,GetVehicleAt,The following statement contains a magic number: foreach (NodeConnection nc in connections)  				{  				if (nc.lineSegment.Contains(position' 5' 15))  					{  					foreach (IVehicle v in nc.vehicles)  						{  						if (v.state.boundingRectangle.Contains(position))  							{  							return v;  							}  						}  					}  				}
Magic Number,CityTrafficSimulator,NodeSteuerung,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\NodeSteuerung.cs,GetVehicleAt,The following statement contains a magic number: foreach (NodeConnection nc in connections)  				{  				if (nc.lineSegment.Contains(position' 5' 15))  					{  					foreach (IVehicle v in nc.vehicles)  						{  						if (v.state.boundingRectangle.Contains(position))  							{  							return v;  							}  						}  					}  				}
Magic Number,CityTrafficSimulator,NodeSteuerung,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\NodeSteuerung.cs,RenderNetwork,The following statement contains a magic number: if (options.renderIntersections)  				{  				using (Pen redPen = new Pen(Color.Red' 1.0f))  					{  					using (Pen yellowPen = new Pen(Color.Orange' 1.0f))  						{  						using (Pen greenPen = new Pen(Color.Green' 1.0f))  							{  							foreach (Intersection i in intersections)  								{  								if (i._aConnection.startNode.isVisible || i._aConnection.endNode.isVisible || i._bConnection.startNode.isVisible || i._bConnection.endNode.isVisible)  									{  									PointF[] surroundingPoints = new PointF[4]  											{  												i._aConnection.lineSegment.AtPosition(i.aArcPosition - i._frontWaitingDistance)'  												i._bConnection.lineSegment.AtPosition(i.bArcPosition - i._frontWaitingDistance)'  												i._aConnection.lineSegment.AtPosition(i.aArcPosition + i._rearWaitingDistance)'  												i._bConnection.lineSegment.AtPosition(i.bArcPosition + i._rearWaitingDistance)  											};    									if (i.avoidBlocking)  										{  										g.DrawLine(redPen' i.aPosition' i.bPosition);  										g.DrawPolygon(redPen' surroundingPoints);  										}  									else if (i._aConnection.startNode != i._bConnection.startNode || (i._frontWaitingDistance < i.aArcPosition && i._frontWaitingDistance < i.bArcPosition))  										{  										g.DrawLine(yellowPen' i.aPosition' i.bPosition);  										g.DrawPolygon(yellowPen' surroundingPoints);  										}  									else  										{  										g.DrawLine(greenPen' i.aPosition' i.bPosition);  										g.DrawPolygon(greenPen' surroundingPoints);  										}  									}  								}  							}  						}  					}  				}
Magic Number,CityTrafficSimulator,NodeSteuerung,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\NodeSteuerung.cs,RenderNetwork,The following statement contains a magic number: if (options.renderVehicleDebugData)  				{  				foreach (NodeConnection nc in connections)  					{  					if (!options.performClipping || nc.lineSegment.boundingRectangle.IntersectsWith(options.clippingRect))  						{  						using (Pen greenPen = new Pen(Color.Green' 3))  							{  							foreach (IVehicle v in nc.vehicles)  								{  								v.DrawDebugData(g);  								if (v.state.vehicleThatLetsMeChangeLine != null)  									{  									g.DrawLine(greenPen' v.state.positionAbs' v.state.vehicleThatLetsMeChangeLine.state.positionAbs);  									}  								}  							}  						}  					}  				}
Magic Number,CityTrafficSimulator,NodeSteuerung,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\NodeSteuerung.cs,LoadFromFile,The following statement contains a magic number: lf.SetupLowerProgess("Parsing XML..."' 3);
Magic Number,CityTrafficSimulator,NodeSteuerung,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\NodeSteuerung.cs,LoadFromFile,The following statement contains a magic number: if (saveVersion >= 6)  				{  				foreach (NetworkLayer nl in _networkLayers)  					{  					foreach (int hash in nl._nodeHashes)  						{  						LineNode tmp = GetLineNodeByHash(nodes' hash);  						if (tmp != null)  							tmp.networkLayer = nl;  						}  					nl.TitleChanged += new NetworkLayer.TitleChangedEventHandler(nl_TitleChanged);  					nl.VisibleChanged +=new NetworkLayer.VisibleChangedEventHandler(nl_VisibleChanged);  					}  				}  			else  				{  				AddNetworkLayer("Layer 1"' true);  				foreach (LineNode ln in _nodes)  					{  					ln.networkLayer = _networkLayers[0];  					}  				}
Magic Number,CityTrafficSimulator,NodeSteuerung,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\NodeSteuerung.cs,LoadFromFile,The following statement contains a magic number: if (saveVersion < 5)  				{  				XmlNodeList xnlAuftrag = xd.SelectNodes("//CityTrafficSimulator/Traffic/Auftrag");    				lf.SetupLowerProgess("Load Old Traffic Volume..."' 2 * xnlAuftrag.Count);    				foreach (XmlNode aXmlNode in xnlAuftrag)  					{  					// Node in einen TextReader packen  					TextReader tr = new StringReader(aXmlNode.OuterXml);  					// und Deserializen  					XmlSerializer xs = new XmlSerializer(typeof(Auftrag));  					Auftrag ln = (Auftrag)xs.Deserialize(tr);    					// in alten Dateien wurde das Feld häufigkeit statt trafficDensity gespeichert. Da es dieses Feld heute nicht mehr gibt' müssen wir konvertieren:  					if (saveVersion < 1)  						{  						// eigentlich wollte ich hier direkt mit aXmlNode arbeiten' das hat jedoch komische Fehler verursacht (SelectSingleNode) wählt immer den gleichen aus)  						// daher der Umweg über das neue XmlDocument.  						XmlDocument doc = new XmlDocument();  						XmlElement elem = doc.CreateElement("Auftrag");  						elem.InnerXml = aXmlNode.InnerXml;  						doc.AppendChild(elem);    						XmlNode haeufigkeitNode = doc.SelectSingleNode("//Auftrag/häufigkeit");  						if (haeufigkeitNode != null)  							{  							ln.trafficDensity = 72000 / Int32.Parse(haeufigkeitNode.InnerXml);  							}  						haeufigkeitNode = null;  						}    					// ab in die Liste  					toReturn.Add(ln);    					lf.StepLowerProgress();  					}    				// Nodes wiederherstellen  				foreach (Auftrag a in toReturn)  					{  					a.RecoverFromLoad(saveVersion' nodes);    					lf.StepLowerProgress();  					}    				}
Magic Number,CityTrafficSimulator,NodeSteuerung,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\NodeSteuerung.cs,LoadFromFile,The following statement contains a magic number: if (saveVersion < 5)  				{  				XmlNodeList xnlAuftrag = xd.SelectNodes("//CityTrafficSimulator/Traffic/Auftrag");    				lf.SetupLowerProgess("Load Old Traffic Volume..."' 2 * xnlAuftrag.Count);    				foreach (XmlNode aXmlNode in xnlAuftrag)  					{  					// Node in einen TextReader packen  					TextReader tr = new StringReader(aXmlNode.OuterXml);  					// und Deserializen  					XmlSerializer xs = new XmlSerializer(typeof(Auftrag));  					Auftrag ln = (Auftrag)xs.Deserialize(tr);    					// in alten Dateien wurde das Feld häufigkeit statt trafficDensity gespeichert. Da es dieses Feld heute nicht mehr gibt' müssen wir konvertieren:  					if (saveVersion < 1)  						{  						// eigentlich wollte ich hier direkt mit aXmlNode arbeiten' das hat jedoch komische Fehler verursacht (SelectSingleNode) wählt immer den gleichen aus)  						// daher der Umweg über das neue XmlDocument.  						XmlDocument doc = new XmlDocument();  						XmlElement elem = doc.CreateElement("Auftrag");  						elem.InnerXml = aXmlNode.InnerXml;  						doc.AppendChild(elem);    						XmlNode haeufigkeitNode = doc.SelectSingleNode("//Auftrag/häufigkeit");  						if (haeufigkeitNode != null)  							{  							ln.trafficDensity = 72000 / Int32.Parse(haeufigkeitNode.InnerXml);  							}  						haeufigkeitNode = null;  						}    					// ab in die Liste  					toReturn.Add(ln);    					lf.StepLowerProgress();  					}    				// Nodes wiederherstellen  				foreach (Auftrag a in toReturn)  					{  					a.RecoverFromLoad(saveVersion' nodes);    					lf.StepLowerProgress();  					}    				}
Magic Number,CityTrafficSimulator,NodeSteuerung,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\NodeSteuerung.cs,LoadFromFile,The following statement contains a magic number: if (saveVersion < 5)  				{  				XmlNodeList xnlAuftrag = xd.SelectNodes("//CityTrafficSimulator/Traffic/Auftrag");    				lf.SetupLowerProgess("Load Old Traffic Volume..."' 2 * xnlAuftrag.Count);    				foreach (XmlNode aXmlNode in xnlAuftrag)  					{  					// Node in einen TextReader packen  					TextReader tr = new StringReader(aXmlNode.OuterXml);  					// und Deserializen  					XmlSerializer xs = new XmlSerializer(typeof(Auftrag));  					Auftrag ln = (Auftrag)xs.Deserialize(tr);    					// in alten Dateien wurde das Feld häufigkeit statt trafficDensity gespeichert. Da es dieses Feld heute nicht mehr gibt' müssen wir konvertieren:  					if (saveVersion < 1)  						{  						// eigentlich wollte ich hier direkt mit aXmlNode arbeiten' das hat jedoch komische Fehler verursacht (SelectSingleNode) wählt immer den gleichen aus)  						// daher der Umweg über das neue XmlDocument.  						XmlDocument doc = new XmlDocument();  						XmlElement elem = doc.CreateElement("Auftrag");  						elem.InnerXml = aXmlNode.InnerXml;  						doc.AppendChild(elem);    						XmlNode haeufigkeitNode = doc.SelectSingleNode("//Auftrag/häufigkeit");  						if (haeufigkeitNode != null)  							{  							ln.trafficDensity = 72000 / Int32.Parse(haeufigkeitNode.InnerXml);  							}  						haeufigkeitNode = null;  						}    					// ab in die Liste  					toReturn.Add(ln);    					lf.StepLowerProgress();  					}    				// Nodes wiederherstellen  				foreach (Auftrag a in toReturn)  					{  					a.RecoverFromLoad(saveVersion' nodes);    					lf.StepLowerProgress();  					}    				}
Magic Number,CityTrafficSimulator,TimelineControl,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TimelineControl.cs,TimelineControl,The following statement contains a magic number: if (DesignMode)  				{  				this.zoom = 5;    				}
Magic Number,CityTrafficSimulator,TimelineControl,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TimelineControl.cs,UpdateControlSize,The following statement contains a magic number: if (steuerung != null)  				{  				foreach (TimelineGroup tg in steuerung.groups)  					{  					currentVisibleRowCount++;  					if (!tg.collapsed)  						currentVisibleRowCount += tg.entries.Count;  					}  				this.ClientSize = new Size((int)Math.Round(m_zoom * steuerung.maxTime) + 5 + totalRowHeight' Math.Max(currentVisibleRowCount * totalRowHeight + 20' 50));  				}
Magic Number,CityTrafficSimulator,TimelineControl,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TimelineControl.cs,UpdateControlSize,The following statement contains a magic number: if (steuerung != null)  				{  				foreach (TimelineGroup tg in steuerung.groups)  					{  					currentVisibleRowCount++;  					if (!tg.collapsed)  						currentVisibleRowCount += tg.entries.Count;  					}  				this.ClientSize = new Size((int)Math.Round(m_zoom * steuerung.maxTime) + 5 + totalRowHeight' Math.Max(currentVisibleRowCount * totalRowHeight + 20' 50));  				}
Magic Number,CityTrafficSimulator,TimelineControl,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TimelineControl.cs,UpdateControlSize,The following statement contains a magic number: if (steuerung != null)  				{  				foreach (TimelineGroup tg in steuerung.groups)  					{  					currentVisibleRowCount++;  					if (!tg.collapsed)  						currentVisibleRowCount += tg.entries.Count;  					}  				this.ClientSize = new Size((int)Math.Round(m_zoom * steuerung.maxTime) + 5 + totalRowHeight' Math.Max(currentVisibleRowCount * totalRowHeight + 20' 50));  				}
Magic Number,CityTrafficSimulator,TimelineControl,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TimelineControl.cs,TimelineControl_Paint,The following statement contains a magic number: if (steuerung != null)  				{  				int maxWidth = (int)Math.Round(m_zoom * steuerung.maxTime);    				int row = 0;  				foreach (TimelineGroup tg in steuerung.groups)  					{  					// zusammengefaltete Gruppe zeichnen  					if (tg.collapsed)  						{  						if (tg == m_selectedGroup)  							{  							e.Graphics.FillRectangle(backgroundBrush' 0' 1 + (row * totalRowHeight)' ClientSize.Width' totalRowHeight);  							}    						// Gruppenname zeichnen  						e.Graphics.DrawString(tg.title' calibriFont' blackBrush' new PointF(totalRowHeight + 3' row * totalRowHeight));    						// Pluszeichen malen  						e.Graphics.DrawRectangle(blackPen' 0' 1 + (row * totalRowHeight)' rowHeight' rowHeight);  						e.Graphics.DrawLine(blackPen' 2' 1 + (row * totalRowHeight) + rowHeight / 2' rowHeight - 2' 1 + (row * totalRowHeight) + rowHeight / 2);  						e.Graphics.DrawLine(blackPen' rowHeight / 2' 1 + (row * totalRowHeight) + 2' rowHeight / 2' 1 + (row * totalRowHeight) + rowHeight - 2);  						}  					// aufgefaltete Gruppe zeichnen  					else  						{  						if (tg == m_selectedGroup)  							{  							e.Graphics.FillRectangle(backgroundBrush' 0' 1 + (row * totalRowHeight)' ClientSize.Width' (1 + tg.entries.Count) * totalRowHeight);  							}    						// Gruppenname zeichnen  						e.Graphics.DrawString(tg.title' calibriFont' blackBrush' new PointF(totalRowHeight + 3' row * totalRowHeight));    						// Minuszeichen malen  						e.Graphics.DrawRectangle(blackPen' 0' 1 + (row * totalRowHeight)' rowHeight' rowHeight);  						e.Graphics.DrawLine(blackPen' 2' 1 + (row * totalRowHeight) + rowHeight / 2' rowHeight - 2' 1 + (row * totalRowHeight) + rowHeight / 2);    						// vertikale Linie unter Minuszeichen malen  						if (tg.entries.Count > 0)  							e.Graphics.DrawLine(blackPen' rowHeight / 2' row * totalRowHeight + totalRowHeight' rowHeight / 2' (row + tg.entries.Count) * totalRowHeight + totalRowHeight / 2);      						// Entries zeichnen  						foreach (TimelineEntry te in tg.entries)  							{  							row++;    							// horizontale Linie links malen  							e.Graphics.DrawLine(blackPen' totalRowHeight / 2' row * totalRowHeight + totalRowHeight / 2' totalRowHeight / 2 + totalRowHeight / 4' row * totalRowHeight + totalRowHeight / 2);    							// Balken malen  							if (te == selectedEntry)  								{  								e.Graphics.DrawRectangle(dottedPen' totalRowHeight' 1 + (row * totalRowHeight)' maxWidth' rowHeight);  								}  							else  								{  								e.Graphics.DrawRectangle(blackPen' totalRowHeight' 1 + (row * totalRowHeight)' maxWidth' rowHeight);  								}  							e.Graphics.FillRectangle(new SolidBrush(te.color)' totalRowHeight + 1' 2 + (row * totalRowHeight)' maxWidth - 1' rowHeight - 1);    							// einzelne Events zeichnen  							foreach (TimelineEvent ev in te.events)  								{  								int startPosition = totalRowHeight + (int)Math.Round(ev.eventTime * zoom);  								int length = (int)Math.Round(ev.eventLength * zoom);  								e.Graphics.FillRectangle(new SolidBrush(ev.color)' startPosition' 2 + (row * totalRowHeight)' length' rowHeight - 1);  								e.Graphics.DrawLine(blackPen' startPosition' 2 + (row * totalRowHeight)' startPosition' totalRowHeight - 2 + (row * totalRowHeight));  								e.Graphics.DrawLine(blackPen' startPosition + length' 2 + (row * totalRowHeight)' startPosition + length' totalRowHeight - 2 + (row * totalRowHeight));  								}    							e.Graphics.DrawString(te.name' calibriFont' blackBrush' new PointF(totalRowHeight + 3' row * totalRowHeight));  							}  						}    					row++;  					}        				// Lineal zeichnen  				dottedPen.DashStyle = System.Drawing.Drawing2D.DashStyle.Dash;    				e.Graphics.DrawLine(blackPen' totalRowHeight' this.ClientSize.Height - 1' this.Width' this.Height - 1);    				for (int i = 0; i <= steuerung.maxTime / 10; i++)  					{  					e.Graphics.DrawLine(blackPen' totalRowHeight + i * 10 * zoom' this.Height - 1' totalRowHeight + i * 10 * zoom' this.Height - 7);  					e.Graphics.DrawString((i * 10).ToString()' calibriFont' blackBrush' new PointF(totalRowHeight + (i * 10 * zoom) - 8' this.Height - 18));  					}    				// aktuelle Zeit zeichnen  				e.Graphics.DrawLine(dottedPen' totalRowHeight + (int)Math.Round(timelineBarTime * zoom)' 0' totalRowHeight + (int)Math.Round(timelineBarTime * zoom)' Height);  				}
Magic Number,CityTrafficSimulator,TimelineControl,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TimelineControl.cs,TimelineControl_Paint,The following statement contains a magic number: if (steuerung != null)  				{  				int maxWidth = (int)Math.Round(m_zoom * steuerung.maxTime);    				int row = 0;  				foreach (TimelineGroup tg in steuerung.groups)  					{  					// zusammengefaltete Gruppe zeichnen  					if (tg.collapsed)  						{  						if (tg == m_selectedGroup)  							{  							e.Graphics.FillRectangle(backgroundBrush' 0' 1 + (row * totalRowHeight)' ClientSize.Width' totalRowHeight);  							}    						// Gruppenname zeichnen  						e.Graphics.DrawString(tg.title' calibriFont' blackBrush' new PointF(totalRowHeight + 3' row * totalRowHeight));    						// Pluszeichen malen  						e.Graphics.DrawRectangle(blackPen' 0' 1 + (row * totalRowHeight)' rowHeight' rowHeight);  						e.Graphics.DrawLine(blackPen' 2' 1 + (row * totalRowHeight) + rowHeight / 2' rowHeight - 2' 1 + (row * totalRowHeight) + rowHeight / 2);  						e.Graphics.DrawLine(blackPen' rowHeight / 2' 1 + (row * totalRowHeight) + 2' rowHeight / 2' 1 + (row * totalRowHeight) + rowHeight - 2);  						}  					// aufgefaltete Gruppe zeichnen  					else  						{  						if (tg == m_selectedGroup)  							{  							e.Graphics.FillRectangle(backgroundBrush' 0' 1 + (row * totalRowHeight)' ClientSize.Width' (1 + tg.entries.Count) * totalRowHeight);  							}    						// Gruppenname zeichnen  						e.Graphics.DrawString(tg.title' calibriFont' blackBrush' new PointF(totalRowHeight + 3' row * totalRowHeight));    						// Minuszeichen malen  						e.Graphics.DrawRectangle(blackPen' 0' 1 + (row * totalRowHeight)' rowHeight' rowHeight);  						e.Graphics.DrawLine(blackPen' 2' 1 + (row * totalRowHeight) + rowHeight / 2' rowHeight - 2' 1 + (row * totalRowHeight) + rowHeight / 2);    						// vertikale Linie unter Minuszeichen malen  						if (tg.entries.Count > 0)  							e.Graphics.DrawLine(blackPen' rowHeight / 2' row * totalRowHeight + totalRowHeight' rowHeight / 2' (row + tg.entries.Count) * totalRowHeight + totalRowHeight / 2);      						// Entries zeichnen  						foreach (TimelineEntry te in tg.entries)  							{  							row++;    							// horizontale Linie links malen  							e.Graphics.DrawLine(blackPen' totalRowHeight / 2' row * totalRowHeight + totalRowHeight / 2' totalRowHeight / 2 + totalRowHeight / 4' row * totalRowHeight + totalRowHeight / 2);    							// Balken malen  							if (te == selectedEntry)  								{  								e.Graphics.DrawRectangle(dottedPen' totalRowHeight' 1 + (row * totalRowHeight)' maxWidth' rowHeight);  								}  							else  								{  								e.Graphics.DrawRectangle(blackPen' totalRowHeight' 1 + (row * totalRowHeight)' maxWidth' rowHeight);  								}  							e.Graphics.FillRectangle(new SolidBrush(te.color)' totalRowHeight + 1' 2 + (row * totalRowHeight)' maxWidth - 1' rowHeight - 1);    							// einzelne Events zeichnen  							foreach (TimelineEvent ev in te.events)  								{  								int startPosition = totalRowHeight + (int)Math.Round(ev.eventTime * zoom);  								int length = (int)Math.Round(ev.eventLength * zoom);  								e.Graphics.FillRectangle(new SolidBrush(ev.color)' startPosition' 2 + (row * totalRowHeight)' length' rowHeight - 1);  								e.Graphics.DrawLine(blackPen' startPosition' 2 + (row * totalRowHeight)' startPosition' totalRowHeight - 2 + (row * totalRowHeight));  								e.Graphics.DrawLine(blackPen' startPosition + length' 2 + (row * totalRowHeight)' startPosition + length' totalRowHeight - 2 + (row * totalRowHeight));  								}    							e.Graphics.DrawString(te.name' calibriFont' blackBrush' new PointF(totalRowHeight + 3' row * totalRowHeight));  							}  						}    					row++;  					}        				// Lineal zeichnen  				dottedPen.DashStyle = System.Drawing.Drawing2D.DashStyle.Dash;    				e.Graphics.DrawLine(blackPen' totalRowHeight' this.ClientSize.Height - 1' this.Width' this.Height - 1);    				for (int i = 0; i <= steuerung.maxTime / 10; i++)  					{  					e.Graphics.DrawLine(blackPen' totalRowHeight + i * 10 * zoom' this.Height - 1' totalRowHeight + i * 10 * zoom' this.Height - 7);  					e.Graphics.DrawString((i * 10).ToString()' calibriFont' blackBrush' new PointF(totalRowHeight + (i * 10 * zoom) - 8' this.Height - 18));  					}    				// aktuelle Zeit zeichnen  				e.Graphics.DrawLine(dottedPen' totalRowHeight + (int)Math.Round(timelineBarTime * zoom)' 0' totalRowHeight + (int)Math.Round(timelineBarTime * zoom)' Height);  				}
Magic Number,CityTrafficSimulator,TimelineControl,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TimelineControl.cs,TimelineControl_Paint,The following statement contains a magic number: if (steuerung != null)  				{  				int maxWidth = (int)Math.Round(m_zoom * steuerung.maxTime);    				int row = 0;  				foreach (TimelineGroup tg in steuerung.groups)  					{  					// zusammengefaltete Gruppe zeichnen  					if (tg.collapsed)  						{  						if (tg == m_selectedGroup)  							{  							e.Graphics.FillRectangle(backgroundBrush' 0' 1 + (row * totalRowHeight)' ClientSize.Width' totalRowHeight);  							}    						// Gruppenname zeichnen  						e.Graphics.DrawString(tg.title' calibriFont' blackBrush' new PointF(totalRowHeight + 3' row * totalRowHeight));    						// Pluszeichen malen  						e.Graphics.DrawRectangle(blackPen' 0' 1 + (row * totalRowHeight)' rowHeight' rowHeight);  						e.Graphics.DrawLine(blackPen' 2' 1 + (row * totalRowHeight) + rowHeight / 2' rowHeight - 2' 1 + (row * totalRowHeight) + rowHeight / 2);  						e.Graphics.DrawLine(blackPen' rowHeight / 2' 1 + (row * totalRowHeight) + 2' rowHeight / 2' 1 + (row * totalRowHeight) + rowHeight - 2);  						}  					// aufgefaltete Gruppe zeichnen  					else  						{  						if (tg == m_selectedGroup)  							{  							e.Graphics.FillRectangle(backgroundBrush' 0' 1 + (row * totalRowHeight)' ClientSize.Width' (1 + tg.entries.Count) * totalRowHeight);  							}    						// Gruppenname zeichnen  						e.Graphics.DrawString(tg.title' calibriFont' blackBrush' new PointF(totalRowHeight + 3' row * totalRowHeight));    						// Minuszeichen malen  						e.Graphics.DrawRectangle(blackPen' 0' 1 + (row * totalRowHeight)' rowHeight' rowHeight);  						e.Graphics.DrawLine(blackPen' 2' 1 + (row * totalRowHeight) + rowHeight / 2' rowHeight - 2' 1 + (row * totalRowHeight) + rowHeight / 2);    						// vertikale Linie unter Minuszeichen malen  						if (tg.entries.Count > 0)  							e.Graphics.DrawLine(blackPen' rowHeight / 2' row * totalRowHeight + totalRowHeight' rowHeight / 2' (row + tg.entries.Count) * totalRowHeight + totalRowHeight / 2);      						// Entries zeichnen  						foreach (TimelineEntry te in tg.entries)  							{  							row++;    							// horizontale Linie links malen  							e.Graphics.DrawLine(blackPen' totalRowHeight / 2' row * totalRowHeight + totalRowHeight / 2' totalRowHeight / 2 + totalRowHeight / 4' row * totalRowHeight + totalRowHeight / 2);    							// Balken malen  							if (te == selectedEntry)  								{  								e.Graphics.DrawRectangle(dottedPen' totalRowHeight' 1 + (row * totalRowHeight)' maxWidth' rowHeight);  								}  							else  								{  								e.Graphics.DrawRectangle(blackPen' totalRowHeight' 1 + (row * totalRowHeight)' maxWidth' rowHeight);  								}  							e.Graphics.FillRectangle(new SolidBrush(te.color)' totalRowHeight + 1' 2 + (row * totalRowHeight)' maxWidth - 1' rowHeight - 1);    							// einzelne Events zeichnen  							foreach (TimelineEvent ev in te.events)  								{  								int startPosition = totalRowHeight + (int)Math.Round(ev.eventTime * zoom);  								int length = (int)Math.Round(ev.eventLength * zoom);  								e.Graphics.FillRectangle(new SolidBrush(ev.color)' startPosition' 2 + (row * totalRowHeight)' length' rowHeight - 1);  								e.Graphics.DrawLine(blackPen' startPosition' 2 + (row * totalRowHeight)' startPosition' totalRowHeight - 2 + (row * totalRowHeight));  								e.Graphics.DrawLine(blackPen' startPosition + length' 2 + (row * totalRowHeight)' startPosition + length' totalRowHeight - 2 + (row * totalRowHeight));  								}    							e.Graphics.DrawString(te.name' calibriFont' blackBrush' new PointF(totalRowHeight + 3' row * totalRowHeight));  							}  						}    					row++;  					}        				// Lineal zeichnen  				dottedPen.DashStyle = System.Drawing.Drawing2D.DashStyle.Dash;    				e.Graphics.DrawLine(blackPen' totalRowHeight' this.ClientSize.Height - 1' this.Width' this.Height - 1);    				for (int i = 0; i <= steuerung.maxTime / 10; i++)  					{  					e.Graphics.DrawLine(blackPen' totalRowHeight + i * 10 * zoom' this.Height - 1' totalRowHeight + i * 10 * zoom' this.Height - 7);  					e.Graphics.DrawString((i * 10).ToString()' calibriFont' blackBrush' new PointF(totalRowHeight + (i * 10 * zoom) - 8' this.Height - 18));  					}    				// aktuelle Zeit zeichnen  				e.Graphics.DrawLine(dottedPen' totalRowHeight + (int)Math.Round(timelineBarTime * zoom)' 0' totalRowHeight + (int)Math.Round(timelineBarTime * zoom)' Height);  				}
Magic Number,CityTrafficSimulator,TimelineControl,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TimelineControl.cs,TimelineControl_Paint,The following statement contains a magic number: if (steuerung != null)  				{  				int maxWidth = (int)Math.Round(m_zoom * steuerung.maxTime);    				int row = 0;  				foreach (TimelineGroup tg in steuerung.groups)  					{  					// zusammengefaltete Gruppe zeichnen  					if (tg.collapsed)  						{  						if (tg == m_selectedGroup)  							{  							e.Graphics.FillRectangle(backgroundBrush' 0' 1 + (row * totalRowHeight)' ClientSize.Width' totalRowHeight);  							}    						// Gruppenname zeichnen  						e.Graphics.DrawString(tg.title' calibriFont' blackBrush' new PointF(totalRowHeight + 3' row * totalRowHeight));    						// Pluszeichen malen  						e.Graphics.DrawRectangle(blackPen' 0' 1 + (row * totalRowHeight)' rowHeight' rowHeight);  						e.Graphics.DrawLine(blackPen' 2' 1 + (row * totalRowHeight) + rowHeight / 2' rowHeight - 2' 1 + (row * totalRowHeight) + rowHeight / 2);  						e.Graphics.DrawLine(blackPen' rowHeight / 2' 1 + (row * totalRowHeight) + 2' rowHeight / 2' 1 + (row * totalRowHeight) + rowHeight - 2);  						}  					// aufgefaltete Gruppe zeichnen  					else  						{  						if (tg == m_selectedGroup)  							{  							e.Graphics.FillRectangle(backgroundBrush' 0' 1 + (row * totalRowHeight)' ClientSize.Width' (1 + tg.entries.Count) * totalRowHeight);  							}    						// Gruppenname zeichnen  						e.Graphics.DrawString(tg.title' calibriFont' blackBrush' new PointF(totalRowHeight + 3' row * totalRowHeight));    						// Minuszeichen malen  						e.Graphics.DrawRectangle(blackPen' 0' 1 + (row * totalRowHeight)' rowHeight' rowHeight);  						e.Graphics.DrawLine(blackPen' 2' 1 + (row * totalRowHeight) + rowHeight / 2' rowHeight - 2' 1 + (row * totalRowHeight) + rowHeight / 2);    						// vertikale Linie unter Minuszeichen malen  						if (tg.entries.Count > 0)  							e.Graphics.DrawLine(blackPen' rowHeight / 2' row * totalRowHeight + totalRowHeight' rowHeight / 2' (row + tg.entries.Count) * totalRowHeight + totalRowHeight / 2);      						// Entries zeichnen  						foreach (TimelineEntry te in tg.entries)  							{  							row++;    							// horizontale Linie links malen  							e.Graphics.DrawLine(blackPen' totalRowHeight / 2' row * totalRowHeight + totalRowHeight / 2' totalRowHeight / 2 + totalRowHeight / 4' row * totalRowHeight + totalRowHeight / 2);    							// Balken malen  							if (te == selectedEntry)  								{  								e.Graphics.DrawRectangle(dottedPen' totalRowHeight' 1 + (row * totalRowHeight)' maxWidth' rowHeight);  								}  							else  								{  								e.Graphics.DrawRectangle(blackPen' totalRowHeight' 1 + (row * totalRowHeight)' maxWidth' rowHeight);  								}  							e.Graphics.FillRectangle(new SolidBrush(te.color)' totalRowHeight + 1' 2 + (row * totalRowHeight)' maxWidth - 1' rowHeight - 1);    							// einzelne Events zeichnen  							foreach (TimelineEvent ev in te.events)  								{  								int startPosition = totalRowHeight + (int)Math.Round(ev.eventTime * zoom);  								int length = (int)Math.Round(ev.eventLength * zoom);  								e.Graphics.FillRectangle(new SolidBrush(ev.color)' startPosition' 2 + (row * totalRowHeight)' length' rowHeight - 1);  								e.Graphics.DrawLine(blackPen' startPosition' 2 + (row * totalRowHeight)' startPosition' totalRowHeight - 2 + (row * totalRowHeight));  								e.Graphics.DrawLine(blackPen' startPosition + length' 2 + (row * totalRowHeight)' startPosition + length' totalRowHeight - 2 + (row * totalRowHeight));  								}    							e.Graphics.DrawString(te.name' calibriFont' blackBrush' new PointF(totalRowHeight + 3' row * totalRowHeight));  							}  						}    					row++;  					}        				// Lineal zeichnen  				dottedPen.DashStyle = System.Drawing.Drawing2D.DashStyle.Dash;    				e.Graphics.DrawLine(blackPen' totalRowHeight' this.ClientSize.Height - 1' this.Width' this.Height - 1);    				for (int i = 0; i <= steuerung.maxTime / 10; i++)  					{  					e.Graphics.DrawLine(blackPen' totalRowHeight + i * 10 * zoom' this.Height - 1' totalRowHeight + i * 10 * zoom' this.Height - 7);  					e.Graphics.DrawString((i * 10).ToString()' calibriFont' blackBrush' new PointF(totalRowHeight + (i * 10 * zoom) - 8' this.Height - 18));  					}    				// aktuelle Zeit zeichnen  				e.Graphics.DrawLine(dottedPen' totalRowHeight + (int)Math.Round(timelineBarTime * zoom)' 0' totalRowHeight + (int)Math.Round(timelineBarTime * zoom)' Height);  				}
Magic Number,CityTrafficSimulator,TimelineControl,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TimelineControl.cs,TimelineControl_Paint,The following statement contains a magic number: if (steuerung != null)  				{  				int maxWidth = (int)Math.Round(m_zoom * steuerung.maxTime);    				int row = 0;  				foreach (TimelineGroup tg in steuerung.groups)  					{  					// zusammengefaltete Gruppe zeichnen  					if (tg.collapsed)  						{  						if (tg == m_selectedGroup)  							{  							e.Graphics.FillRectangle(backgroundBrush' 0' 1 + (row * totalRowHeight)' ClientSize.Width' totalRowHeight);  							}    						// Gruppenname zeichnen  						e.Graphics.DrawString(tg.title' calibriFont' blackBrush' new PointF(totalRowHeight + 3' row * totalRowHeight));    						// Pluszeichen malen  						e.Graphics.DrawRectangle(blackPen' 0' 1 + (row * totalRowHeight)' rowHeight' rowHeight);  						e.Graphics.DrawLine(blackPen' 2' 1 + (row * totalRowHeight) + rowHeight / 2' rowHeight - 2' 1 + (row * totalRowHeight) + rowHeight / 2);  						e.Graphics.DrawLine(blackPen' rowHeight / 2' 1 + (row * totalRowHeight) + 2' rowHeight / 2' 1 + (row * totalRowHeight) + rowHeight - 2);  						}  					// aufgefaltete Gruppe zeichnen  					else  						{  						if (tg == m_selectedGroup)  							{  							e.Graphics.FillRectangle(backgroundBrush' 0' 1 + (row * totalRowHeight)' ClientSize.Width' (1 + tg.entries.Count) * totalRowHeight);  							}    						// Gruppenname zeichnen  						e.Graphics.DrawString(tg.title' calibriFont' blackBrush' new PointF(totalRowHeight + 3' row * totalRowHeight));    						// Minuszeichen malen  						e.Graphics.DrawRectangle(blackPen' 0' 1 + (row * totalRowHeight)' rowHeight' rowHeight);  						e.Graphics.DrawLine(blackPen' 2' 1 + (row * totalRowHeight) + rowHeight / 2' rowHeight - 2' 1 + (row * totalRowHeight) + rowHeight / 2);    						// vertikale Linie unter Minuszeichen malen  						if (tg.entries.Count > 0)  							e.Graphics.DrawLine(blackPen' rowHeight / 2' row * totalRowHeight + totalRowHeight' rowHeight / 2' (row + tg.entries.Count) * totalRowHeight + totalRowHeight / 2);      						// Entries zeichnen  						foreach (TimelineEntry te in tg.entries)  							{  							row++;    							// horizontale Linie links malen  							e.Graphics.DrawLine(blackPen' totalRowHeight / 2' row * totalRowHeight + totalRowHeight / 2' totalRowHeight / 2 + totalRowHeight / 4' row * totalRowHeight + totalRowHeight / 2);    							// Balken malen  							if (te == selectedEntry)  								{  								e.Graphics.DrawRectangle(dottedPen' totalRowHeight' 1 + (row * totalRowHeight)' maxWidth' rowHeight);  								}  							else  								{  								e.Graphics.DrawRectangle(blackPen' totalRowHeight' 1 + (row * totalRowHeight)' maxWidth' rowHeight);  								}  							e.Graphics.FillRectangle(new SolidBrush(te.color)' totalRowHeight + 1' 2 + (row * totalRowHeight)' maxWidth - 1' rowHeight - 1);    							// einzelne Events zeichnen  							foreach (TimelineEvent ev in te.events)  								{  								int startPosition = totalRowHeight + (int)Math.Round(ev.eventTime * zoom);  								int length = (int)Math.Round(ev.eventLength * zoom);  								e.Graphics.FillRectangle(new SolidBrush(ev.color)' startPosition' 2 + (row * totalRowHeight)' length' rowHeight - 1);  								e.Graphics.DrawLine(blackPen' startPosition' 2 + (row * totalRowHeight)' startPosition' totalRowHeight - 2 + (row * totalRowHeight));  								e.Graphics.DrawLine(blackPen' startPosition + length' 2 + (row * totalRowHeight)' startPosition + length' totalRowHeight - 2 + (row * totalRowHeight));  								}    							e.Graphics.DrawString(te.name' calibriFont' blackBrush' new PointF(totalRowHeight + 3' row * totalRowHeight));  							}  						}    					row++;  					}        				// Lineal zeichnen  				dottedPen.DashStyle = System.Drawing.Drawing2D.DashStyle.Dash;    				e.Graphics.DrawLine(blackPen' totalRowHeight' this.ClientSize.Height - 1' this.Width' this.Height - 1);    				for (int i = 0; i <= steuerung.maxTime / 10; i++)  					{  					e.Graphics.DrawLine(blackPen' totalRowHeight + i * 10 * zoom' this.Height - 1' totalRowHeight + i * 10 * zoom' this.Height - 7);  					e.Graphics.DrawString((i * 10).ToString()' calibriFont' blackBrush' new PointF(totalRowHeight + (i * 10 * zoom) - 8' this.Height - 18));  					}    				// aktuelle Zeit zeichnen  				e.Graphics.DrawLine(dottedPen' totalRowHeight + (int)Math.Round(timelineBarTime * zoom)' 0' totalRowHeight + (int)Math.Round(timelineBarTime * zoom)' Height);  				}
Magic Number,CityTrafficSimulator,TimelineControl,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TimelineControl.cs,TimelineControl_Paint,The following statement contains a magic number: if (steuerung != null)  				{  				int maxWidth = (int)Math.Round(m_zoom * steuerung.maxTime);    				int row = 0;  				foreach (TimelineGroup tg in steuerung.groups)  					{  					// zusammengefaltete Gruppe zeichnen  					if (tg.collapsed)  						{  						if (tg == m_selectedGroup)  							{  							e.Graphics.FillRectangle(backgroundBrush' 0' 1 + (row * totalRowHeight)' ClientSize.Width' totalRowHeight);  							}    						// Gruppenname zeichnen  						e.Graphics.DrawString(tg.title' calibriFont' blackBrush' new PointF(totalRowHeight + 3' row * totalRowHeight));    						// Pluszeichen malen  						e.Graphics.DrawRectangle(blackPen' 0' 1 + (row * totalRowHeight)' rowHeight' rowHeight);  						e.Graphics.DrawLine(blackPen' 2' 1 + (row * totalRowHeight) + rowHeight / 2' rowHeight - 2' 1 + (row * totalRowHeight) + rowHeight / 2);  						e.Graphics.DrawLine(blackPen' rowHeight / 2' 1 + (row * totalRowHeight) + 2' rowHeight / 2' 1 + (row * totalRowHeight) + rowHeight - 2);  						}  					// aufgefaltete Gruppe zeichnen  					else  						{  						if (tg == m_selectedGroup)  							{  							e.Graphics.FillRectangle(backgroundBrush' 0' 1 + (row * totalRowHeight)' ClientSize.Width' (1 + tg.entries.Count) * totalRowHeight);  							}    						// Gruppenname zeichnen  						e.Graphics.DrawString(tg.title' calibriFont' blackBrush' new PointF(totalRowHeight + 3' row * totalRowHeight));    						// Minuszeichen malen  						e.Graphics.DrawRectangle(blackPen' 0' 1 + (row * totalRowHeight)' rowHeight' rowHeight);  						e.Graphics.DrawLine(blackPen' 2' 1 + (row * totalRowHeight) + rowHeight / 2' rowHeight - 2' 1 + (row * totalRowHeight) + rowHeight / 2);    						// vertikale Linie unter Minuszeichen malen  						if (tg.entries.Count > 0)  							e.Graphics.DrawLine(blackPen' rowHeight / 2' row * totalRowHeight + totalRowHeight' rowHeight / 2' (row + tg.entries.Count) * totalRowHeight + totalRowHeight / 2);      						// Entries zeichnen  						foreach (TimelineEntry te in tg.entries)  							{  							row++;    							// horizontale Linie links malen  							e.Graphics.DrawLine(blackPen' totalRowHeight / 2' row * totalRowHeight + totalRowHeight / 2' totalRowHeight / 2 + totalRowHeight / 4' row * totalRowHeight + totalRowHeight / 2);    							// Balken malen  							if (te == selectedEntry)  								{  								e.Graphics.DrawRectangle(dottedPen' totalRowHeight' 1 + (row * totalRowHeight)' maxWidth' rowHeight);  								}  							else  								{  								e.Graphics.DrawRectangle(blackPen' totalRowHeight' 1 + (row * totalRowHeight)' maxWidth' rowHeight);  								}  							e.Graphics.FillRectangle(new SolidBrush(te.color)' totalRowHeight + 1' 2 + (row * totalRowHeight)' maxWidth - 1' rowHeight - 1);    							// einzelne Events zeichnen  							foreach (TimelineEvent ev in te.events)  								{  								int startPosition = totalRowHeight + (int)Math.Round(ev.eventTime * zoom);  								int length = (int)Math.Round(ev.eventLength * zoom);  								e.Graphics.FillRectangle(new SolidBrush(ev.color)' startPosition' 2 + (row * totalRowHeight)' length' rowHeight - 1);  								e.Graphics.DrawLine(blackPen' startPosition' 2 + (row * totalRowHeight)' startPosition' totalRowHeight - 2 + (row * totalRowHeight));  								e.Graphics.DrawLine(blackPen' startPosition + length' 2 + (row * totalRowHeight)' startPosition + length' totalRowHeight - 2 + (row * totalRowHeight));  								}    							e.Graphics.DrawString(te.name' calibriFont' blackBrush' new PointF(totalRowHeight + 3' row * totalRowHeight));  							}  						}    					row++;  					}        				// Lineal zeichnen  				dottedPen.DashStyle = System.Drawing.Drawing2D.DashStyle.Dash;    				e.Graphics.DrawLine(blackPen' totalRowHeight' this.ClientSize.Height - 1' this.Width' this.Height - 1);    				for (int i = 0; i <= steuerung.maxTime / 10; i++)  					{  					e.Graphics.DrawLine(blackPen' totalRowHeight + i * 10 * zoom' this.Height - 1' totalRowHeight + i * 10 * zoom' this.Height - 7);  					e.Graphics.DrawString((i * 10).ToString()' calibriFont' blackBrush' new PointF(totalRowHeight + (i * 10 * zoom) - 8' this.Height - 18));  					}    				// aktuelle Zeit zeichnen  				e.Graphics.DrawLine(dottedPen' totalRowHeight + (int)Math.Round(timelineBarTime * zoom)' 0' totalRowHeight + (int)Math.Round(timelineBarTime * zoom)' Height);  				}
Magic Number,CityTrafficSimulator,TimelineControl,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TimelineControl.cs,TimelineControl_Paint,The following statement contains a magic number: if (steuerung != null)  				{  				int maxWidth = (int)Math.Round(m_zoom * steuerung.maxTime);    				int row = 0;  				foreach (TimelineGroup tg in steuerung.groups)  					{  					// zusammengefaltete Gruppe zeichnen  					if (tg.collapsed)  						{  						if (tg == m_selectedGroup)  							{  							e.Graphics.FillRectangle(backgroundBrush' 0' 1 + (row * totalRowHeight)' ClientSize.Width' totalRowHeight);  							}    						// Gruppenname zeichnen  						e.Graphics.DrawString(tg.title' calibriFont' blackBrush' new PointF(totalRowHeight + 3' row * totalRowHeight));    						// Pluszeichen malen  						e.Graphics.DrawRectangle(blackPen' 0' 1 + (row * totalRowHeight)' rowHeight' rowHeight);  						e.Graphics.DrawLine(blackPen' 2' 1 + (row * totalRowHeight) + rowHeight / 2' rowHeight - 2' 1 + (row * totalRowHeight) + rowHeight / 2);  						e.Graphics.DrawLine(blackPen' rowHeight / 2' 1 + (row * totalRowHeight) + 2' rowHeight / 2' 1 + (row * totalRowHeight) + rowHeight - 2);  						}  					// aufgefaltete Gruppe zeichnen  					else  						{  						if (tg == m_selectedGroup)  							{  							e.Graphics.FillRectangle(backgroundBrush' 0' 1 + (row * totalRowHeight)' ClientSize.Width' (1 + tg.entries.Count) * totalRowHeight);  							}    						// Gruppenname zeichnen  						e.Graphics.DrawString(tg.title' calibriFont' blackBrush' new PointF(totalRowHeight + 3' row * totalRowHeight));    						// Minuszeichen malen  						e.Graphics.DrawRectangle(blackPen' 0' 1 + (row * totalRowHeight)' rowHeight' rowHeight);  						e.Graphics.DrawLine(blackPen' 2' 1 + (row * totalRowHeight) + rowHeight / 2' rowHeight - 2' 1 + (row * totalRowHeight) + rowHeight / 2);    						// vertikale Linie unter Minuszeichen malen  						if (tg.entries.Count > 0)  							e.Graphics.DrawLine(blackPen' rowHeight / 2' row * totalRowHeight + totalRowHeight' rowHeight / 2' (row + tg.entries.Count) * totalRowHeight + totalRowHeight / 2);      						// Entries zeichnen  						foreach (TimelineEntry te in tg.entries)  							{  							row++;    							// horizontale Linie links malen  							e.Graphics.DrawLine(blackPen' totalRowHeight / 2' row * totalRowHeight + totalRowHeight / 2' totalRowHeight / 2 + totalRowHeight / 4' row * totalRowHeight + totalRowHeight / 2);    							// Balken malen  							if (te == selectedEntry)  								{  								e.Graphics.DrawRectangle(dottedPen' totalRowHeight' 1 + (row * totalRowHeight)' maxWidth' rowHeight);  								}  							else  								{  								e.Graphics.DrawRectangle(blackPen' totalRowHeight' 1 + (row * totalRowHeight)' maxWidth' rowHeight);  								}  							e.Graphics.FillRectangle(new SolidBrush(te.color)' totalRowHeight + 1' 2 + (row * totalRowHeight)' maxWidth - 1' rowHeight - 1);    							// einzelne Events zeichnen  							foreach (TimelineEvent ev in te.events)  								{  								int startPosition = totalRowHeight + (int)Math.Round(ev.eventTime * zoom);  								int length = (int)Math.Round(ev.eventLength * zoom);  								e.Graphics.FillRectangle(new SolidBrush(ev.color)' startPosition' 2 + (row * totalRowHeight)' length' rowHeight - 1);  								e.Graphics.DrawLine(blackPen' startPosition' 2 + (row * totalRowHeight)' startPosition' totalRowHeight - 2 + (row * totalRowHeight));  								e.Graphics.DrawLine(blackPen' startPosition + length' 2 + (row * totalRowHeight)' startPosition + length' totalRowHeight - 2 + (row * totalRowHeight));  								}    							e.Graphics.DrawString(te.name' calibriFont' blackBrush' new PointF(totalRowHeight + 3' row * totalRowHeight));  							}  						}    					row++;  					}        				// Lineal zeichnen  				dottedPen.DashStyle = System.Drawing.Drawing2D.DashStyle.Dash;    				e.Graphics.DrawLine(blackPen' totalRowHeight' this.ClientSize.Height - 1' this.Width' this.Height - 1);    				for (int i = 0; i <= steuerung.maxTime / 10; i++)  					{  					e.Graphics.DrawLine(blackPen' totalRowHeight + i * 10 * zoom' this.Height - 1' totalRowHeight + i * 10 * zoom' this.Height - 7);  					e.Graphics.DrawString((i * 10).ToString()' calibriFont' blackBrush' new PointF(totalRowHeight + (i * 10 * zoom) - 8' this.Height - 18));  					}    				// aktuelle Zeit zeichnen  				e.Graphics.DrawLine(dottedPen' totalRowHeight + (int)Math.Round(timelineBarTime * zoom)' 0' totalRowHeight + (int)Math.Round(timelineBarTime * zoom)' Height);  				}
Magic Number,CityTrafficSimulator,TimelineControl,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TimelineControl.cs,TimelineControl_Paint,The following statement contains a magic number: if (steuerung != null)  				{  				int maxWidth = (int)Math.Round(m_zoom * steuerung.maxTime);    				int row = 0;  				foreach (TimelineGroup tg in steuerung.groups)  					{  					// zusammengefaltete Gruppe zeichnen  					if (tg.collapsed)  						{  						if (tg == m_selectedGroup)  							{  							e.Graphics.FillRectangle(backgroundBrush' 0' 1 + (row * totalRowHeight)' ClientSize.Width' totalRowHeight);  							}    						// Gruppenname zeichnen  						e.Graphics.DrawString(tg.title' calibriFont' blackBrush' new PointF(totalRowHeight + 3' row * totalRowHeight));    						// Pluszeichen malen  						e.Graphics.DrawRectangle(blackPen' 0' 1 + (row * totalRowHeight)' rowHeight' rowHeight);  						e.Graphics.DrawLine(blackPen' 2' 1 + (row * totalRowHeight) + rowHeight / 2' rowHeight - 2' 1 + (row * totalRowHeight) + rowHeight / 2);  						e.Graphics.DrawLine(blackPen' rowHeight / 2' 1 + (row * totalRowHeight) + 2' rowHeight / 2' 1 + (row * totalRowHeight) + rowHeight - 2);  						}  					// aufgefaltete Gruppe zeichnen  					else  						{  						if (tg == m_selectedGroup)  							{  							e.Graphics.FillRectangle(backgroundBrush' 0' 1 + (row * totalRowHeight)' ClientSize.Width' (1 + tg.entries.Count) * totalRowHeight);  							}    						// Gruppenname zeichnen  						e.Graphics.DrawString(tg.title' calibriFont' blackBrush' new PointF(totalRowHeight + 3' row * totalRowHeight));    						// Minuszeichen malen  						e.Graphics.DrawRectangle(blackPen' 0' 1 + (row * totalRowHeight)' rowHeight' rowHeight);  						e.Graphics.DrawLine(blackPen' 2' 1 + (row * totalRowHeight) + rowHeight / 2' rowHeight - 2' 1 + (row * totalRowHeight) + rowHeight / 2);    						// vertikale Linie unter Minuszeichen malen  						if (tg.entries.Count > 0)  							e.Graphics.DrawLine(blackPen' rowHeight / 2' row * totalRowHeight + totalRowHeight' rowHeight / 2' (row + tg.entries.Count) * totalRowHeight + totalRowHeight / 2);      						// Entries zeichnen  						foreach (TimelineEntry te in tg.entries)  							{  							row++;    							// horizontale Linie links malen  							e.Graphics.DrawLine(blackPen' totalRowHeight / 2' row * totalRowHeight + totalRowHeight / 2' totalRowHeight / 2 + totalRowHeight / 4' row * totalRowHeight + totalRowHeight / 2);    							// Balken malen  							if (te == selectedEntry)  								{  								e.Graphics.DrawRectangle(dottedPen' totalRowHeight' 1 + (row * totalRowHeight)' maxWidth' rowHeight);  								}  							else  								{  								e.Graphics.DrawRectangle(blackPen' totalRowHeight' 1 + (row * totalRowHeight)' maxWidth' rowHeight);  								}  							e.Graphics.FillRectangle(new SolidBrush(te.color)' totalRowHeight + 1' 2 + (row * totalRowHeight)' maxWidth - 1' rowHeight - 1);    							// einzelne Events zeichnen  							foreach (TimelineEvent ev in te.events)  								{  								int startPosition = totalRowHeight + (int)Math.Round(ev.eventTime * zoom);  								int length = (int)Math.Round(ev.eventLength * zoom);  								e.Graphics.FillRectangle(new SolidBrush(ev.color)' startPosition' 2 + (row * totalRowHeight)' length' rowHeight - 1);  								e.Graphics.DrawLine(blackPen' startPosition' 2 + (row * totalRowHeight)' startPosition' totalRowHeight - 2 + (row * totalRowHeight));  								e.Graphics.DrawLine(blackPen' startPosition + length' 2 + (row * totalRowHeight)' startPosition + length' totalRowHeight - 2 + (row * totalRowHeight));  								}    							e.Graphics.DrawString(te.name' calibriFont' blackBrush' new PointF(totalRowHeight + 3' row * totalRowHeight));  							}  						}    					row++;  					}        				// Lineal zeichnen  				dottedPen.DashStyle = System.Drawing.Drawing2D.DashStyle.Dash;    				e.Graphics.DrawLine(blackPen' totalRowHeight' this.ClientSize.Height - 1' this.Width' this.Height - 1);    				for (int i = 0; i <= steuerung.maxTime / 10; i++)  					{  					e.Graphics.DrawLine(blackPen' totalRowHeight + i * 10 * zoom' this.Height - 1' totalRowHeight + i * 10 * zoom' this.Height - 7);  					e.Graphics.DrawString((i * 10).ToString()' calibriFont' blackBrush' new PointF(totalRowHeight + (i * 10 * zoom) - 8' this.Height - 18));  					}    				// aktuelle Zeit zeichnen  				e.Graphics.DrawLine(dottedPen' totalRowHeight + (int)Math.Round(timelineBarTime * zoom)' 0' totalRowHeight + (int)Math.Round(timelineBarTime * zoom)' Height);  				}
Magic Number,CityTrafficSimulator,TimelineControl,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TimelineControl.cs,TimelineControl_Paint,The following statement contains a magic number: if (steuerung != null)  				{  				int maxWidth = (int)Math.Round(m_zoom * steuerung.maxTime);    				int row = 0;  				foreach (TimelineGroup tg in steuerung.groups)  					{  					// zusammengefaltete Gruppe zeichnen  					if (tg.collapsed)  						{  						if (tg == m_selectedGroup)  							{  							e.Graphics.FillRectangle(backgroundBrush' 0' 1 + (row * totalRowHeight)' ClientSize.Width' totalRowHeight);  							}    						// Gruppenname zeichnen  						e.Graphics.DrawString(tg.title' calibriFont' blackBrush' new PointF(totalRowHeight + 3' row * totalRowHeight));    						// Pluszeichen malen  						e.Graphics.DrawRectangle(blackPen' 0' 1 + (row * totalRowHeight)' rowHeight' rowHeight);  						e.Graphics.DrawLine(blackPen' 2' 1 + (row * totalRowHeight) + rowHeight / 2' rowHeight - 2' 1 + (row * totalRowHeight) + rowHeight / 2);  						e.Graphics.DrawLine(blackPen' rowHeight / 2' 1 + (row * totalRowHeight) + 2' rowHeight / 2' 1 + (row * totalRowHeight) + rowHeight - 2);  						}  					// aufgefaltete Gruppe zeichnen  					else  						{  						if (tg == m_selectedGroup)  							{  							e.Graphics.FillRectangle(backgroundBrush' 0' 1 + (row * totalRowHeight)' ClientSize.Width' (1 + tg.entries.Count) * totalRowHeight);  							}    						// Gruppenname zeichnen  						e.Graphics.DrawString(tg.title' calibriFont' blackBrush' new PointF(totalRowHeight + 3' row * totalRowHeight));    						// Minuszeichen malen  						e.Graphics.DrawRectangle(blackPen' 0' 1 + (row * totalRowHeight)' rowHeight' rowHeight);  						e.Graphics.DrawLine(blackPen' 2' 1 + (row * totalRowHeight) + rowHeight / 2' rowHeight - 2' 1 + (row * totalRowHeight) + rowHeight / 2);    						// vertikale Linie unter Minuszeichen malen  						if (tg.entries.Count > 0)  							e.Graphics.DrawLine(blackPen' rowHeight / 2' row * totalRowHeight + totalRowHeight' rowHeight / 2' (row + tg.entries.Count) * totalRowHeight + totalRowHeight / 2);      						// Entries zeichnen  						foreach (TimelineEntry te in tg.entries)  							{  							row++;    							// horizontale Linie links malen  							e.Graphics.DrawLine(blackPen' totalRowHeight / 2' row * totalRowHeight + totalRowHeight / 2' totalRowHeight / 2 + totalRowHeight / 4' row * totalRowHeight + totalRowHeight / 2);    							// Balken malen  							if (te == selectedEntry)  								{  								e.Graphics.DrawRectangle(dottedPen' totalRowHeight' 1 + (row * totalRowHeight)' maxWidth' rowHeight);  								}  							else  								{  								e.Graphics.DrawRectangle(blackPen' totalRowHeight' 1 + (row * totalRowHeight)' maxWidth' rowHeight);  								}  							e.Graphics.FillRectangle(new SolidBrush(te.color)' totalRowHeight + 1' 2 + (row * totalRowHeight)' maxWidth - 1' rowHeight - 1);    							// einzelne Events zeichnen  							foreach (TimelineEvent ev in te.events)  								{  								int startPosition = totalRowHeight + (int)Math.Round(ev.eventTime * zoom);  								int length = (int)Math.Round(ev.eventLength * zoom);  								e.Graphics.FillRectangle(new SolidBrush(ev.color)' startPosition' 2 + (row * totalRowHeight)' length' rowHeight - 1);  								e.Graphics.DrawLine(blackPen' startPosition' 2 + (row * totalRowHeight)' startPosition' totalRowHeight - 2 + (row * totalRowHeight));  								e.Graphics.DrawLine(blackPen' startPosition + length' 2 + (row * totalRowHeight)' startPosition + length' totalRowHeight - 2 + (row * totalRowHeight));  								}    							e.Graphics.DrawString(te.name' calibriFont' blackBrush' new PointF(totalRowHeight + 3' row * totalRowHeight));  							}  						}    					row++;  					}        				// Lineal zeichnen  				dottedPen.DashStyle = System.Drawing.Drawing2D.DashStyle.Dash;    				e.Graphics.DrawLine(blackPen' totalRowHeight' this.ClientSize.Height - 1' this.Width' this.Height - 1);    				for (int i = 0; i <= steuerung.maxTime / 10; i++)  					{  					e.Graphics.DrawLine(blackPen' totalRowHeight + i * 10 * zoom' this.Height - 1' totalRowHeight + i * 10 * zoom' this.Height - 7);  					e.Graphics.DrawString((i * 10).ToString()' calibriFont' blackBrush' new PointF(totalRowHeight + (i * 10 * zoom) - 8' this.Height - 18));  					}    				// aktuelle Zeit zeichnen  				e.Graphics.DrawLine(dottedPen' totalRowHeight + (int)Math.Round(timelineBarTime * zoom)' 0' totalRowHeight + (int)Math.Round(timelineBarTime * zoom)' Height);  				}
Magic Number,CityTrafficSimulator,TimelineControl,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TimelineControl.cs,TimelineControl_Paint,The following statement contains a magic number: if (steuerung != null)  				{  				int maxWidth = (int)Math.Round(m_zoom * steuerung.maxTime);    				int row = 0;  				foreach (TimelineGroup tg in steuerung.groups)  					{  					// zusammengefaltete Gruppe zeichnen  					if (tg.collapsed)  						{  						if (tg == m_selectedGroup)  							{  							e.Graphics.FillRectangle(backgroundBrush' 0' 1 + (row * totalRowHeight)' ClientSize.Width' totalRowHeight);  							}    						// Gruppenname zeichnen  						e.Graphics.DrawString(tg.title' calibriFont' blackBrush' new PointF(totalRowHeight + 3' row * totalRowHeight));    						// Pluszeichen malen  						e.Graphics.DrawRectangle(blackPen' 0' 1 + (row * totalRowHeight)' rowHeight' rowHeight);  						e.Graphics.DrawLine(blackPen' 2' 1 + (row * totalRowHeight) + rowHeight / 2' rowHeight - 2' 1 + (row * totalRowHeight) + rowHeight / 2);  						e.Graphics.DrawLine(blackPen' rowHeight / 2' 1 + (row * totalRowHeight) + 2' rowHeight / 2' 1 + (row * totalRowHeight) + rowHeight - 2);  						}  					// aufgefaltete Gruppe zeichnen  					else  						{  						if (tg == m_selectedGroup)  							{  							e.Graphics.FillRectangle(backgroundBrush' 0' 1 + (row * totalRowHeight)' ClientSize.Width' (1 + tg.entries.Count) * totalRowHeight);  							}    						// Gruppenname zeichnen  						e.Graphics.DrawString(tg.title' calibriFont' blackBrush' new PointF(totalRowHeight + 3' row * totalRowHeight));    						// Minuszeichen malen  						e.Graphics.DrawRectangle(blackPen' 0' 1 + (row * totalRowHeight)' rowHeight' rowHeight);  						e.Graphics.DrawLine(blackPen' 2' 1 + (row * totalRowHeight) + rowHeight / 2' rowHeight - 2' 1 + (row * totalRowHeight) + rowHeight / 2);    						// vertikale Linie unter Minuszeichen malen  						if (tg.entries.Count > 0)  							e.Graphics.DrawLine(blackPen' rowHeight / 2' row * totalRowHeight + totalRowHeight' rowHeight / 2' (row + tg.entries.Count) * totalRowHeight + totalRowHeight / 2);      						// Entries zeichnen  						foreach (TimelineEntry te in tg.entries)  							{  							row++;    							// horizontale Linie links malen  							e.Graphics.DrawLine(blackPen' totalRowHeight / 2' row * totalRowHeight + totalRowHeight / 2' totalRowHeight / 2 + totalRowHeight / 4' row * totalRowHeight + totalRowHeight / 2);    							// Balken malen  							if (te == selectedEntry)  								{  								e.Graphics.DrawRectangle(dottedPen' totalRowHeight' 1 + (row * totalRowHeight)' maxWidth' rowHeight);  								}  							else  								{  								e.Graphics.DrawRectangle(blackPen' totalRowHeight' 1 + (row * totalRowHeight)' maxWidth' rowHeight);  								}  							e.Graphics.FillRectangle(new SolidBrush(te.color)' totalRowHeight + 1' 2 + (row * totalRowHeight)' maxWidth - 1' rowHeight - 1);    							// einzelne Events zeichnen  							foreach (TimelineEvent ev in te.events)  								{  								int startPosition = totalRowHeight + (int)Math.Round(ev.eventTime * zoom);  								int length = (int)Math.Round(ev.eventLength * zoom);  								e.Graphics.FillRectangle(new SolidBrush(ev.color)' startPosition' 2 + (row * totalRowHeight)' length' rowHeight - 1);  								e.Graphics.DrawLine(blackPen' startPosition' 2 + (row * totalRowHeight)' startPosition' totalRowHeight - 2 + (row * totalRowHeight));  								e.Graphics.DrawLine(blackPen' startPosition + length' 2 + (row * totalRowHeight)' startPosition + length' totalRowHeight - 2 + (row * totalRowHeight));  								}    							e.Graphics.DrawString(te.name' calibriFont' blackBrush' new PointF(totalRowHeight + 3' row * totalRowHeight));  							}  						}    					row++;  					}        				// Lineal zeichnen  				dottedPen.DashStyle = System.Drawing.Drawing2D.DashStyle.Dash;    				e.Graphics.DrawLine(blackPen' totalRowHeight' this.ClientSize.Height - 1' this.Width' this.Height - 1);    				for (int i = 0; i <= steuerung.maxTime / 10; i++)  					{  					e.Graphics.DrawLine(blackPen' totalRowHeight + i * 10 * zoom' this.Height - 1' totalRowHeight + i * 10 * zoom' this.Height - 7);  					e.Graphics.DrawString((i * 10).ToString()' calibriFont' blackBrush' new PointF(totalRowHeight + (i * 10 * zoom) - 8' this.Height - 18));  					}    				// aktuelle Zeit zeichnen  				e.Graphics.DrawLine(dottedPen' totalRowHeight + (int)Math.Round(timelineBarTime * zoom)' 0' totalRowHeight + (int)Math.Round(timelineBarTime * zoom)' Height);  				}
Magic Number,CityTrafficSimulator,TimelineControl,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TimelineControl.cs,TimelineControl_Paint,The following statement contains a magic number: if (steuerung != null)  				{  				int maxWidth = (int)Math.Round(m_zoom * steuerung.maxTime);    				int row = 0;  				foreach (TimelineGroup tg in steuerung.groups)  					{  					// zusammengefaltete Gruppe zeichnen  					if (tg.collapsed)  						{  						if (tg == m_selectedGroup)  							{  							e.Graphics.FillRectangle(backgroundBrush' 0' 1 + (row * totalRowHeight)' ClientSize.Width' totalRowHeight);  							}    						// Gruppenname zeichnen  						e.Graphics.DrawString(tg.title' calibriFont' blackBrush' new PointF(totalRowHeight + 3' row * totalRowHeight));    						// Pluszeichen malen  						e.Graphics.DrawRectangle(blackPen' 0' 1 + (row * totalRowHeight)' rowHeight' rowHeight);  						e.Graphics.DrawLine(blackPen' 2' 1 + (row * totalRowHeight) + rowHeight / 2' rowHeight - 2' 1 + (row * totalRowHeight) + rowHeight / 2);  						e.Graphics.DrawLine(blackPen' rowHeight / 2' 1 + (row * totalRowHeight) + 2' rowHeight / 2' 1 + (row * totalRowHeight) + rowHeight - 2);  						}  					// aufgefaltete Gruppe zeichnen  					else  						{  						if (tg == m_selectedGroup)  							{  							e.Graphics.FillRectangle(backgroundBrush' 0' 1 + (row * totalRowHeight)' ClientSize.Width' (1 + tg.entries.Count) * totalRowHeight);  							}    						// Gruppenname zeichnen  						e.Graphics.DrawString(tg.title' calibriFont' blackBrush' new PointF(totalRowHeight + 3' row * totalRowHeight));    						// Minuszeichen malen  						e.Graphics.DrawRectangle(blackPen' 0' 1 + (row * totalRowHeight)' rowHeight' rowHeight);  						e.Graphics.DrawLine(blackPen' 2' 1 + (row * totalRowHeight) + rowHeight / 2' rowHeight - 2' 1 + (row * totalRowHeight) + rowHeight / 2);    						// vertikale Linie unter Minuszeichen malen  						if (tg.entries.Count > 0)  							e.Graphics.DrawLine(blackPen' rowHeight / 2' row * totalRowHeight + totalRowHeight' rowHeight / 2' (row + tg.entries.Count) * totalRowHeight + totalRowHeight / 2);      						// Entries zeichnen  						foreach (TimelineEntry te in tg.entries)  							{  							row++;    							// horizontale Linie links malen  							e.Graphics.DrawLine(blackPen' totalRowHeight / 2' row * totalRowHeight + totalRowHeight / 2' totalRowHeight / 2 + totalRowHeight / 4' row * totalRowHeight + totalRowHeight / 2);    							// Balken malen  							if (te == selectedEntry)  								{  								e.Graphics.DrawRectangle(dottedPen' totalRowHeight' 1 + (row * totalRowHeight)' maxWidth' rowHeight);  								}  							else  								{  								e.Graphics.DrawRectangle(blackPen' totalRowHeight' 1 + (row * totalRowHeight)' maxWidth' rowHeight);  								}  							e.Graphics.FillRectangle(new SolidBrush(te.color)' totalRowHeight + 1' 2 + (row * totalRowHeight)' maxWidth - 1' rowHeight - 1);    							// einzelne Events zeichnen  							foreach (TimelineEvent ev in te.events)  								{  								int startPosition = totalRowHeight + (int)Math.Round(ev.eventTime * zoom);  								int length = (int)Math.Round(ev.eventLength * zoom);  								e.Graphics.FillRectangle(new SolidBrush(ev.color)' startPosition' 2 + (row * totalRowHeight)' length' rowHeight - 1);  								e.Graphics.DrawLine(blackPen' startPosition' 2 + (row * totalRowHeight)' startPosition' totalRowHeight - 2 + (row * totalRowHeight));  								e.Graphics.DrawLine(blackPen' startPosition + length' 2 + (row * totalRowHeight)' startPosition + length' totalRowHeight - 2 + (row * totalRowHeight));  								}    							e.Graphics.DrawString(te.name' calibriFont' blackBrush' new PointF(totalRowHeight + 3' row * totalRowHeight));  							}  						}    					row++;  					}        				// Lineal zeichnen  				dottedPen.DashStyle = System.Drawing.Drawing2D.DashStyle.Dash;    				e.Graphics.DrawLine(blackPen' totalRowHeight' this.ClientSize.Height - 1' this.Width' this.Height - 1);    				for (int i = 0; i <= steuerung.maxTime / 10; i++)  					{  					e.Graphics.DrawLine(blackPen' totalRowHeight + i * 10 * zoom' this.Height - 1' totalRowHeight + i * 10 * zoom' this.Height - 7);  					e.Graphics.DrawString((i * 10).ToString()' calibriFont' blackBrush' new PointF(totalRowHeight + (i * 10 * zoom) - 8' this.Height - 18));  					}    				// aktuelle Zeit zeichnen  				e.Graphics.DrawLine(dottedPen' totalRowHeight + (int)Math.Round(timelineBarTime * zoom)' 0' totalRowHeight + (int)Math.Round(timelineBarTime * zoom)' Height);  				}
Magic Number,CityTrafficSimulator,TimelineControl,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TimelineControl.cs,TimelineControl_Paint,The following statement contains a magic number: if (steuerung != null)  				{  				int maxWidth = (int)Math.Round(m_zoom * steuerung.maxTime);    				int row = 0;  				foreach (TimelineGroup tg in steuerung.groups)  					{  					// zusammengefaltete Gruppe zeichnen  					if (tg.collapsed)  						{  						if (tg == m_selectedGroup)  							{  							e.Graphics.FillRectangle(backgroundBrush' 0' 1 + (row * totalRowHeight)' ClientSize.Width' totalRowHeight);  							}    						// Gruppenname zeichnen  						e.Graphics.DrawString(tg.title' calibriFont' blackBrush' new PointF(totalRowHeight + 3' row * totalRowHeight));    						// Pluszeichen malen  						e.Graphics.DrawRectangle(blackPen' 0' 1 + (row * totalRowHeight)' rowHeight' rowHeight);  						e.Graphics.DrawLine(blackPen' 2' 1 + (row * totalRowHeight) + rowHeight / 2' rowHeight - 2' 1 + (row * totalRowHeight) + rowHeight / 2);  						e.Graphics.DrawLine(blackPen' rowHeight / 2' 1 + (row * totalRowHeight) + 2' rowHeight / 2' 1 + (row * totalRowHeight) + rowHeight - 2);  						}  					// aufgefaltete Gruppe zeichnen  					else  						{  						if (tg == m_selectedGroup)  							{  							e.Graphics.FillRectangle(backgroundBrush' 0' 1 + (row * totalRowHeight)' ClientSize.Width' (1 + tg.entries.Count) * totalRowHeight);  							}    						// Gruppenname zeichnen  						e.Graphics.DrawString(tg.title' calibriFont' blackBrush' new PointF(totalRowHeight + 3' row * totalRowHeight));    						// Minuszeichen malen  						e.Graphics.DrawRectangle(blackPen' 0' 1 + (row * totalRowHeight)' rowHeight' rowHeight);  						e.Graphics.DrawLine(blackPen' 2' 1 + (row * totalRowHeight) + rowHeight / 2' rowHeight - 2' 1 + (row * totalRowHeight) + rowHeight / 2);    						// vertikale Linie unter Minuszeichen malen  						if (tg.entries.Count > 0)  							e.Graphics.DrawLine(blackPen' rowHeight / 2' row * totalRowHeight + totalRowHeight' rowHeight / 2' (row + tg.entries.Count) * totalRowHeight + totalRowHeight / 2);      						// Entries zeichnen  						foreach (TimelineEntry te in tg.entries)  							{  							row++;    							// horizontale Linie links malen  							e.Graphics.DrawLine(blackPen' totalRowHeight / 2' row * totalRowHeight + totalRowHeight / 2' totalRowHeight / 2 + totalRowHeight / 4' row * totalRowHeight + totalRowHeight / 2);    							// Balken malen  							if (te == selectedEntry)  								{  								e.Graphics.DrawRectangle(dottedPen' totalRowHeight' 1 + (row * totalRowHeight)' maxWidth' rowHeight);  								}  							else  								{  								e.Graphics.DrawRectangle(blackPen' totalRowHeight' 1 + (row * totalRowHeight)' maxWidth' rowHeight);  								}  							e.Graphics.FillRectangle(new SolidBrush(te.color)' totalRowHeight + 1' 2 + (row * totalRowHeight)' maxWidth - 1' rowHeight - 1);    							// einzelne Events zeichnen  							foreach (TimelineEvent ev in te.events)  								{  								int startPosition = totalRowHeight + (int)Math.Round(ev.eventTime * zoom);  								int length = (int)Math.Round(ev.eventLength * zoom);  								e.Graphics.FillRectangle(new SolidBrush(ev.color)' startPosition' 2 + (row * totalRowHeight)' length' rowHeight - 1);  								e.Graphics.DrawLine(blackPen' startPosition' 2 + (row * totalRowHeight)' startPosition' totalRowHeight - 2 + (row * totalRowHeight));  								e.Graphics.DrawLine(blackPen' startPosition + length' 2 + (row * totalRowHeight)' startPosition + length' totalRowHeight - 2 + (row * totalRowHeight));  								}    							e.Graphics.DrawString(te.name' calibriFont' blackBrush' new PointF(totalRowHeight + 3' row * totalRowHeight));  							}  						}    					row++;  					}        				// Lineal zeichnen  				dottedPen.DashStyle = System.Drawing.Drawing2D.DashStyle.Dash;    				e.Graphics.DrawLine(blackPen' totalRowHeight' this.ClientSize.Height - 1' this.Width' this.Height - 1);    				for (int i = 0; i <= steuerung.maxTime / 10; i++)  					{  					e.Graphics.DrawLine(blackPen' totalRowHeight + i * 10 * zoom' this.Height - 1' totalRowHeight + i * 10 * zoom' this.Height - 7);  					e.Graphics.DrawString((i * 10).ToString()' calibriFont' blackBrush' new PointF(totalRowHeight + (i * 10 * zoom) - 8' this.Height - 18));  					}    				// aktuelle Zeit zeichnen  				e.Graphics.DrawLine(dottedPen' totalRowHeight + (int)Math.Round(timelineBarTime * zoom)' 0' totalRowHeight + (int)Math.Round(timelineBarTime * zoom)' Height);  				}
Magic Number,CityTrafficSimulator,TimelineControl,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TimelineControl.cs,TimelineControl_Paint,The following statement contains a magic number: if (steuerung != null)  				{  				int maxWidth = (int)Math.Round(m_zoom * steuerung.maxTime);    				int row = 0;  				foreach (TimelineGroup tg in steuerung.groups)  					{  					// zusammengefaltete Gruppe zeichnen  					if (tg.collapsed)  						{  						if (tg == m_selectedGroup)  							{  							e.Graphics.FillRectangle(backgroundBrush' 0' 1 + (row * totalRowHeight)' ClientSize.Width' totalRowHeight);  							}    						// Gruppenname zeichnen  						e.Graphics.DrawString(tg.title' calibriFont' blackBrush' new PointF(totalRowHeight + 3' row * totalRowHeight));    						// Pluszeichen malen  						e.Graphics.DrawRectangle(blackPen' 0' 1 + (row * totalRowHeight)' rowHeight' rowHeight);  						e.Graphics.DrawLine(blackPen' 2' 1 + (row * totalRowHeight) + rowHeight / 2' rowHeight - 2' 1 + (row * totalRowHeight) + rowHeight / 2);  						e.Graphics.DrawLine(blackPen' rowHeight / 2' 1 + (row * totalRowHeight) + 2' rowHeight / 2' 1 + (row * totalRowHeight) + rowHeight - 2);  						}  					// aufgefaltete Gruppe zeichnen  					else  						{  						if (tg == m_selectedGroup)  							{  							e.Graphics.FillRectangle(backgroundBrush' 0' 1 + (row * totalRowHeight)' ClientSize.Width' (1 + tg.entries.Count) * totalRowHeight);  							}    						// Gruppenname zeichnen  						e.Graphics.DrawString(tg.title' calibriFont' blackBrush' new PointF(totalRowHeight + 3' row * totalRowHeight));    						// Minuszeichen malen  						e.Graphics.DrawRectangle(blackPen' 0' 1 + (row * totalRowHeight)' rowHeight' rowHeight);  						e.Graphics.DrawLine(blackPen' 2' 1 + (row * totalRowHeight) + rowHeight / 2' rowHeight - 2' 1 + (row * totalRowHeight) + rowHeight / 2);    						// vertikale Linie unter Minuszeichen malen  						if (tg.entries.Count > 0)  							e.Graphics.DrawLine(blackPen' rowHeight / 2' row * totalRowHeight + totalRowHeight' rowHeight / 2' (row + tg.entries.Count) * totalRowHeight + totalRowHeight / 2);      						// Entries zeichnen  						foreach (TimelineEntry te in tg.entries)  							{  							row++;    							// horizontale Linie links malen  							e.Graphics.DrawLine(blackPen' totalRowHeight / 2' row * totalRowHeight + totalRowHeight / 2' totalRowHeight / 2 + totalRowHeight / 4' row * totalRowHeight + totalRowHeight / 2);    							// Balken malen  							if (te == selectedEntry)  								{  								e.Graphics.DrawRectangle(dottedPen' totalRowHeight' 1 + (row * totalRowHeight)' maxWidth' rowHeight);  								}  							else  								{  								e.Graphics.DrawRectangle(blackPen' totalRowHeight' 1 + (row * totalRowHeight)' maxWidth' rowHeight);  								}  							e.Graphics.FillRectangle(new SolidBrush(te.color)' totalRowHeight + 1' 2 + (row * totalRowHeight)' maxWidth - 1' rowHeight - 1);    							// einzelne Events zeichnen  							foreach (TimelineEvent ev in te.events)  								{  								int startPosition = totalRowHeight + (int)Math.Round(ev.eventTime * zoom);  								int length = (int)Math.Round(ev.eventLength * zoom);  								e.Graphics.FillRectangle(new SolidBrush(ev.color)' startPosition' 2 + (row * totalRowHeight)' length' rowHeight - 1);  								e.Graphics.DrawLine(blackPen' startPosition' 2 + (row * totalRowHeight)' startPosition' totalRowHeight - 2 + (row * totalRowHeight));  								e.Graphics.DrawLine(blackPen' startPosition + length' 2 + (row * totalRowHeight)' startPosition + length' totalRowHeight - 2 + (row * totalRowHeight));  								}    							e.Graphics.DrawString(te.name' calibriFont' blackBrush' new PointF(totalRowHeight + 3' row * totalRowHeight));  							}  						}    					row++;  					}        				// Lineal zeichnen  				dottedPen.DashStyle = System.Drawing.Drawing2D.DashStyle.Dash;    				e.Graphics.DrawLine(blackPen' totalRowHeight' this.ClientSize.Height - 1' this.Width' this.Height - 1);    				for (int i = 0; i <= steuerung.maxTime / 10; i++)  					{  					e.Graphics.DrawLine(blackPen' totalRowHeight + i * 10 * zoom' this.Height - 1' totalRowHeight + i * 10 * zoom' this.Height - 7);  					e.Graphics.DrawString((i * 10).ToString()' calibriFont' blackBrush' new PointF(totalRowHeight + (i * 10 * zoom) - 8' this.Height - 18));  					}    				// aktuelle Zeit zeichnen  				e.Graphics.DrawLine(dottedPen' totalRowHeight + (int)Math.Round(timelineBarTime * zoom)' 0' totalRowHeight + (int)Math.Round(timelineBarTime * zoom)' Height);  				}
Magic Number,CityTrafficSimulator,TimelineControl,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TimelineControl.cs,TimelineControl_Paint,The following statement contains a magic number: if (steuerung != null)  				{  				int maxWidth = (int)Math.Round(m_zoom * steuerung.maxTime);    				int row = 0;  				foreach (TimelineGroup tg in steuerung.groups)  					{  					// zusammengefaltete Gruppe zeichnen  					if (tg.collapsed)  						{  						if (tg == m_selectedGroup)  							{  							e.Graphics.FillRectangle(backgroundBrush' 0' 1 + (row * totalRowHeight)' ClientSize.Width' totalRowHeight);  							}    						// Gruppenname zeichnen  						e.Graphics.DrawString(tg.title' calibriFont' blackBrush' new PointF(totalRowHeight + 3' row * totalRowHeight));    						// Pluszeichen malen  						e.Graphics.DrawRectangle(blackPen' 0' 1 + (row * totalRowHeight)' rowHeight' rowHeight);  						e.Graphics.DrawLine(blackPen' 2' 1 + (row * totalRowHeight) + rowHeight / 2' rowHeight - 2' 1 + (row * totalRowHeight) + rowHeight / 2);  						e.Graphics.DrawLine(blackPen' rowHeight / 2' 1 + (row * totalRowHeight) + 2' rowHeight / 2' 1 + (row * totalRowHeight) + rowHeight - 2);  						}  					// aufgefaltete Gruppe zeichnen  					else  						{  						if (tg == m_selectedGroup)  							{  							e.Graphics.FillRectangle(backgroundBrush' 0' 1 + (row * totalRowHeight)' ClientSize.Width' (1 + tg.entries.Count) * totalRowHeight);  							}    						// Gruppenname zeichnen  						e.Graphics.DrawString(tg.title' calibriFont' blackBrush' new PointF(totalRowHeight + 3' row * totalRowHeight));    						// Minuszeichen malen  						e.Graphics.DrawRectangle(blackPen' 0' 1 + (row * totalRowHeight)' rowHeight' rowHeight);  						e.Graphics.DrawLine(blackPen' 2' 1 + (row * totalRowHeight) + rowHeight / 2' rowHeight - 2' 1 + (row * totalRowHeight) + rowHeight / 2);    						// vertikale Linie unter Minuszeichen malen  						if (tg.entries.Count > 0)  							e.Graphics.DrawLine(blackPen' rowHeight / 2' row * totalRowHeight + totalRowHeight' rowHeight / 2' (row + tg.entries.Count) * totalRowHeight + totalRowHeight / 2);      						// Entries zeichnen  						foreach (TimelineEntry te in tg.entries)  							{  							row++;    							// horizontale Linie links malen  							e.Graphics.DrawLine(blackPen' totalRowHeight / 2' row * totalRowHeight + totalRowHeight / 2' totalRowHeight / 2 + totalRowHeight / 4' row * totalRowHeight + totalRowHeight / 2);    							// Balken malen  							if (te == selectedEntry)  								{  								e.Graphics.DrawRectangle(dottedPen' totalRowHeight' 1 + (row * totalRowHeight)' maxWidth' rowHeight);  								}  							else  								{  								e.Graphics.DrawRectangle(blackPen' totalRowHeight' 1 + (row * totalRowHeight)' maxWidth' rowHeight);  								}  							e.Graphics.FillRectangle(new SolidBrush(te.color)' totalRowHeight + 1' 2 + (row * totalRowHeight)' maxWidth - 1' rowHeight - 1);    							// einzelne Events zeichnen  							foreach (TimelineEvent ev in te.events)  								{  								int startPosition = totalRowHeight + (int)Math.Round(ev.eventTime * zoom);  								int length = (int)Math.Round(ev.eventLength * zoom);  								e.Graphics.FillRectangle(new SolidBrush(ev.color)' startPosition' 2 + (row * totalRowHeight)' length' rowHeight - 1);  								e.Graphics.DrawLine(blackPen' startPosition' 2 + (row * totalRowHeight)' startPosition' totalRowHeight - 2 + (row * totalRowHeight));  								e.Graphics.DrawLine(blackPen' startPosition + length' 2 + (row * totalRowHeight)' startPosition + length' totalRowHeight - 2 + (row * totalRowHeight));  								}    							e.Graphics.DrawString(te.name' calibriFont' blackBrush' new PointF(totalRowHeight + 3' row * totalRowHeight));  							}  						}    					row++;  					}        				// Lineal zeichnen  				dottedPen.DashStyle = System.Drawing.Drawing2D.DashStyle.Dash;    				e.Graphics.DrawLine(blackPen' totalRowHeight' this.ClientSize.Height - 1' this.Width' this.Height - 1);    				for (int i = 0; i <= steuerung.maxTime / 10; i++)  					{  					e.Graphics.DrawLine(blackPen' totalRowHeight + i * 10 * zoom' this.Height - 1' totalRowHeight + i * 10 * zoom' this.Height - 7);  					e.Graphics.DrawString((i * 10).ToString()' calibriFont' blackBrush' new PointF(totalRowHeight + (i * 10 * zoom) - 8' this.Height - 18));  					}    				// aktuelle Zeit zeichnen  				e.Graphics.DrawLine(dottedPen' totalRowHeight + (int)Math.Round(timelineBarTime * zoom)' 0' totalRowHeight + (int)Math.Round(timelineBarTime * zoom)' Height);  				}
Magic Number,CityTrafficSimulator,TimelineControl,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TimelineControl.cs,TimelineControl_Paint,The following statement contains a magic number: if (steuerung != null)  				{  				int maxWidth = (int)Math.Round(m_zoom * steuerung.maxTime);    				int row = 0;  				foreach (TimelineGroup tg in steuerung.groups)  					{  					// zusammengefaltete Gruppe zeichnen  					if (tg.collapsed)  						{  						if (tg == m_selectedGroup)  							{  							e.Graphics.FillRectangle(backgroundBrush' 0' 1 + (row * totalRowHeight)' ClientSize.Width' totalRowHeight);  							}    						// Gruppenname zeichnen  						e.Graphics.DrawString(tg.title' calibriFont' blackBrush' new PointF(totalRowHeight + 3' row * totalRowHeight));    						// Pluszeichen malen  						e.Graphics.DrawRectangle(blackPen' 0' 1 + (row * totalRowHeight)' rowHeight' rowHeight);  						e.Graphics.DrawLine(blackPen' 2' 1 + (row * totalRowHeight) + rowHeight / 2' rowHeight - 2' 1 + (row * totalRowHeight) + rowHeight / 2);  						e.Graphics.DrawLine(blackPen' rowHeight / 2' 1 + (row * totalRowHeight) + 2' rowHeight / 2' 1 + (row * totalRowHeight) + rowHeight - 2);  						}  					// aufgefaltete Gruppe zeichnen  					else  						{  						if (tg == m_selectedGroup)  							{  							e.Graphics.FillRectangle(backgroundBrush' 0' 1 + (row * totalRowHeight)' ClientSize.Width' (1 + tg.entries.Count) * totalRowHeight);  							}    						// Gruppenname zeichnen  						e.Graphics.DrawString(tg.title' calibriFont' blackBrush' new PointF(totalRowHeight + 3' row * totalRowHeight));    						// Minuszeichen malen  						e.Graphics.DrawRectangle(blackPen' 0' 1 + (row * totalRowHeight)' rowHeight' rowHeight);  						e.Graphics.DrawLine(blackPen' 2' 1 + (row * totalRowHeight) + rowHeight / 2' rowHeight - 2' 1 + (row * totalRowHeight) + rowHeight / 2);    						// vertikale Linie unter Minuszeichen malen  						if (tg.entries.Count > 0)  							e.Graphics.DrawLine(blackPen' rowHeight / 2' row * totalRowHeight + totalRowHeight' rowHeight / 2' (row + tg.entries.Count) * totalRowHeight + totalRowHeight / 2);      						// Entries zeichnen  						foreach (TimelineEntry te in tg.entries)  							{  							row++;    							// horizontale Linie links malen  							e.Graphics.DrawLine(blackPen' totalRowHeight / 2' row * totalRowHeight + totalRowHeight / 2' totalRowHeight / 2 + totalRowHeight / 4' row * totalRowHeight + totalRowHeight / 2);    							// Balken malen  							if (te == selectedEntry)  								{  								e.Graphics.DrawRectangle(dottedPen' totalRowHeight' 1 + (row * totalRowHeight)' maxWidth' rowHeight);  								}  							else  								{  								e.Graphics.DrawRectangle(blackPen' totalRowHeight' 1 + (row * totalRowHeight)' maxWidth' rowHeight);  								}  							e.Graphics.FillRectangle(new SolidBrush(te.color)' totalRowHeight + 1' 2 + (row * totalRowHeight)' maxWidth - 1' rowHeight - 1);    							// einzelne Events zeichnen  							foreach (TimelineEvent ev in te.events)  								{  								int startPosition = totalRowHeight + (int)Math.Round(ev.eventTime * zoom);  								int length = (int)Math.Round(ev.eventLength * zoom);  								e.Graphics.FillRectangle(new SolidBrush(ev.color)' startPosition' 2 + (row * totalRowHeight)' length' rowHeight - 1);  								e.Graphics.DrawLine(blackPen' startPosition' 2 + (row * totalRowHeight)' startPosition' totalRowHeight - 2 + (row * totalRowHeight));  								e.Graphics.DrawLine(blackPen' startPosition + length' 2 + (row * totalRowHeight)' startPosition + length' totalRowHeight - 2 + (row * totalRowHeight));  								}    							e.Graphics.DrawString(te.name' calibriFont' blackBrush' new PointF(totalRowHeight + 3' row * totalRowHeight));  							}  						}    					row++;  					}        				// Lineal zeichnen  				dottedPen.DashStyle = System.Drawing.Drawing2D.DashStyle.Dash;    				e.Graphics.DrawLine(blackPen' totalRowHeight' this.ClientSize.Height - 1' this.Width' this.Height - 1);    				for (int i = 0; i <= steuerung.maxTime / 10; i++)  					{  					e.Graphics.DrawLine(blackPen' totalRowHeight + i * 10 * zoom' this.Height - 1' totalRowHeight + i * 10 * zoom' this.Height - 7);  					e.Graphics.DrawString((i * 10).ToString()' calibriFont' blackBrush' new PointF(totalRowHeight + (i * 10 * zoom) - 8' this.Height - 18));  					}    				// aktuelle Zeit zeichnen  				e.Graphics.DrawLine(dottedPen' totalRowHeight + (int)Math.Round(timelineBarTime * zoom)' 0' totalRowHeight + (int)Math.Round(timelineBarTime * zoom)' Height);  				}
Magic Number,CityTrafficSimulator,TimelineControl,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TimelineControl.cs,TimelineControl_Paint,The following statement contains a magic number: if (steuerung != null)  				{  				int maxWidth = (int)Math.Round(m_zoom * steuerung.maxTime);    				int row = 0;  				foreach (TimelineGroup tg in steuerung.groups)  					{  					// zusammengefaltete Gruppe zeichnen  					if (tg.collapsed)  						{  						if (tg == m_selectedGroup)  							{  							e.Graphics.FillRectangle(backgroundBrush' 0' 1 + (row * totalRowHeight)' ClientSize.Width' totalRowHeight);  							}    						// Gruppenname zeichnen  						e.Graphics.DrawString(tg.title' calibriFont' blackBrush' new PointF(totalRowHeight + 3' row * totalRowHeight));    						// Pluszeichen malen  						e.Graphics.DrawRectangle(blackPen' 0' 1 + (row * totalRowHeight)' rowHeight' rowHeight);  						e.Graphics.DrawLine(blackPen' 2' 1 + (row * totalRowHeight) + rowHeight / 2' rowHeight - 2' 1 + (row * totalRowHeight) + rowHeight / 2);  						e.Graphics.DrawLine(blackPen' rowHeight / 2' 1 + (row * totalRowHeight) + 2' rowHeight / 2' 1 + (row * totalRowHeight) + rowHeight - 2);  						}  					// aufgefaltete Gruppe zeichnen  					else  						{  						if (tg == m_selectedGroup)  							{  							e.Graphics.FillRectangle(backgroundBrush' 0' 1 + (row * totalRowHeight)' ClientSize.Width' (1 + tg.entries.Count) * totalRowHeight);  							}    						// Gruppenname zeichnen  						e.Graphics.DrawString(tg.title' calibriFont' blackBrush' new PointF(totalRowHeight + 3' row * totalRowHeight));    						// Minuszeichen malen  						e.Graphics.DrawRectangle(blackPen' 0' 1 + (row * totalRowHeight)' rowHeight' rowHeight);  						e.Graphics.DrawLine(blackPen' 2' 1 + (row * totalRowHeight) + rowHeight / 2' rowHeight - 2' 1 + (row * totalRowHeight) + rowHeight / 2);    						// vertikale Linie unter Minuszeichen malen  						if (tg.entries.Count > 0)  							e.Graphics.DrawLine(blackPen' rowHeight / 2' row * totalRowHeight + totalRowHeight' rowHeight / 2' (row + tg.entries.Count) * totalRowHeight + totalRowHeight / 2);      						// Entries zeichnen  						foreach (TimelineEntry te in tg.entries)  							{  							row++;    							// horizontale Linie links malen  							e.Graphics.DrawLine(blackPen' totalRowHeight / 2' row * totalRowHeight + totalRowHeight / 2' totalRowHeight / 2 + totalRowHeight / 4' row * totalRowHeight + totalRowHeight / 2);    							// Balken malen  							if (te == selectedEntry)  								{  								e.Graphics.DrawRectangle(dottedPen' totalRowHeight' 1 + (row * totalRowHeight)' maxWidth' rowHeight);  								}  							else  								{  								e.Graphics.DrawRectangle(blackPen' totalRowHeight' 1 + (row * totalRowHeight)' maxWidth' rowHeight);  								}  							e.Graphics.FillRectangle(new SolidBrush(te.color)' totalRowHeight + 1' 2 + (row * totalRowHeight)' maxWidth - 1' rowHeight - 1);    							// einzelne Events zeichnen  							foreach (TimelineEvent ev in te.events)  								{  								int startPosition = totalRowHeight + (int)Math.Round(ev.eventTime * zoom);  								int length = (int)Math.Round(ev.eventLength * zoom);  								e.Graphics.FillRectangle(new SolidBrush(ev.color)' startPosition' 2 + (row * totalRowHeight)' length' rowHeight - 1);  								e.Graphics.DrawLine(blackPen' startPosition' 2 + (row * totalRowHeight)' startPosition' totalRowHeight - 2 + (row * totalRowHeight));  								e.Graphics.DrawLine(blackPen' startPosition + length' 2 + (row * totalRowHeight)' startPosition + length' totalRowHeight - 2 + (row * totalRowHeight));  								}    							e.Graphics.DrawString(te.name' calibriFont' blackBrush' new PointF(totalRowHeight + 3' row * totalRowHeight));  							}  						}    					row++;  					}        				// Lineal zeichnen  				dottedPen.DashStyle = System.Drawing.Drawing2D.DashStyle.Dash;    				e.Graphics.DrawLine(blackPen' totalRowHeight' this.ClientSize.Height - 1' this.Width' this.Height - 1);    				for (int i = 0; i <= steuerung.maxTime / 10; i++)  					{  					e.Graphics.DrawLine(blackPen' totalRowHeight + i * 10 * zoom' this.Height - 1' totalRowHeight + i * 10 * zoom' this.Height - 7);  					e.Graphics.DrawString((i * 10).ToString()' calibriFont' blackBrush' new PointF(totalRowHeight + (i * 10 * zoom) - 8' this.Height - 18));  					}    				// aktuelle Zeit zeichnen  				e.Graphics.DrawLine(dottedPen' totalRowHeight + (int)Math.Round(timelineBarTime * zoom)' 0' totalRowHeight + (int)Math.Round(timelineBarTime * zoom)' Height);  				}
Magic Number,CityTrafficSimulator,TimelineControl,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TimelineControl.cs,TimelineControl_Paint,The following statement contains a magic number: if (steuerung != null)  				{  				int maxWidth = (int)Math.Round(m_zoom * steuerung.maxTime);    				int row = 0;  				foreach (TimelineGroup tg in steuerung.groups)  					{  					// zusammengefaltete Gruppe zeichnen  					if (tg.collapsed)  						{  						if (tg == m_selectedGroup)  							{  							e.Graphics.FillRectangle(backgroundBrush' 0' 1 + (row * totalRowHeight)' ClientSize.Width' totalRowHeight);  							}    						// Gruppenname zeichnen  						e.Graphics.DrawString(tg.title' calibriFont' blackBrush' new PointF(totalRowHeight + 3' row * totalRowHeight));    						// Pluszeichen malen  						e.Graphics.DrawRectangle(blackPen' 0' 1 + (row * totalRowHeight)' rowHeight' rowHeight);  						e.Graphics.DrawLine(blackPen' 2' 1 + (row * totalRowHeight) + rowHeight / 2' rowHeight - 2' 1 + (row * totalRowHeight) + rowHeight / 2);  						e.Graphics.DrawLine(blackPen' rowHeight / 2' 1 + (row * totalRowHeight) + 2' rowHeight / 2' 1 + (row * totalRowHeight) + rowHeight - 2);  						}  					// aufgefaltete Gruppe zeichnen  					else  						{  						if (tg == m_selectedGroup)  							{  							e.Graphics.FillRectangle(backgroundBrush' 0' 1 + (row * totalRowHeight)' ClientSize.Width' (1 + tg.entries.Count) * totalRowHeight);  							}    						// Gruppenname zeichnen  						e.Graphics.DrawString(tg.title' calibriFont' blackBrush' new PointF(totalRowHeight + 3' row * totalRowHeight));    						// Minuszeichen malen  						e.Graphics.DrawRectangle(blackPen' 0' 1 + (row * totalRowHeight)' rowHeight' rowHeight);  						e.Graphics.DrawLine(blackPen' 2' 1 + (row * totalRowHeight) + rowHeight / 2' rowHeight - 2' 1 + (row * totalRowHeight) + rowHeight / 2);    						// vertikale Linie unter Minuszeichen malen  						if (tg.entries.Count > 0)  							e.Graphics.DrawLine(blackPen' rowHeight / 2' row * totalRowHeight + totalRowHeight' rowHeight / 2' (row + tg.entries.Count) * totalRowHeight + totalRowHeight / 2);      						// Entries zeichnen  						foreach (TimelineEntry te in tg.entries)  							{  							row++;    							// horizontale Linie links malen  							e.Graphics.DrawLine(blackPen' totalRowHeight / 2' row * totalRowHeight + totalRowHeight / 2' totalRowHeight / 2 + totalRowHeight / 4' row * totalRowHeight + totalRowHeight / 2);    							// Balken malen  							if (te == selectedEntry)  								{  								e.Graphics.DrawRectangle(dottedPen' totalRowHeight' 1 + (row * totalRowHeight)' maxWidth' rowHeight);  								}  							else  								{  								e.Graphics.DrawRectangle(blackPen' totalRowHeight' 1 + (row * totalRowHeight)' maxWidth' rowHeight);  								}  							e.Graphics.FillRectangle(new SolidBrush(te.color)' totalRowHeight + 1' 2 + (row * totalRowHeight)' maxWidth - 1' rowHeight - 1);    							// einzelne Events zeichnen  							foreach (TimelineEvent ev in te.events)  								{  								int startPosition = totalRowHeight + (int)Math.Round(ev.eventTime * zoom);  								int length = (int)Math.Round(ev.eventLength * zoom);  								e.Graphics.FillRectangle(new SolidBrush(ev.color)' startPosition' 2 + (row * totalRowHeight)' length' rowHeight - 1);  								e.Graphics.DrawLine(blackPen' startPosition' 2 + (row * totalRowHeight)' startPosition' totalRowHeight - 2 + (row * totalRowHeight));  								e.Graphics.DrawLine(blackPen' startPosition + length' 2 + (row * totalRowHeight)' startPosition + length' totalRowHeight - 2 + (row * totalRowHeight));  								}    							e.Graphics.DrawString(te.name' calibriFont' blackBrush' new PointF(totalRowHeight + 3' row * totalRowHeight));  							}  						}    					row++;  					}        				// Lineal zeichnen  				dottedPen.DashStyle = System.Drawing.Drawing2D.DashStyle.Dash;    				e.Graphics.DrawLine(blackPen' totalRowHeight' this.ClientSize.Height - 1' this.Width' this.Height - 1);    				for (int i = 0; i <= steuerung.maxTime / 10; i++)  					{  					e.Graphics.DrawLine(blackPen' totalRowHeight + i * 10 * zoom' this.Height - 1' totalRowHeight + i * 10 * zoom' this.Height - 7);  					e.Graphics.DrawString((i * 10).ToString()' calibriFont' blackBrush' new PointF(totalRowHeight + (i * 10 * zoom) - 8' this.Height - 18));  					}    				// aktuelle Zeit zeichnen  				e.Graphics.DrawLine(dottedPen' totalRowHeight + (int)Math.Round(timelineBarTime * zoom)' 0' totalRowHeight + (int)Math.Round(timelineBarTime * zoom)' Height);  				}
Magic Number,CityTrafficSimulator,TimelineControl,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TimelineControl.cs,TimelineControl_Paint,The following statement contains a magic number: if (steuerung != null)  				{  				int maxWidth = (int)Math.Round(m_zoom * steuerung.maxTime);    				int row = 0;  				foreach (TimelineGroup tg in steuerung.groups)  					{  					// zusammengefaltete Gruppe zeichnen  					if (tg.collapsed)  						{  						if (tg == m_selectedGroup)  							{  							e.Graphics.FillRectangle(backgroundBrush' 0' 1 + (row * totalRowHeight)' ClientSize.Width' totalRowHeight);  							}    						// Gruppenname zeichnen  						e.Graphics.DrawString(tg.title' calibriFont' blackBrush' new PointF(totalRowHeight + 3' row * totalRowHeight));    						// Pluszeichen malen  						e.Graphics.DrawRectangle(blackPen' 0' 1 + (row * totalRowHeight)' rowHeight' rowHeight);  						e.Graphics.DrawLine(blackPen' 2' 1 + (row * totalRowHeight) + rowHeight / 2' rowHeight - 2' 1 + (row * totalRowHeight) + rowHeight / 2);  						e.Graphics.DrawLine(blackPen' rowHeight / 2' 1 + (row * totalRowHeight) + 2' rowHeight / 2' 1 + (row * totalRowHeight) + rowHeight - 2);  						}  					// aufgefaltete Gruppe zeichnen  					else  						{  						if (tg == m_selectedGroup)  							{  							e.Graphics.FillRectangle(backgroundBrush' 0' 1 + (row * totalRowHeight)' ClientSize.Width' (1 + tg.entries.Count) * totalRowHeight);  							}    						// Gruppenname zeichnen  						e.Graphics.DrawString(tg.title' calibriFont' blackBrush' new PointF(totalRowHeight + 3' row * totalRowHeight));    						// Minuszeichen malen  						e.Graphics.DrawRectangle(blackPen' 0' 1 + (row * totalRowHeight)' rowHeight' rowHeight);  						e.Graphics.DrawLine(blackPen' 2' 1 + (row * totalRowHeight) + rowHeight / 2' rowHeight - 2' 1 + (row * totalRowHeight) + rowHeight / 2);    						// vertikale Linie unter Minuszeichen malen  						if (tg.entries.Count > 0)  							e.Graphics.DrawLine(blackPen' rowHeight / 2' row * totalRowHeight + totalRowHeight' rowHeight / 2' (row + tg.entries.Count) * totalRowHeight + totalRowHeight / 2);      						// Entries zeichnen  						foreach (TimelineEntry te in tg.entries)  							{  							row++;    							// horizontale Linie links malen  							e.Graphics.DrawLine(blackPen' totalRowHeight / 2' row * totalRowHeight + totalRowHeight / 2' totalRowHeight / 2 + totalRowHeight / 4' row * totalRowHeight + totalRowHeight / 2);    							// Balken malen  							if (te == selectedEntry)  								{  								e.Graphics.DrawRectangle(dottedPen' totalRowHeight' 1 + (row * totalRowHeight)' maxWidth' rowHeight);  								}  							else  								{  								e.Graphics.DrawRectangle(blackPen' totalRowHeight' 1 + (row * totalRowHeight)' maxWidth' rowHeight);  								}  							e.Graphics.FillRectangle(new SolidBrush(te.color)' totalRowHeight + 1' 2 + (row * totalRowHeight)' maxWidth - 1' rowHeight - 1);    							// einzelne Events zeichnen  							foreach (TimelineEvent ev in te.events)  								{  								int startPosition = totalRowHeight + (int)Math.Round(ev.eventTime * zoom);  								int length = (int)Math.Round(ev.eventLength * zoom);  								e.Graphics.FillRectangle(new SolidBrush(ev.color)' startPosition' 2 + (row * totalRowHeight)' length' rowHeight - 1);  								e.Graphics.DrawLine(blackPen' startPosition' 2 + (row * totalRowHeight)' startPosition' totalRowHeight - 2 + (row * totalRowHeight));  								e.Graphics.DrawLine(blackPen' startPosition + length' 2 + (row * totalRowHeight)' startPosition + length' totalRowHeight - 2 + (row * totalRowHeight));  								}    							e.Graphics.DrawString(te.name' calibriFont' blackBrush' new PointF(totalRowHeight + 3' row * totalRowHeight));  							}  						}    					row++;  					}        				// Lineal zeichnen  				dottedPen.DashStyle = System.Drawing.Drawing2D.DashStyle.Dash;    				e.Graphics.DrawLine(blackPen' totalRowHeight' this.ClientSize.Height - 1' this.Width' this.Height - 1);    				for (int i = 0; i <= steuerung.maxTime / 10; i++)  					{  					e.Graphics.DrawLine(blackPen' totalRowHeight + i * 10 * zoom' this.Height - 1' totalRowHeight + i * 10 * zoom' this.Height - 7);  					e.Graphics.DrawString((i * 10).ToString()' calibriFont' blackBrush' new PointF(totalRowHeight + (i * 10 * zoom) - 8' this.Height - 18));  					}    				// aktuelle Zeit zeichnen  				e.Graphics.DrawLine(dottedPen' totalRowHeight + (int)Math.Round(timelineBarTime * zoom)' 0' totalRowHeight + (int)Math.Round(timelineBarTime * zoom)' Height);  				}
Magic Number,CityTrafficSimulator,TimelineControl,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TimelineControl.cs,TimelineControl_Paint,The following statement contains a magic number: if (steuerung != null)  				{  				int maxWidth = (int)Math.Round(m_zoom * steuerung.maxTime);    				int row = 0;  				foreach (TimelineGroup tg in steuerung.groups)  					{  					// zusammengefaltete Gruppe zeichnen  					if (tg.collapsed)  						{  						if (tg == m_selectedGroup)  							{  							e.Graphics.FillRectangle(backgroundBrush' 0' 1 + (row * totalRowHeight)' ClientSize.Width' totalRowHeight);  							}    						// Gruppenname zeichnen  						e.Graphics.DrawString(tg.title' calibriFont' blackBrush' new PointF(totalRowHeight + 3' row * totalRowHeight));    						// Pluszeichen malen  						e.Graphics.DrawRectangle(blackPen' 0' 1 + (row * totalRowHeight)' rowHeight' rowHeight);  						e.Graphics.DrawLine(blackPen' 2' 1 + (row * totalRowHeight) + rowHeight / 2' rowHeight - 2' 1 + (row * totalRowHeight) + rowHeight / 2);  						e.Graphics.DrawLine(blackPen' rowHeight / 2' 1 + (row * totalRowHeight) + 2' rowHeight / 2' 1 + (row * totalRowHeight) + rowHeight - 2);  						}  					// aufgefaltete Gruppe zeichnen  					else  						{  						if (tg == m_selectedGroup)  							{  							e.Graphics.FillRectangle(backgroundBrush' 0' 1 + (row * totalRowHeight)' ClientSize.Width' (1 + tg.entries.Count) * totalRowHeight);  							}    						// Gruppenname zeichnen  						e.Graphics.DrawString(tg.title' calibriFont' blackBrush' new PointF(totalRowHeight + 3' row * totalRowHeight));    						// Minuszeichen malen  						e.Graphics.DrawRectangle(blackPen' 0' 1 + (row * totalRowHeight)' rowHeight' rowHeight);  						e.Graphics.DrawLine(blackPen' 2' 1 + (row * totalRowHeight) + rowHeight / 2' rowHeight - 2' 1 + (row * totalRowHeight) + rowHeight / 2);    						// vertikale Linie unter Minuszeichen malen  						if (tg.entries.Count > 0)  							e.Graphics.DrawLine(blackPen' rowHeight / 2' row * totalRowHeight + totalRowHeight' rowHeight / 2' (row + tg.entries.Count) * totalRowHeight + totalRowHeight / 2);      						// Entries zeichnen  						foreach (TimelineEntry te in tg.entries)  							{  							row++;    							// horizontale Linie links malen  							e.Graphics.DrawLine(blackPen' totalRowHeight / 2' row * totalRowHeight + totalRowHeight / 2' totalRowHeight / 2 + totalRowHeight / 4' row * totalRowHeight + totalRowHeight / 2);    							// Balken malen  							if (te == selectedEntry)  								{  								e.Graphics.DrawRectangle(dottedPen' totalRowHeight' 1 + (row * totalRowHeight)' maxWidth' rowHeight);  								}  							else  								{  								e.Graphics.DrawRectangle(blackPen' totalRowHeight' 1 + (row * totalRowHeight)' maxWidth' rowHeight);  								}  							e.Graphics.FillRectangle(new SolidBrush(te.color)' totalRowHeight + 1' 2 + (row * totalRowHeight)' maxWidth - 1' rowHeight - 1);    							// einzelne Events zeichnen  							foreach (TimelineEvent ev in te.events)  								{  								int startPosition = totalRowHeight + (int)Math.Round(ev.eventTime * zoom);  								int length = (int)Math.Round(ev.eventLength * zoom);  								e.Graphics.FillRectangle(new SolidBrush(ev.color)' startPosition' 2 + (row * totalRowHeight)' length' rowHeight - 1);  								e.Graphics.DrawLine(blackPen' startPosition' 2 + (row * totalRowHeight)' startPosition' totalRowHeight - 2 + (row * totalRowHeight));  								e.Graphics.DrawLine(blackPen' startPosition + length' 2 + (row * totalRowHeight)' startPosition + length' totalRowHeight - 2 + (row * totalRowHeight));  								}    							e.Graphics.DrawString(te.name' calibriFont' blackBrush' new PointF(totalRowHeight + 3' row * totalRowHeight));  							}  						}    					row++;  					}        				// Lineal zeichnen  				dottedPen.DashStyle = System.Drawing.Drawing2D.DashStyle.Dash;    				e.Graphics.DrawLine(blackPen' totalRowHeight' this.ClientSize.Height - 1' this.Width' this.Height - 1);    				for (int i = 0; i <= steuerung.maxTime / 10; i++)  					{  					e.Graphics.DrawLine(blackPen' totalRowHeight + i * 10 * zoom' this.Height - 1' totalRowHeight + i * 10 * zoom' this.Height - 7);  					e.Graphics.DrawString((i * 10).ToString()' calibriFont' blackBrush' new PointF(totalRowHeight + (i * 10 * zoom) - 8' this.Height - 18));  					}    				// aktuelle Zeit zeichnen  				e.Graphics.DrawLine(dottedPen' totalRowHeight + (int)Math.Round(timelineBarTime * zoom)' 0' totalRowHeight + (int)Math.Round(timelineBarTime * zoom)' Height);  				}
Magic Number,CityTrafficSimulator,TimelineControl,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TimelineControl.cs,TimelineControl_Paint,The following statement contains a magic number: if (steuerung != null)  				{  				int maxWidth = (int)Math.Round(m_zoom * steuerung.maxTime);    				int row = 0;  				foreach (TimelineGroup tg in steuerung.groups)  					{  					// zusammengefaltete Gruppe zeichnen  					if (tg.collapsed)  						{  						if (tg == m_selectedGroup)  							{  							e.Graphics.FillRectangle(backgroundBrush' 0' 1 + (row * totalRowHeight)' ClientSize.Width' totalRowHeight);  							}    						// Gruppenname zeichnen  						e.Graphics.DrawString(tg.title' calibriFont' blackBrush' new PointF(totalRowHeight + 3' row * totalRowHeight));    						// Pluszeichen malen  						e.Graphics.DrawRectangle(blackPen' 0' 1 + (row * totalRowHeight)' rowHeight' rowHeight);  						e.Graphics.DrawLine(blackPen' 2' 1 + (row * totalRowHeight) + rowHeight / 2' rowHeight - 2' 1 + (row * totalRowHeight) + rowHeight / 2);  						e.Graphics.DrawLine(blackPen' rowHeight / 2' 1 + (row * totalRowHeight) + 2' rowHeight / 2' 1 + (row * totalRowHeight) + rowHeight - 2);  						}  					// aufgefaltete Gruppe zeichnen  					else  						{  						if (tg == m_selectedGroup)  							{  							e.Graphics.FillRectangle(backgroundBrush' 0' 1 + (row * totalRowHeight)' ClientSize.Width' (1 + tg.entries.Count) * totalRowHeight);  							}    						// Gruppenname zeichnen  						e.Graphics.DrawString(tg.title' calibriFont' blackBrush' new PointF(totalRowHeight + 3' row * totalRowHeight));    						// Minuszeichen malen  						e.Graphics.DrawRectangle(blackPen' 0' 1 + (row * totalRowHeight)' rowHeight' rowHeight);  						e.Graphics.DrawLine(blackPen' 2' 1 + (row * totalRowHeight) + rowHeight / 2' rowHeight - 2' 1 + (row * totalRowHeight) + rowHeight / 2);    						// vertikale Linie unter Minuszeichen malen  						if (tg.entries.Count > 0)  							e.Graphics.DrawLine(blackPen' rowHeight / 2' row * totalRowHeight + totalRowHeight' rowHeight / 2' (row + tg.entries.Count) * totalRowHeight + totalRowHeight / 2);      						// Entries zeichnen  						foreach (TimelineEntry te in tg.entries)  							{  							row++;    							// horizontale Linie links malen  							e.Graphics.DrawLine(blackPen' totalRowHeight / 2' row * totalRowHeight + totalRowHeight / 2' totalRowHeight / 2 + totalRowHeight / 4' row * totalRowHeight + totalRowHeight / 2);    							// Balken malen  							if (te == selectedEntry)  								{  								e.Graphics.DrawRectangle(dottedPen' totalRowHeight' 1 + (row * totalRowHeight)' maxWidth' rowHeight);  								}  							else  								{  								e.Graphics.DrawRectangle(blackPen' totalRowHeight' 1 + (row * totalRowHeight)' maxWidth' rowHeight);  								}  							e.Graphics.FillRectangle(new SolidBrush(te.color)' totalRowHeight + 1' 2 + (row * totalRowHeight)' maxWidth - 1' rowHeight - 1);    							// einzelne Events zeichnen  							foreach (TimelineEvent ev in te.events)  								{  								int startPosition = totalRowHeight + (int)Math.Round(ev.eventTime * zoom);  								int length = (int)Math.Round(ev.eventLength * zoom);  								e.Graphics.FillRectangle(new SolidBrush(ev.color)' startPosition' 2 + (row * totalRowHeight)' length' rowHeight - 1);  								e.Graphics.DrawLine(blackPen' startPosition' 2 + (row * totalRowHeight)' startPosition' totalRowHeight - 2 + (row * totalRowHeight));  								e.Graphics.DrawLine(blackPen' startPosition + length' 2 + (row * totalRowHeight)' startPosition + length' totalRowHeight - 2 + (row * totalRowHeight));  								}    							e.Graphics.DrawString(te.name' calibriFont' blackBrush' new PointF(totalRowHeight + 3' row * totalRowHeight));  							}  						}    					row++;  					}        				// Lineal zeichnen  				dottedPen.DashStyle = System.Drawing.Drawing2D.DashStyle.Dash;    				e.Graphics.DrawLine(blackPen' totalRowHeight' this.ClientSize.Height - 1' this.Width' this.Height - 1);    				for (int i = 0; i <= steuerung.maxTime / 10; i++)  					{  					e.Graphics.DrawLine(blackPen' totalRowHeight + i * 10 * zoom' this.Height - 1' totalRowHeight + i * 10 * zoom' this.Height - 7);  					e.Graphics.DrawString((i * 10).ToString()' calibriFont' blackBrush' new PointF(totalRowHeight + (i * 10 * zoom) - 8' this.Height - 18));  					}    				// aktuelle Zeit zeichnen  				e.Graphics.DrawLine(dottedPen' totalRowHeight + (int)Math.Round(timelineBarTime * zoom)' 0' totalRowHeight + (int)Math.Round(timelineBarTime * zoom)' Height);  				}
Magic Number,CityTrafficSimulator,TimelineControl,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TimelineControl.cs,TimelineControl_Paint,The following statement contains a magic number: if (steuerung != null)  				{  				int maxWidth = (int)Math.Round(m_zoom * steuerung.maxTime);    				int row = 0;  				foreach (TimelineGroup tg in steuerung.groups)  					{  					// zusammengefaltete Gruppe zeichnen  					if (tg.collapsed)  						{  						if (tg == m_selectedGroup)  							{  							e.Graphics.FillRectangle(backgroundBrush' 0' 1 + (row * totalRowHeight)' ClientSize.Width' totalRowHeight);  							}    						// Gruppenname zeichnen  						e.Graphics.DrawString(tg.title' calibriFont' blackBrush' new PointF(totalRowHeight + 3' row * totalRowHeight));    						// Pluszeichen malen  						e.Graphics.DrawRectangle(blackPen' 0' 1 + (row * totalRowHeight)' rowHeight' rowHeight);  						e.Graphics.DrawLine(blackPen' 2' 1 + (row * totalRowHeight) + rowHeight / 2' rowHeight - 2' 1 + (row * totalRowHeight) + rowHeight / 2);  						e.Graphics.DrawLine(blackPen' rowHeight / 2' 1 + (row * totalRowHeight) + 2' rowHeight / 2' 1 + (row * totalRowHeight) + rowHeight - 2);  						}  					// aufgefaltete Gruppe zeichnen  					else  						{  						if (tg == m_selectedGroup)  							{  							e.Graphics.FillRectangle(backgroundBrush' 0' 1 + (row * totalRowHeight)' ClientSize.Width' (1 + tg.entries.Count) * totalRowHeight);  							}    						// Gruppenname zeichnen  						e.Graphics.DrawString(tg.title' calibriFont' blackBrush' new PointF(totalRowHeight + 3' row * totalRowHeight));    						// Minuszeichen malen  						e.Graphics.DrawRectangle(blackPen' 0' 1 + (row * totalRowHeight)' rowHeight' rowHeight);  						e.Graphics.DrawLine(blackPen' 2' 1 + (row * totalRowHeight) + rowHeight / 2' rowHeight - 2' 1 + (row * totalRowHeight) + rowHeight / 2);    						// vertikale Linie unter Minuszeichen malen  						if (tg.entries.Count > 0)  							e.Graphics.DrawLine(blackPen' rowHeight / 2' row * totalRowHeight + totalRowHeight' rowHeight / 2' (row + tg.entries.Count) * totalRowHeight + totalRowHeight / 2);      						// Entries zeichnen  						foreach (TimelineEntry te in tg.entries)  							{  							row++;    							// horizontale Linie links malen  							e.Graphics.DrawLine(blackPen' totalRowHeight / 2' row * totalRowHeight + totalRowHeight / 2' totalRowHeight / 2 + totalRowHeight / 4' row * totalRowHeight + totalRowHeight / 2);    							// Balken malen  							if (te == selectedEntry)  								{  								e.Graphics.DrawRectangle(dottedPen' totalRowHeight' 1 + (row * totalRowHeight)' maxWidth' rowHeight);  								}  							else  								{  								e.Graphics.DrawRectangle(blackPen' totalRowHeight' 1 + (row * totalRowHeight)' maxWidth' rowHeight);  								}  							e.Graphics.FillRectangle(new SolidBrush(te.color)' totalRowHeight + 1' 2 + (row * totalRowHeight)' maxWidth - 1' rowHeight - 1);    							// einzelne Events zeichnen  							foreach (TimelineEvent ev in te.events)  								{  								int startPosition = totalRowHeight + (int)Math.Round(ev.eventTime * zoom);  								int length = (int)Math.Round(ev.eventLength * zoom);  								e.Graphics.FillRectangle(new SolidBrush(ev.color)' startPosition' 2 + (row * totalRowHeight)' length' rowHeight - 1);  								e.Graphics.DrawLine(blackPen' startPosition' 2 + (row * totalRowHeight)' startPosition' totalRowHeight - 2 + (row * totalRowHeight));  								e.Graphics.DrawLine(blackPen' startPosition + length' 2 + (row * totalRowHeight)' startPosition + length' totalRowHeight - 2 + (row * totalRowHeight));  								}    							e.Graphics.DrawString(te.name' calibriFont' blackBrush' new PointF(totalRowHeight + 3' row * totalRowHeight));  							}  						}    					row++;  					}        				// Lineal zeichnen  				dottedPen.DashStyle = System.Drawing.Drawing2D.DashStyle.Dash;    				e.Graphics.DrawLine(blackPen' totalRowHeight' this.ClientSize.Height - 1' this.Width' this.Height - 1);    				for (int i = 0; i <= steuerung.maxTime / 10; i++)  					{  					e.Graphics.DrawLine(blackPen' totalRowHeight + i * 10 * zoom' this.Height - 1' totalRowHeight + i * 10 * zoom' this.Height - 7);  					e.Graphics.DrawString((i * 10).ToString()' calibriFont' blackBrush' new PointF(totalRowHeight + (i * 10 * zoom) - 8' this.Height - 18));  					}    				// aktuelle Zeit zeichnen  				e.Graphics.DrawLine(dottedPen' totalRowHeight + (int)Math.Round(timelineBarTime * zoom)' 0' totalRowHeight + (int)Math.Round(timelineBarTime * zoom)' Height);  				}
Magic Number,CityTrafficSimulator,TimelineControl,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TimelineControl.cs,TimelineControl_Paint,The following statement contains a magic number: if (steuerung != null)  				{  				int maxWidth = (int)Math.Round(m_zoom * steuerung.maxTime);    				int row = 0;  				foreach (TimelineGroup tg in steuerung.groups)  					{  					// zusammengefaltete Gruppe zeichnen  					if (tg.collapsed)  						{  						if (tg == m_selectedGroup)  							{  							e.Graphics.FillRectangle(backgroundBrush' 0' 1 + (row * totalRowHeight)' ClientSize.Width' totalRowHeight);  							}    						// Gruppenname zeichnen  						e.Graphics.DrawString(tg.title' calibriFont' blackBrush' new PointF(totalRowHeight + 3' row * totalRowHeight));    						// Pluszeichen malen  						e.Graphics.DrawRectangle(blackPen' 0' 1 + (row * totalRowHeight)' rowHeight' rowHeight);  						e.Graphics.DrawLine(blackPen' 2' 1 + (row * totalRowHeight) + rowHeight / 2' rowHeight - 2' 1 + (row * totalRowHeight) + rowHeight / 2);  						e.Graphics.DrawLine(blackPen' rowHeight / 2' 1 + (row * totalRowHeight) + 2' rowHeight / 2' 1 + (row * totalRowHeight) + rowHeight - 2);  						}  					// aufgefaltete Gruppe zeichnen  					else  						{  						if (tg == m_selectedGroup)  							{  							e.Graphics.FillRectangle(backgroundBrush' 0' 1 + (row * totalRowHeight)' ClientSize.Width' (1 + tg.entries.Count) * totalRowHeight);  							}    						// Gruppenname zeichnen  						e.Graphics.DrawString(tg.title' calibriFont' blackBrush' new PointF(totalRowHeight + 3' row * totalRowHeight));    						// Minuszeichen malen  						e.Graphics.DrawRectangle(blackPen' 0' 1 + (row * totalRowHeight)' rowHeight' rowHeight);  						e.Graphics.DrawLine(blackPen' 2' 1 + (row * totalRowHeight) + rowHeight / 2' rowHeight - 2' 1 + (row * totalRowHeight) + rowHeight / 2);    						// vertikale Linie unter Minuszeichen malen  						if (tg.entries.Count > 0)  							e.Graphics.DrawLine(blackPen' rowHeight / 2' row * totalRowHeight + totalRowHeight' rowHeight / 2' (row + tg.entries.Count) * totalRowHeight + totalRowHeight / 2);      						// Entries zeichnen  						foreach (TimelineEntry te in tg.entries)  							{  							row++;    							// horizontale Linie links malen  							e.Graphics.DrawLine(blackPen' totalRowHeight / 2' row * totalRowHeight + totalRowHeight / 2' totalRowHeight / 2 + totalRowHeight / 4' row * totalRowHeight + totalRowHeight / 2);    							// Balken malen  							if (te == selectedEntry)  								{  								e.Graphics.DrawRectangle(dottedPen' totalRowHeight' 1 + (row * totalRowHeight)' maxWidth' rowHeight);  								}  							else  								{  								e.Graphics.DrawRectangle(blackPen' totalRowHeight' 1 + (row * totalRowHeight)' maxWidth' rowHeight);  								}  							e.Graphics.FillRectangle(new SolidBrush(te.color)' totalRowHeight + 1' 2 + (row * totalRowHeight)' maxWidth - 1' rowHeight - 1);    							// einzelne Events zeichnen  							foreach (TimelineEvent ev in te.events)  								{  								int startPosition = totalRowHeight + (int)Math.Round(ev.eventTime * zoom);  								int length = (int)Math.Round(ev.eventLength * zoom);  								e.Graphics.FillRectangle(new SolidBrush(ev.color)' startPosition' 2 + (row * totalRowHeight)' length' rowHeight - 1);  								e.Graphics.DrawLine(blackPen' startPosition' 2 + (row * totalRowHeight)' startPosition' totalRowHeight - 2 + (row * totalRowHeight));  								e.Graphics.DrawLine(blackPen' startPosition + length' 2 + (row * totalRowHeight)' startPosition + length' totalRowHeight - 2 + (row * totalRowHeight));  								}    							e.Graphics.DrawString(te.name' calibriFont' blackBrush' new PointF(totalRowHeight + 3' row * totalRowHeight));  							}  						}    					row++;  					}        				// Lineal zeichnen  				dottedPen.DashStyle = System.Drawing.Drawing2D.DashStyle.Dash;    				e.Graphics.DrawLine(blackPen' totalRowHeight' this.ClientSize.Height - 1' this.Width' this.Height - 1);    				for (int i = 0; i <= steuerung.maxTime / 10; i++)  					{  					e.Graphics.DrawLine(blackPen' totalRowHeight + i * 10 * zoom' this.Height - 1' totalRowHeight + i * 10 * zoom' this.Height - 7);  					e.Graphics.DrawString((i * 10).ToString()' calibriFont' blackBrush' new PointF(totalRowHeight + (i * 10 * zoom) - 8' this.Height - 18));  					}    				// aktuelle Zeit zeichnen  				e.Graphics.DrawLine(dottedPen' totalRowHeight + (int)Math.Round(timelineBarTime * zoom)' 0' totalRowHeight + (int)Math.Round(timelineBarTime * zoom)' Height);  				}
Magic Number,CityTrafficSimulator,TimelineControl,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TimelineControl.cs,TimelineControl_Paint,The following statement contains a magic number: if (steuerung != null)  				{  				int maxWidth = (int)Math.Round(m_zoom * steuerung.maxTime);    				int row = 0;  				foreach (TimelineGroup tg in steuerung.groups)  					{  					// zusammengefaltete Gruppe zeichnen  					if (tg.collapsed)  						{  						if (tg == m_selectedGroup)  							{  							e.Graphics.FillRectangle(backgroundBrush' 0' 1 + (row * totalRowHeight)' ClientSize.Width' totalRowHeight);  							}    						// Gruppenname zeichnen  						e.Graphics.DrawString(tg.title' calibriFont' blackBrush' new PointF(totalRowHeight + 3' row * totalRowHeight));    						// Pluszeichen malen  						e.Graphics.DrawRectangle(blackPen' 0' 1 + (row * totalRowHeight)' rowHeight' rowHeight);  						e.Graphics.DrawLine(blackPen' 2' 1 + (row * totalRowHeight) + rowHeight / 2' rowHeight - 2' 1 + (row * totalRowHeight) + rowHeight / 2);  						e.Graphics.DrawLine(blackPen' rowHeight / 2' 1 + (row * totalRowHeight) + 2' rowHeight / 2' 1 + (row * totalRowHeight) + rowHeight - 2);  						}  					// aufgefaltete Gruppe zeichnen  					else  						{  						if (tg == m_selectedGroup)  							{  							e.Graphics.FillRectangle(backgroundBrush' 0' 1 + (row * totalRowHeight)' ClientSize.Width' (1 + tg.entries.Count) * totalRowHeight);  							}    						// Gruppenname zeichnen  						e.Graphics.DrawString(tg.title' calibriFont' blackBrush' new PointF(totalRowHeight + 3' row * totalRowHeight));    						// Minuszeichen malen  						e.Graphics.DrawRectangle(blackPen' 0' 1 + (row * totalRowHeight)' rowHeight' rowHeight);  						e.Graphics.DrawLine(blackPen' 2' 1 + (row * totalRowHeight) + rowHeight / 2' rowHeight - 2' 1 + (row * totalRowHeight) + rowHeight / 2);    						// vertikale Linie unter Minuszeichen malen  						if (tg.entries.Count > 0)  							e.Graphics.DrawLine(blackPen' rowHeight / 2' row * totalRowHeight + totalRowHeight' rowHeight / 2' (row + tg.entries.Count) * totalRowHeight + totalRowHeight / 2);      						// Entries zeichnen  						foreach (TimelineEntry te in tg.entries)  							{  							row++;    							// horizontale Linie links malen  							e.Graphics.DrawLine(blackPen' totalRowHeight / 2' row * totalRowHeight + totalRowHeight / 2' totalRowHeight / 2 + totalRowHeight / 4' row * totalRowHeight + totalRowHeight / 2);    							// Balken malen  							if (te == selectedEntry)  								{  								e.Graphics.DrawRectangle(dottedPen' totalRowHeight' 1 + (row * totalRowHeight)' maxWidth' rowHeight);  								}  							else  								{  								e.Graphics.DrawRectangle(blackPen' totalRowHeight' 1 + (row * totalRowHeight)' maxWidth' rowHeight);  								}  							e.Graphics.FillRectangle(new SolidBrush(te.color)' totalRowHeight + 1' 2 + (row * totalRowHeight)' maxWidth - 1' rowHeight - 1);    							// einzelne Events zeichnen  							foreach (TimelineEvent ev in te.events)  								{  								int startPosition = totalRowHeight + (int)Math.Round(ev.eventTime * zoom);  								int length = (int)Math.Round(ev.eventLength * zoom);  								e.Graphics.FillRectangle(new SolidBrush(ev.color)' startPosition' 2 + (row * totalRowHeight)' length' rowHeight - 1);  								e.Graphics.DrawLine(blackPen' startPosition' 2 + (row * totalRowHeight)' startPosition' totalRowHeight - 2 + (row * totalRowHeight));  								e.Graphics.DrawLine(blackPen' startPosition + length' 2 + (row * totalRowHeight)' startPosition + length' totalRowHeight - 2 + (row * totalRowHeight));  								}    							e.Graphics.DrawString(te.name' calibriFont' blackBrush' new PointF(totalRowHeight + 3' row * totalRowHeight));  							}  						}    					row++;  					}        				// Lineal zeichnen  				dottedPen.DashStyle = System.Drawing.Drawing2D.DashStyle.Dash;    				e.Graphics.DrawLine(blackPen' totalRowHeight' this.ClientSize.Height - 1' this.Width' this.Height - 1);    				for (int i = 0; i <= steuerung.maxTime / 10; i++)  					{  					e.Graphics.DrawLine(blackPen' totalRowHeight + i * 10 * zoom' this.Height - 1' totalRowHeight + i * 10 * zoom' this.Height - 7);  					e.Graphics.DrawString((i * 10).ToString()' calibriFont' blackBrush' new PointF(totalRowHeight + (i * 10 * zoom) - 8' this.Height - 18));  					}    				// aktuelle Zeit zeichnen  				e.Graphics.DrawLine(dottedPen' totalRowHeight + (int)Math.Round(timelineBarTime * zoom)' 0' totalRowHeight + (int)Math.Round(timelineBarTime * zoom)' Height);  				}
Magic Number,CityTrafficSimulator,TimelineControl,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TimelineControl.cs,TimelineControl_Paint,The following statement contains a magic number: if (steuerung != null)  				{  				int maxWidth = (int)Math.Round(m_zoom * steuerung.maxTime);    				int row = 0;  				foreach (TimelineGroup tg in steuerung.groups)  					{  					// zusammengefaltete Gruppe zeichnen  					if (tg.collapsed)  						{  						if (tg == m_selectedGroup)  							{  							e.Graphics.FillRectangle(backgroundBrush' 0' 1 + (row * totalRowHeight)' ClientSize.Width' totalRowHeight);  							}    						// Gruppenname zeichnen  						e.Graphics.DrawString(tg.title' calibriFont' blackBrush' new PointF(totalRowHeight + 3' row * totalRowHeight));    						// Pluszeichen malen  						e.Graphics.DrawRectangle(blackPen' 0' 1 + (row * totalRowHeight)' rowHeight' rowHeight);  						e.Graphics.DrawLine(blackPen' 2' 1 + (row * totalRowHeight) + rowHeight / 2' rowHeight - 2' 1 + (row * totalRowHeight) + rowHeight / 2);  						e.Graphics.DrawLine(blackPen' rowHeight / 2' 1 + (row * totalRowHeight) + 2' rowHeight / 2' 1 + (row * totalRowHeight) + rowHeight - 2);  						}  					// aufgefaltete Gruppe zeichnen  					else  						{  						if (tg == m_selectedGroup)  							{  							e.Graphics.FillRectangle(backgroundBrush' 0' 1 + (row * totalRowHeight)' ClientSize.Width' (1 + tg.entries.Count) * totalRowHeight);  							}    						// Gruppenname zeichnen  						e.Graphics.DrawString(tg.title' calibriFont' blackBrush' new PointF(totalRowHeight + 3' row * totalRowHeight));    						// Minuszeichen malen  						e.Graphics.DrawRectangle(blackPen' 0' 1 + (row * totalRowHeight)' rowHeight' rowHeight);  						e.Graphics.DrawLine(blackPen' 2' 1 + (row * totalRowHeight) + rowHeight / 2' rowHeight - 2' 1 + (row * totalRowHeight) + rowHeight / 2);    						// vertikale Linie unter Minuszeichen malen  						if (tg.entries.Count > 0)  							e.Graphics.DrawLine(blackPen' rowHeight / 2' row * totalRowHeight + totalRowHeight' rowHeight / 2' (row + tg.entries.Count) * totalRowHeight + totalRowHeight / 2);      						// Entries zeichnen  						foreach (TimelineEntry te in tg.entries)  							{  							row++;    							// horizontale Linie links malen  							e.Graphics.DrawLine(blackPen' totalRowHeight / 2' row * totalRowHeight + totalRowHeight / 2' totalRowHeight / 2 + totalRowHeight / 4' row * totalRowHeight + totalRowHeight / 2);    							// Balken malen  							if (te == selectedEntry)  								{  								e.Graphics.DrawRectangle(dottedPen' totalRowHeight' 1 + (row * totalRowHeight)' maxWidth' rowHeight);  								}  							else  								{  								e.Graphics.DrawRectangle(blackPen' totalRowHeight' 1 + (row * totalRowHeight)' maxWidth' rowHeight);  								}  							e.Graphics.FillRectangle(new SolidBrush(te.color)' totalRowHeight + 1' 2 + (row * totalRowHeight)' maxWidth - 1' rowHeight - 1);    							// einzelne Events zeichnen  							foreach (TimelineEvent ev in te.events)  								{  								int startPosition = totalRowHeight + (int)Math.Round(ev.eventTime * zoom);  								int length = (int)Math.Round(ev.eventLength * zoom);  								e.Graphics.FillRectangle(new SolidBrush(ev.color)' startPosition' 2 + (row * totalRowHeight)' length' rowHeight - 1);  								e.Graphics.DrawLine(blackPen' startPosition' 2 + (row * totalRowHeight)' startPosition' totalRowHeight - 2 + (row * totalRowHeight));  								e.Graphics.DrawLine(blackPen' startPosition + length' 2 + (row * totalRowHeight)' startPosition + length' totalRowHeight - 2 + (row * totalRowHeight));  								}    							e.Graphics.DrawString(te.name' calibriFont' blackBrush' new PointF(totalRowHeight + 3' row * totalRowHeight));  							}  						}    					row++;  					}        				// Lineal zeichnen  				dottedPen.DashStyle = System.Drawing.Drawing2D.DashStyle.Dash;    				e.Graphics.DrawLine(blackPen' totalRowHeight' this.ClientSize.Height - 1' this.Width' this.Height - 1);    				for (int i = 0; i <= steuerung.maxTime / 10; i++)  					{  					e.Graphics.DrawLine(blackPen' totalRowHeight + i * 10 * zoom' this.Height - 1' totalRowHeight + i * 10 * zoom' this.Height - 7);  					e.Graphics.DrawString((i * 10).ToString()' calibriFont' blackBrush' new PointF(totalRowHeight + (i * 10 * zoom) - 8' this.Height - 18));  					}    				// aktuelle Zeit zeichnen  				e.Graphics.DrawLine(dottedPen' totalRowHeight + (int)Math.Round(timelineBarTime * zoom)' 0' totalRowHeight + (int)Math.Round(timelineBarTime * zoom)' Height);  				}
Magic Number,CityTrafficSimulator,TimelineControl,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TimelineControl.cs,TimelineControl_Paint,The following statement contains a magic number: if (steuerung != null)  				{  				int maxWidth = (int)Math.Round(m_zoom * steuerung.maxTime);    				int row = 0;  				foreach (TimelineGroup tg in steuerung.groups)  					{  					// zusammengefaltete Gruppe zeichnen  					if (tg.collapsed)  						{  						if (tg == m_selectedGroup)  							{  							e.Graphics.FillRectangle(backgroundBrush' 0' 1 + (row * totalRowHeight)' ClientSize.Width' totalRowHeight);  							}    						// Gruppenname zeichnen  						e.Graphics.DrawString(tg.title' calibriFont' blackBrush' new PointF(totalRowHeight + 3' row * totalRowHeight));    						// Pluszeichen malen  						e.Graphics.DrawRectangle(blackPen' 0' 1 + (row * totalRowHeight)' rowHeight' rowHeight);  						e.Graphics.DrawLine(blackPen' 2' 1 + (row * totalRowHeight) + rowHeight / 2' rowHeight - 2' 1 + (row * totalRowHeight) + rowHeight / 2);  						e.Graphics.DrawLine(blackPen' rowHeight / 2' 1 + (row * totalRowHeight) + 2' rowHeight / 2' 1 + (row * totalRowHeight) + rowHeight - 2);  						}  					// aufgefaltete Gruppe zeichnen  					else  						{  						if (tg == m_selectedGroup)  							{  							e.Graphics.FillRectangle(backgroundBrush' 0' 1 + (row * totalRowHeight)' ClientSize.Width' (1 + tg.entries.Count) * totalRowHeight);  							}    						// Gruppenname zeichnen  						e.Graphics.DrawString(tg.title' calibriFont' blackBrush' new PointF(totalRowHeight + 3' row * totalRowHeight));    						// Minuszeichen malen  						e.Graphics.DrawRectangle(blackPen' 0' 1 + (row * totalRowHeight)' rowHeight' rowHeight);  						e.Graphics.DrawLine(blackPen' 2' 1 + (row * totalRowHeight) + rowHeight / 2' rowHeight - 2' 1 + (row * totalRowHeight) + rowHeight / 2);    						// vertikale Linie unter Minuszeichen malen  						if (tg.entries.Count > 0)  							e.Graphics.DrawLine(blackPen' rowHeight / 2' row * totalRowHeight + totalRowHeight' rowHeight / 2' (row + tg.entries.Count) * totalRowHeight + totalRowHeight / 2);      						// Entries zeichnen  						foreach (TimelineEntry te in tg.entries)  							{  							row++;    							// horizontale Linie links malen  							e.Graphics.DrawLine(blackPen' totalRowHeight / 2' row * totalRowHeight + totalRowHeight / 2' totalRowHeight / 2 + totalRowHeight / 4' row * totalRowHeight + totalRowHeight / 2);    							// Balken malen  							if (te == selectedEntry)  								{  								e.Graphics.DrawRectangle(dottedPen' totalRowHeight' 1 + (row * totalRowHeight)' maxWidth' rowHeight);  								}  							else  								{  								e.Graphics.DrawRectangle(blackPen' totalRowHeight' 1 + (row * totalRowHeight)' maxWidth' rowHeight);  								}  							e.Graphics.FillRectangle(new SolidBrush(te.color)' totalRowHeight + 1' 2 + (row * totalRowHeight)' maxWidth - 1' rowHeight - 1);    							// einzelne Events zeichnen  							foreach (TimelineEvent ev in te.events)  								{  								int startPosition = totalRowHeight + (int)Math.Round(ev.eventTime * zoom);  								int length = (int)Math.Round(ev.eventLength * zoom);  								e.Graphics.FillRectangle(new SolidBrush(ev.color)' startPosition' 2 + (row * totalRowHeight)' length' rowHeight - 1);  								e.Graphics.DrawLine(blackPen' startPosition' 2 + (row * totalRowHeight)' startPosition' totalRowHeight - 2 + (row * totalRowHeight));  								e.Graphics.DrawLine(blackPen' startPosition + length' 2 + (row * totalRowHeight)' startPosition + length' totalRowHeight - 2 + (row * totalRowHeight));  								}    							e.Graphics.DrawString(te.name' calibriFont' blackBrush' new PointF(totalRowHeight + 3' row * totalRowHeight));  							}  						}    					row++;  					}        				// Lineal zeichnen  				dottedPen.DashStyle = System.Drawing.Drawing2D.DashStyle.Dash;    				e.Graphics.DrawLine(blackPen' totalRowHeight' this.ClientSize.Height - 1' this.Width' this.Height - 1);    				for (int i = 0; i <= steuerung.maxTime / 10; i++)  					{  					e.Graphics.DrawLine(blackPen' totalRowHeight + i * 10 * zoom' this.Height - 1' totalRowHeight + i * 10 * zoom' this.Height - 7);  					e.Graphics.DrawString((i * 10).ToString()' calibriFont' blackBrush' new PointF(totalRowHeight + (i * 10 * zoom) - 8' this.Height - 18));  					}    				// aktuelle Zeit zeichnen  				e.Graphics.DrawLine(dottedPen' totalRowHeight + (int)Math.Round(timelineBarTime * zoom)' 0' totalRowHeight + (int)Math.Round(timelineBarTime * zoom)' Height);  				}
Magic Number,CityTrafficSimulator,TimelineControl,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TimelineControl.cs,TimelineControl_Paint,The following statement contains a magic number: if (steuerung != null)  				{  				int maxWidth = (int)Math.Round(m_zoom * steuerung.maxTime);    				int row = 0;  				foreach (TimelineGroup tg in steuerung.groups)  					{  					// zusammengefaltete Gruppe zeichnen  					if (tg.collapsed)  						{  						if (tg == m_selectedGroup)  							{  							e.Graphics.FillRectangle(backgroundBrush' 0' 1 + (row * totalRowHeight)' ClientSize.Width' totalRowHeight);  							}    						// Gruppenname zeichnen  						e.Graphics.DrawString(tg.title' calibriFont' blackBrush' new PointF(totalRowHeight + 3' row * totalRowHeight));    						// Pluszeichen malen  						e.Graphics.DrawRectangle(blackPen' 0' 1 + (row * totalRowHeight)' rowHeight' rowHeight);  						e.Graphics.DrawLine(blackPen' 2' 1 + (row * totalRowHeight) + rowHeight / 2' rowHeight - 2' 1 + (row * totalRowHeight) + rowHeight / 2);  						e.Graphics.DrawLine(blackPen' rowHeight / 2' 1 + (row * totalRowHeight) + 2' rowHeight / 2' 1 + (row * totalRowHeight) + rowHeight - 2);  						}  					// aufgefaltete Gruppe zeichnen  					else  						{  						if (tg == m_selectedGroup)  							{  							e.Graphics.FillRectangle(backgroundBrush' 0' 1 + (row * totalRowHeight)' ClientSize.Width' (1 + tg.entries.Count) * totalRowHeight);  							}    						// Gruppenname zeichnen  						e.Graphics.DrawString(tg.title' calibriFont' blackBrush' new PointF(totalRowHeight + 3' row * totalRowHeight));    						// Minuszeichen malen  						e.Graphics.DrawRectangle(blackPen' 0' 1 + (row * totalRowHeight)' rowHeight' rowHeight);  						e.Graphics.DrawLine(blackPen' 2' 1 + (row * totalRowHeight) + rowHeight / 2' rowHeight - 2' 1 + (row * totalRowHeight) + rowHeight / 2);    						// vertikale Linie unter Minuszeichen malen  						if (tg.entries.Count > 0)  							e.Graphics.DrawLine(blackPen' rowHeight / 2' row * totalRowHeight + totalRowHeight' rowHeight / 2' (row + tg.entries.Count) * totalRowHeight + totalRowHeight / 2);      						// Entries zeichnen  						foreach (TimelineEntry te in tg.entries)  							{  							row++;    							// horizontale Linie links malen  							e.Graphics.DrawLine(blackPen' totalRowHeight / 2' row * totalRowHeight + totalRowHeight / 2' totalRowHeight / 2 + totalRowHeight / 4' row * totalRowHeight + totalRowHeight / 2);    							// Balken malen  							if (te == selectedEntry)  								{  								e.Graphics.DrawRectangle(dottedPen' totalRowHeight' 1 + (row * totalRowHeight)' maxWidth' rowHeight);  								}  							else  								{  								e.Graphics.DrawRectangle(blackPen' totalRowHeight' 1 + (row * totalRowHeight)' maxWidth' rowHeight);  								}  							e.Graphics.FillRectangle(new SolidBrush(te.color)' totalRowHeight + 1' 2 + (row * totalRowHeight)' maxWidth - 1' rowHeight - 1);    							// einzelne Events zeichnen  							foreach (TimelineEvent ev in te.events)  								{  								int startPosition = totalRowHeight + (int)Math.Round(ev.eventTime * zoom);  								int length = (int)Math.Round(ev.eventLength * zoom);  								e.Graphics.FillRectangle(new SolidBrush(ev.color)' startPosition' 2 + (row * totalRowHeight)' length' rowHeight - 1);  								e.Graphics.DrawLine(blackPen' startPosition' 2 + (row * totalRowHeight)' startPosition' totalRowHeight - 2 + (row * totalRowHeight));  								e.Graphics.DrawLine(blackPen' startPosition + length' 2 + (row * totalRowHeight)' startPosition + length' totalRowHeight - 2 + (row * totalRowHeight));  								}    							e.Graphics.DrawString(te.name' calibriFont' blackBrush' new PointF(totalRowHeight + 3' row * totalRowHeight));  							}  						}    					row++;  					}        				// Lineal zeichnen  				dottedPen.DashStyle = System.Drawing.Drawing2D.DashStyle.Dash;    				e.Graphics.DrawLine(blackPen' totalRowHeight' this.ClientSize.Height - 1' this.Width' this.Height - 1);    				for (int i = 0; i <= steuerung.maxTime / 10; i++)  					{  					e.Graphics.DrawLine(blackPen' totalRowHeight + i * 10 * zoom' this.Height - 1' totalRowHeight + i * 10 * zoom' this.Height - 7);  					e.Graphics.DrawString((i * 10).ToString()' calibriFont' blackBrush' new PointF(totalRowHeight + (i * 10 * zoom) - 8' this.Height - 18));  					}    				// aktuelle Zeit zeichnen  				e.Graphics.DrawLine(dottedPen' totalRowHeight + (int)Math.Round(timelineBarTime * zoom)' 0' totalRowHeight + (int)Math.Round(timelineBarTime * zoom)' Height);  				}
Magic Number,CityTrafficSimulator,TimelineControl,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TimelineControl.cs,TimelineControl_Paint,The following statement contains a magic number: if (steuerung != null)  				{  				int maxWidth = (int)Math.Round(m_zoom * steuerung.maxTime);    				int row = 0;  				foreach (TimelineGroup tg in steuerung.groups)  					{  					// zusammengefaltete Gruppe zeichnen  					if (tg.collapsed)  						{  						if (tg == m_selectedGroup)  							{  							e.Graphics.FillRectangle(backgroundBrush' 0' 1 + (row * totalRowHeight)' ClientSize.Width' totalRowHeight);  							}    						// Gruppenname zeichnen  						e.Graphics.DrawString(tg.title' calibriFont' blackBrush' new PointF(totalRowHeight + 3' row * totalRowHeight));    						// Pluszeichen malen  						e.Graphics.DrawRectangle(blackPen' 0' 1 + (row * totalRowHeight)' rowHeight' rowHeight);  						e.Graphics.DrawLine(blackPen' 2' 1 + (row * totalRowHeight) + rowHeight / 2' rowHeight - 2' 1 + (row * totalRowHeight) + rowHeight / 2);  						e.Graphics.DrawLine(blackPen' rowHeight / 2' 1 + (row * totalRowHeight) + 2' rowHeight / 2' 1 + (row * totalRowHeight) + rowHeight - 2);  						}  					// aufgefaltete Gruppe zeichnen  					else  						{  						if (tg == m_selectedGroup)  							{  							e.Graphics.FillRectangle(backgroundBrush' 0' 1 + (row * totalRowHeight)' ClientSize.Width' (1 + tg.entries.Count) * totalRowHeight);  							}    						// Gruppenname zeichnen  						e.Graphics.DrawString(tg.title' calibriFont' blackBrush' new PointF(totalRowHeight + 3' row * totalRowHeight));    						// Minuszeichen malen  						e.Graphics.DrawRectangle(blackPen' 0' 1 + (row * totalRowHeight)' rowHeight' rowHeight);  						e.Graphics.DrawLine(blackPen' 2' 1 + (row * totalRowHeight) + rowHeight / 2' rowHeight - 2' 1 + (row * totalRowHeight) + rowHeight / 2);    						// vertikale Linie unter Minuszeichen malen  						if (tg.entries.Count > 0)  							e.Graphics.DrawLine(blackPen' rowHeight / 2' row * totalRowHeight + totalRowHeight' rowHeight / 2' (row + tg.entries.Count) * totalRowHeight + totalRowHeight / 2);      						// Entries zeichnen  						foreach (TimelineEntry te in tg.entries)  							{  							row++;    							// horizontale Linie links malen  							e.Graphics.DrawLine(blackPen' totalRowHeight / 2' row * totalRowHeight + totalRowHeight / 2' totalRowHeight / 2 + totalRowHeight / 4' row * totalRowHeight + totalRowHeight / 2);    							// Balken malen  							if (te == selectedEntry)  								{  								e.Graphics.DrawRectangle(dottedPen' totalRowHeight' 1 + (row * totalRowHeight)' maxWidth' rowHeight);  								}  							else  								{  								e.Graphics.DrawRectangle(blackPen' totalRowHeight' 1 + (row * totalRowHeight)' maxWidth' rowHeight);  								}  							e.Graphics.FillRectangle(new SolidBrush(te.color)' totalRowHeight + 1' 2 + (row * totalRowHeight)' maxWidth - 1' rowHeight - 1);    							// einzelne Events zeichnen  							foreach (TimelineEvent ev in te.events)  								{  								int startPosition = totalRowHeight + (int)Math.Round(ev.eventTime * zoom);  								int length = (int)Math.Round(ev.eventLength * zoom);  								e.Graphics.FillRectangle(new SolidBrush(ev.color)' startPosition' 2 + (row * totalRowHeight)' length' rowHeight - 1);  								e.Graphics.DrawLine(blackPen' startPosition' 2 + (row * totalRowHeight)' startPosition' totalRowHeight - 2 + (row * totalRowHeight));  								e.Graphics.DrawLine(blackPen' startPosition + length' 2 + (row * totalRowHeight)' startPosition + length' totalRowHeight - 2 + (row * totalRowHeight));  								}    							e.Graphics.DrawString(te.name' calibriFont' blackBrush' new PointF(totalRowHeight + 3' row * totalRowHeight));  							}  						}    					row++;  					}        				// Lineal zeichnen  				dottedPen.DashStyle = System.Drawing.Drawing2D.DashStyle.Dash;    				e.Graphics.DrawLine(blackPen' totalRowHeight' this.ClientSize.Height - 1' this.Width' this.Height - 1);    				for (int i = 0; i <= steuerung.maxTime / 10; i++)  					{  					e.Graphics.DrawLine(blackPen' totalRowHeight + i * 10 * zoom' this.Height - 1' totalRowHeight + i * 10 * zoom' this.Height - 7);  					e.Graphics.DrawString((i * 10).ToString()' calibriFont' blackBrush' new PointF(totalRowHeight + (i * 10 * zoom) - 8' this.Height - 18));  					}    				// aktuelle Zeit zeichnen  				e.Graphics.DrawLine(dottedPen' totalRowHeight + (int)Math.Round(timelineBarTime * zoom)' 0' totalRowHeight + (int)Math.Round(timelineBarTime * zoom)' Height);  				}
Magic Number,CityTrafficSimulator,TimelineControl,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TimelineControl.cs,TimelineControl_Paint,The following statement contains a magic number: if (steuerung != null)  				{  				int maxWidth = (int)Math.Round(m_zoom * steuerung.maxTime);    				int row = 0;  				foreach (TimelineGroup tg in steuerung.groups)  					{  					// zusammengefaltete Gruppe zeichnen  					if (tg.collapsed)  						{  						if (tg == m_selectedGroup)  							{  							e.Graphics.FillRectangle(backgroundBrush' 0' 1 + (row * totalRowHeight)' ClientSize.Width' totalRowHeight);  							}    						// Gruppenname zeichnen  						e.Graphics.DrawString(tg.title' calibriFont' blackBrush' new PointF(totalRowHeight + 3' row * totalRowHeight));    						// Pluszeichen malen  						e.Graphics.DrawRectangle(blackPen' 0' 1 + (row * totalRowHeight)' rowHeight' rowHeight);  						e.Graphics.DrawLine(blackPen' 2' 1 + (row * totalRowHeight) + rowHeight / 2' rowHeight - 2' 1 + (row * totalRowHeight) + rowHeight / 2);  						e.Graphics.DrawLine(blackPen' rowHeight / 2' 1 + (row * totalRowHeight) + 2' rowHeight / 2' 1 + (row * totalRowHeight) + rowHeight - 2);  						}  					// aufgefaltete Gruppe zeichnen  					else  						{  						if (tg == m_selectedGroup)  							{  							e.Graphics.FillRectangle(backgroundBrush' 0' 1 + (row * totalRowHeight)' ClientSize.Width' (1 + tg.entries.Count) * totalRowHeight);  							}    						// Gruppenname zeichnen  						e.Graphics.DrawString(tg.title' calibriFont' blackBrush' new PointF(totalRowHeight + 3' row * totalRowHeight));    						// Minuszeichen malen  						e.Graphics.DrawRectangle(blackPen' 0' 1 + (row * totalRowHeight)' rowHeight' rowHeight);  						e.Graphics.DrawLine(blackPen' 2' 1 + (row * totalRowHeight) + rowHeight / 2' rowHeight - 2' 1 + (row * totalRowHeight) + rowHeight / 2);    						// vertikale Linie unter Minuszeichen malen  						if (tg.entries.Count > 0)  							e.Graphics.DrawLine(blackPen' rowHeight / 2' row * totalRowHeight + totalRowHeight' rowHeight / 2' (row + tg.entries.Count) * totalRowHeight + totalRowHeight / 2);      						// Entries zeichnen  						foreach (TimelineEntry te in tg.entries)  							{  							row++;    							// horizontale Linie links malen  							e.Graphics.DrawLine(blackPen' totalRowHeight / 2' row * totalRowHeight + totalRowHeight / 2' totalRowHeight / 2 + totalRowHeight / 4' row * totalRowHeight + totalRowHeight / 2);    							// Balken malen  							if (te == selectedEntry)  								{  								e.Graphics.DrawRectangle(dottedPen' totalRowHeight' 1 + (row * totalRowHeight)' maxWidth' rowHeight);  								}  							else  								{  								e.Graphics.DrawRectangle(blackPen' totalRowHeight' 1 + (row * totalRowHeight)' maxWidth' rowHeight);  								}  							e.Graphics.FillRectangle(new SolidBrush(te.color)' totalRowHeight + 1' 2 + (row * totalRowHeight)' maxWidth - 1' rowHeight - 1);    							// einzelne Events zeichnen  							foreach (TimelineEvent ev in te.events)  								{  								int startPosition = totalRowHeight + (int)Math.Round(ev.eventTime * zoom);  								int length = (int)Math.Round(ev.eventLength * zoom);  								e.Graphics.FillRectangle(new SolidBrush(ev.color)' startPosition' 2 + (row * totalRowHeight)' length' rowHeight - 1);  								e.Graphics.DrawLine(blackPen' startPosition' 2 + (row * totalRowHeight)' startPosition' totalRowHeight - 2 + (row * totalRowHeight));  								e.Graphics.DrawLine(blackPen' startPosition + length' 2 + (row * totalRowHeight)' startPosition + length' totalRowHeight - 2 + (row * totalRowHeight));  								}    							e.Graphics.DrawString(te.name' calibriFont' blackBrush' new PointF(totalRowHeight + 3' row * totalRowHeight));  							}  						}    					row++;  					}        				// Lineal zeichnen  				dottedPen.DashStyle = System.Drawing.Drawing2D.DashStyle.Dash;    				e.Graphics.DrawLine(blackPen' totalRowHeight' this.ClientSize.Height - 1' this.Width' this.Height - 1);    				for (int i = 0; i <= steuerung.maxTime / 10; i++)  					{  					e.Graphics.DrawLine(blackPen' totalRowHeight + i * 10 * zoom' this.Height - 1' totalRowHeight + i * 10 * zoom' this.Height - 7);  					e.Graphics.DrawString((i * 10).ToString()' calibriFont' blackBrush' new PointF(totalRowHeight + (i * 10 * zoom) - 8' this.Height - 18));  					}    				// aktuelle Zeit zeichnen  				e.Graphics.DrawLine(dottedPen' totalRowHeight + (int)Math.Round(timelineBarTime * zoom)' 0' totalRowHeight + (int)Math.Round(timelineBarTime * zoom)' Height);  				}
Magic Number,CityTrafficSimulator,TimelineControl,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TimelineControl.cs,TimelineControl_Paint,The following statement contains a magic number: if (steuerung != null)  				{  				int maxWidth = (int)Math.Round(m_zoom * steuerung.maxTime);    				int row = 0;  				foreach (TimelineGroup tg in steuerung.groups)  					{  					// zusammengefaltete Gruppe zeichnen  					if (tg.collapsed)  						{  						if (tg == m_selectedGroup)  							{  							e.Graphics.FillRectangle(backgroundBrush' 0' 1 + (row * totalRowHeight)' ClientSize.Width' totalRowHeight);  							}    						// Gruppenname zeichnen  						e.Graphics.DrawString(tg.title' calibriFont' blackBrush' new PointF(totalRowHeight + 3' row * totalRowHeight));    						// Pluszeichen malen  						e.Graphics.DrawRectangle(blackPen' 0' 1 + (row * totalRowHeight)' rowHeight' rowHeight);  						e.Graphics.DrawLine(blackPen' 2' 1 + (row * totalRowHeight) + rowHeight / 2' rowHeight - 2' 1 + (row * totalRowHeight) + rowHeight / 2);  						e.Graphics.DrawLine(blackPen' rowHeight / 2' 1 + (row * totalRowHeight) + 2' rowHeight / 2' 1 + (row * totalRowHeight) + rowHeight - 2);  						}  					// aufgefaltete Gruppe zeichnen  					else  						{  						if (tg == m_selectedGroup)  							{  							e.Graphics.FillRectangle(backgroundBrush' 0' 1 + (row * totalRowHeight)' ClientSize.Width' (1 + tg.entries.Count) * totalRowHeight);  							}    						// Gruppenname zeichnen  						e.Graphics.DrawString(tg.title' calibriFont' blackBrush' new PointF(totalRowHeight + 3' row * totalRowHeight));    						// Minuszeichen malen  						e.Graphics.DrawRectangle(blackPen' 0' 1 + (row * totalRowHeight)' rowHeight' rowHeight);  						e.Graphics.DrawLine(blackPen' 2' 1 + (row * totalRowHeight) + rowHeight / 2' rowHeight - 2' 1 + (row * totalRowHeight) + rowHeight / 2);    						// vertikale Linie unter Minuszeichen malen  						if (tg.entries.Count > 0)  							e.Graphics.DrawLine(blackPen' rowHeight / 2' row * totalRowHeight + totalRowHeight' rowHeight / 2' (row + tg.entries.Count) * totalRowHeight + totalRowHeight / 2);      						// Entries zeichnen  						foreach (TimelineEntry te in tg.entries)  							{  							row++;    							// horizontale Linie links malen  							e.Graphics.DrawLine(blackPen' totalRowHeight / 2' row * totalRowHeight + totalRowHeight / 2' totalRowHeight / 2 + totalRowHeight / 4' row * totalRowHeight + totalRowHeight / 2);    							// Balken malen  							if (te == selectedEntry)  								{  								e.Graphics.DrawRectangle(dottedPen' totalRowHeight' 1 + (row * totalRowHeight)' maxWidth' rowHeight);  								}  							else  								{  								e.Graphics.DrawRectangle(blackPen' totalRowHeight' 1 + (row * totalRowHeight)' maxWidth' rowHeight);  								}  							e.Graphics.FillRectangle(new SolidBrush(te.color)' totalRowHeight + 1' 2 + (row * totalRowHeight)' maxWidth - 1' rowHeight - 1);    							// einzelne Events zeichnen  							foreach (TimelineEvent ev in te.events)  								{  								int startPosition = totalRowHeight + (int)Math.Round(ev.eventTime * zoom);  								int length = (int)Math.Round(ev.eventLength * zoom);  								e.Graphics.FillRectangle(new SolidBrush(ev.color)' startPosition' 2 + (row * totalRowHeight)' length' rowHeight - 1);  								e.Graphics.DrawLine(blackPen' startPosition' 2 + (row * totalRowHeight)' startPosition' totalRowHeight - 2 + (row * totalRowHeight));  								e.Graphics.DrawLine(blackPen' startPosition + length' 2 + (row * totalRowHeight)' startPosition + length' totalRowHeight - 2 + (row * totalRowHeight));  								}    							e.Graphics.DrawString(te.name' calibriFont' blackBrush' new PointF(totalRowHeight + 3' row * totalRowHeight));  							}  						}    					row++;  					}        				// Lineal zeichnen  				dottedPen.DashStyle = System.Drawing.Drawing2D.DashStyle.Dash;    				e.Graphics.DrawLine(blackPen' totalRowHeight' this.ClientSize.Height - 1' this.Width' this.Height - 1);    				for (int i = 0; i <= steuerung.maxTime / 10; i++)  					{  					e.Graphics.DrawLine(blackPen' totalRowHeight + i * 10 * zoom' this.Height - 1' totalRowHeight + i * 10 * zoom' this.Height - 7);  					e.Graphics.DrawString((i * 10).ToString()' calibriFont' blackBrush' new PointF(totalRowHeight + (i * 10 * zoom) - 8' this.Height - 18));  					}    				// aktuelle Zeit zeichnen  				e.Graphics.DrawLine(dottedPen' totalRowHeight + (int)Math.Round(timelineBarTime * zoom)' 0' totalRowHeight + (int)Math.Round(timelineBarTime * zoom)' Height);  				}
Magic Number,CityTrafficSimulator,TimelineControl,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TimelineControl.cs,TimelineControl_Paint,The following statement contains a magic number: if (steuerung != null)  				{  				int maxWidth = (int)Math.Round(m_zoom * steuerung.maxTime);    				int row = 0;  				foreach (TimelineGroup tg in steuerung.groups)  					{  					// zusammengefaltete Gruppe zeichnen  					if (tg.collapsed)  						{  						if (tg == m_selectedGroup)  							{  							e.Graphics.FillRectangle(backgroundBrush' 0' 1 + (row * totalRowHeight)' ClientSize.Width' totalRowHeight);  							}    						// Gruppenname zeichnen  						e.Graphics.DrawString(tg.title' calibriFont' blackBrush' new PointF(totalRowHeight + 3' row * totalRowHeight));    						// Pluszeichen malen  						e.Graphics.DrawRectangle(blackPen' 0' 1 + (row * totalRowHeight)' rowHeight' rowHeight);  						e.Graphics.DrawLine(blackPen' 2' 1 + (row * totalRowHeight) + rowHeight / 2' rowHeight - 2' 1 + (row * totalRowHeight) + rowHeight / 2);  						e.Graphics.DrawLine(blackPen' rowHeight / 2' 1 + (row * totalRowHeight) + 2' rowHeight / 2' 1 + (row * totalRowHeight) + rowHeight - 2);  						}  					// aufgefaltete Gruppe zeichnen  					else  						{  						if (tg == m_selectedGroup)  							{  							e.Graphics.FillRectangle(backgroundBrush' 0' 1 + (row * totalRowHeight)' ClientSize.Width' (1 + tg.entries.Count) * totalRowHeight);  							}    						// Gruppenname zeichnen  						e.Graphics.DrawString(tg.title' calibriFont' blackBrush' new PointF(totalRowHeight + 3' row * totalRowHeight));    						// Minuszeichen malen  						e.Graphics.DrawRectangle(blackPen' 0' 1 + (row * totalRowHeight)' rowHeight' rowHeight);  						e.Graphics.DrawLine(blackPen' 2' 1 + (row * totalRowHeight) + rowHeight / 2' rowHeight - 2' 1 + (row * totalRowHeight) + rowHeight / 2);    						// vertikale Linie unter Minuszeichen malen  						if (tg.entries.Count > 0)  							e.Graphics.DrawLine(blackPen' rowHeight / 2' row * totalRowHeight + totalRowHeight' rowHeight / 2' (row + tg.entries.Count) * totalRowHeight + totalRowHeight / 2);      						// Entries zeichnen  						foreach (TimelineEntry te in tg.entries)  							{  							row++;    							// horizontale Linie links malen  							e.Graphics.DrawLine(blackPen' totalRowHeight / 2' row * totalRowHeight + totalRowHeight / 2' totalRowHeight / 2 + totalRowHeight / 4' row * totalRowHeight + totalRowHeight / 2);    							// Balken malen  							if (te == selectedEntry)  								{  								e.Graphics.DrawRectangle(dottedPen' totalRowHeight' 1 + (row * totalRowHeight)' maxWidth' rowHeight);  								}  							else  								{  								e.Graphics.DrawRectangle(blackPen' totalRowHeight' 1 + (row * totalRowHeight)' maxWidth' rowHeight);  								}  							e.Graphics.FillRectangle(new SolidBrush(te.color)' totalRowHeight + 1' 2 + (row * totalRowHeight)' maxWidth - 1' rowHeight - 1);    							// einzelne Events zeichnen  							foreach (TimelineEvent ev in te.events)  								{  								int startPosition = totalRowHeight + (int)Math.Round(ev.eventTime * zoom);  								int length = (int)Math.Round(ev.eventLength * zoom);  								e.Graphics.FillRectangle(new SolidBrush(ev.color)' startPosition' 2 + (row * totalRowHeight)' length' rowHeight - 1);  								e.Graphics.DrawLine(blackPen' startPosition' 2 + (row * totalRowHeight)' startPosition' totalRowHeight - 2 + (row * totalRowHeight));  								e.Graphics.DrawLine(blackPen' startPosition + length' 2 + (row * totalRowHeight)' startPosition + length' totalRowHeight - 2 + (row * totalRowHeight));  								}    							e.Graphics.DrawString(te.name' calibriFont' blackBrush' new PointF(totalRowHeight + 3' row * totalRowHeight));  							}  						}    					row++;  					}        				// Lineal zeichnen  				dottedPen.DashStyle = System.Drawing.Drawing2D.DashStyle.Dash;    				e.Graphics.DrawLine(blackPen' totalRowHeight' this.ClientSize.Height - 1' this.Width' this.Height - 1);    				for (int i = 0; i <= steuerung.maxTime / 10; i++)  					{  					e.Graphics.DrawLine(blackPen' totalRowHeight + i * 10 * zoom' this.Height - 1' totalRowHeight + i * 10 * zoom' this.Height - 7);  					e.Graphics.DrawString((i * 10).ToString()' calibriFont' blackBrush' new PointF(totalRowHeight + (i * 10 * zoom) - 8' this.Height - 18));  					}    				// aktuelle Zeit zeichnen  				e.Graphics.DrawLine(dottedPen' totalRowHeight + (int)Math.Round(timelineBarTime * zoom)' 0' totalRowHeight + (int)Math.Round(timelineBarTime * zoom)' Height);  				}
Magic Number,CityTrafficSimulator,TimelineControl,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TimelineControl.cs,TimelineControl_Paint,The following statement contains a magic number: if (steuerung != null)  				{  				int maxWidth = (int)Math.Round(m_zoom * steuerung.maxTime);    				int row = 0;  				foreach (TimelineGroup tg in steuerung.groups)  					{  					// zusammengefaltete Gruppe zeichnen  					if (tg.collapsed)  						{  						if (tg == m_selectedGroup)  							{  							e.Graphics.FillRectangle(backgroundBrush' 0' 1 + (row * totalRowHeight)' ClientSize.Width' totalRowHeight);  							}    						// Gruppenname zeichnen  						e.Graphics.DrawString(tg.title' calibriFont' blackBrush' new PointF(totalRowHeight + 3' row * totalRowHeight));    						// Pluszeichen malen  						e.Graphics.DrawRectangle(blackPen' 0' 1 + (row * totalRowHeight)' rowHeight' rowHeight);  						e.Graphics.DrawLine(blackPen' 2' 1 + (row * totalRowHeight) + rowHeight / 2' rowHeight - 2' 1 + (row * totalRowHeight) + rowHeight / 2);  						e.Graphics.DrawLine(blackPen' rowHeight / 2' 1 + (row * totalRowHeight) + 2' rowHeight / 2' 1 + (row * totalRowHeight) + rowHeight - 2);  						}  					// aufgefaltete Gruppe zeichnen  					else  						{  						if (tg == m_selectedGroup)  							{  							e.Graphics.FillRectangle(backgroundBrush' 0' 1 + (row * totalRowHeight)' ClientSize.Width' (1 + tg.entries.Count) * totalRowHeight);  							}    						// Gruppenname zeichnen  						e.Graphics.DrawString(tg.title' calibriFont' blackBrush' new PointF(totalRowHeight + 3' row * totalRowHeight));    						// Minuszeichen malen  						e.Graphics.DrawRectangle(blackPen' 0' 1 + (row * totalRowHeight)' rowHeight' rowHeight);  						e.Graphics.DrawLine(blackPen' 2' 1 + (row * totalRowHeight) + rowHeight / 2' rowHeight - 2' 1 + (row * totalRowHeight) + rowHeight / 2);    						// vertikale Linie unter Minuszeichen malen  						if (tg.entries.Count > 0)  							e.Graphics.DrawLine(blackPen' rowHeight / 2' row * totalRowHeight + totalRowHeight' rowHeight / 2' (row + tg.entries.Count) * totalRowHeight + totalRowHeight / 2);      						// Entries zeichnen  						foreach (TimelineEntry te in tg.entries)  							{  							row++;    							// horizontale Linie links malen  							e.Graphics.DrawLine(blackPen' totalRowHeight / 2' row * totalRowHeight + totalRowHeight / 2' totalRowHeight / 2 + totalRowHeight / 4' row * totalRowHeight + totalRowHeight / 2);    							// Balken malen  							if (te == selectedEntry)  								{  								e.Graphics.DrawRectangle(dottedPen' totalRowHeight' 1 + (row * totalRowHeight)' maxWidth' rowHeight);  								}  							else  								{  								e.Graphics.DrawRectangle(blackPen' totalRowHeight' 1 + (row * totalRowHeight)' maxWidth' rowHeight);  								}  							e.Graphics.FillRectangle(new SolidBrush(te.color)' totalRowHeight + 1' 2 + (row * totalRowHeight)' maxWidth - 1' rowHeight - 1);    							// einzelne Events zeichnen  							foreach (TimelineEvent ev in te.events)  								{  								int startPosition = totalRowHeight + (int)Math.Round(ev.eventTime * zoom);  								int length = (int)Math.Round(ev.eventLength * zoom);  								e.Graphics.FillRectangle(new SolidBrush(ev.color)' startPosition' 2 + (row * totalRowHeight)' length' rowHeight - 1);  								e.Graphics.DrawLine(blackPen' startPosition' 2 + (row * totalRowHeight)' startPosition' totalRowHeight - 2 + (row * totalRowHeight));  								e.Graphics.DrawLine(blackPen' startPosition + length' 2 + (row * totalRowHeight)' startPosition + length' totalRowHeight - 2 + (row * totalRowHeight));  								}    							e.Graphics.DrawString(te.name' calibriFont' blackBrush' new PointF(totalRowHeight + 3' row * totalRowHeight));  							}  						}    					row++;  					}        				// Lineal zeichnen  				dottedPen.DashStyle = System.Drawing.Drawing2D.DashStyle.Dash;    				e.Graphics.DrawLine(blackPen' totalRowHeight' this.ClientSize.Height - 1' this.Width' this.Height - 1);    				for (int i = 0; i <= steuerung.maxTime / 10; i++)  					{  					e.Graphics.DrawLine(blackPen' totalRowHeight + i * 10 * zoom' this.Height - 1' totalRowHeight + i * 10 * zoom' this.Height - 7);  					e.Graphics.DrawString((i * 10).ToString()' calibriFont' blackBrush' new PointF(totalRowHeight + (i * 10 * zoom) - 8' this.Height - 18));  					}    				// aktuelle Zeit zeichnen  				e.Graphics.DrawLine(dottedPen' totalRowHeight + (int)Math.Round(timelineBarTime * zoom)' 0' totalRowHeight + (int)Math.Round(timelineBarTime * zoom)' Height);  				}
Magic Number,CityTrafficSimulator,TimelineControl,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TimelineControl.cs,TimelineControl_Paint,The following statement contains a magic number: if (steuerung != null)  				{  				int maxWidth = (int)Math.Round(m_zoom * steuerung.maxTime);    				int row = 0;  				foreach (TimelineGroup tg in steuerung.groups)  					{  					// zusammengefaltete Gruppe zeichnen  					if (tg.collapsed)  						{  						if (tg == m_selectedGroup)  							{  							e.Graphics.FillRectangle(backgroundBrush' 0' 1 + (row * totalRowHeight)' ClientSize.Width' totalRowHeight);  							}    						// Gruppenname zeichnen  						e.Graphics.DrawString(tg.title' calibriFont' blackBrush' new PointF(totalRowHeight + 3' row * totalRowHeight));    						// Pluszeichen malen  						e.Graphics.DrawRectangle(blackPen' 0' 1 + (row * totalRowHeight)' rowHeight' rowHeight);  						e.Graphics.DrawLine(blackPen' 2' 1 + (row * totalRowHeight) + rowHeight / 2' rowHeight - 2' 1 + (row * totalRowHeight) + rowHeight / 2);  						e.Graphics.DrawLine(blackPen' rowHeight / 2' 1 + (row * totalRowHeight) + 2' rowHeight / 2' 1 + (row * totalRowHeight) + rowHeight - 2);  						}  					// aufgefaltete Gruppe zeichnen  					else  						{  						if (tg == m_selectedGroup)  							{  							e.Graphics.FillRectangle(backgroundBrush' 0' 1 + (row * totalRowHeight)' ClientSize.Width' (1 + tg.entries.Count) * totalRowHeight);  							}    						// Gruppenname zeichnen  						e.Graphics.DrawString(tg.title' calibriFont' blackBrush' new PointF(totalRowHeight + 3' row * totalRowHeight));    						// Minuszeichen malen  						e.Graphics.DrawRectangle(blackPen' 0' 1 + (row * totalRowHeight)' rowHeight' rowHeight);  						e.Graphics.DrawLine(blackPen' 2' 1 + (row * totalRowHeight) + rowHeight / 2' rowHeight - 2' 1 + (row * totalRowHeight) + rowHeight / 2);    						// vertikale Linie unter Minuszeichen malen  						if (tg.entries.Count > 0)  							e.Graphics.DrawLine(blackPen' rowHeight / 2' row * totalRowHeight + totalRowHeight' rowHeight / 2' (row + tg.entries.Count) * totalRowHeight + totalRowHeight / 2);      						// Entries zeichnen  						foreach (TimelineEntry te in tg.entries)  							{  							row++;    							// horizontale Linie links malen  							e.Graphics.DrawLine(blackPen' totalRowHeight / 2' row * totalRowHeight + totalRowHeight / 2' totalRowHeight / 2 + totalRowHeight / 4' row * totalRowHeight + totalRowHeight / 2);    							// Balken malen  							if (te == selectedEntry)  								{  								e.Graphics.DrawRectangle(dottedPen' totalRowHeight' 1 + (row * totalRowHeight)' maxWidth' rowHeight);  								}  							else  								{  								e.Graphics.DrawRectangle(blackPen' totalRowHeight' 1 + (row * totalRowHeight)' maxWidth' rowHeight);  								}  							e.Graphics.FillRectangle(new SolidBrush(te.color)' totalRowHeight + 1' 2 + (row * totalRowHeight)' maxWidth - 1' rowHeight - 1);    							// einzelne Events zeichnen  							foreach (TimelineEvent ev in te.events)  								{  								int startPosition = totalRowHeight + (int)Math.Round(ev.eventTime * zoom);  								int length = (int)Math.Round(ev.eventLength * zoom);  								e.Graphics.FillRectangle(new SolidBrush(ev.color)' startPosition' 2 + (row * totalRowHeight)' length' rowHeight - 1);  								e.Graphics.DrawLine(blackPen' startPosition' 2 + (row * totalRowHeight)' startPosition' totalRowHeight - 2 + (row * totalRowHeight));  								e.Graphics.DrawLine(blackPen' startPosition + length' 2 + (row * totalRowHeight)' startPosition + length' totalRowHeight - 2 + (row * totalRowHeight));  								}    							e.Graphics.DrawString(te.name' calibriFont' blackBrush' new PointF(totalRowHeight + 3' row * totalRowHeight));  							}  						}    					row++;  					}        				// Lineal zeichnen  				dottedPen.DashStyle = System.Drawing.Drawing2D.DashStyle.Dash;    				e.Graphics.DrawLine(blackPen' totalRowHeight' this.ClientSize.Height - 1' this.Width' this.Height - 1);    				for (int i = 0; i <= steuerung.maxTime / 10; i++)  					{  					e.Graphics.DrawLine(blackPen' totalRowHeight + i * 10 * zoom' this.Height - 1' totalRowHeight + i * 10 * zoom' this.Height - 7);  					e.Graphics.DrawString((i * 10).ToString()' calibriFont' blackBrush' new PointF(totalRowHeight + (i * 10 * zoom) - 8' this.Height - 18));  					}    				// aktuelle Zeit zeichnen  				e.Graphics.DrawLine(dottedPen' totalRowHeight + (int)Math.Round(timelineBarTime * zoom)' 0' totalRowHeight + (int)Math.Round(timelineBarTime * zoom)' Height);  				}
Magic Number,CityTrafficSimulator,TimelineControl,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TimelineControl.cs,TimelineControl_Paint,The following statement contains a magic number: if (steuerung != null)  				{  				int maxWidth = (int)Math.Round(m_zoom * steuerung.maxTime);    				int row = 0;  				foreach (TimelineGroup tg in steuerung.groups)  					{  					// zusammengefaltete Gruppe zeichnen  					if (tg.collapsed)  						{  						if (tg == m_selectedGroup)  							{  							e.Graphics.FillRectangle(backgroundBrush' 0' 1 + (row * totalRowHeight)' ClientSize.Width' totalRowHeight);  							}    						// Gruppenname zeichnen  						e.Graphics.DrawString(tg.title' calibriFont' blackBrush' new PointF(totalRowHeight + 3' row * totalRowHeight));    						// Pluszeichen malen  						e.Graphics.DrawRectangle(blackPen' 0' 1 + (row * totalRowHeight)' rowHeight' rowHeight);  						e.Graphics.DrawLine(blackPen' 2' 1 + (row * totalRowHeight) + rowHeight / 2' rowHeight - 2' 1 + (row * totalRowHeight) + rowHeight / 2);  						e.Graphics.DrawLine(blackPen' rowHeight / 2' 1 + (row * totalRowHeight) + 2' rowHeight / 2' 1 + (row * totalRowHeight) + rowHeight - 2);  						}  					// aufgefaltete Gruppe zeichnen  					else  						{  						if (tg == m_selectedGroup)  							{  							e.Graphics.FillRectangle(backgroundBrush' 0' 1 + (row * totalRowHeight)' ClientSize.Width' (1 + tg.entries.Count) * totalRowHeight);  							}    						// Gruppenname zeichnen  						e.Graphics.DrawString(tg.title' calibriFont' blackBrush' new PointF(totalRowHeight + 3' row * totalRowHeight));    						// Minuszeichen malen  						e.Graphics.DrawRectangle(blackPen' 0' 1 + (row * totalRowHeight)' rowHeight' rowHeight);  						e.Graphics.DrawLine(blackPen' 2' 1 + (row * totalRowHeight) + rowHeight / 2' rowHeight - 2' 1 + (row * totalRowHeight) + rowHeight / 2);    						// vertikale Linie unter Minuszeichen malen  						if (tg.entries.Count > 0)  							e.Graphics.DrawLine(blackPen' rowHeight / 2' row * totalRowHeight + totalRowHeight' rowHeight / 2' (row + tg.entries.Count) * totalRowHeight + totalRowHeight / 2);      						// Entries zeichnen  						foreach (TimelineEntry te in tg.entries)  							{  							row++;    							// horizontale Linie links malen  							e.Graphics.DrawLine(blackPen' totalRowHeight / 2' row * totalRowHeight + totalRowHeight / 2' totalRowHeight / 2 + totalRowHeight / 4' row * totalRowHeight + totalRowHeight / 2);    							// Balken malen  							if (te == selectedEntry)  								{  								e.Graphics.DrawRectangle(dottedPen' totalRowHeight' 1 + (row * totalRowHeight)' maxWidth' rowHeight);  								}  							else  								{  								e.Graphics.DrawRectangle(blackPen' totalRowHeight' 1 + (row * totalRowHeight)' maxWidth' rowHeight);  								}  							e.Graphics.FillRectangle(new SolidBrush(te.color)' totalRowHeight + 1' 2 + (row * totalRowHeight)' maxWidth - 1' rowHeight - 1);    							// einzelne Events zeichnen  							foreach (TimelineEvent ev in te.events)  								{  								int startPosition = totalRowHeight + (int)Math.Round(ev.eventTime * zoom);  								int length = (int)Math.Round(ev.eventLength * zoom);  								e.Graphics.FillRectangle(new SolidBrush(ev.color)' startPosition' 2 + (row * totalRowHeight)' length' rowHeight - 1);  								e.Graphics.DrawLine(blackPen' startPosition' 2 + (row * totalRowHeight)' startPosition' totalRowHeight - 2 + (row * totalRowHeight));  								e.Graphics.DrawLine(blackPen' startPosition + length' 2 + (row * totalRowHeight)' startPosition + length' totalRowHeight - 2 + (row * totalRowHeight));  								}    							e.Graphics.DrawString(te.name' calibriFont' blackBrush' new PointF(totalRowHeight + 3' row * totalRowHeight));  							}  						}    					row++;  					}        				// Lineal zeichnen  				dottedPen.DashStyle = System.Drawing.Drawing2D.DashStyle.Dash;    				e.Graphics.DrawLine(blackPen' totalRowHeight' this.ClientSize.Height - 1' this.Width' this.Height - 1);    				for (int i = 0; i <= steuerung.maxTime / 10; i++)  					{  					e.Graphics.DrawLine(blackPen' totalRowHeight + i * 10 * zoom' this.Height - 1' totalRowHeight + i * 10 * zoom' this.Height - 7);  					e.Graphics.DrawString((i * 10).ToString()' calibriFont' blackBrush' new PointF(totalRowHeight + (i * 10 * zoom) - 8' this.Height - 18));  					}    				// aktuelle Zeit zeichnen  				e.Graphics.DrawLine(dottedPen' totalRowHeight + (int)Math.Round(timelineBarTime * zoom)' 0' totalRowHeight + (int)Math.Round(timelineBarTime * zoom)' Height);  				}
Magic Number,CityTrafficSimulator,TimelineControl,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TimelineControl.cs,TimelineControl_Paint,The following statement contains a magic number: if (steuerung != null)  				{  				int maxWidth = (int)Math.Round(m_zoom * steuerung.maxTime);    				int row = 0;  				foreach (TimelineGroup tg in steuerung.groups)  					{  					// zusammengefaltete Gruppe zeichnen  					if (tg.collapsed)  						{  						if (tg == m_selectedGroup)  							{  							e.Graphics.FillRectangle(backgroundBrush' 0' 1 + (row * totalRowHeight)' ClientSize.Width' totalRowHeight);  							}    						// Gruppenname zeichnen  						e.Graphics.DrawString(tg.title' calibriFont' blackBrush' new PointF(totalRowHeight + 3' row * totalRowHeight));    						// Pluszeichen malen  						e.Graphics.DrawRectangle(blackPen' 0' 1 + (row * totalRowHeight)' rowHeight' rowHeight);  						e.Graphics.DrawLine(blackPen' 2' 1 + (row * totalRowHeight) + rowHeight / 2' rowHeight - 2' 1 + (row * totalRowHeight) + rowHeight / 2);  						e.Graphics.DrawLine(blackPen' rowHeight / 2' 1 + (row * totalRowHeight) + 2' rowHeight / 2' 1 + (row * totalRowHeight) + rowHeight - 2);  						}  					// aufgefaltete Gruppe zeichnen  					else  						{  						if (tg == m_selectedGroup)  							{  							e.Graphics.FillRectangle(backgroundBrush' 0' 1 + (row * totalRowHeight)' ClientSize.Width' (1 + tg.entries.Count) * totalRowHeight);  							}    						// Gruppenname zeichnen  						e.Graphics.DrawString(tg.title' calibriFont' blackBrush' new PointF(totalRowHeight + 3' row * totalRowHeight));    						// Minuszeichen malen  						e.Graphics.DrawRectangle(blackPen' 0' 1 + (row * totalRowHeight)' rowHeight' rowHeight);  						e.Graphics.DrawLine(blackPen' 2' 1 + (row * totalRowHeight) + rowHeight / 2' rowHeight - 2' 1 + (row * totalRowHeight) + rowHeight / 2);    						// vertikale Linie unter Minuszeichen malen  						if (tg.entries.Count > 0)  							e.Graphics.DrawLine(blackPen' rowHeight / 2' row * totalRowHeight + totalRowHeight' rowHeight / 2' (row + tg.entries.Count) * totalRowHeight + totalRowHeight / 2);      						// Entries zeichnen  						foreach (TimelineEntry te in tg.entries)  							{  							row++;    							// horizontale Linie links malen  							e.Graphics.DrawLine(blackPen' totalRowHeight / 2' row * totalRowHeight + totalRowHeight / 2' totalRowHeight / 2 + totalRowHeight / 4' row * totalRowHeight + totalRowHeight / 2);    							// Balken malen  							if (te == selectedEntry)  								{  								e.Graphics.DrawRectangle(dottedPen' totalRowHeight' 1 + (row * totalRowHeight)' maxWidth' rowHeight);  								}  							else  								{  								e.Graphics.DrawRectangle(blackPen' totalRowHeight' 1 + (row * totalRowHeight)' maxWidth' rowHeight);  								}  							e.Graphics.FillRectangle(new SolidBrush(te.color)' totalRowHeight + 1' 2 + (row * totalRowHeight)' maxWidth - 1' rowHeight - 1);    							// einzelne Events zeichnen  							foreach (TimelineEvent ev in te.events)  								{  								int startPosition = totalRowHeight + (int)Math.Round(ev.eventTime * zoom);  								int length = (int)Math.Round(ev.eventLength * zoom);  								e.Graphics.FillRectangle(new SolidBrush(ev.color)' startPosition' 2 + (row * totalRowHeight)' length' rowHeight - 1);  								e.Graphics.DrawLine(blackPen' startPosition' 2 + (row * totalRowHeight)' startPosition' totalRowHeight - 2 + (row * totalRowHeight));  								e.Graphics.DrawLine(blackPen' startPosition + length' 2 + (row * totalRowHeight)' startPosition + length' totalRowHeight - 2 + (row * totalRowHeight));  								}    							e.Graphics.DrawString(te.name' calibriFont' blackBrush' new PointF(totalRowHeight + 3' row * totalRowHeight));  							}  						}    					row++;  					}        				// Lineal zeichnen  				dottedPen.DashStyle = System.Drawing.Drawing2D.DashStyle.Dash;    				e.Graphics.DrawLine(blackPen' totalRowHeight' this.ClientSize.Height - 1' this.Width' this.Height - 1);    				for (int i = 0; i <= steuerung.maxTime / 10; i++)  					{  					e.Graphics.DrawLine(blackPen' totalRowHeight + i * 10 * zoom' this.Height - 1' totalRowHeight + i * 10 * zoom' this.Height - 7);  					e.Graphics.DrawString((i * 10).ToString()' calibriFont' blackBrush' new PointF(totalRowHeight + (i * 10 * zoom) - 8' this.Height - 18));  					}    				// aktuelle Zeit zeichnen  				e.Graphics.DrawLine(dottedPen' totalRowHeight + (int)Math.Round(timelineBarTime * zoom)' 0' totalRowHeight + (int)Math.Round(timelineBarTime * zoom)' Height);  				}
Magic Number,CityTrafficSimulator,TimelineControl,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TimelineControl.cs,TimelineControl_Paint,The following statement contains a magic number: if (steuerung != null)  				{  				int maxWidth = (int)Math.Round(m_zoom * steuerung.maxTime);    				int row = 0;  				foreach (TimelineGroup tg in steuerung.groups)  					{  					// zusammengefaltete Gruppe zeichnen  					if (tg.collapsed)  						{  						if (tg == m_selectedGroup)  							{  							e.Graphics.FillRectangle(backgroundBrush' 0' 1 + (row * totalRowHeight)' ClientSize.Width' totalRowHeight);  							}    						// Gruppenname zeichnen  						e.Graphics.DrawString(tg.title' calibriFont' blackBrush' new PointF(totalRowHeight + 3' row * totalRowHeight));    						// Pluszeichen malen  						e.Graphics.DrawRectangle(blackPen' 0' 1 + (row * totalRowHeight)' rowHeight' rowHeight);  						e.Graphics.DrawLine(blackPen' 2' 1 + (row * totalRowHeight) + rowHeight / 2' rowHeight - 2' 1 + (row * totalRowHeight) + rowHeight / 2);  						e.Graphics.DrawLine(blackPen' rowHeight / 2' 1 + (row * totalRowHeight) + 2' rowHeight / 2' 1 + (row * totalRowHeight) + rowHeight - 2);  						}  					// aufgefaltete Gruppe zeichnen  					else  						{  						if (tg == m_selectedGroup)  							{  							e.Graphics.FillRectangle(backgroundBrush' 0' 1 + (row * totalRowHeight)' ClientSize.Width' (1 + tg.entries.Count) * totalRowHeight);  							}    						// Gruppenname zeichnen  						e.Graphics.DrawString(tg.title' calibriFont' blackBrush' new PointF(totalRowHeight + 3' row * totalRowHeight));    						// Minuszeichen malen  						e.Graphics.DrawRectangle(blackPen' 0' 1 + (row * totalRowHeight)' rowHeight' rowHeight);  						e.Graphics.DrawLine(blackPen' 2' 1 + (row * totalRowHeight) + rowHeight / 2' rowHeight - 2' 1 + (row * totalRowHeight) + rowHeight / 2);    						// vertikale Linie unter Minuszeichen malen  						if (tg.entries.Count > 0)  							e.Graphics.DrawLine(blackPen' rowHeight / 2' row * totalRowHeight + totalRowHeight' rowHeight / 2' (row + tg.entries.Count) * totalRowHeight + totalRowHeight / 2);      						// Entries zeichnen  						foreach (TimelineEntry te in tg.entries)  							{  							row++;    							// horizontale Linie links malen  							e.Graphics.DrawLine(blackPen' totalRowHeight / 2' row * totalRowHeight + totalRowHeight / 2' totalRowHeight / 2 + totalRowHeight / 4' row * totalRowHeight + totalRowHeight / 2);    							// Balken malen  							if (te == selectedEntry)  								{  								e.Graphics.DrawRectangle(dottedPen' totalRowHeight' 1 + (row * totalRowHeight)' maxWidth' rowHeight);  								}  							else  								{  								e.Graphics.DrawRectangle(blackPen' totalRowHeight' 1 + (row * totalRowHeight)' maxWidth' rowHeight);  								}  							e.Graphics.FillRectangle(new SolidBrush(te.color)' totalRowHeight + 1' 2 + (row * totalRowHeight)' maxWidth - 1' rowHeight - 1);    							// einzelne Events zeichnen  							foreach (TimelineEvent ev in te.events)  								{  								int startPosition = totalRowHeight + (int)Math.Round(ev.eventTime * zoom);  								int length = (int)Math.Round(ev.eventLength * zoom);  								e.Graphics.FillRectangle(new SolidBrush(ev.color)' startPosition' 2 + (row * totalRowHeight)' length' rowHeight - 1);  								e.Graphics.DrawLine(blackPen' startPosition' 2 + (row * totalRowHeight)' startPosition' totalRowHeight - 2 + (row * totalRowHeight));  								e.Graphics.DrawLine(blackPen' startPosition + length' 2 + (row * totalRowHeight)' startPosition + length' totalRowHeight - 2 + (row * totalRowHeight));  								}    							e.Graphics.DrawString(te.name' calibriFont' blackBrush' new PointF(totalRowHeight + 3' row * totalRowHeight));  							}  						}    					row++;  					}        				// Lineal zeichnen  				dottedPen.DashStyle = System.Drawing.Drawing2D.DashStyle.Dash;    				e.Graphics.DrawLine(blackPen' totalRowHeight' this.ClientSize.Height - 1' this.Width' this.Height - 1);    				for (int i = 0; i <= steuerung.maxTime / 10; i++)  					{  					e.Graphics.DrawLine(blackPen' totalRowHeight + i * 10 * zoom' this.Height - 1' totalRowHeight + i * 10 * zoom' this.Height - 7);  					e.Graphics.DrawString((i * 10).ToString()' calibriFont' blackBrush' new PointF(totalRowHeight + (i * 10 * zoom) - 8' this.Height - 18));  					}    				// aktuelle Zeit zeichnen  				e.Graphics.DrawLine(dottedPen' totalRowHeight + (int)Math.Round(timelineBarTime * zoom)' 0' totalRowHeight + (int)Math.Round(timelineBarTime * zoom)' Height);  				}
Magic Number,CityTrafficSimulator,TimelineControl,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TimelineControl.cs,TimelineControl_Paint,The following statement contains a magic number: if (steuerung != null)  				{  				int maxWidth = (int)Math.Round(m_zoom * steuerung.maxTime);    				int row = 0;  				foreach (TimelineGroup tg in steuerung.groups)  					{  					// zusammengefaltete Gruppe zeichnen  					if (tg.collapsed)  						{  						if (tg == m_selectedGroup)  							{  							e.Graphics.FillRectangle(backgroundBrush' 0' 1 + (row * totalRowHeight)' ClientSize.Width' totalRowHeight);  							}    						// Gruppenname zeichnen  						e.Graphics.DrawString(tg.title' calibriFont' blackBrush' new PointF(totalRowHeight + 3' row * totalRowHeight));    						// Pluszeichen malen  						e.Graphics.DrawRectangle(blackPen' 0' 1 + (row * totalRowHeight)' rowHeight' rowHeight);  						e.Graphics.DrawLine(blackPen' 2' 1 + (row * totalRowHeight) + rowHeight / 2' rowHeight - 2' 1 + (row * totalRowHeight) + rowHeight / 2);  						e.Graphics.DrawLine(blackPen' rowHeight / 2' 1 + (row * totalRowHeight) + 2' rowHeight / 2' 1 + (row * totalRowHeight) + rowHeight - 2);  						}  					// aufgefaltete Gruppe zeichnen  					else  						{  						if (tg == m_selectedGroup)  							{  							e.Graphics.FillRectangle(backgroundBrush' 0' 1 + (row * totalRowHeight)' ClientSize.Width' (1 + tg.entries.Count) * totalRowHeight);  							}    						// Gruppenname zeichnen  						e.Graphics.DrawString(tg.title' calibriFont' blackBrush' new PointF(totalRowHeight + 3' row * totalRowHeight));    						// Minuszeichen malen  						e.Graphics.DrawRectangle(blackPen' 0' 1 + (row * totalRowHeight)' rowHeight' rowHeight);  						e.Graphics.DrawLine(blackPen' 2' 1 + (row * totalRowHeight) + rowHeight / 2' rowHeight - 2' 1 + (row * totalRowHeight) + rowHeight / 2);    						// vertikale Linie unter Minuszeichen malen  						if (tg.entries.Count > 0)  							e.Graphics.DrawLine(blackPen' rowHeight / 2' row * totalRowHeight + totalRowHeight' rowHeight / 2' (row + tg.entries.Count) * totalRowHeight + totalRowHeight / 2);      						// Entries zeichnen  						foreach (TimelineEntry te in tg.entries)  							{  							row++;    							// horizontale Linie links malen  							e.Graphics.DrawLine(blackPen' totalRowHeight / 2' row * totalRowHeight + totalRowHeight / 2' totalRowHeight / 2 + totalRowHeight / 4' row * totalRowHeight + totalRowHeight / 2);    							// Balken malen  							if (te == selectedEntry)  								{  								e.Graphics.DrawRectangle(dottedPen' totalRowHeight' 1 + (row * totalRowHeight)' maxWidth' rowHeight);  								}  							else  								{  								e.Graphics.DrawRectangle(blackPen' totalRowHeight' 1 + (row * totalRowHeight)' maxWidth' rowHeight);  								}  							e.Graphics.FillRectangle(new SolidBrush(te.color)' totalRowHeight + 1' 2 + (row * totalRowHeight)' maxWidth - 1' rowHeight - 1);    							// einzelne Events zeichnen  							foreach (TimelineEvent ev in te.events)  								{  								int startPosition = totalRowHeight + (int)Math.Round(ev.eventTime * zoom);  								int length = (int)Math.Round(ev.eventLength * zoom);  								e.Graphics.FillRectangle(new SolidBrush(ev.color)' startPosition' 2 + (row * totalRowHeight)' length' rowHeight - 1);  								e.Graphics.DrawLine(blackPen' startPosition' 2 + (row * totalRowHeight)' startPosition' totalRowHeight - 2 + (row * totalRowHeight));  								e.Graphics.DrawLine(blackPen' startPosition + length' 2 + (row * totalRowHeight)' startPosition + length' totalRowHeight - 2 + (row * totalRowHeight));  								}    							e.Graphics.DrawString(te.name' calibriFont' blackBrush' new PointF(totalRowHeight + 3' row * totalRowHeight));  							}  						}    					row++;  					}        				// Lineal zeichnen  				dottedPen.DashStyle = System.Drawing.Drawing2D.DashStyle.Dash;    				e.Graphics.DrawLine(blackPen' totalRowHeight' this.ClientSize.Height - 1' this.Width' this.Height - 1);    				for (int i = 0; i <= steuerung.maxTime / 10; i++)  					{  					e.Graphics.DrawLine(blackPen' totalRowHeight + i * 10 * zoom' this.Height - 1' totalRowHeight + i * 10 * zoom' this.Height - 7);  					e.Graphics.DrawString((i * 10).ToString()' calibriFont' blackBrush' new PointF(totalRowHeight + (i * 10 * zoom) - 8' this.Height - 18));  					}    				// aktuelle Zeit zeichnen  				e.Graphics.DrawLine(dottedPen' totalRowHeight + (int)Math.Round(timelineBarTime * zoom)' 0' totalRowHeight + (int)Math.Round(timelineBarTime * zoom)' Height);  				}
Magic Number,CityTrafficSimulator,TimelineControl,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TimelineControl.cs,TimelineControl_Paint,The following statement contains a magic number: if (steuerung != null)  				{  				int maxWidth = (int)Math.Round(m_zoom * steuerung.maxTime);    				int row = 0;  				foreach (TimelineGroup tg in steuerung.groups)  					{  					// zusammengefaltete Gruppe zeichnen  					if (tg.collapsed)  						{  						if (tg == m_selectedGroup)  							{  							e.Graphics.FillRectangle(backgroundBrush' 0' 1 + (row * totalRowHeight)' ClientSize.Width' totalRowHeight);  							}    						// Gruppenname zeichnen  						e.Graphics.DrawString(tg.title' calibriFont' blackBrush' new PointF(totalRowHeight + 3' row * totalRowHeight));    						// Pluszeichen malen  						e.Graphics.DrawRectangle(blackPen' 0' 1 + (row * totalRowHeight)' rowHeight' rowHeight);  						e.Graphics.DrawLine(blackPen' 2' 1 + (row * totalRowHeight) + rowHeight / 2' rowHeight - 2' 1 + (row * totalRowHeight) + rowHeight / 2);  						e.Graphics.DrawLine(blackPen' rowHeight / 2' 1 + (row * totalRowHeight) + 2' rowHeight / 2' 1 + (row * totalRowHeight) + rowHeight - 2);  						}  					// aufgefaltete Gruppe zeichnen  					else  						{  						if (tg == m_selectedGroup)  							{  							e.Graphics.FillRectangle(backgroundBrush' 0' 1 + (row * totalRowHeight)' ClientSize.Width' (1 + tg.entries.Count) * totalRowHeight);  							}    						// Gruppenname zeichnen  						e.Graphics.DrawString(tg.title' calibriFont' blackBrush' new PointF(totalRowHeight + 3' row * totalRowHeight));    						// Minuszeichen malen  						e.Graphics.DrawRectangle(blackPen' 0' 1 + (row * totalRowHeight)' rowHeight' rowHeight);  						e.Graphics.DrawLine(blackPen' 2' 1 + (row * totalRowHeight) + rowHeight / 2' rowHeight - 2' 1 + (row * totalRowHeight) + rowHeight / 2);    						// vertikale Linie unter Minuszeichen malen  						if (tg.entries.Count > 0)  							e.Graphics.DrawLine(blackPen' rowHeight / 2' row * totalRowHeight + totalRowHeight' rowHeight / 2' (row + tg.entries.Count) * totalRowHeight + totalRowHeight / 2);      						// Entries zeichnen  						foreach (TimelineEntry te in tg.entries)  							{  							row++;    							// horizontale Linie links malen  							e.Graphics.DrawLine(blackPen' totalRowHeight / 2' row * totalRowHeight + totalRowHeight / 2' totalRowHeight / 2 + totalRowHeight / 4' row * totalRowHeight + totalRowHeight / 2);    							// Balken malen  							if (te == selectedEntry)  								{  								e.Graphics.DrawRectangle(dottedPen' totalRowHeight' 1 + (row * totalRowHeight)' maxWidth' rowHeight);  								}  							else  								{  								e.Graphics.DrawRectangle(blackPen' totalRowHeight' 1 + (row * totalRowHeight)' maxWidth' rowHeight);  								}  							e.Graphics.FillRectangle(new SolidBrush(te.color)' totalRowHeight + 1' 2 + (row * totalRowHeight)' maxWidth - 1' rowHeight - 1);    							// einzelne Events zeichnen  							foreach (TimelineEvent ev in te.events)  								{  								int startPosition = totalRowHeight + (int)Math.Round(ev.eventTime * zoom);  								int length = (int)Math.Round(ev.eventLength * zoom);  								e.Graphics.FillRectangle(new SolidBrush(ev.color)' startPosition' 2 + (row * totalRowHeight)' length' rowHeight - 1);  								e.Graphics.DrawLine(blackPen' startPosition' 2 + (row * totalRowHeight)' startPosition' totalRowHeight - 2 + (row * totalRowHeight));  								e.Graphics.DrawLine(blackPen' startPosition + length' 2 + (row * totalRowHeight)' startPosition + length' totalRowHeight - 2 + (row * totalRowHeight));  								}    							e.Graphics.DrawString(te.name' calibriFont' blackBrush' new PointF(totalRowHeight + 3' row * totalRowHeight));  							}  						}    					row++;  					}        				// Lineal zeichnen  				dottedPen.DashStyle = System.Drawing.Drawing2D.DashStyle.Dash;    				e.Graphics.DrawLine(blackPen' totalRowHeight' this.ClientSize.Height - 1' this.Width' this.Height - 1);    				for (int i = 0; i <= steuerung.maxTime / 10; i++)  					{  					e.Graphics.DrawLine(blackPen' totalRowHeight + i * 10 * zoom' this.Height - 1' totalRowHeight + i * 10 * zoom' this.Height - 7);  					e.Graphics.DrawString((i * 10).ToString()' calibriFont' blackBrush' new PointF(totalRowHeight + (i * 10 * zoom) - 8' this.Height - 18));  					}    				// aktuelle Zeit zeichnen  				e.Graphics.DrawLine(dottedPen' totalRowHeight + (int)Math.Round(timelineBarTime * zoom)' 0' totalRowHeight + (int)Math.Round(timelineBarTime * zoom)' Height);  				}
Magic Number,CityTrafficSimulator,TimelineControl,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TimelineControl.cs,TimelineControl_MouseMove,The following statement contains a magic number: if (howToDrag == DragNDrop.MOVE_TIMELINE_BAR)  				{  				timelineBarTime = GetTimeAtControlPosition(e.Location' false);  				Invalidate();  				OnTimelineMoved();  				}  			else if (howToDrag == DragNDrop.MOVE_EVENT)  				{  				double time = GetTimeAtControlPosition(new Point(e.Location.X + eventToDragOffset' e.Location.Y)' true);  				selectedEntry.MoveEvent(eventToDrag' time);  				OnEventChanged(new EventChangedEventArgs(m_selectedEntry' eventToDrag' howToDrag));  				Invalidate();  				}  			else if (howToDrag == DragNDrop.MOVE_EVENT_START)  				{  				selectedEntry.MoveEventStart(eventToDrag' GetTimeAtControlPosition(e.Location' true));  				OnEventChanged(new EventChangedEventArgs(m_selectedEntry' eventToDrag' howToDrag));  				Invalidate();  				}  			else if (howToDrag == DragNDrop.MOVE_EVENT_END)  				{  				selectedEntry.MoveEventEnd(eventToDrag' GetTimeAtControlPosition(e.Location' true));  				OnEventChanged(new EventChangedEventArgs(m_selectedEntry' eventToDrag' howToDrag));  				Invalidate();  				}  			else if (howToDrag == DragNDrop.NONE)  				{  				TimelineEvent te = GetTimelineEventAtControlPosition(e.Location' false);    				// Mauszeiger ändern' falls über TimelineBar  				if (Math.Abs(e.X - GetHorizontalClientPositionAtCurrentTime()) < 2)  					{  					this.Cursor = Cursors.SizeWE;  					}    				// Mauszeiger ändern' falls über Plus/Minus einer Gruppe  				else if (e.X < rowHeight && GetGroupAtClientPosition(e.Location' true) != null)  					{  					this.Cursor = Cursors.Hand;  					}    				// Mauszeiger ändern' falls über den Ecken eines Events des selektierten TimelineEntries  				else if (te != null)  					{  					if (Math.Abs(GetClientPositionForTimelineEvent(te).X - e.Location.X) < 3)  						{  						this.Cursor = Cursors.SizeWE;  						}  					else if (Math.Abs(GetClientPositionForTimelineEvent(te).X + te.eventLength * zoom - e.Location.X) < 3)  						{  						this.Cursor = Cursors.SizeWE;  						}  					else  						{  						this.Cursor = Cursors.SizeAll;  						}    					}    				// Mauszeiger normal  				else  					{  					this.Cursor = Cursors.Default;  					}  				}
Magic Number,CityTrafficSimulator,TimelineControl,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TimelineControl.cs,TimelineControl_MouseMove,The following statement contains a magic number: if (howToDrag == DragNDrop.MOVE_TIMELINE_BAR)  				{  				timelineBarTime = GetTimeAtControlPosition(e.Location' false);  				Invalidate();  				OnTimelineMoved();  				}  			else if (howToDrag == DragNDrop.MOVE_EVENT)  				{  				double time = GetTimeAtControlPosition(new Point(e.Location.X + eventToDragOffset' e.Location.Y)' true);  				selectedEntry.MoveEvent(eventToDrag' time);  				OnEventChanged(new EventChangedEventArgs(m_selectedEntry' eventToDrag' howToDrag));  				Invalidate();  				}  			else if (howToDrag == DragNDrop.MOVE_EVENT_START)  				{  				selectedEntry.MoveEventStart(eventToDrag' GetTimeAtControlPosition(e.Location' true));  				OnEventChanged(new EventChangedEventArgs(m_selectedEntry' eventToDrag' howToDrag));  				Invalidate();  				}  			else if (howToDrag == DragNDrop.MOVE_EVENT_END)  				{  				selectedEntry.MoveEventEnd(eventToDrag' GetTimeAtControlPosition(e.Location' true));  				OnEventChanged(new EventChangedEventArgs(m_selectedEntry' eventToDrag' howToDrag));  				Invalidate();  				}  			else if (howToDrag == DragNDrop.NONE)  				{  				TimelineEvent te = GetTimelineEventAtControlPosition(e.Location' false);    				// Mauszeiger ändern' falls über TimelineBar  				if (Math.Abs(e.X - GetHorizontalClientPositionAtCurrentTime()) < 2)  					{  					this.Cursor = Cursors.SizeWE;  					}    				// Mauszeiger ändern' falls über Plus/Minus einer Gruppe  				else if (e.X < rowHeight && GetGroupAtClientPosition(e.Location' true) != null)  					{  					this.Cursor = Cursors.Hand;  					}    				// Mauszeiger ändern' falls über den Ecken eines Events des selektierten TimelineEntries  				else if (te != null)  					{  					if (Math.Abs(GetClientPositionForTimelineEvent(te).X - e.Location.X) < 3)  						{  						this.Cursor = Cursors.SizeWE;  						}  					else if (Math.Abs(GetClientPositionForTimelineEvent(te).X + te.eventLength * zoom - e.Location.X) < 3)  						{  						this.Cursor = Cursors.SizeWE;  						}  					else  						{  						this.Cursor = Cursors.SizeAll;  						}    					}    				// Mauszeiger normal  				else  					{  					this.Cursor = Cursors.Default;  					}  				}
Magic Number,CityTrafficSimulator,TimelineControl,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TimelineControl.cs,TimelineControl_MouseMove,The following statement contains a magic number: if (howToDrag == DragNDrop.MOVE_TIMELINE_BAR)  				{  				timelineBarTime = GetTimeAtControlPosition(e.Location' false);  				Invalidate();  				OnTimelineMoved();  				}  			else if (howToDrag == DragNDrop.MOVE_EVENT)  				{  				double time = GetTimeAtControlPosition(new Point(e.Location.X + eventToDragOffset' e.Location.Y)' true);  				selectedEntry.MoveEvent(eventToDrag' time);  				OnEventChanged(new EventChangedEventArgs(m_selectedEntry' eventToDrag' howToDrag));  				Invalidate();  				}  			else if (howToDrag == DragNDrop.MOVE_EVENT_START)  				{  				selectedEntry.MoveEventStart(eventToDrag' GetTimeAtControlPosition(e.Location' true));  				OnEventChanged(new EventChangedEventArgs(m_selectedEntry' eventToDrag' howToDrag));  				Invalidate();  				}  			else if (howToDrag == DragNDrop.MOVE_EVENT_END)  				{  				selectedEntry.MoveEventEnd(eventToDrag' GetTimeAtControlPosition(e.Location' true));  				OnEventChanged(new EventChangedEventArgs(m_selectedEntry' eventToDrag' howToDrag));  				Invalidate();  				}  			else if (howToDrag == DragNDrop.NONE)  				{  				TimelineEvent te = GetTimelineEventAtControlPosition(e.Location' false);    				// Mauszeiger ändern' falls über TimelineBar  				if (Math.Abs(e.X - GetHorizontalClientPositionAtCurrentTime()) < 2)  					{  					this.Cursor = Cursors.SizeWE;  					}    				// Mauszeiger ändern' falls über Plus/Minus einer Gruppe  				else if (e.X < rowHeight && GetGroupAtClientPosition(e.Location' true) != null)  					{  					this.Cursor = Cursors.Hand;  					}    				// Mauszeiger ändern' falls über den Ecken eines Events des selektierten TimelineEntries  				else if (te != null)  					{  					if (Math.Abs(GetClientPositionForTimelineEvent(te).X - e.Location.X) < 3)  						{  						this.Cursor = Cursors.SizeWE;  						}  					else if (Math.Abs(GetClientPositionForTimelineEvent(te).X + te.eventLength * zoom - e.Location.X) < 3)  						{  						this.Cursor = Cursors.SizeWE;  						}  					else  						{  						this.Cursor = Cursors.SizeAll;  						}    					}    				// Mauszeiger normal  				else  					{  					this.Cursor = Cursors.Default;  					}  				}
Magic Number,CityTrafficSimulator,TimelineControl,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TimelineControl.cs,TimelineControl_MouseDown,The following statement contains a magic number: if ((e.Button == MouseButtons.Left) && (Math.Abs(e.X - GetHorizontalClientPositionAtCurrentTime()) < 2))  				{  				// Drag'n'Drop Modus setzen  				howToDrag = DragNDrop.MOVE_TIMELINE_BAR;  				}    			// wurde ein Plus-/Minussysmbol einer Gruppe angeklickt?  			else if (e.X < rowHeight && GetGroupAtClientPosition(e.Location' true) != null)  				{  				TimelineGroup tg = GetGroupAtClientPosition(e.Location' true);  				tg.collapsed = !tg.collapsed;  				}    			// wurde vielleicht was anderes wichtiges angeklickt?  			else  				{  				TimelineEntry newEntry = GetTimelineEntryAtControlPosition(e.Location);  				TimelineGroup newGroup = GetGroupAtClientPosition(e.Location' false);    				if (newEntry != m_selectedEntry || newGroup != m_selectedGroup)  					{  					m_selectedGroup = newGroup;  					m_selectedEntry = newEntry;  					OnSelectionChanged();  					}    				// wurde ein TimelineEntry angeklickt?  				if (m_selectedEntry != null)  					{  					// gucken' ob es sich bei te um ein TrafficLight handelt  					TrafficLight tl = m_selectedEntry as TrafficLight;  					if (tl != null)  						{  						switch (e.Button)  							{  						case MouseButtons.Left:  							#region TimelineEvent hinzufügen  							if ((Control.ModifierKeys & Keys.Control) == Keys.Control)  								{  								double time = GetTimeAtControlPosition(e.Location' true);    								// Event hinzufügen' welches die Ampel umschaltet  								TimelineEvent eventToAdd = new TimelineEvent(time' Math.Min(1' (m_selectedEntry.GetTimeOfNextEvent(time) - time) / 2)' Color.Green' tl.SwitchToGreen' tl.SwitchToRed);  								m_selectedEntry.AddEvent(eventToAdd' true' false);    								howToDrag = DragNDrop.MOVE_EVENT_END;  								eventToDrag = eventToAdd;  								this.Cursor = Cursors.SizeWE;  								Invalidate();  								}  							#endregion    							#region TimelineEntry selektieren  							else  								{  								// Drag'n'Drop für Events initialisieren  								TimelineEvent theEvent = GetTimelineEventAtControlPosition(e.Location' true);  								if (theEvent != null)  									{  									if (Math.Abs(GetClientPositionForTimelineEvent(theEvent).X - e.Location.X) < 3)  										{  										howToDrag = DragNDrop.MOVE_EVENT_START;  										eventToDrag = theEvent;  										}  									else if (Math.Abs(GetClientPositionForTimelineEvent(theEvent).X + theEvent.eventLength * zoom - e.Location.X) < 3)  										{  										howToDrag = DragNDrop.MOVE_EVENT_END;  										eventToDrag = theEvent;  										}  									else  										{  										mouseDownPosition = e.Location;  										eventToDragOffset = GetClientPositionForTimelineEvent(theEvent).X - e.Location.X;  										howToDrag = DragNDrop.MOVE_EVENT;  										eventToDrag = theEvent;  										}  									}    								}  							#endregion  							break;    						case MouseButtons.Right:  							#region TimelineEvent entfernen  							if ((Control.ModifierKeys & Keys.Control) == Keys.Control)  								{  								double time = GetTimeAtControlPosition(e.Location' false);    								TimelineEvent eventToRemove = tl.GetEventAtTime(time);  								tl.RemoveEvent(eventToRemove);  								}  							#endregion  							break;  							}  						}  					}    				Invalidate();  				}
Magic Number,CityTrafficSimulator,TimelineControl,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TimelineControl.cs,TimelineControl_MouseDown,The following statement contains a magic number: if ((e.Button == MouseButtons.Left) && (Math.Abs(e.X - GetHorizontalClientPositionAtCurrentTime()) < 2))  				{  				// Drag'n'Drop Modus setzen  				howToDrag = DragNDrop.MOVE_TIMELINE_BAR;  				}    			// wurde ein Plus-/Minussysmbol einer Gruppe angeklickt?  			else if (e.X < rowHeight && GetGroupAtClientPosition(e.Location' true) != null)  				{  				TimelineGroup tg = GetGroupAtClientPosition(e.Location' true);  				tg.collapsed = !tg.collapsed;  				}    			// wurde vielleicht was anderes wichtiges angeklickt?  			else  				{  				TimelineEntry newEntry = GetTimelineEntryAtControlPosition(e.Location);  				TimelineGroup newGroup = GetGroupAtClientPosition(e.Location' false);    				if (newEntry != m_selectedEntry || newGroup != m_selectedGroup)  					{  					m_selectedGroup = newGroup;  					m_selectedEntry = newEntry;  					OnSelectionChanged();  					}    				// wurde ein TimelineEntry angeklickt?  				if (m_selectedEntry != null)  					{  					// gucken' ob es sich bei te um ein TrafficLight handelt  					TrafficLight tl = m_selectedEntry as TrafficLight;  					if (tl != null)  						{  						switch (e.Button)  							{  						case MouseButtons.Left:  							#region TimelineEvent hinzufügen  							if ((Control.ModifierKeys & Keys.Control) == Keys.Control)  								{  								double time = GetTimeAtControlPosition(e.Location' true);    								// Event hinzufügen' welches die Ampel umschaltet  								TimelineEvent eventToAdd = new TimelineEvent(time' Math.Min(1' (m_selectedEntry.GetTimeOfNextEvent(time) - time) / 2)' Color.Green' tl.SwitchToGreen' tl.SwitchToRed);  								m_selectedEntry.AddEvent(eventToAdd' true' false);    								howToDrag = DragNDrop.MOVE_EVENT_END;  								eventToDrag = eventToAdd;  								this.Cursor = Cursors.SizeWE;  								Invalidate();  								}  							#endregion    							#region TimelineEntry selektieren  							else  								{  								// Drag'n'Drop für Events initialisieren  								TimelineEvent theEvent = GetTimelineEventAtControlPosition(e.Location' true);  								if (theEvent != null)  									{  									if (Math.Abs(GetClientPositionForTimelineEvent(theEvent).X - e.Location.X) < 3)  										{  										howToDrag = DragNDrop.MOVE_EVENT_START;  										eventToDrag = theEvent;  										}  									else if (Math.Abs(GetClientPositionForTimelineEvent(theEvent).X + theEvent.eventLength * zoom - e.Location.X) < 3)  										{  										howToDrag = DragNDrop.MOVE_EVENT_END;  										eventToDrag = theEvent;  										}  									else  										{  										mouseDownPosition = e.Location;  										eventToDragOffset = GetClientPositionForTimelineEvent(theEvent).X - e.Location.X;  										howToDrag = DragNDrop.MOVE_EVENT;  										eventToDrag = theEvent;  										}  									}    								}  							#endregion  							break;    						case MouseButtons.Right:  							#region TimelineEvent entfernen  							if ((Control.ModifierKeys & Keys.Control) == Keys.Control)  								{  								double time = GetTimeAtControlPosition(e.Location' false);    								TimelineEvent eventToRemove = tl.GetEventAtTime(time);  								tl.RemoveEvent(eventToRemove);  								}  							#endregion  							break;  							}  						}  					}    				Invalidate();  				}
Magic Number,CityTrafficSimulator,TimelineControl,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TimelineControl.cs,TimelineControl_MouseDown,The following statement contains a magic number: if ((e.Button == MouseButtons.Left) && (Math.Abs(e.X - GetHorizontalClientPositionAtCurrentTime()) < 2))  				{  				// Drag'n'Drop Modus setzen  				howToDrag = DragNDrop.MOVE_TIMELINE_BAR;  				}    			// wurde ein Plus-/Minussysmbol einer Gruppe angeklickt?  			else if (e.X < rowHeight && GetGroupAtClientPosition(e.Location' true) != null)  				{  				TimelineGroup tg = GetGroupAtClientPosition(e.Location' true);  				tg.collapsed = !tg.collapsed;  				}    			// wurde vielleicht was anderes wichtiges angeklickt?  			else  				{  				TimelineEntry newEntry = GetTimelineEntryAtControlPosition(e.Location);  				TimelineGroup newGroup = GetGroupAtClientPosition(e.Location' false);    				if (newEntry != m_selectedEntry || newGroup != m_selectedGroup)  					{  					m_selectedGroup = newGroup;  					m_selectedEntry = newEntry;  					OnSelectionChanged();  					}    				// wurde ein TimelineEntry angeklickt?  				if (m_selectedEntry != null)  					{  					// gucken' ob es sich bei te um ein TrafficLight handelt  					TrafficLight tl = m_selectedEntry as TrafficLight;  					if (tl != null)  						{  						switch (e.Button)  							{  						case MouseButtons.Left:  							#region TimelineEvent hinzufügen  							if ((Control.ModifierKeys & Keys.Control) == Keys.Control)  								{  								double time = GetTimeAtControlPosition(e.Location' true);    								// Event hinzufügen' welches die Ampel umschaltet  								TimelineEvent eventToAdd = new TimelineEvent(time' Math.Min(1' (m_selectedEntry.GetTimeOfNextEvent(time) - time) / 2)' Color.Green' tl.SwitchToGreen' tl.SwitchToRed);  								m_selectedEntry.AddEvent(eventToAdd' true' false);    								howToDrag = DragNDrop.MOVE_EVENT_END;  								eventToDrag = eventToAdd;  								this.Cursor = Cursors.SizeWE;  								Invalidate();  								}  							#endregion    							#region TimelineEntry selektieren  							else  								{  								// Drag'n'Drop für Events initialisieren  								TimelineEvent theEvent = GetTimelineEventAtControlPosition(e.Location' true);  								if (theEvent != null)  									{  									if (Math.Abs(GetClientPositionForTimelineEvent(theEvent).X - e.Location.X) < 3)  										{  										howToDrag = DragNDrop.MOVE_EVENT_START;  										eventToDrag = theEvent;  										}  									else if (Math.Abs(GetClientPositionForTimelineEvent(theEvent).X + theEvent.eventLength * zoom - e.Location.X) < 3)  										{  										howToDrag = DragNDrop.MOVE_EVENT_END;  										eventToDrag = theEvent;  										}  									else  										{  										mouseDownPosition = e.Location;  										eventToDragOffset = GetClientPositionForTimelineEvent(theEvent).X - e.Location.X;  										howToDrag = DragNDrop.MOVE_EVENT;  										eventToDrag = theEvent;  										}  									}    								}  							#endregion  							break;    						case MouseButtons.Right:  							#region TimelineEvent entfernen  							if ((Control.ModifierKeys & Keys.Control) == Keys.Control)  								{  								double time = GetTimeAtControlPosition(e.Location' false);    								TimelineEvent eventToRemove = tl.GetEventAtTime(time);  								tl.RemoveEvent(eventToRemove);  								}  							#endregion  							break;  							}  						}  					}    				Invalidate();  				}
Magic Number,CityTrafficSimulator,TimelineControl,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TimelineControl.cs,TimelineControl_MouseDown,The following statement contains a magic number: if ((e.Button == MouseButtons.Left) && (Math.Abs(e.X - GetHorizontalClientPositionAtCurrentTime()) < 2))  				{  				// Drag'n'Drop Modus setzen  				howToDrag = DragNDrop.MOVE_TIMELINE_BAR;  				}    			// wurde ein Plus-/Minussysmbol einer Gruppe angeklickt?  			else if (e.X < rowHeight && GetGroupAtClientPosition(e.Location' true) != null)  				{  				TimelineGroup tg = GetGroupAtClientPosition(e.Location' true);  				tg.collapsed = !tg.collapsed;  				}    			// wurde vielleicht was anderes wichtiges angeklickt?  			else  				{  				TimelineEntry newEntry = GetTimelineEntryAtControlPosition(e.Location);  				TimelineGroup newGroup = GetGroupAtClientPosition(e.Location' false);    				if (newEntry != m_selectedEntry || newGroup != m_selectedGroup)  					{  					m_selectedGroup = newGroup;  					m_selectedEntry = newEntry;  					OnSelectionChanged();  					}    				// wurde ein TimelineEntry angeklickt?  				if (m_selectedEntry != null)  					{  					// gucken' ob es sich bei te um ein TrafficLight handelt  					TrafficLight tl = m_selectedEntry as TrafficLight;  					if (tl != null)  						{  						switch (e.Button)  							{  						case MouseButtons.Left:  							#region TimelineEvent hinzufügen  							if ((Control.ModifierKeys & Keys.Control) == Keys.Control)  								{  								double time = GetTimeAtControlPosition(e.Location' true);    								// Event hinzufügen' welches die Ampel umschaltet  								TimelineEvent eventToAdd = new TimelineEvent(time' Math.Min(1' (m_selectedEntry.GetTimeOfNextEvent(time) - time) / 2)' Color.Green' tl.SwitchToGreen' tl.SwitchToRed);  								m_selectedEntry.AddEvent(eventToAdd' true' false);    								howToDrag = DragNDrop.MOVE_EVENT_END;  								eventToDrag = eventToAdd;  								this.Cursor = Cursors.SizeWE;  								Invalidate();  								}  							#endregion    							#region TimelineEntry selektieren  							else  								{  								// Drag'n'Drop für Events initialisieren  								TimelineEvent theEvent = GetTimelineEventAtControlPosition(e.Location' true);  								if (theEvent != null)  									{  									if (Math.Abs(GetClientPositionForTimelineEvent(theEvent).X - e.Location.X) < 3)  										{  										howToDrag = DragNDrop.MOVE_EVENT_START;  										eventToDrag = theEvent;  										}  									else if (Math.Abs(GetClientPositionForTimelineEvent(theEvent).X + theEvent.eventLength * zoom - e.Location.X) < 3)  										{  										howToDrag = DragNDrop.MOVE_EVENT_END;  										eventToDrag = theEvent;  										}  									else  										{  										mouseDownPosition = e.Location;  										eventToDragOffset = GetClientPositionForTimelineEvent(theEvent).X - e.Location.X;  										howToDrag = DragNDrop.MOVE_EVENT;  										eventToDrag = theEvent;  										}  									}    								}  							#endregion  							break;    						case MouseButtons.Right:  							#region TimelineEvent entfernen  							if ((Control.ModifierKeys & Keys.Control) == Keys.Control)  								{  								double time = GetTimeAtControlPosition(e.Location' false);    								TimelineEvent eventToRemove = tl.GetEventAtTime(time);  								tl.RemoveEvent(eventToRemove);  								}  							#endregion  							break;  							}  						}  					}    				Invalidate();  				}
Magic Number,CityTrafficSimulator,TimelineControl,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TimelineControl.cs,InitializeComponent,The following statement contains a magic number: this.Size = new System.Drawing.Size(435' 147);
Magic Number,CityTrafficSimulator,TimelineControl,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TimelineControl.cs,InitializeComponent,The following statement contains a magic number: this.Size = new System.Drawing.Size(435' 147);
Magic Number,CityTrafficSimulator,IDM,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Tools\IDM.cs,CalculateWantedDistance,The following statement contains a magic number: double ss = s0 + T * velocity + (velocity * vDiff) / (2 * Math.Sqrt(a * b));
Magic Number,CityTrafficSimulator,IDM,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Tools\IDM.cs,CalculateAcceleration,The following statement contains a magic number: double vNeu = a * (1 - Math.Pow((velocity / desiredVelocity)' 2) - Math2.Square(ss / distance));
Magic Number,CityTrafficSimulator,IDM,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Tools\IDM.cs,CalculateAcceleration,The following statement contains a magic number: double vNeu = a * (1 - Math.Pow((velocity / desiredVelocity)' 2) );
Magic Number,CityTrafficSimulator,IDM,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Tools\IDM.cs,CalculateAccelerationHeun,The following statement contains a magic number: double vNeu = a * (1 - Math.Pow((velocity / desiredVelocity)' 2) - Math2.Square(ss1 / distance));
Magic Number,CityTrafficSimulator,IDM,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Tools\IDM.cs,CalculateAccelerationHeun,The following statement contains a magic number: vNeu += a * (1 - Math.Pow(((velocity + vNeu) / desiredVelocity)' 2) - Math2.Square(ss2 / distance));
Magic Number,CityTrafficSimulator,IDM,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Tools\IDM.cs,CalculateAccelerationHeun,The following statement contains a magic number: return vNeu/2;
Magic Number,CityTrafficSimulator,IDM,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Tools\IDM.cs,CalculateAcceleration,The following statement contains a magic number: double vNeu = a * (1 - Math.Pow((velocity / desiredVelocity)' 2) - Math2.Square(wantedDistance / distance));
Magic Number,CityTrafficSimulator,RechenkaestchenControl,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\RechenkaestchenControl.cs,RechenkaestchenControl,The following statement contains a magic number: if (DesignMode)                  {                  this.Dimension = new Point(10' 10);                  this.CellSize = new Size(16' 16);                  }
Magic Number,CityTrafficSimulator,RechenkaestchenControl,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\RechenkaestchenControl.cs,RechenkaestchenControl,The following statement contains a magic number: if (DesignMode)                  {                  this.Dimension = new Point(10' 10);                  this.CellSize = new Size(16' 16);                  }
Magic Number,CityTrafficSimulator,RechenkaestchenControl,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\RechenkaestchenControl.cs,RechenkaestchenControl,The following statement contains a magic number: if (DesignMode)                  {                  this.Dimension = new Point(10' 10);                  this.CellSize = new Size(16' 16);                  }
Magic Number,CityTrafficSimulator,RechenkaestchenControl,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\RechenkaestchenControl.cs,RechenkaestchenControl,The following statement contains a magic number: if (DesignMode)                  {                  this.Dimension = new Point(10' 10);                  this.CellSize = new Size(16' 16);                  }
Magic Number,CityTrafficSimulator,RechenkaestchenControl,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\RechenkaestchenControl.cs,InitializeComponent,The following statement contains a magic number: this.Size = new System.Drawing.Size(295' 283);
Magic Number,CityTrafficSimulator,RechenkaestchenControl,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\RechenkaestchenControl.cs,InitializeComponent,The following statement contains a magic number: this.Size = new System.Drawing.Size(295' 283);
Magic Number,CityTrafficSimulator,PriorityQueue<TValue;TPriority>,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Tools\PriorityQueue.cs,Enqueue,The following statement contains a magic number: if (numItems == capacity)  	        {  		        // need to increase capacity  		        // grow by 50 percent  		        SetCapacity((3*Capacity)/2);  	        }
Magic Number,CityTrafficSimulator,PriorityQueue<TValue;TPriority>,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Tools\PriorityQueue.cs,Enqueue,The following statement contains a magic number: if (numItems == capacity)  	        {  		        // need to increase capacity  		        // grow by 50 percent  		        SetCapacity((3*Capacity)/2);  	        }
Magic Number,CityTrafficSimulator,PriorityQueue<TValue;TPriority>,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Tools\PriorityQueue.cs,Enqueue,The following statement contains a magic number: while ((i > 0) && (compareFunc(items[i/2].Priority' newItem.Priority) < 0))  	        {  		        items[i] = items[i/2];  		        i /= 2;  	        }
Magic Number,CityTrafficSimulator,PriorityQueue<TValue;TPriority>,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Tools\PriorityQueue.cs,Enqueue,The following statement contains a magic number: while ((i > 0) && (compareFunc(items[i/2].Priority' newItem.Priority) < 0))  	        {  		        items[i] = items[i/2];  		        i /= 2;  	        }
Magic Number,CityTrafficSimulator,PriorityQueue<TValue;TPriority>,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Tools\PriorityQueue.cs,Enqueue,The following statement contains a magic number: while ((i > 0) && (compareFunc(items[i/2].Priority' newItem.Priority) < 0))  	        {  		        items[i] = items[i/2];  		        i /= 2;  	        }
Magic Number,CityTrafficSimulator,PriorityQueue<TValue;TPriority>,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Tools\PriorityQueue.cs,RemoveAt,The following statement contains a magic number: if (numItems > 0)  			{  				int i = index;  				int j = i+1;  				while (i < Count/2)  				{  					if ((j < Count-1) && (compareFunc(items[j].Priority' items[j+1].Priority) < 0))  					{  						j++;  					}  					if (compareFunc(items[j].Priority' tmp.Priority) <= 0)  					{  						break;  					}  					items[i] = items[j];  					i = j;  					j *= 2;  				}  				items[i] = tmp;  			}
Magic Number,CityTrafficSimulator,PriorityQueue<TValue;TPriority>,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Tools\PriorityQueue.cs,RemoveAt,The following statement contains a magic number: if (numItems > 0)  			{  				int i = index;  				int j = i+1;  				while (i < Count/2)  				{  					if ((j < Count-1) && (compareFunc(items[j].Priority' items[j+1].Priority) < 0))  					{  						j++;  					}  					if (compareFunc(items[j].Priority' tmp.Priority) <= 0)  					{  						break;  					}  					items[i] = items[j];  					i = j;  					j *= 2;  				}  				items[i] = tmp;  			}
Magic Number,CityTrafficSimulator,PriorityQueue<TValue;TPriority>,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Tools\PriorityQueue.cs,TrimExcess,The following statement contains a magic number: if (numItems < (0.9 * capacity))                  SetCapacity(numItems);
Magic Number,CityTrafficSimulator,TrafficLight,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\TrafficLight.cs,RecoverFromLoad,The following statement contains a magic number: if (saveVersion <= 2)  				{  				foreach (LineNode ln in nodesList)  					{  					if (ln.GetHashCode() == parentNodeHash)  						{  						AddAssignedLineNode(ln);  						break;  						}  					}  				}
Magic Number,CityTrafficSimulator,XmlSaver,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\XmlSaver.cs,LoadFromFile,The following statement contains a magic number: lf.SetupUpperProgress("Loading Document..."' 8);
Magic Number,CityTrafficSimulator,XmlSaver,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\XmlSaver.cs,LoadFromFile,The following statement contains a magic number: if (saveVersion >= 8)  				{  				XmlNode xnlLineNode = xd.SelectSingleNode("//CityTrafficSimulator/ProgramSettings");  				TextReader tr = new StringReader(xnlLineNode.OuterXml);  				XmlSerializer xsPS = new XmlSerializer(typeof(ProgramSettings));  				ps = (ProgramSettings)xsPS.Deserialize(tr);  				}  			else  				{  				// set some okay default settings  				ps = new ProgramSettings();    				ps._simSpeed = 1;  				ps._simSteps = 15;  				ps._simDuration = 300;  				ps._simRandomSeed = 42;    				ps._zoomLevel = 7;  				ps._renderQuality = 0;    				ps._renderStatistics = false;  				ps._renderVelocityMapping = false;  				ps._showFPS = false;    				ps._renderOptions = new NodeSteuerung.RenderOptions();  				ps._renderOptions.renderLineNodes = true;  				ps._renderOptions.renderNodeConnections = true;  				ps._renderOptions.renderVehicles = true;  				ps._renderOptions.performClipping = true;  				ps._renderOptions.clippingRect = new Rectangle(0' 0' 10000' 10000);  				ps._renderOptions.renderIntersections = false;  				ps._renderOptions.renderLineChangePoints = false;  				ps._renderOptions.renderLineNodeDebugData = false;  				ps._renderOptions.renderNodeConnectionDebugData = false;  				ps._renderOptions.renderVehicleDebugData = false;    				List<Color> tmp = new List<Color>();  				tmp.Add(Color.DarkRed);  				tmp.Add(Color.Yellow);  				tmp.Add(Color.DarkGreen);  				ps._velocityMappingColorMap = new Tools.ColorMap(tmp);  				}
Magic Number,CityTrafficSimulator,XmlSaver,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\XmlSaver.cs,LoadFromFile,The following statement contains a magic number: if (saveVersion >= 8)  				{  				XmlNode xnlLineNode = xd.SelectSingleNode("//CityTrafficSimulator/ProgramSettings");  				TextReader tr = new StringReader(xnlLineNode.OuterXml);  				XmlSerializer xsPS = new XmlSerializer(typeof(ProgramSettings));  				ps = (ProgramSettings)xsPS.Deserialize(tr);  				}  			else  				{  				// set some okay default settings  				ps = new ProgramSettings();    				ps._simSpeed = 1;  				ps._simSteps = 15;  				ps._simDuration = 300;  				ps._simRandomSeed = 42;    				ps._zoomLevel = 7;  				ps._renderQuality = 0;    				ps._renderStatistics = false;  				ps._renderVelocityMapping = false;  				ps._showFPS = false;    				ps._renderOptions = new NodeSteuerung.RenderOptions();  				ps._renderOptions.renderLineNodes = true;  				ps._renderOptions.renderNodeConnections = true;  				ps._renderOptions.renderVehicles = true;  				ps._renderOptions.performClipping = true;  				ps._renderOptions.clippingRect = new Rectangle(0' 0' 10000' 10000);  				ps._renderOptions.renderIntersections = false;  				ps._renderOptions.renderLineChangePoints = false;  				ps._renderOptions.renderLineNodeDebugData = false;  				ps._renderOptions.renderNodeConnectionDebugData = false;  				ps._renderOptions.renderVehicleDebugData = false;    				List<Color> tmp = new List<Color>();  				tmp.Add(Color.DarkRed);  				tmp.Add(Color.Yellow);  				tmp.Add(Color.DarkGreen);  				ps._velocityMappingColorMap = new Tools.ColorMap(tmp);  				}
Magic Number,CityTrafficSimulator,XmlSaver,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\XmlSaver.cs,LoadFromFile,The following statement contains a magic number: if (saveVersion >= 8)  				{  				XmlNode xnlLineNode = xd.SelectSingleNode("//CityTrafficSimulator/ProgramSettings");  				TextReader tr = new StringReader(xnlLineNode.OuterXml);  				XmlSerializer xsPS = new XmlSerializer(typeof(ProgramSettings));  				ps = (ProgramSettings)xsPS.Deserialize(tr);  				}  			else  				{  				// set some okay default settings  				ps = new ProgramSettings();    				ps._simSpeed = 1;  				ps._simSteps = 15;  				ps._simDuration = 300;  				ps._simRandomSeed = 42;    				ps._zoomLevel = 7;  				ps._renderQuality = 0;    				ps._renderStatistics = false;  				ps._renderVelocityMapping = false;  				ps._showFPS = false;    				ps._renderOptions = new NodeSteuerung.RenderOptions();  				ps._renderOptions.renderLineNodes = true;  				ps._renderOptions.renderNodeConnections = true;  				ps._renderOptions.renderVehicles = true;  				ps._renderOptions.performClipping = true;  				ps._renderOptions.clippingRect = new Rectangle(0' 0' 10000' 10000);  				ps._renderOptions.renderIntersections = false;  				ps._renderOptions.renderLineChangePoints = false;  				ps._renderOptions.renderLineNodeDebugData = false;  				ps._renderOptions.renderNodeConnectionDebugData = false;  				ps._renderOptions.renderVehicleDebugData = false;    				List<Color> tmp = new List<Color>();  				tmp.Add(Color.DarkRed);  				tmp.Add(Color.Yellow);  				tmp.Add(Color.DarkGreen);  				ps._velocityMappingColorMap = new Tools.ColorMap(tmp);  				}
Magic Number,CityTrafficSimulator,XmlSaver,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\XmlSaver.cs,LoadFromFile,The following statement contains a magic number: if (saveVersion >= 8)  				{  				XmlNode xnlLineNode = xd.SelectSingleNode("//CityTrafficSimulator/ProgramSettings");  				TextReader tr = new StringReader(xnlLineNode.OuterXml);  				XmlSerializer xsPS = new XmlSerializer(typeof(ProgramSettings));  				ps = (ProgramSettings)xsPS.Deserialize(tr);  				}  			else  				{  				// set some okay default settings  				ps = new ProgramSettings();    				ps._simSpeed = 1;  				ps._simSteps = 15;  				ps._simDuration = 300;  				ps._simRandomSeed = 42;    				ps._zoomLevel = 7;  				ps._renderQuality = 0;    				ps._renderStatistics = false;  				ps._renderVelocityMapping = false;  				ps._showFPS = false;    				ps._renderOptions = new NodeSteuerung.RenderOptions();  				ps._renderOptions.renderLineNodes = true;  				ps._renderOptions.renderNodeConnections = true;  				ps._renderOptions.renderVehicles = true;  				ps._renderOptions.performClipping = true;  				ps._renderOptions.clippingRect = new Rectangle(0' 0' 10000' 10000);  				ps._renderOptions.renderIntersections = false;  				ps._renderOptions.renderLineChangePoints = false;  				ps._renderOptions.renderLineNodeDebugData = false;  				ps._renderOptions.renderNodeConnectionDebugData = false;  				ps._renderOptions.renderVehicleDebugData = false;    				List<Color> tmp = new List<Color>();  				tmp.Add(Color.DarkRed);  				tmp.Add(Color.Yellow);  				tmp.Add(Color.DarkGreen);  				ps._velocityMappingColorMap = new Tools.ColorMap(tmp);  				}
Magic Number,CityTrafficSimulator,XmlSaver,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\XmlSaver.cs,LoadFromFile,The following statement contains a magic number: if (saveVersion >= 8)  				{  				XmlNode xnlLineNode = xd.SelectSingleNode("//CityTrafficSimulator/ProgramSettings");  				TextReader tr = new StringReader(xnlLineNode.OuterXml);  				XmlSerializer xsPS = new XmlSerializer(typeof(ProgramSettings));  				ps = (ProgramSettings)xsPS.Deserialize(tr);  				}  			else  				{  				// set some okay default settings  				ps = new ProgramSettings();    				ps._simSpeed = 1;  				ps._simSteps = 15;  				ps._simDuration = 300;  				ps._simRandomSeed = 42;    				ps._zoomLevel = 7;  				ps._renderQuality = 0;    				ps._renderStatistics = false;  				ps._renderVelocityMapping = false;  				ps._showFPS = false;    				ps._renderOptions = new NodeSteuerung.RenderOptions();  				ps._renderOptions.renderLineNodes = true;  				ps._renderOptions.renderNodeConnections = true;  				ps._renderOptions.renderVehicles = true;  				ps._renderOptions.performClipping = true;  				ps._renderOptions.clippingRect = new Rectangle(0' 0' 10000' 10000);  				ps._renderOptions.renderIntersections = false;  				ps._renderOptions.renderLineChangePoints = false;  				ps._renderOptions.renderLineNodeDebugData = false;  				ps._renderOptions.renderNodeConnectionDebugData = false;  				ps._renderOptions.renderVehicleDebugData = false;    				List<Color> tmp = new List<Color>();  				tmp.Add(Color.DarkRed);  				tmp.Add(Color.Yellow);  				tmp.Add(Color.DarkGreen);  				ps._velocityMappingColorMap = new Tools.ColorMap(tmp);  				}
Magic Number,CityTrafficSimulator,XmlSaver,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\XmlSaver.cs,LoadFromFile,The following statement contains a magic number: if (saveVersion >= 8)  				{  				XmlNode xnlLineNode = xd.SelectSingleNode("//CityTrafficSimulator/ProgramSettings");  				TextReader tr = new StringReader(xnlLineNode.OuterXml);  				XmlSerializer xsPS = new XmlSerializer(typeof(ProgramSettings));  				ps = (ProgramSettings)xsPS.Deserialize(tr);  				}  			else  				{  				// set some okay default settings  				ps = new ProgramSettings();    				ps._simSpeed = 1;  				ps._simSteps = 15;  				ps._simDuration = 300;  				ps._simRandomSeed = 42;    				ps._zoomLevel = 7;  				ps._renderQuality = 0;    				ps._renderStatistics = false;  				ps._renderVelocityMapping = false;  				ps._showFPS = false;    				ps._renderOptions = new NodeSteuerung.RenderOptions();  				ps._renderOptions.renderLineNodes = true;  				ps._renderOptions.renderNodeConnections = true;  				ps._renderOptions.renderVehicles = true;  				ps._renderOptions.performClipping = true;  				ps._renderOptions.clippingRect = new Rectangle(0' 0' 10000' 10000);  				ps._renderOptions.renderIntersections = false;  				ps._renderOptions.renderLineChangePoints = false;  				ps._renderOptions.renderLineNodeDebugData = false;  				ps._renderOptions.renderNodeConnectionDebugData = false;  				ps._renderOptions.renderVehicleDebugData = false;    				List<Color> tmp = new List<Color>();  				tmp.Add(Color.DarkRed);  				tmp.Add(Color.Yellow);  				tmp.Add(Color.DarkGreen);  				ps._velocityMappingColorMap = new Tools.ColorMap(tmp);  				}
Magic Number,CityTrafficSimulator,XmlSaver,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\XmlSaver.cs,LoadFromFile,The following statement contains a magic number: if (saveVersion >= 8)  				{  				XmlNode xnlLineNode = xd.SelectSingleNode("//CityTrafficSimulator/ProgramSettings");  				TextReader tr = new StringReader(xnlLineNode.OuterXml);  				XmlSerializer xsPS = new XmlSerializer(typeof(ProgramSettings));  				ps = (ProgramSettings)xsPS.Deserialize(tr);  				}  			else  				{  				// set some okay default settings  				ps = new ProgramSettings();    				ps._simSpeed = 1;  				ps._simSteps = 15;  				ps._simDuration = 300;  				ps._simRandomSeed = 42;    				ps._zoomLevel = 7;  				ps._renderQuality = 0;    				ps._renderStatistics = false;  				ps._renderVelocityMapping = false;  				ps._showFPS = false;    				ps._renderOptions = new NodeSteuerung.RenderOptions();  				ps._renderOptions.renderLineNodes = true;  				ps._renderOptions.renderNodeConnections = true;  				ps._renderOptions.renderVehicles = true;  				ps._renderOptions.performClipping = true;  				ps._renderOptions.clippingRect = new Rectangle(0' 0' 10000' 10000);  				ps._renderOptions.renderIntersections = false;  				ps._renderOptions.renderLineChangePoints = false;  				ps._renderOptions.renderLineNodeDebugData = false;  				ps._renderOptions.renderNodeConnectionDebugData = false;  				ps._renderOptions.renderVehicleDebugData = false;    				List<Color> tmp = new List<Color>();  				tmp.Add(Color.DarkRed);  				tmp.Add(Color.Yellow);  				tmp.Add(Color.DarkGreen);  				ps._velocityMappingColorMap = new Tools.ColorMap(tmp);  				}
Magic Number,CityTrafficSimulator,XmlSaver,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\XmlSaver.cs,LoadFromFile,The following statement contains a magic number: if (saveVersion < 5)  				{  				trafficVolumeSteuerung.ImportOldTrafficVolumeData(toReturn);  				}
Magic Number,CityTrafficSimulator.LoadingForm,LoadingForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\LoadingForm\LoadingForm.cs,Refresh,The following statement contains a magic number: System.Threading.Thread.Sleep(40);
Magic Number,CityTrafficSimulator.LoadingForm,LoadingForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\LoadingForm\LoadingForm.cs,InitializeComponent,The following statement contains a magic number: this.upperProgress.Location = new System.Drawing.Point(12' 42);
Magic Number,CityTrafficSimulator.LoadingForm,LoadingForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\LoadingForm\LoadingForm.cs,InitializeComponent,The following statement contains a magic number: this.upperProgress.Location = new System.Drawing.Point(12' 42);
Magic Number,CityTrafficSimulator.LoadingForm,LoadingForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\LoadingForm\LoadingForm.cs,InitializeComponent,The following statement contains a magic number: this.upperProgress.Maximum = 8;
Magic Number,CityTrafficSimulator.LoadingForm,LoadingForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\LoadingForm\LoadingForm.cs,InitializeComponent,The following statement contains a magic number: this.upperProgress.Size = new System.Drawing.Size(429' 23);
Magic Number,CityTrafficSimulator.LoadingForm,LoadingForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\LoadingForm\LoadingForm.cs,InitializeComponent,The following statement contains a magic number: this.upperProgress.Size = new System.Drawing.Size(429' 23);
Magic Number,CityTrafficSimulator.LoadingForm,LoadingForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\LoadingForm\LoadingForm.cs,InitializeComponent,The following statement contains a magic number: this.upperLabel.Location = new System.Drawing.Point(12' 9);
Magic Number,CityTrafficSimulator.LoadingForm,LoadingForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\LoadingForm\LoadingForm.cs,InitializeComponent,The following statement contains a magic number: this.upperLabel.Location = new System.Drawing.Point(12' 9);
Magic Number,CityTrafficSimulator.LoadingForm,LoadingForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\LoadingForm\LoadingForm.cs,InitializeComponent,The following statement contains a magic number: this.upperLabel.Size = new System.Drawing.Size(429' 30);
Magic Number,CityTrafficSimulator.LoadingForm,LoadingForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\LoadingForm\LoadingForm.cs,InitializeComponent,The following statement contains a magic number: this.upperLabel.Size = new System.Drawing.Size(429' 30);
Magic Number,CityTrafficSimulator.LoadingForm,LoadingForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\LoadingForm\LoadingForm.cs,InitializeComponent,The following statement contains a magic number: this.lowerLabel.Location = new System.Drawing.Point(12' 68);
Magic Number,CityTrafficSimulator.LoadingForm,LoadingForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\LoadingForm\LoadingForm.cs,InitializeComponent,The following statement contains a magic number: this.lowerLabel.Location = new System.Drawing.Point(12' 68);
Magic Number,CityTrafficSimulator.LoadingForm,LoadingForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\LoadingForm\LoadingForm.cs,InitializeComponent,The following statement contains a magic number: this.lowerLabel.Size = new System.Drawing.Size(429' 30);
Magic Number,CityTrafficSimulator.LoadingForm,LoadingForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\LoadingForm\LoadingForm.cs,InitializeComponent,The following statement contains a magic number: this.lowerLabel.Size = new System.Drawing.Size(429' 30);
Magic Number,CityTrafficSimulator.LoadingForm,LoadingForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\LoadingForm\LoadingForm.cs,InitializeComponent,The following statement contains a magic number: this.lowerLabel.TabIndex = 3;
Magic Number,CityTrafficSimulator.LoadingForm,LoadingForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\LoadingForm\LoadingForm.cs,InitializeComponent,The following statement contains a magic number: this.lowerProgress.Location = new System.Drawing.Point(12' 101);
Magic Number,CityTrafficSimulator.LoadingForm,LoadingForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\LoadingForm\LoadingForm.cs,InitializeComponent,The following statement contains a magic number: this.lowerProgress.Location = new System.Drawing.Point(12' 101);
Magic Number,CityTrafficSimulator.LoadingForm,LoadingForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\LoadingForm\LoadingForm.cs,InitializeComponent,The following statement contains a magic number: this.lowerProgress.Size = new System.Drawing.Size(429' 23);
Magic Number,CityTrafficSimulator.LoadingForm,LoadingForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\LoadingForm\LoadingForm.cs,InitializeComponent,The following statement contains a magic number: this.lowerProgress.Size = new System.Drawing.Size(429' 23);
Magic Number,CityTrafficSimulator.LoadingForm,LoadingForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\LoadingForm\LoadingForm.cs,InitializeComponent,The following statement contains a magic number: this.lowerProgress.TabIndex = 2;
Magic Number,CityTrafficSimulator.LoadingForm,LoadingForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\LoadingForm\LoadingForm.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(453' 155);
Magic Number,CityTrafficSimulator.LoadingForm,LoadingForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\LoadingForm\LoadingForm.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(453' 155);
Magic Number,CityTrafficSimulator.Timeline,TimelineGroup,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TimelineGroup.cs,UpdateConflictPoints,The following statement contains a magic number: for (int from = 0; from < _entries.Count; from++)  				{  				for (int to = 0; to < _entries.Count; to++)  					{  					_conflictPointMatrix[from' to] = new List<Pair<SpecificIntersection' double>>();  					_interimTimes[from' to] = -1;    					if (from == to)  						continue;    					foreach (Pair<SpecificIntersection' double> pFrom in _conflictPoints[from])  						{  						foreach (Pair<SpecificIntersection' double> pTo in _conflictPoints[to])  							{  							if (pFrom.Left.intersection == pTo.Left.intersection)  								{  								_conflictPointMatrix[from' to].Add(pFrom);  								_interimTimes[from' to] = pFrom.Right / (10 * pFrom.Left.nodeConnection.targetVelocity);  								}  							}  						}  					}  				}
Magic Number,CityTrafficSimulator.Timeline,TimelineSteuerung,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TimelineSteuerung.cs,LoadFromFile,The following statement contains a magic number: if (saveVersion >= 4)  				{  				XmlNode xnlTrafficLights = xd.SelectSingleNode("//CityTrafficSimulator/TrafficLights");  				XmlNode cycleTimeNode = xnlTrafficLights.Attributes.GetNamedItem("cycleTime");  				if (cycleTimeNode != null)  					maxTime = Double.Parse(cycleTimeNode.Value);  				}  			else  				{  				maxTime = 50;  				}
Magic Number,CityTrafficSimulator.Timeline,TimelineSteuerung,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TimelineSteuerung.cs,LoadFromFile,The following statement contains a magic number: if (saveVersion >= 4)  				{  				XmlNode xnlTrafficLights = xd.SelectSingleNode("//CityTrafficSimulator/TrafficLights");  				XmlNode cycleTimeNode = xnlTrafficLights.Attributes.GetNamedItem("cycleTime");  				if (cycleTimeNode != null)  					maxTime = Double.Parse(cycleTimeNode.Value);  				}  			else  				{  				maxTime = 50;  				}
Magic Number,CityTrafficSimulator.Timeline,TimelineSteuerung,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TimelineSteuerung.cs,LoadFromFile,The following statement contains a magic number: if (saveVersion >= 3)  				{  				// entsprechenden Node auswählen  				XmlNodeList xnlLineNode = xd.SelectNodes("//CityTrafficSimulator/TrafficLights/TimelineGroup");  				Type[] extraTypes = { typeof(TrafficLight) };  				foreach (XmlNode aXmlNode in xnlLineNode)  					{  					// Node in einen TextReader packen  					TextReader tr = new StringReader(aXmlNode.OuterXml);  					// und Deserializen  					XmlSerializer xs = new XmlSerializer(typeof(TimelineGroup)' extraTypes);  					TimelineGroup tg = (TimelineGroup)xs.Deserialize(tr);    					// ab in die Liste  					tg.GroupChanged += new TimelineGroup.GroupChangedEventHandler(tg_GroupChanged);  					_groups.Add(tg);  					}  				}  			else  				{  				TimelineGroup unsortedGroup = new TimelineGroup("Unsorted Signals"' false);    				// entsprechenden Node auswählen  				XmlNodeList xnlLineNode = xd.SelectNodes("//CityTrafficSimulator/Layout/LineNode/tLight");  				foreach (XmlNode aXmlNode in xnlLineNode)  					{  					// der XMLNode darf nicht tLight heißen' sondern muss TrafficLight heißen. Das müssen wir mal anpassen:  					XmlDocument doc = new XmlDocument();  					XmlElement elem = doc.CreateElement("TrafficLight");  					elem.InnerXml = aXmlNode.InnerXml;  					doc.AppendChild(elem);  					// so' das war nicht wirklich hübsch und schnell' aber es funktioniert ;)  					  					// Node in einen TextReader packen  					StringReader tr = new StringReader(doc.InnerXml);    					// und Deserializen  					XmlSerializer xs = new XmlSerializer(typeof(TrafficLight));  					TrafficLight tl = (TrafficLight)xs.Deserialize(tr);      					XmlNode pnhNode = doc.SelectSingleNode("//TrafficLight/parentNodeHash");  					tl.parentNodeHash = Int32.Parse(pnhNode.InnerXml);  					unsortedGroup.AddEntry(tl);  					}    				// ab in die Liste  				_groups.Add(unsortedGroup);  				}
Magic Number,CityTrafficSimulator.Timeline,TrafficLightForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TrafficLightForm.cs,TrafficLightForm,The following statement contains a magic number: this.splitContainer1.Panel2MinSize = 220;
Magic Number,CityTrafficSimulator.Timeline,TrafficLightForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TrafficLightForm.cs,groupsGroupBox_SizeChanged,The following statement contains a magic number: splitContainer1.SplitterDistance = splitContainer1.ClientSize.Width - groupsGroupBox.Width - 32;
Magic Number,CityTrafficSimulator.Timeline,TrafficLightForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TrafficLightForm.cs,InitializeComponent,The following statement contains a magic number: this.statusStrip1.Location = new System.Drawing.Point(0' 281);
Magic Number,CityTrafficSimulator.Timeline,TrafficLightForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TrafficLightForm.cs,InitializeComponent,The following statement contains a magic number: this.statusStrip1.Size = new System.Drawing.Size(890' 22);
Magic Number,CityTrafficSimulator.Timeline,TrafficLightForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TrafficLightForm.cs,InitializeComponent,The following statement contains a magic number: this.statusStrip1.Size = new System.Drawing.Size(890' 22);
Magic Number,CityTrafficSimulator.Timeline,TrafficLightForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TrafficLightForm.cs,InitializeComponent,The following statement contains a magic number: this.statusLabel.Size = new System.Drawing.Size(10' 17);
Magic Number,CityTrafficSimulator.Timeline,TrafficLightForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TrafficLightForm.cs,InitializeComponent,The following statement contains a magic number: this.statusLabel.Size = new System.Drawing.Size(10' 17);
Magic Number,CityTrafficSimulator.Timeline,TrafficLightForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TrafficLightForm.cs,InitializeComponent,The following statement contains a magic number: this.splitContainer1.Size = new System.Drawing.Size(890' 281);
Magic Number,CityTrafficSimulator.Timeline,TrafficLightForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TrafficLightForm.cs,InitializeComponent,The following statement contains a magic number: this.splitContainer1.Size = new System.Drawing.Size(890' 281);
Magic Number,CityTrafficSimulator.Timeline,TrafficLightForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TrafficLightForm.cs,InitializeComponent,The following statement contains a magic number: this.splitContainer1.SplitterDistance = 600;
Magic Number,CityTrafficSimulator.Timeline,TrafficLightForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TrafficLightForm.cs,InitializeComponent,The following statement contains a magic number: this.groupBox1.Location = new System.Drawing.Point(3' 195);
Magic Number,CityTrafficSimulator.Timeline,TrafficLightForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TrafficLightForm.cs,InitializeComponent,The following statement contains a magic number: this.groupBox1.Location = new System.Drawing.Point(3' 195);
Magic Number,CityTrafficSimulator.Timeline,TrafficLightForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TrafficLightForm.cs,InitializeComponent,The following statement contains a magic number: this.groupBox1.Size = new System.Drawing.Size(250' 75);
Magic Number,CityTrafficSimulator.Timeline,TrafficLightForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TrafficLightForm.cs,InitializeComponent,The following statement contains a magic number: this.groupBox1.Size = new System.Drawing.Size(250' 75);
Magic Number,CityTrafficSimulator.Timeline,TrafficLightForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TrafficLightForm.cs,InitializeComponent,The following statement contains a magic number: this.groupBox1.TabIndex = 2;
Magic Number,CityTrafficSimulator.Timeline,TrafficLightForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TrafficLightForm.cs,InitializeComponent,The following statement contains a magic number: this.cycleTimeSpinEdit.Location = new System.Drawing.Point(140' 21);
Magic Number,CityTrafficSimulator.Timeline,TrafficLightForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TrafficLightForm.cs,InitializeComponent,The following statement contains a magic number: this.cycleTimeSpinEdit.Location = new System.Drawing.Point(140' 21);
Magic Number,CityTrafficSimulator.Timeline,TrafficLightForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TrafficLightForm.cs,InitializeComponent,The following statement contains a magic number: this.cycleTimeSpinEdit.Maximum = new decimal(new int[] {              240'              0'              0'              0});
Magic Number,CityTrafficSimulator.Timeline,TrafficLightForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TrafficLightForm.cs,InitializeComponent,The following statement contains a magic number: this.cycleTimeSpinEdit.Minimum = new decimal(new int[] {              10'              0'              0'              0});
Magic Number,CityTrafficSimulator.Timeline,TrafficLightForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TrafficLightForm.cs,InitializeComponent,The following statement contains a magic number: this.cycleTimeSpinEdit.Size = new System.Drawing.Size(104' 20);
Magic Number,CityTrafficSimulator.Timeline,TrafficLightForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TrafficLightForm.cs,InitializeComponent,The following statement contains a magic number: this.cycleTimeSpinEdit.Size = new System.Drawing.Size(104' 20);
Magic Number,CityTrafficSimulator.Timeline,TrafficLightForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TrafficLightForm.cs,InitializeComponent,The following statement contains a magic number: this.cycleTimeSpinEdit.TabIndex = 3;
Magic Number,CityTrafficSimulator.Timeline,TrafficLightForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TrafficLightForm.cs,InitializeComponent,The following statement contains a magic number: this.cycleTimeSpinEdit.Value = new decimal(new int[] {              50'              0'              0'              0});
Magic Number,CityTrafficSimulator.Timeline,TrafficLightForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TrafficLightForm.cs,InitializeComponent,The following statement contains a magic number: this.label5.Location = new System.Drawing.Point(6' 21);
Magic Number,CityTrafficSimulator.Timeline,TrafficLightForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TrafficLightForm.cs,InitializeComponent,The following statement contains a magic number: this.label5.Location = new System.Drawing.Point(6' 21);
Magic Number,CityTrafficSimulator.Timeline,TrafficLightForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TrafficLightForm.cs,InitializeComponent,The following statement contains a magic number: this.label5.Size = new System.Drawing.Size(94' 13);
Magic Number,CityTrafficSimulator.Timeline,TrafficLightForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TrafficLightForm.cs,InitializeComponent,The following statement contains a magic number: this.label5.Size = new System.Drawing.Size(94' 13);
Magic Number,CityTrafficSimulator.Timeline,TrafficLightForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TrafficLightForm.cs,InitializeComponent,The following statement contains a magic number: this.label5.TabIndex = 2;
Magic Number,CityTrafficSimulator.Timeline,TrafficLightForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TrafficLightForm.cs,InitializeComponent,The following statement contains a magic number: this.label4.Location = new System.Drawing.Point(6' 47);
Magic Number,CityTrafficSimulator.Timeline,TrafficLightForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TrafficLightForm.cs,InitializeComponent,The following statement contains a magic number: this.label4.Location = new System.Drawing.Point(6' 47);
Magic Number,CityTrafficSimulator.Timeline,TrafficLightForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TrafficLightForm.cs,InitializeComponent,The following statement contains a magic number: this.label4.Size = new System.Drawing.Size(125' 13);
Magic Number,CityTrafficSimulator.Timeline,TrafficLightForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TrafficLightForm.cs,InitializeComponent,The following statement contains a magic number: this.label4.Size = new System.Drawing.Size(125' 13);
Magic Number,CityTrafficSimulator.Timeline,TrafficLightForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TrafficLightForm.cs,InitializeComponent,The following statement contains a magic number: this.zoomSpinEdit.Location = new System.Drawing.Point(140' 47);
Magic Number,CityTrafficSimulator.Timeline,TrafficLightForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TrafficLightForm.cs,InitializeComponent,The following statement contains a magic number: this.zoomSpinEdit.Location = new System.Drawing.Point(140' 47);
Magic Number,CityTrafficSimulator.Timeline,TrafficLightForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TrafficLightForm.cs,InitializeComponent,The following statement contains a magic number: this.zoomSpinEdit.Maximum = new decimal(new int[] {              20'              0'              0'              0});
Magic Number,CityTrafficSimulator.Timeline,TrafficLightForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TrafficLightForm.cs,InitializeComponent,The following statement contains a magic number: this.zoomSpinEdit.Size = new System.Drawing.Size(104' 20);
Magic Number,CityTrafficSimulator.Timeline,TrafficLightForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TrafficLightForm.cs,InitializeComponent,The following statement contains a magic number: this.zoomSpinEdit.Size = new System.Drawing.Size(104' 20);
Magic Number,CityTrafficSimulator.Timeline,TrafficLightForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TrafficLightForm.cs,InitializeComponent,The following statement contains a magic number: this.zoomSpinEdit.Value = new decimal(new int[] {              10'              0'              0'              0});
Magic Number,CityTrafficSimulator.Timeline,TrafficLightForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TrafficLightForm.cs,InitializeComponent,The following statement contains a magic number: this.trafficLightGroupBox.Location = new System.Drawing.Point(3' 86);
Magic Number,CityTrafficSimulator.Timeline,TrafficLightForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TrafficLightForm.cs,InitializeComponent,The following statement contains a magic number: this.trafficLightGroupBox.Location = new System.Drawing.Point(3' 86);
Magic Number,CityTrafficSimulator.Timeline,TrafficLightForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TrafficLightForm.cs,InitializeComponent,The following statement contains a magic number: this.trafficLightGroupBox.Size = new System.Drawing.Size(250' 103);
Magic Number,CityTrafficSimulator.Timeline,TrafficLightForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TrafficLightForm.cs,InitializeComponent,The following statement contains a magic number: this.trafficLightGroupBox.Size = new System.Drawing.Size(250' 103);
Magic Number,CityTrafficSimulator.Timeline,TrafficLightForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TrafficLightForm.cs,InitializeComponent,The following statement contains a magic number: this.label3.Location = new System.Drawing.Point(6' 48);
Magic Number,CityTrafficSimulator.Timeline,TrafficLightForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TrafficLightForm.cs,InitializeComponent,The following statement contains a magic number: this.label3.Location = new System.Drawing.Point(6' 48);
Magic Number,CityTrafficSimulator.Timeline,TrafficLightForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TrafficLightForm.cs,InitializeComponent,The following statement contains a magic number: this.label3.Size = new System.Drawing.Size(71' 13);
Magic Number,CityTrafficSimulator.Timeline,TrafficLightForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TrafficLightForm.cs,InitializeComponent,The following statement contains a magic number: this.label3.Size = new System.Drawing.Size(71' 13);
Magic Number,CityTrafficSimulator.Timeline,TrafficLightForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TrafficLightForm.cs,InitializeComponent,The following statement contains a magic number: this.label3.TabIndex = 9;
Magic Number,CityTrafficSimulator.Timeline,TrafficLightForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TrafficLightForm.cs,InitializeComponent,The following statement contains a magic number: this.groupComboBox.Location = new System.Drawing.Point(98' 45);
Magic Number,CityTrafficSimulator.Timeline,TrafficLightForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TrafficLightForm.cs,InitializeComponent,The following statement contains a magic number: this.groupComboBox.Location = new System.Drawing.Point(98' 45);
Magic Number,CityTrafficSimulator.Timeline,TrafficLightForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TrafficLightForm.cs,InitializeComponent,The following statement contains a magic number: this.groupComboBox.Size = new System.Drawing.Size(146' 21);
Magic Number,CityTrafficSimulator.Timeline,TrafficLightForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TrafficLightForm.cs,InitializeComponent,The following statement contains a magic number: this.groupComboBox.Size = new System.Drawing.Size(146' 21);
Magic Number,CityTrafficSimulator.Timeline,TrafficLightForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TrafficLightForm.cs,InitializeComponent,The following statement contains a magic number: this.groupComboBox.TabIndex = 8;
Magic Number,CityTrafficSimulator.Timeline,TrafficLightForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TrafficLightForm.cs,InitializeComponent,The following statement contains a magic number: this.label2.Location = new System.Drawing.Point(6' 22);
Magic Number,CityTrafficSimulator.Timeline,TrafficLightForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TrafficLightForm.cs,InitializeComponent,The following statement contains a magic number: this.label2.Location = new System.Drawing.Point(6' 22);
Magic Number,CityTrafficSimulator.Timeline,TrafficLightForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TrafficLightForm.cs,InitializeComponent,The following statement contains a magic number: this.label2.Size = new System.Drawing.Size(70' 13);
Magic Number,CityTrafficSimulator.Timeline,TrafficLightForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TrafficLightForm.cs,InitializeComponent,The following statement contains a magic number: this.label2.Size = new System.Drawing.Size(70' 13);
Magic Number,CityTrafficSimulator.Timeline,TrafficLightForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TrafficLightForm.cs,InitializeComponent,The following statement contains a magic number: this.label2.TabIndex = 7;
Magic Number,CityTrafficSimulator.Timeline,TrafficLightForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TrafficLightForm.cs,InitializeComponent,The following statement contains a magic number: this.trafficLightNameEdit.Location = new System.Drawing.Point(98' 19);
Magic Number,CityTrafficSimulator.Timeline,TrafficLightForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TrafficLightForm.cs,InitializeComponent,The following statement contains a magic number: this.trafficLightNameEdit.Location = new System.Drawing.Point(98' 19);
Magic Number,CityTrafficSimulator.Timeline,TrafficLightForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TrafficLightForm.cs,InitializeComponent,The following statement contains a magic number: this.trafficLightNameEdit.Size = new System.Drawing.Size(146' 20);
Magic Number,CityTrafficSimulator.Timeline,TrafficLightForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TrafficLightForm.cs,InitializeComponent,The following statement contains a magic number: this.trafficLightNameEdit.Size = new System.Drawing.Size(146' 20);
Magic Number,CityTrafficSimulator.Timeline,TrafficLightForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TrafficLightForm.cs,InitializeComponent,The following statement contains a magic number: this.trafficLightNameEdit.TabIndex = 6;
Magic Number,CityTrafficSimulator.Timeline,TrafficLightForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TrafficLightForm.cs,InitializeComponent,The following statement contains a magic number: this.removeTrafficLightButton.Location = new System.Drawing.Point(154' 72);
Magic Number,CityTrafficSimulator.Timeline,TrafficLightForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TrafficLightForm.cs,InitializeComponent,The following statement contains a magic number: this.removeTrafficLightButton.Location = new System.Drawing.Point(154' 72);
Magic Number,CityTrafficSimulator.Timeline,TrafficLightForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TrafficLightForm.cs,InitializeComponent,The following statement contains a magic number: this.removeTrafficLightButton.Size = new System.Drawing.Size(90' 23);
Magic Number,CityTrafficSimulator.Timeline,TrafficLightForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TrafficLightForm.cs,InitializeComponent,The following statement contains a magic number: this.removeTrafficLightButton.Size = new System.Drawing.Size(90' 23);
Magic Number,CityTrafficSimulator.Timeline,TrafficLightForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TrafficLightForm.cs,InitializeComponent,The following statement contains a magic number: this.removeTrafficLightButton.TabIndex = 5;
Magic Number,CityTrafficSimulator.Timeline,TrafficLightForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TrafficLightForm.cs,InitializeComponent,The following statement contains a magic number: this.addTrafficLightButton.Location = new System.Drawing.Point(58' 72);
Magic Number,CityTrafficSimulator.Timeline,TrafficLightForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TrafficLightForm.cs,InitializeComponent,The following statement contains a magic number: this.addTrafficLightButton.Location = new System.Drawing.Point(58' 72);
Magic Number,CityTrafficSimulator.Timeline,TrafficLightForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TrafficLightForm.cs,InitializeComponent,The following statement contains a magic number: this.addTrafficLightButton.Size = new System.Drawing.Size(90' 23);
Magic Number,CityTrafficSimulator.Timeline,TrafficLightForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TrafficLightForm.cs,InitializeComponent,The following statement contains a magic number: this.addTrafficLightButton.Size = new System.Drawing.Size(90' 23);
Magic Number,CityTrafficSimulator.Timeline,TrafficLightForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TrafficLightForm.cs,InitializeComponent,The following statement contains a magic number: this.addTrafficLightButton.TabIndex = 4;
Magic Number,CityTrafficSimulator.Timeline,TrafficLightForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TrafficLightForm.cs,InitializeComponent,The following statement contains a magic number: this.groupsGroupBox.Location = new System.Drawing.Point(3' 3);
Magic Number,CityTrafficSimulator.Timeline,TrafficLightForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TrafficLightForm.cs,InitializeComponent,The following statement contains a magic number: this.groupsGroupBox.Location = new System.Drawing.Point(3' 3);
Magic Number,CityTrafficSimulator.Timeline,TrafficLightForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TrafficLightForm.cs,InitializeComponent,The following statement contains a magic number: this.groupsGroupBox.Size = new System.Drawing.Size(250' 77);
Magic Number,CityTrafficSimulator.Timeline,TrafficLightForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TrafficLightForm.cs,InitializeComponent,The following statement contains a magic number: this.groupsGroupBox.Size = new System.Drawing.Size(250' 77);
Magic Number,CityTrafficSimulator.Timeline,TrafficLightForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TrafficLightForm.cs,InitializeComponent,The following statement contains a magic number: this.button1.Location = new System.Drawing.Point(9' 45);
Magic Number,CityTrafficSimulator.Timeline,TrafficLightForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TrafficLightForm.cs,InitializeComponent,The following statement contains a magic number: this.button1.Location = new System.Drawing.Point(9' 45);
Magic Number,CityTrafficSimulator.Timeline,TrafficLightForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TrafficLightForm.cs,InitializeComponent,The following statement contains a magic number: this.button1.Size = new System.Drawing.Size(43' 23);
Magic Number,CityTrafficSimulator.Timeline,TrafficLightForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TrafficLightForm.cs,InitializeComponent,The following statement contains a magic number: this.button1.Size = new System.Drawing.Size(43' 23);
Magic Number,CityTrafficSimulator.Timeline,TrafficLightForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TrafficLightForm.cs,InitializeComponent,The following statement contains a magic number: this.button1.TabIndex = 4;
Magic Number,CityTrafficSimulator.Timeline,TrafficLightForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TrafficLightForm.cs,InitializeComponent,The following statement contains a magic number: this.label1.Location = new System.Drawing.Point(6' 22);
Magic Number,CityTrafficSimulator.Timeline,TrafficLightForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TrafficLightForm.cs,InitializeComponent,The following statement contains a magic number: this.label1.Location = new System.Drawing.Point(6' 22);
Magic Number,CityTrafficSimulator.Timeline,TrafficLightForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TrafficLightForm.cs,InitializeComponent,The following statement contains a magic number: this.label1.Size = new System.Drawing.Size(70' 13);
Magic Number,CityTrafficSimulator.Timeline,TrafficLightForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TrafficLightForm.cs,InitializeComponent,The following statement contains a magic number: this.label1.Size = new System.Drawing.Size(70' 13);
Magic Number,CityTrafficSimulator.Timeline,TrafficLightForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TrafficLightForm.cs,InitializeComponent,The following statement contains a magic number: this.label1.TabIndex = 3;
Magic Number,CityTrafficSimulator.Timeline,TrafficLightForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TrafficLightForm.cs,InitializeComponent,The following statement contains a magic number: this.groupTitleEdit.Location = new System.Drawing.Point(98' 19);
Magic Number,CityTrafficSimulator.Timeline,TrafficLightForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TrafficLightForm.cs,InitializeComponent,The following statement contains a magic number: this.groupTitleEdit.Location = new System.Drawing.Point(98' 19);
Magic Number,CityTrafficSimulator.Timeline,TrafficLightForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TrafficLightForm.cs,InitializeComponent,The following statement contains a magic number: this.groupTitleEdit.Size = new System.Drawing.Size(146' 20);
Magic Number,CityTrafficSimulator.Timeline,TrafficLightForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TrafficLightForm.cs,InitializeComponent,The following statement contains a magic number: this.groupTitleEdit.Size = new System.Drawing.Size(146' 20);
Magic Number,CityTrafficSimulator.Timeline,TrafficLightForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TrafficLightForm.cs,InitializeComponent,The following statement contains a magic number: this.groupTitleEdit.TabIndex = 2;
Magic Number,CityTrafficSimulator.Timeline,TrafficLightForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TrafficLightForm.cs,InitializeComponent,The following statement contains a magic number: this.removeGroupButton.Location = new System.Drawing.Point(154' 45);
Magic Number,CityTrafficSimulator.Timeline,TrafficLightForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TrafficLightForm.cs,InitializeComponent,The following statement contains a magic number: this.removeGroupButton.Location = new System.Drawing.Point(154' 45);
Magic Number,CityTrafficSimulator.Timeline,TrafficLightForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TrafficLightForm.cs,InitializeComponent,The following statement contains a magic number: this.removeGroupButton.Size = new System.Drawing.Size(90' 23);
Magic Number,CityTrafficSimulator.Timeline,TrafficLightForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TrafficLightForm.cs,InitializeComponent,The following statement contains a magic number: this.removeGroupButton.Size = new System.Drawing.Size(90' 23);
Magic Number,CityTrafficSimulator.Timeline,TrafficLightForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TrafficLightForm.cs,InitializeComponent,The following statement contains a magic number: this.addGroupButton.Location = new System.Drawing.Point(58' 45);
Magic Number,CityTrafficSimulator.Timeline,TrafficLightForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TrafficLightForm.cs,InitializeComponent,The following statement contains a magic number: this.addGroupButton.Location = new System.Drawing.Point(58' 45);
Magic Number,CityTrafficSimulator.Timeline,TrafficLightForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TrafficLightForm.cs,InitializeComponent,The following statement contains a magic number: this.addGroupButton.Size = new System.Drawing.Size(90' 23);
Magic Number,CityTrafficSimulator.Timeline,TrafficLightForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TrafficLightForm.cs,InitializeComponent,The following statement contains a magic number: this.addGroupButton.Size = new System.Drawing.Size(90' 23);
Magic Number,CityTrafficSimulator.Timeline,TrafficLightForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TrafficLightForm.cs,InitializeComponent,The following statement contains a magic number: this.timelineControl.Size = new System.Drawing.Size(435' 147);
Magic Number,CityTrafficSimulator.Timeline,TrafficLightForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TrafficLightForm.cs,InitializeComponent,The following statement contains a magic number: this.timelineControl.Size = new System.Drawing.Size(435' 147);
Magic Number,CityTrafficSimulator.Timeline,TrafficLightForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TrafficLightForm.cs,InitializeComponent,The following statement contains a magic number: this.timelineControl.snapSize = 0.5;
Magic Number,CityTrafficSimulator.Timeline,TrafficLightForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TrafficLightForm.cs,InitializeComponent,The following statement contains a magic number: this.timelineControl.zoom = 10;
Magic Number,CityTrafficSimulator.Timeline,TrafficLightForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TrafficLightForm.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(890' 303);
Magic Number,CityTrafficSimulator.Timeline,TrafficLightForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TrafficLightForm.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(890' 303);
Magic Number,CityTrafficSimulator.Timeline,TimelineEntry,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TimelineEntry.cs,AddEvent,The following statement contains a magic number: if (addBlockingEntries)  				{  				List<Pair<TimelineEntry' double>> interimTimes = parentGroup.GetInterimTimes(this);  				if (interimTimes != null)  					{  					foreach (Pair<TimelineEntry' double> p in interimTimes)  						{  						double startTime = eventToAdd.eventTime + (Math.Floor(p.Right * 2) / 2);   						TimelineEvent blockingEvent = new TimelineBlockingEvent(eventToAdd' p.Right' 1' 2);  						p.Left.AddEvent(blockingEvent' false' true);  						}  					}  				}
Magic Number,CityTrafficSimulator.Timeline,TimelineEntry,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TimelineEntry.cs,AddEvent,The following statement contains a magic number: if (addBlockingEntries)  				{  				List<Pair<TimelineEntry' double>> interimTimes = parentGroup.GetInterimTimes(this);  				if (interimTimes != null)  					{  					foreach (Pair<TimelineEntry' double> p in interimTimes)  						{  						double startTime = eventToAdd.eventTime + (Math.Floor(p.Right * 2) / 2);   						TimelineEvent blockingEvent = new TimelineBlockingEvent(eventToAdd' p.Right' 1' 2);  						p.Left.AddEvent(blockingEvent' false' true);  						}  					}  				}
Magic Number,CityTrafficSimulator.Timeline,TimelineEntry,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TimelineEntry.cs,AddEvent,The following statement contains a magic number: if (addBlockingEntries)  				{  				List<Pair<TimelineEntry' double>> interimTimes = parentGroup.GetInterimTimes(this);  				if (interimTimes != null)  					{  					foreach (Pair<TimelineEntry' double> p in interimTimes)  						{  						double startTime = eventToAdd.eventTime + (Math.Floor(p.Right * 2) / 2);   						TimelineEvent blockingEvent = new TimelineBlockingEvent(eventToAdd' p.Right' 1' 2);  						p.Left.AddEvent(blockingEvent' false' true);  						}  					}  				}
Magic Number,CityTrafficSimulator.Tools,AlgorithmicGeometry,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Tools\AlgorithmicGeometry.cs,roundedConvexHullPath,The following statement contains a magic number: if (convexHull.Count == 0)  				{  				return toReturn;  				}				  			else if (convexHull.Count == 1)  				{  				toReturn.AddEllipse((float)(convexHull.First.Value.X - radius)' (float)(convexHull.First.Value.Y - radius)' (float)(2 * radius)' (float)(2 * radius));  				return toReturn;  				}
Magic Number,CityTrafficSimulator.Tools,AlgorithmicGeometry,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Tools\AlgorithmicGeometry.cs,roundedConvexHullPath,The following statement contains a magic number: if (convexHull.Count == 0)  				{  				return toReturn;  				}				  			else if (convexHull.Count == 1)  				{  				toReturn.AddEllipse((float)(convexHull.First.Value.X - radius)' (float)(convexHull.First.Value.Y - radius)' (float)(2 * radius)' (float)(2 * radius));  				return toReturn;  				}
Magic Number,CityTrafficSimulator.Tools,AlgorithmicGeometry,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Tools\AlgorithmicGeometry.cs,roundedConvexHullPath,The following statement contains a magic number: while (curNode.Next.Next != null)  				{  				// compute orthogonal vectors to point-to-point directions  				Vector2 ortho = (curNode.Next.Value - curNode.Value).RotatedClockwise.Normalized * radius;  				Vector2 nextOrtho = (curNode.Next.Next.Value - curNode.Next.Value).RotatedClockwise.Normalized * radius;    				// compute angles for rounded corners  				float start = (float)(Math.Atan2(ortho.Y' ortho.X) * 180 / Math.PI);  				float end = (float)(Math.Atan2(nextOrtho.Y' nextOrtho.X) * 180 / Math.PI);  				float sweep = end - start;  				if (sweep < 0)  					sweep += 360;    				toReturn.AddLine(curNode.Value + ortho' curNode.Next.Value + ortho);  				toReturn.AddArc((float)(curNode.Next.Value.X - radius)' (float)(curNode.Next.Value.Y - radius)' (float)(2 * radius)' (float)(2 * radius)' start' sweep);    				curNode = curNode.Next;  				}
Magic Number,CityTrafficSimulator.Tools,AlgorithmicGeometry,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Tools\AlgorithmicGeometry.cs,roundedConvexHullPath,The following statement contains a magic number: while (curNode.Next.Next != null)  				{  				// compute orthogonal vectors to point-to-point directions  				Vector2 ortho = (curNode.Next.Value - curNode.Value).RotatedClockwise.Normalized * radius;  				Vector2 nextOrtho = (curNode.Next.Next.Value - curNode.Next.Value).RotatedClockwise.Normalized * radius;    				// compute angles for rounded corners  				float start = (float)(Math.Atan2(ortho.Y' ortho.X) * 180 / Math.PI);  				float end = (float)(Math.Atan2(nextOrtho.Y' nextOrtho.X) * 180 / Math.PI);  				float sweep = end - start;  				if (sweep < 0)  					sweep += 360;    				toReturn.AddLine(curNode.Value + ortho' curNode.Next.Value + ortho);  				toReturn.AddArc((float)(curNode.Next.Value.X - radius)' (float)(curNode.Next.Value.Y - radius)' (float)(2 * radius)' (float)(2 * radius)' start' sweep);    				curNode = curNode.Next;  				}
Magic Number,CityTrafficSimulator.Tools,AlgorithmicGeometry,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Tools\AlgorithmicGeometry.cs,roundedConvexHullPath,The following statement contains a magic number: while (curNode.Next.Next != null)  				{  				// compute orthogonal vectors to point-to-point directions  				Vector2 ortho = (curNode.Next.Value - curNode.Value).RotatedClockwise.Normalized * radius;  				Vector2 nextOrtho = (curNode.Next.Next.Value - curNode.Next.Value).RotatedClockwise.Normalized * radius;    				// compute angles for rounded corners  				float start = (float)(Math.Atan2(ortho.Y' ortho.X) * 180 / Math.PI);  				float end = (float)(Math.Atan2(nextOrtho.Y' nextOrtho.X) * 180 / Math.PI);  				float sweep = end - start;  				if (sweep < 0)  					sweep += 360;    				toReturn.AddLine(curNode.Value + ortho' curNode.Next.Value + ortho);  				toReturn.AddArc((float)(curNode.Next.Value.X - radius)' (float)(curNode.Next.Value.Y - radius)' (float)(2 * radius)' (float)(2 * radius)' start' sweep);    				curNode = curNode.Next;  				}
Magic Number,CityTrafficSimulator.Tools,AlgorithmicGeometry,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Tools\AlgorithmicGeometry.cs,roundedConvexHullPath,The following statement contains a magic number: while (curNode.Next.Next != null)  				{  				// compute orthogonal vectors to point-to-point directions  				Vector2 ortho = (curNode.Next.Value - curNode.Value).RotatedClockwise.Normalized * radius;  				Vector2 nextOrtho = (curNode.Next.Next.Value - curNode.Next.Value).RotatedClockwise.Normalized * radius;    				// compute angles for rounded corners  				float start = (float)(Math.Atan2(ortho.Y' ortho.X) * 180 / Math.PI);  				float end = (float)(Math.Atan2(nextOrtho.Y' nextOrtho.X) * 180 / Math.PI);  				float sweep = end - start;  				if (sweep < 0)  					sweep += 360;    				toReturn.AddLine(curNode.Value + ortho' curNode.Next.Value + ortho);  				toReturn.AddArc((float)(curNode.Next.Value.X - radius)' (float)(curNode.Next.Value.Y - radius)' (float)(2 * radius)' (float)(2 * radius)' start' sweep);    				curNode = curNode.Next;  				}
Magic Number,CityTrafficSimulator.Tools,AlgorithmicGeometry,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Tools\AlgorithmicGeometry.cs,roundedConvexHullPath,The following statement contains a magic number: while (curNode.Next.Next != null)  				{  				// compute orthogonal vectors to point-to-point directions  				Vector2 ortho = (curNode.Next.Value - curNode.Value).RotatedClockwise.Normalized * radius;  				Vector2 nextOrtho = (curNode.Next.Next.Value - curNode.Next.Value).RotatedClockwise.Normalized * radius;    				// compute angles for rounded corners  				float start = (float)(Math.Atan2(ortho.Y' ortho.X) * 180 / Math.PI);  				float end = (float)(Math.Atan2(nextOrtho.Y' nextOrtho.X) * 180 / Math.PI);  				float sweep = end - start;  				if (sweep < 0)  					sweep += 360;    				toReturn.AddLine(curNode.Value + ortho' curNode.Next.Value + ortho);  				toReturn.AddArc((float)(curNode.Next.Value.X - radius)' (float)(curNode.Next.Value.Y - radius)' (float)(2 * radius)' (float)(2 * radius)' start' sweep);    				curNode = curNode.Next;  				}
Magic Number,CityTrafficSimulator.Tools,AlgorithmicGeometry,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Tools\AlgorithmicGeometry.cs,convexHull,The following statement contains a magic number: if (points.Count < 3)  				{  				foreach (Vector2 p in points)  					toReturn.AddLast(p);  				return toReturn;  				}
Magic Number,CityTrafficSimulator.Tools,AlgorithmicGeometry,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Tools\AlgorithmicGeometry.cs,convexHull,The following statement contains a magic number: toReturn.AddLast(points[2]);
Magic Number,CityTrafficSimulator.Tools,AlgorithmicGeometry,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Tools\AlgorithmicGeometry.cs,convexHull,The following statement contains a magic number: for (int i = 3; i < points.Count; ++i)  				{  				while (!leftTurn(toReturn.Last.Previous.Value' toReturn.Last.Value' points[i]))  					toReturn.RemoveLast();  				toReturn.AddLast(points[i]);  				}
Magic Number,CityTrafficSimulator.Tools,ColorMapControl,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Tools\Colormap.cs,ColorMapControl,The following statement contains a magic number: if (DesignMode)  				{  				this.Size = new System.Drawing.Size(96' 24);  				}
Magic Number,CityTrafficSimulator.Tools,ColorMapControl,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Tools\Colormap.cs,ColorMapControl,The following statement contains a magic number: if (DesignMode)  				{  				this.Size = new System.Drawing.Size(96' 24);  				}
Magic Number,CityTrafficSimulator.Tools,ColorMapControl,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Tools\Colormap.cs,ColorMapControl_MouseUp,The following statement contains a magic number: if (Math.Abs(_mouseDownPosition.X - e.X) <= 2 && Math.Abs(_mouseDownPosition.Y - e.Y) <= 2)  				{  				int index = WorldToIndex(e.X);    				if (e.Button == MouseButtons.Left)  					{  					if (ClientSize.Width - e.X < 8)  						index = _colormap.Count;  					ColorDialog cd = new ColorDialog();  					cd.FullOpen = true;  					cd.AnyColor = true;  					if (cd.ShowDialog() == DialogResult.OK)  						{  						_colormap.AddColorAt(cd.Color' index);  						}  					}  				else if (e.Button == MouseButtons.Right)  					{  					if (_colormap.Count > 1)  						_colormap.RemoveColorAt(index);  					}  				}  			else if (_draggingColor)  				{  				_draggingColor = false;  				colormap = _tempMap;  				}
Magic Number,CityTrafficSimulator.Tools,ColorMapControl,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Tools\Colormap.cs,ColorMapControl_MouseUp,The following statement contains a magic number: if (Math.Abs(_mouseDownPosition.X - e.X) <= 2 && Math.Abs(_mouseDownPosition.Y - e.Y) <= 2)  				{  				int index = WorldToIndex(e.X);    				if (e.Button == MouseButtons.Left)  					{  					if (ClientSize.Width - e.X < 8)  						index = _colormap.Count;  					ColorDialog cd = new ColorDialog();  					cd.FullOpen = true;  					cd.AnyColor = true;  					if (cd.ShowDialog() == DialogResult.OK)  						{  						_colormap.AddColorAt(cd.Color' index);  						}  					}  				else if (e.Button == MouseButtons.Right)  					{  					if (_colormap.Count > 1)  						_colormap.RemoveColorAt(index);  					}  				}  			else if (_draggingColor)  				{  				_draggingColor = false;  				colormap = _tempMap;  				}
Magic Number,CityTrafficSimulator.Tools,ColorMapControl,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Tools\Colormap.cs,ColorMapControl_MouseUp,The following statement contains a magic number: if (Math.Abs(_mouseDownPosition.X - e.X) <= 2 && Math.Abs(_mouseDownPosition.Y - e.Y) <= 2)  				{  				int index = WorldToIndex(e.X);    				if (e.Button == MouseButtons.Left)  					{  					if (ClientSize.Width - e.X < 8)  						index = _colormap.Count;  					ColorDialog cd = new ColorDialog();  					cd.FullOpen = true;  					cd.AnyColor = true;  					if (cd.ShowDialog() == DialogResult.OK)  						{  						_colormap.AddColorAt(cd.Color' index);  						}  					}  				else if (e.Button == MouseButtons.Right)  					{  					if (_colormap.Count > 1)  						_colormap.RemoveColorAt(index);  					}  				}  			else if (_draggingColor)  				{  				_draggingColor = false;  				colormap = _tempMap;  				}
Magic Number,CityTrafficSimulator.Tools,ColorMapControl,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Tools\Colormap.cs,ColorMapControl_MouseMove,The following statement contains a magic number: if (_leftMouseDown && (Math.Abs(_mouseDownPosition.X - e.X) > 2 || Math.Abs(_mouseDownPosition.Y - e.Y) > 2))  				{  				int origin = WorldToIndex(_mouseDownPosition.X);  				int destination = WorldToIndex(e.X);  				List<Color> l = _colormap.GetListCopy();    				Color c = l[origin];  				l[origin] = l[destination];  				l[destination] = c;    				_tempMap = new ColorMap(l);  				_draggingColor = true;  				Invalidate();  				}
Magic Number,CityTrafficSimulator.Tools,ColorMapControl,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Tools\Colormap.cs,ColorMapControl_MouseMove,The following statement contains a magic number: if (_leftMouseDown && (Math.Abs(_mouseDownPosition.X - e.X) > 2 || Math.Abs(_mouseDownPosition.Y - e.Y) > 2))  				{  				int origin = WorldToIndex(_mouseDownPosition.X);  				int destination = WorldToIndex(e.X);  				List<Color> l = _colormap.GetListCopy();    				Color c = l[origin];  				l[origin] = l[destination];  				l[destination] = c;    				_tempMap = new ColorMap(l);  				_draggingColor = true;  				Invalidate();  				}
Magic Number,CityTrafficSimulator.Vehicle,Bus,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Bus.cs,Bus,The following statement contains a magic number: length = (GlobalRandom.Instance.Next(2) == 0) ? 120 : 180;
Magic Number,CityTrafficSimulator.Vehicle,Bus,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Bus.cs,Bus,The following statement contains a magic number: length = (GlobalRandom.Instance.Next(2) == 0) ? 120 : 180;
Magic Number,CityTrafficSimulator.Vehicle,Bus,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Bus.cs,Bus,The following statement contains a magic number: length = (GlobalRandom.Instance.Next(2) == 0) ? 120 : 180;
Magic Number,CityTrafficSimulator.Vehicle,Bus,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Bus.cs,Bus,The following statement contains a magic number: color = Color.FromArgb(GlobalRandom.Instance.Next(256)' GlobalRandom.Instance.Next(256)' GlobalRandom.Instance.Next(256));
Magic Number,CityTrafficSimulator.Vehicle,Bus,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Bus.cs,Bus,The following statement contains a magic number: color = Color.FromArgb(GlobalRandom.Instance.Next(256)' GlobalRandom.Instance.Next(256)' GlobalRandom.Instance.Next(256));
Magic Number,CityTrafficSimulator.Vehicle,Bus,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Bus.cs,Bus,The following statement contains a magic number: color = Color.FromArgb(GlobalRandom.Instance.Next(256)' GlobalRandom.Instance.Next(256)' GlobalRandom.Instance.Next(256));
Magic Number,CityTrafficSimulator.Vehicle,Bus,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Bus.cs,Bus,The following statement contains a magic number: a = 0.9;
Magic Number,CityTrafficSimulator.Vehicle,Bus,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Bus.cs,BuildGraphicsPath,The following statement contains a magic number: if (_length == 120)  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 120)'  									  };  				if ((positions[0] - positions[1]).IsNotZeroVector())  					{  					Vector2[] normals = {  						(positions[0] - positions[1]).RotatedClockwise.Normalized'  									  };    					PointF[] frontPoints = {   						positions[0]  -  11*normals[0]'  						positions[0]  +  11*normals[0]'  						positions[1]  +  11*normals[0]'  						positions[1]  -  11*normals[0]'  					};    					toReturn.AddPolygon(frontPoints);  					}  				}  			// Gelenkbus  			else  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 105)'  					GetPositionAbsAtArcPos(currentPosition - 180)  									  };  				if ((positions[0] - positions[1]).IsNotZeroVector() && (positions[2] - positions[3]).IsNotZeroVector())  					{  					Vector2[] normals = {  						(positions[0] - positions[1]).RotatedClockwise.Normalized'  						(positions[2] - positions[3]).RotatedClockwise.Normalized  									  };    					PointF[] frontPoints = {   						positions[0]  -  11*normals[0]'  						positions[0]  +  11*normals[0]'  						positions[1]  +  11*normals[0]'  						positions[1]  -  11*normals[0]'  					};  					PointF[] backPoints = {   						positions[2]  -  11*normals[1]'  						positions[2]  +  11*normals[1]'  						positions[3]  +  11*normals[1]'  						positions[3]  -  11*normals[1]'  					};    					toReturn.AddPolygon(frontPoints);  					toReturn.AddPolygon(backPoints);  					}  				}
Magic Number,CityTrafficSimulator.Vehicle,Bus,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Bus.cs,BuildGraphicsPath,The following statement contains a magic number: if (_length == 120)  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 120)'  									  };  				if ((positions[0] - positions[1]).IsNotZeroVector())  					{  					Vector2[] normals = {  						(positions[0] - positions[1]).RotatedClockwise.Normalized'  									  };    					PointF[] frontPoints = {   						positions[0]  -  11*normals[0]'  						positions[0]  +  11*normals[0]'  						positions[1]  +  11*normals[0]'  						positions[1]  -  11*normals[0]'  					};    					toReturn.AddPolygon(frontPoints);  					}  				}  			// Gelenkbus  			else  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 105)'  					GetPositionAbsAtArcPos(currentPosition - 180)  									  };  				if ((positions[0] - positions[1]).IsNotZeroVector() && (positions[2] - positions[3]).IsNotZeroVector())  					{  					Vector2[] normals = {  						(positions[0] - positions[1]).RotatedClockwise.Normalized'  						(positions[2] - positions[3]).RotatedClockwise.Normalized  									  };    					PointF[] frontPoints = {   						positions[0]  -  11*normals[0]'  						positions[0]  +  11*normals[0]'  						positions[1]  +  11*normals[0]'  						positions[1]  -  11*normals[0]'  					};  					PointF[] backPoints = {   						positions[2]  -  11*normals[1]'  						positions[2]  +  11*normals[1]'  						positions[3]  +  11*normals[1]'  						positions[3]  -  11*normals[1]'  					};    					toReturn.AddPolygon(frontPoints);  					toReturn.AddPolygon(backPoints);  					}  				}
Magic Number,CityTrafficSimulator.Vehicle,Bus,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Bus.cs,BuildGraphicsPath,The following statement contains a magic number: if (_length == 120)  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 120)'  									  };  				if ((positions[0] - positions[1]).IsNotZeroVector())  					{  					Vector2[] normals = {  						(positions[0] - positions[1]).RotatedClockwise.Normalized'  									  };    					PointF[] frontPoints = {   						positions[0]  -  11*normals[0]'  						positions[0]  +  11*normals[0]'  						positions[1]  +  11*normals[0]'  						positions[1]  -  11*normals[0]'  					};    					toReturn.AddPolygon(frontPoints);  					}  				}  			// Gelenkbus  			else  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 105)'  					GetPositionAbsAtArcPos(currentPosition - 180)  									  };  				if ((positions[0] - positions[1]).IsNotZeroVector() && (positions[2] - positions[3]).IsNotZeroVector())  					{  					Vector2[] normals = {  						(positions[0] - positions[1]).RotatedClockwise.Normalized'  						(positions[2] - positions[3]).RotatedClockwise.Normalized  									  };    					PointF[] frontPoints = {   						positions[0]  -  11*normals[0]'  						positions[0]  +  11*normals[0]'  						positions[1]  +  11*normals[0]'  						positions[1]  -  11*normals[0]'  					};  					PointF[] backPoints = {   						positions[2]  -  11*normals[1]'  						positions[2]  +  11*normals[1]'  						positions[3]  +  11*normals[1]'  						positions[3]  -  11*normals[1]'  					};    					toReturn.AddPolygon(frontPoints);  					toReturn.AddPolygon(backPoints);  					}  				}
Magic Number,CityTrafficSimulator.Vehicle,Bus,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Bus.cs,BuildGraphicsPath,The following statement contains a magic number: if (_length == 120)  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 120)'  									  };  				if ((positions[0] - positions[1]).IsNotZeroVector())  					{  					Vector2[] normals = {  						(positions[0] - positions[1]).RotatedClockwise.Normalized'  									  };    					PointF[] frontPoints = {   						positions[0]  -  11*normals[0]'  						positions[0]  +  11*normals[0]'  						positions[1]  +  11*normals[0]'  						positions[1]  -  11*normals[0]'  					};    					toReturn.AddPolygon(frontPoints);  					}  				}  			// Gelenkbus  			else  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 105)'  					GetPositionAbsAtArcPos(currentPosition - 180)  									  };  				if ((positions[0] - positions[1]).IsNotZeroVector() && (positions[2] - positions[3]).IsNotZeroVector())  					{  					Vector2[] normals = {  						(positions[0] - positions[1]).RotatedClockwise.Normalized'  						(positions[2] - positions[3]).RotatedClockwise.Normalized  									  };    					PointF[] frontPoints = {   						positions[0]  -  11*normals[0]'  						positions[0]  +  11*normals[0]'  						positions[1]  +  11*normals[0]'  						positions[1]  -  11*normals[0]'  					};  					PointF[] backPoints = {   						positions[2]  -  11*normals[1]'  						positions[2]  +  11*normals[1]'  						positions[3]  +  11*normals[1]'  						positions[3]  -  11*normals[1]'  					};    					toReturn.AddPolygon(frontPoints);  					toReturn.AddPolygon(backPoints);  					}  				}
Magic Number,CityTrafficSimulator.Vehicle,Bus,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Bus.cs,BuildGraphicsPath,The following statement contains a magic number: if (_length == 120)  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 120)'  									  };  				if ((positions[0] - positions[1]).IsNotZeroVector())  					{  					Vector2[] normals = {  						(positions[0] - positions[1]).RotatedClockwise.Normalized'  									  };    					PointF[] frontPoints = {   						positions[0]  -  11*normals[0]'  						positions[0]  +  11*normals[0]'  						positions[1]  +  11*normals[0]'  						positions[1]  -  11*normals[0]'  					};    					toReturn.AddPolygon(frontPoints);  					}  				}  			// Gelenkbus  			else  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 105)'  					GetPositionAbsAtArcPos(currentPosition - 180)  									  };  				if ((positions[0] - positions[1]).IsNotZeroVector() && (positions[2] - positions[3]).IsNotZeroVector())  					{  					Vector2[] normals = {  						(positions[0] - positions[1]).RotatedClockwise.Normalized'  						(positions[2] - positions[3]).RotatedClockwise.Normalized  									  };    					PointF[] frontPoints = {   						positions[0]  -  11*normals[0]'  						positions[0]  +  11*normals[0]'  						positions[1]  +  11*normals[0]'  						positions[1]  -  11*normals[0]'  					};  					PointF[] backPoints = {   						positions[2]  -  11*normals[1]'  						positions[2]  +  11*normals[1]'  						positions[3]  +  11*normals[1]'  						positions[3]  -  11*normals[1]'  					};    					toReturn.AddPolygon(frontPoints);  					toReturn.AddPolygon(backPoints);  					}  				}
Magic Number,CityTrafficSimulator.Vehicle,Bus,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Bus.cs,BuildGraphicsPath,The following statement contains a magic number: if (_length == 120)  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 120)'  									  };  				if ((positions[0] - positions[1]).IsNotZeroVector())  					{  					Vector2[] normals = {  						(positions[0] - positions[1]).RotatedClockwise.Normalized'  									  };    					PointF[] frontPoints = {   						positions[0]  -  11*normals[0]'  						positions[0]  +  11*normals[0]'  						positions[1]  +  11*normals[0]'  						positions[1]  -  11*normals[0]'  					};    					toReturn.AddPolygon(frontPoints);  					}  				}  			// Gelenkbus  			else  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 105)'  					GetPositionAbsAtArcPos(currentPosition - 180)  									  };  				if ((positions[0] - positions[1]).IsNotZeroVector() && (positions[2] - positions[3]).IsNotZeroVector())  					{  					Vector2[] normals = {  						(positions[0] - positions[1]).RotatedClockwise.Normalized'  						(positions[2] - positions[3]).RotatedClockwise.Normalized  									  };    					PointF[] frontPoints = {   						positions[0]  -  11*normals[0]'  						positions[0]  +  11*normals[0]'  						positions[1]  +  11*normals[0]'  						positions[1]  -  11*normals[0]'  					};  					PointF[] backPoints = {   						positions[2]  -  11*normals[1]'  						positions[2]  +  11*normals[1]'  						positions[3]  +  11*normals[1]'  						positions[3]  -  11*normals[1]'  					};    					toReturn.AddPolygon(frontPoints);  					toReturn.AddPolygon(backPoints);  					}  				}
Magic Number,CityTrafficSimulator.Vehicle,Bus,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Bus.cs,BuildGraphicsPath,The following statement contains a magic number: if (_length == 120)  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 120)'  									  };  				if ((positions[0] - positions[1]).IsNotZeroVector())  					{  					Vector2[] normals = {  						(positions[0] - positions[1]).RotatedClockwise.Normalized'  									  };    					PointF[] frontPoints = {   						positions[0]  -  11*normals[0]'  						positions[0]  +  11*normals[0]'  						positions[1]  +  11*normals[0]'  						positions[1]  -  11*normals[0]'  					};    					toReturn.AddPolygon(frontPoints);  					}  				}  			// Gelenkbus  			else  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 105)'  					GetPositionAbsAtArcPos(currentPosition - 180)  									  };  				if ((positions[0] - positions[1]).IsNotZeroVector() && (positions[2] - positions[3]).IsNotZeroVector())  					{  					Vector2[] normals = {  						(positions[0] - positions[1]).RotatedClockwise.Normalized'  						(positions[2] - positions[3]).RotatedClockwise.Normalized  									  };    					PointF[] frontPoints = {   						positions[0]  -  11*normals[0]'  						positions[0]  +  11*normals[0]'  						positions[1]  +  11*normals[0]'  						positions[1]  -  11*normals[0]'  					};  					PointF[] backPoints = {   						positions[2]  -  11*normals[1]'  						positions[2]  +  11*normals[1]'  						positions[3]  +  11*normals[1]'  						positions[3]  -  11*normals[1]'  					};    					toReturn.AddPolygon(frontPoints);  					toReturn.AddPolygon(backPoints);  					}  				}
Magic Number,CityTrafficSimulator.Vehicle,Bus,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Bus.cs,BuildGraphicsPath,The following statement contains a magic number: if (_length == 120)  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 120)'  									  };  				if ((positions[0] - positions[1]).IsNotZeroVector())  					{  					Vector2[] normals = {  						(positions[0] - positions[1]).RotatedClockwise.Normalized'  									  };    					PointF[] frontPoints = {   						positions[0]  -  11*normals[0]'  						positions[0]  +  11*normals[0]'  						positions[1]  +  11*normals[0]'  						positions[1]  -  11*normals[0]'  					};    					toReturn.AddPolygon(frontPoints);  					}  				}  			// Gelenkbus  			else  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 105)'  					GetPositionAbsAtArcPos(currentPosition - 180)  									  };  				if ((positions[0] - positions[1]).IsNotZeroVector() && (positions[2] - positions[3]).IsNotZeroVector())  					{  					Vector2[] normals = {  						(positions[0] - positions[1]).RotatedClockwise.Normalized'  						(positions[2] - positions[3]).RotatedClockwise.Normalized  									  };    					PointF[] frontPoints = {   						positions[0]  -  11*normals[0]'  						positions[0]  +  11*normals[0]'  						positions[1]  +  11*normals[0]'  						positions[1]  -  11*normals[0]'  					};  					PointF[] backPoints = {   						positions[2]  -  11*normals[1]'  						positions[2]  +  11*normals[1]'  						positions[3]  +  11*normals[1]'  						positions[3]  -  11*normals[1]'  					};    					toReturn.AddPolygon(frontPoints);  					toReturn.AddPolygon(backPoints);  					}  				}
Magic Number,CityTrafficSimulator.Vehicle,Bus,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Bus.cs,BuildGraphicsPath,The following statement contains a magic number: if (_length == 120)  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 120)'  									  };  				if ((positions[0] - positions[1]).IsNotZeroVector())  					{  					Vector2[] normals = {  						(positions[0] - positions[1]).RotatedClockwise.Normalized'  									  };    					PointF[] frontPoints = {   						positions[0]  -  11*normals[0]'  						positions[0]  +  11*normals[0]'  						positions[1]  +  11*normals[0]'  						positions[1]  -  11*normals[0]'  					};    					toReturn.AddPolygon(frontPoints);  					}  				}  			// Gelenkbus  			else  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 105)'  					GetPositionAbsAtArcPos(currentPosition - 180)  									  };  				if ((positions[0] - positions[1]).IsNotZeroVector() && (positions[2] - positions[3]).IsNotZeroVector())  					{  					Vector2[] normals = {  						(positions[0] - positions[1]).RotatedClockwise.Normalized'  						(positions[2] - positions[3]).RotatedClockwise.Normalized  									  };    					PointF[] frontPoints = {   						positions[0]  -  11*normals[0]'  						positions[0]  +  11*normals[0]'  						positions[1]  +  11*normals[0]'  						positions[1]  -  11*normals[0]'  					};  					PointF[] backPoints = {   						positions[2]  -  11*normals[1]'  						positions[2]  +  11*normals[1]'  						positions[3]  +  11*normals[1]'  						positions[3]  -  11*normals[1]'  					};    					toReturn.AddPolygon(frontPoints);  					toReturn.AddPolygon(backPoints);  					}  				}
Magic Number,CityTrafficSimulator.Vehicle,Bus,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Bus.cs,BuildGraphicsPath,The following statement contains a magic number: if (_length == 120)  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 120)'  									  };  				if ((positions[0] - positions[1]).IsNotZeroVector())  					{  					Vector2[] normals = {  						(positions[0] - positions[1]).RotatedClockwise.Normalized'  									  };    					PointF[] frontPoints = {   						positions[0]  -  11*normals[0]'  						positions[0]  +  11*normals[0]'  						positions[1]  +  11*normals[0]'  						positions[1]  -  11*normals[0]'  					};    					toReturn.AddPolygon(frontPoints);  					}  				}  			// Gelenkbus  			else  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 105)'  					GetPositionAbsAtArcPos(currentPosition - 180)  									  };  				if ((positions[0] - positions[1]).IsNotZeroVector() && (positions[2] - positions[3]).IsNotZeroVector())  					{  					Vector2[] normals = {  						(positions[0] - positions[1]).RotatedClockwise.Normalized'  						(positions[2] - positions[3]).RotatedClockwise.Normalized  									  };    					PointF[] frontPoints = {   						positions[0]  -  11*normals[0]'  						positions[0]  +  11*normals[0]'  						positions[1]  +  11*normals[0]'  						positions[1]  -  11*normals[0]'  					};  					PointF[] backPoints = {   						positions[2]  -  11*normals[1]'  						positions[2]  +  11*normals[1]'  						positions[3]  +  11*normals[1]'  						positions[3]  -  11*normals[1]'  					};    					toReturn.AddPolygon(frontPoints);  					toReturn.AddPolygon(backPoints);  					}  				}
Magic Number,CityTrafficSimulator.Vehicle,Bus,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Bus.cs,BuildGraphicsPath,The following statement contains a magic number: if (_length == 120)  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 120)'  									  };  				if ((positions[0] - positions[1]).IsNotZeroVector())  					{  					Vector2[] normals = {  						(positions[0] - positions[1]).RotatedClockwise.Normalized'  									  };    					PointF[] frontPoints = {   						positions[0]  -  11*normals[0]'  						positions[0]  +  11*normals[0]'  						positions[1]  +  11*normals[0]'  						positions[1]  -  11*normals[0]'  					};    					toReturn.AddPolygon(frontPoints);  					}  				}  			// Gelenkbus  			else  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 105)'  					GetPositionAbsAtArcPos(currentPosition - 180)  									  };  				if ((positions[0] - positions[1]).IsNotZeroVector() && (positions[2] - positions[3]).IsNotZeroVector())  					{  					Vector2[] normals = {  						(positions[0] - positions[1]).RotatedClockwise.Normalized'  						(positions[2] - positions[3]).RotatedClockwise.Normalized  									  };    					PointF[] frontPoints = {   						positions[0]  -  11*normals[0]'  						positions[0]  +  11*normals[0]'  						positions[1]  +  11*normals[0]'  						positions[1]  -  11*normals[0]'  					};  					PointF[] backPoints = {   						positions[2]  -  11*normals[1]'  						positions[2]  +  11*normals[1]'  						positions[3]  +  11*normals[1]'  						positions[3]  -  11*normals[1]'  					};    					toReturn.AddPolygon(frontPoints);  					toReturn.AddPolygon(backPoints);  					}  				}
Magic Number,CityTrafficSimulator.Vehicle,Bus,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Bus.cs,BuildGraphicsPath,The following statement contains a magic number: if (_length == 120)  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 120)'  									  };  				if ((positions[0] - positions[1]).IsNotZeroVector())  					{  					Vector2[] normals = {  						(positions[0] - positions[1]).RotatedClockwise.Normalized'  									  };    					PointF[] frontPoints = {   						positions[0]  -  11*normals[0]'  						positions[0]  +  11*normals[0]'  						positions[1]  +  11*normals[0]'  						positions[1]  -  11*normals[0]'  					};    					toReturn.AddPolygon(frontPoints);  					}  				}  			// Gelenkbus  			else  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 105)'  					GetPositionAbsAtArcPos(currentPosition - 180)  									  };  				if ((positions[0] - positions[1]).IsNotZeroVector() && (positions[2] - positions[3]).IsNotZeroVector())  					{  					Vector2[] normals = {  						(positions[0] - positions[1]).RotatedClockwise.Normalized'  						(positions[2] - positions[3]).RotatedClockwise.Normalized  									  };    					PointF[] frontPoints = {   						positions[0]  -  11*normals[0]'  						positions[0]  +  11*normals[0]'  						positions[1]  +  11*normals[0]'  						positions[1]  -  11*normals[0]'  					};  					PointF[] backPoints = {   						positions[2]  -  11*normals[1]'  						positions[2]  +  11*normals[1]'  						positions[3]  +  11*normals[1]'  						positions[3]  -  11*normals[1]'  					};    					toReturn.AddPolygon(frontPoints);  					toReturn.AddPolygon(backPoints);  					}  				}
Magic Number,CityTrafficSimulator.Vehicle,Bus,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Bus.cs,BuildGraphicsPath,The following statement contains a magic number: if (_length == 120)  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 120)'  									  };  				if ((positions[0] - positions[1]).IsNotZeroVector())  					{  					Vector2[] normals = {  						(positions[0] - positions[1]).RotatedClockwise.Normalized'  									  };    					PointF[] frontPoints = {   						positions[0]  -  11*normals[0]'  						positions[0]  +  11*normals[0]'  						positions[1]  +  11*normals[0]'  						positions[1]  -  11*normals[0]'  					};    					toReturn.AddPolygon(frontPoints);  					}  				}  			// Gelenkbus  			else  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 105)'  					GetPositionAbsAtArcPos(currentPosition - 180)  									  };  				if ((positions[0] - positions[1]).IsNotZeroVector() && (positions[2] - positions[3]).IsNotZeroVector())  					{  					Vector2[] normals = {  						(positions[0] - positions[1]).RotatedClockwise.Normalized'  						(positions[2] - positions[3]).RotatedClockwise.Normalized  									  };    					PointF[] frontPoints = {   						positions[0]  -  11*normals[0]'  						positions[0]  +  11*normals[0]'  						positions[1]  +  11*normals[0]'  						positions[1]  -  11*normals[0]'  					};  					PointF[] backPoints = {   						positions[2]  -  11*normals[1]'  						positions[2]  +  11*normals[1]'  						positions[3]  +  11*normals[1]'  						positions[3]  -  11*normals[1]'  					};    					toReturn.AddPolygon(frontPoints);  					toReturn.AddPolygon(backPoints);  					}  				}
Magic Number,CityTrafficSimulator.Vehicle,Bus,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Bus.cs,BuildGraphicsPath,The following statement contains a magic number: if (_length == 120)  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 120)'  									  };  				if ((positions[0] - positions[1]).IsNotZeroVector())  					{  					Vector2[] normals = {  						(positions[0] - positions[1]).RotatedClockwise.Normalized'  									  };    					PointF[] frontPoints = {   						positions[0]  -  11*normals[0]'  						positions[0]  +  11*normals[0]'  						positions[1]  +  11*normals[0]'  						positions[1]  -  11*normals[0]'  					};    					toReturn.AddPolygon(frontPoints);  					}  				}  			// Gelenkbus  			else  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 105)'  					GetPositionAbsAtArcPos(currentPosition - 180)  									  };  				if ((positions[0] - positions[1]).IsNotZeroVector() && (positions[2] - positions[3]).IsNotZeroVector())  					{  					Vector2[] normals = {  						(positions[0] - positions[1]).RotatedClockwise.Normalized'  						(positions[2] - positions[3]).RotatedClockwise.Normalized  									  };    					PointF[] frontPoints = {   						positions[0]  -  11*normals[0]'  						positions[0]  +  11*normals[0]'  						positions[1]  +  11*normals[0]'  						positions[1]  -  11*normals[0]'  					};  					PointF[] backPoints = {   						positions[2]  -  11*normals[1]'  						positions[2]  +  11*normals[1]'  						positions[3]  +  11*normals[1]'  						positions[3]  -  11*normals[1]'  					};    					toReturn.AddPolygon(frontPoints);  					toReturn.AddPolygon(backPoints);  					}  				}
Magic Number,CityTrafficSimulator.Vehicle,Bus,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Bus.cs,BuildGraphicsPath,The following statement contains a magic number: if (_length == 120)  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 120)'  									  };  				if ((positions[0] - positions[1]).IsNotZeroVector())  					{  					Vector2[] normals = {  						(positions[0] - positions[1]).RotatedClockwise.Normalized'  									  };    					PointF[] frontPoints = {   						positions[0]  -  11*normals[0]'  						positions[0]  +  11*normals[0]'  						positions[1]  +  11*normals[0]'  						positions[1]  -  11*normals[0]'  					};    					toReturn.AddPolygon(frontPoints);  					}  				}  			// Gelenkbus  			else  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 105)'  					GetPositionAbsAtArcPos(currentPosition - 180)  									  };  				if ((positions[0] - positions[1]).IsNotZeroVector() && (positions[2] - positions[3]).IsNotZeroVector())  					{  					Vector2[] normals = {  						(positions[0] - positions[1]).RotatedClockwise.Normalized'  						(positions[2] - positions[3]).RotatedClockwise.Normalized  									  };    					PointF[] frontPoints = {   						positions[0]  -  11*normals[0]'  						positions[0]  +  11*normals[0]'  						positions[1]  +  11*normals[0]'  						positions[1]  -  11*normals[0]'  					};  					PointF[] backPoints = {   						positions[2]  -  11*normals[1]'  						positions[2]  +  11*normals[1]'  						positions[3]  +  11*normals[1]'  						positions[3]  -  11*normals[1]'  					};    					toReturn.AddPolygon(frontPoints);  					toReturn.AddPolygon(backPoints);  					}  				}
Magic Number,CityTrafficSimulator.Vehicle,Bus,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Bus.cs,BuildGraphicsPath,The following statement contains a magic number: if (_length == 120)  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 120)'  									  };  				if ((positions[0] - positions[1]).IsNotZeroVector())  					{  					Vector2[] normals = {  						(positions[0] - positions[1]).RotatedClockwise.Normalized'  									  };    					PointF[] frontPoints = {   						positions[0]  -  11*normals[0]'  						positions[0]  +  11*normals[0]'  						positions[1]  +  11*normals[0]'  						positions[1]  -  11*normals[0]'  					};    					toReturn.AddPolygon(frontPoints);  					}  				}  			// Gelenkbus  			else  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 105)'  					GetPositionAbsAtArcPos(currentPosition - 180)  									  };  				if ((positions[0] - positions[1]).IsNotZeroVector() && (positions[2] - positions[3]).IsNotZeroVector())  					{  					Vector2[] normals = {  						(positions[0] - positions[1]).RotatedClockwise.Normalized'  						(positions[2] - positions[3]).RotatedClockwise.Normalized  									  };    					PointF[] frontPoints = {   						positions[0]  -  11*normals[0]'  						positions[0]  +  11*normals[0]'  						positions[1]  +  11*normals[0]'  						positions[1]  -  11*normals[0]'  					};  					PointF[] backPoints = {   						positions[2]  -  11*normals[1]'  						positions[2]  +  11*normals[1]'  						positions[3]  +  11*normals[1]'  						positions[3]  -  11*normals[1]'  					};    					toReturn.AddPolygon(frontPoints);  					toReturn.AddPolygon(backPoints);  					}  				}
Magic Number,CityTrafficSimulator.Vehicle,Bus,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Bus.cs,BuildGraphicsPath,The following statement contains a magic number: if (_length == 120)  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 120)'  									  };  				if ((positions[0] - positions[1]).IsNotZeroVector())  					{  					Vector2[] normals = {  						(positions[0] - positions[1]).RotatedClockwise.Normalized'  									  };    					PointF[] frontPoints = {   						positions[0]  -  11*normals[0]'  						positions[0]  +  11*normals[0]'  						positions[1]  +  11*normals[0]'  						positions[1]  -  11*normals[0]'  					};    					toReturn.AddPolygon(frontPoints);  					}  				}  			// Gelenkbus  			else  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 105)'  					GetPositionAbsAtArcPos(currentPosition - 180)  									  };  				if ((positions[0] - positions[1]).IsNotZeroVector() && (positions[2] - positions[3]).IsNotZeroVector())  					{  					Vector2[] normals = {  						(positions[0] - positions[1]).RotatedClockwise.Normalized'  						(positions[2] - positions[3]).RotatedClockwise.Normalized  									  };    					PointF[] frontPoints = {   						positions[0]  -  11*normals[0]'  						positions[0]  +  11*normals[0]'  						positions[1]  +  11*normals[0]'  						positions[1]  -  11*normals[0]'  					};  					PointF[] backPoints = {   						positions[2]  -  11*normals[1]'  						positions[2]  +  11*normals[1]'  						positions[3]  +  11*normals[1]'  						positions[3]  -  11*normals[1]'  					};    					toReturn.AddPolygon(frontPoints);  					toReturn.AddPolygon(backPoints);  					}  				}
Magic Number,CityTrafficSimulator.Vehicle,Bus,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Bus.cs,BuildGraphicsPath,The following statement contains a magic number: if (_length == 120)  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 120)'  									  };  				if ((positions[0] - positions[1]).IsNotZeroVector())  					{  					Vector2[] normals = {  						(positions[0] - positions[1]).RotatedClockwise.Normalized'  									  };    					PointF[] frontPoints = {   						positions[0]  -  11*normals[0]'  						positions[0]  +  11*normals[0]'  						positions[1]  +  11*normals[0]'  						positions[1]  -  11*normals[0]'  					};    					toReturn.AddPolygon(frontPoints);  					}  				}  			// Gelenkbus  			else  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 105)'  					GetPositionAbsAtArcPos(currentPosition - 180)  									  };  				if ((positions[0] - positions[1]).IsNotZeroVector() && (positions[2] - positions[3]).IsNotZeroVector())  					{  					Vector2[] normals = {  						(positions[0] - positions[1]).RotatedClockwise.Normalized'  						(positions[2] - positions[3]).RotatedClockwise.Normalized  									  };    					PointF[] frontPoints = {   						positions[0]  -  11*normals[0]'  						positions[0]  +  11*normals[0]'  						positions[1]  +  11*normals[0]'  						positions[1]  -  11*normals[0]'  					};  					PointF[] backPoints = {   						positions[2]  -  11*normals[1]'  						positions[2]  +  11*normals[1]'  						positions[3]  +  11*normals[1]'  						positions[3]  -  11*normals[1]'  					};    					toReturn.AddPolygon(frontPoints);  					toReturn.AddPolygon(backPoints);  					}  				}
Magic Number,CityTrafficSimulator.Vehicle,Bus,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Bus.cs,BuildGraphicsPath,The following statement contains a magic number: if (_length == 120)  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 120)'  									  };  				if ((positions[0] - positions[1]).IsNotZeroVector())  					{  					Vector2[] normals = {  						(positions[0] - positions[1]).RotatedClockwise.Normalized'  									  };    					PointF[] frontPoints = {   						positions[0]  -  11*normals[0]'  						positions[0]  +  11*normals[0]'  						positions[1]  +  11*normals[0]'  						positions[1]  -  11*normals[0]'  					};    					toReturn.AddPolygon(frontPoints);  					}  				}  			// Gelenkbus  			else  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 105)'  					GetPositionAbsAtArcPos(currentPosition - 180)  									  };  				if ((positions[0] - positions[1]).IsNotZeroVector() && (positions[2] - positions[3]).IsNotZeroVector())  					{  					Vector2[] normals = {  						(positions[0] - positions[1]).RotatedClockwise.Normalized'  						(positions[2] - positions[3]).RotatedClockwise.Normalized  									  };    					PointF[] frontPoints = {   						positions[0]  -  11*normals[0]'  						positions[0]  +  11*normals[0]'  						positions[1]  +  11*normals[0]'  						positions[1]  -  11*normals[0]'  					};  					PointF[] backPoints = {   						positions[2]  -  11*normals[1]'  						positions[2]  +  11*normals[1]'  						positions[3]  +  11*normals[1]'  						positions[3]  -  11*normals[1]'  					};    					toReturn.AddPolygon(frontPoints);  					toReturn.AddPolygon(backPoints);  					}  				}
Magic Number,CityTrafficSimulator.Vehicle,Bus,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Bus.cs,BuildGraphicsPath,The following statement contains a magic number: if (_length == 120)  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 120)'  									  };  				if ((positions[0] - positions[1]).IsNotZeroVector())  					{  					Vector2[] normals = {  						(positions[0] - positions[1]).RotatedClockwise.Normalized'  									  };    					PointF[] frontPoints = {   						positions[0]  -  11*normals[0]'  						positions[0]  +  11*normals[0]'  						positions[1]  +  11*normals[0]'  						positions[1]  -  11*normals[0]'  					};    					toReturn.AddPolygon(frontPoints);  					}  				}  			// Gelenkbus  			else  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 105)'  					GetPositionAbsAtArcPos(currentPosition - 180)  									  };  				if ((positions[0] - positions[1]).IsNotZeroVector() && (positions[2] - positions[3]).IsNotZeroVector())  					{  					Vector2[] normals = {  						(positions[0] - positions[1]).RotatedClockwise.Normalized'  						(positions[2] - positions[3]).RotatedClockwise.Normalized  									  };    					PointF[] frontPoints = {   						positions[0]  -  11*normals[0]'  						positions[0]  +  11*normals[0]'  						positions[1]  +  11*normals[0]'  						positions[1]  -  11*normals[0]'  					};  					PointF[] backPoints = {   						positions[2]  -  11*normals[1]'  						positions[2]  +  11*normals[1]'  						positions[3]  +  11*normals[1]'  						positions[3]  -  11*normals[1]'  					};    					toReturn.AddPolygon(frontPoints);  					toReturn.AddPolygon(backPoints);  					}  				}
Magic Number,CityTrafficSimulator.Vehicle,Bus,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Bus.cs,BuildGraphicsPath,The following statement contains a magic number: if (_length == 120)  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 120)'  									  };  				if ((positions[0] - positions[1]).IsNotZeroVector())  					{  					Vector2[] normals = {  						(positions[0] - positions[1]).RotatedClockwise.Normalized'  									  };    					PointF[] frontPoints = {   						positions[0]  -  11*normals[0]'  						positions[0]  +  11*normals[0]'  						positions[1]  +  11*normals[0]'  						positions[1]  -  11*normals[0]'  					};    					toReturn.AddPolygon(frontPoints);  					}  				}  			// Gelenkbus  			else  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 105)'  					GetPositionAbsAtArcPos(currentPosition - 180)  									  };  				if ((positions[0] - positions[1]).IsNotZeroVector() && (positions[2] - positions[3]).IsNotZeroVector())  					{  					Vector2[] normals = {  						(positions[0] - positions[1]).RotatedClockwise.Normalized'  						(positions[2] - positions[3]).RotatedClockwise.Normalized  									  };    					PointF[] frontPoints = {   						positions[0]  -  11*normals[0]'  						positions[0]  +  11*normals[0]'  						positions[1]  +  11*normals[0]'  						positions[1]  -  11*normals[0]'  					};  					PointF[] backPoints = {   						positions[2]  -  11*normals[1]'  						positions[2]  +  11*normals[1]'  						positions[3]  +  11*normals[1]'  						positions[3]  -  11*normals[1]'  					};    					toReturn.AddPolygon(frontPoints);  					toReturn.AddPolygon(backPoints);  					}  				}
Magic Number,CityTrafficSimulator.Vehicle,Bus,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Bus.cs,BuildGraphicsPath,The following statement contains a magic number: if (_length == 120)  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 120)'  									  };  				if ((positions[0] - positions[1]).IsNotZeroVector())  					{  					Vector2[] normals = {  						(positions[0] - positions[1]).RotatedClockwise.Normalized'  									  };    					PointF[] frontPoints = {   						positions[0]  -  11*normals[0]'  						positions[0]  +  11*normals[0]'  						positions[1]  +  11*normals[0]'  						positions[1]  -  11*normals[0]'  					};    					toReturn.AddPolygon(frontPoints);  					}  				}  			// Gelenkbus  			else  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 105)'  					GetPositionAbsAtArcPos(currentPosition - 180)  									  };  				if ((positions[0] - positions[1]).IsNotZeroVector() && (positions[2] - positions[3]).IsNotZeroVector())  					{  					Vector2[] normals = {  						(positions[0] - positions[1]).RotatedClockwise.Normalized'  						(positions[2] - positions[3]).RotatedClockwise.Normalized  									  };    					PointF[] frontPoints = {   						positions[0]  -  11*normals[0]'  						positions[0]  +  11*normals[0]'  						positions[1]  +  11*normals[0]'  						positions[1]  -  11*normals[0]'  					};  					PointF[] backPoints = {   						positions[2]  -  11*normals[1]'  						positions[2]  +  11*normals[1]'  						positions[3]  +  11*normals[1]'  						positions[3]  -  11*normals[1]'  					};    					toReturn.AddPolygon(frontPoints);  					toReturn.AddPolygon(backPoints);  					}  				}
Magic Number,CityTrafficSimulator.Vehicle,Bus,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Bus.cs,BuildGraphicsPath,The following statement contains a magic number: if (_length == 120)  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 120)'  									  };  				if ((positions[0] - positions[1]).IsNotZeroVector())  					{  					Vector2[] normals = {  						(positions[0] - positions[1]).RotatedClockwise.Normalized'  									  };    					PointF[] frontPoints = {   						positions[0]  -  11*normals[0]'  						positions[0]  +  11*normals[0]'  						positions[1]  +  11*normals[0]'  						positions[1]  -  11*normals[0]'  					};    					toReturn.AddPolygon(frontPoints);  					}  				}  			// Gelenkbus  			else  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 105)'  					GetPositionAbsAtArcPos(currentPosition - 180)  									  };  				if ((positions[0] - positions[1]).IsNotZeroVector() && (positions[2] - positions[3]).IsNotZeroVector())  					{  					Vector2[] normals = {  						(positions[0] - positions[1]).RotatedClockwise.Normalized'  						(positions[2] - positions[3]).RotatedClockwise.Normalized  									  };    					PointF[] frontPoints = {   						positions[0]  -  11*normals[0]'  						positions[0]  +  11*normals[0]'  						positions[1]  +  11*normals[0]'  						positions[1]  -  11*normals[0]'  					};  					PointF[] backPoints = {   						positions[2]  -  11*normals[1]'  						positions[2]  +  11*normals[1]'  						positions[3]  +  11*normals[1]'  						positions[3]  -  11*normals[1]'  					};    					toReturn.AddPolygon(frontPoints);  					toReturn.AddPolygon(backPoints);  					}  				}
Magic Number,CityTrafficSimulator.Vehicle,Bus,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Bus.cs,BuildGraphicsPath,The following statement contains a magic number: if (_length == 120)  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 120)'  									  };  				if ((positions[0] - positions[1]).IsNotZeroVector())  					{  					Vector2[] normals = {  						(positions[0] - positions[1]).RotatedClockwise.Normalized'  									  };    					PointF[] frontPoints = {   						positions[0]  -  11*normals[0]'  						positions[0]  +  11*normals[0]'  						positions[1]  +  11*normals[0]'  						positions[1]  -  11*normals[0]'  					};    					toReturn.AddPolygon(frontPoints);  					}  				}  			// Gelenkbus  			else  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 105)'  					GetPositionAbsAtArcPos(currentPosition - 180)  									  };  				if ((positions[0] - positions[1]).IsNotZeroVector() && (positions[2] - positions[3]).IsNotZeroVector())  					{  					Vector2[] normals = {  						(positions[0] - positions[1]).RotatedClockwise.Normalized'  						(positions[2] - positions[3]).RotatedClockwise.Normalized  									  };    					PointF[] frontPoints = {   						positions[0]  -  11*normals[0]'  						positions[0]  +  11*normals[0]'  						positions[1]  +  11*normals[0]'  						positions[1]  -  11*normals[0]'  					};  					PointF[] backPoints = {   						positions[2]  -  11*normals[1]'  						positions[2]  +  11*normals[1]'  						positions[3]  +  11*normals[1]'  						positions[3]  -  11*normals[1]'  					};    					toReturn.AddPolygon(frontPoints);  					toReturn.AddPolygon(backPoints);  					}  				}
Magic Number,CityTrafficSimulator.Vehicle,Bus,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Bus.cs,BuildGraphicsPath,The following statement contains a magic number: if (_length == 120)  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 120)'  									  };  				if ((positions[0] - positions[1]).IsNotZeroVector())  					{  					Vector2[] normals = {  						(positions[0] - positions[1]).RotatedClockwise.Normalized'  									  };    					PointF[] frontPoints = {   						positions[0]  -  11*normals[0]'  						positions[0]  +  11*normals[0]'  						positions[1]  +  11*normals[0]'  						positions[1]  -  11*normals[0]'  					};    					toReturn.AddPolygon(frontPoints);  					}  				}  			// Gelenkbus  			else  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 105)'  					GetPositionAbsAtArcPos(currentPosition - 180)  									  };  				if ((positions[0] - positions[1]).IsNotZeroVector() && (positions[2] - positions[3]).IsNotZeroVector())  					{  					Vector2[] normals = {  						(positions[0] - positions[1]).RotatedClockwise.Normalized'  						(positions[2] - positions[3]).RotatedClockwise.Normalized  									  };    					PointF[] frontPoints = {   						positions[0]  -  11*normals[0]'  						positions[0]  +  11*normals[0]'  						positions[1]  +  11*normals[0]'  						positions[1]  -  11*normals[0]'  					};  					PointF[] backPoints = {   						positions[2]  -  11*normals[1]'  						positions[2]  +  11*normals[1]'  						positions[3]  +  11*normals[1]'  						positions[3]  -  11*normals[1]'  					};    					toReturn.AddPolygon(frontPoints);  					toReturn.AddPolygon(backPoints);  					}  				}
Magic Number,CityTrafficSimulator.Vehicle,Car,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Car.cs,Car,The following statement contains a magic number: length = GlobalRandom.Instance.Next(28' 45);
Magic Number,CityTrafficSimulator.Vehicle,Car,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Car.cs,Car,The following statement contains a magic number: length = GlobalRandom.Instance.Next(28' 45);
Magic Number,CityTrafficSimulator.Vehicle,Car,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Car.cs,Car,The following statement contains a magic number: a *= (GlobalRandom.Instance.NextDouble() + 0.5);
Magic Number,CityTrafficSimulator.Vehicle,Car,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Car.cs,Car,The following statement contains a magic number: b *= (GlobalRandom.Instance.NextDouble() + 0.5);
Magic Number,CityTrafficSimulator.Vehicle,Car,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Car.cs,Car,The following statement contains a magic number: s0 *= (GlobalRandom.Instance.NextDouble() + 0.5);
Magic Number,CityTrafficSimulator.Vehicle,Car,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Car.cs,Car,The following statement contains a magic number: T *= (GlobalRandom.Instance.NextDouble() + 0.5);
Magic Number,CityTrafficSimulator.Vehicle,Car,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Car.cs,Car,The following statement contains a magic number: _physics.targetVelocity += ((GlobalRandom.Instance.NextDouble() - 0.5) * 4);
Magic Number,CityTrafficSimulator.Vehicle,Car,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Car.cs,Car,The following statement contains a magic number: _physics.targetVelocity += ((GlobalRandom.Instance.NextDouble() - 0.5) * 4);
Magic Number,CityTrafficSimulator.Vehicle,Car,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Car.cs,Car,The following statement contains a magic number: color = Color.FromArgb(GlobalRandom.Instance.Next(256)' GlobalRandom.Instance.Next(256)' GlobalRandom.Instance.Next(256));
Magic Number,CityTrafficSimulator.Vehicle,Car,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Car.cs,Car,The following statement contains a magic number: color = Color.FromArgb(GlobalRandom.Instance.Next(256)' GlobalRandom.Instance.Next(256)' GlobalRandom.Instance.Next(256));
Magic Number,CityTrafficSimulator.Vehicle,Car,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Car.cs,Car,The following statement contains a magic number: color = Color.FromArgb(GlobalRandom.Instance.Next(256)' GlobalRandom.Instance.Next(256)' GlobalRandom.Instance.Next(256));
Magic Number,CityTrafficSimulator.Vehicle,IVehicle,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\IVehicle.cs,Think,The following statement contains a magic number: if (_state.letVehicleChangeLine)  				{  				double percentOfLCILeft = (lci == null) ? 0.2 : Math.Max(0.2' (lci.endArcPos - currentPosition - Constants.breakPointBeforeForcedLineChange) / (lci.length - Constants.breakPointBeforeForcedLineChange));  				lookaheadDistance = Math.Max(3 * percentOfLCILeft * s0' _state.tailPositionOfOtherVehicle - currentPosition);  				thinkAboutLineChange = false;  				lowestAcceleration = CalculateAcceleration(physics.velocity' effectiveDesiredVelocity' lookaheadDistance' physics.velocity);  				_state._freeDrive = false;  				}
Magic Number,CityTrafficSimulator.Vehicle,IVehicle,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\IVehicle.cs,Think,The following statement contains a magic number: if (_state.letVehicleChangeLine)  				{  				double percentOfLCILeft = (lci == null) ? 0.2 : Math.Max(0.2' (lci.endArcPos - currentPosition - Constants.breakPointBeforeForcedLineChange) / (lci.length - Constants.breakPointBeforeForcedLineChange));  				lookaheadDistance = Math.Max(3 * percentOfLCILeft * s0' _state.tailPositionOfOtherVehicle - currentPosition);  				thinkAboutLineChange = false;  				lowestAcceleration = CalculateAcceleration(physics.velocity' effectiveDesiredVelocity' lookaheadDistance' physics.velocity);  				_state._freeDrive = false;  				}
Magic Number,CityTrafficSimulator.Vehicle,IVehicle,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\IVehicle.cs,Think,The following statement contains a magic number: if (_state.letVehicleChangeLine)  				{  				double percentOfLCILeft = (lci == null) ? 0.2 : Math.Max(0.2' (lci.endArcPos - currentPosition - Constants.breakPointBeforeForcedLineChange) / (lci.length - Constants.breakPointBeforeForcedLineChange));  				lookaheadDistance = Math.Max(3 * percentOfLCILeft * s0' _state.tailPositionOfOtherVehicle - currentPosition);  				thinkAboutLineChange = false;  				lowestAcceleration = CalculateAcceleration(physics.velocity' effectiveDesiredVelocity' lookaheadDistance' physics.velocity);  				_state._freeDrive = false;  				}
Magic Number,CityTrafficSimulator.Vehicle,IVehicle,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\IVehicle.cs,Think,The following statement contains a magic number: if (theVehicleInFrontOfMe != null && theVehicleInFrontOfMe.distance < lookaheadDistance)  				{  				lookaheadDistance = theVehicleInFrontOfMe.distance;  				thinkAboutLineChange = true;  				lowestAcceleration = CalculateAcceleration(physics.velocity' effectiveDesiredVelocity' theVehicleInFrontOfMe.distance' physics.velocity - theVehicleInFrontOfMe.vehicle.physics.velocity);  				if (lowestAcceleration < 0.1)  					_state._freeDrive = false;    				if (    (theVehicleInFrontOfMe.vehicle.physics.velocity < 2.5)  					 || (theVehicleInFrontOfMe.vehicle.physics.velocity < 5 && theVehicleInFrontOfMe.vehicle.physics.acceleration < 0.1))  					{  					stopDistance = theVehicleInFrontOfMe.distance;  					}  				}  			else  				{  				lowestAcceleration = CalculateAcceleration(physics.velocity' effectiveDesiredVelocity' lookaheadDistance' physics.velocity);  				}
Magic Number,CityTrafficSimulator.Vehicle,IVehicle,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\IVehicle.cs,Think,The following statement contains a magic number: if (theVehicleInFrontOfMe != null && theVehicleInFrontOfMe.distance < lookaheadDistance)  				{  				lookaheadDistance = theVehicleInFrontOfMe.distance;  				thinkAboutLineChange = true;  				lowestAcceleration = CalculateAcceleration(physics.velocity' effectiveDesiredVelocity' theVehicleInFrontOfMe.distance' physics.velocity - theVehicleInFrontOfMe.vehicle.physics.velocity);  				if (lowestAcceleration < 0.1)  					_state._freeDrive = false;    				if (    (theVehicleInFrontOfMe.vehicle.physics.velocity < 2.5)  					 || (theVehicleInFrontOfMe.vehicle.physics.velocity < 5 && theVehicleInFrontOfMe.vehicle.physics.acceleration < 0.1))  					{  					stopDistance = theVehicleInFrontOfMe.distance;  					}  				}  			else  				{  				lowestAcceleration = CalculateAcceleration(physics.velocity' effectiveDesiredVelocity' lookaheadDistance' physics.velocity);  				}
Magic Number,CityTrafficSimulator.Vehicle,IVehicle,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\IVehicle.cs,Think,The following statement contains a magic number: if (theVehicleInFrontOfMe != null && theVehicleInFrontOfMe.distance < lookaheadDistance)  				{  				lookaheadDistance = theVehicleInFrontOfMe.distance;  				thinkAboutLineChange = true;  				lowestAcceleration = CalculateAcceleration(physics.velocity' effectiveDesiredVelocity' theVehicleInFrontOfMe.distance' physics.velocity - theVehicleInFrontOfMe.vehicle.physics.velocity);  				if (lowestAcceleration < 0.1)  					_state._freeDrive = false;    				if (    (theVehicleInFrontOfMe.vehicle.physics.velocity < 2.5)  					 || (theVehicleInFrontOfMe.vehicle.physics.velocity < 5 && theVehicleInFrontOfMe.vehicle.physics.acceleration < 0.1))  					{  					stopDistance = theVehicleInFrontOfMe.distance;  					}  				}  			else  				{  				lowestAcceleration = CalculateAcceleration(physics.velocity' effectiveDesiredVelocity' lookaheadDistance' physics.velocity);  				}
Magic Number,CityTrafficSimulator.Vehicle,IVehicle,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\IVehicle.cs,Think,The following statement contains a magic number: if (theVehicleInFrontOfMe != null && theVehicleInFrontOfMe.distance < lookaheadDistance)  				{  				lookaheadDistance = theVehicleInFrontOfMe.distance;  				thinkAboutLineChange = true;  				lowestAcceleration = CalculateAcceleration(physics.velocity' effectiveDesiredVelocity' theVehicleInFrontOfMe.distance' physics.velocity - theVehicleInFrontOfMe.vehicle.physics.velocity);  				if (lowestAcceleration < 0.1)  					_state._freeDrive = false;    				if (    (theVehicleInFrontOfMe.vehicle.physics.velocity < 2.5)  					 || (theVehicleInFrontOfMe.vehicle.physics.velocity < 5 && theVehicleInFrontOfMe.vehicle.physics.acceleration < 0.1))  					{  					stopDistance = theVehicleInFrontOfMe.distance;  					}  				}  			else  				{  				lowestAcceleration = CalculateAcceleration(physics.velocity' effectiveDesiredVelocity' lookaheadDistance' physics.velocity);  				}
Magic Number,CityTrafficSimulator.Vehicle,IVehicle,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\IVehicle.cs,Think,The following statement contains a magic number: if (!onlySimpleCalculations)  				{  				#region Forced line changes    				// our route forces to perform a line change  				if (lineChangeNeeded && !currentlyChangingLine && lci != null)  					{  					thinkAboutLineChange = false;  					lastLineChangeCheck.Left = GlobalTime.Instance.currentTime;  					lastLineChangeCheck.Right = currentPosition;    					// get current LineChangePoint and check' whether it's leading to our target  					NodeConnection.LineChangePoint lcp = route[0].GetPrevLineChangePoint(arcPos);  					if (lci.targetNode.prevConnections.Contains(lcp.target.nc))  						{  						bool slowDownToBreakPoint = false;  						double myArcPositionOnOtherConnection = lcp.otherStart.arcPosition + (arcPos - lcp.start.arcPosition);    						// check if found LineChangePoint is not too far away to perform the line change  						if ((myArcPositionOnOtherConnection >= 0) && (Math.Abs(arcPos - lcp.start.arcPosition) < Constants.maxDistanceToLineChangePoint * 1.25))  							{  							// Check the relation to my surrounding vehicles on the target NodeConnection  							Pair<VehicleDistance> otherVehicles = lcp.otherStart.nc.GetVehiclesAroundArcPosition(myArcPositionOnOtherConnection' Constants.lookaheadDistance);    							// the new vehicle in front wouldn't be too close  							if (   otherVehicles.Right == null  								|| otherVehicles.Right.distance > otherVehicles.Right.vehicle.length + CalculateWantedDistance(physics.velocity' physics.velocity - otherVehicles.Right.vehicle.physics.velocity)/2)  								{  								// the new vehicle behind wouldn't be too close  								if (   otherVehicles.Left == null  									|| otherVehicles.Left.distance > length + otherVehicles.Left.vehicle.CalculateWantedDistance(otherVehicles.Left.vehicle.physics.velocity' otherVehicles.Left.vehicle.physics.velocity - physics.velocity)/2)  									{  									// calculate my necessary acceleration in case of a line change  									double myAccelerationOnOtherConnection = (otherVehicles.Right != null)  										? CalculateAcceleration(physics.velocity' effectiveDesiredVelocity' otherVehicles.Right.vehicle.currentPosition - myArcPositionOnOtherConnection' physics.velocity - otherVehicles.Right.vehicle.physics.velocity)  										: CalculateAcceleration(physics.velocity' effectiveDesiredVelocity' lookaheadDistance' physics.velocity);    									// calculate the necessary acceleration of the vehicle behind in case of a line change  									double forcedAccelerationOfVehicleBehindMeOnOtherConnection = (otherVehicles.Left != null)  										? CalculateAcceleration(otherVehicles.Left.vehicle.physics.velocity' otherVehicles.Left.vehicle.effectiveDesiredVelocity' otherVehicles.Left.distance' otherVehicles.Left.vehicle.physics.velocity - physics.velocity)  										: 0;    									double currentAccelerationOfVehicleBehindMeOnOtherConnection = (otherVehicles.Left != null) ? otherVehicles.Left.vehicle.physics.acceleration : 0;    									// Final check:  									//  - The new vehicle behind must not break harder than bSave  									//  - My line change must be sufficiently necessary. The closer I come to the end of the LineChangeInterval' the more I may thwart the vehicle behind.   									if (   (forcedAccelerationOfVehicleBehindMeOnOtherConnection > bSave)  										&& ((arcPos - lci.startArcPos) / lci.length >= (currentAccelerationOfVehicleBehindMeOnOtherConnection - forcedAccelerationOfVehicleBehindMeOnOtherConnection)))  										{  										// return to normal velocity  										_physics.multiplierTargetVelocity = 1;    										// initiate the line change  										InitiateLineChange(lcp' arcPos - lcp.start.arcPosition);  										lowestAcceleration = myAccelerationOnOtherConnection;  										}  									// I do not want to change line yet' but I could position myself better between the two other vehicles on the parallel line.  									else if (true)  										{  										// TODO: implement  										slowDownToBreakPoint = true;  										}  									}  								// the new vehicle behind would too close but I can accelerate and are at least as fast as him  								else if (   otherVehicles.Left.vehicle.physics.velocity / this.physics.velocity < 1.2  // I am not significantly slower than him  										 && (otherVehicles.Right == null || otherVehicles.Right.distance > 1.5 * length) // the new vehicle in front is far enough away  										 && lookaheadDistance > 2 * length			// no vehicle/traffic light/intersection in front  										 && lci.endArcPos - arcPos > 2 * length		// enough space left in LineChangeInterval  										 && lowestAcceleration >= -0.1)				// currently not braking  									{  									// accelerate to get in front  									_physics.multiplierTargetVelocity = 1.75;  									lowestAcceleration = Math.Min(lowestAcceleration' CalculateAcceleration(physics.velocity' effectiveDesiredVelocity' lookaheadDistance' physics.velocity));    									_state.SetLineChangeVehicleInteraction(this' otherVehicles.Left.vehicle' lcp.otherStart.nc' myArcPositionOnOtherConnection - _length);  									}  								// There is no way to perform a line change now => slow down  								else  									{  									slowDownToBreakPoint = true;  									}  								}  							// The new vehicle in front is too close => slow down  							else  								{  								slowDownToBreakPoint = true;  								}  							}    						if (slowDownToBreakPoint)  							{  							double percentOfLCILeft = Math.Max(0.2' (lci.endArcPos - currentPosition - Constants.breakPointBeforeForcedLineChange) / (lci.length - Constants.breakPointBeforeForcedLineChange));    							// slow down a bit  							_physics.multiplierTargetVelocity = Math.Min(0.9' 1.5 * percentOfLCILeft);    							// When reaching the end of the LineChangeInterval' check whether there are other possibilities to reach the target:  							if (percentOfLCILeft < 0.5)  								{  								Routing newRTT = Routing.CalculateShortestConenction(route[0].endNode' _targetNodes' _vehicleType);  								// The alternative route does not cost too much -> choose it  								if (newRTT.SegmentCount() > 0 && newRTT.costs / _wayToGo.costs < Constants.maxRatioForEnforcedLineChange)  									{  									_wayToGo = newRTT;  									_physics.multiplierTargetVelocity = 1;  									lineChangeNeeded = false;  									lci = null;  									}  								}  							// Line change still necessacy => stop at break point  							if (lineChangeNeeded)  								{  								if (! _state.letVehicleChangeLine && percentOfLCILeft < 0.8)  									{  									VehicleDistance otherBehind = lcp.otherStart.nc.GetVehicleBeforeArcPosition(myArcPositionOnOtherConnection - ((_length + s0))' Constants.lookaheadDistance);    									// In rare cases deadlocks may appear when a very long and a short vehicle are driving parallel to each other (and both want to change line):  									// Then' none of the two finds a vehicle behind on the parallel connection. Hence' none of the two will wait for the other one  									// and both might drive to the end of the line change interval and there block each other.  									// To avoid this case' if there is no otherBehind' we also look for a parallel vehicle in front of our back (there should be one' otherwise  									// something went terribly wrong above). The longer one of the two will wait for the shorter one to make sure' no deadlock will occur.  									if (otherBehind == null)  										{  										VehicleDistance otherFront = lcp.otherStart.nc.GetVehicleBehindArcPosition(myArcPositionOnOtherConnection - ((_length + s0))' Constants.lookaheadDistance);  										if (otherFront.vehicle.lineChangeNeeded && otherFront.vehicle._length > _length)  											{  											otherBehind = otherFront;  											otherBehind.distance *= -1;  											}  										}    									//Pair<VehicleDistance> vd = lcp.otherStart.nc.GetVehiclesAroundArcPosition(myArcPositionOnOtherConnection - ( (_length + s0))' Constants.lookaheadDistance);  									if (otherBehind != null)// && otherBehind.vehicle.p >= p)  										{  										// tell the vehicle behind my back to wait for me  										_state.SetLineChangeVehicleInteraction(this' otherBehind.vehicle' lcp.otherStart.nc' myArcPositionOnOtherConnection - _length);    										// In addition' I need to get behind the vehicle in front of the vehicle which waits for me. Therefore I adapt the desired velocity  										if (_state.vehicleThatLetsMeChangeLine != null)  											{  											VehicleDistance otherBehindForman = _state.vehicleThatLetsMeChangeLine.currentNodeConnection.GetVehicleBehindArcPosition(_state.vehicleThatLetsMeChangeLine.currentPosition' 2 * (length + s0));  											if (otherBehindForman != null)  												{  												//_physics.multiplierTargetVelocity = Math2.Clamp(Math2.Cubic((otherBehindForman.distance - otherBehind.distance - s0) / (_length + 4 * s0))' 0.3' 1);  												double multPerDistance = 1 - Math2.Clamp((otherBehind.distance + _length + s0 - otherBehindForman.distance + otherBehindForman.vehicle._length + s0) / (otherBehindForman.vehicle._length)' 0.2' 0.75);  												double multPerSpeedDiff = Math2.Clamp((otherBehindForman.vehicle._physics.velocity - _physics.velocity) / 2' 0.25' 0.8);  												_physics.multiplierTargetVelocity = Math.Min(multPerDistance' multPerSpeedDiff);  												}  											}  										}  									}    								lowestAcceleration = Math.Min(lowestAcceleration' CalculateAcceleration(physics.velocity' effectiveDesiredVelocity' lci.endArcPos - Constants.breakPointBeforeForcedLineChange - arcPos' physics.velocity));  								}  							}  						}  					}  				else if (_state.vehicleThatLetsMeChangeLine != null)  					{  					_state.UnsetLineChangeVehicleInteraction();  					}    				#endregion    				#region freiwillig    				thinkAboutLineChange &= ((GlobalTime.Instance.currentTime - lastLineChangeCheck.Left > 1) || (currentPosition - lastLineChangeCheck.Right > 50));    				if (thinkAboutLineChange && !currentlyChangingLine)  					{  					lastLineChangeCheck.Left = GlobalTime.Instance.currentTime;  					lastLineChangeCheck.Right = currentPosition;    					// get current LineChangePoint and check' whether it's reachable  					NodeConnection.LineChangePoint lcp = route[0].GetPrevLineChangePoint(arcPos);  					if ((lcp.target.nc != null) && (Math.Abs(arcPos - lcp.start.arcPosition) < Constants.maxDistanceToLineChangePoint * 0.67))  						{  						// check whether there is an alternative route that is not too costly  						Routing alternativeRoute = Routing.CalculateShortestConenction(lcp.target.nc.endNode' targetNodes' _vehicleType);  						if (alternativeRoute.SegmentCount() > 0 && alternativeRoute.costs / wayToGo.costs < Constants.maxRatioForVoluntaryLineChange && !alternativeRoute.Top().lineChangeNeeded)  							{  							double myArcPositionOnOtherConnection = lcp.otherStart.arcPosition + (arcPos - lcp.start.arcPosition);  							if (myArcPositionOnOtherConnection >= 0)  								{  								// Check the relation to my surrounding vehicles on the target NodeConnection  								Pair<VehicleDistance> otherVehicles = lcp.otherStart.nc.GetVehiclesAroundArcPosition(myArcPositionOnOtherConnection' Constants.lookaheadDistance);    								// the new vehicle in front wouldn't be too close  								if (   otherVehicles.Right == null  									|| otherVehicles.Right.distance > otherVehicles.Right.vehicle.length + 2 * lcp.length)  									{  									// the new vehicle behind wouldn't be too close  									if (   otherVehicles.Left == null  										|| otherVehicles.Left.distance > length + otherVehicles.Left.vehicle.CalculateWantedDistance(otherVehicles.Left.vehicle.physics.velocity' otherVehicles.Left.vehicle.physics.velocity - physics.velocity)/2)  										{  										List<NodeConnection> l = new List<NodeConnection>();  										l.Add(lcp.target.nc);  										foreach (Routing.RouteSegment rs in alternativeRoute)  											l.Add(rs.startConnection);    										// calculate my necessary acceleration in case of a line change  										double myAccelerationOnOtherConnection = (otherVehicles.Right != null)  											? CalculateAcceleration(physics.velocity' effectiveDesiredVelocity' otherVehicles.Right.vehicle.currentPosition - myArcPositionOnOtherConnection' physics.velocity - otherVehicles.Right.vehicle.physics.velocity)  											: CalculateAcceleration(physics.velocity' effectiveDesiredVelocity' GetDistanceToNextTrafficLightOnRoute(l' myArcPositionOnOtherConnection' Constants.lookaheadDistance' true)' physics.velocity);    										// calculate the necessary acceleration of the vehicle behind in case of a line change  										double forcedAccelerationOfVehicleBehindMeOnOtherConnection = (otherVehicles.Left != null)  											? CalculateAcceleration(otherVehicles.Left.vehicle.physics.velocity' otherVehicles.Left.vehicle.effectiveDesiredVelocity' otherVehicles.Left.distance' otherVehicles.Left.vehicle.physics.velocity - physics.velocity)  											: 0;    										double currentAccelerationOfVehicleBehindMeOnOtherConnection = (otherVehicles.Left != null) ? otherVehicles.Left.vehicle.physics.acceleration : 0;    										// simplified implementation of MOBIL: http://www.vwi.tu-dresden.de/~treiber/MicroApplet/MOBIL.html  										if (forcedAccelerationOfVehicleBehindMeOnOtherConnection > bSave)  											{  											if (myAccelerationOnOtherConnection - lowestAcceleration > p * (currentAccelerationOfVehicleBehindMeOnOtherConnection - forcedAccelerationOfVehicleBehindMeOnOtherConnection) + lineChangeThreshold)  												{  												// initiate the line change  												InitiateLineChange(lcp' arcPos - lcp.start.arcPosition);  												lowestAcceleration = myAccelerationOnOtherConnection;  												}  											}  										}  									}  								}  							}  						}  					}    				#endregion    				}
Magic Number,CityTrafficSimulator.Vehicle,IVehicle,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\IVehicle.cs,Think,The following statement contains a magic number: if (!onlySimpleCalculations)  				{  				#region Forced line changes    				// our route forces to perform a line change  				if (lineChangeNeeded && !currentlyChangingLine && lci != null)  					{  					thinkAboutLineChange = false;  					lastLineChangeCheck.Left = GlobalTime.Instance.currentTime;  					lastLineChangeCheck.Right = currentPosition;    					// get current LineChangePoint and check' whether it's leading to our target  					NodeConnection.LineChangePoint lcp = route[0].GetPrevLineChangePoint(arcPos);  					if (lci.targetNode.prevConnections.Contains(lcp.target.nc))  						{  						bool slowDownToBreakPoint = false;  						double myArcPositionOnOtherConnection = lcp.otherStart.arcPosition + (arcPos - lcp.start.arcPosition);    						// check if found LineChangePoint is not too far away to perform the line change  						if ((myArcPositionOnOtherConnection >= 0) && (Math.Abs(arcPos - lcp.start.arcPosition) < Constants.maxDistanceToLineChangePoint * 1.25))  							{  							// Check the relation to my surrounding vehicles on the target NodeConnection  							Pair<VehicleDistance> otherVehicles = lcp.otherStart.nc.GetVehiclesAroundArcPosition(myArcPositionOnOtherConnection' Constants.lookaheadDistance);    							// the new vehicle in front wouldn't be too close  							if (   otherVehicles.Right == null  								|| otherVehicles.Right.distance > otherVehicles.Right.vehicle.length + CalculateWantedDistance(physics.velocity' physics.velocity - otherVehicles.Right.vehicle.physics.velocity)/2)  								{  								// the new vehicle behind wouldn't be too close  								if (   otherVehicles.Left == null  									|| otherVehicles.Left.distance > length + otherVehicles.Left.vehicle.CalculateWantedDistance(otherVehicles.Left.vehicle.physics.velocity' otherVehicles.Left.vehicle.physics.velocity - physics.velocity)/2)  									{  									// calculate my necessary acceleration in case of a line change  									double myAccelerationOnOtherConnection = (otherVehicles.Right != null)  										? CalculateAcceleration(physics.velocity' effectiveDesiredVelocity' otherVehicles.Right.vehicle.currentPosition - myArcPositionOnOtherConnection' physics.velocity - otherVehicles.Right.vehicle.physics.velocity)  										: CalculateAcceleration(physics.velocity' effectiveDesiredVelocity' lookaheadDistance' physics.velocity);    									// calculate the necessary acceleration of the vehicle behind in case of a line change  									double forcedAccelerationOfVehicleBehindMeOnOtherConnection = (otherVehicles.Left != null)  										? CalculateAcceleration(otherVehicles.Left.vehicle.physics.velocity' otherVehicles.Left.vehicle.effectiveDesiredVelocity' otherVehicles.Left.distance' otherVehicles.Left.vehicle.physics.velocity - physics.velocity)  										: 0;    									double currentAccelerationOfVehicleBehindMeOnOtherConnection = (otherVehicles.Left != null) ? otherVehicles.Left.vehicle.physics.acceleration : 0;    									// Final check:  									//  - The new vehicle behind must not break harder than bSave  									//  - My line change must be sufficiently necessary. The closer I come to the end of the LineChangeInterval' the more I may thwart the vehicle behind.   									if (   (forcedAccelerationOfVehicleBehindMeOnOtherConnection > bSave)  										&& ((arcPos - lci.startArcPos) / lci.length >= (currentAccelerationOfVehicleBehindMeOnOtherConnection - forcedAccelerationOfVehicleBehindMeOnOtherConnection)))  										{  										// return to normal velocity  										_physics.multiplierTargetVelocity = 1;    										// initiate the line change  										InitiateLineChange(lcp' arcPos - lcp.start.arcPosition);  										lowestAcceleration = myAccelerationOnOtherConnection;  										}  									// I do not want to change line yet' but I could position myself better between the two other vehicles on the parallel line.  									else if (true)  										{  										// TODO: implement  										slowDownToBreakPoint = true;  										}  									}  								// the new vehicle behind would too close but I can accelerate and are at least as fast as him  								else if (   otherVehicles.Left.vehicle.physics.velocity / this.physics.velocity < 1.2  // I am not significantly slower than him  										 && (otherVehicles.Right == null || otherVehicles.Right.distance > 1.5 * length) // the new vehicle in front is far enough away  										 && lookaheadDistance > 2 * length			// no vehicle/traffic light/intersection in front  										 && lci.endArcPos - arcPos > 2 * length		// enough space left in LineChangeInterval  										 && lowestAcceleration >= -0.1)				// currently not braking  									{  									// accelerate to get in front  									_physics.multiplierTargetVelocity = 1.75;  									lowestAcceleration = Math.Min(lowestAcceleration' CalculateAcceleration(physics.velocity' effectiveDesiredVelocity' lookaheadDistance' physics.velocity));    									_state.SetLineChangeVehicleInteraction(this' otherVehicles.Left.vehicle' lcp.otherStart.nc' myArcPositionOnOtherConnection - _length);  									}  								// There is no way to perform a line change now => slow down  								else  									{  									slowDownToBreakPoint = true;  									}  								}  							// The new vehicle in front is too close => slow down  							else  								{  								slowDownToBreakPoint = true;  								}  							}    						if (slowDownToBreakPoint)  							{  							double percentOfLCILeft = Math.Max(0.2' (lci.endArcPos - currentPosition - Constants.breakPointBeforeForcedLineChange) / (lci.length - Constants.breakPointBeforeForcedLineChange));    							// slow down a bit  							_physics.multiplierTargetVelocity = Math.Min(0.9' 1.5 * percentOfLCILeft);    							// When reaching the end of the LineChangeInterval' check whether there are other possibilities to reach the target:  							if (percentOfLCILeft < 0.5)  								{  								Routing newRTT = Routing.CalculateShortestConenction(route[0].endNode' _targetNodes' _vehicleType);  								// The alternative route does not cost too much -> choose it  								if (newRTT.SegmentCount() > 0 && newRTT.costs / _wayToGo.costs < Constants.maxRatioForEnforcedLineChange)  									{  									_wayToGo = newRTT;  									_physics.multiplierTargetVelocity = 1;  									lineChangeNeeded = false;  									lci = null;  									}  								}  							// Line change still necessacy => stop at break point  							if (lineChangeNeeded)  								{  								if (! _state.letVehicleChangeLine && percentOfLCILeft < 0.8)  									{  									VehicleDistance otherBehind = lcp.otherStart.nc.GetVehicleBeforeArcPosition(myArcPositionOnOtherConnection - ((_length + s0))' Constants.lookaheadDistance);    									// In rare cases deadlocks may appear when a very long and a short vehicle are driving parallel to each other (and both want to change line):  									// Then' none of the two finds a vehicle behind on the parallel connection. Hence' none of the two will wait for the other one  									// and both might drive to the end of the line change interval and there block each other.  									// To avoid this case' if there is no otherBehind' we also look for a parallel vehicle in front of our back (there should be one' otherwise  									// something went terribly wrong above). The longer one of the two will wait for the shorter one to make sure' no deadlock will occur.  									if (otherBehind == null)  										{  										VehicleDistance otherFront = lcp.otherStart.nc.GetVehicleBehindArcPosition(myArcPositionOnOtherConnection - ((_length + s0))' Constants.lookaheadDistance);  										if (otherFront.vehicle.lineChangeNeeded && otherFront.vehicle._length > _length)  											{  											otherBehind = otherFront;  											otherBehind.distance *= -1;  											}  										}    									//Pair<VehicleDistance> vd = lcp.otherStart.nc.GetVehiclesAroundArcPosition(myArcPositionOnOtherConnection - ( (_length + s0))' Constants.lookaheadDistance);  									if (otherBehind != null)// && otherBehind.vehicle.p >= p)  										{  										// tell the vehicle behind my back to wait for me  										_state.SetLineChangeVehicleInteraction(this' otherBehind.vehicle' lcp.otherStart.nc' myArcPositionOnOtherConnection - _length);    										// In addition' I need to get behind the vehicle in front of the vehicle which waits for me. Therefore I adapt the desired velocity  										if (_state.vehicleThatLetsMeChangeLine != null)  											{  											VehicleDistance otherBehindForman = _state.vehicleThatLetsMeChangeLine.currentNodeConnection.GetVehicleBehindArcPosition(_state.vehicleThatLetsMeChangeLine.currentPosition' 2 * (length + s0));  											if (otherBehindForman != null)  												{  												//_physics.multiplierTargetVelocity = Math2.Clamp(Math2.Cubic((otherBehindForman.distance - otherBehind.distance - s0) / (_length + 4 * s0))' 0.3' 1);  												double multPerDistance = 1 - Math2.Clamp((otherBehind.distance + _length + s0 - otherBehindForman.distance + otherBehindForman.vehicle._length + s0) / (otherBehindForman.vehicle._length)' 0.2' 0.75);  												double multPerSpeedDiff = Math2.Clamp((otherBehindForman.vehicle._physics.velocity - _physics.velocity) / 2' 0.25' 0.8);  												_physics.multiplierTargetVelocity = Math.Min(multPerDistance' multPerSpeedDiff);  												}  											}  										}  									}    								lowestAcceleration = Math.Min(lowestAcceleration' CalculateAcceleration(physics.velocity' effectiveDesiredVelocity' lci.endArcPos - Constants.breakPointBeforeForcedLineChange - arcPos' physics.velocity));  								}  							}  						}  					}  				else if (_state.vehicleThatLetsMeChangeLine != null)  					{  					_state.UnsetLineChangeVehicleInteraction();  					}    				#endregion    				#region freiwillig    				thinkAboutLineChange &= ((GlobalTime.Instance.currentTime - lastLineChangeCheck.Left > 1) || (currentPosition - lastLineChangeCheck.Right > 50));    				if (thinkAboutLineChange && !currentlyChangingLine)  					{  					lastLineChangeCheck.Left = GlobalTime.Instance.currentTime;  					lastLineChangeCheck.Right = currentPosition;    					// get current LineChangePoint and check' whether it's reachable  					NodeConnection.LineChangePoint lcp = route[0].GetPrevLineChangePoint(arcPos);  					if ((lcp.target.nc != null) && (Math.Abs(arcPos - lcp.start.arcPosition) < Constants.maxDistanceToLineChangePoint * 0.67))  						{  						// check whether there is an alternative route that is not too costly  						Routing alternativeRoute = Routing.CalculateShortestConenction(lcp.target.nc.endNode' targetNodes' _vehicleType);  						if (alternativeRoute.SegmentCount() > 0 && alternativeRoute.costs / wayToGo.costs < Constants.maxRatioForVoluntaryLineChange && !alternativeRoute.Top().lineChangeNeeded)  							{  							double myArcPositionOnOtherConnection = lcp.otherStart.arcPosition + (arcPos - lcp.start.arcPosition);  							if (myArcPositionOnOtherConnection >= 0)  								{  								// Check the relation to my surrounding vehicles on the target NodeConnection  								Pair<VehicleDistance> otherVehicles = lcp.otherStart.nc.GetVehiclesAroundArcPosition(myArcPositionOnOtherConnection' Constants.lookaheadDistance);    								// the new vehicle in front wouldn't be too close  								if (   otherVehicles.Right == null  									|| otherVehicles.Right.distance > otherVehicles.Right.vehicle.length + 2 * lcp.length)  									{  									// the new vehicle behind wouldn't be too close  									if (   otherVehicles.Left == null  										|| otherVehicles.Left.distance > length + otherVehicles.Left.vehicle.CalculateWantedDistance(otherVehicles.Left.vehicle.physics.velocity' otherVehicles.Left.vehicle.physics.velocity - physics.velocity)/2)  										{  										List<NodeConnection> l = new List<NodeConnection>();  										l.Add(lcp.target.nc);  										foreach (Routing.RouteSegment rs in alternativeRoute)  											l.Add(rs.startConnection);    										// calculate my necessary acceleration in case of a line change  										double myAccelerationOnOtherConnection = (otherVehicles.Right != null)  											? CalculateAcceleration(physics.velocity' effectiveDesiredVelocity' otherVehicles.Right.vehicle.currentPosition - myArcPositionOnOtherConnection' physics.velocity - otherVehicles.Right.vehicle.physics.velocity)  											: CalculateAcceleration(physics.velocity' effectiveDesiredVelocity' GetDistanceToNextTrafficLightOnRoute(l' myArcPositionOnOtherConnection' Constants.lookaheadDistance' true)' physics.velocity);    										// calculate the necessary acceleration of the vehicle behind in case of a line change  										double forcedAccelerationOfVehicleBehindMeOnOtherConnection = (otherVehicles.Left != null)  											? CalculateAcceleration(otherVehicles.Left.vehicle.physics.velocity' otherVehicles.Left.vehicle.effectiveDesiredVelocity' otherVehicles.Left.distance' otherVehicles.Left.vehicle.physics.velocity - physics.velocity)  											: 0;    										double currentAccelerationOfVehicleBehindMeOnOtherConnection = (otherVehicles.Left != null) ? otherVehicles.Left.vehicle.physics.acceleration : 0;    										// simplified implementation of MOBIL: http://www.vwi.tu-dresden.de/~treiber/MicroApplet/MOBIL.html  										if (forcedAccelerationOfVehicleBehindMeOnOtherConnection > bSave)  											{  											if (myAccelerationOnOtherConnection - lowestAcceleration > p * (currentAccelerationOfVehicleBehindMeOnOtherConnection - forcedAccelerationOfVehicleBehindMeOnOtherConnection) + lineChangeThreshold)  												{  												// initiate the line change  												InitiateLineChange(lcp' arcPos - lcp.start.arcPosition);  												lowestAcceleration = myAccelerationOnOtherConnection;  												}  											}  										}  									}  								}  							}  						}  					}    				#endregion    				}
Magic Number,CityTrafficSimulator.Vehicle,IVehicle,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\IVehicle.cs,Think,The following statement contains a magic number: if (!onlySimpleCalculations)  				{  				#region Forced line changes    				// our route forces to perform a line change  				if (lineChangeNeeded && !currentlyChangingLine && lci != null)  					{  					thinkAboutLineChange = false;  					lastLineChangeCheck.Left = GlobalTime.Instance.currentTime;  					lastLineChangeCheck.Right = currentPosition;    					// get current LineChangePoint and check' whether it's leading to our target  					NodeConnection.LineChangePoint lcp = route[0].GetPrevLineChangePoint(arcPos);  					if (lci.targetNode.prevConnections.Contains(lcp.target.nc))  						{  						bool slowDownToBreakPoint = false;  						double myArcPositionOnOtherConnection = lcp.otherStart.arcPosition + (arcPos - lcp.start.arcPosition);    						// check if found LineChangePoint is not too far away to perform the line change  						if ((myArcPositionOnOtherConnection >= 0) && (Math.Abs(arcPos - lcp.start.arcPosition) < Constants.maxDistanceToLineChangePoint * 1.25))  							{  							// Check the relation to my surrounding vehicles on the target NodeConnection  							Pair<VehicleDistance> otherVehicles = lcp.otherStart.nc.GetVehiclesAroundArcPosition(myArcPositionOnOtherConnection' Constants.lookaheadDistance);    							// the new vehicle in front wouldn't be too close  							if (   otherVehicles.Right == null  								|| otherVehicles.Right.distance > otherVehicles.Right.vehicle.length + CalculateWantedDistance(physics.velocity' physics.velocity - otherVehicles.Right.vehicle.physics.velocity)/2)  								{  								// the new vehicle behind wouldn't be too close  								if (   otherVehicles.Left == null  									|| otherVehicles.Left.distance > length + otherVehicles.Left.vehicle.CalculateWantedDistance(otherVehicles.Left.vehicle.physics.velocity' otherVehicles.Left.vehicle.physics.velocity - physics.velocity)/2)  									{  									// calculate my necessary acceleration in case of a line change  									double myAccelerationOnOtherConnection = (otherVehicles.Right != null)  										? CalculateAcceleration(physics.velocity' effectiveDesiredVelocity' otherVehicles.Right.vehicle.currentPosition - myArcPositionOnOtherConnection' physics.velocity - otherVehicles.Right.vehicle.physics.velocity)  										: CalculateAcceleration(physics.velocity' effectiveDesiredVelocity' lookaheadDistance' physics.velocity);    									// calculate the necessary acceleration of the vehicle behind in case of a line change  									double forcedAccelerationOfVehicleBehindMeOnOtherConnection = (otherVehicles.Left != null)  										? CalculateAcceleration(otherVehicles.Left.vehicle.physics.velocity' otherVehicles.Left.vehicle.effectiveDesiredVelocity' otherVehicles.Left.distance' otherVehicles.Left.vehicle.physics.velocity - physics.velocity)  										: 0;    									double currentAccelerationOfVehicleBehindMeOnOtherConnection = (otherVehicles.Left != null) ? otherVehicles.Left.vehicle.physics.acceleration : 0;    									// Final check:  									//  - The new vehicle behind must not break harder than bSave  									//  - My line change must be sufficiently necessary. The closer I come to the end of the LineChangeInterval' the more I may thwart the vehicle behind.   									if (   (forcedAccelerationOfVehicleBehindMeOnOtherConnection > bSave)  										&& ((arcPos - lci.startArcPos) / lci.length >= (currentAccelerationOfVehicleBehindMeOnOtherConnection - forcedAccelerationOfVehicleBehindMeOnOtherConnection)))  										{  										// return to normal velocity  										_physics.multiplierTargetVelocity = 1;    										// initiate the line change  										InitiateLineChange(lcp' arcPos - lcp.start.arcPosition);  										lowestAcceleration = myAccelerationOnOtherConnection;  										}  									// I do not want to change line yet' but I could position myself better between the two other vehicles on the parallel line.  									else if (true)  										{  										// TODO: implement  										slowDownToBreakPoint = true;  										}  									}  								// the new vehicle behind would too close but I can accelerate and are at least as fast as him  								else if (   otherVehicles.Left.vehicle.physics.velocity / this.physics.velocity < 1.2  // I am not significantly slower than him  										 && (otherVehicles.Right == null || otherVehicles.Right.distance > 1.5 * length) // the new vehicle in front is far enough away  										 && lookaheadDistance > 2 * length			// no vehicle/traffic light/intersection in front  										 && lci.endArcPos - arcPos > 2 * length		// enough space left in LineChangeInterval  										 && lowestAcceleration >= -0.1)				// currently not braking  									{  									// accelerate to get in front  									_physics.multiplierTargetVelocity = 1.75;  									lowestAcceleration = Math.Min(lowestAcceleration' CalculateAcceleration(physics.velocity' effectiveDesiredVelocity' lookaheadDistance' physics.velocity));    									_state.SetLineChangeVehicleInteraction(this' otherVehicles.Left.vehicle' lcp.otherStart.nc' myArcPositionOnOtherConnection - _length);  									}  								// There is no way to perform a line change now => slow down  								else  									{  									slowDownToBreakPoint = true;  									}  								}  							// The new vehicle in front is too close => slow down  							else  								{  								slowDownToBreakPoint = true;  								}  							}    						if (slowDownToBreakPoint)  							{  							double percentOfLCILeft = Math.Max(0.2' (lci.endArcPos - currentPosition - Constants.breakPointBeforeForcedLineChange) / (lci.length - Constants.breakPointBeforeForcedLineChange));    							// slow down a bit  							_physics.multiplierTargetVelocity = Math.Min(0.9' 1.5 * percentOfLCILeft);    							// When reaching the end of the LineChangeInterval' check whether there are other possibilities to reach the target:  							if (percentOfLCILeft < 0.5)  								{  								Routing newRTT = Routing.CalculateShortestConenction(route[0].endNode' _targetNodes' _vehicleType);  								// The alternative route does not cost too much -> choose it  								if (newRTT.SegmentCount() > 0 && newRTT.costs / _wayToGo.costs < Constants.maxRatioForEnforcedLineChange)  									{  									_wayToGo = newRTT;  									_physics.multiplierTargetVelocity = 1;  									lineChangeNeeded = false;  									lci = null;  									}  								}  							// Line change still necessacy => stop at break point  							if (lineChangeNeeded)  								{  								if (! _state.letVehicleChangeLine && percentOfLCILeft < 0.8)  									{  									VehicleDistance otherBehind = lcp.otherStart.nc.GetVehicleBeforeArcPosition(myArcPositionOnOtherConnection - ((_length + s0))' Constants.lookaheadDistance);    									// In rare cases deadlocks may appear when a very long and a short vehicle are driving parallel to each other (and both want to change line):  									// Then' none of the two finds a vehicle behind on the parallel connection. Hence' none of the two will wait for the other one  									// and both might drive to the end of the line change interval and there block each other.  									// To avoid this case' if there is no otherBehind' we also look for a parallel vehicle in front of our back (there should be one' otherwise  									// something went terribly wrong above). The longer one of the two will wait for the shorter one to make sure' no deadlock will occur.  									if (otherBehind == null)  										{  										VehicleDistance otherFront = lcp.otherStart.nc.GetVehicleBehindArcPosition(myArcPositionOnOtherConnection - ((_length + s0))' Constants.lookaheadDistance);  										if (otherFront.vehicle.lineChangeNeeded && otherFront.vehicle._length > _length)  											{  											otherBehind = otherFront;  											otherBehind.distance *= -1;  											}  										}    									//Pair<VehicleDistance> vd = lcp.otherStart.nc.GetVehiclesAroundArcPosition(myArcPositionOnOtherConnection - ( (_length + s0))' Constants.lookaheadDistance);  									if (otherBehind != null)// && otherBehind.vehicle.p >= p)  										{  										// tell the vehicle behind my back to wait for me  										_state.SetLineChangeVehicleInteraction(this' otherBehind.vehicle' lcp.otherStart.nc' myArcPositionOnOtherConnection - _length);    										// In addition' I need to get behind the vehicle in front of the vehicle which waits for me. Therefore I adapt the desired velocity  										if (_state.vehicleThatLetsMeChangeLine != null)  											{  											VehicleDistance otherBehindForman = _state.vehicleThatLetsMeChangeLine.currentNodeConnection.GetVehicleBehindArcPosition(_state.vehicleThatLetsMeChangeLine.currentPosition' 2 * (length + s0));  											if (otherBehindForman != null)  												{  												//_physics.multiplierTargetVelocity = Math2.Clamp(Math2.Cubic((otherBehindForman.distance - otherBehind.distance - s0) / (_length + 4 * s0))' 0.3' 1);  												double multPerDistance = 1 - Math2.Clamp((otherBehind.distance + _length + s0 - otherBehindForman.distance + otherBehindForman.vehicle._length + s0) / (otherBehindForman.vehicle._length)' 0.2' 0.75);  												double multPerSpeedDiff = Math2.Clamp((otherBehindForman.vehicle._physics.velocity - _physics.velocity) / 2' 0.25' 0.8);  												_physics.multiplierTargetVelocity = Math.Min(multPerDistance' multPerSpeedDiff);  												}  											}  										}  									}    								lowestAcceleration = Math.Min(lowestAcceleration' CalculateAcceleration(physics.velocity' effectiveDesiredVelocity' lci.endArcPos - Constants.breakPointBeforeForcedLineChange - arcPos' physics.velocity));  								}  							}  						}  					}  				else if (_state.vehicleThatLetsMeChangeLine != null)  					{  					_state.UnsetLineChangeVehicleInteraction();  					}    				#endregion    				#region freiwillig    				thinkAboutLineChange &= ((GlobalTime.Instance.currentTime - lastLineChangeCheck.Left > 1) || (currentPosition - lastLineChangeCheck.Right > 50));    				if (thinkAboutLineChange && !currentlyChangingLine)  					{  					lastLineChangeCheck.Left = GlobalTime.Instance.currentTime;  					lastLineChangeCheck.Right = currentPosition;    					// get current LineChangePoint and check' whether it's reachable  					NodeConnection.LineChangePoint lcp = route[0].GetPrevLineChangePoint(arcPos);  					if ((lcp.target.nc != null) && (Math.Abs(arcPos - lcp.start.arcPosition) < Constants.maxDistanceToLineChangePoint * 0.67))  						{  						// check whether there is an alternative route that is not too costly  						Routing alternativeRoute = Routing.CalculateShortestConenction(lcp.target.nc.endNode' targetNodes' _vehicleType);  						if (alternativeRoute.SegmentCount() > 0 && alternativeRoute.costs / wayToGo.costs < Constants.maxRatioForVoluntaryLineChange && !alternativeRoute.Top().lineChangeNeeded)  							{  							double myArcPositionOnOtherConnection = lcp.otherStart.arcPosition + (arcPos - lcp.start.arcPosition);  							if (myArcPositionOnOtherConnection >= 0)  								{  								// Check the relation to my surrounding vehicles on the target NodeConnection  								Pair<VehicleDistance> otherVehicles = lcp.otherStart.nc.GetVehiclesAroundArcPosition(myArcPositionOnOtherConnection' Constants.lookaheadDistance);    								// the new vehicle in front wouldn't be too close  								if (   otherVehicles.Right == null  									|| otherVehicles.Right.distance > otherVehicles.Right.vehicle.length + 2 * lcp.length)  									{  									// the new vehicle behind wouldn't be too close  									if (   otherVehicles.Left == null  										|| otherVehicles.Left.distance > length + otherVehicles.Left.vehicle.CalculateWantedDistance(otherVehicles.Left.vehicle.physics.velocity' otherVehicles.Left.vehicle.physics.velocity - physics.velocity)/2)  										{  										List<NodeConnection> l = new List<NodeConnection>();  										l.Add(lcp.target.nc);  										foreach (Routing.RouteSegment rs in alternativeRoute)  											l.Add(rs.startConnection);    										// calculate my necessary acceleration in case of a line change  										double myAccelerationOnOtherConnection = (otherVehicles.Right != null)  											? CalculateAcceleration(physics.velocity' effectiveDesiredVelocity' otherVehicles.Right.vehicle.currentPosition - myArcPositionOnOtherConnection' physics.velocity - otherVehicles.Right.vehicle.physics.velocity)  											: CalculateAcceleration(physics.velocity' effectiveDesiredVelocity' GetDistanceToNextTrafficLightOnRoute(l' myArcPositionOnOtherConnection' Constants.lookaheadDistance' true)' physics.velocity);    										// calculate the necessary acceleration of the vehicle behind in case of a line change  										double forcedAccelerationOfVehicleBehindMeOnOtherConnection = (otherVehicles.Left != null)  											? CalculateAcceleration(otherVehicles.Left.vehicle.physics.velocity' otherVehicles.Left.vehicle.effectiveDesiredVelocity' otherVehicles.Left.distance' otherVehicles.Left.vehicle.physics.velocity - physics.velocity)  											: 0;    										double currentAccelerationOfVehicleBehindMeOnOtherConnection = (otherVehicles.Left != null) ? otherVehicles.Left.vehicle.physics.acceleration : 0;    										// simplified implementation of MOBIL: http://www.vwi.tu-dresden.de/~treiber/MicroApplet/MOBIL.html  										if (forcedAccelerationOfVehicleBehindMeOnOtherConnection > bSave)  											{  											if (myAccelerationOnOtherConnection - lowestAcceleration > p * (currentAccelerationOfVehicleBehindMeOnOtherConnection - forcedAccelerationOfVehicleBehindMeOnOtherConnection) + lineChangeThreshold)  												{  												// initiate the line change  												InitiateLineChange(lcp' arcPos - lcp.start.arcPosition);  												lowestAcceleration = myAccelerationOnOtherConnection;  												}  											}  										}  									}  								}  							}  						}  					}    				#endregion    				}
Magic Number,CityTrafficSimulator.Vehicle,IVehicle,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\IVehicle.cs,Think,The following statement contains a magic number: if (!onlySimpleCalculations)  				{  				#region Forced line changes    				// our route forces to perform a line change  				if (lineChangeNeeded && !currentlyChangingLine && lci != null)  					{  					thinkAboutLineChange = false;  					lastLineChangeCheck.Left = GlobalTime.Instance.currentTime;  					lastLineChangeCheck.Right = currentPosition;    					// get current LineChangePoint and check' whether it's leading to our target  					NodeConnection.LineChangePoint lcp = route[0].GetPrevLineChangePoint(arcPos);  					if (lci.targetNode.prevConnections.Contains(lcp.target.nc))  						{  						bool slowDownToBreakPoint = false;  						double myArcPositionOnOtherConnection = lcp.otherStart.arcPosition + (arcPos - lcp.start.arcPosition);    						// check if found LineChangePoint is not too far away to perform the line change  						if ((myArcPositionOnOtherConnection >= 0) && (Math.Abs(arcPos - lcp.start.arcPosition) < Constants.maxDistanceToLineChangePoint * 1.25))  							{  							// Check the relation to my surrounding vehicles on the target NodeConnection  							Pair<VehicleDistance> otherVehicles = lcp.otherStart.nc.GetVehiclesAroundArcPosition(myArcPositionOnOtherConnection' Constants.lookaheadDistance);    							// the new vehicle in front wouldn't be too close  							if (   otherVehicles.Right == null  								|| otherVehicles.Right.distance > otherVehicles.Right.vehicle.length + CalculateWantedDistance(physics.velocity' physics.velocity - otherVehicles.Right.vehicle.physics.velocity)/2)  								{  								// the new vehicle behind wouldn't be too close  								if (   otherVehicles.Left == null  									|| otherVehicles.Left.distance > length + otherVehicles.Left.vehicle.CalculateWantedDistance(otherVehicles.Left.vehicle.physics.velocity' otherVehicles.Left.vehicle.physics.velocity - physics.velocity)/2)  									{  									// calculate my necessary acceleration in case of a line change  									double myAccelerationOnOtherConnection = (otherVehicles.Right != null)  										? CalculateAcceleration(physics.velocity' effectiveDesiredVelocity' otherVehicles.Right.vehicle.currentPosition - myArcPositionOnOtherConnection' physics.velocity - otherVehicles.Right.vehicle.physics.velocity)  										: CalculateAcceleration(physics.velocity' effectiveDesiredVelocity' lookaheadDistance' physics.velocity);    									// calculate the necessary acceleration of the vehicle behind in case of a line change  									double forcedAccelerationOfVehicleBehindMeOnOtherConnection = (otherVehicles.Left != null)  										? CalculateAcceleration(otherVehicles.Left.vehicle.physics.velocity' otherVehicles.Left.vehicle.effectiveDesiredVelocity' otherVehicles.Left.distance' otherVehicles.Left.vehicle.physics.velocity - physics.velocity)  										: 0;    									double currentAccelerationOfVehicleBehindMeOnOtherConnection = (otherVehicles.Left != null) ? otherVehicles.Left.vehicle.physics.acceleration : 0;    									// Final check:  									//  - The new vehicle behind must not break harder than bSave  									//  - My line change must be sufficiently necessary. The closer I come to the end of the LineChangeInterval' the more I may thwart the vehicle behind.   									if (   (forcedAccelerationOfVehicleBehindMeOnOtherConnection > bSave)  										&& ((arcPos - lci.startArcPos) / lci.length >= (currentAccelerationOfVehicleBehindMeOnOtherConnection - forcedAccelerationOfVehicleBehindMeOnOtherConnection)))  										{  										// return to normal velocity  										_physics.multiplierTargetVelocity = 1;    										// initiate the line change  										InitiateLineChange(lcp' arcPos - lcp.start.arcPosition);  										lowestAcceleration = myAccelerationOnOtherConnection;  										}  									// I do not want to change line yet' but I could position myself better between the two other vehicles on the parallel line.  									else if (true)  										{  										// TODO: implement  										slowDownToBreakPoint = true;  										}  									}  								// the new vehicle behind would too close but I can accelerate and are at least as fast as him  								else if (   otherVehicles.Left.vehicle.physics.velocity / this.physics.velocity < 1.2  // I am not significantly slower than him  										 && (otherVehicles.Right == null || otherVehicles.Right.distance > 1.5 * length) // the new vehicle in front is far enough away  										 && lookaheadDistance > 2 * length			// no vehicle/traffic light/intersection in front  										 && lci.endArcPos - arcPos > 2 * length		// enough space left in LineChangeInterval  										 && lowestAcceleration >= -0.1)				// currently not braking  									{  									// accelerate to get in front  									_physics.multiplierTargetVelocity = 1.75;  									lowestAcceleration = Math.Min(lowestAcceleration' CalculateAcceleration(physics.velocity' effectiveDesiredVelocity' lookaheadDistance' physics.velocity));    									_state.SetLineChangeVehicleInteraction(this' otherVehicles.Left.vehicle' lcp.otherStart.nc' myArcPositionOnOtherConnection - _length);  									}  								// There is no way to perform a line change now => slow down  								else  									{  									slowDownToBreakPoint = true;  									}  								}  							// The new vehicle in front is too close => slow down  							else  								{  								slowDownToBreakPoint = true;  								}  							}    						if (slowDownToBreakPoint)  							{  							double percentOfLCILeft = Math.Max(0.2' (lci.endArcPos - currentPosition - Constants.breakPointBeforeForcedLineChange) / (lci.length - Constants.breakPointBeforeForcedLineChange));    							// slow down a bit  							_physics.multiplierTargetVelocity = Math.Min(0.9' 1.5 * percentOfLCILeft);    							// When reaching the end of the LineChangeInterval' check whether there are other possibilities to reach the target:  							if (percentOfLCILeft < 0.5)  								{  								Routing newRTT = Routing.CalculateShortestConenction(route[0].endNode' _targetNodes' _vehicleType);  								// The alternative route does not cost too much -> choose it  								if (newRTT.SegmentCount() > 0 && newRTT.costs / _wayToGo.costs < Constants.maxRatioForEnforcedLineChange)  									{  									_wayToGo = newRTT;  									_physics.multiplierTargetVelocity = 1;  									lineChangeNeeded = false;  									lci = null;  									}  								}  							// Line change still necessacy => stop at break point  							if (lineChangeNeeded)  								{  								if (! _state.letVehicleChangeLine && percentOfLCILeft < 0.8)  									{  									VehicleDistance otherBehind = lcp.otherStart.nc.GetVehicleBeforeArcPosition(myArcPositionOnOtherConnection - ((_length + s0))' Constants.lookaheadDistance);    									// In rare cases deadlocks may appear when a very long and a short vehicle are driving parallel to each other (and both want to change line):  									// Then' none of the two finds a vehicle behind on the parallel connection. Hence' none of the two will wait for the other one  									// and both might drive to the end of the line change interval and there block each other.  									// To avoid this case' if there is no otherBehind' we also look for a parallel vehicle in front of our back (there should be one' otherwise  									// something went terribly wrong above). The longer one of the two will wait for the shorter one to make sure' no deadlock will occur.  									if (otherBehind == null)  										{  										VehicleDistance otherFront = lcp.otherStart.nc.GetVehicleBehindArcPosition(myArcPositionOnOtherConnection - ((_length + s0))' Constants.lookaheadDistance);  										if (otherFront.vehicle.lineChangeNeeded && otherFront.vehicle._length > _length)  											{  											otherBehind = otherFront;  											otherBehind.distance *= -1;  											}  										}    									//Pair<VehicleDistance> vd = lcp.otherStart.nc.GetVehiclesAroundArcPosition(myArcPositionOnOtherConnection - ( (_length + s0))' Constants.lookaheadDistance);  									if (otherBehind != null)// && otherBehind.vehicle.p >= p)  										{  										// tell the vehicle behind my back to wait for me  										_state.SetLineChangeVehicleInteraction(this' otherBehind.vehicle' lcp.otherStart.nc' myArcPositionOnOtherConnection - _length);    										// In addition' I need to get behind the vehicle in front of the vehicle which waits for me. Therefore I adapt the desired velocity  										if (_state.vehicleThatLetsMeChangeLine != null)  											{  											VehicleDistance otherBehindForman = _state.vehicleThatLetsMeChangeLine.currentNodeConnection.GetVehicleBehindArcPosition(_state.vehicleThatLetsMeChangeLine.currentPosition' 2 * (length + s0));  											if (otherBehindForman != null)  												{  												//_physics.multiplierTargetVelocity = Math2.Clamp(Math2.Cubic((otherBehindForman.distance - otherBehind.distance - s0) / (_length + 4 * s0))' 0.3' 1);  												double multPerDistance = 1 - Math2.Clamp((otherBehind.distance + _length + s0 - otherBehindForman.distance + otherBehindForman.vehicle._length + s0) / (otherBehindForman.vehicle._length)' 0.2' 0.75);  												double multPerSpeedDiff = Math2.Clamp((otherBehindForman.vehicle._physics.velocity - _physics.velocity) / 2' 0.25' 0.8);  												_physics.multiplierTargetVelocity = Math.Min(multPerDistance' multPerSpeedDiff);  												}  											}  										}  									}    								lowestAcceleration = Math.Min(lowestAcceleration' CalculateAcceleration(physics.velocity' effectiveDesiredVelocity' lci.endArcPos - Constants.breakPointBeforeForcedLineChange - arcPos' physics.velocity));  								}  							}  						}  					}  				else if (_state.vehicleThatLetsMeChangeLine != null)  					{  					_state.UnsetLineChangeVehicleInteraction();  					}    				#endregion    				#region freiwillig    				thinkAboutLineChange &= ((GlobalTime.Instance.currentTime - lastLineChangeCheck.Left > 1) || (currentPosition - lastLineChangeCheck.Right > 50));    				if (thinkAboutLineChange && !currentlyChangingLine)  					{  					lastLineChangeCheck.Left = GlobalTime.Instance.currentTime;  					lastLineChangeCheck.Right = currentPosition;    					// get current LineChangePoint and check' whether it's reachable  					NodeConnection.LineChangePoint lcp = route[0].GetPrevLineChangePoint(arcPos);  					if ((lcp.target.nc != null) && (Math.Abs(arcPos - lcp.start.arcPosition) < Constants.maxDistanceToLineChangePoint * 0.67))  						{  						// check whether there is an alternative route that is not too costly  						Routing alternativeRoute = Routing.CalculateShortestConenction(lcp.target.nc.endNode' targetNodes' _vehicleType);  						if (alternativeRoute.SegmentCount() > 0 && alternativeRoute.costs / wayToGo.costs < Constants.maxRatioForVoluntaryLineChange && !alternativeRoute.Top().lineChangeNeeded)  							{  							double myArcPositionOnOtherConnection = lcp.otherStart.arcPosition + (arcPos - lcp.start.arcPosition);  							if (myArcPositionOnOtherConnection >= 0)  								{  								// Check the relation to my surrounding vehicles on the target NodeConnection  								Pair<VehicleDistance> otherVehicles = lcp.otherStart.nc.GetVehiclesAroundArcPosition(myArcPositionOnOtherConnection' Constants.lookaheadDistance);    								// the new vehicle in front wouldn't be too close  								if (   otherVehicles.Right == null  									|| otherVehicles.Right.distance > otherVehicles.Right.vehicle.length + 2 * lcp.length)  									{  									// the new vehicle behind wouldn't be too close  									if (   otherVehicles.Left == null  										|| otherVehicles.Left.distance > length + otherVehicles.Left.vehicle.CalculateWantedDistance(otherVehicles.Left.vehicle.physics.velocity' otherVehicles.Left.vehicle.physics.velocity - physics.velocity)/2)  										{  										List<NodeConnection> l = new List<NodeConnection>();  										l.Add(lcp.target.nc);  										foreach (Routing.RouteSegment rs in alternativeRoute)  											l.Add(rs.startConnection);    										// calculate my necessary acceleration in case of a line change  										double myAccelerationOnOtherConnection = (otherVehicles.Right != null)  											? CalculateAcceleration(physics.velocity' effectiveDesiredVelocity' otherVehicles.Right.vehicle.currentPosition - myArcPositionOnOtherConnection' physics.velocity - otherVehicles.Right.vehicle.physics.velocity)  											: CalculateAcceleration(physics.velocity' effectiveDesiredVelocity' GetDistanceToNextTrafficLightOnRoute(l' myArcPositionOnOtherConnection' Constants.lookaheadDistance' true)' physics.velocity);    										// calculate the necessary acceleration of the vehicle behind in case of a line change  										double forcedAccelerationOfVehicleBehindMeOnOtherConnection = (otherVehicles.Left != null)  											? CalculateAcceleration(otherVehicles.Left.vehicle.physics.velocity' otherVehicles.Left.vehicle.effectiveDesiredVelocity' otherVehicles.Left.distance' otherVehicles.Left.vehicle.physics.velocity - physics.velocity)  											: 0;    										double currentAccelerationOfVehicleBehindMeOnOtherConnection = (otherVehicles.Left != null) ? otherVehicles.Left.vehicle.physics.acceleration : 0;    										// simplified implementation of MOBIL: http://www.vwi.tu-dresden.de/~treiber/MicroApplet/MOBIL.html  										if (forcedAccelerationOfVehicleBehindMeOnOtherConnection > bSave)  											{  											if (myAccelerationOnOtherConnection - lowestAcceleration > p * (currentAccelerationOfVehicleBehindMeOnOtherConnection - forcedAccelerationOfVehicleBehindMeOnOtherConnection) + lineChangeThreshold)  												{  												// initiate the line change  												InitiateLineChange(lcp' arcPos - lcp.start.arcPosition);  												lowestAcceleration = myAccelerationOnOtherConnection;  												}  											}  										}  									}  								}  							}  						}  					}    				#endregion    				}
Magic Number,CityTrafficSimulator.Vehicle,IVehicle,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\IVehicle.cs,Think,The following statement contains a magic number: if (!onlySimpleCalculations)  				{  				#region Forced line changes    				// our route forces to perform a line change  				if (lineChangeNeeded && !currentlyChangingLine && lci != null)  					{  					thinkAboutLineChange = false;  					lastLineChangeCheck.Left = GlobalTime.Instance.currentTime;  					lastLineChangeCheck.Right = currentPosition;    					// get current LineChangePoint and check' whether it's leading to our target  					NodeConnection.LineChangePoint lcp = route[0].GetPrevLineChangePoint(arcPos);  					if (lci.targetNode.prevConnections.Contains(lcp.target.nc))  						{  						bool slowDownToBreakPoint = false;  						double myArcPositionOnOtherConnection = lcp.otherStart.arcPosition + (arcPos - lcp.start.arcPosition);    						// check if found LineChangePoint is not too far away to perform the line change  						if ((myArcPositionOnOtherConnection >= 0) && (Math.Abs(arcPos - lcp.start.arcPosition) < Constants.maxDistanceToLineChangePoint * 1.25))  							{  							// Check the relation to my surrounding vehicles on the target NodeConnection  							Pair<VehicleDistance> otherVehicles = lcp.otherStart.nc.GetVehiclesAroundArcPosition(myArcPositionOnOtherConnection' Constants.lookaheadDistance);    							// the new vehicle in front wouldn't be too close  							if (   otherVehicles.Right == null  								|| otherVehicles.Right.distance > otherVehicles.Right.vehicle.length + CalculateWantedDistance(physics.velocity' physics.velocity - otherVehicles.Right.vehicle.physics.velocity)/2)  								{  								// the new vehicle behind wouldn't be too close  								if (   otherVehicles.Left == null  									|| otherVehicles.Left.distance > length + otherVehicles.Left.vehicle.CalculateWantedDistance(otherVehicles.Left.vehicle.physics.velocity' otherVehicles.Left.vehicle.physics.velocity - physics.velocity)/2)  									{  									// calculate my necessary acceleration in case of a line change  									double myAccelerationOnOtherConnection = (otherVehicles.Right != null)  										? CalculateAcceleration(physics.velocity' effectiveDesiredVelocity' otherVehicles.Right.vehicle.currentPosition - myArcPositionOnOtherConnection' physics.velocity - otherVehicles.Right.vehicle.physics.velocity)  										: CalculateAcceleration(physics.velocity' effectiveDesiredVelocity' lookaheadDistance' physics.velocity);    									// calculate the necessary acceleration of the vehicle behind in case of a line change  									double forcedAccelerationOfVehicleBehindMeOnOtherConnection = (otherVehicles.Left != null)  										? CalculateAcceleration(otherVehicles.Left.vehicle.physics.velocity' otherVehicles.Left.vehicle.effectiveDesiredVelocity' otherVehicles.Left.distance' otherVehicles.Left.vehicle.physics.velocity - physics.velocity)  										: 0;    									double currentAccelerationOfVehicleBehindMeOnOtherConnection = (otherVehicles.Left != null) ? otherVehicles.Left.vehicle.physics.acceleration : 0;    									// Final check:  									//  - The new vehicle behind must not break harder than bSave  									//  - My line change must be sufficiently necessary. The closer I come to the end of the LineChangeInterval' the more I may thwart the vehicle behind.   									if (   (forcedAccelerationOfVehicleBehindMeOnOtherConnection > bSave)  										&& ((arcPos - lci.startArcPos) / lci.length >= (currentAccelerationOfVehicleBehindMeOnOtherConnection - forcedAccelerationOfVehicleBehindMeOnOtherConnection)))  										{  										// return to normal velocity  										_physics.multiplierTargetVelocity = 1;    										// initiate the line change  										InitiateLineChange(lcp' arcPos - lcp.start.arcPosition);  										lowestAcceleration = myAccelerationOnOtherConnection;  										}  									// I do not want to change line yet' but I could position myself better between the two other vehicles on the parallel line.  									else if (true)  										{  										// TODO: implement  										slowDownToBreakPoint = true;  										}  									}  								// the new vehicle behind would too close but I can accelerate and are at least as fast as him  								else if (   otherVehicles.Left.vehicle.physics.velocity / this.physics.velocity < 1.2  // I am not significantly slower than him  										 && (otherVehicles.Right == null || otherVehicles.Right.distance > 1.5 * length) // the new vehicle in front is far enough away  										 && lookaheadDistance > 2 * length			// no vehicle/traffic light/intersection in front  										 && lci.endArcPos - arcPos > 2 * length		// enough space left in LineChangeInterval  										 && lowestAcceleration >= -0.1)				// currently not braking  									{  									// accelerate to get in front  									_physics.multiplierTargetVelocity = 1.75;  									lowestAcceleration = Math.Min(lowestAcceleration' CalculateAcceleration(physics.velocity' effectiveDesiredVelocity' lookaheadDistance' physics.velocity));    									_state.SetLineChangeVehicleInteraction(this' otherVehicles.Left.vehicle' lcp.otherStart.nc' myArcPositionOnOtherConnection - _length);  									}  								// There is no way to perform a line change now => slow down  								else  									{  									slowDownToBreakPoint = true;  									}  								}  							// The new vehicle in front is too close => slow down  							else  								{  								slowDownToBreakPoint = true;  								}  							}    						if (slowDownToBreakPoint)  							{  							double percentOfLCILeft = Math.Max(0.2' (lci.endArcPos - currentPosition - Constants.breakPointBeforeForcedLineChange) / (lci.length - Constants.breakPointBeforeForcedLineChange));    							// slow down a bit  							_physics.multiplierTargetVelocity = Math.Min(0.9' 1.5 * percentOfLCILeft);    							// When reaching the end of the LineChangeInterval' check whether there are other possibilities to reach the target:  							if (percentOfLCILeft < 0.5)  								{  								Routing newRTT = Routing.CalculateShortestConenction(route[0].endNode' _targetNodes' _vehicleType);  								// The alternative route does not cost too much -> choose it  								if (newRTT.SegmentCount() > 0 && newRTT.costs / _wayToGo.costs < Constants.maxRatioForEnforcedLineChange)  									{  									_wayToGo = newRTT;  									_physics.multiplierTargetVelocity = 1;  									lineChangeNeeded = false;  									lci = null;  									}  								}  							// Line change still necessacy => stop at break point  							if (lineChangeNeeded)  								{  								if (! _state.letVehicleChangeLine && percentOfLCILeft < 0.8)  									{  									VehicleDistance otherBehind = lcp.otherStart.nc.GetVehicleBeforeArcPosition(myArcPositionOnOtherConnection - ((_length + s0))' Constants.lookaheadDistance);    									// In rare cases deadlocks may appear when a very long and a short vehicle are driving parallel to each other (and both want to change line):  									// Then' none of the two finds a vehicle behind on the parallel connection. Hence' none of the two will wait for the other one  									// and both might drive to the end of the line change interval and there block each other.  									// To avoid this case' if there is no otherBehind' we also look for a parallel vehicle in front of our back (there should be one' otherwise  									// something went terribly wrong above). The longer one of the two will wait for the shorter one to make sure' no deadlock will occur.  									if (otherBehind == null)  										{  										VehicleDistance otherFront = lcp.otherStart.nc.GetVehicleBehindArcPosition(myArcPositionOnOtherConnection - ((_length + s0))' Constants.lookaheadDistance);  										if (otherFront.vehicle.lineChangeNeeded && otherFront.vehicle._length > _length)  											{  											otherBehind = otherFront;  											otherBehind.distance *= -1;  											}  										}    									//Pair<VehicleDistance> vd = lcp.otherStart.nc.GetVehiclesAroundArcPosition(myArcPositionOnOtherConnection - ( (_length + s0))' Constants.lookaheadDistance);  									if (otherBehind != null)// && otherBehind.vehicle.p >= p)  										{  										// tell the vehicle behind my back to wait for me  										_state.SetLineChangeVehicleInteraction(this' otherBehind.vehicle' lcp.otherStart.nc' myArcPositionOnOtherConnection - _length);    										// In addition' I need to get behind the vehicle in front of the vehicle which waits for me. Therefore I adapt the desired velocity  										if (_state.vehicleThatLetsMeChangeLine != null)  											{  											VehicleDistance otherBehindForman = _state.vehicleThatLetsMeChangeLine.currentNodeConnection.GetVehicleBehindArcPosition(_state.vehicleThatLetsMeChangeLine.currentPosition' 2 * (length + s0));  											if (otherBehindForman != null)  												{  												//_physics.multiplierTargetVelocity = Math2.Clamp(Math2.Cubic((otherBehindForman.distance - otherBehind.distance - s0) / (_length + 4 * s0))' 0.3' 1);  												double multPerDistance = 1 - Math2.Clamp((otherBehind.distance + _length + s0 - otherBehindForman.distance + otherBehindForman.vehicle._length + s0) / (otherBehindForman.vehicle._length)' 0.2' 0.75);  												double multPerSpeedDiff = Math2.Clamp((otherBehindForman.vehicle._physics.velocity - _physics.velocity) / 2' 0.25' 0.8);  												_physics.multiplierTargetVelocity = Math.Min(multPerDistance' multPerSpeedDiff);  												}  											}  										}  									}    								lowestAcceleration = Math.Min(lowestAcceleration' CalculateAcceleration(physics.velocity' effectiveDesiredVelocity' lci.endArcPos - Constants.breakPointBeforeForcedLineChange - arcPos' physics.velocity));  								}  							}  						}  					}  				else if (_state.vehicleThatLetsMeChangeLine != null)  					{  					_state.UnsetLineChangeVehicleInteraction();  					}    				#endregion    				#region freiwillig    				thinkAboutLineChange &= ((GlobalTime.Instance.currentTime - lastLineChangeCheck.Left > 1) || (currentPosition - lastLineChangeCheck.Right > 50));    				if (thinkAboutLineChange && !currentlyChangingLine)  					{  					lastLineChangeCheck.Left = GlobalTime.Instance.currentTime;  					lastLineChangeCheck.Right = currentPosition;    					// get current LineChangePoint and check' whether it's reachable  					NodeConnection.LineChangePoint lcp = route[0].GetPrevLineChangePoint(arcPos);  					if ((lcp.target.nc != null) && (Math.Abs(arcPos - lcp.start.arcPosition) < Constants.maxDistanceToLineChangePoint * 0.67))  						{  						// check whether there is an alternative route that is not too costly  						Routing alternativeRoute = Routing.CalculateShortestConenction(lcp.target.nc.endNode' targetNodes' _vehicleType);  						if (alternativeRoute.SegmentCount() > 0 && alternativeRoute.costs / wayToGo.costs < Constants.maxRatioForVoluntaryLineChange && !alternativeRoute.Top().lineChangeNeeded)  							{  							double myArcPositionOnOtherConnection = lcp.otherStart.arcPosition + (arcPos - lcp.start.arcPosition);  							if (myArcPositionOnOtherConnection >= 0)  								{  								// Check the relation to my surrounding vehicles on the target NodeConnection  								Pair<VehicleDistance> otherVehicles = lcp.otherStart.nc.GetVehiclesAroundArcPosition(myArcPositionOnOtherConnection' Constants.lookaheadDistance);    								// the new vehicle in front wouldn't be too close  								if (   otherVehicles.Right == null  									|| otherVehicles.Right.distance > otherVehicles.Right.vehicle.length + 2 * lcp.length)  									{  									// the new vehicle behind wouldn't be too close  									if (   otherVehicles.Left == null  										|| otherVehicles.Left.distance > length + otherVehicles.Left.vehicle.CalculateWantedDistance(otherVehicles.Left.vehicle.physics.velocity' otherVehicles.Left.vehicle.physics.velocity - physics.velocity)/2)  										{  										List<NodeConnection> l = new List<NodeConnection>();  										l.Add(lcp.target.nc);  										foreach (Routing.RouteSegment rs in alternativeRoute)  											l.Add(rs.startConnection);    										// calculate my necessary acceleration in case of a line change  										double myAccelerationOnOtherConnection = (otherVehicles.Right != null)  											? CalculateAcceleration(physics.velocity' effectiveDesiredVelocity' otherVehicles.Right.vehicle.currentPosition - myArcPositionOnOtherConnection' physics.velocity - otherVehicles.Right.vehicle.physics.velocity)  											: CalculateAcceleration(physics.velocity' effectiveDesiredVelocity' GetDistanceToNextTrafficLightOnRoute(l' myArcPositionOnOtherConnection' Constants.lookaheadDistance' true)' physics.velocity);    										// calculate the necessary acceleration of the vehicle behind in case of a line change  										double forcedAccelerationOfVehicleBehindMeOnOtherConnection = (otherVehicles.Left != null)  											? CalculateAcceleration(otherVehicles.Left.vehicle.physics.velocity' otherVehicles.Left.vehicle.effectiveDesiredVelocity' otherVehicles.Left.distance' otherVehicles.Left.vehicle.physics.velocity - physics.velocity)  											: 0;    										double currentAccelerationOfVehicleBehindMeOnOtherConnection = (otherVehicles.Left != null) ? otherVehicles.Left.vehicle.physics.acceleration : 0;    										// simplified implementation of MOBIL: http://www.vwi.tu-dresden.de/~treiber/MicroApplet/MOBIL.html  										if (forcedAccelerationOfVehicleBehindMeOnOtherConnection > bSave)  											{  											if (myAccelerationOnOtherConnection - lowestAcceleration > p * (currentAccelerationOfVehicleBehindMeOnOtherConnection - forcedAccelerationOfVehicleBehindMeOnOtherConnection) + lineChangeThreshold)  												{  												// initiate the line change  												InitiateLineChange(lcp' arcPos - lcp.start.arcPosition);  												lowestAcceleration = myAccelerationOnOtherConnection;  												}  											}  										}  									}  								}  							}  						}  					}    				#endregion    				}
Magic Number,CityTrafficSimulator.Vehicle,IVehicle,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\IVehicle.cs,Think,The following statement contains a magic number: if (!onlySimpleCalculations)  				{  				#region Forced line changes    				// our route forces to perform a line change  				if (lineChangeNeeded && !currentlyChangingLine && lci != null)  					{  					thinkAboutLineChange = false;  					lastLineChangeCheck.Left = GlobalTime.Instance.currentTime;  					lastLineChangeCheck.Right = currentPosition;    					// get current LineChangePoint and check' whether it's leading to our target  					NodeConnection.LineChangePoint lcp = route[0].GetPrevLineChangePoint(arcPos);  					if (lci.targetNode.prevConnections.Contains(lcp.target.nc))  						{  						bool slowDownToBreakPoint = false;  						double myArcPositionOnOtherConnection = lcp.otherStart.arcPosition + (arcPos - lcp.start.arcPosition);    						// check if found LineChangePoint is not too far away to perform the line change  						if ((myArcPositionOnOtherConnection >= 0) && (Math.Abs(arcPos - lcp.start.arcPosition) < Constants.maxDistanceToLineChangePoint * 1.25))  							{  							// Check the relation to my surrounding vehicles on the target NodeConnection  							Pair<VehicleDistance> otherVehicles = lcp.otherStart.nc.GetVehiclesAroundArcPosition(myArcPositionOnOtherConnection' Constants.lookaheadDistance);    							// the new vehicle in front wouldn't be too close  							if (   otherVehicles.Right == null  								|| otherVehicles.Right.distance > otherVehicles.Right.vehicle.length + CalculateWantedDistance(physics.velocity' physics.velocity - otherVehicles.Right.vehicle.physics.velocity)/2)  								{  								// the new vehicle behind wouldn't be too close  								if (   otherVehicles.Left == null  									|| otherVehicles.Left.distance > length + otherVehicles.Left.vehicle.CalculateWantedDistance(otherVehicles.Left.vehicle.physics.velocity' otherVehicles.Left.vehicle.physics.velocity - physics.velocity)/2)  									{  									// calculate my necessary acceleration in case of a line change  									double myAccelerationOnOtherConnection = (otherVehicles.Right != null)  										? CalculateAcceleration(physics.velocity' effectiveDesiredVelocity' otherVehicles.Right.vehicle.currentPosition - myArcPositionOnOtherConnection' physics.velocity - otherVehicles.Right.vehicle.physics.velocity)  										: CalculateAcceleration(physics.velocity' effectiveDesiredVelocity' lookaheadDistance' physics.velocity);    									// calculate the necessary acceleration of the vehicle behind in case of a line change  									double forcedAccelerationOfVehicleBehindMeOnOtherConnection = (otherVehicles.Left != null)  										? CalculateAcceleration(otherVehicles.Left.vehicle.physics.velocity' otherVehicles.Left.vehicle.effectiveDesiredVelocity' otherVehicles.Left.distance' otherVehicles.Left.vehicle.physics.velocity - physics.velocity)  										: 0;    									double currentAccelerationOfVehicleBehindMeOnOtherConnection = (otherVehicles.Left != null) ? otherVehicles.Left.vehicle.physics.acceleration : 0;    									// Final check:  									//  - The new vehicle behind must not break harder than bSave  									//  - My line change must be sufficiently necessary. The closer I come to the end of the LineChangeInterval' the more I may thwart the vehicle behind.   									if (   (forcedAccelerationOfVehicleBehindMeOnOtherConnection > bSave)  										&& ((arcPos - lci.startArcPos) / lci.length >= (currentAccelerationOfVehicleBehindMeOnOtherConnection - forcedAccelerationOfVehicleBehindMeOnOtherConnection)))  										{  										// return to normal velocity  										_physics.multiplierTargetVelocity = 1;    										// initiate the line change  										InitiateLineChange(lcp' arcPos - lcp.start.arcPosition);  										lowestAcceleration = myAccelerationOnOtherConnection;  										}  									// I do not want to change line yet' but I could position myself better between the two other vehicles on the parallel line.  									else if (true)  										{  										// TODO: implement  										slowDownToBreakPoint = true;  										}  									}  								// the new vehicle behind would too close but I can accelerate and are at least as fast as him  								else if (   otherVehicles.Left.vehicle.physics.velocity / this.physics.velocity < 1.2  // I am not significantly slower than him  										 && (otherVehicles.Right == null || otherVehicles.Right.distance > 1.5 * length) // the new vehicle in front is far enough away  										 && lookaheadDistance > 2 * length			// no vehicle/traffic light/intersection in front  										 && lci.endArcPos - arcPos > 2 * length		// enough space left in LineChangeInterval  										 && lowestAcceleration >= -0.1)				// currently not braking  									{  									// accelerate to get in front  									_physics.multiplierTargetVelocity = 1.75;  									lowestAcceleration = Math.Min(lowestAcceleration' CalculateAcceleration(physics.velocity' effectiveDesiredVelocity' lookaheadDistance' physics.velocity));    									_state.SetLineChangeVehicleInteraction(this' otherVehicles.Left.vehicle' lcp.otherStart.nc' myArcPositionOnOtherConnection - _length);  									}  								// There is no way to perform a line change now => slow down  								else  									{  									slowDownToBreakPoint = true;  									}  								}  							// The new vehicle in front is too close => slow down  							else  								{  								slowDownToBreakPoint = true;  								}  							}    						if (slowDownToBreakPoint)  							{  							double percentOfLCILeft = Math.Max(0.2' (lci.endArcPos - currentPosition - Constants.breakPointBeforeForcedLineChange) / (lci.length - Constants.breakPointBeforeForcedLineChange));    							// slow down a bit  							_physics.multiplierTargetVelocity = Math.Min(0.9' 1.5 * percentOfLCILeft);    							// When reaching the end of the LineChangeInterval' check whether there are other possibilities to reach the target:  							if (percentOfLCILeft < 0.5)  								{  								Routing newRTT = Routing.CalculateShortestConenction(route[0].endNode' _targetNodes' _vehicleType);  								// The alternative route does not cost too much -> choose it  								if (newRTT.SegmentCount() > 0 && newRTT.costs / _wayToGo.costs < Constants.maxRatioForEnforcedLineChange)  									{  									_wayToGo = newRTT;  									_physics.multiplierTargetVelocity = 1;  									lineChangeNeeded = false;  									lci = null;  									}  								}  							// Line change still necessacy => stop at break point  							if (lineChangeNeeded)  								{  								if (! _state.letVehicleChangeLine && percentOfLCILeft < 0.8)  									{  									VehicleDistance otherBehind = lcp.otherStart.nc.GetVehicleBeforeArcPosition(myArcPositionOnOtherConnection - ((_length + s0))' Constants.lookaheadDistance);    									// In rare cases deadlocks may appear when a very long and a short vehicle are driving parallel to each other (and both want to change line):  									// Then' none of the two finds a vehicle behind on the parallel connection. Hence' none of the two will wait for the other one  									// and both might drive to the end of the line change interval and there block each other.  									// To avoid this case' if there is no otherBehind' we also look for a parallel vehicle in front of our back (there should be one' otherwise  									// something went terribly wrong above). The longer one of the two will wait for the shorter one to make sure' no deadlock will occur.  									if (otherBehind == null)  										{  										VehicleDistance otherFront = lcp.otherStart.nc.GetVehicleBehindArcPosition(myArcPositionOnOtherConnection - ((_length + s0))' Constants.lookaheadDistance);  										if (otherFront.vehicle.lineChangeNeeded && otherFront.vehicle._length > _length)  											{  											otherBehind = otherFront;  											otherBehind.distance *= -1;  											}  										}    									//Pair<VehicleDistance> vd = lcp.otherStart.nc.GetVehiclesAroundArcPosition(myArcPositionOnOtherConnection - ( (_length + s0))' Constants.lookaheadDistance);  									if (otherBehind != null)// && otherBehind.vehicle.p >= p)  										{  										// tell the vehicle behind my back to wait for me  										_state.SetLineChangeVehicleInteraction(this' otherBehind.vehicle' lcp.otherStart.nc' myArcPositionOnOtherConnection - _length);    										// In addition' I need to get behind the vehicle in front of the vehicle which waits for me. Therefore I adapt the desired velocity  										if (_state.vehicleThatLetsMeChangeLine != null)  											{  											VehicleDistance otherBehindForman = _state.vehicleThatLetsMeChangeLine.currentNodeConnection.GetVehicleBehindArcPosition(_state.vehicleThatLetsMeChangeLine.currentPosition' 2 * (length + s0));  											if (otherBehindForman != null)  												{  												//_physics.multiplierTargetVelocity = Math2.Clamp(Math2.Cubic((otherBehindForman.distance - otherBehind.distance - s0) / (_length + 4 * s0))' 0.3' 1);  												double multPerDistance = 1 - Math2.Clamp((otherBehind.distance + _length + s0 - otherBehindForman.distance + otherBehindForman.vehicle._length + s0) / (otherBehindForman.vehicle._length)' 0.2' 0.75);  												double multPerSpeedDiff = Math2.Clamp((otherBehindForman.vehicle._physics.velocity - _physics.velocity) / 2' 0.25' 0.8);  												_physics.multiplierTargetVelocity = Math.Min(multPerDistance' multPerSpeedDiff);  												}  											}  										}  									}    								lowestAcceleration = Math.Min(lowestAcceleration' CalculateAcceleration(physics.velocity' effectiveDesiredVelocity' lci.endArcPos - Constants.breakPointBeforeForcedLineChange - arcPos' physics.velocity));  								}  							}  						}  					}  				else if (_state.vehicleThatLetsMeChangeLine != null)  					{  					_state.UnsetLineChangeVehicleInteraction();  					}    				#endregion    				#region freiwillig    				thinkAboutLineChange &= ((GlobalTime.Instance.currentTime - lastLineChangeCheck.Left > 1) || (currentPosition - lastLineChangeCheck.Right > 50));    				if (thinkAboutLineChange && !currentlyChangingLine)  					{  					lastLineChangeCheck.Left = GlobalTime.Instance.currentTime;  					lastLineChangeCheck.Right = currentPosition;    					// get current LineChangePoint and check' whether it's reachable  					NodeConnection.LineChangePoint lcp = route[0].GetPrevLineChangePoint(arcPos);  					if ((lcp.target.nc != null) && (Math.Abs(arcPos - lcp.start.arcPosition) < Constants.maxDistanceToLineChangePoint * 0.67))  						{  						// check whether there is an alternative route that is not too costly  						Routing alternativeRoute = Routing.CalculateShortestConenction(lcp.target.nc.endNode' targetNodes' _vehicleType);  						if (alternativeRoute.SegmentCount() > 0 && alternativeRoute.costs / wayToGo.costs < Constants.maxRatioForVoluntaryLineChange && !alternativeRoute.Top().lineChangeNeeded)  							{  							double myArcPositionOnOtherConnection = lcp.otherStart.arcPosition + (arcPos - lcp.start.arcPosition);  							if (myArcPositionOnOtherConnection >= 0)  								{  								// Check the relation to my surrounding vehicles on the target NodeConnection  								Pair<VehicleDistance> otherVehicles = lcp.otherStart.nc.GetVehiclesAroundArcPosition(myArcPositionOnOtherConnection' Constants.lookaheadDistance);    								// the new vehicle in front wouldn't be too close  								if (   otherVehicles.Right == null  									|| otherVehicles.Right.distance > otherVehicles.Right.vehicle.length + 2 * lcp.length)  									{  									// the new vehicle behind wouldn't be too close  									if (   otherVehicles.Left == null  										|| otherVehicles.Left.distance > length + otherVehicles.Left.vehicle.CalculateWantedDistance(otherVehicles.Left.vehicle.physics.velocity' otherVehicles.Left.vehicle.physics.velocity - physics.velocity)/2)  										{  										List<NodeConnection> l = new List<NodeConnection>();  										l.Add(lcp.target.nc);  										foreach (Routing.RouteSegment rs in alternativeRoute)  											l.Add(rs.startConnection);    										// calculate my necessary acceleration in case of a line change  										double myAccelerationOnOtherConnection = (otherVehicles.Right != null)  											? CalculateAcceleration(physics.velocity' effectiveDesiredVelocity' otherVehicles.Right.vehicle.currentPosition - myArcPositionOnOtherConnection' physics.velocity - otherVehicles.Right.vehicle.physics.velocity)  											: CalculateAcceleration(physics.velocity' effectiveDesiredVelocity' GetDistanceToNextTrafficLightOnRoute(l' myArcPositionOnOtherConnection' Constants.lookaheadDistance' true)' physics.velocity);    										// calculate the necessary acceleration of the vehicle behind in case of a line change  										double forcedAccelerationOfVehicleBehindMeOnOtherConnection = (otherVehicles.Left != null)  											? CalculateAcceleration(otherVehicles.Left.vehicle.physics.velocity' otherVehicles.Left.vehicle.effectiveDesiredVelocity' otherVehicles.Left.distance' otherVehicles.Left.vehicle.physics.velocity - physics.velocity)  											: 0;    										double currentAccelerationOfVehicleBehindMeOnOtherConnection = (otherVehicles.Left != null) ? otherVehicles.Left.vehicle.physics.acceleration : 0;    										// simplified implementation of MOBIL: http://www.vwi.tu-dresden.de/~treiber/MicroApplet/MOBIL.html  										if (forcedAccelerationOfVehicleBehindMeOnOtherConnection > bSave)  											{  											if (myAccelerationOnOtherConnection - lowestAcceleration > p * (currentAccelerationOfVehicleBehindMeOnOtherConnection - forcedAccelerationOfVehicleBehindMeOnOtherConnection) + lineChangeThreshold)  												{  												// initiate the line change  												InitiateLineChange(lcp' arcPos - lcp.start.arcPosition);  												lowestAcceleration = myAccelerationOnOtherConnection;  												}  											}  										}  									}  								}  							}  						}  					}    				#endregion    				}
Magic Number,CityTrafficSimulator.Vehicle,IVehicle,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\IVehicle.cs,Think,The following statement contains a magic number: if (!onlySimpleCalculations)  				{  				#region Forced line changes    				// our route forces to perform a line change  				if (lineChangeNeeded && !currentlyChangingLine && lci != null)  					{  					thinkAboutLineChange = false;  					lastLineChangeCheck.Left = GlobalTime.Instance.currentTime;  					lastLineChangeCheck.Right = currentPosition;    					// get current LineChangePoint and check' whether it's leading to our target  					NodeConnection.LineChangePoint lcp = route[0].GetPrevLineChangePoint(arcPos);  					if (lci.targetNode.prevConnections.Contains(lcp.target.nc))  						{  						bool slowDownToBreakPoint = false;  						double myArcPositionOnOtherConnection = lcp.otherStart.arcPosition + (arcPos - lcp.start.arcPosition);    						// check if found LineChangePoint is not too far away to perform the line change  						if ((myArcPositionOnOtherConnection >= 0) && (Math.Abs(arcPos - lcp.start.arcPosition) < Constants.maxDistanceToLineChangePoint * 1.25))  							{  							// Check the relation to my surrounding vehicles on the target NodeConnection  							Pair<VehicleDistance> otherVehicles = lcp.otherStart.nc.GetVehiclesAroundArcPosition(myArcPositionOnOtherConnection' Constants.lookaheadDistance);    							// the new vehicle in front wouldn't be too close  							if (   otherVehicles.Right == null  								|| otherVehicles.Right.distance > otherVehicles.Right.vehicle.length + CalculateWantedDistance(physics.velocity' physics.velocity - otherVehicles.Right.vehicle.physics.velocity)/2)  								{  								// the new vehicle behind wouldn't be too close  								if (   otherVehicles.Left == null  									|| otherVehicles.Left.distance > length + otherVehicles.Left.vehicle.CalculateWantedDistance(otherVehicles.Left.vehicle.physics.velocity' otherVehicles.Left.vehicle.physics.velocity - physics.velocity)/2)  									{  									// calculate my necessary acceleration in case of a line change  									double myAccelerationOnOtherConnection = (otherVehicles.Right != null)  										? CalculateAcceleration(physics.velocity' effectiveDesiredVelocity' otherVehicles.Right.vehicle.currentPosition - myArcPositionOnOtherConnection' physics.velocity - otherVehicles.Right.vehicle.physics.velocity)  										: CalculateAcceleration(physics.velocity' effectiveDesiredVelocity' lookaheadDistance' physics.velocity);    									// calculate the necessary acceleration of the vehicle behind in case of a line change  									double forcedAccelerationOfVehicleBehindMeOnOtherConnection = (otherVehicles.Left != null)  										? CalculateAcceleration(otherVehicles.Left.vehicle.physics.velocity' otherVehicles.Left.vehicle.effectiveDesiredVelocity' otherVehicles.Left.distance' otherVehicles.Left.vehicle.physics.velocity - physics.velocity)  										: 0;    									double currentAccelerationOfVehicleBehindMeOnOtherConnection = (otherVehicles.Left != null) ? otherVehicles.Left.vehicle.physics.acceleration : 0;    									// Final check:  									//  - The new vehicle behind must not break harder than bSave  									//  - My line change must be sufficiently necessary. The closer I come to the end of the LineChangeInterval' the more I may thwart the vehicle behind.   									if (   (forcedAccelerationOfVehicleBehindMeOnOtherConnection > bSave)  										&& ((arcPos - lci.startArcPos) / lci.length >= (currentAccelerationOfVehicleBehindMeOnOtherConnection - forcedAccelerationOfVehicleBehindMeOnOtherConnection)))  										{  										// return to normal velocity  										_physics.multiplierTargetVelocity = 1;    										// initiate the line change  										InitiateLineChange(lcp' arcPos - lcp.start.arcPosition);  										lowestAcceleration = myAccelerationOnOtherConnection;  										}  									// I do not want to change line yet' but I could position myself better between the two other vehicles on the parallel line.  									else if (true)  										{  										// TODO: implement  										slowDownToBreakPoint = true;  										}  									}  								// the new vehicle behind would too close but I can accelerate and are at least as fast as him  								else if (   otherVehicles.Left.vehicle.physics.velocity / this.physics.velocity < 1.2  // I am not significantly slower than him  										 && (otherVehicles.Right == null || otherVehicles.Right.distance > 1.5 * length) // the new vehicle in front is far enough away  										 && lookaheadDistance > 2 * length			// no vehicle/traffic light/intersection in front  										 && lci.endArcPos - arcPos > 2 * length		// enough space left in LineChangeInterval  										 && lowestAcceleration >= -0.1)				// currently not braking  									{  									// accelerate to get in front  									_physics.multiplierTargetVelocity = 1.75;  									lowestAcceleration = Math.Min(lowestAcceleration' CalculateAcceleration(physics.velocity' effectiveDesiredVelocity' lookaheadDistance' physics.velocity));    									_state.SetLineChangeVehicleInteraction(this' otherVehicles.Left.vehicle' lcp.otherStart.nc' myArcPositionOnOtherConnection - _length);  									}  								// There is no way to perform a line change now => slow down  								else  									{  									slowDownToBreakPoint = true;  									}  								}  							// The new vehicle in front is too close => slow down  							else  								{  								slowDownToBreakPoint = true;  								}  							}    						if (slowDownToBreakPoint)  							{  							double percentOfLCILeft = Math.Max(0.2' (lci.endArcPos - currentPosition - Constants.breakPointBeforeForcedLineChange) / (lci.length - Constants.breakPointBeforeForcedLineChange));    							// slow down a bit  							_physics.multiplierTargetVelocity = Math.Min(0.9' 1.5 * percentOfLCILeft);    							// When reaching the end of the LineChangeInterval' check whether there are other possibilities to reach the target:  							if (percentOfLCILeft < 0.5)  								{  								Routing newRTT = Routing.CalculateShortestConenction(route[0].endNode' _targetNodes' _vehicleType);  								// The alternative route does not cost too much -> choose it  								if (newRTT.SegmentCount() > 0 && newRTT.costs / _wayToGo.costs < Constants.maxRatioForEnforcedLineChange)  									{  									_wayToGo = newRTT;  									_physics.multiplierTargetVelocity = 1;  									lineChangeNeeded = false;  									lci = null;  									}  								}  							// Line change still necessacy => stop at break point  							if (lineChangeNeeded)  								{  								if (! _state.letVehicleChangeLine && percentOfLCILeft < 0.8)  									{  									VehicleDistance otherBehind = lcp.otherStart.nc.GetVehicleBeforeArcPosition(myArcPositionOnOtherConnection - ((_length + s0))' Constants.lookaheadDistance);    									// In rare cases deadlocks may appear when a very long and a short vehicle are driving parallel to each other (and both want to change line):  									// Then' none of the two finds a vehicle behind on the parallel connection. Hence' none of the two will wait for the other one  									// and both might drive to the end of the line change interval and there block each other.  									// To avoid this case' if there is no otherBehind' we also look for a parallel vehicle in front of our back (there should be one' otherwise  									// something went terribly wrong above). The longer one of the two will wait for the shorter one to make sure' no deadlock will occur.  									if (otherBehind == null)  										{  										VehicleDistance otherFront = lcp.otherStart.nc.GetVehicleBehindArcPosition(myArcPositionOnOtherConnection - ((_length + s0))' Constants.lookaheadDistance);  										if (otherFront.vehicle.lineChangeNeeded && otherFront.vehicle._length > _length)  											{  											otherBehind = otherFront;  											otherBehind.distance *= -1;  											}  										}    									//Pair<VehicleDistance> vd = lcp.otherStart.nc.GetVehiclesAroundArcPosition(myArcPositionOnOtherConnection - ( (_length + s0))' Constants.lookaheadDistance);  									if (otherBehind != null)// && otherBehind.vehicle.p >= p)  										{  										// tell the vehicle behind my back to wait for me  										_state.SetLineChangeVehicleInteraction(this' otherBehind.vehicle' lcp.otherStart.nc' myArcPositionOnOtherConnection - _length);    										// In addition' I need to get behind the vehicle in front of the vehicle which waits for me. Therefore I adapt the desired velocity  										if (_state.vehicleThatLetsMeChangeLine != null)  											{  											VehicleDistance otherBehindForman = _state.vehicleThatLetsMeChangeLine.currentNodeConnection.GetVehicleBehindArcPosition(_state.vehicleThatLetsMeChangeLine.currentPosition' 2 * (length + s0));  											if (otherBehindForman != null)  												{  												//_physics.multiplierTargetVelocity = Math2.Clamp(Math2.Cubic((otherBehindForman.distance - otherBehind.distance - s0) / (_length + 4 * s0))' 0.3' 1);  												double multPerDistance = 1 - Math2.Clamp((otherBehind.distance + _length + s0 - otherBehindForman.distance + otherBehindForman.vehicle._length + s0) / (otherBehindForman.vehicle._length)' 0.2' 0.75);  												double multPerSpeedDiff = Math2.Clamp((otherBehindForman.vehicle._physics.velocity - _physics.velocity) / 2' 0.25' 0.8);  												_physics.multiplierTargetVelocity = Math.Min(multPerDistance' multPerSpeedDiff);  												}  											}  										}  									}    								lowestAcceleration = Math.Min(lowestAcceleration' CalculateAcceleration(physics.velocity' effectiveDesiredVelocity' lci.endArcPos - Constants.breakPointBeforeForcedLineChange - arcPos' physics.velocity));  								}  							}  						}  					}  				else if (_state.vehicleThatLetsMeChangeLine != null)  					{  					_state.UnsetLineChangeVehicleInteraction();  					}    				#endregion    				#region freiwillig    				thinkAboutLineChange &= ((GlobalTime.Instance.currentTime - lastLineChangeCheck.Left > 1) || (currentPosition - lastLineChangeCheck.Right > 50));    				if (thinkAboutLineChange && !currentlyChangingLine)  					{  					lastLineChangeCheck.Left = GlobalTime.Instance.currentTime;  					lastLineChangeCheck.Right = currentPosition;    					// get current LineChangePoint and check' whether it's reachable  					NodeConnection.LineChangePoint lcp = route[0].GetPrevLineChangePoint(arcPos);  					if ((lcp.target.nc != null) && (Math.Abs(arcPos - lcp.start.arcPosition) < Constants.maxDistanceToLineChangePoint * 0.67))  						{  						// check whether there is an alternative route that is not too costly  						Routing alternativeRoute = Routing.CalculateShortestConenction(lcp.target.nc.endNode' targetNodes' _vehicleType);  						if (alternativeRoute.SegmentCount() > 0 && alternativeRoute.costs / wayToGo.costs < Constants.maxRatioForVoluntaryLineChange && !alternativeRoute.Top().lineChangeNeeded)  							{  							double myArcPositionOnOtherConnection = lcp.otherStart.arcPosition + (arcPos - lcp.start.arcPosition);  							if (myArcPositionOnOtherConnection >= 0)  								{  								// Check the relation to my surrounding vehicles on the target NodeConnection  								Pair<VehicleDistance> otherVehicles = lcp.otherStart.nc.GetVehiclesAroundArcPosition(myArcPositionOnOtherConnection' Constants.lookaheadDistance);    								// the new vehicle in front wouldn't be too close  								if (   otherVehicles.Right == null  									|| otherVehicles.Right.distance > otherVehicles.Right.vehicle.length + 2 * lcp.length)  									{  									// the new vehicle behind wouldn't be too close  									if (   otherVehicles.Left == null  										|| otherVehicles.Left.distance > length + otherVehicles.Left.vehicle.CalculateWantedDistance(otherVehicles.Left.vehicle.physics.velocity' otherVehicles.Left.vehicle.physics.velocity - physics.velocity)/2)  										{  										List<NodeConnection> l = new List<NodeConnection>();  										l.Add(lcp.target.nc);  										foreach (Routing.RouteSegment rs in alternativeRoute)  											l.Add(rs.startConnection);    										// calculate my necessary acceleration in case of a line change  										double myAccelerationOnOtherConnection = (otherVehicles.Right != null)  											? CalculateAcceleration(physics.velocity' effectiveDesiredVelocity' otherVehicles.Right.vehicle.currentPosition - myArcPositionOnOtherConnection' physics.velocity - otherVehicles.Right.vehicle.physics.velocity)  											: CalculateAcceleration(physics.velocity' effectiveDesiredVelocity' GetDistanceToNextTrafficLightOnRoute(l' myArcPositionOnOtherConnection' Constants.lookaheadDistance' true)' physics.velocity);    										// calculate the necessary acceleration of the vehicle behind in case of a line change  										double forcedAccelerationOfVehicleBehindMeOnOtherConnection = (otherVehicles.Left != null)  											? CalculateAcceleration(otherVehicles.Left.vehicle.physics.velocity' otherVehicles.Left.vehicle.effectiveDesiredVelocity' otherVehicles.Left.distance' otherVehicles.Left.vehicle.physics.velocity - physics.velocity)  											: 0;    										double currentAccelerationOfVehicleBehindMeOnOtherConnection = (otherVehicles.Left != null) ? otherVehicles.Left.vehicle.physics.acceleration : 0;    										// simplified implementation of MOBIL: http://www.vwi.tu-dresden.de/~treiber/MicroApplet/MOBIL.html  										if (forcedAccelerationOfVehicleBehindMeOnOtherConnection > bSave)  											{  											if (myAccelerationOnOtherConnection - lowestAcceleration > p * (currentAccelerationOfVehicleBehindMeOnOtherConnection - forcedAccelerationOfVehicleBehindMeOnOtherConnection) + lineChangeThreshold)  												{  												// initiate the line change  												InitiateLineChange(lcp' arcPos - lcp.start.arcPosition);  												lowestAcceleration = myAccelerationOnOtherConnection;  												}  											}  										}  									}  								}  							}  						}  					}    				#endregion    				}
Magic Number,CityTrafficSimulator.Vehicle,IVehicle,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\IVehicle.cs,Think,The following statement contains a magic number: if (!onlySimpleCalculations)  				{  				#region Forced line changes    				// our route forces to perform a line change  				if (lineChangeNeeded && !currentlyChangingLine && lci != null)  					{  					thinkAboutLineChange = false;  					lastLineChangeCheck.Left = GlobalTime.Instance.currentTime;  					lastLineChangeCheck.Right = currentPosition;    					// get current LineChangePoint and check' whether it's leading to our target  					NodeConnection.LineChangePoint lcp = route[0].GetPrevLineChangePoint(arcPos);  					if (lci.targetNode.prevConnections.Contains(lcp.target.nc))  						{  						bool slowDownToBreakPoint = false;  						double myArcPositionOnOtherConnection = lcp.otherStart.arcPosition + (arcPos - lcp.start.arcPosition);    						// check if found LineChangePoint is not too far away to perform the line change  						if ((myArcPositionOnOtherConnection >= 0) && (Math.Abs(arcPos - lcp.start.arcPosition) < Constants.maxDistanceToLineChangePoint * 1.25))  							{  							// Check the relation to my surrounding vehicles on the target NodeConnection  							Pair<VehicleDistance> otherVehicles = lcp.otherStart.nc.GetVehiclesAroundArcPosition(myArcPositionOnOtherConnection' Constants.lookaheadDistance);    							// the new vehicle in front wouldn't be too close  							if (   otherVehicles.Right == null  								|| otherVehicles.Right.distance > otherVehicles.Right.vehicle.length + CalculateWantedDistance(physics.velocity' physics.velocity - otherVehicles.Right.vehicle.physics.velocity)/2)  								{  								// the new vehicle behind wouldn't be too close  								if (   otherVehicles.Left == null  									|| otherVehicles.Left.distance > length + otherVehicles.Left.vehicle.CalculateWantedDistance(otherVehicles.Left.vehicle.physics.velocity' otherVehicles.Left.vehicle.physics.velocity - physics.velocity)/2)  									{  									// calculate my necessary acceleration in case of a line change  									double myAccelerationOnOtherConnection = (otherVehicles.Right != null)  										? CalculateAcceleration(physics.velocity' effectiveDesiredVelocity' otherVehicles.Right.vehicle.currentPosition - myArcPositionOnOtherConnection' physics.velocity - otherVehicles.Right.vehicle.physics.velocity)  										: CalculateAcceleration(physics.velocity' effectiveDesiredVelocity' lookaheadDistance' physics.velocity);    									// calculate the necessary acceleration of the vehicle behind in case of a line change  									double forcedAccelerationOfVehicleBehindMeOnOtherConnection = (otherVehicles.Left != null)  										? CalculateAcceleration(otherVehicles.Left.vehicle.physics.velocity' otherVehicles.Left.vehicle.effectiveDesiredVelocity' otherVehicles.Left.distance' otherVehicles.Left.vehicle.physics.velocity - physics.velocity)  										: 0;    									double currentAccelerationOfVehicleBehindMeOnOtherConnection = (otherVehicles.Left != null) ? otherVehicles.Left.vehicle.physics.acceleration : 0;    									// Final check:  									//  - The new vehicle behind must not break harder than bSave  									//  - My line change must be sufficiently necessary. The closer I come to the end of the LineChangeInterval' the more I may thwart the vehicle behind.   									if (   (forcedAccelerationOfVehicleBehindMeOnOtherConnection > bSave)  										&& ((arcPos - lci.startArcPos) / lci.length >= (currentAccelerationOfVehicleBehindMeOnOtherConnection - forcedAccelerationOfVehicleBehindMeOnOtherConnection)))  										{  										// return to normal velocity  										_physics.multiplierTargetVelocity = 1;    										// initiate the line change  										InitiateLineChange(lcp' arcPos - lcp.start.arcPosition);  										lowestAcceleration = myAccelerationOnOtherConnection;  										}  									// I do not want to change line yet' but I could position myself better between the two other vehicles on the parallel line.  									else if (true)  										{  										// TODO: implement  										slowDownToBreakPoint = true;  										}  									}  								// the new vehicle behind would too close but I can accelerate and are at least as fast as him  								else if (   otherVehicles.Left.vehicle.physics.velocity / this.physics.velocity < 1.2  // I am not significantly slower than him  										 && (otherVehicles.Right == null || otherVehicles.Right.distance > 1.5 * length) // the new vehicle in front is far enough away  										 && lookaheadDistance > 2 * length			// no vehicle/traffic light/intersection in front  										 && lci.endArcPos - arcPos > 2 * length		// enough space left in LineChangeInterval  										 && lowestAcceleration >= -0.1)				// currently not braking  									{  									// accelerate to get in front  									_physics.multiplierTargetVelocity = 1.75;  									lowestAcceleration = Math.Min(lowestAcceleration' CalculateAcceleration(physics.velocity' effectiveDesiredVelocity' lookaheadDistance' physics.velocity));    									_state.SetLineChangeVehicleInteraction(this' otherVehicles.Left.vehicle' lcp.otherStart.nc' myArcPositionOnOtherConnection - _length);  									}  								// There is no way to perform a line change now => slow down  								else  									{  									slowDownToBreakPoint = true;  									}  								}  							// The new vehicle in front is too close => slow down  							else  								{  								slowDownToBreakPoint = true;  								}  							}    						if (slowDownToBreakPoint)  							{  							double percentOfLCILeft = Math.Max(0.2' (lci.endArcPos - currentPosition - Constants.breakPointBeforeForcedLineChange) / (lci.length - Constants.breakPointBeforeForcedLineChange));    							// slow down a bit  							_physics.multiplierTargetVelocity = Math.Min(0.9' 1.5 * percentOfLCILeft);    							// When reaching the end of the LineChangeInterval' check whether there are other possibilities to reach the target:  							if (percentOfLCILeft < 0.5)  								{  								Routing newRTT = Routing.CalculateShortestConenction(route[0].endNode' _targetNodes' _vehicleType);  								// The alternative route does not cost too much -> choose it  								if (newRTT.SegmentCount() > 0 && newRTT.costs / _wayToGo.costs < Constants.maxRatioForEnforcedLineChange)  									{  									_wayToGo = newRTT;  									_physics.multiplierTargetVelocity = 1;  									lineChangeNeeded = false;  									lci = null;  									}  								}  							// Line change still necessacy => stop at break point  							if (lineChangeNeeded)  								{  								if (! _state.letVehicleChangeLine && percentOfLCILeft < 0.8)  									{  									VehicleDistance otherBehind = lcp.otherStart.nc.GetVehicleBeforeArcPosition(myArcPositionOnOtherConnection - ((_length + s0))' Constants.lookaheadDistance);    									// In rare cases deadlocks may appear when a very long and a short vehicle are driving parallel to each other (and both want to change line):  									// Then' none of the two finds a vehicle behind on the parallel connection. Hence' none of the two will wait for the other one  									// and both might drive to the end of the line change interval and there block each other.  									// To avoid this case' if there is no otherBehind' we also look for a parallel vehicle in front of our back (there should be one' otherwise  									// something went terribly wrong above). The longer one of the two will wait for the shorter one to make sure' no deadlock will occur.  									if (otherBehind == null)  										{  										VehicleDistance otherFront = lcp.otherStart.nc.GetVehicleBehindArcPosition(myArcPositionOnOtherConnection - ((_length + s0))' Constants.lookaheadDistance);  										if (otherFront.vehicle.lineChangeNeeded && otherFront.vehicle._length > _length)  											{  											otherBehind = otherFront;  											otherBehind.distance *= -1;  											}  										}    									//Pair<VehicleDistance> vd = lcp.otherStart.nc.GetVehiclesAroundArcPosition(myArcPositionOnOtherConnection - ( (_length + s0))' Constants.lookaheadDistance);  									if (otherBehind != null)// && otherBehind.vehicle.p >= p)  										{  										// tell the vehicle behind my back to wait for me  										_state.SetLineChangeVehicleInteraction(this' otherBehind.vehicle' lcp.otherStart.nc' myArcPositionOnOtherConnection - _length);    										// In addition' I need to get behind the vehicle in front of the vehicle which waits for me. Therefore I adapt the desired velocity  										if (_state.vehicleThatLetsMeChangeLine != null)  											{  											VehicleDistance otherBehindForman = _state.vehicleThatLetsMeChangeLine.currentNodeConnection.GetVehicleBehindArcPosition(_state.vehicleThatLetsMeChangeLine.currentPosition' 2 * (length + s0));  											if (otherBehindForman != null)  												{  												//_physics.multiplierTargetVelocity = Math2.Clamp(Math2.Cubic((otherBehindForman.distance - otherBehind.distance - s0) / (_length + 4 * s0))' 0.3' 1);  												double multPerDistance = 1 - Math2.Clamp((otherBehind.distance + _length + s0 - otherBehindForman.distance + otherBehindForman.vehicle._length + s0) / (otherBehindForman.vehicle._length)' 0.2' 0.75);  												double multPerSpeedDiff = Math2.Clamp((otherBehindForman.vehicle._physics.velocity - _physics.velocity) / 2' 0.25' 0.8);  												_physics.multiplierTargetVelocity = Math.Min(multPerDistance' multPerSpeedDiff);  												}  											}  										}  									}    								lowestAcceleration = Math.Min(lowestAcceleration' CalculateAcceleration(physics.velocity' effectiveDesiredVelocity' lci.endArcPos - Constants.breakPointBeforeForcedLineChange - arcPos' physics.velocity));  								}  							}  						}  					}  				else if (_state.vehicleThatLetsMeChangeLine != null)  					{  					_state.UnsetLineChangeVehicleInteraction();  					}    				#endregion    				#region freiwillig    				thinkAboutLineChange &= ((GlobalTime.Instance.currentTime - lastLineChangeCheck.Left > 1) || (currentPosition - lastLineChangeCheck.Right > 50));    				if (thinkAboutLineChange && !currentlyChangingLine)  					{  					lastLineChangeCheck.Left = GlobalTime.Instance.currentTime;  					lastLineChangeCheck.Right = currentPosition;    					// get current LineChangePoint and check' whether it's reachable  					NodeConnection.LineChangePoint lcp = route[0].GetPrevLineChangePoint(arcPos);  					if ((lcp.target.nc != null) && (Math.Abs(arcPos - lcp.start.arcPosition) < Constants.maxDistanceToLineChangePoint * 0.67))  						{  						// check whether there is an alternative route that is not too costly  						Routing alternativeRoute = Routing.CalculateShortestConenction(lcp.target.nc.endNode' targetNodes' _vehicleType);  						if (alternativeRoute.SegmentCount() > 0 && alternativeRoute.costs / wayToGo.costs < Constants.maxRatioForVoluntaryLineChange && !alternativeRoute.Top().lineChangeNeeded)  							{  							double myArcPositionOnOtherConnection = lcp.otherStart.arcPosition + (arcPos - lcp.start.arcPosition);  							if (myArcPositionOnOtherConnection >= 0)  								{  								// Check the relation to my surrounding vehicles on the target NodeConnection  								Pair<VehicleDistance> otherVehicles = lcp.otherStart.nc.GetVehiclesAroundArcPosition(myArcPositionOnOtherConnection' Constants.lookaheadDistance);    								// the new vehicle in front wouldn't be too close  								if (   otherVehicles.Right == null  									|| otherVehicles.Right.distance > otherVehicles.Right.vehicle.length + 2 * lcp.length)  									{  									// the new vehicle behind wouldn't be too close  									if (   otherVehicles.Left == null  										|| otherVehicles.Left.distance > length + otherVehicles.Left.vehicle.CalculateWantedDistance(otherVehicles.Left.vehicle.physics.velocity' otherVehicles.Left.vehicle.physics.velocity - physics.velocity)/2)  										{  										List<NodeConnection> l = new List<NodeConnection>();  										l.Add(lcp.target.nc);  										foreach (Routing.RouteSegment rs in alternativeRoute)  											l.Add(rs.startConnection);    										// calculate my necessary acceleration in case of a line change  										double myAccelerationOnOtherConnection = (otherVehicles.Right != null)  											? CalculateAcceleration(physics.velocity' effectiveDesiredVelocity' otherVehicles.Right.vehicle.currentPosition - myArcPositionOnOtherConnection' physics.velocity - otherVehicles.Right.vehicle.physics.velocity)  											: CalculateAcceleration(physics.velocity' effectiveDesiredVelocity' GetDistanceToNextTrafficLightOnRoute(l' myArcPositionOnOtherConnection' Constants.lookaheadDistance' true)' physics.velocity);    										// calculate the necessary acceleration of the vehicle behind in case of a line change  										double forcedAccelerationOfVehicleBehindMeOnOtherConnection = (otherVehicles.Left != null)  											? CalculateAcceleration(otherVehicles.Left.vehicle.physics.velocity' otherVehicles.Left.vehicle.effectiveDesiredVelocity' otherVehicles.Left.distance' otherVehicles.Left.vehicle.physics.velocity - physics.velocity)  											: 0;    										double currentAccelerationOfVehicleBehindMeOnOtherConnection = (otherVehicles.Left != null) ? otherVehicles.Left.vehicle.physics.acceleration : 0;    										// simplified implementation of MOBIL: http://www.vwi.tu-dresden.de/~treiber/MicroApplet/MOBIL.html  										if (forcedAccelerationOfVehicleBehindMeOnOtherConnection > bSave)  											{  											if (myAccelerationOnOtherConnection - lowestAcceleration > p * (currentAccelerationOfVehicleBehindMeOnOtherConnection - forcedAccelerationOfVehicleBehindMeOnOtherConnection) + lineChangeThreshold)  												{  												// initiate the line change  												InitiateLineChange(lcp' arcPos - lcp.start.arcPosition);  												lowestAcceleration = myAccelerationOnOtherConnection;  												}  											}  										}  									}  								}  							}  						}  					}    				#endregion    				}
Magic Number,CityTrafficSimulator.Vehicle,IVehicle,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\IVehicle.cs,Think,The following statement contains a magic number: if (!onlySimpleCalculations)  				{  				#region Forced line changes    				// our route forces to perform a line change  				if (lineChangeNeeded && !currentlyChangingLine && lci != null)  					{  					thinkAboutLineChange = false;  					lastLineChangeCheck.Left = GlobalTime.Instance.currentTime;  					lastLineChangeCheck.Right = currentPosition;    					// get current LineChangePoint and check' whether it's leading to our target  					NodeConnection.LineChangePoint lcp = route[0].GetPrevLineChangePoint(arcPos);  					if (lci.targetNode.prevConnections.Contains(lcp.target.nc))  						{  						bool slowDownToBreakPoint = false;  						double myArcPositionOnOtherConnection = lcp.otherStart.arcPosition + (arcPos - lcp.start.arcPosition);    						// check if found LineChangePoint is not too far away to perform the line change  						if ((myArcPositionOnOtherConnection >= 0) && (Math.Abs(arcPos - lcp.start.arcPosition) < Constants.maxDistanceToLineChangePoint * 1.25))  							{  							// Check the relation to my surrounding vehicles on the target NodeConnection  							Pair<VehicleDistance> otherVehicles = lcp.otherStart.nc.GetVehiclesAroundArcPosition(myArcPositionOnOtherConnection' Constants.lookaheadDistance);    							// the new vehicle in front wouldn't be too close  							if (   otherVehicles.Right == null  								|| otherVehicles.Right.distance > otherVehicles.Right.vehicle.length + CalculateWantedDistance(physics.velocity' physics.velocity - otherVehicles.Right.vehicle.physics.velocity)/2)  								{  								// the new vehicle behind wouldn't be too close  								if (   otherVehicles.Left == null  									|| otherVehicles.Left.distance > length + otherVehicles.Left.vehicle.CalculateWantedDistance(otherVehicles.Left.vehicle.physics.velocity' otherVehicles.Left.vehicle.physics.velocity - physics.velocity)/2)  									{  									// calculate my necessary acceleration in case of a line change  									double myAccelerationOnOtherConnection = (otherVehicles.Right != null)  										? CalculateAcceleration(physics.velocity' effectiveDesiredVelocity' otherVehicles.Right.vehicle.currentPosition - myArcPositionOnOtherConnection' physics.velocity - otherVehicles.Right.vehicle.physics.velocity)  										: CalculateAcceleration(physics.velocity' effectiveDesiredVelocity' lookaheadDistance' physics.velocity);    									// calculate the necessary acceleration of the vehicle behind in case of a line change  									double forcedAccelerationOfVehicleBehindMeOnOtherConnection = (otherVehicles.Left != null)  										? CalculateAcceleration(otherVehicles.Left.vehicle.physics.velocity' otherVehicles.Left.vehicle.effectiveDesiredVelocity' otherVehicles.Left.distance' otherVehicles.Left.vehicle.physics.velocity - physics.velocity)  										: 0;    									double currentAccelerationOfVehicleBehindMeOnOtherConnection = (otherVehicles.Left != null) ? otherVehicles.Left.vehicle.physics.acceleration : 0;    									// Final check:  									//  - The new vehicle behind must not break harder than bSave  									//  - My line change must be sufficiently necessary. The closer I come to the end of the LineChangeInterval' the more I may thwart the vehicle behind.   									if (   (forcedAccelerationOfVehicleBehindMeOnOtherConnection > bSave)  										&& ((arcPos - lci.startArcPos) / lci.length >= (currentAccelerationOfVehicleBehindMeOnOtherConnection - forcedAccelerationOfVehicleBehindMeOnOtherConnection)))  										{  										// return to normal velocity  										_physics.multiplierTargetVelocity = 1;    										// initiate the line change  										InitiateLineChange(lcp' arcPos - lcp.start.arcPosition);  										lowestAcceleration = myAccelerationOnOtherConnection;  										}  									// I do not want to change line yet' but I could position myself better between the two other vehicles on the parallel line.  									else if (true)  										{  										// TODO: implement  										slowDownToBreakPoint = true;  										}  									}  								// the new vehicle behind would too close but I can accelerate and are at least as fast as him  								else if (   otherVehicles.Left.vehicle.physics.velocity / this.physics.velocity < 1.2  // I am not significantly slower than him  										 && (otherVehicles.Right == null || otherVehicles.Right.distance > 1.5 * length) // the new vehicle in front is far enough away  										 && lookaheadDistance > 2 * length			// no vehicle/traffic light/intersection in front  										 && lci.endArcPos - arcPos > 2 * length		// enough space left in LineChangeInterval  										 && lowestAcceleration >= -0.1)				// currently not braking  									{  									// accelerate to get in front  									_physics.multiplierTargetVelocity = 1.75;  									lowestAcceleration = Math.Min(lowestAcceleration' CalculateAcceleration(physics.velocity' effectiveDesiredVelocity' lookaheadDistance' physics.velocity));    									_state.SetLineChangeVehicleInteraction(this' otherVehicles.Left.vehicle' lcp.otherStart.nc' myArcPositionOnOtherConnection - _length);  									}  								// There is no way to perform a line change now => slow down  								else  									{  									slowDownToBreakPoint = true;  									}  								}  							// The new vehicle in front is too close => slow down  							else  								{  								slowDownToBreakPoint = true;  								}  							}    						if (slowDownToBreakPoint)  							{  							double percentOfLCILeft = Math.Max(0.2' (lci.endArcPos - currentPosition - Constants.breakPointBeforeForcedLineChange) / (lci.length - Constants.breakPointBeforeForcedLineChange));    							// slow down a bit  							_physics.multiplierTargetVelocity = Math.Min(0.9' 1.5 * percentOfLCILeft);    							// When reaching the end of the LineChangeInterval' check whether there are other possibilities to reach the target:  							if (percentOfLCILeft < 0.5)  								{  								Routing newRTT = Routing.CalculateShortestConenction(route[0].endNode' _targetNodes' _vehicleType);  								// The alternative route does not cost too much -> choose it  								if (newRTT.SegmentCount() > 0 && newRTT.costs / _wayToGo.costs < Constants.maxRatioForEnforcedLineChange)  									{  									_wayToGo = newRTT;  									_physics.multiplierTargetVelocity = 1;  									lineChangeNeeded = false;  									lci = null;  									}  								}  							// Line change still necessacy => stop at break point  							if (lineChangeNeeded)  								{  								if (! _state.letVehicleChangeLine && percentOfLCILeft < 0.8)  									{  									VehicleDistance otherBehind = lcp.otherStart.nc.GetVehicleBeforeArcPosition(myArcPositionOnOtherConnection - ((_length + s0))' Constants.lookaheadDistance);    									// In rare cases deadlocks may appear when a very long and a short vehicle are driving parallel to each other (and both want to change line):  									// Then' none of the two finds a vehicle behind on the parallel connection. Hence' none of the two will wait for the other one  									// and both might drive to the end of the line change interval and there block each other.  									// To avoid this case' if there is no otherBehind' we also look for a parallel vehicle in front of our back (there should be one' otherwise  									// something went terribly wrong above). The longer one of the two will wait for the shorter one to make sure' no deadlock will occur.  									if (otherBehind == null)  										{  										VehicleDistance otherFront = lcp.otherStart.nc.GetVehicleBehindArcPosition(myArcPositionOnOtherConnection - ((_length + s0))' Constants.lookaheadDistance);  										if (otherFront.vehicle.lineChangeNeeded && otherFront.vehicle._length > _length)  											{  											otherBehind = otherFront;  											otherBehind.distance *= -1;  											}  										}    									//Pair<VehicleDistance> vd = lcp.otherStart.nc.GetVehiclesAroundArcPosition(myArcPositionOnOtherConnection - ( (_length + s0))' Constants.lookaheadDistance);  									if (otherBehind != null)// && otherBehind.vehicle.p >= p)  										{  										// tell the vehicle behind my back to wait for me  										_state.SetLineChangeVehicleInteraction(this' otherBehind.vehicle' lcp.otherStart.nc' myArcPositionOnOtherConnection - _length);    										// In addition' I need to get behind the vehicle in front of the vehicle which waits for me. Therefore I adapt the desired velocity  										if (_state.vehicleThatLetsMeChangeLine != null)  											{  											VehicleDistance otherBehindForman = _state.vehicleThatLetsMeChangeLine.currentNodeConnection.GetVehicleBehindArcPosition(_state.vehicleThatLetsMeChangeLine.currentPosition' 2 * (length + s0));  											if (otherBehindForman != null)  												{  												//_physics.multiplierTargetVelocity = Math2.Clamp(Math2.Cubic((otherBehindForman.distance - otherBehind.distance - s0) / (_length + 4 * s0))' 0.3' 1);  												double multPerDistance = 1 - Math2.Clamp((otherBehind.distance + _length + s0 - otherBehindForman.distance + otherBehindForman.vehicle._length + s0) / (otherBehindForman.vehicle._length)' 0.2' 0.75);  												double multPerSpeedDiff = Math2.Clamp((otherBehindForman.vehicle._physics.velocity - _physics.velocity) / 2' 0.25' 0.8);  												_physics.multiplierTargetVelocity = Math.Min(multPerDistance' multPerSpeedDiff);  												}  											}  										}  									}    								lowestAcceleration = Math.Min(lowestAcceleration' CalculateAcceleration(physics.velocity' effectiveDesiredVelocity' lci.endArcPos - Constants.breakPointBeforeForcedLineChange - arcPos' physics.velocity));  								}  							}  						}  					}  				else if (_state.vehicleThatLetsMeChangeLine != null)  					{  					_state.UnsetLineChangeVehicleInteraction();  					}    				#endregion    				#region freiwillig    				thinkAboutLineChange &= ((GlobalTime.Instance.currentTime - lastLineChangeCheck.Left > 1) || (currentPosition - lastLineChangeCheck.Right > 50));    				if (thinkAboutLineChange && !currentlyChangingLine)  					{  					lastLineChangeCheck.Left = GlobalTime.Instance.currentTime;  					lastLineChangeCheck.Right = currentPosition;    					// get current LineChangePoint and check' whether it's reachable  					NodeConnection.LineChangePoint lcp = route[0].GetPrevLineChangePoint(arcPos);  					if ((lcp.target.nc != null) && (Math.Abs(arcPos - lcp.start.arcPosition) < Constants.maxDistanceToLineChangePoint * 0.67))  						{  						// check whether there is an alternative route that is not too costly  						Routing alternativeRoute = Routing.CalculateShortestConenction(lcp.target.nc.endNode' targetNodes' _vehicleType);  						if (alternativeRoute.SegmentCount() > 0 && alternativeRoute.costs / wayToGo.costs < Constants.maxRatioForVoluntaryLineChange && !alternativeRoute.Top().lineChangeNeeded)  							{  							double myArcPositionOnOtherConnection = lcp.otherStart.arcPosition + (arcPos - lcp.start.arcPosition);  							if (myArcPositionOnOtherConnection >= 0)  								{  								// Check the relation to my surrounding vehicles on the target NodeConnection  								Pair<VehicleDistance> otherVehicles = lcp.otherStart.nc.GetVehiclesAroundArcPosition(myArcPositionOnOtherConnection' Constants.lookaheadDistance);    								// the new vehicle in front wouldn't be too close  								if (   otherVehicles.Right == null  									|| otherVehicles.Right.distance > otherVehicles.Right.vehicle.length + 2 * lcp.length)  									{  									// the new vehicle behind wouldn't be too close  									if (   otherVehicles.Left == null  										|| otherVehicles.Left.distance > length + otherVehicles.Left.vehicle.CalculateWantedDistance(otherVehicles.Left.vehicle.physics.velocity' otherVehicles.Left.vehicle.physics.velocity - physics.velocity)/2)  										{  										List<NodeConnection> l = new List<NodeConnection>();  										l.Add(lcp.target.nc);  										foreach (Routing.RouteSegment rs in alternativeRoute)  											l.Add(rs.startConnection);    										// calculate my necessary acceleration in case of a line change  										double myAccelerationOnOtherConnection = (otherVehicles.Right != null)  											? CalculateAcceleration(physics.velocity' effectiveDesiredVelocity' otherVehicles.Right.vehicle.currentPosition - myArcPositionOnOtherConnection' physics.velocity - otherVehicles.Right.vehicle.physics.velocity)  											: CalculateAcceleration(physics.velocity' effectiveDesiredVelocity' GetDistanceToNextTrafficLightOnRoute(l' myArcPositionOnOtherConnection' Constants.lookaheadDistance' true)' physics.velocity);    										// calculate the necessary acceleration of the vehicle behind in case of a line change  										double forcedAccelerationOfVehicleBehindMeOnOtherConnection = (otherVehicles.Left != null)  											? CalculateAcceleration(otherVehicles.Left.vehicle.physics.velocity' otherVehicles.Left.vehicle.effectiveDesiredVelocity' otherVehicles.Left.distance' otherVehicles.Left.vehicle.physics.velocity - physics.velocity)  											: 0;    										double currentAccelerationOfVehicleBehindMeOnOtherConnection = (otherVehicles.Left != null) ? otherVehicles.Left.vehicle.physics.acceleration : 0;    										// simplified implementation of MOBIL: http://www.vwi.tu-dresden.de/~treiber/MicroApplet/MOBIL.html  										if (forcedAccelerationOfVehicleBehindMeOnOtherConnection > bSave)  											{  											if (myAccelerationOnOtherConnection - lowestAcceleration > p * (currentAccelerationOfVehicleBehindMeOnOtherConnection - forcedAccelerationOfVehicleBehindMeOnOtherConnection) + lineChangeThreshold)  												{  												// initiate the line change  												InitiateLineChange(lcp' arcPos - lcp.start.arcPosition);  												lowestAcceleration = myAccelerationOnOtherConnection;  												}  											}  										}  									}  								}  							}  						}  					}    				#endregion    				}
Magic Number,CityTrafficSimulator.Vehicle,IVehicle,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\IVehicle.cs,Think,The following statement contains a magic number: if (!onlySimpleCalculations)  				{  				#region Forced line changes    				// our route forces to perform a line change  				if (lineChangeNeeded && !currentlyChangingLine && lci != null)  					{  					thinkAboutLineChange = false;  					lastLineChangeCheck.Left = GlobalTime.Instance.currentTime;  					lastLineChangeCheck.Right = currentPosition;    					// get current LineChangePoint and check' whether it's leading to our target  					NodeConnection.LineChangePoint lcp = route[0].GetPrevLineChangePoint(arcPos);  					if (lci.targetNode.prevConnections.Contains(lcp.target.nc))  						{  						bool slowDownToBreakPoint = false;  						double myArcPositionOnOtherConnection = lcp.otherStart.arcPosition + (arcPos - lcp.start.arcPosition);    						// check if found LineChangePoint is not too far away to perform the line change  						if ((myArcPositionOnOtherConnection >= 0) && (Math.Abs(arcPos - lcp.start.arcPosition) < Constants.maxDistanceToLineChangePoint * 1.25))  							{  							// Check the relation to my surrounding vehicles on the target NodeConnection  							Pair<VehicleDistance> otherVehicles = lcp.otherStart.nc.GetVehiclesAroundArcPosition(myArcPositionOnOtherConnection' Constants.lookaheadDistance);    							// the new vehicle in front wouldn't be too close  							if (   otherVehicles.Right == null  								|| otherVehicles.Right.distance > otherVehicles.Right.vehicle.length + CalculateWantedDistance(physics.velocity' physics.velocity - otherVehicles.Right.vehicle.physics.velocity)/2)  								{  								// the new vehicle behind wouldn't be too close  								if (   otherVehicles.Left == null  									|| otherVehicles.Left.distance > length + otherVehicles.Left.vehicle.CalculateWantedDistance(otherVehicles.Left.vehicle.physics.velocity' otherVehicles.Left.vehicle.physics.velocity - physics.velocity)/2)  									{  									// calculate my necessary acceleration in case of a line change  									double myAccelerationOnOtherConnection = (otherVehicles.Right != null)  										? CalculateAcceleration(physics.velocity' effectiveDesiredVelocity' otherVehicles.Right.vehicle.currentPosition - myArcPositionOnOtherConnection' physics.velocity - otherVehicles.Right.vehicle.physics.velocity)  										: CalculateAcceleration(physics.velocity' effectiveDesiredVelocity' lookaheadDistance' physics.velocity);    									// calculate the necessary acceleration of the vehicle behind in case of a line change  									double forcedAccelerationOfVehicleBehindMeOnOtherConnection = (otherVehicles.Left != null)  										? CalculateAcceleration(otherVehicles.Left.vehicle.physics.velocity' otherVehicles.Left.vehicle.effectiveDesiredVelocity' otherVehicles.Left.distance' otherVehicles.Left.vehicle.physics.velocity - physics.velocity)  										: 0;    									double currentAccelerationOfVehicleBehindMeOnOtherConnection = (otherVehicles.Left != null) ? otherVehicles.Left.vehicle.physics.acceleration : 0;    									// Final check:  									//  - The new vehicle behind must not break harder than bSave  									//  - My line change must be sufficiently necessary. The closer I come to the end of the LineChangeInterval' the more I may thwart the vehicle behind.   									if (   (forcedAccelerationOfVehicleBehindMeOnOtherConnection > bSave)  										&& ((arcPos - lci.startArcPos) / lci.length >= (currentAccelerationOfVehicleBehindMeOnOtherConnection - forcedAccelerationOfVehicleBehindMeOnOtherConnection)))  										{  										// return to normal velocity  										_physics.multiplierTargetVelocity = 1;    										// initiate the line change  										InitiateLineChange(lcp' arcPos - lcp.start.arcPosition);  										lowestAcceleration = myAccelerationOnOtherConnection;  										}  									// I do not want to change line yet' but I could position myself better between the two other vehicles on the parallel line.  									else if (true)  										{  										// TODO: implement  										slowDownToBreakPoint = true;  										}  									}  								// the new vehicle behind would too close but I can accelerate and are at least as fast as him  								else if (   otherVehicles.Left.vehicle.physics.velocity / this.physics.velocity < 1.2  // I am not significantly slower than him  										 && (otherVehicles.Right == null || otherVehicles.Right.distance > 1.5 * length) // the new vehicle in front is far enough away  										 && lookaheadDistance > 2 * length			// no vehicle/traffic light/intersection in front  										 && lci.endArcPos - arcPos > 2 * length		// enough space left in LineChangeInterval  										 && lowestAcceleration >= -0.1)				// currently not braking  									{  									// accelerate to get in front  									_physics.multiplierTargetVelocity = 1.75;  									lowestAcceleration = Math.Min(lowestAcceleration' CalculateAcceleration(physics.velocity' effectiveDesiredVelocity' lookaheadDistance' physics.velocity));    									_state.SetLineChangeVehicleInteraction(this' otherVehicles.Left.vehicle' lcp.otherStart.nc' myArcPositionOnOtherConnection - _length);  									}  								// There is no way to perform a line change now => slow down  								else  									{  									slowDownToBreakPoint = true;  									}  								}  							// The new vehicle in front is too close => slow down  							else  								{  								slowDownToBreakPoint = true;  								}  							}    						if (slowDownToBreakPoint)  							{  							double percentOfLCILeft = Math.Max(0.2' (lci.endArcPos - currentPosition - Constants.breakPointBeforeForcedLineChange) / (lci.length - Constants.breakPointBeforeForcedLineChange));    							// slow down a bit  							_physics.multiplierTargetVelocity = Math.Min(0.9' 1.5 * percentOfLCILeft);    							// When reaching the end of the LineChangeInterval' check whether there are other possibilities to reach the target:  							if (percentOfLCILeft < 0.5)  								{  								Routing newRTT = Routing.CalculateShortestConenction(route[0].endNode' _targetNodes' _vehicleType);  								// The alternative route does not cost too much -> choose it  								if (newRTT.SegmentCount() > 0 && newRTT.costs / _wayToGo.costs < Constants.maxRatioForEnforcedLineChange)  									{  									_wayToGo = newRTT;  									_physics.multiplierTargetVelocity = 1;  									lineChangeNeeded = false;  									lci = null;  									}  								}  							// Line change still necessacy => stop at break point  							if (lineChangeNeeded)  								{  								if (! _state.letVehicleChangeLine && percentOfLCILeft < 0.8)  									{  									VehicleDistance otherBehind = lcp.otherStart.nc.GetVehicleBeforeArcPosition(myArcPositionOnOtherConnection - ((_length + s0))' Constants.lookaheadDistance);    									// In rare cases deadlocks may appear when a very long and a short vehicle are driving parallel to each other (and both want to change line):  									// Then' none of the two finds a vehicle behind on the parallel connection. Hence' none of the two will wait for the other one  									// and both might drive to the end of the line change interval and there block each other.  									// To avoid this case' if there is no otherBehind' we also look for a parallel vehicle in front of our back (there should be one' otherwise  									// something went terribly wrong above). The longer one of the two will wait for the shorter one to make sure' no deadlock will occur.  									if (otherBehind == null)  										{  										VehicleDistance otherFront = lcp.otherStart.nc.GetVehicleBehindArcPosition(myArcPositionOnOtherConnection - ((_length + s0))' Constants.lookaheadDistance);  										if (otherFront.vehicle.lineChangeNeeded && otherFront.vehicle._length > _length)  											{  											otherBehind = otherFront;  											otherBehind.distance *= -1;  											}  										}    									//Pair<VehicleDistance> vd = lcp.otherStart.nc.GetVehiclesAroundArcPosition(myArcPositionOnOtherConnection - ( (_length + s0))' Constants.lookaheadDistance);  									if (otherBehind != null)// && otherBehind.vehicle.p >= p)  										{  										// tell the vehicle behind my back to wait for me  										_state.SetLineChangeVehicleInteraction(this' otherBehind.vehicle' lcp.otherStart.nc' myArcPositionOnOtherConnection - _length);    										// In addition' I need to get behind the vehicle in front of the vehicle which waits for me. Therefore I adapt the desired velocity  										if (_state.vehicleThatLetsMeChangeLine != null)  											{  											VehicleDistance otherBehindForman = _state.vehicleThatLetsMeChangeLine.currentNodeConnection.GetVehicleBehindArcPosition(_state.vehicleThatLetsMeChangeLine.currentPosition' 2 * (length + s0));  											if (otherBehindForman != null)  												{  												//_physics.multiplierTargetVelocity = Math2.Clamp(Math2.Cubic((otherBehindForman.distance - otherBehind.distance - s0) / (_length + 4 * s0))' 0.3' 1);  												double multPerDistance = 1 - Math2.Clamp((otherBehind.distance + _length + s0 - otherBehindForman.distance + otherBehindForman.vehicle._length + s0) / (otherBehindForman.vehicle._length)' 0.2' 0.75);  												double multPerSpeedDiff = Math2.Clamp((otherBehindForman.vehicle._physics.velocity - _physics.velocity) / 2' 0.25' 0.8);  												_physics.multiplierTargetVelocity = Math.Min(multPerDistance' multPerSpeedDiff);  												}  											}  										}  									}    								lowestAcceleration = Math.Min(lowestAcceleration' CalculateAcceleration(physics.velocity' effectiveDesiredVelocity' lci.endArcPos - Constants.breakPointBeforeForcedLineChange - arcPos' physics.velocity));  								}  							}  						}  					}  				else if (_state.vehicleThatLetsMeChangeLine != null)  					{  					_state.UnsetLineChangeVehicleInteraction();  					}    				#endregion    				#region freiwillig    				thinkAboutLineChange &= ((GlobalTime.Instance.currentTime - lastLineChangeCheck.Left > 1) || (currentPosition - lastLineChangeCheck.Right > 50));    				if (thinkAboutLineChange && !currentlyChangingLine)  					{  					lastLineChangeCheck.Left = GlobalTime.Instance.currentTime;  					lastLineChangeCheck.Right = currentPosition;    					// get current LineChangePoint and check' whether it's reachable  					NodeConnection.LineChangePoint lcp = route[0].GetPrevLineChangePoint(arcPos);  					if ((lcp.target.nc != null) && (Math.Abs(arcPos - lcp.start.arcPosition) < Constants.maxDistanceToLineChangePoint * 0.67))  						{  						// check whether there is an alternative route that is not too costly  						Routing alternativeRoute = Routing.CalculateShortestConenction(lcp.target.nc.endNode' targetNodes' _vehicleType);  						if (alternativeRoute.SegmentCount() > 0 && alternativeRoute.costs / wayToGo.costs < Constants.maxRatioForVoluntaryLineChange && !alternativeRoute.Top().lineChangeNeeded)  							{  							double myArcPositionOnOtherConnection = lcp.otherStart.arcPosition + (arcPos - lcp.start.arcPosition);  							if (myArcPositionOnOtherConnection >= 0)  								{  								// Check the relation to my surrounding vehicles on the target NodeConnection  								Pair<VehicleDistance> otherVehicles = lcp.otherStart.nc.GetVehiclesAroundArcPosition(myArcPositionOnOtherConnection' Constants.lookaheadDistance);    								// the new vehicle in front wouldn't be too close  								if (   otherVehicles.Right == null  									|| otherVehicles.Right.distance > otherVehicles.Right.vehicle.length + 2 * lcp.length)  									{  									// the new vehicle behind wouldn't be too close  									if (   otherVehicles.Left == null  										|| otherVehicles.Left.distance > length + otherVehicles.Left.vehicle.CalculateWantedDistance(otherVehicles.Left.vehicle.physics.velocity' otherVehicles.Left.vehicle.physics.velocity - physics.velocity)/2)  										{  										List<NodeConnection> l = new List<NodeConnection>();  										l.Add(lcp.target.nc);  										foreach (Routing.RouteSegment rs in alternativeRoute)  											l.Add(rs.startConnection);    										// calculate my necessary acceleration in case of a line change  										double myAccelerationOnOtherConnection = (otherVehicles.Right != null)  											? CalculateAcceleration(physics.velocity' effectiveDesiredVelocity' otherVehicles.Right.vehicle.currentPosition - myArcPositionOnOtherConnection' physics.velocity - otherVehicles.Right.vehicle.physics.velocity)  											: CalculateAcceleration(physics.velocity' effectiveDesiredVelocity' GetDistanceToNextTrafficLightOnRoute(l' myArcPositionOnOtherConnection' Constants.lookaheadDistance' true)' physics.velocity);    										// calculate the necessary acceleration of the vehicle behind in case of a line change  										double forcedAccelerationOfVehicleBehindMeOnOtherConnection = (otherVehicles.Left != null)  											? CalculateAcceleration(otherVehicles.Left.vehicle.physics.velocity' otherVehicles.Left.vehicle.effectiveDesiredVelocity' otherVehicles.Left.distance' otherVehicles.Left.vehicle.physics.velocity - physics.velocity)  											: 0;    										double currentAccelerationOfVehicleBehindMeOnOtherConnection = (otherVehicles.Left != null) ? otherVehicles.Left.vehicle.physics.acceleration : 0;    										// simplified implementation of MOBIL: http://www.vwi.tu-dresden.de/~treiber/MicroApplet/MOBIL.html  										if (forcedAccelerationOfVehicleBehindMeOnOtherConnection > bSave)  											{  											if (myAccelerationOnOtherConnection - lowestAcceleration > p * (currentAccelerationOfVehicleBehindMeOnOtherConnection - forcedAccelerationOfVehicleBehindMeOnOtherConnection) + lineChangeThreshold)  												{  												// initiate the line change  												InitiateLineChange(lcp' arcPos - lcp.start.arcPosition);  												lowestAcceleration = myAccelerationOnOtherConnection;  												}  											}  										}  									}  								}  							}  						}  					}    				#endregion    				}
Magic Number,CityTrafficSimulator.Vehicle,IVehicle,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\IVehicle.cs,Think,The following statement contains a magic number: if (!onlySimpleCalculations)  				{  				#region Forced line changes    				// our route forces to perform a line change  				if (lineChangeNeeded && !currentlyChangingLine && lci != null)  					{  					thinkAboutLineChange = false;  					lastLineChangeCheck.Left = GlobalTime.Instance.currentTime;  					lastLineChangeCheck.Right = currentPosition;    					// get current LineChangePoint and check' whether it's leading to our target  					NodeConnection.LineChangePoint lcp = route[0].GetPrevLineChangePoint(arcPos);  					if (lci.targetNode.prevConnections.Contains(lcp.target.nc))  						{  						bool slowDownToBreakPoint = false;  						double myArcPositionOnOtherConnection = lcp.otherStart.arcPosition + (arcPos - lcp.start.arcPosition);    						// check if found LineChangePoint is not too far away to perform the line change  						if ((myArcPositionOnOtherConnection >= 0) && (Math.Abs(arcPos - lcp.start.arcPosition) < Constants.maxDistanceToLineChangePoint * 1.25))  							{  							// Check the relation to my surrounding vehicles on the target NodeConnection  							Pair<VehicleDistance> otherVehicles = lcp.otherStart.nc.GetVehiclesAroundArcPosition(myArcPositionOnOtherConnection' Constants.lookaheadDistance);    							// the new vehicle in front wouldn't be too close  							if (   otherVehicles.Right == null  								|| otherVehicles.Right.distance > otherVehicles.Right.vehicle.length + CalculateWantedDistance(physics.velocity' physics.velocity - otherVehicles.Right.vehicle.physics.velocity)/2)  								{  								// the new vehicle behind wouldn't be too close  								if (   otherVehicles.Left == null  									|| otherVehicles.Left.distance > length + otherVehicles.Left.vehicle.CalculateWantedDistance(otherVehicles.Left.vehicle.physics.velocity' otherVehicles.Left.vehicle.physics.velocity - physics.velocity)/2)  									{  									// calculate my necessary acceleration in case of a line change  									double myAccelerationOnOtherConnection = (otherVehicles.Right != null)  										? CalculateAcceleration(physics.velocity' effectiveDesiredVelocity' otherVehicles.Right.vehicle.currentPosition - myArcPositionOnOtherConnection' physics.velocity - otherVehicles.Right.vehicle.physics.velocity)  										: CalculateAcceleration(physics.velocity' effectiveDesiredVelocity' lookaheadDistance' physics.velocity);    									// calculate the necessary acceleration of the vehicle behind in case of a line change  									double forcedAccelerationOfVehicleBehindMeOnOtherConnection = (otherVehicles.Left != null)  										? CalculateAcceleration(otherVehicles.Left.vehicle.physics.velocity' otherVehicles.Left.vehicle.effectiveDesiredVelocity' otherVehicles.Left.distance' otherVehicles.Left.vehicle.physics.velocity - physics.velocity)  										: 0;    									double currentAccelerationOfVehicleBehindMeOnOtherConnection = (otherVehicles.Left != null) ? otherVehicles.Left.vehicle.physics.acceleration : 0;    									// Final check:  									//  - The new vehicle behind must not break harder than bSave  									//  - My line change must be sufficiently necessary. The closer I come to the end of the LineChangeInterval' the more I may thwart the vehicle behind.   									if (   (forcedAccelerationOfVehicleBehindMeOnOtherConnection > bSave)  										&& ((arcPos - lci.startArcPos) / lci.length >= (currentAccelerationOfVehicleBehindMeOnOtherConnection - forcedAccelerationOfVehicleBehindMeOnOtherConnection)))  										{  										// return to normal velocity  										_physics.multiplierTargetVelocity = 1;    										// initiate the line change  										InitiateLineChange(lcp' arcPos - lcp.start.arcPosition);  										lowestAcceleration = myAccelerationOnOtherConnection;  										}  									// I do not want to change line yet' but I could position myself better between the two other vehicles on the parallel line.  									else if (true)  										{  										// TODO: implement  										slowDownToBreakPoint = true;  										}  									}  								// the new vehicle behind would too close but I can accelerate and are at least as fast as him  								else if (   otherVehicles.Left.vehicle.physics.velocity / this.physics.velocity < 1.2  // I am not significantly slower than him  										 && (otherVehicles.Right == null || otherVehicles.Right.distance > 1.5 * length) // the new vehicle in front is far enough away  										 && lookaheadDistance > 2 * length			// no vehicle/traffic light/intersection in front  										 && lci.endArcPos - arcPos > 2 * length		// enough space left in LineChangeInterval  										 && lowestAcceleration >= -0.1)				// currently not braking  									{  									// accelerate to get in front  									_physics.multiplierTargetVelocity = 1.75;  									lowestAcceleration = Math.Min(lowestAcceleration' CalculateAcceleration(physics.velocity' effectiveDesiredVelocity' lookaheadDistance' physics.velocity));    									_state.SetLineChangeVehicleInteraction(this' otherVehicles.Left.vehicle' lcp.otherStart.nc' myArcPositionOnOtherConnection - _length);  									}  								// There is no way to perform a line change now => slow down  								else  									{  									slowDownToBreakPoint = true;  									}  								}  							// The new vehicle in front is too close => slow down  							else  								{  								slowDownToBreakPoint = true;  								}  							}    						if (slowDownToBreakPoint)  							{  							double percentOfLCILeft = Math.Max(0.2' (lci.endArcPos - currentPosition - Constants.breakPointBeforeForcedLineChange) / (lci.length - Constants.breakPointBeforeForcedLineChange));    							// slow down a bit  							_physics.multiplierTargetVelocity = Math.Min(0.9' 1.5 * percentOfLCILeft);    							// When reaching the end of the LineChangeInterval' check whether there are other possibilities to reach the target:  							if (percentOfLCILeft < 0.5)  								{  								Routing newRTT = Routing.CalculateShortestConenction(route[0].endNode' _targetNodes' _vehicleType);  								// The alternative route does not cost too much -> choose it  								if (newRTT.SegmentCount() > 0 && newRTT.costs / _wayToGo.costs < Constants.maxRatioForEnforcedLineChange)  									{  									_wayToGo = newRTT;  									_physics.multiplierTargetVelocity = 1;  									lineChangeNeeded = false;  									lci = null;  									}  								}  							// Line change still necessacy => stop at break point  							if (lineChangeNeeded)  								{  								if (! _state.letVehicleChangeLine && percentOfLCILeft < 0.8)  									{  									VehicleDistance otherBehind = lcp.otherStart.nc.GetVehicleBeforeArcPosition(myArcPositionOnOtherConnection - ((_length + s0))' Constants.lookaheadDistance);    									// In rare cases deadlocks may appear when a very long and a short vehicle are driving parallel to each other (and both want to change line):  									// Then' none of the two finds a vehicle behind on the parallel connection. Hence' none of the two will wait for the other one  									// and both might drive to the end of the line change interval and there block each other.  									// To avoid this case' if there is no otherBehind' we also look for a parallel vehicle in front of our back (there should be one' otherwise  									// something went terribly wrong above). The longer one of the two will wait for the shorter one to make sure' no deadlock will occur.  									if (otherBehind == null)  										{  										VehicleDistance otherFront = lcp.otherStart.nc.GetVehicleBehindArcPosition(myArcPositionOnOtherConnection - ((_length + s0))' Constants.lookaheadDistance);  										if (otherFront.vehicle.lineChangeNeeded && otherFront.vehicle._length > _length)  											{  											otherBehind = otherFront;  											otherBehind.distance *= -1;  											}  										}    									//Pair<VehicleDistance> vd = lcp.otherStart.nc.GetVehiclesAroundArcPosition(myArcPositionOnOtherConnection - ( (_length + s0))' Constants.lookaheadDistance);  									if (otherBehind != null)// && otherBehind.vehicle.p >= p)  										{  										// tell the vehicle behind my back to wait for me  										_state.SetLineChangeVehicleInteraction(this' otherBehind.vehicle' lcp.otherStart.nc' myArcPositionOnOtherConnection - _length);    										// In addition' I need to get behind the vehicle in front of the vehicle which waits for me. Therefore I adapt the desired velocity  										if (_state.vehicleThatLetsMeChangeLine != null)  											{  											VehicleDistance otherBehindForman = _state.vehicleThatLetsMeChangeLine.currentNodeConnection.GetVehicleBehindArcPosition(_state.vehicleThatLetsMeChangeLine.currentPosition' 2 * (length + s0));  											if (otherBehindForman != null)  												{  												//_physics.multiplierTargetVelocity = Math2.Clamp(Math2.Cubic((otherBehindForman.distance - otherBehind.distance - s0) / (_length + 4 * s0))' 0.3' 1);  												double multPerDistance = 1 - Math2.Clamp((otherBehind.distance + _length + s0 - otherBehindForman.distance + otherBehindForman.vehicle._length + s0) / (otherBehindForman.vehicle._length)' 0.2' 0.75);  												double multPerSpeedDiff = Math2.Clamp((otherBehindForman.vehicle._physics.velocity - _physics.velocity) / 2' 0.25' 0.8);  												_physics.multiplierTargetVelocity = Math.Min(multPerDistance' multPerSpeedDiff);  												}  											}  										}  									}    								lowestAcceleration = Math.Min(lowestAcceleration' CalculateAcceleration(physics.velocity' effectiveDesiredVelocity' lci.endArcPos - Constants.breakPointBeforeForcedLineChange - arcPos' physics.velocity));  								}  							}  						}  					}  				else if (_state.vehicleThatLetsMeChangeLine != null)  					{  					_state.UnsetLineChangeVehicleInteraction();  					}    				#endregion    				#region freiwillig    				thinkAboutLineChange &= ((GlobalTime.Instance.currentTime - lastLineChangeCheck.Left > 1) || (currentPosition - lastLineChangeCheck.Right > 50));    				if (thinkAboutLineChange && !currentlyChangingLine)  					{  					lastLineChangeCheck.Left = GlobalTime.Instance.currentTime;  					lastLineChangeCheck.Right = currentPosition;    					// get current LineChangePoint and check' whether it's reachable  					NodeConnection.LineChangePoint lcp = route[0].GetPrevLineChangePoint(arcPos);  					if ((lcp.target.nc != null) && (Math.Abs(arcPos - lcp.start.arcPosition) < Constants.maxDistanceToLineChangePoint * 0.67))  						{  						// check whether there is an alternative route that is not too costly  						Routing alternativeRoute = Routing.CalculateShortestConenction(lcp.target.nc.endNode' targetNodes' _vehicleType);  						if (alternativeRoute.SegmentCount() > 0 && alternativeRoute.costs / wayToGo.costs < Constants.maxRatioForVoluntaryLineChange && !alternativeRoute.Top().lineChangeNeeded)  							{  							double myArcPositionOnOtherConnection = lcp.otherStart.arcPosition + (arcPos - lcp.start.arcPosition);  							if (myArcPositionOnOtherConnection >= 0)  								{  								// Check the relation to my surrounding vehicles on the target NodeConnection  								Pair<VehicleDistance> otherVehicles = lcp.otherStart.nc.GetVehiclesAroundArcPosition(myArcPositionOnOtherConnection' Constants.lookaheadDistance);    								// the new vehicle in front wouldn't be too close  								if (   otherVehicles.Right == null  									|| otherVehicles.Right.distance > otherVehicles.Right.vehicle.length + 2 * lcp.length)  									{  									// the new vehicle behind wouldn't be too close  									if (   otherVehicles.Left == null  										|| otherVehicles.Left.distance > length + otherVehicles.Left.vehicle.CalculateWantedDistance(otherVehicles.Left.vehicle.physics.velocity' otherVehicles.Left.vehicle.physics.velocity - physics.velocity)/2)  										{  										List<NodeConnection> l = new List<NodeConnection>();  										l.Add(lcp.target.nc);  										foreach (Routing.RouteSegment rs in alternativeRoute)  											l.Add(rs.startConnection);    										// calculate my necessary acceleration in case of a line change  										double myAccelerationOnOtherConnection = (otherVehicles.Right != null)  											? CalculateAcceleration(physics.velocity' effectiveDesiredVelocity' otherVehicles.Right.vehicle.currentPosition - myArcPositionOnOtherConnection' physics.velocity - otherVehicles.Right.vehicle.physics.velocity)  											: CalculateAcceleration(physics.velocity' effectiveDesiredVelocity' GetDistanceToNextTrafficLightOnRoute(l' myArcPositionOnOtherConnection' Constants.lookaheadDistance' true)' physics.velocity);    										// calculate the necessary acceleration of the vehicle behind in case of a line change  										double forcedAccelerationOfVehicleBehindMeOnOtherConnection = (otherVehicles.Left != null)  											? CalculateAcceleration(otherVehicles.Left.vehicle.physics.velocity' otherVehicles.Left.vehicle.effectiveDesiredVelocity' otherVehicles.Left.distance' otherVehicles.Left.vehicle.physics.velocity - physics.velocity)  											: 0;    										double currentAccelerationOfVehicleBehindMeOnOtherConnection = (otherVehicles.Left != null) ? otherVehicles.Left.vehicle.physics.acceleration : 0;    										// simplified implementation of MOBIL: http://www.vwi.tu-dresden.de/~treiber/MicroApplet/MOBIL.html  										if (forcedAccelerationOfVehicleBehindMeOnOtherConnection > bSave)  											{  											if (myAccelerationOnOtherConnection - lowestAcceleration > p * (currentAccelerationOfVehicleBehindMeOnOtherConnection - forcedAccelerationOfVehicleBehindMeOnOtherConnection) + lineChangeThreshold)  												{  												// initiate the line change  												InitiateLineChange(lcp' arcPos - lcp.start.arcPosition);  												lowestAcceleration = myAccelerationOnOtherConnection;  												}  											}  										}  									}  								}  							}  						}  					}    				#endregion    				}
Magic Number,CityTrafficSimulator.Vehicle,IVehicle,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\IVehicle.cs,Think,The following statement contains a magic number: if (!onlySimpleCalculations)  				{  				#region Forced line changes    				// our route forces to perform a line change  				if (lineChangeNeeded && !currentlyChangingLine && lci != null)  					{  					thinkAboutLineChange = false;  					lastLineChangeCheck.Left = GlobalTime.Instance.currentTime;  					lastLineChangeCheck.Right = currentPosition;    					// get current LineChangePoint and check' whether it's leading to our target  					NodeConnection.LineChangePoint lcp = route[0].GetPrevLineChangePoint(arcPos);  					if (lci.targetNode.prevConnections.Contains(lcp.target.nc))  						{  						bool slowDownToBreakPoint = false;  						double myArcPositionOnOtherConnection = lcp.otherStart.arcPosition + (arcPos - lcp.start.arcPosition);    						// check if found LineChangePoint is not too far away to perform the line change  						if ((myArcPositionOnOtherConnection >= 0) && (Math.Abs(arcPos - lcp.start.arcPosition) < Constants.maxDistanceToLineChangePoint * 1.25))  							{  							// Check the relation to my surrounding vehicles on the target NodeConnection  							Pair<VehicleDistance> otherVehicles = lcp.otherStart.nc.GetVehiclesAroundArcPosition(myArcPositionOnOtherConnection' Constants.lookaheadDistance);    							// the new vehicle in front wouldn't be too close  							if (   otherVehicles.Right == null  								|| otherVehicles.Right.distance > otherVehicles.Right.vehicle.length + CalculateWantedDistance(physics.velocity' physics.velocity - otherVehicles.Right.vehicle.physics.velocity)/2)  								{  								// the new vehicle behind wouldn't be too close  								if (   otherVehicles.Left == null  									|| otherVehicles.Left.distance > length + otherVehicles.Left.vehicle.CalculateWantedDistance(otherVehicles.Left.vehicle.physics.velocity' otherVehicles.Left.vehicle.physics.velocity - physics.velocity)/2)  									{  									// calculate my necessary acceleration in case of a line change  									double myAccelerationOnOtherConnection = (otherVehicles.Right != null)  										? CalculateAcceleration(physics.velocity' effectiveDesiredVelocity' otherVehicles.Right.vehicle.currentPosition - myArcPositionOnOtherConnection' physics.velocity - otherVehicles.Right.vehicle.physics.velocity)  										: CalculateAcceleration(physics.velocity' effectiveDesiredVelocity' lookaheadDistance' physics.velocity);    									// calculate the necessary acceleration of the vehicle behind in case of a line change  									double forcedAccelerationOfVehicleBehindMeOnOtherConnection = (otherVehicles.Left != null)  										? CalculateAcceleration(otherVehicles.Left.vehicle.physics.velocity' otherVehicles.Left.vehicle.effectiveDesiredVelocity' otherVehicles.Left.distance' otherVehicles.Left.vehicle.physics.velocity - physics.velocity)  										: 0;    									double currentAccelerationOfVehicleBehindMeOnOtherConnection = (otherVehicles.Left != null) ? otherVehicles.Left.vehicle.physics.acceleration : 0;    									// Final check:  									//  - The new vehicle behind must not break harder than bSave  									//  - My line change must be sufficiently necessary. The closer I come to the end of the LineChangeInterval' the more I may thwart the vehicle behind.   									if (   (forcedAccelerationOfVehicleBehindMeOnOtherConnection > bSave)  										&& ((arcPos - lci.startArcPos) / lci.length >= (currentAccelerationOfVehicleBehindMeOnOtherConnection - forcedAccelerationOfVehicleBehindMeOnOtherConnection)))  										{  										// return to normal velocity  										_physics.multiplierTargetVelocity = 1;    										// initiate the line change  										InitiateLineChange(lcp' arcPos - lcp.start.arcPosition);  										lowestAcceleration = myAccelerationOnOtherConnection;  										}  									// I do not want to change line yet' but I could position myself better between the two other vehicles on the parallel line.  									else if (true)  										{  										// TODO: implement  										slowDownToBreakPoint = true;  										}  									}  								// the new vehicle behind would too close but I can accelerate and are at least as fast as him  								else if (   otherVehicles.Left.vehicle.physics.velocity / this.physics.velocity < 1.2  // I am not significantly slower than him  										 && (otherVehicles.Right == null || otherVehicles.Right.distance > 1.5 * length) // the new vehicle in front is far enough away  										 && lookaheadDistance > 2 * length			// no vehicle/traffic light/intersection in front  										 && lci.endArcPos - arcPos > 2 * length		// enough space left in LineChangeInterval  										 && lowestAcceleration >= -0.1)				// currently not braking  									{  									// accelerate to get in front  									_physics.multiplierTargetVelocity = 1.75;  									lowestAcceleration = Math.Min(lowestAcceleration' CalculateAcceleration(physics.velocity' effectiveDesiredVelocity' lookaheadDistance' physics.velocity));    									_state.SetLineChangeVehicleInteraction(this' otherVehicles.Left.vehicle' lcp.otherStart.nc' myArcPositionOnOtherConnection - _length);  									}  								// There is no way to perform a line change now => slow down  								else  									{  									slowDownToBreakPoint = true;  									}  								}  							// The new vehicle in front is too close => slow down  							else  								{  								slowDownToBreakPoint = true;  								}  							}    						if (slowDownToBreakPoint)  							{  							double percentOfLCILeft = Math.Max(0.2' (lci.endArcPos - currentPosition - Constants.breakPointBeforeForcedLineChange) / (lci.length - Constants.breakPointBeforeForcedLineChange));    							// slow down a bit  							_physics.multiplierTargetVelocity = Math.Min(0.9' 1.5 * percentOfLCILeft);    							// When reaching the end of the LineChangeInterval' check whether there are other possibilities to reach the target:  							if (percentOfLCILeft < 0.5)  								{  								Routing newRTT = Routing.CalculateShortestConenction(route[0].endNode' _targetNodes' _vehicleType);  								// The alternative route does not cost too much -> choose it  								if (newRTT.SegmentCount() > 0 && newRTT.costs / _wayToGo.costs < Constants.maxRatioForEnforcedLineChange)  									{  									_wayToGo = newRTT;  									_physics.multiplierTargetVelocity = 1;  									lineChangeNeeded = false;  									lci = null;  									}  								}  							// Line change still necessacy => stop at break point  							if (lineChangeNeeded)  								{  								if (! _state.letVehicleChangeLine && percentOfLCILeft < 0.8)  									{  									VehicleDistance otherBehind = lcp.otherStart.nc.GetVehicleBeforeArcPosition(myArcPositionOnOtherConnection - ((_length + s0))' Constants.lookaheadDistance);    									// In rare cases deadlocks may appear when a very long and a short vehicle are driving parallel to each other (and both want to change line):  									// Then' none of the two finds a vehicle behind on the parallel connection. Hence' none of the two will wait for the other one  									// and both might drive to the end of the line change interval and there block each other.  									// To avoid this case' if there is no otherBehind' we also look for a parallel vehicle in front of our back (there should be one' otherwise  									// something went terribly wrong above). The longer one of the two will wait for the shorter one to make sure' no deadlock will occur.  									if (otherBehind == null)  										{  										VehicleDistance otherFront = lcp.otherStart.nc.GetVehicleBehindArcPosition(myArcPositionOnOtherConnection - ((_length + s0))' Constants.lookaheadDistance);  										if (otherFront.vehicle.lineChangeNeeded && otherFront.vehicle._length > _length)  											{  											otherBehind = otherFront;  											otherBehind.distance *= -1;  											}  										}    									//Pair<VehicleDistance> vd = lcp.otherStart.nc.GetVehiclesAroundArcPosition(myArcPositionOnOtherConnection - ( (_length + s0))' Constants.lookaheadDistance);  									if (otherBehind != null)// && otherBehind.vehicle.p >= p)  										{  										// tell the vehicle behind my back to wait for me  										_state.SetLineChangeVehicleInteraction(this' otherBehind.vehicle' lcp.otherStart.nc' myArcPositionOnOtherConnection - _length);    										// In addition' I need to get behind the vehicle in front of the vehicle which waits for me. Therefore I adapt the desired velocity  										if (_state.vehicleThatLetsMeChangeLine != null)  											{  											VehicleDistance otherBehindForman = _state.vehicleThatLetsMeChangeLine.currentNodeConnection.GetVehicleBehindArcPosition(_state.vehicleThatLetsMeChangeLine.currentPosition' 2 * (length + s0));  											if (otherBehindForman != null)  												{  												//_physics.multiplierTargetVelocity = Math2.Clamp(Math2.Cubic((otherBehindForman.distance - otherBehind.distance - s0) / (_length + 4 * s0))' 0.3' 1);  												double multPerDistance = 1 - Math2.Clamp((otherBehind.distance + _length + s0 - otherBehindForman.distance + otherBehindForman.vehicle._length + s0) / (otherBehindForman.vehicle._length)' 0.2' 0.75);  												double multPerSpeedDiff = Math2.Clamp((otherBehindForman.vehicle._physics.velocity - _physics.velocity) / 2' 0.25' 0.8);  												_physics.multiplierTargetVelocity = Math.Min(multPerDistance' multPerSpeedDiff);  												}  											}  										}  									}    								lowestAcceleration = Math.Min(lowestAcceleration' CalculateAcceleration(physics.velocity' effectiveDesiredVelocity' lci.endArcPos - Constants.breakPointBeforeForcedLineChange - arcPos' physics.velocity));  								}  							}  						}  					}  				else if (_state.vehicleThatLetsMeChangeLine != null)  					{  					_state.UnsetLineChangeVehicleInteraction();  					}    				#endregion    				#region freiwillig    				thinkAboutLineChange &= ((GlobalTime.Instance.currentTime - lastLineChangeCheck.Left > 1) || (currentPosition - lastLineChangeCheck.Right > 50));    				if (thinkAboutLineChange && !currentlyChangingLine)  					{  					lastLineChangeCheck.Left = GlobalTime.Instance.currentTime;  					lastLineChangeCheck.Right = currentPosition;    					// get current LineChangePoint and check' whether it's reachable  					NodeConnection.LineChangePoint lcp = route[0].GetPrevLineChangePoint(arcPos);  					if ((lcp.target.nc != null) && (Math.Abs(arcPos - lcp.start.arcPosition) < Constants.maxDistanceToLineChangePoint * 0.67))  						{  						// check whether there is an alternative route that is not too costly  						Routing alternativeRoute = Routing.CalculateShortestConenction(lcp.target.nc.endNode' targetNodes' _vehicleType);  						if (alternativeRoute.SegmentCount() > 0 && alternativeRoute.costs / wayToGo.costs < Constants.maxRatioForVoluntaryLineChange && !alternativeRoute.Top().lineChangeNeeded)  							{  							double myArcPositionOnOtherConnection = lcp.otherStart.arcPosition + (arcPos - lcp.start.arcPosition);  							if (myArcPositionOnOtherConnection >= 0)  								{  								// Check the relation to my surrounding vehicles on the target NodeConnection  								Pair<VehicleDistance> otherVehicles = lcp.otherStart.nc.GetVehiclesAroundArcPosition(myArcPositionOnOtherConnection' Constants.lookaheadDistance);    								// the new vehicle in front wouldn't be too close  								if (   otherVehicles.Right == null  									|| otherVehicles.Right.distance > otherVehicles.Right.vehicle.length + 2 * lcp.length)  									{  									// the new vehicle behind wouldn't be too close  									if (   otherVehicles.Left == null  										|| otherVehicles.Left.distance > length + otherVehicles.Left.vehicle.CalculateWantedDistance(otherVehicles.Left.vehicle.physics.velocity' otherVehicles.Left.vehicle.physics.velocity - physics.velocity)/2)  										{  										List<NodeConnection> l = new List<NodeConnection>();  										l.Add(lcp.target.nc);  										foreach (Routing.RouteSegment rs in alternativeRoute)  											l.Add(rs.startConnection);    										// calculate my necessary acceleration in case of a line change  										double myAccelerationOnOtherConnection = (otherVehicles.Right != null)  											? CalculateAcceleration(physics.velocity' effectiveDesiredVelocity' otherVehicles.Right.vehicle.currentPosition - myArcPositionOnOtherConnection' physics.velocity - otherVehicles.Right.vehicle.physics.velocity)  											: CalculateAcceleration(physics.velocity' effectiveDesiredVelocity' GetDistanceToNextTrafficLightOnRoute(l' myArcPositionOnOtherConnection' Constants.lookaheadDistance' true)' physics.velocity);    										// calculate the necessary acceleration of the vehicle behind in case of a line change  										double forcedAccelerationOfVehicleBehindMeOnOtherConnection = (otherVehicles.Left != null)  											? CalculateAcceleration(otherVehicles.Left.vehicle.physics.velocity' otherVehicles.Left.vehicle.effectiveDesiredVelocity' otherVehicles.Left.distance' otherVehicles.Left.vehicle.physics.velocity - physics.velocity)  											: 0;    										double currentAccelerationOfVehicleBehindMeOnOtherConnection = (otherVehicles.Left != null) ? otherVehicles.Left.vehicle.physics.acceleration : 0;    										// simplified implementation of MOBIL: http://www.vwi.tu-dresden.de/~treiber/MicroApplet/MOBIL.html  										if (forcedAccelerationOfVehicleBehindMeOnOtherConnection > bSave)  											{  											if (myAccelerationOnOtherConnection - lowestAcceleration > p * (currentAccelerationOfVehicleBehindMeOnOtherConnection - forcedAccelerationOfVehicleBehindMeOnOtherConnection) + lineChangeThreshold)  												{  												// initiate the line change  												InitiateLineChange(lcp' arcPos - lcp.start.arcPosition);  												lowestAcceleration = myAccelerationOnOtherConnection;  												}  											}  										}  									}  								}  							}  						}  					}    				#endregion    				}
Magic Number,CityTrafficSimulator.Vehicle,IVehicle,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\IVehicle.cs,Think,The following statement contains a magic number: if (!onlySimpleCalculations)  				{  				#region Forced line changes    				// our route forces to perform a line change  				if (lineChangeNeeded && !currentlyChangingLine && lci != null)  					{  					thinkAboutLineChange = false;  					lastLineChangeCheck.Left = GlobalTime.Instance.currentTime;  					lastLineChangeCheck.Right = currentPosition;    					// get current LineChangePoint and check' whether it's leading to our target  					NodeConnection.LineChangePoint lcp = route[0].GetPrevLineChangePoint(arcPos);  					if (lci.targetNode.prevConnections.Contains(lcp.target.nc))  						{  						bool slowDownToBreakPoint = false;  						double myArcPositionOnOtherConnection = lcp.otherStart.arcPosition + (arcPos - lcp.start.arcPosition);    						// check if found LineChangePoint is not too far away to perform the line change  						if ((myArcPositionOnOtherConnection >= 0) && (Math.Abs(arcPos - lcp.start.arcPosition) < Constants.maxDistanceToLineChangePoint * 1.25))  							{  							// Check the relation to my surrounding vehicles on the target NodeConnection  							Pair<VehicleDistance> otherVehicles = lcp.otherStart.nc.GetVehiclesAroundArcPosition(myArcPositionOnOtherConnection' Constants.lookaheadDistance);    							// the new vehicle in front wouldn't be too close  							if (   otherVehicles.Right == null  								|| otherVehicles.Right.distance > otherVehicles.Right.vehicle.length + CalculateWantedDistance(physics.velocity' physics.velocity - otherVehicles.Right.vehicle.physics.velocity)/2)  								{  								// the new vehicle behind wouldn't be too close  								if (   otherVehicles.Left == null  									|| otherVehicles.Left.distance > length + otherVehicles.Left.vehicle.CalculateWantedDistance(otherVehicles.Left.vehicle.physics.velocity' otherVehicles.Left.vehicle.physics.velocity - physics.velocity)/2)  									{  									// calculate my necessary acceleration in case of a line change  									double myAccelerationOnOtherConnection = (otherVehicles.Right != null)  										? CalculateAcceleration(physics.velocity' effectiveDesiredVelocity' otherVehicles.Right.vehicle.currentPosition - myArcPositionOnOtherConnection' physics.velocity - otherVehicles.Right.vehicle.physics.velocity)  										: CalculateAcceleration(physics.velocity' effectiveDesiredVelocity' lookaheadDistance' physics.velocity);    									// calculate the necessary acceleration of the vehicle behind in case of a line change  									double forcedAccelerationOfVehicleBehindMeOnOtherConnection = (otherVehicles.Left != null)  										? CalculateAcceleration(otherVehicles.Left.vehicle.physics.velocity' otherVehicles.Left.vehicle.effectiveDesiredVelocity' otherVehicles.Left.distance' otherVehicles.Left.vehicle.physics.velocity - physics.velocity)  										: 0;    									double currentAccelerationOfVehicleBehindMeOnOtherConnection = (otherVehicles.Left != null) ? otherVehicles.Left.vehicle.physics.acceleration : 0;    									// Final check:  									//  - The new vehicle behind must not break harder than bSave  									//  - My line change must be sufficiently necessary. The closer I come to the end of the LineChangeInterval' the more I may thwart the vehicle behind.   									if (   (forcedAccelerationOfVehicleBehindMeOnOtherConnection > bSave)  										&& ((arcPos - lci.startArcPos) / lci.length >= (currentAccelerationOfVehicleBehindMeOnOtherConnection - forcedAccelerationOfVehicleBehindMeOnOtherConnection)))  										{  										// return to normal velocity  										_physics.multiplierTargetVelocity = 1;    										// initiate the line change  										InitiateLineChange(lcp' arcPos - lcp.start.arcPosition);  										lowestAcceleration = myAccelerationOnOtherConnection;  										}  									// I do not want to change line yet' but I could position myself better between the two other vehicles on the parallel line.  									else if (true)  										{  										// TODO: implement  										slowDownToBreakPoint = true;  										}  									}  								// the new vehicle behind would too close but I can accelerate and are at least as fast as him  								else if (   otherVehicles.Left.vehicle.physics.velocity / this.physics.velocity < 1.2  // I am not significantly slower than him  										 && (otherVehicles.Right == null || otherVehicles.Right.distance > 1.5 * length) // the new vehicle in front is far enough away  										 && lookaheadDistance > 2 * length			// no vehicle/traffic light/intersection in front  										 && lci.endArcPos - arcPos > 2 * length		// enough space left in LineChangeInterval  										 && lowestAcceleration >= -0.1)				// currently not braking  									{  									// accelerate to get in front  									_physics.multiplierTargetVelocity = 1.75;  									lowestAcceleration = Math.Min(lowestAcceleration' CalculateAcceleration(physics.velocity' effectiveDesiredVelocity' lookaheadDistance' physics.velocity));    									_state.SetLineChangeVehicleInteraction(this' otherVehicles.Left.vehicle' lcp.otherStart.nc' myArcPositionOnOtherConnection - _length);  									}  								// There is no way to perform a line change now => slow down  								else  									{  									slowDownToBreakPoint = true;  									}  								}  							// The new vehicle in front is too close => slow down  							else  								{  								slowDownToBreakPoint = true;  								}  							}    						if (slowDownToBreakPoint)  							{  							double percentOfLCILeft = Math.Max(0.2' (lci.endArcPos - currentPosition - Constants.breakPointBeforeForcedLineChange) / (lci.length - Constants.breakPointBeforeForcedLineChange));    							// slow down a bit  							_physics.multiplierTargetVelocity = Math.Min(0.9' 1.5 * percentOfLCILeft);    							// When reaching the end of the LineChangeInterval' check whether there are other possibilities to reach the target:  							if (percentOfLCILeft < 0.5)  								{  								Routing newRTT = Routing.CalculateShortestConenction(route[0].endNode' _targetNodes' _vehicleType);  								// The alternative route does not cost too much -> choose it  								if (newRTT.SegmentCount() > 0 && newRTT.costs / _wayToGo.costs < Constants.maxRatioForEnforcedLineChange)  									{  									_wayToGo = newRTT;  									_physics.multiplierTargetVelocity = 1;  									lineChangeNeeded = false;  									lci = null;  									}  								}  							// Line change still necessacy => stop at break point  							if (lineChangeNeeded)  								{  								if (! _state.letVehicleChangeLine && percentOfLCILeft < 0.8)  									{  									VehicleDistance otherBehind = lcp.otherStart.nc.GetVehicleBeforeArcPosition(myArcPositionOnOtherConnection - ((_length + s0))' Constants.lookaheadDistance);    									// In rare cases deadlocks may appear when a very long and a short vehicle are driving parallel to each other (and both want to change line):  									// Then' none of the two finds a vehicle behind on the parallel connection. Hence' none of the two will wait for the other one  									// and both might drive to the end of the line change interval and there block each other.  									// To avoid this case' if there is no otherBehind' we also look for a parallel vehicle in front of our back (there should be one' otherwise  									// something went terribly wrong above). The longer one of the two will wait for the shorter one to make sure' no deadlock will occur.  									if (otherBehind == null)  										{  										VehicleDistance otherFront = lcp.otherStart.nc.GetVehicleBehindArcPosition(myArcPositionOnOtherConnection - ((_length + s0))' Constants.lookaheadDistance);  										if (otherFront.vehicle.lineChangeNeeded && otherFront.vehicle._length > _length)  											{  											otherBehind = otherFront;  											otherBehind.distance *= -1;  											}  										}    									//Pair<VehicleDistance> vd = lcp.otherStart.nc.GetVehiclesAroundArcPosition(myArcPositionOnOtherConnection - ( (_length + s0))' Constants.lookaheadDistance);  									if (otherBehind != null)// && otherBehind.vehicle.p >= p)  										{  										// tell the vehicle behind my back to wait for me  										_state.SetLineChangeVehicleInteraction(this' otherBehind.vehicle' lcp.otherStart.nc' myArcPositionOnOtherConnection - _length);    										// In addition' I need to get behind the vehicle in front of the vehicle which waits for me. Therefore I adapt the desired velocity  										if (_state.vehicleThatLetsMeChangeLine != null)  											{  											VehicleDistance otherBehindForman = _state.vehicleThatLetsMeChangeLine.currentNodeConnection.GetVehicleBehindArcPosition(_state.vehicleThatLetsMeChangeLine.currentPosition' 2 * (length + s0));  											if (otherBehindForman != null)  												{  												//_physics.multiplierTargetVelocity = Math2.Clamp(Math2.Cubic((otherBehindForman.distance - otherBehind.distance - s0) / (_length + 4 * s0))' 0.3' 1);  												double multPerDistance = 1 - Math2.Clamp((otherBehind.distance + _length + s0 - otherBehindForman.distance + otherBehindForman.vehicle._length + s0) / (otherBehindForman.vehicle._length)' 0.2' 0.75);  												double multPerSpeedDiff = Math2.Clamp((otherBehindForman.vehicle._physics.velocity - _physics.velocity) / 2' 0.25' 0.8);  												_physics.multiplierTargetVelocity = Math.Min(multPerDistance' multPerSpeedDiff);  												}  											}  										}  									}    								lowestAcceleration = Math.Min(lowestAcceleration' CalculateAcceleration(physics.velocity' effectiveDesiredVelocity' lci.endArcPos - Constants.breakPointBeforeForcedLineChange - arcPos' physics.velocity));  								}  							}  						}  					}  				else if (_state.vehicleThatLetsMeChangeLine != null)  					{  					_state.UnsetLineChangeVehicleInteraction();  					}    				#endregion    				#region freiwillig    				thinkAboutLineChange &= ((GlobalTime.Instance.currentTime - lastLineChangeCheck.Left > 1) || (currentPosition - lastLineChangeCheck.Right > 50));    				if (thinkAboutLineChange && !currentlyChangingLine)  					{  					lastLineChangeCheck.Left = GlobalTime.Instance.currentTime;  					lastLineChangeCheck.Right = currentPosition;    					// get current LineChangePoint and check' whether it's reachable  					NodeConnection.LineChangePoint lcp = route[0].GetPrevLineChangePoint(arcPos);  					if ((lcp.target.nc != null) && (Math.Abs(arcPos - lcp.start.arcPosition) < Constants.maxDistanceToLineChangePoint * 0.67))  						{  						// check whether there is an alternative route that is not too costly  						Routing alternativeRoute = Routing.CalculateShortestConenction(lcp.target.nc.endNode' targetNodes' _vehicleType);  						if (alternativeRoute.SegmentCount() > 0 && alternativeRoute.costs / wayToGo.costs < Constants.maxRatioForVoluntaryLineChange && !alternativeRoute.Top().lineChangeNeeded)  							{  							double myArcPositionOnOtherConnection = lcp.otherStart.arcPosition + (arcPos - lcp.start.arcPosition);  							if (myArcPositionOnOtherConnection >= 0)  								{  								// Check the relation to my surrounding vehicles on the target NodeConnection  								Pair<VehicleDistance> otherVehicles = lcp.otherStart.nc.GetVehiclesAroundArcPosition(myArcPositionOnOtherConnection' Constants.lookaheadDistance);    								// the new vehicle in front wouldn't be too close  								if (   otherVehicles.Right == null  									|| otherVehicles.Right.distance > otherVehicles.Right.vehicle.length + 2 * lcp.length)  									{  									// the new vehicle behind wouldn't be too close  									if (   otherVehicles.Left == null  										|| otherVehicles.Left.distance > length + otherVehicles.Left.vehicle.CalculateWantedDistance(otherVehicles.Left.vehicle.physics.velocity' otherVehicles.Left.vehicle.physics.velocity - physics.velocity)/2)  										{  										List<NodeConnection> l = new List<NodeConnection>();  										l.Add(lcp.target.nc);  										foreach (Routing.RouteSegment rs in alternativeRoute)  											l.Add(rs.startConnection);    										// calculate my necessary acceleration in case of a line change  										double myAccelerationOnOtherConnection = (otherVehicles.Right != null)  											? CalculateAcceleration(physics.velocity' effectiveDesiredVelocity' otherVehicles.Right.vehicle.currentPosition - myArcPositionOnOtherConnection' physics.velocity - otherVehicles.Right.vehicle.physics.velocity)  											: CalculateAcceleration(physics.velocity' effectiveDesiredVelocity' GetDistanceToNextTrafficLightOnRoute(l' myArcPositionOnOtherConnection' Constants.lookaheadDistance' true)' physics.velocity);    										// calculate the necessary acceleration of the vehicle behind in case of a line change  										double forcedAccelerationOfVehicleBehindMeOnOtherConnection = (otherVehicles.Left != null)  											? CalculateAcceleration(otherVehicles.Left.vehicle.physics.velocity' otherVehicles.Left.vehicle.effectiveDesiredVelocity' otherVehicles.Left.distance' otherVehicles.Left.vehicle.physics.velocity - physics.velocity)  											: 0;    										double currentAccelerationOfVehicleBehindMeOnOtherConnection = (otherVehicles.Left != null) ? otherVehicles.Left.vehicle.physics.acceleration : 0;    										// simplified implementation of MOBIL: http://www.vwi.tu-dresden.de/~treiber/MicroApplet/MOBIL.html  										if (forcedAccelerationOfVehicleBehindMeOnOtherConnection > bSave)  											{  											if (myAccelerationOnOtherConnection - lowestAcceleration > p * (currentAccelerationOfVehicleBehindMeOnOtherConnection - forcedAccelerationOfVehicleBehindMeOnOtherConnection) + lineChangeThreshold)  												{  												// initiate the line change  												InitiateLineChange(lcp' arcPos - lcp.start.arcPosition);  												lowestAcceleration = myAccelerationOnOtherConnection;  												}  											}  										}  									}  								}  							}  						}  					}    				#endregion    				}
Magic Number,CityTrafficSimulator.Vehicle,IVehicle,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\IVehicle.cs,Think,The following statement contains a magic number: if (!onlySimpleCalculations)  				{  				#region Forced line changes    				// our route forces to perform a line change  				if (lineChangeNeeded && !currentlyChangingLine && lci != null)  					{  					thinkAboutLineChange = false;  					lastLineChangeCheck.Left = GlobalTime.Instance.currentTime;  					lastLineChangeCheck.Right = currentPosition;    					// get current LineChangePoint and check' whether it's leading to our target  					NodeConnection.LineChangePoint lcp = route[0].GetPrevLineChangePoint(arcPos);  					if (lci.targetNode.prevConnections.Contains(lcp.target.nc))  						{  						bool slowDownToBreakPoint = false;  						double myArcPositionOnOtherConnection = lcp.otherStart.arcPosition + (arcPos - lcp.start.arcPosition);    						// check if found LineChangePoint is not too far away to perform the line change  						if ((myArcPositionOnOtherConnection >= 0) && (Math.Abs(arcPos - lcp.start.arcPosition) < Constants.maxDistanceToLineChangePoint * 1.25))  							{  							// Check the relation to my surrounding vehicles on the target NodeConnection  							Pair<VehicleDistance> otherVehicles = lcp.otherStart.nc.GetVehiclesAroundArcPosition(myArcPositionOnOtherConnection' Constants.lookaheadDistance);    							// the new vehicle in front wouldn't be too close  							if (   otherVehicles.Right == null  								|| otherVehicles.Right.distance > otherVehicles.Right.vehicle.length + CalculateWantedDistance(physics.velocity' physics.velocity - otherVehicles.Right.vehicle.physics.velocity)/2)  								{  								// the new vehicle behind wouldn't be too close  								if (   otherVehicles.Left == null  									|| otherVehicles.Left.distance > length + otherVehicles.Left.vehicle.CalculateWantedDistance(otherVehicles.Left.vehicle.physics.velocity' otherVehicles.Left.vehicle.physics.velocity - physics.velocity)/2)  									{  									// calculate my necessary acceleration in case of a line change  									double myAccelerationOnOtherConnection = (otherVehicles.Right != null)  										? CalculateAcceleration(physics.velocity' effectiveDesiredVelocity' otherVehicles.Right.vehicle.currentPosition - myArcPositionOnOtherConnection' physics.velocity - otherVehicles.Right.vehicle.physics.velocity)  										: CalculateAcceleration(physics.velocity' effectiveDesiredVelocity' lookaheadDistance' physics.velocity);    									// calculate the necessary acceleration of the vehicle behind in case of a line change  									double forcedAccelerationOfVehicleBehindMeOnOtherConnection = (otherVehicles.Left != null)  										? CalculateAcceleration(otherVehicles.Left.vehicle.physics.velocity' otherVehicles.Left.vehicle.effectiveDesiredVelocity' otherVehicles.Left.distance' otherVehicles.Left.vehicle.physics.velocity - physics.velocity)  										: 0;    									double currentAccelerationOfVehicleBehindMeOnOtherConnection = (otherVehicles.Left != null) ? otherVehicles.Left.vehicle.physics.acceleration : 0;    									// Final check:  									//  - The new vehicle behind must not break harder than bSave  									//  - My line change must be sufficiently necessary. The closer I come to the end of the LineChangeInterval' the more I may thwart the vehicle behind.   									if (   (forcedAccelerationOfVehicleBehindMeOnOtherConnection > bSave)  										&& ((arcPos - lci.startArcPos) / lci.length >= (currentAccelerationOfVehicleBehindMeOnOtherConnection - forcedAccelerationOfVehicleBehindMeOnOtherConnection)))  										{  										// return to normal velocity  										_physics.multiplierTargetVelocity = 1;    										// initiate the line change  										InitiateLineChange(lcp' arcPos - lcp.start.arcPosition);  										lowestAcceleration = myAccelerationOnOtherConnection;  										}  									// I do not want to change line yet' but I could position myself better between the two other vehicles on the parallel line.  									else if (true)  										{  										// TODO: implement  										slowDownToBreakPoint = true;  										}  									}  								// the new vehicle behind would too close but I can accelerate and are at least as fast as him  								else if (   otherVehicles.Left.vehicle.physics.velocity / this.physics.velocity < 1.2  // I am not significantly slower than him  										 && (otherVehicles.Right == null || otherVehicles.Right.distance > 1.5 * length) // the new vehicle in front is far enough away  										 && lookaheadDistance > 2 * length			// no vehicle/traffic light/intersection in front  										 && lci.endArcPos - arcPos > 2 * length		// enough space left in LineChangeInterval  										 && lowestAcceleration >= -0.1)				// currently not braking  									{  									// accelerate to get in front  									_physics.multiplierTargetVelocity = 1.75;  									lowestAcceleration = Math.Min(lowestAcceleration' CalculateAcceleration(physics.velocity' effectiveDesiredVelocity' lookaheadDistance' physics.velocity));    									_state.SetLineChangeVehicleInteraction(this' otherVehicles.Left.vehicle' lcp.otherStart.nc' myArcPositionOnOtherConnection - _length);  									}  								// There is no way to perform a line change now => slow down  								else  									{  									slowDownToBreakPoint = true;  									}  								}  							// The new vehicle in front is too close => slow down  							else  								{  								slowDownToBreakPoint = true;  								}  							}    						if (slowDownToBreakPoint)  							{  							double percentOfLCILeft = Math.Max(0.2' (lci.endArcPos - currentPosition - Constants.breakPointBeforeForcedLineChange) / (lci.length - Constants.breakPointBeforeForcedLineChange));    							// slow down a bit  							_physics.multiplierTargetVelocity = Math.Min(0.9' 1.5 * percentOfLCILeft);    							// When reaching the end of the LineChangeInterval' check whether there are other possibilities to reach the target:  							if (percentOfLCILeft < 0.5)  								{  								Routing newRTT = Routing.CalculateShortestConenction(route[0].endNode' _targetNodes' _vehicleType);  								// The alternative route does not cost too much -> choose it  								if (newRTT.SegmentCount() > 0 && newRTT.costs / _wayToGo.costs < Constants.maxRatioForEnforcedLineChange)  									{  									_wayToGo = newRTT;  									_physics.multiplierTargetVelocity = 1;  									lineChangeNeeded = false;  									lci = null;  									}  								}  							// Line change still necessacy => stop at break point  							if (lineChangeNeeded)  								{  								if (! _state.letVehicleChangeLine && percentOfLCILeft < 0.8)  									{  									VehicleDistance otherBehind = lcp.otherStart.nc.GetVehicleBeforeArcPosition(myArcPositionOnOtherConnection - ((_length + s0))' Constants.lookaheadDistance);    									// In rare cases deadlocks may appear when a very long and a short vehicle are driving parallel to each other (and both want to change line):  									// Then' none of the two finds a vehicle behind on the parallel connection. Hence' none of the two will wait for the other one  									// and both might drive to the end of the line change interval and there block each other.  									// To avoid this case' if there is no otherBehind' we also look for a parallel vehicle in front of our back (there should be one' otherwise  									// something went terribly wrong above). The longer one of the two will wait for the shorter one to make sure' no deadlock will occur.  									if (otherBehind == null)  										{  										VehicleDistance otherFront = lcp.otherStart.nc.GetVehicleBehindArcPosition(myArcPositionOnOtherConnection - ((_length + s0))' Constants.lookaheadDistance);  										if (otherFront.vehicle.lineChangeNeeded && otherFront.vehicle._length > _length)  											{  											otherBehind = otherFront;  											otherBehind.distance *= -1;  											}  										}    									//Pair<VehicleDistance> vd = lcp.otherStart.nc.GetVehiclesAroundArcPosition(myArcPositionOnOtherConnection - ( (_length + s0))' Constants.lookaheadDistance);  									if (otherBehind != null)// && otherBehind.vehicle.p >= p)  										{  										// tell the vehicle behind my back to wait for me  										_state.SetLineChangeVehicleInteraction(this' otherBehind.vehicle' lcp.otherStart.nc' myArcPositionOnOtherConnection - _length);    										// In addition' I need to get behind the vehicle in front of the vehicle which waits for me. Therefore I adapt the desired velocity  										if (_state.vehicleThatLetsMeChangeLine != null)  											{  											VehicleDistance otherBehindForman = _state.vehicleThatLetsMeChangeLine.currentNodeConnection.GetVehicleBehindArcPosition(_state.vehicleThatLetsMeChangeLine.currentPosition' 2 * (length + s0));  											if (otherBehindForman != null)  												{  												//_physics.multiplierTargetVelocity = Math2.Clamp(Math2.Cubic((otherBehindForman.distance - otherBehind.distance - s0) / (_length + 4 * s0))' 0.3' 1);  												double multPerDistance = 1 - Math2.Clamp((otherBehind.distance + _length + s0 - otherBehindForman.distance + otherBehindForman.vehicle._length + s0) / (otherBehindForman.vehicle._length)' 0.2' 0.75);  												double multPerSpeedDiff = Math2.Clamp((otherBehindForman.vehicle._physics.velocity - _physics.velocity) / 2' 0.25' 0.8);  												_physics.multiplierTargetVelocity = Math.Min(multPerDistance' multPerSpeedDiff);  												}  											}  										}  									}    								lowestAcceleration = Math.Min(lowestAcceleration' CalculateAcceleration(physics.velocity' effectiveDesiredVelocity' lci.endArcPos - Constants.breakPointBeforeForcedLineChange - arcPos' physics.velocity));  								}  							}  						}  					}  				else if (_state.vehicleThatLetsMeChangeLine != null)  					{  					_state.UnsetLineChangeVehicleInteraction();  					}    				#endregion    				#region freiwillig    				thinkAboutLineChange &= ((GlobalTime.Instance.currentTime - lastLineChangeCheck.Left > 1) || (currentPosition - lastLineChangeCheck.Right > 50));    				if (thinkAboutLineChange && !currentlyChangingLine)  					{  					lastLineChangeCheck.Left = GlobalTime.Instance.currentTime;  					lastLineChangeCheck.Right = currentPosition;    					// get current LineChangePoint and check' whether it's reachable  					NodeConnection.LineChangePoint lcp = route[0].GetPrevLineChangePoint(arcPos);  					if ((lcp.target.nc != null) && (Math.Abs(arcPos - lcp.start.arcPosition) < Constants.maxDistanceToLineChangePoint * 0.67))  						{  						// check whether there is an alternative route that is not too costly  						Routing alternativeRoute = Routing.CalculateShortestConenction(lcp.target.nc.endNode' targetNodes' _vehicleType);  						if (alternativeRoute.SegmentCount() > 0 && alternativeRoute.costs / wayToGo.costs < Constants.maxRatioForVoluntaryLineChange && !alternativeRoute.Top().lineChangeNeeded)  							{  							double myArcPositionOnOtherConnection = lcp.otherStart.arcPosition + (arcPos - lcp.start.arcPosition);  							if (myArcPositionOnOtherConnection >= 0)  								{  								// Check the relation to my surrounding vehicles on the target NodeConnection  								Pair<VehicleDistance> otherVehicles = lcp.otherStart.nc.GetVehiclesAroundArcPosition(myArcPositionOnOtherConnection' Constants.lookaheadDistance);    								// the new vehicle in front wouldn't be too close  								if (   otherVehicles.Right == null  									|| otherVehicles.Right.distance > otherVehicles.Right.vehicle.length + 2 * lcp.length)  									{  									// the new vehicle behind wouldn't be too close  									if (   otherVehicles.Left == null  										|| otherVehicles.Left.distance > length + otherVehicles.Left.vehicle.CalculateWantedDistance(otherVehicles.Left.vehicle.physics.velocity' otherVehicles.Left.vehicle.physics.velocity - physics.velocity)/2)  										{  										List<NodeConnection> l = new List<NodeConnection>();  										l.Add(lcp.target.nc);  										foreach (Routing.RouteSegment rs in alternativeRoute)  											l.Add(rs.startConnection);    										// calculate my necessary acceleration in case of a line change  										double myAccelerationOnOtherConnection = (otherVehicles.Right != null)  											? CalculateAcceleration(physics.velocity' effectiveDesiredVelocity' otherVehicles.Right.vehicle.currentPosition - myArcPositionOnOtherConnection' physics.velocity - otherVehicles.Right.vehicle.physics.velocity)  											: CalculateAcceleration(physics.velocity' effectiveDesiredVelocity' GetDistanceToNextTrafficLightOnRoute(l' myArcPositionOnOtherConnection' Constants.lookaheadDistance' true)' physics.velocity);    										// calculate the necessary acceleration of the vehicle behind in case of a line change  										double forcedAccelerationOfVehicleBehindMeOnOtherConnection = (otherVehicles.Left != null)  											? CalculateAcceleration(otherVehicles.Left.vehicle.physics.velocity' otherVehicles.Left.vehicle.effectiveDesiredVelocity' otherVehicles.Left.distance' otherVehicles.Left.vehicle.physics.velocity - physics.velocity)  											: 0;    										double currentAccelerationOfVehicleBehindMeOnOtherConnection = (otherVehicles.Left != null) ? otherVehicles.Left.vehicle.physics.acceleration : 0;    										// simplified implementation of MOBIL: http://www.vwi.tu-dresden.de/~treiber/MicroApplet/MOBIL.html  										if (forcedAccelerationOfVehicleBehindMeOnOtherConnection > bSave)  											{  											if (myAccelerationOnOtherConnection - lowestAcceleration > p * (currentAccelerationOfVehicleBehindMeOnOtherConnection - forcedAccelerationOfVehicleBehindMeOnOtherConnection) + lineChangeThreshold)  												{  												// initiate the line change  												InitiateLineChange(lcp' arcPos - lcp.start.arcPosition);  												lowestAcceleration = myAccelerationOnOtherConnection;  												}  											}  										}  									}  								}  							}  						}  					}    				#endregion    				}
Magic Number,CityTrafficSimulator.Vehicle,IVehicle,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\IVehicle.cs,Think,The following statement contains a magic number: if (!onlySimpleCalculations)  				{  				#region Forced line changes    				// our route forces to perform a line change  				if (lineChangeNeeded && !currentlyChangingLine && lci != null)  					{  					thinkAboutLineChange = false;  					lastLineChangeCheck.Left = GlobalTime.Instance.currentTime;  					lastLineChangeCheck.Right = currentPosition;    					// get current LineChangePoint and check' whether it's leading to our target  					NodeConnection.LineChangePoint lcp = route[0].GetPrevLineChangePoint(arcPos);  					if (lci.targetNode.prevConnections.Contains(lcp.target.nc))  						{  						bool slowDownToBreakPoint = false;  						double myArcPositionOnOtherConnection = lcp.otherStart.arcPosition + (arcPos - lcp.start.arcPosition);    						// check if found LineChangePoint is not too far away to perform the line change  						if ((myArcPositionOnOtherConnection >= 0) && (Math.Abs(arcPos - lcp.start.arcPosition) < Constants.maxDistanceToLineChangePoint * 1.25))  							{  							// Check the relation to my surrounding vehicles on the target NodeConnection  							Pair<VehicleDistance> otherVehicles = lcp.otherStart.nc.GetVehiclesAroundArcPosition(myArcPositionOnOtherConnection' Constants.lookaheadDistance);    							// the new vehicle in front wouldn't be too close  							if (   otherVehicles.Right == null  								|| otherVehicles.Right.distance > otherVehicles.Right.vehicle.length + CalculateWantedDistance(physics.velocity' physics.velocity - otherVehicles.Right.vehicle.physics.velocity)/2)  								{  								// the new vehicle behind wouldn't be too close  								if (   otherVehicles.Left == null  									|| otherVehicles.Left.distance > length + otherVehicles.Left.vehicle.CalculateWantedDistance(otherVehicles.Left.vehicle.physics.velocity' otherVehicles.Left.vehicle.physics.velocity - physics.velocity)/2)  									{  									// calculate my necessary acceleration in case of a line change  									double myAccelerationOnOtherConnection = (otherVehicles.Right != null)  										? CalculateAcceleration(physics.velocity' effectiveDesiredVelocity' otherVehicles.Right.vehicle.currentPosition - myArcPositionOnOtherConnection' physics.velocity - otherVehicles.Right.vehicle.physics.velocity)  										: CalculateAcceleration(physics.velocity' effectiveDesiredVelocity' lookaheadDistance' physics.velocity);    									// calculate the necessary acceleration of the vehicle behind in case of a line change  									double forcedAccelerationOfVehicleBehindMeOnOtherConnection = (otherVehicles.Left != null)  										? CalculateAcceleration(otherVehicles.Left.vehicle.physics.velocity' otherVehicles.Left.vehicle.effectiveDesiredVelocity' otherVehicles.Left.distance' otherVehicles.Left.vehicle.physics.velocity - physics.velocity)  										: 0;    									double currentAccelerationOfVehicleBehindMeOnOtherConnection = (otherVehicles.Left != null) ? otherVehicles.Left.vehicle.physics.acceleration : 0;    									// Final check:  									//  - The new vehicle behind must not break harder than bSave  									//  - My line change must be sufficiently necessary. The closer I come to the end of the LineChangeInterval' the more I may thwart the vehicle behind.   									if (   (forcedAccelerationOfVehicleBehindMeOnOtherConnection > bSave)  										&& ((arcPos - lci.startArcPos) / lci.length >= (currentAccelerationOfVehicleBehindMeOnOtherConnection - forcedAccelerationOfVehicleBehindMeOnOtherConnection)))  										{  										// return to normal velocity  										_physics.multiplierTargetVelocity = 1;    										// initiate the line change  										InitiateLineChange(lcp' arcPos - lcp.start.arcPosition);  										lowestAcceleration = myAccelerationOnOtherConnection;  										}  									// I do not want to change line yet' but I could position myself better between the two other vehicles on the parallel line.  									else if (true)  										{  										// TODO: implement  										slowDownToBreakPoint = true;  										}  									}  								// the new vehicle behind would too close but I can accelerate and are at least as fast as him  								else if (   otherVehicles.Left.vehicle.physics.velocity / this.physics.velocity < 1.2  // I am not significantly slower than him  										 && (otherVehicles.Right == null || otherVehicles.Right.distance > 1.5 * length) // the new vehicle in front is far enough away  										 && lookaheadDistance > 2 * length			// no vehicle/traffic light/intersection in front  										 && lci.endArcPos - arcPos > 2 * length		// enough space left in LineChangeInterval  										 && lowestAcceleration >= -0.1)				// currently not braking  									{  									// accelerate to get in front  									_physics.multiplierTargetVelocity = 1.75;  									lowestAcceleration = Math.Min(lowestAcceleration' CalculateAcceleration(physics.velocity' effectiveDesiredVelocity' lookaheadDistance' physics.velocity));    									_state.SetLineChangeVehicleInteraction(this' otherVehicles.Left.vehicle' lcp.otherStart.nc' myArcPositionOnOtherConnection - _length);  									}  								// There is no way to perform a line change now => slow down  								else  									{  									slowDownToBreakPoint = true;  									}  								}  							// The new vehicle in front is too close => slow down  							else  								{  								slowDownToBreakPoint = true;  								}  							}    						if (slowDownToBreakPoint)  							{  							double percentOfLCILeft = Math.Max(0.2' (lci.endArcPos - currentPosition - Constants.breakPointBeforeForcedLineChange) / (lci.length - Constants.breakPointBeforeForcedLineChange));    							// slow down a bit  							_physics.multiplierTargetVelocity = Math.Min(0.9' 1.5 * percentOfLCILeft);    							// When reaching the end of the LineChangeInterval' check whether there are other possibilities to reach the target:  							if (percentOfLCILeft < 0.5)  								{  								Routing newRTT = Routing.CalculateShortestConenction(route[0].endNode' _targetNodes' _vehicleType);  								// The alternative route does not cost too much -> choose it  								if (newRTT.SegmentCount() > 0 && newRTT.costs / _wayToGo.costs < Constants.maxRatioForEnforcedLineChange)  									{  									_wayToGo = newRTT;  									_physics.multiplierTargetVelocity = 1;  									lineChangeNeeded = false;  									lci = null;  									}  								}  							// Line change still necessacy => stop at break point  							if (lineChangeNeeded)  								{  								if (! _state.letVehicleChangeLine && percentOfLCILeft < 0.8)  									{  									VehicleDistance otherBehind = lcp.otherStart.nc.GetVehicleBeforeArcPosition(myArcPositionOnOtherConnection - ((_length + s0))' Constants.lookaheadDistance);    									// In rare cases deadlocks may appear when a very long and a short vehicle are driving parallel to each other (and both want to change line):  									// Then' none of the two finds a vehicle behind on the parallel connection. Hence' none of the two will wait for the other one  									// and both might drive to the end of the line change interval and there block each other.  									// To avoid this case' if there is no otherBehind' we also look for a parallel vehicle in front of our back (there should be one' otherwise  									// something went terribly wrong above). The longer one of the two will wait for the shorter one to make sure' no deadlock will occur.  									if (otherBehind == null)  										{  										VehicleDistance otherFront = lcp.otherStart.nc.GetVehicleBehindArcPosition(myArcPositionOnOtherConnection - ((_length + s0))' Constants.lookaheadDistance);  										if (otherFront.vehicle.lineChangeNeeded && otherFront.vehicle._length > _length)  											{  											otherBehind = otherFront;  											otherBehind.distance *= -1;  											}  										}    									//Pair<VehicleDistance> vd = lcp.otherStart.nc.GetVehiclesAroundArcPosition(myArcPositionOnOtherConnection - ( (_length + s0))' Constants.lookaheadDistance);  									if (otherBehind != null)// && otherBehind.vehicle.p >= p)  										{  										// tell the vehicle behind my back to wait for me  										_state.SetLineChangeVehicleInteraction(this' otherBehind.vehicle' lcp.otherStart.nc' myArcPositionOnOtherConnection - _length);    										// In addition' I need to get behind the vehicle in front of the vehicle which waits for me. Therefore I adapt the desired velocity  										if (_state.vehicleThatLetsMeChangeLine != null)  											{  											VehicleDistance otherBehindForman = _state.vehicleThatLetsMeChangeLine.currentNodeConnection.GetVehicleBehindArcPosition(_state.vehicleThatLetsMeChangeLine.currentPosition' 2 * (length + s0));  											if (otherBehindForman != null)  												{  												//_physics.multiplierTargetVelocity = Math2.Clamp(Math2.Cubic((otherBehindForman.distance - otherBehind.distance - s0) / (_length + 4 * s0))' 0.3' 1);  												double multPerDistance = 1 - Math2.Clamp((otherBehind.distance + _length + s0 - otherBehindForman.distance + otherBehindForman.vehicle._length + s0) / (otherBehindForman.vehicle._length)' 0.2' 0.75);  												double multPerSpeedDiff = Math2.Clamp((otherBehindForman.vehicle._physics.velocity - _physics.velocity) / 2' 0.25' 0.8);  												_physics.multiplierTargetVelocity = Math.Min(multPerDistance' multPerSpeedDiff);  												}  											}  										}  									}    								lowestAcceleration = Math.Min(lowestAcceleration' CalculateAcceleration(physics.velocity' effectiveDesiredVelocity' lci.endArcPos - Constants.breakPointBeforeForcedLineChange - arcPos' physics.velocity));  								}  							}  						}  					}  				else if (_state.vehicleThatLetsMeChangeLine != null)  					{  					_state.UnsetLineChangeVehicleInteraction();  					}    				#endregion    				#region freiwillig    				thinkAboutLineChange &= ((GlobalTime.Instance.currentTime - lastLineChangeCheck.Left > 1) || (currentPosition - lastLineChangeCheck.Right > 50));    				if (thinkAboutLineChange && !currentlyChangingLine)  					{  					lastLineChangeCheck.Left = GlobalTime.Instance.currentTime;  					lastLineChangeCheck.Right = currentPosition;    					// get current LineChangePoint and check' whether it's reachable  					NodeConnection.LineChangePoint lcp = route[0].GetPrevLineChangePoint(arcPos);  					if ((lcp.target.nc != null) && (Math.Abs(arcPos - lcp.start.arcPosition) < Constants.maxDistanceToLineChangePoint * 0.67))  						{  						// check whether there is an alternative route that is not too costly  						Routing alternativeRoute = Routing.CalculateShortestConenction(lcp.target.nc.endNode' targetNodes' _vehicleType);  						if (alternativeRoute.SegmentCount() > 0 && alternativeRoute.costs / wayToGo.costs < Constants.maxRatioForVoluntaryLineChange && !alternativeRoute.Top().lineChangeNeeded)  							{  							double myArcPositionOnOtherConnection = lcp.otherStart.arcPosition + (arcPos - lcp.start.arcPosition);  							if (myArcPositionOnOtherConnection >= 0)  								{  								// Check the relation to my surrounding vehicles on the target NodeConnection  								Pair<VehicleDistance> otherVehicles = lcp.otherStart.nc.GetVehiclesAroundArcPosition(myArcPositionOnOtherConnection' Constants.lookaheadDistance);    								// the new vehicle in front wouldn't be too close  								if (   otherVehicles.Right == null  									|| otherVehicles.Right.distance > otherVehicles.Right.vehicle.length + 2 * lcp.length)  									{  									// the new vehicle behind wouldn't be too close  									if (   otherVehicles.Left == null  										|| otherVehicles.Left.distance > length + otherVehicles.Left.vehicle.CalculateWantedDistance(otherVehicles.Left.vehicle.physics.velocity' otherVehicles.Left.vehicle.physics.velocity - physics.velocity)/2)  										{  										List<NodeConnection> l = new List<NodeConnection>();  										l.Add(lcp.target.nc);  										foreach (Routing.RouteSegment rs in alternativeRoute)  											l.Add(rs.startConnection);    										// calculate my necessary acceleration in case of a line change  										double myAccelerationOnOtherConnection = (otherVehicles.Right != null)  											? CalculateAcceleration(physics.velocity' effectiveDesiredVelocity' otherVehicles.Right.vehicle.currentPosition - myArcPositionOnOtherConnection' physics.velocity - otherVehicles.Right.vehicle.physics.velocity)  											: CalculateAcceleration(physics.velocity' effectiveDesiredVelocity' GetDistanceToNextTrafficLightOnRoute(l' myArcPositionOnOtherConnection' Constants.lookaheadDistance' true)' physics.velocity);    										// calculate the necessary acceleration of the vehicle behind in case of a line change  										double forcedAccelerationOfVehicleBehindMeOnOtherConnection = (otherVehicles.Left != null)  											? CalculateAcceleration(otherVehicles.Left.vehicle.physics.velocity' otherVehicles.Left.vehicle.effectiveDesiredVelocity' otherVehicles.Left.distance' otherVehicles.Left.vehicle.physics.velocity - physics.velocity)  											: 0;    										double currentAccelerationOfVehicleBehindMeOnOtherConnection = (otherVehicles.Left != null) ? otherVehicles.Left.vehicle.physics.acceleration : 0;    										// simplified implementation of MOBIL: http://www.vwi.tu-dresden.de/~treiber/MicroApplet/MOBIL.html  										if (forcedAccelerationOfVehicleBehindMeOnOtherConnection > bSave)  											{  											if (myAccelerationOnOtherConnection - lowestAcceleration > p * (currentAccelerationOfVehicleBehindMeOnOtherConnection - forcedAccelerationOfVehicleBehindMeOnOtherConnection) + lineChangeThreshold)  												{  												// initiate the line change  												InitiateLineChange(lcp' arcPos - lcp.start.arcPosition);  												lowestAcceleration = myAccelerationOnOtherConnection;  												}  											}  										}  									}  								}  							}  						}  					}    				#endregion    				}
Magic Number,CityTrafficSimulator.Vehicle,IVehicle,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\IVehicle.cs,Think,The following statement contains a magic number: if (!onlySimpleCalculations)  				{  				#region Forced line changes    				// our route forces to perform a line change  				if (lineChangeNeeded && !currentlyChangingLine && lci != null)  					{  					thinkAboutLineChange = false;  					lastLineChangeCheck.Left = GlobalTime.Instance.currentTime;  					lastLineChangeCheck.Right = currentPosition;    					// get current LineChangePoint and check' whether it's leading to our target  					NodeConnection.LineChangePoint lcp = route[0].GetPrevLineChangePoint(arcPos);  					if (lci.targetNode.prevConnections.Contains(lcp.target.nc))  						{  						bool slowDownToBreakPoint = false;  						double myArcPositionOnOtherConnection = lcp.otherStart.arcPosition + (arcPos - lcp.start.arcPosition);    						// check if found LineChangePoint is not too far away to perform the line change  						if ((myArcPositionOnOtherConnection >= 0) && (Math.Abs(arcPos - lcp.start.arcPosition) < Constants.maxDistanceToLineChangePoint * 1.25))  							{  							// Check the relation to my surrounding vehicles on the target NodeConnection  							Pair<VehicleDistance> otherVehicles = lcp.otherStart.nc.GetVehiclesAroundArcPosition(myArcPositionOnOtherConnection' Constants.lookaheadDistance);    							// the new vehicle in front wouldn't be too close  							if (   otherVehicles.Right == null  								|| otherVehicles.Right.distance > otherVehicles.Right.vehicle.length + CalculateWantedDistance(physics.velocity' physics.velocity - otherVehicles.Right.vehicle.physics.velocity)/2)  								{  								// the new vehicle behind wouldn't be too close  								if (   otherVehicles.Left == null  									|| otherVehicles.Left.distance > length + otherVehicles.Left.vehicle.CalculateWantedDistance(otherVehicles.Left.vehicle.physics.velocity' otherVehicles.Left.vehicle.physics.velocity - physics.velocity)/2)  									{  									// calculate my necessary acceleration in case of a line change  									double myAccelerationOnOtherConnection = (otherVehicles.Right != null)  										? CalculateAcceleration(physics.velocity' effectiveDesiredVelocity' otherVehicles.Right.vehicle.currentPosition - myArcPositionOnOtherConnection' physics.velocity - otherVehicles.Right.vehicle.physics.velocity)  										: CalculateAcceleration(physics.velocity' effectiveDesiredVelocity' lookaheadDistance' physics.velocity);    									// calculate the necessary acceleration of the vehicle behind in case of a line change  									double forcedAccelerationOfVehicleBehindMeOnOtherConnection = (otherVehicles.Left != null)  										? CalculateAcceleration(otherVehicles.Left.vehicle.physics.velocity' otherVehicles.Left.vehicle.effectiveDesiredVelocity' otherVehicles.Left.distance' otherVehicles.Left.vehicle.physics.velocity - physics.velocity)  										: 0;    									double currentAccelerationOfVehicleBehindMeOnOtherConnection = (otherVehicles.Left != null) ? otherVehicles.Left.vehicle.physics.acceleration : 0;    									// Final check:  									//  - The new vehicle behind must not break harder than bSave  									//  - My line change must be sufficiently necessary. The closer I come to the end of the LineChangeInterval' the more I may thwart the vehicle behind.   									if (   (forcedAccelerationOfVehicleBehindMeOnOtherConnection > bSave)  										&& ((arcPos - lci.startArcPos) / lci.length >= (currentAccelerationOfVehicleBehindMeOnOtherConnection - forcedAccelerationOfVehicleBehindMeOnOtherConnection)))  										{  										// return to normal velocity  										_physics.multiplierTargetVelocity = 1;    										// initiate the line change  										InitiateLineChange(lcp' arcPos - lcp.start.arcPosition);  										lowestAcceleration = myAccelerationOnOtherConnection;  										}  									// I do not want to change line yet' but I could position myself better between the two other vehicles on the parallel line.  									else if (true)  										{  										// TODO: implement  										slowDownToBreakPoint = true;  										}  									}  								// the new vehicle behind would too close but I can accelerate and are at least as fast as him  								else if (   otherVehicles.Left.vehicle.physics.velocity / this.physics.velocity < 1.2  // I am not significantly slower than him  										 && (otherVehicles.Right == null || otherVehicles.Right.distance > 1.5 * length) // the new vehicle in front is far enough away  										 && lookaheadDistance > 2 * length			// no vehicle/traffic light/intersection in front  										 && lci.endArcPos - arcPos > 2 * length		// enough space left in LineChangeInterval  										 && lowestAcceleration >= -0.1)				// currently not braking  									{  									// accelerate to get in front  									_physics.multiplierTargetVelocity = 1.75;  									lowestAcceleration = Math.Min(lowestAcceleration' CalculateAcceleration(physics.velocity' effectiveDesiredVelocity' lookaheadDistance' physics.velocity));    									_state.SetLineChangeVehicleInteraction(this' otherVehicles.Left.vehicle' lcp.otherStart.nc' myArcPositionOnOtherConnection - _length);  									}  								// There is no way to perform a line change now => slow down  								else  									{  									slowDownToBreakPoint = true;  									}  								}  							// The new vehicle in front is too close => slow down  							else  								{  								slowDownToBreakPoint = true;  								}  							}    						if (slowDownToBreakPoint)  							{  							double percentOfLCILeft = Math.Max(0.2' (lci.endArcPos - currentPosition - Constants.breakPointBeforeForcedLineChange) / (lci.length - Constants.breakPointBeforeForcedLineChange));    							// slow down a bit  							_physics.multiplierTargetVelocity = Math.Min(0.9' 1.5 * percentOfLCILeft);    							// When reaching the end of the LineChangeInterval' check whether there are other possibilities to reach the target:  							if (percentOfLCILeft < 0.5)  								{  								Routing newRTT = Routing.CalculateShortestConenction(route[0].endNode' _targetNodes' _vehicleType);  								// The alternative route does not cost too much -> choose it  								if (newRTT.SegmentCount() > 0 && newRTT.costs / _wayToGo.costs < Constants.maxRatioForEnforcedLineChange)  									{  									_wayToGo = newRTT;  									_physics.multiplierTargetVelocity = 1;  									lineChangeNeeded = false;  									lci = null;  									}  								}  							// Line change still necessacy => stop at break point  							if (lineChangeNeeded)  								{  								if (! _state.letVehicleChangeLine && percentOfLCILeft < 0.8)  									{  									VehicleDistance otherBehind = lcp.otherStart.nc.GetVehicleBeforeArcPosition(myArcPositionOnOtherConnection - ((_length + s0))' Constants.lookaheadDistance);    									// In rare cases deadlocks may appear when a very long and a short vehicle are driving parallel to each other (and both want to change line):  									// Then' none of the two finds a vehicle behind on the parallel connection. Hence' none of the two will wait for the other one  									// and both might drive to the end of the line change interval and there block each other.  									// To avoid this case' if there is no otherBehind' we also look for a parallel vehicle in front of our back (there should be one' otherwise  									// something went terribly wrong above). The longer one of the two will wait for the shorter one to make sure' no deadlock will occur.  									if (otherBehind == null)  										{  										VehicleDistance otherFront = lcp.otherStart.nc.GetVehicleBehindArcPosition(myArcPositionOnOtherConnection - ((_length + s0))' Constants.lookaheadDistance);  										if (otherFront.vehicle.lineChangeNeeded && otherFront.vehicle._length > _length)  											{  											otherBehind = otherFront;  											otherBehind.distance *= -1;  											}  										}    									//Pair<VehicleDistance> vd = lcp.otherStart.nc.GetVehiclesAroundArcPosition(myArcPositionOnOtherConnection - ( (_length + s0))' Constants.lookaheadDistance);  									if (otherBehind != null)// && otherBehind.vehicle.p >= p)  										{  										// tell the vehicle behind my back to wait for me  										_state.SetLineChangeVehicleInteraction(this' otherBehind.vehicle' lcp.otherStart.nc' myArcPositionOnOtherConnection - _length);    										// In addition' I need to get behind the vehicle in front of the vehicle which waits for me. Therefore I adapt the desired velocity  										if (_state.vehicleThatLetsMeChangeLine != null)  											{  											VehicleDistance otherBehindForman = _state.vehicleThatLetsMeChangeLine.currentNodeConnection.GetVehicleBehindArcPosition(_state.vehicleThatLetsMeChangeLine.currentPosition' 2 * (length + s0));  											if (otherBehindForman != null)  												{  												//_physics.multiplierTargetVelocity = Math2.Clamp(Math2.Cubic((otherBehindForman.distance - otherBehind.distance - s0) / (_length + 4 * s0))' 0.3' 1);  												double multPerDistance = 1 - Math2.Clamp((otherBehind.distance + _length + s0 - otherBehindForman.distance + otherBehindForman.vehicle._length + s0) / (otherBehindForman.vehicle._length)' 0.2' 0.75);  												double multPerSpeedDiff = Math2.Clamp((otherBehindForman.vehicle._physics.velocity - _physics.velocity) / 2' 0.25' 0.8);  												_physics.multiplierTargetVelocity = Math.Min(multPerDistance' multPerSpeedDiff);  												}  											}  										}  									}    								lowestAcceleration = Math.Min(lowestAcceleration' CalculateAcceleration(physics.velocity' effectiveDesiredVelocity' lci.endArcPos - Constants.breakPointBeforeForcedLineChange - arcPos' physics.velocity));  								}  							}  						}  					}  				else if (_state.vehicleThatLetsMeChangeLine != null)  					{  					_state.UnsetLineChangeVehicleInteraction();  					}    				#endregion    				#region freiwillig    				thinkAboutLineChange &= ((GlobalTime.Instance.currentTime - lastLineChangeCheck.Left > 1) || (currentPosition - lastLineChangeCheck.Right > 50));    				if (thinkAboutLineChange && !currentlyChangingLine)  					{  					lastLineChangeCheck.Left = GlobalTime.Instance.currentTime;  					lastLineChangeCheck.Right = currentPosition;    					// get current LineChangePoint and check' whether it's reachable  					NodeConnection.LineChangePoint lcp = route[0].GetPrevLineChangePoint(arcPos);  					if ((lcp.target.nc != null) && (Math.Abs(arcPos - lcp.start.arcPosition) < Constants.maxDistanceToLineChangePoint * 0.67))  						{  						// check whether there is an alternative route that is not too costly  						Routing alternativeRoute = Routing.CalculateShortestConenction(lcp.target.nc.endNode' targetNodes' _vehicleType);  						if (alternativeRoute.SegmentCount() > 0 && alternativeRoute.costs / wayToGo.costs < Constants.maxRatioForVoluntaryLineChange && !alternativeRoute.Top().lineChangeNeeded)  							{  							double myArcPositionOnOtherConnection = lcp.otherStart.arcPosition + (arcPos - lcp.start.arcPosition);  							if (myArcPositionOnOtherConnection >= 0)  								{  								// Check the relation to my surrounding vehicles on the target NodeConnection  								Pair<VehicleDistance> otherVehicles = lcp.otherStart.nc.GetVehiclesAroundArcPosition(myArcPositionOnOtherConnection' Constants.lookaheadDistance);    								// the new vehicle in front wouldn't be too close  								if (   otherVehicles.Right == null  									|| otherVehicles.Right.distance > otherVehicles.Right.vehicle.length + 2 * lcp.length)  									{  									// the new vehicle behind wouldn't be too close  									if (   otherVehicles.Left == null  										|| otherVehicles.Left.distance > length + otherVehicles.Left.vehicle.CalculateWantedDistance(otherVehicles.Left.vehicle.physics.velocity' otherVehicles.Left.vehicle.physics.velocity - physics.velocity)/2)  										{  										List<NodeConnection> l = new List<NodeConnection>();  										l.Add(lcp.target.nc);  										foreach (Routing.RouteSegment rs in alternativeRoute)  											l.Add(rs.startConnection);    										// calculate my necessary acceleration in case of a line change  										double myAccelerationOnOtherConnection = (otherVehicles.Right != null)  											? CalculateAcceleration(physics.velocity' effectiveDesiredVelocity' otherVehicles.Right.vehicle.currentPosition - myArcPositionOnOtherConnection' physics.velocity - otherVehicles.Right.vehicle.physics.velocity)  											: CalculateAcceleration(physics.velocity' effectiveDesiredVelocity' GetDistanceToNextTrafficLightOnRoute(l' myArcPositionOnOtherConnection' Constants.lookaheadDistance' true)' physics.velocity);    										// calculate the necessary acceleration of the vehicle behind in case of a line change  										double forcedAccelerationOfVehicleBehindMeOnOtherConnection = (otherVehicles.Left != null)  											? CalculateAcceleration(otherVehicles.Left.vehicle.physics.velocity' otherVehicles.Left.vehicle.effectiveDesiredVelocity' otherVehicles.Left.distance' otherVehicles.Left.vehicle.physics.velocity - physics.velocity)  											: 0;    										double currentAccelerationOfVehicleBehindMeOnOtherConnection = (otherVehicles.Left != null) ? otherVehicles.Left.vehicle.physics.acceleration : 0;    										// simplified implementation of MOBIL: http://www.vwi.tu-dresden.de/~treiber/MicroApplet/MOBIL.html  										if (forcedAccelerationOfVehicleBehindMeOnOtherConnection > bSave)  											{  											if (myAccelerationOnOtherConnection - lowestAcceleration > p * (currentAccelerationOfVehicleBehindMeOnOtherConnection - forcedAccelerationOfVehicleBehindMeOnOtherConnection) + lineChangeThreshold)  												{  												// initiate the line change  												InitiateLineChange(lcp' arcPos - lcp.start.arcPosition);  												lowestAcceleration = myAccelerationOnOtherConnection;  												}  											}  										}  									}  								}  							}  						}  					}    				#endregion    				}
Magic Number,CityTrafficSimulator.Vehicle,IVehicle,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\IVehicle.cs,Think,The following statement contains a magic number: if (!onlySimpleCalculations)  				{  				#region Forced line changes    				// our route forces to perform a line change  				if (lineChangeNeeded && !currentlyChangingLine && lci != null)  					{  					thinkAboutLineChange = false;  					lastLineChangeCheck.Left = GlobalTime.Instance.currentTime;  					lastLineChangeCheck.Right = currentPosition;    					// get current LineChangePoint and check' whether it's leading to our target  					NodeConnection.LineChangePoint lcp = route[0].GetPrevLineChangePoint(arcPos);  					if (lci.targetNode.prevConnections.Contains(lcp.target.nc))  						{  						bool slowDownToBreakPoint = false;  						double myArcPositionOnOtherConnection = lcp.otherStart.arcPosition + (arcPos - lcp.start.arcPosition);    						// check if found LineChangePoint is not too far away to perform the line change  						if ((myArcPositionOnOtherConnection >= 0) && (Math.Abs(arcPos - lcp.start.arcPosition) < Constants.maxDistanceToLineChangePoint * 1.25))  							{  							// Check the relation to my surrounding vehicles on the target NodeConnection  							Pair<VehicleDistance> otherVehicles = lcp.otherStart.nc.GetVehiclesAroundArcPosition(myArcPositionOnOtherConnection' Constants.lookaheadDistance);    							// the new vehicle in front wouldn't be too close  							if (   otherVehicles.Right == null  								|| otherVehicles.Right.distance > otherVehicles.Right.vehicle.length + CalculateWantedDistance(physics.velocity' physics.velocity - otherVehicles.Right.vehicle.physics.velocity)/2)  								{  								// the new vehicle behind wouldn't be too close  								if (   otherVehicles.Left == null  									|| otherVehicles.Left.distance > length + otherVehicles.Left.vehicle.CalculateWantedDistance(otherVehicles.Left.vehicle.physics.velocity' otherVehicles.Left.vehicle.physics.velocity - physics.velocity)/2)  									{  									// calculate my necessary acceleration in case of a line change  									double myAccelerationOnOtherConnection = (otherVehicles.Right != null)  										? CalculateAcceleration(physics.velocity' effectiveDesiredVelocity' otherVehicles.Right.vehicle.currentPosition - myArcPositionOnOtherConnection' physics.velocity - otherVehicles.Right.vehicle.physics.velocity)  										: CalculateAcceleration(physics.velocity' effectiveDesiredVelocity' lookaheadDistance' physics.velocity);    									// calculate the necessary acceleration of the vehicle behind in case of a line change  									double forcedAccelerationOfVehicleBehindMeOnOtherConnection = (otherVehicles.Left != null)  										? CalculateAcceleration(otherVehicles.Left.vehicle.physics.velocity' otherVehicles.Left.vehicle.effectiveDesiredVelocity' otherVehicles.Left.distance' otherVehicles.Left.vehicle.physics.velocity - physics.velocity)  										: 0;    									double currentAccelerationOfVehicleBehindMeOnOtherConnection = (otherVehicles.Left != null) ? otherVehicles.Left.vehicle.physics.acceleration : 0;    									// Final check:  									//  - The new vehicle behind must not break harder than bSave  									//  - My line change must be sufficiently necessary. The closer I come to the end of the LineChangeInterval' the more I may thwart the vehicle behind.   									if (   (forcedAccelerationOfVehicleBehindMeOnOtherConnection > bSave)  										&& ((arcPos - lci.startArcPos) / lci.length >= (currentAccelerationOfVehicleBehindMeOnOtherConnection - forcedAccelerationOfVehicleBehindMeOnOtherConnection)))  										{  										// return to normal velocity  										_physics.multiplierTargetVelocity = 1;    										// initiate the line change  										InitiateLineChange(lcp' arcPos - lcp.start.arcPosition);  										lowestAcceleration = myAccelerationOnOtherConnection;  										}  									// I do not want to change line yet' but I could position myself better between the two other vehicles on the parallel line.  									else if (true)  										{  										// TODO: implement  										slowDownToBreakPoint = true;  										}  									}  								// the new vehicle behind would too close but I can accelerate and are at least as fast as him  								else if (   otherVehicles.Left.vehicle.physics.velocity / this.physics.velocity < 1.2  // I am not significantly slower than him  										 && (otherVehicles.Right == null || otherVehicles.Right.distance > 1.5 * length) // the new vehicle in front is far enough away  										 && lookaheadDistance > 2 * length			// no vehicle/traffic light/intersection in front  										 && lci.endArcPos - arcPos > 2 * length		// enough space left in LineChangeInterval  										 && lowestAcceleration >= -0.1)				// currently not braking  									{  									// accelerate to get in front  									_physics.multiplierTargetVelocity = 1.75;  									lowestAcceleration = Math.Min(lowestAcceleration' CalculateAcceleration(physics.velocity' effectiveDesiredVelocity' lookaheadDistance' physics.velocity));    									_state.SetLineChangeVehicleInteraction(this' otherVehicles.Left.vehicle' lcp.otherStart.nc' myArcPositionOnOtherConnection - _length);  									}  								// There is no way to perform a line change now => slow down  								else  									{  									slowDownToBreakPoint = true;  									}  								}  							// The new vehicle in front is too close => slow down  							else  								{  								slowDownToBreakPoint = true;  								}  							}    						if (slowDownToBreakPoint)  							{  							double percentOfLCILeft = Math.Max(0.2' (lci.endArcPos - currentPosition - Constants.breakPointBeforeForcedLineChange) / (lci.length - Constants.breakPointBeforeForcedLineChange));    							// slow down a bit  							_physics.multiplierTargetVelocity = Math.Min(0.9' 1.5 * percentOfLCILeft);    							// When reaching the end of the LineChangeInterval' check whether there are other possibilities to reach the target:  							if (percentOfLCILeft < 0.5)  								{  								Routing newRTT = Routing.CalculateShortestConenction(route[0].endNode' _targetNodes' _vehicleType);  								// The alternative route does not cost too much -> choose it  								if (newRTT.SegmentCount() > 0 && newRTT.costs / _wayToGo.costs < Constants.maxRatioForEnforcedLineChange)  									{  									_wayToGo = newRTT;  									_physics.multiplierTargetVelocity = 1;  									lineChangeNeeded = false;  									lci = null;  									}  								}  							// Line change still necessacy => stop at break point  							if (lineChangeNeeded)  								{  								if (! _state.letVehicleChangeLine && percentOfLCILeft < 0.8)  									{  									VehicleDistance otherBehind = lcp.otherStart.nc.GetVehicleBeforeArcPosition(myArcPositionOnOtherConnection - ((_length + s0))' Constants.lookaheadDistance);    									// In rare cases deadlocks may appear when a very long and a short vehicle are driving parallel to each other (and both want to change line):  									// Then' none of the two finds a vehicle behind on the parallel connection. Hence' none of the two will wait for the other one  									// and both might drive to the end of the line change interval and there block each other.  									// To avoid this case' if there is no otherBehind' we also look for a parallel vehicle in front of our back (there should be one' otherwise  									// something went terribly wrong above). The longer one of the two will wait for the shorter one to make sure' no deadlock will occur.  									if (otherBehind == null)  										{  										VehicleDistance otherFront = lcp.otherStart.nc.GetVehicleBehindArcPosition(myArcPositionOnOtherConnection - ((_length + s0))' Constants.lookaheadDistance);  										if (otherFront.vehicle.lineChangeNeeded && otherFront.vehicle._length > _length)  											{  											otherBehind = otherFront;  											otherBehind.distance *= -1;  											}  										}    									//Pair<VehicleDistance> vd = lcp.otherStart.nc.GetVehiclesAroundArcPosition(myArcPositionOnOtherConnection - ( (_length + s0))' Constants.lookaheadDistance);  									if (otherBehind != null)// && otherBehind.vehicle.p >= p)  										{  										// tell the vehicle behind my back to wait for me  										_state.SetLineChangeVehicleInteraction(this' otherBehind.vehicle' lcp.otherStart.nc' myArcPositionOnOtherConnection - _length);    										// In addition' I need to get behind the vehicle in front of the vehicle which waits for me. Therefore I adapt the desired velocity  										if (_state.vehicleThatLetsMeChangeLine != null)  											{  											VehicleDistance otherBehindForman = _state.vehicleThatLetsMeChangeLine.currentNodeConnection.GetVehicleBehindArcPosition(_state.vehicleThatLetsMeChangeLine.currentPosition' 2 * (length + s0));  											if (otherBehindForman != null)  												{  												//_physics.multiplierTargetVelocity = Math2.Clamp(Math2.Cubic((otherBehindForman.distance - otherBehind.distance - s0) / (_length + 4 * s0))' 0.3' 1);  												double multPerDistance = 1 - Math2.Clamp((otherBehind.distance + _length + s0 - otherBehindForman.distance + otherBehindForman.vehicle._length + s0) / (otherBehindForman.vehicle._length)' 0.2' 0.75);  												double multPerSpeedDiff = Math2.Clamp((otherBehindForman.vehicle._physics.velocity - _physics.velocity) / 2' 0.25' 0.8);  												_physics.multiplierTargetVelocity = Math.Min(multPerDistance' multPerSpeedDiff);  												}  											}  										}  									}    								lowestAcceleration = Math.Min(lowestAcceleration' CalculateAcceleration(physics.velocity' effectiveDesiredVelocity' lci.endArcPos - Constants.breakPointBeforeForcedLineChange - arcPos' physics.velocity));  								}  							}  						}  					}  				else if (_state.vehicleThatLetsMeChangeLine != null)  					{  					_state.UnsetLineChangeVehicleInteraction();  					}    				#endregion    				#region freiwillig    				thinkAboutLineChange &= ((GlobalTime.Instance.currentTime - lastLineChangeCheck.Left > 1) || (currentPosition - lastLineChangeCheck.Right > 50));    				if (thinkAboutLineChange && !currentlyChangingLine)  					{  					lastLineChangeCheck.Left = GlobalTime.Instance.currentTime;  					lastLineChangeCheck.Right = currentPosition;    					// get current LineChangePoint and check' whether it's reachable  					NodeConnection.LineChangePoint lcp = route[0].GetPrevLineChangePoint(arcPos);  					if ((lcp.target.nc != null) && (Math.Abs(arcPos - lcp.start.arcPosition) < Constants.maxDistanceToLineChangePoint * 0.67))  						{  						// check whether there is an alternative route that is not too costly  						Routing alternativeRoute = Routing.CalculateShortestConenction(lcp.target.nc.endNode' targetNodes' _vehicleType);  						if (alternativeRoute.SegmentCount() > 0 && alternativeRoute.costs / wayToGo.costs < Constants.maxRatioForVoluntaryLineChange && !alternativeRoute.Top().lineChangeNeeded)  							{  							double myArcPositionOnOtherConnection = lcp.otherStart.arcPosition + (arcPos - lcp.start.arcPosition);  							if (myArcPositionOnOtherConnection >= 0)  								{  								// Check the relation to my surrounding vehicles on the target NodeConnection  								Pair<VehicleDistance> otherVehicles = lcp.otherStart.nc.GetVehiclesAroundArcPosition(myArcPositionOnOtherConnection' Constants.lookaheadDistance);    								// the new vehicle in front wouldn't be too close  								if (   otherVehicles.Right == null  									|| otherVehicles.Right.distance > otherVehicles.Right.vehicle.length + 2 * lcp.length)  									{  									// the new vehicle behind wouldn't be too close  									if (   otherVehicles.Left == null  										|| otherVehicles.Left.distance > length + otherVehicles.Left.vehicle.CalculateWantedDistance(otherVehicles.Left.vehicle.physics.velocity' otherVehicles.Left.vehicle.physics.velocity - physics.velocity)/2)  										{  										List<NodeConnection> l = new List<NodeConnection>();  										l.Add(lcp.target.nc);  										foreach (Routing.RouteSegment rs in alternativeRoute)  											l.Add(rs.startConnection);    										// calculate my necessary acceleration in case of a line change  										double myAccelerationOnOtherConnection = (otherVehicles.Right != null)  											? CalculateAcceleration(physics.velocity' effectiveDesiredVelocity' otherVehicles.Right.vehicle.currentPosition - myArcPositionOnOtherConnection' physics.velocity - otherVehicles.Right.vehicle.physics.velocity)  											: CalculateAcceleration(physics.velocity' effectiveDesiredVelocity' GetDistanceToNextTrafficLightOnRoute(l' myArcPositionOnOtherConnection' Constants.lookaheadDistance' true)' physics.velocity);    										// calculate the necessary acceleration of the vehicle behind in case of a line change  										double forcedAccelerationOfVehicleBehindMeOnOtherConnection = (otherVehicles.Left != null)  											? CalculateAcceleration(otherVehicles.Left.vehicle.physics.velocity' otherVehicles.Left.vehicle.effectiveDesiredVelocity' otherVehicles.Left.distance' otherVehicles.Left.vehicle.physics.velocity - physics.velocity)  											: 0;    										double currentAccelerationOfVehicleBehindMeOnOtherConnection = (otherVehicles.Left != null) ? otherVehicles.Left.vehicle.physics.acceleration : 0;    										// simplified implementation of MOBIL: http://www.vwi.tu-dresden.de/~treiber/MicroApplet/MOBIL.html  										if (forcedAccelerationOfVehicleBehindMeOnOtherConnection > bSave)  											{  											if (myAccelerationOnOtherConnection - lowestAcceleration > p * (currentAccelerationOfVehicleBehindMeOnOtherConnection - forcedAccelerationOfVehicleBehindMeOnOtherConnection) + lineChangeThreshold)  												{  												// initiate the line change  												InitiateLineChange(lcp' arcPos - lcp.start.arcPosition);  												lowestAcceleration = myAccelerationOnOtherConnection;  												}  											}  										}  									}  								}  							}  						}  					}    				#endregion    				}
Magic Number,CityTrafficSimulator.Vehicle,IVehicle,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\IVehicle.cs,Think,The following statement contains a magic number: if (!onlySimpleCalculations)  				{  				#region Forced line changes    				// our route forces to perform a line change  				if (lineChangeNeeded && !currentlyChangingLine && lci != null)  					{  					thinkAboutLineChange = false;  					lastLineChangeCheck.Left = GlobalTime.Instance.currentTime;  					lastLineChangeCheck.Right = currentPosition;    					// get current LineChangePoint and check' whether it's leading to our target  					NodeConnection.LineChangePoint lcp = route[0].GetPrevLineChangePoint(arcPos);  					if (lci.targetNode.prevConnections.Contains(lcp.target.nc))  						{  						bool slowDownToBreakPoint = false;  						double myArcPositionOnOtherConnection = lcp.otherStart.arcPosition + (arcPos - lcp.start.arcPosition);    						// check if found LineChangePoint is not too far away to perform the line change  						if ((myArcPositionOnOtherConnection >= 0) && (Math.Abs(arcPos - lcp.start.arcPosition) < Constants.maxDistanceToLineChangePoint * 1.25))  							{  							// Check the relation to my surrounding vehicles on the target NodeConnection  							Pair<VehicleDistance> otherVehicles = lcp.otherStart.nc.GetVehiclesAroundArcPosition(myArcPositionOnOtherConnection' Constants.lookaheadDistance);    							// the new vehicle in front wouldn't be too close  							if (   otherVehicles.Right == null  								|| otherVehicles.Right.distance > otherVehicles.Right.vehicle.length + CalculateWantedDistance(physics.velocity' physics.velocity - otherVehicles.Right.vehicle.physics.velocity)/2)  								{  								// the new vehicle behind wouldn't be too close  								if (   otherVehicles.Left == null  									|| otherVehicles.Left.distance > length + otherVehicles.Left.vehicle.CalculateWantedDistance(otherVehicles.Left.vehicle.physics.velocity' otherVehicles.Left.vehicle.physics.velocity - physics.velocity)/2)  									{  									// calculate my necessary acceleration in case of a line change  									double myAccelerationOnOtherConnection = (otherVehicles.Right != null)  										? CalculateAcceleration(physics.velocity' effectiveDesiredVelocity' otherVehicles.Right.vehicle.currentPosition - myArcPositionOnOtherConnection' physics.velocity - otherVehicles.Right.vehicle.physics.velocity)  										: CalculateAcceleration(physics.velocity' effectiveDesiredVelocity' lookaheadDistance' physics.velocity);    									// calculate the necessary acceleration of the vehicle behind in case of a line change  									double forcedAccelerationOfVehicleBehindMeOnOtherConnection = (otherVehicles.Left != null)  										? CalculateAcceleration(otherVehicles.Left.vehicle.physics.velocity' otherVehicles.Left.vehicle.effectiveDesiredVelocity' otherVehicles.Left.distance' otherVehicles.Left.vehicle.physics.velocity - physics.velocity)  										: 0;    									double currentAccelerationOfVehicleBehindMeOnOtherConnection = (otherVehicles.Left != null) ? otherVehicles.Left.vehicle.physics.acceleration : 0;    									// Final check:  									//  - The new vehicle behind must not break harder than bSave  									//  - My line change must be sufficiently necessary. The closer I come to the end of the LineChangeInterval' the more I may thwart the vehicle behind.   									if (   (forcedAccelerationOfVehicleBehindMeOnOtherConnection > bSave)  										&& ((arcPos - lci.startArcPos) / lci.length >= (currentAccelerationOfVehicleBehindMeOnOtherConnection - forcedAccelerationOfVehicleBehindMeOnOtherConnection)))  										{  										// return to normal velocity  										_physics.multiplierTargetVelocity = 1;    										// initiate the line change  										InitiateLineChange(lcp' arcPos - lcp.start.arcPosition);  										lowestAcceleration = myAccelerationOnOtherConnection;  										}  									// I do not want to change line yet' but I could position myself better between the two other vehicles on the parallel line.  									else if (true)  										{  										// TODO: implement  										slowDownToBreakPoint = true;  										}  									}  								// the new vehicle behind would too close but I can accelerate and are at least as fast as him  								else if (   otherVehicles.Left.vehicle.physics.velocity / this.physics.velocity < 1.2  // I am not significantly slower than him  										 && (otherVehicles.Right == null || otherVehicles.Right.distance > 1.5 * length) // the new vehicle in front is far enough away  										 && lookaheadDistance > 2 * length			// no vehicle/traffic light/intersection in front  										 && lci.endArcPos - arcPos > 2 * length		// enough space left in LineChangeInterval  										 && lowestAcceleration >= -0.1)				// currently not braking  									{  									// accelerate to get in front  									_physics.multiplierTargetVelocity = 1.75;  									lowestAcceleration = Math.Min(lowestAcceleration' CalculateAcceleration(physics.velocity' effectiveDesiredVelocity' lookaheadDistance' physics.velocity));    									_state.SetLineChangeVehicleInteraction(this' otherVehicles.Left.vehicle' lcp.otherStart.nc' myArcPositionOnOtherConnection - _length);  									}  								// There is no way to perform a line change now => slow down  								else  									{  									slowDownToBreakPoint = true;  									}  								}  							// The new vehicle in front is too close => slow down  							else  								{  								slowDownToBreakPoint = true;  								}  							}    						if (slowDownToBreakPoint)  							{  							double percentOfLCILeft = Math.Max(0.2' (lci.endArcPos - currentPosition - Constants.breakPointBeforeForcedLineChange) / (lci.length - Constants.breakPointBeforeForcedLineChange));    							// slow down a bit  							_physics.multiplierTargetVelocity = Math.Min(0.9' 1.5 * percentOfLCILeft);    							// When reaching the end of the LineChangeInterval' check whether there are other possibilities to reach the target:  							if (percentOfLCILeft < 0.5)  								{  								Routing newRTT = Routing.CalculateShortestConenction(route[0].endNode' _targetNodes' _vehicleType);  								// The alternative route does not cost too much -> choose it  								if (newRTT.SegmentCount() > 0 && newRTT.costs / _wayToGo.costs < Constants.maxRatioForEnforcedLineChange)  									{  									_wayToGo = newRTT;  									_physics.multiplierTargetVelocity = 1;  									lineChangeNeeded = false;  									lci = null;  									}  								}  							// Line change still necessacy => stop at break point  							if (lineChangeNeeded)  								{  								if (! _state.letVehicleChangeLine && percentOfLCILeft < 0.8)  									{  									VehicleDistance otherBehind = lcp.otherStart.nc.GetVehicleBeforeArcPosition(myArcPositionOnOtherConnection - ((_length + s0))' Constants.lookaheadDistance);    									// In rare cases deadlocks may appear when a very long and a short vehicle are driving parallel to each other (and both want to change line):  									// Then' none of the two finds a vehicle behind on the parallel connection. Hence' none of the two will wait for the other one  									// and both might drive to the end of the line change interval and there block each other.  									// To avoid this case' if there is no otherBehind' we also look for a parallel vehicle in front of our back (there should be one' otherwise  									// something went terribly wrong above). The longer one of the two will wait for the shorter one to make sure' no deadlock will occur.  									if (otherBehind == null)  										{  										VehicleDistance otherFront = lcp.otherStart.nc.GetVehicleBehindArcPosition(myArcPositionOnOtherConnection - ((_length + s0))' Constants.lookaheadDistance);  										if (otherFront.vehicle.lineChangeNeeded && otherFront.vehicle._length > _length)  											{  											otherBehind = otherFront;  											otherBehind.distance *= -1;  											}  										}    									//Pair<VehicleDistance> vd = lcp.otherStart.nc.GetVehiclesAroundArcPosition(myArcPositionOnOtherConnection - ( (_length + s0))' Constants.lookaheadDistance);  									if (otherBehind != null)// && otherBehind.vehicle.p >= p)  										{  										// tell the vehicle behind my back to wait for me  										_state.SetLineChangeVehicleInteraction(this' otherBehind.vehicle' lcp.otherStart.nc' myArcPositionOnOtherConnection - _length);    										// In addition' I need to get behind the vehicle in front of the vehicle which waits for me. Therefore I adapt the desired velocity  										if (_state.vehicleThatLetsMeChangeLine != null)  											{  											VehicleDistance otherBehindForman = _state.vehicleThatLetsMeChangeLine.currentNodeConnection.GetVehicleBehindArcPosition(_state.vehicleThatLetsMeChangeLine.currentPosition' 2 * (length + s0));  											if (otherBehindForman != null)  												{  												//_physics.multiplierTargetVelocity = Math2.Clamp(Math2.Cubic((otherBehindForman.distance - otherBehind.distance - s0) / (_length + 4 * s0))' 0.3' 1);  												double multPerDistance = 1 - Math2.Clamp((otherBehind.distance + _length + s0 - otherBehindForman.distance + otherBehindForman.vehicle._length + s0) / (otherBehindForman.vehicle._length)' 0.2' 0.75);  												double multPerSpeedDiff = Math2.Clamp((otherBehindForman.vehicle._physics.velocity - _physics.velocity) / 2' 0.25' 0.8);  												_physics.multiplierTargetVelocity = Math.Min(multPerDistance' multPerSpeedDiff);  												}  											}  										}  									}    								lowestAcceleration = Math.Min(lowestAcceleration' CalculateAcceleration(physics.velocity' effectiveDesiredVelocity' lci.endArcPos - Constants.breakPointBeforeForcedLineChange - arcPos' physics.velocity));  								}  							}  						}  					}  				else if (_state.vehicleThatLetsMeChangeLine != null)  					{  					_state.UnsetLineChangeVehicleInteraction();  					}    				#endregion    				#region freiwillig    				thinkAboutLineChange &= ((GlobalTime.Instance.currentTime - lastLineChangeCheck.Left > 1) || (currentPosition - lastLineChangeCheck.Right > 50));    				if (thinkAboutLineChange && !currentlyChangingLine)  					{  					lastLineChangeCheck.Left = GlobalTime.Instance.currentTime;  					lastLineChangeCheck.Right = currentPosition;    					// get current LineChangePoint and check' whether it's reachable  					NodeConnection.LineChangePoint lcp = route[0].GetPrevLineChangePoint(arcPos);  					if ((lcp.target.nc != null) && (Math.Abs(arcPos - lcp.start.arcPosition) < Constants.maxDistanceToLineChangePoint * 0.67))  						{  						// check whether there is an alternative route that is not too costly  						Routing alternativeRoute = Routing.CalculateShortestConenction(lcp.target.nc.endNode' targetNodes' _vehicleType);  						if (alternativeRoute.SegmentCount() > 0 && alternativeRoute.costs / wayToGo.costs < Constants.maxRatioForVoluntaryLineChange && !alternativeRoute.Top().lineChangeNeeded)  							{  							double myArcPositionOnOtherConnection = lcp.otherStart.arcPosition + (arcPos - lcp.start.arcPosition);  							if (myArcPositionOnOtherConnection >= 0)  								{  								// Check the relation to my surrounding vehicles on the target NodeConnection  								Pair<VehicleDistance> otherVehicles = lcp.otherStart.nc.GetVehiclesAroundArcPosition(myArcPositionOnOtherConnection' Constants.lookaheadDistance);    								// the new vehicle in front wouldn't be too close  								if (   otherVehicles.Right == null  									|| otherVehicles.Right.distance > otherVehicles.Right.vehicle.length + 2 * lcp.length)  									{  									// the new vehicle behind wouldn't be too close  									if (   otherVehicles.Left == null  										|| otherVehicles.Left.distance > length + otherVehicles.Left.vehicle.CalculateWantedDistance(otherVehicles.Left.vehicle.physics.velocity' otherVehicles.Left.vehicle.physics.velocity - physics.velocity)/2)  										{  										List<NodeConnection> l = new List<NodeConnection>();  										l.Add(lcp.target.nc);  										foreach (Routing.RouteSegment rs in alternativeRoute)  											l.Add(rs.startConnection);    										// calculate my necessary acceleration in case of a line change  										double myAccelerationOnOtherConnection = (otherVehicles.Right != null)  											? CalculateAcceleration(physics.velocity' effectiveDesiredVelocity' otherVehicles.Right.vehicle.currentPosition - myArcPositionOnOtherConnection' physics.velocity - otherVehicles.Right.vehicle.physics.velocity)  											: CalculateAcceleration(physics.velocity' effectiveDesiredVelocity' GetDistanceToNextTrafficLightOnRoute(l' myArcPositionOnOtherConnection' Constants.lookaheadDistance' true)' physics.velocity);    										// calculate the necessary acceleration of the vehicle behind in case of a line change  										double forcedAccelerationOfVehicleBehindMeOnOtherConnection = (otherVehicles.Left != null)  											? CalculateAcceleration(otherVehicles.Left.vehicle.physics.velocity' otherVehicles.Left.vehicle.effectiveDesiredVelocity' otherVehicles.Left.distance' otherVehicles.Left.vehicle.physics.velocity - physics.velocity)  											: 0;    										double currentAccelerationOfVehicleBehindMeOnOtherConnection = (otherVehicles.Left != null) ? otherVehicles.Left.vehicle.physics.acceleration : 0;    										// simplified implementation of MOBIL: http://www.vwi.tu-dresden.de/~treiber/MicroApplet/MOBIL.html  										if (forcedAccelerationOfVehicleBehindMeOnOtherConnection > bSave)  											{  											if (myAccelerationOnOtherConnection - lowestAcceleration > p * (currentAccelerationOfVehicleBehindMeOnOtherConnection - forcedAccelerationOfVehicleBehindMeOnOtherConnection) + lineChangeThreshold)  												{  												// initiate the line change  												InitiateLineChange(lcp' arcPos - lcp.start.arcPosition);  												lowestAcceleration = myAccelerationOnOtherConnection;  												}  											}  										}  									}  								}  							}  						}  					}    				#endregion    				}
Magic Number,CityTrafficSimulator.Vehicle,IVehicle,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\IVehicle.cs,Think,The following statement contains a magic number: if (!onlySimpleCalculations)  				{  				#region Forced line changes    				// our route forces to perform a line change  				if (lineChangeNeeded && !currentlyChangingLine && lci != null)  					{  					thinkAboutLineChange = false;  					lastLineChangeCheck.Left = GlobalTime.Instance.currentTime;  					lastLineChangeCheck.Right = currentPosition;    					// get current LineChangePoint and check' whether it's leading to our target  					NodeConnection.LineChangePoint lcp = route[0].GetPrevLineChangePoint(arcPos);  					if (lci.targetNode.prevConnections.Contains(lcp.target.nc))  						{  						bool slowDownToBreakPoint = false;  						double myArcPositionOnOtherConnection = lcp.otherStart.arcPosition + (arcPos - lcp.start.arcPosition);    						// check if found LineChangePoint is not too far away to perform the line change  						if ((myArcPositionOnOtherConnection >= 0) && (Math.Abs(arcPos - lcp.start.arcPosition) < Constants.maxDistanceToLineChangePoint * 1.25))  							{  							// Check the relation to my surrounding vehicles on the target NodeConnection  							Pair<VehicleDistance> otherVehicles = lcp.otherStart.nc.GetVehiclesAroundArcPosition(myArcPositionOnOtherConnection' Constants.lookaheadDistance);    							// the new vehicle in front wouldn't be too close  							if (   otherVehicles.Right == null  								|| otherVehicles.Right.distance > otherVehicles.Right.vehicle.length + CalculateWantedDistance(physics.velocity' physics.velocity - otherVehicles.Right.vehicle.physics.velocity)/2)  								{  								// the new vehicle behind wouldn't be too close  								if (   otherVehicles.Left == null  									|| otherVehicles.Left.distance > length + otherVehicles.Left.vehicle.CalculateWantedDistance(otherVehicles.Left.vehicle.physics.velocity' otherVehicles.Left.vehicle.physics.velocity - physics.velocity)/2)  									{  									// calculate my necessary acceleration in case of a line change  									double myAccelerationOnOtherConnection = (otherVehicles.Right != null)  										? CalculateAcceleration(physics.velocity' effectiveDesiredVelocity' otherVehicles.Right.vehicle.currentPosition - myArcPositionOnOtherConnection' physics.velocity - otherVehicles.Right.vehicle.physics.velocity)  										: CalculateAcceleration(physics.velocity' effectiveDesiredVelocity' lookaheadDistance' physics.velocity);    									// calculate the necessary acceleration of the vehicle behind in case of a line change  									double forcedAccelerationOfVehicleBehindMeOnOtherConnection = (otherVehicles.Left != null)  										? CalculateAcceleration(otherVehicles.Left.vehicle.physics.velocity' otherVehicles.Left.vehicle.effectiveDesiredVelocity' otherVehicles.Left.distance' otherVehicles.Left.vehicle.physics.velocity - physics.velocity)  										: 0;    									double currentAccelerationOfVehicleBehindMeOnOtherConnection = (otherVehicles.Left != null) ? otherVehicles.Left.vehicle.physics.acceleration : 0;    									// Final check:  									//  - The new vehicle behind must not break harder than bSave  									//  - My line change must be sufficiently necessary. The closer I come to the end of the LineChangeInterval' the more I may thwart the vehicle behind.   									if (   (forcedAccelerationOfVehicleBehindMeOnOtherConnection > bSave)  										&& ((arcPos - lci.startArcPos) / lci.length >= (currentAccelerationOfVehicleBehindMeOnOtherConnection - forcedAccelerationOfVehicleBehindMeOnOtherConnection)))  										{  										// return to normal velocity  										_physics.multiplierTargetVelocity = 1;    										// initiate the line change  										InitiateLineChange(lcp' arcPos - lcp.start.arcPosition);  										lowestAcceleration = myAccelerationOnOtherConnection;  										}  									// I do not want to change line yet' but I could position myself better between the two other vehicles on the parallel line.  									else if (true)  										{  										// TODO: implement  										slowDownToBreakPoint = true;  										}  									}  								// the new vehicle behind would too close but I can accelerate and are at least as fast as him  								else if (   otherVehicles.Left.vehicle.physics.velocity / this.physics.velocity < 1.2  // I am not significantly slower than him  										 && (otherVehicles.Right == null || otherVehicles.Right.distance > 1.5 * length) // the new vehicle in front is far enough away  										 && lookaheadDistance > 2 * length			// no vehicle/traffic light/intersection in front  										 && lci.endArcPos - arcPos > 2 * length		// enough space left in LineChangeInterval  										 && lowestAcceleration >= -0.1)				// currently not braking  									{  									// accelerate to get in front  									_physics.multiplierTargetVelocity = 1.75;  									lowestAcceleration = Math.Min(lowestAcceleration' CalculateAcceleration(physics.velocity' effectiveDesiredVelocity' lookaheadDistance' physics.velocity));    									_state.SetLineChangeVehicleInteraction(this' otherVehicles.Left.vehicle' lcp.otherStart.nc' myArcPositionOnOtherConnection - _length);  									}  								// There is no way to perform a line change now => slow down  								else  									{  									slowDownToBreakPoint = true;  									}  								}  							// The new vehicle in front is too close => slow down  							else  								{  								slowDownToBreakPoint = true;  								}  							}    						if (slowDownToBreakPoint)  							{  							double percentOfLCILeft = Math.Max(0.2' (lci.endArcPos - currentPosition - Constants.breakPointBeforeForcedLineChange) / (lci.length - Constants.breakPointBeforeForcedLineChange));    							// slow down a bit  							_physics.multiplierTargetVelocity = Math.Min(0.9' 1.5 * percentOfLCILeft);    							// When reaching the end of the LineChangeInterval' check whether there are other possibilities to reach the target:  							if (percentOfLCILeft < 0.5)  								{  								Routing newRTT = Routing.CalculateShortestConenction(route[0].endNode' _targetNodes' _vehicleType);  								// The alternative route does not cost too much -> choose it  								if (newRTT.SegmentCount() > 0 && newRTT.costs / _wayToGo.costs < Constants.maxRatioForEnforcedLineChange)  									{  									_wayToGo = newRTT;  									_physics.multiplierTargetVelocity = 1;  									lineChangeNeeded = false;  									lci = null;  									}  								}  							// Line change still necessacy => stop at break point  							if (lineChangeNeeded)  								{  								if (! _state.letVehicleChangeLine && percentOfLCILeft < 0.8)  									{  									VehicleDistance otherBehind = lcp.otherStart.nc.GetVehicleBeforeArcPosition(myArcPositionOnOtherConnection - ((_length + s0))' Constants.lookaheadDistance);    									// In rare cases deadlocks may appear when a very long and a short vehicle are driving parallel to each other (and both want to change line):  									// Then' none of the two finds a vehicle behind on the parallel connection. Hence' none of the two will wait for the other one  									// and both might drive to the end of the line change interval and there block each other.  									// To avoid this case' if there is no otherBehind' we also look for a parallel vehicle in front of our back (there should be one' otherwise  									// something went terribly wrong above). The longer one of the two will wait for the shorter one to make sure' no deadlock will occur.  									if (otherBehind == null)  										{  										VehicleDistance otherFront = lcp.otherStart.nc.GetVehicleBehindArcPosition(myArcPositionOnOtherConnection - ((_length + s0))' Constants.lookaheadDistance);  										if (otherFront.vehicle.lineChangeNeeded && otherFront.vehicle._length > _length)  											{  											otherBehind = otherFront;  											otherBehind.distance *= -1;  											}  										}    									//Pair<VehicleDistance> vd = lcp.otherStart.nc.GetVehiclesAroundArcPosition(myArcPositionOnOtherConnection - ( (_length + s0))' Constants.lookaheadDistance);  									if (otherBehind != null)// && otherBehind.vehicle.p >= p)  										{  										// tell the vehicle behind my back to wait for me  										_state.SetLineChangeVehicleInteraction(this' otherBehind.vehicle' lcp.otherStart.nc' myArcPositionOnOtherConnection - _length);    										// In addition' I need to get behind the vehicle in front of the vehicle which waits for me. Therefore I adapt the desired velocity  										if (_state.vehicleThatLetsMeChangeLine != null)  											{  											VehicleDistance otherBehindForman = _state.vehicleThatLetsMeChangeLine.currentNodeConnection.GetVehicleBehindArcPosition(_state.vehicleThatLetsMeChangeLine.currentPosition' 2 * (length + s0));  											if (otherBehindForman != null)  												{  												//_physics.multiplierTargetVelocity = Math2.Clamp(Math2.Cubic((otherBehindForman.distance - otherBehind.distance - s0) / (_length + 4 * s0))' 0.3' 1);  												double multPerDistance = 1 - Math2.Clamp((otherBehind.distance + _length + s0 - otherBehindForman.distance + otherBehindForman.vehicle._length + s0) / (otherBehindForman.vehicle._length)' 0.2' 0.75);  												double multPerSpeedDiff = Math2.Clamp((otherBehindForman.vehicle._physics.velocity - _physics.velocity) / 2' 0.25' 0.8);  												_physics.multiplierTargetVelocity = Math.Min(multPerDistance' multPerSpeedDiff);  												}  											}  										}  									}    								lowestAcceleration = Math.Min(lowestAcceleration' CalculateAcceleration(physics.velocity' effectiveDesiredVelocity' lci.endArcPos - Constants.breakPointBeforeForcedLineChange - arcPos' physics.velocity));  								}  							}  						}  					}  				else if (_state.vehicleThatLetsMeChangeLine != null)  					{  					_state.UnsetLineChangeVehicleInteraction();  					}    				#endregion    				#region freiwillig    				thinkAboutLineChange &= ((GlobalTime.Instance.currentTime - lastLineChangeCheck.Left > 1) || (currentPosition - lastLineChangeCheck.Right > 50));    				if (thinkAboutLineChange && !currentlyChangingLine)  					{  					lastLineChangeCheck.Left = GlobalTime.Instance.currentTime;  					lastLineChangeCheck.Right = currentPosition;    					// get current LineChangePoint and check' whether it's reachable  					NodeConnection.LineChangePoint lcp = route[0].GetPrevLineChangePoint(arcPos);  					if ((lcp.target.nc != null) && (Math.Abs(arcPos - lcp.start.arcPosition) < Constants.maxDistanceToLineChangePoint * 0.67))  						{  						// check whether there is an alternative route that is not too costly  						Routing alternativeRoute = Routing.CalculateShortestConenction(lcp.target.nc.endNode' targetNodes' _vehicleType);  						if (alternativeRoute.SegmentCount() > 0 && alternativeRoute.costs / wayToGo.costs < Constants.maxRatioForVoluntaryLineChange && !alternativeRoute.Top().lineChangeNeeded)  							{  							double myArcPositionOnOtherConnection = lcp.otherStart.arcPosition + (arcPos - lcp.start.arcPosition);  							if (myArcPositionOnOtherConnection >= 0)  								{  								// Check the relation to my surrounding vehicles on the target NodeConnection  								Pair<VehicleDistance> otherVehicles = lcp.otherStart.nc.GetVehiclesAroundArcPosition(myArcPositionOnOtherConnection' Constants.lookaheadDistance);    								// the new vehicle in front wouldn't be too close  								if (   otherVehicles.Right == null  									|| otherVehicles.Right.distance > otherVehicles.Right.vehicle.length + 2 * lcp.length)  									{  									// the new vehicle behind wouldn't be too close  									if (   otherVehicles.Left == null  										|| otherVehicles.Left.distance > length + otherVehicles.Left.vehicle.CalculateWantedDistance(otherVehicles.Left.vehicle.physics.velocity' otherVehicles.Left.vehicle.physics.velocity - physics.velocity)/2)  										{  										List<NodeConnection> l = new List<NodeConnection>();  										l.Add(lcp.target.nc);  										foreach (Routing.RouteSegment rs in alternativeRoute)  											l.Add(rs.startConnection);    										// calculate my necessary acceleration in case of a line change  										double myAccelerationOnOtherConnection = (otherVehicles.Right != null)  											? CalculateAcceleration(physics.velocity' effectiveDesiredVelocity' otherVehicles.Right.vehicle.currentPosition - myArcPositionOnOtherConnection' physics.velocity - otherVehicles.Right.vehicle.physics.velocity)  											: CalculateAcceleration(physics.velocity' effectiveDesiredVelocity' GetDistanceToNextTrafficLightOnRoute(l' myArcPositionOnOtherConnection' Constants.lookaheadDistance' true)' physics.velocity);    										// calculate the necessary acceleration of the vehicle behind in case of a line change  										double forcedAccelerationOfVehicleBehindMeOnOtherConnection = (otherVehicles.Left != null)  											? CalculateAcceleration(otherVehicles.Left.vehicle.physics.velocity' otherVehicles.Left.vehicle.effectiveDesiredVelocity' otherVehicles.Left.distance' otherVehicles.Left.vehicle.physics.velocity - physics.velocity)  											: 0;    										double currentAccelerationOfVehicleBehindMeOnOtherConnection = (otherVehicles.Left != null) ? otherVehicles.Left.vehicle.physics.acceleration : 0;    										// simplified implementation of MOBIL: http://www.vwi.tu-dresden.de/~treiber/MicroApplet/MOBIL.html  										if (forcedAccelerationOfVehicleBehindMeOnOtherConnection > bSave)  											{  											if (myAccelerationOnOtherConnection - lowestAcceleration > p * (currentAccelerationOfVehicleBehindMeOnOtherConnection - forcedAccelerationOfVehicleBehindMeOnOtherConnection) + lineChangeThreshold)  												{  												// initiate the line change  												InitiateLineChange(lcp' arcPos - lcp.start.arcPosition);  												lowestAcceleration = myAccelerationOnOtherConnection;  												}  											}  										}  									}  								}  							}  						}  					}    				#endregion    				}
Magic Number,CityTrafficSimulator.Vehicle,IVehicle,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\IVehicle.cs,Think,The following statement contains a magic number: if (!onlySimpleCalculations)  				{  				#region Forced line changes    				// our route forces to perform a line change  				if (lineChangeNeeded && !currentlyChangingLine && lci != null)  					{  					thinkAboutLineChange = false;  					lastLineChangeCheck.Left = GlobalTime.Instance.currentTime;  					lastLineChangeCheck.Right = currentPosition;    					// get current LineChangePoint and check' whether it's leading to our target  					NodeConnection.LineChangePoint lcp = route[0].GetPrevLineChangePoint(arcPos);  					if (lci.targetNode.prevConnections.Contains(lcp.target.nc))  						{  						bool slowDownToBreakPoint = false;  						double myArcPositionOnOtherConnection = lcp.otherStart.arcPosition + (arcPos - lcp.start.arcPosition);    						// check if found LineChangePoint is not too far away to perform the line change  						if ((myArcPositionOnOtherConnection >= 0) && (Math.Abs(arcPos - lcp.start.arcPosition) < Constants.maxDistanceToLineChangePoint * 1.25))  							{  							// Check the relation to my surrounding vehicles on the target NodeConnection  							Pair<VehicleDistance> otherVehicles = lcp.otherStart.nc.GetVehiclesAroundArcPosition(myArcPositionOnOtherConnection' Constants.lookaheadDistance);    							// the new vehicle in front wouldn't be too close  							if (   otherVehicles.Right == null  								|| otherVehicles.Right.distance > otherVehicles.Right.vehicle.length + CalculateWantedDistance(physics.velocity' physics.velocity - otherVehicles.Right.vehicle.physics.velocity)/2)  								{  								// the new vehicle behind wouldn't be too close  								if (   otherVehicles.Left == null  									|| otherVehicles.Left.distance > length + otherVehicles.Left.vehicle.CalculateWantedDistance(otherVehicles.Left.vehicle.physics.velocity' otherVehicles.Left.vehicle.physics.velocity - physics.velocity)/2)  									{  									// calculate my necessary acceleration in case of a line change  									double myAccelerationOnOtherConnection = (otherVehicles.Right != null)  										? CalculateAcceleration(physics.velocity' effectiveDesiredVelocity' otherVehicles.Right.vehicle.currentPosition - myArcPositionOnOtherConnection' physics.velocity - otherVehicles.Right.vehicle.physics.velocity)  										: CalculateAcceleration(physics.velocity' effectiveDesiredVelocity' lookaheadDistance' physics.velocity);    									// calculate the necessary acceleration of the vehicle behind in case of a line change  									double forcedAccelerationOfVehicleBehindMeOnOtherConnection = (otherVehicles.Left != null)  										? CalculateAcceleration(otherVehicles.Left.vehicle.physics.velocity' otherVehicles.Left.vehicle.effectiveDesiredVelocity' otherVehicles.Left.distance' otherVehicles.Left.vehicle.physics.velocity - physics.velocity)  										: 0;    									double currentAccelerationOfVehicleBehindMeOnOtherConnection = (otherVehicles.Left != null) ? otherVehicles.Left.vehicle.physics.acceleration : 0;    									// Final check:  									//  - The new vehicle behind must not break harder than bSave  									//  - My line change must be sufficiently necessary. The closer I come to the end of the LineChangeInterval' the more I may thwart the vehicle behind.   									if (   (forcedAccelerationOfVehicleBehindMeOnOtherConnection > bSave)  										&& ((arcPos - lci.startArcPos) / lci.length >= (currentAccelerationOfVehicleBehindMeOnOtherConnection - forcedAccelerationOfVehicleBehindMeOnOtherConnection)))  										{  										// return to normal velocity  										_physics.multiplierTargetVelocity = 1;    										// initiate the line change  										InitiateLineChange(lcp' arcPos - lcp.start.arcPosition);  										lowestAcceleration = myAccelerationOnOtherConnection;  										}  									// I do not want to change line yet' but I could position myself better between the two other vehicles on the parallel line.  									else if (true)  										{  										// TODO: implement  										slowDownToBreakPoint = true;  										}  									}  								// the new vehicle behind would too close but I can accelerate and are at least as fast as him  								else if (   otherVehicles.Left.vehicle.physics.velocity / this.physics.velocity < 1.2  // I am not significantly slower than him  										 && (otherVehicles.Right == null || otherVehicles.Right.distance > 1.5 * length) // the new vehicle in front is far enough away  										 && lookaheadDistance > 2 * length			// no vehicle/traffic light/intersection in front  										 && lci.endArcPos - arcPos > 2 * length		// enough space left in LineChangeInterval  										 && lowestAcceleration >= -0.1)				// currently not braking  									{  									// accelerate to get in front  									_physics.multiplierTargetVelocity = 1.75;  									lowestAcceleration = Math.Min(lowestAcceleration' CalculateAcceleration(physics.velocity' effectiveDesiredVelocity' lookaheadDistance' physics.velocity));    									_state.SetLineChangeVehicleInteraction(this' otherVehicles.Left.vehicle' lcp.otherStart.nc' myArcPositionOnOtherConnection - _length);  									}  								// There is no way to perform a line change now => slow down  								else  									{  									slowDownToBreakPoint = true;  									}  								}  							// The new vehicle in front is too close => slow down  							else  								{  								slowDownToBreakPoint = true;  								}  							}    						if (slowDownToBreakPoint)  							{  							double percentOfLCILeft = Math.Max(0.2' (lci.endArcPos - currentPosition - Constants.breakPointBeforeForcedLineChange) / (lci.length - Constants.breakPointBeforeForcedLineChange));    							// slow down a bit  							_physics.multiplierTargetVelocity = Math.Min(0.9' 1.5 * percentOfLCILeft);    							// When reaching the end of the LineChangeInterval' check whether there are other possibilities to reach the target:  							if (percentOfLCILeft < 0.5)  								{  								Routing newRTT = Routing.CalculateShortestConenction(route[0].endNode' _targetNodes' _vehicleType);  								// The alternative route does not cost too much -> choose it  								if (newRTT.SegmentCount() > 0 && newRTT.costs / _wayToGo.costs < Constants.maxRatioForEnforcedLineChange)  									{  									_wayToGo = newRTT;  									_physics.multiplierTargetVelocity = 1;  									lineChangeNeeded = false;  									lci = null;  									}  								}  							// Line change still necessacy => stop at break point  							if (lineChangeNeeded)  								{  								if (! _state.letVehicleChangeLine && percentOfLCILeft < 0.8)  									{  									VehicleDistance otherBehind = lcp.otherStart.nc.GetVehicleBeforeArcPosition(myArcPositionOnOtherConnection - ((_length + s0))' Constants.lookaheadDistance);    									// In rare cases deadlocks may appear when a very long and a short vehicle are driving parallel to each other (and both want to change line):  									// Then' none of the two finds a vehicle behind on the parallel connection. Hence' none of the two will wait for the other one  									// and both might drive to the end of the line change interval and there block each other.  									// To avoid this case' if there is no otherBehind' we also look for a parallel vehicle in front of our back (there should be one' otherwise  									// something went terribly wrong above). The longer one of the two will wait for the shorter one to make sure' no deadlock will occur.  									if (otherBehind == null)  										{  										VehicleDistance otherFront = lcp.otherStart.nc.GetVehicleBehindArcPosition(myArcPositionOnOtherConnection - ((_length + s0))' Constants.lookaheadDistance);  										if (otherFront.vehicle.lineChangeNeeded && otherFront.vehicle._length > _length)  											{  											otherBehind = otherFront;  											otherBehind.distance *= -1;  											}  										}    									//Pair<VehicleDistance> vd = lcp.otherStart.nc.GetVehiclesAroundArcPosition(myArcPositionOnOtherConnection - ( (_length + s0))' Constants.lookaheadDistance);  									if (otherBehind != null)// && otherBehind.vehicle.p >= p)  										{  										// tell the vehicle behind my back to wait for me  										_state.SetLineChangeVehicleInteraction(this' otherBehind.vehicle' lcp.otherStart.nc' myArcPositionOnOtherConnection - _length);    										// In addition' I need to get behind the vehicle in front of the vehicle which waits for me. Therefore I adapt the desired velocity  										if (_state.vehicleThatLetsMeChangeLine != null)  											{  											VehicleDistance otherBehindForman = _state.vehicleThatLetsMeChangeLine.currentNodeConnection.GetVehicleBehindArcPosition(_state.vehicleThatLetsMeChangeLine.currentPosition' 2 * (length + s0));  											if (otherBehindForman != null)  												{  												//_physics.multiplierTargetVelocity = Math2.Clamp(Math2.Cubic((otherBehindForman.distance - otherBehind.distance - s0) / (_length + 4 * s0))' 0.3' 1);  												double multPerDistance = 1 - Math2.Clamp((otherBehind.distance + _length + s0 - otherBehindForman.distance + otherBehindForman.vehicle._length + s0) / (otherBehindForman.vehicle._length)' 0.2' 0.75);  												double multPerSpeedDiff = Math2.Clamp((otherBehindForman.vehicle._physics.velocity - _physics.velocity) / 2' 0.25' 0.8);  												_physics.multiplierTargetVelocity = Math.Min(multPerDistance' multPerSpeedDiff);  												}  											}  										}  									}    								lowestAcceleration = Math.Min(lowestAcceleration' CalculateAcceleration(physics.velocity' effectiveDesiredVelocity' lci.endArcPos - Constants.breakPointBeforeForcedLineChange - arcPos' physics.velocity));  								}  							}  						}  					}  				else if (_state.vehicleThatLetsMeChangeLine != null)  					{  					_state.UnsetLineChangeVehicleInteraction();  					}    				#endregion    				#region freiwillig    				thinkAboutLineChange &= ((GlobalTime.Instance.currentTime - lastLineChangeCheck.Left > 1) || (currentPosition - lastLineChangeCheck.Right > 50));    				if (thinkAboutLineChange && !currentlyChangingLine)  					{  					lastLineChangeCheck.Left = GlobalTime.Instance.currentTime;  					lastLineChangeCheck.Right = currentPosition;    					// get current LineChangePoint and check' whether it's reachable  					NodeConnection.LineChangePoint lcp = route[0].GetPrevLineChangePoint(arcPos);  					if ((lcp.target.nc != null) && (Math.Abs(arcPos - lcp.start.arcPosition) < Constants.maxDistanceToLineChangePoint * 0.67))  						{  						// check whether there is an alternative route that is not too costly  						Routing alternativeRoute = Routing.CalculateShortestConenction(lcp.target.nc.endNode' targetNodes' _vehicleType);  						if (alternativeRoute.SegmentCount() > 0 && alternativeRoute.costs / wayToGo.costs < Constants.maxRatioForVoluntaryLineChange && !alternativeRoute.Top().lineChangeNeeded)  							{  							double myArcPositionOnOtherConnection = lcp.otherStart.arcPosition + (arcPos - lcp.start.arcPosition);  							if (myArcPositionOnOtherConnection >= 0)  								{  								// Check the relation to my surrounding vehicles on the target NodeConnection  								Pair<VehicleDistance> otherVehicles = lcp.otherStart.nc.GetVehiclesAroundArcPosition(myArcPositionOnOtherConnection' Constants.lookaheadDistance);    								// the new vehicle in front wouldn't be too close  								if (   otherVehicles.Right == null  									|| otherVehicles.Right.distance > otherVehicles.Right.vehicle.length + 2 * lcp.length)  									{  									// the new vehicle behind wouldn't be too close  									if (   otherVehicles.Left == null  										|| otherVehicles.Left.distance > length + otherVehicles.Left.vehicle.CalculateWantedDistance(otherVehicles.Left.vehicle.physics.velocity' otherVehicles.Left.vehicle.physics.velocity - physics.velocity)/2)  										{  										List<NodeConnection> l = new List<NodeConnection>();  										l.Add(lcp.target.nc);  										foreach (Routing.RouteSegment rs in alternativeRoute)  											l.Add(rs.startConnection);    										// calculate my necessary acceleration in case of a line change  										double myAccelerationOnOtherConnection = (otherVehicles.Right != null)  											? CalculateAcceleration(physics.velocity' effectiveDesiredVelocity' otherVehicles.Right.vehicle.currentPosition - myArcPositionOnOtherConnection' physics.velocity - otherVehicles.Right.vehicle.physics.velocity)  											: CalculateAcceleration(physics.velocity' effectiveDesiredVelocity' GetDistanceToNextTrafficLightOnRoute(l' myArcPositionOnOtherConnection' Constants.lookaheadDistance' true)' physics.velocity);    										// calculate the necessary acceleration of the vehicle behind in case of a line change  										double forcedAccelerationOfVehicleBehindMeOnOtherConnection = (otherVehicles.Left != null)  											? CalculateAcceleration(otherVehicles.Left.vehicle.physics.velocity' otherVehicles.Left.vehicle.effectiveDesiredVelocity' otherVehicles.Left.distance' otherVehicles.Left.vehicle.physics.velocity - physics.velocity)  											: 0;    										double currentAccelerationOfVehicleBehindMeOnOtherConnection = (otherVehicles.Left != null) ? otherVehicles.Left.vehicle.physics.acceleration : 0;    										// simplified implementation of MOBIL: http://www.vwi.tu-dresden.de/~treiber/MicroApplet/MOBIL.html  										if (forcedAccelerationOfVehicleBehindMeOnOtherConnection > bSave)  											{  											if (myAccelerationOnOtherConnection - lowestAcceleration > p * (currentAccelerationOfVehicleBehindMeOnOtherConnection - forcedAccelerationOfVehicleBehindMeOnOtherConnection) + lineChangeThreshold)  												{  												// initiate the line change  												InitiateLineChange(lcp' arcPos - lcp.start.arcPosition);  												lowestAcceleration = myAccelerationOnOtherConnection;  												}  											}  										}  									}  								}  							}  						}  					}    				#endregion    				}
Magic Number,CityTrafficSimulator.Vehicle,IVehicle,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\IVehicle.cs,Think,The following statement contains a magic number: if (!onlySimpleCalculations)  				{  				#region Forced line changes    				// our route forces to perform a line change  				if (lineChangeNeeded && !currentlyChangingLine && lci != null)  					{  					thinkAboutLineChange = false;  					lastLineChangeCheck.Left = GlobalTime.Instance.currentTime;  					lastLineChangeCheck.Right = currentPosition;    					// get current LineChangePoint and check' whether it's leading to our target  					NodeConnection.LineChangePoint lcp = route[0].GetPrevLineChangePoint(arcPos);  					if (lci.targetNode.prevConnections.Contains(lcp.target.nc))  						{  						bool slowDownToBreakPoint = false;  						double myArcPositionOnOtherConnection = lcp.otherStart.arcPosition + (arcPos - lcp.start.arcPosition);    						// check if found LineChangePoint is not too far away to perform the line change  						if ((myArcPositionOnOtherConnection >= 0) && (Math.Abs(arcPos - lcp.start.arcPosition) < Constants.maxDistanceToLineChangePoint * 1.25))  							{  							// Check the relation to my surrounding vehicles on the target NodeConnection  							Pair<VehicleDistance> otherVehicles = lcp.otherStart.nc.GetVehiclesAroundArcPosition(myArcPositionOnOtherConnection' Constants.lookaheadDistance);    							// the new vehicle in front wouldn't be too close  							if (   otherVehicles.Right == null  								|| otherVehicles.Right.distance > otherVehicles.Right.vehicle.length + CalculateWantedDistance(physics.velocity' physics.velocity - otherVehicles.Right.vehicle.physics.velocity)/2)  								{  								// the new vehicle behind wouldn't be too close  								if (   otherVehicles.Left == null  									|| otherVehicles.Left.distance > length + otherVehicles.Left.vehicle.CalculateWantedDistance(otherVehicles.Left.vehicle.physics.velocity' otherVehicles.Left.vehicle.physics.velocity - physics.velocity)/2)  									{  									// calculate my necessary acceleration in case of a line change  									double myAccelerationOnOtherConnection = (otherVehicles.Right != null)  										? CalculateAcceleration(physics.velocity' effectiveDesiredVelocity' otherVehicles.Right.vehicle.currentPosition - myArcPositionOnOtherConnection' physics.velocity - otherVehicles.Right.vehicle.physics.velocity)  										: CalculateAcceleration(physics.velocity' effectiveDesiredVelocity' lookaheadDistance' physics.velocity);    									// calculate the necessary acceleration of the vehicle behind in case of a line change  									double forcedAccelerationOfVehicleBehindMeOnOtherConnection = (otherVehicles.Left != null)  										? CalculateAcceleration(otherVehicles.Left.vehicle.physics.velocity' otherVehicles.Left.vehicle.effectiveDesiredVelocity' otherVehicles.Left.distance' otherVehicles.Left.vehicle.physics.velocity - physics.velocity)  										: 0;    									double currentAccelerationOfVehicleBehindMeOnOtherConnection = (otherVehicles.Left != null) ? otherVehicles.Left.vehicle.physics.acceleration : 0;    									// Final check:  									//  - The new vehicle behind must not break harder than bSave  									//  - My line change must be sufficiently necessary. The closer I come to the end of the LineChangeInterval' the more I may thwart the vehicle behind.   									if (   (forcedAccelerationOfVehicleBehindMeOnOtherConnection > bSave)  										&& ((arcPos - lci.startArcPos) / lci.length >= (currentAccelerationOfVehicleBehindMeOnOtherConnection - forcedAccelerationOfVehicleBehindMeOnOtherConnection)))  										{  										// return to normal velocity  										_physics.multiplierTargetVelocity = 1;    										// initiate the line change  										InitiateLineChange(lcp' arcPos - lcp.start.arcPosition);  										lowestAcceleration = myAccelerationOnOtherConnection;  										}  									// I do not want to change line yet' but I could position myself better between the two other vehicles on the parallel line.  									else if (true)  										{  										// TODO: implement  										slowDownToBreakPoint = true;  										}  									}  								// the new vehicle behind would too close but I can accelerate and are at least as fast as him  								else if (   otherVehicles.Left.vehicle.physics.velocity / this.physics.velocity < 1.2  // I am not significantly slower than him  										 && (otherVehicles.Right == null || otherVehicles.Right.distance > 1.5 * length) // the new vehicle in front is far enough away  										 && lookaheadDistance > 2 * length			// no vehicle/traffic light/intersection in front  										 && lci.endArcPos - arcPos > 2 * length		// enough space left in LineChangeInterval  										 && lowestAcceleration >= -0.1)				// currently not braking  									{  									// accelerate to get in front  									_physics.multiplierTargetVelocity = 1.75;  									lowestAcceleration = Math.Min(lowestAcceleration' CalculateAcceleration(physics.velocity' effectiveDesiredVelocity' lookaheadDistance' physics.velocity));    									_state.SetLineChangeVehicleInteraction(this' otherVehicles.Left.vehicle' lcp.otherStart.nc' myArcPositionOnOtherConnection - _length);  									}  								// There is no way to perform a line change now => slow down  								else  									{  									slowDownToBreakPoint = true;  									}  								}  							// The new vehicle in front is too close => slow down  							else  								{  								slowDownToBreakPoint = true;  								}  							}    						if (slowDownToBreakPoint)  							{  							double percentOfLCILeft = Math.Max(0.2' (lci.endArcPos - currentPosition - Constants.breakPointBeforeForcedLineChange) / (lci.length - Constants.breakPointBeforeForcedLineChange));    							// slow down a bit  							_physics.multiplierTargetVelocity = Math.Min(0.9' 1.5 * percentOfLCILeft);    							// When reaching the end of the LineChangeInterval' check whether there are other possibilities to reach the target:  							if (percentOfLCILeft < 0.5)  								{  								Routing newRTT = Routing.CalculateShortestConenction(route[0].endNode' _targetNodes' _vehicleType);  								// The alternative route does not cost too much -> choose it  								if (newRTT.SegmentCount() > 0 && newRTT.costs / _wayToGo.costs < Constants.maxRatioForEnforcedLineChange)  									{  									_wayToGo = newRTT;  									_physics.multiplierTargetVelocity = 1;  									lineChangeNeeded = false;  									lci = null;  									}  								}  							// Line change still necessacy => stop at break point  							if (lineChangeNeeded)  								{  								if (! _state.letVehicleChangeLine && percentOfLCILeft < 0.8)  									{  									VehicleDistance otherBehind = lcp.otherStart.nc.GetVehicleBeforeArcPosition(myArcPositionOnOtherConnection - ((_length + s0))' Constants.lookaheadDistance);    									// In rare cases deadlocks may appear when a very long and a short vehicle are driving parallel to each other (and both want to change line):  									// Then' none of the two finds a vehicle behind on the parallel connection. Hence' none of the two will wait for the other one  									// and both might drive to the end of the line change interval and there block each other.  									// To avoid this case' if there is no otherBehind' we also look for a parallel vehicle in front of our back (there should be one' otherwise  									// something went terribly wrong above). The longer one of the two will wait for the shorter one to make sure' no deadlock will occur.  									if (otherBehind == null)  										{  										VehicleDistance otherFront = lcp.otherStart.nc.GetVehicleBehindArcPosition(myArcPositionOnOtherConnection - ((_length + s0))' Constants.lookaheadDistance);  										if (otherFront.vehicle.lineChangeNeeded && otherFront.vehicle._length > _length)  											{  											otherBehind = otherFront;  											otherBehind.distance *= -1;  											}  										}    									//Pair<VehicleDistance> vd = lcp.otherStart.nc.GetVehiclesAroundArcPosition(myArcPositionOnOtherConnection - ( (_length + s0))' Constants.lookaheadDistance);  									if (otherBehind != null)// && otherBehind.vehicle.p >= p)  										{  										// tell the vehicle behind my back to wait for me  										_state.SetLineChangeVehicleInteraction(this' otherBehind.vehicle' lcp.otherStart.nc' myArcPositionOnOtherConnection - _length);    										// In addition' I need to get behind the vehicle in front of the vehicle which waits for me. Therefore I adapt the desired velocity  										if (_state.vehicleThatLetsMeChangeLine != null)  											{  											VehicleDistance otherBehindForman = _state.vehicleThatLetsMeChangeLine.currentNodeConnection.GetVehicleBehindArcPosition(_state.vehicleThatLetsMeChangeLine.currentPosition' 2 * (length + s0));  											if (otherBehindForman != null)  												{  												//_physics.multiplierTargetVelocity = Math2.Clamp(Math2.Cubic((otherBehindForman.distance - otherBehind.distance - s0) / (_length + 4 * s0))' 0.3' 1);  												double multPerDistance = 1 - Math2.Clamp((otherBehind.distance + _length + s0 - otherBehindForman.distance + otherBehindForman.vehicle._length + s0) / (otherBehindForman.vehicle._length)' 0.2' 0.75);  												double multPerSpeedDiff = Math2.Clamp((otherBehindForman.vehicle._physics.velocity - _physics.velocity) / 2' 0.25' 0.8);  												_physics.multiplierTargetVelocity = Math.Min(multPerDistance' multPerSpeedDiff);  												}  											}  										}  									}    								lowestAcceleration = Math.Min(lowestAcceleration' CalculateAcceleration(physics.velocity' effectiveDesiredVelocity' lci.endArcPos - Constants.breakPointBeforeForcedLineChange - arcPos' physics.velocity));  								}  							}  						}  					}  				else if (_state.vehicleThatLetsMeChangeLine != null)  					{  					_state.UnsetLineChangeVehicleInteraction();  					}    				#endregion    				#region freiwillig    				thinkAboutLineChange &= ((GlobalTime.Instance.currentTime - lastLineChangeCheck.Left > 1) || (currentPosition - lastLineChangeCheck.Right > 50));    				if (thinkAboutLineChange && !currentlyChangingLine)  					{  					lastLineChangeCheck.Left = GlobalTime.Instance.currentTime;  					lastLineChangeCheck.Right = currentPosition;    					// get current LineChangePoint and check' whether it's reachable  					NodeConnection.LineChangePoint lcp = route[0].GetPrevLineChangePoint(arcPos);  					if ((lcp.target.nc != null) && (Math.Abs(arcPos - lcp.start.arcPosition) < Constants.maxDistanceToLineChangePoint * 0.67))  						{  						// check whether there is an alternative route that is not too costly  						Routing alternativeRoute = Routing.CalculateShortestConenction(lcp.target.nc.endNode' targetNodes' _vehicleType);  						if (alternativeRoute.SegmentCount() > 0 && alternativeRoute.costs / wayToGo.costs < Constants.maxRatioForVoluntaryLineChange && !alternativeRoute.Top().lineChangeNeeded)  							{  							double myArcPositionOnOtherConnection = lcp.otherStart.arcPosition + (arcPos - lcp.start.arcPosition);  							if (myArcPositionOnOtherConnection >= 0)  								{  								// Check the relation to my surrounding vehicles on the target NodeConnection  								Pair<VehicleDistance> otherVehicles = lcp.otherStart.nc.GetVehiclesAroundArcPosition(myArcPositionOnOtherConnection' Constants.lookaheadDistance);    								// the new vehicle in front wouldn't be too close  								if (   otherVehicles.Right == null  									|| otherVehicles.Right.distance > otherVehicles.Right.vehicle.length + 2 * lcp.length)  									{  									// the new vehicle behind wouldn't be too close  									if (   otherVehicles.Left == null  										|| otherVehicles.Left.distance > length + otherVehicles.Left.vehicle.CalculateWantedDistance(otherVehicles.Left.vehicle.physics.velocity' otherVehicles.Left.vehicle.physics.velocity - physics.velocity)/2)  										{  										List<NodeConnection> l = new List<NodeConnection>();  										l.Add(lcp.target.nc);  										foreach (Routing.RouteSegment rs in alternativeRoute)  											l.Add(rs.startConnection);    										// calculate my necessary acceleration in case of a line change  										double myAccelerationOnOtherConnection = (otherVehicles.Right != null)  											? CalculateAcceleration(physics.velocity' effectiveDesiredVelocity' otherVehicles.Right.vehicle.currentPosition - myArcPositionOnOtherConnection' physics.velocity - otherVehicles.Right.vehicle.physics.velocity)  											: CalculateAcceleration(physics.velocity' effectiveDesiredVelocity' GetDistanceToNextTrafficLightOnRoute(l' myArcPositionOnOtherConnection' Constants.lookaheadDistance' true)' physics.velocity);    										// calculate the necessary acceleration of the vehicle behind in case of a line change  										double forcedAccelerationOfVehicleBehindMeOnOtherConnection = (otherVehicles.Left != null)  											? CalculateAcceleration(otherVehicles.Left.vehicle.physics.velocity' otherVehicles.Left.vehicle.effectiveDesiredVelocity' otherVehicles.Left.distance' otherVehicles.Left.vehicle.physics.velocity - physics.velocity)  											: 0;    										double currentAccelerationOfVehicleBehindMeOnOtherConnection = (otherVehicles.Left != null) ? otherVehicles.Left.vehicle.physics.acceleration : 0;    										// simplified implementation of MOBIL: http://www.vwi.tu-dresden.de/~treiber/MicroApplet/MOBIL.html  										if (forcedAccelerationOfVehicleBehindMeOnOtherConnection > bSave)  											{  											if (myAccelerationOnOtherConnection - lowestAcceleration > p * (currentAccelerationOfVehicleBehindMeOnOtherConnection - forcedAccelerationOfVehicleBehindMeOnOtherConnection) + lineChangeThreshold)  												{  												// initiate the line change  												InitiateLineChange(lcp' arcPos - lcp.start.arcPosition);  												lowestAcceleration = myAccelerationOnOtherConnection;  												}  											}  										}  									}  								}  							}  						}  					}    				#endregion    				}
Magic Number,CityTrafficSimulator.Vehicle,IVehicle,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\IVehicle.cs,Think,The following statement contains a magic number: if (!onlySimpleCalculations)  				{  				#region Forced line changes    				// our route forces to perform a line change  				if (lineChangeNeeded && !currentlyChangingLine && lci != null)  					{  					thinkAboutLineChange = false;  					lastLineChangeCheck.Left = GlobalTime.Instance.currentTime;  					lastLineChangeCheck.Right = currentPosition;    					// get current LineChangePoint and check' whether it's leading to our target  					NodeConnection.LineChangePoint lcp = route[0].GetPrevLineChangePoint(arcPos);  					if (lci.targetNode.prevConnections.Contains(lcp.target.nc))  						{  						bool slowDownToBreakPoint = false;  						double myArcPositionOnOtherConnection = lcp.otherStart.arcPosition + (arcPos - lcp.start.arcPosition);    						// check if found LineChangePoint is not too far away to perform the line change  						if ((myArcPositionOnOtherConnection >= 0) && (Math.Abs(arcPos - lcp.start.arcPosition) < Constants.maxDistanceToLineChangePoint * 1.25))  							{  							// Check the relation to my surrounding vehicles on the target NodeConnection  							Pair<VehicleDistance> otherVehicles = lcp.otherStart.nc.GetVehiclesAroundArcPosition(myArcPositionOnOtherConnection' Constants.lookaheadDistance);    							// the new vehicle in front wouldn't be too close  							if (   otherVehicles.Right == null  								|| otherVehicles.Right.distance > otherVehicles.Right.vehicle.length + CalculateWantedDistance(physics.velocity' physics.velocity - otherVehicles.Right.vehicle.physics.velocity)/2)  								{  								// the new vehicle behind wouldn't be too close  								if (   otherVehicles.Left == null  									|| otherVehicles.Left.distance > length + otherVehicles.Left.vehicle.CalculateWantedDistance(otherVehicles.Left.vehicle.physics.velocity' otherVehicles.Left.vehicle.physics.velocity - physics.velocity)/2)  									{  									// calculate my necessary acceleration in case of a line change  									double myAccelerationOnOtherConnection = (otherVehicles.Right != null)  										? CalculateAcceleration(physics.velocity' effectiveDesiredVelocity' otherVehicles.Right.vehicle.currentPosition - myArcPositionOnOtherConnection' physics.velocity - otherVehicles.Right.vehicle.physics.velocity)  										: CalculateAcceleration(physics.velocity' effectiveDesiredVelocity' lookaheadDistance' physics.velocity);    									// calculate the necessary acceleration of the vehicle behind in case of a line change  									double forcedAccelerationOfVehicleBehindMeOnOtherConnection = (otherVehicles.Left != null)  										? CalculateAcceleration(otherVehicles.Left.vehicle.physics.velocity' otherVehicles.Left.vehicle.effectiveDesiredVelocity' otherVehicles.Left.distance' otherVehicles.Left.vehicle.physics.velocity - physics.velocity)  										: 0;    									double currentAccelerationOfVehicleBehindMeOnOtherConnection = (otherVehicles.Left != null) ? otherVehicles.Left.vehicle.physics.acceleration : 0;    									// Final check:  									//  - The new vehicle behind must not break harder than bSave  									//  - My line change must be sufficiently necessary. The closer I come to the end of the LineChangeInterval' the more I may thwart the vehicle behind.   									if (   (forcedAccelerationOfVehicleBehindMeOnOtherConnection > bSave)  										&& ((arcPos - lci.startArcPos) / lci.length >= (currentAccelerationOfVehicleBehindMeOnOtherConnection - forcedAccelerationOfVehicleBehindMeOnOtherConnection)))  										{  										// return to normal velocity  										_physics.multiplierTargetVelocity = 1;    										// initiate the line change  										InitiateLineChange(lcp' arcPos - lcp.start.arcPosition);  										lowestAcceleration = myAccelerationOnOtherConnection;  										}  									// I do not want to change line yet' but I could position myself better between the two other vehicles on the parallel line.  									else if (true)  										{  										// TODO: implement  										slowDownToBreakPoint = true;  										}  									}  								// the new vehicle behind would too close but I can accelerate and are at least as fast as him  								else if (   otherVehicles.Left.vehicle.physics.velocity / this.physics.velocity < 1.2  // I am not significantly slower than him  										 && (otherVehicles.Right == null || otherVehicles.Right.distance > 1.5 * length) // the new vehicle in front is far enough away  										 && lookaheadDistance > 2 * length			// no vehicle/traffic light/intersection in front  										 && lci.endArcPos - arcPos > 2 * length		// enough space left in LineChangeInterval  										 && lowestAcceleration >= -0.1)				// currently not braking  									{  									// accelerate to get in front  									_physics.multiplierTargetVelocity = 1.75;  									lowestAcceleration = Math.Min(lowestAcceleration' CalculateAcceleration(physics.velocity' effectiveDesiredVelocity' lookaheadDistance' physics.velocity));    									_state.SetLineChangeVehicleInteraction(this' otherVehicles.Left.vehicle' lcp.otherStart.nc' myArcPositionOnOtherConnection - _length);  									}  								// There is no way to perform a line change now => slow down  								else  									{  									slowDownToBreakPoint = true;  									}  								}  							// The new vehicle in front is too close => slow down  							else  								{  								slowDownToBreakPoint = true;  								}  							}    						if (slowDownToBreakPoint)  							{  							double percentOfLCILeft = Math.Max(0.2' (lci.endArcPos - currentPosition - Constants.breakPointBeforeForcedLineChange) / (lci.length - Constants.breakPointBeforeForcedLineChange));    							// slow down a bit  							_physics.multiplierTargetVelocity = Math.Min(0.9' 1.5 * percentOfLCILeft);    							// When reaching the end of the LineChangeInterval' check whether there are other possibilities to reach the target:  							if (percentOfLCILeft < 0.5)  								{  								Routing newRTT = Routing.CalculateShortestConenction(route[0].endNode' _targetNodes' _vehicleType);  								// The alternative route does not cost too much -> choose it  								if (newRTT.SegmentCount() > 0 && newRTT.costs / _wayToGo.costs < Constants.maxRatioForEnforcedLineChange)  									{  									_wayToGo = newRTT;  									_physics.multiplierTargetVelocity = 1;  									lineChangeNeeded = false;  									lci = null;  									}  								}  							// Line change still necessacy => stop at break point  							if (lineChangeNeeded)  								{  								if (! _state.letVehicleChangeLine && percentOfLCILeft < 0.8)  									{  									VehicleDistance otherBehind = lcp.otherStart.nc.GetVehicleBeforeArcPosition(myArcPositionOnOtherConnection - ((_length + s0))' Constants.lookaheadDistance);    									// In rare cases deadlocks may appear when a very long and a short vehicle are driving parallel to each other (and both want to change line):  									// Then' none of the two finds a vehicle behind on the parallel connection. Hence' none of the two will wait for the other one  									// and both might drive to the end of the line change interval and there block each other.  									// To avoid this case' if there is no otherBehind' we also look for a parallel vehicle in front of our back (there should be one' otherwise  									// something went terribly wrong above). The longer one of the two will wait for the shorter one to make sure' no deadlock will occur.  									if (otherBehind == null)  										{  										VehicleDistance otherFront = lcp.otherStart.nc.GetVehicleBehindArcPosition(myArcPositionOnOtherConnection - ((_length + s0))' Constants.lookaheadDistance);  										if (otherFront.vehicle.lineChangeNeeded && otherFront.vehicle._length > _length)  											{  											otherBehind = otherFront;  											otherBehind.distance *= -1;  											}  										}    									//Pair<VehicleDistance> vd = lcp.otherStart.nc.GetVehiclesAroundArcPosition(myArcPositionOnOtherConnection - ( (_length + s0))' Constants.lookaheadDistance);  									if (otherBehind != null)// && otherBehind.vehicle.p >= p)  										{  										// tell the vehicle behind my back to wait for me  										_state.SetLineChangeVehicleInteraction(this' otherBehind.vehicle' lcp.otherStart.nc' myArcPositionOnOtherConnection - _length);    										// In addition' I need to get behind the vehicle in front of the vehicle which waits for me. Therefore I adapt the desired velocity  										if (_state.vehicleThatLetsMeChangeLine != null)  											{  											VehicleDistance otherBehindForman = _state.vehicleThatLetsMeChangeLine.currentNodeConnection.GetVehicleBehindArcPosition(_state.vehicleThatLetsMeChangeLine.currentPosition' 2 * (length + s0));  											if (otherBehindForman != null)  												{  												//_physics.multiplierTargetVelocity = Math2.Clamp(Math2.Cubic((otherBehindForman.distance - otherBehind.distance - s0) / (_length + 4 * s0))' 0.3' 1);  												double multPerDistance = 1 - Math2.Clamp((otherBehind.distance + _length + s0 - otherBehindForman.distance + otherBehindForman.vehicle._length + s0) / (otherBehindForman.vehicle._length)' 0.2' 0.75);  												double multPerSpeedDiff = Math2.Clamp((otherBehindForman.vehicle._physics.velocity - _physics.velocity) / 2' 0.25' 0.8);  												_physics.multiplierTargetVelocity = Math.Min(multPerDistance' multPerSpeedDiff);  												}  											}  										}  									}    								lowestAcceleration = Math.Min(lowestAcceleration' CalculateAcceleration(physics.velocity' effectiveDesiredVelocity' lci.endArcPos - Constants.breakPointBeforeForcedLineChange - arcPos' physics.velocity));  								}  							}  						}  					}  				else if (_state.vehicleThatLetsMeChangeLine != null)  					{  					_state.UnsetLineChangeVehicleInteraction();  					}    				#endregion    				#region freiwillig    				thinkAboutLineChange &= ((GlobalTime.Instance.currentTime - lastLineChangeCheck.Left > 1) || (currentPosition - lastLineChangeCheck.Right > 50));    				if (thinkAboutLineChange && !currentlyChangingLine)  					{  					lastLineChangeCheck.Left = GlobalTime.Instance.currentTime;  					lastLineChangeCheck.Right = currentPosition;    					// get current LineChangePoint and check' whether it's reachable  					NodeConnection.LineChangePoint lcp = route[0].GetPrevLineChangePoint(arcPos);  					if ((lcp.target.nc != null) && (Math.Abs(arcPos - lcp.start.arcPosition) < Constants.maxDistanceToLineChangePoint * 0.67))  						{  						// check whether there is an alternative route that is not too costly  						Routing alternativeRoute = Routing.CalculateShortestConenction(lcp.target.nc.endNode' targetNodes' _vehicleType);  						if (alternativeRoute.SegmentCount() > 0 && alternativeRoute.costs / wayToGo.costs < Constants.maxRatioForVoluntaryLineChange && !alternativeRoute.Top().lineChangeNeeded)  							{  							double myArcPositionOnOtherConnection = lcp.otherStart.arcPosition + (arcPos - lcp.start.arcPosition);  							if (myArcPositionOnOtherConnection >= 0)  								{  								// Check the relation to my surrounding vehicles on the target NodeConnection  								Pair<VehicleDistance> otherVehicles = lcp.otherStart.nc.GetVehiclesAroundArcPosition(myArcPositionOnOtherConnection' Constants.lookaheadDistance);    								// the new vehicle in front wouldn't be too close  								if (   otherVehicles.Right == null  									|| otherVehicles.Right.distance > otherVehicles.Right.vehicle.length + 2 * lcp.length)  									{  									// the new vehicle behind wouldn't be too close  									if (   otherVehicles.Left == null  										|| otherVehicles.Left.distance > length + otherVehicles.Left.vehicle.CalculateWantedDistance(otherVehicles.Left.vehicle.physics.velocity' otherVehicles.Left.vehicle.physics.velocity - physics.velocity)/2)  										{  										List<NodeConnection> l = new List<NodeConnection>();  										l.Add(lcp.target.nc);  										foreach (Routing.RouteSegment rs in alternativeRoute)  											l.Add(rs.startConnection);    										// calculate my necessary acceleration in case of a line change  										double myAccelerationOnOtherConnection = (otherVehicles.Right != null)  											? CalculateAcceleration(physics.velocity' effectiveDesiredVelocity' otherVehicles.Right.vehicle.currentPosition - myArcPositionOnOtherConnection' physics.velocity - otherVehicles.Right.vehicle.physics.velocity)  											: CalculateAcceleration(physics.velocity' effectiveDesiredVelocity' GetDistanceToNextTrafficLightOnRoute(l' myArcPositionOnOtherConnection' Constants.lookaheadDistance' true)' physics.velocity);    										// calculate the necessary acceleration of the vehicle behind in case of a line change  										double forcedAccelerationOfVehicleBehindMeOnOtherConnection = (otherVehicles.Left != null)  											? CalculateAcceleration(otherVehicles.Left.vehicle.physics.velocity' otherVehicles.Left.vehicle.effectiveDesiredVelocity' otherVehicles.Left.distance' otherVehicles.Left.vehicle.physics.velocity - physics.velocity)  											: 0;    										double currentAccelerationOfVehicleBehindMeOnOtherConnection = (otherVehicles.Left != null) ? otherVehicles.Left.vehicle.physics.acceleration : 0;    										// simplified implementation of MOBIL: http://www.vwi.tu-dresden.de/~treiber/MicroApplet/MOBIL.html  										if (forcedAccelerationOfVehicleBehindMeOnOtherConnection > bSave)  											{  											if (myAccelerationOnOtherConnection - lowestAcceleration > p * (currentAccelerationOfVehicleBehindMeOnOtherConnection - forcedAccelerationOfVehicleBehindMeOnOtherConnection) + lineChangeThreshold)  												{  												// initiate the line change  												InitiateLineChange(lcp' arcPos - lcp.start.arcPosition);  												lowestAcceleration = myAccelerationOnOtherConnection;  												}  											}  										}  									}  								}  							}  						}  					}    				#endregion    				}
Magic Number,CityTrafficSimulator.Vehicle,IVehicle,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\IVehicle.cs,Think,The following statement contains a magic number: if (!onlySimpleCalculations)  				{  				#region Forced line changes    				// our route forces to perform a line change  				if (lineChangeNeeded && !currentlyChangingLine && lci != null)  					{  					thinkAboutLineChange = false;  					lastLineChangeCheck.Left = GlobalTime.Instance.currentTime;  					lastLineChangeCheck.Right = currentPosition;    					// get current LineChangePoint and check' whether it's leading to our target  					NodeConnection.LineChangePoint lcp = route[0].GetPrevLineChangePoint(arcPos);  					if (lci.targetNode.prevConnections.Contains(lcp.target.nc))  						{  						bool slowDownToBreakPoint = false;  						double myArcPositionOnOtherConnection = lcp.otherStart.arcPosition + (arcPos - lcp.start.arcPosition);    						// check if found LineChangePoint is not too far away to perform the line change  						if ((myArcPositionOnOtherConnection >= 0) && (Math.Abs(arcPos - lcp.start.arcPosition) < Constants.maxDistanceToLineChangePoint * 1.25))  							{  							// Check the relation to my surrounding vehicles on the target NodeConnection  							Pair<VehicleDistance> otherVehicles = lcp.otherStart.nc.GetVehiclesAroundArcPosition(myArcPositionOnOtherConnection' Constants.lookaheadDistance);    							// the new vehicle in front wouldn't be too close  							if (   otherVehicles.Right == null  								|| otherVehicles.Right.distance > otherVehicles.Right.vehicle.length + CalculateWantedDistance(physics.velocity' physics.velocity - otherVehicles.Right.vehicle.physics.velocity)/2)  								{  								// the new vehicle behind wouldn't be too close  								if (   otherVehicles.Left == null  									|| otherVehicles.Left.distance > length + otherVehicles.Left.vehicle.CalculateWantedDistance(otherVehicles.Left.vehicle.physics.velocity' otherVehicles.Left.vehicle.physics.velocity - physics.velocity)/2)  									{  									// calculate my necessary acceleration in case of a line change  									double myAccelerationOnOtherConnection = (otherVehicles.Right != null)  										? CalculateAcceleration(physics.velocity' effectiveDesiredVelocity' otherVehicles.Right.vehicle.currentPosition - myArcPositionOnOtherConnection' physics.velocity - otherVehicles.Right.vehicle.physics.velocity)  										: CalculateAcceleration(physics.velocity' effectiveDesiredVelocity' lookaheadDistance' physics.velocity);    									// calculate the necessary acceleration of the vehicle behind in case of a line change  									double forcedAccelerationOfVehicleBehindMeOnOtherConnection = (otherVehicles.Left != null)  										? CalculateAcceleration(otherVehicles.Left.vehicle.physics.velocity' otherVehicles.Left.vehicle.effectiveDesiredVelocity' otherVehicles.Left.distance' otherVehicles.Left.vehicle.physics.velocity - physics.velocity)  										: 0;    									double currentAccelerationOfVehicleBehindMeOnOtherConnection = (otherVehicles.Left != null) ? otherVehicles.Left.vehicle.physics.acceleration : 0;    									// Final check:  									//  - The new vehicle behind must not break harder than bSave  									//  - My line change must be sufficiently necessary. The closer I come to the end of the LineChangeInterval' the more I may thwart the vehicle behind.   									if (   (forcedAccelerationOfVehicleBehindMeOnOtherConnection > bSave)  										&& ((arcPos - lci.startArcPos) / lci.length >= (currentAccelerationOfVehicleBehindMeOnOtherConnection - forcedAccelerationOfVehicleBehindMeOnOtherConnection)))  										{  										// return to normal velocity  										_physics.multiplierTargetVelocity = 1;    										// initiate the line change  										InitiateLineChange(lcp' arcPos - lcp.start.arcPosition);  										lowestAcceleration = myAccelerationOnOtherConnection;  										}  									// I do not want to change line yet' but I could position myself better between the two other vehicles on the parallel line.  									else if (true)  										{  										// TODO: implement  										slowDownToBreakPoint = true;  										}  									}  								// the new vehicle behind would too close but I can accelerate and are at least as fast as him  								else if (   otherVehicles.Left.vehicle.physics.velocity / this.physics.velocity < 1.2  // I am not significantly slower than him  										 && (otherVehicles.Right == null || otherVehicles.Right.distance > 1.5 * length) // the new vehicle in front is far enough away  										 && lookaheadDistance > 2 * length			// no vehicle/traffic light/intersection in front  										 && lci.endArcPos - arcPos > 2 * length		// enough space left in LineChangeInterval  										 && lowestAcceleration >= -0.1)				// currently not braking  									{  									// accelerate to get in front  									_physics.multiplierTargetVelocity = 1.75;  									lowestAcceleration = Math.Min(lowestAcceleration' CalculateAcceleration(physics.velocity' effectiveDesiredVelocity' lookaheadDistance' physics.velocity));    									_state.SetLineChangeVehicleInteraction(this' otherVehicles.Left.vehicle' lcp.otherStart.nc' myArcPositionOnOtherConnection - _length);  									}  								// There is no way to perform a line change now => slow down  								else  									{  									slowDownToBreakPoint = true;  									}  								}  							// The new vehicle in front is too close => slow down  							else  								{  								slowDownToBreakPoint = true;  								}  							}    						if (slowDownToBreakPoint)  							{  							double percentOfLCILeft = Math.Max(0.2' (lci.endArcPos - currentPosition - Constants.breakPointBeforeForcedLineChange) / (lci.length - Constants.breakPointBeforeForcedLineChange));    							// slow down a bit  							_physics.multiplierTargetVelocity = Math.Min(0.9' 1.5 * percentOfLCILeft);    							// When reaching the end of the LineChangeInterval' check whether there are other possibilities to reach the target:  							if (percentOfLCILeft < 0.5)  								{  								Routing newRTT = Routing.CalculateShortestConenction(route[0].endNode' _targetNodes' _vehicleType);  								// The alternative route does not cost too much -> choose it  								if (newRTT.SegmentCount() > 0 && newRTT.costs / _wayToGo.costs < Constants.maxRatioForEnforcedLineChange)  									{  									_wayToGo = newRTT;  									_physics.multiplierTargetVelocity = 1;  									lineChangeNeeded = false;  									lci = null;  									}  								}  							// Line change still necessacy => stop at break point  							if (lineChangeNeeded)  								{  								if (! _state.letVehicleChangeLine && percentOfLCILeft < 0.8)  									{  									VehicleDistance otherBehind = lcp.otherStart.nc.GetVehicleBeforeArcPosition(myArcPositionOnOtherConnection - ((_length + s0))' Constants.lookaheadDistance);    									// In rare cases deadlocks may appear when a very long and a short vehicle are driving parallel to each other (and both want to change line):  									// Then' none of the two finds a vehicle behind on the parallel connection. Hence' none of the two will wait for the other one  									// and both might drive to the end of the line change interval and there block each other.  									// To avoid this case' if there is no otherBehind' we also look for a parallel vehicle in front of our back (there should be one' otherwise  									// something went terribly wrong above). The longer one of the two will wait for the shorter one to make sure' no deadlock will occur.  									if (otherBehind == null)  										{  										VehicleDistance otherFront = lcp.otherStart.nc.GetVehicleBehindArcPosition(myArcPositionOnOtherConnection - ((_length + s0))' Constants.lookaheadDistance);  										if (otherFront.vehicle.lineChangeNeeded && otherFront.vehicle._length > _length)  											{  											otherBehind = otherFront;  											otherBehind.distance *= -1;  											}  										}    									//Pair<VehicleDistance> vd = lcp.otherStart.nc.GetVehiclesAroundArcPosition(myArcPositionOnOtherConnection - ( (_length + s0))' Constants.lookaheadDistance);  									if (otherBehind != null)// && otherBehind.vehicle.p >= p)  										{  										// tell the vehicle behind my back to wait for me  										_state.SetLineChangeVehicleInteraction(this' otherBehind.vehicle' lcp.otherStart.nc' myArcPositionOnOtherConnection - _length);    										// In addition' I need to get behind the vehicle in front of the vehicle which waits for me. Therefore I adapt the desired velocity  										if (_state.vehicleThatLetsMeChangeLine != null)  											{  											VehicleDistance otherBehindForman = _state.vehicleThatLetsMeChangeLine.currentNodeConnection.GetVehicleBehindArcPosition(_state.vehicleThatLetsMeChangeLine.currentPosition' 2 * (length + s0));  											if (otherBehindForman != null)  												{  												//_physics.multiplierTargetVelocity = Math2.Clamp(Math2.Cubic((otherBehindForman.distance - otherBehind.distance - s0) / (_length + 4 * s0))' 0.3' 1);  												double multPerDistance = 1 - Math2.Clamp((otherBehind.distance + _length + s0 - otherBehindForman.distance + otherBehindForman.vehicle._length + s0) / (otherBehindForman.vehicle._length)' 0.2' 0.75);  												double multPerSpeedDiff = Math2.Clamp((otherBehindForman.vehicle._physics.velocity - _physics.velocity) / 2' 0.25' 0.8);  												_physics.multiplierTargetVelocity = Math.Min(multPerDistance' multPerSpeedDiff);  												}  											}  										}  									}    								lowestAcceleration = Math.Min(lowestAcceleration' CalculateAcceleration(physics.velocity' effectiveDesiredVelocity' lci.endArcPos - Constants.breakPointBeforeForcedLineChange - arcPos' physics.velocity));  								}  							}  						}  					}  				else if (_state.vehicleThatLetsMeChangeLine != null)  					{  					_state.UnsetLineChangeVehicleInteraction();  					}    				#endregion    				#region freiwillig    				thinkAboutLineChange &= ((GlobalTime.Instance.currentTime - lastLineChangeCheck.Left > 1) || (currentPosition - lastLineChangeCheck.Right > 50));    				if (thinkAboutLineChange && !currentlyChangingLine)  					{  					lastLineChangeCheck.Left = GlobalTime.Instance.currentTime;  					lastLineChangeCheck.Right = currentPosition;    					// get current LineChangePoint and check' whether it's reachable  					NodeConnection.LineChangePoint lcp = route[0].GetPrevLineChangePoint(arcPos);  					if ((lcp.target.nc != null) && (Math.Abs(arcPos - lcp.start.arcPosition) < Constants.maxDistanceToLineChangePoint * 0.67))  						{  						// check whether there is an alternative route that is not too costly  						Routing alternativeRoute = Routing.CalculateShortestConenction(lcp.target.nc.endNode' targetNodes' _vehicleType);  						if (alternativeRoute.SegmentCount() > 0 && alternativeRoute.costs / wayToGo.costs < Constants.maxRatioForVoluntaryLineChange && !alternativeRoute.Top().lineChangeNeeded)  							{  							double myArcPositionOnOtherConnection = lcp.otherStart.arcPosition + (arcPos - lcp.start.arcPosition);  							if (myArcPositionOnOtherConnection >= 0)  								{  								// Check the relation to my surrounding vehicles on the target NodeConnection  								Pair<VehicleDistance> otherVehicles = lcp.otherStart.nc.GetVehiclesAroundArcPosition(myArcPositionOnOtherConnection' Constants.lookaheadDistance);    								// the new vehicle in front wouldn't be too close  								if (   otherVehicles.Right == null  									|| otherVehicles.Right.distance > otherVehicles.Right.vehicle.length + 2 * lcp.length)  									{  									// the new vehicle behind wouldn't be too close  									if (   otherVehicles.Left == null  										|| otherVehicles.Left.distance > length + otherVehicles.Left.vehicle.CalculateWantedDistance(otherVehicles.Left.vehicle.physics.velocity' otherVehicles.Left.vehicle.physics.velocity - physics.velocity)/2)  										{  										List<NodeConnection> l = new List<NodeConnection>();  										l.Add(lcp.target.nc);  										foreach (Routing.RouteSegment rs in alternativeRoute)  											l.Add(rs.startConnection);    										// calculate my necessary acceleration in case of a line change  										double myAccelerationOnOtherConnection = (otherVehicles.Right != null)  											? CalculateAcceleration(physics.velocity' effectiveDesiredVelocity' otherVehicles.Right.vehicle.currentPosition - myArcPositionOnOtherConnection' physics.velocity - otherVehicles.Right.vehicle.physics.velocity)  											: CalculateAcceleration(physics.velocity' effectiveDesiredVelocity' GetDistanceToNextTrafficLightOnRoute(l' myArcPositionOnOtherConnection' Constants.lookaheadDistance' true)' physics.velocity);    										// calculate the necessary acceleration of the vehicle behind in case of a line change  										double forcedAccelerationOfVehicleBehindMeOnOtherConnection = (otherVehicles.Left != null)  											? CalculateAcceleration(otherVehicles.Left.vehicle.physics.velocity' otherVehicles.Left.vehicle.effectiveDesiredVelocity' otherVehicles.Left.distance' otherVehicles.Left.vehicle.physics.velocity - physics.velocity)  											: 0;    										double currentAccelerationOfVehicleBehindMeOnOtherConnection = (otherVehicles.Left != null) ? otherVehicles.Left.vehicle.physics.acceleration : 0;    										// simplified implementation of MOBIL: http://www.vwi.tu-dresden.de/~treiber/MicroApplet/MOBIL.html  										if (forcedAccelerationOfVehicleBehindMeOnOtherConnection > bSave)  											{  											if (myAccelerationOnOtherConnection - lowestAcceleration > p * (currentAccelerationOfVehicleBehindMeOnOtherConnection - forcedAccelerationOfVehicleBehindMeOnOtherConnection) + lineChangeThreshold)  												{  												// initiate the line change  												InitiateLineChange(lcp' arcPos - lcp.start.arcPosition);  												lowestAcceleration = myAccelerationOnOtherConnection;  												}  											}  										}  									}  								}  							}  						}  					}    				#endregion    				}
Magic Number,CityTrafficSimulator.Vehicle,IVehicle,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\IVehicle.cs,Think,The following statement contains a magic number: if (!onlySimpleCalculations)  				{  				#region Forced line changes    				// our route forces to perform a line change  				if (lineChangeNeeded && !currentlyChangingLine && lci != null)  					{  					thinkAboutLineChange = false;  					lastLineChangeCheck.Left = GlobalTime.Instance.currentTime;  					lastLineChangeCheck.Right = currentPosition;    					// get current LineChangePoint and check' whether it's leading to our target  					NodeConnection.LineChangePoint lcp = route[0].GetPrevLineChangePoint(arcPos);  					if (lci.targetNode.prevConnections.Contains(lcp.target.nc))  						{  						bool slowDownToBreakPoint = false;  						double myArcPositionOnOtherConnection = lcp.otherStart.arcPosition + (arcPos - lcp.start.arcPosition);    						// check if found LineChangePoint is not too far away to perform the line change  						if ((myArcPositionOnOtherConnection >= 0) && (Math.Abs(arcPos - lcp.start.arcPosition) < Constants.maxDistanceToLineChangePoint * 1.25))  							{  							// Check the relation to my surrounding vehicles on the target NodeConnection  							Pair<VehicleDistance> otherVehicles = lcp.otherStart.nc.GetVehiclesAroundArcPosition(myArcPositionOnOtherConnection' Constants.lookaheadDistance);    							// the new vehicle in front wouldn't be too close  							if (   otherVehicles.Right == null  								|| otherVehicles.Right.distance > otherVehicles.Right.vehicle.length + CalculateWantedDistance(physics.velocity' physics.velocity - otherVehicles.Right.vehicle.physics.velocity)/2)  								{  								// the new vehicle behind wouldn't be too close  								if (   otherVehicles.Left == null  									|| otherVehicles.Left.distance > length + otherVehicles.Left.vehicle.CalculateWantedDistance(otherVehicles.Left.vehicle.physics.velocity' otherVehicles.Left.vehicle.physics.velocity - physics.velocity)/2)  									{  									// calculate my necessary acceleration in case of a line change  									double myAccelerationOnOtherConnection = (otherVehicles.Right != null)  										? CalculateAcceleration(physics.velocity' effectiveDesiredVelocity' otherVehicles.Right.vehicle.currentPosition - myArcPositionOnOtherConnection' physics.velocity - otherVehicles.Right.vehicle.physics.velocity)  										: CalculateAcceleration(physics.velocity' effectiveDesiredVelocity' lookaheadDistance' physics.velocity);    									// calculate the necessary acceleration of the vehicle behind in case of a line change  									double forcedAccelerationOfVehicleBehindMeOnOtherConnection = (otherVehicles.Left != null)  										? CalculateAcceleration(otherVehicles.Left.vehicle.physics.velocity' otherVehicles.Left.vehicle.effectiveDesiredVelocity' otherVehicles.Left.distance' otherVehicles.Left.vehicle.physics.velocity - physics.velocity)  										: 0;    									double currentAccelerationOfVehicleBehindMeOnOtherConnection = (otherVehicles.Left != null) ? otherVehicles.Left.vehicle.physics.acceleration : 0;    									// Final check:  									//  - The new vehicle behind must not break harder than bSave  									//  - My line change must be sufficiently necessary. The closer I come to the end of the LineChangeInterval' the more I may thwart the vehicle behind.   									if (   (forcedAccelerationOfVehicleBehindMeOnOtherConnection > bSave)  										&& ((arcPos - lci.startArcPos) / lci.length >= (currentAccelerationOfVehicleBehindMeOnOtherConnection - forcedAccelerationOfVehicleBehindMeOnOtherConnection)))  										{  										// return to normal velocity  										_physics.multiplierTargetVelocity = 1;    										// initiate the line change  										InitiateLineChange(lcp' arcPos - lcp.start.arcPosition);  										lowestAcceleration = myAccelerationOnOtherConnection;  										}  									// I do not want to change line yet' but I could position myself better between the two other vehicles on the parallel line.  									else if (true)  										{  										// TODO: implement  										slowDownToBreakPoint = true;  										}  									}  								// the new vehicle behind would too close but I can accelerate and are at least as fast as him  								else if (   otherVehicles.Left.vehicle.physics.velocity / this.physics.velocity < 1.2  // I am not significantly slower than him  										 && (otherVehicles.Right == null || otherVehicles.Right.distance > 1.5 * length) // the new vehicle in front is far enough away  										 && lookaheadDistance > 2 * length			// no vehicle/traffic light/intersection in front  										 && lci.endArcPos - arcPos > 2 * length		// enough space left in LineChangeInterval  										 && lowestAcceleration >= -0.1)				// currently not braking  									{  									// accelerate to get in front  									_physics.multiplierTargetVelocity = 1.75;  									lowestAcceleration = Math.Min(lowestAcceleration' CalculateAcceleration(physics.velocity' effectiveDesiredVelocity' lookaheadDistance' physics.velocity));    									_state.SetLineChangeVehicleInteraction(this' otherVehicles.Left.vehicle' lcp.otherStart.nc' myArcPositionOnOtherConnection - _length);  									}  								// There is no way to perform a line change now => slow down  								else  									{  									slowDownToBreakPoint = true;  									}  								}  							// The new vehicle in front is too close => slow down  							else  								{  								slowDownToBreakPoint = true;  								}  							}    						if (slowDownToBreakPoint)  							{  							double percentOfLCILeft = Math.Max(0.2' (lci.endArcPos - currentPosition - Constants.breakPointBeforeForcedLineChange) / (lci.length - Constants.breakPointBeforeForcedLineChange));    							// slow down a bit  							_physics.multiplierTargetVelocity = Math.Min(0.9' 1.5 * percentOfLCILeft);    							// When reaching the end of the LineChangeInterval' check whether there are other possibilities to reach the target:  							if (percentOfLCILeft < 0.5)  								{  								Routing newRTT = Routing.CalculateShortestConenction(route[0].endNode' _targetNodes' _vehicleType);  								// The alternative route does not cost too much -> choose it  								if (newRTT.SegmentCount() > 0 && newRTT.costs / _wayToGo.costs < Constants.maxRatioForEnforcedLineChange)  									{  									_wayToGo = newRTT;  									_physics.multiplierTargetVelocity = 1;  									lineChangeNeeded = false;  									lci = null;  									}  								}  							// Line change still necessacy => stop at break point  							if (lineChangeNeeded)  								{  								if (! _state.letVehicleChangeLine && percentOfLCILeft < 0.8)  									{  									VehicleDistance otherBehind = lcp.otherStart.nc.GetVehicleBeforeArcPosition(myArcPositionOnOtherConnection - ((_length + s0))' Constants.lookaheadDistance);    									// In rare cases deadlocks may appear when a very long and a short vehicle are driving parallel to each other (and both want to change line):  									// Then' none of the two finds a vehicle behind on the parallel connection. Hence' none of the two will wait for the other one  									// and both might drive to the end of the line change interval and there block each other.  									// To avoid this case' if there is no otherBehind' we also look for a parallel vehicle in front of our back (there should be one' otherwise  									// something went terribly wrong above). The longer one of the two will wait for the shorter one to make sure' no deadlock will occur.  									if (otherBehind == null)  										{  										VehicleDistance otherFront = lcp.otherStart.nc.GetVehicleBehindArcPosition(myArcPositionOnOtherConnection - ((_length + s0))' Constants.lookaheadDistance);  										if (otherFront.vehicle.lineChangeNeeded && otherFront.vehicle._length > _length)  											{  											otherBehind = otherFront;  											otherBehind.distance *= -1;  											}  										}    									//Pair<VehicleDistance> vd = lcp.otherStart.nc.GetVehiclesAroundArcPosition(myArcPositionOnOtherConnection - ( (_length + s0))' Constants.lookaheadDistance);  									if (otherBehind != null)// && otherBehind.vehicle.p >= p)  										{  										// tell the vehicle behind my back to wait for me  										_state.SetLineChangeVehicleInteraction(this' otherBehind.vehicle' lcp.otherStart.nc' myArcPositionOnOtherConnection - _length);    										// In addition' I need to get behind the vehicle in front of the vehicle which waits for me. Therefore I adapt the desired velocity  										if (_state.vehicleThatLetsMeChangeLine != null)  											{  											VehicleDistance otherBehindForman = _state.vehicleThatLetsMeChangeLine.currentNodeConnection.GetVehicleBehindArcPosition(_state.vehicleThatLetsMeChangeLine.currentPosition' 2 * (length + s0));  											if (otherBehindForman != null)  												{  												//_physics.multiplierTargetVelocity = Math2.Clamp(Math2.Cubic((otherBehindForman.distance - otherBehind.distance - s0) / (_length + 4 * s0))' 0.3' 1);  												double multPerDistance = 1 - Math2.Clamp((otherBehind.distance + _length + s0 - otherBehindForman.distance + otherBehindForman.vehicle._length + s0) / (otherBehindForman.vehicle._length)' 0.2' 0.75);  												double multPerSpeedDiff = Math2.Clamp((otherBehindForman.vehicle._physics.velocity - _physics.velocity) / 2' 0.25' 0.8);  												_physics.multiplierTargetVelocity = Math.Min(multPerDistance' multPerSpeedDiff);  												}  											}  										}  									}    								lowestAcceleration = Math.Min(lowestAcceleration' CalculateAcceleration(physics.velocity' effectiveDesiredVelocity' lci.endArcPos - Constants.breakPointBeforeForcedLineChange - arcPos' physics.velocity));  								}  							}  						}  					}  				else if (_state.vehicleThatLetsMeChangeLine != null)  					{  					_state.UnsetLineChangeVehicleInteraction();  					}    				#endregion    				#region freiwillig    				thinkAboutLineChange &= ((GlobalTime.Instance.currentTime - lastLineChangeCheck.Left > 1) || (currentPosition - lastLineChangeCheck.Right > 50));    				if (thinkAboutLineChange && !currentlyChangingLine)  					{  					lastLineChangeCheck.Left = GlobalTime.Instance.currentTime;  					lastLineChangeCheck.Right = currentPosition;    					// get current LineChangePoint and check' whether it's reachable  					NodeConnection.LineChangePoint lcp = route[0].GetPrevLineChangePoint(arcPos);  					if ((lcp.target.nc != null) && (Math.Abs(arcPos - lcp.start.arcPosition) < Constants.maxDistanceToLineChangePoint * 0.67))  						{  						// check whether there is an alternative route that is not too costly  						Routing alternativeRoute = Routing.CalculateShortestConenction(lcp.target.nc.endNode' targetNodes' _vehicleType);  						if (alternativeRoute.SegmentCount() > 0 && alternativeRoute.costs / wayToGo.costs < Constants.maxRatioForVoluntaryLineChange && !alternativeRoute.Top().lineChangeNeeded)  							{  							double myArcPositionOnOtherConnection = lcp.otherStart.arcPosition + (arcPos - lcp.start.arcPosition);  							if (myArcPositionOnOtherConnection >= 0)  								{  								// Check the relation to my surrounding vehicles on the target NodeConnection  								Pair<VehicleDistance> otherVehicles = lcp.otherStart.nc.GetVehiclesAroundArcPosition(myArcPositionOnOtherConnection' Constants.lookaheadDistance);    								// the new vehicle in front wouldn't be too close  								if (   otherVehicles.Right == null  									|| otherVehicles.Right.distance > otherVehicles.Right.vehicle.length + 2 * lcp.length)  									{  									// the new vehicle behind wouldn't be too close  									if (   otherVehicles.Left == null  										|| otherVehicles.Left.distance > length + otherVehicles.Left.vehicle.CalculateWantedDistance(otherVehicles.Left.vehicle.physics.velocity' otherVehicles.Left.vehicle.physics.velocity - physics.velocity)/2)  										{  										List<NodeConnection> l = new List<NodeConnection>();  										l.Add(lcp.target.nc);  										foreach (Routing.RouteSegment rs in alternativeRoute)  											l.Add(rs.startConnection);    										// calculate my necessary acceleration in case of a line change  										double myAccelerationOnOtherConnection = (otherVehicles.Right != null)  											? CalculateAcceleration(physics.velocity' effectiveDesiredVelocity' otherVehicles.Right.vehicle.currentPosition - myArcPositionOnOtherConnection' physics.velocity - otherVehicles.Right.vehicle.physics.velocity)  											: CalculateAcceleration(physics.velocity' effectiveDesiredVelocity' GetDistanceToNextTrafficLightOnRoute(l' myArcPositionOnOtherConnection' Constants.lookaheadDistance' true)' physics.velocity);    										// calculate the necessary acceleration of the vehicle behind in case of a line change  										double forcedAccelerationOfVehicleBehindMeOnOtherConnection = (otherVehicles.Left != null)  											? CalculateAcceleration(otherVehicles.Left.vehicle.physics.velocity' otherVehicles.Left.vehicle.effectiveDesiredVelocity' otherVehicles.Left.distance' otherVehicles.Left.vehicle.physics.velocity - physics.velocity)  											: 0;    										double currentAccelerationOfVehicleBehindMeOnOtherConnection = (otherVehicles.Left != null) ? otherVehicles.Left.vehicle.physics.acceleration : 0;    										// simplified implementation of MOBIL: http://www.vwi.tu-dresden.de/~treiber/MicroApplet/MOBIL.html  										if (forcedAccelerationOfVehicleBehindMeOnOtherConnection > bSave)  											{  											if (myAccelerationOnOtherConnection - lowestAcceleration > p * (currentAccelerationOfVehicleBehindMeOnOtherConnection - forcedAccelerationOfVehicleBehindMeOnOtherConnection) + lineChangeThreshold)  												{  												// initiate the line change  												InitiateLineChange(lcp' arcPos - lcp.start.arcPosition);  												lowestAcceleration = myAccelerationOnOtherConnection;  												}  											}  										}  									}  								}  							}  						}  					}    				#endregion    				}
Magic Number,CityTrafficSimulator.Vehicle,IVehicle,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\IVehicle.cs,Move,The following statement contains a magic number: if (!alreadyMoved)  				{  				_physics.velocity += physics.acceleration;    				// Rückwärts fahren geht nicht  				if (_physics.velocity < 0)  					_physics.velocity = 0;    				double arcLengthToMove = (physics.velocity * tickLength * 10);    				if (_physics.velocity < 0.1)  					{  					if (!isStopped)  						{  						++_statistics.numStops;  						}  					isStopped = true;  					}  				else  					{  					isStopped = false;  					}    				// wenn ich gerade am Spurwechseln bin' sollte ich das erstmal behandeln  				if (currentlyChangingLine)  					{  					currentPositionOnLineChangePoint += arcLengthToMove; // ich bewege mich echt auf dem LCP  					_state.position += arcLengthToMove * ratioProjectionOnTargetConnectionvsLCPLength; // ich muss meine Position auf der Ziel-NodeConnection entsprechend anpassen  					}  				else  					{  					_state.position += arcLengthToMove;  					}    				// wenn meine aktuelle NodeConnection zu Ende ist' sollte ich das auch behandeln  				if (currentPosition > currentNodeConnection.lineSegment.length)  					{  					// gucken' ob es mit ner Connection weitergeht  					if ((currentNodeConnection.endNode.nextConnections.Count != 0) && (wayToGo.SegmentCount() > 0))  						{  						_physics.multiplierTargetVelocity = 1;  						_state.UnsetLineChangeVehicleInteraction();    						double startDistance = (currentPosition - currentNodeConnection.lineSegment.length);    						// falls ich mehrere Connections zur Auswahl habe' berechne die mit dem kürzesten Weg  						// (dieser könnte sich geändert haben' weil dort plötzlich mehr Autos fahren)  						if (currentNodeConnection.endNode.nextConnections.Count > 1)  							{  							_wayToGo = Routing.CalculateShortestConenction(currentNodeConnection.endNode' targetNodes' _vehicleType);  							if (_wayToGo.SegmentCount() == 0 || _wayToGo.Top() == null)  								{  								RemoveFromCurrentNodeConnection(true' null' 0);  								return;  								}  							}    						visitedNodeConnections.AddFirst(currentNodeConnection);    						// nächsten Wegpunkt extrahieren  						Routing.RouteSegment rs = wayToGo.Pop();    						if (rs == null)  							{  							RemoveFromCurrentNodeConnection(true' null' 0);  							return;  							}  						else  							{  							// ist ein Spurwechsel nötig' so die entsprechenden Felder füllen  							if (rs.lineChangeNeeded)  								rs.startConnection.lineChangeIntervals.TryGetValue(rs.nextNode.hashcode' out lci);  							else  								lci = null;  							lineChangeNeeded = (lci != null);    							LinkedListNode<IVehicle> lln = rs.startConnection.GetVehicleListNodeBehindArcPosition(startDistance);  							if (lln == null || lln.Value.currentPosition - lln.Value.length >= startDistance)  								{  								RemoveFromCurrentNodeConnection(true' rs.startConnection' startDistance);  								}  							else  								{  								RemoveFromCurrentNodeConnection(true' null' 0);  								}  							}  						}  					else  						{  						// Ende der Fahnenstange' also selbstzerstören  						RemoveFromCurrentNodeConnection(true' null' 0);  						}  					}  				else if (Double.IsNaN(currentPosition))  					{  					RemoveFromCurrentNodeConnection(false' null' 0);  					}    				// Der Spurwechsel ist fertig' dann sollte ich diesen auch abschließen:  				if (currentlyChangingLine && currentPositionOnLineChangePoint >= currentLineChangePoint.lineSegment.length)  					{  					FinishLineChange(currentPositionOnLineChangePoint - currentLineChangePoint.lineSegment.length);    					_statistics.startTimeOnNodeConnection = GlobalTime.Instance.currentTime;  					_statistics.arcPositionOfStartOnNodeConnection = _state.position;  					}      				alreadyMoved = true;  				}
Magic Number,CityTrafficSimulator.Vehicle,IVehicle,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\IVehicle.cs,Move,The following statement contains a magic number: if (!alreadyMoved)  				{  				_physics.velocity += physics.acceleration;    				// Rückwärts fahren geht nicht  				if (_physics.velocity < 0)  					_physics.velocity = 0;    				double arcLengthToMove = (physics.velocity * tickLength * 10);    				if (_physics.velocity < 0.1)  					{  					if (!isStopped)  						{  						++_statistics.numStops;  						}  					isStopped = true;  					}  				else  					{  					isStopped = false;  					}    				// wenn ich gerade am Spurwechseln bin' sollte ich das erstmal behandeln  				if (currentlyChangingLine)  					{  					currentPositionOnLineChangePoint += arcLengthToMove; // ich bewege mich echt auf dem LCP  					_state.position += arcLengthToMove * ratioProjectionOnTargetConnectionvsLCPLength; // ich muss meine Position auf der Ziel-NodeConnection entsprechend anpassen  					}  				else  					{  					_state.position += arcLengthToMove;  					}    				// wenn meine aktuelle NodeConnection zu Ende ist' sollte ich das auch behandeln  				if (currentPosition > currentNodeConnection.lineSegment.length)  					{  					// gucken' ob es mit ner Connection weitergeht  					if ((currentNodeConnection.endNode.nextConnections.Count != 0) && (wayToGo.SegmentCount() > 0))  						{  						_physics.multiplierTargetVelocity = 1;  						_state.UnsetLineChangeVehicleInteraction();    						double startDistance = (currentPosition - currentNodeConnection.lineSegment.length);    						// falls ich mehrere Connections zur Auswahl habe' berechne die mit dem kürzesten Weg  						// (dieser könnte sich geändert haben' weil dort plötzlich mehr Autos fahren)  						if (currentNodeConnection.endNode.nextConnections.Count > 1)  							{  							_wayToGo = Routing.CalculateShortestConenction(currentNodeConnection.endNode' targetNodes' _vehicleType);  							if (_wayToGo.SegmentCount() == 0 || _wayToGo.Top() == null)  								{  								RemoveFromCurrentNodeConnection(true' null' 0);  								return;  								}  							}    						visitedNodeConnections.AddFirst(currentNodeConnection);    						// nächsten Wegpunkt extrahieren  						Routing.RouteSegment rs = wayToGo.Pop();    						if (rs == null)  							{  							RemoveFromCurrentNodeConnection(true' null' 0);  							return;  							}  						else  							{  							// ist ein Spurwechsel nötig' so die entsprechenden Felder füllen  							if (rs.lineChangeNeeded)  								rs.startConnection.lineChangeIntervals.TryGetValue(rs.nextNode.hashcode' out lci);  							else  								lci = null;  							lineChangeNeeded = (lci != null);    							LinkedListNode<IVehicle> lln = rs.startConnection.GetVehicleListNodeBehindArcPosition(startDistance);  							if (lln == null || lln.Value.currentPosition - lln.Value.length >= startDistance)  								{  								RemoveFromCurrentNodeConnection(true' rs.startConnection' startDistance);  								}  							else  								{  								RemoveFromCurrentNodeConnection(true' null' 0);  								}  							}  						}  					else  						{  						// Ende der Fahnenstange' also selbstzerstören  						RemoveFromCurrentNodeConnection(true' null' 0);  						}  					}  				else if (Double.IsNaN(currentPosition))  					{  					RemoveFromCurrentNodeConnection(false' null' 0);  					}    				// Der Spurwechsel ist fertig' dann sollte ich diesen auch abschließen:  				if (currentlyChangingLine && currentPositionOnLineChangePoint >= currentLineChangePoint.lineSegment.length)  					{  					FinishLineChange(currentPositionOnLineChangePoint - currentLineChangePoint.lineSegment.length);    					_statistics.startTimeOnNodeConnection = GlobalTime.Instance.currentTime;  					_statistics.arcPositionOfStartOnNodeConnection = _state.position;  					}      				alreadyMoved = true;  				}
Magic Number,CityTrafficSimulator.Vehicle,IVehicle,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\IVehicle.cs,GetTimeToCoverDistance,The following statement contains a magic number: distance /= 10;
Magic Number,CityTrafficSimulator.Vehicle,IVehicle,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\IVehicle.cs,BuildGraphicsPath,The following statement contains a magic number: if (!currentlyChangingLine)  				{  				Vector2 direction = state.orientation;  				if (!direction.IsZeroVector())  					{  					Vector2 orientation = direction.Normalized;  					Vector2 normal = direction.RotatedClockwise.Normalized;    					PointF[] ppoints =   						{   						state.positionAbs  -  8 * normal'  						state.positionAbs  +  8 * normal'  						state.positionAbs  -  length * orientation  +  8 * normal'  						state.positionAbs  -  length * orientation  -  8 * normal'  						};  					toReturn.AddPolygon(ppoints);  					}  				}  			else  				{  				Vector2 positionOnLcp = currentLineChangePoint.lineSegment.AtPosition(currentPositionOnLineChangePoint);  				Vector2 derivate = currentLineChangePoint.lineSegment.DerivateAtTime(currentLineChangePoint.lineSegment.PosToTime(currentPositionOnLineChangePoint));  				if (!derivate.IsZeroVector())  					{  					Vector2 orientation = derivate.Normalized;  					Vector2 normal = derivate.RotatedClockwise.Normalized;  					PointF[] ppoints =   						{   						positionOnLcp  -  8 * normal'  						positionOnLcp  +  8 * normal'  						positionOnLcp  -  length * orientation  +  8 * normal'  						positionOnLcp  -  length * orientation  -  8 * normal'  						};  					toReturn.AddPolygon(ppoints);  					}  				}
Magic Number,CityTrafficSimulator.Vehicle,IVehicle,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\IVehicle.cs,BuildGraphicsPath,The following statement contains a magic number: if (!currentlyChangingLine)  				{  				Vector2 direction = state.orientation;  				if (!direction.IsZeroVector())  					{  					Vector2 orientation = direction.Normalized;  					Vector2 normal = direction.RotatedClockwise.Normalized;    					PointF[] ppoints =   						{   						state.positionAbs  -  8 * normal'  						state.positionAbs  +  8 * normal'  						state.positionAbs  -  length * orientation  +  8 * normal'  						state.positionAbs  -  length * orientation  -  8 * normal'  						};  					toReturn.AddPolygon(ppoints);  					}  				}  			else  				{  				Vector2 positionOnLcp = currentLineChangePoint.lineSegment.AtPosition(currentPositionOnLineChangePoint);  				Vector2 derivate = currentLineChangePoint.lineSegment.DerivateAtTime(currentLineChangePoint.lineSegment.PosToTime(currentPositionOnLineChangePoint));  				if (!derivate.IsZeroVector())  					{  					Vector2 orientation = derivate.Normalized;  					Vector2 normal = derivate.RotatedClockwise.Normalized;  					PointF[] ppoints =   						{   						positionOnLcp  -  8 * normal'  						positionOnLcp  +  8 * normal'  						positionOnLcp  -  length * orientation  +  8 * normal'  						positionOnLcp  -  length * orientation  -  8 * normal'  						};  					toReturn.AddPolygon(ppoints);  					}  				}
Magic Number,CityTrafficSimulator.Vehicle,IVehicle,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\IVehicle.cs,BuildGraphicsPath,The following statement contains a magic number: if (!currentlyChangingLine)  				{  				Vector2 direction = state.orientation;  				if (!direction.IsZeroVector())  					{  					Vector2 orientation = direction.Normalized;  					Vector2 normal = direction.RotatedClockwise.Normalized;    					PointF[] ppoints =   						{   						state.positionAbs  -  8 * normal'  						state.positionAbs  +  8 * normal'  						state.positionAbs  -  length * orientation  +  8 * normal'  						state.positionAbs  -  length * orientation  -  8 * normal'  						};  					toReturn.AddPolygon(ppoints);  					}  				}  			else  				{  				Vector2 positionOnLcp = currentLineChangePoint.lineSegment.AtPosition(currentPositionOnLineChangePoint);  				Vector2 derivate = currentLineChangePoint.lineSegment.DerivateAtTime(currentLineChangePoint.lineSegment.PosToTime(currentPositionOnLineChangePoint));  				if (!derivate.IsZeroVector())  					{  					Vector2 orientation = derivate.Normalized;  					Vector2 normal = derivate.RotatedClockwise.Normalized;  					PointF[] ppoints =   						{   						positionOnLcp  -  8 * normal'  						positionOnLcp  +  8 * normal'  						positionOnLcp  -  length * orientation  +  8 * normal'  						positionOnLcp  -  length * orientation  -  8 * normal'  						};  					toReturn.AddPolygon(ppoints);  					}  				}
Magic Number,CityTrafficSimulator.Vehicle,IVehicle,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\IVehicle.cs,BuildGraphicsPath,The following statement contains a magic number: if (!currentlyChangingLine)  				{  				Vector2 direction = state.orientation;  				if (!direction.IsZeroVector())  					{  					Vector2 orientation = direction.Normalized;  					Vector2 normal = direction.RotatedClockwise.Normalized;    					PointF[] ppoints =   						{   						state.positionAbs  -  8 * normal'  						state.positionAbs  +  8 * normal'  						state.positionAbs  -  length * orientation  +  8 * normal'  						state.positionAbs  -  length * orientation  -  8 * normal'  						};  					toReturn.AddPolygon(ppoints);  					}  				}  			else  				{  				Vector2 positionOnLcp = currentLineChangePoint.lineSegment.AtPosition(currentPositionOnLineChangePoint);  				Vector2 derivate = currentLineChangePoint.lineSegment.DerivateAtTime(currentLineChangePoint.lineSegment.PosToTime(currentPositionOnLineChangePoint));  				if (!derivate.IsZeroVector())  					{  					Vector2 orientation = derivate.Normalized;  					Vector2 normal = derivate.RotatedClockwise.Normalized;  					PointF[] ppoints =   						{   						positionOnLcp  -  8 * normal'  						positionOnLcp  +  8 * normal'  						positionOnLcp  -  length * orientation  +  8 * normal'  						positionOnLcp  -  length * orientation  -  8 * normal'  						};  					toReturn.AddPolygon(ppoints);  					}  				}
Magic Number,CityTrafficSimulator.Vehicle,IVehicle,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\IVehicle.cs,BuildGraphicsPath,The following statement contains a magic number: if (!currentlyChangingLine)  				{  				Vector2 direction = state.orientation;  				if (!direction.IsZeroVector())  					{  					Vector2 orientation = direction.Normalized;  					Vector2 normal = direction.RotatedClockwise.Normalized;    					PointF[] ppoints =   						{   						state.positionAbs  -  8 * normal'  						state.positionAbs  +  8 * normal'  						state.positionAbs  -  length * orientation  +  8 * normal'  						state.positionAbs  -  length * orientation  -  8 * normal'  						};  					toReturn.AddPolygon(ppoints);  					}  				}  			else  				{  				Vector2 positionOnLcp = currentLineChangePoint.lineSegment.AtPosition(currentPositionOnLineChangePoint);  				Vector2 derivate = currentLineChangePoint.lineSegment.DerivateAtTime(currentLineChangePoint.lineSegment.PosToTime(currentPositionOnLineChangePoint));  				if (!derivate.IsZeroVector())  					{  					Vector2 orientation = derivate.Normalized;  					Vector2 normal = derivate.RotatedClockwise.Normalized;  					PointF[] ppoints =   						{   						positionOnLcp  -  8 * normal'  						positionOnLcp  +  8 * normal'  						positionOnLcp  -  length * orientation  +  8 * normal'  						positionOnLcp  -  length * orientation  -  8 * normal'  						};  					toReturn.AddPolygon(ppoints);  					}  				}
Magic Number,CityTrafficSimulator.Vehicle,IVehicle,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\IVehicle.cs,BuildGraphicsPath,The following statement contains a magic number: if (!currentlyChangingLine)  				{  				Vector2 direction = state.orientation;  				if (!direction.IsZeroVector())  					{  					Vector2 orientation = direction.Normalized;  					Vector2 normal = direction.RotatedClockwise.Normalized;    					PointF[] ppoints =   						{   						state.positionAbs  -  8 * normal'  						state.positionAbs  +  8 * normal'  						state.positionAbs  -  length * orientation  +  8 * normal'  						state.positionAbs  -  length * orientation  -  8 * normal'  						};  					toReturn.AddPolygon(ppoints);  					}  				}  			else  				{  				Vector2 positionOnLcp = currentLineChangePoint.lineSegment.AtPosition(currentPositionOnLineChangePoint);  				Vector2 derivate = currentLineChangePoint.lineSegment.DerivateAtTime(currentLineChangePoint.lineSegment.PosToTime(currentPositionOnLineChangePoint));  				if (!derivate.IsZeroVector())  					{  					Vector2 orientation = derivate.Normalized;  					Vector2 normal = derivate.RotatedClockwise.Normalized;  					PointF[] ppoints =   						{   						positionOnLcp  -  8 * normal'  						positionOnLcp  +  8 * normal'  						positionOnLcp  -  length * orientation  +  8 * normal'  						positionOnLcp  -  length * orientation  -  8 * normal'  						};  					toReturn.AddPolygon(ppoints);  					}  				}
Magic Number,CityTrafficSimulator.Vehicle,IVehicle,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\IVehicle.cs,BuildGraphicsPath,The following statement contains a magic number: if (!currentlyChangingLine)  				{  				Vector2 direction = state.orientation;  				if (!direction.IsZeroVector())  					{  					Vector2 orientation = direction.Normalized;  					Vector2 normal = direction.RotatedClockwise.Normalized;    					PointF[] ppoints =   						{   						state.positionAbs  -  8 * normal'  						state.positionAbs  +  8 * normal'  						state.positionAbs  -  length * orientation  +  8 * normal'  						state.positionAbs  -  length * orientation  -  8 * normal'  						};  					toReturn.AddPolygon(ppoints);  					}  				}  			else  				{  				Vector2 positionOnLcp = currentLineChangePoint.lineSegment.AtPosition(currentPositionOnLineChangePoint);  				Vector2 derivate = currentLineChangePoint.lineSegment.DerivateAtTime(currentLineChangePoint.lineSegment.PosToTime(currentPositionOnLineChangePoint));  				if (!derivate.IsZeroVector())  					{  					Vector2 orientation = derivate.Normalized;  					Vector2 normal = derivate.RotatedClockwise.Normalized;  					PointF[] ppoints =   						{   						positionOnLcp  -  8 * normal'  						positionOnLcp  +  8 * normal'  						positionOnLcp  -  length * orientation  +  8 * normal'  						positionOnLcp  -  length * orientation  -  8 * normal'  						};  					toReturn.AddPolygon(ppoints);  					}  				}
Magic Number,CityTrafficSimulator.Vehicle,IVehicle,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\IVehicle.cs,BuildGraphicsPath,The following statement contains a magic number: if (!currentlyChangingLine)  				{  				Vector2 direction = state.orientation;  				if (!direction.IsZeroVector())  					{  					Vector2 orientation = direction.Normalized;  					Vector2 normal = direction.RotatedClockwise.Normalized;    					PointF[] ppoints =   						{   						state.positionAbs  -  8 * normal'  						state.positionAbs  +  8 * normal'  						state.positionAbs  -  length * orientation  +  8 * normal'  						state.positionAbs  -  length * orientation  -  8 * normal'  						};  					toReturn.AddPolygon(ppoints);  					}  				}  			else  				{  				Vector2 positionOnLcp = currentLineChangePoint.lineSegment.AtPosition(currentPositionOnLineChangePoint);  				Vector2 derivate = currentLineChangePoint.lineSegment.DerivateAtTime(currentLineChangePoint.lineSegment.PosToTime(currentPositionOnLineChangePoint));  				if (!derivate.IsZeroVector())  					{  					Vector2 orientation = derivate.Normalized;  					Vector2 normal = derivate.RotatedClockwise.Normalized;  					PointF[] ppoints =   						{   						positionOnLcp  -  8 * normal'  						positionOnLcp  +  8 * normal'  						positionOnLcp  -  length * orientation  +  8 * normal'  						positionOnLcp  -  length * orientation  -  8 * normal'  						};  					toReturn.AddPolygon(ppoints);  					}  				}
Magic Number,CityTrafficSimulator.Vehicle,IVehicle,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\IVehicle.cs,DrawDebugData,The following statement contains a magic number: Pen lineToIntersectionPen = new Pen(Color.Maroon' 3);
Magic Number,CityTrafficSimulator.Vehicle,IVehicle,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\IVehicle.cs,DrawDebugData,The following statement contains a magic number: Font debugFont = new Font("Calibri"' 6);
Magic Number,CityTrafficSimulator.Vehicle,IVehicle,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\IVehicle.cs,DrawDebugData,The following statement contains a magic number: foreach (SpecificIntersection si in registeredIntersections)  				{  				g.DrawLine(lineToIntersectionPen' state.positionAbs' si.intersection.aPosition);  				CrossingVehicleTimes myCvt = si.intersection.GetCrossingVehicleTimes(this' si.nodeConnection);  				g.DrawString("arr.: " + myCvt.originalArrivingTime.ToString("####.##") + "' wait: " + myCvt.willWaitInFrontOfIntersection' debugFont' blackBrush' (state.positionAbs + si.intersection.aPosition) * 0.5);  				}
Magic Number,CityTrafficSimulator.Vehicle,IVehicle,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\IVehicle.cs,DrawDebugData,The following statement contains a magic number: g.DrawString(hashcode.ToString() + " @ " + currentPosition.ToString("####") + "dm - " + physics.velocity.ToString("##.#") + "m/s - Mult.: " + physics.multiplierTargetVelocity.ToString("#.##") + debugData.ToString()' debugFont' blackBrush' state.positionAbs + new Vector2(0' -10));
Magic Number,CityTrafficSimulator.Vehicle,Tram,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Tram.cs,Tram,The following statement contains a magic number: length = (GlobalRandom.Instance.Next(2) == 0) ? 250 : 400;
Magic Number,CityTrafficSimulator.Vehicle,Tram,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Tram.cs,Tram,The following statement contains a magic number: length = (GlobalRandom.Instance.Next(2) == 0) ? 250 : 400;
Magic Number,CityTrafficSimulator.Vehicle,Tram,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Tram.cs,Tram,The following statement contains a magic number: length = (GlobalRandom.Instance.Next(2) == 0) ? 250 : 400;
Magic Number,CityTrafficSimulator.Vehicle,Tram,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Tram.cs,Tram,The following statement contains a magic number: color = Color.FromArgb(GlobalRandom.Instance.Next(256)' GlobalRandom.Instance.Next(256)' GlobalRandom.Instance.Next(256));
Magic Number,CityTrafficSimulator.Vehicle,Tram,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Tram.cs,Tram,The following statement contains a magic number: color = Color.FromArgb(GlobalRandom.Instance.Next(256)' GlobalRandom.Instance.Next(256)' GlobalRandom.Instance.Next(256));
Magic Number,CityTrafficSimulator.Vehicle,Tram,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Tram.cs,Tram,The following statement contains a magic number: color = Color.FromArgb(GlobalRandom.Instance.Next(256)' GlobalRandom.Instance.Next(256)' GlobalRandom.Instance.Next(256));
Magic Number,CityTrafficSimulator.Vehicle,Tram,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Tram.cs,BuildGraphicsPath,The following statement contains a magic number: if (_length == 250)  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized  									  };    				PointF[] frontPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] midPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] backPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				if (positions[0] != positions[1])  					toReturn.AddPolygon(frontPoints);  				if (positions[2] != positions[3])  					toReturn.AddPolygon(midPoints);  				if (positions[4] != positions[5])  					toReturn.AddPolygon(backPoints);  				}  			// 40-Meter-Zug  			else  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)'  					GetPositionAbsAtArcPos(currentPosition - 255)'  					GetPositionAbsAtArcPos(currentPosition - 300)'  					GetPositionAbsAtArcPos(currentPosition - 305)'  					GetPositionAbsAtArcPos(currentPosition - 400)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized'  					(positions[6] - positions[7]).RotatedClockwise.Normalized'  					(positions[7] - positions[9]).RotatedClockwise.Normalized  									  };    				PointF[] firstPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] secondPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] thirdPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				PointF[] forthPoints =   					{   					positions[6]  -  11*normals[3]'  					positions[6]  +  11*normals[3]'  					positions[7]  +  11*normals[3]'  					positions[7]  -  11*normals[3]'  					};    				PointF[] fifthPoints =   					{   					positions[8]  -  11*normals[4]'  					positions[8]  +  11*normals[4]'  					positions[9]  +  11*normals[4]'  					positions[9]  -  11*normals[4]'  					};    				if ((positions[0] - positions[1]).IsNotZeroVector())  					toReturn.AddPolygon(firstPoints);  				if ((positions[2] - positions[3]).IsNotZeroVector())  					toReturn.AddPolygon(secondPoints);  				if ((positions[4] - positions[5]).IsNotZeroVector())  					toReturn.AddPolygon(thirdPoints);  				if ((positions[6] - positions[7]).IsNotZeroVector())  					toReturn.AddPolygon(forthPoints);  				if ((positions[8] - positions[9]).IsNotZeroVector())  					toReturn.AddPolygon(fifthPoints);  				}
Magic Number,CityTrafficSimulator.Vehicle,Tram,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Tram.cs,BuildGraphicsPath,The following statement contains a magic number: if (_length == 250)  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized  									  };    				PointF[] frontPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] midPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] backPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				if (positions[0] != positions[1])  					toReturn.AddPolygon(frontPoints);  				if (positions[2] != positions[3])  					toReturn.AddPolygon(midPoints);  				if (positions[4] != positions[5])  					toReturn.AddPolygon(backPoints);  				}  			// 40-Meter-Zug  			else  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)'  					GetPositionAbsAtArcPos(currentPosition - 255)'  					GetPositionAbsAtArcPos(currentPosition - 300)'  					GetPositionAbsAtArcPos(currentPosition - 305)'  					GetPositionAbsAtArcPos(currentPosition - 400)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized'  					(positions[6] - positions[7]).RotatedClockwise.Normalized'  					(positions[7] - positions[9]).RotatedClockwise.Normalized  									  };    				PointF[] firstPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] secondPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] thirdPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				PointF[] forthPoints =   					{   					positions[6]  -  11*normals[3]'  					positions[6]  +  11*normals[3]'  					positions[7]  +  11*normals[3]'  					positions[7]  -  11*normals[3]'  					};    				PointF[] fifthPoints =   					{   					positions[8]  -  11*normals[4]'  					positions[8]  +  11*normals[4]'  					positions[9]  +  11*normals[4]'  					positions[9]  -  11*normals[4]'  					};    				if ((positions[0] - positions[1]).IsNotZeroVector())  					toReturn.AddPolygon(firstPoints);  				if ((positions[2] - positions[3]).IsNotZeroVector())  					toReturn.AddPolygon(secondPoints);  				if ((positions[4] - positions[5]).IsNotZeroVector())  					toReturn.AddPolygon(thirdPoints);  				if ((positions[6] - positions[7]).IsNotZeroVector())  					toReturn.AddPolygon(forthPoints);  				if ((positions[8] - positions[9]).IsNotZeroVector())  					toReturn.AddPolygon(fifthPoints);  				}
Magic Number,CityTrafficSimulator.Vehicle,Tram,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Tram.cs,BuildGraphicsPath,The following statement contains a magic number: if (_length == 250)  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized  									  };    				PointF[] frontPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] midPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] backPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				if (positions[0] != positions[1])  					toReturn.AddPolygon(frontPoints);  				if (positions[2] != positions[3])  					toReturn.AddPolygon(midPoints);  				if (positions[4] != positions[5])  					toReturn.AddPolygon(backPoints);  				}  			// 40-Meter-Zug  			else  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)'  					GetPositionAbsAtArcPos(currentPosition - 255)'  					GetPositionAbsAtArcPos(currentPosition - 300)'  					GetPositionAbsAtArcPos(currentPosition - 305)'  					GetPositionAbsAtArcPos(currentPosition - 400)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized'  					(positions[6] - positions[7]).RotatedClockwise.Normalized'  					(positions[7] - positions[9]).RotatedClockwise.Normalized  									  };    				PointF[] firstPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] secondPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] thirdPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				PointF[] forthPoints =   					{   					positions[6]  -  11*normals[3]'  					positions[6]  +  11*normals[3]'  					positions[7]  +  11*normals[3]'  					positions[7]  -  11*normals[3]'  					};    				PointF[] fifthPoints =   					{   					positions[8]  -  11*normals[4]'  					positions[8]  +  11*normals[4]'  					positions[9]  +  11*normals[4]'  					positions[9]  -  11*normals[4]'  					};    				if ((positions[0] - positions[1]).IsNotZeroVector())  					toReturn.AddPolygon(firstPoints);  				if ((positions[2] - positions[3]).IsNotZeroVector())  					toReturn.AddPolygon(secondPoints);  				if ((positions[4] - positions[5]).IsNotZeroVector())  					toReturn.AddPolygon(thirdPoints);  				if ((positions[6] - positions[7]).IsNotZeroVector())  					toReturn.AddPolygon(forthPoints);  				if ((positions[8] - positions[9]).IsNotZeroVector())  					toReturn.AddPolygon(fifthPoints);  				}
Magic Number,CityTrafficSimulator.Vehicle,Tram,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Tram.cs,BuildGraphicsPath,The following statement contains a magic number: if (_length == 250)  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized  									  };    				PointF[] frontPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] midPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] backPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				if (positions[0] != positions[1])  					toReturn.AddPolygon(frontPoints);  				if (positions[2] != positions[3])  					toReturn.AddPolygon(midPoints);  				if (positions[4] != positions[5])  					toReturn.AddPolygon(backPoints);  				}  			// 40-Meter-Zug  			else  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)'  					GetPositionAbsAtArcPos(currentPosition - 255)'  					GetPositionAbsAtArcPos(currentPosition - 300)'  					GetPositionAbsAtArcPos(currentPosition - 305)'  					GetPositionAbsAtArcPos(currentPosition - 400)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized'  					(positions[6] - positions[7]).RotatedClockwise.Normalized'  					(positions[7] - positions[9]).RotatedClockwise.Normalized  									  };    				PointF[] firstPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] secondPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] thirdPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				PointF[] forthPoints =   					{   					positions[6]  -  11*normals[3]'  					positions[6]  +  11*normals[3]'  					positions[7]  +  11*normals[3]'  					positions[7]  -  11*normals[3]'  					};    				PointF[] fifthPoints =   					{   					positions[8]  -  11*normals[4]'  					positions[8]  +  11*normals[4]'  					positions[9]  +  11*normals[4]'  					positions[9]  -  11*normals[4]'  					};    				if ((positions[0] - positions[1]).IsNotZeroVector())  					toReturn.AddPolygon(firstPoints);  				if ((positions[2] - positions[3]).IsNotZeroVector())  					toReturn.AddPolygon(secondPoints);  				if ((positions[4] - positions[5]).IsNotZeroVector())  					toReturn.AddPolygon(thirdPoints);  				if ((positions[6] - positions[7]).IsNotZeroVector())  					toReturn.AddPolygon(forthPoints);  				if ((positions[8] - positions[9]).IsNotZeroVector())  					toReturn.AddPolygon(fifthPoints);  				}
Magic Number,CityTrafficSimulator.Vehicle,Tram,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Tram.cs,BuildGraphicsPath,The following statement contains a magic number: if (_length == 250)  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized  									  };    				PointF[] frontPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] midPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] backPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				if (positions[0] != positions[1])  					toReturn.AddPolygon(frontPoints);  				if (positions[2] != positions[3])  					toReturn.AddPolygon(midPoints);  				if (positions[4] != positions[5])  					toReturn.AddPolygon(backPoints);  				}  			// 40-Meter-Zug  			else  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)'  					GetPositionAbsAtArcPos(currentPosition - 255)'  					GetPositionAbsAtArcPos(currentPosition - 300)'  					GetPositionAbsAtArcPos(currentPosition - 305)'  					GetPositionAbsAtArcPos(currentPosition - 400)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized'  					(positions[6] - positions[7]).RotatedClockwise.Normalized'  					(positions[7] - positions[9]).RotatedClockwise.Normalized  									  };    				PointF[] firstPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] secondPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] thirdPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				PointF[] forthPoints =   					{   					positions[6]  -  11*normals[3]'  					positions[6]  +  11*normals[3]'  					positions[7]  +  11*normals[3]'  					positions[7]  -  11*normals[3]'  					};    				PointF[] fifthPoints =   					{   					positions[8]  -  11*normals[4]'  					positions[8]  +  11*normals[4]'  					positions[9]  +  11*normals[4]'  					positions[9]  -  11*normals[4]'  					};    				if ((positions[0] - positions[1]).IsNotZeroVector())  					toReturn.AddPolygon(firstPoints);  				if ((positions[2] - positions[3]).IsNotZeroVector())  					toReturn.AddPolygon(secondPoints);  				if ((positions[4] - positions[5]).IsNotZeroVector())  					toReturn.AddPolygon(thirdPoints);  				if ((positions[6] - positions[7]).IsNotZeroVector())  					toReturn.AddPolygon(forthPoints);  				if ((positions[8] - positions[9]).IsNotZeroVector())  					toReturn.AddPolygon(fifthPoints);  				}
Magic Number,CityTrafficSimulator.Vehicle,Tram,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Tram.cs,BuildGraphicsPath,The following statement contains a magic number: if (_length == 250)  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized  									  };    				PointF[] frontPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] midPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] backPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				if (positions[0] != positions[1])  					toReturn.AddPolygon(frontPoints);  				if (positions[2] != positions[3])  					toReturn.AddPolygon(midPoints);  				if (positions[4] != positions[5])  					toReturn.AddPolygon(backPoints);  				}  			// 40-Meter-Zug  			else  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)'  					GetPositionAbsAtArcPos(currentPosition - 255)'  					GetPositionAbsAtArcPos(currentPosition - 300)'  					GetPositionAbsAtArcPos(currentPosition - 305)'  					GetPositionAbsAtArcPos(currentPosition - 400)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized'  					(positions[6] - positions[7]).RotatedClockwise.Normalized'  					(positions[7] - positions[9]).RotatedClockwise.Normalized  									  };    				PointF[] firstPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] secondPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] thirdPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				PointF[] forthPoints =   					{   					positions[6]  -  11*normals[3]'  					positions[6]  +  11*normals[3]'  					positions[7]  +  11*normals[3]'  					positions[7]  -  11*normals[3]'  					};    				PointF[] fifthPoints =   					{   					positions[8]  -  11*normals[4]'  					positions[8]  +  11*normals[4]'  					positions[9]  +  11*normals[4]'  					positions[9]  -  11*normals[4]'  					};    				if ((positions[0] - positions[1]).IsNotZeroVector())  					toReturn.AddPolygon(firstPoints);  				if ((positions[2] - positions[3]).IsNotZeroVector())  					toReturn.AddPolygon(secondPoints);  				if ((positions[4] - positions[5]).IsNotZeroVector())  					toReturn.AddPolygon(thirdPoints);  				if ((positions[6] - positions[7]).IsNotZeroVector())  					toReturn.AddPolygon(forthPoints);  				if ((positions[8] - positions[9]).IsNotZeroVector())  					toReturn.AddPolygon(fifthPoints);  				}
Magic Number,CityTrafficSimulator.Vehicle,Tram,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Tram.cs,BuildGraphicsPath,The following statement contains a magic number: if (_length == 250)  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized  									  };    				PointF[] frontPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] midPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] backPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				if (positions[0] != positions[1])  					toReturn.AddPolygon(frontPoints);  				if (positions[2] != positions[3])  					toReturn.AddPolygon(midPoints);  				if (positions[4] != positions[5])  					toReturn.AddPolygon(backPoints);  				}  			// 40-Meter-Zug  			else  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)'  					GetPositionAbsAtArcPos(currentPosition - 255)'  					GetPositionAbsAtArcPos(currentPosition - 300)'  					GetPositionAbsAtArcPos(currentPosition - 305)'  					GetPositionAbsAtArcPos(currentPosition - 400)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized'  					(positions[6] - positions[7]).RotatedClockwise.Normalized'  					(positions[7] - positions[9]).RotatedClockwise.Normalized  									  };    				PointF[] firstPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] secondPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] thirdPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				PointF[] forthPoints =   					{   					positions[6]  -  11*normals[3]'  					positions[6]  +  11*normals[3]'  					positions[7]  +  11*normals[3]'  					positions[7]  -  11*normals[3]'  					};    				PointF[] fifthPoints =   					{   					positions[8]  -  11*normals[4]'  					positions[8]  +  11*normals[4]'  					positions[9]  +  11*normals[4]'  					positions[9]  -  11*normals[4]'  					};    				if ((positions[0] - positions[1]).IsNotZeroVector())  					toReturn.AddPolygon(firstPoints);  				if ((positions[2] - positions[3]).IsNotZeroVector())  					toReturn.AddPolygon(secondPoints);  				if ((positions[4] - positions[5]).IsNotZeroVector())  					toReturn.AddPolygon(thirdPoints);  				if ((positions[6] - positions[7]).IsNotZeroVector())  					toReturn.AddPolygon(forthPoints);  				if ((positions[8] - positions[9]).IsNotZeroVector())  					toReturn.AddPolygon(fifthPoints);  				}
Magic Number,CityTrafficSimulator.Vehicle,Tram,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Tram.cs,BuildGraphicsPath,The following statement contains a magic number: if (_length == 250)  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized  									  };    				PointF[] frontPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] midPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] backPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				if (positions[0] != positions[1])  					toReturn.AddPolygon(frontPoints);  				if (positions[2] != positions[3])  					toReturn.AddPolygon(midPoints);  				if (positions[4] != positions[5])  					toReturn.AddPolygon(backPoints);  				}  			// 40-Meter-Zug  			else  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)'  					GetPositionAbsAtArcPos(currentPosition - 255)'  					GetPositionAbsAtArcPos(currentPosition - 300)'  					GetPositionAbsAtArcPos(currentPosition - 305)'  					GetPositionAbsAtArcPos(currentPosition - 400)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized'  					(positions[6] - positions[7]).RotatedClockwise.Normalized'  					(positions[7] - positions[9]).RotatedClockwise.Normalized  									  };    				PointF[] firstPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] secondPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] thirdPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				PointF[] forthPoints =   					{   					positions[6]  -  11*normals[3]'  					positions[6]  +  11*normals[3]'  					positions[7]  +  11*normals[3]'  					positions[7]  -  11*normals[3]'  					};    				PointF[] fifthPoints =   					{   					positions[8]  -  11*normals[4]'  					positions[8]  +  11*normals[4]'  					positions[9]  +  11*normals[4]'  					positions[9]  -  11*normals[4]'  					};    				if ((positions[0] - positions[1]).IsNotZeroVector())  					toReturn.AddPolygon(firstPoints);  				if ((positions[2] - positions[3]).IsNotZeroVector())  					toReturn.AddPolygon(secondPoints);  				if ((positions[4] - positions[5]).IsNotZeroVector())  					toReturn.AddPolygon(thirdPoints);  				if ((positions[6] - positions[7]).IsNotZeroVector())  					toReturn.AddPolygon(forthPoints);  				if ((positions[8] - positions[9]).IsNotZeroVector())  					toReturn.AddPolygon(fifthPoints);  				}
Magic Number,CityTrafficSimulator.Vehicle,Tram,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Tram.cs,BuildGraphicsPath,The following statement contains a magic number: if (_length == 250)  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized  									  };    				PointF[] frontPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] midPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] backPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				if (positions[0] != positions[1])  					toReturn.AddPolygon(frontPoints);  				if (positions[2] != positions[3])  					toReturn.AddPolygon(midPoints);  				if (positions[4] != positions[5])  					toReturn.AddPolygon(backPoints);  				}  			// 40-Meter-Zug  			else  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)'  					GetPositionAbsAtArcPos(currentPosition - 255)'  					GetPositionAbsAtArcPos(currentPosition - 300)'  					GetPositionAbsAtArcPos(currentPosition - 305)'  					GetPositionAbsAtArcPos(currentPosition - 400)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized'  					(positions[6] - positions[7]).RotatedClockwise.Normalized'  					(positions[7] - positions[9]).RotatedClockwise.Normalized  									  };    				PointF[] firstPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] secondPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] thirdPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				PointF[] forthPoints =   					{   					positions[6]  -  11*normals[3]'  					positions[6]  +  11*normals[3]'  					positions[7]  +  11*normals[3]'  					positions[7]  -  11*normals[3]'  					};    				PointF[] fifthPoints =   					{   					positions[8]  -  11*normals[4]'  					positions[8]  +  11*normals[4]'  					positions[9]  +  11*normals[4]'  					positions[9]  -  11*normals[4]'  					};    				if ((positions[0] - positions[1]).IsNotZeroVector())  					toReturn.AddPolygon(firstPoints);  				if ((positions[2] - positions[3]).IsNotZeroVector())  					toReturn.AddPolygon(secondPoints);  				if ((positions[4] - positions[5]).IsNotZeroVector())  					toReturn.AddPolygon(thirdPoints);  				if ((positions[6] - positions[7]).IsNotZeroVector())  					toReturn.AddPolygon(forthPoints);  				if ((positions[8] - positions[9]).IsNotZeroVector())  					toReturn.AddPolygon(fifthPoints);  				}
Magic Number,CityTrafficSimulator.Vehicle,Tram,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Tram.cs,BuildGraphicsPath,The following statement contains a magic number: if (_length == 250)  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized  									  };    				PointF[] frontPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] midPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] backPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				if (positions[0] != positions[1])  					toReturn.AddPolygon(frontPoints);  				if (positions[2] != positions[3])  					toReturn.AddPolygon(midPoints);  				if (positions[4] != positions[5])  					toReturn.AddPolygon(backPoints);  				}  			// 40-Meter-Zug  			else  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)'  					GetPositionAbsAtArcPos(currentPosition - 255)'  					GetPositionAbsAtArcPos(currentPosition - 300)'  					GetPositionAbsAtArcPos(currentPosition - 305)'  					GetPositionAbsAtArcPos(currentPosition - 400)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized'  					(positions[6] - positions[7]).RotatedClockwise.Normalized'  					(positions[7] - positions[9]).RotatedClockwise.Normalized  									  };    				PointF[] firstPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] secondPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] thirdPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				PointF[] forthPoints =   					{   					positions[6]  -  11*normals[3]'  					positions[6]  +  11*normals[3]'  					positions[7]  +  11*normals[3]'  					positions[7]  -  11*normals[3]'  					};    				PointF[] fifthPoints =   					{   					positions[8]  -  11*normals[4]'  					positions[8]  +  11*normals[4]'  					positions[9]  +  11*normals[4]'  					positions[9]  -  11*normals[4]'  					};    				if ((positions[0] - positions[1]).IsNotZeroVector())  					toReturn.AddPolygon(firstPoints);  				if ((positions[2] - positions[3]).IsNotZeroVector())  					toReturn.AddPolygon(secondPoints);  				if ((positions[4] - positions[5]).IsNotZeroVector())  					toReturn.AddPolygon(thirdPoints);  				if ((positions[6] - positions[7]).IsNotZeroVector())  					toReturn.AddPolygon(forthPoints);  				if ((positions[8] - positions[9]).IsNotZeroVector())  					toReturn.AddPolygon(fifthPoints);  				}
Magic Number,CityTrafficSimulator.Vehicle,Tram,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Tram.cs,BuildGraphicsPath,The following statement contains a magic number: if (_length == 250)  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized  									  };    				PointF[] frontPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] midPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] backPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				if (positions[0] != positions[1])  					toReturn.AddPolygon(frontPoints);  				if (positions[2] != positions[3])  					toReturn.AddPolygon(midPoints);  				if (positions[4] != positions[5])  					toReturn.AddPolygon(backPoints);  				}  			// 40-Meter-Zug  			else  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)'  					GetPositionAbsAtArcPos(currentPosition - 255)'  					GetPositionAbsAtArcPos(currentPosition - 300)'  					GetPositionAbsAtArcPos(currentPosition - 305)'  					GetPositionAbsAtArcPos(currentPosition - 400)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized'  					(positions[6] - positions[7]).RotatedClockwise.Normalized'  					(positions[7] - positions[9]).RotatedClockwise.Normalized  									  };    				PointF[] firstPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] secondPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] thirdPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				PointF[] forthPoints =   					{   					positions[6]  -  11*normals[3]'  					positions[6]  +  11*normals[3]'  					positions[7]  +  11*normals[3]'  					positions[7]  -  11*normals[3]'  					};    				PointF[] fifthPoints =   					{   					positions[8]  -  11*normals[4]'  					positions[8]  +  11*normals[4]'  					positions[9]  +  11*normals[4]'  					positions[9]  -  11*normals[4]'  					};    				if ((positions[0] - positions[1]).IsNotZeroVector())  					toReturn.AddPolygon(firstPoints);  				if ((positions[2] - positions[3]).IsNotZeroVector())  					toReturn.AddPolygon(secondPoints);  				if ((positions[4] - positions[5]).IsNotZeroVector())  					toReturn.AddPolygon(thirdPoints);  				if ((positions[6] - positions[7]).IsNotZeroVector())  					toReturn.AddPolygon(forthPoints);  				if ((positions[8] - positions[9]).IsNotZeroVector())  					toReturn.AddPolygon(fifthPoints);  				}
Magic Number,CityTrafficSimulator.Vehicle,Tram,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Tram.cs,BuildGraphicsPath,The following statement contains a magic number: if (_length == 250)  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized  									  };    				PointF[] frontPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] midPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] backPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				if (positions[0] != positions[1])  					toReturn.AddPolygon(frontPoints);  				if (positions[2] != positions[3])  					toReturn.AddPolygon(midPoints);  				if (positions[4] != positions[5])  					toReturn.AddPolygon(backPoints);  				}  			// 40-Meter-Zug  			else  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)'  					GetPositionAbsAtArcPos(currentPosition - 255)'  					GetPositionAbsAtArcPos(currentPosition - 300)'  					GetPositionAbsAtArcPos(currentPosition - 305)'  					GetPositionAbsAtArcPos(currentPosition - 400)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized'  					(positions[6] - positions[7]).RotatedClockwise.Normalized'  					(positions[7] - positions[9]).RotatedClockwise.Normalized  									  };    				PointF[] firstPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] secondPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] thirdPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				PointF[] forthPoints =   					{   					positions[6]  -  11*normals[3]'  					positions[6]  +  11*normals[3]'  					positions[7]  +  11*normals[3]'  					positions[7]  -  11*normals[3]'  					};    				PointF[] fifthPoints =   					{   					positions[8]  -  11*normals[4]'  					positions[8]  +  11*normals[4]'  					positions[9]  +  11*normals[4]'  					positions[9]  -  11*normals[4]'  					};    				if ((positions[0] - positions[1]).IsNotZeroVector())  					toReturn.AddPolygon(firstPoints);  				if ((positions[2] - positions[3]).IsNotZeroVector())  					toReturn.AddPolygon(secondPoints);  				if ((positions[4] - positions[5]).IsNotZeroVector())  					toReturn.AddPolygon(thirdPoints);  				if ((positions[6] - positions[7]).IsNotZeroVector())  					toReturn.AddPolygon(forthPoints);  				if ((positions[8] - positions[9]).IsNotZeroVector())  					toReturn.AddPolygon(fifthPoints);  				}
Magic Number,CityTrafficSimulator.Vehicle,Tram,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Tram.cs,BuildGraphicsPath,The following statement contains a magic number: if (_length == 250)  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized  									  };    				PointF[] frontPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] midPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] backPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				if (positions[0] != positions[1])  					toReturn.AddPolygon(frontPoints);  				if (positions[2] != positions[3])  					toReturn.AddPolygon(midPoints);  				if (positions[4] != positions[5])  					toReturn.AddPolygon(backPoints);  				}  			// 40-Meter-Zug  			else  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)'  					GetPositionAbsAtArcPos(currentPosition - 255)'  					GetPositionAbsAtArcPos(currentPosition - 300)'  					GetPositionAbsAtArcPos(currentPosition - 305)'  					GetPositionAbsAtArcPos(currentPosition - 400)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized'  					(positions[6] - positions[7]).RotatedClockwise.Normalized'  					(positions[7] - positions[9]).RotatedClockwise.Normalized  									  };    				PointF[] firstPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] secondPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] thirdPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				PointF[] forthPoints =   					{   					positions[6]  -  11*normals[3]'  					positions[6]  +  11*normals[3]'  					positions[7]  +  11*normals[3]'  					positions[7]  -  11*normals[3]'  					};    				PointF[] fifthPoints =   					{   					positions[8]  -  11*normals[4]'  					positions[8]  +  11*normals[4]'  					positions[9]  +  11*normals[4]'  					positions[9]  -  11*normals[4]'  					};    				if ((positions[0] - positions[1]).IsNotZeroVector())  					toReturn.AddPolygon(firstPoints);  				if ((positions[2] - positions[3]).IsNotZeroVector())  					toReturn.AddPolygon(secondPoints);  				if ((positions[4] - positions[5]).IsNotZeroVector())  					toReturn.AddPolygon(thirdPoints);  				if ((positions[6] - positions[7]).IsNotZeroVector())  					toReturn.AddPolygon(forthPoints);  				if ((positions[8] - positions[9]).IsNotZeroVector())  					toReturn.AddPolygon(fifthPoints);  				}
Magic Number,CityTrafficSimulator.Vehicle,Tram,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Tram.cs,BuildGraphicsPath,The following statement contains a magic number: if (_length == 250)  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized  									  };    				PointF[] frontPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] midPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] backPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				if (positions[0] != positions[1])  					toReturn.AddPolygon(frontPoints);  				if (positions[2] != positions[3])  					toReturn.AddPolygon(midPoints);  				if (positions[4] != positions[5])  					toReturn.AddPolygon(backPoints);  				}  			// 40-Meter-Zug  			else  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)'  					GetPositionAbsAtArcPos(currentPosition - 255)'  					GetPositionAbsAtArcPos(currentPosition - 300)'  					GetPositionAbsAtArcPos(currentPosition - 305)'  					GetPositionAbsAtArcPos(currentPosition - 400)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized'  					(positions[6] - positions[7]).RotatedClockwise.Normalized'  					(positions[7] - positions[9]).RotatedClockwise.Normalized  									  };    				PointF[] firstPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] secondPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] thirdPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				PointF[] forthPoints =   					{   					positions[6]  -  11*normals[3]'  					positions[6]  +  11*normals[3]'  					positions[7]  +  11*normals[3]'  					positions[7]  -  11*normals[3]'  					};    				PointF[] fifthPoints =   					{   					positions[8]  -  11*normals[4]'  					positions[8]  +  11*normals[4]'  					positions[9]  +  11*normals[4]'  					positions[9]  -  11*normals[4]'  					};    				if ((positions[0] - positions[1]).IsNotZeroVector())  					toReturn.AddPolygon(firstPoints);  				if ((positions[2] - positions[3]).IsNotZeroVector())  					toReturn.AddPolygon(secondPoints);  				if ((positions[4] - positions[5]).IsNotZeroVector())  					toReturn.AddPolygon(thirdPoints);  				if ((positions[6] - positions[7]).IsNotZeroVector())  					toReturn.AddPolygon(forthPoints);  				if ((positions[8] - positions[9]).IsNotZeroVector())  					toReturn.AddPolygon(fifthPoints);  				}
Magic Number,CityTrafficSimulator.Vehicle,Tram,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Tram.cs,BuildGraphicsPath,The following statement contains a magic number: if (_length == 250)  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized  									  };    				PointF[] frontPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] midPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] backPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				if (positions[0] != positions[1])  					toReturn.AddPolygon(frontPoints);  				if (positions[2] != positions[3])  					toReturn.AddPolygon(midPoints);  				if (positions[4] != positions[5])  					toReturn.AddPolygon(backPoints);  				}  			// 40-Meter-Zug  			else  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)'  					GetPositionAbsAtArcPos(currentPosition - 255)'  					GetPositionAbsAtArcPos(currentPosition - 300)'  					GetPositionAbsAtArcPos(currentPosition - 305)'  					GetPositionAbsAtArcPos(currentPosition - 400)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized'  					(positions[6] - positions[7]).RotatedClockwise.Normalized'  					(positions[7] - positions[9]).RotatedClockwise.Normalized  									  };    				PointF[] firstPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] secondPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] thirdPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				PointF[] forthPoints =   					{   					positions[6]  -  11*normals[3]'  					positions[6]  +  11*normals[3]'  					positions[7]  +  11*normals[3]'  					positions[7]  -  11*normals[3]'  					};    				PointF[] fifthPoints =   					{   					positions[8]  -  11*normals[4]'  					positions[8]  +  11*normals[4]'  					positions[9]  +  11*normals[4]'  					positions[9]  -  11*normals[4]'  					};    				if ((positions[0] - positions[1]).IsNotZeroVector())  					toReturn.AddPolygon(firstPoints);  				if ((positions[2] - positions[3]).IsNotZeroVector())  					toReturn.AddPolygon(secondPoints);  				if ((positions[4] - positions[5]).IsNotZeroVector())  					toReturn.AddPolygon(thirdPoints);  				if ((positions[6] - positions[7]).IsNotZeroVector())  					toReturn.AddPolygon(forthPoints);  				if ((positions[8] - positions[9]).IsNotZeroVector())  					toReturn.AddPolygon(fifthPoints);  				}
Magic Number,CityTrafficSimulator.Vehicle,Tram,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Tram.cs,BuildGraphicsPath,The following statement contains a magic number: if (_length == 250)  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized  									  };    				PointF[] frontPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] midPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] backPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				if (positions[0] != positions[1])  					toReturn.AddPolygon(frontPoints);  				if (positions[2] != positions[3])  					toReturn.AddPolygon(midPoints);  				if (positions[4] != positions[5])  					toReturn.AddPolygon(backPoints);  				}  			// 40-Meter-Zug  			else  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)'  					GetPositionAbsAtArcPos(currentPosition - 255)'  					GetPositionAbsAtArcPos(currentPosition - 300)'  					GetPositionAbsAtArcPos(currentPosition - 305)'  					GetPositionAbsAtArcPos(currentPosition - 400)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized'  					(positions[6] - positions[7]).RotatedClockwise.Normalized'  					(positions[7] - positions[9]).RotatedClockwise.Normalized  									  };    				PointF[] firstPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] secondPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] thirdPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				PointF[] forthPoints =   					{   					positions[6]  -  11*normals[3]'  					positions[6]  +  11*normals[3]'  					positions[7]  +  11*normals[3]'  					positions[7]  -  11*normals[3]'  					};    				PointF[] fifthPoints =   					{   					positions[8]  -  11*normals[4]'  					positions[8]  +  11*normals[4]'  					positions[9]  +  11*normals[4]'  					positions[9]  -  11*normals[4]'  					};    				if ((positions[0] - positions[1]).IsNotZeroVector())  					toReturn.AddPolygon(firstPoints);  				if ((positions[2] - positions[3]).IsNotZeroVector())  					toReturn.AddPolygon(secondPoints);  				if ((positions[4] - positions[5]).IsNotZeroVector())  					toReturn.AddPolygon(thirdPoints);  				if ((positions[6] - positions[7]).IsNotZeroVector())  					toReturn.AddPolygon(forthPoints);  				if ((positions[8] - positions[9]).IsNotZeroVector())  					toReturn.AddPolygon(fifthPoints);  				}
Magic Number,CityTrafficSimulator.Vehicle,Tram,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Tram.cs,BuildGraphicsPath,The following statement contains a magic number: if (_length == 250)  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized  									  };    				PointF[] frontPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] midPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] backPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				if (positions[0] != positions[1])  					toReturn.AddPolygon(frontPoints);  				if (positions[2] != positions[3])  					toReturn.AddPolygon(midPoints);  				if (positions[4] != positions[5])  					toReturn.AddPolygon(backPoints);  				}  			// 40-Meter-Zug  			else  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)'  					GetPositionAbsAtArcPos(currentPosition - 255)'  					GetPositionAbsAtArcPos(currentPosition - 300)'  					GetPositionAbsAtArcPos(currentPosition - 305)'  					GetPositionAbsAtArcPos(currentPosition - 400)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized'  					(positions[6] - positions[7]).RotatedClockwise.Normalized'  					(positions[7] - positions[9]).RotatedClockwise.Normalized  									  };    				PointF[] firstPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] secondPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] thirdPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				PointF[] forthPoints =   					{   					positions[6]  -  11*normals[3]'  					positions[6]  +  11*normals[3]'  					positions[7]  +  11*normals[3]'  					positions[7]  -  11*normals[3]'  					};    				PointF[] fifthPoints =   					{   					positions[8]  -  11*normals[4]'  					positions[8]  +  11*normals[4]'  					positions[9]  +  11*normals[4]'  					positions[9]  -  11*normals[4]'  					};    				if ((positions[0] - positions[1]).IsNotZeroVector())  					toReturn.AddPolygon(firstPoints);  				if ((positions[2] - positions[3]).IsNotZeroVector())  					toReturn.AddPolygon(secondPoints);  				if ((positions[4] - positions[5]).IsNotZeroVector())  					toReturn.AddPolygon(thirdPoints);  				if ((positions[6] - positions[7]).IsNotZeroVector())  					toReturn.AddPolygon(forthPoints);  				if ((positions[8] - positions[9]).IsNotZeroVector())  					toReturn.AddPolygon(fifthPoints);  				}
Magic Number,CityTrafficSimulator.Vehicle,Tram,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Tram.cs,BuildGraphicsPath,The following statement contains a magic number: if (_length == 250)  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized  									  };    				PointF[] frontPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] midPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] backPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				if (positions[0] != positions[1])  					toReturn.AddPolygon(frontPoints);  				if (positions[2] != positions[3])  					toReturn.AddPolygon(midPoints);  				if (positions[4] != positions[5])  					toReturn.AddPolygon(backPoints);  				}  			// 40-Meter-Zug  			else  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)'  					GetPositionAbsAtArcPos(currentPosition - 255)'  					GetPositionAbsAtArcPos(currentPosition - 300)'  					GetPositionAbsAtArcPos(currentPosition - 305)'  					GetPositionAbsAtArcPos(currentPosition - 400)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized'  					(positions[6] - positions[7]).RotatedClockwise.Normalized'  					(positions[7] - positions[9]).RotatedClockwise.Normalized  									  };    				PointF[] firstPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] secondPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] thirdPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				PointF[] forthPoints =   					{   					positions[6]  -  11*normals[3]'  					positions[6]  +  11*normals[3]'  					positions[7]  +  11*normals[3]'  					positions[7]  -  11*normals[3]'  					};    				PointF[] fifthPoints =   					{   					positions[8]  -  11*normals[4]'  					positions[8]  +  11*normals[4]'  					positions[9]  +  11*normals[4]'  					positions[9]  -  11*normals[4]'  					};    				if ((positions[0] - positions[1]).IsNotZeroVector())  					toReturn.AddPolygon(firstPoints);  				if ((positions[2] - positions[3]).IsNotZeroVector())  					toReturn.AddPolygon(secondPoints);  				if ((positions[4] - positions[5]).IsNotZeroVector())  					toReturn.AddPolygon(thirdPoints);  				if ((positions[6] - positions[7]).IsNotZeroVector())  					toReturn.AddPolygon(forthPoints);  				if ((positions[8] - positions[9]).IsNotZeroVector())  					toReturn.AddPolygon(fifthPoints);  				}
Magic Number,CityTrafficSimulator.Vehicle,Tram,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Tram.cs,BuildGraphicsPath,The following statement contains a magic number: if (_length == 250)  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized  									  };    				PointF[] frontPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] midPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] backPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				if (positions[0] != positions[1])  					toReturn.AddPolygon(frontPoints);  				if (positions[2] != positions[3])  					toReturn.AddPolygon(midPoints);  				if (positions[4] != positions[5])  					toReturn.AddPolygon(backPoints);  				}  			// 40-Meter-Zug  			else  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)'  					GetPositionAbsAtArcPos(currentPosition - 255)'  					GetPositionAbsAtArcPos(currentPosition - 300)'  					GetPositionAbsAtArcPos(currentPosition - 305)'  					GetPositionAbsAtArcPos(currentPosition - 400)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized'  					(positions[6] - positions[7]).RotatedClockwise.Normalized'  					(positions[7] - positions[9]).RotatedClockwise.Normalized  									  };    				PointF[] firstPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] secondPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] thirdPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				PointF[] forthPoints =   					{   					positions[6]  -  11*normals[3]'  					positions[6]  +  11*normals[3]'  					positions[7]  +  11*normals[3]'  					positions[7]  -  11*normals[3]'  					};    				PointF[] fifthPoints =   					{   					positions[8]  -  11*normals[4]'  					positions[8]  +  11*normals[4]'  					positions[9]  +  11*normals[4]'  					positions[9]  -  11*normals[4]'  					};    				if ((positions[0] - positions[1]).IsNotZeroVector())  					toReturn.AddPolygon(firstPoints);  				if ((positions[2] - positions[3]).IsNotZeroVector())  					toReturn.AddPolygon(secondPoints);  				if ((positions[4] - positions[5]).IsNotZeroVector())  					toReturn.AddPolygon(thirdPoints);  				if ((positions[6] - positions[7]).IsNotZeroVector())  					toReturn.AddPolygon(forthPoints);  				if ((positions[8] - positions[9]).IsNotZeroVector())  					toReturn.AddPolygon(fifthPoints);  				}
Magic Number,CityTrafficSimulator.Vehicle,Tram,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Tram.cs,BuildGraphicsPath,The following statement contains a magic number: if (_length == 250)  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized  									  };    				PointF[] frontPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] midPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] backPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				if (positions[0] != positions[1])  					toReturn.AddPolygon(frontPoints);  				if (positions[2] != positions[3])  					toReturn.AddPolygon(midPoints);  				if (positions[4] != positions[5])  					toReturn.AddPolygon(backPoints);  				}  			// 40-Meter-Zug  			else  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)'  					GetPositionAbsAtArcPos(currentPosition - 255)'  					GetPositionAbsAtArcPos(currentPosition - 300)'  					GetPositionAbsAtArcPos(currentPosition - 305)'  					GetPositionAbsAtArcPos(currentPosition - 400)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized'  					(positions[6] - positions[7]).RotatedClockwise.Normalized'  					(positions[7] - positions[9]).RotatedClockwise.Normalized  									  };    				PointF[] firstPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] secondPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] thirdPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				PointF[] forthPoints =   					{   					positions[6]  -  11*normals[3]'  					positions[6]  +  11*normals[3]'  					positions[7]  +  11*normals[3]'  					positions[7]  -  11*normals[3]'  					};    				PointF[] fifthPoints =   					{   					positions[8]  -  11*normals[4]'  					positions[8]  +  11*normals[4]'  					positions[9]  +  11*normals[4]'  					positions[9]  -  11*normals[4]'  					};    				if ((positions[0] - positions[1]).IsNotZeroVector())  					toReturn.AddPolygon(firstPoints);  				if ((positions[2] - positions[3]).IsNotZeroVector())  					toReturn.AddPolygon(secondPoints);  				if ((positions[4] - positions[5]).IsNotZeroVector())  					toReturn.AddPolygon(thirdPoints);  				if ((positions[6] - positions[7]).IsNotZeroVector())  					toReturn.AddPolygon(forthPoints);  				if ((positions[8] - positions[9]).IsNotZeroVector())  					toReturn.AddPolygon(fifthPoints);  				}
Magic Number,CityTrafficSimulator.Vehicle,Tram,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Tram.cs,BuildGraphicsPath,The following statement contains a magic number: if (_length == 250)  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized  									  };    				PointF[] frontPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] midPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] backPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				if (positions[0] != positions[1])  					toReturn.AddPolygon(frontPoints);  				if (positions[2] != positions[3])  					toReturn.AddPolygon(midPoints);  				if (positions[4] != positions[5])  					toReturn.AddPolygon(backPoints);  				}  			// 40-Meter-Zug  			else  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)'  					GetPositionAbsAtArcPos(currentPosition - 255)'  					GetPositionAbsAtArcPos(currentPosition - 300)'  					GetPositionAbsAtArcPos(currentPosition - 305)'  					GetPositionAbsAtArcPos(currentPosition - 400)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized'  					(positions[6] - positions[7]).RotatedClockwise.Normalized'  					(positions[7] - positions[9]).RotatedClockwise.Normalized  									  };    				PointF[] firstPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] secondPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] thirdPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				PointF[] forthPoints =   					{   					positions[6]  -  11*normals[3]'  					positions[6]  +  11*normals[3]'  					positions[7]  +  11*normals[3]'  					positions[7]  -  11*normals[3]'  					};    				PointF[] fifthPoints =   					{   					positions[8]  -  11*normals[4]'  					positions[8]  +  11*normals[4]'  					positions[9]  +  11*normals[4]'  					positions[9]  -  11*normals[4]'  					};    				if ((positions[0] - positions[1]).IsNotZeroVector())  					toReturn.AddPolygon(firstPoints);  				if ((positions[2] - positions[3]).IsNotZeroVector())  					toReturn.AddPolygon(secondPoints);  				if ((positions[4] - positions[5]).IsNotZeroVector())  					toReturn.AddPolygon(thirdPoints);  				if ((positions[6] - positions[7]).IsNotZeroVector())  					toReturn.AddPolygon(forthPoints);  				if ((positions[8] - positions[9]).IsNotZeroVector())  					toReturn.AddPolygon(fifthPoints);  				}
Magic Number,CityTrafficSimulator.Vehicle,Tram,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Tram.cs,BuildGraphicsPath,The following statement contains a magic number: if (_length == 250)  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized  									  };    				PointF[] frontPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] midPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] backPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				if (positions[0] != positions[1])  					toReturn.AddPolygon(frontPoints);  				if (positions[2] != positions[3])  					toReturn.AddPolygon(midPoints);  				if (positions[4] != positions[5])  					toReturn.AddPolygon(backPoints);  				}  			// 40-Meter-Zug  			else  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)'  					GetPositionAbsAtArcPos(currentPosition - 255)'  					GetPositionAbsAtArcPos(currentPosition - 300)'  					GetPositionAbsAtArcPos(currentPosition - 305)'  					GetPositionAbsAtArcPos(currentPosition - 400)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized'  					(positions[6] - positions[7]).RotatedClockwise.Normalized'  					(positions[7] - positions[9]).RotatedClockwise.Normalized  									  };    				PointF[] firstPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] secondPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] thirdPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				PointF[] forthPoints =   					{   					positions[6]  -  11*normals[3]'  					positions[6]  +  11*normals[3]'  					positions[7]  +  11*normals[3]'  					positions[7]  -  11*normals[3]'  					};    				PointF[] fifthPoints =   					{   					positions[8]  -  11*normals[4]'  					positions[8]  +  11*normals[4]'  					positions[9]  +  11*normals[4]'  					positions[9]  -  11*normals[4]'  					};    				if ((positions[0] - positions[1]).IsNotZeroVector())  					toReturn.AddPolygon(firstPoints);  				if ((positions[2] - positions[3]).IsNotZeroVector())  					toReturn.AddPolygon(secondPoints);  				if ((positions[4] - positions[5]).IsNotZeroVector())  					toReturn.AddPolygon(thirdPoints);  				if ((positions[6] - positions[7]).IsNotZeroVector())  					toReturn.AddPolygon(forthPoints);  				if ((positions[8] - positions[9]).IsNotZeroVector())  					toReturn.AddPolygon(fifthPoints);  				}
Magic Number,CityTrafficSimulator.Vehicle,Tram,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Tram.cs,BuildGraphicsPath,The following statement contains a magic number: if (_length == 250)  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized  									  };    				PointF[] frontPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] midPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] backPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				if (positions[0] != positions[1])  					toReturn.AddPolygon(frontPoints);  				if (positions[2] != positions[3])  					toReturn.AddPolygon(midPoints);  				if (positions[4] != positions[5])  					toReturn.AddPolygon(backPoints);  				}  			// 40-Meter-Zug  			else  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)'  					GetPositionAbsAtArcPos(currentPosition - 255)'  					GetPositionAbsAtArcPos(currentPosition - 300)'  					GetPositionAbsAtArcPos(currentPosition - 305)'  					GetPositionAbsAtArcPos(currentPosition - 400)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized'  					(positions[6] - positions[7]).RotatedClockwise.Normalized'  					(positions[7] - positions[9]).RotatedClockwise.Normalized  									  };    				PointF[] firstPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] secondPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] thirdPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				PointF[] forthPoints =   					{   					positions[6]  -  11*normals[3]'  					positions[6]  +  11*normals[3]'  					positions[7]  +  11*normals[3]'  					positions[7]  -  11*normals[3]'  					};    				PointF[] fifthPoints =   					{   					positions[8]  -  11*normals[4]'  					positions[8]  +  11*normals[4]'  					positions[9]  +  11*normals[4]'  					positions[9]  -  11*normals[4]'  					};    				if ((positions[0] - positions[1]).IsNotZeroVector())  					toReturn.AddPolygon(firstPoints);  				if ((positions[2] - positions[3]).IsNotZeroVector())  					toReturn.AddPolygon(secondPoints);  				if ((positions[4] - positions[5]).IsNotZeroVector())  					toReturn.AddPolygon(thirdPoints);  				if ((positions[6] - positions[7]).IsNotZeroVector())  					toReturn.AddPolygon(forthPoints);  				if ((positions[8] - positions[9]).IsNotZeroVector())  					toReturn.AddPolygon(fifthPoints);  				}
Magic Number,CityTrafficSimulator.Vehicle,Tram,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Tram.cs,BuildGraphicsPath,The following statement contains a magic number: if (_length == 250)  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized  									  };    				PointF[] frontPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] midPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] backPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				if (positions[0] != positions[1])  					toReturn.AddPolygon(frontPoints);  				if (positions[2] != positions[3])  					toReturn.AddPolygon(midPoints);  				if (positions[4] != positions[5])  					toReturn.AddPolygon(backPoints);  				}  			// 40-Meter-Zug  			else  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)'  					GetPositionAbsAtArcPos(currentPosition - 255)'  					GetPositionAbsAtArcPos(currentPosition - 300)'  					GetPositionAbsAtArcPos(currentPosition - 305)'  					GetPositionAbsAtArcPos(currentPosition - 400)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized'  					(positions[6] - positions[7]).RotatedClockwise.Normalized'  					(positions[7] - positions[9]).RotatedClockwise.Normalized  									  };    				PointF[] firstPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] secondPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] thirdPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				PointF[] forthPoints =   					{   					positions[6]  -  11*normals[3]'  					positions[6]  +  11*normals[3]'  					positions[7]  +  11*normals[3]'  					positions[7]  -  11*normals[3]'  					};    				PointF[] fifthPoints =   					{   					positions[8]  -  11*normals[4]'  					positions[8]  +  11*normals[4]'  					positions[9]  +  11*normals[4]'  					positions[9]  -  11*normals[4]'  					};    				if ((positions[0] - positions[1]).IsNotZeroVector())  					toReturn.AddPolygon(firstPoints);  				if ((positions[2] - positions[3]).IsNotZeroVector())  					toReturn.AddPolygon(secondPoints);  				if ((positions[4] - positions[5]).IsNotZeroVector())  					toReturn.AddPolygon(thirdPoints);  				if ((positions[6] - positions[7]).IsNotZeroVector())  					toReturn.AddPolygon(forthPoints);  				if ((positions[8] - positions[9]).IsNotZeroVector())  					toReturn.AddPolygon(fifthPoints);  				}
Magic Number,CityTrafficSimulator.Vehicle,Tram,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Tram.cs,BuildGraphicsPath,The following statement contains a magic number: if (_length == 250)  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized  									  };    				PointF[] frontPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] midPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] backPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				if (positions[0] != positions[1])  					toReturn.AddPolygon(frontPoints);  				if (positions[2] != positions[3])  					toReturn.AddPolygon(midPoints);  				if (positions[4] != positions[5])  					toReturn.AddPolygon(backPoints);  				}  			// 40-Meter-Zug  			else  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)'  					GetPositionAbsAtArcPos(currentPosition - 255)'  					GetPositionAbsAtArcPos(currentPosition - 300)'  					GetPositionAbsAtArcPos(currentPosition - 305)'  					GetPositionAbsAtArcPos(currentPosition - 400)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized'  					(positions[6] - positions[7]).RotatedClockwise.Normalized'  					(positions[7] - positions[9]).RotatedClockwise.Normalized  									  };    				PointF[] firstPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] secondPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] thirdPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				PointF[] forthPoints =   					{   					positions[6]  -  11*normals[3]'  					positions[6]  +  11*normals[3]'  					positions[7]  +  11*normals[3]'  					positions[7]  -  11*normals[3]'  					};    				PointF[] fifthPoints =   					{   					positions[8]  -  11*normals[4]'  					positions[8]  +  11*normals[4]'  					positions[9]  +  11*normals[4]'  					positions[9]  -  11*normals[4]'  					};    				if ((positions[0] - positions[1]).IsNotZeroVector())  					toReturn.AddPolygon(firstPoints);  				if ((positions[2] - positions[3]).IsNotZeroVector())  					toReturn.AddPolygon(secondPoints);  				if ((positions[4] - positions[5]).IsNotZeroVector())  					toReturn.AddPolygon(thirdPoints);  				if ((positions[6] - positions[7]).IsNotZeroVector())  					toReturn.AddPolygon(forthPoints);  				if ((positions[8] - positions[9]).IsNotZeroVector())  					toReturn.AddPolygon(fifthPoints);  				}
Magic Number,CityTrafficSimulator.Vehicle,Tram,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Tram.cs,BuildGraphicsPath,The following statement contains a magic number: if (_length == 250)  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized  									  };    				PointF[] frontPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] midPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] backPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				if (positions[0] != positions[1])  					toReturn.AddPolygon(frontPoints);  				if (positions[2] != positions[3])  					toReturn.AddPolygon(midPoints);  				if (positions[4] != positions[5])  					toReturn.AddPolygon(backPoints);  				}  			// 40-Meter-Zug  			else  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)'  					GetPositionAbsAtArcPos(currentPosition - 255)'  					GetPositionAbsAtArcPos(currentPosition - 300)'  					GetPositionAbsAtArcPos(currentPosition - 305)'  					GetPositionAbsAtArcPos(currentPosition - 400)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized'  					(positions[6] - positions[7]).RotatedClockwise.Normalized'  					(positions[7] - positions[9]).RotatedClockwise.Normalized  									  };    				PointF[] firstPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] secondPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] thirdPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				PointF[] forthPoints =   					{   					positions[6]  -  11*normals[3]'  					positions[6]  +  11*normals[3]'  					positions[7]  +  11*normals[3]'  					positions[7]  -  11*normals[3]'  					};    				PointF[] fifthPoints =   					{   					positions[8]  -  11*normals[4]'  					positions[8]  +  11*normals[4]'  					positions[9]  +  11*normals[4]'  					positions[9]  -  11*normals[4]'  					};    				if ((positions[0] - positions[1]).IsNotZeroVector())  					toReturn.AddPolygon(firstPoints);  				if ((positions[2] - positions[3]).IsNotZeroVector())  					toReturn.AddPolygon(secondPoints);  				if ((positions[4] - positions[5]).IsNotZeroVector())  					toReturn.AddPolygon(thirdPoints);  				if ((positions[6] - positions[7]).IsNotZeroVector())  					toReturn.AddPolygon(forthPoints);  				if ((positions[8] - positions[9]).IsNotZeroVector())  					toReturn.AddPolygon(fifthPoints);  				}
Magic Number,CityTrafficSimulator.Vehicle,Tram,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Tram.cs,BuildGraphicsPath,The following statement contains a magic number: if (_length == 250)  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized  									  };    				PointF[] frontPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] midPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] backPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				if (positions[0] != positions[1])  					toReturn.AddPolygon(frontPoints);  				if (positions[2] != positions[3])  					toReturn.AddPolygon(midPoints);  				if (positions[4] != positions[5])  					toReturn.AddPolygon(backPoints);  				}  			// 40-Meter-Zug  			else  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)'  					GetPositionAbsAtArcPos(currentPosition - 255)'  					GetPositionAbsAtArcPos(currentPosition - 300)'  					GetPositionAbsAtArcPos(currentPosition - 305)'  					GetPositionAbsAtArcPos(currentPosition - 400)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized'  					(positions[6] - positions[7]).RotatedClockwise.Normalized'  					(positions[7] - positions[9]).RotatedClockwise.Normalized  									  };    				PointF[] firstPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] secondPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] thirdPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				PointF[] forthPoints =   					{   					positions[6]  -  11*normals[3]'  					positions[6]  +  11*normals[3]'  					positions[7]  +  11*normals[3]'  					positions[7]  -  11*normals[3]'  					};    				PointF[] fifthPoints =   					{   					positions[8]  -  11*normals[4]'  					positions[8]  +  11*normals[4]'  					positions[9]  +  11*normals[4]'  					positions[9]  -  11*normals[4]'  					};    				if ((positions[0] - positions[1]).IsNotZeroVector())  					toReturn.AddPolygon(firstPoints);  				if ((positions[2] - positions[3]).IsNotZeroVector())  					toReturn.AddPolygon(secondPoints);  				if ((positions[4] - positions[5]).IsNotZeroVector())  					toReturn.AddPolygon(thirdPoints);  				if ((positions[6] - positions[7]).IsNotZeroVector())  					toReturn.AddPolygon(forthPoints);  				if ((positions[8] - positions[9]).IsNotZeroVector())  					toReturn.AddPolygon(fifthPoints);  				}
Magic Number,CityTrafficSimulator.Vehicle,Tram,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Tram.cs,BuildGraphicsPath,The following statement contains a magic number: if (_length == 250)  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized  									  };    				PointF[] frontPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] midPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] backPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				if (positions[0] != positions[1])  					toReturn.AddPolygon(frontPoints);  				if (positions[2] != positions[3])  					toReturn.AddPolygon(midPoints);  				if (positions[4] != positions[5])  					toReturn.AddPolygon(backPoints);  				}  			// 40-Meter-Zug  			else  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)'  					GetPositionAbsAtArcPos(currentPosition - 255)'  					GetPositionAbsAtArcPos(currentPosition - 300)'  					GetPositionAbsAtArcPos(currentPosition - 305)'  					GetPositionAbsAtArcPos(currentPosition - 400)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized'  					(positions[6] - positions[7]).RotatedClockwise.Normalized'  					(positions[7] - positions[9]).RotatedClockwise.Normalized  									  };    				PointF[] firstPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] secondPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] thirdPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				PointF[] forthPoints =   					{   					positions[6]  -  11*normals[3]'  					positions[6]  +  11*normals[3]'  					positions[7]  +  11*normals[3]'  					positions[7]  -  11*normals[3]'  					};    				PointF[] fifthPoints =   					{   					positions[8]  -  11*normals[4]'  					positions[8]  +  11*normals[4]'  					positions[9]  +  11*normals[4]'  					positions[9]  -  11*normals[4]'  					};    				if ((positions[0] - positions[1]).IsNotZeroVector())  					toReturn.AddPolygon(firstPoints);  				if ((positions[2] - positions[3]).IsNotZeroVector())  					toReturn.AddPolygon(secondPoints);  				if ((positions[4] - positions[5]).IsNotZeroVector())  					toReturn.AddPolygon(thirdPoints);  				if ((positions[6] - positions[7]).IsNotZeroVector())  					toReturn.AddPolygon(forthPoints);  				if ((positions[8] - positions[9]).IsNotZeroVector())  					toReturn.AddPolygon(fifthPoints);  				}
Magic Number,CityTrafficSimulator.Vehicle,Tram,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Tram.cs,BuildGraphicsPath,The following statement contains a magic number: if (_length == 250)  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized  									  };    				PointF[] frontPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] midPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] backPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				if (positions[0] != positions[1])  					toReturn.AddPolygon(frontPoints);  				if (positions[2] != positions[3])  					toReturn.AddPolygon(midPoints);  				if (positions[4] != positions[5])  					toReturn.AddPolygon(backPoints);  				}  			// 40-Meter-Zug  			else  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)'  					GetPositionAbsAtArcPos(currentPosition - 255)'  					GetPositionAbsAtArcPos(currentPosition - 300)'  					GetPositionAbsAtArcPos(currentPosition - 305)'  					GetPositionAbsAtArcPos(currentPosition - 400)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized'  					(positions[6] - positions[7]).RotatedClockwise.Normalized'  					(positions[7] - positions[9]).RotatedClockwise.Normalized  									  };    				PointF[] firstPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] secondPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] thirdPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				PointF[] forthPoints =   					{   					positions[6]  -  11*normals[3]'  					positions[6]  +  11*normals[3]'  					positions[7]  +  11*normals[3]'  					positions[7]  -  11*normals[3]'  					};    				PointF[] fifthPoints =   					{   					positions[8]  -  11*normals[4]'  					positions[8]  +  11*normals[4]'  					positions[9]  +  11*normals[4]'  					positions[9]  -  11*normals[4]'  					};    				if ((positions[0] - positions[1]).IsNotZeroVector())  					toReturn.AddPolygon(firstPoints);  				if ((positions[2] - positions[3]).IsNotZeroVector())  					toReturn.AddPolygon(secondPoints);  				if ((positions[4] - positions[5]).IsNotZeroVector())  					toReturn.AddPolygon(thirdPoints);  				if ((positions[6] - positions[7]).IsNotZeroVector())  					toReturn.AddPolygon(forthPoints);  				if ((positions[8] - positions[9]).IsNotZeroVector())  					toReturn.AddPolygon(fifthPoints);  				}
Magic Number,CityTrafficSimulator.Vehicle,Tram,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Tram.cs,BuildGraphicsPath,The following statement contains a magic number: if (_length == 250)  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized  									  };    				PointF[] frontPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] midPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] backPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				if (positions[0] != positions[1])  					toReturn.AddPolygon(frontPoints);  				if (positions[2] != positions[3])  					toReturn.AddPolygon(midPoints);  				if (positions[4] != positions[5])  					toReturn.AddPolygon(backPoints);  				}  			// 40-Meter-Zug  			else  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)'  					GetPositionAbsAtArcPos(currentPosition - 255)'  					GetPositionAbsAtArcPos(currentPosition - 300)'  					GetPositionAbsAtArcPos(currentPosition - 305)'  					GetPositionAbsAtArcPos(currentPosition - 400)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized'  					(positions[6] - positions[7]).RotatedClockwise.Normalized'  					(positions[7] - positions[9]).RotatedClockwise.Normalized  									  };    				PointF[] firstPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] secondPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] thirdPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				PointF[] forthPoints =   					{   					positions[6]  -  11*normals[3]'  					positions[6]  +  11*normals[3]'  					positions[7]  +  11*normals[3]'  					positions[7]  -  11*normals[3]'  					};    				PointF[] fifthPoints =   					{   					positions[8]  -  11*normals[4]'  					positions[8]  +  11*normals[4]'  					positions[9]  +  11*normals[4]'  					positions[9]  -  11*normals[4]'  					};    				if ((positions[0] - positions[1]).IsNotZeroVector())  					toReturn.AddPolygon(firstPoints);  				if ((positions[2] - positions[3]).IsNotZeroVector())  					toReturn.AddPolygon(secondPoints);  				if ((positions[4] - positions[5]).IsNotZeroVector())  					toReturn.AddPolygon(thirdPoints);  				if ((positions[6] - positions[7]).IsNotZeroVector())  					toReturn.AddPolygon(forthPoints);  				if ((positions[8] - positions[9]).IsNotZeroVector())  					toReturn.AddPolygon(fifthPoints);  				}
Magic Number,CityTrafficSimulator.Vehicle,Tram,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Tram.cs,BuildGraphicsPath,The following statement contains a magic number: if (_length == 250)  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized  									  };    				PointF[] frontPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] midPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] backPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				if (positions[0] != positions[1])  					toReturn.AddPolygon(frontPoints);  				if (positions[2] != positions[3])  					toReturn.AddPolygon(midPoints);  				if (positions[4] != positions[5])  					toReturn.AddPolygon(backPoints);  				}  			// 40-Meter-Zug  			else  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)'  					GetPositionAbsAtArcPos(currentPosition - 255)'  					GetPositionAbsAtArcPos(currentPosition - 300)'  					GetPositionAbsAtArcPos(currentPosition - 305)'  					GetPositionAbsAtArcPos(currentPosition - 400)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized'  					(positions[6] - positions[7]).RotatedClockwise.Normalized'  					(positions[7] - positions[9]).RotatedClockwise.Normalized  									  };    				PointF[] firstPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] secondPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] thirdPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				PointF[] forthPoints =   					{   					positions[6]  -  11*normals[3]'  					positions[6]  +  11*normals[3]'  					positions[7]  +  11*normals[3]'  					positions[7]  -  11*normals[3]'  					};    				PointF[] fifthPoints =   					{   					positions[8]  -  11*normals[4]'  					positions[8]  +  11*normals[4]'  					positions[9]  +  11*normals[4]'  					positions[9]  -  11*normals[4]'  					};    				if ((positions[0] - positions[1]).IsNotZeroVector())  					toReturn.AddPolygon(firstPoints);  				if ((positions[2] - positions[3]).IsNotZeroVector())  					toReturn.AddPolygon(secondPoints);  				if ((positions[4] - positions[5]).IsNotZeroVector())  					toReturn.AddPolygon(thirdPoints);  				if ((positions[6] - positions[7]).IsNotZeroVector())  					toReturn.AddPolygon(forthPoints);  				if ((positions[8] - positions[9]).IsNotZeroVector())  					toReturn.AddPolygon(fifthPoints);  				}
Magic Number,CityTrafficSimulator.Vehicle,Tram,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Tram.cs,BuildGraphicsPath,The following statement contains a magic number: if (_length == 250)  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized  									  };    				PointF[] frontPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] midPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] backPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				if (positions[0] != positions[1])  					toReturn.AddPolygon(frontPoints);  				if (positions[2] != positions[3])  					toReturn.AddPolygon(midPoints);  				if (positions[4] != positions[5])  					toReturn.AddPolygon(backPoints);  				}  			// 40-Meter-Zug  			else  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)'  					GetPositionAbsAtArcPos(currentPosition - 255)'  					GetPositionAbsAtArcPos(currentPosition - 300)'  					GetPositionAbsAtArcPos(currentPosition - 305)'  					GetPositionAbsAtArcPos(currentPosition - 400)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized'  					(positions[6] - positions[7]).RotatedClockwise.Normalized'  					(positions[7] - positions[9]).RotatedClockwise.Normalized  									  };    				PointF[] firstPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] secondPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] thirdPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				PointF[] forthPoints =   					{   					positions[6]  -  11*normals[3]'  					positions[6]  +  11*normals[3]'  					positions[7]  +  11*normals[3]'  					positions[7]  -  11*normals[3]'  					};    				PointF[] fifthPoints =   					{   					positions[8]  -  11*normals[4]'  					positions[8]  +  11*normals[4]'  					positions[9]  +  11*normals[4]'  					positions[9]  -  11*normals[4]'  					};    				if ((positions[0] - positions[1]).IsNotZeroVector())  					toReturn.AddPolygon(firstPoints);  				if ((positions[2] - positions[3]).IsNotZeroVector())  					toReturn.AddPolygon(secondPoints);  				if ((positions[4] - positions[5]).IsNotZeroVector())  					toReturn.AddPolygon(thirdPoints);  				if ((positions[6] - positions[7]).IsNotZeroVector())  					toReturn.AddPolygon(forthPoints);  				if ((positions[8] - positions[9]).IsNotZeroVector())  					toReturn.AddPolygon(fifthPoints);  				}
Magic Number,CityTrafficSimulator.Vehicle,Tram,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Tram.cs,BuildGraphicsPath,The following statement contains a magic number: if (_length == 250)  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized  									  };    				PointF[] frontPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] midPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] backPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				if (positions[0] != positions[1])  					toReturn.AddPolygon(frontPoints);  				if (positions[2] != positions[3])  					toReturn.AddPolygon(midPoints);  				if (positions[4] != positions[5])  					toReturn.AddPolygon(backPoints);  				}  			// 40-Meter-Zug  			else  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)'  					GetPositionAbsAtArcPos(currentPosition - 255)'  					GetPositionAbsAtArcPos(currentPosition - 300)'  					GetPositionAbsAtArcPos(currentPosition - 305)'  					GetPositionAbsAtArcPos(currentPosition - 400)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized'  					(positions[6] - positions[7]).RotatedClockwise.Normalized'  					(positions[7] - positions[9]).RotatedClockwise.Normalized  									  };    				PointF[] firstPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] secondPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] thirdPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				PointF[] forthPoints =   					{   					positions[6]  -  11*normals[3]'  					positions[6]  +  11*normals[3]'  					positions[7]  +  11*normals[3]'  					positions[7]  -  11*normals[3]'  					};    				PointF[] fifthPoints =   					{   					positions[8]  -  11*normals[4]'  					positions[8]  +  11*normals[4]'  					positions[9]  +  11*normals[4]'  					positions[9]  -  11*normals[4]'  					};    				if ((positions[0] - positions[1]).IsNotZeroVector())  					toReturn.AddPolygon(firstPoints);  				if ((positions[2] - positions[3]).IsNotZeroVector())  					toReturn.AddPolygon(secondPoints);  				if ((positions[4] - positions[5]).IsNotZeroVector())  					toReturn.AddPolygon(thirdPoints);  				if ((positions[6] - positions[7]).IsNotZeroVector())  					toReturn.AddPolygon(forthPoints);  				if ((positions[8] - positions[9]).IsNotZeroVector())  					toReturn.AddPolygon(fifthPoints);  				}
Magic Number,CityTrafficSimulator.Vehicle,Tram,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Tram.cs,BuildGraphicsPath,The following statement contains a magic number: if (_length == 250)  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized  									  };    				PointF[] frontPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] midPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] backPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				if (positions[0] != positions[1])  					toReturn.AddPolygon(frontPoints);  				if (positions[2] != positions[3])  					toReturn.AddPolygon(midPoints);  				if (positions[4] != positions[5])  					toReturn.AddPolygon(backPoints);  				}  			// 40-Meter-Zug  			else  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)'  					GetPositionAbsAtArcPos(currentPosition - 255)'  					GetPositionAbsAtArcPos(currentPosition - 300)'  					GetPositionAbsAtArcPos(currentPosition - 305)'  					GetPositionAbsAtArcPos(currentPosition - 400)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized'  					(positions[6] - positions[7]).RotatedClockwise.Normalized'  					(positions[7] - positions[9]).RotatedClockwise.Normalized  									  };    				PointF[] firstPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] secondPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] thirdPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				PointF[] forthPoints =   					{   					positions[6]  -  11*normals[3]'  					positions[6]  +  11*normals[3]'  					positions[7]  +  11*normals[3]'  					positions[7]  -  11*normals[3]'  					};    				PointF[] fifthPoints =   					{   					positions[8]  -  11*normals[4]'  					positions[8]  +  11*normals[4]'  					positions[9]  +  11*normals[4]'  					positions[9]  -  11*normals[4]'  					};    				if ((positions[0] - positions[1]).IsNotZeroVector())  					toReturn.AddPolygon(firstPoints);  				if ((positions[2] - positions[3]).IsNotZeroVector())  					toReturn.AddPolygon(secondPoints);  				if ((positions[4] - positions[5]).IsNotZeroVector())  					toReturn.AddPolygon(thirdPoints);  				if ((positions[6] - positions[7]).IsNotZeroVector())  					toReturn.AddPolygon(forthPoints);  				if ((positions[8] - positions[9]).IsNotZeroVector())  					toReturn.AddPolygon(fifthPoints);  				}
Magic Number,CityTrafficSimulator.Vehicle,Tram,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Tram.cs,BuildGraphicsPath,The following statement contains a magic number: if (_length == 250)  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized  									  };    				PointF[] frontPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] midPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] backPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				if (positions[0] != positions[1])  					toReturn.AddPolygon(frontPoints);  				if (positions[2] != positions[3])  					toReturn.AddPolygon(midPoints);  				if (positions[4] != positions[5])  					toReturn.AddPolygon(backPoints);  				}  			// 40-Meter-Zug  			else  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)'  					GetPositionAbsAtArcPos(currentPosition - 255)'  					GetPositionAbsAtArcPos(currentPosition - 300)'  					GetPositionAbsAtArcPos(currentPosition - 305)'  					GetPositionAbsAtArcPos(currentPosition - 400)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized'  					(positions[6] - positions[7]).RotatedClockwise.Normalized'  					(positions[7] - positions[9]).RotatedClockwise.Normalized  									  };    				PointF[] firstPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] secondPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] thirdPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				PointF[] forthPoints =   					{   					positions[6]  -  11*normals[3]'  					positions[6]  +  11*normals[3]'  					positions[7]  +  11*normals[3]'  					positions[7]  -  11*normals[3]'  					};    				PointF[] fifthPoints =   					{   					positions[8]  -  11*normals[4]'  					positions[8]  +  11*normals[4]'  					positions[9]  +  11*normals[4]'  					positions[9]  -  11*normals[4]'  					};    				if ((positions[0] - positions[1]).IsNotZeroVector())  					toReturn.AddPolygon(firstPoints);  				if ((positions[2] - positions[3]).IsNotZeroVector())  					toReturn.AddPolygon(secondPoints);  				if ((positions[4] - positions[5]).IsNotZeroVector())  					toReturn.AddPolygon(thirdPoints);  				if ((positions[6] - positions[7]).IsNotZeroVector())  					toReturn.AddPolygon(forthPoints);  				if ((positions[8] - positions[9]).IsNotZeroVector())  					toReturn.AddPolygon(fifthPoints);  				}
Magic Number,CityTrafficSimulator.Vehicle,Tram,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Tram.cs,BuildGraphicsPath,The following statement contains a magic number: if (_length == 250)  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized  									  };    				PointF[] frontPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] midPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] backPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				if (positions[0] != positions[1])  					toReturn.AddPolygon(frontPoints);  				if (positions[2] != positions[3])  					toReturn.AddPolygon(midPoints);  				if (positions[4] != positions[5])  					toReturn.AddPolygon(backPoints);  				}  			// 40-Meter-Zug  			else  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)'  					GetPositionAbsAtArcPos(currentPosition - 255)'  					GetPositionAbsAtArcPos(currentPosition - 300)'  					GetPositionAbsAtArcPos(currentPosition - 305)'  					GetPositionAbsAtArcPos(currentPosition - 400)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized'  					(positions[6] - positions[7]).RotatedClockwise.Normalized'  					(positions[7] - positions[9]).RotatedClockwise.Normalized  									  };    				PointF[] firstPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] secondPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] thirdPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				PointF[] forthPoints =   					{   					positions[6]  -  11*normals[3]'  					positions[6]  +  11*normals[3]'  					positions[7]  +  11*normals[3]'  					positions[7]  -  11*normals[3]'  					};    				PointF[] fifthPoints =   					{   					positions[8]  -  11*normals[4]'  					positions[8]  +  11*normals[4]'  					positions[9]  +  11*normals[4]'  					positions[9]  -  11*normals[4]'  					};    				if ((positions[0] - positions[1]).IsNotZeroVector())  					toReturn.AddPolygon(firstPoints);  				if ((positions[2] - positions[3]).IsNotZeroVector())  					toReturn.AddPolygon(secondPoints);  				if ((positions[4] - positions[5]).IsNotZeroVector())  					toReturn.AddPolygon(thirdPoints);  				if ((positions[6] - positions[7]).IsNotZeroVector())  					toReturn.AddPolygon(forthPoints);  				if ((positions[8] - positions[9]).IsNotZeroVector())  					toReturn.AddPolygon(fifthPoints);  				}
Magic Number,CityTrafficSimulator.Vehicle,Tram,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Tram.cs,BuildGraphicsPath,The following statement contains a magic number: if (_length == 250)  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized  									  };    				PointF[] frontPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] midPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] backPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				if (positions[0] != positions[1])  					toReturn.AddPolygon(frontPoints);  				if (positions[2] != positions[3])  					toReturn.AddPolygon(midPoints);  				if (positions[4] != positions[5])  					toReturn.AddPolygon(backPoints);  				}  			// 40-Meter-Zug  			else  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)'  					GetPositionAbsAtArcPos(currentPosition - 255)'  					GetPositionAbsAtArcPos(currentPosition - 300)'  					GetPositionAbsAtArcPos(currentPosition - 305)'  					GetPositionAbsAtArcPos(currentPosition - 400)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized'  					(positions[6] - positions[7]).RotatedClockwise.Normalized'  					(positions[7] - positions[9]).RotatedClockwise.Normalized  									  };    				PointF[] firstPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] secondPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] thirdPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				PointF[] forthPoints =   					{   					positions[6]  -  11*normals[3]'  					positions[6]  +  11*normals[3]'  					positions[7]  +  11*normals[3]'  					positions[7]  -  11*normals[3]'  					};    				PointF[] fifthPoints =   					{   					positions[8]  -  11*normals[4]'  					positions[8]  +  11*normals[4]'  					positions[9]  +  11*normals[4]'  					positions[9]  -  11*normals[4]'  					};    				if ((positions[0] - positions[1]).IsNotZeroVector())  					toReturn.AddPolygon(firstPoints);  				if ((positions[2] - positions[3]).IsNotZeroVector())  					toReturn.AddPolygon(secondPoints);  				if ((positions[4] - positions[5]).IsNotZeroVector())  					toReturn.AddPolygon(thirdPoints);  				if ((positions[6] - positions[7]).IsNotZeroVector())  					toReturn.AddPolygon(forthPoints);  				if ((positions[8] - positions[9]).IsNotZeroVector())  					toReturn.AddPolygon(fifthPoints);  				}
Magic Number,CityTrafficSimulator.Vehicle,Tram,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Tram.cs,BuildGraphicsPath,The following statement contains a magic number: if (_length == 250)  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized  									  };    				PointF[] frontPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] midPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] backPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				if (positions[0] != positions[1])  					toReturn.AddPolygon(frontPoints);  				if (positions[2] != positions[3])  					toReturn.AddPolygon(midPoints);  				if (positions[4] != positions[5])  					toReturn.AddPolygon(backPoints);  				}  			// 40-Meter-Zug  			else  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)'  					GetPositionAbsAtArcPos(currentPosition - 255)'  					GetPositionAbsAtArcPos(currentPosition - 300)'  					GetPositionAbsAtArcPos(currentPosition - 305)'  					GetPositionAbsAtArcPos(currentPosition - 400)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized'  					(positions[6] - positions[7]).RotatedClockwise.Normalized'  					(positions[7] - positions[9]).RotatedClockwise.Normalized  									  };    				PointF[] firstPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] secondPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] thirdPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				PointF[] forthPoints =   					{   					positions[6]  -  11*normals[3]'  					positions[6]  +  11*normals[3]'  					positions[7]  +  11*normals[3]'  					positions[7]  -  11*normals[3]'  					};    				PointF[] fifthPoints =   					{   					positions[8]  -  11*normals[4]'  					positions[8]  +  11*normals[4]'  					positions[9]  +  11*normals[4]'  					positions[9]  -  11*normals[4]'  					};    				if ((positions[0] - positions[1]).IsNotZeroVector())  					toReturn.AddPolygon(firstPoints);  				if ((positions[2] - positions[3]).IsNotZeroVector())  					toReturn.AddPolygon(secondPoints);  				if ((positions[4] - positions[5]).IsNotZeroVector())  					toReturn.AddPolygon(thirdPoints);  				if ((positions[6] - positions[7]).IsNotZeroVector())  					toReturn.AddPolygon(forthPoints);  				if ((positions[8] - positions[9]).IsNotZeroVector())  					toReturn.AddPolygon(fifthPoints);  				}
Magic Number,CityTrafficSimulator.Vehicle,Tram,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Tram.cs,BuildGraphicsPath,The following statement contains a magic number: if (_length == 250)  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized  									  };    				PointF[] frontPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] midPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] backPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				if (positions[0] != positions[1])  					toReturn.AddPolygon(frontPoints);  				if (positions[2] != positions[3])  					toReturn.AddPolygon(midPoints);  				if (positions[4] != positions[5])  					toReturn.AddPolygon(backPoints);  				}  			// 40-Meter-Zug  			else  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)'  					GetPositionAbsAtArcPos(currentPosition - 255)'  					GetPositionAbsAtArcPos(currentPosition - 300)'  					GetPositionAbsAtArcPos(currentPosition - 305)'  					GetPositionAbsAtArcPos(currentPosition - 400)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized'  					(positions[6] - positions[7]).RotatedClockwise.Normalized'  					(positions[7] - positions[9]).RotatedClockwise.Normalized  									  };    				PointF[] firstPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] secondPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] thirdPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				PointF[] forthPoints =   					{   					positions[6]  -  11*normals[3]'  					positions[6]  +  11*normals[3]'  					positions[7]  +  11*normals[3]'  					positions[7]  -  11*normals[3]'  					};    				PointF[] fifthPoints =   					{   					positions[8]  -  11*normals[4]'  					positions[8]  +  11*normals[4]'  					positions[9]  +  11*normals[4]'  					positions[9]  -  11*normals[4]'  					};    				if ((positions[0] - positions[1]).IsNotZeroVector())  					toReturn.AddPolygon(firstPoints);  				if ((positions[2] - positions[3]).IsNotZeroVector())  					toReturn.AddPolygon(secondPoints);  				if ((positions[4] - positions[5]).IsNotZeroVector())  					toReturn.AddPolygon(thirdPoints);  				if ((positions[6] - positions[7]).IsNotZeroVector())  					toReturn.AddPolygon(forthPoints);  				if ((positions[8] - positions[9]).IsNotZeroVector())  					toReturn.AddPolygon(fifthPoints);  				}
Magic Number,CityTrafficSimulator.Vehicle,Tram,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Tram.cs,BuildGraphicsPath,The following statement contains a magic number: if (_length == 250)  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized  									  };    				PointF[] frontPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] midPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] backPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				if (positions[0] != positions[1])  					toReturn.AddPolygon(frontPoints);  				if (positions[2] != positions[3])  					toReturn.AddPolygon(midPoints);  				if (positions[4] != positions[5])  					toReturn.AddPolygon(backPoints);  				}  			// 40-Meter-Zug  			else  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)'  					GetPositionAbsAtArcPos(currentPosition - 255)'  					GetPositionAbsAtArcPos(currentPosition - 300)'  					GetPositionAbsAtArcPos(currentPosition - 305)'  					GetPositionAbsAtArcPos(currentPosition - 400)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized'  					(positions[6] - positions[7]).RotatedClockwise.Normalized'  					(positions[7] - positions[9]).RotatedClockwise.Normalized  									  };    				PointF[] firstPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] secondPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] thirdPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				PointF[] forthPoints =   					{   					positions[6]  -  11*normals[3]'  					positions[6]  +  11*normals[3]'  					positions[7]  +  11*normals[3]'  					positions[7]  -  11*normals[3]'  					};    				PointF[] fifthPoints =   					{   					positions[8]  -  11*normals[4]'  					positions[8]  +  11*normals[4]'  					positions[9]  +  11*normals[4]'  					positions[9]  -  11*normals[4]'  					};    				if ((positions[0] - positions[1]).IsNotZeroVector())  					toReturn.AddPolygon(firstPoints);  				if ((positions[2] - positions[3]).IsNotZeroVector())  					toReturn.AddPolygon(secondPoints);  				if ((positions[4] - positions[5]).IsNotZeroVector())  					toReturn.AddPolygon(thirdPoints);  				if ((positions[6] - positions[7]).IsNotZeroVector())  					toReturn.AddPolygon(forthPoints);  				if ((positions[8] - positions[9]).IsNotZeroVector())  					toReturn.AddPolygon(fifthPoints);  				}
Magic Number,CityTrafficSimulator.Vehicle,Tram,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Tram.cs,BuildGraphicsPath,The following statement contains a magic number: if (_length == 250)  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized  									  };    				PointF[] frontPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] midPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] backPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				if (positions[0] != positions[1])  					toReturn.AddPolygon(frontPoints);  				if (positions[2] != positions[3])  					toReturn.AddPolygon(midPoints);  				if (positions[4] != positions[5])  					toReturn.AddPolygon(backPoints);  				}  			// 40-Meter-Zug  			else  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)'  					GetPositionAbsAtArcPos(currentPosition - 255)'  					GetPositionAbsAtArcPos(currentPosition - 300)'  					GetPositionAbsAtArcPos(currentPosition - 305)'  					GetPositionAbsAtArcPos(currentPosition - 400)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized'  					(positions[6] - positions[7]).RotatedClockwise.Normalized'  					(positions[7] - positions[9]).RotatedClockwise.Normalized  									  };    				PointF[] firstPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] secondPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] thirdPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				PointF[] forthPoints =   					{   					positions[6]  -  11*normals[3]'  					positions[6]  +  11*normals[3]'  					positions[7]  +  11*normals[3]'  					positions[7]  -  11*normals[3]'  					};    				PointF[] fifthPoints =   					{   					positions[8]  -  11*normals[4]'  					positions[8]  +  11*normals[4]'  					positions[9]  +  11*normals[4]'  					positions[9]  -  11*normals[4]'  					};    				if ((positions[0] - positions[1]).IsNotZeroVector())  					toReturn.AddPolygon(firstPoints);  				if ((positions[2] - positions[3]).IsNotZeroVector())  					toReturn.AddPolygon(secondPoints);  				if ((positions[4] - positions[5]).IsNotZeroVector())  					toReturn.AddPolygon(thirdPoints);  				if ((positions[6] - positions[7]).IsNotZeroVector())  					toReturn.AddPolygon(forthPoints);  				if ((positions[8] - positions[9]).IsNotZeroVector())  					toReturn.AddPolygon(fifthPoints);  				}
Magic Number,CityTrafficSimulator.Vehicle,Tram,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Tram.cs,BuildGraphicsPath,The following statement contains a magic number: if (_length == 250)  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized  									  };    				PointF[] frontPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] midPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] backPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				if (positions[0] != positions[1])  					toReturn.AddPolygon(frontPoints);  				if (positions[2] != positions[3])  					toReturn.AddPolygon(midPoints);  				if (positions[4] != positions[5])  					toReturn.AddPolygon(backPoints);  				}  			// 40-Meter-Zug  			else  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)'  					GetPositionAbsAtArcPos(currentPosition - 255)'  					GetPositionAbsAtArcPos(currentPosition - 300)'  					GetPositionAbsAtArcPos(currentPosition - 305)'  					GetPositionAbsAtArcPos(currentPosition - 400)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized'  					(positions[6] - positions[7]).RotatedClockwise.Normalized'  					(positions[7] - positions[9]).RotatedClockwise.Normalized  									  };    				PointF[] firstPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] secondPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] thirdPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				PointF[] forthPoints =   					{   					positions[6]  -  11*normals[3]'  					positions[6]  +  11*normals[3]'  					positions[7]  +  11*normals[3]'  					positions[7]  -  11*normals[3]'  					};    				PointF[] fifthPoints =   					{   					positions[8]  -  11*normals[4]'  					positions[8]  +  11*normals[4]'  					positions[9]  +  11*normals[4]'  					positions[9]  -  11*normals[4]'  					};    				if ((positions[0] - positions[1]).IsNotZeroVector())  					toReturn.AddPolygon(firstPoints);  				if ((positions[2] - positions[3]).IsNotZeroVector())  					toReturn.AddPolygon(secondPoints);  				if ((positions[4] - positions[5]).IsNotZeroVector())  					toReturn.AddPolygon(thirdPoints);  				if ((positions[6] - positions[7]).IsNotZeroVector())  					toReturn.AddPolygon(forthPoints);  				if ((positions[8] - positions[9]).IsNotZeroVector())  					toReturn.AddPolygon(fifthPoints);  				}
Magic Number,CityTrafficSimulator.Vehicle,Tram,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Tram.cs,BuildGraphicsPath,The following statement contains a magic number: if (_length == 250)  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized  									  };    				PointF[] frontPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] midPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] backPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				if (positions[0] != positions[1])  					toReturn.AddPolygon(frontPoints);  				if (positions[2] != positions[3])  					toReturn.AddPolygon(midPoints);  				if (positions[4] != positions[5])  					toReturn.AddPolygon(backPoints);  				}  			// 40-Meter-Zug  			else  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)'  					GetPositionAbsAtArcPos(currentPosition - 255)'  					GetPositionAbsAtArcPos(currentPosition - 300)'  					GetPositionAbsAtArcPos(currentPosition - 305)'  					GetPositionAbsAtArcPos(currentPosition - 400)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized'  					(positions[6] - positions[7]).RotatedClockwise.Normalized'  					(positions[7] - positions[9]).RotatedClockwise.Normalized  									  };    				PointF[] firstPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] secondPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] thirdPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				PointF[] forthPoints =   					{   					positions[6]  -  11*normals[3]'  					positions[6]  +  11*normals[3]'  					positions[7]  +  11*normals[3]'  					positions[7]  -  11*normals[3]'  					};    				PointF[] fifthPoints =   					{   					positions[8]  -  11*normals[4]'  					positions[8]  +  11*normals[4]'  					positions[9]  +  11*normals[4]'  					positions[9]  -  11*normals[4]'  					};    				if ((positions[0] - positions[1]).IsNotZeroVector())  					toReturn.AddPolygon(firstPoints);  				if ((positions[2] - positions[3]).IsNotZeroVector())  					toReturn.AddPolygon(secondPoints);  				if ((positions[4] - positions[5]).IsNotZeroVector())  					toReturn.AddPolygon(thirdPoints);  				if ((positions[6] - positions[7]).IsNotZeroVector())  					toReturn.AddPolygon(forthPoints);  				if ((positions[8] - positions[9]).IsNotZeroVector())  					toReturn.AddPolygon(fifthPoints);  				}
Magic Number,CityTrafficSimulator.Vehicle,Tram,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Tram.cs,BuildGraphicsPath,The following statement contains a magic number: if (_length == 250)  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized  									  };    				PointF[] frontPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] midPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] backPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				if (positions[0] != positions[1])  					toReturn.AddPolygon(frontPoints);  				if (positions[2] != positions[3])  					toReturn.AddPolygon(midPoints);  				if (positions[4] != positions[5])  					toReturn.AddPolygon(backPoints);  				}  			// 40-Meter-Zug  			else  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)'  					GetPositionAbsAtArcPos(currentPosition - 255)'  					GetPositionAbsAtArcPos(currentPosition - 300)'  					GetPositionAbsAtArcPos(currentPosition - 305)'  					GetPositionAbsAtArcPos(currentPosition - 400)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized'  					(positions[6] - positions[7]).RotatedClockwise.Normalized'  					(positions[7] - positions[9]).RotatedClockwise.Normalized  									  };    				PointF[] firstPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] secondPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] thirdPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				PointF[] forthPoints =   					{   					positions[6]  -  11*normals[3]'  					positions[6]  +  11*normals[3]'  					positions[7]  +  11*normals[3]'  					positions[7]  -  11*normals[3]'  					};    				PointF[] fifthPoints =   					{   					positions[8]  -  11*normals[4]'  					positions[8]  +  11*normals[4]'  					positions[9]  +  11*normals[4]'  					positions[9]  -  11*normals[4]'  					};    				if ((positions[0] - positions[1]).IsNotZeroVector())  					toReturn.AddPolygon(firstPoints);  				if ((positions[2] - positions[3]).IsNotZeroVector())  					toReturn.AddPolygon(secondPoints);  				if ((positions[4] - positions[5]).IsNotZeroVector())  					toReturn.AddPolygon(thirdPoints);  				if ((positions[6] - positions[7]).IsNotZeroVector())  					toReturn.AddPolygon(forthPoints);  				if ((positions[8] - positions[9]).IsNotZeroVector())  					toReturn.AddPolygon(fifthPoints);  				}
Magic Number,CityTrafficSimulator.Vehicle,Tram,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Tram.cs,BuildGraphicsPath,The following statement contains a magic number: if (_length == 250)  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized  									  };    				PointF[] frontPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] midPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] backPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				if (positions[0] != positions[1])  					toReturn.AddPolygon(frontPoints);  				if (positions[2] != positions[3])  					toReturn.AddPolygon(midPoints);  				if (positions[4] != positions[5])  					toReturn.AddPolygon(backPoints);  				}  			// 40-Meter-Zug  			else  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)'  					GetPositionAbsAtArcPos(currentPosition - 255)'  					GetPositionAbsAtArcPos(currentPosition - 300)'  					GetPositionAbsAtArcPos(currentPosition - 305)'  					GetPositionAbsAtArcPos(currentPosition - 400)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized'  					(positions[6] - positions[7]).RotatedClockwise.Normalized'  					(positions[7] - positions[9]).RotatedClockwise.Normalized  									  };    				PointF[] firstPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] secondPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] thirdPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				PointF[] forthPoints =   					{   					positions[6]  -  11*normals[3]'  					positions[6]  +  11*normals[3]'  					positions[7]  +  11*normals[3]'  					positions[7]  -  11*normals[3]'  					};    				PointF[] fifthPoints =   					{   					positions[8]  -  11*normals[4]'  					positions[8]  +  11*normals[4]'  					positions[9]  +  11*normals[4]'  					positions[9]  -  11*normals[4]'  					};    				if ((positions[0] - positions[1]).IsNotZeroVector())  					toReturn.AddPolygon(firstPoints);  				if ((positions[2] - positions[3]).IsNotZeroVector())  					toReturn.AddPolygon(secondPoints);  				if ((positions[4] - positions[5]).IsNotZeroVector())  					toReturn.AddPolygon(thirdPoints);  				if ((positions[6] - positions[7]).IsNotZeroVector())  					toReturn.AddPolygon(forthPoints);  				if ((positions[8] - positions[9]).IsNotZeroVector())  					toReturn.AddPolygon(fifthPoints);  				}
Magic Number,CityTrafficSimulator.Vehicle,Tram,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Tram.cs,BuildGraphicsPath,The following statement contains a magic number: if (_length == 250)  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized  									  };    				PointF[] frontPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] midPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] backPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				if (positions[0] != positions[1])  					toReturn.AddPolygon(frontPoints);  				if (positions[2] != positions[3])  					toReturn.AddPolygon(midPoints);  				if (positions[4] != positions[5])  					toReturn.AddPolygon(backPoints);  				}  			// 40-Meter-Zug  			else  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)'  					GetPositionAbsAtArcPos(currentPosition - 255)'  					GetPositionAbsAtArcPos(currentPosition - 300)'  					GetPositionAbsAtArcPos(currentPosition - 305)'  					GetPositionAbsAtArcPos(currentPosition - 400)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized'  					(positions[6] - positions[7]).RotatedClockwise.Normalized'  					(positions[7] - positions[9]).RotatedClockwise.Normalized  									  };    				PointF[] firstPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] secondPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] thirdPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				PointF[] forthPoints =   					{   					positions[6]  -  11*normals[3]'  					positions[6]  +  11*normals[3]'  					positions[7]  +  11*normals[3]'  					positions[7]  -  11*normals[3]'  					};    				PointF[] fifthPoints =   					{   					positions[8]  -  11*normals[4]'  					positions[8]  +  11*normals[4]'  					positions[9]  +  11*normals[4]'  					positions[9]  -  11*normals[4]'  					};    				if ((positions[0] - positions[1]).IsNotZeroVector())  					toReturn.AddPolygon(firstPoints);  				if ((positions[2] - positions[3]).IsNotZeroVector())  					toReturn.AddPolygon(secondPoints);  				if ((positions[4] - positions[5]).IsNotZeroVector())  					toReturn.AddPolygon(thirdPoints);  				if ((positions[6] - positions[7]).IsNotZeroVector())  					toReturn.AddPolygon(forthPoints);  				if ((positions[8] - positions[9]).IsNotZeroVector())  					toReturn.AddPolygon(fifthPoints);  				}
Magic Number,CityTrafficSimulator.Vehicle,Tram,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Tram.cs,BuildGraphicsPath,The following statement contains a magic number: if (_length == 250)  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized  									  };    				PointF[] frontPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] midPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] backPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				if (positions[0] != positions[1])  					toReturn.AddPolygon(frontPoints);  				if (positions[2] != positions[3])  					toReturn.AddPolygon(midPoints);  				if (positions[4] != positions[5])  					toReturn.AddPolygon(backPoints);  				}  			// 40-Meter-Zug  			else  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)'  					GetPositionAbsAtArcPos(currentPosition - 255)'  					GetPositionAbsAtArcPos(currentPosition - 300)'  					GetPositionAbsAtArcPos(currentPosition - 305)'  					GetPositionAbsAtArcPos(currentPosition - 400)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized'  					(positions[6] - positions[7]).RotatedClockwise.Normalized'  					(positions[7] - positions[9]).RotatedClockwise.Normalized  									  };    				PointF[] firstPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] secondPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] thirdPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				PointF[] forthPoints =   					{   					positions[6]  -  11*normals[3]'  					positions[6]  +  11*normals[3]'  					positions[7]  +  11*normals[3]'  					positions[7]  -  11*normals[3]'  					};    				PointF[] fifthPoints =   					{   					positions[8]  -  11*normals[4]'  					positions[8]  +  11*normals[4]'  					positions[9]  +  11*normals[4]'  					positions[9]  -  11*normals[4]'  					};    				if ((positions[0] - positions[1]).IsNotZeroVector())  					toReturn.AddPolygon(firstPoints);  				if ((positions[2] - positions[3]).IsNotZeroVector())  					toReturn.AddPolygon(secondPoints);  				if ((positions[4] - positions[5]).IsNotZeroVector())  					toReturn.AddPolygon(thirdPoints);  				if ((positions[6] - positions[7]).IsNotZeroVector())  					toReturn.AddPolygon(forthPoints);  				if ((positions[8] - positions[9]).IsNotZeroVector())  					toReturn.AddPolygon(fifthPoints);  				}
Magic Number,CityTrafficSimulator.Vehicle,Tram,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Tram.cs,BuildGraphicsPath,The following statement contains a magic number: if (_length == 250)  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized  									  };    				PointF[] frontPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] midPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] backPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				if (positions[0] != positions[1])  					toReturn.AddPolygon(frontPoints);  				if (positions[2] != positions[3])  					toReturn.AddPolygon(midPoints);  				if (positions[4] != positions[5])  					toReturn.AddPolygon(backPoints);  				}  			// 40-Meter-Zug  			else  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)'  					GetPositionAbsAtArcPos(currentPosition - 255)'  					GetPositionAbsAtArcPos(currentPosition - 300)'  					GetPositionAbsAtArcPos(currentPosition - 305)'  					GetPositionAbsAtArcPos(currentPosition - 400)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized'  					(positions[6] - positions[7]).RotatedClockwise.Normalized'  					(positions[7] - positions[9]).RotatedClockwise.Normalized  									  };    				PointF[] firstPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] secondPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] thirdPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				PointF[] forthPoints =   					{   					positions[6]  -  11*normals[3]'  					positions[6]  +  11*normals[3]'  					positions[7]  +  11*normals[3]'  					positions[7]  -  11*normals[3]'  					};    				PointF[] fifthPoints =   					{   					positions[8]  -  11*normals[4]'  					positions[8]  +  11*normals[4]'  					positions[9]  +  11*normals[4]'  					positions[9]  -  11*normals[4]'  					};    				if ((positions[0] - positions[1]).IsNotZeroVector())  					toReturn.AddPolygon(firstPoints);  				if ((positions[2] - positions[3]).IsNotZeroVector())  					toReturn.AddPolygon(secondPoints);  				if ((positions[4] - positions[5]).IsNotZeroVector())  					toReturn.AddPolygon(thirdPoints);  				if ((positions[6] - positions[7]).IsNotZeroVector())  					toReturn.AddPolygon(forthPoints);  				if ((positions[8] - positions[9]).IsNotZeroVector())  					toReturn.AddPolygon(fifthPoints);  				}
Magic Number,CityTrafficSimulator.Vehicle,Tram,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Tram.cs,BuildGraphicsPath,The following statement contains a magic number: if (_length == 250)  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized  									  };    				PointF[] frontPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] midPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] backPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				if (positions[0] != positions[1])  					toReturn.AddPolygon(frontPoints);  				if (positions[2] != positions[3])  					toReturn.AddPolygon(midPoints);  				if (positions[4] != positions[5])  					toReturn.AddPolygon(backPoints);  				}  			// 40-Meter-Zug  			else  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)'  					GetPositionAbsAtArcPos(currentPosition - 255)'  					GetPositionAbsAtArcPos(currentPosition - 300)'  					GetPositionAbsAtArcPos(currentPosition - 305)'  					GetPositionAbsAtArcPos(currentPosition - 400)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized'  					(positions[6] - positions[7]).RotatedClockwise.Normalized'  					(positions[7] - positions[9]).RotatedClockwise.Normalized  									  };    				PointF[] firstPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] secondPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] thirdPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				PointF[] forthPoints =   					{   					positions[6]  -  11*normals[3]'  					positions[6]  +  11*normals[3]'  					positions[7]  +  11*normals[3]'  					positions[7]  -  11*normals[3]'  					};    				PointF[] fifthPoints =   					{   					positions[8]  -  11*normals[4]'  					positions[8]  +  11*normals[4]'  					positions[9]  +  11*normals[4]'  					positions[9]  -  11*normals[4]'  					};    				if ((positions[0] - positions[1]).IsNotZeroVector())  					toReturn.AddPolygon(firstPoints);  				if ((positions[2] - positions[3]).IsNotZeroVector())  					toReturn.AddPolygon(secondPoints);  				if ((positions[4] - positions[5]).IsNotZeroVector())  					toReturn.AddPolygon(thirdPoints);  				if ((positions[6] - positions[7]).IsNotZeroVector())  					toReturn.AddPolygon(forthPoints);  				if ((positions[8] - positions[9]).IsNotZeroVector())  					toReturn.AddPolygon(fifthPoints);  				}
Magic Number,CityTrafficSimulator.Vehicle,Tram,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Tram.cs,BuildGraphicsPath,The following statement contains a magic number: if (_length == 250)  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized  									  };    				PointF[] frontPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] midPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] backPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				if (positions[0] != positions[1])  					toReturn.AddPolygon(frontPoints);  				if (positions[2] != positions[3])  					toReturn.AddPolygon(midPoints);  				if (positions[4] != positions[5])  					toReturn.AddPolygon(backPoints);  				}  			// 40-Meter-Zug  			else  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)'  					GetPositionAbsAtArcPos(currentPosition - 255)'  					GetPositionAbsAtArcPos(currentPosition - 300)'  					GetPositionAbsAtArcPos(currentPosition - 305)'  					GetPositionAbsAtArcPos(currentPosition - 400)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized'  					(positions[6] - positions[7]).RotatedClockwise.Normalized'  					(positions[7] - positions[9]).RotatedClockwise.Normalized  									  };    				PointF[] firstPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] secondPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] thirdPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				PointF[] forthPoints =   					{   					positions[6]  -  11*normals[3]'  					positions[6]  +  11*normals[3]'  					positions[7]  +  11*normals[3]'  					positions[7]  -  11*normals[3]'  					};    				PointF[] fifthPoints =   					{   					positions[8]  -  11*normals[4]'  					positions[8]  +  11*normals[4]'  					positions[9]  +  11*normals[4]'  					positions[9]  -  11*normals[4]'  					};    				if ((positions[0] - positions[1]).IsNotZeroVector())  					toReturn.AddPolygon(firstPoints);  				if ((positions[2] - positions[3]).IsNotZeroVector())  					toReturn.AddPolygon(secondPoints);  				if ((positions[4] - positions[5]).IsNotZeroVector())  					toReturn.AddPolygon(thirdPoints);  				if ((positions[6] - positions[7]).IsNotZeroVector())  					toReturn.AddPolygon(forthPoints);  				if ((positions[8] - positions[9]).IsNotZeroVector())  					toReturn.AddPolygon(fifthPoints);  				}
Magic Number,CityTrafficSimulator.Vehicle,Tram,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Tram.cs,BuildGraphicsPath,The following statement contains a magic number: if (_length == 250)  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized  									  };    				PointF[] frontPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] midPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] backPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				if (positions[0] != positions[1])  					toReturn.AddPolygon(frontPoints);  				if (positions[2] != positions[3])  					toReturn.AddPolygon(midPoints);  				if (positions[4] != positions[5])  					toReturn.AddPolygon(backPoints);  				}  			// 40-Meter-Zug  			else  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)'  					GetPositionAbsAtArcPos(currentPosition - 255)'  					GetPositionAbsAtArcPos(currentPosition - 300)'  					GetPositionAbsAtArcPos(currentPosition - 305)'  					GetPositionAbsAtArcPos(currentPosition - 400)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized'  					(positions[6] - positions[7]).RotatedClockwise.Normalized'  					(positions[7] - positions[9]).RotatedClockwise.Normalized  									  };    				PointF[] firstPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] secondPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] thirdPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				PointF[] forthPoints =   					{   					positions[6]  -  11*normals[3]'  					positions[6]  +  11*normals[3]'  					positions[7]  +  11*normals[3]'  					positions[7]  -  11*normals[3]'  					};    				PointF[] fifthPoints =   					{   					positions[8]  -  11*normals[4]'  					positions[8]  +  11*normals[4]'  					positions[9]  +  11*normals[4]'  					positions[9]  -  11*normals[4]'  					};    				if ((positions[0] - positions[1]).IsNotZeroVector())  					toReturn.AddPolygon(firstPoints);  				if ((positions[2] - positions[3]).IsNotZeroVector())  					toReturn.AddPolygon(secondPoints);  				if ((positions[4] - positions[5]).IsNotZeroVector())  					toReturn.AddPolygon(thirdPoints);  				if ((positions[6] - positions[7]).IsNotZeroVector())  					toReturn.AddPolygon(forthPoints);  				if ((positions[8] - positions[9]).IsNotZeroVector())  					toReturn.AddPolygon(fifthPoints);  				}
Magic Number,CityTrafficSimulator.Vehicle,Tram,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Tram.cs,BuildGraphicsPath,The following statement contains a magic number: if (_length == 250)  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized  									  };    				PointF[] frontPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] midPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] backPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				if (positions[0] != positions[1])  					toReturn.AddPolygon(frontPoints);  				if (positions[2] != positions[3])  					toReturn.AddPolygon(midPoints);  				if (positions[4] != positions[5])  					toReturn.AddPolygon(backPoints);  				}  			// 40-Meter-Zug  			else  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)'  					GetPositionAbsAtArcPos(currentPosition - 255)'  					GetPositionAbsAtArcPos(currentPosition - 300)'  					GetPositionAbsAtArcPos(currentPosition - 305)'  					GetPositionAbsAtArcPos(currentPosition - 400)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized'  					(positions[6] - positions[7]).RotatedClockwise.Normalized'  					(positions[7] - positions[9]).RotatedClockwise.Normalized  									  };    				PointF[] firstPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] secondPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] thirdPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				PointF[] forthPoints =   					{   					positions[6]  -  11*normals[3]'  					positions[6]  +  11*normals[3]'  					positions[7]  +  11*normals[3]'  					positions[7]  -  11*normals[3]'  					};    				PointF[] fifthPoints =   					{   					positions[8]  -  11*normals[4]'  					positions[8]  +  11*normals[4]'  					positions[9]  +  11*normals[4]'  					positions[9]  -  11*normals[4]'  					};    				if ((positions[0] - positions[1]).IsNotZeroVector())  					toReturn.AddPolygon(firstPoints);  				if ((positions[2] - positions[3]).IsNotZeroVector())  					toReturn.AddPolygon(secondPoints);  				if ((positions[4] - positions[5]).IsNotZeroVector())  					toReturn.AddPolygon(thirdPoints);  				if ((positions[6] - positions[7]).IsNotZeroVector())  					toReturn.AddPolygon(forthPoints);  				if ((positions[8] - positions[9]).IsNotZeroVector())  					toReturn.AddPolygon(fifthPoints);  				}
Magic Number,CityTrafficSimulator.Vehicle,Tram,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Tram.cs,BuildGraphicsPath,The following statement contains a magic number: if (_length == 250)  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized  									  };    				PointF[] frontPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] midPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] backPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				if (positions[0] != positions[1])  					toReturn.AddPolygon(frontPoints);  				if (positions[2] != positions[3])  					toReturn.AddPolygon(midPoints);  				if (positions[4] != positions[5])  					toReturn.AddPolygon(backPoints);  				}  			// 40-Meter-Zug  			else  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)'  					GetPositionAbsAtArcPos(currentPosition - 255)'  					GetPositionAbsAtArcPos(currentPosition - 300)'  					GetPositionAbsAtArcPos(currentPosition - 305)'  					GetPositionAbsAtArcPos(currentPosition - 400)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized'  					(positions[6] - positions[7]).RotatedClockwise.Normalized'  					(positions[7] - positions[9]).RotatedClockwise.Normalized  									  };    				PointF[] firstPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] secondPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] thirdPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				PointF[] forthPoints =   					{   					positions[6]  -  11*normals[3]'  					positions[6]  +  11*normals[3]'  					positions[7]  +  11*normals[3]'  					positions[7]  -  11*normals[3]'  					};    				PointF[] fifthPoints =   					{   					positions[8]  -  11*normals[4]'  					positions[8]  +  11*normals[4]'  					positions[9]  +  11*normals[4]'  					positions[9]  -  11*normals[4]'  					};    				if ((positions[0] - positions[1]).IsNotZeroVector())  					toReturn.AddPolygon(firstPoints);  				if ((positions[2] - positions[3]).IsNotZeroVector())  					toReturn.AddPolygon(secondPoints);  				if ((positions[4] - positions[5]).IsNotZeroVector())  					toReturn.AddPolygon(thirdPoints);  				if ((positions[6] - positions[7]).IsNotZeroVector())  					toReturn.AddPolygon(forthPoints);  				if ((positions[8] - positions[9]).IsNotZeroVector())  					toReturn.AddPolygon(fifthPoints);  				}
Magic Number,CityTrafficSimulator.Vehicle,Tram,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Tram.cs,BuildGraphicsPath,The following statement contains a magic number: if (_length == 250)  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized  									  };    				PointF[] frontPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] midPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] backPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				if (positions[0] != positions[1])  					toReturn.AddPolygon(frontPoints);  				if (positions[2] != positions[3])  					toReturn.AddPolygon(midPoints);  				if (positions[4] != positions[5])  					toReturn.AddPolygon(backPoints);  				}  			// 40-Meter-Zug  			else  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)'  					GetPositionAbsAtArcPos(currentPosition - 255)'  					GetPositionAbsAtArcPos(currentPosition - 300)'  					GetPositionAbsAtArcPos(currentPosition - 305)'  					GetPositionAbsAtArcPos(currentPosition - 400)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized'  					(positions[6] - positions[7]).RotatedClockwise.Normalized'  					(positions[7] - positions[9]).RotatedClockwise.Normalized  									  };    				PointF[] firstPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] secondPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] thirdPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				PointF[] forthPoints =   					{   					positions[6]  -  11*normals[3]'  					positions[6]  +  11*normals[3]'  					positions[7]  +  11*normals[3]'  					positions[7]  -  11*normals[3]'  					};    				PointF[] fifthPoints =   					{   					positions[8]  -  11*normals[4]'  					positions[8]  +  11*normals[4]'  					positions[9]  +  11*normals[4]'  					positions[9]  -  11*normals[4]'  					};    				if ((positions[0] - positions[1]).IsNotZeroVector())  					toReturn.AddPolygon(firstPoints);  				if ((positions[2] - positions[3]).IsNotZeroVector())  					toReturn.AddPolygon(secondPoints);  				if ((positions[4] - positions[5]).IsNotZeroVector())  					toReturn.AddPolygon(thirdPoints);  				if ((positions[6] - positions[7]).IsNotZeroVector())  					toReturn.AddPolygon(forthPoints);  				if ((positions[8] - positions[9]).IsNotZeroVector())  					toReturn.AddPolygon(fifthPoints);  				}
Magic Number,CityTrafficSimulator.Vehicle,Tram,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Tram.cs,BuildGraphicsPath,The following statement contains a magic number: if (_length == 250)  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized  									  };    				PointF[] frontPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] midPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] backPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				if (positions[0] != positions[1])  					toReturn.AddPolygon(frontPoints);  				if (positions[2] != positions[3])  					toReturn.AddPolygon(midPoints);  				if (positions[4] != positions[5])  					toReturn.AddPolygon(backPoints);  				}  			// 40-Meter-Zug  			else  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)'  					GetPositionAbsAtArcPos(currentPosition - 255)'  					GetPositionAbsAtArcPos(currentPosition - 300)'  					GetPositionAbsAtArcPos(currentPosition - 305)'  					GetPositionAbsAtArcPos(currentPosition - 400)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized'  					(positions[6] - positions[7]).RotatedClockwise.Normalized'  					(positions[7] - positions[9]).RotatedClockwise.Normalized  									  };    				PointF[] firstPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] secondPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] thirdPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				PointF[] forthPoints =   					{   					positions[6]  -  11*normals[3]'  					positions[6]  +  11*normals[3]'  					positions[7]  +  11*normals[3]'  					positions[7]  -  11*normals[3]'  					};    				PointF[] fifthPoints =   					{   					positions[8]  -  11*normals[4]'  					positions[8]  +  11*normals[4]'  					positions[9]  +  11*normals[4]'  					positions[9]  -  11*normals[4]'  					};    				if ((positions[0] - positions[1]).IsNotZeroVector())  					toReturn.AddPolygon(firstPoints);  				if ((positions[2] - positions[3]).IsNotZeroVector())  					toReturn.AddPolygon(secondPoints);  				if ((positions[4] - positions[5]).IsNotZeroVector())  					toReturn.AddPolygon(thirdPoints);  				if ((positions[6] - positions[7]).IsNotZeroVector())  					toReturn.AddPolygon(forthPoints);  				if ((positions[8] - positions[9]).IsNotZeroVector())  					toReturn.AddPolygon(fifthPoints);  				}
Magic Number,CityTrafficSimulator.Vehicle,Tram,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Tram.cs,BuildGraphicsPath,The following statement contains a magic number: if (_length == 250)  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized  									  };    				PointF[] frontPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] midPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] backPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				if (positions[0] != positions[1])  					toReturn.AddPolygon(frontPoints);  				if (positions[2] != positions[3])  					toReturn.AddPolygon(midPoints);  				if (positions[4] != positions[5])  					toReturn.AddPolygon(backPoints);  				}  			// 40-Meter-Zug  			else  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)'  					GetPositionAbsAtArcPos(currentPosition - 255)'  					GetPositionAbsAtArcPos(currentPosition - 300)'  					GetPositionAbsAtArcPos(currentPosition - 305)'  					GetPositionAbsAtArcPos(currentPosition - 400)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized'  					(positions[6] - positions[7]).RotatedClockwise.Normalized'  					(positions[7] - positions[9]).RotatedClockwise.Normalized  									  };    				PointF[] firstPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] secondPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] thirdPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				PointF[] forthPoints =   					{   					positions[6]  -  11*normals[3]'  					positions[6]  +  11*normals[3]'  					positions[7]  +  11*normals[3]'  					positions[7]  -  11*normals[3]'  					};    				PointF[] fifthPoints =   					{   					positions[8]  -  11*normals[4]'  					positions[8]  +  11*normals[4]'  					positions[9]  +  11*normals[4]'  					positions[9]  -  11*normals[4]'  					};    				if ((positions[0] - positions[1]).IsNotZeroVector())  					toReturn.AddPolygon(firstPoints);  				if ((positions[2] - positions[3]).IsNotZeroVector())  					toReturn.AddPolygon(secondPoints);  				if ((positions[4] - positions[5]).IsNotZeroVector())  					toReturn.AddPolygon(thirdPoints);  				if ((positions[6] - positions[7]).IsNotZeroVector())  					toReturn.AddPolygon(forthPoints);  				if ((positions[8] - positions[9]).IsNotZeroVector())  					toReturn.AddPolygon(fifthPoints);  				}
Magic Number,CityTrafficSimulator.Vehicle,Tram,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Tram.cs,BuildGraphicsPath,The following statement contains a magic number: if (_length == 250)  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized  									  };    				PointF[] frontPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] midPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] backPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				if (positions[0] != positions[1])  					toReturn.AddPolygon(frontPoints);  				if (positions[2] != positions[3])  					toReturn.AddPolygon(midPoints);  				if (positions[4] != positions[5])  					toReturn.AddPolygon(backPoints);  				}  			// 40-Meter-Zug  			else  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)'  					GetPositionAbsAtArcPos(currentPosition - 255)'  					GetPositionAbsAtArcPos(currentPosition - 300)'  					GetPositionAbsAtArcPos(currentPosition - 305)'  					GetPositionAbsAtArcPos(currentPosition - 400)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized'  					(positions[6] - positions[7]).RotatedClockwise.Normalized'  					(positions[7] - positions[9]).RotatedClockwise.Normalized  									  };    				PointF[] firstPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] secondPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] thirdPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				PointF[] forthPoints =   					{   					positions[6]  -  11*normals[3]'  					positions[6]  +  11*normals[3]'  					positions[7]  +  11*normals[3]'  					positions[7]  -  11*normals[3]'  					};    				PointF[] fifthPoints =   					{   					positions[8]  -  11*normals[4]'  					positions[8]  +  11*normals[4]'  					positions[9]  +  11*normals[4]'  					positions[9]  -  11*normals[4]'  					};    				if ((positions[0] - positions[1]).IsNotZeroVector())  					toReturn.AddPolygon(firstPoints);  				if ((positions[2] - positions[3]).IsNotZeroVector())  					toReturn.AddPolygon(secondPoints);  				if ((positions[4] - positions[5]).IsNotZeroVector())  					toReturn.AddPolygon(thirdPoints);  				if ((positions[6] - positions[7]).IsNotZeroVector())  					toReturn.AddPolygon(forthPoints);  				if ((positions[8] - positions[9]).IsNotZeroVector())  					toReturn.AddPolygon(fifthPoints);  				}
Magic Number,CityTrafficSimulator.Vehicle,Tram,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Tram.cs,BuildGraphicsPath,The following statement contains a magic number: if (_length == 250)  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized  									  };    				PointF[] frontPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] midPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] backPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				if (positions[0] != positions[1])  					toReturn.AddPolygon(frontPoints);  				if (positions[2] != positions[3])  					toReturn.AddPolygon(midPoints);  				if (positions[4] != positions[5])  					toReturn.AddPolygon(backPoints);  				}  			// 40-Meter-Zug  			else  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)'  					GetPositionAbsAtArcPos(currentPosition - 255)'  					GetPositionAbsAtArcPos(currentPosition - 300)'  					GetPositionAbsAtArcPos(currentPosition - 305)'  					GetPositionAbsAtArcPos(currentPosition - 400)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized'  					(positions[6] - positions[7]).RotatedClockwise.Normalized'  					(positions[7] - positions[9]).RotatedClockwise.Normalized  									  };    				PointF[] firstPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] secondPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] thirdPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				PointF[] forthPoints =   					{   					positions[6]  -  11*normals[3]'  					positions[6]  +  11*normals[3]'  					positions[7]  +  11*normals[3]'  					positions[7]  -  11*normals[3]'  					};    				PointF[] fifthPoints =   					{   					positions[8]  -  11*normals[4]'  					positions[8]  +  11*normals[4]'  					positions[9]  +  11*normals[4]'  					positions[9]  -  11*normals[4]'  					};    				if ((positions[0] - positions[1]).IsNotZeroVector())  					toReturn.AddPolygon(firstPoints);  				if ((positions[2] - positions[3]).IsNotZeroVector())  					toReturn.AddPolygon(secondPoints);  				if ((positions[4] - positions[5]).IsNotZeroVector())  					toReturn.AddPolygon(thirdPoints);  				if ((positions[6] - positions[7]).IsNotZeroVector())  					toReturn.AddPolygon(forthPoints);  				if ((positions[8] - positions[9]).IsNotZeroVector())  					toReturn.AddPolygon(fifthPoints);  				}
Magic Number,CityTrafficSimulator.Vehicle,Tram,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Tram.cs,BuildGraphicsPath,The following statement contains a magic number: if (_length == 250)  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized  									  };    				PointF[] frontPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] midPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] backPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				if (positions[0] != positions[1])  					toReturn.AddPolygon(frontPoints);  				if (positions[2] != positions[3])  					toReturn.AddPolygon(midPoints);  				if (positions[4] != positions[5])  					toReturn.AddPolygon(backPoints);  				}  			// 40-Meter-Zug  			else  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)'  					GetPositionAbsAtArcPos(currentPosition - 255)'  					GetPositionAbsAtArcPos(currentPosition - 300)'  					GetPositionAbsAtArcPos(currentPosition - 305)'  					GetPositionAbsAtArcPos(currentPosition - 400)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized'  					(positions[6] - positions[7]).RotatedClockwise.Normalized'  					(positions[7] - positions[9]).RotatedClockwise.Normalized  									  };    				PointF[] firstPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] secondPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] thirdPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				PointF[] forthPoints =   					{   					positions[6]  -  11*normals[3]'  					positions[6]  +  11*normals[3]'  					positions[7]  +  11*normals[3]'  					positions[7]  -  11*normals[3]'  					};    				PointF[] fifthPoints =   					{   					positions[8]  -  11*normals[4]'  					positions[8]  +  11*normals[4]'  					positions[9]  +  11*normals[4]'  					positions[9]  -  11*normals[4]'  					};    				if ((positions[0] - positions[1]).IsNotZeroVector())  					toReturn.AddPolygon(firstPoints);  				if ((positions[2] - positions[3]).IsNotZeroVector())  					toReturn.AddPolygon(secondPoints);  				if ((positions[4] - positions[5]).IsNotZeroVector())  					toReturn.AddPolygon(thirdPoints);  				if ((positions[6] - positions[7]).IsNotZeroVector())  					toReturn.AddPolygon(forthPoints);  				if ((positions[8] - positions[9]).IsNotZeroVector())  					toReturn.AddPolygon(fifthPoints);  				}
Magic Number,CityTrafficSimulator.Vehicle,Tram,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Tram.cs,BuildGraphicsPath,The following statement contains a magic number: if (_length == 250)  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized  									  };    				PointF[] frontPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] midPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] backPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				if (positions[0] != positions[1])  					toReturn.AddPolygon(frontPoints);  				if (positions[2] != positions[3])  					toReturn.AddPolygon(midPoints);  				if (positions[4] != positions[5])  					toReturn.AddPolygon(backPoints);  				}  			// 40-Meter-Zug  			else  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)'  					GetPositionAbsAtArcPos(currentPosition - 255)'  					GetPositionAbsAtArcPos(currentPosition - 300)'  					GetPositionAbsAtArcPos(currentPosition - 305)'  					GetPositionAbsAtArcPos(currentPosition - 400)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized'  					(positions[6] - positions[7]).RotatedClockwise.Normalized'  					(positions[7] - positions[9]).RotatedClockwise.Normalized  									  };    				PointF[] firstPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] secondPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] thirdPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				PointF[] forthPoints =   					{   					positions[6]  -  11*normals[3]'  					positions[6]  +  11*normals[3]'  					positions[7]  +  11*normals[3]'  					positions[7]  -  11*normals[3]'  					};    				PointF[] fifthPoints =   					{   					positions[8]  -  11*normals[4]'  					positions[8]  +  11*normals[4]'  					positions[9]  +  11*normals[4]'  					positions[9]  -  11*normals[4]'  					};    				if ((positions[0] - positions[1]).IsNotZeroVector())  					toReturn.AddPolygon(firstPoints);  				if ((positions[2] - positions[3]).IsNotZeroVector())  					toReturn.AddPolygon(secondPoints);  				if ((positions[4] - positions[5]).IsNotZeroVector())  					toReturn.AddPolygon(thirdPoints);  				if ((positions[6] - positions[7]).IsNotZeroVector())  					toReturn.AddPolygon(forthPoints);  				if ((positions[8] - positions[9]).IsNotZeroVector())  					toReturn.AddPolygon(fifthPoints);  				}
Magic Number,CityTrafficSimulator.Vehicle,Tram,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Tram.cs,BuildGraphicsPath,The following statement contains a magic number: if (_length == 250)  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized  									  };    				PointF[] frontPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] midPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] backPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				if (positions[0] != positions[1])  					toReturn.AddPolygon(frontPoints);  				if (positions[2] != positions[3])  					toReturn.AddPolygon(midPoints);  				if (positions[4] != positions[5])  					toReturn.AddPolygon(backPoints);  				}  			// 40-Meter-Zug  			else  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)'  					GetPositionAbsAtArcPos(currentPosition - 255)'  					GetPositionAbsAtArcPos(currentPosition - 300)'  					GetPositionAbsAtArcPos(currentPosition - 305)'  					GetPositionAbsAtArcPos(currentPosition - 400)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized'  					(positions[6] - positions[7]).RotatedClockwise.Normalized'  					(positions[7] - positions[9]).RotatedClockwise.Normalized  									  };    				PointF[] firstPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] secondPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] thirdPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				PointF[] forthPoints =   					{   					positions[6]  -  11*normals[3]'  					positions[6]  +  11*normals[3]'  					positions[7]  +  11*normals[3]'  					positions[7]  -  11*normals[3]'  					};    				PointF[] fifthPoints =   					{   					positions[8]  -  11*normals[4]'  					positions[8]  +  11*normals[4]'  					positions[9]  +  11*normals[4]'  					positions[9]  -  11*normals[4]'  					};    				if ((positions[0] - positions[1]).IsNotZeroVector())  					toReturn.AddPolygon(firstPoints);  				if ((positions[2] - positions[3]).IsNotZeroVector())  					toReturn.AddPolygon(secondPoints);  				if ((positions[4] - positions[5]).IsNotZeroVector())  					toReturn.AddPolygon(thirdPoints);  				if ((positions[6] - positions[7]).IsNotZeroVector())  					toReturn.AddPolygon(forthPoints);  				if ((positions[8] - positions[9]).IsNotZeroVector())  					toReturn.AddPolygon(fifthPoints);  				}
Magic Number,CityTrafficSimulator.Vehicle,Tram,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Tram.cs,BuildGraphicsPath,The following statement contains a magic number: if (_length == 250)  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized  									  };    				PointF[] frontPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] midPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] backPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				if (positions[0] != positions[1])  					toReturn.AddPolygon(frontPoints);  				if (positions[2] != positions[3])  					toReturn.AddPolygon(midPoints);  				if (positions[4] != positions[5])  					toReturn.AddPolygon(backPoints);  				}  			// 40-Meter-Zug  			else  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)'  					GetPositionAbsAtArcPos(currentPosition - 255)'  					GetPositionAbsAtArcPos(currentPosition - 300)'  					GetPositionAbsAtArcPos(currentPosition - 305)'  					GetPositionAbsAtArcPos(currentPosition - 400)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized'  					(positions[6] - positions[7]).RotatedClockwise.Normalized'  					(positions[7] - positions[9]).RotatedClockwise.Normalized  									  };    				PointF[] firstPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] secondPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] thirdPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				PointF[] forthPoints =   					{   					positions[6]  -  11*normals[3]'  					positions[6]  +  11*normals[3]'  					positions[7]  +  11*normals[3]'  					positions[7]  -  11*normals[3]'  					};    				PointF[] fifthPoints =   					{   					positions[8]  -  11*normals[4]'  					positions[8]  +  11*normals[4]'  					positions[9]  +  11*normals[4]'  					positions[9]  -  11*normals[4]'  					};    				if ((positions[0] - positions[1]).IsNotZeroVector())  					toReturn.AddPolygon(firstPoints);  				if ((positions[2] - positions[3]).IsNotZeroVector())  					toReturn.AddPolygon(secondPoints);  				if ((positions[4] - positions[5]).IsNotZeroVector())  					toReturn.AddPolygon(thirdPoints);  				if ((positions[6] - positions[7]).IsNotZeroVector())  					toReturn.AddPolygon(forthPoints);  				if ((positions[8] - positions[9]).IsNotZeroVector())  					toReturn.AddPolygon(fifthPoints);  				}
Magic Number,CityTrafficSimulator.Vehicle,Tram,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Tram.cs,BuildGraphicsPath,The following statement contains a magic number: if (_length == 250)  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized  									  };    				PointF[] frontPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] midPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] backPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				if (positions[0] != positions[1])  					toReturn.AddPolygon(frontPoints);  				if (positions[2] != positions[3])  					toReturn.AddPolygon(midPoints);  				if (positions[4] != positions[5])  					toReturn.AddPolygon(backPoints);  				}  			// 40-Meter-Zug  			else  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)'  					GetPositionAbsAtArcPos(currentPosition - 255)'  					GetPositionAbsAtArcPos(currentPosition - 300)'  					GetPositionAbsAtArcPos(currentPosition - 305)'  					GetPositionAbsAtArcPos(currentPosition - 400)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized'  					(positions[6] - positions[7]).RotatedClockwise.Normalized'  					(positions[7] - positions[9]).RotatedClockwise.Normalized  									  };    				PointF[] firstPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] secondPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] thirdPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				PointF[] forthPoints =   					{   					positions[6]  -  11*normals[3]'  					positions[6]  +  11*normals[3]'  					positions[7]  +  11*normals[3]'  					positions[7]  -  11*normals[3]'  					};    				PointF[] fifthPoints =   					{   					positions[8]  -  11*normals[4]'  					positions[8]  +  11*normals[4]'  					positions[9]  +  11*normals[4]'  					positions[9]  -  11*normals[4]'  					};    				if ((positions[0] - positions[1]).IsNotZeroVector())  					toReturn.AddPolygon(firstPoints);  				if ((positions[2] - positions[3]).IsNotZeroVector())  					toReturn.AddPolygon(secondPoints);  				if ((positions[4] - positions[5]).IsNotZeroVector())  					toReturn.AddPolygon(thirdPoints);  				if ((positions[6] - positions[7]).IsNotZeroVector())  					toReturn.AddPolygon(forthPoints);  				if ((positions[8] - positions[9]).IsNotZeroVector())  					toReturn.AddPolygon(fifthPoints);  				}
Magic Number,CityTrafficSimulator.Vehicle,Tram,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Tram.cs,BuildGraphicsPath,The following statement contains a magic number: if (_length == 250)  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized  									  };    				PointF[] frontPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] midPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] backPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				if (positions[0] != positions[1])  					toReturn.AddPolygon(frontPoints);  				if (positions[2] != positions[3])  					toReturn.AddPolygon(midPoints);  				if (positions[4] != positions[5])  					toReturn.AddPolygon(backPoints);  				}  			// 40-Meter-Zug  			else  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)'  					GetPositionAbsAtArcPos(currentPosition - 255)'  					GetPositionAbsAtArcPos(currentPosition - 300)'  					GetPositionAbsAtArcPos(currentPosition - 305)'  					GetPositionAbsAtArcPos(currentPosition - 400)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized'  					(positions[6] - positions[7]).RotatedClockwise.Normalized'  					(positions[7] - positions[9]).RotatedClockwise.Normalized  									  };    				PointF[] firstPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] secondPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] thirdPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				PointF[] forthPoints =   					{   					positions[6]  -  11*normals[3]'  					positions[6]  +  11*normals[3]'  					positions[7]  +  11*normals[3]'  					positions[7]  -  11*normals[3]'  					};    				PointF[] fifthPoints =   					{   					positions[8]  -  11*normals[4]'  					positions[8]  +  11*normals[4]'  					positions[9]  +  11*normals[4]'  					positions[9]  -  11*normals[4]'  					};    				if ((positions[0] - positions[1]).IsNotZeroVector())  					toReturn.AddPolygon(firstPoints);  				if ((positions[2] - positions[3]).IsNotZeroVector())  					toReturn.AddPolygon(secondPoints);  				if ((positions[4] - positions[5]).IsNotZeroVector())  					toReturn.AddPolygon(thirdPoints);  				if ((positions[6] - positions[7]).IsNotZeroVector())  					toReturn.AddPolygon(forthPoints);  				if ((positions[8] - positions[9]).IsNotZeroVector())  					toReturn.AddPolygon(fifthPoints);  				}
Magic Number,CityTrafficSimulator.Vehicle,Tram,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Tram.cs,BuildGraphicsPath,The following statement contains a magic number: if (_length == 250)  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized  									  };    				PointF[] frontPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] midPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] backPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				if (positions[0] != positions[1])  					toReturn.AddPolygon(frontPoints);  				if (positions[2] != positions[3])  					toReturn.AddPolygon(midPoints);  				if (positions[4] != positions[5])  					toReturn.AddPolygon(backPoints);  				}  			// 40-Meter-Zug  			else  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)'  					GetPositionAbsAtArcPos(currentPosition - 255)'  					GetPositionAbsAtArcPos(currentPosition - 300)'  					GetPositionAbsAtArcPos(currentPosition - 305)'  					GetPositionAbsAtArcPos(currentPosition - 400)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized'  					(positions[6] - positions[7]).RotatedClockwise.Normalized'  					(positions[7] - positions[9]).RotatedClockwise.Normalized  									  };    				PointF[] firstPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] secondPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] thirdPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				PointF[] forthPoints =   					{   					positions[6]  -  11*normals[3]'  					positions[6]  +  11*normals[3]'  					positions[7]  +  11*normals[3]'  					positions[7]  -  11*normals[3]'  					};    				PointF[] fifthPoints =   					{   					positions[8]  -  11*normals[4]'  					positions[8]  +  11*normals[4]'  					positions[9]  +  11*normals[4]'  					positions[9]  -  11*normals[4]'  					};    				if ((positions[0] - positions[1]).IsNotZeroVector())  					toReturn.AddPolygon(firstPoints);  				if ((positions[2] - positions[3]).IsNotZeroVector())  					toReturn.AddPolygon(secondPoints);  				if ((positions[4] - positions[5]).IsNotZeroVector())  					toReturn.AddPolygon(thirdPoints);  				if ((positions[6] - positions[7]).IsNotZeroVector())  					toReturn.AddPolygon(forthPoints);  				if ((positions[8] - positions[9]).IsNotZeroVector())  					toReturn.AddPolygon(fifthPoints);  				}
Magic Number,CityTrafficSimulator.Vehicle,Tram,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Tram.cs,BuildGraphicsPath,The following statement contains a magic number: if (_length == 250)  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized  									  };    				PointF[] frontPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] midPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] backPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				if (positions[0] != positions[1])  					toReturn.AddPolygon(frontPoints);  				if (positions[2] != positions[3])  					toReturn.AddPolygon(midPoints);  				if (positions[4] != positions[5])  					toReturn.AddPolygon(backPoints);  				}  			// 40-Meter-Zug  			else  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)'  					GetPositionAbsAtArcPos(currentPosition - 255)'  					GetPositionAbsAtArcPos(currentPosition - 300)'  					GetPositionAbsAtArcPos(currentPosition - 305)'  					GetPositionAbsAtArcPos(currentPosition - 400)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized'  					(positions[6] - positions[7]).RotatedClockwise.Normalized'  					(positions[7] - positions[9]).RotatedClockwise.Normalized  									  };    				PointF[] firstPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] secondPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] thirdPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				PointF[] forthPoints =   					{   					positions[6]  -  11*normals[3]'  					positions[6]  +  11*normals[3]'  					positions[7]  +  11*normals[3]'  					positions[7]  -  11*normals[3]'  					};    				PointF[] fifthPoints =   					{   					positions[8]  -  11*normals[4]'  					positions[8]  +  11*normals[4]'  					positions[9]  +  11*normals[4]'  					positions[9]  -  11*normals[4]'  					};    				if ((positions[0] - positions[1]).IsNotZeroVector())  					toReturn.AddPolygon(firstPoints);  				if ((positions[2] - positions[3]).IsNotZeroVector())  					toReturn.AddPolygon(secondPoints);  				if ((positions[4] - positions[5]).IsNotZeroVector())  					toReturn.AddPolygon(thirdPoints);  				if ((positions[6] - positions[7]).IsNotZeroVector())  					toReturn.AddPolygon(forthPoints);  				if ((positions[8] - positions[9]).IsNotZeroVector())  					toReturn.AddPolygon(fifthPoints);  				}
Magic Number,CityTrafficSimulator.Vehicle,Tram,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Tram.cs,BuildGraphicsPath,The following statement contains a magic number: if (_length == 250)  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized  									  };    				PointF[] frontPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] midPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] backPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				if (positions[0] != positions[1])  					toReturn.AddPolygon(frontPoints);  				if (positions[2] != positions[3])  					toReturn.AddPolygon(midPoints);  				if (positions[4] != positions[5])  					toReturn.AddPolygon(backPoints);  				}  			// 40-Meter-Zug  			else  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)'  					GetPositionAbsAtArcPos(currentPosition - 255)'  					GetPositionAbsAtArcPos(currentPosition - 300)'  					GetPositionAbsAtArcPos(currentPosition - 305)'  					GetPositionAbsAtArcPos(currentPosition - 400)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized'  					(positions[6] - positions[7]).RotatedClockwise.Normalized'  					(positions[7] - positions[9]).RotatedClockwise.Normalized  									  };    				PointF[] firstPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] secondPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] thirdPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				PointF[] forthPoints =   					{   					positions[6]  -  11*normals[3]'  					positions[6]  +  11*normals[3]'  					positions[7]  +  11*normals[3]'  					positions[7]  -  11*normals[3]'  					};    				PointF[] fifthPoints =   					{   					positions[8]  -  11*normals[4]'  					positions[8]  +  11*normals[4]'  					positions[9]  +  11*normals[4]'  					positions[9]  -  11*normals[4]'  					};    				if ((positions[0] - positions[1]).IsNotZeroVector())  					toReturn.AddPolygon(firstPoints);  				if ((positions[2] - positions[3]).IsNotZeroVector())  					toReturn.AddPolygon(secondPoints);  				if ((positions[4] - positions[5]).IsNotZeroVector())  					toReturn.AddPolygon(thirdPoints);  				if ((positions[6] - positions[7]).IsNotZeroVector())  					toReturn.AddPolygon(forthPoints);  				if ((positions[8] - positions[9]).IsNotZeroVector())  					toReturn.AddPolygon(fifthPoints);  				}
Magic Number,CityTrafficSimulator.Vehicle,Tram,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Tram.cs,BuildGraphicsPath,The following statement contains a magic number: if (_length == 250)  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized  									  };    				PointF[] frontPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] midPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] backPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				if (positions[0] != positions[1])  					toReturn.AddPolygon(frontPoints);  				if (positions[2] != positions[3])  					toReturn.AddPolygon(midPoints);  				if (positions[4] != positions[5])  					toReturn.AddPolygon(backPoints);  				}  			// 40-Meter-Zug  			else  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)'  					GetPositionAbsAtArcPos(currentPosition - 255)'  					GetPositionAbsAtArcPos(currentPosition - 300)'  					GetPositionAbsAtArcPos(currentPosition - 305)'  					GetPositionAbsAtArcPos(currentPosition - 400)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized'  					(positions[6] - positions[7]).RotatedClockwise.Normalized'  					(positions[7] - positions[9]).RotatedClockwise.Normalized  									  };    				PointF[] firstPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] secondPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] thirdPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				PointF[] forthPoints =   					{   					positions[6]  -  11*normals[3]'  					positions[6]  +  11*normals[3]'  					positions[7]  +  11*normals[3]'  					positions[7]  -  11*normals[3]'  					};    				PointF[] fifthPoints =   					{   					positions[8]  -  11*normals[4]'  					positions[8]  +  11*normals[4]'  					positions[9]  +  11*normals[4]'  					positions[9]  -  11*normals[4]'  					};    				if ((positions[0] - positions[1]).IsNotZeroVector())  					toReturn.AddPolygon(firstPoints);  				if ((positions[2] - positions[3]).IsNotZeroVector())  					toReturn.AddPolygon(secondPoints);  				if ((positions[4] - positions[5]).IsNotZeroVector())  					toReturn.AddPolygon(thirdPoints);  				if ((positions[6] - positions[7]).IsNotZeroVector())  					toReturn.AddPolygon(forthPoints);  				if ((positions[8] - positions[9]).IsNotZeroVector())  					toReturn.AddPolygon(fifthPoints);  				}
Magic Number,CityTrafficSimulator.Vehicle,Tram,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Tram.cs,BuildGraphicsPath,The following statement contains a magic number: if (_length == 250)  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized  									  };    				PointF[] frontPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] midPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] backPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				if (positions[0] != positions[1])  					toReturn.AddPolygon(frontPoints);  				if (positions[2] != positions[3])  					toReturn.AddPolygon(midPoints);  				if (positions[4] != positions[5])  					toReturn.AddPolygon(backPoints);  				}  			// 40-Meter-Zug  			else  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)'  					GetPositionAbsAtArcPos(currentPosition - 255)'  					GetPositionAbsAtArcPos(currentPosition - 300)'  					GetPositionAbsAtArcPos(currentPosition - 305)'  					GetPositionAbsAtArcPos(currentPosition - 400)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized'  					(positions[6] - positions[7]).RotatedClockwise.Normalized'  					(positions[7] - positions[9]).RotatedClockwise.Normalized  									  };    				PointF[] firstPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] secondPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] thirdPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				PointF[] forthPoints =   					{   					positions[6]  -  11*normals[3]'  					positions[6]  +  11*normals[3]'  					positions[7]  +  11*normals[3]'  					positions[7]  -  11*normals[3]'  					};    				PointF[] fifthPoints =   					{   					positions[8]  -  11*normals[4]'  					positions[8]  +  11*normals[4]'  					positions[9]  +  11*normals[4]'  					positions[9]  -  11*normals[4]'  					};    				if ((positions[0] - positions[1]).IsNotZeroVector())  					toReturn.AddPolygon(firstPoints);  				if ((positions[2] - positions[3]).IsNotZeroVector())  					toReturn.AddPolygon(secondPoints);  				if ((positions[4] - positions[5]).IsNotZeroVector())  					toReturn.AddPolygon(thirdPoints);  				if ((positions[6] - positions[7]).IsNotZeroVector())  					toReturn.AddPolygon(forthPoints);  				if ((positions[8] - positions[9]).IsNotZeroVector())  					toReturn.AddPolygon(fifthPoints);  				}
Magic Number,CityTrafficSimulator.Vehicle,Tram,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Tram.cs,BuildGraphicsPath,The following statement contains a magic number: if (_length == 250)  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized  									  };    				PointF[] frontPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] midPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] backPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				if (positions[0] != positions[1])  					toReturn.AddPolygon(frontPoints);  				if (positions[2] != positions[3])  					toReturn.AddPolygon(midPoints);  				if (positions[4] != positions[5])  					toReturn.AddPolygon(backPoints);  				}  			// 40-Meter-Zug  			else  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)'  					GetPositionAbsAtArcPos(currentPosition - 255)'  					GetPositionAbsAtArcPos(currentPosition - 300)'  					GetPositionAbsAtArcPos(currentPosition - 305)'  					GetPositionAbsAtArcPos(currentPosition - 400)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized'  					(positions[6] - positions[7]).RotatedClockwise.Normalized'  					(positions[7] - positions[9]).RotatedClockwise.Normalized  									  };    				PointF[] firstPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] secondPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] thirdPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				PointF[] forthPoints =   					{   					positions[6]  -  11*normals[3]'  					positions[6]  +  11*normals[3]'  					positions[7]  +  11*normals[3]'  					positions[7]  -  11*normals[3]'  					};    				PointF[] fifthPoints =   					{   					positions[8]  -  11*normals[4]'  					positions[8]  +  11*normals[4]'  					positions[9]  +  11*normals[4]'  					positions[9]  -  11*normals[4]'  					};    				if ((positions[0] - positions[1]).IsNotZeroVector())  					toReturn.AddPolygon(firstPoints);  				if ((positions[2] - positions[3]).IsNotZeroVector())  					toReturn.AddPolygon(secondPoints);  				if ((positions[4] - positions[5]).IsNotZeroVector())  					toReturn.AddPolygon(thirdPoints);  				if ((positions[6] - positions[7]).IsNotZeroVector())  					toReturn.AddPolygon(forthPoints);  				if ((positions[8] - positions[9]).IsNotZeroVector())  					toReturn.AddPolygon(fifthPoints);  				}
Magic Number,CityTrafficSimulator.Vehicle,Tram,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Tram.cs,BuildGraphicsPath,The following statement contains a magic number: if (_length == 250)  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized  									  };    				PointF[] frontPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] midPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] backPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				if (positions[0] != positions[1])  					toReturn.AddPolygon(frontPoints);  				if (positions[2] != positions[3])  					toReturn.AddPolygon(midPoints);  				if (positions[4] != positions[5])  					toReturn.AddPolygon(backPoints);  				}  			// 40-Meter-Zug  			else  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)'  					GetPositionAbsAtArcPos(currentPosition - 255)'  					GetPositionAbsAtArcPos(currentPosition - 300)'  					GetPositionAbsAtArcPos(currentPosition - 305)'  					GetPositionAbsAtArcPos(currentPosition - 400)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized'  					(positions[6] - positions[7]).RotatedClockwise.Normalized'  					(positions[7] - positions[9]).RotatedClockwise.Normalized  									  };    				PointF[] firstPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] secondPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] thirdPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				PointF[] forthPoints =   					{   					positions[6]  -  11*normals[3]'  					positions[6]  +  11*normals[3]'  					positions[7]  +  11*normals[3]'  					positions[7]  -  11*normals[3]'  					};    				PointF[] fifthPoints =   					{   					positions[8]  -  11*normals[4]'  					positions[8]  +  11*normals[4]'  					positions[9]  +  11*normals[4]'  					positions[9]  -  11*normals[4]'  					};    				if ((positions[0] - positions[1]).IsNotZeroVector())  					toReturn.AddPolygon(firstPoints);  				if ((positions[2] - positions[3]).IsNotZeroVector())  					toReturn.AddPolygon(secondPoints);  				if ((positions[4] - positions[5]).IsNotZeroVector())  					toReturn.AddPolygon(thirdPoints);  				if ((positions[6] - positions[7]).IsNotZeroVector())  					toReturn.AddPolygon(forthPoints);  				if ((positions[8] - positions[9]).IsNotZeroVector())  					toReturn.AddPolygon(fifthPoints);  				}
Magic Number,CityTrafficSimulator.Vehicle,Tram,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Tram.cs,BuildGraphicsPath,The following statement contains a magic number: if (_length == 250)  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized  									  };    				PointF[] frontPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] midPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] backPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				if (positions[0] != positions[1])  					toReturn.AddPolygon(frontPoints);  				if (positions[2] != positions[3])  					toReturn.AddPolygon(midPoints);  				if (positions[4] != positions[5])  					toReturn.AddPolygon(backPoints);  				}  			// 40-Meter-Zug  			else  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)'  					GetPositionAbsAtArcPos(currentPosition - 255)'  					GetPositionAbsAtArcPos(currentPosition - 300)'  					GetPositionAbsAtArcPos(currentPosition - 305)'  					GetPositionAbsAtArcPos(currentPosition - 400)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized'  					(positions[6] - positions[7]).RotatedClockwise.Normalized'  					(positions[7] - positions[9]).RotatedClockwise.Normalized  									  };    				PointF[] firstPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] secondPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] thirdPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				PointF[] forthPoints =   					{   					positions[6]  -  11*normals[3]'  					positions[6]  +  11*normals[3]'  					positions[7]  +  11*normals[3]'  					positions[7]  -  11*normals[3]'  					};    				PointF[] fifthPoints =   					{   					positions[8]  -  11*normals[4]'  					positions[8]  +  11*normals[4]'  					positions[9]  +  11*normals[4]'  					positions[9]  -  11*normals[4]'  					};    				if ((positions[0] - positions[1]).IsNotZeroVector())  					toReturn.AddPolygon(firstPoints);  				if ((positions[2] - positions[3]).IsNotZeroVector())  					toReturn.AddPolygon(secondPoints);  				if ((positions[4] - positions[5]).IsNotZeroVector())  					toReturn.AddPolygon(thirdPoints);  				if ((positions[6] - positions[7]).IsNotZeroVector())  					toReturn.AddPolygon(forthPoints);  				if ((positions[8] - positions[9]).IsNotZeroVector())  					toReturn.AddPolygon(fifthPoints);  				}
Magic Number,CityTrafficSimulator.Vehicle,Tram,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Tram.cs,BuildGraphicsPath,The following statement contains a magic number: if (_length == 250)  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized  									  };    				PointF[] frontPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] midPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] backPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				if (positions[0] != positions[1])  					toReturn.AddPolygon(frontPoints);  				if (positions[2] != positions[3])  					toReturn.AddPolygon(midPoints);  				if (positions[4] != positions[5])  					toReturn.AddPolygon(backPoints);  				}  			// 40-Meter-Zug  			else  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)'  					GetPositionAbsAtArcPos(currentPosition - 255)'  					GetPositionAbsAtArcPos(currentPosition - 300)'  					GetPositionAbsAtArcPos(currentPosition - 305)'  					GetPositionAbsAtArcPos(currentPosition - 400)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized'  					(positions[6] - positions[7]).RotatedClockwise.Normalized'  					(positions[7] - positions[9]).RotatedClockwise.Normalized  									  };    				PointF[] firstPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] secondPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] thirdPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				PointF[] forthPoints =   					{   					positions[6]  -  11*normals[3]'  					positions[6]  +  11*normals[3]'  					positions[7]  +  11*normals[3]'  					positions[7]  -  11*normals[3]'  					};    				PointF[] fifthPoints =   					{   					positions[8]  -  11*normals[4]'  					positions[8]  +  11*normals[4]'  					positions[9]  +  11*normals[4]'  					positions[9]  -  11*normals[4]'  					};    				if ((positions[0] - positions[1]).IsNotZeroVector())  					toReturn.AddPolygon(firstPoints);  				if ((positions[2] - positions[3]).IsNotZeroVector())  					toReturn.AddPolygon(secondPoints);  				if ((positions[4] - positions[5]).IsNotZeroVector())  					toReturn.AddPolygon(thirdPoints);  				if ((positions[6] - positions[7]).IsNotZeroVector())  					toReturn.AddPolygon(forthPoints);  				if ((positions[8] - positions[9]).IsNotZeroVector())  					toReturn.AddPolygon(fifthPoints);  				}
Magic Number,CityTrafficSimulator.Vehicle,Tram,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Tram.cs,BuildGraphicsPath,The following statement contains a magic number: if (_length == 250)  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized  									  };    				PointF[] frontPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] midPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] backPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				if (positions[0] != positions[1])  					toReturn.AddPolygon(frontPoints);  				if (positions[2] != positions[3])  					toReturn.AddPolygon(midPoints);  				if (positions[4] != positions[5])  					toReturn.AddPolygon(backPoints);  				}  			// 40-Meter-Zug  			else  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)'  					GetPositionAbsAtArcPos(currentPosition - 255)'  					GetPositionAbsAtArcPos(currentPosition - 300)'  					GetPositionAbsAtArcPos(currentPosition - 305)'  					GetPositionAbsAtArcPos(currentPosition - 400)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized'  					(positions[6] - positions[7]).RotatedClockwise.Normalized'  					(positions[7] - positions[9]).RotatedClockwise.Normalized  									  };    				PointF[] firstPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] secondPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] thirdPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				PointF[] forthPoints =   					{   					positions[6]  -  11*normals[3]'  					positions[6]  +  11*normals[3]'  					positions[7]  +  11*normals[3]'  					positions[7]  -  11*normals[3]'  					};    				PointF[] fifthPoints =   					{   					positions[8]  -  11*normals[4]'  					positions[8]  +  11*normals[4]'  					positions[9]  +  11*normals[4]'  					positions[9]  -  11*normals[4]'  					};    				if ((positions[0] - positions[1]).IsNotZeroVector())  					toReturn.AddPolygon(firstPoints);  				if ((positions[2] - positions[3]).IsNotZeroVector())  					toReturn.AddPolygon(secondPoints);  				if ((positions[4] - positions[5]).IsNotZeroVector())  					toReturn.AddPolygon(thirdPoints);  				if ((positions[6] - positions[7]).IsNotZeroVector())  					toReturn.AddPolygon(forthPoints);  				if ((positions[8] - positions[9]).IsNotZeroVector())  					toReturn.AddPolygon(fifthPoints);  				}
Magic Number,CityTrafficSimulator.Vehicle,Tram,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Tram.cs,BuildGraphicsPath,The following statement contains a magic number: if (_length == 250)  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized  									  };    				PointF[] frontPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] midPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] backPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				if (positions[0] != positions[1])  					toReturn.AddPolygon(frontPoints);  				if (positions[2] != positions[3])  					toReturn.AddPolygon(midPoints);  				if (positions[4] != positions[5])  					toReturn.AddPolygon(backPoints);  				}  			// 40-Meter-Zug  			else  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)'  					GetPositionAbsAtArcPos(currentPosition - 255)'  					GetPositionAbsAtArcPos(currentPosition - 300)'  					GetPositionAbsAtArcPos(currentPosition - 305)'  					GetPositionAbsAtArcPos(currentPosition - 400)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized'  					(positions[6] - positions[7]).RotatedClockwise.Normalized'  					(positions[7] - positions[9]).RotatedClockwise.Normalized  									  };    				PointF[] firstPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] secondPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] thirdPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				PointF[] forthPoints =   					{   					positions[6]  -  11*normals[3]'  					positions[6]  +  11*normals[3]'  					positions[7]  +  11*normals[3]'  					positions[7]  -  11*normals[3]'  					};    				PointF[] fifthPoints =   					{   					positions[8]  -  11*normals[4]'  					positions[8]  +  11*normals[4]'  					positions[9]  +  11*normals[4]'  					positions[9]  -  11*normals[4]'  					};    				if ((positions[0] - positions[1]).IsNotZeroVector())  					toReturn.AddPolygon(firstPoints);  				if ((positions[2] - positions[3]).IsNotZeroVector())  					toReturn.AddPolygon(secondPoints);  				if ((positions[4] - positions[5]).IsNotZeroVector())  					toReturn.AddPolygon(thirdPoints);  				if ((positions[6] - positions[7]).IsNotZeroVector())  					toReturn.AddPolygon(forthPoints);  				if ((positions[8] - positions[9]).IsNotZeroVector())  					toReturn.AddPolygon(fifthPoints);  				}
Magic Number,CityTrafficSimulator.Vehicle,Tram,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Tram.cs,BuildGraphicsPath,The following statement contains a magic number: if (_length == 250)  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized  									  };    				PointF[] frontPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] midPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] backPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				if (positions[0] != positions[1])  					toReturn.AddPolygon(frontPoints);  				if (positions[2] != positions[3])  					toReturn.AddPolygon(midPoints);  				if (positions[4] != positions[5])  					toReturn.AddPolygon(backPoints);  				}  			// 40-Meter-Zug  			else  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)'  					GetPositionAbsAtArcPos(currentPosition - 255)'  					GetPositionAbsAtArcPos(currentPosition - 300)'  					GetPositionAbsAtArcPos(currentPosition - 305)'  					GetPositionAbsAtArcPos(currentPosition - 400)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized'  					(positions[6] - positions[7]).RotatedClockwise.Normalized'  					(positions[7] - positions[9]).RotatedClockwise.Normalized  									  };    				PointF[] firstPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] secondPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] thirdPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				PointF[] forthPoints =   					{   					positions[6]  -  11*normals[3]'  					positions[6]  +  11*normals[3]'  					positions[7]  +  11*normals[3]'  					positions[7]  -  11*normals[3]'  					};    				PointF[] fifthPoints =   					{   					positions[8]  -  11*normals[4]'  					positions[8]  +  11*normals[4]'  					positions[9]  +  11*normals[4]'  					positions[9]  -  11*normals[4]'  					};    				if ((positions[0] - positions[1]).IsNotZeroVector())  					toReturn.AddPolygon(firstPoints);  				if ((positions[2] - positions[3]).IsNotZeroVector())  					toReturn.AddPolygon(secondPoints);  				if ((positions[4] - positions[5]).IsNotZeroVector())  					toReturn.AddPolygon(thirdPoints);  				if ((positions[6] - positions[7]).IsNotZeroVector())  					toReturn.AddPolygon(forthPoints);  				if ((positions[8] - positions[9]).IsNotZeroVector())  					toReturn.AddPolygon(fifthPoints);  				}
Magic Number,CityTrafficSimulator.Vehicle,Tram,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Tram.cs,BuildGraphicsPath,The following statement contains a magic number: if (_length == 250)  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized  									  };    				PointF[] frontPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] midPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] backPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				if (positions[0] != positions[1])  					toReturn.AddPolygon(frontPoints);  				if (positions[2] != positions[3])  					toReturn.AddPolygon(midPoints);  				if (positions[4] != positions[5])  					toReturn.AddPolygon(backPoints);  				}  			// 40-Meter-Zug  			else  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)'  					GetPositionAbsAtArcPos(currentPosition - 255)'  					GetPositionAbsAtArcPos(currentPosition - 300)'  					GetPositionAbsAtArcPos(currentPosition - 305)'  					GetPositionAbsAtArcPos(currentPosition - 400)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized'  					(positions[6] - positions[7]).RotatedClockwise.Normalized'  					(positions[7] - positions[9]).RotatedClockwise.Normalized  									  };    				PointF[] firstPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] secondPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] thirdPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				PointF[] forthPoints =   					{   					positions[6]  -  11*normals[3]'  					positions[6]  +  11*normals[3]'  					positions[7]  +  11*normals[3]'  					positions[7]  -  11*normals[3]'  					};    				PointF[] fifthPoints =   					{   					positions[8]  -  11*normals[4]'  					positions[8]  +  11*normals[4]'  					positions[9]  +  11*normals[4]'  					positions[9]  -  11*normals[4]'  					};    				if ((positions[0] - positions[1]).IsNotZeroVector())  					toReturn.AddPolygon(firstPoints);  				if ((positions[2] - positions[3]).IsNotZeroVector())  					toReturn.AddPolygon(secondPoints);  				if ((positions[4] - positions[5]).IsNotZeroVector())  					toReturn.AddPolygon(thirdPoints);  				if ((positions[6] - positions[7]).IsNotZeroVector())  					toReturn.AddPolygon(forthPoints);  				if ((positions[8] - positions[9]).IsNotZeroVector())  					toReturn.AddPolygon(fifthPoints);  				}
Magic Number,CityTrafficSimulator.Vehicle,Tram,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Tram.cs,BuildGraphicsPath,The following statement contains a magic number: if (_length == 250)  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized  									  };    				PointF[] frontPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] midPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] backPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				if (positions[0] != positions[1])  					toReturn.AddPolygon(frontPoints);  				if (positions[2] != positions[3])  					toReturn.AddPolygon(midPoints);  				if (positions[4] != positions[5])  					toReturn.AddPolygon(backPoints);  				}  			// 40-Meter-Zug  			else  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)'  					GetPositionAbsAtArcPos(currentPosition - 255)'  					GetPositionAbsAtArcPos(currentPosition - 300)'  					GetPositionAbsAtArcPos(currentPosition - 305)'  					GetPositionAbsAtArcPos(currentPosition - 400)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized'  					(positions[6] - positions[7]).RotatedClockwise.Normalized'  					(positions[7] - positions[9]).RotatedClockwise.Normalized  									  };    				PointF[] firstPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] secondPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] thirdPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				PointF[] forthPoints =   					{   					positions[6]  -  11*normals[3]'  					positions[6]  +  11*normals[3]'  					positions[7]  +  11*normals[3]'  					positions[7]  -  11*normals[3]'  					};    				PointF[] fifthPoints =   					{   					positions[8]  -  11*normals[4]'  					positions[8]  +  11*normals[4]'  					positions[9]  +  11*normals[4]'  					positions[9]  -  11*normals[4]'  					};    				if ((positions[0] - positions[1]).IsNotZeroVector())  					toReturn.AddPolygon(firstPoints);  				if ((positions[2] - positions[3]).IsNotZeroVector())  					toReturn.AddPolygon(secondPoints);  				if ((positions[4] - positions[5]).IsNotZeroVector())  					toReturn.AddPolygon(thirdPoints);  				if ((positions[6] - positions[7]).IsNotZeroVector())  					toReturn.AddPolygon(forthPoints);  				if ((positions[8] - positions[9]).IsNotZeroVector())  					toReturn.AddPolygon(fifthPoints);  				}
Magic Number,CityTrafficSimulator.Vehicle,Tram,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Tram.cs,BuildGraphicsPath,The following statement contains a magic number: if (_length == 250)  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized  									  };    				PointF[] frontPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] midPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] backPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				if (positions[0] != positions[1])  					toReturn.AddPolygon(frontPoints);  				if (positions[2] != positions[3])  					toReturn.AddPolygon(midPoints);  				if (positions[4] != positions[5])  					toReturn.AddPolygon(backPoints);  				}  			// 40-Meter-Zug  			else  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)'  					GetPositionAbsAtArcPos(currentPosition - 255)'  					GetPositionAbsAtArcPos(currentPosition - 300)'  					GetPositionAbsAtArcPos(currentPosition - 305)'  					GetPositionAbsAtArcPos(currentPosition - 400)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized'  					(positions[6] - positions[7]).RotatedClockwise.Normalized'  					(positions[7] - positions[9]).RotatedClockwise.Normalized  									  };    				PointF[] firstPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] secondPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] thirdPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				PointF[] forthPoints =   					{   					positions[6]  -  11*normals[3]'  					positions[6]  +  11*normals[3]'  					positions[7]  +  11*normals[3]'  					positions[7]  -  11*normals[3]'  					};    				PointF[] fifthPoints =   					{   					positions[8]  -  11*normals[4]'  					positions[8]  +  11*normals[4]'  					positions[9]  +  11*normals[4]'  					positions[9]  -  11*normals[4]'  					};    				if ((positions[0] - positions[1]).IsNotZeroVector())  					toReturn.AddPolygon(firstPoints);  				if ((positions[2] - positions[3]).IsNotZeroVector())  					toReturn.AddPolygon(secondPoints);  				if ((positions[4] - positions[5]).IsNotZeroVector())  					toReturn.AddPolygon(thirdPoints);  				if ((positions[6] - positions[7]).IsNotZeroVector())  					toReturn.AddPolygon(forthPoints);  				if ((positions[8] - positions[9]).IsNotZeroVector())  					toReturn.AddPolygon(fifthPoints);  				}
Magic Number,CityTrafficSimulator.Vehicle,Tram,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Tram.cs,BuildGraphicsPath,The following statement contains a magic number: if (_length == 250)  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized  									  };    				PointF[] frontPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] midPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] backPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				if (positions[0] != positions[1])  					toReturn.AddPolygon(frontPoints);  				if (positions[2] != positions[3])  					toReturn.AddPolygon(midPoints);  				if (positions[4] != positions[5])  					toReturn.AddPolygon(backPoints);  				}  			// 40-Meter-Zug  			else  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)'  					GetPositionAbsAtArcPos(currentPosition - 255)'  					GetPositionAbsAtArcPos(currentPosition - 300)'  					GetPositionAbsAtArcPos(currentPosition - 305)'  					GetPositionAbsAtArcPos(currentPosition - 400)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized'  					(positions[6] - positions[7]).RotatedClockwise.Normalized'  					(positions[7] - positions[9]).RotatedClockwise.Normalized  									  };    				PointF[] firstPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] secondPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] thirdPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				PointF[] forthPoints =   					{   					positions[6]  -  11*normals[3]'  					positions[6]  +  11*normals[3]'  					positions[7]  +  11*normals[3]'  					positions[7]  -  11*normals[3]'  					};    				PointF[] fifthPoints =   					{   					positions[8]  -  11*normals[4]'  					positions[8]  +  11*normals[4]'  					positions[9]  +  11*normals[4]'  					positions[9]  -  11*normals[4]'  					};    				if ((positions[0] - positions[1]).IsNotZeroVector())  					toReturn.AddPolygon(firstPoints);  				if ((positions[2] - positions[3]).IsNotZeroVector())  					toReturn.AddPolygon(secondPoints);  				if ((positions[4] - positions[5]).IsNotZeroVector())  					toReturn.AddPolygon(thirdPoints);  				if ((positions[6] - positions[7]).IsNotZeroVector())  					toReturn.AddPolygon(forthPoints);  				if ((positions[8] - positions[9]).IsNotZeroVector())  					toReturn.AddPolygon(fifthPoints);  				}
Magic Number,CityTrafficSimulator.Vehicle,Tram,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Tram.cs,BuildGraphicsPath,The following statement contains a magic number: if (_length == 250)  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized  									  };    				PointF[] frontPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] midPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] backPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				if (positions[0] != positions[1])  					toReturn.AddPolygon(frontPoints);  				if (positions[2] != positions[3])  					toReturn.AddPolygon(midPoints);  				if (positions[4] != positions[5])  					toReturn.AddPolygon(backPoints);  				}  			// 40-Meter-Zug  			else  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)'  					GetPositionAbsAtArcPos(currentPosition - 255)'  					GetPositionAbsAtArcPos(currentPosition - 300)'  					GetPositionAbsAtArcPos(currentPosition - 305)'  					GetPositionAbsAtArcPos(currentPosition - 400)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized'  					(positions[6] - positions[7]).RotatedClockwise.Normalized'  					(positions[7] - positions[9]).RotatedClockwise.Normalized  									  };    				PointF[] firstPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] secondPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] thirdPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				PointF[] forthPoints =   					{   					positions[6]  -  11*normals[3]'  					positions[6]  +  11*normals[3]'  					positions[7]  +  11*normals[3]'  					positions[7]  -  11*normals[3]'  					};    				PointF[] fifthPoints =   					{   					positions[8]  -  11*normals[4]'  					positions[8]  +  11*normals[4]'  					positions[9]  +  11*normals[4]'  					positions[9]  -  11*normals[4]'  					};    				if ((positions[0] - positions[1]).IsNotZeroVector())  					toReturn.AddPolygon(firstPoints);  				if ((positions[2] - positions[3]).IsNotZeroVector())  					toReturn.AddPolygon(secondPoints);  				if ((positions[4] - positions[5]).IsNotZeroVector())  					toReturn.AddPolygon(thirdPoints);  				if ((positions[6] - positions[7]).IsNotZeroVector())  					toReturn.AddPolygon(forthPoints);  				if ((positions[8] - positions[9]).IsNotZeroVector())  					toReturn.AddPolygon(fifthPoints);  				}
Magic Number,CityTrafficSimulator.Vehicle,Tram,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Tram.cs,BuildGraphicsPath,The following statement contains a magic number: if (_length == 250)  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized  									  };    				PointF[] frontPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] midPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] backPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				if (positions[0] != positions[1])  					toReturn.AddPolygon(frontPoints);  				if (positions[2] != positions[3])  					toReturn.AddPolygon(midPoints);  				if (positions[4] != positions[5])  					toReturn.AddPolygon(backPoints);  				}  			// 40-Meter-Zug  			else  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)'  					GetPositionAbsAtArcPos(currentPosition - 255)'  					GetPositionAbsAtArcPos(currentPosition - 300)'  					GetPositionAbsAtArcPos(currentPosition - 305)'  					GetPositionAbsAtArcPos(currentPosition - 400)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized'  					(positions[6] - positions[7]).RotatedClockwise.Normalized'  					(positions[7] - positions[9]).RotatedClockwise.Normalized  									  };    				PointF[] firstPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] secondPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] thirdPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				PointF[] forthPoints =   					{   					positions[6]  -  11*normals[3]'  					positions[6]  +  11*normals[3]'  					positions[7]  +  11*normals[3]'  					positions[7]  -  11*normals[3]'  					};    				PointF[] fifthPoints =   					{   					positions[8]  -  11*normals[4]'  					positions[8]  +  11*normals[4]'  					positions[9]  +  11*normals[4]'  					positions[9]  -  11*normals[4]'  					};    				if ((positions[0] - positions[1]).IsNotZeroVector())  					toReturn.AddPolygon(firstPoints);  				if ((positions[2] - positions[3]).IsNotZeroVector())  					toReturn.AddPolygon(secondPoints);  				if ((positions[4] - positions[5]).IsNotZeroVector())  					toReturn.AddPolygon(thirdPoints);  				if ((positions[6] - positions[7]).IsNotZeroVector())  					toReturn.AddPolygon(forthPoints);  				if ((positions[8] - positions[9]).IsNotZeroVector())  					toReturn.AddPolygon(fifthPoints);  				}
Magic Number,CityTrafficSimulator.Vehicle,Tram,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Tram.cs,BuildGraphicsPath,The following statement contains a magic number: if (_length == 250)  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized  									  };    				PointF[] frontPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] midPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] backPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				if (positions[0] != positions[1])  					toReturn.AddPolygon(frontPoints);  				if (positions[2] != positions[3])  					toReturn.AddPolygon(midPoints);  				if (positions[4] != positions[5])  					toReturn.AddPolygon(backPoints);  				}  			// 40-Meter-Zug  			else  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)'  					GetPositionAbsAtArcPos(currentPosition - 255)'  					GetPositionAbsAtArcPos(currentPosition - 300)'  					GetPositionAbsAtArcPos(currentPosition - 305)'  					GetPositionAbsAtArcPos(currentPosition - 400)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized'  					(positions[6] - positions[7]).RotatedClockwise.Normalized'  					(positions[7] - positions[9]).RotatedClockwise.Normalized  									  };    				PointF[] firstPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] secondPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] thirdPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				PointF[] forthPoints =   					{   					positions[6]  -  11*normals[3]'  					positions[6]  +  11*normals[3]'  					positions[7]  +  11*normals[3]'  					positions[7]  -  11*normals[3]'  					};    				PointF[] fifthPoints =   					{   					positions[8]  -  11*normals[4]'  					positions[8]  +  11*normals[4]'  					positions[9]  +  11*normals[4]'  					positions[9]  -  11*normals[4]'  					};    				if ((positions[0] - positions[1]).IsNotZeroVector())  					toReturn.AddPolygon(firstPoints);  				if ((positions[2] - positions[3]).IsNotZeroVector())  					toReturn.AddPolygon(secondPoints);  				if ((positions[4] - positions[5]).IsNotZeroVector())  					toReturn.AddPolygon(thirdPoints);  				if ((positions[6] - positions[7]).IsNotZeroVector())  					toReturn.AddPolygon(forthPoints);  				if ((positions[8] - positions[9]).IsNotZeroVector())  					toReturn.AddPolygon(fifthPoints);  				}
Magic Number,CityTrafficSimulator.Vehicle,Tram,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Tram.cs,BuildGraphicsPath,The following statement contains a magic number: if (_length == 250)  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized  									  };    				PointF[] frontPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] midPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] backPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				if (positions[0] != positions[1])  					toReturn.AddPolygon(frontPoints);  				if (positions[2] != positions[3])  					toReturn.AddPolygon(midPoints);  				if (positions[4] != positions[5])  					toReturn.AddPolygon(backPoints);  				}  			// 40-Meter-Zug  			else  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)'  					GetPositionAbsAtArcPos(currentPosition - 255)'  					GetPositionAbsAtArcPos(currentPosition - 300)'  					GetPositionAbsAtArcPos(currentPosition - 305)'  					GetPositionAbsAtArcPos(currentPosition - 400)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized'  					(positions[6] - positions[7]).RotatedClockwise.Normalized'  					(positions[7] - positions[9]).RotatedClockwise.Normalized  									  };    				PointF[] firstPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] secondPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] thirdPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				PointF[] forthPoints =   					{   					positions[6]  -  11*normals[3]'  					positions[6]  +  11*normals[3]'  					positions[7]  +  11*normals[3]'  					positions[7]  -  11*normals[3]'  					};    				PointF[] fifthPoints =   					{   					positions[8]  -  11*normals[4]'  					positions[8]  +  11*normals[4]'  					positions[9]  +  11*normals[4]'  					positions[9]  -  11*normals[4]'  					};    				if ((positions[0] - positions[1]).IsNotZeroVector())  					toReturn.AddPolygon(firstPoints);  				if ((positions[2] - positions[3]).IsNotZeroVector())  					toReturn.AddPolygon(secondPoints);  				if ((positions[4] - positions[5]).IsNotZeroVector())  					toReturn.AddPolygon(thirdPoints);  				if ((positions[6] - positions[7]).IsNotZeroVector())  					toReturn.AddPolygon(forthPoints);  				if ((positions[8] - positions[9]).IsNotZeroVector())  					toReturn.AddPolygon(fifthPoints);  				}
Magic Number,CityTrafficSimulator.Vehicle,Tram,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Tram.cs,BuildGraphicsPath,The following statement contains a magic number: if (_length == 250)  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized  									  };    				PointF[] frontPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] midPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] backPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				if (positions[0] != positions[1])  					toReturn.AddPolygon(frontPoints);  				if (positions[2] != positions[3])  					toReturn.AddPolygon(midPoints);  				if (positions[4] != positions[5])  					toReturn.AddPolygon(backPoints);  				}  			// 40-Meter-Zug  			else  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)'  					GetPositionAbsAtArcPos(currentPosition - 255)'  					GetPositionAbsAtArcPos(currentPosition - 300)'  					GetPositionAbsAtArcPos(currentPosition - 305)'  					GetPositionAbsAtArcPos(currentPosition - 400)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized'  					(positions[6] - positions[7]).RotatedClockwise.Normalized'  					(positions[7] - positions[9]).RotatedClockwise.Normalized  									  };    				PointF[] firstPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] secondPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] thirdPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				PointF[] forthPoints =   					{   					positions[6]  -  11*normals[3]'  					positions[6]  +  11*normals[3]'  					positions[7]  +  11*normals[3]'  					positions[7]  -  11*normals[3]'  					};    				PointF[] fifthPoints =   					{   					positions[8]  -  11*normals[4]'  					positions[8]  +  11*normals[4]'  					positions[9]  +  11*normals[4]'  					positions[9]  -  11*normals[4]'  					};    				if ((positions[0] - positions[1]).IsNotZeroVector())  					toReturn.AddPolygon(firstPoints);  				if ((positions[2] - positions[3]).IsNotZeroVector())  					toReturn.AddPolygon(secondPoints);  				if ((positions[4] - positions[5]).IsNotZeroVector())  					toReturn.AddPolygon(thirdPoints);  				if ((positions[6] - positions[7]).IsNotZeroVector())  					toReturn.AddPolygon(forthPoints);  				if ((positions[8] - positions[9]).IsNotZeroVector())  					toReturn.AddPolygon(fifthPoints);  				}
Magic Number,CityTrafficSimulator.Vehicle,Tram,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Tram.cs,BuildGraphicsPath,The following statement contains a magic number: if (_length == 250)  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized  									  };    				PointF[] frontPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] midPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] backPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				if (positions[0] != positions[1])  					toReturn.AddPolygon(frontPoints);  				if (positions[2] != positions[3])  					toReturn.AddPolygon(midPoints);  				if (positions[4] != positions[5])  					toReturn.AddPolygon(backPoints);  				}  			// 40-Meter-Zug  			else  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)'  					GetPositionAbsAtArcPos(currentPosition - 255)'  					GetPositionAbsAtArcPos(currentPosition - 300)'  					GetPositionAbsAtArcPos(currentPosition - 305)'  					GetPositionAbsAtArcPos(currentPosition - 400)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized'  					(positions[6] - positions[7]).RotatedClockwise.Normalized'  					(positions[7] - positions[9]).RotatedClockwise.Normalized  									  };    				PointF[] firstPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] secondPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] thirdPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				PointF[] forthPoints =   					{   					positions[6]  -  11*normals[3]'  					positions[6]  +  11*normals[3]'  					positions[7]  +  11*normals[3]'  					positions[7]  -  11*normals[3]'  					};    				PointF[] fifthPoints =   					{   					positions[8]  -  11*normals[4]'  					positions[8]  +  11*normals[4]'  					positions[9]  +  11*normals[4]'  					positions[9]  -  11*normals[4]'  					};    				if ((positions[0] - positions[1]).IsNotZeroVector())  					toReturn.AddPolygon(firstPoints);  				if ((positions[2] - positions[3]).IsNotZeroVector())  					toReturn.AddPolygon(secondPoints);  				if ((positions[4] - positions[5]).IsNotZeroVector())  					toReturn.AddPolygon(thirdPoints);  				if ((positions[6] - positions[7]).IsNotZeroVector())  					toReturn.AddPolygon(forthPoints);  				if ((positions[8] - positions[9]).IsNotZeroVector())  					toReturn.AddPolygon(fifthPoints);  				}
Magic Number,CityTrafficSimulator.Vehicle,Tram,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Tram.cs,BuildGraphicsPath,The following statement contains a magic number: if (_length == 250)  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized  									  };    				PointF[] frontPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] midPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] backPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				if (positions[0] != positions[1])  					toReturn.AddPolygon(frontPoints);  				if (positions[2] != positions[3])  					toReturn.AddPolygon(midPoints);  				if (positions[4] != positions[5])  					toReturn.AddPolygon(backPoints);  				}  			// 40-Meter-Zug  			else  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)'  					GetPositionAbsAtArcPos(currentPosition - 255)'  					GetPositionAbsAtArcPos(currentPosition - 300)'  					GetPositionAbsAtArcPos(currentPosition - 305)'  					GetPositionAbsAtArcPos(currentPosition - 400)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized'  					(positions[6] - positions[7]).RotatedClockwise.Normalized'  					(positions[7] - positions[9]).RotatedClockwise.Normalized  									  };    				PointF[] firstPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] secondPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] thirdPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				PointF[] forthPoints =   					{   					positions[6]  -  11*normals[3]'  					positions[6]  +  11*normals[3]'  					positions[7]  +  11*normals[3]'  					positions[7]  -  11*normals[3]'  					};    				PointF[] fifthPoints =   					{   					positions[8]  -  11*normals[4]'  					positions[8]  +  11*normals[4]'  					positions[9]  +  11*normals[4]'  					positions[9]  -  11*normals[4]'  					};    				if ((positions[0] - positions[1]).IsNotZeroVector())  					toReturn.AddPolygon(firstPoints);  				if ((positions[2] - positions[3]).IsNotZeroVector())  					toReturn.AddPolygon(secondPoints);  				if ((positions[4] - positions[5]).IsNotZeroVector())  					toReturn.AddPolygon(thirdPoints);  				if ((positions[6] - positions[7]).IsNotZeroVector())  					toReturn.AddPolygon(forthPoints);  				if ((positions[8] - positions[9]).IsNotZeroVector())  					toReturn.AddPolygon(fifthPoints);  				}
Magic Number,CityTrafficSimulator.Vehicle,Tram,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Tram.cs,BuildGraphicsPath,The following statement contains a magic number: if (_length == 250)  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized  									  };    				PointF[] frontPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] midPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] backPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				if (positions[0] != positions[1])  					toReturn.AddPolygon(frontPoints);  				if (positions[2] != positions[3])  					toReturn.AddPolygon(midPoints);  				if (positions[4] != positions[5])  					toReturn.AddPolygon(backPoints);  				}  			// 40-Meter-Zug  			else  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)'  					GetPositionAbsAtArcPos(currentPosition - 255)'  					GetPositionAbsAtArcPos(currentPosition - 300)'  					GetPositionAbsAtArcPos(currentPosition - 305)'  					GetPositionAbsAtArcPos(currentPosition - 400)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized'  					(positions[6] - positions[7]).RotatedClockwise.Normalized'  					(positions[7] - positions[9]).RotatedClockwise.Normalized  									  };    				PointF[] firstPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] secondPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] thirdPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				PointF[] forthPoints =   					{   					positions[6]  -  11*normals[3]'  					positions[6]  +  11*normals[3]'  					positions[7]  +  11*normals[3]'  					positions[7]  -  11*normals[3]'  					};    				PointF[] fifthPoints =   					{   					positions[8]  -  11*normals[4]'  					positions[8]  +  11*normals[4]'  					positions[9]  +  11*normals[4]'  					positions[9]  -  11*normals[4]'  					};    				if ((positions[0] - positions[1]).IsNotZeroVector())  					toReturn.AddPolygon(firstPoints);  				if ((positions[2] - positions[3]).IsNotZeroVector())  					toReturn.AddPolygon(secondPoints);  				if ((positions[4] - positions[5]).IsNotZeroVector())  					toReturn.AddPolygon(thirdPoints);  				if ((positions[6] - positions[7]).IsNotZeroVector())  					toReturn.AddPolygon(forthPoints);  				if ((positions[8] - positions[9]).IsNotZeroVector())  					toReturn.AddPolygon(fifthPoints);  				}
Magic Number,CityTrafficSimulator.Vehicle,Tram,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Tram.cs,BuildGraphicsPath,The following statement contains a magic number: if (_length == 250)  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized  									  };    				PointF[] frontPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] midPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] backPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				if (positions[0] != positions[1])  					toReturn.AddPolygon(frontPoints);  				if (positions[2] != positions[3])  					toReturn.AddPolygon(midPoints);  				if (positions[4] != positions[5])  					toReturn.AddPolygon(backPoints);  				}  			// 40-Meter-Zug  			else  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)'  					GetPositionAbsAtArcPos(currentPosition - 255)'  					GetPositionAbsAtArcPos(currentPosition - 300)'  					GetPositionAbsAtArcPos(currentPosition - 305)'  					GetPositionAbsAtArcPos(currentPosition - 400)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized'  					(positions[6] - positions[7]).RotatedClockwise.Normalized'  					(positions[7] - positions[9]).RotatedClockwise.Normalized  									  };    				PointF[] firstPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] secondPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] thirdPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				PointF[] forthPoints =   					{   					positions[6]  -  11*normals[3]'  					positions[6]  +  11*normals[3]'  					positions[7]  +  11*normals[3]'  					positions[7]  -  11*normals[3]'  					};    				PointF[] fifthPoints =   					{   					positions[8]  -  11*normals[4]'  					positions[8]  +  11*normals[4]'  					positions[9]  +  11*normals[4]'  					positions[9]  -  11*normals[4]'  					};    				if ((positions[0] - positions[1]).IsNotZeroVector())  					toReturn.AddPolygon(firstPoints);  				if ((positions[2] - positions[3]).IsNotZeroVector())  					toReturn.AddPolygon(secondPoints);  				if ((positions[4] - positions[5]).IsNotZeroVector())  					toReturn.AddPolygon(thirdPoints);  				if ((positions[6] - positions[7]).IsNotZeroVector())  					toReturn.AddPolygon(forthPoints);  				if ((positions[8] - positions[9]).IsNotZeroVector())  					toReturn.AddPolygon(fifthPoints);  				}
Magic Number,CityTrafficSimulator.Vehicle,Tram,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Tram.cs,BuildGraphicsPath,The following statement contains a magic number: if (_length == 250)  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized  									  };    				PointF[] frontPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] midPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] backPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				if (positions[0] != positions[1])  					toReturn.AddPolygon(frontPoints);  				if (positions[2] != positions[3])  					toReturn.AddPolygon(midPoints);  				if (positions[4] != positions[5])  					toReturn.AddPolygon(backPoints);  				}  			// 40-Meter-Zug  			else  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)'  					GetPositionAbsAtArcPos(currentPosition - 255)'  					GetPositionAbsAtArcPos(currentPosition - 300)'  					GetPositionAbsAtArcPos(currentPosition - 305)'  					GetPositionAbsAtArcPos(currentPosition - 400)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized'  					(positions[6] - positions[7]).RotatedClockwise.Normalized'  					(positions[7] - positions[9]).RotatedClockwise.Normalized  									  };    				PointF[] firstPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] secondPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] thirdPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				PointF[] forthPoints =   					{   					positions[6]  -  11*normals[3]'  					positions[6]  +  11*normals[3]'  					positions[7]  +  11*normals[3]'  					positions[7]  -  11*normals[3]'  					};    				PointF[] fifthPoints =   					{   					positions[8]  -  11*normals[4]'  					positions[8]  +  11*normals[4]'  					positions[9]  +  11*normals[4]'  					positions[9]  -  11*normals[4]'  					};    				if ((positions[0] - positions[1]).IsNotZeroVector())  					toReturn.AddPolygon(firstPoints);  				if ((positions[2] - positions[3]).IsNotZeroVector())  					toReturn.AddPolygon(secondPoints);  				if ((positions[4] - positions[5]).IsNotZeroVector())  					toReturn.AddPolygon(thirdPoints);  				if ((positions[6] - positions[7]).IsNotZeroVector())  					toReturn.AddPolygon(forthPoints);  				if ((positions[8] - positions[9]).IsNotZeroVector())  					toReturn.AddPolygon(fifthPoints);  				}
Magic Number,CityTrafficSimulator.Vehicle,Tram,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Tram.cs,BuildGraphicsPath,The following statement contains a magic number: if (_length == 250)  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized  									  };    				PointF[] frontPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] midPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] backPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				if (positions[0] != positions[1])  					toReturn.AddPolygon(frontPoints);  				if (positions[2] != positions[3])  					toReturn.AddPolygon(midPoints);  				if (positions[4] != positions[5])  					toReturn.AddPolygon(backPoints);  				}  			// 40-Meter-Zug  			else  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)'  					GetPositionAbsAtArcPos(currentPosition - 255)'  					GetPositionAbsAtArcPos(currentPosition - 300)'  					GetPositionAbsAtArcPos(currentPosition - 305)'  					GetPositionAbsAtArcPos(currentPosition - 400)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized'  					(positions[6] - positions[7]).RotatedClockwise.Normalized'  					(positions[7] - positions[9]).RotatedClockwise.Normalized  									  };    				PointF[] firstPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] secondPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] thirdPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				PointF[] forthPoints =   					{   					positions[6]  -  11*normals[3]'  					positions[6]  +  11*normals[3]'  					positions[7]  +  11*normals[3]'  					positions[7]  -  11*normals[3]'  					};    				PointF[] fifthPoints =   					{   					positions[8]  -  11*normals[4]'  					positions[8]  +  11*normals[4]'  					positions[9]  +  11*normals[4]'  					positions[9]  -  11*normals[4]'  					};    				if ((positions[0] - positions[1]).IsNotZeroVector())  					toReturn.AddPolygon(firstPoints);  				if ((positions[2] - positions[3]).IsNotZeroVector())  					toReturn.AddPolygon(secondPoints);  				if ((positions[4] - positions[5]).IsNotZeroVector())  					toReturn.AddPolygon(thirdPoints);  				if ((positions[6] - positions[7]).IsNotZeroVector())  					toReturn.AddPolygon(forthPoints);  				if ((positions[8] - positions[9]).IsNotZeroVector())  					toReturn.AddPolygon(fifthPoints);  				}
Magic Number,CityTrafficSimulator.Vehicle,Tram,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Tram.cs,BuildGraphicsPath,The following statement contains a magic number: if (_length == 250)  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized  									  };    				PointF[] frontPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] midPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] backPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				if (positions[0] != positions[1])  					toReturn.AddPolygon(frontPoints);  				if (positions[2] != positions[3])  					toReturn.AddPolygon(midPoints);  				if (positions[4] != positions[5])  					toReturn.AddPolygon(backPoints);  				}  			// 40-Meter-Zug  			else  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)'  					GetPositionAbsAtArcPos(currentPosition - 255)'  					GetPositionAbsAtArcPos(currentPosition - 300)'  					GetPositionAbsAtArcPos(currentPosition - 305)'  					GetPositionAbsAtArcPos(currentPosition - 400)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized'  					(positions[6] - positions[7]).RotatedClockwise.Normalized'  					(positions[7] - positions[9]).RotatedClockwise.Normalized  									  };    				PointF[] firstPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] secondPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] thirdPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				PointF[] forthPoints =   					{   					positions[6]  -  11*normals[3]'  					positions[6]  +  11*normals[3]'  					positions[7]  +  11*normals[3]'  					positions[7]  -  11*normals[3]'  					};    				PointF[] fifthPoints =   					{   					positions[8]  -  11*normals[4]'  					positions[8]  +  11*normals[4]'  					positions[9]  +  11*normals[4]'  					positions[9]  -  11*normals[4]'  					};    				if ((positions[0] - positions[1]).IsNotZeroVector())  					toReturn.AddPolygon(firstPoints);  				if ((positions[2] - positions[3]).IsNotZeroVector())  					toReturn.AddPolygon(secondPoints);  				if ((positions[4] - positions[5]).IsNotZeroVector())  					toReturn.AddPolygon(thirdPoints);  				if ((positions[6] - positions[7]).IsNotZeroVector())  					toReturn.AddPolygon(forthPoints);  				if ((positions[8] - positions[9]).IsNotZeroVector())  					toReturn.AddPolygon(fifthPoints);  				}
Magic Number,CityTrafficSimulator.Vehicle,Tram,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Tram.cs,BuildGraphicsPath,The following statement contains a magic number: if (_length == 250)  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized  									  };    				PointF[] frontPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] midPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] backPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				if (positions[0] != positions[1])  					toReturn.AddPolygon(frontPoints);  				if (positions[2] != positions[3])  					toReturn.AddPolygon(midPoints);  				if (positions[4] != positions[5])  					toReturn.AddPolygon(backPoints);  				}  			// 40-Meter-Zug  			else  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)'  					GetPositionAbsAtArcPos(currentPosition - 255)'  					GetPositionAbsAtArcPos(currentPosition - 300)'  					GetPositionAbsAtArcPos(currentPosition - 305)'  					GetPositionAbsAtArcPos(currentPosition - 400)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized'  					(positions[6] - positions[7]).RotatedClockwise.Normalized'  					(positions[7] - positions[9]).RotatedClockwise.Normalized  									  };    				PointF[] firstPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] secondPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] thirdPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				PointF[] forthPoints =   					{   					positions[6]  -  11*normals[3]'  					positions[6]  +  11*normals[3]'  					positions[7]  +  11*normals[3]'  					positions[7]  -  11*normals[3]'  					};    				PointF[] fifthPoints =   					{   					positions[8]  -  11*normals[4]'  					positions[8]  +  11*normals[4]'  					positions[9]  +  11*normals[4]'  					positions[9]  -  11*normals[4]'  					};    				if ((positions[0] - positions[1]).IsNotZeroVector())  					toReturn.AddPolygon(firstPoints);  				if ((positions[2] - positions[3]).IsNotZeroVector())  					toReturn.AddPolygon(secondPoints);  				if ((positions[4] - positions[5]).IsNotZeroVector())  					toReturn.AddPolygon(thirdPoints);  				if ((positions[6] - positions[7]).IsNotZeroVector())  					toReturn.AddPolygon(forthPoints);  				if ((positions[8] - positions[9]).IsNotZeroVector())  					toReturn.AddPolygon(fifthPoints);  				}
Magic Number,CityTrafficSimulator.Vehicle,Tram,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Tram.cs,BuildGraphicsPath,The following statement contains a magic number: if (_length == 250)  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized  									  };    				PointF[] frontPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] midPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] backPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				if (positions[0] != positions[1])  					toReturn.AddPolygon(frontPoints);  				if (positions[2] != positions[3])  					toReturn.AddPolygon(midPoints);  				if (positions[4] != positions[5])  					toReturn.AddPolygon(backPoints);  				}  			// 40-Meter-Zug  			else  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)'  					GetPositionAbsAtArcPos(currentPosition - 255)'  					GetPositionAbsAtArcPos(currentPosition - 300)'  					GetPositionAbsAtArcPos(currentPosition - 305)'  					GetPositionAbsAtArcPos(currentPosition - 400)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized'  					(positions[6] - positions[7]).RotatedClockwise.Normalized'  					(positions[7] - positions[9]).RotatedClockwise.Normalized  									  };    				PointF[] firstPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] secondPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] thirdPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				PointF[] forthPoints =   					{   					positions[6]  -  11*normals[3]'  					positions[6]  +  11*normals[3]'  					positions[7]  +  11*normals[3]'  					positions[7]  -  11*normals[3]'  					};    				PointF[] fifthPoints =   					{   					positions[8]  -  11*normals[4]'  					positions[8]  +  11*normals[4]'  					positions[9]  +  11*normals[4]'  					positions[9]  -  11*normals[4]'  					};    				if ((positions[0] - positions[1]).IsNotZeroVector())  					toReturn.AddPolygon(firstPoints);  				if ((positions[2] - positions[3]).IsNotZeroVector())  					toReturn.AddPolygon(secondPoints);  				if ((positions[4] - positions[5]).IsNotZeroVector())  					toReturn.AddPolygon(thirdPoints);  				if ((positions[6] - positions[7]).IsNotZeroVector())  					toReturn.AddPolygon(forthPoints);  				if ((positions[8] - positions[9]).IsNotZeroVector())  					toReturn.AddPolygon(fifthPoints);  				}
Magic Number,CityTrafficSimulator.Vehicle,Tram,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Tram.cs,BuildGraphicsPath,The following statement contains a magic number: if (_length == 250)  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized  									  };    				PointF[] frontPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] midPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] backPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				if (positions[0] != positions[1])  					toReturn.AddPolygon(frontPoints);  				if (positions[2] != positions[3])  					toReturn.AddPolygon(midPoints);  				if (positions[4] != positions[5])  					toReturn.AddPolygon(backPoints);  				}  			// 40-Meter-Zug  			else  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)'  					GetPositionAbsAtArcPos(currentPosition - 255)'  					GetPositionAbsAtArcPos(currentPosition - 300)'  					GetPositionAbsAtArcPos(currentPosition - 305)'  					GetPositionAbsAtArcPos(currentPosition - 400)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized'  					(positions[6] - positions[7]).RotatedClockwise.Normalized'  					(positions[7] - positions[9]).RotatedClockwise.Normalized  									  };    				PointF[] firstPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] secondPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] thirdPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				PointF[] forthPoints =   					{   					positions[6]  -  11*normals[3]'  					positions[6]  +  11*normals[3]'  					positions[7]  +  11*normals[3]'  					positions[7]  -  11*normals[3]'  					};    				PointF[] fifthPoints =   					{   					positions[8]  -  11*normals[4]'  					positions[8]  +  11*normals[4]'  					positions[9]  +  11*normals[4]'  					positions[9]  -  11*normals[4]'  					};    				if ((positions[0] - positions[1]).IsNotZeroVector())  					toReturn.AddPolygon(firstPoints);  				if ((positions[2] - positions[3]).IsNotZeroVector())  					toReturn.AddPolygon(secondPoints);  				if ((positions[4] - positions[5]).IsNotZeroVector())  					toReturn.AddPolygon(thirdPoints);  				if ((positions[6] - positions[7]).IsNotZeroVector())  					toReturn.AddPolygon(forthPoints);  				if ((positions[8] - positions[9]).IsNotZeroVector())  					toReturn.AddPolygon(fifthPoints);  				}
Magic Number,CityTrafficSimulator.Vehicle,Tram,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Tram.cs,BuildGraphicsPath,The following statement contains a magic number: if (_length == 250)  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized  									  };    				PointF[] frontPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] midPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] backPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				if (positions[0] != positions[1])  					toReturn.AddPolygon(frontPoints);  				if (positions[2] != positions[3])  					toReturn.AddPolygon(midPoints);  				if (positions[4] != positions[5])  					toReturn.AddPolygon(backPoints);  				}  			// 40-Meter-Zug  			else  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)'  					GetPositionAbsAtArcPos(currentPosition - 255)'  					GetPositionAbsAtArcPos(currentPosition - 300)'  					GetPositionAbsAtArcPos(currentPosition - 305)'  					GetPositionAbsAtArcPos(currentPosition - 400)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized'  					(positions[6] - positions[7]).RotatedClockwise.Normalized'  					(positions[7] - positions[9]).RotatedClockwise.Normalized  									  };    				PointF[] firstPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] secondPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] thirdPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				PointF[] forthPoints =   					{   					positions[6]  -  11*normals[3]'  					positions[6]  +  11*normals[3]'  					positions[7]  +  11*normals[3]'  					positions[7]  -  11*normals[3]'  					};    				PointF[] fifthPoints =   					{   					positions[8]  -  11*normals[4]'  					positions[8]  +  11*normals[4]'  					positions[9]  +  11*normals[4]'  					positions[9]  -  11*normals[4]'  					};    				if ((positions[0] - positions[1]).IsNotZeroVector())  					toReturn.AddPolygon(firstPoints);  				if ((positions[2] - positions[3]).IsNotZeroVector())  					toReturn.AddPolygon(secondPoints);  				if ((positions[4] - positions[5]).IsNotZeroVector())  					toReturn.AddPolygon(thirdPoints);  				if ((positions[6] - positions[7]).IsNotZeroVector())  					toReturn.AddPolygon(forthPoints);  				if ((positions[8] - positions[9]).IsNotZeroVector())  					toReturn.AddPolygon(fifthPoints);  				}
Magic Number,CityTrafficSimulator.Vehicle,Tram,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Tram.cs,BuildGraphicsPath,The following statement contains a magic number: if (_length == 250)  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized  									  };    				PointF[] frontPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] midPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] backPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				if (positions[0] != positions[1])  					toReturn.AddPolygon(frontPoints);  				if (positions[2] != positions[3])  					toReturn.AddPolygon(midPoints);  				if (positions[4] != positions[5])  					toReturn.AddPolygon(backPoints);  				}  			// 40-Meter-Zug  			else  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)'  					GetPositionAbsAtArcPos(currentPosition - 255)'  					GetPositionAbsAtArcPos(currentPosition - 300)'  					GetPositionAbsAtArcPos(currentPosition - 305)'  					GetPositionAbsAtArcPos(currentPosition - 400)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized'  					(positions[6] - positions[7]).RotatedClockwise.Normalized'  					(positions[7] - positions[9]).RotatedClockwise.Normalized  									  };    				PointF[] firstPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] secondPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] thirdPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				PointF[] forthPoints =   					{   					positions[6]  -  11*normals[3]'  					positions[6]  +  11*normals[3]'  					positions[7]  +  11*normals[3]'  					positions[7]  -  11*normals[3]'  					};    				PointF[] fifthPoints =   					{   					positions[8]  -  11*normals[4]'  					positions[8]  +  11*normals[4]'  					positions[9]  +  11*normals[4]'  					positions[9]  -  11*normals[4]'  					};    				if ((positions[0] - positions[1]).IsNotZeroVector())  					toReturn.AddPolygon(firstPoints);  				if ((positions[2] - positions[3]).IsNotZeroVector())  					toReturn.AddPolygon(secondPoints);  				if ((positions[4] - positions[5]).IsNotZeroVector())  					toReturn.AddPolygon(thirdPoints);  				if ((positions[6] - positions[7]).IsNotZeroVector())  					toReturn.AddPolygon(forthPoints);  				if ((positions[8] - positions[9]).IsNotZeroVector())  					toReturn.AddPolygon(fifthPoints);  				}
Magic Number,CityTrafficSimulator.Vehicle,Tram,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Tram.cs,BuildGraphicsPath,The following statement contains a magic number: if (_length == 250)  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized  									  };    				PointF[] frontPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] midPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] backPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				if (positions[0] != positions[1])  					toReturn.AddPolygon(frontPoints);  				if (positions[2] != positions[3])  					toReturn.AddPolygon(midPoints);  				if (positions[4] != positions[5])  					toReturn.AddPolygon(backPoints);  				}  			// 40-Meter-Zug  			else  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)'  					GetPositionAbsAtArcPos(currentPosition - 255)'  					GetPositionAbsAtArcPos(currentPosition - 300)'  					GetPositionAbsAtArcPos(currentPosition - 305)'  					GetPositionAbsAtArcPos(currentPosition - 400)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized'  					(positions[6] - positions[7]).RotatedClockwise.Normalized'  					(positions[7] - positions[9]).RotatedClockwise.Normalized  									  };    				PointF[] firstPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] secondPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] thirdPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				PointF[] forthPoints =   					{   					positions[6]  -  11*normals[3]'  					positions[6]  +  11*normals[3]'  					positions[7]  +  11*normals[3]'  					positions[7]  -  11*normals[3]'  					};    				PointF[] fifthPoints =   					{   					positions[8]  -  11*normals[4]'  					positions[8]  +  11*normals[4]'  					positions[9]  +  11*normals[4]'  					positions[9]  -  11*normals[4]'  					};    				if ((positions[0] - positions[1]).IsNotZeroVector())  					toReturn.AddPolygon(firstPoints);  				if ((positions[2] - positions[3]).IsNotZeroVector())  					toReturn.AddPolygon(secondPoints);  				if ((positions[4] - positions[5]).IsNotZeroVector())  					toReturn.AddPolygon(thirdPoints);  				if ((positions[6] - positions[7]).IsNotZeroVector())  					toReturn.AddPolygon(forthPoints);  				if ((positions[8] - positions[9]).IsNotZeroVector())  					toReturn.AddPolygon(fifthPoints);  				}
Magic Number,CityTrafficSimulator.Vehicle,Tram,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Tram.cs,BuildGraphicsPath,The following statement contains a magic number: if (_length == 250)  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized  									  };    				PointF[] frontPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] midPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] backPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				if (positions[0] != positions[1])  					toReturn.AddPolygon(frontPoints);  				if (positions[2] != positions[3])  					toReturn.AddPolygon(midPoints);  				if (positions[4] != positions[5])  					toReturn.AddPolygon(backPoints);  				}  			// 40-Meter-Zug  			else  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)'  					GetPositionAbsAtArcPos(currentPosition - 255)'  					GetPositionAbsAtArcPos(currentPosition - 300)'  					GetPositionAbsAtArcPos(currentPosition - 305)'  					GetPositionAbsAtArcPos(currentPosition - 400)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized'  					(positions[6] - positions[7]).RotatedClockwise.Normalized'  					(positions[7] - positions[9]).RotatedClockwise.Normalized  									  };    				PointF[] firstPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] secondPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] thirdPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				PointF[] forthPoints =   					{   					positions[6]  -  11*normals[3]'  					positions[6]  +  11*normals[3]'  					positions[7]  +  11*normals[3]'  					positions[7]  -  11*normals[3]'  					};    				PointF[] fifthPoints =   					{   					positions[8]  -  11*normals[4]'  					positions[8]  +  11*normals[4]'  					positions[9]  +  11*normals[4]'  					positions[9]  -  11*normals[4]'  					};    				if ((positions[0] - positions[1]).IsNotZeroVector())  					toReturn.AddPolygon(firstPoints);  				if ((positions[2] - positions[3]).IsNotZeroVector())  					toReturn.AddPolygon(secondPoints);  				if ((positions[4] - positions[5]).IsNotZeroVector())  					toReturn.AddPolygon(thirdPoints);  				if ((positions[6] - positions[7]).IsNotZeroVector())  					toReturn.AddPolygon(forthPoints);  				if ((positions[8] - positions[9]).IsNotZeroVector())  					toReturn.AddPolygon(fifthPoints);  				}
Magic Number,CityTrafficSimulator.Vehicle,Tram,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Tram.cs,BuildGraphicsPath,The following statement contains a magic number: if (_length == 250)  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized  									  };    				PointF[] frontPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] midPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] backPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				if (positions[0] != positions[1])  					toReturn.AddPolygon(frontPoints);  				if (positions[2] != positions[3])  					toReturn.AddPolygon(midPoints);  				if (positions[4] != positions[5])  					toReturn.AddPolygon(backPoints);  				}  			// 40-Meter-Zug  			else  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)'  					GetPositionAbsAtArcPos(currentPosition - 255)'  					GetPositionAbsAtArcPos(currentPosition - 300)'  					GetPositionAbsAtArcPos(currentPosition - 305)'  					GetPositionAbsAtArcPos(currentPosition - 400)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized'  					(positions[6] - positions[7]).RotatedClockwise.Normalized'  					(positions[7] - positions[9]).RotatedClockwise.Normalized  									  };    				PointF[] firstPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] secondPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] thirdPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				PointF[] forthPoints =   					{   					positions[6]  -  11*normals[3]'  					positions[6]  +  11*normals[3]'  					positions[7]  +  11*normals[3]'  					positions[7]  -  11*normals[3]'  					};    				PointF[] fifthPoints =   					{   					positions[8]  -  11*normals[4]'  					positions[8]  +  11*normals[4]'  					positions[9]  +  11*normals[4]'  					positions[9]  -  11*normals[4]'  					};    				if ((positions[0] - positions[1]).IsNotZeroVector())  					toReturn.AddPolygon(firstPoints);  				if ((positions[2] - positions[3]).IsNotZeroVector())  					toReturn.AddPolygon(secondPoints);  				if ((positions[4] - positions[5]).IsNotZeroVector())  					toReturn.AddPolygon(thirdPoints);  				if ((positions[6] - positions[7]).IsNotZeroVector())  					toReturn.AddPolygon(forthPoints);  				if ((positions[8] - positions[9]).IsNotZeroVector())  					toReturn.AddPolygon(fifthPoints);  				}
Magic Number,CityTrafficSimulator.Vehicle,Tram,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Tram.cs,BuildGraphicsPath,The following statement contains a magic number: if (_length == 250)  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized  									  };    				PointF[] frontPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] midPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] backPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				if (positions[0] != positions[1])  					toReturn.AddPolygon(frontPoints);  				if (positions[2] != positions[3])  					toReturn.AddPolygon(midPoints);  				if (positions[4] != positions[5])  					toReturn.AddPolygon(backPoints);  				}  			// 40-Meter-Zug  			else  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)'  					GetPositionAbsAtArcPos(currentPosition - 255)'  					GetPositionAbsAtArcPos(currentPosition - 300)'  					GetPositionAbsAtArcPos(currentPosition - 305)'  					GetPositionAbsAtArcPos(currentPosition - 400)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized'  					(positions[6] - positions[7]).RotatedClockwise.Normalized'  					(positions[7] - positions[9]).RotatedClockwise.Normalized  									  };    				PointF[] firstPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] secondPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] thirdPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				PointF[] forthPoints =   					{   					positions[6]  -  11*normals[3]'  					positions[6]  +  11*normals[3]'  					positions[7]  +  11*normals[3]'  					positions[7]  -  11*normals[3]'  					};    				PointF[] fifthPoints =   					{   					positions[8]  -  11*normals[4]'  					positions[8]  +  11*normals[4]'  					positions[9]  +  11*normals[4]'  					positions[9]  -  11*normals[4]'  					};    				if ((positions[0] - positions[1]).IsNotZeroVector())  					toReturn.AddPolygon(firstPoints);  				if ((positions[2] - positions[3]).IsNotZeroVector())  					toReturn.AddPolygon(secondPoints);  				if ((positions[4] - positions[5]).IsNotZeroVector())  					toReturn.AddPolygon(thirdPoints);  				if ((positions[6] - positions[7]).IsNotZeroVector())  					toReturn.AddPolygon(forthPoints);  				if ((positions[8] - positions[9]).IsNotZeroVector())  					toReturn.AddPolygon(fifthPoints);  				}
Magic Number,CityTrafficSimulator.Vehicle,Tram,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Tram.cs,BuildGraphicsPath,The following statement contains a magic number: if (_length == 250)  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized  									  };    				PointF[] frontPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] midPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] backPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				if (positions[0] != positions[1])  					toReturn.AddPolygon(frontPoints);  				if (positions[2] != positions[3])  					toReturn.AddPolygon(midPoints);  				if (positions[4] != positions[5])  					toReturn.AddPolygon(backPoints);  				}  			// 40-Meter-Zug  			else  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)'  					GetPositionAbsAtArcPos(currentPosition - 255)'  					GetPositionAbsAtArcPos(currentPosition - 300)'  					GetPositionAbsAtArcPos(currentPosition - 305)'  					GetPositionAbsAtArcPos(currentPosition - 400)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized'  					(positions[6] - positions[7]).RotatedClockwise.Normalized'  					(positions[7] - positions[9]).RotatedClockwise.Normalized  									  };    				PointF[] firstPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] secondPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] thirdPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				PointF[] forthPoints =   					{   					positions[6]  -  11*normals[3]'  					positions[6]  +  11*normals[3]'  					positions[7]  +  11*normals[3]'  					positions[7]  -  11*normals[3]'  					};    				PointF[] fifthPoints =   					{   					positions[8]  -  11*normals[4]'  					positions[8]  +  11*normals[4]'  					positions[9]  +  11*normals[4]'  					positions[9]  -  11*normals[4]'  					};    				if ((positions[0] - positions[1]).IsNotZeroVector())  					toReturn.AddPolygon(firstPoints);  				if ((positions[2] - positions[3]).IsNotZeroVector())  					toReturn.AddPolygon(secondPoints);  				if ((positions[4] - positions[5]).IsNotZeroVector())  					toReturn.AddPolygon(thirdPoints);  				if ((positions[6] - positions[7]).IsNotZeroVector())  					toReturn.AddPolygon(forthPoints);  				if ((positions[8] - positions[9]).IsNotZeroVector())  					toReturn.AddPolygon(fifthPoints);  				}
Magic Number,CityTrafficSimulator.Vehicle,Tram,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Tram.cs,BuildGraphicsPath,The following statement contains a magic number: if (_length == 250)  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized  									  };    				PointF[] frontPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] midPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] backPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				if (positions[0] != positions[1])  					toReturn.AddPolygon(frontPoints);  				if (positions[2] != positions[3])  					toReturn.AddPolygon(midPoints);  				if (positions[4] != positions[5])  					toReturn.AddPolygon(backPoints);  				}  			// 40-Meter-Zug  			else  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)'  					GetPositionAbsAtArcPos(currentPosition - 255)'  					GetPositionAbsAtArcPos(currentPosition - 300)'  					GetPositionAbsAtArcPos(currentPosition - 305)'  					GetPositionAbsAtArcPos(currentPosition - 400)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized'  					(positions[6] - positions[7]).RotatedClockwise.Normalized'  					(positions[7] - positions[9]).RotatedClockwise.Normalized  									  };    				PointF[] firstPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] secondPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] thirdPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				PointF[] forthPoints =   					{   					positions[6]  -  11*normals[3]'  					positions[6]  +  11*normals[3]'  					positions[7]  +  11*normals[3]'  					positions[7]  -  11*normals[3]'  					};    				PointF[] fifthPoints =   					{   					positions[8]  -  11*normals[4]'  					positions[8]  +  11*normals[4]'  					positions[9]  +  11*normals[4]'  					positions[9]  -  11*normals[4]'  					};    				if ((positions[0] - positions[1]).IsNotZeroVector())  					toReturn.AddPolygon(firstPoints);  				if ((positions[2] - positions[3]).IsNotZeroVector())  					toReturn.AddPolygon(secondPoints);  				if ((positions[4] - positions[5]).IsNotZeroVector())  					toReturn.AddPolygon(thirdPoints);  				if ((positions[6] - positions[7]).IsNotZeroVector())  					toReturn.AddPolygon(forthPoints);  				if ((positions[8] - positions[9]).IsNotZeroVector())  					toReturn.AddPolygon(fifthPoints);  				}
Magic Number,CityTrafficSimulator.Vehicle,Tram,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Tram.cs,BuildGraphicsPath,The following statement contains a magic number: if (_length == 250)  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized  									  };    				PointF[] frontPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] midPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] backPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				if (positions[0] != positions[1])  					toReturn.AddPolygon(frontPoints);  				if (positions[2] != positions[3])  					toReturn.AddPolygon(midPoints);  				if (positions[4] != positions[5])  					toReturn.AddPolygon(backPoints);  				}  			// 40-Meter-Zug  			else  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)'  					GetPositionAbsAtArcPos(currentPosition - 255)'  					GetPositionAbsAtArcPos(currentPosition - 300)'  					GetPositionAbsAtArcPos(currentPosition - 305)'  					GetPositionAbsAtArcPos(currentPosition - 400)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized'  					(positions[6] - positions[7]).RotatedClockwise.Normalized'  					(positions[7] - positions[9]).RotatedClockwise.Normalized  									  };    				PointF[] firstPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] secondPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] thirdPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				PointF[] forthPoints =   					{   					positions[6]  -  11*normals[3]'  					positions[6]  +  11*normals[3]'  					positions[7]  +  11*normals[3]'  					positions[7]  -  11*normals[3]'  					};    				PointF[] fifthPoints =   					{   					positions[8]  -  11*normals[4]'  					positions[8]  +  11*normals[4]'  					positions[9]  +  11*normals[4]'  					positions[9]  -  11*normals[4]'  					};    				if ((positions[0] - positions[1]).IsNotZeroVector())  					toReturn.AddPolygon(firstPoints);  				if ((positions[2] - positions[3]).IsNotZeroVector())  					toReturn.AddPolygon(secondPoints);  				if ((positions[4] - positions[5]).IsNotZeroVector())  					toReturn.AddPolygon(thirdPoints);  				if ((positions[6] - positions[7]).IsNotZeroVector())  					toReturn.AddPolygon(forthPoints);  				if ((positions[8] - positions[9]).IsNotZeroVector())  					toReturn.AddPolygon(fifthPoints);  				}
Magic Number,CityTrafficSimulator.Vehicle,Tram,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Tram.cs,BuildGraphicsPath,The following statement contains a magic number: if (_length == 250)  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized  									  };    				PointF[] frontPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] midPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] backPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				if (positions[0] != positions[1])  					toReturn.AddPolygon(frontPoints);  				if (positions[2] != positions[3])  					toReturn.AddPolygon(midPoints);  				if (positions[4] != positions[5])  					toReturn.AddPolygon(backPoints);  				}  			// 40-Meter-Zug  			else  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)'  					GetPositionAbsAtArcPos(currentPosition - 255)'  					GetPositionAbsAtArcPos(currentPosition - 300)'  					GetPositionAbsAtArcPos(currentPosition - 305)'  					GetPositionAbsAtArcPos(currentPosition - 400)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized'  					(positions[6] - positions[7]).RotatedClockwise.Normalized'  					(positions[7] - positions[9]).RotatedClockwise.Normalized  									  };    				PointF[] firstPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] secondPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] thirdPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				PointF[] forthPoints =   					{   					positions[6]  -  11*normals[3]'  					positions[6]  +  11*normals[3]'  					positions[7]  +  11*normals[3]'  					positions[7]  -  11*normals[3]'  					};    				PointF[] fifthPoints =   					{   					positions[8]  -  11*normals[4]'  					positions[8]  +  11*normals[4]'  					positions[9]  +  11*normals[4]'  					positions[9]  -  11*normals[4]'  					};    				if ((positions[0] - positions[1]).IsNotZeroVector())  					toReturn.AddPolygon(firstPoints);  				if ((positions[2] - positions[3]).IsNotZeroVector())  					toReturn.AddPolygon(secondPoints);  				if ((positions[4] - positions[5]).IsNotZeroVector())  					toReturn.AddPolygon(thirdPoints);  				if ((positions[6] - positions[7]).IsNotZeroVector())  					toReturn.AddPolygon(forthPoints);  				if ((positions[8] - positions[9]).IsNotZeroVector())  					toReturn.AddPolygon(fifthPoints);  				}
Magic Number,CityTrafficSimulator.Vehicle,Tram,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Tram.cs,BuildGraphicsPath,The following statement contains a magic number: if (_length == 250)  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized  									  };    				PointF[] frontPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] midPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] backPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				if (positions[0] != positions[1])  					toReturn.AddPolygon(frontPoints);  				if (positions[2] != positions[3])  					toReturn.AddPolygon(midPoints);  				if (positions[4] != positions[5])  					toReturn.AddPolygon(backPoints);  				}  			// 40-Meter-Zug  			else  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)'  					GetPositionAbsAtArcPos(currentPosition - 255)'  					GetPositionAbsAtArcPos(currentPosition - 300)'  					GetPositionAbsAtArcPos(currentPosition - 305)'  					GetPositionAbsAtArcPos(currentPosition - 400)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized'  					(positions[6] - positions[7]).RotatedClockwise.Normalized'  					(positions[7] - positions[9]).RotatedClockwise.Normalized  									  };    				PointF[] firstPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] secondPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] thirdPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				PointF[] forthPoints =   					{   					positions[6]  -  11*normals[3]'  					positions[6]  +  11*normals[3]'  					positions[7]  +  11*normals[3]'  					positions[7]  -  11*normals[3]'  					};    				PointF[] fifthPoints =   					{   					positions[8]  -  11*normals[4]'  					positions[8]  +  11*normals[4]'  					positions[9]  +  11*normals[4]'  					positions[9]  -  11*normals[4]'  					};    				if ((positions[0] - positions[1]).IsNotZeroVector())  					toReturn.AddPolygon(firstPoints);  				if ((positions[2] - positions[3]).IsNotZeroVector())  					toReturn.AddPolygon(secondPoints);  				if ((positions[4] - positions[5]).IsNotZeroVector())  					toReturn.AddPolygon(thirdPoints);  				if ((positions[6] - positions[7]).IsNotZeroVector())  					toReturn.AddPolygon(forthPoints);  				if ((positions[8] - positions[9]).IsNotZeroVector())  					toReturn.AddPolygon(fifthPoints);  				}
Magic Number,CityTrafficSimulator.Vehicle,Tram,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Tram.cs,BuildGraphicsPath,The following statement contains a magic number: if (_length == 250)  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized  									  };    				PointF[] frontPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] midPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] backPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				if (positions[0] != positions[1])  					toReturn.AddPolygon(frontPoints);  				if (positions[2] != positions[3])  					toReturn.AddPolygon(midPoints);  				if (positions[4] != positions[5])  					toReturn.AddPolygon(backPoints);  				}  			// 40-Meter-Zug  			else  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)'  					GetPositionAbsAtArcPos(currentPosition - 255)'  					GetPositionAbsAtArcPos(currentPosition - 300)'  					GetPositionAbsAtArcPos(currentPosition - 305)'  					GetPositionAbsAtArcPos(currentPosition - 400)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized'  					(positions[6] - positions[7]).RotatedClockwise.Normalized'  					(positions[7] - positions[9]).RotatedClockwise.Normalized  									  };    				PointF[] firstPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] secondPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] thirdPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				PointF[] forthPoints =   					{   					positions[6]  -  11*normals[3]'  					positions[6]  +  11*normals[3]'  					positions[7]  +  11*normals[3]'  					positions[7]  -  11*normals[3]'  					};    				PointF[] fifthPoints =   					{   					positions[8]  -  11*normals[4]'  					positions[8]  +  11*normals[4]'  					positions[9]  +  11*normals[4]'  					positions[9]  -  11*normals[4]'  					};    				if ((positions[0] - positions[1]).IsNotZeroVector())  					toReturn.AddPolygon(firstPoints);  				if ((positions[2] - positions[3]).IsNotZeroVector())  					toReturn.AddPolygon(secondPoints);  				if ((positions[4] - positions[5]).IsNotZeroVector())  					toReturn.AddPolygon(thirdPoints);  				if ((positions[6] - positions[7]).IsNotZeroVector())  					toReturn.AddPolygon(forthPoints);  				if ((positions[8] - positions[9]).IsNotZeroVector())  					toReturn.AddPolygon(fifthPoints);  				}
Magic Number,CityTrafficSimulator.Vehicle,Tram,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Tram.cs,BuildGraphicsPath,The following statement contains a magic number: if (_length == 250)  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized  									  };    				PointF[] frontPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] midPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] backPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				if (positions[0] != positions[1])  					toReturn.AddPolygon(frontPoints);  				if (positions[2] != positions[3])  					toReturn.AddPolygon(midPoints);  				if (positions[4] != positions[5])  					toReturn.AddPolygon(backPoints);  				}  			// 40-Meter-Zug  			else  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)'  					GetPositionAbsAtArcPos(currentPosition - 255)'  					GetPositionAbsAtArcPos(currentPosition - 300)'  					GetPositionAbsAtArcPos(currentPosition - 305)'  					GetPositionAbsAtArcPos(currentPosition - 400)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized'  					(positions[6] - positions[7]).RotatedClockwise.Normalized'  					(positions[7] - positions[9]).RotatedClockwise.Normalized  									  };    				PointF[] firstPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] secondPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] thirdPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				PointF[] forthPoints =   					{   					positions[6]  -  11*normals[3]'  					positions[6]  +  11*normals[3]'  					positions[7]  +  11*normals[3]'  					positions[7]  -  11*normals[3]'  					};    				PointF[] fifthPoints =   					{   					positions[8]  -  11*normals[4]'  					positions[8]  +  11*normals[4]'  					positions[9]  +  11*normals[4]'  					positions[9]  -  11*normals[4]'  					};    				if ((positions[0] - positions[1]).IsNotZeroVector())  					toReturn.AddPolygon(firstPoints);  				if ((positions[2] - positions[3]).IsNotZeroVector())  					toReturn.AddPolygon(secondPoints);  				if ((positions[4] - positions[5]).IsNotZeroVector())  					toReturn.AddPolygon(thirdPoints);  				if ((positions[6] - positions[7]).IsNotZeroVector())  					toReturn.AddPolygon(forthPoints);  				if ((positions[8] - positions[9]).IsNotZeroVector())  					toReturn.AddPolygon(fifthPoints);  				}
Magic Number,CityTrafficSimulator.Vehicle,Tram,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Tram.cs,BuildGraphicsPath,The following statement contains a magic number: if (_length == 250)  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized  									  };    				PointF[] frontPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] midPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] backPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				if (positions[0] != positions[1])  					toReturn.AddPolygon(frontPoints);  				if (positions[2] != positions[3])  					toReturn.AddPolygon(midPoints);  				if (positions[4] != positions[5])  					toReturn.AddPolygon(backPoints);  				}  			// 40-Meter-Zug  			else  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)'  					GetPositionAbsAtArcPos(currentPosition - 255)'  					GetPositionAbsAtArcPos(currentPosition - 300)'  					GetPositionAbsAtArcPos(currentPosition - 305)'  					GetPositionAbsAtArcPos(currentPosition - 400)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized'  					(positions[6] - positions[7]).RotatedClockwise.Normalized'  					(positions[7] - positions[9]).RotatedClockwise.Normalized  									  };    				PointF[] firstPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] secondPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] thirdPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				PointF[] forthPoints =   					{   					positions[6]  -  11*normals[3]'  					positions[6]  +  11*normals[3]'  					positions[7]  +  11*normals[3]'  					positions[7]  -  11*normals[3]'  					};    				PointF[] fifthPoints =   					{   					positions[8]  -  11*normals[4]'  					positions[8]  +  11*normals[4]'  					positions[9]  +  11*normals[4]'  					positions[9]  -  11*normals[4]'  					};    				if ((positions[0] - positions[1]).IsNotZeroVector())  					toReturn.AddPolygon(firstPoints);  				if ((positions[2] - positions[3]).IsNotZeroVector())  					toReturn.AddPolygon(secondPoints);  				if ((positions[4] - positions[5]).IsNotZeroVector())  					toReturn.AddPolygon(thirdPoints);  				if ((positions[6] - positions[7]).IsNotZeroVector())  					toReturn.AddPolygon(forthPoints);  				if ((positions[8] - positions[9]).IsNotZeroVector())  					toReturn.AddPolygon(fifthPoints);  				}
Magic Number,CityTrafficSimulator.Vehicle,Tram,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Tram.cs,BuildGraphicsPath,The following statement contains a magic number: if (_length == 250)  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized  									  };    				PointF[] frontPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] midPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] backPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				if (positions[0] != positions[1])  					toReturn.AddPolygon(frontPoints);  				if (positions[2] != positions[3])  					toReturn.AddPolygon(midPoints);  				if (positions[4] != positions[5])  					toReturn.AddPolygon(backPoints);  				}  			// 40-Meter-Zug  			else  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)'  					GetPositionAbsAtArcPos(currentPosition - 255)'  					GetPositionAbsAtArcPos(currentPosition - 300)'  					GetPositionAbsAtArcPos(currentPosition - 305)'  					GetPositionAbsAtArcPos(currentPosition - 400)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized'  					(positions[6] - positions[7]).RotatedClockwise.Normalized'  					(positions[7] - positions[9]).RotatedClockwise.Normalized  									  };    				PointF[] firstPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] secondPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] thirdPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				PointF[] forthPoints =   					{   					positions[6]  -  11*normals[3]'  					positions[6]  +  11*normals[3]'  					positions[7]  +  11*normals[3]'  					positions[7]  -  11*normals[3]'  					};    				PointF[] fifthPoints =   					{   					positions[8]  -  11*normals[4]'  					positions[8]  +  11*normals[4]'  					positions[9]  +  11*normals[4]'  					positions[9]  -  11*normals[4]'  					};    				if ((positions[0] - positions[1]).IsNotZeroVector())  					toReturn.AddPolygon(firstPoints);  				if ((positions[2] - positions[3]).IsNotZeroVector())  					toReturn.AddPolygon(secondPoints);  				if ((positions[4] - positions[5]).IsNotZeroVector())  					toReturn.AddPolygon(thirdPoints);  				if ((positions[6] - positions[7]).IsNotZeroVector())  					toReturn.AddPolygon(forthPoints);  				if ((positions[8] - positions[9]).IsNotZeroVector())  					toReturn.AddPolygon(fifthPoints);  				}
Magic Number,CityTrafficSimulator.Vehicle,Tram,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Tram.cs,BuildGraphicsPath,The following statement contains a magic number: if (_length == 250)  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized  									  };    				PointF[] frontPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] midPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] backPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				if (positions[0] != positions[1])  					toReturn.AddPolygon(frontPoints);  				if (positions[2] != positions[3])  					toReturn.AddPolygon(midPoints);  				if (positions[4] != positions[5])  					toReturn.AddPolygon(backPoints);  				}  			// 40-Meter-Zug  			else  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 95)'  					GetPositionAbsAtArcPos(currentPosition - 100)'  					GetPositionAbsAtArcPos(currentPosition - 150)'  					GetPositionAbsAtArcPos(currentPosition - 155)'  					GetPositionAbsAtArcPos(currentPosition - 250)'  					GetPositionAbsAtArcPos(currentPosition - 255)'  					GetPositionAbsAtArcPos(currentPosition - 300)'  					GetPositionAbsAtArcPos(currentPosition - 305)'  					GetPositionAbsAtArcPos(currentPosition - 400)  									  };  				Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized'  					(positions[4] - positions[5]).RotatedClockwise.Normalized'  					(positions[6] - positions[7]).RotatedClockwise.Normalized'  					(positions[7] - positions[9]).RotatedClockwise.Normalized  									  };    				PointF[] firstPoints =   					{   					positions[0]  -  11*normals[0]'  					positions[0]  +  11*normals[0]'  					positions[1]  +  11*normals[0]'  					positions[1]  -  11*normals[0]'  					};  				PointF[] secondPoints =   					{   					positions[2]  -  11*normals[1]'  					positions[2]  +  11*normals[1]'  					positions[3]  +  11*normals[1]'  					positions[3]  -  11*normals[1]'  					};    				PointF[] thirdPoints =   					{   					positions[4]  -  11*normals[2]'  					positions[4]  +  11*normals[2]'  					positions[5]  +  11*normals[2]'  					positions[5]  -  11*normals[2]'  					};    				PointF[] forthPoints =   					{   					positions[6]  -  11*normals[3]'  					positions[6]  +  11*normals[3]'  					positions[7]  +  11*normals[3]'  					positions[7]  -  11*normals[3]'  					};    				PointF[] fifthPoints =   					{   					positions[8]  -  11*normals[4]'  					positions[8]  +  11*normals[4]'  					positions[9]  +  11*normals[4]'  					positions[9]  -  11*normals[4]'  					};    				if ((positions[0] - positions[1]).IsNotZeroVector())  					toReturn.AddPolygon(firstPoints);  				if ((positions[2] - positions[3]).IsNotZeroVector())  					toReturn.AddPolygon(secondPoints);  				if ((positions[4] - positions[5]).IsNotZeroVector())  					toReturn.AddPolygon(thirdPoints);  				if ((positions[6] - positions[7]).IsNotZeroVector())  					toReturn.AddPolygon(forthPoints);  				if ((positions[8] - positions[9]).IsNotZeroVector())  					toReturn.AddPolygon(fifthPoints);  				}
Magic Number,CityTrafficSimulator.Vehicle,Truck,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Truck.cs,Truck,The following statement contains a magic number: length = (GlobalRandom.Instance.Next(2) == 0) ? 100 : 165;
Magic Number,CityTrafficSimulator.Vehicle,Truck,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Truck.cs,Truck,The following statement contains a magic number: length = (GlobalRandom.Instance.Next(2) == 0) ? 100 : 165;
Magic Number,CityTrafficSimulator.Vehicle,Truck,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Truck.cs,Truck,The following statement contains a magic number: length = (GlobalRandom.Instance.Next(2) == 0) ? 100 : 165;
Magic Number,CityTrafficSimulator.Vehicle,Truck,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Truck.cs,Truck,The following statement contains a magic number: color = Color.FromArgb(GlobalRandom.Instance.Next(256)' GlobalRandom.Instance.Next(256)' GlobalRandom.Instance.Next(256));
Magic Number,CityTrafficSimulator.Vehicle,Truck,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Truck.cs,Truck,The following statement contains a magic number: color = Color.FromArgb(GlobalRandom.Instance.Next(256)' GlobalRandom.Instance.Next(256)' GlobalRandom.Instance.Next(256));
Magic Number,CityTrafficSimulator.Vehicle,Truck,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Truck.cs,Truck,The following statement contains a magic number: color = Color.FromArgb(GlobalRandom.Instance.Next(256)' GlobalRandom.Instance.Next(256)' GlobalRandom.Instance.Next(256));
Magic Number,CityTrafficSimulator.Vehicle,Truck,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Truck.cs,Truck,The following statement contains a magic number: a = 0.6;
Magic Number,CityTrafficSimulator.Vehicle,Truck,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Truck.cs,Truck,The following statement contains a magic number: b = 0.7;
Magic Number,CityTrafficSimulator.Vehicle,Truck,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Truck.cs,Truck,The following statement contains a magic number: a *= (GlobalRandom.Instance.NextDouble() + 0.5);
Magic Number,CityTrafficSimulator.Vehicle,Truck,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Truck.cs,Truck,The following statement contains a magic number: b *= (GlobalRandom.Instance.NextDouble() + 0.5);
Magic Number,CityTrafficSimulator.Vehicle,Truck,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Truck.cs,Truck,The following statement contains a magic number: s0 *= (GlobalRandom.Instance.NextDouble() + 0.5);
Magic Number,CityTrafficSimulator.Vehicle,Truck,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Truck.cs,Truck,The following statement contains a magic number: T *= (GlobalRandom.Instance.NextDouble() + 0.5);
Magic Number,CityTrafficSimulator.Vehicle,Truck,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Truck.cs,Truck,The following statement contains a magic number: _physics.targetVelocity += ((GlobalRandom.Instance.NextDouble() - 0.5) * 4);
Magic Number,CityTrafficSimulator.Vehicle,Truck,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Truck.cs,Truck,The following statement contains a magic number: _physics.targetVelocity += ((GlobalRandom.Instance.NextDouble() - 0.5) * 4);
Magic Number,CityTrafficSimulator.Vehicle,Truck,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Truck.cs,BuildGraphicsPath,The following statement contains a magic number: if (_length == 100)  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 100)'  									  };  				if ((positions[0] - positions[1]).IsNotZeroVector())  					{  					Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  								  };    					PointF[] frontPoints = {   						positions[0]  -  10*normals[0]'  						positions[0]  +  10*normals[0]'  						positions[1]  +  10*normals[0]'  						positions[1]  -  10*normals[0]'  					};    					toReturn.AddPolygon(frontPoints);  					}  				}  			// Sattelzug  			else  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 40)'  					GetPositionAbsAtArcPos(currentPosition - 45)'  					GetPositionAbsAtArcPos(currentPosition - 165)  									  };  				if ((positions[0] - positions[1]).IsNotZeroVector() && (positions[2] - positions[3]).IsNotZeroVector())  					{  					Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized  								  };    					PointF[] frontPoints = {   						positions[0]  -  10*normals[0]'  						positions[0]  +  10*normals[0]'  						positions[1]  +  10*normals[0]'  						positions[1]  -  10*normals[0]'  					};  					PointF[] backPoints = {   						positions[2]  -  10*normals[1]'  						positions[2]  +  10*normals[1]'  						positions[3]  +  10*normals[1]'  						positions[3]  -  10*normals[1]'  	                };    					toReturn.AddPolygon(frontPoints);  					toReturn.AddPolygon(backPoints);  					}  				}
Magic Number,CityTrafficSimulator.Vehicle,Truck,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Truck.cs,BuildGraphicsPath,The following statement contains a magic number: if (_length == 100)  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 100)'  									  };  				if ((positions[0] - positions[1]).IsNotZeroVector())  					{  					Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  								  };    					PointF[] frontPoints = {   						positions[0]  -  10*normals[0]'  						positions[0]  +  10*normals[0]'  						positions[1]  +  10*normals[0]'  						positions[1]  -  10*normals[0]'  					};    					toReturn.AddPolygon(frontPoints);  					}  				}  			// Sattelzug  			else  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 40)'  					GetPositionAbsAtArcPos(currentPosition - 45)'  					GetPositionAbsAtArcPos(currentPosition - 165)  									  };  				if ((positions[0] - positions[1]).IsNotZeroVector() && (positions[2] - positions[3]).IsNotZeroVector())  					{  					Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized  								  };    					PointF[] frontPoints = {   						positions[0]  -  10*normals[0]'  						positions[0]  +  10*normals[0]'  						positions[1]  +  10*normals[0]'  						positions[1]  -  10*normals[0]'  					};  					PointF[] backPoints = {   						positions[2]  -  10*normals[1]'  						positions[2]  +  10*normals[1]'  						positions[3]  +  10*normals[1]'  						positions[3]  -  10*normals[1]'  	                };    					toReturn.AddPolygon(frontPoints);  					toReturn.AddPolygon(backPoints);  					}  				}
Magic Number,CityTrafficSimulator.Vehicle,Truck,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Truck.cs,BuildGraphicsPath,The following statement contains a magic number: if (_length == 100)  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 100)'  									  };  				if ((positions[0] - positions[1]).IsNotZeroVector())  					{  					Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  								  };    					PointF[] frontPoints = {   						positions[0]  -  10*normals[0]'  						positions[0]  +  10*normals[0]'  						positions[1]  +  10*normals[0]'  						positions[1]  -  10*normals[0]'  					};    					toReturn.AddPolygon(frontPoints);  					}  				}  			// Sattelzug  			else  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 40)'  					GetPositionAbsAtArcPos(currentPosition - 45)'  					GetPositionAbsAtArcPos(currentPosition - 165)  									  };  				if ((positions[0] - positions[1]).IsNotZeroVector() && (positions[2] - positions[3]).IsNotZeroVector())  					{  					Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized  								  };    					PointF[] frontPoints = {   						positions[0]  -  10*normals[0]'  						positions[0]  +  10*normals[0]'  						positions[1]  +  10*normals[0]'  						positions[1]  -  10*normals[0]'  					};  					PointF[] backPoints = {   						positions[2]  -  10*normals[1]'  						positions[2]  +  10*normals[1]'  						positions[3]  +  10*normals[1]'  						positions[3]  -  10*normals[1]'  	                };    					toReturn.AddPolygon(frontPoints);  					toReturn.AddPolygon(backPoints);  					}  				}
Magic Number,CityTrafficSimulator.Vehicle,Truck,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Truck.cs,BuildGraphicsPath,The following statement contains a magic number: if (_length == 100)  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 100)'  									  };  				if ((positions[0] - positions[1]).IsNotZeroVector())  					{  					Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  								  };    					PointF[] frontPoints = {   						positions[0]  -  10*normals[0]'  						positions[0]  +  10*normals[0]'  						positions[1]  +  10*normals[0]'  						positions[1]  -  10*normals[0]'  					};    					toReturn.AddPolygon(frontPoints);  					}  				}  			// Sattelzug  			else  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 40)'  					GetPositionAbsAtArcPos(currentPosition - 45)'  					GetPositionAbsAtArcPos(currentPosition - 165)  									  };  				if ((positions[0] - positions[1]).IsNotZeroVector() && (positions[2] - positions[3]).IsNotZeroVector())  					{  					Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized  								  };    					PointF[] frontPoints = {   						positions[0]  -  10*normals[0]'  						positions[0]  +  10*normals[0]'  						positions[1]  +  10*normals[0]'  						positions[1]  -  10*normals[0]'  					};  					PointF[] backPoints = {   						positions[2]  -  10*normals[1]'  						positions[2]  +  10*normals[1]'  						positions[3]  +  10*normals[1]'  						positions[3]  -  10*normals[1]'  	                };    					toReturn.AddPolygon(frontPoints);  					toReturn.AddPolygon(backPoints);  					}  				}
Magic Number,CityTrafficSimulator.Vehicle,Truck,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Truck.cs,BuildGraphicsPath,The following statement contains a magic number: if (_length == 100)  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 100)'  									  };  				if ((positions[0] - positions[1]).IsNotZeroVector())  					{  					Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  								  };    					PointF[] frontPoints = {   						positions[0]  -  10*normals[0]'  						positions[0]  +  10*normals[0]'  						positions[1]  +  10*normals[0]'  						positions[1]  -  10*normals[0]'  					};    					toReturn.AddPolygon(frontPoints);  					}  				}  			// Sattelzug  			else  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 40)'  					GetPositionAbsAtArcPos(currentPosition - 45)'  					GetPositionAbsAtArcPos(currentPosition - 165)  									  };  				if ((positions[0] - positions[1]).IsNotZeroVector() && (positions[2] - positions[3]).IsNotZeroVector())  					{  					Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized  								  };    					PointF[] frontPoints = {   						positions[0]  -  10*normals[0]'  						positions[0]  +  10*normals[0]'  						positions[1]  +  10*normals[0]'  						positions[1]  -  10*normals[0]'  					};  					PointF[] backPoints = {   						positions[2]  -  10*normals[1]'  						positions[2]  +  10*normals[1]'  						positions[3]  +  10*normals[1]'  						positions[3]  -  10*normals[1]'  	                };    					toReturn.AddPolygon(frontPoints);  					toReturn.AddPolygon(backPoints);  					}  				}
Magic Number,CityTrafficSimulator.Vehicle,Truck,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Truck.cs,BuildGraphicsPath,The following statement contains a magic number: if (_length == 100)  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 100)'  									  };  				if ((positions[0] - positions[1]).IsNotZeroVector())  					{  					Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  								  };    					PointF[] frontPoints = {   						positions[0]  -  10*normals[0]'  						positions[0]  +  10*normals[0]'  						positions[1]  +  10*normals[0]'  						positions[1]  -  10*normals[0]'  					};    					toReturn.AddPolygon(frontPoints);  					}  				}  			// Sattelzug  			else  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 40)'  					GetPositionAbsAtArcPos(currentPosition - 45)'  					GetPositionAbsAtArcPos(currentPosition - 165)  									  };  				if ((positions[0] - positions[1]).IsNotZeroVector() && (positions[2] - positions[3]).IsNotZeroVector())  					{  					Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized  								  };    					PointF[] frontPoints = {   						positions[0]  -  10*normals[0]'  						positions[0]  +  10*normals[0]'  						positions[1]  +  10*normals[0]'  						positions[1]  -  10*normals[0]'  					};  					PointF[] backPoints = {   						positions[2]  -  10*normals[1]'  						positions[2]  +  10*normals[1]'  						positions[3]  +  10*normals[1]'  						positions[3]  -  10*normals[1]'  	                };    					toReturn.AddPolygon(frontPoints);  					toReturn.AddPolygon(backPoints);  					}  				}
Magic Number,CityTrafficSimulator.Vehicle,Truck,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Truck.cs,BuildGraphicsPath,The following statement contains a magic number: if (_length == 100)  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 100)'  									  };  				if ((positions[0] - positions[1]).IsNotZeroVector())  					{  					Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  								  };    					PointF[] frontPoints = {   						positions[0]  -  10*normals[0]'  						positions[0]  +  10*normals[0]'  						positions[1]  +  10*normals[0]'  						positions[1]  -  10*normals[0]'  					};    					toReturn.AddPolygon(frontPoints);  					}  				}  			// Sattelzug  			else  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 40)'  					GetPositionAbsAtArcPos(currentPosition - 45)'  					GetPositionAbsAtArcPos(currentPosition - 165)  									  };  				if ((positions[0] - positions[1]).IsNotZeroVector() && (positions[2] - positions[3]).IsNotZeroVector())  					{  					Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized  								  };    					PointF[] frontPoints = {   						positions[0]  -  10*normals[0]'  						positions[0]  +  10*normals[0]'  						positions[1]  +  10*normals[0]'  						positions[1]  -  10*normals[0]'  					};  					PointF[] backPoints = {   						positions[2]  -  10*normals[1]'  						positions[2]  +  10*normals[1]'  						positions[3]  +  10*normals[1]'  						positions[3]  -  10*normals[1]'  	                };    					toReturn.AddPolygon(frontPoints);  					toReturn.AddPolygon(backPoints);  					}  				}
Magic Number,CityTrafficSimulator.Vehicle,Truck,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Truck.cs,BuildGraphicsPath,The following statement contains a magic number: if (_length == 100)  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 100)'  									  };  				if ((positions[0] - positions[1]).IsNotZeroVector())  					{  					Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  								  };    					PointF[] frontPoints = {   						positions[0]  -  10*normals[0]'  						positions[0]  +  10*normals[0]'  						positions[1]  +  10*normals[0]'  						positions[1]  -  10*normals[0]'  					};    					toReturn.AddPolygon(frontPoints);  					}  				}  			// Sattelzug  			else  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 40)'  					GetPositionAbsAtArcPos(currentPosition - 45)'  					GetPositionAbsAtArcPos(currentPosition - 165)  									  };  				if ((positions[0] - positions[1]).IsNotZeroVector() && (positions[2] - positions[3]).IsNotZeroVector())  					{  					Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized  								  };    					PointF[] frontPoints = {   						positions[0]  -  10*normals[0]'  						positions[0]  +  10*normals[0]'  						positions[1]  +  10*normals[0]'  						positions[1]  -  10*normals[0]'  					};  					PointF[] backPoints = {   						positions[2]  -  10*normals[1]'  						positions[2]  +  10*normals[1]'  						positions[3]  +  10*normals[1]'  						positions[3]  -  10*normals[1]'  	                };    					toReturn.AddPolygon(frontPoints);  					toReturn.AddPolygon(backPoints);  					}  				}
Magic Number,CityTrafficSimulator.Vehicle,Truck,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Truck.cs,BuildGraphicsPath,The following statement contains a magic number: if (_length == 100)  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 100)'  									  };  				if ((positions[0] - positions[1]).IsNotZeroVector())  					{  					Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  								  };    					PointF[] frontPoints = {   						positions[0]  -  10*normals[0]'  						positions[0]  +  10*normals[0]'  						positions[1]  +  10*normals[0]'  						positions[1]  -  10*normals[0]'  					};    					toReturn.AddPolygon(frontPoints);  					}  				}  			// Sattelzug  			else  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 40)'  					GetPositionAbsAtArcPos(currentPosition - 45)'  					GetPositionAbsAtArcPos(currentPosition - 165)  									  };  				if ((positions[0] - positions[1]).IsNotZeroVector() && (positions[2] - positions[3]).IsNotZeroVector())  					{  					Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized  								  };    					PointF[] frontPoints = {   						positions[0]  -  10*normals[0]'  						positions[0]  +  10*normals[0]'  						positions[1]  +  10*normals[0]'  						positions[1]  -  10*normals[0]'  					};  					PointF[] backPoints = {   						positions[2]  -  10*normals[1]'  						positions[2]  +  10*normals[1]'  						positions[3]  +  10*normals[1]'  						positions[3]  -  10*normals[1]'  	                };    					toReturn.AddPolygon(frontPoints);  					toReturn.AddPolygon(backPoints);  					}  				}
Magic Number,CityTrafficSimulator.Vehicle,Truck,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Truck.cs,BuildGraphicsPath,The following statement contains a magic number: if (_length == 100)  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 100)'  									  };  				if ((positions[0] - positions[1]).IsNotZeroVector())  					{  					Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  								  };    					PointF[] frontPoints = {   						positions[0]  -  10*normals[0]'  						positions[0]  +  10*normals[0]'  						positions[1]  +  10*normals[0]'  						positions[1]  -  10*normals[0]'  					};    					toReturn.AddPolygon(frontPoints);  					}  				}  			// Sattelzug  			else  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 40)'  					GetPositionAbsAtArcPos(currentPosition - 45)'  					GetPositionAbsAtArcPos(currentPosition - 165)  									  };  				if ((positions[0] - positions[1]).IsNotZeroVector() && (positions[2] - positions[3]).IsNotZeroVector())  					{  					Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized  								  };    					PointF[] frontPoints = {   						positions[0]  -  10*normals[0]'  						positions[0]  +  10*normals[0]'  						positions[1]  +  10*normals[0]'  						positions[1]  -  10*normals[0]'  					};  					PointF[] backPoints = {   						positions[2]  -  10*normals[1]'  						positions[2]  +  10*normals[1]'  						positions[3]  +  10*normals[1]'  						positions[3]  -  10*normals[1]'  	                };    					toReturn.AddPolygon(frontPoints);  					toReturn.AddPolygon(backPoints);  					}  				}
Magic Number,CityTrafficSimulator.Vehicle,Truck,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Truck.cs,BuildGraphicsPath,The following statement contains a magic number: if (_length == 100)  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 100)'  									  };  				if ((positions[0] - positions[1]).IsNotZeroVector())  					{  					Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  								  };    					PointF[] frontPoints = {   						positions[0]  -  10*normals[0]'  						positions[0]  +  10*normals[0]'  						positions[1]  +  10*normals[0]'  						positions[1]  -  10*normals[0]'  					};    					toReturn.AddPolygon(frontPoints);  					}  				}  			// Sattelzug  			else  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 40)'  					GetPositionAbsAtArcPos(currentPosition - 45)'  					GetPositionAbsAtArcPos(currentPosition - 165)  									  };  				if ((positions[0] - positions[1]).IsNotZeroVector() && (positions[2] - positions[3]).IsNotZeroVector())  					{  					Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized  								  };    					PointF[] frontPoints = {   						positions[0]  -  10*normals[0]'  						positions[0]  +  10*normals[0]'  						positions[1]  +  10*normals[0]'  						positions[1]  -  10*normals[0]'  					};  					PointF[] backPoints = {   						positions[2]  -  10*normals[1]'  						positions[2]  +  10*normals[1]'  						positions[3]  +  10*normals[1]'  						positions[3]  -  10*normals[1]'  	                };    					toReturn.AddPolygon(frontPoints);  					toReturn.AddPolygon(backPoints);  					}  				}
Magic Number,CityTrafficSimulator.Vehicle,Truck,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Truck.cs,BuildGraphicsPath,The following statement contains a magic number: if (_length == 100)  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 100)'  									  };  				if ((positions[0] - positions[1]).IsNotZeroVector())  					{  					Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  								  };    					PointF[] frontPoints = {   						positions[0]  -  10*normals[0]'  						positions[0]  +  10*normals[0]'  						positions[1]  +  10*normals[0]'  						positions[1]  -  10*normals[0]'  					};    					toReturn.AddPolygon(frontPoints);  					}  				}  			// Sattelzug  			else  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 40)'  					GetPositionAbsAtArcPos(currentPosition - 45)'  					GetPositionAbsAtArcPos(currentPosition - 165)  									  };  				if ((positions[0] - positions[1]).IsNotZeroVector() && (positions[2] - positions[3]).IsNotZeroVector())  					{  					Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized  								  };    					PointF[] frontPoints = {   						positions[0]  -  10*normals[0]'  						positions[0]  +  10*normals[0]'  						positions[1]  +  10*normals[0]'  						positions[1]  -  10*normals[0]'  					};  					PointF[] backPoints = {   						positions[2]  -  10*normals[1]'  						positions[2]  +  10*normals[1]'  						positions[3]  +  10*normals[1]'  						positions[3]  -  10*normals[1]'  	                };    					toReturn.AddPolygon(frontPoints);  					toReturn.AddPolygon(backPoints);  					}  				}
Magic Number,CityTrafficSimulator.Vehicle,Truck,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Truck.cs,BuildGraphicsPath,The following statement contains a magic number: if (_length == 100)  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 100)'  									  };  				if ((positions[0] - positions[1]).IsNotZeroVector())  					{  					Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  								  };    					PointF[] frontPoints = {   						positions[0]  -  10*normals[0]'  						positions[0]  +  10*normals[0]'  						positions[1]  +  10*normals[0]'  						positions[1]  -  10*normals[0]'  					};    					toReturn.AddPolygon(frontPoints);  					}  				}  			// Sattelzug  			else  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 40)'  					GetPositionAbsAtArcPos(currentPosition - 45)'  					GetPositionAbsAtArcPos(currentPosition - 165)  									  };  				if ((positions[0] - positions[1]).IsNotZeroVector() && (positions[2] - positions[3]).IsNotZeroVector())  					{  					Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized  								  };    					PointF[] frontPoints = {   						positions[0]  -  10*normals[0]'  						positions[0]  +  10*normals[0]'  						positions[1]  +  10*normals[0]'  						positions[1]  -  10*normals[0]'  					};  					PointF[] backPoints = {   						positions[2]  -  10*normals[1]'  						positions[2]  +  10*normals[1]'  						positions[3]  +  10*normals[1]'  						positions[3]  -  10*normals[1]'  	                };    					toReturn.AddPolygon(frontPoints);  					toReturn.AddPolygon(backPoints);  					}  				}
Magic Number,CityTrafficSimulator.Vehicle,Truck,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Truck.cs,BuildGraphicsPath,The following statement contains a magic number: if (_length == 100)  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 100)'  									  };  				if ((positions[0] - positions[1]).IsNotZeroVector())  					{  					Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  								  };    					PointF[] frontPoints = {   						positions[0]  -  10*normals[0]'  						positions[0]  +  10*normals[0]'  						positions[1]  +  10*normals[0]'  						positions[1]  -  10*normals[0]'  					};    					toReturn.AddPolygon(frontPoints);  					}  				}  			// Sattelzug  			else  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 40)'  					GetPositionAbsAtArcPos(currentPosition - 45)'  					GetPositionAbsAtArcPos(currentPosition - 165)  									  };  				if ((positions[0] - positions[1]).IsNotZeroVector() && (positions[2] - positions[3]).IsNotZeroVector())  					{  					Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized  								  };    					PointF[] frontPoints = {   						positions[0]  -  10*normals[0]'  						positions[0]  +  10*normals[0]'  						positions[1]  +  10*normals[0]'  						positions[1]  -  10*normals[0]'  					};  					PointF[] backPoints = {   						positions[2]  -  10*normals[1]'  						positions[2]  +  10*normals[1]'  						positions[3]  +  10*normals[1]'  						positions[3]  -  10*normals[1]'  	                };    					toReturn.AddPolygon(frontPoints);  					toReturn.AddPolygon(backPoints);  					}  				}
Magic Number,CityTrafficSimulator.Vehicle,Truck,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Truck.cs,BuildGraphicsPath,The following statement contains a magic number: if (_length == 100)  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 100)'  									  };  				if ((positions[0] - positions[1]).IsNotZeroVector())  					{  					Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  								  };    					PointF[] frontPoints = {   						positions[0]  -  10*normals[0]'  						positions[0]  +  10*normals[0]'  						positions[1]  +  10*normals[0]'  						positions[1]  -  10*normals[0]'  					};    					toReturn.AddPolygon(frontPoints);  					}  				}  			// Sattelzug  			else  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 40)'  					GetPositionAbsAtArcPos(currentPosition - 45)'  					GetPositionAbsAtArcPos(currentPosition - 165)  									  };  				if ((positions[0] - positions[1]).IsNotZeroVector() && (positions[2] - positions[3]).IsNotZeroVector())  					{  					Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized  								  };    					PointF[] frontPoints = {   						positions[0]  -  10*normals[0]'  						positions[0]  +  10*normals[0]'  						positions[1]  +  10*normals[0]'  						positions[1]  -  10*normals[0]'  					};  					PointF[] backPoints = {   						positions[2]  -  10*normals[1]'  						positions[2]  +  10*normals[1]'  						positions[3]  +  10*normals[1]'  						positions[3]  -  10*normals[1]'  	                };    					toReturn.AddPolygon(frontPoints);  					toReturn.AddPolygon(backPoints);  					}  				}
Magic Number,CityTrafficSimulator.Vehicle,Truck,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Truck.cs,BuildGraphicsPath,The following statement contains a magic number: if (_length == 100)  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 100)'  									  };  				if ((positions[0] - positions[1]).IsNotZeroVector())  					{  					Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  								  };    					PointF[] frontPoints = {   						positions[0]  -  10*normals[0]'  						positions[0]  +  10*normals[0]'  						positions[1]  +  10*normals[0]'  						positions[1]  -  10*normals[0]'  					};    					toReturn.AddPolygon(frontPoints);  					}  				}  			// Sattelzug  			else  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 40)'  					GetPositionAbsAtArcPos(currentPosition - 45)'  					GetPositionAbsAtArcPos(currentPosition - 165)  									  };  				if ((positions[0] - positions[1]).IsNotZeroVector() && (positions[2] - positions[3]).IsNotZeroVector())  					{  					Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized  								  };    					PointF[] frontPoints = {   						positions[0]  -  10*normals[0]'  						positions[0]  +  10*normals[0]'  						positions[1]  +  10*normals[0]'  						positions[1]  -  10*normals[0]'  					};  					PointF[] backPoints = {   						positions[2]  -  10*normals[1]'  						positions[2]  +  10*normals[1]'  						positions[3]  +  10*normals[1]'  						positions[3]  -  10*normals[1]'  	                };    					toReturn.AddPolygon(frontPoints);  					toReturn.AddPolygon(backPoints);  					}  				}
Magic Number,CityTrafficSimulator.Vehicle,Truck,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Truck.cs,BuildGraphicsPath,The following statement contains a magic number: if (_length == 100)  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 100)'  									  };  				if ((positions[0] - positions[1]).IsNotZeroVector())  					{  					Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  								  };    					PointF[] frontPoints = {   						positions[0]  -  10*normals[0]'  						positions[0]  +  10*normals[0]'  						positions[1]  +  10*normals[0]'  						positions[1]  -  10*normals[0]'  					};    					toReturn.AddPolygon(frontPoints);  					}  				}  			// Sattelzug  			else  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 40)'  					GetPositionAbsAtArcPos(currentPosition - 45)'  					GetPositionAbsAtArcPos(currentPosition - 165)  									  };  				if ((positions[0] - positions[1]).IsNotZeroVector() && (positions[2] - positions[3]).IsNotZeroVector())  					{  					Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized  								  };    					PointF[] frontPoints = {   						positions[0]  -  10*normals[0]'  						positions[0]  +  10*normals[0]'  						positions[1]  +  10*normals[0]'  						positions[1]  -  10*normals[0]'  					};  					PointF[] backPoints = {   						positions[2]  -  10*normals[1]'  						positions[2]  +  10*normals[1]'  						positions[3]  +  10*normals[1]'  						positions[3]  -  10*normals[1]'  	                };    					toReturn.AddPolygon(frontPoints);  					toReturn.AddPolygon(backPoints);  					}  				}
Magic Number,CityTrafficSimulator.Vehicle,Truck,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Truck.cs,BuildGraphicsPath,The following statement contains a magic number: if (_length == 100)  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 100)'  									  };  				if ((positions[0] - positions[1]).IsNotZeroVector())  					{  					Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  								  };    					PointF[] frontPoints = {   						positions[0]  -  10*normals[0]'  						positions[0]  +  10*normals[0]'  						positions[1]  +  10*normals[0]'  						positions[1]  -  10*normals[0]'  					};    					toReturn.AddPolygon(frontPoints);  					}  				}  			// Sattelzug  			else  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 40)'  					GetPositionAbsAtArcPos(currentPosition - 45)'  					GetPositionAbsAtArcPos(currentPosition - 165)  									  };  				if ((positions[0] - positions[1]).IsNotZeroVector() && (positions[2] - positions[3]).IsNotZeroVector())  					{  					Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized  								  };    					PointF[] frontPoints = {   						positions[0]  -  10*normals[0]'  						positions[0]  +  10*normals[0]'  						positions[1]  +  10*normals[0]'  						positions[1]  -  10*normals[0]'  					};  					PointF[] backPoints = {   						positions[2]  -  10*normals[1]'  						positions[2]  +  10*normals[1]'  						positions[3]  +  10*normals[1]'  						positions[3]  -  10*normals[1]'  	                };    					toReturn.AddPolygon(frontPoints);  					toReturn.AddPolygon(backPoints);  					}  				}
Magic Number,CityTrafficSimulator.Vehicle,Truck,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Truck.cs,BuildGraphicsPath,The following statement contains a magic number: if (_length == 100)  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 100)'  									  };  				if ((positions[0] - positions[1]).IsNotZeroVector())  					{  					Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  								  };    					PointF[] frontPoints = {   						positions[0]  -  10*normals[0]'  						positions[0]  +  10*normals[0]'  						positions[1]  +  10*normals[0]'  						positions[1]  -  10*normals[0]'  					};    					toReturn.AddPolygon(frontPoints);  					}  				}  			// Sattelzug  			else  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 40)'  					GetPositionAbsAtArcPos(currentPosition - 45)'  					GetPositionAbsAtArcPos(currentPosition - 165)  									  };  				if ((positions[0] - positions[1]).IsNotZeroVector() && (positions[2] - positions[3]).IsNotZeroVector())  					{  					Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized  								  };    					PointF[] frontPoints = {   						positions[0]  -  10*normals[0]'  						positions[0]  +  10*normals[0]'  						positions[1]  +  10*normals[0]'  						positions[1]  -  10*normals[0]'  					};  					PointF[] backPoints = {   						positions[2]  -  10*normals[1]'  						positions[2]  +  10*normals[1]'  						positions[3]  +  10*normals[1]'  						positions[3]  -  10*normals[1]'  	                };    					toReturn.AddPolygon(frontPoints);  					toReturn.AddPolygon(backPoints);  					}  				}
Magic Number,CityTrafficSimulator.Vehicle,Truck,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Truck.cs,BuildGraphicsPath,The following statement contains a magic number: if (_length == 100)  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 100)'  									  };  				if ((positions[0] - positions[1]).IsNotZeroVector())  					{  					Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  								  };    					PointF[] frontPoints = {   						positions[0]  -  10*normals[0]'  						positions[0]  +  10*normals[0]'  						positions[1]  +  10*normals[0]'  						positions[1]  -  10*normals[0]'  					};    					toReturn.AddPolygon(frontPoints);  					}  				}  			// Sattelzug  			else  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 40)'  					GetPositionAbsAtArcPos(currentPosition - 45)'  					GetPositionAbsAtArcPos(currentPosition - 165)  									  };  				if ((positions[0] - positions[1]).IsNotZeroVector() && (positions[2] - positions[3]).IsNotZeroVector())  					{  					Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized  								  };    					PointF[] frontPoints = {   						positions[0]  -  10*normals[0]'  						positions[0]  +  10*normals[0]'  						positions[1]  +  10*normals[0]'  						positions[1]  -  10*normals[0]'  					};  					PointF[] backPoints = {   						positions[2]  -  10*normals[1]'  						positions[2]  +  10*normals[1]'  						positions[3]  +  10*normals[1]'  						positions[3]  -  10*normals[1]'  	                };    					toReturn.AddPolygon(frontPoints);  					toReturn.AddPolygon(backPoints);  					}  				}
Magic Number,CityTrafficSimulator.Vehicle,Truck,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Truck.cs,BuildGraphicsPath,The following statement contains a magic number: if (_length == 100)  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 100)'  									  };  				if ((positions[0] - positions[1]).IsNotZeroVector())  					{  					Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  								  };    					PointF[] frontPoints = {   						positions[0]  -  10*normals[0]'  						positions[0]  +  10*normals[0]'  						positions[1]  +  10*normals[0]'  						positions[1]  -  10*normals[0]'  					};    					toReturn.AddPolygon(frontPoints);  					}  				}  			// Sattelzug  			else  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 40)'  					GetPositionAbsAtArcPos(currentPosition - 45)'  					GetPositionAbsAtArcPos(currentPosition - 165)  									  };  				if ((positions[0] - positions[1]).IsNotZeroVector() && (positions[2] - positions[3]).IsNotZeroVector())  					{  					Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized  								  };    					PointF[] frontPoints = {   						positions[0]  -  10*normals[0]'  						positions[0]  +  10*normals[0]'  						positions[1]  +  10*normals[0]'  						positions[1]  -  10*normals[0]'  					};  					PointF[] backPoints = {   						positions[2]  -  10*normals[1]'  						positions[2]  +  10*normals[1]'  						positions[3]  +  10*normals[1]'  						positions[3]  -  10*normals[1]'  	                };    					toReturn.AddPolygon(frontPoints);  					toReturn.AddPolygon(backPoints);  					}  				}
Magic Number,CityTrafficSimulator.Vehicle,Truck,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Truck.cs,BuildGraphicsPath,The following statement contains a magic number: if (_length == 100)  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 100)'  									  };  				if ((positions[0] - positions[1]).IsNotZeroVector())  					{  					Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  								  };    					PointF[] frontPoints = {   						positions[0]  -  10*normals[0]'  						positions[0]  +  10*normals[0]'  						positions[1]  +  10*normals[0]'  						positions[1]  -  10*normals[0]'  					};    					toReturn.AddPolygon(frontPoints);  					}  				}  			// Sattelzug  			else  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 40)'  					GetPositionAbsAtArcPos(currentPosition - 45)'  					GetPositionAbsAtArcPos(currentPosition - 165)  									  };  				if ((positions[0] - positions[1]).IsNotZeroVector() && (positions[2] - positions[3]).IsNotZeroVector())  					{  					Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized  								  };    					PointF[] frontPoints = {   						positions[0]  -  10*normals[0]'  						positions[0]  +  10*normals[0]'  						positions[1]  +  10*normals[0]'  						positions[1]  -  10*normals[0]'  					};  					PointF[] backPoints = {   						positions[2]  -  10*normals[1]'  						positions[2]  +  10*normals[1]'  						positions[3]  +  10*normals[1]'  						positions[3]  -  10*normals[1]'  	                };    					toReturn.AddPolygon(frontPoints);  					toReturn.AddPolygon(backPoints);  					}  				}
Magic Number,CityTrafficSimulator.Vehicle,Truck,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Truck.cs,BuildGraphicsPath,The following statement contains a magic number: if (_length == 100)  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 100)'  									  };  				if ((positions[0] - positions[1]).IsNotZeroVector())  					{  					Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  								  };    					PointF[] frontPoints = {   						positions[0]  -  10*normals[0]'  						positions[0]  +  10*normals[0]'  						positions[1]  +  10*normals[0]'  						positions[1]  -  10*normals[0]'  					};    					toReturn.AddPolygon(frontPoints);  					}  				}  			// Sattelzug  			else  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 40)'  					GetPositionAbsAtArcPos(currentPosition - 45)'  					GetPositionAbsAtArcPos(currentPosition - 165)  									  };  				if ((positions[0] - positions[1]).IsNotZeroVector() && (positions[2] - positions[3]).IsNotZeroVector())  					{  					Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized  								  };    					PointF[] frontPoints = {   						positions[0]  -  10*normals[0]'  						positions[0]  +  10*normals[0]'  						positions[1]  +  10*normals[0]'  						positions[1]  -  10*normals[0]'  					};  					PointF[] backPoints = {   						positions[2]  -  10*normals[1]'  						positions[2]  +  10*normals[1]'  						positions[3]  +  10*normals[1]'  						positions[3]  -  10*normals[1]'  	                };    					toReturn.AddPolygon(frontPoints);  					toReturn.AddPolygon(backPoints);  					}  				}
Magic Number,CityTrafficSimulator.Vehicle,Truck,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Truck.cs,BuildGraphicsPath,The following statement contains a magic number: if (_length == 100)  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 100)'  									  };  				if ((positions[0] - positions[1]).IsNotZeroVector())  					{  					Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  								  };    					PointF[] frontPoints = {   						positions[0]  -  10*normals[0]'  						positions[0]  +  10*normals[0]'  						positions[1]  +  10*normals[0]'  						positions[1]  -  10*normals[0]'  					};    					toReturn.AddPolygon(frontPoints);  					}  				}  			// Sattelzug  			else  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 40)'  					GetPositionAbsAtArcPos(currentPosition - 45)'  					GetPositionAbsAtArcPos(currentPosition - 165)  									  };  				if ((positions[0] - positions[1]).IsNotZeroVector() && (positions[2] - positions[3]).IsNotZeroVector())  					{  					Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized  								  };    					PointF[] frontPoints = {   						positions[0]  -  10*normals[0]'  						positions[0]  +  10*normals[0]'  						positions[1]  +  10*normals[0]'  						positions[1]  -  10*normals[0]'  					};  					PointF[] backPoints = {   						positions[2]  -  10*normals[1]'  						positions[2]  +  10*normals[1]'  						positions[3]  +  10*normals[1]'  						positions[3]  -  10*normals[1]'  	                };    					toReturn.AddPolygon(frontPoints);  					toReturn.AddPolygon(backPoints);  					}  				}
Magic Number,CityTrafficSimulator.Vehicle,Truck,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Vehicle\Truck.cs,BuildGraphicsPath,The following statement contains a magic number: if (_length == 100)  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 100)'  									  };  				if ((positions[0] - positions[1]).IsNotZeroVector())  					{  					Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  								  };    					PointF[] frontPoints = {   						positions[0]  -  10*normals[0]'  						positions[0]  +  10*normals[0]'  						positions[1]  +  10*normals[0]'  						positions[1]  -  10*normals[0]'  					};    					toReturn.AddPolygon(frontPoints);  					}  				}  			// Sattelzug  			else  				{  				Vector2[] positions = {  					state.positionAbs'  					GetPositionAbsAtArcPos(currentPosition - 40)'  					GetPositionAbsAtArcPos(currentPosition - 45)'  					GetPositionAbsAtArcPos(currentPosition - 165)  									  };  				if ((positions[0] - positions[1]).IsNotZeroVector() && (positions[2] - positions[3]).IsNotZeroVector())  					{  					Vector2[] normals = {  					(positions[0] - positions[1]).RotatedClockwise.Normalized'  					(positions[2] - positions[3]).RotatedClockwise.Normalized  								  };    					PointF[] frontPoints = {   						positions[0]  -  10*normals[0]'  						positions[0]  +  10*normals[0]'  						positions[1]  +  10*normals[0]'  						positions[1]  -  10*normals[0]'  					};  					PointF[] backPoints = {   						positions[2]  -  10*normals[1]'  						positions[2]  +  10*normals[1]'  						positions[3]  +  10*normals[1]'  						positions[3]  -  10*normals[1]'  	                };    					toReturn.AddPolygon(frontPoints);  					toReturn.AddPolygon(backPoints);  					}  				}
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolume,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolume.cs,Tick,The following statement contains a magic number: if (tickLength > 0)  				{  				// enqueue cars  				int randomValue = trafficVolumeCars > 0 ? GlobalRandom.Instance.Next((int)Math.Ceiling(3600.0 / (tickLength * trafficVolumeCars))) : -1;  				if (randomValue == 0)  					{  					OnVehicleSpawned(new VehicleSpawnedEventArgs(new Car(new IVehicle.Physics())' this));  					}    				// enqueue trucks  				randomValue = trafficVolumeTrucks > 0 ? GlobalRandom.Instance.Next((int)Math.Ceiling(3600.0 / (tickLength * trafficVolumeTrucks))) : -1;  				if (randomValue == 0)  					{  					OnVehicleSpawned(new VehicleSpawnedEventArgs(new Truck(new IVehicle.Physics())' this));  					}    				// enqueue busses  				randomValue = trafficVolumeBusses > 0 ? GlobalRandom.Instance.Next((int)Math.Ceiling(3600.0 / (tickLength * trafficVolumeBusses))) : -1;  				if (randomValue == 0)  					{  					OnVehicleSpawned(new VehicleSpawnedEventArgs(new Bus(new IVehicle.Physics())' this));  					}    				// enqueue trams  				randomValue = trafficVolumeTrams > 0 ? GlobalRandom.Instance.Next((int)Math.Ceiling(3600.0 / (tickLength * trafficVolumeTrams))) : -1;  				if (randomValue == 0)  					{  					OnVehicleSpawned(new VehicleSpawnedEventArgs(new Tram(new IVehicle.Physics())' this));  					}  				}
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolume,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolume.cs,Tick,The following statement contains a magic number: if (tickLength > 0)  				{  				// enqueue cars  				int randomValue = trafficVolumeCars > 0 ? GlobalRandom.Instance.Next((int)Math.Ceiling(3600.0 / (tickLength * trafficVolumeCars))) : -1;  				if (randomValue == 0)  					{  					OnVehicleSpawned(new VehicleSpawnedEventArgs(new Car(new IVehicle.Physics())' this));  					}    				// enqueue trucks  				randomValue = trafficVolumeTrucks > 0 ? GlobalRandom.Instance.Next((int)Math.Ceiling(3600.0 / (tickLength * trafficVolumeTrucks))) : -1;  				if (randomValue == 0)  					{  					OnVehicleSpawned(new VehicleSpawnedEventArgs(new Truck(new IVehicle.Physics())' this));  					}    				// enqueue busses  				randomValue = trafficVolumeBusses > 0 ? GlobalRandom.Instance.Next((int)Math.Ceiling(3600.0 / (tickLength * trafficVolumeBusses))) : -1;  				if (randomValue == 0)  					{  					OnVehicleSpawned(new VehicleSpawnedEventArgs(new Bus(new IVehicle.Physics())' this));  					}    				// enqueue trams  				randomValue = trafficVolumeTrams > 0 ? GlobalRandom.Instance.Next((int)Math.Ceiling(3600.0 / (tickLength * trafficVolumeTrams))) : -1;  				if (randomValue == 0)  					{  					OnVehicleSpawned(new VehicleSpawnedEventArgs(new Tram(new IVehicle.Physics())' this));  					}  				}
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolume,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolume.cs,Tick,The following statement contains a magic number: if (tickLength > 0)  				{  				// enqueue cars  				int randomValue = trafficVolumeCars > 0 ? GlobalRandom.Instance.Next((int)Math.Ceiling(3600.0 / (tickLength * trafficVolumeCars))) : -1;  				if (randomValue == 0)  					{  					OnVehicleSpawned(new VehicleSpawnedEventArgs(new Car(new IVehicle.Physics())' this));  					}    				// enqueue trucks  				randomValue = trafficVolumeTrucks > 0 ? GlobalRandom.Instance.Next((int)Math.Ceiling(3600.0 / (tickLength * trafficVolumeTrucks))) : -1;  				if (randomValue == 0)  					{  					OnVehicleSpawned(new VehicleSpawnedEventArgs(new Truck(new IVehicle.Physics())' this));  					}    				// enqueue busses  				randomValue = trafficVolumeBusses > 0 ? GlobalRandom.Instance.Next((int)Math.Ceiling(3600.0 / (tickLength * trafficVolumeBusses))) : -1;  				if (randomValue == 0)  					{  					OnVehicleSpawned(new VehicleSpawnedEventArgs(new Bus(new IVehicle.Physics())' this));  					}    				// enqueue trams  				randomValue = trafficVolumeTrams > 0 ? GlobalRandom.Instance.Next((int)Math.Ceiling(3600.0 / (tickLength * trafficVolumeTrams))) : -1;  				if (randomValue == 0)  					{  					OnVehicleSpawned(new VehicleSpawnedEventArgs(new Tram(new IVehicle.Physics())' this));  					}  				}
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolume,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolume.cs,Tick,The following statement contains a magic number: if (tickLength > 0)  				{  				// enqueue cars  				int randomValue = trafficVolumeCars > 0 ? GlobalRandom.Instance.Next((int)Math.Ceiling(3600.0 / (tickLength * trafficVolumeCars))) : -1;  				if (randomValue == 0)  					{  					OnVehicleSpawned(new VehicleSpawnedEventArgs(new Car(new IVehicle.Physics())' this));  					}    				// enqueue trucks  				randomValue = trafficVolumeTrucks > 0 ? GlobalRandom.Instance.Next((int)Math.Ceiling(3600.0 / (tickLength * trafficVolumeTrucks))) : -1;  				if (randomValue == 0)  					{  					OnVehicleSpawned(new VehicleSpawnedEventArgs(new Truck(new IVehicle.Physics())' this));  					}    				// enqueue busses  				randomValue = trafficVolumeBusses > 0 ? GlobalRandom.Instance.Next((int)Math.Ceiling(3600.0 / (tickLength * trafficVolumeBusses))) : -1;  				if (randomValue == 0)  					{  					OnVehicleSpawned(new VehicleSpawnedEventArgs(new Bus(new IVehicle.Physics())' this));  					}    				// enqueue trams  				randomValue = trafficVolumeTrams > 0 ? GlobalRandom.Instance.Next((int)Math.Ceiling(3600.0 / (tickLength * trafficVolumeTrams))) : -1;  				if (randomValue == 0)  					{  					OnVehicleSpawned(new VehicleSpawnedEventArgs(new Tram(new IVehicle.Physics())' this));  					}  				}
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,TrafficVolumeForm,The following statement contains a magic number: this.splitContainer1.Panel2MinSize = 260;
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,TrafficVolumeForm,The following statement contains a magic number: renderOptions.clippingRect = new Rectangle(0' 0' 10000' 10000);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,TrafficVolumeForm,The following statement contains a magic number: renderOptions.clippingRect = new Rectangle(0' 0' 10000' 10000);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,UpdateListboxLayout,The following statement contains a magic number: int spacer = 4;
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,UpdateListboxLayout,The following statement contains a magic number: lbStartNodes.Location = new System.Drawing.Point(spacer' 26);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,UpdateListboxLayout,The following statement contains a magic number: lbStartNodes.Size = new System.Drawing.Size(totalWidth / 2 - spacer - spacer' totalHeight - 96);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,UpdateListboxLayout,The following statement contains a magic number: lbStartNodes.Size = new System.Drawing.Size(totalWidth / 2 - spacer - spacer' totalHeight - 96);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,UpdateListboxLayout,The following statement contains a magic number: lbDestinationNodes.Size = new System.Drawing.Size(totalWidth / 2 - spacer - spacer' totalHeight - 96);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,UpdateListboxLayout,The following statement contains a magic number: lbDestinationNodes.Size = new System.Drawing.Size(totalWidth / 2 - spacer - spacer' totalHeight - 96);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,UpdateListboxLayout,The following statement contains a magic number: lbDestinationNodes.Location = new System.Drawing.Point(totalWidth - spacer - lbDestinationNodes.Width' 26);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,UpdateListboxLayout,The following statement contains a magic number: label2.Location = new System.Drawing.Point(lbDestinationNodes.Location.X' 9);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,GetTrafficVolume,The following statement contains a magic number: if (start != null && destination != null)  				{  				m_currentVolume = m_steuerung.GetOrCreateTrafficVolume(start' destination);    				spinCarsVolume.Value = m_currentVolume.trafficVolumeCars;  				spinTruckVolume.Value = m_currentVolume.trafficVolumeTrucks;  				spinBusVolume.Value = m_currentVolume.trafficVolumeBusses;  				spinTramVolume.Value = m_currentVolume.trafficVolumeTrams;  				spinCarsVolume.Enabled = true;  				spinTruckVolume.Enabled = true;  				spinBusVolume.Enabled = true;  				spinTramVolume.Enabled = true;  				ignoreUpdateEvent = false;    				double milage = (m_currentVolume.statistics.sumMilage / m_currentVolume.statistics.numVehiclesReachedDestination) / 10;  				double tt = m_currentVolume.statistics.sumTravelTime / m_currentVolume.statistics.numVehiclesReachedDestination;  				if (m_currentVolume.statistics.numVehicles == 0)  					{  					milage = 0;  					tt = 1;  					}  				lblNumVehicles.Text = "Total Vehicles: " + m_currentVolume.statistics.numVehicles + " (" + m_currentVolume.statistics.numVehiclesReachedDestination + " reached Destination)";  				lblMilage.Text = "Average Milage: " + milage + "m";  				lblTravelTime.Text = "Average Travel Time: " + tt + "s";  				lblVelocity.Text = "Average Milage: " + (milage / tt) + "m/s";  				lblNumStops.Text = "Average Number of Stops: " + ((float)m_currentVolume.statistics.numStops / m_currentVolume.statistics.numVehicles);  				}  			else  				{  				m_currentVolume = null;  				spinCarsVolume.Enabled = false;  				spinTruckVolume.Enabled = false;  				spinBusVolume.Enabled = false;  				spinTramVolume.Enabled = false;  				lblNumVehicles.Text = "Total Vehicles: 0";  				lblMilage.Text = "Average Milage: 0m";  				lblTravelTime.Text = "Average Travel Time: 0s";  				lblVelocity.Text = "Average Milage: 0m/s";  				lblNumStops.Text = "Average Number of Stops: 0";  				}
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,groupBox1_SizeChanged,The following statement contains a magic number: splitContainer1.SplitterDistance = splitContainer1.ClientSize.Width - groupBox1.Width - 32;
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.splitContainer1.Size = new System.Drawing.Size(890' 459);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.splitContainer1.Size = new System.Drawing.Size(890' 459);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.splitContainer1.SplitterDistance = 600;
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.btnUpdateDestinationNodes.Location = new System.Drawing.Point(292' 292);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.btnUpdateDestinationNodes.Location = new System.Drawing.Point(292' 292);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.btnUpdateDestinationNodes.Size = new System.Drawing.Size(60' 23);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.btnUpdateDestinationNodes.Size = new System.Drawing.Size(60' 23);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.btnUpdateDestinationNodes.TabIndex = 10;
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.btnUpdateStartNodes.Location = new System.Drawing.Point(92' 366);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.btnUpdateStartNodes.Location = new System.Drawing.Point(92' 366);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.btnUpdateStartNodes.Size = new System.Drawing.Size(60' 23);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.btnUpdateStartNodes.Size = new System.Drawing.Size(60' 23);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.btnUpdateStartNodes.TabIndex = 4;
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.btnSetDestinationTitle.Location = new System.Drawing.Point(378' 264);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.btnSetDestinationTitle.Location = new System.Drawing.Point(378' 264);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.btnSetDestinationTitle.Size = new System.Drawing.Size(40' 23);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.btnSetDestinationTitle.Size = new System.Drawing.Size(40' 23);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.btnSetDestinationTitle.TabIndex = 8;
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.label1.Location = new System.Drawing.Point(12' 9);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.label1.Location = new System.Drawing.Point(12' 9);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.label1.Size = new System.Drawing.Size(66' 13);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.label1.Size = new System.Drawing.Size(66' 13);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.label1.TabIndex = 2;
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.btnSetStartTitle.Location = new System.Drawing.Point(178' 338);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.btnSetStartTitle.Location = new System.Drawing.Point(178' 338);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.btnSetStartTitle.Size = new System.Drawing.Size(40' 23);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.btnSetStartTitle.Size = new System.Drawing.Size(40' 23);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.btnSetStartTitle.TabIndex = 2;
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.lbStartNodes.Location = new System.Drawing.Point(12' 44);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.lbStartNodes.Location = new System.Drawing.Point(12' 44);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.lbStartNodes.Size = new System.Drawing.Size(206' 290);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.lbStartNodes.Size = new System.Drawing.Size(206' 290);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.lblDestinationTitle.Location = new System.Drawing.Point(216' 269);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.lblDestinationTitle.Location = new System.Drawing.Point(216' 269);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.lblDestinationTitle.Size = new System.Drawing.Size(30' 13);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.lblDestinationTitle.Size = new System.Drawing.Size(30' 13);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.lblDestinationTitle.TabIndex = 11;
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.lbDestinationNodes.Location = new System.Drawing.Point(270' 74);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.lbDestinationNodes.Location = new System.Drawing.Point(270' 74);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.lbDestinationNodes.Size = new System.Drawing.Size(148' 186);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.lbDestinationNodes.Size = new System.Drawing.Size(148' 186);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.lbDestinationNodes.TabIndex = 6;
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.lblStartTitle.Location = new System.Drawing.Point(16' 343);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.lblStartTitle.Location = new System.Drawing.Point(16' 343);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.lblStartTitle.Size = new System.Drawing.Size(30' 13);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.lblStartTitle.Size = new System.Drawing.Size(30' 13);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.lblStartTitle.TabIndex = 10;
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.label2.Location = new System.Drawing.Point(267' 9);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.label2.Location = new System.Drawing.Point(267' 9);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.label2.Size = new System.Drawing.Size(97' 13);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.label2.Size = new System.Drawing.Size(97' 13);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.label2.TabIndex = 3;
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.editDestinationNodeTitle.Location = new System.Drawing.Point(252' 266);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.editDestinationNodeTitle.Location = new System.Drawing.Point(252' 266);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.editDestinationNodeTitle.Size = new System.Drawing.Size(120' 20);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.editDestinationNodeTitle.Size = new System.Drawing.Size(120' 20);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.editDestinationNodeTitle.TabIndex = 7;
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.btnAddStartNode.Location = new System.Drawing.Point(26' 366);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.btnAddStartNode.Location = new System.Drawing.Point(26' 366);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.btnAddStartNode.Size = new System.Drawing.Size(60' 23);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.btnAddStartNode.Size = new System.Drawing.Size(60' 23);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.btnAddStartNode.TabIndex = 3;
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.editStartNodeTitle.Location = new System.Drawing.Point(52' 340);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.editStartNodeTitle.Location = new System.Drawing.Point(52' 340);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.editStartNodeTitle.Size = new System.Drawing.Size(120' 20);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.editStartNodeTitle.Size = new System.Drawing.Size(120' 20);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.btnRemoveStartNode.Location = new System.Drawing.Point(158' 366);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.btnRemoveStartNode.Location = new System.Drawing.Point(158' 366);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.btnRemoveStartNode.Size = new System.Drawing.Size(60' 23);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.btnRemoveStartNode.Size = new System.Drawing.Size(60' 23);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.btnRemoveStartNode.TabIndex = 5;
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.btnRemoveDestinationNode.Location = new System.Drawing.Point(358' 292);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.btnRemoveDestinationNode.Location = new System.Drawing.Point(358' 292);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.btnRemoveDestinationNode.Size = new System.Drawing.Size(60' 23);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.btnRemoveDestinationNode.Size = new System.Drawing.Size(60' 23);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.btnRemoveDestinationNode.TabIndex = 11;
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.btnAddDestinationNode.Location = new System.Drawing.Point(226' 292);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.btnAddDestinationNode.Location = new System.Drawing.Point(226' 292);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.btnAddDestinationNode.Size = new System.Drawing.Size(60' 23);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.btnAddDestinationNode.Size = new System.Drawing.Size(60' 23);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.btnAddDestinationNode.TabIndex = 9;
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.groupBox3.Location = new System.Drawing.Point(3' 293);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.groupBox3.Location = new System.Drawing.Point(3' 293);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.groupBox3.Size = new System.Drawing.Size(250' 153);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.groupBox3.Size = new System.Drawing.Size(250' 153);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.groupBox3.TabIndex = 23;
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.lblNumStops.Location = new System.Drawing.Point(6' 125);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.lblNumStops.Location = new System.Drawing.Point(6' 125);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.lblNumStops.Size = new System.Drawing.Size(141' 13);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.lblNumStops.Size = new System.Drawing.Size(141' 13);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.lblNumStops.TabIndex = 4;
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.lblNumVehicles.Location = new System.Drawing.Point(6' 21);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.lblNumVehicles.Location = new System.Drawing.Point(6' 21);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.lblNumVehicles.Size = new System.Drawing.Size(86' 13);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.lblNumVehicles.Size = new System.Drawing.Size(86' 13);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.lblNumVehicles.TabIndex = 3;
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.lblTravelTime.Location = new System.Drawing.Point(6' 73);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.lblTravelTime.Location = new System.Drawing.Point(6' 73);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.lblTravelTime.Size = new System.Drawing.Size(123' 13);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.lblTravelTime.Size = new System.Drawing.Size(123' 13);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.lblTravelTime.TabIndex = 2;
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.lblVelocity.Location = new System.Drawing.Point(6' 99);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.lblVelocity.Location = new System.Drawing.Point(6' 99);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.lblVelocity.Size = new System.Drawing.Size(117' 13);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.lblVelocity.Size = new System.Drawing.Size(117' 13);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.lblMilage.Location = new System.Drawing.Point(6' 47);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.lblMilage.Location = new System.Drawing.Point(6' 47);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.lblMilage.Size = new System.Drawing.Size(101' 13);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.lblMilage.Size = new System.Drawing.Size(101' 13);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.groupBox2.Location = new System.Drawing.Point(3' 135);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.groupBox2.Location = new System.Drawing.Point(3' 135);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.groupBox2.Size = new System.Drawing.Size(250' 152);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.groupBox2.Size = new System.Drawing.Size(250' 152);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.groupBox2.TabIndex = 22;
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.label11.Location = new System.Drawing.Point(6' 125);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.label11.Location = new System.Drawing.Point(6' 125);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.label11.Size = new System.Drawing.Size(135' 13);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.label11.Size = new System.Drawing.Size(135' 13);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.label11.TabIndex = 29;
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.label10.Location = new System.Drawing.Point(6' 99);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.label10.Location = new System.Drawing.Point(6' 99);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.label10.Size = new System.Drawing.Size(129' 13);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.label10.Size = new System.Drawing.Size(129' 13);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.label10.TabIndex = 28;
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.label9.Location = new System.Drawing.Point(6' 73);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.label9.Location = new System.Drawing.Point(6' 73);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.label9.Size = new System.Drawing.Size(139' 13);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.label9.Size = new System.Drawing.Size(139' 13);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.label9.TabIndex = 27;
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.label8.Location = new System.Drawing.Point(6' 47);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.label8.Location = new System.Drawing.Point(6' 47);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.label8.Size = new System.Drawing.Size(127' 13);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.label8.Size = new System.Drawing.Size(127' 13);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.label8.TabIndex = 26;
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.spinTramsTargetVelocity.Location = new System.Drawing.Point(161' 123);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.spinTramsTargetVelocity.Location = new System.Drawing.Point(161' 123);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.spinTramsTargetVelocity.Maximum = new decimal(new int[] {              1000'              0'              0'              0});
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.spinTramsTargetVelocity.Size = new System.Drawing.Size(83' 20);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.spinTramsTargetVelocity.Size = new System.Drawing.Size(83' 20);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.spinTramsTargetVelocity.TabIndex = 25;
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.spinTramsTargetVelocity.Value = new decimal(new int[] {              23'              0'              0'              0});
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.spinBussesTargetVelocity.Location = new System.Drawing.Point(161' 97);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.spinBussesTargetVelocity.Location = new System.Drawing.Point(161' 97);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.spinBussesTargetVelocity.Maximum = new decimal(new int[] {              1000'              0'              0'              0});
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.spinBussesTargetVelocity.Size = new System.Drawing.Size(83' 20);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.spinBussesTargetVelocity.Size = new System.Drawing.Size(83' 20);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.spinBussesTargetVelocity.TabIndex = 24;
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.spinBussesTargetVelocity.Value = new decimal(new int[] {              23'              0'              0'              0});
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.spinTrucksTargetVelocity.Location = new System.Drawing.Point(161' 71);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.spinTrucksTargetVelocity.Location = new System.Drawing.Point(161' 71);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.spinTrucksTargetVelocity.Maximum = new decimal(new int[] {              1000'              0'              0'              0});
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.spinTrucksTargetVelocity.Size = new System.Drawing.Size(83' 20);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.spinTrucksTargetVelocity.Size = new System.Drawing.Size(83' 20);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.spinTrucksTargetVelocity.TabIndex = 23;
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.spinTrucksTargetVelocity.Value = new decimal(new int[] {              23'              0'              0'              0});
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.spinCarsTargetVelocity.Location = new System.Drawing.Point(161' 45);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.spinCarsTargetVelocity.Location = new System.Drawing.Point(161' 45);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.spinCarsTargetVelocity.Maximum = new decimal(new int[] {              1000'              0'              0'              0});
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.spinCarsTargetVelocity.Size = new System.Drawing.Size(83' 20);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.spinCarsTargetVelocity.Size = new System.Drawing.Size(83' 20);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.spinCarsTargetVelocity.TabIndex = 22;
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.spinCarsTargetVelocity.Value = new decimal(new int[] {              36'              0'              0'              0});
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.spinGlobalTrafficVolumeMultiplier.Increment = new decimal(new int[] {              1'              0'              0'              65536});
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.spinGlobalTrafficVolumeMultiplier.Location = new System.Drawing.Point(161' 19);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.spinGlobalTrafficVolumeMultiplier.Location = new System.Drawing.Point(161' 19);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.spinGlobalTrafficVolumeMultiplier.Maximum = new decimal(new int[] {              10'              0'              0'              0});
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.spinGlobalTrafficVolumeMultiplier.Size = new System.Drawing.Size(83' 20);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.spinGlobalTrafficVolumeMultiplier.Size = new System.Drawing.Size(83' 20);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.spinGlobalTrafficVolumeMultiplier.TabIndex = 20;
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.label7.Location = new System.Drawing.Point(6' 21);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.label7.Location = new System.Drawing.Point(6' 21);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.label7.Size = new System.Drawing.Size(155' 13);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.label7.Size = new System.Drawing.Size(155' 13);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.label7.TabIndex = 21;
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.groupBox1.Location = new System.Drawing.Point(3' 3);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.groupBox1.Location = new System.Drawing.Point(3' 3);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.groupBox1.Size = new System.Drawing.Size(250' 126);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.groupBox1.Size = new System.Drawing.Size(250' 126);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.label6.Location = new System.Drawing.Point(6' 99);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.label6.Location = new System.Drawing.Point(6' 99);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.label6.Size = new System.Drawing.Size(67' 13);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.label6.Size = new System.Drawing.Size(67' 13);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.label6.TabIndex = 7;
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.label5.Location = new System.Drawing.Point(6' 73);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.label5.Location = new System.Drawing.Point(6' 73);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.label5.Size = new System.Drawing.Size(72' 13);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.label5.Size = new System.Drawing.Size(72' 13);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.label5.TabIndex = 6;
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.label4.Location = new System.Drawing.Point(6' 47);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.label4.Location = new System.Drawing.Point(6' 47);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.label4.Size = new System.Drawing.Size(71' 13);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.label4.Size = new System.Drawing.Size(71' 13);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.label4.TabIndex = 5;
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.label3.Location = new System.Drawing.Point(6' 21);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.label3.Location = new System.Drawing.Point(6' 21);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.label3.Size = new System.Drawing.Size(59' 13);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.label3.Size = new System.Drawing.Size(59' 13);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.label3.TabIndex = 4;
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.spinTruckVolume.Location = new System.Drawing.Point(161' 45);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.spinTruckVolume.Location = new System.Drawing.Point(161' 45);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.spinTruckVolume.Maximum = new decimal(new int[] {              100000'              0'              0'              0});
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.spinTruckVolume.Size = new System.Drawing.Size(83' 20);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.spinTruckVolume.Size = new System.Drawing.Size(83' 20);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.spinTruckVolume.TabIndex = 22;
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.spinTramVolume.Location = new System.Drawing.Point(161' 97);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.spinTramVolume.Location = new System.Drawing.Point(161' 97);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.spinTramVolume.Maximum = new decimal(new int[] {              100000'              0'              0'              0});
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.spinTramVolume.Size = new System.Drawing.Size(83' 20);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.spinTramVolume.Size = new System.Drawing.Size(83' 20);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.spinTramVolume.TabIndex = 24;
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.spinBusVolume.Location = new System.Drawing.Point(161' 71);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.spinBusVolume.Location = new System.Drawing.Point(161' 71);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.spinBusVolume.Maximum = new decimal(new int[] {              100000'              0'              0'              0});
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.spinBusVolume.Size = new System.Drawing.Size(83' 20);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.spinBusVolume.Size = new System.Drawing.Size(83' 20);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.spinBusVolume.TabIndex = 23;
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.spinCarsVolume.Location = new System.Drawing.Point(161' 19);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.spinCarsVolume.Location = new System.Drawing.Point(161' 19);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.spinCarsVolume.Maximum = new decimal(new int[] {              100000'              0'              0'              0});
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.spinCarsVolume.Size = new System.Drawing.Size(83' 20);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.spinCarsVolume.Size = new System.Drawing.Size(83' 20);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.spinCarsVolume.TabIndex = 21;
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(890' 459);
Magic Number,CityTrafficSimulator.Verkehr,TrafficVolumeForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\TrafficVolumeForm.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(890' 459);
Magic Number,CityTrafficSimulator.Verkehr,VerkehrSteuerung,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\VerkehrSteuerung.cs,ImportOldTrafficVolumeData,The following statement contains a magic number: foreach (Auftrag a in fahrauftraege)  				{  				BunchOfNodes startBof = GetOrCreateEqualBoF(a.startNodes' startPoints);  				BunchOfNodes destinationBof = GetOrCreateEqualBoF(a.endNodes' destinationPoints);    				TrafficVolume tv = GetOrCreateTrafficVolume(startBof' destinationBof);  				switch (a.vehicleType)  					{  					case CityTrafficSimulator.Vehicle.IVehicle.VehicleTypes.CAR:  						tv.SetTrafficVolume((int)(tv.trafficVolumeCars + a.trafficDensity * 0.92)' (int)(tv.trafficVolumeTrucks + a.trafficDensity * 0.08)' tv.trafficVolumeBusses' tv.trafficVolumeTrams);  						break;  					case CityTrafficSimulator.Vehicle.IVehicle.VehicleTypes.BUS:  						tv.SetTrafficVolume(tv.trafficVolumeCars' tv.trafficVolumeTrucks' tv.trafficVolumeBusses + a.trafficDensity' tv.trafficVolumeTrams);  						break;  					case CityTrafficSimulator.Vehicle.IVehicle.VehicleTypes.TRAM:  						tv.SetTrafficVolume(tv.trafficVolumeCars' tv.trafficVolumeTrucks' tv.trafficVolumeBusses' tv.trafficVolumeTrams + a.trafficDensity);  						break;  					}  				}
Magic Number,CityTrafficSimulator.Verkehr,VerkehrSteuerung,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\VerkehrSteuerung.cs,ImportOldTrafficVolumeData,The following statement contains a magic number: foreach (Auftrag a in fahrauftraege)  				{  				BunchOfNodes startBof = GetOrCreateEqualBoF(a.startNodes' startPoints);  				BunchOfNodes destinationBof = GetOrCreateEqualBoF(a.endNodes' destinationPoints);    				TrafficVolume tv = GetOrCreateTrafficVolume(startBof' destinationBof);  				switch (a.vehicleType)  					{  					case CityTrafficSimulator.Vehicle.IVehicle.VehicleTypes.CAR:  						tv.SetTrafficVolume((int)(tv.trafficVolumeCars + a.trafficDensity * 0.92)' (int)(tv.trafficVolumeTrucks + a.trafficDensity * 0.08)' tv.trafficVolumeBusses' tv.trafficVolumeTrams);  						break;  					case CityTrafficSimulator.Vehicle.IVehicle.VehicleTypes.BUS:  						tv.SetTrafficVolume(tv.trafficVolumeCars' tv.trafficVolumeTrucks' tv.trafficVolumeBusses + a.trafficDensity' tv.trafficVolumeTrams);  						break;  					case CityTrafficSimulator.Vehicle.IVehicle.VehicleTypes.TRAM:  						tv.SetTrafficVolume(tv.trafficVolumeCars' tv.trafficVolumeTrucks' tv.trafficVolumeBusses' tv.trafficVolumeTrams + a.trafficDensity);  						break;  					}  				}
Magic Number,CityTrafficSimulator.Verkehr,VerkehrSteuerung,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\VerkehrSteuerung.cs,LoadFromFile,The following statement contains a magic number: lf.SetupLowerProgess("Parsing XML..."' 3);
Magic Number,CityTrafficSimulator.Verkehr,VerkehrSteuerung,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\VerkehrSteuerung.cs,SpawnVehicle,The following statement contains a magic number: if (start.nextConnections.Count > 0)  				{  				int foo = GlobalRandom.Instance.Next(start.nextConnections.Count);  				NodeConnection nc = start.nextConnections[foo];    				e.vehicleToSpawn.state = new IVehicle.State(nc' 0);  				if (e.vehicleToSpawn.GetType() == typeof(Car))  					e.vehicleToSpawn.physics = new IVehicle.Physics(carTargetVelocity + ((GlobalRandom.Instance.NextDouble() - 0.5) * 4)' Math.Min(nc.targetVelocity' carTargetVelocity)' 0);  				else if (e.vehicleToSpawn.GetType() == typeof(Truck))  					e.vehicleToSpawn.physics = new IVehicle.Physics(truckTargetVelocity + ((GlobalRandom.Instance.NextDouble() - 0.5) * 4)' Math.Min(nc.targetVelocity' truckTargetVelocity)' 0);  				else if (e.vehicleToSpawn.GetType() == typeof(Tram))  					e.vehicleToSpawn.physics = new IVehicle.Physics(tramTargetVelocity + ((GlobalRandom.Instance.NextDouble() - 0.5) * 4)' Math.Min(nc.targetVelocity' tramTargetVelocity)' 0);  				else if (e.vehicleToSpawn.GetType() == typeof(Bus))  					e.vehicleToSpawn.physics = new IVehicle.Physics(busTargetVelocity + ((GlobalRandom.Instance.NextDouble() - 0.5) * 4)' Math.Min(nc.targetVelocity' busTargetVelocity)' 0);    				if (start.nextConnections[foo].AddVehicle(e.vehicleToSpawn))  					{  					e.vehicleToSpawn.targetNodes = e.tv.destinationNodes.nodes;  					e.vehicleToSpawn.VehicleDied += new IVehicle.VehicleDiedEventHandler(e.tv.SpawnedVehicleDied);  					return true;  					}  				}
Magic Number,CityTrafficSimulator.Verkehr,VerkehrSteuerung,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\VerkehrSteuerung.cs,SpawnVehicle,The following statement contains a magic number: if (start.nextConnections.Count > 0)  				{  				int foo = GlobalRandom.Instance.Next(start.nextConnections.Count);  				NodeConnection nc = start.nextConnections[foo];    				e.vehicleToSpawn.state = new IVehicle.State(nc' 0);  				if (e.vehicleToSpawn.GetType() == typeof(Car))  					e.vehicleToSpawn.physics = new IVehicle.Physics(carTargetVelocity + ((GlobalRandom.Instance.NextDouble() - 0.5) * 4)' Math.Min(nc.targetVelocity' carTargetVelocity)' 0);  				else if (e.vehicleToSpawn.GetType() == typeof(Truck))  					e.vehicleToSpawn.physics = new IVehicle.Physics(truckTargetVelocity + ((GlobalRandom.Instance.NextDouble() - 0.5) * 4)' Math.Min(nc.targetVelocity' truckTargetVelocity)' 0);  				else if (e.vehicleToSpawn.GetType() == typeof(Tram))  					e.vehicleToSpawn.physics = new IVehicle.Physics(tramTargetVelocity + ((GlobalRandom.Instance.NextDouble() - 0.5) * 4)' Math.Min(nc.targetVelocity' tramTargetVelocity)' 0);  				else if (e.vehicleToSpawn.GetType() == typeof(Bus))  					e.vehicleToSpawn.physics = new IVehicle.Physics(busTargetVelocity + ((GlobalRandom.Instance.NextDouble() - 0.5) * 4)' Math.Min(nc.targetVelocity' busTargetVelocity)' 0);    				if (start.nextConnections[foo].AddVehicle(e.vehicleToSpawn))  					{  					e.vehicleToSpawn.targetNodes = e.tv.destinationNodes.nodes;  					e.vehicleToSpawn.VehicleDied += new IVehicle.VehicleDiedEventHandler(e.tv.SpawnedVehicleDied);  					return true;  					}  				}
Magic Number,CityTrafficSimulator.Verkehr,VerkehrSteuerung,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\VerkehrSteuerung.cs,SpawnVehicle,The following statement contains a magic number: if (start.nextConnections.Count > 0)  				{  				int foo = GlobalRandom.Instance.Next(start.nextConnections.Count);  				NodeConnection nc = start.nextConnections[foo];    				e.vehicleToSpawn.state = new IVehicle.State(nc' 0);  				if (e.vehicleToSpawn.GetType() == typeof(Car))  					e.vehicleToSpawn.physics = new IVehicle.Physics(carTargetVelocity + ((GlobalRandom.Instance.NextDouble() - 0.5) * 4)' Math.Min(nc.targetVelocity' carTargetVelocity)' 0);  				else if (e.vehicleToSpawn.GetType() == typeof(Truck))  					e.vehicleToSpawn.physics = new IVehicle.Physics(truckTargetVelocity + ((GlobalRandom.Instance.NextDouble() - 0.5) * 4)' Math.Min(nc.targetVelocity' truckTargetVelocity)' 0);  				else if (e.vehicleToSpawn.GetType() == typeof(Tram))  					e.vehicleToSpawn.physics = new IVehicle.Physics(tramTargetVelocity + ((GlobalRandom.Instance.NextDouble() - 0.5) * 4)' Math.Min(nc.targetVelocity' tramTargetVelocity)' 0);  				else if (e.vehicleToSpawn.GetType() == typeof(Bus))  					e.vehicleToSpawn.physics = new IVehicle.Physics(busTargetVelocity + ((GlobalRandom.Instance.NextDouble() - 0.5) * 4)' Math.Min(nc.targetVelocity' busTargetVelocity)' 0);    				if (start.nextConnections[foo].AddVehicle(e.vehicleToSpawn))  					{  					e.vehicleToSpawn.targetNodes = e.tv.destinationNodes.nodes;  					e.vehicleToSpawn.VehicleDied += new IVehicle.VehicleDiedEventHandler(e.tv.SpawnedVehicleDied);  					return true;  					}  				}
Magic Number,CityTrafficSimulator.Verkehr,VerkehrSteuerung,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\VerkehrSteuerung.cs,SpawnVehicle,The following statement contains a magic number: if (start.nextConnections.Count > 0)  				{  				int foo = GlobalRandom.Instance.Next(start.nextConnections.Count);  				NodeConnection nc = start.nextConnections[foo];    				e.vehicleToSpawn.state = new IVehicle.State(nc' 0);  				if (e.vehicleToSpawn.GetType() == typeof(Car))  					e.vehicleToSpawn.physics = new IVehicle.Physics(carTargetVelocity + ((GlobalRandom.Instance.NextDouble() - 0.5) * 4)' Math.Min(nc.targetVelocity' carTargetVelocity)' 0);  				else if (e.vehicleToSpawn.GetType() == typeof(Truck))  					e.vehicleToSpawn.physics = new IVehicle.Physics(truckTargetVelocity + ((GlobalRandom.Instance.NextDouble() - 0.5) * 4)' Math.Min(nc.targetVelocity' truckTargetVelocity)' 0);  				else if (e.vehicleToSpawn.GetType() == typeof(Tram))  					e.vehicleToSpawn.physics = new IVehicle.Physics(tramTargetVelocity + ((GlobalRandom.Instance.NextDouble() - 0.5) * 4)' Math.Min(nc.targetVelocity' tramTargetVelocity)' 0);  				else if (e.vehicleToSpawn.GetType() == typeof(Bus))  					e.vehicleToSpawn.physics = new IVehicle.Physics(busTargetVelocity + ((GlobalRandom.Instance.NextDouble() - 0.5) * 4)' Math.Min(nc.targetVelocity' busTargetVelocity)' 0);    				if (start.nextConnections[foo].AddVehicle(e.vehicleToSpawn))  					{  					e.vehicleToSpawn.targetNodes = e.tv.destinationNodes.nodes;  					e.vehicleToSpawn.VehicleDied += new IVehicle.VehicleDiedEventHandler(e.tv.SpawnedVehicleDied);  					return true;  					}  				}
Magic Number,CityTrafficSimulator.Verkehr,VerkehrSteuerung,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\VerkehrSteuerung.cs,SpawnVehicle,The following statement contains a magic number: if (start.nextConnections.Count > 0)  				{  				int foo = GlobalRandom.Instance.Next(start.nextConnections.Count);  				NodeConnection nc = start.nextConnections[foo];    				e.vehicleToSpawn.state = new IVehicle.State(nc' 0);  				if (e.vehicleToSpawn.GetType() == typeof(Car))  					e.vehicleToSpawn.physics = new IVehicle.Physics(carTargetVelocity + ((GlobalRandom.Instance.NextDouble() - 0.5) * 4)' Math.Min(nc.targetVelocity' carTargetVelocity)' 0);  				else if (e.vehicleToSpawn.GetType() == typeof(Truck))  					e.vehicleToSpawn.physics = new IVehicle.Physics(truckTargetVelocity + ((GlobalRandom.Instance.NextDouble() - 0.5) * 4)' Math.Min(nc.targetVelocity' truckTargetVelocity)' 0);  				else if (e.vehicleToSpawn.GetType() == typeof(Tram))  					e.vehicleToSpawn.physics = new IVehicle.Physics(tramTargetVelocity + ((GlobalRandom.Instance.NextDouble() - 0.5) * 4)' Math.Min(nc.targetVelocity' tramTargetVelocity)' 0);  				else if (e.vehicleToSpawn.GetType() == typeof(Bus))  					e.vehicleToSpawn.physics = new IVehicle.Physics(busTargetVelocity + ((GlobalRandom.Instance.NextDouble() - 0.5) * 4)' Math.Min(nc.targetVelocity' busTargetVelocity)' 0);    				if (start.nextConnections[foo].AddVehicle(e.vehicleToSpawn))  					{  					e.vehicleToSpawn.targetNodes = e.tv.destinationNodes.nodes;  					e.vehicleToSpawn.VehicleDied += new IVehicle.VehicleDiedEventHandler(e.tv.SpawnedVehicleDied);  					return true;  					}  				}
Magic Number,CityTrafficSimulator.Verkehr,VerkehrSteuerung,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\VerkehrSteuerung.cs,SpawnVehicle,The following statement contains a magic number: if (start.nextConnections.Count > 0)  				{  				int foo = GlobalRandom.Instance.Next(start.nextConnections.Count);  				NodeConnection nc = start.nextConnections[foo];    				e.vehicleToSpawn.state = new IVehicle.State(nc' 0);  				if (e.vehicleToSpawn.GetType() == typeof(Car))  					e.vehicleToSpawn.physics = new IVehicle.Physics(carTargetVelocity + ((GlobalRandom.Instance.NextDouble() - 0.5) * 4)' Math.Min(nc.targetVelocity' carTargetVelocity)' 0);  				else if (e.vehicleToSpawn.GetType() == typeof(Truck))  					e.vehicleToSpawn.physics = new IVehicle.Physics(truckTargetVelocity + ((GlobalRandom.Instance.NextDouble() - 0.5) * 4)' Math.Min(nc.targetVelocity' truckTargetVelocity)' 0);  				else if (e.vehicleToSpawn.GetType() == typeof(Tram))  					e.vehicleToSpawn.physics = new IVehicle.Physics(tramTargetVelocity + ((GlobalRandom.Instance.NextDouble() - 0.5) * 4)' Math.Min(nc.targetVelocity' tramTargetVelocity)' 0);  				else if (e.vehicleToSpawn.GetType() == typeof(Bus))  					e.vehicleToSpawn.physics = new IVehicle.Physics(busTargetVelocity + ((GlobalRandom.Instance.NextDouble() - 0.5) * 4)' Math.Min(nc.targetVelocity' busTargetVelocity)' 0);    				if (start.nextConnections[foo].AddVehicle(e.vehicleToSpawn))  					{  					e.vehicleToSpawn.targetNodes = e.tv.destinationNodes.nodes;  					e.vehicleToSpawn.VehicleDied += new IVehicle.VehicleDiedEventHandler(e.tv.SpawnedVehicleDied);  					return true;  					}  				}
Magic Number,CityTrafficSimulator.Verkehr,VerkehrSteuerung,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\VerkehrSteuerung.cs,SpawnVehicle,The following statement contains a magic number: if (start.nextConnections.Count > 0)  				{  				int foo = GlobalRandom.Instance.Next(start.nextConnections.Count);  				NodeConnection nc = start.nextConnections[foo];    				e.vehicleToSpawn.state = new IVehicle.State(nc' 0);  				if (e.vehicleToSpawn.GetType() == typeof(Car))  					e.vehicleToSpawn.physics = new IVehicle.Physics(carTargetVelocity + ((GlobalRandom.Instance.NextDouble() - 0.5) * 4)' Math.Min(nc.targetVelocity' carTargetVelocity)' 0);  				else if (e.vehicleToSpawn.GetType() == typeof(Truck))  					e.vehicleToSpawn.physics = new IVehicle.Physics(truckTargetVelocity + ((GlobalRandom.Instance.NextDouble() - 0.5) * 4)' Math.Min(nc.targetVelocity' truckTargetVelocity)' 0);  				else if (e.vehicleToSpawn.GetType() == typeof(Tram))  					e.vehicleToSpawn.physics = new IVehicle.Physics(tramTargetVelocity + ((GlobalRandom.Instance.NextDouble() - 0.5) * 4)' Math.Min(nc.targetVelocity' tramTargetVelocity)' 0);  				else if (e.vehicleToSpawn.GetType() == typeof(Bus))  					e.vehicleToSpawn.physics = new IVehicle.Physics(busTargetVelocity + ((GlobalRandom.Instance.NextDouble() - 0.5) * 4)' Math.Min(nc.targetVelocity' busTargetVelocity)' 0);    				if (start.nextConnections[foo].AddVehicle(e.vehicleToSpawn))  					{  					e.vehicleToSpawn.targetNodes = e.tv.destinationNodes.nodes;  					e.vehicleToSpawn.VehicleDied += new IVehicle.VehicleDiedEventHandler(e.tv.SpawnedVehicleDied);  					return true;  					}  				}
Magic Number,CityTrafficSimulator.Verkehr,VerkehrSteuerung,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\VerkehrSteuerung.cs,SpawnVehicle,The following statement contains a magic number: if (start.nextConnections.Count > 0)  				{  				int foo = GlobalRandom.Instance.Next(start.nextConnections.Count);  				NodeConnection nc = start.nextConnections[foo];    				e.vehicleToSpawn.state = new IVehicle.State(nc' 0);  				if (e.vehicleToSpawn.GetType() == typeof(Car))  					e.vehicleToSpawn.physics = new IVehicle.Physics(carTargetVelocity + ((GlobalRandom.Instance.NextDouble() - 0.5) * 4)' Math.Min(nc.targetVelocity' carTargetVelocity)' 0);  				else if (e.vehicleToSpawn.GetType() == typeof(Truck))  					e.vehicleToSpawn.physics = new IVehicle.Physics(truckTargetVelocity + ((GlobalRandom.Instance.NextDouble() - 0.5) * 4)' Math.Min(nc.targetVelocity' truckTargetVelocity)' 0);  				else if (e.vehicleToSpawn.GetType() == typeof(Tram))  					e.vehicleToSpawn.physics = new IVehicle.Physics(tramTargetVelocity + ((GlobalRandom.Instance.NextDouble() - 0.5) * 4)' Math.Min(nc.targetVelocity' tramTargetVelocity)' 0);  				else if (e.vehicleToSpawn.GetType() == typeof(Bus))  					e.vehicleToSpawn.physics = new IVehicle.Physics(busTargetVelocity + ((GlobalRandom.Instance.NextDouble() - 0.5) * 4)' Math.Min(nc.targetVelocity' busTargetVelocity)' 0);    				if (start.nextConnections[foo].AddVehicle(e.vehicleToSpawn))  					{  					e.vehicleToSpawn.targetNodes = e.tv.destinationNodes.nodes;  					e.vehicleToSpawn.VehicleDied += new IVehicle.VehicleDiedEventHandler(e.tv.SpawnedVehicleDied);  					return true;  					}  				}
Duplicate Code,CityTrafficSimulator,Routing,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Routing.cs,CalculateShortestConenction,The method contains a code clone-set at the following line numbers (starting from the method definition): ((93' 117)' (166' 190))
Duplicate Code,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,DaGrid_MouseDown,The method contains a code clone-set at the following line numbers (starting from the method definition): ((45' 68)' (97' 120))
Duplicate Code,CityTrafficSimulator,NodeSteuerung,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\NodeSteuerung.cs,FindLineChangePoints,The method contains a code clone-set at the following line numbers (starting from the method definition): ((56' 83)' (102' 129))
Missing Default,CityTrafficSimulator,Auftrag,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Auftrag.cs,CreateVehicle,The following switch statement is missing a default case: switch (m_vehicleType)  				{  				case IVehicle.VehicleTypes.CAR:  					if (GlobalRandom.Instance.Next(100) < truckRatio)  						{  						v = new Truck(p);  						}  					else  						{  						v = new Car(p);  						}					  					break;  				case IVehicle.VehicleTypes.TRAM:  					v = new Tram(p);  					break;  				case IVehicle.VehicleTypes.BUS:  					v = new Bus(p);  					break;  				}
Missing Default,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,DaGrid_MouseDown,The following switch statement is missing a default case: switch (e.Button)  				{  				case MouseButtons.Left:  					this.Cursor = Cursors.Default;    					#region Nodes hinzufügen  					if ((Control.ModifierKeys & Keys.Control) == Keys.Control)  						{  						// LineNode hinzufügen  						List<LineNode> nodesToAdd = new List<LineNode>(m_selectedLineNodes.Count);  						selectedLineNodesMovingOffset.Clear();    						// testen ob ein Node schon markiert ist  						if (selectedLineNodes.Count > 0)  							{  							// Mittelpunkt des selektierten LineNodes ermitteln  							Vector2 midpoint = new Vector2(0' 0);  							foreach (LineNode ln in selectedLineNodes)  								{  								midpoint += ln.position;  								}  							midpoint *= (double)1 / selectedLineNodes.Count;    							// Line Node nach SelectedLineNode einfügen  							if (!((Control.ModifierKeys & Keys.Shift) == Keys.Shift))  								{  								// ersten Line Node erstellen  								nodesToAdd.Add(new LineNode(DaGrid.DockToGrid(clickedPosition' dockToGrid)' cbNetworkLayer.SelectedItem as NetworkLayer' cbStopSign.Checked));  								selectedLineNodesMovingOffset.Add(m_selectedLineNodes[0].outSlope);    								// in/outSlope berechnen  								nodesToAdd[0].outSlope = 30 * Vector2.Normalize(nodesToAdd[0].position - midpoint);  								nodesToAdd[0].inSlope = -1 * nodesToAdd[0].outSlope;    								// Connecten  								nodeSteuerung.Connect(  									m_selectedLineNodes[0]'  									nodesToAdd[0]'  									(int)nodeConnectionPrioritySpinEdit.Value'  									(double)spinTargetVelocity.Value'  									carsAllowedCheckBox.Checked'  									busAllowedCheckBox.Checked'  									tramAllowedCheckBox.Checked'  									enableIncomingLineChangeCheckBox.Checked'  									enableOutgoingLineChangeCheckBox.Checked);      								// nun die restlichen LineNodes parallel erstellen  								for (int i = 1; i < m_selectedLineNodes.Count; i++)  									{  									Vector2 offset = m_selectedLineNodes[0].position - m_selectedLineNodes[i].position;  									selectedLineNodesMovingOffset.Add(offset);    									// Line Node erstellen  									nodesToAdd.Add(new LineNode(DaGrid.DockToGrid(clickedPosition - offset' dockToGrid)' cbNetworkLayer.SelectedItem as NetworkLayer' cbStopSign.Checked));    									// in/outSlope berechnen  									nodesToAdd[i].outSlope = 30 * Vector2.Normalize(nodesToAdd[i].position - midpoint);  									nodesToAdd[i].inSlope = -1 * nodesToAdd[i].outSlope;    									// Connecten  									nodeSteuerung.Connect(  										m_selectedLineNodes[i]'  										nodesToAdd[i]'  										(int)nodeConnectionPrioritySpinEdit.Value'  										(double)spinTargetVelocity.Value'  										carsAllowedCheckBox.Checked'  										busAllowedCheckBox.Checked'  										tramAllowedCheckBox.Checked'  										enableIncomingLineChangeCheckBox.Checked'  										enableOutgoingLineChangeCheckBox.Checked);    									}  								}  							// Line Node vor SelectedLineNode einfügen  							else  								{  								// ersten Line Node erstellen  								nodesToAdd.Add(new LineNode(DaGrid.DockToGrid(clickedPosition' dockToGrid)' cbNetworkLayer.SelectedItem as NetworkLayer' cbStopSign.Checked));  								selectedLineNodesMovingOffset.Add(m_selectedLineNodes[0].outSlope);      								// in/outSlope berechnen  								nodesToAdd[0].outSlope = 30 * Vector2.Normalize(nodesToAdd[0].position - midpoint);  								nodesToAdd[0].inSlope = -1 * nodesToAdd[0].outSlope;    								// Connecten  								nodeSteuerung.Connect(  									nodesToAdd[0]'  									m_selectedLineNodes[0]'  									(int)nodeConnectionPrioritySpinEdit.Value'  									(double)spinTargetVelocity.Value'  									carsAllowedCheckBox.Checked'  									busAllowedCheckBox.Checked'  									tramAllowedCheckBox.Checked'  									enableIncomingLineChangeCheckBox.Checked'  									enableOutgoingLineChangeCheckBox.Checked);      								// nun die restlichen LineNodes parallel erstellen  								for (int i = 1; i < m_selectedLineNodes.Count; i++)  									{  									Vector2 offset = m_selectedLineNodes[0].position - m_selectedLineNodes[i].position;  									selectedLineNodesMovingOffset.Add(offset);    									// Line Node erstellen  									nodesToAdd.Add(new LineNode(DaGrid.DockToGrid(clickedPosition - offset' dockToGrid)' cbNetworkLayer.SelectedItem as NetworkLayer' cbStopSign.Checked));    									// in/outSlope berechnen  									nodesToAdd[i].outSlope = 30 * Vector2.Normalize(nodesToAdd[i].position - midpoint);  									nodesToAdd[i].inSlope = -1 * nodesToAdd[i].outSlope;    									// Connecten  									nodeSteuerung.Connect(  										nodesToAdd[i]'  										m_selectedLineNodes[i]'  										(int)nodeConnectionPrioritySpinEdit.Value'  										(double)spinTargetVelocity.Value'  										carsAllowedCheckBox.Checked'  										busAllowedCheckBox.Checked'  										tramAllowedCheckBox.Checked'  										enableIncomingLineChangeCheckBox.Checked'  										enableOutgoingLineChangeCheckBox.Checked);    									}  								}  							}  						else  							{  							// ersten Line Node erstellen  							nodesToAdd.Add(new LineNode(DaGrid.DockToGrid(clickedPosition' dockToGrid)' cbNetworkLayer.SelectedItem as NetworkLayer' cbStopSign.Checked));  							selectedLineNodesMovingOffset.Add(new Vector2(0' 0));  							}    						previousSelectedNodePositions.Clear();  						foreach (LineNode ln in m_selectedLineNodes)  							{  							previousSelectedNodePositions.Add(ln.position);  							}    						selectedLineNodes.Clear();  						foreach (LineNode ln in nodesToAdd)  							{  							nodeSteuerung.AddLineNode(ln);  							selectedLineNodes.Add(ln);  							}  						howToDrag = DragNDrop.CREATE_NODE;  						}  					#endregion    					#region Nodes Verbinden  					else if (((Control.ModifierKeys & Keys.Alt) == Keys.Alt) && (selectedLineNodes != null))  						{  						LineNode nodeToConnectTo = nodeSteuerung.GetLineNodeAt(clickedPosition);    						if (nodeToConnectTo != null)  							{  							foreach (LineNode ln in selectedLineNodes)  								{  								nodeSteuerung.Connect(  									ln'   									nodeToConnectTo'   									(int)nodeConnectionPrioritySpinEdit.Value'  									(double)spinTargetVelocity.Value'  									carsAllowedCheckBox.Checked'   									busAllowedCheckBox.Checked'   									tramAllowedCheckBox.Checked'   									enableIncomingLineChangeCheckBox.Checked'  									enableOutgoingLineChangeCheckBox.Checked);  								}						  							}  						}  					#endregion    					#region Nodes selektieren bzw. verschieben  					else  						{  						bool found = false;    						if (!lockNodesCheckBox.Checked)  							{  							// erst gucken' ob evtl. In/OutSlopes angeklickt wurden  							if (selectedLineNodes != null && selectedLineNodes.Count >= 1)  								{  									if (m_selectedLineNodes[0].inSlopeRect.Contains(clickedPosition))  										{  										originalSlopes.Clear();  										foreach (LineNode ln in m_selectedLineNodes)  											{  											originalSlopes.Add(ln.inSlope);  											}  										  										howToDrag = DragNDrop.MOVE_IN_SLOPE;  										found = true;  										}  									if (m_selectedLineNodes[0].outSlopeRect.Contains(clickedPosition))  										{  										originalSlopes.Clear();  										foreach (LineNode ln in m_selectedLineNodes)  											{  											originalSlopes.Add(ln.outSlope);  											}    										howToDrag = DragNDrop.MOVE_OUT_SLOPE;  										found = true;  										}  								}  							}    						if (! found)  							{  							LineNode ln = nodeSteuerung.GetLineNodeAt(clickedPosition);  							if (ln != null && !lockNodesCheckBox.Checked)  								{  								if (selectedLineNodes.Contains(ln))  									{  									// MovingOffsets berechnen:  									selectedLineNodesMovingOffset.Clear();  									foreach (LineNode lln in m_selectedLineNodes)  										{  										selectedLineNodesMovingOffset.Add(lln.position - clickedPosition);  										}    									howToDrag = DragNDrop.MOVE_NODES;  									}  								else  									{  									// bei nur einem Punkt brauchen wir keine MovingOffsets  									selectedLineNodesMovingOffset.Clear();  									selectedLineNodesMovingOffset.Add(new Vector2(0' 0));    									// Häßlicher Workaround' um Settermethode für selectedLineNodes aufzurufen  									List<LineNode> foo = new List<LineNode>();   									foo.Add(ln);  									selectedLineNodes = foo;    									howToDrag = DragNDrop.MOVE_NODES;  									}  								}  							else  								{  								howToDrag = DragNDrop.DRAG_RUBBERBAND;    								daGridRubberband.Location = clickedPosition;  								daGridRubberband.Width = 1;  								daGridRubberband.Height = 1;  								}  							}  						}  					#endregion  					break;  				case MouseButtons.Right:  					if ((Control.ModifierKeys & Keys.Control) == Keys.Control)  						{  						#region Nodes löschen  						this.Cursor = Cursors.Default;  						// LineNode entfernen  						LineNode nodeToDelete = nodeSteuerung.GetLineNodeAt(clickedPosition);  						// checken ob gefunden  						if (nodeToDelete != null)  							{  							if (selectedLineNodes.Contains(nodeToDelete))  								{  								selectedLineNodes.Remove(nodeToDelete);  								}  							nodeSteuerung.DeleteLineNode(nodeToDelete);  							}  						#endregion  						}  					else  						{  						#region move main grid  						howToDrag = DragNDrop.MOVE_MAIN_GRID;  						daGridRubberband.Location = clickedPosition;  						this.Cursor = Cursors.SizeAll;  						#endregion  						}    					break;  				case MouseButtons.XButton1:  					daGridScrollPosition.Y += 10 * e.Delta;  					UpdateDaGridClippingRect();  					DaGrid.Invalidate();  					thumbGrid.Invalidate();  					break;  				}
Missing Default,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,DaGrid_KeyDown,The following switch statement is missing a default case: switch (e.KeyCode)  				{  			#region Nodes verschieben  			// Node verschieben  			case Keys.Left:  				foreach (LineNode ln in selectedLineNodes)  					{  					ln.position.X -= 1;  					e.Handled = true;  					Invalidate(InvalidationLevel.ONLY_MAIN_CANVAS);  					}  				break;  			case Keys.Right:  				foreach (LineNode ln in selectedLineNodes)  					{  					ln.position.X += 1;  					e.Handled = true;  					Invalidate(InvalidationLevel.ONLY_MAIN_CANVAS);  					}  				break;  			case Keys.Up:  				foreach (LineNode ln in selectedLineNodes)  					{  					ln.position.Y -= 1;  					e.Handled = true;  					Invalidate(InvalidationLevel.ONLY_MAIN_CANVAS);  					}  				break;  			case Keys.Down:  				foreach (LineNode ln in selectedLineNodes)  					{  					ln.position.Y += 1;  					e.Handled = true;  					Invalidate(InvalidationLevel.ONLY_MAIN_CANVAS);  					}  				break;  			#endregion    			#region Nodes durchwandern  			// TODO: nächster Node  			case Keys.PageDown:  				break;  			// TODO: vorheriger Node  			case Keys.PageUp:  				break;  			#endregion    			#region Nodes bearbeiten  			// Node löschen  			case Keys.Delete:  				if (selectedVehicle != null)  					{  					selectedVehicle.currentNodeConnection.RemoveVehicle(selectedVehicle);  					}  				else // do not delete nodes and connections when vehicle selected!  					{  					foreach (LineNode ln in selectedLineNodes)  						{  						nodeSteuerung.DeleteLineNode(ln);  						}  					selectedLineNodes.Clear();  					e.Handled = true;  					Invalidate(InvalidationLevel.ONLY_MAIN_CANVAS);    					if (selectedNodeConnection != null)  						{  						nodeSteuerung.Disconnect(selectedNodeConnection.startNode' selectedNodeConnection.endNode);  						selectedNodeConnection = null;  						e.Handled = true;  						Invalidate(InvalidationLevel.ONLY_MAIN_CANVAS);  						}  					}  				break;    			// LineSegment teilen  			case Keys.S:  				if (selectedNodeConnection != null)  					{  					nodeSteuerung.SplitNodeConnection(selectedNodeConnection);  					selectedNodeConnection = null;  					Invalidate(InvalidationLevel.ONLY_MAIN_CANVAS);  					}  				break;  			case Keys.Return:  				if (selectedNodeConnection != null)  					{  					nodeSteuerung.RemoveLineChangePoints(selectedNodeConnection' true' false);  					nodeSteuerung.FindLineChangePoints(selectedNodeConnection' Constants.maxDistanceToLineChangePoint' Constants.maxDistanceToParallelConnection);  					Invalidate(InvalidationLevel.ONLY_MAIN_CANVAS);  					}  				break;    			case Keys.C:  				if (selectedNodeConnection != null)  					{  					carsAllowedCheckBox.Checked = !carsAllowedCheckBox.Checked;  					}  				break;  			case Keys.B:  				if (selectedNodeConnection != null)  					{  					busAllowedCheckBox.Checked = !busAllowedCheckBox.Checked;  					}  				break;  			case Keys.T:  				if (selectedNodeConnection != null)  					{  					tramAllowedCheckBox.Checked = !tramAllowedCheckBox.Checked;  					}  				break;    			case Keys.O:  				if (selectedNodeConnection != null)  					{  					enableOutgoingLineChangeCheckBox.Checked = !enableOutgoingLineChangeCheckBox.Checked;  					enableOutgoingLineChangeCheckBox_Click(this' new EventArgs());  					}  				break;  			case Keys.I:  				if (selectedNodeConnection != null)  					{  					enableIncomingLineChangeCheckBox.Checked = !enableIncomingLineChangeCheckBox.Checked;  					enableIncomingLineChangeCheckBox_Click(this' new EventArgs());  					}  				break;    			// reset LineNode slopes  			case Keys.R:  				foreach (LineNode ln in selectedLineNodes)  					{  					if (!ln.outSlope.IsZeroVector() && !ln.inSlope.IsZeroVector())  						{  						ln.outSlope = ln.outSlope.Normalized * 32;  						ln.inSlope = ln.inSlope.Normalized * 32;  						}  					}  				Invalidate(InvalidationLevel.ONLY_MAIN_CANVAS);  				break;  			#endregion    			#region from-/toLineNodes setzen    			case Keys.V:  				fromLineNodes.Clear();  				foreach (LineNode ln in selectedLineNodes)  					{  					fromLineNodes.Add(ln);  					}  				Invalidate(InvalidationLevel.ONLY_MAIN_CANVAS);  				break;    			case Keys.N:  				toLineNodes.Clear();  				foreach (LineNode ln in selectedLineNodes)  					{  					toLineNodes.Add(ln);  					}  				Invalidate(InvalidationLevel.ONLY_MAIN_CANVAS);  				break;  			#endregion    			#region Zoomfaktor ändern  			case Keys.P:  				if (selectedNodeConnection != null)  					{  					nodeConnectionPrioritySpinEdit.Value++;  					break;  					}  				if (((Control.ModifierKeys & Keys.Control) == Keys.Control) && zoomComboBox.SelectedIndex < zoomComboBox.Items.Count - 1)  					{  					zoomComboBox.SelectedIndex += 1;  					}  				break;    			case Keys.M:  				if (selectedNodeConnection != null)  					{  					nodeConnectionPrioritySpinEdit.Value--;  					break;  					}  				if (((Control.ModifierKeys & Keys.Control) == Keys.Control) && zoomComboBox.SelectedIndex > 0)  					{  					zoomComboBox.SelectedIndex -= 1;  					}  				break;    			case Keys.Add:  				if (selectedNodeConnection != null)  					{  					nodeConnectionPrioritySpinEdit.Value++;  					break;  					}  				if (((Control.ModifierKeys & Keys.Control) == Keys.Control) && zoomComboBox.SelectedIndex < zoomComboBox.Items.Count - 1)  					{  					zoomComboBox.SelectedIndex += 1;  					}  				break;    			case Keys.Subtract:  				if (selectedNodeConnection != null)  					{  					nodeConnectionPrioritySpinEdit.Value--;  					break;  					}  				if (((Control.ModifierKeys & Keys.Control) == Keys.Control) && zoomComboBox.SelectedIndex > 0)  					{  					zoomComboBox.SelectedIndex -= 1;  					}  				break;    			#endregion      			#region Connections bearbeiten    			#endregion  			case Keys.D:  				  				break;  				}
Missing Default,CityTrafficSimulator,MainForm,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\MainForm\MainForm.cs,DaGrid_Paint,The following switch statement is missing a default case: switch (renderQualityComboBox.SelectedIndex)  				{  				case 0:  					e.Graphics.SmoothingMode = SmoothingMode.HighQuality;  					e.Graphics.InterpolationMode = InterpolationMode.HighQualityBicubic;  					break;  				case 1:  					e.Graphics.SmoothingMode = SmoothingMode.HighSpeed;  					e.Graphics.InterpolationMode = InterpolationMode.Low;  					break;  				}
Missing Default,CityTrafficSimulator,LineNode,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\LineNode.cs,Draw,The following switch statement is missing a default case: switch (tLight.trafficLightState)  					{  					case TrafficLight.State.GREEN:  						g.FillRectangle(greenBrush' positionRect);  						break;  					case TrafficLight.State.RED:  						g.FillRectangle(redBrush' positionRect);  						break;  					}
Missing Default,CityTrafficSimulator,TimelineControl,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Timeline\TimelineControl.cs,TimelineControl_MouseDown,The following switch statement is missing a default case: switch (e.Button)  							{  						case MouseButtons.Left:  							#region TimelineEvent hinzufügen  							if ((Control.ModifierKeys & Keys.Control) == Keys.Control)  								{  								double time = GetTimeAtControlPosition(e.Location' true);    								// Event hinzufügen' welches die Ampel umschaltet  								TimelineEvent eventToAdd = new TimelineEvent(time' Math.Min(1' (m_selectedEntry.GetTimeOfNextEvent(time) - time) / 2)' Color.Green' tl.SwitchToGreen' tl.SwitchToRed);  								m_selectedEntry.AddEvent(eventToAdd' true' false);    								howToDrag = DragNDrop.MOVE_EVENT_END;  								eventToDrag = eventToAdd;  								this.Cursor = Cursors.SizeWE;  								Invalidate();  								}  							#endregion    							#region TimelineEntry selektieren  							else  								{  								// Drag'n'Drop für Events initialisieren  								TimelineEvent theEvent = GetTimelineEventAtControlPosition(e.Location' true);  								if (theEvent != null)  									{  									if (Math.Abs(GetClientPositionForTimelineEvent(theEvent).X - e.Location.X) < 3)  										{  										howToDrag = DragNDrop.MOVE_EVENT_START;  										eventToDrag = theEvent;  										}  									else if (Math.Abs(GetClientPositionForTimelineEvent(theEvent).X + theEvent.eventLength * zoom - e.Location.X) < 3)  										{  										howToDrag = DragNDrop.MOVE_EVENT_END;  										eventToDrag = theEvent;  										}  									else  										{  										mouseDownPosition = e.Location;  										eventToDragOffset = GetClientPositionForTimelineEvent(theEvent).X - e.Location.X;  										howToDrag = DragNDrop.MOVE_EVENT;  										eventToDrag = theEvent;  										}  									}    								}  							#endregion  							break;    						case MouseButtons.Right:  							#region TimelineEvent entfernen  							if ((Control.ModifierKeys & Keys.Control) == Keys.Control)  								{  								double time = GetTimeAtControlPosition(e.Location' false);    								TimelineEvent eventToRemove = tl.GetEventAtTime(time);  								tl.RemoveEvent(eventToRemove);  								}  							#endregion  							break;  							}
Missing Default,CityTrafficSimulator.Verkehr,VerkehrSteuerung,C:\repos\Schulteatq_CityTrafficSimulator\CityTrafficSimulator\Verkehr\VerkehrSteuerung.cs,ImportOldTrafficVolumeData,The following switch statement is missing a default case: switch (a.vehicleType)  					{  					case CityTrafficSimulator.Vehicle.IVehicle.VehicleTypes.CAR:  						tv.SetTrafficVolume((int)(tv.trafficVolumeCars + a.trafficDensity * 0.92)' (int)(tv.trafficVolumeTrucks + a.trafficDensity * 0.08)' tv.trafficVolumeBusses' tv.trafficVolumeTrams);  						break;  					case CityTrafficSimulator.Vehicle.IVehicle.VehicleTypes.BUS:  						tv.SetTrafficVolume(tv.trafficVolumeCars' tv.trafficVolumeTrucks' tv.trafficVolumeBusses + a.trafficDensity' tv.trafficVolumeTrams);  						break;  					case CityTrafficSimulator.Vehicle.IVehicle.VehicleTypes.TRAM:  						tv.SetTrafficVolume(tv.trafficVolumeCars' tv.trafficVolumeTrucks' tv.trafficVolumeBusses' tv.trafficVolumeTrams + a.trafficDensity);  						break;  					}
