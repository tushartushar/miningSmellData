Implementation smell,Namespace,Class,File,Method,Description
Long Method,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The method has 489 lines of code.
Long Method,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,ReverseIME,The method has 226 lines of code.
Complex Method,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,Cyclomatic complexity of the method is 76
Complex Method,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,ReverseIME,Cyclomatic complexity of the method is 205
Long Parameter List,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,FindAoBInFile,The method has 6 parameters.
Long Identifier,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The length of the parameter offset_StringPool__GetString_uint_char is 38.
Long Identifier,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The length of the parameter offset_StringPool__GetString_uint is 33.
Long Identifier,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The length of the parameter offset_StringPool__GetString_uint_ushort is 40.
Long Identifier,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The length of the parameter offset_StringPool__GetBSTR_uint is 31.
Long Identifier,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The length of the parameter offset_StringPool__GetStringW_uint is 34.
Long Identifier,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The length of the parameter offset_CStringDecoder__DelayedLoad is 34.
Long Statement,StringDec,Form1,C:\repos\wahlao_StringDec\Form1.cs,dataGridView1_CellEndEdit,The length of the statement  "	Program.EncodeString (int.Parse (dataGridView1.Rows [e.RowIndex].Cells [0].Value.ToString ())' dataGridView1.Rows [e.RowIndex].Cells [1].Value.ToString ()); " is 156.
Long Statement,StringDec,Form1,C:\repos\wahlao_StringDec\Form1.cs,saveToolStripMenuItem_Click,The length of the statement  "		MessageBox.Show ("Save complete to " + saveFileDialog1.FileName' "Save Complete"' MessageBoxButtons.OK' MessageBoxIcon.Information); " is 132.
Long Statement,StringDec,Form1,C:\repos\wahlao_StringDec\Form1.cs,xMLToolStripMenuItem_Click,The length of the statement  "		MessageBox.Show ("Exported XML to " + saveFileDialog1.FileName' "Save Complete"' MessageBoxButtons.OK' MessageBoxIcon.Information); " is 131.
Long Statement,StringDec,Form1,C:\repos\wahlao_StringDec\Form1.cs,cSVToolStripMenuItem_Click,The length of the statement  "			sb.AppendLine (string.Format ("{0}'\"{1}\"'\"{2}\""' ((DataGridViewRow)row).Cells [0].Value' ((DataGridViewRow)row).Cells [1].Value' ((DataGridViewRow)row).Cells [2].Value)); " is 174.
Long Statement,StringDec,Form1,C:\repos\wahlao_StringDec\Form1.cs,cSVToolStripMenuItem_Click,The length of the statement  "		MessageBox.Show ("Exported CSV to " + saveFileDialog1.FileName' "Save Complete"' MessageBoxButtons.OK' MessageBoxIcon.Information); " is 131.
Long Statement,StringDec,Form1,C:\repos\wahlao_StringDec\Form1.cs,cHeaderFileToolStripMenuItem_Click,The length of the statement  "			string s = Program.ReverseIME (new string (Array.FindAll<char> (((DataGridViewRow)row).Cells [1].Value.ToString ().ToCharArray ()' x => char.IsLetterOrDigit (x) || x == ' '))); " is 176.
Long Statement,StringDec,Form1,C:\repos\wahlao_StringDec\Form1.cs,cHeaderFileToolStripMenuItem_Click,The length of the statement  "			sb.AppendLine (string.Format ("\tSP_{0}_{1:S30} = {0}'"' ((DataGridViewRow)row).Cells [0].Value' Encoding.ASCII.GetString (Encoding.ASCII.GetBytes (s.ToCharArray ()' 0' s.Length > 50 ? 50 : s.Length)).Replace ('?'' '_').Replace (' '' '_'))); " is 241.
Long Statement,StringDec,Form1,C:\repos\wahlao_StringDec\Form1.cs,cHeaderFileToolStripMenuItem_Click,The length of the statement  "		MessageBox.Show ("Exported header to " + saveFileDialog1.FileName' "Save Complete"' MessageBoxButtons.OK' MessageBoxIcon.Information); " is 134.
Long Statement,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The length of the statement  "		if (MessageBox.Show ("Failed to determine location of StringPool::ms_aKey.\r\nAttempt StringDecoder method? [Y/n]"' "Error"' MessageBoxButtons.YesNo' MessageBoxIcon.Error) == DialogResult.Yes) " is 192.
Long Statement,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The length of the statement  "		for (reader.BaseStream.Position = xref [1]; (reader.ReadUInt32 () & 0xffffff00) != 0x000cc200; reader.BaseStream.Position -= 5) " is 127.
Long Statement,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The length of the statement  "			for (reader.BaseStream.Position = xref [0]; (reader.ReadUInt32 () & 0xff00ff00) != 0x0000c200; reader.BaseStream.Position -= 5) " is 127.
Long Statement,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The length of the statement  "		if (MessageBox.Show ("Scan for references to strings in the client? This can take a while."' "Warning"' MessageBoxButtons.YesNo' MessageBoxIcon.Warning) == DialogResult.Yes) { " is 175.
Long Statement,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The length of the statement  "			MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetString"))); " is 166.
Long Statement,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The length of the statement  "			MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetBSTR"))); " is 164.
Long Statement,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The length of the statement  "			MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetStringW"))); " is 167.
Long Statement,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The length of the statement  "			MainForm.Invoke (() => MainForm.dataTable.Rows.Add (i' StringDecoderDecode (i)' string.Format ("{0:X8}"' rsrcStringDataPosition + i * 4))); " is 139.
Long Statement,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,StringDecoderDecode,The length of the statement  "		return string.Format ("Invalid checksum; Expected checksum {0:x8}' but calculated checksum {1:x8}"' checksum' checksum2); " is 121.
Magic Number,StringDec,Extensions,C:\repos\wahlao_StringDec\Extensions.cs,RollLeft,The following statement contains a magic number: return (byte)((num & 0xff) | (num >> 8));  
Magic Number,StringDec,Extensions,C:\repos\wahlao_StringDec\Extensions.cs,RollRight,The following statement contains a magic number: return (byte)((num & 0xff) | (num >> 8));  
Magic Number,StringDec,Form1,C:\repos\wahlao_StringDec\Form1.cs,cSVToolStripMenuItem_Click,The following statement contains a magic number: if (saveFileDialog1.ShowDialog () == System.Windows.Forms.DialogResult.OK) {  	StringBuilder sb = new StringBuilder ();  	foreach (var row in dataGridView1.Rows)  		sb.AppendLine (string.Format ("{0}'\"{1}\"'\"{2}\""' ((DataGridViewRow)row).Cells [0].Value' ((DataGridViewRow)row).Cells [1].Value' ((DataGridViewRow)row).Cells [2].Value));  	File.WriteAllText (saveFileDialog1.FileName' sb.ToString ()' Encoding.GetEncoding (949));  	MessageBox.Show ("Exported CSV to " + saveFileDialog1.FileName' "Save Complete"' MessageBoxButtons.OK' MessageBoxIcon.Information);  }  
Magic Number,StringDec,Form1,C:\repos\wahlao_StringDec\Form1.cs,cSVToolStripMenuItem_Click,The following statement contains a magic number: if (saveFileDialog1.ShowDialog () == System.Windows.Forms.DialogResult.OK) {  	StringBuilder sb = new StringBuilder ();  	foreach (var row in dataGridView1.Rows)  		sb.AppendLine (string.Format ("{0}'\"{1}\"'\"{2}\""' ((DataGridViewRow)row).Cells [0].Value' ((DataGridViewRow)row).Cells [1].Value' ((DataGridViewRow)row).Cells [2].Value));  	File.WriteAllText (saveFileDialog1.FileName' sb.ToString ()' Encoding.GetEncoding (949));  	MessageBox.Show ("Exported CSV to " + saveFileDialog1.FileName' "Save Complete"' MessageBoxButtons.OK' MessageBoxIcon.Information);  }  
Magic Number,StringDec,Form1,C:\repos\wahlao_StringDec\Form1.cs,cSVToolStripMenuItem_Click,The following statement contains a magic number: foreach (var row in dataGridView1.Rows)  	sb.AppendLine (string.Format ("{0}'\"{1}\"'\"{2}\""' ((DataGridViewRow)row).Cells [0].Value' ((DataGridViewRow)row).Cells [1].Value' ((DataGridViewRow)row).Cells [2].Value));  
Magic Number,StringDec,Form1,C:\repos\wahlao_StringDec\Form1.cs,cSVToolStripMenuItem_Click,The following statement contains a magic number: sb.AppendLine (string.Format ("{0}'\"{1}\"'\"{2}\""' ((DataGridViewRow)row).Cells [0].Value' ((DataGridViewRow)row).Cells [1].Value' ((DataGridViewRow)row).Cells [2].Value));  
Magic Number,StringDec,Form1,C:\repos\wahlao_StringDec\Form1.cs,cSVToolStripMenuItem_Click,The following statement contains a magic number: File.WriteAllText (saveFileDialog1.FileName' sb.ToString ()' Encoding.GetEncoding (949));  
Magic Number,StringDec,Form1,C:\repos\wahlao_StringDec\Form1.cs,cHeaderFileToolStripMenuItem_Click,The following statement contains a magic number: if (saveFileDialog1.ShowDialog () == System.Windows.Forms.DialogResult.OK) {  	StringBuilder sb = new StringBuilder ();  	sb.AppendLine ("enum StringPoolStrings {");  	foreach (var row in dataGridView1.Rows) {  		string s = Program.ReverseIME (new string (Array.FindAll<char> (((DataGridViewRow)row).Cells [1].Value.ToString ().ToCharArray ()' x => char.IsLetterOrDigit (x) || x == ' ')));  		sb.AppendLine (string.Format ("\tSP_{0}_{1:S30} = {0}'"' ((DataGridViewRow)row).Cells [0].Value' Encoding.ASCII.GetString (Encoding.ASCII.GetBytes (s.ToCharArray ()' 0' s.Length > 50 ? 50 : s.Length)).Replace ('?'' '_').Replace (' '' '_')));  	}  	sb.AppendLine ("};");  	File.WriteAllText (saveFileDialog1.FileName' sb.ToString ()' Encoding.ASCII);  	MessageBox.Show ("Exported header to " + saveFileDialog1.FileName' "Save Complete"' MessageBoxButtons.OK' MessageBoxIcon.Information);  }  
Magic Number,StringDec,Form1,C:\repos\wahlao_StringDec\Form1.cs,cHeaderFileToolStripMenuItem_Click,The following statement contains a magic number: if (saveFileDialog1.ShowDialog () == System.Windows.Forms.DialogResult.OK) {  	StringBuilder sb = new StringBuilder ();  	sb.AppendLine ("enum StringPoolStrings {");  	foreach (var row in dataGridView1.Rows) {  		string s = Program.ReverseIME (new string (Array.FindAll<char> (((DataGridViewRow)row).Cells [1].Value.ToString ().ToCharArray ()' x => char.IsLetterOrDigit (x) || x == ' ')));  		sb.AppendLine (string.Format ("\tSP_{0}_{1:S30} = {0}'"' ((DataGridViewRow)row).Cells [0].Value' Encoding.ASCII.GetString (Encoding.ASCII.GetBytes (s.ToCharArray ()' 0' s.Length > 50 ? 50 : s.Length)).Replace ('?'' '_').Replace (' '' '_')));  	}  	sb.AppendLine ("};");  	File.WriteAllText (saveFileDialog1.FileName' sb.ToString ()' Encoding.ASCII);  	MessageBox.Show ("Exported header to " + saveFileDialog1.FileName' "Save Complete"' MessageBoxButtons.OK' MessageBoxIcon.Information);  }  
Magic Number,StringDec,Form1,C:\repos\wahlao_StringDec\Form1.cs,cHeaderFileToolStripMenuItem_Click,The following statement contains a magic number: foreach (var row in dataGridView1.Rows) {  	string s = Program.ReverseIME (new string (Array.FindAll<char> (((DataGridViewRow)row).Cells [1].Value.ToString ().ToCharArray ()' x => char.IsLetterOrDigit (x) || x == ' ')));  	sb.AppendLine (string.Format ("\tSP_{0}_{1:S30} = {0}'"' ((DataGridViewRow)row).Cells [0].Value' Encoding.ASCII.GetString (Encoding.ASCII.GetBytes (s.ToCharArray ()' 0' s.Length > 50 ? 50 : s.Length)).Replace ('?'' '_').Replace (' '' '_')));  }  
Magic Number,StringDec,Form1,C:\repos\wahlao_StringDec\Form1.cs,cHeaderFileToolStripMenuItem_Click,The following statement contains a magic number: foreach (var row in dataGridView1.Rows) {  	string s = Program.ReverseIME (new string (Array.FindAll<char> (((DataGridViewRow)row).Cells [1].Value.ToString ().ToCharArray ()' x => char.IsLetterOrDigit (x) || x == ' ')));  	sb.AppendLine (string.Format ("\tSP_{0}_{1:S30} = {0}'"' ((DataGridViewRow)row).Cells [0].Value' Encoding.ASCII.GetString (Encoding.ASCII.GetBytes (s.ToCharArray ()' 0' s.Length > 50 ? 50 : s.Length)).Replace ('?'' '_').Replace (' '' '_')));  }  
Magic Number,StringDec,Form1,C:\repos\wahlao_StringDec\Form1.cs,cHeaderFileToolStripMenuItem_Click,The following statement contains a magic number: sb.AppendLine (string.Format ("\tSP_{0}_{1:S30} = {0}'"' ((DataGridViewRow)row).Cells [0].Value' Encoding.ASCII.GetString (Encoding.ASCII.GetBytes (s.ToCharArray ()' 0' s.Length > 50 ? 50 : s.Length)).Replace ('?'' '_').Replace (' '' '_')));  
Magic Number,StringDec,Form1,C:\repos\wahlao_StringDec\Form1.cs,cHeaderFileToolStripMenuItem_Click,The following statement contains a magic number: sb.AppendLine (string.Format ("\tSP_{0}_{1:S30} = {0}'"' ((DataGridViewRow)row).Cells [0].Value' Encoding.ASCII.GetString (Encoding.ASCII.GetBytes (s.ToCharArray ()' 0' s.Length > 50 ? 50 : s.Length)).Replace ('?'' '_').Replace (' '' '_')));  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: for (int i = 0; i < 16; ++i) {  	reader.ReadInt32 ();  	reader.ReadInt32 ();  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: for (short i = 0; i < NumberOfSections; ++i) {  	string Name = ASCIIEncoding.ASCII.GetString (reader.ReadBytes (8));  	int Misc = reader.ReadInt32 ();  	int VirtualAddress = reader.ReadInt32 ();  	int SizeOfRawData = reader.ReadInt32 ();  	int PointerToRawData = reader.ReadInt32 ();  	int PointerToRelocations = reader.ReadInt32 ();  	int PointerToLinenumbers = reader.ReadInt32 ();  	short NumberOfRelocations = reader.ReadInt16 ();  	short NumberOfLinenumbers = reader.ReadInt16 ();  	int Characteristics = reader.ReadInt32 ();  	if (Name == ".rsrc\0\0\0") {  		rsrcVirtualAddress = VirtualAddress;  		rsrcPointerToRawData = PointerToRawData;  	}  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: if (StringDecodeMethod == 0)// StringPool   {  	MainForm.Invoke (() => MainForm.Text += " [StringPool]");  	int offset_StringPool__ms_aKey = (int)reader.BaseStream.Position;  	Status ("StringPool::ms_aKey located at {0:X8}"' offset_StringPool__ms_aKey);  	int keyRef = 0;  	// Only GetString references ms_aKey  	byte[] bytes = new byte[5];  	bytes [0] = 0x68;  	// push offset  	Buffer.BlockCopy (BitConverter.GetBytes (ImageBase + offset_StringPool__ms_aKey)' 0' bytes' 1' 4);  	if (FindAoBInFile (reader' 0' bytes))  		keyRef = (int)reader.BaseStream.Position;  	reader.BaseStream.Position = keyRef;  	while (true) {  		byte[] asdf = reader.ReadBytes (5);  		if (asdf [4] == 0xc3)// retn  		 {  			bool die = true;  			foreach (byte b in asdf)  				if (b == 0xe8)// call  				 {  					die = false;  					break;  				}  			if (die)  				break;  		}  		reader.BaseStream.Position -= 6;  	}  	while (reader.ReadByte () == 0xcc)  		;  	// allign  	reader.BaseStream.Position -= 1;  	int offset_StringPool__GetString_uint_char = (int)reader.BaseStream.Position;  	Status ("StringPool::GetString(uint' char) located at {0:X8}"' offset_StringPool__GetString_uint_char);  	//search for StringPool::offset_ms_aString  	if (FindAoBInFile (reader' keyRef - 100' new byte[] {  		0x8b'  		0x0c  	}' 100))  		reader.BaseStream.Position += 3;  	else if (FindAoBInFile (reader' keyRef - 100' new byte[] {  		0x8b'  		0x86  	}' 100))  		reader.BaseStream.Position += 2;  	else  		throw new Exception ("could not find start of StringPool::offset_ms_aString");  	offset_StringPool__ms_aString = reader.ReadInt32 () - ImageBase;  	Status ("StringPool::ms_aString located at {0:X8}"' offset_StringPool__ms_aString);  	//search for xrefs to function StringPool::GetString(uint' char)   	int[] xref = FindCalls (offset_StringPool__GetString_uint_char' 2);  	if (xref.Length != 2)  		throw new Exception ("failed to find references to StringPool::GetString(uint' char)");  	//search for start of StringPool::GetString(uint)  	if (!FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x51'  		0x8b  	}' 50) && !FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x55'  		0x8b  	}' 50))  		throw new Exception ("could not find start of GetString(uint)");  	int offset_StringPool__GetString_uint = (int)reader.BaseStream.Position;  	Status ("StringPool::GetString(uint) located at {0:X8}"' offset_StringPool__GetString_uint);  	//search for start of StringPool::GetString(uint' ushort)  	for (reader.BaseStream.Position = xref [1]; (reader.ReadUInt32 () & 0xffffff00) != 0x000cc200; reader.BaseStream.Position -= 5)  		;  	//seek the start of function StringPool::GetString(uint' char)  	while (reader.ReadByte () == 0xcc)  		;  	// allign  	reader.BaseStream.Position -= 1;  	int offset_StringPool__GetString_uint_ushort = (int)reader.BaseStream.Position;  	Status ("StringPool::GetString(uint' ushort) located at {0:X8}"' offset_StringPool__GetString_uint_ushort);  	//search for xrefs to function StringPool::GetString(uint)  	xref = FindCalls (offset_StringPool__GetString_uint' 1);  	if (xref.Length != 1)  		throw new Exception ("failed to find references to StringPool::GetString(uint)");  	//search for start of function StringPool::GetBSTR(uint)  	reader.BaseStream.Position -= 100;  	// should be enough  	if (!FindAoBInFile (reader' (int)reader.BaseStream.Position' new byte[] {  		0xb8'  		0xaa'  		0xaa'  		0xaa'  		0x00  	}))  		for (reader.BaseStream.Position = xref [0]; (reader.ReadUInt32 () & 0xff00ff00) != 0x0000c200; reader.BaseStream.Position -= 5)  			;  	//seek the start of function StringPool::GetString(uint' char)  	while (reader.ReadByte () == 0xcc)  		;  	// allign  	reader.BaseStream.Position -= 1;  	int offset_StringPool__GetBSTR_uint = (int)reader.BaseStream.Position;  	Status ("StringPool::GetBSTR(uint) located at {0:X8}"' offset_StringPool__GetBSTR_uint);  	//search for xrefs to function StringPool::GetString(uint' ushort)  	xref = FindCalls (offset_StringPool__GetString_uint_ushort' 1);  	if (xref.Length != 1)  		throw new Exception ("failed to find references to StringPool::GetString(uint' ushort)");  	//search for start of function StringPool::GetStringW(uint)  	if (!FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x51'  		0x8b  	}' 50) && !FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x55'  		0x8b  	}' 50))  		throw new Exception ("could not find start of GetStringW(uint)");  	int offset_StringPool__GetStringW_uint = (int)reader.BaseStream.Position;  	Status ("StringPool::GetStringW(uint) located at {0:X8}"' offset_StringPool__GetStringW_uint);  	ms_nSize = GetIntFromOffset (offset_StringPool__ms_aKey + 16 + 4);  	Status ("Amount of strings: {0}"' ms_nSize);  	if (MessageBox.Show ("Scan for references to strings in the client? This can take a while."' "Warning"' MessageBoxButtons.YesNo' MessageBoxIcon.Warning) == DialogResult.Yes) {  		Status ("Searching for references to GetString' GetStringW' and GetBSTR");  		List<int> GetStringCalls = new List<int> ();  		List<int> GetStringWCalls = new List<int> ();  		List<int> GetBSTRCalls = new List<int> ();  		for (reader.BaseStream.Position = 0; reader.BaseStream.Position < reader.BaseStream.Length;) {  			//int lol = (int)((float)reader.BaseStream.Position / reader.BaseStream.Length * 100);  			//if (lol > MainForm.toolStripProgressBar1.Value)  			//{  			//    MainForm.Invoke(() => MainForm.toolStripProgressBar1.Value = lol);  			//    MainForm.Invoke(() => MainForm.Update());  			//} too expensive  			if (reader.ReadByte () != 0xE8)  				// call  				continue;  			int offset = reader.ReadInt32 ();  			if (reader.BaseStream.Position + offset == offset_StringPool__GetString_uint)  				GetStringCalls.Add ((int)reader.BaseStream.Position - 5);  			else if (reader.BaseStream.Position + offset == offset_StringPool__GetStringW_uint)  				GetStringWCalls.Add ((int)reader.BaseStream.Position - 5);  			else if (reader.BaseStream.Position + offset == offset_StringPool__GetBSTR_uint)  				GetBSTRCalls.Add ((int)reader.BaseStream.Position - 5);  			else  				reader.BaseStream.Position -= 4;  		}  		List<int> GetStringFail = new List<int> ();  		foreach (int addr in GetStringCalls) {  			reader.BaseStream.Position = addr;  			reader.BaseStream.Position -= 2;  			if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  			 {  				GetStringFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 7;  			if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  			 {  				GetStringFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 2;  			if (reader.ReadByte () != 0x50)// push eax  			 {  				GetStringFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 6;  			if (reader.ReadByte () != 0x68)// push dword  			 {  				GetStringFail.Add (addr);  				continue;  			}  			int idx = reader.ReadInt32 ();  			if (idx > ms_nSize - 1)  				GetStringFail.Add (addr);  			else  				GetString.Add (addr' idx);  		}  		List<int> GetStringWFail = new List<int> ();  		foreach (int addr in GetStringWCalls) {  			reader.BaseStream.Position = addr;  			reader.BaseStream.Position -= 2;  			if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 7;  			if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 2;  			if (reader.ReadByte () != 0x50)// push eax  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 6;  			if (reader.ReadByte () != 0x68)// push dword  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			int idx = reader.ReadInt32 ();  			if (idx > ms_nSize - 1)  				GetStringWFail.Add (addr);  			else  				GetStringW.Add (addr' idx);  		}  		List<int> GetBSTRFail = new List<int> ();  		foreach (int addr in GetBSTRCalls) {  			reader.BaseStream.Position = addr;  			reader.BaseStream.Position -= 2;  			if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 7;  			if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 2;  			if (reader.ReadByte () != 0x50)// push eax  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 6;  			if (reader.ReadByte () != 0x68)// push dword  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			int idx = reader.ReadInt32 ();  			if (idx > ms_nSize - 1)  				GetBSTRFail.Add (addr);  			else  				GetBSTR.Add (addr' idx);  		}  		Status ("Failed to find index of {0} references"' GetStringFail.Count + GetStringWFail.Count + GetBSTRFail.Count);  	}  	Status ("Successfully found index of {0} references"' GetString.Count + GetBSTR.Count + GetStringW.Count);  	Status ("Decoding strings");  	for (int index = 0; index < ms_nSize; ++index)  		if (index != -1 && index <= 0xffff)  			Strings.Add (index' StringPoolDecode (index));  	Status ("Populating table");  	foreach (var s in Strings)  		MainForm.Invoke (() => MainForm.dataTable.Rows.Add (s.Key' s.Value' string.Empty));  	foreach (var a in GetString)  		MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetString")));  	foreach (var a in GetBSTR)  		MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetBSTR")));  	foreach (var a in GetStringW)  		MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetStringW")));  }  else if (StringDecodeMethod == 1)// StringDecoder   {  	MainForm.Invoke (() => MainForm.Text += " [StringDecoder]");  	int type = 0;  	int name = 0;  	int offset = 0;  	//search for CStringDecoder::DelayedLoad' which contains the resource type and name  	if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00'  		0x89'  		0x45'  		0xF4'  		0x6A'  		0xAA'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x8B'  		0x4D'  		0xF4'  		0x51'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 12;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 1;  		name = reader.ReadInt32 ();  	}  	else if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00'  		0x6A'  		0xAA'  		0x8B'  		0xF8'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x57'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 9;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 3;  		name = reader.ReadInt32 ();  	}  	else if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0xAA'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 1;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 1;  		name = reader.ReadInt32 ();  	}  	else  		throw new Exception ("Failed to determine type and name of resource.");  	//search for start of function CStringDecoder::DelayedLoad()  	reader.BaseStream.Position -= 50;  	// should be enough  	FindAoBInFile (reader' (int)reader.BaseStream.Position' new byte[] {  		0x55'  		0x8B'  		0xEC'  		0x83'  		0xEC'  		0x10  	});  	int offset_CStringDecoder__DelayedLoad = (int)reader.BaseStream.Position;  	for (reader.BaseStream.Position = 0; reader.BaseStream.Position < reader.BaseStream.Length;) {  		if (reader.ReadByte () != 0xE8)  			// call  			continue;  		int offse = reader.ReadInt32 ();  		if (reader.BaseStream.Position + offse == offset_CStringDecoder__DelayedLoad) {  			Status ("{0:X8} reference to offset_CStringDecoder__DelayedLoad = {1:X8}"' reader.BaseStream.Position - 5' offse);  			break;  		}  	}  	ImageResourceDirectory tier1 = (ImageResourceDirectory)root.GetEntry (type).Entry;  	ImageResourceDirectory tier2 = (ImageResourceDirectory)tier1.GetEntry (name).Entry;  	rsrcStringDataEntry = (ImageResourceDataEntry)tier2.Entrys [0].Entry;  	rsrcStringDataPosition = rsrcPointerToRawData + (rsrcStringDataEntry.OffsetToData - rsrcVirtualAddress);  	m_nCount = GetWordFromIndex (0);  	Status ("Amount of strings: {0}"' m_nCount);  	for (int i = 1; i < m_nCount; ++i)  		MainForm.Invoke (() => MainForm.dataTable.Rows.Add (i' StringDecoderDecode (i)' string.Format ("{0:X8}"' rsrcStringDataPosition + i * 4)));  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: if (StringDecodeMethod == 0)// StringPool   {  	MainForm.Invoke (() => MainForm.Text += " [StringPool]");  	int offset_StringPool__ms_aKey = (int)reader.BaseStream.Position;  	Status ("StringPool::ms_aKey located at {0:X8}"' offset_StringPool__ms_aKey);  	int keyRef = 0;  	// Only GetString references ms_aKey  	byte[] bytes = new byte[5];  	bytes [0] = 0x68;  	// push offset  	Buffer.BlockCopy (BitConverter.GetBytes (ImageBase + offset_StringPool__ms_aKey)' 0' bytes' 1' 4);  	if (FindAoBInFile (reader' 0' bytes))  		keyRef = (int)reader.BaseStream.Position;  	reader.BaseStream.Position = keyRef;  	while (true) {  		byte[] asdf = reader.ReadBytes (5);  		if (asdf [4] == 0xc3)// retn  		 {  			bool die = true;  			foreach (byte b in asdf)  				if (b == 0xe8)// call  				 {  					die = false;  					break;  				}  			if (die)  				break;  		}  		reader.BaseStream.Position -= 6;  	}  	while (reader.ReadByte () == 0xcc)  		;  	// allign  	reader.BaseStream.Position -= 1;  	int offset_StringPool__GetString_uint_char = (int)reader.BaseStream.Position;  	Status ("StringPool::GetString(uint' char) located at {0:X8}"' offset_StringPool__GetString_uint_char);  	//search for StringPool::offset_ms_aString  	if (FindAoBInFile (reader' keyRef - 100' new byte[] {  		0x8b'  		0x0c  	}' 100))  		reader.BaseStream.Position += 3;  	else if (FindAoBInFile (reader' keyRef - 100' new byte[] {  		0x8b'  		0x86  	}' 100))  		reader.BaseStream.Position += 2;  	else  		throw new Exception ("could not find start of StringPool::offset_ms_aString");  	offset_StringPool__ms_aString = reader.ReadInt32 () - ImageBase;  	Status ("StringPool::ms_aString located at {0:X8}"' offset_StringPool__ms_aString);  	//search for xrefs to function StringPool::GetString(uint' char)   	int[] xref = FindCalls (offset_StringPool__GetString_uint_char' 2);  	if (xref.Length != 2)  		throw new Exception ("failed to find references to StringPool::GetString(uint' char)");  	//search for start of StringPool::GetString(uint)  	if (!FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x51'  		0x8b  	}' 50) && !FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x55'  		0x8b  	}' 50))  		throw new Exception ("could not find start of GetString(uint)");  	int offset_StringPool__GetString_uint = (int)reader.BaseStream.Position;  	Status ("StringPool::GetString(uint) located at {0:X8}"' offset_StringPool__GetString_uint);  	//search for start of StringPool::GetString(uint' ushort)  	for (reader.BaseStream.Position = xref [1]; (reader.ReadUInt32 () & 0xffffff00) != 0x000cc200; reader.BaseStream.Position -= 5)  		;  	//seek the start of function StringPool::GetString(uint' char)  	while (reader.ReadByte () == 0xcc)  		;  	// allign  	reader.BaseStream.Position -= 1;  	int offset_StringPool__GetString_uint_ushort = (int)reader.BaseStream.Position;  	Status ("StringPool::GetString(uint' ushort) located at {0:X8}"' offset_StringPool__GetString_uint_ushort);  	//search for xrefs to function StringPool::GetString(uint)  	xref = FindCalls (offset_StringPool__GetString_uint' 1);  	if (xref.Length != 1)  		throw new Exception ("failed to find references to StringPool::GetString(uint)");  	//search for start of function StringPool::GetBSTR(uint)  	reader.BaseStream.Position -= 100;  	// should be enough  	if (!FindAoBInFile (reader' (int)reader.BaseStream.Position' new byte[] {  		0xb8'  		0xaa'  		0xaa'  		0xaa'  		0x00  	}))  		for (reader.BaseStream.Position = xref [0]; (reader.ReadUInt32 () & 0xff00ff00) != 0x0000c200; reader.BaseStream.Position -= 5)  			;  	//seek the start of function StringPool::GetString(uint' char)  	while (reader.ReadByte () == 0xcc)  		;  	// allign  	reader.BaseStream.Position -= 1;  	int offset_StringPool__GetBSTR_uint = (int)reader.BaseStream.Position;  	Status ("StringPool::GetBSTR(uint) located at {0:X8}"' offset_StringPool__GetBSTR_uint);  	//search for xrefs to function StringPool::GetString(uint' ushort)  	xref = FindCalls (offset_StringPool__GetString_uint_ushort' 1);  	if (xref.Length != 1)  		throw new Exception ("failed to find references to StringPool::GetString(uint' ushort)");  	//search for start of function StringPool::GetStringW(uint)  	if (!FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x51'  		0x8b  	}' 50) && !FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x55'  		0x8b  	}' 50))  		throw new Exception ("could not find start of GetStringW(uint)");  	int offset_StringPool__GetStringW_uint = (int)reader.BaseStream.Position;  	Status ("StringPool::GetStringW(uint) located at {0:X8}"' offset_StringPool__GetStringW_uint);  	ms_nSize = GetIntFromOffset (offset_StringPool__ms_aKey + 16 + 4);  	Status ("Amount of strings: {0}"' ms_nSize);  	if (MessageBox.Show ("Scan for references to strings in the client? This can take a while."' "Warning"' MessageBoxButtons.YesNo' MessageBoxIcon.Warning) == DialogResult.Yes) {  		Status ("Searching for references to GetString' GetStringW' and GetBSTR");  		List<int> GetStringCalls = new List<int> ();  		List<int> GetStringWCalls = new List<int> ();  		List<int> GetBSTRCalls = new List<int> ();  		for (reader.BaseStream.Position = 0; reader.BaseStream.Position < reader.BaseStream.Length;) {  			//int lol = (int)((float)reader.BaseStream.Position / reader.BaseStream.Length * 100);  			//if (lol > MainForm.toolStripProgressBar1.Value)  			//{  			//    MainForm.Invoke(() => MainForm.toolStripProgressBar1.Value = lol);  			//    MainForm.Invoke(() => MainForm.Update());  			//} too expensive  			if (reader.ReadByte () != 0xE8)  				// call  				continue;  			int offset = reader.ReadInt32 ();  			if (reader.BaseStream.Position + offset == offset_StringPool__GetString_uint)  				GetStringCalls.Add ((int)reader.BaseStream.Position - 5);  			else if (reader.BaseStream.Position + offset == offset_StringPool__GetStringW_uint)  				GetStringWCalls.Add ((int)reader.BaseStream.Position - 5);  			else if (reader.BaseStream.Position + offset == offset_StringPool__GetBSTR_uint)  				GetBSTRCalls.Add ((int)reader.BaseStream.Position - 5);  			else  				reader.BaseStream.Position -= 4;  		}  		List<int> GetStringFail = new List<int> ();  		foreach (int addr in GetStringCalls) {  			reader.BaseStream.Position = addr;  			reader.BaseStream.Position -= 2;  			if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  			 {  				GetStringFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 7;  			if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  			 {  				GetStringFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 2;  			if (reader.ReadByte () != 0x50)// push eax  			 {  				GetStringFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 6;  			if (reader.ReadByte () != 0x68)// push dword  			 {  				GetStringFail.Add (addr);  				continue;  			}  			int idx = reader.ReadInt32 ();  			if (idx > ms_nSize - 1)  				GetStringFail.Add (addr);  			else  				GetString.Add (addr' idx);  		}  		List<int> GetStringWFail = new List<int> ();  		foreach (int addr in GetStringWCalls) {  			reader.BaseStream.Position = addr;  			reader.BaseStream.Position -= 2;  			if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 7;  			if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 2;  			if (reader.ReadByte () != 0x50)// push eax  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 6;  			if (reader.ReadByte () != 0x68)// push dword  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			int idx = reader.ReadInt32 ();  			if (idx > ms_nSize - 1)  				GetStringWFail.Add (addr);  			else  				GetStringW.Add (addr' idx);  		}  		List<int> GetBSTRFail = new List<int> ();  		foreach (int addr in GetBSTRCalls) {  			reader.BaseStream.Position = addr;  			reader.BaseStream.Position -= 2;  			if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 7;  			if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 2;  			if (reader.ReadByte () != 0x50)// push eax  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 6;  			if (reader.ReadByte () != 0x68)// push dword  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			int idx = reader.ReadInt32 ();  			if (idx > ms_nSize - 1)  				GetBSTRFail.Add (addr);  			else  				GetBSTR.Add (addr' idx);  		}  		Status ("Failed to find index of {0} references"' GetStringFail.Count + GetStringWFail.Count + GetBSTRFail.Count);  	}  	Status ("Successfully found index of {0} references"' GetString.Count + GetBSTR.Count + GetStringW.Count);  	Status ("Decoding strings");  	for (int index = 0; index < ms_nSize; ++index)  		if (index != -1 && index <= 0xffff)  			Strings.Add (index' StringPoolDecode (index));  	Status ("Populating table");  	foreach (var s in Strings)  		MainForm.Invoke (() => MainForm.dataTable.Rows.Add (s.Key' s.Value' string.Empty));  	foreach (var a in GetString)  		MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetString")));  	foreach (var a in GetBSTR)  		MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetBSTR")));  	foreach (var a in GetStringW)  		MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetStringW")));  }  else if (StringDecodeMethod == 1)// StringDecoder   {  	MainForm.Invoke (() => MainForm.Text += " [StringDecoder]");  	int type = 0;  	int name = 0;  	int offset = 0;  	//search for CStringDecoder::DelayedLoad' which contains the resource type and name  	if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00'  		0x89'  		0x45'  		0xF4'  		0x6A'  		0xAA'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x8B'  		0x4D'  		0xF4'  		0x51'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 12;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 1;  		name = reader.ReadInt32 ();  	}  	else if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00'  		0x6A'  		0xAA'  		0x8B'  		0xF8'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x57'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 9;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 3;  		name = reader.ReadInt32 ();  	}  	else if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0xAA'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 1;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 1;  		name = reader.ReadInt32 ();  	}  	else  		throw new Exception ("Failed to determine type and name of resource.");  	//search for start of function CStringDecoder::DelayedLoad()  	reader.BaseStream.Position -= 50;  	// should be enough  	FindAoBInFile (reader' (int)reader.BaseStream.Position' new byte[] {  		0x55'  		0x8B'  		0xEC'  		0x83'  		0xEC'  		0x10  	});  	int offset_CStringDecoder__DelayedLoad = (int)reader.BaseStream.Position;  	for (reader.BaseStream.Position = 0; reader.BaseStream.Position < reader.BaseStream.Length;) {  		if (reader.ReadByte () != 0xE8)  			// call  			continue;  		int offse = reader.ReadInt32 ();  		if (reader.BaseStream.Position + offse == offset_CStringDecoder__DelayedLoad) {  			Status ("{0:X8} reference to offset_CStringDecoder__DelayedLoad = {1:X8}"' reader.BaseStream.Position - 5' offse);  			break;  		}  	}  	ImageResourceDirectory tier1 = (ImageResourceDirectory)root.GetEntry (type).Entry;  	ImageResourceDirectory tier2 = (ImageResourceDirectory)tier1.GetEntry (name).Entry;  	rsrcStringDataEntry = (ImageResourceDataEntry)tier2.Entrys [0].Entry;  	rsrcStringDataPosition = rsrcPointerToRawData + (rsrcStringDataEntry.OffsetToData - rsrcVirtualAddress);  	m_nCount = GetWordFromIndex (0);  	Status ("Amount of strings: {0}"' m_nCount);  	for (int i = 1; i < m_nCount; ++i)  		MainForm.Invoke (() => MainForm.dataTable.Rows.Add (i' StringDecoderDecode (i)' string.Format ("{0:X8}"' rsrcStringDataPosition + i * 4)));  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: if (StringDecodeMethod == 0)// StringPool   {  	MainForm.Invoke (() => MainForm.Text += " [StringPool]");  	int offset_StringPool__ms_aKey = (int)reader.BaseStream.Position;  	Status ("StringPool::ms_aKey located at {0:X8}"' offset_StringPool__ms_aKey);  	int keyRef = 0;  	// Only GetString references ms_aKey  	byte[] bytes = new byte[5];  	bytes [0] = 0x68;  	// push offset  	Buffer.BlockCopy (BitConverter.GetBytes (ImageBase + offset_StringPool__ms_aKey)' 0' bytes' 1' 4);  	if (FindAoBInFile (reader' 0' bytes))  		keyRef = (int)reader.BaseStream.Position;  	reader.BaseStream.Position = keyRef;  	while (true) {  		byte[] asdf = reader.ReadBytes (5);  		if (asdf [4] == 0xc3)// retn  		 {  			bool die = true;  			foreach (byte b in asdf)  				if (b == 0xe8)// call  				 {  					die = false;  					break;  				}  			if (die)  				break;  		}  		reader.BaseStream.Position -= 6;  	}  	while (reader.ReadByte () == 0xcc)  		;  	// allign  	reader.BaseStream.Position -= 1;  	int offset_StringPool__GetString_uint_char = (int)reader.BaseStream.Position;  	Status ("StringPool::GetString(uint' char) located at {0:X8}"' offset_StringPool__GetString_uint_char);  	//search for StringPool::offset_ms_aString  	if (FindAoBInFile (reader' keyRef - 100' new byte[] {  		0x8b'  		0x0c  	}' 100))  		reader.BaseStream.Position += 3;  	else if (FindAoBInFile (reader' keyRef - 100' new byte[] {  		0x8b'  		0x86  	}' 100))  		reader.BaseStream.Position += 2;  	else  		throw new Exception ("could not find start of StringPool::offset_ms_aString");  	offset_StringPool__ms_aString = reader.ReadInt32 () - ImageBase;  	Status ("StringPool::ms_aString located at {0:X8}"' offset_StringPool__ms_aString);  	//search for xrefs to function StringPool::GetString(uint' char)   	int[] xref = FindCalls (offset_StringPool__GetString_uint_char' 2);  	if (xref.Length != 2)  		throw new Exception ("failed to find references to StringPool::GetString(uint' char)");  	//search for start of StringPool::GetString(uint)  	if (!FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x51'  		0x8b  	}' 50) && !FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x55'  		0x8b  	}' 50))  		throw new Exception ("could not find start of GetString(uint)");  	int offset_StringPool__GetString_uint = (int)reader.BaseStream.Position;  	Status ("StringPool::GetString(uint) located at {0:X8}"' offset_StringPool__GetString_uint);  	//search for start of StringPool::GetString(uint' ushort)  	for (reader.BaseStream.Position = xref [1]; (reader.ReadUInt32 () & 0xffffff00) != 0x000cc200; reader.BaseStream.Position -= 5)  		;  	//seek the start of function StringPool::GetString(uint' char)  	while (reader.ReadByte () == 0xcc)  		;  	// allign  	reader.BaseStream.Position -= 1;  	int offset_StringPool__GetString_uint_ushort = (int)reader.BaseStream.Position;  	Status ("StringPool::GetString(uint' ushort) located at {0:X8}"' offset_StringPool__GetString_uint_ushort);  	//search for xrefs to function StringPool::GetString(uint)  	xref = FindCalls (offset_StringPool__GetString_uint' 1);  	if (xref.Length != 1)  		throw new Exception ("failed to find references to StringPool::GetString(uint)");  	//search for start of function StringPool::GetBSTR(uint)  	reader.BaseStream.Position -= 100;  	// should be enough  	if (!FindAoBInFile (reader' (int)reader.BaseStream.Position' new byte[] {  		0xb8'  		0xaa'  		0xaa'  		0xaa'  		0x00  	}))  		for (reader.BaseStream.Position = xref [0]; (reader.ReadUInt32 () & 0xff00ff00) != 0x0000c200; reader.BaseStream.Position -= 5)  			;  	//seek the start of function StringPool::GetString(uint' char)  	while (reader.ReadByte () == 0xcc)  		;  	// allign  	reader.BaseStream.Position -= 1;  	int offset_StringPool__GetBSTR_uint = (int)reader.BaseStream.Position;  	Status ("StringPool::GetBSTR(uint) located at {0:X8}"' offset_StringPool__GetBSTR_uint);  	//search for xrefs to function StringPool::GetString(uint' ushort)  	xref = FindCalls (offset_StringPool__GetString_uint_ushort' 1);  	if (xref.Length != 1)  		throw new Exception ("failed to find references to StringPool::GetString(uint' ushort)");  	//search for start of function StringPool::GetStringW(uint)  	if (!FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x51'  		0x8b  	}' 50) && !FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x55'  		0x8b  	}' 50))  		throw new Exception ("could not find start of GetStringW(uint)");  	int offset_StringPool__GetStringW_uint = (int)reader.BaseStream.Position;  	Status ("StringPool::GetStringW(uint) located at {0:X8}"' offset_StringPool__GetStringW_uint);  	ms_nSize = GetIntFromOffset (offset_StringPool__ms_aKey + 16 + 4);  	Status ("Amount of strings: {0}"' ms_nSize);  	if (MessageBox.Show ("Scan for references to strings in the client? This can take a while."' "Warning"' MessageBoxButtons.YesNo' MessageBoxIcon.Warning) == DialogResult.Yes) {  		Status ("Searching for references to GetString' GetStringW' and GetBSTR");  		List<int> GetStringCalls = new List<int> ();  		List<int> GetStringWCalls = new List<int> ();  		List<int> GetBSTRCalls = new List<int> ();  		for (reader.BaseStream.Position = 0; reader.BaseStream.Position < reader.BaseStream.Length;) {  			//int lol = (int)((float)reader.BaseStream.Position / reader.BaseStream.Length * 100);  			//if (lol > MainForm.toolStripProgressBar1.Value)  			//{  			//    MainForm.Invoke(() => MainForm.toolStripProgressBar1.Value = lol);  			//    MainForm.Invoke(() => MainForm.Update());  			//} too expensive  			if (reader.ReadByte () != 0xE8)  				// call  				continue;  			int offset = reader.ReadInt32 ();  			if (reader.BaseStream.Position + offset == offset_StringPool__GetString_uint)  				GetStringCalls.Add ((int)reader.BaseStream.Position - 5);  			else if (reader.BaseStream.Position + offset == offset_StringPool__GetStringW_uint)  				GetStringWCalls.Add ((int)reader.BaseStream.Position - 5);  			else if (reader.BaseStream.Position + offset == offset_StringPool__GetBSTR_uint)  				GetBSTRCalls.Add ((int)reader.BaseStream.Position - 5);  			else  				reader.BaseStream.Position -= 4;  		}  		List<int> GetStringFail = new List<int> ();  		foreach (int addr in GetStringCalls) {  			reader.BaseStream.Position = addr;  			reader.BaseStream.Position -= 2;  			if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  			 {  				GetStringFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 7;  			if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  			 {  				GetStringFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 2;  			if (reader.ReadByte () != 0x50)// push eax  			 {  				GetStringFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 6;  			if (reader.ReadByte () != 0x68)// push dword  			 {  				GetStringFail.Add (addr);  				continue;  			}  			int idx = reader.ReadInt32 ();  			if (idx > ms_nSize - 1)  				GetStringFail.Add (addr);  			else  				GetString.Add (addr' idx);  		}  		List<int> GetStringWFail = new List<int> ();  		foreach (int addr in GetStringWCalls) {  			reader.BaseStream.Position = addr;  			reader.BaseStream.Position -= 2;  			if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 7;  			if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 2;  			if (reader.ReadByte () != 0x50)// push eax  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 6;  			if (reader.ReadByte () != 0x68)// push dword  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			int idx = reader.ReadInt32 ();  			if (idx > ms_nSize - 1)  				GetStringWFail.Add (addr);  			else  				GetStringW.Add (addr' idx);  		}  		List<int> GetBSTRFail = new List<int> ();  		foreach (int addr in GetBSTRCalls) {  			reader.BaseStream.Position = addr;  			reader.BaseStream.Position -= 2;  			if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 7;  			if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 2;  			if (reader.ReadByte () != 0x50)// push eax  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 6;  			if (reader.ReadByte () != 0x68)// push dword  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			int idx = reader.ReadInt32 ();  			if (idx > ms_nSize - 1)  				GetBSTRFail.Add (addr);  			else  				GetBSTR.Add (addr' idx);  		}  		Status ("Failed to find index of {0} references"' GetStringFail.Count + GetStringWFail.Count + GetBSTRFail.Count);  	}  	Status ("Successfully found index of {0} references"' GetString.Count + GetBSTR.Count + GetStringW.Count);  	Status ("Decoding strings");  	for (int index = 0; index < ms_nSize; ++index)  		if (index != -1 && index <= 0xffff)  			Strings.Add (index' StringPoolDecode (index));  	Status ("Populating table");  	foreach (var s in Strings)  		MainForm.Invoke (() => MainForm.dataTable.Rows.Add (s.Key' s.Value' string.Empty));  	foreach (var a in GetString)  		MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetString")));  	foreach (var a in GetBSTR)  		MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetBSTR")));  	foreach (var a in GetStringW)  		MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetStringW")));  }  else if (StringDecodeMethod == 1)// StringDecoder   {  	MainForm.Invoke (() => MainForm.Text += " [StringDecoder]");  	int type = 0;  	int name = 0;  	int offset = 0;  	//search for CStringDecoder::DelayedLoad' which contains the resource type and name  	if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00'  		0x89'  		0x45'  		0xF4'  		0x6A'  		0xAA'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x8B'  		0x4D'  		0xF4'  		0x51'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 12;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 1;  		name = reader.ReadInt32 ();  	}  	else if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00'  		0x6A'  		0xAA'  		0x8B'  		0xF8'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x57'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 9;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 3;  		name = reader.ReadInt32 ();  	}  	else if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0xAA'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 1;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 1;  		name = reader.ReadInt32 ();  	}  	else  		throw new Exception ("Failed to determine type and name of resource.");  	//search for start of function CStringDecoder::DelayedLoad()  	reader.BaseStream.Position -= 50;  	// should be enough  	FindAoBInFile (reader' (int)reader.BaseStream.Position' new byte[] {  		0x55'  		0x8B'  		0xEC'  		0x83'  		0xEC'  		0x10  	});  	int offset_CStringDecoder__DelayedLoad = (int)reader.BaseStream.Position;  	for (reader.BaseStream.Position = 0; reader.BaseStream.Position < reader.BaseStream.Length;) {  		if (reader.ReadByte () != 0xE8)  			// call  			continue;  		int offse = reader.ReadInt32 ();  		if (reader.BaseStream.Position + offse == offset_CStringDecoder__DelayedLoad) {  			Status ("{0:X8} reference to offset_CStringDecoder__DelayedLoad = {1:X8}"' reader.BaseStream.Position - 5' offse);  			break;  		}  	}  	ImageResourceDirectory tier1 = (ImageResourceDirectory)root.GetEntry (type).Entry;  	ImageResourceDirectory tier2 = (ImageResourceDirectory)tier1.GetEntry (name).Entry;  	rsrcStringDataEntry = (ImageResourceDataEntry)tier2.Entrys [0].Entry;  	rsrcStringDataPosition = rsrcPointerToRawData + (rsrcStringDataEntry.OffsetToData - rsrcVirtualAddress);  	m_nCount = GetWordFromIndex (0);  	Status ("Amount of strings: {0}"' m_nCount);  	for (int i = 1; i < m_nCount; ++i)  		MainForm.Invoke (() => MainForm.dataTable.Rows.Add (i' StringDecoderDecode (i)' string.Format ("{0:X8}"' rsrcStringDataPosition + i * 4)));  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: if (StringDecodeMethod == 0)// StringPool   {  	MainForm.Invoke (() => MainForm.Text += " [StringPool]");  	int offset_StringPool__ms_aKey = (int)reader.BaseStream.Position;  	Status ("StringPool::ms_aKey located at {0:X8}"' offset_StringPool__ms_aKey);  	int keyRef = 0;  	// Only GetString references ms_aKey  	byte[] bytes = new byte[5];  	bytes [0] = 0x68;  	// push offset  	Buffer.BlockCopy (BitConverter.GetBytes (ImageBase + offset_StringPool__ms_aKey)' 0' bytes' 1' 4);  	if (FindAoBInFile (reader' 0' bytes))  		keyRef = (int)reader.BaseStream.Position;  	reader.BaseStream.Position = keyRef;  	while (true) {  		byte[] asdf = reader.ReadBytes (5);  		if (asdf [4] == 0xc3)// retn  		 {  			bool die = true;  			foreach (byte b in asdf)  				if (b == 0xe8)// call  				 {  					die = false;  					break;  				}  			if (die)  				break;  		}  		reader.BaseStream.Position -= 6;  	}  	while (reader.ReadByte () == 0xcc)  		;  	// allign  	reader.BaseStream.Position -= 1;  	int offset_StringPool__GetString_uint_char = (int)reader.BaseStream.Position;  	Status ("StringPool::GetString(uint' char) located at {0:X8}"' offset_StringPool__GetString_uint_char);  	//search for StringPool::offset_ms_aString  	if (FindAoBInFile (reader' keyRef - 100' new byte[] {  		0x8b'  		0x0c  	}' 100))  		reader.BaseStream.Position += 3;  	else if (FindAoBInFile (reader' keyRef - 100' new byte[] {  		0x8b'  		0x86  	}' 100))  		reader.BaseStream.Position += 2;  	else  		throw new Exception ("could not find start of StringPool::offset_ms_aString");  	offset_StringPool__ms_aString = reader.ReadInt32 () - ImageBase;  	Status ("StringPool::ms_aString located at {0:X8}"' offset_StringPool__ms_aString);  	//search for xrefs to function StringPool::GetString(uint' char)   	int[] xref = FindCalls (offset_StringPool__GetString_uint_char' 2);  	if (xref.Length != 2)  		throw new Exception ("failed to find references to StringPool::GetString(uint' char)");  	//search for start of StringPool::GetString(uint)  	if (!FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x51'  		0x8b  	}' 50) && !FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x55'  		0x8b  	}' 50))  		throw new Exception ("could not find start of GetString(uint)");  	int offset_StringPool__GetString_uint = (int)reader.BaseStream.Position;  	Status ("StringPool::GetString(uint) located at {0:X8}"' offset_StringPool__GetString_uint);  	//search for start of StringPool::GetString(uint' ushort)  	for (reader.BaseStream.Position = xref [1]; (reader.ReadUInt32 () & 0xffffff00) != 0x000cc200; reader.BaseStream.Position -= 5)  		;  	//seek the start of function StringPool::GetString(uint' char)  	while (reader.ReadByte () == 0xcc)  		;  	// allign  	reader.BaseStream.Position -= 1;  	int offset_StringPool__GetString_uint_ushort = (int)reader.BaseStream.Position;  	Status ("StringPool::GetString(uint' ushort) located at {0:X8}"' offset_StringPool__GetString_uint_ushort);  	//search for xrefs to function StringPool::GetString(uint)  	xref = FindCalls (offset_StringPool__GetString_uint' 1);  	if (xref.Length != 1)  		throw new Exception ("failed to find references to StringPool::GetString(uint)");  	//search for start of function StringPool::GetBSTR(uint)  	reader.BaseStream.Position -= 100;  	// should be enough  	if (!FindAoBInFile (reader' (int)reader.BaseStream.Position' new byte[] {  		0xb8'  		0xaa'  		0xaa'  		0xaa'  		0x00  	}))  		for (reader.BaseStream.Position = xref [0]; (reader.ReadUInt32 () & 0xff00ff00) != 0x0000c200; reader.BaseStream.Position -= 5)  			;  	//seek the start of function StringPool::GetString(uint' char)  	while (reader.ReadByte () == 0xcc)  		;  	// allign  	reader.BaseStream.Position -= 1;  	int offset_StringPool__GetBSTR_uint = (int)reader.BaseStream.Position;  	Status ("StringPool::GetBSTR(uint) located at {0:X8}"' offset_StringPool__GetBSTR_uint);  	//search for xrefs to function StringPool::GetString(uint' ushort)  	xref = FindCalls (offset_StringPool__GetString_uint_ushort' 1);  	if (xref.Length != 1)  		throw new Exception ("failed to find references to StringPool::GetString(uint' ushort)");  	//search for start of function StringPool::GetStringW(uint)  	if (!FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x51'  		0x8b  	}' 50) && !FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x55'  		0x8b  	}' 50))  		throw new Exception ("could not find start of GetStringW(uint)");  	int offset_StringPool__GetStringW_uint = (int)reader.BaseStream.Position;  	Status ("StringPool::GetStringW(uint) located at {0:X8}"' offset_StringPool__GetStringW_uint);  	ms_nSize = GetIntFromOffset (offset_StringPool__ms_aKey + 16 + 4);  	Status ("Amount of strings: {0}"' ms_nSize);  	if (MessageBox.Show ("Scan for references to strings in the client? This can take a while."' "Warning"' MessageBoxButtons.YesNo' MessageBoxIcon.Warning) == DialogResult.Yes) {  		Status ("Searching for references to GetString' GetStringW' and GetBSTR");  		List<int> GetStringCalls = new List<int> ();  		List<int> GetStringWCalls = new List<int> ();  		List<int> GetBSTRCalls = new List<int> ();  		for (reader.BaseStream.Position = 0; reader.BaseStream.Position < reader.BaseStream.Length;) {  			//int lol = (int)((float)reader.BaseStream.Position / reader.BaseStream.Length * 100);  			//if (lol > MainForm.toolStripProgressBar1.Value)  			//{  			//    MainForm.Invoke(() => MainForm.toolStripProgressBar1.Value = lol);  			//    MainForm.Invoke(() => MainForm.Update());  			//} too expensive  			if (reader.ReadByte () != 0xE8)  				// call  				continue;  			int offset = reader.ReadInt32 ();  			if (reader.BaseStream.Position + offset == offset_StringPool__GetString_uint)  				GetStringCalls.Add ((int)reader.BaseStream.Position - 5);  			else if (reader.BaseStream.Position + offset == offset_StringPool__GetStringW_uint)  				GetStringWCalls.Add ((int)reader.BaseStream.Position - 5);  			else if (reader.BaseStream.Position + offset == offset_StringPool__GetBSTR_uint)  				GetBSTRCalls.Add ((int)reader.BaseStream.Position - 5);  			else  				reader.BaseStream.Position -= 4;  		}  		List<int> GetStringFail = new List<int> ();  		foreach (int addr in GetStringCalls) {  			reader.BaseStream.Position = addr;  			reader.BaseStream.Position -= 2;  			if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  			 {  				GetStringFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 7;  			if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  			 {  				GetStringFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 2;  			if (reader.ReadByte () != 0x50)// push eax  			 {  				GetStringFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 6;  			if (reader.ReadByte () != 0x68)// push dword  			 {  				GetStringFail.Add (addr);  				continue;  			}  			int idx = reader.ReadInt32 ();  			if (idx > ms_nSize - 1)  				GetStringFail.Add (addr);  			else  				GetString.Add (addr' idx);  		}  		List<int> GetStringWFail = new List<int> ();  		foreach (int addr in GetStringWCalls) {  			reader.BaseStream.Position = addr;  			reader.BaseStream.Position -= 2;  			if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 7;  			if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 2;  			if (reader.ReadByte () != 0x50)// push eax  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 6;  			if (reader.ReadByte () != 0x68)// push dword  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			int idx = reader.ReadInt32 ();  			if (idx > ms_nSize - 1)  				GetStringWFail.Add (addr);  			else  				GetStringW.Add (addr' idx);  		}  		List<int> GetBSTRFail = new List<int> ();  		foreach (int addr in GetBSTRCalls) {  			reader.BaseStream.Position = addr;  			reader.BaseStream.Position -= 2;  			if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 7;  			if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 2;  			if (reader.ReadByte () != 0x50)// push eax  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 6;  			if (reader.ReadByte () != 0x68)// push dword  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			int idx = reader.ReadInt32 ();  			if (idx > ms_nSize - 1)  				GetBSTRFail.Add (addr);  			else  				GetBSTR.Add (addr' idx);  		}  		Status ("Failed to find index of {0} references"' GetStringFail.Count + GetStringWFail.Count + GetBSTRFail.Count);  	}  	Status ("Successfully found index of {0} references"' GetString.Count + GetBSTR.Count + GetStringW.Count);  	Status ("Decoding strings");  	for (int index = 0; index < ms_nSize; ++index)  		if (index != -1 && index <= 0xffff)  			Strings.Add (index' StringPoolDecode (index));  	Status ("Populating table");  	foreach (var s in Strings)  		MainForm.Invoke (() => MainForm.dataTable.Rows.Add (s.Key' s.Value' string.Empty));  	foreach (var a in GetString)  		MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetString")));  	foreach (var a in GetBSTR)  		MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetBSTR")));  	foreach (var a in GetStringW)  		MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetStringW")));  }  else if (StringDecodeMethod == 1)// StringDecoder   {  	MainForm.Invoke (() => MainForm.Text += " [StringDecoder]");  	int type = 0;  	int name = 0;  	int offset = 0;  	//search for CStringDecoder::DelayedLoad' which contains the resource type and name  	if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00'  		0x89'  		0x45'  		0xF4'  		0x6A'  		0xAA'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x8B'  		0x4D'  		0xF4'  		0x51'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 12;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 1;  		name = reader.ReadInt32 ();  	}  	else if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00'  		0x6A'  		0xAA'  		0x8B'  		0xF8'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x57'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 9;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 3;  		name = reader.ReadInt32 ();  	}  	else if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0xAA'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 1;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 1;  		name = reader.ReadInt32 ();  	}  	else  		throw new Exception ("Failed to determine type and name of resource.");  	//search for start of function CStringDecoder::DelayedLoad()  	reader.BaseStream.Position -= 50;  	// should be enough  	FindAoBInFile (reader' (int)reader.BaseStream.Position' new byte[] {  		0x55'  		0x8B'  		0xEC'  		0x83'  		0xEC'  		0x10  	});  	int offset_CStringDecoder__DelayedLoad = (int)reader.BaseStream.Position;  	for (reader.BaseStream.Position = 0; reader.BaseStream.Position < reader.BaseStream.Length;) {  		if (reader.ReadByte () != 0xE8)  			// call  			continue;  		int offse = reader.ReadInt32 ();  		if (reader.BaseStream.Position + offse == offset_CStringDecoder__DelayedLoad) {  			Status ("{0:X8} reference to offset_CStringDecoder__DelayedLoad = {1:X8}"' reader.BaseStream.Position - 5' offse);  			break;  		}  	}  	ImageResourceDirectory tier1 = (ImageResourceDirectory)root.GetEntry (type).Entry;  	ImageResourceDirectory tier2 = (ImageResourceDirectory)tier1.GetEntry (name).Entry;  	rsrcStringDataEntry = (ImageResourceDataEntry)tier2.Entrys [0].Entry;  	rsrcStringDataPosition = rsrcPointerToRawData + (rsrcStringDataEntry.OffsetToData - rsrcVirtualAddress);  	m_nCount = GetWordFromIndex (0);  	Status ("Amount of strings: {0}"' m_nCount);  	for (int i = 1; i < m_nCount; ++i)  		MainForm.Invoke (() => MainForm.dataTable.Rows.Add (i' StringDecoderDecode (i)' string.Format ("{0:X8}"' rsrcStringDataPosition + i * 4)));  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: if (StringDecodeMethod == 0)// StringPool   {  	MainForm.Invoke (() => MainForm.Text += " [StringPool]");  	int offset_StringPool__ms_aKey = (int)reader.BaseStream.Position;  	Status ("StringPool::ms_aKey located at {0:X8}"' offset_StringPool__ms_aKey);  	int keyRef = 0;  	// Only GetString references ms_aKey  	byte[] bytes = new byte[5];  	bytes [0] = 0x68;  	// push offset  	Buffer.BlockCopy (BitConverter.GetBytes (ImageBase + offset_StringPool__ms_aKey)' 0' bytes' 1' 4);  	if (FindAoBInFile (reader' 0' bytes))  		keyRef = (int)reader.BaseStream.Position;  	reader.BaseStream.Position = keyRef;  	while (true) {  		byte[] asdf = reader.ReadBytes (5);  		if (asdf [4] == 0xc3)// retn  		 {  			bool die = true;  			foreach (byte b in asdf)  				if (b == 0xe8)// call  				 {  					die = false;  					break;  				}  			if (die)  				break;  		}  		reader.BaseStream.Position -= 6;  	}  	while (reader.ReadByte () == 0xcc)  		;  	// allign  	reader.BaseStream.Position -= 1;  	int offset_StringPool__GetString_uint_char = (int)reader.BaseStream.Position;  	Status ("StringPool::GetString(uint' char) located at {0:X8}"' offset_StringPool__GetString_uint_char);  	//search for StringPool::offset_ms_aString  	if (FindAoBInFile (reader' keyRef - 100' new byte[] {  		0x8b'  		0x0c  	}' 100))  		reader.BaseStream.Position += 3;  	else if (FindAoBInFile (reader' keyRef - 100' new byte[] {  		0x8b'  		0x86  	}' 100))  		reader.BaseStream.Position += 2;  	else  		throw new Exception ("could not find start of StringPool::offset_ms_aString");  	offset_StringPool__ms_aString = reader.ReadInt32 () - ImageBase;  	Status ("StringPool::ms_aString located at {0:X8}"' offset_StringPool__ms_aString);  	//search for xrefs to function StringPool::GetString(uint' char)   	int[] xref = FindCalls (offset_StringPool__GetString_uint_char' 2);  	if (xref.Length != 2)  		throw new Exception ("failed to find references to StringPool::GetString(uint' char)");  	//search for start of StringPool::GetString(uint)  	if (!FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x51'  		0x8b  	}' 50) && !FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x55'  		0x8b  	}' 50))  		throw new Exception ("could not find start of GetString(uint)");  	int offset_StringPool__GetString_uint = (int)reader.BaseStream.Position;  	Status ("StringPool::GetString(uint) located at {0:X8}"' offset_StringPool__GetString_uint);  	//search for start of StringPool::GetString(uint' ushort)  	for (reader.BaseStream.Position = xref [1]; (reader.ReadUInt32 () & 0xffffff00) != 0x000cc200; reader.BaseStream.Position -= 5)  		;  	//seek the start of function StringPool::GetString(uint' char)  	while (reader.ReadByte () == 0xcc)  		;  	// allign  	reader.BaseStream.Position -= 1;  	int offset_StringPool__GetString_uint_ushort = (int)reader.BaseStream.Position;  	Status ("StringPool::GetString(uint' ushort) located at {0:X8}"' offset_StringPool__GetString_uint_ushort);  	//search for xrefs to function StringPool::GetString(uint)  	xref = FindCalls (offset_StringPool__GetString_uint' 1);  	if (xref.Length != 1)  		throw new Exception ("failed to find references to StringPool::GetString(uint)");  	//search for start of function StringPool::GetBSTR(uint)  	reader.BaseStream.Position -= 100;  	// should be enough  	if (!FindAoBInFile (reader' (int)reader.BaseStream.Position' new byte[] {  		0xb8'  		0xaa'  		0xaa'  		0xaa'  		0x00  	}))  		for (reader.BaseStream.Position = xref [0]; (reader.ReadUInt32 () & 0xff00ff00) != 0x0000c200; reader.BaseStream.Position -= 5)  			;  	//seek the start of function StringPool::GetString(uint' char)  	while (reader.ReadByte () == 0xcc)  		;  	// allign  	reader.BaseStream.Position -= 1;  	int offset_StringPool__GetBSTR_uint = (int)reader.BaseStream.Position;  	Status ("StringPool::GetBSTR(uint) located at {0:X8}"' offset_StringPool__GetBSTR_uint);  	//search for xrefs to function StringPool::GetString(uint' ushort)  	xref = FindCalls (offset_StringPool__GetString_uint_ushort' 1);  	if (xref.Length != 1)  		throw new Exception ("failed to find references to StringPool::GetString(uint' ushort)");  	//search for start of function StringPool::GetStringW(uint)  	if (!FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x51'  		0x8b  	}' 50) && !FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x55'  		0x8b  	}' 50))  		throw new Exception ("could not find start of GetStringW(uint)");  	int offset_StringPool__GetStringW_uint = (int)reader.BaseStream.Position;  	Status ("StringPool::GetStringW(uint) located at {0:X8}"' offset_StringPool__GetStringW_uint);  	ms_nSize = GetIntFromOffset (offset_StringPool__ms_aKey + 16 + 4);  	Status ("Amount of strings: {0}"' ms_nSize);  	if (MessageBox.Show ("Scan for references to strings in the client? This can take a while."' "Warning"' MessageBoxButtons.YesNo' MessageBoxIcon.Warning) == DialogResult.Yes) {  		Status ("Searching for references to GetString' GetStringW' and GetBSTR");  		List<int> GetStringCalls = new List<int> ();  		List<int> GetStringWCalls = new List<int> ();  		List<int> GetBSTRCalls = new List<int> ();  		for (reader.BaseStream.Position = 0; reader.BaseStream.Position < reader.BaseStream.Length;) {  			//int lol = (int)((float)reader.BaseStream.Position / reader.BaseStream.Length * 100);  			//if (lol > MainForm.toolStripProgressBar1.Value)  			//{  			//    MainForm.Invoke(() => MainForm.toolStripProgressBar1.Value = lol);  			//    MainForm.Invoke(() => MainForm.Update());  			//} too expensive  			if (reader.ReadByte () != 0xE8)  				// call  				continue;  			int offset = reader.ReadInt32 ();  			if (reader.BaseStream.Position + offset == offset_StringPool__GetString_uint)  				GetStringCalls.Add ((int)reader.BaseStream.Position - 5);  			else if (reader.BaseStream.Position + offset == offset_StringPool__GetStringW_uint)  				GetStringWCalls.Add ((int)reader.BaseStream.Position - 5);  			else if (reader.BaseStream.Position + offset == offset_StringPool__GetBSTR_uint)  				GetBSTRCalls.Add ((int)reader.BaseStream.Position - 5);  			else  				reader.BaseStream.Position -= 4;  		}  		List<int> GetStringFail = new List<int> ();  		foreach (int addr in GetStringCalls) {  			reader.BaseStream.Position = addr;  			reader.BaseStream.Position -= 2;  			if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  			 {  				GetStringFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 7;  			if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  			 {  				GetStringFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 2;  			if (reader.ReadByte () != 0x50)// push eax  			 {  				GetStringFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 6;  			if (reader.ReadByte () != 0x68)// push dword  			 {  				GetStringFail.Add (addr);  				continue;  			}  			int idx = reader.ReadInt32 ();  			if (idx > ms_nSize - 1)  				GetStringFail.Add (addr);  			else  				GetString.Add (addr' idx);  		}  		List<int> GetStringWFail = new List<int> ();  		foreach (int addr in GetStringWCalls) {  			reader.BaseStream.Position = addr;  			reader.BaseStream.Position -= 2;  			if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 7;  			if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 2;  			if (reader.ReadByte () != 0x50)// push eax  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 6;  			if (reader.ReadByte () != 0x68)// push dword  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			int idx = reader.ReadInt32 ();  			if (idx > ms_nSize - 1)  				GetStringWFail.Add (addr);  			else  				GetStringW.Add (addr' idx);  		}  		List<int> GetBSTRFail = new List<int> ();  		foreach (int addr in GetBSTRCalls) {  			reader.BaseStream.Position = addr;  			reader.BaseStream.Position -= 2;  			if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 7;  			if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 2;  			if (reader.ReadByte () != 0x50)// push eax  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 6;  			if (reader.ReadByte () != 0x68)// push dword  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			int idx = reader.ReadInt32 ();  			if (idx > ms_nSize - 1)  				GetBSTRFail.Add (addr);  			else  				GetBSTR.Add (addr' idx);  		}  		Status ("Failed to find index of {0} references"' GetStringFail.Count + GetStringWFail.Count + GetBSTRFail.Count);  	}  	Status ("Successfully found index of {0} references"' GetString.Count + GetBSTR.Count + GetStringW.Count);  	Status ("Decoding strings");  	for (int index = 0; index < ms_nSize; ++index)  		if (index != -1 && index <= 0xffff)  			Strings.Add (index' StringPoolDecode (index));  	Status ("Populating table");  	foreach (var s in Strings)  		MainForm.Invoke (() => MainForm.dataTable.Rows.Add (s.Key' s.Value' string.Empty));  	foreach (var a in GetString)  		MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetString")));  	foreach (var a in GetBSTR)  		MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetBSTR")));  	foreach (var a in GetStringW)  		MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetStringW")));  }  else if (StringDecodeMethod == 1)// StringDecoder   {  	MainForm.Invoke (() => MainForm.Text += " [StringDecoder]");  	int type = 0;  	int name = 0;  	int offset = 0;  	//search for CStringDecoder::DelayedLoad' which contains the resource type and name  	if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00'  		0x89'  		0x45'  		0xF4'  		0x6A'  		0xAA'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x8B'  		0x4D'  		0xF4'  		0x51'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 12;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 1;  		name = reader.ReadInt32 ();  	}  	else if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00'  		0x6A'  		0xAA'  		0x8B'  		0xF8'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x57'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 9;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 3;  		name = reader.ReadInt32 ();  	}  	else if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0xAA'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 1;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 1;  		name = reader.ReadInt32 ();  	}  	else  		throw new Exception ("Failed to determine type and name of resource.");  	//search for start of function CStringDecoder::DelayedLoad()  	reader.BaseStream.Position -= 50;  	// should be enough  	FindAoBInFile (reader' (int)reader.BaseStream.Position' new byte[] {  		0x55'  		0x8B'  		0xEC'  		0x83'  		0xEC'  		0x10  	});  	int offset_CStringDecoder__DelayedLoad = (int)reader.BaseStream.Position;  	for (reader.BaseStream.Position = 0; reader.BaseStream.Position < reader.BaseStream.Length;) {  		if (reader.ReadByte () != 0xE8)  			// call  			continue;  		int offse = reader.ReadInt32 ();  		if (reader.BaseStream.Position + offse == offset_CStringDecoder__DelayedLoad) {  			Status ("{0:X8} reference to offset_CStringDecoder__DelayedLoad = {1:X8}"' reader.BaseStream.Position - 5' offse);  			break;  		}  	}  	ImageResourceDirectory tier1 = (ImageResourceDirectory)root.GetEntry (type).Entry;  	ImageResourceDirectory tier2 = (ImageResourceDirectory)tier1.GetEntry (name).Entry;  	rsrcStringDataEntry = (ImageResourceDataEntry)tier2.Entrys [0].Entry;  	rsrcStringDataPosition = rsrcPointerToRawData + (rsrcStringDataEntry.OffsetToData - rsrcVirtualAddress);  	m_nCount = GetWordFromIndex (0);  	Status ("Amount of strings: {0}"' m_nCount);  	for (int i = 1; i < m_nCount; ++i)  		MainForm.Invoke (() => MainForm.dataTable.Rows.Add (i' StringDecoderDecode (i)' string.Format ("{0:X8}"' rsrcStringDataPosition + i * 4)));  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: if (StringDecodeMethod == 0)// StringPool   {  	MainForm.Invoke (() => MainForm.Text += " [StringPool]");  	int offset_StringPool__ms_aKey = (int)reader.BaseStream.Position;  	Status ("StringPool::ms_aKey located at {0:X8}"' offset_StringPool__ms_aKey);  	int keyRef = 0;  	// Only GetString references ms_aKey  	byte[] bytes = new byte[5];  	bytes [0] = 0x68;  	// push offset  	Buffer.BlockCopy (BitConverter.GetBytes (ImageBase + offset_StringPool__ms_aKey)' 0' bytes' 1' 4);  	if (FindAoBInFile (reader' 0' bytes))  		keyRef = (int)reader.BaseStream.Position;  	reader.BaseStream.Position = keyRef;  	while (true) {  		byte[] asdf = reader.ReadBytes (5);  		if (asdf [4] == 0xc3)// retn  		 {  			bool die = true;  			foreach (byte b in asdf)  				if (b == 0xe8)// call  				 {  					die = false;  					break;  				}  			if (die)  				break;  		}  		reader.BaseStream.Position -= 6;  	}  	while (reader.ReadByte () == 0xcc)  		;  	// allign  	reader.BaseStream.Position -= 1;  	int offset_StringPool__GetString_uint_char = (int)reader.BaseStream.Position;  	Status ("StringPool::GetString(uint' char) located at {0:X8}"' offset_StringPool__GetString_uint_char);  	//search for StringPool::offset_ms_aString  	if (FindAoBInFile (reader' keyRef - 100' new byte[] {  		0x8b'  		0x0c  	}' 100))  		reader.BaseStream.Position += 3;  	else if (FindAoBInFile (reader' keyRef - 100' new byte[] {  		0x8b'  		0x86  	}' 100))  		reader.BaseStream.Position += 2;  	else  		throw new Exception ("could not find start of StringPool::offset_ms_aString");  	offset_StringPool__ms_aString = reader.ReadInt32 () - ImageBase;  	Status ("StringPool::ms_aString located at {0:X8}"' offset_StringPool__ms_aString);  	//search for xrefs to function StringPool::GetString(uint' char)   	int[] xref = FindCalls (offset_StringPool__GetString_uint_char' 2);  	if (xref.Length != 2)  		throw new Exception ("failed to find references to StringPool::GetString(uint' char)");  	//search for start of StringPool::GetString(uint)  	if (!FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x51'  		0x8b  	}' 50) && !FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x55'  		0x8b  	}' 50))  		throw new Exception ("could not find start of GetString(uint)");  	int offset_StringPool__GetString_uint = (int)reader.BaseStream.Position;  	Status ("StringPool::GetString(uint) located at {0:X8}"' offset_StringPool__GetString_uint);  	//search for start of StringPool::GetString(uint' ushort)  	for (reader.BaseStream.Position = xref [1]; (reader.ReadUInt32 () & 0xffffff00) != 0x000cc200; reader.BaseStream.Position -= 5)  		;  	//seek the start of function StringPool::GetString(uint' char)  	while (reader.ReadByte () == 0xcc)  		;  	// allign  	reader.BaseStream.Position -= 1;  	int offset_StringPool__GetString_uint_ushort = (int)reader.BaseStream.Position;  	Status ("StringPool::GetString(uint' ushort) located at {0:X8}"' offset_StringPool__GetString_uint_ushort);  	//search for xrefs to function StringPool::GetString(uint)  	xref = FindCalls (offset_StringPool__GetString_uint' 1);  	if (xref.Length != 1)  		throw new Exception ("failed to find references to StringPool::GetString(uint)");  	//search for start of function StringPool::GetBSTR(uint)  	reader.BaseStream.Position -= 100;  	// should be enough  	if (!FindAoBInFile (reader' (int)reader.BaseStream.Position' new byte[] {  		0xb8'  		0xaa'  		0xaa'  		0xaa'  		0x00  	}))  		for (reader.BaseStream.Position = xref [0]; (reader.ReadUInt32 () & 0xff00ff00) != 0x0000c200; reader.BaseStream.Position -= 5)  			;  	//seek the start of function StringPool::GetString(uint' char)  	while (reader.ReadByte () == 0xcc)  		;  	// allign  	reader.BaseStream.Position -= 1;  	int offset_StringPool__GetBSTR_uint = (int)reader.BaseStream.Position;  	Status ("StringPool::GetBSTR(uint) located at {0:X8}"' offset_StringPool__GetBSTR_uint);  	//search for xrefs to function StringPool::GetString(uint' ushort)  	xref = FindCalls (offset_StringPool__GetString_uint_ushort' 1);  	if (xref.Length != 1)  		throw new Exception ("failed to find references to StringPool::GetString(uint' ushort)");  	//search for start of function StringPool::GetStringW(uint)  	if (!FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x51'  		0x8b  	}' 50) && !FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x55'  		0x8b  	}' 50))  		throw new Exception ("could not find start of GetStringW(uint)");  	int offset_StringPool__GetStringW_uint = (int)reader.BaseStream.Position;  	Status ("StringPool::GetStringW(uint) located at {0:X8}"' offset_StringPool__GetStringW_uint);  	ms_nSize = GetIntFromOffset (offset_StringPool__ms_aKey + 16 + 4);  	Status ("Amount of strings: {0}"' ms_nSize);  	if (MessageBox.Show ("Scan for references to strings in the client? This can take a while."' "Warning"' MessageBoxButtons.YesNo' MessageBoxIcon.Warning) == DialogResult.Yes) {  		Status ("Searching for references to GetString' GetStringW' and GetBSTR");  		List<int> GetStringCalls = new List<int> ();  		List<int> GetStringWCalls = new List<int> ();  		List<int> GetBSTRCalls = new List<int> ();  		for (reader.BaseStream.Position = 0; reader.BaseStream.Position < reader.BaseStream.Length;) {  			//int lol = (int)((float)reader.BaseStream.Position / reader.BaseStream.Length * 100);  			//if (lol > MainForm.toolStripProgressBar1.Value)  			//{  			//    MainForm.Invoke(() => MainForm.toolStripProgressBar1.Value = lol);  			//    MainForm.Invoke(() => MainForm.Update());  			//} too expensive  			if (reader.ReadByte () != 0xE8)  				// call  				continue;  			int offset = reader.ReadInt32 ();  			if (reader.BaseStream.Position + offset == offset_StringPool__GetString_uint)  				GetStringCalls.Add ((int)reader.BaseStream.Position - 5);  			else if (reader.BaseStream.Position + offset == offset_StringPool__GetStringW_uint)  				GetStringWCalls.Add ((int)reader.BaseStream.Position - 5);  			else if (reader.BaseStream.Position + offset == offset_StringPool__GetBSTR_uint)  				GetBSTRCalls.Add ((int)reader.BaseStream.Position - 5);  			else  				reader.BaseStream.Position -= 4;  		}  		List<int> GetStringFail = new List<int> ();  		foreach (int addr in GetStringCalls) {  			reader.BaseStream.Position = addr;  			reader.BaseStream.Position -= 2;  			if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  			 {  				GetStringFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 7;  			if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  			 {  				GetStringFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 2;  			if (reader.ReadByte () != 0x50)// push eax  			 {  				GetStringFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 6;  			if (reader.ReadByte () != 0x68)// push dword  			 {  				GetStringFail.Add (addr);  				continue;  			}  			int idx = reader.ReadInt32 ();  			if (idx > ms_nSize - 1)  				GetStringFail.Add (addr);  			else  				GetString.Add (addr' idx);  		}  		List<int> GetStringWFail = new List<int> ();  		foreach (int addr in GetStringWCalls) {  			reader.BaseStream.Position = addr;  			reader.BaseStream.Position -= 2;  			if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 7;  			if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 2;  			if (reader.ReadByte () != 0x50)// push eax  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 6;  			if (reader.ReadByte () != 0x68)// push dword  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			int idx = reader.ReadInt32 ();  			if (idx > ms_nSize - 1)  				GetStringWFail.Add (addr);  			else  				GetStringW.Add (addr' idx);  		}  		List<int> GetBSTRFail = new List<int> ();  		foreach (int addr in GetBSTRCalls) {  			reader.BaseStream.Position = addr;  			reader.BaseStream.Position -= 2;  			if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 7;  			if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 2;  			if (reader.ReadByte () != 0x50)// push eax  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 6;  			if (reader.ReadByte () != 0x68)// push dword  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			int idx = reader.ReadInt32 ();  			if (idx > ms_nSize - 1)  				GetBSTRFail.Add (addr);  			else  				GetBSTR.Add (addr' idx);  		}  		Status ("Failed to find index of {0} references"' GetStringFail.Count + GetStringWFail.Count + GetBSTRFail.Count);  	}  	Status ("Successfully found index of {0} references"' GetString.Count + GetBSTR.Count + GetStringW.Count);  	Status ("Decoding strings");  	for (int index = 0; index < ms_nSize; ++index)  		if (index != -1 && index <= 0xffff)  			Strings.Add (index' StringPoolDecode (index));  	Status ("Populating table");  	foreach (var s in Strings)  		MainForm.Invoke (() => MainForm.dataTable.Rows.Add (s.Key' s.Value' string.Empty));  	foreach (var a in GetString)  		MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetString")));  	foreach (var a in GetBSTR)  		MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetBSTR")));  	foreach (var a in GetStringW)  		MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetStringW")));  }  else if (StringDecodeMethod == 1)// StringDecoder   {  	MainForm.Invoke (() => MainForm.Text += " [StringDecoder]");  	int type = 0;  	int name = 0;  	int offset = 0;  	//search for CStringDecoder::DelayedLoad' which contains the resource type and name  	if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00'  		0x89'  		0x45'  		0xF4'  		0x6A'  		0xAA'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x8B'  		0x4D'  		0xF4'  		0x51'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 12;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 1;  		name = reader.ReadInt32 ();  	}  	else if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00'  		0x6A'  		0xAA'  		0x8B'  		0xF8'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x57'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 9;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 3;  		name = reader.ReadInt32 ();  	}  	else if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0xAA'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 1;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 1;  		name = reader.ReadInt32 ();  	}  	else  		throw new Exception ("Failed to determine type and name of resource.");  	//search for start of function CStringDecoder::DelayedLoad()  	reader.BaseStream.Position -= 50;  	// should be enough  	FindAoBInFile (reader' (int)reader.BaseStream.Position' new byte[] {  		0x55'  		0x8B'  		0xEC'  		0x83'  		0xEC'  		0x10  	});  	int offset_CStringDecoder__DelayedLoad = (int)reader.BaseStream.Position;  	for (reader.BaseStream.Position = 0; reader.BaseStream.Position < reader.BaseStream.Length;) {  		if (reader.ReadByte () != 0xE8)  			// call  			continue;  		int offse = reader.ReadInt32 ();  		if (reader.BaseStream.Position + offse == offset_CStringDecoder__DelayedLoad) {  			Status ("{0:X8} reference to offset_CStringDecoder__DelayedLoad = {1:X8}"' reader.BaseStream.Position - 5' offse);  			break;  		}  	}  	ImageResourceDirectory tier1 = (ImageResourceDirectory)root.GetEntry (type).Entry;  	ImageResourceDirectory tier2 = (ImageResourceDirectory)tier1.GetEntry (name).Entry;  	rsrcStringDataEntry = (ImageResourceDataEntry)tier2.Entrys [0].Entry;  	rsrcStringDataPosition = rsrcPointerToRawData + (rsrcStringDataEntry.OffsetToData - rsrcVirtualAddress);  	m_nCount = GetWordFromIndex (0);  	Status ("Amount of strings: {0}"' m_nCount);  	for (int i = 1; i < m_nCount; ++i)  		MainForm.Invoke (() => MainForm.dataTable.Rows.Add (i' StringDecoderDecode (i)' string.Format ("{0:X8}"' rsrcStringDataPosition + i * 4)));  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: if (StringDecodeMethod == 0)// StringPool   {  	MainForm.Invoke (() => MainForm.Text += " [StringPool]");  	int offset_StringPool__ms_aKey = (int)reader.BaseStream.Position;  	Status ("StringPool::ms_aKey located at {0:X8}"' offset_StringPool__ms_aKey);  	int keyRef = 0;  	// Only GetString references ms_aKey  	byte[] bytes = new byte[5];  	bytes [0] = 0x68;  	// push offset  	Buffer.BlockCopy (BitConverter.GetBytes (ImageBase + offset_StringPool__ms_aKey)' 0' bytes' 1' 4);  	if (FindAoBInFile (reader' 0' bytes))  		keyRef = (int)reader.BaseStream.Position;  	reader.BaseStream.Position = keyRef;  	while (true) {  		byte[] asdf = reader.ReadBytes (5);  		if (asdf [4] == 0xc3)// retn  		 {  			bool die = true;  			foreach (byte b in asdf)  				if (b == 0xe8)// call  				 {  					die = false;  					break;  				}  			if (die)  				break;  		}  		reader.BaseStream.Position -= 6;  	}  	while (reader.ReadByte () == 0xcc)  		;  	// allign  	reader.BaseStream.Position -= 1;  	int offset_StringPool__GetString_uint_char = (int)reader.BaseStream.Position;  	Status ("StringPool::GetString(uint' char) located at {0:X8}"' offset_StringPool__GetString_uint_char);  	//search for StringPool::offset_ms_aString  	if (FindAoBInFile (reader' keyRef - 100' new byte[] {  		0x8b'  		0x0c  	}' 100))  		reader.BaseStream.Position += 3;  	else if (FindAoBInFile (reader' keyRef - 100' new byte[] {  		0x8b'  		0x86  	}' 100))  		reader.BaseStream.Position += 2;  	else  		throw new Exception ("could not find start of StringPool::offset_ms_aString");  	offset_StringPool__ms_aString = reader.ReadInt32 () - ImageBase;  	Status ("StringPool::ms_aString located at {0:X8}"' offset_StringPool__ms_aString);  	//search for xrefs to function StringPool::GetString(uint' char)   	int[] xref = FindCalls (offset_StringPool__GetString_uint_char' 2);  	if (xref.Length != 2)  		throw new Exception ("failed to find references to StringPool::GetString(uint' char)");  	//search for start of StringPool::GetString(uint)  	if (!FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x51'  		0x8b  	}' 50) && !FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x55'  		0x8b  	}' 50))  		throw new Exception ("could not find start of GetString(uint)");  	int offset_StringPool__GetString_uint = (int)reader.BaseStream.Position;  	Status ("StringPool::GetString(uint) located at {0:X8}"' offset_StringPool__GetString_uint);  	//search for start of StringPool::GetString(uint' ushort)  	for (reader.BaseStream.Position = xref [1]; (reader.ReadUInt32 () & 0xffffff00) != 0x000cc200; reader.BaseStream.Position -= 5)  		;  	//seek the start of function StringPool::GetString(uint' char)  	while (reader.ReadByte () == 0xcc)  		;  	// allign  	reader.BaseStream.Position -= 1;  	int offset_StringPool__GetString_uint_ushort = (int)reader.BaseStream.Position;  	Status ("StringPool::GetString(uint' ushort) located at {0:X8}"' offset_StringPool__GetString_uint_ushort);  	//search for xrefs to function StringPool::GetString(uint)  	xref = FindCalls (offset_StringPool__GetString_uint' 1);  	if (xref.Length != 1)  		throw new Exception ("failed to find references to StringPool::GetString(uint)");  	//search for start of function StringPool::GetBSTR(uint)  	reader.BaseStream.Position -= 100;  	// should be enough  	if (!FindAoBInFile (reader' (int)reader.BaseStream.Position' new byte[] {  		0xb8'  		0xaa'  		0xaa'  		0xaa'  		0x00  	}))  		for (reader.BaseStream.Position = xref [0]; (reader.ReadUInt32 () & 0xff00ff00) != 0x0000c200; reader.BaseStream.Position -= 5)  			;  	//seek the start of function StringPool::GetString(uint' char)  	while (reader.ReadByte () == 0xcc)  		;  	// allign  	reader.BaseStream.Position -= 1;  	int offset_StringPool__GetBSTR_uint = (int)reader.BaseStream.Position;  	Status ("StringPool::GetBSTR(uint) located at {0:X8}"' offset_StringPool__GetBSTR_uint);  	//search for xrefs to function StringPool::GetString(uint' ushort)  	xref = FindCalls (offset_StringPool__GetString_uint_ushort' 1);  	if (xref.Length != 1)  		throw new Exception ("failed to find references to StringPool::GetString(uint' ushort)");  	//search for start of function StringPool::GetStringW(uint)  	if (!FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x51'  		0x8b  	}' 50) && !FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x55'  		0x8b  	}' 50))  		throw new Exception ("could not find start of GetStringW(uint)");  	int offset_StringPool__GetStringW_uint = (int)reader.BaseStream.Position;  	Status ("StringPool::GetStringW(uint) located at {0:X8}"' offset_StringPool__GetStringW_uint);  	ms_nSize = GetIntFromOffset (offset_StringPool__ms_aKey + 16 + 4);  	Status ("Amount of strings: {0}"' ms_nSize);  	if (MessageBox.Show ("Scan for references to strings in the client? This can take a while."' "Warning"' MessageBoxButtons.YesNo' MessageBoxIcon.Warning) == DialogResult.Yes) {  		Status ("Searching for references to GetString' GetStringW' and GetBSTR");  		List<int> GetStringCalls = new List<int> ();  		List<int> GetStringWCalls = new List<int> ();  		List<int> GetBSTRCalls = new List<int> ();  		for (reader.BaseStream.Position = 0; reader.BaseStream.Position < reader.BaseStream.Length;) {  			//int lol = (int)((float)reader.BaseStream.Position / reader.BaseStream.Length * 100);  			//if (lol > MainForm.toolStripProgressBar1.Value)  			//{  			//    MainForm.Invoke(() => MainForm.toolStripProgressBar1.Value = lol);  			//    MainForm.Invoke(() => MainForm.Update());  			//} too expensive  			if (reader.ReadByte () != 0xE8)  				// call  				continue;  			int offset = reader.ReadInt32 ();  			if (reader.BaseStream.Position + offset == offset_StringPool__GetString_uint)  				GetStringCalls.Add ((int)reader.BaseStream.Position - 5);  			else if (reader.BaseStream.Position + offset == offset_StringPool__GetStringW_uint)  				GetStringWCalls.Add ((int)reader.BaseStream.Position - 5);  			else if (reader.BaseStream.Position + offset == offset_StringPool__GetBSTR_uint)  				GetBSTRCalls.Add ((int)reader.BaseStream.Position - 5);  			else  				reader.BaseStream.Position -= 4;  		}  		List<int> GetStringFail = new List<int> ();  		foreach (int addr in GetStringCalls) {  			reader.BaseStream.Position = addr;  			reader.BaseStream.Position -= 2;  			if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  			 {  				GetStringFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 7;  			if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  			 {  				GetStringFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 2;  			if (reader.ReadByte () != 0x50)// push eax  			 {  				GetStringFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 6;  			if (reader.ReadByte () != 0x68)// push dword  			 {  				GetStringFail.Add (addr);  				continue;  			}  			int idx = reader.ReadInt32 ();  			if (idx > ms_nSize - 1)  				GetStringFail.Add (addr);  			else  				GetString.Add (addr' idx);  		}  		List<int> GetStringWFail = new List<int> ();  		foreach (int addr in GetStringWCalls) {  			reader.BaseStream.Position = addr;  			reader.BaseStream.Position -= 2;  			if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 7;  			if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 2;  			if (reader.ReadByte () != 0x50)// push eax  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 6;  			if (reader.ReadByte () != 0x68)// push dword  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			int idx = reader.ReadInt32 ();  			if (idx > ms_nSize - 1)  				GetStringWFail.Add (addr);  			else  				GetStringW.Add (addr' idx);  		}  		List<int> GetBSTRFail = new List<int> ();  		foreach (int addr in GetBSTRCalls) {  			reader.BaseStream.Position = addr;  			reader.BaseStream.Position -= 2;  			if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 7;  			if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 2;  			if (reader.ReadByte () != 0x50)// push eax  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 6;  			if (reader.ReadByte () != 0x68)// push dword  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			int idx = reader.ReadInt32 ();  			if (idx > ms_nSize - 1)  				GetBSTRFail.Add (addr);  			else  				GetBSTR.Add (addr' idx);  		}  		Status ("Failed to find index of {0} references"' GetStringFail.Count + GetStringWFail.Count + GetBSTRFail.Count);  	}  	Status ("Successfully found index of {0} references"' GetString.Count + GetBSTR.Count + GetStringW.Count);  	Status ("Decoding strings");  	for (int index = 0; index < ms_nSize; ++index)  		if (index != -1 && index <= 0xffff)  			Strings.Add (index' StringPoolDecode (index));  	Status ("Populating table");  	foreach (var s in Strings)  		MainForm.Invoke (() => MainForm.dataTable.Rows.Add (s.Key' s.Value' string.Empty));  	foreach (var a in GetString)  		MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetString")));  	foreach (var a in GetBSTR)  		MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetBSTR")));  	foreach (var a in GetStringW)  		MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetStringW")));  }  else if (StringDecodeMethod == 1)// StringDecoder   {  	MainForm.Invoke (() => MainForm.Text += " [StringDecoder]");  	int type = 0;  	int name = 0;  	int offset = 0;  	//search for CStringDecoder::DelayedLoad' which contains the resource type and name  	if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00'  		0x89'  		0x45'  		0xF4'  		0x6A'  		0xAA'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x8B'  		0x4D'  		0xF4'  		0x51'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 12;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 1;  		name = reader.ReadInt32 ();  	}  	else if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00'  		0x6A'  		0xAA'  		0x8B'  		0xF8'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x57'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 9;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 3;  		name = reader.ReadInt32 ();  	}  	else if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0xAA'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 1;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 1;  		name = reader.ReadInt32 ();  	}  	else  		throw new Exception ("Failed to determine type and name of resource.");  	//search for start of function CStringDecoder::DelayedLoad()  	reader.BaseStream.Position -= 50;  	// should be enough  	FindAoBInFile (reader' (int)reader.BaseStream.Position' new byte[] {  		0x55'  		0x8B'  		0xEC'  		0x83'  		0xEC'  		0x10  	});  	int offset_CStringDecoder__DelayedLoad = (int)reader.BaseStream.Position;  	for (reader.BaseStream.Position = 0; reader.BaseStream.Position < reader.BaseStream.Length;) {  		if (reader.ReadByte () != 0xE8)  			// call  			continue;  		int offse = reader.ReadInt32 ();  		if (reader.BaseStream.Position + offse == offset_CStringDecoder__DelayedLoad) {  			Status ("{0:X8} reference to offset_CStringDecoder__DelayedLoad = {1:X8}"' reader.BaseStream.Position - 5' offse);  			break;  		}  	}  	ImageResourceDirectory tier1 = (ImageResourceDirectory)root.GetEntry (type).Entry;  	ImageResourceDirectory tier2 = (ImageResourceDirectory)tier1.GetEntry (name).Entry;  	rsrcStringDataEntry = (ImageResourceDataEntry)tier2.Entrys [0].Entry;  	rsrcStringDataPosition = rsrcPointerToRawData + (rsrcStringDataEntry.OffsetToData - rsrcVirtualAddress);  	m_nCount = GetWordFromIndex (0);  	Status ("Amount of strings: {0}"' m_nCount);  	for (int i = 1; i < m_nCount; ++i)  		MainForm.Invoke (() => MainForm.dataTable.Rows.Add (i' StringDecoderDecode (i)' string.Format ("{0:X8}"' rsrcStringDataPosition + i * 4)));  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: if (StringDecodeMethod == 0)// StringPool   {  	MainForm.Invoke (() => MainForm.Text += " [StringPool]");  	int offset_StringPool__ms_aKey = (int)reader.BaseStream.Position;  	Status ("StringPool::ms_aKey located at {0:X8}"' offset_StringPool__ms_aKey);  	int keyRef = 0;  	// Only GetString references ms_aKey  	byte[] bytes = new byte[5];  	bytes [0] = 0x68;  	// push offset  	Buffer.BlockCopy (BitConverter.GetBytes (ImageBase + offset_StringPool__ms_aKey)' 0' bytes' 1' 4);  	if (FindAoBInFile (reader' 0' bytes))  		keyRef = (int)reader.BaseStream.Position;  	reader.BaseStream.Position = keyRef;  	while (true) {  		byte[] asdf = reader.ReadBytes (5);  		if (asdf [4] == 0xc3)// retn  		 {  			bool die = true;  			foreach (byte b in asdf)  				if (b == 0xe8)// call  				 {  					die = false;  					break;  				}  			if (die)  				break;  		}  		reader.BaseStream.Position -= 6;  	}  	while (reader.ReadByte () == 0xcc)  		;  	// allign  	reader.BaseStream.Position -= 1;  	int offset_StringPool__GetString_uint_char = (int)reader.BaseStream.Position;  	Status ("StringPool::GetString(uint' char) located at {0:X8}"' offset_StringPool__GetString_uint_char);  	//search for StringPool::offset_ms_aString  	if (FindAoBInFile (reader' keyRef - 100' new byte[] {  		0x8b'  		0x0c  	}' 100))  		reader.BaseStream.Position += 3;  	else if (FindAoBInFile (reader' keyRef - 100' new byte[] {  		0x8b'  		0x86  	}' 100))  		reader.BaseStream.Position += 2;  	else  		throw new Exception ("could not find start of StringPool::offset_ms_aString");  	offset_StringPool__ms_aString = reader.ReadInt32 () - ImageBase;  	Status ("StringPool::ms_aString located at {0:X8}"' offset_StringPool__ms_aString);  	//search for xrefs to function StringPool::GetString(uint' char)   	int[] xref = FindCalls (offset_StringPool__GetString_uint_char' 2);  	if (xref.Length != 2)  		throw new Exception ("failed to find references to StringPool::GetString(uint' char)");  	//search for start of StringPool::GetString(uint)  	if (!FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x51'  		0x8b  	}' 50) && !FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x55'  		0x8b  	}' 50))  		throw new Exception ("could not find start of GetString(uint)");  	int offset_StringPool__GetString_uint = (int)reader.BaseStream.Position;  	Status ("StringPool::GetString(uint) located at {0:X8}"' offset_StringPool__GetString_uint);  	//search for start of StringPool::GetString(uint' ushort)  	for (reader.BaseStream.Position = xref [1]; (reader.ReadUInt32 () & 0xffffff00) != 0x000cc200; reader.BaseStream.Position -= 5)  		;  	//seek the start of function StringPool::GetString(uint' char)  	while (reader.ReadByte () == 0xcc)  		;  	// allign  	reader.BaseStream.Position -= 1;  	int offset_StringPool__GetString_uint_ushort = (int)reader.BaseStream.Position;  	Status ("StringPool::GetString(uint' ushort) located at {0:X8}"' offset_StringPool__GetString_uint_ushort);  	//search for xrefs to function StringPool::GetString(uint)  	xref = FindCalls (offset_StringPool__GetString_uint' 1);  	if (xref.Length != 1)  		throw new Exception ("failed to find references to StringPool::GetString(uint)");  	//search for start of function StringPool::GetBSTR(uint)  	reader.BaseStream.Position -= 100;  	// should be enough  	if (!FindAoBInFile (reader' (int)reader.BaseStream.Position' new byte[] {  		0xb8'  		0xaa'  		0xaa'  		0xaa'  		0x00  	}))  		for (reader.BaseStream.Position = xref [0]; (reader.ReadUInt32 () & 0xff00ff00) != 0x0000c200; reader.BaseStream.Position -= 5)  			;  	//seek the start of function StringPool::GetString(uint' char)  	while (reader.ReadByte () == 0xcc)  		;  	// allign  	reader.BaseStream.Position -= 1;  	int offset_StringPool__GetBSTR_uint = (int)reader.BaseStream.Position;  	Status ("StringPool::GetBSTR(uint) located at {0:X8}"' offset_StringPool__GetBSTR_uint);  	//search for xrefs to function StringPool::GetString(uint' ushort)  	xref = FindCalls (offset_StringPool__GetString_uint_ushort' 1);  	if (xref.Length != 1)  		throw new Exception ("failed to find references to StringPool::GetString(uint' ushort)");  	//search for start of function StringPool::GetStringW(uint)  	if (!FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x51'  		0x8b  	}' 50) && !FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x55'  		0x8b  	}' 50))  		throw new Exception ("could not find start of GetStringW(uint)");  	int offset_StringPool__GetStringW_uint = (int)reader.BaseStream.Position;  	Status ("StringPool::GetStringW(uint) located at {0:X8}"' offset_StringPool__GetStringW_uint);  	ms_nSize = GetIntFromOffset (offset_StringPool__ms_aKey + 16 + 4);  	Status ("Amount of strings: {0}"' ms_nSize);  	if (MessageBox.Show ("Scan for references to strings in the client? This can take a while."' "Warning"' MessageBoxButtons.YesNo' MessageBoxIcon.Warning) == DialogResult.Yes) {  		Status ("Searching for references to GetString' GetStringW' and GetBSTR");  		List<int> GetStringCalls = new List<int> ();  		List<int> GetStringWCalls = new List<int> ();  		List<int> GetBSTRCalls = new List<int> ();  		for (reader.BaseStream.Position = 0; reader.BaseStream.Position < reader.BaseStream.Length;) {  			//int lol = (int)((float)reader.BaseStream.Position / reader.BaseStream.Length * 100);  			//if (lol > MainForm.toolStripProgressBar1.Value)  			//{  			//    MainForm.Invoke(() => MainForm.toolStripProgressBar1.Value = lol);  			//    MainForm.Invoke(() => MainForm.Update());  			//} too expensive  			if (reader.ReadByte () != 0xE8)  				// call  				continue;  			int offset = reader.ReadInt32 ();  			if (reader.BaseStream.Position + offset == offset_StringPool__GetString_uint)  				GetStringCalls.Add ((int)reader.BaseStream.Position - 5);  			else if (reader.BaseStream.Position + offset == offset_StringPool__GetStringW_uint)  				GetStringWCalls.Add ((int)reader.BaseStream.Position - 5);  			else if (reader.BaseStream.Position + offset == offset_StringPool__GetBSTR_uint)  				GetBSTRCalls.Add ((int)reader.BaseStream.Position - 5);  			else  				reader.BaseStream.Position -= 4;  		}  		List<int> GetStringFail = new List<int> ();  		foreach (int addr in GetStringCalls) {  			reader.BaseStream.Position = addr;  			reader.BaseStream.Position -= 2;  			if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  			 {  				GetStringFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 7;  			if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  			 {  				GetStringFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 2;  			if (reader.ReadByte () != 0x50)// push eax  			 {  				GetStringFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 6;  			if (reader.ReadByte () != 0x68)// push dword  			 {  				GetStringFail.Add (addr);  				continue;  			}  			int idx = reader.ReadInt32 ();  			if (idx > ms_nSize - 1)  				GetStringFail.Add (addr);  			else  				GetString.Add (addr' idx);  		}  		List<int> GetStringWFail = new List<int> ();  		foreach (int addr in GetStringWCalls) {  			reader.BaseStream.Position = addr;  			reader.BaseStream.Position -= 2;  			if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 7;  			if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 2;  			if (reader.ReadByte () != 0x50)// push eax  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 6;  			if (reader.ReadByte () != 0x68)// push dword  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			int idx = reader.ReadInt32 ();  			if (idx > ms_nSize - 1)  				GetStringWFail.Add (addr);  			else  				GetStringW.Add (addr' idx);  		}  		List<int> GetBSTRFail = new List<int> ();  		foreach (int addr in GetBSTRCalls) {  			reader.BaseStream.Position = addr;  			reader.BaseStream.Position -= 2;  			if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 7;  			if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 2;  			if (reader.ReadByte () != 0x50)// push eax  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 6;  			if (reader.ReadByte () != 0x68)// push dword  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			int idx = reader.ReadInt32 ();  			if (idx > ms_nSize - 1)  				GetBSTRFail.Add (addr);  			else  				GetBSTR.Add (addr' idx);  		}  		Status ("Failed to find index of {0} references"' GetStringFail.Count + GetStringWFail.Count + GetBSTRFail.Count);  	}  	Status ("Successfully found index of {0} references"' GetString.Count + GetBSTR.Count + GetStringW.Count);  	Status ("Decoding strings");  	for (int index = 0; index < ms_nSize; ++index)  		if (index != -1 && index <= 0xffff)  			Strings.Add (index' StringPoolDecode (index));  	Status ("Populating table");  	foreach (var s in Strings)  		MainForm.Invoke (() => MainForm.dataTable.Rows.Add (s.Key' s.Value' string.Empty));  	foreach (var a in GetString)  		MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetString")));  	foreach (var a in GetBSTR)  		MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetBSTR")));  	foreach (var a in GetStringW)  		MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetStringW")));  }  else if (StringDecodeMethod == 1)// StringDecoder   {  	MainForm.Invoke (() => MainForm.Text += " [StringDecoder]");  	int type = 0;  	int name = 0;  	int offset = 0;  	//search for CStringDecoder::DelayedLoad' which contains the resource type and name  	if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00'  		0x89'  		0x45'  		0xF4'  		0x6A'  		0xAA'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x8B'  		0x4D'  		0xF4'  		0x51'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 12;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 1;  		name = reader.ReadInt32 ();  	}  	else if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00'  		0x6A'  		0xAA'  		0x8B'  		0xF8'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x57'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 9;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 3;  		name = reader.ReadInt32 ();  	}  	else if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0xAA'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 1;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 1;  		name = reader.ReadInt32 ();  	}  	else  		throw new Exception ("Failed to determine type and name of resource.");  	//search for start of function CStringDecoder::DelayedLoad()  	reader.BaseStream.Position -= 50;  	// should be enough  	FindAoBInFile (reader' (int)reader.BaseStream.Position' new byte[] {  		0x55'  		0x8B'  		0xEC'  		0x83'  		0xEC'  		0x10  	});  	int offset_CStringDecoder__DelayedLoad = (int)reader.BaseStream.Position;  	for (reader.BaseStream.Position = 0; reader.BaseStream.Position < reader.BaseStream.Length;) {  		if (reader.ReadByte () != 0xE8)  			// call  			continue;  		int offse = reader.ReadInt32 ();  		if (reader.BaseStream.Position + offse == offset_CStringDecoder__DelayedLoad) {  			Status ("{0:X8} reference to offset_CStringDecoder__DelayedLoad = {1:X8}"' reader.BaseStream.Position - 5' offse);  			break;  		}  	}  	ImageResourceDirectory tier1 = (ImageResourceDirectory)root.GetEntry (type).Entry;  	ImageResourceDirectory tier2 = (ImageResourceDirectory)tier1.GetEntry (name).Entry;  	rsrcStringDataEntry = (ImageResourceDataEntry)tier2.Entrys [0].Entry;  	rsrcStringDataPosition = rsrcPointerToRawData + (rsrcStringDataEntry.OffsetToData - rsrcVirtualAddress);  	m_nCount = GetWordFromIndex (0);  	Status ("Amount of strings: {0}"' m_nCount);  	for (int i = 1; i < m_nCount; ++i)  		MainForm.Invoke (() => MainForm.dataTable.Rows.Add (i' StringDecoderDecode (i)' string.Format ("{0:X8}"' rsrcStringDataPosition + i * 4)));  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: if (StringDecodeMethod == 0)// StringPool   {  	MainForm.Invoke (() => MainForm.Text += " [StringPool]");  	int offset_StringPool__ms_aKey = (int)reader.BaseStream.Position;  	Status ("StringPool::ms_aKey located at {0:X8}"' offset_StringPool__ms_aKey);  	int keyRef = 0;  	// Only GetString references ms_aKey  	byte[] bytes = new byte[5];  	bytes [0] = 0x68;  	// push offset  	Buffer.BlockCopy (BitConverter.GetBytes (ImageBase + offset_StringPool__ms_aKey)' 0' bytes' 1' 4);  	if (FindAoBInFile (reader' 0' bytes))  		keyRef = (int)reader.BaseStream.Position;  	reader.BaseStream.Position = keyRef;  	while (true) {  		byte[] asdf = reader.ReadBytes (5);  		if (asdf [4] == 0xc3)// retn  		 {  			bool die = true;  			foreach (byte b in asdf)  				if (b == 0xe8)// call  				 {  					die = false;  					break;  				}  			if (die)  				break;  		}  		reader.BaseStream.Position -= 6;  	}  	while (reader.ReadByte () == 0xcc)  		;  	// allign  	reader.BaseStream.Position -= 1;  	int offset_StringPool__GetString_uint_char = (int)reader.BaseStream.Position;  	Status ("StringPool::GetString(uint' char) located at {0:X8}"' offset_StringPool__GetString_uint_char);  	//search for StringPool::offset_ms_aString  	if (FindAoBInFile (reader' keyRef - 100' new byte[] {  		0x8b'  		0x0c  	}' 100))  		reader.BaseStream.Position += 3;  	else if (FindAoBInFile (reader' keyRef - 100' new byte[] {  		0x8b'  		0x86  	}' 100))  		reader.BaseStream.Position += 2;  	else  		throw new Exception ("could not find start of StringPool::offset_ms_aString");  	offset_StringPool__ms_aString = reader.ReadInt32 () - ImageBase;  	Status ("StringPool::ms_aString located at {0:X8}"' offset_StringPool__ms_aString);  	//search for xrefs to function StringPool::GetString(uint' char)   	int[] xref = FindCalls (offset_StringPool__GetString_uint_char' 2);  	if (xref.Length != 2)  		throw new Exception ("failed to find references to StringPool::GetString(uint' char)");  	//search for start of StringPool::GetString(uint)  	if (!FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x51'  		0x8b  	}' 50) && !FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x55'  		0x8b  	}' 50))  		throw new Exception ("could not find start of GetString(uint)");  	int offset_StringPool__GetString_uint = (int)reader.BaseStream.Position;  	Status ("StringPool::GetString(uint) located at {0:X8}"' offset_StringPool__GetString_uint);  	//search for start of StringPool::GetString(uint' ushort)  	for (reader.BaseStream.Position = xref [1]; (reader.ReadUInt32 () & 0xffffff00) != 0x000cc200; reader.BaseStream.Position -= 5)  		;  	//seek the start of function StringPool::GetString(uint' char)  	while (reader.ReadByte () == 0xcc)  		;  	// allign  	reader.BaseStream.Position -= 1;  	int offset_StringPool__GetString_uint_ushort = (int)reader.BaseStream.Position;  	Status ("StringPool::GetString(uint' ushort) located at {0:X8}"' offset_StringPool__GetString_uint_ushort);  	//search for xrefs to function StringPool::GetString(uint)  	xref = FindCalls (offset_StringPool__GetString_uint' 1);  	if (xref.Length != 1)  		throw new Exception ("failed to find references to StringPool::GetString(uint)");  	//search for start of function StringPool::GetBSTR(uint)  	reader.BaseStream.Position -= 100;  	// should be enough  	if (!FindAoBInFile (reader' (int)reader.BaseStream.Position' new byte[] {  		0xb8'  		0xaa'  		0xaa'  		0xaa'  		0x00  	}))  		for (reader.BaseStream.Position = xref [0]; (reader.ReadUInt32 () & 0xff00ff00) != 0x0000c200; reader.BaseStream.Position -= 5)  			;  	//seek the start of function StringPool::GetString(uint' char)  	while (reader.ReadByte () == 0xcc)  		;  	// allign  	reader.BaseStream.Position -= 1;  	int offset_StringPool__GetBSTR_uint = (int)reader.BaseStream.Position;  	Status ("StringPool::GetBSTR(uint) located at {0:X8}"' offset_StringPool__GetBSTR_uint);  	//search for xrefs to function StringPool::GetString(uint' ushort)  	xref = FindCalls (offset_StringPool__GetString_uint_ushort' 1);  	if (xref.Length != 1)  		throw new Exception ("failed to find references to StringPool::GetString(uint' ushort)");  	//search for start of function StringPool::GetStringW(uint)  	if (!FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x51'  		0x8b  	}' 50) && !FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x55'  		0x8b  	}' 50))  		throw new Exception ("could not find start of GetStringW(uint)");  	int offset_StringPool__GetStringW_uint = (int)reader.BaseStream.Position;  	Status ("StringPool::GetStringW(uint) located at {0:X8}"' offset_StringPool__GetStringW_uint);  	ms_nSize = GetIntFromOffset (offset_StringPool__ms_aKey + 16 + 4);  	Status ("Amount of strings: {0}"' ms_nSize);  	if (MessageBox.Show ("Scan for references to strings in the client? This can take a while."' "Warning"' MessageBoxButtons.YesNo' MessageBoxIcon.Warning) == DialogResult.Yes) {  		Status ("Searching for references to GetString' GetStringW' and GetBSTR");  		List<int> GetStringCalls = new List<int> ();  		List<int> GetStringWCalls = new List<int> ();  		List<int> GetBSTRCalls = new List<int> ();  		for (reader.BaseStream.Position = 0; reader.BaseStream.Position < reader.BaseStream.Length;) {  			//int lol = (int)((float)reader.BaseStream.Position / reader.BaseStream.Length * 100);  			//if (lol > MainForm.toolStripProgressBar1.Value)  			//{  			//    MainForm.Invoke(() => MainForm.toolStripProgressBar1.Value = lol);  			//    MainForm.Invoke(() => MainForm.Update());  			//} too expensive  			if (reader.ReadByte () != 0xE8)  				// call  				continue;  			int offset = reader.ReadInt32 ();  			if (reader.BaseStream.Position + offset == offset_StringPool__GetString_uint)  				GetStringCalls.Add ((int)reader.BaseStream.Position - 5);  			else if (reader.BaseStream.Position + offset == offset_StringPool__GetStringW_uint)  				GetStringWCalls.Add ((int)reader.BaseStream.Position - 5);  			else if (reader.BaseStream.Position + offset == offset_StringPool__GetBSTR_uint)  				GetBSTRCalls.Add ((int)reader.BaseStream.Position - 5);  			else  				reader.BaseStream.Position -= 4;  		}  		List<int> GetStringFail = new List<int> ();  		foreach (int addr in GetStringCalls) {  			reader.BaseStream.Position = addr;  			reader.BaseStream.Position -= 2;  			if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  			 {  				GetStringFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 7;  			if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  			 {  				GetStringFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 2;  			if (reader.ReadByte () != 0x50)// push eax  			 {  				GetStringFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 6;  			if (reader.ReadByte () != 0x68)// push dword  			 {  				GetStringFail.Add (addr);  				continue;  			}  			int idx = reader.ReadInt32 ();  			if (idx > ms_nSize - 1)  				GetStringFail.Add (addr);  			else  				GetString.Add (addr' idx);  		}  		List<int> GetStringWFail = new List<int> ();  		foreach (int addr in GetStringWCalls) {  			reader.BaseStream.Position = addr;  			reader.BaseStream.Position -= 2;  			if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 7;  			if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 2;  			if (reader.ReadByte () != 0x50)// push eax  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 6;  			if (reader.ReadByte () != 0x68)// push dword  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			int idx = reader.ReadInt32 ();  			if (idx > ms_nSize - 1)  				GetStringWFail.Add (addr);  			else  				GetStringW.Add (addr' idx);  		}  		List<int> GetBSTRFail = new List<int> ();  		foreach (int addr in GetBSTRCalls) {  			reader.BaseStream.Position = addr;  			reader.BaseStream.Position -= 2;  			if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 7;  			if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 2;  			if (reader.ReadByte () != 0x50)// push eax  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 6;  			if (reader.ReadByte () != 0x68)// push dword  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			int idx = reader.ReadInt32 ();  			if (idx > ms_nSize - 1)  				GetBSTRFail.Add (addr);  			else  				GetBSTR.Add (addr' idx);  		}  		Status ("Failed to find index of {0} references"' GetStringFail.Count + GetStringWFail.Count + GetBSTRFail.Count);  	}  	Status ("Successfully found index of {0} references"' GetString.Count + GetBSTR.Count + GetStringW.Count);  	Status ("Decoding strings");  	for (int index = 0; index < ms_nSize; ++index)  		if (index != -1 && index <= 0xffff)  			Strings.Add (index' StringPoolDecode (index));  	Status ("Populating table");  	foreach (var s in Strings)  		MainForm.Invoke (() => MainForm.dataTable.Rows.Add (s.Key' s.Value' string.Empty));  	foreach (var a in GetString)  		MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetString")));  	foreach (var a in GetBSTR)  		MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetBSTR")));  	foreach (var a in GetStringW)  		MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetStringW")));  }  else if (StringDecodeMethod == 1)// StringDecoder   {  	MainForm.Invoke (() => MainForm.Text += " [StringDecoder]");  	int type = 0;  	int name = 0;  	int offset = 0;  	//search for CStringDecoder::DelayedLoad' which contains the resource type and name  	if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00'  		0x89'  		0x45'  		0xF4'  		0x6A'  		0xAA'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x8B'  		0x4D'  		0xF4'  		0x51'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 12;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 1;  		name = reader.ReadInt32 ();  	}  	else if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00'  		0x6A'  		0xAA'  		0x8B'  		0xF8'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x57'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 9;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 3;  		name = reader.ReadInt32 ();  	}  	else if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0xAA'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 1;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 1;  		name = reader.ReadInt32 ();  	}  	else  		throw new Exception ("Failed to determine type and name of resource.");  	//search for start of function CStringDecoder::DelayedLoad()  	reader.BaseStream.Position -= 50;  	// should be enough  	FindAoBInFile (reader' (int)reader.BaseStream.Position' new byte[] {  		0x55'  		0x8B'  		0xEC'  		0x83'  		0xEC'  		0x10  	});  	int offset_CStringDecoder__DelayedLoad = (int)reader.BaseStream.Position;  	for (reader.BaseStream.Position = 0; reader.BaseStream.Position < reader.BaseStream.Length;) {  		if (reader.ReadByte () != 0xE8)  			// call  			continue;  		int offse = reader.ReadInt32 ();  		if (reader.BaseStream.Position + offse == offset_CStringDecoder__DelayedLoad) {  			Status ("{0:X8} reference to offset_CStringDecoder__DelayedLoad = {1:X8}"' reader.BaseStream.Position - 5' offse);  			break;  		}  	}  	ImageResourceDirectory tier1 = (ImageResourceDirectory)root.GetEntry (type).Entry;  	ImageResourceDirectory tier2 = (ImageResourceDirectory)tier1.GetEntry (name).Entry;  	rsrcStringDataEntry = (ImageResourceDataEntry)tier2.Entrys [0].Entry;  	rsrcStringDataPosition = rsrcPointerToRawData + (rsrcStringDataEntry.OffsetToData - rsrcVirtualAddress);  	m_nCount = GetWordFromIndex (0);  	Status ("Amount of strings: {0}"' m_nCount);  	for (int i = 1; i < m_nCount; ++i)  		MainForm.Invoke (() => MainForm.dataTable.Rows.Add (i' StringDecoderDecode (i)' string.Format ("{0:X8}"' rsrcStringDataPosition + i * 4)));  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: if (StringDecodeMethod == 0)// StringPool   {  	MainForm.Invoke (() => MainForm.Text += " [StringPool]");  	int offset_StringPool__ms_aKey = (int)reader.BaseStream.Position;  	Status ("StringPool::ms_aKey located at {0:X8}"' offset_StringPool__ms_aKey);  	int keyRef = 0;  	// Only GetString references ms_aKey  	byte[] bytes = new byte[5];  	bytes [0] = 0x68;  	// push offset  	Buffer.BlockCopy (BitConverter.GetBytes (ImageBase + offset_StringPool__ms_aKey)' 0' bytes' 1' 4);  	if (FindAoBInFile (reader' 0' bytes))  		keyRef = (int)reader.BaseStream.Position;  	reader.BaseStream.Position = keyRef;  	while (true) {  		byte[] asdf = reader.ReadBytes (5);  		if (asdf [4] == 0xc3)// retn  		 {  			bool die = true;  			foreach (byte b in asdf)  				if (b == 0xe8)// call  				 {  					die = false;  					break;  				}  			if (die)  				break;  		}  		reader.BaseStream.Position -= 6;  	}  	while (reader.ReadByte () == 0xcc)  		;  	// allign  	reader.BaseStream.Position -= 1;  	int offset_StringPool__GetString_uint_char = (int)reader.BaseStream.Position;  	Status ("StringPool::GetString(uint' char) located at {0:X8}"' offset_StringPool__GetString_uint_char);  	//search for StringPool::offset_ms_aString  	if (FindAoBInFile (reader' keyRef - 100' new byte[] {  		0x8b'  		0x0c  	}' 100))  		reader.BaseStream.Position += 3;  	else if (FindAoBInFile (reader' keyRef - 100' new byte[] {  		0x8b'  		0x86  	}' 100))  		reader.BaseStream.Position += 2;  	else  		throw new Exception ("could not find start of StringPool::offset_ms_aString");  	offset_StringPool__ms_aString = reader.ReadInt32 () - ImageBase;  	Status ("StringPool::ms_aString located at {0:X8}"' offset_StringPool__ms_aString);  	//search for xrefs to function StringPool::GetString(uint' char)   	int[] xref = FindCalls (offset_StringPool__GetString_uint_char' 2);  	if (xref.Length != 2)  		throw new Exception ("failed to find references to StringPool::GetString(uint' char)");  	//search for start of StringPool::GetString(uint)  	if (!FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x51'  		0x8b  	}' 50) && !FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x55'  		0x8b  	}' 50))  		throw new Exception ("could not find start of GetString(uint)");  	int offset_StringPool__GetString_uint = (int)reader.BaseStream.Position;  	Status ("StringPool::GetString(uint) located at {0:X8}"' offset_StringPool__GetString_uint);  	//search for start of StringPool::GetString(uint' ushort)  	for (reader.BaseStream.Position = xref [1]; (reader.ReadUInt32 () & 0xffffff00) != 0x000cc200; reader.BaseStream.Position -= 5)  		;  	//seek the start of function StringPool::GetString(uint' char)  	while (reader.ReadByte () == 0xcc)  		;  	// allign  	reader.BaseStream.Position -= 1;  	int offset_StringPool__GetString_uint_ushort = (int)reader.BaseStream.Position;  	Status ("StringPool::GetString(uint' ushort) located at {0:X8}"' offset_StringPool__GetString_uint_ushort);  	//search for xrefs to function StringPool::GetString(uint)  	xref = FindCalls (offset_StringPool__GetString_uint' 1);  	if (xref.Length != 1)  		throw new Exception ("failed to find references to StringPool::GetString(uint)");  	//search for start of function StringPool::GetBSTR(uint)  	reader.BaseStream.Position -= 100;  	// should be enough  	if (!FindAoBInFile (reader' (int)reader.BaseStream.Position' new byte[] {  		0xb8'  		0xaa'  		0xaa'  		0xaa'  		0x00  	}))  		for (reader.BaseStream.Position = xref [0]; (reader.ReadUInt32 () & 0xff00ff00) != 0x0000c200; reader.BaseStream.Position -= 5)  			;  	//seek the start of function StringPool::GetString(uint' char)  	while (reader.ReadByte () == 0xcc)  		;  	// allign  	reader.BaseStream.Position -= 1;  	int offset_StringPool__GetBSTR_uint = (int)reader.BaseStream.Position;  	Status ("StringPool::GetBSTR(uint) located at {0:X8}"' offset_StringPool__GetBSTR_uint);  	//search for xrefs to function StringPool::GetString(uint' ushort)  	xref = FindCalls (offset_StringPool__GetString_uint_ushort' 1);  	if (xref.Length != 1)  		throw new Exception ("failed to find references to StringPool::GetString(uint' ushort)");  	//search for start of function StringPool::GetStringW(uint)  	if (!FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x51'  		0x8b  	}' 50) && !FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x55'  		0x8b  	}' 50))  		throw new Exception ("could not find start of GetStringW(uint)");  	int offset_StringPool__GetStringW_uint = (int)reader.BaseStream.Position;  	Status ("StringPool::GetStringW(uint) located at {0:X8}"' offset_StringPool__GetStringW_uint);  	ms_nSize = GetIntFromOffset (offset_StringPool__ms_aKey + 16 + 4);  	Status ("Amount of strings: {0}"' ms_nSize);  	if (MessageBox.Show ("Scan for references to strings in the client? This can take a while."' "Warning"' MessageBoxButtons.YesNo' MessageBoxIcon.Warning) == DialogResult.Yes) {  		Status ("Searching for references to GetString' GetStringW' and GetBSTR");  		List<int> GetStringCalls = new List<int> ();  		List<int> GetStringWCalls = new List<int> ();  		List<int> GetBSTRCalls = new List<int> ();  		for (reader.BaseStream.Position = 0; reader.BaseStream.Position < reader.BaseStream.Length;) {  			//int lol = (int)((float)reader.BaseStream.Position / reader.BaseStream.Length * 100);  			//if (lol > MainForm.toolStripProgressBar1.Value)  			//{  			//    MainForm.Invoke(() => MainForm.toolStripProgressBar1.Value = lol);  			//    MainForm.Invoke(() => MainForm.Update());  			//} too expensive  			if (reader.ReadByte () != 0xE8)  				// call  				continue;  			int offset = reader.ReadInt32 ();  			if (reader.BaseStream.Position + offset == offset_StringPool__GetString_uint)  				GetStringCalls.Add ((int)reader.BaseStream.Position - 5);  			else if (reader.BaseStream.Position + offset == offset_StringPool__GetStringW_uint)  				GetStringWCalls.Add ((int)reader.BaseStream.Position - 5);  			else if (reader.BaseStream.Position + offset == offset_StringPool__GetBSTR_uint)  				GetBSTRCalls.Add ((int)reader.BaseStream.Position - 5);  			else  				reader.BaseStream.Position -= 4;  		}  		List<int> GetStringFail = new List<int> ();  		foreach (int addr in GetStringCalls) {  			reader.BaseStream.Position = addr;  			reader.BaseStream.Position -= 2;  			if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  			 {  				GetStringFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 7;  			if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  			 {  				GetStringFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 2;  			if (reader.ReadByte () != 0x50)// push eax  			 {  				GetStringFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 6;  			if (reader.ReadByte () != 0x68)// push dword  			 {  				GetStringFail.Add (addr);  				continue;  			}  			int idx = reader.ReadInt32 ();  			if (idx > ms_nSize - 1)  				GetStringFail.Add (addr);  			else  				GetString.Add (addr' idx);  		}  		List<int> GetStringWFail = new List<int> ();  		foreach (int addr in GetStringWCalls) {  			reader.BaseStream.Position = addr;  			reader.BaseStream.Position -= 2;  			if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 7;  			if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 2;  			if (reader.ReadByte () != 0x50)// push eax  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 6;  			if (reader.ReadByte () != 0x68)// push dword  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			int idx = reader.ReadInt32 ();  			if (idx > ms_nSize - 1)  				GetStringWFail.Add (addr);  			else  				GetStringW.Add (addr' idx);  		}  		List<int> GetBSTRFail = new List<int> ();  		foreach (int addr in GetBSTRCalls) {  			reader.BaseStream.Position = addr;  			reader.BaseStream.Position -= 2;  			if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 7;  			if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 2;  			if (reader.ReadByte () != 0x50)// push eax  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 6;  			if (reader.ReadByte () != 0x68)// push dword  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			int idx = reader.ReadInt32 ();  			if (idx > ms_nSize - 1)  				GetBSTRFail.Add (addr);  			else  				GetBSTR.Add (addr' idx);  		}  		Status ("Failed to find index of {0} references"' GetStringFail.Count + GetStringWFail.Count + GetBSTRFail.Count);  	}  	Status ("Successfully found index of {0} references"' GetString.Count + GetBSTR.Count + GetStringW.Count);  	Status ("Decoding strings");  	for (int index = 0; index < ms_nSize; ++index)  		if (index != -1 && index <= 0xffff)  			Strings.Add (index' StringPoolDecode (index));  	Status ("Populating table");  	foreach (var s in Strings)  		MainForm.Invoke (() => MainForm.dataTable.Rows.Add (s.Key' s.Value' string.Empty));  	foreach (var a in GetString)  		MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetString")));  	foreach (var a in GetBSTR)  		MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetBSTR")));  	foreach (var a in GetStringW)  		MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetStringW")));  }  else if (StringDecodeMethod == 1)// StringDecoder   {  	MainForm.Invoke (() => MainForm.Text += " [StringDecoder]");  	int type = 0;  	int name = 0;  	int offset = 0;  	//search for CStringDecoder::DelayedLoad' which contains the resource type and name  	if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00'  		0x89'  		0x45'  		0xF4'  		0x6A'  		0xAA'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x8B'  		0x4D'  		0xF4'  		0x51'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 12;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 1;  		name = reader.ReadInt32 ();  	}  	else if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00'  		0x6A'  		0xAA'  		0x8B'  		0xF8'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x57'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 9;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 3;  		name = reader.ReadInt32 ();  	}  	else if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0xAA'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 1;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 1;  		name = reader.ReadInt32 ();  	}  	else  		throw new Exception ("Failed to determine type and name of resource.");  	//search for start of function CStringDecoder::DelayedLoad()  	reader.BaseStream.Position -= 50;  	// should be enough  	FindAoBInFile (reader' (int)reader.BaseStream.Position' new byte[] {  		0x55'  		0x8B'  		0xEC'  		0x83'  		0xEC'  		0x10  	});  	int offset_CStringDecoder__DelayedLoad = (int)reader.BaseStream.Position;  	for (reader.BaseStream.Position = 0; reader.BaseStream.Position < reader.BaseStream.Length;) {  		if (reader.ReadByte () != 0xE8)  			// call  			continue;  		int offse = reader.ReadInt32 ();  		if (reader.BaseStream.Position + offse == offset_CStringDecoder__DelayedLoad) {  			Status ("{0:X8} reference to offset_CStringDecoder__DelayedLoad = {1:X8}"' reader.BaseStream.Position - 5' offse);  			break;  		}  	}  	ImageResourceDirectory tier1 = (ImageResourceDirectory)root.GetEntry (type).Entry;  	ImageResourceDirectory tier2 = (ImageResourceDirectory)tier1.GetEntry (name).Entry;  	rsrcStringDataEntry = (ImageResourceDataEntry)tier2.Entrys [0].Entry;  	rsrcStringDataPosition = rsrcPointerToRawData + (rsrcStringDataEntry.OffsetToData - rsrcVirtualAddress);  	m_nCount = GetWordFromIndex (0);  	Status ("Amount of strings: {0}"' m_nCount);  	for (int i = 1; i < m_nCount; ++i)  		MainForm.Invoke (() => MainForm.dataTable.Rows.Add (i' StringDecoderDecode (i)' string.Format ("{0:X8}"' rsrcStringDataPosition + i * 4)));  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: if (StringDecodeMethod == 0)// StringPool   {  	MainForm.Invoke (() => MainForm.Text += " [StringPool]");  	int offset_StringPool__ms_aKey = (int)reader.BaseStream.Position;  	Status ("StringPool::ms_aKey located at {0:X8}"' offset_StringPool__ms_aKey);  	int keyRef = 0;  	// Only GetString references ms_aKey  	byte[] bytes = new byte[5];  	bytes [0] = 0x68;  	// push offset  	Buffer.BlockCopy (BitConverter.GetBytes (ImageBase + offset_StringPool__ms_aKey)' 0' bytes' 1' 4);  	if (FindAoBInFile (reader' 0' bytes))  		keyRef = (int)reader.BaseStream.Position;  	reader.BaseStream.Position = keyRef;  	while (true) {  		byte[] asdf = reader.ReadBytes (5);  		if (asdf [4] == 0xc3)// retn  		 {  			bool die = true;  			foreach (byte b in asdf)  				if (b == 0xe8)// call  				 {  					die = false;  					break;  				}  			if (die)  				break;  		}  		reader.BaseStream.Position -= 6;  	}  	while (reader.ReadByte () == 0xcc)  		;  	// allign  	reader.BaseStream.Position -= 1;  	int offset_StringPool__GetString_uint_char = (int)reader.BaseStream.Position;  	Status ("StringPool::GetString(uint' char) located at {0:X8}"' offset_StringPool__GetString_uint_char);  	//search for StringPool::offset_ms_aString  	if (FindAoBInFile (reader' keyRef - 100' new byte[] {  		0x8b'  		0x0c  	}' 100))  		reader.BaseStream.Position += 3;  	else if (FindAoBInFile (reader' keyRef - 100' new byte[] {  		0x8b'  		0x86  	}' 100))  		reader.BaseStream.Position += 2;  	else  		throw new Exception ("could not find start of StringPool::offset_ms_aString");  	offset_StringPool__ms_aString = reader.ReadInt32 () - ImageBase;  	Status ("StringPool::ms_aString located at {0:X8}"' offset_StringPool__ms_aString);  	//search for xrefs to function StringPool::GetString(uint' char)   	int[] xref = FindCalls (offset_StringPool__GetString_uint_char' 2);  	if (xref.Length != 2)  		throw new Exception ("failed to find references to StringPool::GetString(uint' char)");  	//search for start of StringPool::GetString(uint)  	if (!FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x51'  		0x8b  	}' 50) && !FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x55'  		0x8b  	}' 50))  		throw new Exception ("could not find start of GetString(uint)");  	int offset_StringPool__GetString_uint = (int)reader.BaseStream.Position;  	Status ("StringPool::GetString(uint) located at {0:X8}"' offset_StringPool__GetString_uint);  	//search for start of StringPool::GetString(uint' ushort)  	for (reader.BaseStream.Position = xref [1]; (reader.ReadUInt32 () & 0xffffff00) != 0x000cc200; reader.BaseStream.Position -= 5)  		;  	//seek the start of function StringPool::GetString(uint' char)  	while (reader.ReadByte () == 0xcc)  		;  	// allign  	reader.BaseStream.Position -= 1;  	int offset_StringPool__GetString_uint_ushort = (int)reader.BaseStream.Position;  	Status ("StringPool::GetString(uint' ushort) located at {0:X8}"' offset_StringPool__GetString_uint_ushort);  	//search for xrefs to function StringPool::GetString(uint)  	xref = FindCalls (offset_StringPool__GetString_uint' 1);  	if (xref.Length != 1)  		throw new Exception ("failed to find references to StringPool::GetString(uint)");  	//search for start of function StringPool::GetBSTR(uint)  	reader.BaseStream.Position -= 100;  	// should be enough  	if (!FindAoBInFile (reader' (int)reader.BaseStream.Position' new byte[] {  		0xb8'  		0xaa'  		0xaa'  		0xaa'  		0x00  	}))  		for (reader.BaseStream.Position = xref [0]; (reader.ReadUInt32 () & 0xff00ff00) != 0x0000c200; reader.BaseStream.Position -= 5)  			;  	//seek the start of function StringPool::GetString(uint' char)  	while (reader.ReadByte () == 0xcc)  		;  	// allign  	reader.BaseStream.Position -= 1;  	int offset_StringPool__GetBSTR_uint = (int)reader.BaseStream.Position;  	Status ("StringPool::GetBSTR(uint) located at {0:X8}"' offset_StringPool__GetBSTR_uint);  	//search for xrefs to function StringPool::GetString(uint' ushort)  	xref = FindCalls (offset_StringPool__GetString_uint_ushort' 1);  	if (xref.Length != 1)  		throw new Exception ("failed to find references to StringPool::GetString(uint' ushort)");  	//search for start of function StringPool::GetStringW(uint)  	if (!FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x51'  		0x8b  	}' 50) && !FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x55'  		0x8b  	}' 50))  		throw new Exception ("could not find start of GetStringW(uint)");  	int offset_StringPool__GetStringW_uint = (int)reader.BaseStream.Position;  	Status ("StringPool::GetStringW(uint) located at {0:X8}"' offset_StringPool__GetStringW_uint);  	ms_nSize = GetIntFromOffset (offset_StringPool__ms_aKey + 16 + 4);  	Status ("Amount of strings: {0}"' ms_nSize);  	if (MessageBox.Show ("Scan for references to strings in the client? This can take a while."' "Warning"' MessageBoxButtons.YesNo' MessageBoxIcon.Warning) == DialogResult.Yes) {  		Status ("Searching for references to GetString' GetStringW' and GetBSTR");  		List<int> GetStringCalls = new List<int> ();  		List<int> GetStringWCalls = new List<int> ();  		List<int> GetBSTRCalls = new List<int> ();  		for (reader.BaseStream.Position = 0; reader.BaseStream.Position < reader.BaseStream.Length;) {  			//int lol = (int)((float)reader.BaseStream.Position / reader.BaseStream.Length * 100);  			//if (lol > MainForm.toolStripProgressBar1.Value)  			//{  			//    MainForm.Invoke(() => MainForm.toolStripProgressBar1.Value = lol);  			//    MainForm.Invoke(() => MainForm.Update());  			//} too expensive  			if (reader.ReadByte () != 0xE8)  				// call  				continue;  			int offset = reader.ReadInt32 ();  			if (reader.BaseStream.Position + offset == offset_StringPool__GetString_uint)  				GetStringCalls.Add ((int)reader.BaseStream.Position - 5);  			else if (reader.BaseStream.Position + offset == offset_StringPool__GetStringW_uint)  				GetStringWCalls.Add ((int)reader.BaseStream.Position - 5);  			else if (reader.BaseStream.Position + offset == offset_StringPool__GetBSTR_uint)  				GetBSTRCalls.Add ((int)reader.BaseStream.Position - 5);  			else  				reader.BaseStream.Position -= 4;  		}  		List<int> GetStringFail = new List<int> ();  		foreach (int addr in GetStringCalls) {  			reader.BaseStream.Position = addr;  			reader.BaseStream.Position -= 2;  			if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  			 {  				GetStringFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 7;  			if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  			 {  				GetStringFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 2;  			if (reader.ReadByte () != 0x50)// push eax  			 {  				GetStringFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 6;  			if (reader.ReadByte () != 0x68)// push dword  			 {  				GetStringFail.Add (addr);  				continue;  			}  			int idx = reader.ReadInt32 ();  			if (idx > ms_nSize - 1)  				GetStringFail.Add (addr);  			else  				GetString.Add (addr' idx);  		}  		List<int> GetStringWFail = new List<int> ();  		foreach (int addr in GetStringWCalls) {  			reader.BaseStream.Position = addr;  			reader.BaseStream.Position -= 2;  			if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 7;  			if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 2;  			if (reader.ReadByte () != 0x50)// push eax  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 6;  			if (reader.ReadByte () != 0x68)// push dword  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			int idx = reader.ReadInt32 ();  			if (idx > ms_nSize - 1)  				GetStringWFail.Add (addr);  			else  				GetStringW.Add (addr' idx);  		}  		List<int> GetBSTRFail = new List<int> ();  		foreach (int addr in GetBSTRCalls) {  			reader.BaseStream.Position = addr;  			reader.BaseStream.Position -= 2;  			if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 7;  			if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 2;  			if (reader.ReadByte () != 0x50)// push eax  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 6;  			if (reader.ReadByte () != 0x68)// push dword  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			int idx = reader.ReadInt32 ();  			if (idx > ms_nSize - 1)  				GetBSTRFail.Add (addr);  			else  				GetBSTR.Add (addr' idx);  		}  		Status ("Failed to find index of {0} references"' GetStringFail.Count + GetStringWFail.Count + GetBSTRFail.Count);  	}  	Status ("Successfully found index of {0} references"' GetString.Count + GetBSTR.Count + GetStringW.Count);  	Status ("Decoding strings");  	for (int index = 0; index < ms_nSize; ++index)  		if (index != -1 && index <= 0xffff)  			Strings.Add (index' StringPoolDecode (index));  	Status ("Populating table");  	foreach (var s in Strings)  		MainForm.Invoke (() => MainForm.dataTable.Rows.Add (s.Key' s.Value' string.Empty));  	foreach (var a in GetString)  		MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetString")));  	foreach (var a in GetBSTR)  		MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetBSTR")));  	foreach (var a in GetStringW)  		MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetStringW")));  }  else if (StringDecodeMethod == 1)// StringDecoder   {  	MainForm.Invoke (() => MainForm.Text += " [StringDecoder]");  	int type = 0;  	int name = 0;  	int offset = 0;  	//search for CStringDecoder::DelayedLoad' which contains the resource type and name  	if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00'  		0x89'  		0x45'  		0xF4'  		0x6A'  		0xAA'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x8B'  		0x4D'  		0xF4'  		0x51'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 12;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 1;  		name = reader.ReadInt32 ();  	}  	else if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00'  		0x6A'  		0xAA'  		0x8B'  		0xF8'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x57'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 9;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 3;  		name = reader.ReadInt32 ();  	}  	else if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0xAA'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 1;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 1;  		name = reader.ReadInt32 ();  	}  	else  		throw new Exception ("Failed to determine type and name of resource.");  	//search for start of function CStringDecoder::DelayedLoad()  	reader.BaseStream.Position -= 50;  	// should be enough  	FindAoBInFile (reader' (int)reader.BaseStream.Position' new byte[] {  		0x55'  		0x8B'  		0xEC'  		0x83'  		0xEC'  		0x10  	});  	int offset_CStringDecoder__DelayedLoad = (int)reader.BaseStream.Position;  	for (reader.BaseStream.Position = 0; reader.BaseStream.Position < reader.BaseStream.Length;) {  		if (reader.ReadByte () != 0xE8)  			// call  			continue;  		int offse = reader.ReadInt32 ();  		if (reader.BaseStream.Position + offse == offset_CStringDecoder__DelayedLoad) {  			Status ("{0:X8} reference to offset_CStringDecoder__DelayedLoad = {1:X8}"' reader.BaseStream.Position - 5' offse);  			break;  		}  	}  	ImageResourceDirectory tier1 = (ImageResourceDirectory)root.GetEntry (type).Entry;  	ImageResourceDirectory tier2 = (ImageResourceDirectory)tier1.GetEntry (name).Entry;  	rsrcStringDataEntry = (ImageResourceDataEntry)tier2.Entrys [0].Entry;  	rsrcStringDataPosition = rsrcPointerToRawData + (rsrcStringDataEntry.OffsetToData - rsrcVirtualAddress);  	m_nCount = GetWordFromIndex (0);  	Status ("Amount of strings: {0}"' m_nCount);  	for (int i = 1; i < m_nCount; ++i)  		MainForm.Invoke (() => MainForm.dataTable.Rows.Add (i' StringDecoderDecode (i)' string.Format ("{0:X8}"' rsrcStringDataPosition + i * 4)));  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: if (StringDecodeMethod == 0)// StringPool   {  	MainForm.Invoke (() => MainForm.Text += " [StringPool]");  	int offset_StringPool__ms_aKey = (int)reader.BaseStream.Position;  	Status ("StringPool::ms_aKey located at {0:X8}"' offset_StringPool__ms_aKey);  	int keyRef = 0;  	// Only GetString references ms_aKey  	byte[] bytes = new byte[5];  	bytes [0] = 0x68;  	// push offset  	Buffer.BlockCopy (BitConverter.GetBytes (ImageBase + offset_StringPool__ms_aKey)' 0' bytes' 1' 4);  	if (FindAoBInFile (reader' 0' bytes))  		keyRef = (int)reader.BaseStream.Position;  	reader.BaseStream.Position = keyRef;  	while (true) {  		byte[] asdf = reader.ReadBytes (5);  		if (asdf [4] == 0xc3)// retn  		 {  			bool die = true;  			foreach (byte b in asdf)  				if (b == 0xe8)// call  				 {  					die = false;  					break;  				}  			if (die)  				break;  		}  		reader.BaseStream.Position -= 6;  	}  	while (reader.ReadByte () == 0xcc)  		;  	// allign  	reader.BaseStream.Position -= 1;  	int offset_StringPool__GetString_uint_char = (int)reader.BaseStream.Position;  	Status ("StringPool::GetString(uint' char) located at {0:X8}"' offset_StringPool__GetString_uint_char);  	//search for StringPool::offset_ms_aString  	if (FindAoBInFile (reader' keyRef - 100' new byte[] {  		0x8b'  		0x0c  	}' 100))  		reader.BaseStream.Position += 3;  	else if (FindAoBInFile (reader' keyRef - 100' new byte[] {  		0x8b'  		0x86  	}' 100))  		reader.BaseStream.Position += 2;  	else  		throw new Exception ("could not find start of StringPool::offset_ms_aString");  	offset_StringPool__ms_aString = reader.ReadInt32 () - ImageBase;  	Status ("StringPool::ms_aString located at {0:X8}"' offset_StringPool__ms_aString);  	//search for xrefs to function StringPool::GetString(uint' char)   	int[] xref = FindCalls (offset_StringPool__GetString_uint_char' 2);  	if (xref.Length != 2)  		throw new Exception ("failed to find references to StringPool::GetString(uint' char)");  	//search for start of StringPool::GetString(uint)  	if (!FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x51'  		0x8b  	}' 50) && !FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x55'  		0x8b  	}' 50))  		throw new Exception ("could not find start of GetString(uint)");  	int offset_StringPool__GetString_uint = (int)reader.BaseStream.Position;  	Status ("StringPool::GetString(uint) located at {0:X8}"' offset_StringPool__GetString_uint);  	//search for start of StringPool::GetString(uint' ushort)  	for (reader.BaseStream.Position = xref [1]; (reader.ReadUInt32 () & 0xffffff00) != 0x000cc200; reader.BaseStream.Position -= 5)  		;  	//seek the start of function StringPool::GetString(uint' char)  	while (reader.ReadByte () == 0xcc)  		;  	// allign  	reader.BaseStream.Position -= 1;  	int offset_StringPool__GetString_uint_ushort = (int)reader.BaseStream.Position;  	Status ("StringPool::GetString(uint' ushort) located at {0:X8}"' offset_StringPool__GetString_uint_ushort);  	//search for xrefs to function StringPool::GetString(uint)  	xref = FindCalls (offset_StringPool__GetString_uint' 1);  	if (xref.Length != 1)  		throw new Exception ("failed to find references to StringPool::GetString(uint)");  	//search for start of function StringPool::GetBSTR(uint)  	reader.BaseStream.Position -= 100;  	// should be enough  	if (!FindAoBInFile (reader' (int)reader.BaseStream.Position' new byte[] {  		0xb8'  		0xaa'  		0xaa'  		0xaa'  		0x00  	}))  		for (reader.BaseStream.Position = xref [0]; (reader.ReadUInt32 () & 0xff00ff00) != 0x0000c200; reader.BaseStream.Position -= 5)  			;  	//seek the start of function StringPool::GetString(uint' char)  	while (reader.ReadByte () == 0xcc)  		;  	// allign  	reader.BaseStream.Position -= 1;  	int offset_StringPool__GetBSTR_uint = (int)reader.BaseStream.Position;  	Status ("StringPool::GetBSTR(uint) located at {0:X8}"' offset_StringPool__GetBSTR_uint);  	//search for xrefs to function StringPool::GetString(uint' ushort)  	xref = FindCalls (offset_StringPool__GetString_uint_ushort' 1);  	if (xref.Length != 1)  		throw new Exception ("failed to find references to StringPool::GetString(uint' ushort)");  	//search for start of function StringPool::GetStringW(uint)  	if (!FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x51'  		0x8b  	}' 50) && !FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x55'  		0x8b  	}' 50))  		throw new Exception ("could not find start of GetStringW(uint)");  	int offset_StringPool__GetStringW_uint = (int)reader.BaseStream.Position;  	Status ("StringPool::GetStringW(uint) located at {0:X8}"' offset_StringPool__GetStringW_uint);  	ms_nSize = GetIntFromOffset (offset_StringPool__ms_aKey + 16 + 4);  	Status ("Amount of strings: {0}"' ms_nSize);  	if (MessageBox.Show ("Scan for references to strings in the client? This can take a while."' "Warning"' MessageBoxButtons.YesNo' MessageBoxIcon.Warning) == DialogResult.Yes) {  		Status ("Searching for references to GetString' GetStringW' and GetBSTR");  		List<int> GetStringCalls = new List<int> ();  		List<int> GetStringWCalls = new List<int> ();  		List<int> GetBSTRCalls = new List<int> ();  		for (reader.BaseStream.Position = 0; reader.BaseStream.Position < reader.BaseStream.Length;) {  			//int lol = (int)((float)reader.BaseStream.Position / reader.BaseStream.Length * 100);  			//if (lol > MainForm.toolStripProgressBar1.Value)  			//{  			//    MainForm.Invoke(() => MainForm.toolStripProgressBar1.Value = lol);  			//    MainForm.Invoke(() => MainForm.Update());  			//} too expensive  			if (reader.ReadByte () != 0xE8)  				// call  				continue;  			int offset = reader.ReadInt32 ();  			if (reader.BaseStream.Position + offset == offset_StringPool__GetString_uint)  				GetStringCalls.Add ((int)reader.BaseStream.Position - 5);  			else if (reader.BaseStream.Position + offset == offset_StringPool__GetStringW_uint)  				GetStringWCalls.Add ((int)reader.BaseStream.Position - 5);  			else if (reader.BaseStream.Position + offset == offset_StringPool__GetBSTR_uint)  				GetBSTRCalls.Add ((int)reader.BaseStream.Position - 5);  			else  				reader.BaseStream.Position -= 4;  		}  		List<int> GetStringFail = new List<int> ();  		foreach (int addr in GetStringCalls) {  			reader.BaseStream.Position = addr;  			reader.BaseStream.Position -= 2;  			if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  			 {  				GetStringFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 7;  			if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  			 {  				GetStringFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 2;  			if (reader.ReadByte () != 0x50)// push eax  			 {  				GetStringFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 6;  			if (reader.ReadByte () != 0x68)// push dword  			 {  				GetStringFail.Add (addr);  				continue;  			}  			int idx = reader.ReadInt32 ();  			if (idx > ms_nSize - 1)  				GetStringFail.Add (addr);  			else  				GetString.Add (addr' idx);  		}  		List<int> GetStringWFail = new List<int> ();  		foreach (int addr in GetStringWCalls) {  			reader.BaseStream.Position = addr;  			reader.BaseStream.Position -= 2;  			if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 7;  			if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 2;  			if (reader.ReadByte () != 0x50)// push eax  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 6;  			if (reader.ReadByte () != 0x68)// push dword  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			int idx = reader.ReadInt32 ();  			if (idx > ms_nSize - 1)  				GetStringWFail.Add (addr);  			else  				GetStringW.Add (addr' idx);  		}  		List<int> GetBSTRFail = new List<int> ();  		foreach (int addr in GetBSTRCalls) {  			reader.BaseStream.Position = addr;  			reader.BaseStream.Position -= 2;  			if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 7;  			if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 2;  			if (reader.ReadByte () != 0x50)// push eax  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 6;  			if (reader.ReadByte () != 0x68)// push dword  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			int idx = reader.ReadInt32 ();  			if (idx > ms_nSize - 1)  				GetBSTRFail.Add (addr);  			else  				GetBSTR.Add (addr' idx);  		}  		Status ("Failed to find index of {0} references"' GetStringFail.Count + GetStringWFail.Count + GetBSTRFail.Count);  	}  	Status ("Successfully found index of {0} references"' GetString.Count + GetBSTR.Count + GetStringW.Count);  	Status ("Decoding strings");  	for (int index = 0; index < ms_nSize; ++index)  		if (index != -1 && index <= 0xffff)  			Strings.Add (index' StringPoolDecode (index));  	Status ("Populating table");  	foreach (var s in Strings)  		MainForm.Invoke (() => MainForm.dataTable.Rows.Add (s.Key' s.Value' string.Empty));  	foreach (var a in GetString)  		MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetString")));  	foreach (var a in GetBSTR)  		MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetBSTR")));  	foreach (var a in GetStringW)  		MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetStringW")));  }  else if (StringDecodeMethod == 1)// StringDecoder   {  	MainForm.Invoke (() => MainForm.Text += " [StringDecoder]");  	int type = 0;  	int name = 0;  	int offset = 0;  	//search for CStringDecoder::DelayedLoad' which contains the resource type and name  	if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00'  		0x89'  		0x45'  		0xF4'  		0x6A'  		0xAA'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x8B'  		0x4D'  		0xF4'  		0x51'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 12;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 1;  		name = reader.ReadInt32 ();  	}  	else if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00'  		0x6A'  		0xAA'  		0x8B'  		0xF8'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x57'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 9;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 3;  		name = reader.ReadInt32 ();  	}  	else if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0xAA'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 1;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 1;  		name = reader.ReadInt32 ();  	}  	else  		throw new Exception ("Failed to determine type and name of resource.");  	//search for start of function CStringDecoder::DelayedLoad()  	reader.BaseStream.Position -= 50;  	// should be enough  	FindAoBInFile (reader' (int)reader.BaseStream.Position' new byte[] {  		0x55'  		0x8B'  		0xEC'  		0x83'  		0xEC'  		0x10  	});  	int offset_CStringDecoder__DelayedLoad = (int)reader.BaseStream.Position;  	for (reader.BaseStream.Position = 0; reader.BaseStream.Position < reader.BaseStream.Length;) {  		if (reader.ReadByte () != 0xE8)  			// call  			continue;  		int offse = reader.ReadInt32 ();  		if (reader.BaseStream.Position + offse == offset_CStringDecoder__DelayedLoad) {  			Status ("{0:X8} reference to offset_CStringDecoder__DelayedLoad = {1:X8}"' reader.BaseStream.Position - 5' offse);  			break;  		}  	}  	ImageResourceDirectory tier1 = (ImageResourceDirectory)root.GetEntry (type).Entry;  	ImageResourceDirectory tier2 = (ImageResourceDirectory)tier1.GetEntry (name).Entry;  	rsrcStringDataEntry = (ImageResourceDataEntry)tier2.Entrys [0].Entry;  	rsrcStringDataPosition = rsrcPointerToRawData + (rsrcStringDataEntry.OffsetToData - rsrcVirtualAddress);  	m_nCount = GetWordFromIndex (0);  	Status ("Amount of strings: {0}"' m_nCount);  	for (int i = 1; i < m_nCount; ++i)  		MainForm.Invoke (() => MainForm.dataTable.Rows.Add (i' StringDecoderDecode (i)' string.Format ("{0:X8}"' rsrcStringDataPosition + i * 4)));  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: if (StringDecodeMethod == 0)// StringPool   {  	MainForm.Invoke (() => MainForm.Text += " [StringPool]");  	int offset_StringPool__ms_aKey = (int)reader.BaseStream.Position;  	Status ("StringPool::ms_aKey located at {0:X8}"' offset_StringPool__ms_aKey);  	int keyRef = 0;  	// Only GetString references ms_aKey  	byte[] bytes = new byte[5];  	bytes [0] = 0x68;  	// push offset  	Buffer.BlockCopy (BitConverter.GetBytes (ImageBase + offset_StringPool__ms_aKey)' 0' bytes' 1' 4);  	if (FindAoBInFile (reader' 0' bytes))  		keyRef = (int)reader.BaseStream.Position;  	reader.BaseStream.Position = keyRef;  	while (true) {  		byte[] asdf = reader.ReadBytes (5);  		if (asdf [4] == 0xc3)// retn  		 {  			bool die = true;  			foreach (byte b in asdf)  				if (b == 0xe8)// call  				 {  					die = false;  					break;  				}  			if (die)  				break;  		}  		reader.BaseStream.Position -= 6;  	}  	while (reader.ReadByte () == 0xcc)  		;  	// allign  	reader.BaseStream.Position -= 1;  	int offset_StringPool__GetString_uint_char = (int)reader.BaseStream.Position;  	Status ("StringPool::GetString(uint' char) located at {0:X8}"' offset_StringPool__GetString_uint_char);  	//search for StringPool::offset_ms_aString  	if (FindAoBInFile (reader' keyRef - 100' new byte[] {  		0x8b'  		0x0c  	}' 100))  		reader.BaseStream.Position += 3;  	else if (FindAoBInFile (reader' keyRef - 100' new byte[] {  		0x8b'  		0x86  	}' 100))  		reader.BaseStream.Position += 2;  	else  		throw new Exception ("could not find start of StringPool::offset_ms_aString");  	offset_StringPool__ms_aString = reader.ReadInt32 () - ImageBase;  	Status ("StringPool::ms_aString located at {0:X8}"' offset_StringPool__ms_aString);  	//search for xrefs to function StringPool::GetString(uint' char)   	int[] xref = FindCalls (offset_StringPool__GetString_uint_char' 2);  	if (xref.Length != 2)  		throw new Exception ("failed to find references to StringPool::GetString(uint' char)");  	//search for start of StringPool::GetString(uint)  	if (!FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x51'  		0x8b  	}' 50) && !FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x55'  		0x8b  	}' 50))  		throw new Exception ("could not find start of GetString(uint)");  	int offset_StringPool__GetString_uint = (int)reader.BaseStream.Position;  	Status ("StringPool::GetString(uint) located at {0:X8}"' offset_StringPool__GetString_uint);  	//search for start of StringPool::GetString(uint' ushort)  	for (reader.BaseStream.Position = xref [1]; (reader.ReadUInt32 () & 0xffffff00) != 0x000cc200; reader.BaseStream.Position -= 5)  		;  	//seek the start of function StringPool::GetString(uint' char)  	while (reader.ReadByte () == 0xcc)  		;  	// allign  	reader.BaseStream.Position -= 1;  	int offset_StringPool__GetString_uint_ushort = (int)reader.BaseStream.Position;  	Status ("StringPool::GetString(uint' ushort) located at {0:X8}"' offset_StringPool__GetString_uint_ushort);  	//search for xrefs to function StringPool::GetString(uint)  	xref = FindCalls (offset_StringPool__GetString_uint' 1);  	if (xref.Length != 1)  		throw new Exception ("failed to find references to StringPool::GetString(uint)");  	//search for start of function StringPool::GetBSTR(uint)  	reader.BaseStream.Position -= 100;  	// should be enough  	if (!FindAoBInFile (reader' (int)reader.BaseStream.Position' new byte[] {  		0xb8'  		0xaa'  		0xaa'  		0xaa'  		0x00  	}))  		for (reader.BaseStream.Position = xref [0]; (reader.ReadUInt32 () & 0xff00ff00) != 0x0000c200; reader.BaseStream.Position -= 5)  			;  	//seek the start of function StringPool::GetString(uint' char)  	while (reader.ReadByte () == 0xcc)  		;  	// allign  	reader.BaseStream.Position -= 1;  	int offset_StringPool__GetBSTR_uint = (int)reader.BaseStream.Position;  	Status ("StringPool::GetBSTR(uint) located at {0:X8}"' offset_StringPool__GetBSTR_uint);  	//search for xrefs to function StringPool::GetString(uint' ushort)  	xref = FindCalls (offset_StringPool__GetString_uint_ushort' 1);  	if (xref.Length != 1)  		throw new Exception ("failed to find references to StringPool::GetString(uint' ushort)");  	//search for start of function StringPool::GetStringW(uint)  	if (!FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x51'  		0x8b  	}' 50) && !FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x55'  		0x8b  	}' 50))  		throw new Exception ("could not find start of GetStringW(uint)");  	int offset_StringPool__GetStringW_uint = (int)reader.BaseStream.Position;  	Status ("StringPool::GetStringW(uint) located at {0:X8}"' offset_StringPool__GetStringW_uint);  	ms_nSize = GetIntFromOffset (offset_StringPool__ms_aKey + 16 + 4);  	Status ("Amount of strings: {0}"' ms_nSize);  	if (MessageBox.Show ("Scan for references to strings in the client? This can take a while."' "Warning"' MessageBoxButtons.YesNo' MessageBoxIcon.Warning) == DialogResult.Yes) {  		Status ("Searching for references to GetString' GetStringW' and GetBSTR");  		List<int> GetStringCalls = new List<int> ();  		List<int> GetStringWCalls = new List<int> ();  		List<int> GetBSTRCalls = new List<int> ();  		for (reader.BaseStream.Position = 0; reader.BaseStream.Position < reader.BaseStream.Length;) {  			//int lol = (int)((float)reader.BaseStream.Position / reader.BaseStream.Length * 100);  			//if (lol > MainForm.toolStripProgressBar1.Value)  			//{  			//    MainForm.Invoke(() => MainForm.toolStripProgressBar1.Value = lol);  			//    MainForm.Invoke(() => MainForm.Update());  			//} too expensive  			if (reader.ReadByte () != 0xE8)  				// call  				continue;  			int offset = reader.ReadInt32 ();  			if (reader.BaseStream.Position + offset == offset_StringPool__GetString_uint)  				GetStringCalls.Add ((int)reader.BaseStream.Position - 5);  			else if (reader.BaseStream.Position + offset == offset_StringPool__GetStringW_uint)  				GetStringWCalls.Add ((int)reader.BaseStream.Position - 5);  			else if (reader.BaseStream.Position + offset == offset_StringPool__GetBSTR_uint)  				GetBSTRCalls.Add ((int)reader.BaseStream.Position - 5);  			else  				reader.BaseStream.Position -= 4;  		}  		List<int> GetStringFail = new List<int> ();  		foreach (int addr in GetStringCalls) {  			reader.BaseStream.Position = addr;  			reader.BaseStream.Position -= 2;  			if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  			 {  				GetStringFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 7;  			if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  			 {  				GetStringFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 2;  			if (reader.ReadByte () != 0x50)// push eax  			 {  				GetStringFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 6;  			if (reader.ReadByte () != 0x68)// push dword  			 {  				GetStringFail.Add (addr);  				continue;  			}  			int idx = reader.ReadInt32 ();  			if (idx > ms_nSize - 1)  				GetStringFail.Add (addr);  			else  				GetString.Add (addr' idx);  		}  		List<int> GetStringWFail = new List<int> ();  		foreach (int addr in GetStringWCalls) {  			reader.BaseStream.Position = addr;  			reader.BaseStream.Position -= 2;  			if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 7;  			if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 2;  			if (reader.ReadByte () != 0x50)// push eax  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 6;  			if (reader.ReadByte () != 0x68)// push dword  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			int idx = reader.ReadInt32 ();  			if (idx > ms_nSize - 1)  				GetStringWFail.Add (addr);  			else  				GetStringW.Add (addr' idx);  		}  		List<int> GetBSTRFail = new List<int> ();  		foreach (int addr in GetBSTRCalls) {  			reader.BaseStream.Position = addr;  			reader.BaseStream.Position -= 2;  			if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 7;  			if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 2;  			if (reader.ReadByte () != 0x50)// push eax  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 6;  			if (reader.ReadByte () != 0x68)// push dword  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			int idx = reader.ReadInt32 ();  			if (idx > ms_nSize - 1)  				GetBSTRFail.Add (addr);  			else  				GetBSTR.Add (addr' idx);  		}  		Status ("Failed to find index of {0} references"' GetStringFail.Count + GetStringWFail.Count + GetBSTRFail.Count);  	}  	Status ("Successfully found index of {0} references"' GetString.Count + GetBSTR.Count + GetStringW.Count);  	Status ("Decoding strings");  	for (int index = 0; index < ms_nSize; ++index)  		if (index != -1 && index <= 0xffff)  			Strings.Add (index' StringPoolDecode (index));  	Status ("Populating table");  	foreach (var s in Strings)  		MainForm.Invoke (() => MainForm.dataTable.Rows.Add (s.Key' s.Value' string.Empty));  	foreach (var a in GetString)  		MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetString")));  	foreach (var a in GetBSTR)  		MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetBSTR")));  	foreach (var a in GetStringW)  		MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetStringW")));  }  else if (StringDecodeMethod == 1)// StringDecoder   {  	MainForm.Invoke (() => MainForm.Text += " [StringDecoder]");  	int type = 0;  	int name = 0;  	int offset = 0;  	//search for CStringDecoder::DelayedLoad' which contains the resource type and name  	if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00'  		0x89'  		0x45'  		0xF4'  		0x6A'  		0xAA'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x8B'  		0x4D'  		0xF4'  		0x51'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 12;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 1;  		name = reader.ReadInt32 ();  	}  	else if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00'  		0x6A'  		0xAA'  		0x8B'  		0xF8'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x57'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 9;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 3;  		name = reader.ReadInt32 ();  	}  	else if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0xAA'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 1;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 1;  		name = reader.ReadInt32 ();  	}  	else  		throw new Exception ("Failed to determine type and name of resource.");  	//search for start of function CStringDecoder::DelayedLoad()  	reader.BaseStream.Position -= 50;  	// should be enough  	FindAoBInFile (reader' (int)reader.BaseStream.Position' new byte[] {  		0x55'  		0x8B'  		0xEC'  		0x83'  		0xEC'  		0x10  	});  	int offset_CStringDecoder__DelayedLoad = (int)reader.BaseStream.Position;  	for (reader.BaseStream.Position = 0; reader.BaseStream.Position < reader.BaseStream.Length;) {  		if (reader.ReadByte () != 0xE8)  			// call  			continue;  		int offse = reader.ReadInt32 ();  		if (reader.BaseStream.Position + offse == offset_CStringDecoder__DelayedLoad) {  			Status ("{0:X8} reference to offset_CStringDecoder__DelayedLoad = {1:X8}"' reader.BaseStream.Position - 5' offse);  			break;  		}  	}  	ImageResourceDirectory tier1 = (ImageResourceDirectory)root.GetEntry (type).Entry;  	ImageResourceDirectory tier2 = (ImageResourceDirectory)tier1.GetEntry (name).Entry;  	rsrcStringDataEntry = (ImageResourceDataEntry)tier2.Entrys [0].Entry;  	rsrcStringDataPosition = rsrcPointerToRawData + (rsrcStringDataEntry.OffsetToData - rsrcVirtualAddress);  	m_nCount = GetWordFromIndex (0);  	Status ("Amount of strings: {0}"' m_nCount);  	for (int i = 1; i < m_nCount; ++i)  		MainForm.Invoke (() => MainForm.dataTable.Rows.Add (i' StringDecoderDecode (i)' string.Format ("{0:X8}"' rsrcStringDataPosition + i * 4)));  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: if (StringDecodeMethod == 0)// StringPool   {  	MainForm.Invoke (() => MainForm.Text += " [StringPool]");  	int offset_StringPool__ms_aKey = (int)reader.BaseStream.Position;  	Status ("StringPool::ms_aKey located at {0:X8}"' offset_StringPool__ms_aKey);  	int keyRef = 0;  	// Only GetString references ms_aKey  	byte[] bytes = new byte[5];  	bytes [0] = 0x68;  	// push offset  	Buffer.BlockCopy (BitConverter.GetBytes (ImageBase + offset_StringPool__ms_aKey)' 0' bytes' 1' 4);  	if (FindAoBInFile (reader' 0' bytes))  		keyRef = (int)reader.BaseStream.Position;  	reader.BaseStream.Position = keyRef;  	while (true) {  		byte[] asdf = reader.ReadBytes (5);  		if (asdf [4] == 0xc3)// retn  		 {  			bool die = true;  			foreach (byte b in asdf)  				if (b == 0xe8)// call  				 {  					die = false;  					break;  				}  			if (die)  				break;  		}  		reader.BaseStream.Position -= 6;  	}  	while (reader.ReadByte () == 0xcc)  		;  	// allign  	reader.BaseStream.Position -= 1;  	int offset_StringPool__GetString_uint_char = (int)reader.BaseStream.Position;  	Status ("StringPool::GetString(uint' char) located at {0:X8}"' offset_StringPool__GetString_uint_char);  	//search for StringPool::offset_ms_aString  	if (FindAoBInFile (reader' keyRef - 100' new byte[] {  		0x8b'  		0x0c  	}' 100))  		reader.BaseStream.Position += 3;  	else if (FindAoBInFile (reader' keyRef - 100' new byte[] {  		0x8b'  		0x86  	}' 100))  		reader.BaseStream.Position += 2;  	else  		throw new Exception ("could not find start of StringPool::offset_ms_aString");  	offset_StringPool__ms_aString = reader.ReadInt32 () - ImageBase;  	Status ("StringPool::ms_aString located at {0:X8}"' offset_StringPool__ms_aString);  	//search for xrefs to function StringPool::GetString(uint' char)   	int[] xref = FindCalls (offset_StringPool__GetString_uint_char' 2);  	if (xref.Length != 2)  		throw new Exception ("failed to find references to StringPool::GetString(uint' char)");  	//search for start of StringPool::GetString(uint)  	if (!FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x51'  		0x8b  	}' 50) && !FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x55'  		0x8b  	}' 50))  		throw new Exception ("could not find start of GetString(uint)");  	int offset_StringPool__GetString_uint = (int)reader.BaseStream.Position;  	Status ("StringPool::GetString(uint) located at {0:X8}"' offset_StringPool__GetString_uint);  	//search for start of StringPool::GetString(uint' ushort)  	for (reader.BaseStream.Position = xref [1]; (reader.ReadUInt32 () & 0xffffff00) != 0x000cc200; reader.BaseStream.Position -= 5)  		;  	//seek the start of function StringPool::GetString(uint' char)  	while (reader.ReadByte () == 0xcc)  		;  	// allign  	reader.BaseStream.Position -= 1;  	int offset_StringPool__GetString_uint_ushort = (int)reader.BaseStream.Position;  	Status ("StringPool::GetString(uint' ushort) located at {0:X8}"' offset_StringPool__GetString_uint_ushort);  	//search for xrefs to function StringPool::GetString(uint)  	xref = FindCalls (offset_StringPool__GetString_uint' 1);  	if (xref.Length != 1)  		throw new Exception ("failed to find references to StringPool::GetString(uint)");  	//search for start of function StringPool::GetBSTR(uint)  	reader.BaseStream.Position -= 100;  	// should be enough  	if (!FindAoBInFile (reader' (int)reader.BaseStream.Position' new byte[] {  		0xb8'  		0xaa'  		0xaa'  		0xaa'  		0x00  	}))  		for (reader.BaseStream.Position = xref [0]; (reader.ReadUInt32 () & 0xff00ff00) != 0x0000c200; reader.BaseStream.Position -= 5)  			;  	//seek the start of function StringPool::GetString(uint' char)  	while (reader.ReadByte () == 0xcc)  		;  	// allign  	reader.BaseStream.Position -= 1;  	int offset_StringPool__GetBSTR_uint = (int)reader.BaseStream.Position;  	Status ("StringPool::GetBSTR(uint) located at {0:X8}"' offset_StringPool__GetBSTR_uint);  	//search for xrefs to function StringPool::GetString(uint' ushort)  	xref = FindCalls (offset_StringPool__GetString_uint_ushort' 1);  	if (xref.Length != 1)  		throw new Exception ("failed to find references to StringPool::GetString(uint' ushort)");  	//search for start of function StringPool::GetStringW(uint)  	if (!FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x51'  		0x8b  	}' 50) && !FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x55'  		0x8b  	}' 50))  		throw new Exception ("could not find start of GetStringW(uint)");  	int offset_StringPool__GetStringW_uint = (int)reader.BaseStream.Position;  	Status ("StringPool::GetStringW(uint) located at {0:X8}"' offset_StringPool__GetStringW_uint);  	ms_nSize = GetIntFromOffset (offset_StringPool__ms_aKey + 16 + 4);  	Status ("Amount of strings: {0}"' ms_nSize);  	if (MessageBox.Show ("Scan for references to strings in the client? This can take a while."' "Warning"' MessageBoxButtons.YesNo' MessageBoxIcon.Warning) == DialogResult.Yes) {  		Status ("Searching for references to GetString' GetStringW' and GetBSTR");  		List<int> GetStringCalls = new List<int> ();  		List<int> GetStringWCalls = new List<int> ();  		List<int> GetBSTRCalls = new List<int> ();  		for (reader.BaseStream.Position = 0; reader.BaseStream.Position < reader.BaseStream.Length;) {  			//int lol = (int)((float)reader.BaseStream.Position / reader.BaseStream.Length * 100);  			//if (lol > MainForm.toolStripProgressBar1.Value)  			//{  			//    MainForm.Invoke(() => MainForm.toolStripProgressBar1.Value = lol);  			//    MainForm.Invoke(() => MainForm.Update());  			//} too expensive  			if (reader.ReadByte () != 0xE8)  				// call  				continue;  			int offset = reader.ReadInt32 ();  			if (reader.BaseStream.Position + offset == offset_StringPool__GetString_uint)  				GetStringCalls.Add ((int)reader.BaseStream.Position - 5);  			else if (reader.BaseStream.Position + offset == offset_StringPool__GetStringW_uint)  				GetStringWCalls.Add ((int)reader.BaseStream.Position - 5);  			else if (reader.BaseStream.Position + offset == offset_StringPool__GetBSTR_uint)  				GetBSTRCalls.Add ((int)reader.BaseStream.Position - 5);  			else  				reader.BaseStream.Position -= 4;  		}  		List<int> GetStringFail = new List<int> ();  		foreach (int addr in GetStringCalls) {  			reader.BaseStream.Position = addr;  			reader.BaseStream.Position -= 2;  			if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  			 {  				GetStringFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 7;  			if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  			 {  				GetStringFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 2;  			if (reader.ReadByte () != 0x50)// push eax  			 {  				GetStringFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 6;  			if (reader.ReadByte () != 0x68)// push dword  			 {  				GetStringFail.Add (addr);  				continue;  			}  			int idx = reader.ReadInt32 ();  			if (idx > ms_nSize - 1)  				GetStringFail.Add (addr);  			else  				GetString.Add (addr' idx);  		}  		List<int> GetStringWFail = new List<int> ();  		foreach (int addr in GetStringWCalls) {  			reader.BaseStream.Position = addr;  			reader.BaseStream.Position -= 2;  			if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 7;  			if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 2;  			if (reader.ReadByte () != 0x50)// push eax  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 6;  			if (reader.ReadByte () != 0x68)// push dword  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			int idx = reader.ReadInt32 ();  			if (idx > ms_nSize - 1)  				GetStringWFail.Add (addr);  			else  				GetStringW.Add (addr' idx);  		}  		List<int> GetBSTRFail = new List<int> ();  		foreach (int addr in GetBSTRCalls) {  			reader.BaseStream.Position = addr;  			reader.BaseStream.Position -= 2;  			if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 7;  			if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 2;  			if (reader.ReadByte () != 0x50)// push eax  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 6;  			if (reader.ReadByte () != 0x68)// push dword  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			int idx = reader.ReadInt32 ();  			if (idx > ms_nSize - 1)  				GetBSTRFail.Add (addr);  			else  				GetBSTR.Add (addr' idx);  		}  		Status ("Failed to find index of {0} references"' GetStringFail.Count + GetStringWFail.Count + GetBSTRFail.Count);  	}  	Status ("Successfully found index of {0} references"' GetString.Count + GetBSTR.Count + GetStringW.Count);  	Status ("Decoding strings");  	for (int index = 0; index < ms_nSize; ++index)  		if (index != -1 && index <= 0xffff)  			Strings.Add (index' StringPoolDecode (index));  	Status ("Populating table");  	foreach (var s in Strings)  		MainForm.Invoke (() => MainForm.dataTable.Rows.Add (s.Key' s.Value' string.Empty));  	foreach (var a in GetString)  		MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetString")));  	foreach (var a in GetBSTR)  		MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetBSTR")));  	foreach (var a in GetStringW)  		MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetStringW")));  }  else if (StringDecodeMethod == 1)// StringDecoder   {  	MainForm.Invoke (() => MainForm.Text += " [StringDecoder]");  	int type = 0;  	int name = 0;  	int offset = 0;  	//search for CStringDecoder::DelayedLoad' which contains the resource type and name  	if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00'  		0x89'  		0x45'  		0xF4'  		0x6A'  		0xAA'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x8B'  		0x4D'  		0xF4'  		0x51'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 12;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 1;  		name = reader.ReadInt32 ();  	}  	else if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00'  		0x6A'  		0xAA'  		0x8B'  		0xF8'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x57'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 9;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 3;  		name = reader.ReadInt32 ();  	}  	else if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0xAA'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 1;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 1;  		name = reader.ReadInt32 ();  	}  	else  		throw new Exception ("Failed to determine type and name of resource.");  	//search for start of function CStringDecoder::DelayedLoad()  	reader.BaseStream.Position -= 50;  	// should be enough  	FindAoBInFile (reader' (int)reader.BaseStream.Position' new byte[] {  		0x55'  		0x8B'  		0xEC'  		0x83'  		0xEC'  		0x10  	});  	int offset_CStringDecoder__DelayedLoad = (int)reader.BaseStream.Position;  	for (reader.BaseStream.Position = 0; reader.BaseStream.Position < reader.BaseStream.Length;) {  		if (reader.ReadByte () != 0xE8)  			// call  			continue;  		int offse = reader.ReadInt32 ();  		if (reader.BaseStream.Position + offse == offset_CStringDecoder__DelayedLoad) {  			Status ("{0:X8} reference to offset_CStringDecoder__DelayedLoad = {1:X8}"' reader.BaseStream.Position - 5' offse);  			break;  		}  	}  	ImageResourceDirectory tier1 = (ImageResourceDirectory)root.GetEntry (type).Entry;  	ImageResourceDirectory tier2 = (ImageResourceDirectory)tier1.GetEntry (name).Entry;  	rsrcStringDataEntry = (ImageResourceDataEntry)tier2.Entrys [0].Entry;  	rsrcStringDataPosition = rsrcPointerToRawData + (rsrcStringDataEntry.OffsetToData - rsrcVirtualAddress);  	m_nCount = GetWordFromIndex (0);  	Status ("Amount of strings: {0}"' m_nCount);  	for (int i = 1; i < m_nCount; ++i)  		MainForm.Invoke (() => MainForm.dataTable.Rows.Add (i' StringDecoderDecode (i)' string.Format ("{0:X8}"' rsrcStringDataPosition + i * 4)));  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: if (StringDecodeMethod == 0)// StringPool   {  	MainForm.Invoke (() => MainForm.Text += " [StringPool]");  	int offset_StringPool__ms_aKey = (int)reader.BaseStream.Position;  	Status ("StringPool::ms_aKey located at {0:X8}"' offset_StringPool__ms_aKey);  	int keyRef = 0;  	// Only GetString references ms_aKey  	byte[] bytes = new byte[5];  	bytes [0] = 0x68;  	// push offset  	Buffer.BlockCopy (BitConverter.GetBytes (ImageBase + offset_StringPool__ms_aKey)' 0' bytes' 1' 4);  	if (FindAoBInFile (reader' 0' bytes))  		keyRef = (int)reader.BaseStream.Position;  	reader.BaseStream.Position = keyRef;  	while (true) {  		byte[] asdf = reader.ReadBytes (5);  		if (asdf [4] == 0xc3)// retn  		 {  			bool die = true;  			foreach (byte b in asdf)  				if (b == 0xe8)// call  				 {  					die = false;  					break;  				}  			if (die)  				break;  		}  		reader.BaseStream.Position -= 6;  	}  	while (reader.ReadByte () == 0xcc)  		;  	// allign  	reader.BaseStream.Position -= 1;  	int offset_StringPool__GetString_uint_char = (int)reader.BaseStream.Position;  	Status ("StringPool::GetString(uint' char) located at {0:X8}"' offset_StringPool__GetString_uint_char);  	//search for StringPool::offset_ms_aString  	if (FindAoBInFile (reader' keyRef - 100' new byte[] {  		0x8b'  		0x0c  	}' 100))  		reader.BaseStream.Position += 3;  	else if (FindAoBInFile (reader' keyRef - 100' new byte[] {  		0x8b'  		0x86  	}' 100))  		reader.BaseStream.Position += 2;  	else  		throw new Exception ("could not find start of StringPool::offset_ms_aString");  	offset_StringPool__ms_aString = reader.ReadInt32 () - ImageBase;  	Status ("StringPool::ms_aString located at {0:X8}"' offset_StringPool__ms_aString);  	//search for xrefs to function StringPool::GetString(uint' char)   	int[] xref = FindCalls (offset_StringPool__GetString_uint_char' 2);  	if (xref.Length != 2)  		throw new Exception ("failed to find references to StringPool::GetString(uint' char)");  	//search for start of StringPool::GetString(uint)  	if (!FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x51'  		0x8b  	}' 50) && !FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x55'  		0x8b  	}' 50))  		throw new Exception ("could not find start of GetString(uint)");  	int offset_StringPool__GetString_uint = (int)reader.BaseStream.Position;  	Status ("StringPool::GetString(uint) located at {0:X8}"' offset_StringPool__GetString_uint);  	//search for start of StringPool::GetString(uint' ushort)  	for (reader.BaseStream.Position = xref [1]; (reader.ReadUInt32 () & 0xffffff00) != 0x000cc200; reader.BaseStream.Position -= 5)  		;  	//seek the start of function StringPool::GetString(uint' char)  	while (reader.ReadByte () == 0xcc)  		;  	// allign  	reader.BaseStream.Position -= 1;  	int offset_StringPool__GetString_uint_ushort = (int)reader.BaseStream.Position;  	Status ("StringPool::GetString(uint' ushort) located at {0:X8}"' offset_StringPool__GetString_uint_ushort);  	//search for xrefs to function StringPool::GetString(uint)  	xref = FindCalls (offset_StringPool__GetString_uint' 1);  	if (xref.Length != 1)  		throw new Exception ("failed to find references to StringPool::GetString(uint)");  	//search for start of function StringPool::GetBSTR(uint)  	reader.BaseStream.Position -= 100;  	// should be enough  	if (!FindAoBInFile (reader' (int)reader.BaseStream.Position' new byte[] {  		0xb8'  		0xaa'  		0xaa'  		0xaa'  		0x00  	}))  		for (reader.BaseStream.Position = xref [0]; (reader.ReadUInt32 () & 0xff00ff00) != 0x0000c200; reader.BaseStream.Position -= 5)  			;  	//seek the start of function StringPool::GetString(uint' char)  	while (reader.ReadByte () == 0xcc)  		;  	// allign  	reader.BaseStream.Position -= 1;  	int offset_StringPool__GetBSTR_uint = (int)reader.BaseStream.Position;  	Status ("StringPool::GetBSTR(uint) located at {0:X8}"' offset_StringPool__GetBSTR_uint);  	//search for xrefs to function StringPool::GetString(uint' ushort)  	xref = FindCalls (offset_StringPool__GetString_uint_ushort' 1);  	if (xref.Length != 1)  		throw new Exception ("failed to find references to StringPool::GetString(uint' ushort)");  	//search for start of function StringPool::GetStringW(uint)  	if (!FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x51'  		0x8b  	}' 50) && !FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x55'  		0x8b  	}' 50))  		throw new Exception ("could not find start of GetStringW(uint)");  	int offset_StringPool__GetStringW_uint = (int)reader.BaseStream.Position;  	Status ("StringPool::GetStringW(uint) located at {0:X8}"' offset_StringPool__GetStringW_uint);  	ms_nSize = GetIntFromOffset (offset_StringPool__ms_aKey + 16 + 4);  	Status ("Amount of strings: {0}"' ms_nSize);  	if (MessageBox.Show ("Scan for references to strings in the client? This can take a while."' "Warning"' MessageBoxButtons.YesNo' MessageBoxIcon.Warning) == DialogResult.Yes) {  		Status ("Searching for references to GetString' GetStringW' and GetBSTR");  		List<int> GetStringCalls = new List<int> ();  		List<int> GetStringWCalls = new List<int> ();  		List<int> GetBSTRCalls = new List<int> ();  		for (reader.BaseStream.Position = 0; reader.BaseStream.Position < reader.BaseStream.Length;) {  			//int lol = (int)((float)reader.BaseStream.Position / reader.BaseStream.Length * 100);  			//if (lol > MainForm.toolStripProgressBar1.Value)  			//{  			//    MainForm.Invoke(() => MainForm.toolStripProgressBar1.Value = lol);  			//    MainForm.Invoke(() => MainForm.Update());  			//} too expensive  			if (reader.ReadByte () != 0xE8)  				// call  				continue;  			int offset = reader.ReadInt32 ();  			if (reader.BaseStream.Position + offset == offset_StringPool__GetString_uint)  				GetStringCalls.Add ((int)reader.BaseStream.Position - 5);  			else if (reader.BaseStream.Position + offset == offset_StringPool__GetStringW_uint)  				GetStringWCalls.Add ((int)reader.BaseStream.Position - 5);  			else if (reader.BaseStream.Position + offset == offset_StringPool__GetBSTR_uint)  				GetBSTRCalls.Add ((int)reader.BaseStream.Position - 5);  			else  				reader.BaseStream.Position -= 4;  		}  		List<int> GetStringFail = new List<int> ();  		foreach (int addr in GetStringCalls) {  			reader.BaseStream.Position = addr;  			reader.BaseStream.Position -= 2;  			if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  			 {  				GetStringFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 7;  			if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  			 {  				GetStringFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 2;  			if (reader.ReadByte () != 0x50)// push eax  			 {  				GetStringFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 6;  			if (reader.ReadByte () != 0x68)// push dword  			 {  				GetStringFail.Add (addr);  				continue;  			}  			int idx = reader.ReadInt32 ();  			if (idx > ms_nSize - 1)  				GetStringFail.Add (addr);  			else  				GetString.Add (addr' idx);  		}  		List<int> GetStringWFail = new List<int> ();  		foreach (int addr in GetStringWCalls) {  			reader.BaseStream.Position = addr;  			reader.BaseStream.Position -= 2;  			if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 7;  			if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 2;  			if (reader.ReadByte () != 0x50)// push eax  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 6;  			if (reader.ReadByte () != 0x68)// push dword  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			int idx = reader.ReadInt32 ();  			if (idx > ms_nSize - 1)  				GetStringWFail.Add (addr);  			else  				GetStringW.Add (addr' idx);  		}  		List<int> GetBSTRFail = new List<int> ();  		foreach (int addr in GetBSTRCalls) {  			reader.BaseStream.Position = addr;  			reader.BaseStream.Position -= 2;  			if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 7;  			if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 2;  			if (reader.ReadByte () != 0x50)// push eax  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 6;  			if (reader.ReadByte () != 0x68)// push dword  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			int idx = reader.ReadInt32 ();  			if (idx > ms_nSize - 1)  				GetBSTRFail.Add (addr);  			else  				GetBSTR.Add (addr' idx);  		}  		Status ("Failed to find index of {0} references"' GetStringFail.Count + GetStringWFail.Count + GetBSTRFail.Count);  	}  	Status ("Successfully found index of {0} references"' GetString.Count + GetBSTR.Count + GetStringW.Count);  	Status ("Decoding strings");  	for (int index = 0; index < ms_nSize; ++index)  		if (index != -1 && index <= 0xffff)  			Strings.Add (index' StringPoolDecode (index));  	Status ("Populating table");  	foreach (var s in Strings)  		MainForm.Invoke (() => MainForm.dataTable.Rows.Add (s.Key' s.Value' string.Empty));  	foreach (var a in GetString)  		MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetString")));  	foreach (var a in GetBSTR)  		MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetBSTR")));  	foreach (var a in GetStringW)  		MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetStringW")));  }  else if (StringDecodeMethod == 1)// StringDecoder   {  	MainForm.Invoke (() => MainForm.Text += " [StringDecoder]");  	int type = 0;  	int name = 0;  	int offset = 0;  	//search for CStringDecoder::DelayedLoad' which contains the resource type and name  	if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00'  		0x89'  		0x45'  		0xF4'  		0x6A'  		0xAA'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x8B'  		0x4D'  		0xF4'  		0x51'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 12;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 1;  		name = reader.ReadInt32 ();  	}  	else if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00'  		0x6A'  		0xAA'  		0x8B'  		0xF8'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x57'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 9;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 3;  		name = reader.ReadInt32 ();  	}  	else if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0xAA'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 1;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 1;  		name = reader.ReadInt32 ();  	}  	else  		throw new Exception ("Failed to determine type and name of resource.");  	//search for start of function CStringDecoder::DelayedLoad()  	reader.BaseStream.Position -= 50;  	// should be enough  	FindAoBInFile (reader' (int)reader.BaseStream.Position' new byte[] {  		0x55'  		0x8B'  		0xEC'  		0x83'  		0xEC'  		0x10  	});  	int offset_CStringDecoder__DelayedLoad = (int)reader.BaseStream.Position;  	for (reader.BaseStream.Position = 0; reader.BaseStream.Position < reader.BaseStream.Length;) {  		if (reader.ReadByte () != 0xE8)  			// call  			continue;  		int offse = reader.ReadInt32 ();  		if (reader.BaseStream.Position + offse == offset_CStringDecoder__DelayedLoad) {  			Status ("{0:X8} reference to offset_CStringDecoder__DelayedLoad = {1:X8}"' reader.BaseStream.Position - 5' offse);  			break;  		}  	}  	ImageResourceDirectory tier1 = (ImageResourceDirectory)root.GetEntry (type).Entry;  	ImageResourceDirectory tier2 = (ImageResourceDirectory)tier1.GetEntry (name).Entry;  	rsrcStringDataEntry = (ImageResourceDataEntry)tier2.Entrys [0].Entry;  	rsrcStringDataPosition = rsrcPointerToRawData + (rsrcStringDataEntry.OffsetToData - rsrcVirtualAddress);  	m_nCount = GetWordFromIndex (0);  	Status ("Amount of strings: {0}"' m_nCount);  	for (int i = 1; i < m_nCount; ++i)  		MainForm.Invoke (() => MainForm.dataTable.Rows.Add (i' StringDecoderDecode (i)' string.Format ("{0:X8}"' rsrcStringDataPosition + i * 4)));  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: if (StringDecodeMethod == 0)// StringPool   {  	MainForm.Invoke (() => MainForm.Text += " [StringPool]");  	int offset_StringPool__ms_aKey = (int)reader.BaseStream.Position;  	Status ("StringPool::ms_aKey located at {0:X8}"' offset_StringPool__ms_aKey);  	int keyRef = 0;  	// Only GetString references ms_aKey  	byte[] bytes = new byte[5];  	bytes [0] = 0x68;  	// push offset  	Buffer.BlockCopy (BitConverter.GetBytes (ImageBase + offset_StringPool__ms_aKey)' 0' bytes' 1' 4);  	if (FindAoBInFile (reader' 0' bytes))  		keyRef = (int)reader.BaseStream.Position;  	reader.BaseStream.Position = keyRef;  	while (true) {  		byte[] asdf = reader.ReadBytes (5);  		if (asdf [4] == 0xc3)// retn  		 {  			bool die = true;  			foreach (byte b in asdf)  				if (b == 0xe8)// call  				 {  					die = false;  					break;  				}  			if (die)  				break;  		}  		reader.BaseStream.Position -= 6;  	}  	while (reader.ReadByte () == 0xcc)  		;  	// allign  	reader.BaseStream.Position -= 1;  	int offset_StringPool__GetString_uint_char = (int)reader.BaseStream.Position;  	Status ("StringPool::GetString(uint' char) located at {0:X8}"' offset_StringPool__GetString_uint_char);  	//search for StringPool::offset_ms_aString  	if (FindAoBInFile (reader' keyRef - 100' new byte[] {  		0x8b'  		0x0c  	}' 100))  		reader.BaseStream.Position += 3;  	else if (FindAoBInFile (reader' keyRef - 100' new byte[] {  		0x8b'  		0x86  	}' 100))  		reader.BaseStream.Position += 2;  	else  		throw new Exception ("could not find start of StringPool::offset_ms_aString");  	offset_StringPool__ms_aString = reader.ReadInt32 () - ImageBase;  	Status ("StringPool::ms_aString located at {0:X8}"' offset_StringPool__ms_aString);  	//search for xrefs to function StringPool::GetString(uint' char)   	int[] xref = FindCalls (offset_StringPool__GetString_uint_char' 2);  	if (xref.Length != 2)  		throw new Exception ("failed to find references to StringPool::GetString(uint' char)");  	//search for start of StringPool::GetString(uint)  	if (!FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x51'  		0x8b  	}' 50) && !FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x55'  		0x8b  	}' 50))  		throw new Exception ("could not find start of GetString(uint)");  	int offset_StringPool__GetString_uint = (int)reader.BaseStream.Position;  	Status ("StringPool::GetString(uint) located at {0:X8}"' offset_StringPool__GetString_uint);  	//search for start of StringPool::GetString(uint' ushort)  	for (reader.BaseStream.Position = xref [1]; (reader.ReadUInt32 () & 0xffffff00) != 0x000cc200; reader.BaseStream.Position -= 5)  		;  	//seek the start of function StringPool::GetString(uint' char)  	while (reader.ReadByte () == 0xcc)  		;  	// allign  	reader.BaseStream.Position -= 1;  	int offset_StringPool__GetString_uint_ushort = (int)reader.BaseStream.Position;  	Status ("StringPool::GetString(uint' ushort) located at {0:X8}"' offset_StringPool__GetString_uint_ushort);  	//search for xrefs to function StringPool::GetString(uint)  	xref = FindCalls (offset_StringPool__GetString_uint' 1);  	if (xref.Length != 1)  		throw new Exception ("failed to find references to StringPool::GetString(uint)");  	//search for start of function StringPool::GetBSTR(uint)  	reader.BaseStream.Position -= 100;  	// should be enough  	if (!FindAoBInFile (reader' (int)reader.BaseStream.Position' new byte[] {  		0xb8'  		0xaa'  		0xaa'  		0xaa'  		0x00  	}))  		for (reader.BaseStream.Position = xref [0]; (reader.ReadUInt32 () & 0xff00ff00) != 0x0000c200; reader.BaseStream.Position -= 5)  			;  	//seek the start of function StringPool::GetString(uint' char)  	while (reader.ReadByte () == 0xcc)  		;  	// allign  	reader.BaseStream.Position -= 1;  	int offset_StringPool__GetBSTR_uint = (int)reader.BaseStream.Position;  	Status ("StringPool::GetBSTR(uint) located at {0:X8}"' offset_StringPool__GetBSTR_uint);  	//search for xrefs to function StringPool::GetString(uint' ushort)  	xref = FindCalls (offset_StringPool__GetString_uint_ushort' 1);  	if (xref.Length != 1)  		throw new Exception ("failed to find references to StringPool::GetString(uint' ushort)");  	//search for start of function StringPool::GetStringW(uint)  	if (!FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x51'  		0x8b  	}' 50) && !FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x55'  		0x8b  	}' 50))  		throw new Exception ("could not find start of GetStringW(uint)");  	int offset_StringPool__GetStringW_uint = (int)reader.BaseStream.Position;  	Status ("StringPool::GetStringW(uint) located at {0:X8}"' offset_StringPool__GetStringW_uint);  	ms_nSize = GetIntFromOffset (offset_StringPool__ms_aKey + 16 + 4);  	Status ("Amount of strings: {0}"' ms_nSize);  	if (MessageBox.Show ("Scan for references to strings in the client? This can take a while."' "Warning"' MessageBoxButtons.YesNo' MessageBoxIcon.Warning) == DialogResult.Yes) {  		Status ("Searching for references to GetString' GetStringW' and GetBSTR");  		List<int> GetStringCalls = new List<int> ();  		List<int> GetStringWCalls = new List<int> ();  		List<int> GetBSTRCalls = new List<int> ();  		for (reader.BaseStream.Position = 0; reader.BaseStream.Position < reader.BaseStream.Length;) {  			//int lol = (int)((float)reader.BaseStream.Position / reader.BaseStream.Length * 100);  			//if (lol > MainForm.toolStripProgressBar1.Value)  			//{  			//    MainForm.Invoke(() => MainForm.toolStripProgressBar1.Value = lol);  			//    MainForm.Invoke(() => MainForm.Update());  			//} too expensive  			if (reader.ReadByte () != 0xE8)  				// call  				continue;  			int offset = reader.ReadInt32 ();  			if (reader.BaseStream.Position + offset == offset_StringPool__GetString_uint)  				GetStringCalls.Add ((int)reader.BaseStream.Position - 5);  			else if (reader.BaseStream.Position + offset == offset_StringPool__GetStringW_uint)  				GetStringWCalls.Add ((int)reader.BaseStream.Position - 5);  			else if (reader.BaseStream.Position + offset == offset_StringPool__GetBSTR_uint)  				GetBSTRCalls.Add ((int)reader.BaseStream.Position - 5);  			else  				reader.BaseStream.Position -= 4;  		}  		List<int> GetStringFail = new List<int> ();  		foreach (int addr in GetStringCalls) {  			reader.BaseStream.Position = addr;  			reader.BaseStream.Position -= 2;  			if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  			 {  				GetStringFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 7;  			if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  			 {  				GetStringFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 2;  			if (reader.ReadByte () != 0x50)// push eax  			 {  				GetStringFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 6;  			if (reader.ReadByte () != 0x68)// push dword  			 {  				GetStringFail.Add (addr);  				continue;  			}  			int idx = reader.ReadInt32 ();  			if (idx > ms_nSize - 1)  				GetStringFail.Add (addr);  			else  				GetString.Add (addr' idx);  		}  		List<int> GetStringWFail = new List<int> ();  		foreach (int addr in GetStringWCalls) {  			reader.BaseStream.Position = addr;  			reader.BaseStream.Position -= 2;  			if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 7;  			if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 2;  			if (reader.ReadByte () != 0x50)// push eax  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 6;  			if (reader.ReadByte () != 0x68)// push dword  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			int idx = reader.ReadInt32 ();  			if (idx > ms_nSize - 1)  				GetStringWFail.Add (addr);  			else  				GetStringW.Add (addr' idx);  		}  		List<int> GetBSTRFail = new List<int> ();  		foreach (int addr in GetBSTRCalls) {  			reader.BaseStream.Position = addr;  			reader.BaseStream.Position -= 2;  			if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 7;  			if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 2;  			if (reader.ReadByte () != 0x50)// push eax  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 6;  			if (reader.ReadByte () != 0x68)// push dword  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			int idx = reader.ReadInt32 ();  			if (idx > ms_nSize - 1)  				GetBSTRFail.Add (addr);  			else  				GetBSTR.Add (addr' idx);  		}  		Status ("Failed to find index of {0} references"' GetStringFail.Count + GetStringWFail.Count + GetBSTRFail.Count);  	}  	Status ("Successfully found index of {0} references"' GetString.Count + GetBSTR.Count + GetStringW.Count);  	Status ("Decoding strings");  	for (int index = 0; index < ms_nSize; ++index)  		if (index != -1 && index <= 0xffff)  			Strings.Add (index' StringPoolDecode (index));  	Status ("Populating table");  	foreach (var s in Strings)  		MainForm.Invoke (() => MainForm.dataTable.Rows.Add (s.Key' s.Value' string.Empty));  	foreach (var a in GetString)  		MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetString")));  	foreach (var a in GetBSTR)  		MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetBSTR")));  	foreach (var a in GetStringW)  		MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetStringW")));  }  else if (StringDecodeMethod == 1)// StringDecoder   {  	MainForm.Invoke (() => MainForm.Text += " [StringDecoder]");  	int type = 0;  	int name = 0;  	int offset = 0;  	//search for CStringDecoder::DelayedLoad' which contains the resource type and name  	if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00'  		0x89'  		0x45'  		0xF4'  		0x6A'  		0xAA'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x8B'  		0x4D'  		0xF4'  		0x51'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 12;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 1;  		name = reader.ReadInt32 ();  	}  	else if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00'  		0x6A'  		0xAA'  		0x8B'  		0xF8'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x57'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 9;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 3;  		name = reader.ReadInt32 ();  	}  	else if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0xAA'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 1;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 1;  		name = reader.ReadInt32 ();  	}  	else  		throw new Exception ("Failed to determine type and name of resource.");  	//search for start of function CStringDecoder::DelayedLoad()  	reader.BaseStream.Position -= 50;  	// should be enough  	FindAoBInFile (reader' (int)reader.BaseStream.Position' new byte[] {  		0x55'  		0x8B'  		0xEC'  		0x83'  		0xEC'  		0x10  	});  	int offset_CStringDecoder__DelayedLoad = (int)reader.BaseStream.Position;  	for (reader.BaseStream.Position = 0; reader.BaseStream.Position < reader.BaseStream.Length;) {  		if (reader.ReadByte () != 0xE8)  			// call  			continue;  		int offse = reader.ReadInt32 ();  		if (reader.BaseStream.Position + offse == offset_CStringDecoder__DelayedLoad) {  			Status ("{0:X8} reference to offset_CStringDecoder__DelayedLoad = {1:X8}"' reader.BaseStream.Position - 5' offse);  			break;  		}  	}  	ImageResourceDirectory tier1 = (ImageResourceDirectory)root.GetEntry (type).Entry;  	ImageResourceDirectory tier2 = (ImageResourceDirectory)tier1.GetEntry (name).Entry;  	rsrcStringDataEntry = (ImageResourceDataEntry)tier2.Entrys [0].Entry;  	rsrcStringDataPosition = rsrcPointerToRawData + (rsrcStringDataEntry.OffsetToData - rsrcVirtualAddress);  	m_nCount = GetWordFromIndex (0);  	Status ("Amount of strings: {0}"' m_nCount);  	for (int i = 1; i < m_nCount; ++i)  		MainForm.Invoke (() => MainForm.dataTable.Rows.Add (i' StringDecoderDecode (i)' string.Format ("{0:X8}"' rsrcStringDataPosition + i * 4)));  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: if (StringDecodeMethod == 0)// StringPool   {  	MainForm.Invoke (() => MainForm.Text += " [StringPool]");  	int offset_StringPool__ms_aKey = (int)reader.BaseStream.Position;  	Status ("StringPool::ms_aKey located at {0:X8}"' offset_StringPool__ms_aKey);  	int keyRef = 0;  	// Only GetString references ms_aKey  	byte[] bytes = new byte[5];  	bytes [0] = 0x68;  	// push offset  	Buffer.BlockCopy (BitConverter.GetBytes (ImageBase + offset_StringPool__ms_aKey)' 0' bytes' 1' 4);  	if (FindAoBInFile (reader' 0' bytes))  		keyRef = (int)reader.BaseStream.Position;  	reader.BaseStream.Position = keyRef;  	while (true) {  		byte[] asdf = reader.ReadBytes (5);  		if (asdf [4] == 0xc3)// retn  		 {  			bool die = true;  			foreach (byte b in asdf)  				if (b == 0xe8)// call  				 {  					die = false;  					break;  				}  			if (die)  				break;  		}  		reader.BaseStream.Position -= 6;  	}  	while (reader.ReadByte () == 0xcc)  		;  	// allign  	reader.BaseStream.Position -= 1;  	int offset_StringPool__GetString_uint_char = (int)reader.BaseStream.Position;  	Status ("StringPool::GetString(uint' char) located at {0:X8}"' offset_StringPool__GetString_uint_char);  	//search for StringPool::offset_ms_aString  	if (FindAoBInFile (reader' keyRef - 100' new byte[] {  		0x8b'  		0x0c  	}' 100))  		reader.BaseStream.Position += 3;  	else if (FindAoBInFile (reader' keyRef - 100' new byte[] {  		0x8b'  		0x86  	}' 100))  		reader.BaseStream.Position += 2;  	else  		throw new Exception ("could not find start of StringPool::offset_ms_aString");  	offset_StringPool__ms_aString = reader.ReadInt32 () - ImageBase;  	Status ("StringPool::ms_aString located at {0:X8}"' offset_StringPool__ms_aString);  	//search for xrefs to function StringPool::GetString(uint' char)   	int[] xref = FindCalls (offset_StringPool__GetString_uint_char' 2);  	if (xref.Length != 2)  		throw new Exception ("failed to find references to StringPool::GetString(uint' char)");  	//search for start of StringPool::GetString(uint)  	if (!FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x51'  		0x8b  	}' 50) && !FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x55'  		0x8b  	}' 50))  		throw new Exception ("could not find start of GetString(uint)");  	int offset_StringPool__GetString_uint = (int)reader.BaseStream.Position;  	Status ("StringPool::GetString(uint) located at {0:X8}"' offset_StringPool__GetString_uint);  	//search for start of StringPool::GetString(uint' ushort)  	for (reader.BaseStream.Position = xref [1]; (reader.ReadUInt32 () & 0xffffff00) != 0x000cc200; reader.BaseStream.Position -= 5)  		;  	//seek the start of function StringPool::GetString(uint' char)  	while (reader.ReadByte () == 0xcc)  		;  	// allign  	reader.BaseStream.Position -= 1;  	int offset_StringPool__GetString_uint_ushort = (int)reader.BaseStream.Position;  	Status ("StringPool::GetString(uint' ushort) located at {0:X8}"' offset_StringPool__GetString_uint_ushort);  	//search for xrefs to function StringPool::GetString(uint)  	xref = FindCalls (offset_StringPool__GetString_uint' 1);  	if (xref.Length != 1)  		throw new Exception ("failed to find references to StringPool::GetString(uint)");  	//search for start of function StringPool::GetBSTR(uint)  	reader.BaseStream.Position -= 100;  	// should be enough  	if (!FindAoBInFile (reader' (int)reader.BaseStream.Position' new byte[] {  		0xb8'  		0xaa'  		0xaa'  		0xaa'  		0x00  	}))  		for (reader.BaseStream.Position = xref [0]; (reader.ReadUInt32 () & 0xff00ff00) != 0x0000c200; reader.BaseStream.Position -= 5)  			;  	//seek the start of function StringPool::GetString(uint' char)  	while (reader.ReadByte () == 0xcc)  		;  	// allign  	reader.BaseStream.Position -= 1;  	int offset_StringPool__GetBSTR_uint = (int)reader.BaseStream.Position;  	Status ("StringPool::GetBSTR(uint) located at {0:X8}"' offset_StringPool__GetBSTR_uint);  	//search for xrefs to function StringPool::GetString(uint' ushort)  	xref = FindCalls (offset_StringPool__GetString_uint_ushort' 1);  	if (xref.Length != 1)  		throw new Exception ("failed to find references to StringPool::GetString(uint' ushort)");  	//search for start of function StringPool::GetStringW(uint)  	if (!FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x51'  		0x8b  	}' 50) && !FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x55'  		0x8b  	}' 50))  		throw new Exception ("could not find start of GetStringW(uint)");  	int offset_StringPool__GetStringW_uint = (int)reader.BaseStream.Position;  	Status ("StringPool::GetStringW(uint) located at {0:X8}"' offset_StringPool__GetStringW_uint);  	ms_nSize = GetIntFromOffset (offset_StringPool__ms_aKey + 16 + 4);  	Status ("Amount of strings: {0}"' ms_nSize);  	if (MessageBox.Show ("Scan for references to strings in the client? This can take a while."' "Warning"' MessageBoxButtons.YesNo' MessageBoxIcon.Warning) == DialogResult.Yes) {  		Status ("Searching for references to GetString' GetStringW' and GetBSTR");  		List<int> GetStringCalls = new List<int> ();  		List<int> GetStringWCalls = new List<int> ();  		List<int> GetBSTRCalls = new List<int> ();  		for (reader.BaseStream.Position = 0; reader.BaseStream.Position < reader.BaseStream.Length;) {  			//int lol = (int)((float)reader.BaseStream.Position / reader.BaseStream.Length * 100);  			//if (lol > MainForm.toolStripProgressBar1.Value)  			//{  			//    MainForm.Invoke(() => MainForm.toolStripProgressBar1.Value = lol);  			//    MainForm.Invoke(() => MainForm.Update());  			//} too expensive  			if (reader.ReadByte () != 0xE8)  				// call  				continue;  			int offset = reader.ReadInt32 ();  			if (reader.BaseStream.Position + offset == offset_StringPool__GetString_uint)  				GetStringCalls.Add ((int)reader.BaseStream.Position - 5);  			else if (reader.BaseStream.Position + offset == offset_StringPool__GetStringW_uint)  				GetStringWCalls.Add ((int)reader.BaseStream.Position - 5);  			else if (reader.BaseStream.Position + offset == offset_StringPool__GetBSTR_uint)  				GetBSTRCalls.Add ((int)reader.BaseStream.Position - 5);  			else  				reader.BaseStream.Position -= 4;  		}  		List<int> GetStringFail = new List<int> ();  		foreach (int addr in GetStringCalls) {  			reader.BaseStream.Position = addr;  			reader.BaseStream.Position -= 2;  			if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  			 {  				GetStringFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 7;  			if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  			 {  				GetStringFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 2;  			if (reader.ReadByte () != 0x50)// push eax  			 {  				GetStringFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 6;  			if (reader.ReadByte () != 0x68)// push dword  			 {  				GetStringFail.Add (addr);  				continue;  			}  			int idx = reader.ReadInt32 ();  			if (idx > ms_nSize - 1)  				GetStringFail.Add (addr);  			else  				GetString.Add (addr' idx);  		}  		List<int> GetStringWFail = new List<int> ();  		foreach (int addr in GetStringWCalls) {  			reader.BaseStream.Position = addr;  			reader.BaseStream.Position -= 2;  			if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 7;  			if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 2;  			if (reader.ReadByte () != 0x50)// push eax  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 6;  			if (reader.ReadByte () != 0x68)// push dword  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			int idx = reader.ReadInt32 ();  			if (idx > ms_nSize - 1)  				GetStringWFail.Add (addr);  			else  				GetStringW.Add (addr' idx);  		}  		List<int> GetBSTRFail = new List<int> ();  		foreach (int addr in GetBSTRCalls) {  			reader.BaseStream.Position = addr;  			reader.BaseStream.Position -= 2;  			if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 7;  			if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 2;  			if (reader.ReadByte () != 0x50)// push eax  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 6;  			if (reader.ReadByte () != 0x68)// push dword  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			int idx = reader.ReadInt32 ();  			if (idx > ms_nSize - 1)  				GetBSTRFail.Add (addr);  			else  				GetBSTR.Add (addr' idx);  		}  		Status ("Failed to find index of {0} references"' GetStringFail.Count + GetStringWFail.Count + GetBSTRFail.Count);  	}  	Status ("Successfully found index of {0} references"' GetString.Count + GetBSTR.Count + GetStringW.Count);  	Status ("Decoding strings");  	for (int index = 0; index < ms_nSize; ++index)  		if (index != -1 && index <= 0xffff)  			Strings.Add (index' StringPoolDecode (index));  	Status ("Populating table");  	foreach (var s in Strings)  		MainForm.Invoke (() => MainForm.dataTable.Rows.Add (s.Key' s.Value' string.Empty));  	foreach (var a in GetString)  		MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetString")));  	foreach (var a in GetBSTR)  		MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetBSTR")));  	foreach (var a in GetStringW)  		MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetStringW")));  }  else if (StringDecodeMethod == 1)// StringDecoder   {  	MainForm.Invoke (() => MainForm.Text += " [StringDecoder]");  	int type = 0;  	int name = 0;  	int offset = 0;  	//search for CStringDecoder::DelayedLoad' which contains the resource type and name  	if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00'  		0x89'  		0x45'  		0xF4'  		0x6A'  		0xAA'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x8B'  		0x4D'  		0xF4'  		0x51'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 12;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 1;  		name = reader.ReadInt32 ();  	}  	else if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00'  		0x6A'  		0xAA'  		0x8B'  		0xF8'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x57'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 9;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 3;  		name = reader.ReadInt32 ();  	}  	else if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0xAA'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 1;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 1;  		name = reader.ReadInt32 ();  	}  	else  		throw new Exception ("Failed to determine type and name of resource.");  	//search for start of function CStringDecoder::DelayedLoad()  	reader.BaseStream.Position -= 50;  	// should be enough  	FindAoBInFile (reader' (int)reader.BaseStream.Position' new byte[] {  		0x55'  		0x8B'  		0xEC'  		0x83'  		0xEC'  		0x10  	});  	int offset_CStringDecoder__DelayedLoad = (int)reader.BaseStream.Position;  	for (reader.BaseStream.Position = 0; reader.BaseStream.Position < reader.BaseStream.Length;) {  		if (reader.ReadByte () != 0xE8)  			// call  			continue;  		int offse = reader.ReadInt32 ();  		if (reader.BaseStream.Position + offse == offset_CStringDecoder__DelayedLoad) {  			Status ("{0:X8} reference to offset_CStringDecoder__DelayedLoad = {1:X8}"' reader.BaseStream.Position - 5' offse);  			break;  		}  	}  	ImageResourceDirectory tier1 = (ImageResourceDirectory)root.GetEntry (type).Entry;  	ImageResourceDirectory tier2 = (ImageResourceDirectory)tier1.GetEntry (name).Entry;  	rsrcStringDataEntry = (ImageResourceDataEntry)tier2.Entrys [0].Entry;  	rsrcStringDataPosition = rsrcPointerToRawData + (rsrcStringDataEntry.OffsetToData - rsrcVirtualAddress);  	m_nCount = GetWordFromIndex (0);  	Status ("Amount of strings: {0}"' m_nCount);  	for (int i = 1; i < m_nCount; ++i)  		MainForm.Invoke (() => MainForm.dataTable.Rows.Add (i' StringDecoderDecode (i)' string.Format ("{0:X8}"' rsrcStringDataPosition + i * 4)));  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: if (StringDecodeMethod == 0)// StringPool   {  	MainForm.Invoke (() => MainForm.Text += " [StringPool]");  	int offset_StringPool__ms_aKey = (int)reader.BaseStream.Position;  	Status ("StringPool::ms_aKey located at {0:X8}"' offset_StringPool__ms_aKey);  	int keyRef = 0;  	// Only GetString references ms_aKey  	byte[] bytes = new byte[5];  	bytes [0] = 0x68;  	// push offset  	Buffer.BlockCopy (BitConverter.GetBytes (ImageBase + offset_StringPool__ms_aKey)' 0' bytes' 1' 4);  	if (FindAoBInFile (reader' 0' bytes))  		keyRef = (int)reader.BaseStream.Position;  	reader.BaseStream.Position = keyRef;  	while (true) {  		byte[] asdf = reader.ReadBytes (5);  		if (asdf [4] == 0xc3)// retn  		 {  			bool die = true;  			foreach (byte b in asdf)  				if (b == 0xe8)// call  				 {  					die = false;  					break;  				}  			if (die)  				break;  		}  		reader.BaseStream.Position -= 6;  	}  	while (reader.ReadByte () == 0xcc)  		;  	// allign  	reader.BaseStream.Position -= 1;  	int offset_StringPool__GetString_uint_char = (int)reader.BaseStream.Position;  	Status ("StringPool::GetString(uint' char) located at {0:X8}"' offset_StringPool__GetString_uint_char);  	//search for StringPool::offset_ms_aString  	if (FindAoBInFile (reader' keyRef - 100' new byte[] {  		0x8b'  		0x0c  	}' 100))  		reader.BaseStream.Position += 3;  	else if (FindAoBInFile (reader' keyRef - 100' new byte[] {  		0x8b'  		0x86  	}' 100))  		reader.BaseStream.Position += 2;  	else  		throw new Exception ("could not find start of StringPool::offset_ms_aString");  	offset_StringPool__ms_aString = reader.ReadInt32 () - ImageBase;  	Status ("StringPool::ms_aString located at {0:X8}"' offset_StringPool__ms_aString);  	//search for xrefs to function StringPool::GetString(uint' char)   	int[] xref = FindCalls (offset_StringPool__GetString_uint_char' 2);  	if (xref.Length != 2)  		throw new Exception ("failed to find references to StringPool::GetString(uint' char)");  	//search for start of StringPool::GetString(uint)  	if (!FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x51'  		0x8b  	}' 50) && !FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x55'  		0x8b  	}' 50))  		throw new Exception ("could not find start of GetString(uint)");  	int offset_StringPool__GetString_uint = (int)reader.BaseStream.Position;  	Status ("StringPool::GetString(uint) located at {0:X8}"' offset_StringPool__GetString_uint);  	//search for start of StringPool::GetString(uint' ushort)  	for (reader.BaseStream.Position = xref [1]; (reader.ReadUInt32 () & 0xffffff00) != 0x000cc200; reader.BaseStream.Position -= 5)  		;  	//seek the start of function StringPool::GetString(uint' char)  	while (reader.ReadByte () == 0xcc)  		;  	// allign  	reader.BaseStream.Position -= 1;  	int offset_StringPool__GetString_uint_ushort = (int)reader.BaseStream.Position;  	Status ("StringPool::GetString(uint' ushort) located at {0:X8}"' offset_StringPool__GetString_uint_ushort);  	//search for xrefs to function StringPool::GetString(uint)  	xref = FindCalls (offset_StringPool__GetString_uint' 1);  	if (xref.Length != 1)  		throw new Exception ("failed to find references to StringPool::GetString(uint)");  	//search for start of function StringPool::GetBSTR(uint)  	reader.BaseStream.Position -= 100;  	// should be enough  	if (!FindAoBInFile (reader' (int)reader.BaseStream.Position' new byte[] {  		0xb8'  		0xaa'  		0xaa'  		0xaa'  		0x00  	}))  		for (reader.BaseStream.Position = xref [0]; (reader.ReadUInt32 () & 0xff00ff00) != 0x0000c200; reader.BaseStream.Position -= 5)  			;  	//seek the start of function StringPool::GetString(uint' char)  	while (reader.ReadByte () == 0xcc)  		;  	// allign  	reader.BaseStream.Position -= 1;  	int offset_StringPool__GetBSTR_uint = (int)reader.BaseStream.Position;  	Status ("StringPool::GetBSTR(uint) located at {0:X8}"' offset_StringPool__GetBSTR_uint);  	//search for xrefs to function StringPool::GetString(uint' ushort)  	xref = FindCalls (offset_StringPool__GetString_uint_ushort' 1);  	if (xref.Length != 1)  		throw new Exception ("failed to find references to StringPool::GetString(uint' ushort)");  	//search for start of function StringPool::GetStringW(uint)  	if (!FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x51'  		0x8b  	}' 50) && !FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x55'  		0x8b  	}' 50))  		throw new Exception ("could not find start of GetStringW(uint)");  	int offset_StringPool__GetStringW_uint = (int)reader.BaseStream.Position;  	Status ("StringPool::GetStringW(uint) located at {0:X8}"' offset_StringPool__GetStringW_uint);  	ms_nSize = GetIntFromOffset (offset_StringPool__ms_aKey + 16 + 4);  	Status ("Amount of strings: {0}"' ms_nSize);  	if (MessageBox.Show ("Scan for references to strings in the client? This can take a while."' "Warning"' MessageBoxButtons.YesNo' MessageBoxIcon.Warning) == DialogResult.Yes) {  		Status ("Searching for references to GetString' GetStringW' and GetBSTR");  		List<int> GetStringCalls = new List<int> ();  		List<int> GetStringWCalls = new List<int> ();  		List<int> GetBSTRCalls = new List<int> ();  		for (reader.BaseStream.Position = 0; reader.BaseStream.Position < reader.BaseStream.Length;) {  			//int lol = (int)((float)reader.BaseStream.Position / reader.BaseStream.Length * 100);  			//if (lol > MainForm.toolStripProgressBar1.Value)  			//{  			//    MainForm.Invoke(() => MainForm.toolStripProgressBar1.Value = lol);  			//    MainForm.Invoke(() => MainForm.Update());  			//} too expensive  			if (reader.ReadByte () != 0xE8)  				// call  				continue;  			int offset = reader.ReadInt32 ();  			if (reader.BaseStream.Position + offset == offset_StringPool__GetString_uint)  				GetStringCalls.Add ((int)reader.BaseStream.Position - 5);  			else if (reader.BaseStream.Position + offset == offset_StringPool__GetStringW_uint)  				GetStringWCalls.Add ((int)reader.BaseStream.Position - 5);  			else if (reader.BaseStream.Position + offset == offset_StringPool__GetBSTR_uint)  				GetBSTRCalls.Add ((int)reader.BaseStream.Position - 5);  			else  				reader.BaseStream.Position -= 4;  		}  		List<int> GetStringFail = new List<int> ();  		foreach (int addr in GetStringCalls) {  			reader.BaseStream.Position = addr;  			reader.BaseStream.Position -= 2;  			if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  			 {  				GetStringFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 7;  			if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  			 {  				GetStringFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 2;  			if (reader.ReadByte () != 0x50)// push eax  			 {  				GetStringFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 6;  			if (reader.ReadByte () != 0x68)// push dword  			 {  				GetStringFail.Add (addr);  				continue;  			}  			int idx = reader.ReadInt32 ();  			if (idx > ms_nSize - 1)  				GetStringFail.Add (addr);  			else  				GetString.Add (addr' idx);  		}  		List<int> GetStringWFail = new List<int> ();  		foreach (int addr in GetStringWCalls) {  			reader.BaseStream.Position = addr;  			reader.BaseStream.Position -= 2;  			if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 7;  			if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 2;  			if (reader.ReadByte () != 0x50)// push eax  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 6;  			if (reader.ReadByte () != 0x68)// push dword  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			int idx = reader.ReadInt32 ();  			if (idx > ms_nSize - 1)  				GetStringWFail.Add (addr);  			else  				GetStringW.Add (addr' idx);  		}  		List<int> GetBSTRFail = new List<int> ();  		foreach (int addr in GetBSTRCalls) {  			reader.BaseStream.Position = addr;  			reader.BaseStream.Position -= 2;  			if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 7;  			if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 2;  			if (reader.ReadByte () != 0x50)// push eax  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 6;  			if (reader.ReadByte () != 0x68)// push dword  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			int idx = reader.ReadInt32 ();  			if (idx > ms_nSize - 1)  				GetBSTRFail.Add (addr);  			else  				GetBSTR.Add (addr' idx);  		}  		Status ("Failed to find index of {0} references"' GetStringFail.Count + GetStringWFail.Count + GetBSTRFail.Count);  	}  	Status ("Successfully found index of {0} references"' GetString.Count + GetBSTR.Count + GetStringW.Count);  	Status ("Decoding strings");  	for (int index = 0; index < ms_nSize; ++index)  		if (index != -1 && index <= 0xffff)  			Strings.Add (index' StringPoolDecode (index));  	Status ("Populating table");  	foreach (var s in Strings)  		MainForm.Invoke (() => MainForm.dataTable.Rows.Add (s.Key' s.Value' string.Empty));  	foreach (var a in GetString)  		MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetString")));  	foreach (var a in GetBSTR)  		MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetBSTR")));  	foreach (var a in GetStringW)  		MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetStringW")));  }  else if (StringDecodeMethod == 1)// StringDecoder   {  	MainForm.Invoke (() => MainForm.Text += " [StringDecoder]");  	int type = 0;  	int name = 0;  	int offset = 0;  	//search for CStringDecoder::DelayedLoad' which contains the resource type and name  	if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00'  		0x89'  		0x45'  		0xF4'  		0x6A'  		0xAA'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x8B'  		0x4D'  		0xF4'  		0x51'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 12;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 1;  		name = reader.ReadInt32 ();  	}  	else if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00'  		0x6A'  		0xAA'  		0x8B'  		0xF8'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x57'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 9;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 3;  		name = reader.ReadInt32 ();  	}  	else if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0xAA'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 1;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 1;  		name = reader.ReadInt32 ();  	}  	else  		throw new Exception ("Failed to determine type and name of resource.");  	//search for start of function CStringDecoder::DelayedLoad()  	reader.BaseStream.Position -= 50;  	// should be enough  	FindAoBInFile (reader' (int)reader.BaseStream.Position' new byte[] {  		0x55'  		0x8B'  		0xEC'  		0x83'  		0xEC'  		0x10  	});  	int offset_CStringDecoder__DelayedLoad = (int)reader.BaseStream.Position;  	for (reader.BaseStream.Position = 0; reader.BaseStream.Position < reader.BaseStream.Length;) {  		if (reader.ReadByte () != 0xE8)  			// call  			continue;  		int offse = reader.ReadInt32 ();  		if (reader.BaseStream.Position + offse == offset_CStringDecoder__DelayedLoad) {  			Status ("{0:X8} reference to offset_CStringDecoder__DelayedLoad = {1:X8}"' reader.BaseStream.Position - 5' offse);  			break;  		}  	}  	ImageResourceDirectory tier1 = (ImageResourceDirectory)root.GetEntry (type).Entry;  	ImageResourceDirectory tier2 = (ImageResourceDirectory)tier1.GetEntry (name).Entry;  	rsrcStringDataEntry = (ImageResourceDataEntry)tier2.Entrys [0].Entry;  	rsrcStringDataPosition = rsrcPointerToRawData + (rsrcStringDataEntry.OffsetToData - rsrcVirtualAddress);  	m_nCount = GetWordFromIndex (0);  	Status ("Amount of strings: {0}"' m_nCount);  	for (int i = 1; i < m_nCount; ++i)  		MainForm.Invoke (() => MainForm.dataTable.Rows.Add (i' StringDecoderDecode (i)' string.Format ("{0:X8}"' rsrcStringDataPosition + i * 4)));  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: if (StringDecodeMethod == 0)// StringPool   {  	MainForm.Invoke (() => MainForm.Text += " [StringPool]");  	int offset_StringPool__ms_aKey = (int)reader.BaseStream.Position;  	Status ("StringPool::ms_aKey located at {0:X8}"' offset_StringPool__ms_aKey);  	int keyRef = 0;  	// Only GetString references ms_aKey  	byte[] bytes = new byte[5];  	bytes [0] = 0x68;  	// push offset  	Buffer.BlockCopy (BitConverter.GetBytes (ImageBase + offset_StringPool__ms_aKey)' 0' bytes' 1' 4);  	if (FindAoBInFile (reader' 0' bytes))  		keyRef = (int)reader.BaseStream.Position;  	reader.BaseStream.Position = keyRef;  	while (true) {  		byte[] asdf = reader.ReadBytes (5);  		if (asdf [4] == 0xc3)// retn  		 {  			bool die = true;  			foreach (byte b in asdf)  				if (b == 0xe8)// call  				 {  					die = false;  					break;  				}  			if (die)  				break;  		}  		reader.BaseStream.Position -= 6;  	}  	while (reader.ReadByte () == 0xcc)  		;  	// allign  	reader.BaseStream.Position -= 1;  	int offset_StringPool__GetString_uint_char = (int)reader.BaseStream.Position;  	Status ("StringPool::GetString(uint' char) located at {0:X8}"' offset_StringPool__GetString_uint_char);  	//search for StringPool::offset_ms_aString  	if (FindAoBInFile (reader' keyRef - 100' new byte[] {  		0x8b'  		0x0c  	}' 100))  		reader.BaseStream.Position += 3;  	else if (FindAoBInFile (reader' keyRef - 100' new byte[] {  		0x8b'  		0x86  	}' 100))  		reader.BaseStream.Position += 2;  	else  		throw new Exception ("could not find start of StringPool::offset_ms_aString");  	offset_StringPool__ms_aString = reader.ReadInt32 () - ImageBase;  	Status ("StringPool::ms_aString located at {0:X8}"' offset_StringPool__ms_aString);  	//search for xrefs to function StringPool::GetString(uint' char)   	int[] xref = FindCalls (offset_StringPool__GetString_uint_char' 2);  	if (xref.Length != 2)  		throw new Exception ("failed to find references to StringPool::GetString(uint' char)");  	//search for start of StringPool::GetString(uint)  	if (!FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x51'  		0x8b  	}' 50) && !FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x55'  		0x8b  	}' 50))  		throw new Exception ("could not find start of GetString(uint)");  	int offset_StringPool__GetString_uint = (int)reader.BaseStream.Position;  	Status ("StringPool::GetString(uint) located at {0:X8}"' offset_StringPool__GetString_uint);  	//search for start of StringPool::GetString(uint' ushort)  	for (reader.BaseStream.Position = xref [1]; (reader.ReadUInt32 () & 0xffffff00) != 0x000cc200; reader.BaseStream.Position -= 5)  		;  	//seek the start of function StringPool::GetString(uint' char)  	while (reader.ReadByte () == 0xcc)  		;  	// allign  	reader.BaseStream.Position -= 1;  	int offset_StringPool__GetString_uint_ushort = (int)reader.BaseStream.Position;  	Status ("StringPool::GetString(uint' ushort) located at {0:X8}"' offset_StringPool__GetString_uint_ushort);  	//search for xrefs to function StringPool::GetString(uint)  	xref = FindCalls (offset_StringPool__GetString_uint' 1);  	if (xref.Length != 1)  		throw new Exception ("failed to find references to StringPool::GetString(uint)");  	//search for start of function StringPool::GetBSTR(uint)  	reader.BaseStream.Position -= 100;  	// should be enough  	if (!FindAoBInFile (reader' (int)reader.BaseStream.Position' new byte[] {  		0xb8'  		0xaa'  		0xaa'  		0xaa'  		0x00  	}))  		for (reader.BaseStream.Position = xref [0]; (reader.ReadUInt32 () & 0xff00ff00) != 0x0000c200; reader.BaseStream.Position -= 5)  			;  	//seek the start of function StringPool::GetString(uint' char)  	while (reader.ReadByte () == 0xcc)  		;  	// allign  	reader.BaseStream.Position -= 1;  	int offset_StringPool__GetBSTR_uint = (int)reader.BaseStream.Position;  	Status ("StringPool::GetBSTR(uint) located at {0:X8}"' offset_StringPool__GetBSTR_uint);  	//search for xrefs to function StringPool::GetString(uint' ushort)  	xref = FindCalls (offset_StringPool__GetString_uint_ushort' 1);  	if (xref.Length != 1)  		throw new Exception ("failed to find references to StringPool::GetString(uint' ushort)");  	//search for start of function StringPool::GetStringW(uint)  	if (!FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x51'  		0x8b  	}' 50) && !FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x55'  		0x8b  	}' 50))  		throw new Exception ("could not find start of GetStringW(uint)");  	int offset_StringPool__GetStringW_uint = (int)reader.BaseStream.Position;  	Status ("StringPool::GetStringW(uint) located at {0:X8}"' offset_StringPool__GetStringW_uint);  	ms_nSize = GetIntFromOffset (offset_StringPool__ms_aKey + 16 + 4);  	Status ("Amount of strings: {0}"' ms_nSize);  	if (MessageBox.Show ("Scan for references to strings in the client? This can take a while."' "Warning"' MessageBoxButtons.YesNo' MessageBoxIcon.Warning) == DialogResult.Yes) {  		Status ("Searching for references to GetString' GetStringW' and GetBSTR");  		List<int> GetStringCalls = new List<int> ();  		List<int> GetStringWCalls = new List<int> ();  		List<int> GetBSTRCalls = new List<int> ();  		for (reader.BaseStream.Position = 0; reader.BaseStream.Position < reader.BaseStream.Length;) {  			//int lol = (int)((float)reader.BaseStream.Position / reader.BaseStream.Length * 100);  			//if (lol > MainForm.toolStripProgressBar1.Value)  			//{  			//    MainForm.Invoke(() => MainForm.toolStripProgressBar1.Value = lol);  			//    MainForm.Invoke(() => MainForm.Update());  			//} too expensive  			if (reader.ReadByte () != 0xE8)  				// call  				continue;  			int offset = reader.ReadInt32 ();  			if (reader.BaseStream.Position + offset == offset_StringPool__GetString_uint)  				GetStringCalls.Add ((int)reader.BaseStream.Position - 5);  			else if (reader.BaseStream.Position + offset == offset_StringPool__GetStringW_uint)  				GetStringWCalls.Add ((int)reader.BaseStream.Position - 5);  			else if (reader.BaseStream.Position + offset == offset_StringPool__GetBSTR_uint)  				GetBSTRCalls.Add ((int)reader.BaseStream.Position - 5);  			else  				reader.BaseStream.Position -= 4;  		}  		List<int> GetStringFail = new List<int> ();  		foreach (int addr in GetStringCalls) {  			reader.BaseStream.Position = addr;  			reader.BaseStream.Position -= 2;  			if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  			 {  				GetStringFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 7;  			if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  			 {  				GetStringFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 2;  			if (reader.ReadByte () != 0x50)// push eax  			 {  				GetStringFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 6;  			if (reader.ReadByte () != 0x68)// push dword  			 {  				GetStringFail.Add (addr);  				continue;  			}  			int idx = reader.ReadInt32 ();  			if (idx > ms_nSize - 1)  				GetStringFail.Add (addr);  			else  				GetString.Add (addr' idx);  		}  		List<int> GetStringWFail = new List<int> ();  		foreach (int addr in GetStringWCalls) {  			reader.BaseStream.Position = addr;  			reader.BaseStream.Position -= 2;  			if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 7;  			if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 2;  			if (reader.ReadByte () != 0x50)// push eax  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 6;  			if (reader.ReadByte () != 0x68)// push dword  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			int idx = reader.ReadInt32 ();  			if (idx > ms_nSize - 1)  				GetStringWFail.Add (addr);  			else  				GetStringW.Add (addr' idx);  		}  		List<int> GetBSTRFail = new List<int> ();  		foreach (int addr in GetBSTRCalls) {  			reader.BaseStream.Position = addr;  			reader.BaseStream.Position -= 2;  			if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 7;  			if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 2;  			if (reader.ReadByte () != 0x50)// push eax  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 6;  			if (reader.ReadByte () != 0x68)// push dword  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			int idx = reader.ReadInt32 ();  			if (idx > ms_nSize - 1)  				GetBSTRFail.Add (addr);  			else  				GetBSTR.Add (addr' idx);  		}  		Status ("Failed to find index of {0} references"' GetStringFail.Count + GetStringWFail.Count + GetBSTRFail.Count);  	}  	Status ("Successfully found index of {0} references"' GetString.Count + GetBSTR.Count + GetStringW.Count);  	Status ("Decoding strings");  	for (int index = 0; index < ms_nSize; ++index)  		if (index != -1 && index <= 0xffff)  			Strings.Add (index' StringPoolDecode (index));  	Status ("Populating table");  	foreach (var s in Strings)  		MainForm.Invoke (() => MainForm.dataTable.Rows.Add (s.Key' s.Value' string.Empty));  	foreach (var a in GetString)  		MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetString")));  	foreach (var a in GetBSTR)  		MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetBSTR")));  	foreach (var a in GetStringW)  		MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetStringW")));  }  else if (StringDecodeMethod == 1)// StringDecoder   {  	MainForm.Invoke (() => MainForm.Text += " [StringDecoder]");  	int type = 0;  	int name = 0;  	int offset = 0;  	//search for CStringDecoder::DelayedLoad' which contains the resource type and name  	if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00'  		0x89'  		0x45'  		0xF4'  		0x6A'  		0xAA'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x8B'  		0x4D'  		0xF4'  		0x51'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 12;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 1;  		name = reader.ReadInt32 ();  	}  	else if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00'  		0x6A'  		0xAA'  		0x8B'  		0xF8'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x57'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 9;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 3;  		name = reader.ReadInt32 ();  	}  	else if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0xAA'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 1;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 1;  		name = reader.ReadInt32 ();  	}  	else  		throw new Exception ("Failed to determine type and name of resource.");  	//search for start of function CStringDecoder::DelayedLoad()  	reader.BaseStream.Position -= 50;  	// should be enough  	FindAoBInFile (reader' (int)reader.BaseStream.Position' new byte[] {  		0x55'  		0x8B'  		0xEC'  		0x83'  		0xEC'  		0x10  	});  	int offset_CStringDecoder__DelayedLoad = (int)reader.BaseStream.Position;  	for (reader.BaseStream.Position = 0; reader.BaseStream.Position < reader.BaseStream.Length;) {  		if (reader.ReadByte () != 0xE8)  			// call  			continue;  		int offse = reader.ReadInt32 ();  		if (reader.BaseStream.Position + offse == offset_CStringDecoder__DelayedLoad) {  			Status ("{0:X8} reference to offset_CStringDecoder__DelayedLoad = {1:X8}"' reader.BaseStream.Position - 5' offse);  			break;  		}  	}  	ImageResourceDirectory tier1 = (ImageResourceDirectory)root.GetEntry (type).Entry;  	ImageResourceDirectory tier2 = (ImageResourceDirectory)tier1.GetEntry (name).Entry;  	rsrcStringDataEntry = (ImageResourceDataEntry)tier2.Entrys [0].Entry;  	rsrcStringDataPosition = rsrcPointerToRawData + (rsrcStringDataEntry.OffsetToData - rsrcVirtualAddress);  	m_nCount = GetWordFromIndex (0);  	Status ("Amount of strings: {0}"' m_nCount);  	for (int i = 1; i < m_nCount; ++i)  		MainForm.Invoke (() => MainForm.dataTable.Rows.Add (i' StringDecoderDecode (i)' string.Format ("{0:X8}"' rsrcStringDataPosition + i * 4)));  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: if (StringDecodeMethod == 0)// StringPool   {  	MainForm.Invoke (() => MainForm.Text += " [StringPool]");  	int offset_StringPool__ms_aKey = (int)reader.BaseStream.Position;  	Status ("StringPool::ms_aKey located at {0:X8}"' offset_StringPool__ms_aKey);  	int keyRef = 0;  	// Only GetString references ms_aKey  	byte[] bytes = new byte[5];  	bytes [0] = 0x68;  	// push offset  	Buffer.BlockCopy (BitConverter.GetBytes (ImageBase + offset_StringPool__ms_aKey)' 0' bytes' 1' 4);  	if (FindAoBInFile (reader' 0' bytes))  		keyRef = (int)reader.BaseStream.Position;  	reader.BaseStream.Position = keyRef;  	while (true) {  		byte[] asdf = reader.ReadBytes (5);  		if (asdf [4] == 0xc3)// retn  		 {  			bool die = true;  			foreach (byte b in asdf)  				if (b == 0xe8)// call  				 {  					die = false;  					break;  				}  			if (die)  				break;  		}  		reader.BaseStream.Position -= 6;  	}  	while (reader.ReadByte () == 0xcc)  		;  	// allign  	reader.BaseStream.Position -= 1;  	int offset_StringPool__GetString_uint_char = (int)reader.BaseStream.Position;  	Status ("StringPool::GetString(uint' char) located at {0:X8}"' offset_StringPool__GetString_uint_char);  	//search for StringPool::offset_ms_aString  	if (FindAoBInFile (reader' keyRef - 100' new byte[] {  		0x8b'  		0x0c  	}' 100))  		reader.BaseStream.Position += 3;  	else if (FindAoBInFile (reader' keyRef - 100' new byte[] {  		0x8b'  		0x86  	}' 100))  		reader.BaseStream.Position += 2;  	else  		throw new Exception ("could not find start of StringPool::offset_ms_aString");  	offset_StringPool__ms_aString = reader.ReadInt32 () - ImageBase;  	Status ("StringPool::ms_aString located at {0:X8}"' offset_StringPool__ms_aString);  	//search for xrefs to function StringPool::GetString(uint' char)   	int[] xref = FindCalls (offset_StringPool__GetString_uint_char' 2);  	if (xref.Length != 2)  		throw new Exception ("failed to find references to StringPool::GetString(uint' char)");  	//search for start of StringPool::GetString(uint)  	if (!FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x51'  		0x8b  	}' 50) && !FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x55'  		0x8b  	}' 50))  		throw new Exception ("could not find start of GetString(uint)");  	int offset_StringPool__GetString_uint = (int)reader.BaseStream.Position;  	Status ("StringPool::GetString(uint) located at {0:X8}"' offset_StringPool__GetString_uint);  	//search for start of StringPool::GetString(uint' ushort)  	for (reader.BaseStream.Position = xref [1]; (reader.ReadUInt32 () & 0xffffff00) != 0x000cc200; reader.BaseStream.Position -= 5)  		;  	//seek the start of function StringPool::GetString(uint' char)  	while (reader.ReadByte () == 0xcc)  		;  	// allign  	reader.BaseStream.Position -= 1;  	int offset_StringPool__GetString_uint_ushort = (int)reader.BaseStream.Position;  	Status ("StringPool::GetString(uint' ushort) located at {0:X8}"' offset_StringPool__GetString_uint_ushort);  	//search for xrefs to function StringPool::GetString(uint)  	xref = FindCalls (offset_StringPool__GetString_uint' 1);  	if (xref.Length != 1)  		throw new Exception ("failed to find references to StringPool::GetString(uint)");  	//search for start of function StringPool::GetBSTR(uint)  	reader.BaseStream.Position -= 100;  	// should be enough  	if (!FindAoBInFile (reader' (int)reader.BaseStream.Position' new byte[] {  		0xb8'  		0xaa'  		0xaa'  		0xaa'  		0x00  	}))  		for (reader.BaseStream.Position = xref [0]; (reader.ReadUInt32 () & 0xff00ff00) != 0x0000c200; reader.BaseStream.Position -= 5)  			;  	//seek the start of function StringPool::GetString(uint' char)  	while (reader.ReadByte () == 0xcc)  		;  	// allign  	reader.BaseStream.Position -= 1;  	int offset_StringPool__GetBSTR_uint = (int)reader.BaseStream.Position;  	Status ("StringPool::GetBSTR(uint) located at {0:X8}"' offset_StringPool__GetBSTR_uint);  	//search for xrefs to function StringPool::GetString(uint' ushort)  	xref = FindCalls (offset_StringPool__GetString_uint_ushort' 1);  	if (xref.Length != 1)  		throw new Exception ("failed to find references to StringPool::GetString(uint' ushort)");  	//search for start of function StringPool::GetStringW(uint)  	if (!FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x51'  		0x8b  	}' 50) && !FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x55'  		0x8b  	}' 50))  		throw new Exception ("could not find start of GetStringW(uint)");  	int offset_StringPool__GetStringW_uint = (int)reader.BaseStream.Position;  	Status ("StringPool::GetStringW(uint) located at {0:X8}"' offset_StringPool__GetStringW_uint);  	ms_nSize = GetIntFromOffset (offset_StringPool__ms_aKey + 16 + 4);  	Status ("Amount of strings: {0}"' ms_nSize);  	if (MessageBox.Show ("Scan for references to strings in the client? This can take a while."' "Warning"' MessageBoxButtons.YesNo' MessageBoxIcon.Warning) == DialogResult.Yes) {  		Status ("Searching for references to GetString' GetStringW' and GetBSTR");  		List<int> GetStringCalls = new List<int> ();  		List<int> GetStringWCalls = new List<int> ();  		List<int> GetBSTRCalls = new List<int> ();  		for (reader.BaseStream.Position = 0; reader.BaseStream.Position < reader.BaseStream.Length;) {  			//int lol = (int)((float)reader.BaseStream.Position / reader.BaseStream.Length * 100);  			//if (lol > MainForm.toolStripProgressBar1.Value)  			//{  			//    MainForm.Invoke(() => MainForm.toolStripProgressBar1.Value = lol);  			//    MainForm.Invoke(() => MainForm.Update());  			//} too expensive  			if (reader.ReadByte () != 0xE8)  				// call  				continue;  			int offset = reader.ReadInt32 ();  			if (reader.BaseStream.Position + offset == offset_StringPool__GetString_uint)  				GetStringCalls.Add ((int)reader.BaseStream.Position - 5);  			else if (reader.BaseStream.Position + offset == offset_StringPool__GetStringW_uint)  				GetStringWCalls.Add ((int)reader.BaseStream.Position - 5);  			else if (reader.BaseStream.Position + offset == offset_StringPool__GetBSTR_uint)  				GetBSTRCalls.Add ((int)reader.BaseStream.Position - 5);  			else  				reader.BaseStream.Position -= 4;  		}  		List<int> GetStringFail = new List<int> ();  		foreach (int addr in GetStringCalls) {  			reader.BaseStream.Position = addr;  			reader.BaseStream.Position -= 2;  			if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  			 {  				GetStringFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 7;  			if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  			 {  				GetStringFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 2;  			if (reader.ReadByte () != 0x50)// push eax  			 {  				GetStringFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 6;  			if (reader.ReadByte () != 0x68)// push dword  			 {  				GetStringFail.Add (addr);  				continue;  			}  			int idx = reader.ReadInt32 ();  			if (idx > ms_nSize - 1)  				GetStringFail.Add (addr);  			else  				GetString.Add (addr' idx);  		}  		List<int> GetStringWFail = new List<int> ();  		foreach (int addr in GetStringWCalls) {  			reader.BaseStream.Position = addr;  			reader.BaseStream.Position -= 2;  			if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 7;  			if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 2;  			if (reader.ReadByte () != 0x50)// push eax  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 6;  			if (reader.ReadByte () != 0x68)// push dword  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			int idx = reader.ReadInt32 ();  			if (idx > ms_nSize - 1)  				GetStringWFail.Add (addr);  			else  				GetStringW.Add (addr' idx);  		}  		List<int> GetBSTRFail = new List<int> ();  		foreach (int addr in GetBSTRCalls) {  			reader.BaseStream.Position = addr;  			reader.BaseStream.Position -= 2;  			if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 7;  			if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 2;  			if (reader.ReadByte () != 0x50)// push eax  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 6;  			if (reader.ReadByte () != 0x68)// push dword  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			int idx = reader.ReadInt32 ();  			if (idx > ms_nSize - 1)  				GetBSTRFail.Add (addr);  			else  				GetBSTR.Add (addr' idx);  		}  		Status ("Failed to find index of {0} references"' GetStringFail.Count + GetStringWFail.Count + GetBSTRFail.Count);  	}  	Status ("Successfully found index of {0} references"' GetString.Count + GetBSTR.Count + GetStringW.Count);  	Status ("Decoding strings");  	for (int index = 0; index < ms_nSize; ++index)  		if (index != -1 && index <= 0xffff)  			Strings.Add (index' StringPoolDecode (index));  	Status ("Populating table");  	foreach (var s in Strings)  		MainForm.Invoke (() => MainForm.dataTable.Rows.Add (s.Key' s.Value' string.Empty));  	foreach (var a in GetString)  		MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetString")));  	foreach (var a in GetBSTR)  		MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetBSTR")));  	foreach (var a in GetStringW)  		MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetStringW")));  }  else if (StringDecodeMethod == 1)// StringDecoder   {  	MainForm.Invoke (() => MainForm.Text += " [StringDecoder]");  	int type = 0;  	int name = 0;  	int offset = 0;  	//search for CStringDecoder::DelayedLoad' which contains the resource type and name  	if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00'  		0x89'  		0x45'  		0xF4'  		0x6A'  		0xAA'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x8B'  		0x4D'  		0xF4'  		0x51'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 12;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 1;  		name = reader.ReadInt32 ();  	}  	else if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00'  		0x6A'  		0xAA'  		0x8B'  		0xF8'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x57'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 9;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 3;  		name = reader.ReadInt32 ();  	}  	else if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0xAA'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 1;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 1;  		name = reader.ReadInt32 ();  	}  	else  		throw new Exception ("Failed to determine type and name of resource.");  	//search for start of function CStringDecoder::DelayedLoad()  	reader.BaseStream.Position -= 50;  	// should be enough  	FindAoBInFile (reader' (int)reader.BaseStream.Position' new byte[] {  		0x55'  		0x8B'  		0xEC'  		0x83'  		0xEC'  		0x10  	});  	int offset_CStringDecoder__DelayedLoad = (int)reader.BaseStream.Position;  	for (reader.BaseStream.Position = 0; reader.BaseStream.Position < reader.BaseStream.Length;) {  		if (reader.ReadByte () != 0xE8)  			// call  			continue;  		int offse = reader.ReadInt32 ();  		if (reader.BaseStream.Position + offse == offset_CStringDecoder__DelayedLoad) {  			Status ("{0:X8} reference to offset_CStringDecoder__DelayedLoad = {1:X8}"' reader.BaseStream.Position - 5' offse);  			break;  		}  	}  	ImageResourceDirectory tier1 = (ImageResourceDirectory)root.GetEntry (type).Entry;  	ImageResourceDirectory tier2 = (ImageResourceDirectory)tier1.GetEntry (name).Entry;  	rsrcStringDataEntry = (ImageResourceDataEntry)tier2.Entrys [0].Entry;  	rsrcStringDataPosition = rsrcPointerToRawData + (rsrcStringDataEntry.OffsetToData - rsrcVirtualAddress);  	m_nCount = GetWordFromIndex (0);  	Status ("Amount of strings: {0}"' m_nCount);  	for (int i = 1; i < m_nCount; ++i)  		MainForm.Invoke (() => MainForm.dataTable.Rows.Add (i' StringDecoderDecode (i)' string.Format ("{0:X8}"' rsrcStringDataPosition + i * 4)));  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: if (StringDecodeMethod == 0)// StringPool   {  	MainForm.Invoke (() => MainForm.Text += " [StringPool]");  	int offset_StringPool__ms_aKey = (int)reader.BaseStream.Position;  	Status ("StringPool::ms_aKey located at {0:X8}"' offset_StringPool__ms_aKey);  	int keyRef = 0;  	// Only GetString references ms_aKey  	byte[] bytes = new byte[5];  	bytes [0] = 0x68;  	// push offset  	Buffer.BlockCopy (BitConverter.GetBytes (ImageBase + offset_StringPool__ms_aKey)' 0' bytes' 1' 4);  	if (FindAoBInFile (reader' 0' bytes))  		keyRef = (int)reader.BaseStream.Position;  	reader.BaseStream.Position = keyRef;  	while (true) {  		byte[] asdf = reader.ReadBytes (5);  		if (asdf [4] == 0xc3)// retn  		 {  			bool die = true;  			foreach (byte b in asdf)  				if (b == 0xe8)// call  				 {  					die = false;  					break;  				}  			if (die)  				break;  		}  		reader.BaseStream.Position -= 6;  	}  	while (reader.ReadByte () == 0xcc)  		;  	// allign  	reader.BaseStream.Position -= 1;  	int offset_StringPool__GetString_uint_char = (int)reader.BaseStream.Position;  	Status ("StringPool::GetString(uint' char) located at {0:X8}"' offset_StringPool__GetString_uint_char);  	//search for StringPool::offset_ms_aString  	if (FindAoBInFile (reader' keyRef - 100' new byte[] {  		0x8b'  		0x0c  	}' 100))  		reader.BaseStream.Position += 3;  	else if (FindAoBInFile (reader' keyRef - 100' new byte[] {  		0x8b'  		0x86  	}' 100))  		reader.BaseStream.Position += 2;  	else  		throw new Exception ("could not find start of StringPool::offset_ms_aString");  	offset_StringPool__ms_aString = reader.ReadInt32 () - ImageBase;  	Status ("StringPool::ms_aString located at {0:X8}"' offset_StringPool__ms_aString);  	//search for xrefs to function StringPool::GetString(uint' char)   	int[] xref = FindCalls (offset_StringPool__GetString_uint_char' 2);  	if (xref.Length != 2)  		throw new Exception ("failed to find references to StringPool::GetString(uint' char)");  	//search for start of StringPool::GetString(uint)  	if (!FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x51'  		0x8b  	}' 50) && !FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x55'  		0x8b  	}' 50))  		throw new Exception ("could not find start of GetString(uint)");  	int offset_StringPool__GetString_uint = (int)reader.BaseStream.Position;  	Status ("StringPool::GetString(uint) located at {0:X8}"' offset_StringPool__GetString_uint);  	//search for start of StringPool::GetString(uint' ushort)  	for (reader.BaseStream.Position = xref [1]; (reader.ReadUInt32 () & 0xffffff00) != 0x000cc200; reader.BaseStream.Position -= 5)  		;  	//seek the start of function StringPool::GetString(uint' char)  	while (reader.ReadByte () == 0xcc)  		;  	// allign  	reader.BaseStream.Position -= 1;  	int offset_StringPool__GetString_uint_ushort = (int)reader.BaseStream.Position;  	Status ("StringPool::GetString(uint' ushort) located at {0:X8}"' offset_StringPool__GetString_uint_ushort);  	//search for xrefs to function StringPool::GetString(uint)  	xref = FindCalls (offset_StringPool__GetString_uint' 1);  	if (xref.Length != 1)  		throw new Exception ("failed to find references to StringPool::GetString(uint)");  	//search for start of function StringPool::GetBSTR(uint)  	reader.BaseStream.Position -= 100;  	// should be enough  	if (!FindAoBInFile (reader' (int)reader.BaseStream.Position' new byte[] {  		0xb8'  		0xaa'  		0xaa'  		0xaa'  		0x00  	}))  		for (reader.BaseStream.Position = xref [0]; (reader.ReadUInt32 () & 0xff00ff00) != 0x0000c200; reader.BaseStream.Position -= 5)  			;  	//seek the start of function StringPool::GetString(uint' char)  	while (reader.ReadByte () == 0xcc)  		;  	// allign  	reader.BaseStream.Position -= 1;  	int offset_StringPool__GetBSTR_uint = (int)reader.BaseStream.Position;  	Status ("StringPool::GetBSTR(uint) located at {0:X8}"' offset_StringPool__GetBSTR_uint);  	//search for xrefs to function StringPool::GetString(uint' ushort)  	xref = FindCalls (offset_StringPool__GetString_uint_ushort' 1);  	if (xref.Length != 1)  		throw new Exception ("failed to find references to StringPool::GetString(uint' ushort)");  	//search for start of function StringPool::GetStringW(uint)  	if (!FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x51'  		0x8b  	}' 50) && !FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x55'  		0x8b  	}' 50))  		throw new Exception ("could not find start of GetStringW(uint)");  	int offset_StringPool__GetStringW_uint = (int)reader.BaseStream.Position;  	Status ("StringPool::GetStringW(uint) located at {0:X8}"' offset_StringPool__GetStringW_uint);  	ms_nSize = GetIntFromOffset (offset_StringPool__ms_aKey + 16 + 4);  	Status ("Amount of strings: {0}"' ms_nSize);  	if (MessageBox.Show ("Scan for references to strings in the client? This can take a while."' "Warning"' MessageBoxButtons.YesNo' MessageBoxIcon.Warning) == DialogResult.Yes) {  		Status ("Searching for references to GetString' GetStringW' and GetBSTR");  		List<int> GetStringCalls = new List<int> ();  		List<int> GetStringWCalls = new List<int> ();  		List<int> GetBSTRCalls = new List<int> ();  		for (reader.BaseStream.Position = 0; reader.BaseStream.Position < reader.BaseStream.Length;) {  			//int lol = (int)((float)reader.BaseStream.Position / reader.BaseStream.Length * 100);  			//if (lol > MainForm.toolStripProgressBar1.Value)  			//{  			//    MainForm.Invoke(() => MainForm.toolStripProgressBar1.Value = lol);  			//    MainForm.Invoke(() => MainForm.Update());  			//} too expensive  			if (reader.ReadByte () != 0xE8)  				// call  				continue;  			int offset = reader.ReadInt32 ();  			if (reader.BaseStream.Position + offset == offset_StringPool__GetString_uint)  				GetStringCalls.Add ((int)reader.BaseStream.Position - 5);  			else if (reader.BaseStream.Position + offset == offset_StringPool__GetStringW_uint)  				GetStringWCalls.Add ((int)reader.BaseStream.Position - 5);  			else if (reader.BaseStream.Position + offset == offset_StringPool__GetBSTR_uint)  				GetBSTRCalls.Add ((int)reader.BaseStream.Position - 5);  			else  				reader.BaseStream.Position -= 4;  		}  		List<int> GetStringFail = new List<int> ();  		foreach (int addr in GetStringCalls) {  			reader.BaseStream.Position = addr;  			reader.BaseStream.Position -= 2;  			if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  			 {  				GetStringFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 7;  			if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  			 {  				GetStringFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 2;  			if (reader.ReadByte () != 0x50)// push eax  			 {  				GetStringFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 6;  			if (reader.ReadByte () != 0x68)// push dword  			 {  				GetStringFail.Add (addr);  				continue;  			}  			int idx = reader.ReadInt32 ();  			if (idx > ms_nSize - 1)  				GetStringFail.Add (addr);  			else  				GetString.Add (addr' idx);  		}  		List<int> GetStringWFail = new List<int> ();  		foreach (int addr in GetStringWCalls) {  			reader.BaseStream.Position = addr;  			reader.BaseStream.Position -= 2;  			if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 7;  			if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 2;  			if (reader.ReadByte () != 0x50)// push eax  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 6;  			if (reader.ReadByte () != 0x68)// push dword  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			int idx = reader.ReadInt32 ();  			if (idx > ms_nSize - 1)  				GetStringWFail.Add (addr);  			else  				GetStringW.Add (addr' idx);  		}  		List<int> GetBSTRFail = new List<int> ();  		foreach (int addr in GetBSTRCalls) {  			reader.BaseStream.Position = addr;  			reader.BaseStream.Position -= 2;  			if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 7;  			if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 2;  			if (reader.ReadByte () != 0x50)// push eax  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 6;  			if (reader.ReadByte () != 0x68)// push dword  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			int idx = reader.ReadInt32 ();  			if (idx > ms_nSize - 1)  				GetBSTRFail.Add (addr);  			else  				GetBSTR.Add (addr' idx);  		}  		Status ("Failed to find index of {0} references"' GetStringFail.Count + GetStringWFail.Count + GetBSTRFail.Count);  	}  	Status ("Successfully found index of {0} references"' GetString.Count + GetBSTR.Count + GetStringW.Count);  	Status ("Decoding strings");  	for (int index = 0; index < ms_nSize; ++index)  		if (index != -1 && index <= 0xffff)  			Strings.Add (index' StringPoolDecode (index));  	Status ("Populating table");  	foreach (var s in Strings)  		MainForm.Invoke (() => MainForm.dataTable.Rows.Add (s.Key' s.Value' string.Empty));  	foreach (var a in GetString)  		MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetString")));  	foreach (var a in GetBSTR)  		MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetBSTR")));  	foreach (var a in GetStringW)  		MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetStringW")));  }  else if (StringDecodeMethod == 1)// StringDecoder   {  	MainForm.Invoke (() => MainForm.Text += " [StringDecoder]");  	int type = 0;  	int name = 0;  	int offset = 0;  	//search for CStringDecoder::DelayedLoad' which contains the resource type and name  	if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00'  		0x89'  		0x45'  		0xF4'  		0x6A'  		0xAA'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x8B'  		0x4D'  		0xF4'  		0x51'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 12;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 1;  		name = reader.ReadInt32 ();  	}  	else if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00'  		0x6A'  		0xAA'  		0x8B'  		0xF8'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x57'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 9;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 3;  		name = reader.ReadInt32 ();  	}  	else if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0xAA'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 1;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 1;  		name = reader.ReadInt32 ();  	}  	else  		throw new Exception ("Failed to determine type and name of resource.");  	//search for start of function CStringDecoder::DelayedLoad()  	reader.BaseStream.Position -= 50;  	// should be enough  	FindAoBInFile (reader' (int)reader.BaseStream.Position' new byte[] {  		0x55'  		0x8B'  		0xEC'  		0x83'  		0xEC'  		0x10  	});  	int offset_CStringDecoder__DelayedLoad = (int)reader.BaseStream.Position;  	for (reader.BaseStream.Position = 0; reader.BaseStream.Position < reader.BaseStream.Length;) {  		if (reader.ReadByte () != 0xE8)  			// call  			continue;  		int offse = reader.ReadInt32 ();  		if (reader.BaseStream.Position + offse == offset_CStringDecoder__DelayedLoad) {  			Status ("{0:X8} reference to offset_CStringDecoder__DelayedLoad = {1:X8}"' reader.BaseStream.Position - 5' offse);  			break;  		}  	}  	ImageResourceDirectory tier1 = (ImageResourceDirectory)root.GetEntry (type).Entry;  	ImageResourceDirectory tier2 = (ImageResourceDirectory)tier1.GetEntry (name).Entry;  	rsrcStringDataEntry = (ImageResourceDataEntry)tier2.Entrys [0].Entry;  	rsrcStringDataPosition = rsrcPointerToRawData + (rsrcStringDataEntry.OffsetToData - rsrcVirtualAddress);  	m_nCount = GetWordFromIndex (0);  	Status ("Amount of strings: {0}"' m_nCount);  	for (int i = 1; i < m_nCount; ++i)  		MainForm.Invoke (() => MainForm.dataTable.Rows.Add (i' StringDecoderDecode (i)' string.Format ("{0:X8}"' rsrcStringDataPosition + i * 4)));  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: if (StringDecodeMethod == 0)// StringPool   {  	MainForm.Invoke (() => MainForm.Text += " [StringPool]");  	int offset_StringPool__ms_aKey = (int)reader.BaseStream.Position;  	Status ("StringPool::ms_aKey located at {0:X8}"' offset_StringPool__ms_aKey);  	int keyRef = 0;  	// Only GetString references ms_aKey  	byte[] bytes = new byte[5];  	bytes [0] = 0x68;  	// push offset  	Buffer.BlockCopy (BitConverter.GetBytes (ImageBase + offset_StringPool__ms_aKey)' 0' bytes' 1' 4);  	if (FindAoBInFile (reader' 0' bytes))  		keyRef = (int)reader.BaseStream.Position;  	reader.BaseStream.Position = keyRef;  	while (true) {  		byte[] asdf = reader.ReadBytes (5);  		if (asdf [4] == 0xc3)// retn  		 {  			bool die = true;  			foreach (byte b in asdf)  				if (b == 0xe8)// call  				 {  					die = false;  					break;  				}  			if (die)  				break;  		}  		reader.BaseStream.Position -= 6;  	}  	while (reader.ReadByte () == 0xcc)  		;  	// allign  	reader.BaseStream.Position -= 1;  	int offset_StringPool__GetString_uint_char = (int)reader.BaseStream.Position;  	Status ("StringPool::GetString(uint' char) located at {0:X8}"' offset_StringPool__GetString_uint_char);  	//search for StringPool::offset_ms_aString  	if (FindAoBInFile (reader' keyRef - 100' new byte[] {  		0x8b'  		0x0c  	}' 100))  		reader.BaseStream.Position += 3;  	else if (FindAoBInFile (reader' keyRef - 100' new byte[] {  		0x8b'  		0x86  	}' 100))  		reader.BaseStream.Position += 2;  	else  		throw new Exception ("could not find start of StringPool::offset_ms_aString");  	offset_StringPool__ms_aString = reader.ReadInt32 () - ImageBase;  	Status ("StringPool::ms_aString located at {0:X8}"' offset_StringPool__ms_aString);  	//search for xrefs to function StringPool::GetString(uint' char)   	int[] xref = FindCalls (offset_StringPool__GetString_uint_char' 2);  	if (xref.Length != 2)  		throw new Exception ("failed to find references to StringPool::GetString(uint' char)");  	//search for start of StringPool::GetString(uint)  	if (!FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x51'  		0x8b  	}' 50) && !FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x55'  		0x8b  	}' 50))  		throw new Exception ("could not find start of GetString(uint)");  	int offset_StringPool__GetString_uint = (int)reader.BaseStream.Position;  	Status ("StringPool::GetString(uint) located at {0:X8}"' offset_StringPool__GetString_uint);  	//search for start of StringPool::GetString(uint' ushort)  	for (reader.BaseStream.Position = xref [1]; (reader.ReadUInt32 () & 0xffffff00) != 0x000cc200; reader.BaseStream.Position -= 5)  		;  	//seek the start of function StringPool::GetString(uint' char)  	while (reader.ReadByte () == 0xcc)  		;  	// allign  	reader.BaseStream.Position -= 1;  	int offset_StringPool__GetString_uint_ushort = (int)reader.BaseStream.Position;  	Status ("StringPool::GetString(uint' ushort) located at {0:X8}"' offset_StringPool__GetString_uint_ushort);  	//search for xrefs to function StringPool::GetString(uint)  	xref = FindCalls (offset_StringPool__GetString_uint' 1);  	if (xref.Length != 1)  		throw new Exception ("failed to find references to StringPool::GetString(uint)");  	//search for start of function StringPool::GetBSTR(uint)  	reader.BaseStream.Position -= 100;  	// should be enough  	if (!FindAoBInFile (reader' (int)reader.BaseStream.Position' new byte[] {  		0xb8'  		0xaa'  		0xaa'  		0xaa'  		0x00  	}))  		for (reader.BaseStream.Position = xref [0]; (reader.ReadUInt32 () & 0xff00ff00) != 0x0000c200; reader.BaseStream.Position -= 5)  			;  	//seek the start of function StringPool::GetString(uint' char)  	while (reader.ReadByte () == 0xcc)  		;  	// allign  	reader.BaseStream.Position -= 1;  	int offset_StringPool__GetBSTR_uint = (int)reader.BaseStream.Position;  	Status ("StringPool::GetBSTR(uint) located at {0:X8}"' offset_StringPool__GetBSTR_uint);  	//search for xrefs to function StringPool::GetString(uint' ushort)  	xref = FindCalls (offset_StringPool__GetString_uint_ushort' 1);  	if (xref.Length != 1)  		throw new Exception ("failed to find references to StringPool::GetString(uint' ushort)");  	//search for start of function StringPool::GetStringW(uint)  	if (!FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x51'  		0x8b  	}' 50) && !FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x55'  		0x8b  	}' 50))  		throw new Exception ("could not find start of GetStringW(uint)");  	int offset_StringPool__GetStringW_uint = (int)reader.BaseStream.Position;  	Status ("StringPool::GetStringW(uint) located at {0:X8}"' offset_StringPool__GetStringW_uint);  	ms_nSize = GetIntFromOffset (offset_StringPool__ms_aKey + 16 + 4);  	Status ("Amount of strings: {0}"' ms_nSize);  	if (MessageBox.Show ("Scan for references to strings in the client? This can take a while."' "Warning"' MessageBoxButtons.YesNo' MessageBoxIcon.Warning) == DialogResult.Yes) {  		Status ("Searching for references to GetString' GetStringW' and GetBSTR");  		List<int> GetStringCalls = new List<int> ();  		List<int> GetStringWCalls = new List<int> ();  		List<int> GetBSTRCalls = new List<int> ();  		for (reader.BaseStream.Position = 0; reader.BaseStream.Position < reader.BaseStream.Length;) {  			//int lol = (int)((float)reader.BaseStream.Position / reader.BaseStream.Length * 100);  			//if (lol > MainForm.toolStripProgressBar1.Value)  			//{  			//    MainForm.Invoke(() => MainForm.toolStripProgressBar1.Value = lol);  			//    MainForm.Invoke(() => MainForm.Update());  			//} too expensive  			if (reader.ReadByte () != 0xE8)  				// call  				continue;  			int offset = reader.ReadInt32 ();  			if (reader.BaseStream.Position + offset == offset_StringPool__GetString_uint)  				GetStringCalls.Add ((int)reader.BaseStream.Position - 5);  			else if (reader.BaseStream.Position + offset == offset_StringPool__GetStringW_uint)  				GetStringWCalls.Add ((int)reader.BaseStream.Position - 5);  			else if (reader.BaseStream.Position + offset == offset_StringPool__GetBSTR_uint)  				GetBSTRCalls.Add ((int)reader.BaseStream.Position - 5);  			else  				reader.BaseStream.Position -= 4;  		}  		List<int> GetStringFail = new List<int> ();  		foreach (int addr in GetStringCalls) {  			reader.BaseStream.Position = addr;  			reader.BaseStream.Position -= 2;  			if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  			 {  				GetStringFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 7;  			if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  			 {  				GetStringFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 2;  			if (reader.ReadByte () != 0x50)// push eax  			 {  				GetStringFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 6;  			if (reader.ReadByte () != 0x68)// push dword  			 {  				GetStringFail.Add (addr);  				continue;  			}  			int idx = reader.ReadInt32 ();  			if (idx > ms_nSize - 1)  				GetStringFail.Add (addr);  			else  				GetString.Add (addr' idx);  		}  		List<int> GetStringWFail = new List<int> ();  		foreach (int addr in GetStringWCalls) {  			reader.BaseStream.Position = addr;  			reader.BaseStream.Position -= 2;  			if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 7;  			if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 2;  			if (reader.ReadByte () != 0x50)// push eax  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 6;  			if (reader.ReadByte () != 0x68)// push dword  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			int idx = reader.ReadInt32 ();  			if (idx > ms_nSize - 1)  				GetStringWFail.Add (addr);  			else  				GetStringW.Add (addr' idx);  		}  		List<int> GetBSTRFail = new List<int> ();  		foreach (int addr in GetBSTRCalls) {  			reader.BaseStream.Position = addr;  			reader.BaseStream.Position -= 2;  			if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 7;  			if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 2;  			if (reader.ReadByte () != 0x50)// push eax  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 6;  			if (reader.ReadByte () != 0x68)// push dword  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			int idx = reader.ReadInt32 ();  			if (idx > ms_nSize - 1)  				GetBSTRFail.Add (addr);  			else  				GetBSTR.Add (addr' idx);  		}  		Status ("Failed to find index of {0} references"' GetStringFail.Count + GetStringWFail.Count + GetBSTRFail.Count);  	}  	Status ("Successfully found index of {0} references"' GetString.Count + GetBSTR.Count + GetStringW.Count);  	Status ("Decoding strings");  	for (int index = 0; index < ms_nSize; ++index)  		if (index != -1 && index <= 0xffff)  			Strings.Add (index' StringPoolDecode (index));  	Status ("Populating table");  	foreach (var s in Strings)  		MainForm.Invoke (() => MainForm.dataTable.Rows.Add (s.Key' s.Value' string.Empty));  	foreach (var a in GetString)  		MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetString")));  	foreach (var a in GetBSTR)  		MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetBSTR")));  	foreach (var a in GetStringW)  		MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetStringW")));  }  else if (StringDecodeMethod == 1)// StringDecoder   {  	MainForm.Invoke (() => MainForm.Text += " [StringDecoder]");  	int type = 0;  	int name = 0;  	int offset = 0;  	//search for CStringDecoder::DelayedLoad' which contains the resource type and name  	if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00'  		0x89'  		0x45'  		0xF4'  		0x6A'  		0xAA'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x8B'  		0x4D'  		0xF4'  		0x51'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 12;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 1;  		name = reader.ReadInt32 ();  	}  	else if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00'  		0x6A'  		0xAA'  		0x8B'  		0xF8'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x57'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 9;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 3;  		name = reader.ReadInt32 ();  	}  	else if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0xAA'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 1;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 1;  		name = reader.ReadInt32 ();  	}  	else  		throw new Exception ("Failed to determine type and name of resource.");  	//search for start of function CStringDecoder::DelayedLoad()  	reader.BaseStream.Position -= 50;  	// should be enough  	FindAoBInFile (reader' (int)reader.BaseStream.Position' new byte[] {  		0x55'  		0x8B'  		0xEC'  		0x83'  		0xEC'  		0x10  	});  	int offset_CStringDecoder__DelayedLoad = (int)reader.BaseStream.Position;  	for (reader.BaseStream.Position = 0; reader.BaseStream.Position < reader.BaseStream.Length;) {  		if (reader.ReadByte () != 0xE8)  			// call  			continue;  		int offse = reader.ReadInt32 ();  		if (reader.BaseStream.Position + offse == offset_CStringDecoder__DelayedLoad) {  			Status ("{0:X8} reference to offset_CStringDecoder__DelayedLoad = {1:X8}"' reader.BaseStream.Position - 5' offse);  			break;  		}  	}  	ImageResourceDirectory tier1 = (ImageResourceDirectory)root.GetEntry (type).Entry;  	ImageResourceDirectory tier2 = (ImageResourceDirectory)tier1.GetEntry (name).Entry;  	rsrcStringDataEntry = (ImageResourceDataEntry)tier2.Entrys [0].Entry;  	rsrcStringDataPosition = rsrcPointerToRawData + (rsrcStringDataEntry.OffsetToData - rsrcVirtualAddress);  	m_nCount = GetWordFromIndex (0);  	Status ("Amount of strings: {0}"' m_nCount);  	for (int i = 1; i < m_nCount; ++i)  		MainForm.Invoke (() => MainForm.dataTable.Rows.Add (i' StringDecoderDecode (i)' string.Format ("{0:X8}"' rsrcStringDataPosition + i * 4)));  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: if (StringDecodeMethod == 0)// StringPool   {  	MainForm.Invoke (() => MainForm.Text += " [StringPool]");  	int offset_StringPool__ms_aKey = (int)reader.BaseStream.Position;  	Status ("StringPool::ms_aKey located at {0:X8}"' offset_StringPool__ms_aKey);  	int keyRef = 0;  	// Only GetString references ms_aKey  	byte[] bytes = new byte[5];  	bytes [0] = 0x68;  	// push offset  	Buffer.BlockCopy (BitConverter.GetBytes (ImageBase + offset_StringPool__ms_aKey)' 0' bytes' 1' 4);  	if (FindAoBInFile (reader' 0' bytes))  		keyRef = (int)reader.BaseStream.Position;  	reader.BaseStream.Position = keyRef;  	while (true) {  		byte[] asdf = reader.ReadBytes (5);  		if (asdf [4] == 0xc3)// retn  		 {  			bool die = true;  			foreach (byte b in asdf)  				if (b == 0xe8)// call  				 {  					die = false;  					break;  				}  			if (die)  				break;  		}  		reader.BaseStream.Position -= 6;  	}  	while (reader.ReadByte () == 0xcc)  		;  	// allign  	reader.BaseStream.Position -= 1;  	int offset_StringPool__GetString_uint_char = (int)reader.BaseStream.Position;  	Status ("StringPool::GetString(uint' char) located at {0:X8}"' offset_StringPool__GetString_uint_char);  	//search for StringPool::offset_ms_aString  	if (FindAoBInFile (reader' keyRef - 100' new byte[] {  		0x8b'  		0x0c  	}' 100))  		reader.BaseStream.Position += 3;  	else if (FindAoBInFile (reader' keyRef - 100' new byte[] {  		0x8b'  		0x86  	}' 100))  		reader.BaseStream.Position += 2;  	else  		throw new Exception ("could not find start of StringPool::offset_ms_aString");  	offset_StringPool__ms_aString = reader.ReadInt32 () - ImageBase;  	Status ("StringPool::ms_aString located at {0:X8}"' offset_StringPool__ms_aString);  	//search for xrefs to function StringPool::GetString(uint' char)   	int[] xref = FindCalls (offset_StringPool__GetString_uint_char' 2);  	if (xref.Length != 2)  		throw new Exception ("failed to find references to StringPool::GetString(uint' char)");  	//search for start of StringPool::GetString(uint)  	if (!FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x51'  		0x8b  	}' 50) && !FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x55'  		0x8b  	}' 50))  		throw new Exception ("could not find start of GetString(uint)");  	int offset_StringPool__GetString_uint = (int)reader.BaseStream.Position;  	Status ("StringPool::GetString(uint) located at {0:X8}"' offset_StringPool__GetString_uint);  	//search for start of StringPool::GetString(uint' ushort)  	for (reader.BaseStream.Position = xref [1]; (reader.ReadUInt32 () & 0xffffff00) != 0x000cc200; reader.BaseStream.Position -= 5)  		;  	//seek the start of function StringPool::GetString(uint' char)  	while (reader.ReadByte () == 0xcc)  		;  	// allign  	reader.BaseStream.Position -= 1;  	int offset_StringPool__GetString_uint_ushort = (int)reader.BaseStream.Position;  	Status ("StringPool::GetString(uint' ushort) located at {0:X8}"' offset_StringPool__GetString_uint_ushort);  	//search for xrefs to function StringPool::GetString(uint)  	xref = FindCalls (offset_StringPool__GetString_uint' 1);  	if (xref.Length != 1)  		throw new Exception ("failed to find references to StringPool::GetString(uint)");  	//search for start of function StringPool::GetBSTR(uint)  	reader.BaseStream.Position -= 100;  	// should be enough  	if (!FindAoBInFile (reader' (int)reader.BaseStream.Position' new byte[] {  		0xb8'  		0xaa'  		0xaa'  		0xaa'  		0x00  	}))  		for (reader.BaseStream.Position = xref [0]; (reader.ReadUInt32 () & 0xff00ff00) != 0x0000c200; reader.BaseStream.Position -= 5)  			;  	//seek the start of function StringPool::GetString(uint' char)  	while (reader.ReadByte () == 0xcc)  		;  	// allign  	reader.BaseStream.Position -= 1;  	int offset_StringPool__GetBSTR_uint = (int)reader.BaseStream.Position;  	Status ("StringPool::GetBSTR(uint) located at {0:X8}"' offset_StringPool__GetBSTR_uint);  	//search for xrefs to function StringPool::GetString(uint' ushort)  	xref = FindCalls (offset_StringPool__GetString_uint_ushort' 1);  	if (xref.Length != 1)  		throw new Exception ("failed to find references to StringPool::GetString(uint' ushort)");  	//search for start of function StringPool::GetStringW(uint)  	if (!FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x51'  		0x8b  	}' 50) && !FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x55'  		0x8b  	}' 50))  		throw new Exception ("could not find start of GetStringW(uint)");  	int offset_StringPool__GetStringW_uint = (int)reader.BaseStream.Position;  	Status ("StringPool::GetStringW(uint) located at {0:X8}"' offset_StringPool__GetStringW_uint);  	ms_nSize = GetIntFromOffset (offset_StringPool__ms_aKey + 16 + 4);  	Status ("Amount of strings: {0}"' ms_nSize);  	if (MessageBox.Show ("Scan for references to strings in the client? This can take a while."' "Warning"' MessageBoxButtons.YesNo' MessageBoxIcon.Warning) == DialogResult.Yes) {  		Status ("Searching for references to GetString' GetStringW' and GetBSTR");  		List<int> GetStringCalls = new List<int> ();  		List<int> GetStringWCalls = new List<int> ();  		List<int> GetBSTRCalls = new List<int> ();  		for (reader.BaseStream.Position = 0; reader.BaseStream.Position < reader.BaseStream.Length;) {  			//int lol = (int)((float)reader.BaseStream.Position / reader.BaseStream.Length * 100);  			//if (lol > MainForm.toolStripProgressBar1.Value)  			//{  			//    MainForm.Invoke(() => MainForm.toolStripProgressBar1.Value = lol);  			//    MainForm.Invoke(() => MainForm.Update());  			//} too expensive  			if (reader.ReadByte () != 0xE8)  				// call  				continue;  			int offset = reader.ReadInt32 ();  			if (reader.BaseStream.Position + offset == offset_StringPool__GetString_uint)  				GetStringCalls.Add ((int)reader.BaseStream.Position - 5);  			else if (reader.BaseStream.Position + offset == offset_StringPool__GetStringW_uint)  				GetStringWCalls.Add ((int)reader.BaseStream.Position - 5);  			else if (reader.BaseStream.Position + offset == offset_StringPool__GetBSTR_uint)  				GetBSTRCalls.Add ((int)reader.BaseStream.Position - 5);  			else  				reader.BaseStream.Position -= 4;  		}  		List<int> GetStringFail = new List<int> ();  		foreach (int addr in GetStringCalls) {  			reader.BaseStream.Position = addr;  			reader.BaseStream.Position -= 2;  			if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  			 {  				GetStringFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 7;  			if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  			 {  				GetStringFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 2;  			if (reader.ReadByte () != 0x50)// push eax  			 {  				GetStringFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 6;  			if (reader.ReadByte () != 0x68)// push dword  			 {  				GetStringFail.Add (addr);  				continue;  			}  			int idx = reader.ReadInt32 ();  			if (idx > ms_nSize - 1)  				GetStringFail.Add (addr);  			else  				GetString.Add (addr' idx);  		}  		List<int> GetStringWFail = new List<int> ();  		foreach (int addr in GetStringWCalls) {  			reader.BaseStream.Position = addr;  			reader.BaseStream.Position -= 2;  			if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 7;  			if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 2;  			if (reader.ReadByte () != 0x50)// push eax  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 6;  			if (reader.ReadByte () != 0x68)// push dword  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			int idx = reader.ReadInt32 ();  			if (idx > ms_nSize - 1)  				GetStringWFail.Add (addr);  			else  				GetStringW.Add (addr' idx);  		}  		List<int> GetBSTRFail = new List<int> ();  		foreach (int addr in GetBSTRCalls) {  			reader.BaseStream.Position = addr;  			reader.BaseStream.Position -= 2;  			if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 7;  			if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 2;  			if (reader.ReadByte () != 0x50)// push eax  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 6;  			if (reader.ReadByte () != 0x68)// push dword  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			int idx = reader.ReadInt32 ();  			if (idx > ms_nSize - 1)  				GetBSTRFail.Add (addr);  			else  				GetBSTR.Add (addr' idx);  		}  		Status ("Failed to find index of {0} references"' GetStringFail.Count + GetStringWFail.Count + GetBSTRFail.Count);  	}  	Status ("Successfully found index of {0} references"' GetString.Count + GetBSTR.Count + GetStringW.Count);  	Status ("Decoding strings");  	for (int index = 0; index < ms_nSize; ++index)  		if (index != -1 && index <= 0xffff)  			Strings.Add (index' StringPoolDecode (index));  	Status ("Populating table");  	foreach (var s in Strings)  		MainForm.Invoke (() => MainForm.dataTable.Rows.Add (s.Key' s.Value' string.Empty));  	foreach (var a in GetString)  		MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetString")));  	foreach (var a in GetBSTR)  		MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetBSTR")));  	foreach (var a in GetStringW)  		MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetStringW")));  }  else if (StringDecodeMethod == 1)// StringDecoder   {  	MainForm.Invoke (() => MainForm.Text += " [StringDecoder]");  	int type = 0;  	int name = 0;  	int offset = 0;  	//search for CStringDecoder::DelayedLoad' which contains the resource type and name  	if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00'  		0x89'  		0x45'  		0xF4'  		0x6A'  		0xAA'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x8B'  		0x4D'  		0xF4'  		0x51'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 12;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 1;  		name = reader.ReadInt32 ();  	}  	else if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00'  		0x6A'  		0xAA'  		0x8B'  		0xF8'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x57'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 9;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 3;  		name = reader.ReadInt32 ();  	}  	else if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0xAA'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 1;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 1;  		name = reader.ReadInt32 ();  	}  	else  		throw new Exception ("Failed to determine type and name of resource.");  	//search for start of function CStringDecoder::DelayedLoad()  	reader.BaseStream.Position -= 50;  	// should be enough  	FindAoBInFile (reader' (int)reader.BaseStream.Position' new byte[] {  		0x55'  		0x8B'  		0xEC'  		0x83'  		0xEC'  		0x10  	});  	int offset_CStringDecoder__DelayedLoad = (int)reader.BaseStream.Position;  	for (reader.BaseStream.Position = 0; reader.BaseStream.Position < reader.BaseStream.Length;) {  		if (reader.ReadByte () != 0xE8)  			// call  			continue;  		int offse = reader.ReadInt32 ();  		if (reader.BaseStream.Position + offse == offset_CStringDecoder__DelayedLoad) {  			Status ("{0:X8} reference to offset_CStringDecoder__DelayedLoad = {1:X8}"' reader.BaseStream.Position - 5' offse);  			break;  		}  	}  	ImageResourceDirectory tier1 = (ImageResourceDirectory)root.GetEntry (type).Entry;  	ImageResourceDirectory tier2 = (ImageResourceDirectory)tier1.GetEntry (name).Entry;  	rsrcStringDataEntry = (ImageResourceDataEntry)tier2.Entrys [0].Entry;  	rsrcStringDataPosition = rsrcPointerToRawData + (rsrcStringDataEntry.OffsetToData - rsrcVirtualAddress);  	m_nCount = GetWordFromIndex (0);  	Status ("Amount of strings: {0}"' m_nCount);  	for (int i = 1; i < m_nCount; ++i)  		MainForm.Invoke (() => MainForm.dataTable.Rows.Add (i' StringDecoderDecode (i)' string.Format ("{0:X8}"' rsrcStringDataPosition + i * 4)));  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: if (StringDecodeMethod == 0)// StringPool   {  	MainForm.Invoke (() => MainForm.Text += " [StringPool]");  	int offset_StringPool__ms_aKey = (int)reader.BaseStream.Position;  	Status ("StringPool::ms_aKey located at {0:X8}"' offset_StringPool__ms_aKey);  	int keyRef = 0;  	// Only GetString references ms_aKey  	byte[] bytes = new byte[5];  	bytes [0] = 0x68;  	// push offset  	Buffer.BlockCopy (BitConverter.GetBytes (ImageBase + offset_StringPool__ms_aKey)' 0' bytes' 1' 4);  	if (FindAoBInFile (reader' 0' bytes))  		keyRef = (int)reader.BaseStream.Position;  	reader.BaseStream.Position = keyRef;  	while (true) {  		byte[] asdf = reader.ReadBytes (5);  		if (asdf [4] == 0xc3)// retn  		 {  			bool die = true;  			foreach (byte b in asdf)  				if (b == 0xe8)// call  				 {  					die = false;  					break;  				}  			if (die)  				break;  		}  		reader.BaseStream.Position -= 6;  	}  	while (reader.ReadByte () == 0xcc)  		;  	// allign  	reader.BaseStream.Position -= 1;  	int offset_StringPool__GetString_uint_char = (int)reader.BaseStream.Position;  	Status ("StringPool::GetString(uint' char) located at {0:X8}"' offset_StringPool__GetString_uint_char);  	//search for StringPool::offset_ms_aString  	if (FindAoBInFile (reader' keyRef - 100' new byte[] {  		0x8b'  		0x0c  	}' 100))  		reader.BaseStream.Position += 3;  	else if (FindAoBInFile (reader' keyRef - 100' new byte[] {  		0x8b'  		0x86  	}' 100))  		reader.BaseStream.Position += 2;  	else  		throw new Exception ("could not find start of StringPool::offset_ms_aString");  	offset_StringPool__ms_aString = reader.ReadInt32 () - ImageBase;  	Status ("StringPool::ms_aString located at {0:X8}"' offset_StringPool__ms_aString);  	//search for xrefs to function StringPool::GetString(uint' char)   	int[] xref = FindCalls (offset_StringPool__GetString_uint_char' 2);  	if (xref.Length != 2)  		throw new Exception ("failed to find references to StringPool::GetString(uint' char)");  	//search for start of StringPool::GetString(uint)  	if (!FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x51'  		0x8b  	}' 50) && !FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x55'  		0x8b  	}' 50))  		throw new Exception ("could not find start of GetString(uint)");  	int offset_StringPool__GetString_uint = (int)reader.BaseStream.Position;  	Status ("StringPool::GetString(uint) located at {0:X8}"' offset_StringPool__GetString_uint);  	//search for start of StringPool::GetString(uint' ushort)  	for (reader.BaseStream.Position = xref [1]; (reader.ReadUInt32 () & 0xffffff00) != 0x000cc200; reader.BaseStream.Position -= 5)  		;  	//seek the start of function StringPool::GetString(uint' char)  	while (reader.ReadByte () == 0xcc)  		;  	// allign  	reader.BaseStream.Position -= 1;  	int offset_StringPool__GetString_uint_ushort = (int)reader.BaseStream.Position;  	Status ("StringPool::GetString(uint' ushort) located at {0:X8}"' offset_StringPool__GetString_uint_ushort);  	//search for xrefs to function StringPool::GetString(uint)  	xref = FindCalls (offset_StringPool__GetString_uint' 1);  	if (xref.Length != 1)  		throw new Exception ("failed to find references to StringPool::GetString(uint)");  	//search for start of function StringPool::GetBSTR(uint)  	reader.BaseStream.Position -= 100;  	// should be enough  	if (!FindAoBInFile (reader' (int)reader.BaseStream.Position' new byte[] {  		0xb8'  		0xaa'  		0xaa'  		0xaa'  		0x00  	}))  		for (reader.BaseStream.Position = xref [0]; (reader.ReadUInt32 () & 0xff00ff00) != 0x0000c200; reader.BaseStream.Position -= 5)  			;  	//seek the start of function StringPool::GetString(uint' char)  	while (reader.ReadByte () == 0xcc)  		;  	// allign  	reader.BaseStream.Position -= 1;  	int offset_StringPool__GetBSTR_uint = (int)reader.BaseStream.Position;  	Status ("StringPool::GetBSTR(uint) located at {0:X8}"' offset_StringPool__GetBSTR_uint);  	//search for xrefs to function StringPool::GetString(uint' ushort)  	xref = FindCalls (offset_StringPool__GetString_uint_ushort' 1);  	if (xref.Length != 1)  		throw new Exception ("failed to find references to StringPool::GetString(uint' ushort)");  	//search for start of function StringPool::GetStringW(uint)  	if (!FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x51'  		0x8b  	}' 50) && !FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x55'  		0x8b  	}' 50))  		throw new Exception ("could not find start of GetStringW(uint)");  	int offset_StringPool__GetStringW_uint = (int)reader.BaseStream.Position;  	Status ("StringPool::GetStringW(uint) located at {0:X8}"' offset_StringPool__GetStringW_uint);  	ms_nSize = GetIntFromOffset (offset_StringPool__ms_aKey + 16 + 4);  	Status ("Amount of strings: {0}"' ms_nSize);  	if (MessageBox.Show ("Scan for references to strings in the client? This can take a while."' "Warning"' MessageBoxButtons.YesNo' MessageBoxIcon.Warning) == DialogResult.Yes) {  		Status ("Searching for references to GetString' GetStringW' and GetBSTR");  		List<int> GetStringCalls = new List<int> ();  		List<int> GetStringWCalls = new List<int> ();  		List<int> GetBSTRCalls = new List<int> ();  		for (reader.BaseStream.Position = 0; reader.BaseStream.Position < reader.BaseStream.Length;) {  			//int lol = (int)((float)reader.BaseStream.Position / reader.BaseStream.Length * 100);  			//if (lol > MainForm.toolStripProgressBar1.Value)  			//{  			//    MainForm.Invoke(() => MainForm.toolStripProgressBar1.Value = lol);  			//    MainForm.Invoke(() => MainForm.Update());  			//} too expensive  			if (reader.ReadByte () != 0xE8)  				// call  				continue;  			int offset = reader.ReadInt32 ();  			if (reader.BaseStream.Position + offset == offset_StringPool__GetString_uint)  				GetStringCalls.Add ((int)reader.BaseStream.Position - 5);  			else if (reader.BaseStream.Position + offset == offset_StringPool__GetStringW_uint)  				GetStringWCalls.Add ((int)reader.BaseStream.Position - 5);  			else if (reader.BaseStream.Position + offset == offset_StringPool__GetBSTR_uint)  				GetBSTRCalls.Add ((int)reader.BaseStream.Position - 5);  			else  				reader.BaseStream.Position -= 4;  		}  		List<int> GetStringFail = new List<int> ();  		foreach (int addr in GetStringCalls) {  			reader.BaseStream.Position = addr;  			reader.BaseStream.Position -= 2;  			if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  			 {  				GetStringFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 7;  			if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  			 {  				GetStringFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 2;  			if (reader.ReadByte () != 0x50)// push eax  			 {  				GetStringFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 6;  			if (reader.ReadByte () != 0x68)// push dword  			 {  				GetStringFail.Add (addr);  				continue;  			}  			int idx = reader.ReadInt32 ();  			if (idx > ms_nSize - 1)  				GetStringFail.Add (addr);  			else  				GetString.Add (addr' idx);  		}  		List<int> GetStringWFail = new List<int> ();  		foreach (int addr in GetStringWCalls) {  			reader.BaseStream.Position = addr;  			reader.BaseStream.Position -= 2;  			if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 7;  			if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 2;  			if (reader.ReadByte () != 0x50)// push eax  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 6;  			if (reader.ReadByte () != 0x68)// push dword  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			int idx = reader.ReadInt32 ();  			if (idx > ms_nSize - 1)  				GetStringWFail.Add (addr);  			else  				GetStringW.Add (addr' idx);  		}  		List<int> GetBSTRFail = new List<int> ();  		foreach (int addr in GetBSTRCalls) {  			reader.BaseStream.Position = addr;  			reader.BaseStream.Position -= 2;  			if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 7;  			if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 2;  			if (reader.ReadByte () != 0x50)// push eax  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 6;  			if (reader.ReadByte () != 0x68)// push dword  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			int idx = reader.ReadInt32 ();  			if (idx > ms_nSize - 1)  				GetBSTRFail.Add (addr);  			else  				GetBSTR.Add (addr' idx);  		}  		Status ("Failed to find index of {0} references"' GetStringFail.Count + GetStringWFail.Count + GetBSTRFail.Count);  	}  	Status ("Successfully found index of {0} references"' GetString.Count + GetBSTR.Count + GetStringW.Count);  	Status ("Decoding strings");  	for (int index = 0; index < ms_nSize; ++index)  		if (index != -1 && index <= 0xffff)  			Strings.Add (index' StringPoolDecode (index));  	Status ("Populating table");  	foreach (var s in Strings)  		MainForm.Invoke (() => MainForm.dataTable.Rows.Add (s.Key' s.Value' string.Empty));  	foreach (var a in GetString)  		MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetString")));  	foreach (var a in GetBSTR)  		MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetBSTR")));  	foreach (var a in GetStringW)  		MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetStringW")));  }  else if (StringDecodeMethod == 1)// StringDecoder   {  	MainForm.Invoke (() => MainForm.Text += " [StringDecoder]");  	int type = 0;  	int name = 0;  	int offset = 0;  	//search for CStringDecoder::DelayedLoad' which contains the resource type and name  	if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00'  		0x89'  		0x45'  		0xF4'  		0x6A'  		0xAA'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x8B'  		0x4D'  		0xF4'  		0x51'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 12;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 1;  		name = reader.ReadInt32 ();  	}  	else if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00'  		0x6A'  		0xAA'  		0x8B'  		0xF8'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x57'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 9;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 3;  		name = reader.ReadInt32 ();  	}  	else if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0xAA'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 1;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 1;  		name = reader.ReadInt32 ();  	}  	else  		throw new Exception ("Failed to determine type and name of resource.");  	//search for start of function CStringDecoder::DelayedLoad()  	reader.BaseStream.Position -= 50;  	// should be enough  	FindAoBInFile (reader' (int)reader.BaseStream.Position' new byte[] {  		0x55'  		0x8B'  		0xEC'  		0x83'  		0xEC'  		0x10  	});  	int offset_CStringDecoder__DelayedLoad = (int)reader.BaseStream.Position;  	for (reader.BaseStream.Position = 0; reader.BaseStream.Position < reader.BaseStream.Length;) {  		if (reader.ReadByte () != 0xE8)  			// call  			continue;  		int offse = reader.ReadInt32 ();  		if (reader.BaseStream.Position + offse == offset_CStringDecoder__DelayedLoad) {  			Status ("{0:X8} reference to offset_CStringDecoder__DelayedLoad = {1:X8}"' reader.BaseStream.Position - 5' offse);  			break;  		}  	}  	ImageResourceDirectory tier1 = (ImageResourceDirectory)root.GetEntry (type).Entry;  	ImageResourceDirectory tier2 = (ImageResourceDirectory)tier1.GetEntry (name).Entry;  	rsrcStringDataEntry = (ImageResourceDataEntry)tier2.Entrys [0].Entry;  	rsrcStringDataPosition = rsrcPointerToRawData + (rsrcStringDataEntry.OffsetToData - rsrcVirtualAddress);  	m_nCount = GetWordFromIndex (0);  	Status ("Amount of strings: {0}"' m_nCount);  	for (int i = 1; i < m_nCount; ++i)  		MainForm.Invoke (() => MainForm.dataTable.Rows.Add (i' StringDecoderDecode (i)' string.Format ("{0:X8}"' rsrcStringDataPosition + i * 4)));  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: if (StringDecodeMethod == 0)// StringPool   {  	MainForm.Invoke (() => MainForm.Text += " [StringPool]");  	int offset_StringPool__ms_aKey = (int)reader.BaseStream.Position;  	Status ("StringPool::ms_aKey located at {0:X8}"' offset_StringPool__ms_aKey);  	int keyRef = 0;  	// Only GetString references ms_aKey  	byte[] bytes = new byte[5];  	bytes [0] = 0x68;  	// push offset  	Buffer.BlockCopy (BitConverter.GetBytes (ImageBase + offset_StringPool__ms_aKey)' 0' bytes' 1' 4);  	if (FindAoBInFile (reader' 0' bytes))  		keyRef = (int)reader.BaseStream.Position;  	reader.BaseStream.Position = keyRef;  	while (true) {  		byte[] asdf = reader.ReadBytes (5);  		if (asdf [4] == 0xc3)// retn  		 {  			bool die = true;  			foreach (byte b in asdf)  				if (b == 0xe8)// call  				 {  					die = false;  					break;  				}  			if (die)  				break;  		}  		reader.BaseStream.Position -= 6;  	}  	while (reader.ReadByte () == 0xcc)  		;  	// allign  	reader.BaseStream.Position -= 1;  	int offset_StringPool__GetString_uint_char = (int)reader.BaseStream.Position;  	Status ("StringPool::GetString(uint' char) located at {0:X8}"' offset_StringPool__GetString_uint_char);  	//search for StringPool::offset_ms_aString  	if (FindAoBInFile (reader' keyRef - 100' new byte[] {  		0x8b'  		0x0c  	}' 100))  		reader.BaseStream.Position += 3;  	else if (FindAoBInFile (reader' keyRef - 100' new byte[] {  		0x8b'  		0x86  	}' 100))  		reader.BaseStream.Position += 2;  	else  		throw new Exception ("could not find start of StringPool::offset_ms_aString");  	offset_StringPool__ms_aString = reader.ReadInt32 () - ImageBase;  	Status ("StringPool::ms_aString located at {0:X8}"' offset_StringPool__ms_aString);  	//search for xrefs to function StringPool::GetString(uint' char)   	int[] xref = FindCalls (offset_StringPool__GetString_uint_char' 2);  	if (xref.Length != 2)  		throw new Exception ("failed to find references to StringPool::GetString(uint' char)");  	//search for start of StringPool::GetString(uint)  	if (!FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x51'  		0x8b  	}' 50) && !FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x55'  		0x8b  	}' 50))  		throw new Exception ("could not find start of GetString(uint)");  	int offset_StringPool__GetString_uint = (int)reader.BaseStream.Position;  	Status ("StringPool::GetString(uint) located at {0:X8}"' offset_StringPool__GetString_uint);  	//search for start of StringPool::GetString(uint' ushort)  	for (reader.BaseStream.Position = xref [1]; (reader.ReadUInt32 () & 0xffffff00) != 0x000cc200; reader.BaseStream.Position -= 5)  		;  	//seek the start of function StringPool::GetString(uint' char)  	while (reader.ReadByte () == 0xcc)  		;  	// allign  	reader.BaseStream.Position -= 1;  	int offset_StringPool__GetString_uint_ushort = (int)reader.BaseStream.Position;  	Status ("StringPool::GetString(uint' ushort) located at {0:X8}"' offset_StringPool__GetString_uint_ushort);  	//search for xrefs to function StringPool::GetString(uint)  	xref = FindCalls (offset_StringPool__GetString_uint' 1);  	if (xref.Length != 1)  		throw new Exception ("failed to find references to StringPool::GetString(uint)");  	//search for start of function StringPool::GetBSTR(uint)  	reader.BaseStream.Position -= 100;  	// should be enough  	if (!FindAoBInFile (reader' (int)reader.BaseStream.Position' new byte[] {  		0xb8'  		0xaa'  		0xaa'  		0xaa'  		0x00  	}))  		for (reader.BaseStream.Position = xref [0]; (reader.ReadUInt32 () & 0xff00ff00) != 0x0000c200; reader.BaseStream.Position -= 5)  			;  	//seek the start of function StringPool::GetString(uint' char)  	while (reader.ReadByte () == 0xcc)  		;  	// allign  	reader.BaseStream.Position -= 1;  	int offset_StringPool__GetBSTR_uint = (int)reader.BaseStream.Position;  	Status ("StringPool::GetBSTR(uint) located at {0:X8}"' offset_StringPool__GetBSTR_uint);  	//search for xrefs to function StringPool::GetString(uint' ushort)  	xref = FindCalls (offset_StringPool__GetString_uint_ushort' 1);  	if (xref.Length != 1)  		throw new Exception ("failed to find references to StringPool::GetString(uint' ushort)");  	//search for start of function StringPool::GetStringW(uint)  	if (!FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x51'  		0x8b  	}' 50) && !FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x55'  		0x8b  	}' 50))  		throw new Exception ("could not find start of GetStringW(uint)");  	int offset_StringPool__GetStringW_uint = (int)reader.BaseStream.Position;  	Status ("StringPool::GetStringW(uint) located at {0:X8}"' offset_StringPool__GetStringW_uint);  	ms_nSize = GetIntFromOffset (offset_StringPool__ms_aKey + 16 + 4);  	Status ("Amount of strings: {0}"' ms_nSize);  	if (MessageBox.Show ("Scan for references to strings in the client? This can take a while."' "Warning"' MessageBoxButtons.YesNo' MessageBoxIcon.Warning) == DialogResult.Yes) {  		Status ("Searching for references to GetString' GetStringW' and GetBSTR");  		List<int> GetStringCalls = new List<int> ();  		List<int> GetStringWCalls = new List<int> ();  		List<int> GetBSTRCalls = new List<int> ();  		for (reader.BaseStream.Position = 0; reader.BaseStream.Position < reader.BaseStream.Length;) {  			//int lol = (int)((float)reader.BaseStream.Position / reader.BaseStream.Length * 100);  			//if (lol > MainForm.toolStripProgressBar1.Value)  			//{  			//    MainForm.Invoke(() => MainForm.toolStripProgressBar1.Value = lol);  			//    MainForm.Invoke(() => MainForm.Update());  			//} too expensive  			if (reader.ReadByte () != 0xE8)  				// call  				continue;  			int offset = reader.ReadInt32 ();  			if (reader.BaseStream.Position + offset == offset_StringPool__GetString_uint)  				GetStringCalls.Add ((int)reader.BaseStream.Position - 5);  			else if (reader.BaseStream.Position + offset == offset_StringPool__GetStringW_uint)  				GetStringWCalls.Add ((int)reader.BaseStream.Position - 5);  			else if (reader.BaseStream.Position + offset == offset_StringPool__GetBSTR_uint)  				GetBSTRCalls.Add ((int)reader.BaseStream.Position - 5);  			else  				reader.BaseStream.Position -= 4;  		}  		List<int> GetStringFail = new List<int> ();  		foreach (int addr in GetStringCalls) {  			reader.BaseStream.Position = addr;  			reader.BaseStream.Position -= 2;  			if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  			 {  				GetStringFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 7;  			if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  			 {  				GetStringFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 2;  			if (reader.ReadByte () != 0x50)// push eax  			 {  				GetStringFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 6;  			if (reader.ReadByte () != 0x68)// push dword  			 {  				GetStringFail.Add (addr);  				continue;  			}  			int idx = reader.ReadInt32 ();  			if (idx > ms_nSize - 1)  				GetStringFail.Add (addr);  			else  				GetString.Add (addr' idx);  		}  		List<int> GetStringWFail = new List<int> ();  		foreach (int addr in GetStringWCalls) {  			reader.BaseStream.Position = addr;  			reader.BaseStream.Position -= 2;  			if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 7;  			if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 2;  			if (reader.ReadByte () != 0x50)// push eax  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 6;  			if (reader.ReadByte () != 0x68)// push dword  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			int idx = reader.ReadInt32 ();  			if (idx > ms_nSize - 1)  				GetStringWFail.Add (addr);  			else  				GetStringW.Add (addr' idx);  		}  		List<int> GetBSTRFail = new List<int> ();  		foreach (int addr in GetBSTRCalls) {  			reader.BaseStream.Position = addr;  			reader.BaseStream.Position -= 2;  			if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 7;  			if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 2;  			if (reader.ReadByte () != 0x50)// push eax  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 6;  			if (reader.ReadByte () != 0x68)// push dword  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			int idx = reader.ReadInt32 ();  			if (idx > ms_nSize - 1)  				GetBSTRFail.Add (addr);  			else  				GetBSTR.Add (addr' idx);  		}  		Status ("Failed to find index of {0} references"' GetStringFail.Count + GetStringWFail.Count + GetBSTRFail.Count);  	}  	Status ("Successfully found index of {0} references"' GetString.Count + GetBSTR.Count + GetStringW.Count);  	Status ("Decoding strings");  	for (int index = 0; index < ms_nSize; ++index)  		if (index != -1 && index <= 0xffff)  			Strings.Add (index' StringPoolDecode (index));  	Status ("Populating table");  	foreach (var s in Strings)  		MainForm.Invoke (() => MainForm.dataTable.Rows.Add (s.Key' s.Value' string.Empty));  	foreach (var a in GetString)  		MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetString")));  	foreach (var a in GetBSTR)  		MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetBSTR")));  	foreach (var a in GetStringW)  		MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetStringW")));  }  else if (StringDecodeMethod == 1)// StringDecoder   {  	MainForm.Invoke (() => MainForm.Text += " [StringDecoder]");  	int type = 0;  	int name = 0;  	int offset = 0;  	//search for CStringDecoder::DelayedLoad' which contains the resource type and name  	if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00'  		0x89'  		0x45'  		0xF4'  		0x6A'  		0xAA'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x8B'  		0x4D'  		0xF4'  		0x51'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 12;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 1;  		name = reader.ReadInt32 ();  	}  	else if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00'  		0x6A'  		0xAA'  		0x8B'  		0xF8'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x57'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 9;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 3;  		name = reader.ReadInt32 ();  	}  	else if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0xAA'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 1;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 1;  		name = reader.ReadInt32 ();  	}  	else  		throw new Exception ("Failed to determine type and name of resource.");  	//search for start of function CStringDecoder::DelayedLoad()  	reader.BaseStream.Position -= 50;  	// should be enough  	FindAoBInFile (reader' (int)reader.BaseStream.Position' new byte[] {  		0x55'  		0x8B'  		0xEC'  		0x83'  		0xEC'  		0x10  	});  	int offset_CStringDecoder__DelayedLoad = (int)reader.BaseStream.Position;  	for (reader.BaseStream.Position = 0; reader.BaseStream.Position < reader.BaseStream.Length;) {  		if (reader.ReadByte () != 0xE8)  			// call  			continue;  		int offse = reader.ReadInt32 ();  		if (reader.BaseStream.Position + offse == offset_CStringDecoder__DelayedLoad) {  			Status ("{0:X8} reference to offset_CStringDecoder__DelayedLoad = {1:X8}"' reader.BaseStream.Position - 5' offse);  			break;  		}  	}  	ImageResourceDirectory tier1 = (ImageResourceDirectory)root.GetEntry (type).Entry;  	ImageResourceDirectory tier2 = (ImageResourceDirectory)tier1.GetEntry (name).Entry;  	rsrcStringDataEntry = (ImageResourceDataEntry)tier2.Entrys [0].Entry;  	rsrcStringDataPosition = rsrcPointerToRawData + (rsrcStringDataEntry.OffsetToData - rsrcVirtualAddress);  	m_nCount = GetWordFromIndex (0);  	Status ("Amount of strings: {0}"' m_nCount);  	for (int i = 1; i < m_nCount; ++i)  		MainForm.Invoke (() => MainForm.dataTable.Rows.Add (i' StringDecoderDecode (i)' string.Format ("{0:X8}"' rsrcStringDataPosition + i * 4)));  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: if (StringDecodeMethod == 0)// StringPool   {  	MainForm.Invoke (() => MainForm.Text += " [StringPool]");  	int offset_StringPool__ms_aKey = (int)reader.BaseStream.Position;  	Status ("StringPool::ms_aKey located at {0:X8}"' offset_StringPool__ms_aKey);  	int keyRef = 0;  	// Only GetString references ms_aKey  	byte[] bytes = new byte[5];  	bytes [0] = 0x68;  	// push offset  	Buffer.BlockCopy (BitConverter.GetBytes (ImageBase + offset_StringPool__ms_aKey)' 0' bytes' 1' 4);  	if (FindAoBInFile (reader' 0' bytes))  		keyRef = (int)reader.BaseStream.Position;  	reader.BaseStream.Position = keyRef;  	while (true) {  		byte[] asdf = reader.ReadBytes (5);  		if (asdf [4] == 0xc3)// retn  		 {  			bool die = true;  			foreach (byte b in asdf)  				if (b == 0xe8)// call  				 {  					die = false;  					break;  				}  			if (die)  				break;  		}  		reader.BaseStream.Position -= 6;  	}  	while (reader.ReadByte () == 0xcc)  		;  	// allign  	reader.BaseStream.Position -= 1;  	int offset_StringPool__GetString_uint_char = (int)reader.BaseStream.Position;  	Status ("StringPool::GetString(uint' char) located at {0:X8}"' offset_StringPool__GetString_uint_char);  	//search for StringPool::offset_ms_aString  	if (FindAoBInFile (reader' keyRef - 100' new byte[] {  		0x8b'  		0x0c  	}' 100))  		reader.BaseStream.Position += 3;  	else if (FindAoBInFile (reader' keyRef - 100' new byte[] {  		0x8b'  		0x86  	}' 100))  		reader.BaseStream.Position += 2;  	else  		throw new Exception ("could not find start of StringPool::offset_ms_aString");  	offset_StringPool__ms_aString = reader.ReadInt32 () - ImageBase;  	Status ("StringPool::ms_aString located at {0:X8}"' offset_StringPool__ms_aString);  	//search for xrefs to function StringPool::GetString(uint' char)   	int[] xref = FindCalls (offset_StringPool__GetString_uint_char' 2);  	if (xref.Length != 2)  		throw new Exception ("failed to find references to StringPool::GetString(uint' char)");  	//search for start of StringPool::GetString(uint)  	if (!FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x51'  		0x8b  	}' 50) && !FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x55'  		0x8b  	}' 50))  		throw new Exception ("could not find start of GetString(uint)");  	int offset_StringPool__GetString_uint = (int)reader.BaseStream.Position;  	Status ("StringPool::GetString(uint) located at {0:X8}"' offset_StringPool__GetString_uint);  	//search for start of StringPool::GetString(uint' ushort)  	for (reader.BaseStream.Position = xref [1]; (reader.ReadUInt32 () & 0xffffff00) != 0x000cc200; reader.BaseStream.Position -= 5)  		;  	//seek the start of function StringPool::GetString(uint' char)  	while (reader.ReadByte () == 0xcc)  		;  	// allign  	reader.BaseStream.Position -= 1;  	int offset_StringPool__GetString_uint_ushort = (int)reader.BaseStream.Position;  	Status ("StringPool::GetString(uint' ushort) located at {0:X8}"' offset_StringPool__GetString_uint_ushort);  	//search for xrefs to function StringPool::GetString(uint)  	xref = FindCalls (offset_StringPool__GetString_uint' 1);  	if (xref.Length != 1)  		throw new Exception ("failed to find references to StringPool::GetString(uint)");  	//search for start of function StringPool::GetBSTR(uint)  	reader.BaseStream.Position -= 100;  	// should be enough  	if (!FindAoBInFile (reader' (int)reader.BaseStream.Position' new byte[] {  		0xb8'  		0xaa'  		0xaa'  		0xaa'  		0x00  	}))  		for (reader.BaseStream.Position = xref [0]; (reader.ReadUInt32 () & 0xff00ff00) != 0x0000c200; reader.BaseStream.Position -= 5)  			;  	//seek the start of function StringPool::GetString(uint' char)  	while (reader.ReadByte () == 0xcc)  		;  	// allign  	reader.BaseStream.Position -= 1;  	int offset_StringPool__GetBSTR_uint = (int)reader.BaseStream.Position;  	Status ("StringPool::GetBSTR(uint) located at {0:X8}"' offset_StringPool__GetBSTR_uint);  	//search for xrefs to function StringPool::GetString(uint' ushort)  	xref = FindCalls (offset_StringPool__GetString_uint_ushort' 1);  	if (xref.Length != 1)  		throw new Exception ("failed to find references to StringPool::GetString(uint' ushort)");  	//search for start of function StringPool::GetStringW(uint)  	if (!FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x51'  		0x8b  	}' 50) && !FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x55'  		0x8b  	}' 50))  		throw new Exception ("could not find start of GetStringW(uint)");  	int offset_StringPool__GetStringW_uint = (int)reader.BaseStream.Position;  	Status ("StringPool::GetStringW(uint) located at {0:X8}"' offset_StringPool__GetStringW_uint);  	ms_nSize = GetIntFromOffset (offset_StringPool__ms_aKey + 16 + 4);  	Status ("Amount of strings: {0}"' ms_nSize);  	if (MessageBox.Show ("Scan for references to strings in the client? This can take a while."' "Warning"' MessageBoxButtons.YesNo' MessageBoxIcon.Warning) == DialogResult.Yes) {  		Status ("Searching for references to GetString' GetStringW' and GetBSTR");  		List<int> GetStringCalls = new List<int> ();  		List<int> GetStringWCalls = new List<int> ();  		List<int> GetBSTRCalls = new List<int> ();  		for (reader.BaseStream.Position = 0; reader.BaseStream.Position < reader.BaseStream.Length;) {  			//int lol = (int)((float)reader.BaseStream.Position / reader.BaseStream.Length * 100);  			//if (lol > MainForm.toolStripProgressBar1.Value)  			//{  			//    MainForm.Invoke(() => MainForm.toolStripProgressBar1.Value = lol);  			//    MainForm.Invoke(() => MainForm.Update());  			//} too expensive  			if (reader.ReadByte () != 0xE8)  				// call  				continue;  			int offset = reader.ReadInt32 ();  			if (reader.BaseStream.Position + offset == offset_StringPool__GetString_uint)  				GetStringCalls.Add ((int)reader.BaseStream.Position - 5);  			else if (reader.BaseStream.Position + offset == offset_StringPool__GetStringW_uint)  				GetStringWCalls.Add ((int)reader.BaseStream.Position - 5);  			else if (reader.BaseStream.Position + offset == offset_StringPool__GetBSTR_uint)  				GetBSTRCalls.Add ((int)reader.BaseStream.Position - 5);  			else  				reader.BaseStream.Position -= 4;  		}  		List<int> GetStringFail = new List<int> ();  		foreach (int addr in GetStringCalls) {  			reader.BaseStream.Position = addr;  			reader.BaseStream.Position -= 2;  			if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  			 {  				GetStringFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 7;  			if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  			 {  				GetStringFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 2;  			if (reader.ReadByte () != 0x50)// push eax  			 {  				GetStringFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 6;  			if (reader.ReadByte () != 0x68)// push dword  			 {  				GetStringFail.Add (addr);  				continue;  			}  			int idx = reader.ReadInt32 ();  			if (idx > ms_nSize - 1)  				GetStringFail.Add (addr);  			else  				GetString.Add (addr' idx);  		}  		List<int> GetStringWFail = new List<int> ();  		foreach (int addr in GetStringWCalls) {  			reader.BaseStream.Position = addr;  			reader.BaseStream.Position -= 2;  			if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 7;  			if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 2;  			if (reader.ReadByte () != 0x50)// push eax  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 6;  			if (reader.ReadByte () != 0x68)// push dword  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			int idx = reader.ReadInt32 ();  			if (idx > ms_nSize - 1)  				GetStringWFail.Add (addr);  			else  				GetStringW.Add (addr' idx);  		}  		List<int> GetBSTRFail = new List<int> ();  		foreach (int addr in GetBSTRCalls) {  			reader.BaseStream.Position = addr;  			reader.BaseStream.Position -= 2;  			if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 7;  			if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 2;  			if (reader.ReadByte () != 0x50)// push eax  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 6;  			if (reader.ReadByte () != 0x68)// push dword  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			int idx = reader.ReadInt32 ();  			if (idx > ms_nSize - 1)  				GetBSTRFail.Add (addr);  			else  				GetBSTR.Add (addr' idx);  		}  		Status ("Failed to find index of {0} references"' GetStringFail.Count + GetStringWFail.Count + GetBSTRFail.Count);  	}  	Status ("Successfully found index of {0} references"' GetString.Count + GetBSTR.Count + GetStringW.Count);  	Status ("Decoding strings");  	for (int index = 0; index < ms_nSize; ++index)  		if (index != -1 && index <= 0xffff)  			Strings.Add (index' StringPoolDecode (index));  	Status ("Populating table");  	foreach (var s in Strings)  		MainForm.Invoke (() => MainForm.dataTable.Rows.Add (s.Key' s.Value' string.Empty));  	foreach (var a in GetString)  		MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetString")));  	foreach (var a in GetBSTR)  		MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetBSTR")));  	foreach (var a in GetStringW)  		MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetStringW")));  }  else if (StringDecodeMethod == 1)// StringDecoder   {  	MainForm.Invoke (() => MainForm.Text += " [StringDecoder]");  	int type = 0;  	int name = 0;  	int offset = 0;  	//search for CStringDecoder::DelayedLoad' which contains the resource type and name  	if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00'  		0x89'  		0x45'  		0xF4'  		0x6A'  		0xAA'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x8B'  		0x4D'  		0xF4'  		0x51'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 12;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 1;  		name = reader.ReadInt32 ();  	}  	else if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00'  		0x6A'  		0xAA'  		0x8B'  		0xF8'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x57'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 9;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 3;  		name = reader.ReadInt32 ();  	}  	else if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0xAA'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 1;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 1;  		name = reader.ReadInt32 ();  	}  	else  		throw new Exception ("Failed to determine type and name of resource.");  	//search for start of function CStringDecoder::DelayedLoad()  	reader.BaseStream.Position -= 50;  	// should be enough  	FindAoBInFile (reader' (int)reader.BaseStream.Position' new byte[] {  		0x55'  		0x8B'  		0xEC'  		0x83'  		0xEC'  		0x10  	});  	int offset_CStringDecoder__DelayedLoad = (int)reader.BaseStream.Position;  	for (reader.BaseStream.Position = 0; reader.BaseStream.Position < reader.BaseStream.Length;) {  		if (reader.ReadByte () != 0xE8)  			// call  			continue;  		int offse = reader.ReadInt32 ();  		if (reader.BaseStream.Position + offse == offset_CStringDecoder__DelayedLoad) {  			Status ("{0:X8} reference to offset_CStringDecoder__DelayedLoad = {1:X8}"' reader.BaseStream.Position - 5' offse);  			break;  		}  	}  	ImageResourceDirectory tier1 = (ImageResourceDirectory)root.GetEntry (type).Entry;  	ImageResourceDirectory tier2 = (ImageResourceDirectory)tier1.GetEntry (name).Entry;  	rsrcStringDataEntry = (ImageResourceDataEntry)tier2.Entrys [0].Entry;  	rsrcStringDataPosition = rsrcPointerToRawData + (rsrcStringDataEntry.OffsetToData - rsrcVirtualAddress);  	m_nCount = GetWordFromIndex (0);  	Status ("Amount of strings: {0}"' m_nCount);  	for (int i = 1; i < m_nCount; ++i)  		MainForm.Invoke (() => MainForm.dataTable.Rows.Add (i' StringDecoderDecode (i)' string.Format ("{0:X8}"' rsrcStringDataPosition + i * 4)));  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: if (StringDecodeMethod == 0)// StringPool   {  	MainForm.Invoke (() => MainForm.Text += " [StringPool]");  	int offset_StringPool__ms_aKey = (int)reader.BaseStream.Position;  	Status ("StringPool::ms_aKey located at {0:X8}"' offset_StringPool__ms_aKey);  	int keyRef = 0;  	// Only GetString references ms_aKey  	byte[] bytes = new byte[5];  	bytes [0] = 0x68;  	// push offset  	Buffer.BlockCopy (BitConverter.GetBytes (ImageBase + offset_StringPool__ms_aKey)' 0' bytes' 1' 4);  	if (FindAoBInFile (reader' 0' bytes))  		keyRef = (int)reader.BaseStream.Position;  	reader.BaseStream.Position = keyRef;  	while (true) {  		byte[] asdf = reader.ReadBytes (5);  		if (asdf [4] == 0xc3)// retn  		 {  			bool die = true;  			foreach (byte b in asdf)  				if (b == 0xe8)// call  				 {  					die = false;  					break;  				}  			if (die)  				break;  		}  		reader.BaseStream.Position -= 6;  	}  	while (reader.ReadByte () == 0xcc)  		;  	// allign  	reader.BaseStream.Position -= 1;  	int offset_StringPool__GetString_uint_char = (int)reader.BaseStream.Position;  	Status ("StringPool::GetString(uint' char) located at {0:X8}"' offset_StringPool__GetString_uint_char);  	//search for StringPool::offset_ms_aString  	if (FindAoBInFile (reader' keyRef - 100' new byte[] {  		0x8b'  		0x0c  	}' 100))  		reader.BaseStream.Position += 3;  	else if (FindAoBInFile (reader' keyRef - 100' new byte[] {  		0x8b'  		0x86  	}' 100))  		reader.BaseStream.Position += 2;  	else  		throw new Exception ("could not find start of StringPool::offset_ms_aString");  	offset_StringPool__ms_aString = reader.ReadInt32 () - ImageBase;  	Status ("StringPool::ms_aString located at {0:X8}"' offset_StringPool__ms_aString);  	//search for xrefs to function StringPool::GetString(uint' char)   	int[] xref = FindCalls (offset_StringPool__GetString_uint_char' 2);  	if (xref.Length != 2)  		throw new Exception ("failed to find references to StringPool::GetString(uint' char)");  	//search for start of StringPool::GetString(uint)  	if (!FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x51'  		0x8b  	}' 50) && !FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x55'  		0x8b  	}' 50))  		throw new Exception ("could not find start of GetString(uint)");  	int offset_StringPool__GetString_uint = (int)reader.BaseStream.Position;  	Status ("StringPool::GetString(uint) located at {0:X8}"' offset_StringPool__GetString_uint);  	//search for start of StringPool::GetString(uint' ushort)  	for (reader.BaseStream.Position = xref [1]; (reader.ReadUInt32 () & 0xffffff00) != 0x000cc200; reader.BaseStream.Position -= 5)  		;  	//seek the start of function StringPool::GetString(uint' char)  	while (reader.ReadByte () == 0xcc)  		;  	// allign  	reader.BaseStream.Position -= 1;  	int offset_StringPool__GetString_uint_ushort = (int)reader.BaseStream.Position;  	Status ("StringPool::GetString(uint' ushort) located at {0:X8}"' offset_StringPool__GetString_uint_ushort);  	//search for xrefs to function StringPool::GetString(uint)  	xref = FindCalls (offset_StringPool__GetString_uint' 1);  	if (xref.Length != 1)  		throw new Exception ("failed to find references to StringPool::GetString(uint)");  	//search for start of function StringPool::GetBSTR(uint)  	reader.BaseStream.Position -= 100;  	// should be enough  	if (!FindAoBInFile (reader' (int)reader.BaseStream.Position' new byte[] {  		0xb8'  		0xaa'  		0xaa'  		0xaa'  		0x00  	}))  		for (reader.BaseStream.Position = xref [0]; (reader.ReadUInt32 () & 0xff00ff00) != 0x0000c200; reader.BaseStream.Position -= 5)  			;  	//seek the start of function StringPool::GetString(uint' char)  	while (reader.ReadByte () == 0xcc)  		;  	// allign  	reader.BaseStream.Position -= 1;  	int offset_StringPool__GetBSTR_uint = (int)reader.BaseStream.Position;  	Status ("StringPool::GetBSTR(uint) located at {0:X8}"' offset_StringPool__GetBSTR_uint);  	//search for xrefs to function StringPool::GetString(uint' ushort)  	xref = FindCalls (offset_StringPool__GetString_uint_ushort' 1);  	if (xref.Length != 1)  		throw new Exception ("failed to find references to StringPool::GetString(uint' ushort)");  	//search for start of function StringPool::GetStringW(uint)  	if (!FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x51'  		0x8b  	}' 50) && !FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x55'  		0x8b  	}' 50))  		throw new Exception ("could not find start of GetStringW(uint)");  	int offset_StringPool__GetStringW_uint = (int)reader.BaseStream.Position;  	Status ("StringPool::GetStringW(uint) located at {0:X8}"' offset_StringPool__GetStringW_uint);  	ms_nSize = GetIntFromOffset (offset_StringPool__ms_aKey + 16 + 4);  	Status ("Amount of strings: {0}"' ms_nSize);  	if (MessageBox.Show ("Scan for references to strings in the client? This can take a while."' "Warning"' MessageBoxButtons.YesNo' MessageBoxIcon.Warning) == DialogResult.Yes) {  		Status ("Searching for references to GetString' GetStringW' and GetBSTR");  		List<int> GetStringCalls = new List<int> ();  		List<int> GetStringWCalls = new List<int> ();  		List<int> GetBSTRCalls = new List<int> ();  		for (reader.BaseStream.Position = 0; reader.BaseStream.Position < reader.BaseStream.Length;) {  			//int lol = (int)((float)reader.BaseStream.Position / reader.BaseStream.Length * 100);  			//if (lol > MainForm.toolStripProgressBar1.Value)  			//{  			//    MainForm.Invoke(() => MainForm.toolStripProgressBar1.Value = lol);  			//    MainForm.Invoke(() => MainForm.Update());  			//} too expensive  			if (reader.ReadByte () != 0xE8)  				// call  				continue;  			int offset = reader.ReadInt32 ();  			if (reader.BaseStream.Position + offset == offset_StringPool__GetString_uint)  				GetStringCalls.Add ((int)reader.BaseStream.Position - 5);  			else if (reader.BaseStream.Position + offset == offset_StringPool__GetStringW_uint)  				GetStringWCalls.Add ((int)reader.BaseStream.Position - 5);  			else if (reader.BaseStream.Position + offset == offset_StringPool__GetBSTR_uint)  				GetBSTRCalls.Add ((int)reader.BaseStream.Position - 5);  			else  				reader.BaseStream.Position -= 4;  		}  		List<int> GetStringFail = new List<int> ();  		foreach (int addr in GetStringCalls) {  			reader.BaseStream.Position = addr;  			reader.BaseStream.Position -= 2;  			if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  			 {  				GetStringFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 7;  			if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  			 {  				GetStringFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 2;  			if (reader.ReadByte () != 0x50)// push eax  			 {  				GetStringFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 6;  			if (reader.ReadByte () != 0x68)// push dword  			 {  				GetStringFail.Add (addr);  				continue;  			}  			int idx = reader.ReadInt32 ();  			if (idx > ms_nSize - 1)  				GetStringFail.Add (addr);  			else  				GetString.Add (addr' idx);  		}  		List<int> GetStringWFail = new List<int> ();  		foreach (int addr in GetStringWCalls) {  			reader.BaseStream.Position = addr;  			reader.BaseStream.Position -= 2;  			if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 7;  			if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 2;  			if (reader.ReadByte () != 0x50)// push eax  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 6;  			if (reader.ReadByte () != 0x68)// push dword  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			int idx = reader.ReadInt32 ();  			if (idx > ms_nSize - 1)  				GetStringWFail.Add (addr);  			else  				GetStringW.Add (addr' idx);  		}  		List<int> GetBSTRFail = new List<int> ();  		foreach (int addr in GetBSTRCalls) {  			reader.BaseStream.Position = addr;  			reader.BaseStream.Position -= 2;  			if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 7;  			if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 2;  			if (reader.ReadByte () != 0x50)// push eax  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 6;  			if (reader.ReadByte () != 0x68)// push dword  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			int idx = reader.ReadInt32 ();  			if (idx > ms_nSize - 1)  				GetBSTRFail.Add (addr);  			else  				GetBSTR.Add (addr' idx);  		}  		Status ("Failed to find index of {0} references"' GetStringFail.Count + GetStringWFail.Count + GetBSTRFail.Count);  	}  	Status ("Successfully found index of {0} references"' GetString.Count + GetBSTR.Count + GetStringW.Count);  	Status ("Decoding strings");  	for (int index = 0; index < ms_nSize; ++index)  		if (index != -1 && index <= 0xffff)  			Strings.Add (index' StringPoolDecode (index));  	Status ("Populating table");  	foreach (var s in Strings)  		MainForm.Invoke (() => MainForm.dataTable.Rows.Add (s.Key' s.Value' string.Empty));  	foreach (var a in GetString)  		MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetString")));  	foreach (var a in GetBSTR)  		MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetBSTR")));  	foreach (var a in GetStringW)  		MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetStringW")));  }  else if (StringDecodeMethod == 1)// StringDecoder   {  	MainForm.Invoke (() => MainForm.Text += " [StringDecoder]");  	int type = 0;  	int name = 0;  	int offset = 0;  	//search for CStringDecoder::DelayedLoad' which contains the resource type and name  	if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00'  		0x89'  		0x45'  		0xF4'  		0x6A'  		0xAA'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x8B'  		0x4D'  		0xF4'  		0x51'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 12;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 1;  		name = reader.ReadInt32 ();  	}  	else if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00'  		0x6A'  		0xAA'  		0x8B'  		0xF8'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x57'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 9;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 3;  		name = reader.ReadInt32 ();  	}  	else if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0xAA'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 1;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 1;  		name = reader.ReadInt32 ();  	}  	else  		throw new Exception ("Failed to determine type and name of resource.");  	//search for start of function CStringDecoder::DelayedLoad()  	reader.BaseStream.Position -= 50;  	// should be enough  	FindAoBInFile (reader' (int)reader.BaseStream.Position' new byte[] {  		0x55'  		0x8B'  		0xEC'  		0x83'  		0xEC'  		0x10  	});  	int offset_CStringDecoder__DelayedLoad = (int)reader.BaseStream.Position;  	for (reader.BaseStream.Position = 0; reader.BaseStream.Position < reader.BaseStream.Length;) {  		if (reader.ReadByte () != 0xE8)  			// call  			continue;  		int offse = reader.ReadInt32 ();  		if (reader.BaseStream.Position + offse == offset_CStringDecoder__DelayedLoad) {  			Status ("{0:X8} reference to offset_CStringDecoder__DelayedLoad = {1:X8}"' reader.BaseStream.Position - 5' offse);  			break;  		}  	}  	ImageResourceDirectory tier1 = (ImageResourceDirectory)root.GetEntry (type).Entry;  	ImageResourceDirectory tier2 = (ImageResourceDirectory)tier1.GetEntry (name).Entry;  	rsrcStringDataEntry = (ImageResourceDataEntry)tier2.Entrys [0].Entry;  	rsrcStringDataPosition = rsrcPointerToRawData + (rsrcStringDataEntry.OffsetToData - rsrcVirtualAddress);  	m_nCount = GetWordFromIndex (0);  	Status ("Amount of strings: {0}"' m_nCount);  	for (int i = 1; i < m_nCount; ++i)  		MainForm.Invoke (() => MainForm.dataTable.Rows.Add (i' StringDecoderDecode (i)' string.Format ("{0:X8}"' rsrcStringDataPosition + i * 4)));  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: if (StringDecodeMethod == 0)// StringPool   {  	MainForm.Invoke (() => MainForm.Text += " [StringPool]");  	int offset_StringPool__ms_aKey = (int)reader.BaseStream.Position;  	Status ("StringPool::ms_aKey located at {0:X8}"' offset_StringPool__ms_aKey);  	int keyRef = 0;  	// Only GetString references ms_aKey  	byte[] bytes = new byte[5];  	bytes [0] = 0x68;  	// push offset  	Buffer.BlockCopy (BitConverter.GetBytes (ImageBase + offset_StringPool__ms_aKey)' 0' bytes' 1' 4);  	if (FindAoBInFile (reader' 0' bytes))  		keyRef = (int)reader.BaseStream.Position;  	reader.BaseStream.Position = keyRef;  	while (true) {  		byte[] asdf = reader.ReadBytes (5);  		if (asdf [4] == 0xc3)// retn  		 {  			bool die = true;  			foreach (byte b in asdf)  				if (b == 0xe8)// call  				 {  					die = false;  					break;  				}  			if (die)  				break;  		}  		reader.BaseStream.Position -= 6;  	}  	while (reader.ReadByte () == 0xcc)  		;  	// allign  	reader.BaseStream.Position -= 1;  	int offset_StringPool__GetString_uint_char = (int)reader.BaseStream.Position;  	Status ("StringPool::GetString(uint' char) located at {0:X8}"' offset_StringPool__GetString_uint_char);  	//search for StringPool::offset_ms_aString  	if (FindAoBInFile (reader' keyRef - 100' new byte[] {  		0x8b'  		0x0c  	}' 100))  		reader.BaseStream.Position += 3;  	else if (FindAoBInFile (reader' keyRef - 100' new byte[] {  		0x8b'  		0x86  	}' 100))  		reader.BaseStream.Position += 2;  	else  		throw new Exception ("could not find start of StringPool::offset_ms_aString");  	offset_StringPool__ms_aString = reader.ReadInt32 () - ImageBase;  	Status ("StringPool::ms_aString located at {0:X8}"' offset_StringPool__ms_aString);  	//search for xrefs to function StringPool::GetString(uint' char)   	int[] xref = FindCalls (offset_StringPool__GetString_uint_char' 2);  	if (xref.Length != 2)  		throw new Exception ("failed to find references to StringPool::GetString(uint' char)");  	//search for start of StringPool::GetString(uint)  	if (!FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x51'  		0x8b  	}' 50) && !FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x55'  		0x8b  	}' 50))  		throw new Exception ("could not find start of GetString(uint)");  	int offset_StringPool__GetString_uint = (int)reader.BaseStream.Position;  	Status ("StringPool::GetString(uint) located at {0:X8}"' offset_StringPool__GetString_uint);  	//search for start of StringPool::GetString(uint' ushort)  	for (reader.BaseStream.Position = xref [1]; (reader.ReadUInt32 () & 0xffffff00) != 0x000cc200; reader.BaseStream.Position -= 5)  		;  	//seek the start of function StringPool::GetString(uint' char)  	while (reader.ReadByte () == 0xcc)  		;  	// allign  	reader.BaseStream.Position -= 1;  	int offset_StringPool__GetString_uint_ushort = (int)reader.BaseStream.Position;  	Status ("StringPool::GetString(uint' ushort) located at {0:X8}"' offset_StringPool__GetString_uint_ushort);  	//search for xrefs to function StringPool::GetString(uint)  	xref = FindCalls (offset_StringPool__GetString_uint' 1);  	if (xref.Length != 1)  		throw new Exception ("failed to find references to StringPool::GetString(uint)");  	//search for start of function StringPool::GetBSTR(uint)  	reader.BaseStream.Position -= 100;  	// should be enough  	if (!FindAoBInFile (reader' (int)reader.BaseStream.Position' new byte[] {  		0xb8'  		0xaa'  		0xaa'  		0xaa'  		0x00  	}))  		for (reader.BaseStream.Position = xref [0]; (reader.ReadUInt32 () & 0xff00ff00) != 0x0000c200; reader.BaseStream.Position -= 5)  			;  	//seek the start of function StringPool::GetString(uint' char)  	while (reader.ReadByte () == 0xcc)  		;  	// allign  	reader.BaseStream.Position -= 1;  	int offset_StringPool__GetBSTR_uint = (int)reader.BaseStream.Position;  	Status ("StringPool::GetBSTR(uint) located at {0:X8}"' offset_StringPool__GetBSTR_uint);  	//search for xrefs to function StringPool::GetString(uint' ushort)  	xref = FindCalls (offset_StringPool__GetString_uint_ushort' 1);  	if (xref.Length != 1)  		throw new Exception ("failed to find references to StringPool::GetString(uint' ushort)");  	//search for start of function StringPool::GetStringW(uint)  	if (!FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x51'  		0x8b  	}' 50) && !FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x55'  		0x8b  	}' 50))  		throw new Exception ("could not find start of GetStringW(uint)");  	int offset_StringPool__GetStringW_uint = (int)reader.BaseStream.Position;  	Status ("StringPool::GetStringW(uint) located at {0:X8}"' offset_StringPool__GetStringW_uint);  	ms_nSize = GetIntFromOffset (offset_StringPool__ms_aKey + 16 + 4);  	Status ("Amount of strings: {0}"' ms_nSize);  	if (MessageBox.Show ("Scan for references to strings in the client? This can take a while."' "Warning"' MessageBoxButtons.YesNo' MessageBoxIcon.Warning) == DialogResult.Yes) {  		Status ("Searching for references to GetString' GetStringW' and GetBSTR");  		List<int> GetStringCalls = new List<int> ();  		List<int> GetStringWCalls = new List<int> ();  		List<int> GetBSTRCalls = new List<int> ();  		for (reader.BaseStream.Position = 0; reader.BaseStream.Position < reader.BaseStream.Length;) {  			//int lol = (int)((float)reader.BaseStream.Position / reader.BaseStream.Length * 100);  			//if (lol > MainForm.toolStripProgressBar1.Value)  			//{  			//    MainForm.Invoke(() => MainForm.toolStripProgressBar1.Value = lol);  			//    MainForm.Invoke(() => MainForm.Update());  			//} too expensive  			if (reader.ReadByte () != 0xE8)  				// call  				continue;  			int offset = reader.ReadInt32 ();  			if (reader.BaseStream.Position + offset == offset_StringPool__GetString_uint)  				GetStringCalls.Add ((int)reader.BaseStream.Position - 5);  			else if (reader.BaseStream.Position + offset == offset_StringPool__GetStringW_uint)  				GetStringWCalls.Add ((int)reader.BaseStream.Position - 5);  			else if (reader.BaseStream.Position + offset == offset_StringPool__GetBSTR_uint)  				GetBSTRCalls.Add ((int)reader.BaseStream.Position - 5);  			else  				reader.BaseStream.Position -= 4;  		}  		List<int> GetStringFail = new List<int> ();  		foreach (int addr in GetStringCalls) {  			reader.BaseStream.Position = addr;  			reader.BaseStream.Position -= 2;  			if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  			 {  				GetStringFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 7;  			if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  			 {  				GetStringFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 2;  			if (reader.ReadByte () != 0x50)// push eax  			 {  				GetStringFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 6;  			if (reader.ReadByte () != 0x68)// push dword  			 {  				GetStringFail.Add (addr);  				continue;  			}  			int idx = reader.ReadInt32 ();  			if (idx > ms_nSize - 1)  				GetStringFail.Add (addr);  			else  				GetString.Add (addr' idx);  		}  		List<int> GetStringWFail = new List<int> ();  		foreach (int addr in GetStringWCalls) {  			reader.BaseStream.Position = addr;  			reader.BaseStream.Position -= 2;  			if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 7;  			if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 2;  			if (reader.ReadByte () != 0x50)// push eax  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 6;  			if (reader.ReadByte () != 0x68)// push dword  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			int idx = reader.ReadInt32 ();  			if (idx > ms_nSize - 1)  				GetStringWFail.Add (addr);  			else  				GetStringW.Add (addr' idx);  		}  		List<int> GetBSTRFail = new List<int> ();  		foreach (int addr in GetBSTRCalls) {  			reader.BaseStream.Position = addr;  			reader.BaseStream.Position -= 2;  			if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 7;  			if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 2;  			if (reader.ReadByte () != 0x50)// push eax  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 6;  			if (reader.ReadByte () != 0x68)// push dword  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			int idx = reader.ReadInt32 ();  			if (idx > ms_nSize - 1)  				GetBSTRFail.Add (addr);  			else  				GetBSTR.Add (addr' idx);  		}  		Status ("Failed to find index of {0} references"' GetStringFail.Count + GetStringWFail.Count + GetBSTRFail.Count);  	}  	Status ("Successfully found index of {0} references"' GetString.Count + GetBSTR.Count + GetStringW.Count);  	Status ("Decoding strings");  	for (int index = 0; index < ms_nSize; ++index)  		if (index != -1 && index <= 0xffff)  			Strings.Add (index' StringPoolDecode (index));  	Status ("Populating table");  	foreach (var s in Strings)  		MainForm.Invoke (() => MainForm.dataTable.Rows.Add (s.Key' s.Value' string.Empty));  	foreach (var a in GetString)  		MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetString")));  	foreach (var a in GetBSTR)  		MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetBSTR")));  	foreach (var a in GetStringW)  		MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetStringW")));  }  else if (StringDecodeMethod == 1)// StringDecoder   {  	MainForm.Invoke (() => MainForm.Text += " [StringDecoder]");  	int type = 0;  	int name = 0;  	int offset = 0;  	//search for CStringDecoder::DelayedLoad' which contains the resource type and name  	if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00'  		0x89'  		0x45'  		0xF4'  		0x6A'  		0xAA'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x8B'  		0x4D'  		0xF4'  		0x51'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 12;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 1;  		name = reader.ReadInt32 ();  	}  	else if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00'  		0x6A'  		0xAA'  		0x8B'  		0xF8'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x57'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 9;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 3;  		name = reader.ReadInt32 ();  	}  	else if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0xAA'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 1;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 1;  		name = reader.ReadInt32 ();  	}  	else  		throw new Exception ("Failed to determine type and name of resource.");  	//search for start of function CStringDecoder::DelayedLoad()  	reader.BaseStream.Position -= 50;  	// should be enough  	FindAoBInFile (reader' (int)reader.BaseStream.Position' new byte[] {  		0x55'  		0x8B'  		0xEC'  		0x83'  		0xEC'  		0x10  	});  	int offset_CStringDecoder__DelayedLoad = (int)reader.BaseStream.Position;  	for (reader.BaseStream.Position = 0; reader.BaseStream.Position < reader.BaseStream.Length;) {  		if (reader.ReadByte () != 0xE8)  			// call  			continue;  		int offse = reader.ReadInt32 ();  		if (reader.BaseStream.Position + offse == offset_CStringDecoder__DelayedLoad) {  			Status ("{0:X8} reference to offset_CStringDecoder__DelayedLoad = {1:X8}"' reader.BaseStream.Position - 5' offse);  			break;  		}  	}  	ImageResourceDirectory tier1 = (ImageResourceDirectory)root.GetEntry (type).Entry;  	ImageResourceDirectory tier2 = (ImageResourceDirectory)tier1.GetEntry (name).Entry;  	rsrcStringDataEntry = (ImageResourceDataEntry)tier2.Entrys [0].Entry;  	rsrcStringDataPosition = rsrcPointerToRawData + (rsrcStringDataEntry.OffsetToData - rsrcVirtualAddress);  	m_nCount = GetWordFromIndex (0);  	Status ("Amount of strings: {0}"' m_nCount);  	for (int i = 1; i < m_nCount; ++i)  		MainForm.Invoke (() => MainForm.dataTable.Rows.Add (i' StringDecoderDecode (i)' string.Format ("{0:X8}"' rsrcStringDataPosition + i * 4)));  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: if (StringDecodeMethod == 0)// StringPool   {  	MainForm.Invoke (() => MainForm.Text += " [StringPool]");  	int offset_StringPool__ms_aKey = (int)reader.BaseStream.Position;  	Status ("StringPool::ms_aKey located at {0:X8}"' offset_StringPool__ms_aKey);  	int keyRef = 0;  	// Only GetString references ms_aKey  	byte[] bytes = new byte[5];  	bytes [0] = 0x68;  	// push offset  	Buffer.BlockCopy (BitConverter.GetBytes (ImageBase + offset_StringPool__ms_aKey)' 0' bytes' 1' 4);  	if (FindAoBInFile (reader' 0' bytes))  		keyRef = (int)reader.BaseStream.Position;  	reader.BaseStream.Position = keyRef;  	while (true) {  		byte[] asdf = reader.ReadBytes (5);  		if (asdf [4] == 0xc3)// retn  		 {  			bool die = true;  			foreach (byte b in asdf)  				if (b == 0xe8)// call  				 {  					die = false;  					break;  				}  			if (die)  				break;  		}  		reader.BaseStream.Position -= 6;  	}  	while (reader.ReadByte () == 0xcc)  		;  	// allign  	reader.BaseStream.Position -= 1;  	int offset_StringPool__GetString_uint_char = (int)reader.BaseStream.Position;  	Status ("StringPool::GetString(uint' char) located at {0:X8}"' offset_StringPool__GetString_uint_char);  	//search for StringPool::offset_ms_aString  	if (FindAoBInFile (reader' keyRef - 100' new byte[] {  		0x8b'  		0x0c  	}' 100))  		reader.BaseStream.Position += 3;  	else if (FindAoBInFile (reader' keyRef - 100' new byte[] {  		0x8b'  		0x86  	}' 100))  		reader.BaseStream.Position += 2;  	else  		throw new Exception ("could not find start of StringPool::offset_ms_aString");  	offset_StringPool__ms_aString = reader.ReadInt32 () - ImageBase;  	Status ("StringPool::ms_aString located at {0:X8}"' offset_StringPool__ms_aString);  	//search for xrefs to function StringPool::GetString(uint' char)   	int[] xref = FindCalls (offset_StringPool__GetString_uint_char' 2);  	if (xref.Length != 2)  		throw new Exception ("failed to find references to StringPool::GetString(uint' char)");  	//search for start of StringPool::GetString(uint)  	if (!FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x51'  		0x8b  	}' 50) && !FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x55'  		0x8b  	}' 50))  		throw new Exception ("could not find start of GetString(uint)");  	int offset_StringPool__GetString_uint = (int)reader.BaseStream.Position;  	Status ("StringPool::GetString(uint) located at {0:X8}"' offset_StringPool__GetString_uint);  	//search for start of StringPool::GetString(uint' ushort)  	for (reader.BaseStream.Position = xref [1]; (reader.ReadUInt32 () & 0xffffff00) != 0x000cc200; reader.BaseStream.Position -= 5)  		;  	//seek the start of function StringPool::GetString(uint' char)  	while (reader.ReadByte () == 0xcc)  		;  	// allign  	reader.BaseStream.Position -= 1;  	int offset_StringPool__GetString_uint_ushort = (int)reader.BaseStream.Position;  	Status ("StringPool::GetString(uint' ushort) located at {0:X8}"' offset_StringPool__GetString_uint_ushort);  	//search for xrefs to function StringPool::GetString(uint)  	xref = FindCalls (offset_StringPool__GetString_uint' 1);  	if (xref.Length != 1)  		throw new Exception ("failed to find references to StringPool::GetString(uint)");  	//search for start of function StringPool::GetBSTR(uint)  	reader.BaseStream.Position -= 100;  	// should be enough  	if (!FindAoBInFile (reader' (int)reader.BaseStream.Position' new byte[] {  		0xb8'  		0xaa'  		0xaa'  		0xaa'  		0x00  	}))  		for (reader.BaseStream.Position = xref [0]; (reader.ReadUInt32 () & 0xff00ff00) != 0x0000c200; reader.BaseStream.Position -= 5)  			;  	//seek the start of function StringPool::GetString(uint' char)  	while (reader.ReadByte () == 0xcc)  		;  	// allign  	reader.BaseStream.Position -= 1;  	int offset_StringPool__GetBSTR_uint = (int)reader.BaseStream.Position;  	Status ("StringPool::GetBSTR(uint) located at {0:X8}"' offset_StringPool__GetBSTR_uint);  	//search for xrefs to function StringPool::GetString(uint' ushort)  	xref = FindCalls (offset_StringPool__GetString_uint_ushort' 1);  	if (xref.Length != 1)  		throw new Exception ("failed to find references to StringPool::GetString(uint' ushort)");  	//search for start of function StringPool::GetStringW(uint)  	if (!FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x51'  		0x8b  	}' 50) && !FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x55'  		0x8b  	}' 50))  		throw new Exception ("could not find start of GetStringW(uint)");  	int offset_StringPool__GetStringW_uint = (int)reader.BaseStream.Position;  	Status ("StringPool::GetStringW(uint) located at {0:X8}"' offset_StringPool__GetStringW_uint);  	ms_nSize = GetIntFromOffset (offset_StringPool__ms_aKey + 16 + 4);  	Status ("Amount of strings: {0}"' ms_nSize);  	if (MessageBox.Show ("Scan for references to strings in the client? This can take a while."' "Warning"' MessageBoxButtons.YesNo' MessageBoxIcon.Warning) == DialogResult.Yes) {  		Status ("Searching for references to GetString' GetStringW' and GetBSTR");  		List<int> GetStringCalls = new List<int> ();  		List<int> GetStringWCalls = new List<int> ();  		List<int> GetBSTRCalls = new List<int> ();  		for (reader.BaseStream.Position = 0; reader.BaseStream.Position < reader.BaseStream.Length;) {  			//int lol = (int)((float)reader.BaseStream.Position / reader.BaseStream.Length * 100);  			//if (lol > MainForm.toolStripProgressBar1.Value)  			//{  			//    MainForm.Invoke(() => MainForm.toolStripProgressBar1.Value = lol);  			//    MainForm.Invoke(() => MainForm.Update());  			//} too expensive  			if (reader.ReadByte () != 0xE8)  				// call  				continue;  			int offset = reader.ReadInt32 ();  			if (reader.BaseStream.Position + offset == offset_StringPool__GetString_uint)  				GetStringCalls.Add ((int)reader.BaseStream.Position - 5);  			else if (reader.BaseStream.Position + offset == offset_StringPool__GetStringW_uint)  				GetStringWCalls.Add ((int)reader.BaseStream.Position - 5);  			else if (reader.BaseStream.Position + offset == offset_StringPool__GetBSTR_uint)  				GetBSTRCalls.Add ((int)reader.BaseStream.Position - 5);  			else  				reader.BaseStream.Position -= 4;  		}  		List<int> GetStringFail = new List<int> ();  		foreach (int addr in GetStringCalls) {  			reader.BaseStream.Position = addr;  			reader.BaseStream.Position -= 2;  			if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  			 {  				GetStringFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 7;  			if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  			 {  				GetStringFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 2;  			if (reader.ReadByte () != 0x50)// push eax  			 {  				GetStringFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 6;  			if (reader.ReadByte () != 0x68)// push dword  			 {  				GetStringFail.Add (addr);  				continue;  			}  			int idx = reader.ReadInt32 ();  			if (idx > ms_nSize - 1)  				GetStringFail.Add (addr);  			else  				GetString.Add (addr' idx);  		}  		List<int> GetStringWFail = new List<int> ();  		foreach (int addr in GetStringWCalls) {  			reader.BaseStream.Position = addr;  			reader.BaseStream.Position -= 2;  			if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 7;  			if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 2;  			if (reader.ReadByte () != 0x50)// push eax  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 6;  			if (reader.ReadByte () != 0x68)// push dword  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			int idx = reader.ReadInt32 ();  			if (idx > ms_nSize - 1)  				GetStringWFail.Add (addr);  			else  				GetStringW.Add (addr' idx);  		}  		List<int> GetBSTRFail = new List<int> ();  		foreach (int addr in GetBSTRCalls) {  			reader.BaseStream.Position = addr;  			reader.BaseStream.Position -= 2;  			if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 7;  			if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 2;  			if (reader.ReadByte () != 0x50)// push eax  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 6;  			if (reader.ReadByte () != 0x68)// push dword  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			int idx = reader.ReadInt32 ();  			if (idx > ms_nSize - 1)  				GetBSTRFail.Add (addr);  			else  				GetBSTR.Add (addr' idx);  		}  		Status ("Failed to find index of {0} references"' GetStringFail.Count + GetStringWFail.Count + GetBSTRFail.Count);  	}  	Status ("Successfully found index of {0} references"' GetString.Count + GetBSTR.Count + GetStringW.Count);  	Status ("Decoding strings");  	for (int index = 0; index < ms_nSize; ++index)  		if (index != -1 && index <= 0xffff)  			Strings.Add (index' StringPoolDecode (index));  	Status ("Populating table");  	foreach (var s in Strings)  		MainForm.Invoke (() => MainForm.dataTable.Rows.Add (s.Key' s.Value' string.Empty));  	foreach (var a in GetString)  		MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetString")));  	foreach (var a in GetBSTR)  		MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetBSTR")));  	foreach (var a in GetStringW)  		MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetStringW")));  }  else if (StringDecodeMethod == 1)// StringDecoder   {  	MainForm.Invoke (() => MainForm.Text += " [StringDecoder]");  	int type = 0;  	int name = 0;  	int offset = 0;  	//search for CStringDecoder::DelayedLoad' which contains the resource type and name  	if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00'  		0x89'  		0x45'  		0xF4'  		0x6A'  		0xAA'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x8B'  		0x4D'  		0xF4'  		0x51'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 12;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 1;  		name = reader.ReadInt32 ();  	}  	else if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00'  		0x6A'  		0xAA'  		0x8B'  		0xF8'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x57'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 9;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 3;  		name = reader.ReadInt32 ();  	}  	else if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0xAA'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 1;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 1;  		name = reader.ReadInt32 ();  	}  	else  		throw new Exception ("Failed to determine type and name of resource.");  	//search for start of function CStringDecoder::DelayedLoad()  	reader.BaseStream.Position -= 50;  	// should be enough  	FindAoBInFile (reader' (int)reader.BaseStream.Position' new byte[] {  		0x55'  		0x8B'  		0xEC'  		0x83'  		0xEC'  		0x10  	});  	int offset_CStringDecoder__DelayedLoad = (int)reader.BaseStream.Position;  	for (reader.BaseStream.Position = 0; reader.BaseStream.Position < reader.BaseStream.Length;) {  		if (reader.ReadByte () != 0xE8)  			// call  			continue;  		int offse = reader.ReadInt32 ();  		if (reader.BaseStream.Position + offse == offset_CStringDecoder__DelayedLoad) {  			Status ("{0:X8} reference to offset_CStringDecoder__DelayedLoad = {1:X8}"' reader.BaseStream.Position - 5' offse);  			break;  		}  	}  	ImageResourceDirectory tier1 = (ImageResourceDirectory)root.GetEntry (type).Entry;  	ImageResourceDirectory tier2 = (ImageResourceDirectory)tier1.GetEntry (name).Entry;  	rsrcStringDataEntry = (ImageResourceDataEntry)tier2.Entrys [0].Entry;  	rsrcStringDataPosition = rsrcPointerToRawData + (rsrcStringDataEntry.OffsetToData - rsrcVirtualAddress);  	m_nCount = GetWordFromIndex (0);  	Status ("Amount of strings: {0}"' m_nCount);  	for (int i = 1; i < m_nCount; ++i)  		MainForm.Invoke (() => MainForm.dataTable.Rows.Add (i' StringDecoderDecode (i)' string.Format ("{0:X8}"' rsrcStringDataPosition + i * 4)));  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: if (StringDecodeMethod == 0)// StringPool   {  	MainForm.Invoke (() => MainForm.Text += " [StringPool]");  	int offset_StringPool__ms_aKey = (int)reader.BaseStream.Position;  	Status ("StringPool::ms_aKey located at {0:X8}"' offset_StringPool__ms_aKey);  	int keyRef = 0;  	// Only GetString references ms_aKey  	byte[] bytes = new byte[5];  	bytes [0] = 0x68;  	// push offset  	Buffer.BlockCopy (BitConverter.GetBytes (ImageBase + offset_StringPool__ms_aKey)' 0' bytes' 1' 4);  	if (FindAoBInFile (reader' 0' bytes))  		keyRef = (int)reader.BaseStream.Position;  	reader.BaseStream.Position = keyRef;  	while (true) {  		byte[] asdf = reader.ReadBytes (5);  		if (asdf [4] == 0xc3)// retn  		 {  			bool die = true;  			foreach (byte b in asdf)  				if (b == 0xe8)// call  				 {  					die = false;  					break;  				}  			if (die)  				break;  		}  		reader.BaseStream.Position -= 6;  	}  	while (reader.ReadByte () == 0xcc)  		;  	// allign  	reader.BaseStream.Position -= 1;  	int offset_StringPool__GetString_uint_char = (int)reader.BaseStream.Position;  	Status ("StringPool::GetString(uint' char) located at {0:X8}"' offset_StringPool__GetString_uint_char);  	//search for StringPool::offset_ms_aString  	if (FindAoBInFile (reader' keyRef - 100' new byte[] {  		0x8b'  		0x0c  	}' 100))  		reader.BaseStream.Position += 3;  	else if (FindAoBInFile (reader' keyRef - 100' new byte[] {  		0x8b'  		0x86  	}' 100))  		reader.BaseStream.Position += 2;  	else  		throw new Exception ("could not find start of StringPool::offset_ms_aString");  	offset_StringPool__ms_aString = reader.ReadInt32 () - ImageBase;  	Status ("StringPool::ms_aString located at {0:X8}"' offset_StringPool__ms_aString);  	//search for xrefs to function StringPool::GetString(uint' char)   	int[] xref = FindCalls (offset_StringPool__GetString_uint_char' 2);  	if (xref.Length != 2)  		throw new Exception ("failed to find references to StringPool::GetString(uint' char)");  	//search for start of StringPool::GetString(uint)  	if (!FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x51'  		0x8b  	}' 50) && !FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x55'  		0x8b  	}' 50))  		throw new Exception ("could not find start of GetString(uint)");  	int offset_StringPool__GetString_uint = (int)reader.BaseStream.Position;  	Status ("StringPool::GetString(uint) located at {0:X8}"' offset_StringPool__GetString_uint);  	//search for start of StringPool::GetString(uint' ushort)  	for (reader.BaseStream.Position = xref [1]; (reader.ReadUInt32 () & 0xffffff00) != 0x000cc200; reader.BaseStream.Position -= 5)  		;  	//seek the start of function StringPool::GetString(uint' char)  	while (reader.ReadByte () == 0xcc)  		;  	// allign  	reader.BaseStream.Position -= 1;  	int offset_StringPool__GetString_uint_ushort = (int)reader.BaseStream.Position;  	Status ("StringPool::GetString(uint' ushort) located at {0:X8}"' offset_StringPool__GetString_uint_ushort);  	//search for xrefs to function StringPool::GetString(uint)  	xref = FindCalls (offset_StringPool__GetString_uint' 1);  	if (xref.Length != 1)  		throw new Exception ("failed to find references to StringPool::GetString(uint)");  	//search for start of function StringPool::GetBSTR(uint)  	reader.BaseStream.Position -= 100;  	// should be enough  	if (!FindAoBInFile (reader' (int)reader.BaseStream.Position' new byte[] {  		0xb8'  		0xaa'  		0xaa'  		0xaa'  		0x00  	}))  		for (reader.BaseStream.Position = xref [0]; (reader.ReadUInt32 () & 0xff00ff00) != 0x0000c200; reader.BaseStream.Position -= 5)  			;  	//seek the start of function StringPool::GetString(uint' char)  	while (reader.ReadByte () == 0xcc)  		;  	// allign  	reader.BaseStream.Position -= 1;  	int offset_StringPool__GetBSTR_uint = (int)reader.BaseStream.Position;  	Status ("StringPool::GetBSTR(uint) located at {0:X8}"' offset_StringPool__GetBSTR_uint);  	//search for xrefs to function StringPool::GetString(uint' ushort)  	xref = FindCalls (offset_StringPool__GetString_uint_ushort' 1);  	if (xref.Length != 1)  		throw new Exception ("failed to find references to StringPool::GetString(uint' ushort)");  	//search for start of function StringPool::GetStringW(uint)  	if (!FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x51'  		0x8b  	}' 50) && !FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x55'  		0x8b  	}' 50))  		throw new Exception ("could not find start of GetStringW(uint)");  	int offset_StringPool__GetStringW_uint = (int)reader.BaseStream.Position;  	Status ("StringPool::GetStringW(uint) located at {0:X8}"' offset_StringPool__GetStringW_uint);  	ms_nSize = GetIntFromOffset (offset_StringPool__ms_aKey + 16 + 4);  	Status ("Amount of strings: {0}"' ms_nSize);  	if (MessageBox.Show ("Scan for references to strings in the client? This can take a while."' "Warning"' MessageBoxButtons.YesNo' MessageBoxIcon.Warning) == DialogResult.Yes) {  		Status ("Searching for references to GetString' GetStringW' and GetBSTR");  		List<int> GetStringCalls = new List<int> ();  		List<int> GetStringWCalls = new List<int> ();  		List<int> GetBSTRCalls = new List<int> ();  		for (reader.BaseStream.Position = 0; reader.BaseStream.Position < reader.BaseStream.Length;) {  			//int lol = (int)((float)reader.BaseStream.Position / reader.BaseStream.Length * 100);  			//if (lol > MainForm.toolStripProgressBar1.Value)  			//{  			//    MainForm.Invoke(() => MainForm.toolStripProgressBar1.Value = lol);  			//    MainForm.Invoke(() => MainForm.Update());  			//} too expensive  			if (reader.ReadByte () != 0xE8)  				// call  				continue;  			int offset = reader.ReadInt32 ();  			if (reader.BaseStream.Position + offset == offset_StringPool__GetString_uint)  				GetStringCalls.Add ((int)reader.BaseStream.Position - 5);  			else if (reader.BaseStream.Position + offset == offset_StringPool__GetStringW_uint)  				GetStringWCalls.Add ((int)reader.BaseStream.Position - 5);  			else if (reader.BaseStream.Position + offset == offset_StringPool__GetBSTR_uint)  				GetBSTRCalls.Add ((int)reader.BaseStream.Position - 5);  			else  				reader.BaseStream.Position -= 4;  		}  		List<int> GetStringFail = new List<int> ();  		foreach (int addr in GetStringCalls) {  			reader.BaseStream.Position = addr;  			reader.BaseStream.Position -= 2;  			if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  			 {  				GetStringFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 7;  			if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  			 {  				GetStringFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 2;  			if (reader.ReadByte () != 0x50)// push eax  			 {  				GetStringFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 6;  			if (reader.ReadByte () != 0x68)// push dword  			 {  				GetStringFail.Add (addr);  				continue;  			}  			int idx = reader.ReadInt32 ();  			if (idx > ms_nSize - 1)  				GetStringFail.Add (addr);  			else  				GetString.Add (addr' idx);  		}  		List<int> GetStringWFail = new List<int> ();  		foreach (int addr in GetStringWCalls) {  			reader.BaseStream.Position = addr;  			reader.BaseStream.Position -= 2;  			if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 7;  			if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 2;  			if (reader.ReadByte () != 0x50)// push eax  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 6;  			if (reader.ReadByte () != 0x68)// push dword  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			int idx = reader.ReadInt32 ();  			if (idx > ms_nSize - 1)  				GetStringWFail.Add (addr);  			else  				GetStringW.Add (addr' idx);  		}  		List<int> GetBSTRFail = new List<int> ();  		foreach (int addr in GetBSTRCalls) {  			reader.BaseStream.Position = addr;  			reader.BaseStream.Position -= 2;  			if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 7;  			if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 2;  			if (reader.ReadByte () != 0x50)// push eax  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 6;  			if (reader.ReadByte () != 0x68)// push dword  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			int idx = reader.ReadInt32 ();  			if (idx > ms_nSize - 1)  				GetBSTRFail.Add (addr);  			else  				GetBSTR.Add (addr' idx);  		}  		Status ("Failed to find index of {0} references"' GetStringFail.Count + GetStringWFail.Count + GetBSTRFail.Count);  	}  	Status ("Successfully found index of {0} references"' GetString.Count + GetBSTR.Count + GetStringW.Count);  	Status ("Decoding strings");  	for (int index = 0; index < ms_nSize; ++index)  		if (index != -1 && index <= 0xffff)  			Strings.Add (index' StringPoolDecode (index));  	Status ("Populating table");  	foreach (var s in Strings)  		MainForm.Invoke (() => MainForm.dataTable.Rows.Add (s.Key' s.Value' string.Empty));  	foreach (var a in GetString)  		MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetString")));  	foreach (var a in GetBSTR)  		MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetBSTR")));  	foreach (var a in GetStringW)  		MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetStringW")));  }  else if (StringDecodeMethod == 1)// StringDecoder   {  	MainForm.Invoke (() => MainForm.Text += " [StringDecoder]");  	int type = 0;  	int name = 0;  	int offset = 0;  	//search for CStringDecoder::DelayedLoad' which contains the resource type and name  	if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00'  		0x89'  		0x45'  		0xF4'  		0x6A'  		0xAA'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x8B'  		0x4D'  		0xF4'  		0x51'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 12;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 1;  		name = reader.ReadInt32 ();  	}  	else if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00'  		0x6A'  		0xAA'  		0x8B'  		0xF8'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x57'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 9;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 3;  		name = reader.ReadInt32 ();  	}  	else if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0xAA'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 1;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 1;  		name = reader.ReadInt32 ();  	}  	else  		throw new Exception ("Failed to determine type and name of resource.");  	//search for start of function CStringDecoder::DelayedLoad()  	reader.BaseStream.Position -= 50;  	// should be enough  	FindAoBInFile (reader' (int)reader.BaseStream.Position' new byte[] {  		0x55'  		0x8B'  		0xEC'  		0x83'  		0xEC'  		0x10  	});  	int offset_CStringDecoder__DelayedLoad = (int)reader.BaseStream.Position;  	for (reader.BaseStream.Position = 0; reader.BaseStream.Position < reader.BaseStream.Length;) {  		if (reader.ReadByte () != 0xE8)  			// call  			continue;  		int offse = reader.ReadInt32 ();  		if (reader.BaseStream.Position + offse == offset_CStringDecoder__DelayedLoad) {  			Status ("{0:X8} reference to offset_CStringDecoder__DelayedLoad = {1:X8}"' reader.BaseStream.Position - 5' offse);  			break;  		}  	}  	ImageResourceDirectory tier1 = (ImageResourceDirectory)root.GetEntry (type).Entry;  	ImageResourceDirectory tier2 = (ImageResourceDirectory)tier1.GetEntry (name).Entry;  	rsrcStringDataEntry = (ImageResourceDataEntry)tier2.Entrys [0].Entry;  	rsrcStringDataPosition = rsrcPointerToRawData + (rsrcStringDataEntry.OffsetToData - rsrcVirtualAddress);  	m_nCount = GetWordFromIndex (0);  	Status ("Amount of strings: {0}"' m_nCount);  	for (int i = 1; i < m_nCount; ++i)  		MainForm.Invoke (() => MainForm.dataTable.Rows.Add (i' StringDecoderDecode (i)' string.Format ("{0:X8}"' rsrcStringDataPosition + i * 4)));  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: if (StringDecodeMethod == 0)// StringPool   {  	MainForm.Invoke (() => MainForm.Text += " [StringPool]");  	int offset_StringPool__ms_aKey = (int)reader.BaseStream.Position;  	Status ("StringPool::ms_aKey located at {0:X8}"' offset_StringPool__ms_aKey);  	int keyRef = 0;  	// Only GetString references ms_aKey  	byte[] bytes = new byte[5];  	bytes [0] = 0x68;  	// push offset  	Buffer.BlockCopy (BitConverter.GetBytes (ImageBase + offset_StringPool__ms_aKey)' 0' bytes' 1' 4);  	if (FindAoBInFile (reader' 0' bytes))  		keyRef = (int)reader.BaseStream.Position;  	reader.BaseStream.Position = keyRef;  	while (true) {  		byte[] asdf = reader.ReadBytes (5);  		if (asdf [4] == 0xc3)// retn  		 {  			bool die = true;  			foreach (byte b in asdf)  				if (b == 0xe8)// call  				 {  					die = false;  					break;  				}  			if (die)  				break;  		}  		reader.BaseStream.Position -= 6;  	}  	while (reader.ReadByte () == 0xcc)  		;  	// allign  	reader.BaseStream.Position -= 1;  	int offset_StringPool__GetString_uint_char = (int)reader.BaseStream.Position;  	Status ("StringPool::GetString(uint' char) located at {0:X8}"' offset_StringPool__GetString_uint_char);  	//search for StringPool::offset_ms_aString  	if (FindAoBInFile (reader' keyRef - 100' new byte[] {  		0x8b'  		0x0c  	}' 100))  		reader.BaseStream.Position += 3;  	else if (FindAoBInFile (reader' keyRef - 100' new byte[] {  		0x8b'  		0x86  	}' 100))  		reader.BaseStream.Position += 2;  	else  		throw new Exception ("could not find start of StringPool::offset_ms_aString");  	offset_StringPool__ms_aString = reader.ReadInt32 () - ImageBase;  	Status ("StringPool::ms_aString located at {0:X8}"' offset_StringPool__ms_aString);  	//search for xrefs to function StringPool::GetString(uint' char)   	int[] xref = FindCalls (offset_StringPool__GetString_uint_char' 2);  	if (xref.Length != 2)  		throw new Exception ("failed to find references to StringPool::GetString(uint' char)");  	//search for start of StringPool::GetString(uint)  	if (!FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x51'  		0x8b  	}' 50) && !FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x55'  		0x8b  	}' 50))  		throw new Exception ("could not find start of GetString(uint)");  	int offset_StringPool__GetString_uint = (int)reader.BaseStream.Position;  	Status ("StringPool::GetString(uint) located at {0:X8}"' offset_StringPool__GetString_uint);  	//search for start of StringPool::GetString(uint' ushort)  	for (reader.BaseStream.Position = xref [1]; (reader.ReadUInt32 () & 0xffffff00) != 0x000cc200; reader.BaseStream.Position -= 5)  		;  	//seek the start of function StringPool::GetString(uint' char)  	while (reader.ReadByte () == 0xcc)  		;  	// allign  	reader.BaseStream.Position -= 1;  	int offset_StringPool__GetString_uint_ushort = (int)reader.BaseStream.Position;  	Status ("StringPool::GetString(uint' ushort) located at {0:X8}"' offset_StringPool__GetString_uint_ushort);  	//search for xrefs to function StringPool::GetString(uint)  	xref = FindCalls (offset_StringPool__GetString_uint' 1);  	if (xref.Length != 1)  		throw new Exception ("failed to find references to StringPool::GetString(uint)");  	//search for start of function StringPool::GetBSTR(uint)  	reader.BaseStream.Position -= 100;  	// should be enough  	if (!FindAoBInFile (reader' (int)reader.BaseStream.Position' new byte[] {  		0xb8'  		0xaa'  		0xaa'  		0xaa'  		0x00  	}))  		for (reader.BaseStream.Position = xref [0]; (reader.ReadUInt32 () & 0xff00ff00) != 0x0000c200; reader.BaseStream.Position -= 5)  			;  	//seek the start of function StringPool::GetString(uint' char)  	while (reader.ReadByte () == 0xcc)  		;  	// allign  	reader.BaseStream.Position -= 1;  	int offset_StringPool__GetBSTR_uint = (int)reader.BaseStream.Position;  	Status ("StringPool::GetBSTR(uint) located at {0:X8}"' offset_StringPool__GetBSTR_uint);  	//search for xrefs to function StringPool::GetString(uint' ushort)  	xref = FindCalls (offset_StringPool__GetString_uint_ushort' 1);  	if (xref.Length != 1)  		throw new Exception ("failed to find references to StringPool::GetString(uint' ushort)");  	//search for start of function StringPool::GetStringW(uint)  	if (!FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x51'  		0x8b  	}' 50) && !FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x55'  		0x8b  	}' 50))  		throw new Exception ("could not find start of GetStringW(uint)");  	int offset_StringPool__GetStringW_uint = (int)reader.BaseStream.Position;  	Status ("StringPool::GetStringW(uint) located at {0:X8}"' offset_StringPool__GetStringW_uint);  	ms_nSize = GetIntFromOffset (offset_StringPool__ms_aKey + 16 + 4);  	Status ("Amount of strings: {0}"' ms_nSize);  	if (MessageBox.Show ("Scan for references to strings in the client? This can take a while."' "Warning"' MessageBoxButtons.YesNo' MessageBoxIcon.Warning) == DialogResult.Yes) {  		Status ("Searching for references to GetString' GetStringW' and GetBSTR");  		List<int> GetStringCalls = new List<int> ();  		List<int> GetStringWCalls = new List<int> ();  		List<int> GetBSTRCalls = new List<int> ();  		for (reader.BaseStream.Position = 0; reader.BaseStream.Position < reader.BaseStream.Length;) {  			//int lol = (int)((float)reader.BaseStream.Position / reader.BaseStream.Length * 100);  			//if (lol > MainForm.toolStripProgressBar1.Value)  			//{  			//    MainForm.Invoke(() => MainForm.toolStripProgressBar1.Value = lol);  			//    MainForm.Invoke(() => MainForm.Update());  			//} too expensive  			if (reader.ReadByte () != 0xE8)  				// call  				continue;  			int offset = reader.ReadInt32 ();  			if (reader.BaseStream.Position + offset == offset_StringPool__GetString_uint)  				GetStringCalls.Add ((int)reader.BaseStream.Position - 5);  			else if (reader.BaseStream.Position + offset == offset_StringPool__GetStringW_uint)  				GetStringWCalls.Add ((int)reader.BaseStream.Position - 5);  			else if (reader.BaseStream.Position + offset == offset_StringPool__GetBSTR_uint)  				GetBSTRCalls.Add ((int)reader.BaseStream.Position - 5);  			else  				reader.BaseStream.Position -= 4;  		}  		List<int> GetStringFail = new List<int> ();  		foreach (int addr in GetStringCalls) {  			reader.BaseStream.Position = addr;  			reader.BaseStream.Position -= 2;  			if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  			 {  				GetStringFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 7;  			if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  			 {  				GetStringFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 2;  			if (reader.ReadByte () != 0x50)// push eax  			 {  				GetStringFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 6;  			if (reader.ReadByte () != 0x68)// push dword  			 {  				GetStringFail.Add (addr);  				continue;  			}  			int idx = reader.ReadInt32 ();  			if (idx > ms_nSize - 1)  				GetStringFail.Add (addr);  			else  				GetString.Add (addr' idx);  		}  		List<int> GetStringWFail = new List<int> ();  		foreach (int addr in GetStringWCalls) {  			reader.BaseStream.Position = addr;  			reader.BaseStream.Position -= 2;  			if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 7;  			if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 2;  			if (reader.ReadByte () != 0x50)// push eax  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 6;  			if (reader.ReadByte () != 0x68)// push dword  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			int idx = reader.ReadInt32 ();  			if (idx > ms_nSize - 1)  				GetStringWFail.Add (addr);  			else  				GetStringW.Add (addr' idx);  		}  		List<int> GetBSTRFail = new List<int> ();  		foreach (int addr in GetBSTRCalls) {  			reader.BaseStream.Position = addr;  			reader.BaseStream.Position -= 2;  			if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 7;  			if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 2;  			if (reader.ReadByte () != 0x50)// push eax  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 6;  			if (reader.ReadByte () != 0x68)// push dword  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			int idx = reader.ReadInt32 ();  			if (idx > ms_nSize - 1)  				GetBSTRFail.Add (addr);  			else  				GetBSTR.Add (addr' idx);  		}  		Status ("Failed to find index of {0} references"' GetStringFail.Count + GetStringWFail.Count + GetBSTRFail.Count);  	}  	Status ("Successfully found index of {0} references"' GetString.Count + GetBSTR.Count + GetStringW.Count);  	Status ("Decoding strings");  	for (int index = 0; index < ms_nSize; ++index)  		if (index != -1 && index <= 0xffff)  			Strings.Add (index' StringPoolDecode (index));  	Status ("Populating table");  	foreach (var s in Strings)  		MainForm.Invoke (() => MainForm.dataTable.Rows.Add (s.Key' s.Value' string.Empty));  	foreach (var a in GetString)  		MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetString")));  	foreach (var a in GetBSTR)  		MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetBSTR")));  	foreach (var a in GetStringW)  		MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetStringW")));  }  else if (StringDecodeMethod == 1)// StringDecoder   {  	MainForm.Invoke (() => MainForm.Text += " [StringDecoder]");  	int type = 0;  	int name = 0;  	int offset = 0;  	//search for CStringDecoder::DelayedLoad' which contains the resource type and name  	if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00'  		0x89'  		0x45'  		0xF4'  		0x6A'  		0xAA'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x8B'  		0x4D'  		0xF4'  		0x51'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 12;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 1;  		name = reader.ReadInt32 ();  	}  	else if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00'  		0x6A'  		0xAA'  		0x8B'  		0xF8'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x57'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 9;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 3;  		name = reader.ReadInt32 ();  	}  	else if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0xAA'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 1;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 1;  		name = reader.ReadInt32 ();  	}  	else  		throw new Exception ("Failed to determine type and name of resource.");  	//search for start of function CStringDecoder::DelayedLoad()  	reader.BaseStream.Position -= 50;  	// should be enough  	FindAoBInFile (reader' (int)reader.BaseStream.Position' new byte[] {  		0x55'  		0x8B'  		0xEC'  		0x83'  		0xEC'  		0x10  	});  	int offset_CStringDecoder__DelayedLoad = (int)reader.BaseStream.Position;  	for (reader.BaseStream.Position = 0; reader.BaseStream.Position < reader.BaseStream.Length;) {  		if (reader.ReadByte () != 0xE8)  			// call  			continue;  		int offse = reader.ReadInt32 ();  		if (reader.BaseStream.Position + offse == offset_CStringDecoder__DelayedLoad) {  			Status ("{0:X8} reference to offset_CStringDecoder__DelayedLoad = {1:X8}"' reader.BaseStream.Position - 5' offse);  			break;  		}  	}  	ImageResourceDirectory tier1 = (ImageResourceDirectory)root.GetEntry (type).Entry;  	ImageResourceDirectory tier2 = (ImageResourceDirectory)tier1.GetEntry (name).Entry;  	rsrcStringDataEntry = (ImageResourceDataEntry)tier2.Entrys [0].Entry;  	rsrcStringDataPosition = rsrcPointerToRawData + (rsrcStringDataEntry.OffsetToData - rsrcVirtualAddress);  	m_nCount = GetWordFromIndex (0);  	Status ("Amount of strings: {0}"' m_nCount);  	for (int i = 1; i < m_nCount; ++i)  		MainForm.Invoke (() => MainForm.dataTable.Rows.Add (i' StringDecoderDecode (i)' string.Format ("{0:X8}"' rsrcStringDataPosition + i * 4)));  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: if (StringDecodeMethod == 0)// StringPool   {  	MainForm.Invoke (() => MainForm.Text += " [StringPool]");  	int offset_StringPool__ms_aKey = (int)reader.BaseStream.Position;  	Status ("StringPool::ms_aKey located at {0:X8}"' offset_StringPool__ms_aKey);  	int keyRef = 0;  	// Only GetString references ms_aKey  	byte[] bytes = new byte[5];  	bytes [0] = 0x68;  	// push offset  	Buffer.BlockCopy (BitConverter.GetBytes (ImageBase + offset_StringPool__ms_aKey)' 0' bytes' 1' 4);  	if (FindAoBInFile (reader' 0' bytes))  		keyRef = (int)reader.BaseStream.Position;  	reader.BaseStream.Position = keyRef;  	while (true) {  		byte[] asdf = reader.ReadBytes (5);  		if (asdf [4] == 0xc3)// retn  		 {  			bool die = true;  			foreach (byte b in asdf)  				if (b == 0xe8)// call  				 {  					die = false;  					break;  				}  			if (die)  				break;  		}  		reader.BaseStream.Position -= 6;  	}  	while (reader.ReadByte () == 0xcc)  		;  	// allign  	reader.BaseStream.Position -= 1;  	int offset_StringPool__GetString_uint_char = (int)reader.BaseStream.Position;  	Status ("StringPool::GetString(uint' char) located at {0:X8}"' offset_StringPool__GetString_uint_char);  	//search for StringPool::offset_ms_aString  	if (FindAoBInFile (reader' keyRef - 100' new byte[] {  		0x8b'  		0x0c  	}' 100))  		reader.BaseStream.Position += 3;  	else if (FindAoBInFile (reader' keyRef - 100' new byte[] {  		0x8b'  		0x86  	}' 100))  		reader.BaseStream.Position += 2;  	else  		throw new Exception ("could not find start of StringPool::offset_ms_aString");  	offset_StringPool__ms_aString = reader.ReadInt32 () - ImageBase;  	Status ("StringPool::ms_aString located at {0:X8}"' offset_StringPool__ms_aString);  	//search for xrefs to function StringPool::GetString(uint' char)   	int[] xref = FindCalls (offset_StringPool__GetString_uint_char' 2);  	if (xref.Length != 2)  		throw new Exception ("failed to find references to StringPool::GetString(uint' char)");  	//search for start of StringPool::GetString(uint)  	if (!FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x51'  		0x8b  	}' 50) && !FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x55'  		0x8b  	}' 50))  		throw new Exception ("could not find start of GetString(uint)");  	int offset_StringPool__GetString_uint = (int)reader.BaseStream.Position;  	Status ("StringPool::GetString(uint) located at {0:X8}"' offset_StringPool__GetString_uint);  	//search for start of StringPool::GetString(uint' ushort)  	for (reader.BaseStream.Position = xref [1]; (reader.ReadUInt32 () & 0xffffff00) != 0x000cc200; reader.BaseStream.Position -= 5)  		;  	//seek the start of function StringPool::GetString(uint' char)  	while (reader.ReadByte () == 0xcc)  		;  	// allign  	reader.BaseStream.Position -= 1;  	int offset_StringPool__GetString_uint_ushort = (int)reader.BaseStream.Position;  	Status ("StringPool::GetString(uint' ushort) located at {0:X8}"' offset_StringPool__GetString_uint_ushort);  	//search for xrefs to function StringPool::GetString(uint)  	xref = FindCalls (offset_StringPool__GetString_uint' 1);  	if (xref.Length != 1)  		throw new Exception ("failed to find references to StringPool::GetString(uint)");  	//search for start of function StringPool::GetBSTR(uint)  	reader.BaseStream.Position -= 100;  	// should be enough  	if (!FindAoBInFile (reader' (int)reader.BaseStream.Position' new byte[] {  		0xb8'  		0xaa'  		0xaa'  		0xaa'  		0x00  	}))  		for (reader.BaseStream.Position = xref [0]; (reader.ReadUInt32 () & 0xff00ff00) != 0x0000c200; reader.BaseStream.Position -= 5)  			;  	//seek the start of function StringPool::GetString(uint' char)  	while (reader.ReadByte () == 0xcc)  		;  	// allign  	reader.BaseStream.Position -= 1;  	int offset_StringPool__GetBSTR_uint = (int)reader.BaseStream.Position;  	Status ("StringPool::GetBSTR(uint) located at {0:X8}"' offset_StringPool__GetBSTR_uint);  	//search for xrefs to function StringPool::GetString(uint' ushort)  	xref = FindCalls (offset_StringPool__GetString_uint_ushort' 1);  	if (xref.Length != 1)  		throw new Exception ("failed to find references to StringPool::GetString(uint' ushort)");  	//search for start of function StringPool::GetStringW(uint)  	if (!FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x51'  		0x8b  	}' 50) && !FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x55'  		0x8b  	}' 50))  		throw new Exception ("could not find start of GetStringW(uint)");  	int offset_StringPool__GetStringW_uint = (int)reader.BaseStream.Position;  	Status ("StringPool::GetStringW(uint) located at {0:X8}"' offset_StringPool__GetStringW_uint);  	ms_nSize = GetIntFromOffset (offset_StringPool__ms_aKey + 16 + 4);  	Status ("Amount of strings: {0}"' ms_nSize);  	if (MessageBox.Show ("Scan for references to strings in the client? This can take a while."' "Warning"' MessageBoxButtons.YesNo' MessageBoxIcon.Warning) == DialogResult.Yes) {  		Status ("Searching for references to GetString' GetStringW' and GetBSTR");  		List<int> GetStringCalls = new List<int> ();  		List<int> GetStringWCalls = new List<int> ();  		List<int> GetBSTRCalls = new List<int> ();  		for (reader.BaseStream.Position = 0; reader.BaseStream.Position < reader.BaseStream.Length;) {  			//int lol = (int)((float)reader.BaseStream.Position / reader.BaseStream.Length * 100);  			//if (lol > MainForm.toolStripProgressBar1.Value)  			//{  			//    MainForm.Invoke(() => MainForm.toolStripProgressBar1.Value = lol);  			//    MainForm.Invoke(() => MainForm.Update());  			//} too expensive  			if (reader.ReadByte () != 0xE8)  				// call  				continue;  			int offset = reader.ReadInt32 ();  			if (reader.BaseStream.Position + offset == offset_StringPool__GetString_uint)  				GetStringCalls.Add ((int)reader.BaseStream.Position - 5);  			else if (reader.BaseStream.Position + offset == offset_StringPool__GetStringW_uint)  				GetStringWCalls.Add ((int)reader.BaseStream.Position - 5);  			else if (reader.BaseStream.Position + offset == offset_StringPool__GetBSTR_uint)  				GetBSTRCalls.Add ((int)reader.BaseStream.Position - 5);  			else  				reader.BaseStream.Position -= 4;  		}  		List<int> GetStringFail = new List<int> ();  		foreach (int addr in GetStringCalls) {  			reader.BaseStream.Position = addr;  			reader.BaseStream.Position -= 2;  			if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  			 {  				GetStringFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 7;  			if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  			 {  				GetStringFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 2;  			if (reader.ReadByte () != 0x50)// push eax  			 {  				GetStringFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 6;  			if (reader.ReadByte () != 0x68)// push dword  			 {  				GetStringFail.Add (addr);  				continue;  			}  			int idx = reader.ReadInt32 ();  			if (idx > ms_nSize - 1)  				GetStringFail.Add (addr);  			else  				GetString.Add (addr' idx);  		}  		List<int> GetStringWFail = new List<int> ();  		foreach (int addr in GetStringWCalls) {  			reader.BaseStream.Position = addr;  			reader.BaseStream.Position -= 2;  			if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 7;  			if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 2;  			if (reader.ReadByte () != 0x50)// push eax  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 6;  			if (reader.ReadByte () != 0x68)// push dword  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			int idx = reader.ReadInt32 ();  			if (idx > ms_nSize - 1)  				GetStringWFail.Add (addr);  			else  				GetStringW.Add (addr' idx);  		}  		List<int> GetBSTRFail = new List<int> ();  		foreach (int addr in GetBSTRCalls) {  			reader.BaseStream.Position = addr;  			reader.BaseStream.Position -= 2;  			if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 7;  			if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 2;  			if (reader.ReadByte () != 0x50)// push eax  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 6;  			if (reader.ReadByte () != 0x68)// push dword  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			int idx = reader.ReadInt32 ();  			if (idx > ms_nSize - 1)  				GetBSTRFail.Add (addr);  			else  				GetBSTR.Add (addr' idx);  		}  		Status ("Failed to find index of {0} references"' GetStringFail.Count + GetStringWFail.Count + GetBSTRFail.Count);  	}  	Status ("Successfully found index of {0} references"' GetString.Count + GetBSTR.Count + GetStringW.Count);  	Status ("Decoding strings");  	for (int index = 0; index < ms_nSize; ++index)  		if (index != -1 && index <= 0xffff)  			Strings.Add (index' StringPoolDecode (index));  	Status ("Populating table");  	foreach (var s in Strings)  		MainForm.Invoke (() => MainForm.dataTable.Rows.Add (s.Key' s.Value' string.Empty));  	foreach (var a in GetString)  		MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetString")));  	foreach (var a in GetBSTR)  		MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetBSTR")));  	foreach (var a in GetStringW)  		MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetStringW")));  }  else if (StringDecodeMethod == 1)// StringDecoder   {  	MainForm.Invoke (() => MainForm.Text += " [StringDecoder]");  	int type = 0;  	int name = 0;  	int offset = 0;  	//search for CStringDecoder::DelayedLoad' which contains the resource type and name  	if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00'  		0x89'  		0x45'  		0xF4'  		0x6A'  		0xAA'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x8B'  		0x4D'  		0xF4'  		0x51'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 12;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 1;  		name = reader.ReadInt32 ();  	}  	else if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00'  		0x6A'  		0xAA'  		0x8B'  		0xF8'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x57'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 9;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 3;  		name = reader.ReadInt32 ();  	}  	else if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0xAA'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 1;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 1;  		name = reader.ReadInt32 ();  	}  	else  		throw new Exception ("Failed to determine type and name of resource.");  	//search for start of function CStringDecoder::DelayedLoad()  	reader.BaseStream.Position -= 50;  	// should be enough  	FindAoBInFile (reader' (int)reader.BaseStream.Position' new byte[] {  		0x55'  		0x8B'  		0xEC'  		0x83'  		0xEC'  		0x10  	});  	int offset_CStringDecoder__DelayedLoad = (int)reader.BaseStream.Position;  	for (reader.BaseStream.Position = 0; reader.BaseStream.Position < reader.BaseStream.Length;) {  		if (reader.ReadByte () != 0xE8)  			// call  			continue;  		int offse = reader.ReadInt32 ();  		if (reader.BaseStream.Position + offse == offset_CStringDecoder__DelayedLoad) {  			Status ("{0:X8} reference to offset_CStringDecoder__DelayedLoad = {1:X8}"' reader.BaseStream.Position - 5' offse);  			break;  		}  	}  	ImageResourceDirectory tier1 = (ImageResourceDirectory)root.GetEntry (type).Entry;  	ImageResourceDirectory tier2 = (ImageResourceDirectory)tier1.GetEntry (name).Entry;  	rsrcStringDataEntry = (ImageResourceDataEntry)tier2.Entrys [0].Entry;  	rsrcStringDataPosition = rsrcPointerToRawData + (rsrcStringDataEntry.OffsetToData - rsrcVirtualAddress);  	m_nCount = GetWordFromIndex (0);  	Status ("Amount of strings: {0}"' m_nCount);  	for (int i = 1; i < m_nCount; ++i)  		MainForm.Invoke (() => MainForm.dataTable.Rows.Add (i' StringDecoderDecode (i)' string.Format ("{0:X8}"' rsrcStringDataPosition + i * 4)));  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: if (StringDecodeMethod == 0)// StringPool   {  	MainForm.Invoke (() => MainForm.Text += " [StringPool]");  	int offset_StringPool__ms_aKey = (int)reader.BaseStream.Position;  	Status ("StringPool::ms_aKey located at {0:X8}"' offset_StringPool__ms_aKey);  	int keyRef = 0;  	// Only GetString references ms_aKey  	byte[] bytes = new byte[5];  	bytes [0] = 0x68;  	// push offset  	Buffer.BlockCopy (BitConverter.GetBytes (ImageBase + offset_StringPool__ms_aKey)' 0' bytes' 1' 4);  	if (FindAoBInFile (reader' 0' bytes))  		keyRef = (int)reader.BaseStream.Position;  	reader.BaseStream.Position = keyRef;  	while (true) {  		byte[] asdf = reader.ReadBytes (5);  		if (asdf [4] == 0xc3)// retn  		 {  			bool die = true;  			foreach (byte b in asdf)  				if (b == 0xe8)// call  				 {  					die = false;  					break;  				}  			if (die)  				break;  		}  		reader.BaseStream.Position -= 6;  	}  	while (reader.ReadByte () == 0xcc)  		;  	// allign  	reader.BaseStream.Position -= 1;  	int offset_StringPool__GetString_uint_char = (int)reader.BaseStream.Position;  	Status ("StringPool::GetString(uint' char) located at {0:X8}"' offset_StringPool__GetString_uint_char);  	//search for StringPool::offset_ms_aString  	if (FindAoBInFile (reader' keyRef - 100' new byte[] {  		0x8b'  		0x0c  	}' 100))  		reader.BaseStream.Position += 3;  	else if (FindAoBInFile (reader' keyRef - 100' new byte[] {  		0x8b'  		0x86  	}' 100))  		reader.BaseStream.Position += 2;  	else  		throw new Exception ("could not find start of StringPool::offset_ms_aString");  	offset_StringPool__ms_aString = reader.ReadInt32 () - ImageBase;  	Status ("StringPool::ms_aString located at {0:X8}"' offset_StringPool__ms_aString);  	//search for xrefs to function StringPool::GetString(uint' char)   	int[] xref = FindCalls (offset_StringPool__GetString_uint_char' 2);  	if (xref.Length != 2)  		throw new Exception ("failed to find references to StringPool::GetString(uint' char)");  	//search for start of StringPool::GetString(uint)  	if (!FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x51'  		0x8b  	}' 50) && !FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x55'  		0x8b  	}' 50))  		throw new Exception ("could not find start of GetString(uint)");  	int offset_StringPool__GetString_uint = (int)reader.BaseStream.Position;  	Status ("StringPool::GetString(uint) located at {0:X8}"' offset_StringPool__GetString_uint);  	//search for start of StringPool::GetString(uint' ushort)  	for (reader.BaseStream.Position = xref [1]; (reader.ReadUInt32 () & 0xffffff00) != 0x000cc200; reader.BaseStream.Position -= 5)  		;  	//seek the start of function StringPool::GetString(uint' char)  	while (reader.ReadByte () == 0xcc)  		;  	// allign  	reader.BaseStream.Position -= 1;  	int offset_StringPool__GetString_uint_ushort = (int)reader.BaseStream.Position;  	Status ("StringPool::GetString(uint' ushort) located at {0:X8}"' offset_StringPool__GetString_uint_ushort);  	//search for xrefs to function StringPool::GetString(uint)  	xref = FindCalls (offset_StringPool__GetString_uint' 1);  	if (xref.Length != 1)  		throw new Exception ("failed to find references to StringPool::GetString(uint)");  	//search for start of function StringPool::GetBSTR(uint)  	reader.BaseStream.Position -= 100;  	// should be enough  	if (!FindAoBInFile (reader' (int)reader.BaseStream.Position' new byte[] {  		0xb8'  		0xaa'  		0xaa'  		0xaa'  		0x00  	}))  		for (reader.BaseStream.Position = xref [0]; (reader.ReadUInt32 () & 0xff00ff00) != 0x0000c200; reader.BaseStream.Position -= 5)  			;  	//seek the start of function StringPool::GetString(uint' char)  	while (reader.ReadByte () == 0xcc)  		;  	// allign  	reader.BaseStream.Position -= 1;  	int offset_StringPool__GetBSTR_uint = (int)reader.BaseStream.Position;  	Status ("StringPool::GetBSTR(uint) located at {0:X8}"' offset_StringPool__GetBSTR_uint);  	//search for xrefs to function StringPool::GetString(uint' ushort)  	xref = FindCalls (offset_StringPool__GetString_uint_ushort' 1);  	if (xref.Length != 1)  		throw new Exception ("failed to find references to StringPool::GetString(uint' ushort)");  	//search for start of function StringPool::GetStringW(uint)  	if (!FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x51'  		0x8b  	}' 50) && !FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x55'  		0x8b  	}' 50))  		throw new Exception ("could not find start of GetStringW(uint)");  	int offset_StringPool__GetStringW_uint = (int)reader.BaseStream.Position;  	Status ("StringPool::GetStringW(uint) located at {0:X8}"' offset_StringPool__GetStringW_uint);  	ms_nSize = GetIntFromOffset (offset_StringPool__ms_aKey + 16 + 4);  	Status ("Amount of strings: {0}"' ms_nSize);  	if (MessageBox.Show ("Scan for references to strings in the client? This can take a while."' "Warning"' MessageBoxButtons.YesNo' MessageBoxIcon.Warning) == DialogResult.Yes) {  		Status ("Searching for references to GetString' GetStringW' and GetBSTR");  		List<int> GetStringCalls = new List<int> ();  		List<int> GetStringWCalls = new List<int> ();  		List<int> GetBSTRCalls = new List<int> ();  		for (reader.BaseStream.Position = 0; reader.BaseStream.Position < reader.BaseStream.Length;) {  			//int lol = (int)((float)reader.BaseStream.Position / reader.BaseStream.Length * 100);  			//if (lol > MainForm.toolStripProgressBar1.Value)  			//{  			//    MainForm.Invoke(() => MainForm.toolStripProgressBar1.Value = lol);  			//    MainForm.Invoke(() => MainForm.Update());  			//} too expensive  			if (reader.ReadByte () != 0xE8)  				// call  				continue;  			int offset = reader.ReadInt32 ();  			if (reader.BaseStream.Position + offset == offset_StringPool__GetString_uint)  				GetStringCalls.Add ((int)reader.BaseStream.Position - 5);  			else if (reader.BaseStream.Position + offset == offset_StringPool__GetStringW_uint)  				GetStringWCalls.Add ((int)reader.BaseStream.Position - 5);  			else if (reader.BaseStream.Position + offset == offset_StringPool__GetBSTR_uint)  				GetBSTRCalls.Add ((int)reader.BaseStream.Position - 5);  			else  				reader.BaseStream.Position -= 4;  		}  		List<int> GetStringFail = new List<int> ();  		foreach (int addr in GetStringCalls) {  			reader.BaseStream.Position = addr;  			reader.BaseStream.Position -= 2;  			if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  			 {  				GetStringFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 7;  			if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  			 {  				GetStringFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 2;  			if (reader.ReadByte () != 0x50)// push eax  			 {  				GetStringFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 6;  			if (reader.ReadByte () != 0x68)// push dword  			 {  				GetStringFail.Add (addr);  				continue;  			}  			int idx = reader.ReadInt32 ();  			if (idx > ms_nSize - 1)  				GetStringFail.Add (addr);  			else  				GetString.Add (addr' idx);  		}  		List<int> GetStringWFail = new List<int> ();  		foreach (int addr in GetStringWCalls) {  			reader.BaseStream.Position = addr;  			reader.BaseStream.Position -= 2;  			if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 7;  			if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 2;  			if (reader.ReadByte () != 0x50)// push eax  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 6;  			if (reader.ReadByte () != 0x68)// push dword  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			int idx = reader.ReadInt32 ();  			if (idx > ms_nSize - 1)  				GetStringWFail.Add (addr);  			else  				GetStringW.Add (addr' idx);  		}  		List<int> GetBSTRFail = new List<int> ();  		foreach (int addr in GetBSTRCalls) {  			reader.BaseStream.Position = addr;  			reader.BaseStream.Position -= 2;  			if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 7;  			if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 2;  			if (reader.ReadByte () != 0x50)// push eax  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 6;  			if (reader.ReadByte () != 0x68)// push dword  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			int idx = reader.ReadInt32 ();  			if (idx > ms_nSize - 1)  				GetBSTRFail.Add (addr);  			else  				GetBSTR.Add (addr' idx);  		}  		Status ("Failed to find index of {0} references"' GetStringFail.Count + GetStringWFail.Count + GetBSTRFail.Count);  	}  	Status ("Successfully found index of {0} references"' GetString.Count + GetBSTR.Count + GetStringW.Count);  	Status ("Decoding strings");  	for (int index = 0; index < ms_nSize; ++index)  		if (index != -1 && index <= 0xffff)  			Strings.Add (index' StringPoolDecode (index));  	Status ("Populating table");  	foreach (var s in Strings)  		MainForm.Invoke (() => MainForm.dataTable.Rows.Add (s.Key' s.Value' string.Empty));  	foreach (var a in GetString)  		MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetString")));  	foreach (var a in GetBSTR)  		MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetBSTR")));  	foreach (var a in GetStringW)  		MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetStringW")));  }  else if (StringDecodeMethod == 1)// StringDecoder   {  	MainForm.Invoke (() => MainForm.Text += " [StringDecoder]");  	int type = 0;  	int name = 0;  	int offset = 0;  	//search for CStringDecoder::DelayedLoad' which contains the resource type and name  	if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00'  		0x89'  		0x45'  		0xF4'  		0x6A'  		0xAA'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x8B'  		0x4D'  		0xF4'  		0x51'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 12;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 1;  		name = reader.ReadInt32 ();  	}  	else if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00'  		0x6A'  		0xAA'  		0x8B'  		0xF8'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x57'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 9;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 3;  		name = reader.ReadInt32 ();  	}  	else if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0xAA'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 1;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 1;  		name = reader.ReadInt32 ();  	}  	else  		throw new Exception ("Failed to determine type and name of resource.");  	//search for start of function CStringDecoder::DelayedLoad()  	reader.BaseStream.Position -= 50;  	// should be enough  	FindAoBInFile (reader' (int)reader.BaseStream.Position' new byte[] {  		0x55'  		0x8B'  		0xEC'  		0x83'  		0xEC'  		0x10  	});  	int offset_CStringDecoder__DelayedLoad = (int)reader.BaseStream.Position;  	for (reader.BaseStream.Position = 0; reader.BaseStream.Position < reader.BaseStream.Length;) {  		if (reader.ReadByte () != 0xE8)  			// call  			continue;  		int offse = reader.ReadInt32 ();  		if (reader.BaseStream.Position + offse == offset_CStringDecoder__DelayedLoad) {  			Status ("{0:X8} reference to offset_CStringDecoder__DelayedLoad = {1:X8}"' reader.BaseStream.Position - 5' offse);  			break;  		}  	}  	ImageResourceDirectory tier1 = (ImageResourceDirectory)root.GetEntry (type).Entry;  	ImageResourceDirectory tier2 = (ImageResourceDirectory)tier1.GetEntry (name).Entry;  	rsrcStringDataEntry = (ImageResourceDataEntry)tier2.Entrys [0].Entry;  	rsrcStringDataPosition = rsrcPointerToRawData + (rsrcStringDataEntry.OffsetToData - rsrcVirtualAddress);  	m_nCount = GetWordFromIndex (0);  	Status ("Amount of strings: {0}"' m_nCount);  	for (int i = 1; i < m_nCount; ++i)  		MainForm.Invoke (() => MainForm.dataTable.Rows.Add (i' StringDecoderDecode (i)' string.Format ("{0:X8}"' rsrcStringDataPosition + i * 4)));  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: if (StringDecodeMethod == 0)// StringPool   {  	MainForm.Invoke (() => MainForm.Text += " [StringPool]");  	int offset_StringPool__ms_aKey = (int)reader.BaseStream.Position;  	Status ("StringPool::ms_aKey located at {0:X8}"' offset_StringPool__ms_aKey);  	int keyRef = 0;  	// Only GetString references ms_aKey  	byte[] bytes = new byte[5];  	bytes [0] = 0x68;  	// push offset  	Buffer.BlockCopy (BitConverter.GetBytes (ImageBase + offset_StringPool__ms_aKey)' 0' bytes' 1' 4);  	if (FindAoBInFile (reader' 0' bytes))  		keyRef = (int)reader.BaseStream.Position;  	reader.BaseStream.Position = keyRef;  	while (true) {  		byte[] asdf = reader.ReadBytes (5);  		if (asdf [4] == 0xc3)// retn  		 {  			bool die = true;  			foreach (byte b in asdf)  				if (b == 0xe8)// call  				 {  					die = false;  					break;  				}  			if (die)  				break;  		}  		reader.BaseStream.Position -= 6;  	}  	while (reader.ReadByte () == 0xcc)  		;  	// allign  	reader.BaseStream.Position -= 1;  	int offset_StringPool__GetString_uint_char = (int)reader.BaseStream.Position;  	Status ("StringPool::GetString(uint' char) located at {0:X8}"' offset_StringPool__GetString_uint_char);  	//search for StringPool::offset_ms_aString  	if (FindAoBInFile (reader' keyRef - 100' new byte[] {  		0x8b'  		0x0c  	}' 100))  		reader.BaseStream.Position += 3;  	else if (FindAoBInFile (reader' keyRef - 100' new byte[] {  		0x8b'  		0x86  	}' 100))  		reader.BaseStream.Position += 2;  	else  		throw new Exception ("could not find start of StringPool::offset_ms_aString");  	offset_StringPool__ms_aString = reader.ReadInt32 () - ImageBase;  	Status ("StringPool::ms_aString located at {0:X8}"' offset_StringPool__ms_aString);  	//search for xrefs to function StringPool::GetString(uint' char)   	int[] xref = FindCalls (offset_StringPool__GetString_uint_char' 2);  	if (xref.Length != 2)  		throw new Exception ("failed to find references to StringPool::GetString(uint' char)");  	//search for start of StringPool::GetString(uint)  	if (!FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x51'  		0x8b  	}' 50) && !FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x55'  		0x8b  	}' 50))  		throw new Exception ("could not find start of GetString(uint)");  	int offset_StringPool__GetString_uint = (int)reader.BaseStream.Position;  	Status ("StringPool::GetString(uint) located at {0:X8}"' offset_StringPool__GetString_uint);  	//search for start of StringPool::GetString(uint' ushort)  	for (reader.BaseStream.Position = xref [1]; (reader.ReadUInt32 () & 0xffffff00) != 0x000cc200; reader.BaseStream.Position -= 5)  		;  	//seek the start of function StringPool::GetString(uint' char)  	while (reader.ReadByte () == 0xcc)  		;  	// allign  	reader.BaseStream.Position -= 1;  	int offset_StringPool__GetString_uint_ushort = (int)reader.BaseStream.Position;  	Status ("StringPool::GetString(uint' ushort) located at {0:X8}"' offset_StringPool__GetString_uint_ushort);  	//search for xrefs to function StringPool::GetString(uint)  	xref = FindCalls (offset_StringPool__GetString_uint' 1);  	if (xref.Length != 1)  		throw new Exception ("failed to find references to StringPool::GetString(uint)");  	//search for start of function StringPool::GetBSTR(uint)  	reader.BaseStream.Position -= 100;  	// should be enough  	if (!FindAoBInFile (reader' (int)reader.BaseStream.Position' new byte[] {  		0xb8'  		0xaa'  		0xaa'  		0xaa'  		0x00  	}))  		for (reader.BaseStream.Position = xref [0]; (reader.ReadUInt32 () & 0xff00ff00) != 0x0000c200; reader.BaseStream.Position -= 5)  			;  	//seek the start of function StringPool::GetString(uint' char)  	while (reader.ReadByte () == 0xcc)  		;  	// allign  	reader.BaseStream.Position -= 1;  	int offset_StringPool__GetBSTR_uint = (int)reader.BaseStream.Position;  	Status ("StringPool::GetBSTR(uint) located at {0:X8}"' offset_StringPool__GetBSTR_uint);  	//search for xrefs to function StringPool::GetString(uint' ushort)  	xref = FindCalls (offset_StringPool__GetString_uint_ushort' 1);  	if (xref.Length != 1)  		throw new Exception ("failed to find references to StringPool::GetString(uint' ushort)");  	//search for start of function StringPool::GetStringW(uint)  	if (!FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x51'  		0x8b  	}' 50) && !FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x55'  		0x8b  	}' 50))  		throw new Exception ("could not find start of GetStringW(uint)");  	int offset_StringPool__GetStringW_uint = (int)reader.BaseStream.Position;  	Status ("StringPool::GetStringW(uint) located at {0:X8}"' offset_StringPool__GetStringW_uint);  	ms_nSize = GetIntFromOffset (offset_StringPool__ms_aKey + 16 + 4);  	Status ("Amount of strings: {0}"' ms_nSize);  	if (MessageBox.Show ("Scan for references to strings in the client? This can take a while."' "Warning"' MessageBoxButtons.YesNo' MessageBoxIcon.Warning) == DialogResult.Yes) {  		Status ("Searching for references to GetString' GetStringW' and GetBSTR");  		List<int> GetStringCalls = new List<int> ();  		List<int> GetStringWCalls = new List<int> ();  		List<int> GetBSTRCalls = new List<int> ();  		for (reader.BaseStream.Position = 0; reader.BaseStream.Position < reader.BaseStream.Length;) {  			//int lol = (int)((float)reader.BaseStream.Position / reader.BaseStream.Length * 100);  			//if (lol > MainForm.toolStripProgressBar1.Value)  			//{  			//    MainForm.Invoke(() => MainForm.toolStripProgressBar1.Value = lol);  			//    MainForm.Invoke(() => MainForm.Update());  			//} too expensive  			if (reader.ReadByte () != 0xE8)  				// call  				continue;  			int offset = reader.ReadInt32 ();  			if (reader.BaseStream.Position + offset == offset_StringPool__GetString_uint)  				GetStringCalls.Add ((int)reader.BaseStream.Position - 5);  			else if (reader.BaseStream.Position + offset == offset_StringPool__GetStringW_uint)  				GetStringWCalls.Add ((int)reader.BaseStream.Position - 5);  			else if (reader.BaseStream.Position + offset == offset_StringPool__GetBSTR_uint)  				GetBSTRCalls.Add ((int)reader.BaseStream.Position - 5);  			else  				reader.BaseStream.Position -= 4;  		}  		List<int> GetStringFail = new List<int> ();  		foreach (int addr in GetStringCalls) {  			reader.BaseStream.Position = addr;  			reader.BaseStream.Position -= 2;  			if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  			 {  				GetStringFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 7;  			if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  			 {  				GetStringFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 2;  			if (reader.ReadByte () != 0x50)// push eax  			 {  				GetStringFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 6;  			if (reader.ReadByte () != 0x68)// push dword  			 {  				GetStringFail.Add (addr);  				continue;  			}  			int idx = reader.ReadInt32 ();  			if (idx > ms_nSize - 1)  				GetStringFail.Add (addr);  			else  				GetString.Add (addr' idx);  		}  		List<int> GetStringWFail = new List<int> ();  		foreach (int addr in GetStringWCalls) {  			reader.BaseStream.Position = addr;  			reader.BaseStream.Position -= 2;  			if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 7;  			if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 2;  			if (reader.ReadByte () != 0x50)// push eax  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 6;  			if (reader.ReadByte () != 0x68)// push dword  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			int idx = reader.ReadInt32 ();  			if (idx > ms_nSize - 1)  				GetStringWFail.Add (addr);  			else  				GetStringW.Add (addr' idx);  		}  		List<int> GetBSTRFail = new List<int> ();  		foreach (int addr in GetBSTRCalls) {  			reader.BaseStream.Position = addr;  			reader.BaseStream.Position -= 2;  			if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 7;  			if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 2;  			if (reader.ReadByte () != 0x50)// push eax  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 6;  			if (reader.ReadByte () != 0x68)// push dword  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			int idx = reader.ReadInt32 ();  			if (idx > ms_nSize - 1)  				GetBSTRFail.Add (addr);  			else  				GetBSTR.Add (addr' idx);  		}  		Status ("Failed to find index of {0} references"' GetStringFail.Count + GetStringWFail.Count + GetBSTRFail.Count);  	}  	Status ("Successfully found index of {0} references"' GetString.Count + GetBSTR.Count + GetStringW.Count);  	Status ("Decoding strings");  	for (int index = 0; index < ms_nSize; ++index)  		if (index != -1 && index <= 0xffff)  			Strings.Add (index' StringPoolDecode (index));  	Status ("Populating table");  	foreach (var s in Strings)  		MainForm.Invoke (() => MainForm.dataTable.Rows.Add (s.Key' s.Value' string.Empty));  	foreach (var a in GetString)  		MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetString")));  	foreach (var a in GetBSTR)  		MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetBSTR")));  	foreach (var a in GetStringW)  		MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetStringW")));  }  else if (StringDecodeMethod == 1)// StringDecoder   {  	MainForm.Invoke (() => MainForm.Text += " [StringDecoder]");  	int type = 0;  	int name = 0;  	int offset = 0;  	//search for CStringDecoder::DelayedLoad' which contains the resource type and name  	if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00'  		0x89'  		0x45'  		0xF4'  		0x6A'  		0xAA'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x8B'  		0x4D'  		0xF4'  		0x51'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 12;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 1;  		name = reader.ReadInt32 ();  	}  	else if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00'  		0x6A'  		0xAA'  		0x8B'  		0xF8'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x57'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 9;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 3;  		name = reader.ReadInt32 ();  	}  	else if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0xAA'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 1;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 1;  		name = reader.ReadInt32 ();  	}  	else  		throw new Exception ("Failed to determine type and name of resource.");  	//search for start of function CStringDecoder::DelayedLoad()  	reader.BaseStream.Position -= 50;  	// should be enough  	FindAoBInFile (reader' (int)reader.BaseStream.Position' new byte[] {  		0x55'  		0x8B'  		0xEC'  		0x83'  		0xEC'  		0x10  	});  	int offset_CStringDecoder__DelayedLoad = (int)reader.BaseStream.Position;  	for (reader.BaseStream.Position = 0; reader.BaseStream.Position < reader.BaseStream.Length;) {  		if (reader.ReadByte () != 0xE8)  			// call  			continue;  		int offse = reader.ReadInt32 ();  		if (reader.BaseStream.Position + offse == offset_CStringDecoder__DelayedLoad) {  			Status ("{0:X8} reference to offset_CStringDecoder__DelayedLoad = {1:X8}"' reader.BaseStream.Position - 5' offse);  			break;  		}  	}  	ImageResourceDirectory tier1 = (ImageResourceDirectory)root.GetEntry (type).Entry;  	ImageResourceDirectory tier2 = (ImageResourceDirectory)tier1.GetEntry (name).Entry;  	rsrcStringDataEntry = (ImageResourceDataEntry)tier2.Entrys [0].Entry;  	rsrcStringDataPosition = rsrcPointerToRawData + (rsrcStringDataEntry.OffsetToData - rsrcVirtualAddress);  	m_nCount = GetWordFromIndex (0);  	Status ("Amount of strings: {0}"' m_nCount);  	for (int i = 1; i < m_nCount; ++i)  		MainForm.Invoke (() => MainForm.dataTable.Rows.Add (i' StringDecoderDecode (i)' string.Format ("{0:X8}"' rsrcStringDataPosition + i * 4)));  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: if (StringDecodeMethod == 0)// StringPool   {  	MainForm.Invoke (() => MainForm.Text += " [StringPool]");  	int offset_StringPool__ms_aKey = (int)reader.BaseStream.Position;  	Status ("StringPool::ms_aKey located at {0:X8}"' offset_StringPool__ms_aKey);  	int keyRef = 0;  	// Only GetString references ms_aKey  	byte[] bytes = new byte[5];  	bytes [0] = 0x68;  	// push offset  	Buffer.BlockCopy (BitConverter.GetBytes (ImageBase + offset_StringPool__ms_aKey)' 0' bytes' 1' 4);  	if (FindAoBInFile (reader' 0' bytes))  		keyRef = (int)reader.BaseStream.Position;  	reader.BaseStream.Position = keyRef;  	while (true) {  		byte[] asdf = reader.ReadBytes (5);  		if (asdf [4] == 0xc3)// retn  		 {  			bool die = true;  			foreach (byte b in asdf)  				if (b == 0xe8)// call  				 {  					die = false;  					break;  				}  			if (die)  				break;  		}  		reader.BaseStream.Position -= 6;  	}  	while (reader.ReadByte () == 0xcc)  		;  	// allign  	reader.BaseStream.Position -= 1;  	int offset_StringPool__GetString_uint_char = (int)reader.BaseStream.Position;  	Status ("StringPool::GetString(uint' char) located at {0:X8}"' offset_StringPool__GetString_uint_char);  	//search for StringPool::offset_ms_aString  	if (FindAoBInFile (reader' keyRef - 100' new byte[] {  		0x8b'  		0x0c  	}' 100))  		reader.BaseStream.Position += 3;  	else if (FindAoBInFile (reader' keyRef - 100' new byte[] {  		0x8b'  		0x86  	}' 100))  		reader.BaseStream.Position += 2;  	else  		throw new Exception ("could not find start of StringPool::offset_ms_aString");  	offset_StringPool__ms_aString = reader.ReadInt32 () - ImageBase;  	Status ("StringPool::ms_aString located at {0:X8}"' offset_StringPool__ms_aString);  	//search for xrefs to function StringPool::GetString(uint' char)   	int[] xref = FindCalls (offset_StringPool__GetString_uint_char' 2);  	if (xref.Length != 2)  		throw new Exception ("failed to find references to StringPool::GetString(uint' char)");  	//search for start of StringPool::GetString(uint)  	if (!FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x51'  		0x8b  	}' 50) && !FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x55'  		0x8b  	}' 50))  		throw new Exception ("could not find start of GetString(uint)");  	int offset_StringPool__GetString_uint = (int)reader.BaseStream.Position;  	Status ("StringPool::GetString(uint) located at {0:X8}"' offset_StringPool__GetString_uint);  	//search for start of StringPool::GetString(uint' ushort)  	for (reader.BaseStream.Position = xref [1]; (reader.ReadUInt32 () & 0xffffff00) != 0x000cc200; reader.BaseStream.Position -= 5)  		;  	//seek the start of function StringPool::GetString(uint' char)  	while (reader.ReadByte () == 0xcc)  		;  	// allign  	reader.BaseStream.Position -= 1;  	int offset_StringPool__GetString_uint_ushort = (int)reader.BaseStream.Position;  	Status ("StringPool::GetString(uint' ushort) located at {0:X8}"' offset_StringPool__GetString_uint_ushort);  	//search for xrefs to function StringPool::GetString(uint)  	xref = FindCalls (offset_StringPool__GetString_uint' 1);  	if (xref.Length != 1)  		throw new Exception ("failed to find references to StringPool::GetString(uint)");  	//search for start of function StringPool::GetBSTR(uint)  	reader.BaseStream.Position -= 100;  	// should be enough  	if (!FindAoBInFile (reader' (int)reader.BaseStream.Position' new byte[] {  		0xb8'  		0xaa'  		0xaa'  		0xaa'  		0x00  	}))  		for (reader.BaseStream.Position = xref [0]; (reader.ReadUInt32 () & 0xff00ff00) != 0x0000c200; reader.BaseStream.Position -= 5)  			;  	//seek the start of function StringPool::GetString(uint' char)  	while (reader.ReadByte () == 0xcc)  		;  	// allign  	reader.BaseStream.Position -= 1;  	int offset_StringPool__GetBSTR_uint = (int)reader.BaseStream.Position;  	Status ("StringPool::GetBSTR(uint) located at {0:X8}"' offset_StringPool__GetBSTR_uint);  	//search for xrefs to function StringPool::GetString(uint' ushort)  	xref = FindCalls (offset_StringPool__GetString_uint_ushort' 1);  	if (xref.Length != 1)  		throw new Exception ("failed to find references to StringPool::GetString(uint' ushort)");  	//search for start of function StringPool::GetStringW(uint)  	if (!FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x51'  		0x8b  	}' 50) && !FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x55'  		0x8b  	}' 50))  		throw new Exception ("could not find start of GetStringW(uint)");  	int offset_StringPool__GetStringW_uint = (int)reader.BaseStream.Position;  	Status ("StringPool::GetStringW(uint) located at {0:X8}"' offset_StringPool__GetStringW_uint);  	ms_nSize = GetIntFromOffset (offset_StringPool__ms_aKey + 16 + 4);  	Status ("Amount of strings: {0}"' ms_nSize);  	if (MessageBox.Show ("Scan for references to strings in the client? This can take a while."' "Warning"' MessageBoxButtons.YesNo' MessageBoxIcon.Warning) == DialogResult.Yes) {  		Status ("Searching for references to GetString' GetStringW' and GetBSTR");  		List<int> GetStringCalls = new List<int> ();  		List<int> GetStringWCalls = new List<int> ();  		List<int> GetBSTRCalls = new List<int> ();  		for (reader.BaseStream.Position = 0; reader.BaseStream.Position < reader.BaseStream.Length;) {  			//int lol = (int)((float)reader.BaseStream.Position / reader.BaseStream.Length * 100);  			//if (lol > MainForm.toolStripProgressBar1.Value)  			//{  			//    MainForm.Invoke(() => MainForm.toolStripProgressBar1.Value = lol);  			//    MainForm.Invoke(() => MainForm.Update());  			//} too expensive  			if (reader.ReadByte () != 0xE8)  				// call  				continue;  			int offset = reader.ReadInt32 ();  			if (reader.BaseStream.Position + offset == offset_StringPool__GetString_uint)  				GetStringCalls.Add ((int)reader.BaseStream.Position - 5);  			else if (reader.BaseStream.Position + offset == offset_StringPool__GetStringW_uint)  				GetStringWCalls.Add ((int)reader.BaseStream.Position - 5);  			else if (reader.BaseStream.Position + offset == offset_StringPool__GetBSTR_uint)  				GetBSTRCalls.Add ((int)reader.BaseStream.Position - 5);  			else  				reader.BaseStream.Position -= 4;  		}  		List<int> GetStringFail = new List<int> ();  		foreach (int addr in GetStringCalls) {  			reader.BaseStream.Position = addr;  			reader.BaseStream.Position -= 2;  			if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  			 {  				GetStringFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 7;  			if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  			 {  				GetStringFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 2;  			if (reader.ReadByte () != 0x50)// push eax  			 {  				GetStringFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 6;  			if (reader.ReadByte () != 0x68)// push dword  			 {  				GetStringFail.Add (addr);  				continue;  			}  			int idx = reader.ReadInt32 ();  			if (idx > ms_nSize - 1)  				GetStringFail.Add (addr);  			else  				GetString.Add (addr' idx);  		}  		List<int> GetStringWFail = new List<int> ();  		foreach (int addr in GetStringWCalls) {  			reader.BaseStream.Position = addr;  			reader.BaseStream.Position -= 2;  			if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 7;  			if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 2;  			if (reader.ReadByte () != 0x50)// push eax  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 6;  			if (reader.ReadByte () != 0x68)// push dword  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			int idx = reader.ReadInt32 ();  			if (idx > ms_nSize - 1)  				GetStringWFail.Add (addr);  			else  				GetStringW.Add (addr' idx);  		}  		List<int> GetBSTRFail = new List<int> ();  		foreach (int addr in GetBSTRCalls) {  			reader.BaseStream.Position = addr;  			reader.BaseStream.Position -= 2;  			if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 7;  			if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 2;  			if (reader.ReadByte () != 0x50)// push eax  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 6;  			if (reader.ReadByte () != 0x68)// push dword  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			int idx = reader.ReadInt32 ();  			if (idx > ms_nSize - 1)  				GetBSTRFail.Add (addr);  			else  				GetBSTR.Add (addr' idx);  		}  		Status ("Failed to find index of {0} references"' GetStringFail.Count + GetStringWFail.Count + GetBSTRFail.Count);  	}  	Status ("Successfully found index of {0} references"' GetString.Count + GetBSTR.Count + GetStringW.Count);  	Status ("Decoding strings");  	for (int index = 0; index < ms_nSize; ++index)  		if (index != -1 && index <= 0xffff)  			Strings.Add (index' StringPoolDecode (index));  	Status ("Populating table");  	foreach (var s in Strings)  		MainForm.Invoke (() => MainForm.dataTable.Rows.Add (s.Key' s.Value' string.Empty));  	foreach (var a in GetString)  		MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetString")));  	foreach (var a in GetBSTR)  		MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetBSTR")));  	foreach (var a in GetStringW)  		MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetStringW")));  }  else if (StringDecodeMethod == 1)// StringDecoder   {  	MainForm.Invoke (() => MainForm.Text += " [StringDecoder]");  	int type = 0;  	int name = 0;  	int offset = 0;  	//search for CStringDecoder::DelayedLoad' which contains the resource type and name  	if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00'  		0x89'  		0x45'  		0xF4'  		0x6A'  		0xAA'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x8B'  		0x4D'  		0xF4'  		0x51'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 12;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 1;  		name = reader.ReadInt32 ();  	}  	else if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00'  		0x6A'  		0xAA'  		0x8B'  		0xF8'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x57'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 9;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 3;  		name = reader.ReadInt32 ();  	}  	else if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0xAA'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 1;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 1;  		name = reader.ReadInt32 ();  	}  	else  		throw new Exception ("Failed to determine type and name of resource.");  	//search for start of function CStringDecoder::DelayedLoad()  	reader.BaseStream.Position -= 50;  	// should be enough  	FindAoBInFile (reader' (int)reader.BaseStream.Position' new byte[] {  		0x55'  		0x8B'  		0xEC'  		0x83'  		0xEC'  		0x10  	});  	int offset_CStringDecoder__DelayedLoad = (int)reader.BaseStream.Position;  	for (reader.BaseStream.Position = 0; reader.BaseStream.Position < reader.BaseStream.Length;) {  		if (reader.ReadByte () != 0xE8)  			// call  			continue;  		int offse = reader.ReadInt32 ();  		if (reader.BaseStream.Position + offse == offset_CStringDecoder__DelayedLoad) {  			Status ("{0:X8} reference to offset_CStringDecoder__DelayedLoad = {1:X8}"' reader.BaseStream.Position - 5' offse);  			break;  		}  	}  	ImageResourceDirectory tier1 = (ImageResourceDirectory)root.GetEntry (type).Entry;  	ImageResourceDirectory tier2 = (ImageResourceDirectory)tier1.GetEntry (name).Entry;  	rsrcStringDataEntry = (ImageResourceDataEntry)tier2.Entrys [0].Entry;  	rsrcStringDataPosition = rsrcPointerToRawData + (rsrcStringDataEntry.OffsetToData - rsrcVirtualAddress);  	m_nCount = GetWordFromIndex (0);  	Status ("Amount of strings: {0}"' m_nCount);  	for (int i = 1; i < m_nCount; ++i)  		MainForm.Invoke (() => MainForm.dataTable.Rows.Add (i' StringDecoderDecode (i)' string.Format ("{0:X8}"' rsrcStringDataPosition + i * 4)));  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: if (StringDecodeMethod == 0)// StringPool   {  	MainForm.Invoke (() => MainForm.Text += " [StringPool]");  	int offset_StringPool__ms_aKey = (int)reader.BaseStream.Position;  	Status ("StringPool::ms_aKey located at {0:X8}"' offset_StringPool__ms_aKey);  	int keyRef = 0;  	// Only GetString references ms_aKey  	byte[] bytes = new byte[5];  	bytes [0] = 0x68;  	// push offset  	Buffer.BlockCopy (BitConverter.GetBytes (ImageBase + offset_StringPool__ms_aKey)' 0' bytes' 1' 4);  	if (FindAoBInFile (reader' 0' bytes))  		keyRef = (int)reader.BaseStream.Position;  	reader.BaseStream.Position = keyRef;  	while (true) {  		byte[] asdf = reader.ReadBytes (5);  		if (asdf [4] == 0xc3)// retn  		 {  			bool die = true;  			foreach (byte b in asdf)  				if (b == 0xe8)// call  				 {  					die = false;  					break;  				}  			if (die)  				break;  		}  		reader.BaseStream.Position -= 6;  	}  	while (reader.ReadByte () == 0xcc)  		;  	// allign  	reader.BaseStream.Position -= 1;  	int offset_StringPool__GetString_uint_char = (int)reader.BaseStream.Position;  	Status ("StringPool::GetString(uint' char) located at {0:X8}"' offset_StringPool__GetString_uint_char);  	//search for StringPool::offset_ms_aString  	if (FindAoBInFile (reader' keyRef - 100' new byte[] {  		0x8b'  		0x0c  	}' 100))  		reader.BaseStream.Position += 3;  	else if (FindAoBInFile (reader' keyRef - 100' new byte[] {  		0x8b'  		0x86  	}' 100))  		reader.BaseStream.Position += 2;  	else  		throw new Exception ("could not find start of StringPool::offset_ms_aString");  	offset_StringPool__ms_aString = reader.ReadInt32 () - ImageBase;  	Status ("StringPool::ms_aString located at {0:X8}"' offset_StringPool__ms_aString);  	//search for xrefs to function StringPool::GetString(uint' char)   	int[] xref = FindCalls (offset_StringPool__GetString_uint_char' 2);  	if (xref.Length != 2)  		throw new Exception ("failed to find references to StringPool::GetString(uint' char)");  	//search for start of StringPool::GetString(uint)  	if (!FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x51'  		0x8b  	}' 50) && !FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x55'  		0x8b  	}' 50))  		throw new Exception ("could not find start of GetString(uint)");  	int offset_StringPool__GetString_uint = (int)reader.BaseStream.Position;  	Status ("StringPool::GetString(uint) located at {0:X8}"' offset_StringPool__GetString_uint);  	//search for start of StringPool::GetString(uint' ushort)  	for (reader.BaseStream.Position = xref [1]; (reader.ReadUInt32 () & 0xffffff00) != 0x000cc200; reader.BaseStream.Position -= 5)  		;  	//seek the start of function StringPool::GetString(uint' char)  	while (reader.ReadByte () == 0xcc)  		;  	// allign  	reader.BaseStream.Position -= 1;  	int offset_StringPool__GetString_uint_ushort = (int)reader.BaseStream.Position;  	Status ("StringPool::GetString(uint' ushort) located at {0:X8}"' offset_StringPool__GetString_uint_ushort);  	//search for xrefs to function StringPool::GetString(uint)  	xref = FindCalls (offset_StringPool__GetString_uint' 1);  	if (xref.Length != 1)  		throw new Exception ("failed to find references to StringPool::GetString(uint)");  	//search for start of function StringPool::GetBSTR(uint)  	reader.BaseStream.Position -= 100;  	// should be enough  	if (!FindAoBInFile (reader' (int)reader.BaseStream.Position' new byte[] {  		0xb8'  		0xaa'  		0xaa'  		0xaa'  		0x00  	}))  		for (reader.BaseStream.Position = xref [0]; (reader.ReadUInt32 () & 0xff00ff00) != 0x0000c200; reader.BaseStream.Position -= 5)  			;  	//seek the start of function StringPool::GetString(uint' char)  	while (reader.ReadByte () == 0xcc)  		;  	// allign  	reader.BaseStream.Position -= 1;  	int offset_StringPool__GetBSTR_uint = (int)reader.BaseStream.Position;  	Status ("StringPool::GetBSTR(uint) located at {0:X8}"' offset_StringPool__GetBSTR_uint);  	//search for xrefs to function StringPool::GetString(uint' ushort)  	xref = FindCalls (offset_StringPool__GetString_uint_ushort' 1);  	if (xref.Length != 1)  		throw new Exception ("failed to find references to StringPool::GetString(uint' ushort)");  	//search for start of function StringPool::GetStringW(uint)  	if (!FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x51'  		0x8b  	}' 50) && !FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x55'  		0x8b  	}' 50))  		throw new Exception ("could not find start of GetStringW(uint)");  	int offset_StringPool__GetStringW_uint = (int)reader.BaseStream.Position;  	Status ("StringPool::GetStringW(uint) located at {0:X8}"' offset_StringPool__GetStringW_uint);  	ms_nSize = GetIntFromOffset (offset_StringPool__ms_aKey + 16 + 4);  	Status ("Amount of strings: {0}"' ms_nSize);  	if (MessageBox.Show ("Scan for references to strings in the client? This can take a while."' "Warning"' MessageBoxButtons.YesNo' MessageBoxIcon.Warning) == DialogResult.Yes) {  		Status ("Searching for references to GetString' GetStringW' and GetBSTR");  		List<int> GetStringCalls = new List<int> ();  		List<int> GetStringWCalls = new List<int> ();  		List<int> GetBSTRCalls = new List<int> ();  		for (reader.BaseStream.Position = 0; reader.BaseStream.Position < reader.BaseStream.Length;) {  			//int lol = (int)((float)reader.BaseStream.Position / reader.BaseStream.Length * 100);  			//if (lol > MainForm.toolStripProgressBar1.Value)  			//{  			//    MainForm.Invoke(() => MainForm.toolStripProgressBar1.Value = lol);  			//    MainForm.Invoke(() => MainForm.Update());  			//} too expensive  			if (reader.ReadByte () != 0xE8)  				// call  				continue;  			int offset = reader.ReadInt32 ();  			if (reader.BaseStream.Position + offset == offset_StringPool__GetString_uint)  				GetStringCalls.Add ((int)reader.BaseStream.Position - 5);  			else if (reader.BaseStream.Position + offset == offset_StringPool__GetStringW_uint)  				GetStringWCalls.Add ((int)reader.BaseStream.Position - 5);  			else if (reader.BaseStream.Position + offset == offset_StringPool__GetBSTR_uint)  				GetBSTRCalls.Add ((int)reader.BaseStream.Position - 5);  			else  				reader.BaseStream.Position -= 4;  		}  		List<int> GetStringFail = new List<int> ();  		foreach (int addr in GetStringCalls) {  			reader.BaseStream.Position = addr;  			reader.BaseStream.Position -= 2;  			if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  			 {  				GetStringFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 7;  			if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  			 {  				GetStringFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 2;  			if (reader.ReadByte () != 0x50)// push eax  			 {  				GetStringFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 6;  			if (reader.ReadByte () != 0x68)// push dword  			 {  				GetStringFail.Add (addr);  				continue;  			}  			int idx = reader.ReadInt32 ();  			if (idx > ms_nSize - 1)  				GetStringFail.Add (addr);  			else  				GetString.Add (addr' idx);  		}  		List<int> GetStringWFail = new List<int> ();  		foreach (int addr in GetStringWCalls) {  			reader.BaseStream.Position = addr;  			reader.BaseStream.Position -= 2;  			if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 7;  			if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 2;  			if (reader.ReadByte () != 0x50)// push eax  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 6;  			if (reader.ReadByte () != 0x68)// push dword  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			int idx = reader.ReadInt32 ();  			if (idx > ms_nSize - 1)  				GetStringWFail.Add (addr);  			else  				GetStringW.Add (addr' idx);  		}  		List<int> GetBSTRFail = new List<int> ();  		foreach (int addr in GetBSTRCalls) {  			reader.BaseStream.Position = addr;  			reader.BaseStream.Position -= 2;  			if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 7;  			if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 2;  			if (reader.ReadByte () != 0x50)// push eax  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 6;  			if (reader.ReadByte () != 0x68)// push dword  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			int idx = reader.ReadInt32 ();  			if (idx > ms_nSize - 1)  				GetBSTRFail.Add (addr);  			else  				GetBSTR.Add (addr' idx);  		}  		Status ("Failed to find index of {0} references"' GetStringFail.Count + GetStringWFail.Count + GetBSTRFail.Count);  	}  	Status ("Successfully found index of {0} references"' GetString.Count + GetBSTR.Count + GetStringW.Count);  	Status ("Decoding strings");  	for (int index = 0; index < ms_nSize; ++index)  		if (index != -1 && index <= 0xffff)  			Strings.Add (index' StringPoolDecode (index));  	Status ("Populating table");  	foreach (var s in Strings)  		MainForm.Invoke (() => MainForm.dataTable.Rows.Add (s.Key' s.Value' string.Empty));  	foreach (var a in GetString)  		MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetString")));  	foreach (var a in GetBSTR)  		MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetBSTR")));  	foreach (var a in GetStringW)  		MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetStringW")));  }  else if (StringDecodeMethod == 1)// StringDecoder   {  	MainForm.Invoke (() => MainForm.Text += " [StringDecoder]");  	int type = 0;  	int name = 0;  	int offset = 0;  	//search for CStringDecoder::DelayedLoad' which contains the resource type and name  	if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00'  		0x89'  		0x45'  		0xF4'  		0x6A'  		0xAA'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x8B'  		0x4D'  		0xF4'  		0x51'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 12;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 1;  		name = reader.ReadInt32 ();  	}  	else if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00'  		0x6A'  		0xAA'  		0x8B'  		0xF8'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x57'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 9;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 3;  		name = reader.ReadInt32 ();  	}  	else if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0xAA'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 1;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 1;  		name = reader.ReadInt32 ();  	}  	else  		throw new Exception ("Failed to determine type and name of resource.");  	//search for start of function CStringDecoder::DelayedLoad()  	reader.BaseStream.Position -= 50;  	// should be enough  	FindAoBInFile (reader' (int)reader.BaseStream.Position' new byte[] {  		0x55'  		0x8B'  		0xEC'  		0x83'  		0xEC'  		0x10  	});  	int offset_CStringDecoder__DelayedLoad = (int)reader.BaseStream.Position;  	for (reader.BaseStream.Position = 0; reader.BaseStream.Position < reader.BaseStream.Length;) {  		if (reader.ReadByte () != 0xE8)  			// call  			continue;  		int offse = reader.ReadInt32 ();  		if (reader.BaseStream.Position + offse == offset_CStringDecoder__DelayedLoad) {  			Status ("{0:X8} reference to offset_CStringDecoder__DelayedLoad = {1:X8}"' reader.BaseStream.Position - 5' offse);  			break;  		}  	}  	ImageResourceDirectory tier1 = (ImageResourceDirectory)root.GetEntry (type).Entry;  	ImageResourceDirectory tier2 = (ImageResourceDirectory)tier1.GetEntry (name).Entry;  	rsrcStringDataEntry = (ImageResourceDataEntry)tier2.Entrys [0].Entry;  	rsrcStringDataPosition = rsrcPointerToRawData + (rsrcStringDataEntry.OffsetToData - rsrcVirtualAddress);  	m_nCount = GetWordFromIndex (0);  	Status ("Amount of strings: {0}"' m_nCount);  	for (int i = 1; i < m_nCount; ++i)  		MainForm.Invoke (() => MainForm.dataTable.Rows.Add (i' StringDecoderDecode (i)' string.Format ("{0:X8}"' rsrcStringDataPosition + i * 4)));  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: if (StringDecodeMethod == 0)// StringPool   {  	MainForm.Invoke (() => MainForm.Text += " [StringPool]");  	int offset_StringPool__ms_aKey = (int)reader.BaseStream.Position;  	Status ("StringPool::ms_aKey located at {0:X8}"' offset_StringPool__ms_aKey);  	int keyRef = 0;  	// Only GetString references ms_aKey  	byte[] bytes = new byte[5];  	bytes [0] = 0x68;  	// push offset  	Buffer.BlockCopy (BitConverter.GetBytes (ImageBase + offset_StringPool__ms_aKey)' 0' bytes' 1' 4);  	if (FindAoBInFile (reader' 0' bytes))  		keyRef = (int)reader.BaseStream.Position;  	reader.BaseStream.Position = keyRef;  	while (true) {  		byte[] asdf = reader.ReadBytes (5);  		if (asdf [4] == 0xc3)// retn  		 {  			bool die = true;  			foreach (byte b in asdf)  				if (b == 0xe8)// call  				 {  					die = false;  					break;  				}  			if (die)  				break;  		}  		reader.BaseStream.Position -= 6;  	}  	while (reader.ReadByte () == 0xcc)  		;  	// allign  	reader.BaseStream.Position -= 1;  	int offset_StringPool__GetString_uint_char = (int)reader.BaseStream.Position;  	Status ("StringPool::GetString(uint' char) located at {0:X8}"' offset_StringPool__GetString_uint_char);  	//search for StringPool::offset_ms_aString  	if (FindAoBInFile (reader' keyRef - 100' new byte[] {  		0x8b'  		0x0c  	}' 100))  		reader.BaseStream.Position += 3;  	else if (FindAoBInFile (reader' keyRef - 100' new byte[] {  		0x8b'  		0x86  	}' 100))  		reader.BaseStream.Position += 2;  	else  		throw new Exception ("could not find start of StringPool::offset_ms_aString");  	offset_StringPool__ms_aString = reader.ReadInt32 () - ImageBase;  	Status ("StringPool::ms_aString located at {0:X8}"' offset_StringPool__ms_aString);  	//search for xrefs to function StringPool::GetString(uint' char)   	int[] xref = FindCalls (offset_StringPool__GetString_uint_char' 2);  	if (xref.Length != 2)  		throw new Exception ("failed to find references to StringPool::GetString(uint' char)");  	//search for start of StringPool::GetString(uint)  	if (!FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x51'  		0x8b  	}' 50) && !FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x55'  		0x8b  	}' 50))  		throw new Exception ("could not find start of GetString(uint)");  	int offset_StringPool__GetString_uint = (int)reader.BaseStream.Position;  	Status ("StringPool::GetString(uint) located at {0:X8}"' offset_StringPool__GetString_uint);  	//search for start of StringPool::GetString(uint' ushort)  	for (reader.BaseStream.Position = xref [1]; (reader.ReadUInt32 () & 0xffffff00) != 0x000cc200; reader.BaseStream.Position -= 5)  		;  	//seek the start of function StringPool::GetString(uint' char)  	while (reader.ReadByte () == 0xcc)  		;  	// allign  	reader.BaseStream.Position -= 1;  	int offset_StringPool__GetString_uint_ushort = (int)reader.BaseStream.Position;  	Status ("StringPool::GetString(uint' ushort) located at {0:X8}"' offset_StringPool__GetString_uint_ushort);  	//search for xrefs to function StringPool::GetString(uint)  	xref = FindCalls (offset_StringPool__GetString_uint' 1);  	if (xref.Length != 1)  		throw new Exception ("failed to find references to StringPool::GetString(uint)");  	//search for start of function StringPool::GetBSTR(uint)  	reader.BaseStream.Position -= 100;  	// should be enough  	if (!FindAoBInFile (reader' (int)reader.BaseStream.Position' new byte[] {  		0xb8'  		0xaa'  		0xaa'  		0xaa'  		0x00  	}))  		for (reader.BaseStream.Position = xref [0]; (reader.ReadUInt32 () & 0xff00ff00) != 0x0000c200; reader.BaseStream.Position -= 5)  			;  	//seek the start of function StringPool::GetString(uint' char)  	while (reader.ReadByte () == 0xcc)  		;  	// allign  	reader.BaseStream.Position -= 1;  	int offset_StringPool__GetBSTR_uint = (int)reader.BaseStream.Position;  	Status ("StringPool::GetBSTR(uint) located at {0:X8}"' offset_StringPool__GetBSTR_uint);  	//search for xrefs to function StringPool::GetString(uint' ushort)  	xref = FindCalls (offset_StringPool__GetString_uint_ushort' 1);  	if (xref.Length != 1)  		throw new Exception ("failed to find references to StringPool::GetString(uint' ushort)");  	//search for start of function StringPool::GetStringW(uint)  	if (!FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x51'  		0x8b  	}' 50) && !FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x55'  		0x8b  	}' 50))  		throw new Exception ("could not find start of GetStringW(uint)");  	int offset_StringPool__GetStringW_uint = (int)reader.BaseStream.Position;  	Status ("StringPool::GetStringW(uint) located at {0:X8}"' offset_StringPool__GetStringW_uint);  	ms_nSize = GetIntFromOffset (offset_StringPool__ms_aKey + 16 + 4);  	Status ("Amount of strings: {0}"' ms_nSize);  	if (MessageBox.Show ("Scan for references to strings in the client? This can take a while."' "Warning"' MessageBoxButtons.YesNo' MessageBoxIcon.Warning) == DialogResult.Yes) {  		Status ("Searching for references to GetString' GetStringW' and GetBSTR");  		List<int> GetStringCalls = new List<int> ();  		List<int> GetStringWCalls = new List<int> ();  		List<int> GetBSTRCalls = new List<int> ();  		for (reader.BaseStream.Position = 0; reader.BaseStream.Position < reader.BaseStream.Length;) {  			//int lol = (int)((float)reader.BaseStream.Position / reader.BaseStream.Length * 100);  			//if (lol > MainForm.toolStripProgressBar1.Value)  			//{  			//    MainForm.Invoke(() => MainForm.toolStripProgressBar1.Value = lol);  			//    MainForm.Invoke(() => MainForm.Update());  			//} too expensive  			if (reader.ReadByte () != 0xE8)  				// call  				continue;  			int offset = reader.ReadInt32 ();  			if (reader.BaseStream.Position + offset == offset_StringPool__GetString_uint)  				GetStringCalls.Add ((int)reader.BaseStream.Position - 5);  			else if (reader.BaseStream.Position + offset == offset_StringPool__GetStringW_uint)  				GetStringWCalls.Add ((int)reader.BaseStream.Position - 5);  			else if (reader.BaseStream.Position + offset == offset_StringPool__GetBSTR_uint)  				GetBSTRCalls.Add ((int)reader.BaseStream.Position - 5);  			else  				reader.BaseStream.Position -= 4;  		}  		List<int> GetStringFail = new List<int> ();  		foreach (int addr in GetStringCalls) {  			reader.BaseStream.Position = addr;  			reader.BaseStream.Position -= 2;  			if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  			 {  				GetStringFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 7;  			if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  			 {  				GetStringFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 2;  			if (reader.ReadByte () != 0x50)// push eax  			 {  				GetStringFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 6;  			if (reader.ReadByte () != 0x68)// push dword  			 {  				GetStringFail.Add (addr);  				continue;  			}  			int idx = reader.ReadInt32 ();  			if (idx > ms_nSize - 1)  				GetStringFail.Add (addr);  			else  				GetString.Add (addr' idx);  		}  		List<int> GetStringWFail = new List<int> ();  		foreach (int addr in GetStringWCalls) {  			reader.BaseStream.Position = addr;  			reader.BaseStream.Position -= 2;  			if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 7;  			if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 2;  			if (reader.ReadByte () != 0x50)// push eax  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 6;  			if (reader.ReadByte () != 0x68)// push dword  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			int idx = reader.ReadInt32 ();  			if (idx > ms_nSize - 1)  				GetStringWFail.Add (addr);  			else  				GetStringW.Add (addr' idx);  		}  		List<int> GetBSTRFail = new List<int> ();  		foreach (int addr in GetBSTRCalls) {  			reader.BaseStream.Position = addr;  			reader.BaseStream.Position -= 2;  			if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 7;  			if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 2;  			if (reader.ReadByte () != 0x50)// push eax  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 6;  			if (reader.ReadByte () != 0x68)// push dword  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			int idx = reader.ReadInt32 ();  			if (idx > ms_nSize - 1)  				GetBSTRFail.Add (addr);  			else  				GetBSTR.Add (addr' idx);  		}  		Status ("Failed to find index of {0} references"' GetStringFail.Count + GetStringWFail.Count + GetBSTRFail.Count);  	}  	Status ("Successfully found index of {0} references"' GetString.Count + GetBSTR.Count + GetStringW.Count);  	Status ("Decoding strings");  	for (int index = 0; index < ms_nSize; ++index)  		if (index != -1 && index <= 0xffff)  			Strings.Add (index' StringPoolDecode (index));  	Status ("Populating table");  	foreach (var s in Strings)  		MainForm.Invoke (() => MainForm.dataTable.Rows.Add (s.Key' s.Value' string.Empty));  	foreach (var a in GetString)  		MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetString")));  	foreach (var a in GetBSTR)  		MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetBSTR")));  	foreach (var a in GetStringW)  		MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetStringW")));  }  else if (StringDecodeMethod == 1)// StringDecoder   {  	MainForm.Invoke (() => MainForm.Text += " [StringDecoder]");  	int type = 0;  	int name = 0;  	int offset = 0;  	//search for CStringDecoder::DelayedLoad' which contains the resource type and name  	if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00'  		0x89'  		0x45'  		0xF4'  		0x6A'  		0xAA'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x8B'  		0x4D'  		0xF4'  		0x51'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 12;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 1;  		name = reader.ReadInt32 ();  	}  	else if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00'  		0x6A'  		0xAA'  		0x8B'  		0xF8'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x57'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 9;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 3;  		name = reader.ReadInt32 ();  	}  	else if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0xAA'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 1;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 1;  		name = reader.ReadInt32 ();  	}  	else  		throw new Exception ("Failed to determine type and name of resource.");  	//search for start of function CStringDecoder::DelayedLoad()  	reader.BaseStream.Position -= 50;  	// should be enough  	FindAoBInFile (reader' (int)reader.BaseStream.Position' new byte[] {  		0x55'  		0x8B'  		0xEC'  		0x83'  		0xEC'  		0x10  	});  	int offset_CStringDecoder__DelayedLoad = (int)reader.BaseStream.Position;  	for (reader.BaseStream.Position = 0; reader.BaseStream.Position < reader.BaseStream.Length;) {  		if (reader.ReadByte () != 0xE8)  			// call  			continue;  		int offse = reader.ReadInt32 ();  		if (reader.BaseStream.Position + offse == offset_CStringDecoder__DelayedLoad) {  			Status ("{0:X8} reference to offset_CStringDecoder__DelayedLoad = {1:X8}"' reader.BaseStream.Position - 5' offse);  			break;  		}  	}  	ImageResourceDirectory tier1 = (ImageResourceDirectory)root.GetEntry (type).Entry;  	ImageResourceDirectory tier2 = (ImageResourceDirectory)tier1.GetEntry (name).Entry;  	rsrcStringDataEntry = (ImageResourceDataEntry)tier2.Entrys [0].Entry;  	rsrcStringDataPosition = rsrcPointerToRawData + (rsrcStringDataEntry.OffsetToData - rsrcVirtualAddress);  	m_nCount = GetWordFromIndex (0);  	Status ("Amount of strings: {0}"' m_nCount);  	for (int i = 1; i < m_nCount; ++i)  		MainForm.Invoke (() => MainForm.dataTable.Rows.Add (i' StringDecoderDecode (i)' string.Format ("{0:X8}"' rsrcStringDataPosition + i * 4)));  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: if (StringDecodeMethod == 0)// StringPool   {  	MainForm.Invoke (() => MainForm.Text += " [StringPool]");  	int offset_StringPool__ms_aKey = (int)reader.BaseStream.Position;  	Status ("StringPool::ms_aKey located at {0:X8}"' offset_StringPool__ms_aKey);  	int keyRef = 0;  	// Only GetString references ms_aKey  	byte[] bytes = new byte[5];  	bytes [0] = 0x68;  	// push offset  	Buffer.BlockCopy (BitConverter.GetBytes (ImageBase + offset_StringPool__ms_aKey)' 0' bytes' 1' 4);  	if (FindAoBInFile (reader' 0' bytes))  		keyRef = (int)reader.BaseStream.Position;  	reader.BaseStream.Position = keyRef;  	while (true) {  		byte[] asdf = reader.ReadBytes (5);  		if (asdf [4] == 0xc3)// retn  		 {  			bool die = true;  			foreach (byte b in asdf)  				if (b == 0xe8)// call  				 {  					die = false;  					break;  				}  			if (die)  				break;  		}  		reader.BaseStream.Position -= 6;  	}  	while (reader.ReadByte () == 0xcc)  		;  	// allign  	reader.BaseStream.Position -= 1;  	int offset_StringPool__GetString_uint_char = (int)reader.BaseStream.Position;  	Status ("StringPool::GetString(uint' char) located at {0:X8}"' offset_StringPool__GetString_uint_char);  	//search for StringPool::offset_ms_aString  	if (FindAoBInFile (reader' keyRef - 100' new byte[] {  		0x8b'  		0x0c  	}' 100))  		reader.BaseStream.Position += 3;  	else if (FindAoBInFile (reader' keyRef - 100' new byte[] {  		0x8b'  		0x86  	}' 100))  		reader.BaseStream.Position += 2;  	else  		throw new Exception ("could not find start of StringPool::offset_ms_aString");  	offset_StringPool__ms_aString = reader.ReadInt32 () - ImageBase;  	Status ("StringPool::ms_aString located at {0:X8}"' offset_StringPool__ms_aString);  	//search for xrefs to function StringPool::GetString(uint' char)   	int[] xref = FindCalls (offset_StringPool__GetString_uint_char' 2);  	if (xref.Length != 2)  		throw new Exception ("failed to find references to StringPool::GetString(uint' char)");  	//search for start of StringPool::GetString(uint)  	if (!FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x51'  		0x8b  	}' 50) && !FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x55'  		0x8b  	}' 50))  		throw new Exception ("could not find start of GetString(uint)");  	int offset_StringPool__GetString_uint = (int)reader.BaseStream.Position;  	Status ("StringPool::GetString(uint) located at {0:X8}"' offset_StringPool__GetString_uint);  	//search for start of StringPool::GetString(uint' ushort)  	for (reader.BaseStream.Position = xref [1]; (reader.ReadUInt32 () & 0xffffff00) != 0x000cc200; reader.BaseStream.Position -= 5)  		;  	//seek the start of function StringPool::GetString(uint' char)  	while (reader.ReadByte () == 0xcc)  		;  	// allign  	reader.BaseStream.Position -= 1;  	int offset_StringPool__GetString_uint_ushort = (int)reader.BaseStream.Position;  	Status ("StringPool::GetString(uint' ushort) located at {0:X8}"' offset_StringPool__GetString_uint_ushort);  	//search for xrefs to function StringPool::GetString(uint)  	xref = FindCalls (offset_StringPool__GetString_uint' 1);  	if (xref.Length != 1)  		throw new Exception ("failed to find references to StringPool::GetString(uint)");  	//search for start of function StringPool::GetBSTR(uint)  	reader.BaseStream.Position -= 100;  	// should be enough  	if (!FindAoBInFile (reader' (int)reader.BaseStream.Position' new byte[] {  		0xb8'  		0xaa'  		0xaa'  		0xaa'  		0x00  	}))  		for (reader.BaseStream.Position = xref [0]; (reader.ReadUInt32 () & 0xff00ff00) != 0x0000c200; reader.BaseStream.Position -= 5)  			;  	//seek the start of function StringPool::GetString(uint' char)  	while (reader.ReadByte () == 0xcc)  		;  	// allign  	reader.BaseStream.Position -= 1;  	int offset_StringPool__GetBSTR_uint = (int)reader.BaseStream.Position;  	Status ("StringPool::GetBSTR(uint) located at {0:X8}"' offset_StringPool__GetBSTR_uint);  	//search for xrefs to function StringPool::GetString(uint' ushort)  	xref = FindCalls (offset_StringPool__GetString_uint_ushort' 1);  	if (xref.Length != 1)  		throw new Exception ("failed to find references to StringPool::GetString(uint' ushort)");  	//search for start of function StringPool::GetStringW(uint)  	if (!FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x51'  		0x8b  	}' 50) && !FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x55'  		0x8b  	}' 50))  		throw new Exception ("could not find start of GetStringW(uint)");  	int offset_StringPool__GetStringW_uint = (int)reader.BaseStream.Position;  	Status ("StringPool::GetStringW(uint) located at {0:X8}"' offset_StringPool__GetStringW_uint);  	ms_nSize = GetIntFromOffset (offset_StringPool__ms_aKey + 16 + 4);  	Status ("Amount of strings: {0}"' ms_nSize);  	if (MessageBox.Show ("Scan for references to strings in the client? This can take a while."' "Warning"' MessageBoxButtons.YesNo' MessageBoxIcon.Warning) == DialogResult.Yes) {  		Status ("Searching for references to GetString' GetStringW' and GetBSTR");  		List<int> GetStringCalls = new List<int> ();  		List<int> GetStringWCalls = new List<int> ();  		List<int> GetBSTRCalls = new List<int> ();  		for (reader.BaseStream.Position = 0; reader.BaseStream.Position < reader.BaseStream.Length;) {  			//int lol = (int)((float)reader.BaseStream.Position / reader.BaseStream.Length * 100);  			//if (lol > MainForm.toolStripProgressBar1.Value)  			//{  			//    MainForm.Invoke(() => MainForm.toolStripProgressBar1.Value = lol);  			//    MainForm.Invoke(() => MainForm.Update());  			//} too expensive  			if (reader.ReadByte () != 0xE8)  				// call  				continue;  			int offset = reader.ReadInt32 ();  			if (reader.BaseStream.Position + offset == offset_StringPool__GetString_uint)  				GetStringCalls.Add ((int)reader.BaseStream.Position - 5);  			else if (reader.BaseStream.Position + offset == offset_StringPool__GetStringW_uint)  				GetStringWCalls.Add ((int)reader.BaseStream.Position - 5);  			else if (reader.BaseStream.Position + offset == offset_StringPool__GetBSTR_uint)  				GetBSTRCalls.Add ((int)reader.BaseStream.Position - 5);  			else  				reader.BaseStream.Position -= 4;  		}  		List<int> GetStringFail = new List<int> ();  		foreach (int addr in GetStringCalls) {  			reader.BaseStream.Position = addr;  			reader.BaseStream.Position -= 2;  			if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  			 {  				GetStringFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 7;  			if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  			 {  				GetStringFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 2;  			if (reader.ReadByte () != 0x50)// push eax  			 {  				GetStringFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 6;  			if (reader.ReadByte () != 0x68)// push dword  			 {  				GetStringFail.Add (addr);  				continue;  			}  			int idx = reader.ReadInt32 ();  			if (idx > ms_nSize - 1)  				GetStringFail.Add (addr);  			else  				GetString.Add (addr' idx);  		}  		List<int> GetStringWFail = new List<int> ();  		foreach (int addr in GetStringWCalls) {  			reader.BaseStream.Position = addr;  			reader.BaseStream.Position -= 2;  			if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 7;  			if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 2;  			if (reader.ReadByte () != 0x50)// push eax  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 6;  			if (reader.ReadByte () != 0x68)// push dword  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			int idx = reader.ReadInt32 ();  			if (idx > ms_nSize - 1)  				GetStringWFail.Add (addr);  			else  				GetStringW.Add (addr' idx);  		}  		List<int> GetBSTRFail = new List<int> ();  		foreach (int addr in GetBSTRCalls) {  			reader.BaseStream.Position = addr;  			reader.BaseStream.Position -= 2;  			if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 7;  			if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 2;  			if (reader.ReadByte () != 0x50)// push eax  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 6;  			if (reader.ReadByte () != 0x68)// push dword  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			int idx = reader.ReadInt32 ();  			if (idx > ms_nSize - 1)  				GetBSTRFail.Add (addr);  			else  				GetBSTR.Add (addr' idx);  		}  		Status ("Failed to find index of {0} references"' GetStringFail.Count + GetStringWFail.Count + GetBSTRFail.Count);  	}  	Status ("Successfully found index of {0} references"' GetString.Count + GetBSTR.Count + GetStringW.Count);  	Status ("Decoding strings");  	for (int index = 0; index < ms_nSize; ++index)  		if (index != -1 && index <= 0xffff)  			Strings.Add (index' StringPoolDecode (index));  	Status ("Populating table");  	foreach (var s in Strings)  		MainForm.Invoke (() => MainForm.dataTable.Rows.Add (s.Key' s.Value' string.Empty));  	foreach (var a in GetString)  		MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetString")));  	foreach (var a in GetBSTR)  		MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetBSTR")));  	foreach (var a in GetStringW)  		MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetStringW")));  }  else if (StringDecodeMethod == 1)// StringDecoder   {  	MainForm.Invoke (() => MainForm.Text += " [StringDecoder]");  	int type = 0;  	int name = 0;  	int offset = 0;  	//search for CStringDecoder::DelayedLoad' which contains the resource type and name  	if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00'  		0x89'  		0x45'  		0xF4'  		0x6A'  		0xAA'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x8B'  		0x4D'  		0xF4'  		0x51'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 12;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 1;  		name = reader.ReadInt32 ();  	}  	else if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00'  		0x6A'  		0xAA'  		0x8B'  		0xF8'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x57'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 9;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 3;  		name = reader.ReadInt32 ();  	}  	else if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0xAA'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 1;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 1;  		name = reader.ReadInt32 ();  	}  	else  		throw new Exception ("Failed to determine type and name of resource.");  	//search for start of function CStringDecoder::DelayedLoad()  	reader.BaseStream.Position -= 50;  	// should be enough  	FindAoBInFile (reader' (int)reader.BaseStream.Position' new byte[] {  		0x55'  		0x8B'  		0xEC'  		0x83'  		0xEC'  		0x10  	});  	int offset_CStringDecoder__DelayedLoad = (int)reader.BaseStream.Position;  	for (reader.BaseStream.Position = 0; reader.BaseStream.Position < reader.BaseStream.Length;) {  		if (reader.ReadByte () != 0xE8)  			// call  			continue;  		int offse = reader.ReadInt32 ();  		if (reader.BaseStream.Position + offse == offset_CStringDecoder__DelayedLoad) {  			Status ("{0:X8} reference to offset_CStringDecoder__DelayedLoad = {1:X8}"' reader.BaseStream.Position - 5' offse);  			break;  		}  	}  	ImageResourceDirectory tier1 = (ImageResourceDirectory)root.GetEntry (type).Entry;  	ImageResourceDirectory tier2 = (ImageResourceDirectory)tier1.GetEntry (name).Entry;  	rsrcStringDataEntry = (ImageResourceDataEntry)tier2.Entrys [0].Entry;  	rsrcStringDataPosition = rsrcPointerToRawData + (rsrcStringDataEntry.OffsetToData - rsrcVirtualAddress);  	m_nCount = GetWordFromIndex (0);  	Status ("Amount of strings: {0}"' m_nCount);  	for (int i = 1; i < m_nCount; ++i)  		MainForm.Invoke (() => MainForm.dataTable.Rows.Add (i' StringDecoderDecode (i)' string.Format ("{0:X8}"' rsrcStringDataPosition + i * 4)));  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: if (StringDecodeMethod == 0)// StringPool   {  	MainForm.Invoke (() => MainForm.Text += " [StringPool]");  	int offset_StringPool__ms_aKey = (int)reader.BaseStream.Position;  	Status ("StringPool::ms_aKey located at {0:X8}"' offset_StringPool__ms_aKey);  	int keyRef = 0;  	// Only GetString references ms_aKey  	byte[] bytes = new byte[5];  	bytes [0] = 0x68;  	// push offset  	Buffer.BlockCopy (BitConverter.GetBytes (ImageBase + offset_StringPool__ms_aKey)' 0' bytes' 1' 4);  	if (FindAoBInFile (reader' 0' bytes))  		keyRef = (int)reader.BaseStream.Position;  	reader.BaseStream.Position = keyRef;  	while (true) {  		byte[] asdf = reader.ReadBytes (5);  		if (asdf [4] == 0xc3)// retn  		 {  			bool die = true;  			foreach (byte b in asdf)  				if (b == 0xe8)// call  				 {  					die = false;  					break;  				}  			if (die)  				break;  		}  		reader.BaseStream.Position -= 6;  	}  	while (reader.ReadByte () == 0xcc)  		;  	// allign  	reader.BaseStream.Position -= 1;  	int offset_StringPool__GetString_uint_char = (int)reader.BaseStream.Position;  	Status ("StringPool::GetString(uint' char) located at {0:X8}"' offset_StringPool__GetString_uint_char);  	//search for StringPool::offset_ms_aString  	if (FindAoBInFile (reader' keyRef - 100' new byte[] {  		0x8b'  		0x0c  	}' 100))  		reader.BaseStream.Position += 3;  	else if (FindAoBInFile (reader' keyRef - 100' new byte[] {  		0x8b'  		0x86  	}' 100))  		reader.BaseStream.Position += 2;  	else  		throw new Exception ("could not find start of StringPool::offset_ms_aString");  	offset_StringPool__ms_aString = reader.ReadInt32 () - ImageBase;  	Status ("StringPool::ms_aString located at {0:X8}"' offset_StringPool__ms_aString);  	//search for xrefs to function StringPool::GetString(uint' char)   	int[] xref = FindCalls (offset_StringPool__GetString_uint_char' 2);  	if (xref.Length != 2)  		throw new Exception ("failed to find references to StringPool::GetString(uint' char)");  	//search for start of StringPool::GetString(uint)  	if (!FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x51'  		0x8b  	}' 50) && !FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x55'  		0x8b  	}' 50))  		throw new Exception ("could not find start of GetString(uint)");  	int offset_StringPool__GetString_uint = (int)reader.BaseStream.Position;  	Status ("StringPool::GetString(uint) located at {0:X8}"' offset_StringPool__GetString_uint);  	//search for start of StringPool::GetString(uint' ushort)  	for (reader.BaseStream.Position = xref [1]; (reader.ReadUInt32 () & 0xffffff00) != 0x000cc200; reader.BaseStream.Position -= 5)  		;  	//seek the start of function StringPool::GetString(uint' char)  	while (reader.ReadByte () == 0xcc)  		;  	// allign  	reader.BaseStream.Position -= 1;  	int offset_StringPool__GetString_uint_ushort = (int)reader.BaseStream.Position;  	Status ("StringPool::GetString(uint' ushort) located at {0:X8}"' offset_StringPool__GetString_uint_ushort);  	//search for xrefs to function StringPool::GetString(uint)  	xref = FindCalls (offset_StringPool__GetString_uint' 1);  	if (xref.Length != 1)  		throw new Exception ("failed to find references to StringPool::GetString(uint)");  	//search for start of function StringPool::GetBSTR(uint)  	reader.BaseStream.Position -= 100;  	// should be enough  	if (!FindAoBInFile (reader' (int)reader.BaseStream.Position' new byte[] {  		0xb8'  		0xaa'  		0xaa'  		0xaa'  		0x00  	}))  		for (reader.BaseStream.Position = xref [0]; (reader.ReadUInt32 () & 0xff00ff00) != 0x0000c200; reader.BaseStream.Position -= 5)  			;  	//seek the start of function StringPool::GetString(uint' char)  	while (reader.ReadByte () == 0xcc)  		;  	// allign  	reader.BaseStream.Position -= 1;  	int offset_StringPool__GetBSTR_uint = (int)reader.BaseStream.Position;  	Status ("StringPool::GetBSTR(uint) located at {0:X8}"' offset_StringPool__GetBSTR_uint);  	//search for xrefs to function StringPool::GetString(uint' ushort)  	xref = FindCalls (offset_StringPool__GetString_uint_ushort' 1);  	if (xref.Length != 1)  		throw new Exception ("failed to find references to StringPool::GetString(uint' ushort)");  	//search for start of function StringPool::GetStringW(uint)  	if (!FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x51'  		0x8b  	}' 50) && !FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x55'  		0x8b  	}' 50))  		throw new Exception ("could not find start of GetStringW(uint)");  	int offset_StringPool__GetStringW_uint = (int)reader.BaseStream.Position;  	Status ("StringPool::GetStringW(uint) located at {0:X8}"' offset_StringPool__GetStringW_uint);  	ms_nSize = GetIntFromOffset (offset_StringPool__ms_aKey + 16 + 4);  	Status ("Amount of strings: {0}"' ms_nSize);  	if (MessageBox.Show ("Scan for references to strings in the client? This can take a while."' "Warning"' MessageBoxButtons.YesNo' MessageBoxIcon.Warning) == DialogResult.Yes) {  		Status ("Searching for references to GetString' GetStringW' and GetBSTR");  		List<int> GetStringCalls = new List<int> ();  		List<int> GetStringWCalls = new List<int> ();  		List<int> GetBSTRCalls = new List<int> ();  		for (reader.BaseStream.Position = 0; reader.BaseStream.Position < reader.BaseStream.Length;) {  			//int lol = (int)((float)reader.BaseStream.Position / reader.BaseStream.Length * 100);  			//if (lol > MainForm.toolStripProgressBar1.Value)  			//{  			//    MainForm.Invoke(() => MainForm.toolStripProgressBar1.Value = lol);  			//    MainForm.Invoke(() => MainForm.Update());  			//} too expensive  			if (reader.ReadByte () != 0xE8)  				// call  				continue;  			int offset = reader.ReadInt32 ();  			if (reader.BaseStream.Position + offset == offset_StringPool__GetString_uint)  				GetStringCalls.Add ((int)reader.BaseStream.Position - 5);  			else if (reader.BaseStream.Position + offset == offset_StringPool__GetStringW_uint)  				GetStringWCalls.Add ((int)reader.BaseStream.Position - 5);  			else if (reader.BaseStream.Position + offset == offset_StringPool__GetBSTR_uint)  				GetBSTRCalls.Add ((int)reader.BaseStream.Position - 5);  			else  				reader.BaseStream.Position -= 4;  		}  		List<int> GetStringFail = new List<int> ();  		foreach (int addr in GetStringCalls) {  			reader.BaseStream.Position = addr;  			reader.BaseStream.Position -= 2;  			if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  			 {  				GetStringFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 7;  			if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  			 {  				GetStringFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 2;  			if (reader.ReadByte () != 0x50)// push eax  			 {  				GetStringFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 6;  			if (reader.ReadByte () != 0x68)// push dword  			 {  				GetStringFail.Add (addr);  				continue;  			}  			int idx = reader.ReadInt32 ();  			if (idx > ms_nSize - 1)  				GetStringFail.Add (addr);  			else  				GetString.Add (addr' idx);  		}  		List<int> GetStringWFail = new List<int> ();  		foreach (int addr in GetStringWCalls) {  			reader.BaseStream.Position = addr;  			reader.BaseStream.Position -= 2;  			if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 7;  			if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 2;  			if (reader.ReadByte () != 0x50)// push eax  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 6;  			if (reader.ReadByte () != 0x68)// push dword  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			int idx = reader.ReadInt32 ();  			if (idx > ms_nSize - 1)  				GetStringWFail.Add (addr);  			else  				GetStringW.Add (addr' idx);  		}  		List<int> GetBSTRFail = new List<int> ();  		foreach (int addr in GetBSTRCalls) {  			reader.BaseStream.Position = addr;  			reader.BaseStream.Position -= 2;  			if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 7;  			if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 2;  			if (reader.ReadByte () != 0x50)// push eax  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 6;  			if (reader.ReadByte () != 0x68)// push dword  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			int idx = reader.ReadInt32 ();  			if (idx > ms_nSize - 1)  				GetBSTRFail.Add (addr);  			else  				GetBSTR.Add (addr' idx);  		}  		Status ("Failed to find index of {0} references"' GetStringFail.Count + GetStringWFail.Count + GetBSTRFail.Count);  	}  	Status ("Successfully found index of {0} references"' GetString.Count + GetBSTR.Count + GetStringW.Count);  	Status ("Decoding strings");  	for (int index = 0; index < ms_nSize; ++index)  		if (index != -1 && index <= 0xffff)  			Strings.Add (index' StringPoolDecode (index));  	Status ("Populating table");  	foreach (var s in Strings)  		MainForm.Invoke (() => MainForm.dataTable.Rows.Add (s.Key' s.Value' string.Empty));  	foreach (var a in GetString)  		MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetString")));  	foreach (var a in GetBSTR)  		MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetBSTR")));  	foreach (var a in GetStringW)  		MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetStringW")));  }  else if (StringDecodeMethod == 1)// StringDecoder   {  	MainForm.Invoke (() => MainForm.Text += " [StringDecoder]");  	int type = 0;  	int name = 0;  	int offset = 0;  	//search for CStringDecoder::DelayedLoad' which contains the resource type and name  	if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00'  		0x89'  		0x45'  		0xF4'  		0x6A'  		0xAA'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x8B'  		0x4D'  		0xF4'  		0x51'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 12;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 1;  		name = reader.ReadInt32 ();  	}  	else if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00'  		0x6A'  		0xAA'  		0x8B'  		0xF8'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x57'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 9;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 3;  		name = reader.ReadInt32 ();  	}  	else if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0xAA'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 1;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 1;  		name = reader.ReadInt32 ();  	}  	else  		throw new Exception ("Failed to determine type and name of resource.");  	//search for start of function CStringDecoder::DelayedLoad()  	reader.BaseStream.Position -= 50;  	// should be enough  	FindAoBInFile (reader' (int)reader.BaseStream.Position' new byte[] {  		0x55'  		0x8B'  		0xEC'  		0x83'  		0xEC'  		0x10  	});  	int offset_CStringDecoder__DelayedLoad = (int)reader.BaseStream.Position;  	for (reader.BaseStream.Position = 0; reader.BaseStream.Position < reader.BaseStream.Length;) {  		if (reader.ReadByte () != 0xE8)  			// call  			continue;  		int offse = reader.ReadInt32 ();  		if (reader.BaseStream.Position + offse == offset_CStringDecoder__DelayedLoad) {  			Status ("{0:X8} reference to offset_CStringDecoder__DelayedLoad = {1:X8}"' reader.BaseStream.Position - 5' offse);  			break;  		}  	}  	ImageResourceDirectory tier1 = (ImageResourceDirectory)root.GetEntry (type).Entry;  	ImageResourceDirectory tier2 = (ImageResourceDirectory)tier1.GetEntry (name).Entry;  	rsrcStringDataEntry = (ImageResourceDataEntry)tier2.Entrys [0].Entry;  	rsrcStringDataPosition = rsrcPointerToRawData + (rsrcStringDataEntry.OffsetToData - rsrcVirtualAddress);  	m_nCount = GetWordFromIndex (0);  	Status ("Amount of strings: {0}"' m_nCount);  	for (int i = 1; i < m_nCount; ++i)  		MainForm.Invoke (() => MainForm.dataTable.Rows.Add (i' StringDecoderDecode (i)' string.Format ("{0:X8}"' rsrcStringDataPosition + i * 4)));  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: if (StringDecodeMethod == 0)// StringPool   {  	MainForm.Invoke (() => MainForm.Text += " [StringPool]");  	int offset_StringPool__ms_aKey = (int)reader.BaseStream.Position;  	Status ("StringPool::ms_aKey located at {0:X8}"' offset_StringPool__ms_aKey);  	int keyRef = 0;  	// Only GetString references ms_aKey  	byte[] bytes = new byte[5];  	bytes [0] = 0x68;  	// push offset  	Buffer.BlockCopy (BitConverter.GetBytes (ImageBase + offset_StringPool__ms_aKey)' 0' bytes' 1' 4);  	if (FindAoBInFile (reader' 0' bytes))  		keyRef = (int)reader.BaseStream.Position;  	reader.BaseStream.Position = keyRef;  	while (true) {  		byte[] asdf = reader.ReadBytes (5);  		if (asdf [4] == 0xc3)// retn  		 {  			bool die = true;  			foreach (byte b in asdf)  				if (b == 0xe8)// call  				 {  					die = false;  					break;  				}  			if (die)  				break;  		}  		reader.BaseStream.Position -= 6;  	}  	while (reader.ReadByte () == 0xcc)  		;  	// allign  	reader.BaseStream.Position -= 1;  	int offset_StringPool__GetString_uint_char = (int)reader.BaseStream.Position;  	Status ("StringPool::GetString(uint' char) located at {0:X8}"' offset_StringPool__GetString_uint_char);  	//search for StringPool::offset_ms_aString  	if (FindAoBInFile (reader' keyRef - 100' new byte[] {  		0x8b'  		0x0c  	}' 100))  		reader.BaseStream.Position += 3;  	else if (FindAoBInFile (reader' keyRef - 100' new byte[] {  		0x8b'  		0x86  	}' 100))  		reader.BaseStream.Position += 2;  	else  		throw new Exception ("could not find start of StringPool::offset_ms_aString");  	offset_StringPool__ms_aString = reader.ReadInt32 () - ImageBase;  	Status ("StringPool::ms_aString located at {0:X8}"' offset_StringPool__ms_aString);  	//search for xrefs to function StringPool::GetString(uint' char)   	int[] xref = FindCalls (offset_StringPool__GetString_uint_char' 2);  	if (xref.Length != 2)  		throw new Exception ("failed to find references to StringPool::GetString(uint' char)");  	//search for start of StringPool::GetString(uint)  	if (!FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x51'  		0x8b  	}' 50) && !FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x55'  		0x8b  	}' 50))  		throw new Exception ("could not find start of GetString(uint)");  	int offset_StringPool__GetString_uint = (int)reader.BaseStream.Position;  	Status ("StringPool::GetString(uint) located at {0:X8}"' offset_StringPool__GetString_uint);  	//search for start of StringPool::GetString(uint' ushort)  	for (reader.BaseStream.Position = xref [1]; (reader.ReadUInt32 () & 0xffffff00) != 0x000cc200; reader.BaseStream.Position -= 5)  		;  	//seek the start of function StringPool::GetString(uint' char)  	while (reader.ReadByte () == 0xcc)  		;  	// allign  	reader.BaseStream.Position -= 1;  	int offset_StringPool__GetString_uint_ushort = (int)reader.BaseStream.Position;  	Status ("StringPool::GetString(uint' ushort) located at {0:X8}"' offset_StringPool__GetString_uint_ushort);  	//search for xrefs to function StringPool::GetString(uint)  	xref = FindCalls (offset_StringPool__GetString_uint' 1);  	if (xref.Length != 1)  		throw new Exception ("failed to find references to StringPool::GetString(uint)");  	//search for start of function StringPool::GetBSTR(uint)  	reader.BaseStream.Position -= 100;  	// should be enough  	if (!FindAoBInFile (reader' (int)reader.BaseStream.Position' new byte[] {  		0xb8'  		0xaa'  		0xaa'  		0xaa'  		0x00  	}))  		for (reader.BaseStream.Position = xref [0]; (reader.ReadUInt32 () & 0xff00ff00) != 0x0000c200; reader.BaseStream.Position -= 5)  			;  	//seek the start of function StringPool::GetString(uint' char)  	while (reader.ReadByte () == 0xcc)  		;  	// allign  	reader.BaseStream.Position -= 1;  	int offset_StringPool__GetBSTR_uint = (int)reader.BaseStream.Position;  	Status ("StringPool::GetBSTR(uint) located at {0:X8}"' offset_StringPool__GetBSTR_uint);  	//search for xrefs to function StringPool::GetString(uint' ushort)  	xref = FindCalls (offset_StringPool__GetString_uint_ushort' 1);  	if (xref.Length != 1)  		throw new Exception ("failed to find references to StringPool::GetString(uint' ushort)");  	//search for start of function StringPool::GetStringW(uint)  	if (!FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x51'  		0x8b  	}' 50) && !FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x55'  		0x8b  	}' 50))  		throw new Exception ("could not find start of GetStringW(uint)");  	int offset_StringPool__GetStringW_uint = (int)reader.BaseStream.Position;  	Status ("StringPool::GetStringW(uint) located at {0:X8}"' offset_StringPool__GetStringW_uint);  	ms_nSize = GetIntFromOffset (offset_StringPool__ms_aKey + 16 + 4);  	Status ("Amount of strings: {0}"' ms_nSize);  	if (MessageBox.Show ("Scan for references to strings in the client? This can take a while."' "Warning"' MessageBoxButtons.YesNo' MessageBoxIcon.Warning) == DialogResult.Yes) {  		Status ("Searching for references to GetString' GetStringW' and GetBSTR");  		List<int> GetStringCalls = new List<int> ();  		List<int> GetStringWCalls = new List<int> ();  		List<int> GetBSTRCalls = new List<int> ();  		for (reader.BaseStream.Position = 0; reader.BaseStream.Position < reader.BaseStream.Length;) {  			//int lol = (int)((float)reader.BaseStream.Position / reader.BaseStream.Length * 100);  			//if (lol > MainForm.toolStripProgressBar1.Value)  			//{  			//    MainForm.Invoke(() => MainForm.toolStripProgressBar1.Value = lol);  			//    MainForm.Invoke(() => MainForm.Update());  			//} too expensive  			if (reader.ReadByte () != 0xE8)  				// call  				continue;  			int offset = reader.ReadInt32 ();  			if (reader.BaseStream.Position + offset == offset_StringPool__GetString_uint)  				GetStringCalls.Add ((int)reader.BaseStream.Position - 5);  			else if (reader.BaseStream.Position + offset == offset_StringPool__GetStringW_uint)  				GetStringWCalls.Add ((int)reader.BaseStream.Position - 5);  			else if (reader.BaseStream.Position + offset == offset_StringPool__GetBSTR_uint)  				GetBSTRCalls.Add ((int)reader.BaseStream.Position - 5);  			else  				reader.BaseStream.Position -= 4;  		}  		List<int> GetStringFail = new List<int> ();  		foreach (int addr in GetStringCalls) {  			reader.BaseStream.Position = addr;  			reader.BaseStream.Position -= 2;  			if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  			 {  				GetStringFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 7;  			if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  			 {  				GetStringFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 2;  			if (reader.ReadByte () != 0x50)// push eax  			 {  				GetStringFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 6;  			if (reader.ReadByte () != 0x68)// push dword  			 {  				GetStringFail.Add (addr);  				continue;  			}  			int idx = reader.ReadInt32 ();  			if (idx > ms_nSize - 1)  				GetStringFail.Add (addr);  			else  				GetString.Add (addr' idx);  		}  		List<int> GetStringWFail = new List<int> ();  		foreach (int addr in GetStringWCalls) {  			reader.BaseStream.Position = addr;  			reader.BaseStream.Position -= 2;  			if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 7;  			if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 2;  			if (reader.ReadByte () != 0x50)// push eax  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 6;  			if (reader.ReadByte () != 0x68)// push dword  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			int idx = reader.ReadInt32 ();  			if (idx > ms_nSize - 1)  				GetStringWFail.Add (addr);  			else  				GetStringW.Add (addr' idx);  		}  		List<int> GetBSTRFail = new List<int> ();  		foreach (int addr in GetBSTRCalls) {  			reader.BaseStream.Position = addr;  			reader.BaseStream.Position -= 2;  			if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 7;  			if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 2;  			if (reader.ReadByte () != 0x50)// push eax  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 6;  			if (reader.ReadByte () != 0x68)// push dword  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			int idx = reader.ReadInt32 ();  			if (idx > ms_nSize - 1)  				GetBSTRFail.Add (addr);  			else  				GetBSTR.Add (addr' idx);  		}  		Status ("Failed to find index of {0} references"' GetStringFail.Count + GetStringWFail.Count + GetBSTRFail.Count);  	}  	Status ("Successfully found index of {0} references"' GetString.Count + GetBSTR.Count + GetStringW.Count);  	Status ("Decoding strings");  	for (int index = 0; index < ms_nSize; ++index)  		if (index != -1 && index <= 0xffff)  			Strings.Add (index' StringPoolDecode (index));  	Status ("Populating table");  	foreach (var s in Strings)  		MainForm.Invoke (() => MainForm.dataTable.Rows.Add (s.Key' s.Value' string.Empty));  	foreach (var a in GetString)  		MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetString")));  	foreach (var a in GetBSTR)  		MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetBSTR")));  	foreach (var a in GetStringW)  		MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetStringW")));  }  else if (StringDecodeMethod == 1)// StringDecoder   {  	MainForm.Invoke (() => MainForm.Text += " [StringDecoder]");  	int type = 0;  	int name = 0;  	int offset = 0;  	//search for CStringDecoder::DelayedLoad' which contains the resource type and name  	if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00'  		0x89'  		0x45'  		0xF4'  		0x6A'  		0xAA'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x8B'  		0x4D'  		0xF4'  		0x51'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 12;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 1;  		name = reader.ReadInt32 ();  	}  	else if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00'  		0x6A'  		0xAA'  		0x8B'  		0xF8'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x57'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 9;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 3;  		name = reader.ReadInt32 ();  	}  	else if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0xAA'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 1;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 1;  		name = reader.ReadInt32 ();  	}  	else  		throw new Exception ("Failed to determine type and name of resource.");  	//search for start of function CStringDecoder::DelayedLoad()  	reader.BaseStream.Position -= 50;  	// should be enough  	FindAoBInFile (reader' (int)reader.BaseStream.Position' new byte[] {  		0x55'  		0x8B'  		0xEC'  		0x83'  		0xEC'  		0x10  	});  	int offset_CStringDecoder__DelayedLoad = (int)reader.BaseStream.Position;  	for (reader.BaseStream.Position = 0; reader.BaseStream.Position < reader.BaseStream.Length;) {  		if (reader.ReadByte () != 0xE8)  			// call  			continue;  		int offse = reader.ReadInt32 ();  		if (reader.BaseStream.Position + offse == offset_CStringDecoder__DelayedLoad) {  			Status ("{0:X8} reference to offset_CStringDecoder__DelayedLoad = {1:X8}"' reader.BaseStream.Position - 5' offse);  			break;  		}  	}  	ImageResourceDirectory tier1 = (ImageResourceDirectory)root.GetEntry (type).Entry;  	ImageResourceDirectory tier2 = (ImageResourceDirectory)tier1.GetEntry (name).Entry;  	rsrcStringDataEntry = (ImageResourceDataEntry)tier2.Entrys [0].Entry;  	rsrcStringDataPosition = rsrcPointerToRawData + (rsrcStringDataEntry.OffsetToData - rsrcVirtualAddress);  	m_nCount = GetWordFromIndex (0);  	Status ("Amount of strings: {0}"' m_nCount);  	for (int i = 1; i < m_nCount; ++i)  		MainForm.Invoke (() => MainForm.dataTable.Rows.Add (i' StringDecoderDecode (i)' string.Format ("{0:X8}"' rsrcStringDataPosition + i * 4)));  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: if (StringDecodeMethod == 0)// StringPool   {  	MainForm.Invoke (() => MainForm.Text += " [StringPool]");  	int offset_StringPool__ms_aKey = (int)reader.BaseStream.Position;  	Status ("StringPool::ms_aKey located at {0:X8}"' offset_StringPool__ms_aKey);  	int keyRef = 0;  	// Only GetString references ms_aKey  	byte[] bytes = new byte[5];  	bytes [0] = 0x68;  	// push offset  	Buffer.BlockCopy (BitConverter.GetBytes (ImageBase + offset_StringPool__ms_aKey)' 0' bytes' 1' 4);  	if (FindAoBInFile (reader' 0' bytes))  		keyRef = (int)reader.BaseStream.Position;  	reader.BaseStream.Position = keyRef;  	while (true) {  		byte[] asdf = reader.ReadBytes (5);  		if (asdf [4] == 0xc3)// retn  		 {  			bool die = true;  			foreach (byte b in asdf)  				if (b == 0xe8)// call  				 {  					die = false;  					break;  				}  			if (die)  				break;  		}  		reader.BaseStream.Position -= 6;  	}  	while (reader.ReadByte () == 0xcc)  		;  	// allign  	reader.BaseStream.Position -= 1;  	int offset_StringPool__GetString_uint_char = (int)reader.BaseStream.Position;  	Status ("StringPool::GetString(uint' char) located at {0:X8}"' offset_StringPool__GetString_uint_char);  	//search for StringPool::offset_ms_aString  	if (FindAoBInFile (reader' keyRef - 100' new byte[] {  		0x8b'  		0x0c  	}' 100))  		reader.BaseStream.Position += 3;  	else if (FindAoBInFile (reader' keyRef - 100' new byte[] {  		0x8b'  		0x86  	}' 100))  		reader.BaseStream.Position += 2;  	else  		throw new Exception ("could not find start of StringPool::offset_ms_aString");  	offset_StringPool__ms_aString = reader.ReadInt32 () - ImageBase;  	Status ("StringPool::ms_aString located at {0:X8}"' offset_StringPool__ms_aString);  	//search for xrefs to function StringPool::GetString(uint' char)   	int[] xref = FindCalls (offset_StringPool__GetString_uint_char' 2);  	if (xref.Length != 2)  		throw new Exception ("failed to find references to StringPool::GetString(uint' char)");  	//search for start of StringPool::GetString(uint)  	if (!FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x51'  		0x8b  	}' 50) && !FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x55'  		0x8b  	}' 50))  		throw new Exception ("could not find start of GetString(uint)");  	int offset_StringPool__GetString_uint = (int)reader.BaseStream.Position;  	Status ("StringPool::GetString(uint) located at {0:X8}"' offset_StringPool__GetString_uint);  	//search for start of StringPool::GetString(uint' ushort)  	for (reader.BaseStream.Position = xref [1]; (reader.ReadUInt32 () & 0xffffff00) != 0x000cc200; reader.BaseStream.Position -= 5)  		;  	//seek the start of function StringPool::GetString(uint' char)  	while (reader.ReadByte () == 0xcc)  		;  	// allign  	reader.BaseStream.Position -= 1;  	int offset_StringPool__GetString_uint_ushort = (int)reader.BaseStream.Position;  	Status ("StringPool::GetString(uint' ushort) located at {0:X8}"' offset_StringPool__GetString_uint_ushort);  	//search for xrefs to function StringPool::GetString(uint)  	xref = FindCalls (offset_StringPool__GetString_uint' 1);  	if (xref.Length != 1)  		throw new Exception ("failed to find references to StringPool::GetString(uint)");  	//search for start of function StringPool::GetBSTR(uint)  	reader.BaseStream.Position -= 100;  	// should be enough  	if (!FindAoBInFile (reader' (int)reader.BaseStream.Position' new byte[] {  		0xb8'  		0xaa'  		0xaa'  		0xaa'  		0x00  	}))  		for (reader.BaseStream.Position = xref [0]; (reader.ReadUInt32 () & 0xff00ff00) != 0x0000c200; reader.BaseStream.Position -= 5)  			;  	//seek the start of function StringPool::GetString(uint' char)  	while (reader.ReadByte () == 0xcc)  		;  	// allign  	reader.BaseStream.Position -= 1;  	int offset_StringPool__GetBSTR_uint = (int)reader.BaseStream.Position;  	Status ("StringPool::GetBSTR(uint) located at {0:X8}"' offset_StringPool__GetBSTR_uint);  	//search for xrefs to function StringPool::GetString(uint' ushort)  	xref = FindCalls (offset_StringPool__GetString_uint_ushort' 1);  	if (xref.Length != 1)  		throw new Exception ("failed to find references to StringPool::GetString(uint' ushort)");  	//search for start of function StringPool::GetStringW(uint)  	if (!FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x51'  		0x8b  	}' 50) && !FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x55'  		0x8b  	}' 50))  		throw new Exception ("could not find start of GetStringW(uint)");  	int offset_StringPool__GetStringW_uint = (int)reader.BaseStream.Position;  	Status ("StringPool::GetStringW(uint) located at {0:X8}"' offset_StringPool__GetStringW_uint);  	ms_nSize = GetIntFromOffset (offset_StringPool__ms_aKey + 16 + 4);  	Status ("Amount of strings: {0}"' ms_nSize);  	if (MessageBox.Show ("Scan for references to strings in the client? This can take a while."' "Warning"' MessageBoxButtons.YesNo' MessageBoxIcon.Warning) == DialogResult.Yes) {  		Status ("Searching for references to GetString' GetStringW' and GetBSTR");  		List<int> GetStringCalls = new List<int> ();  		List<int> GetStringWCalls = new List<int> ();  		List<int> GetBSTRCalls = new List<int> ();  		for (reader.BaseStream.Position = 0; reader.BaseStream.Position < reader.BaseStream.Length;) {  			//int lol = (int)((float)reader.BaseStream.Position / reader.BaseStream.Length * 100);  			//if (lol > MainForm.toolStripProgressBar1.Value)  			//{  			//    MainForm.Invoke(() => MainForm.toolStripProgressBar1.Value = lol);  			//    MainForm.Invoke(() => MainForm.Update());  			//} too expensive  			if (reader.ReadByte () != 0xE8)  				// call  				continue;  			int offset = reader.ReadInt32 ();  			if (reader.BaseStream.Position + offset == offset_StringPool__GetString_uint)  				GetStringCalls.Add ((int)reader.BaseStream.Position - 5);  			else if (reader.BaseStream.Position + offset == offset_StringPool__GetStringW_uint)  				GetStringWCalls.Add ((int)reader.BaseStream.Position - 5);  			else if (reader.BaseStream.Position + offset == offset_StringPool__GetBSTR_uint)  				GetBSTRCalls.Add ((int)reader.BaseStream.Position - 5);  			else  				reader.BaseStream.Position -= 4;  		}  		List<int> GetStringFail = new List<int> ();  		foreach (int addr in GetStringCalls) {  			reader.BaseStream.Position = addr;  			reader.BaseStream.Position -= 2;  			if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  			 {  				GetStringFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 7;  			if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  			 {  				GetStringFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 2;  			if (reader.ReadByte () != 0x50)// push eax  			 {  				GetStringFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 6;  			if (reader.ReadByte () != 0x68)// push dword  			 {  				GetStringFail.Add (addr);  				continue;  			}  			int idx = reader.ReadInt32 ();  			if (idx > ms_nSize - 1)  				GetStringFail.Add (addr);  			else  				GetString.Add (addr' idx);  		}  		List<int> GetStringWFail = new List<int> ();  		foreach (int addr in GetStringWCalls) {  			reader.BaseStream.Position = addr;  			reader.BaseStream.Position -= 2;  			if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 7;  			if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 2;  			if (reader.ReadByte () != 0x50)// push eax  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 6;  			if (reader.ReadByte () != 0x68)// push dword  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			int idx = reader.ReadInt32 ();  			if (idx > ms_nSize - 1)  				GetStringWFail.Add (addr);  			else  				GetStringW.Add (addr' idx);  		}  		List<int> GetBSTRFail = new List<int> ();  		foreach (int addr in GetBSTRCalls) {  			reader.BaseStream.Position = addr;  			reader.BaseStream.Position -= 2;  			if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 7;  			if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 2;  			if (reader.ReadByte () != 0x50)// push eax  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 6;  			if (reader.ReadByte () != 0x68)// push dword  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			int idx = reader.ReadInt32 ();  			if (idx > ms_nSize - 1)  				GetBSTRFail.Add (addr);  			else  				GetBSTR.Add (addr' idx);  		}  		Status ("Failed to find index of {0} references"' GetStringFail.Count + GetStringWFail.Count + GetBSTRFail.Count);  	}  	Status ("Successfully found index of {0} references"' GetString.Count + GetBSTR.Count + GetStringW.Count);  	Status ("Decoding strings");  	for (int index = 0; index < ms_nSize; ++index)  		if (index != -1 && index <= 0xffff)  			Strings.Add (index' StringPoolDecode (index));  	Status ("Populating table");  	foreach (var s in Strings)  		MainForm.Invoke (() => MainForm.dataTable.Rows.Add (s.Key' s.Value' string.Empty));  	foreach (var a in GetString)  		MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetString")));  	foreach (var a in GetBSTR)  		MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetBSTR")));  	foreach (var a in GetStringW)  		MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetStringW")));  }  else if (StringDecodeMethod == 1)// StringDecoder   {  	MainForm.Invoke (() => MainForm.Text += " [StringDecoder]");  	int type = 0;  	int name = 0;  	int offset = 0;  	//search for CStringDecoder::DelayedLoad' which contains the resource type and name  	if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00'  		0x89'  		0x45'  		0xF4'  		0x6A'  		0xAA'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x8B'  		0x4D'  		0xF4'  		0x51'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 12;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 1;  		name = reader.ReadInt32 ();  	}  	else if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00'  		0x6A'  		0xAA'  		0x8B'  		0xF8'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x57'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 9;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 3;  		name = reader.ReadInt32 ();  	}  	else if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0xAA'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 1;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 1;  		name = reader.ReadInt32 ();  	}  	else  		throw new Exception ("Failed to determine type and name of resource.");  	//search for start of function CStringDecoder::DelayedLoad()  	reader.BaseStream.Position -= 50;  	// should be enough  	FindAoBInFile (reader' (int)reader.BaseStream.Position' new byte[] {  		0x55'  		0x8B'  		0xEC'  		0x83'  		0xEC'  		0x10  	});  	int offset_CStringDecoder__DelayedLoad = (int)reader.BaseStream.Position;  	for (reader.BaseStream.Position = 0; reader.BaseStream.Position < reader.BaseStream.Length;) {  		if (reader.ReadByte () != 0xE8)  			// call  			continue;  		int offse = reader.ReadInt32 ();  		if (reader.BaseStream.Position + offse == offset_CStringDecoder__DelayedLoad) {  			Status ("{0:X8} reference to offset_CStringDecoder__DelayedLoad = {1:X8}"' reader.BaseStream.Position - 5' offse);  			break;  		}  	}  	ImageResourceDirectory tier1 = (ImageResourceDirectory)root.GetEntry (type).Entry;  	ImageResourceDirectory tier2 = (ImageResourceDirectory)tier1.GetEntry (name).Entry;  	rsrcStringDataEntry = (ImageResourceDataEntry)tier2.Entrys [0].Entry;  	rsrcStringDataPosition = rsrcPointerToRawData + (rsrcStringDataEntry.OffsetToData - rsrcVirtualAddress);  	m_nCount = GetWordFromIndex (0);  	Status ("Amount of strings: {0}"' m_nCount);  	for (int i = 1; i < m_nCount; ++i)  		MainForm.Invoke (() => MainForm.dataTable.Rows.Add (i' StringDecoderDecode (i)' string.Format ("{0:X8}"' rsrcStringDataPosition + i * 4)));  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: if (StringDecodeMethod == 0)// StringPool   {  	MainForm.Invoke (() => MainForm.Text += " [StringPool]");  	int offset_StringPool__ms_aKey = (int)reader.BaseStream.Position;  	Status ("StringPool::ms_aKey located at {0:X8}"' offset_StringPool__ms_aKey);  	int keyRef = 0;  	// Only GetString references ms_aKey  	byte[] bytes = new byte[5];  	bytes [0] = 0x68;  	// push offset  	Buffer.BlockCopy (BitConverter.GetBytes (ImageBase + offset_StringPool__ms_aKey)' 0' bytes' 1' 4);  	if (FindAoBInFile (reader' 0' bytes))  		keyRef = (int)reader.BaseStream.Position;  	reader.BaseStream.Position = keyRef;  	while (true) {  		byte[] asdf = reader.ReadBytes (5);  		if (asdf [4] == 0xc3)// retn  		 {  			bool die = true;  			foreach (byte b in asdf)  				if (b == 0xe8)// call  				 {  					die = false;  					break;  				}  			if (die)  				break;  		}  		reader.BaseStream.Position -= 6;  	}  	while (reader.ReadByte () == 0xcc)  		;  	// allign  	reader.BaseStream.Position -= 1;  	int offset_StringPool__GetString_uint_char = (int)reader.BaseStream.Position;  	Status ("StringPool::GetString(uint' char) located at {0:X8}"' offset_StringPool__GetString_uint_char);  	//search for StringPool::offset_ms_aString  	if (FindAoBInFile (reader' keyRef - 100' new byte[] {  		0x8b'  		0x0c  	}' 100))  		reader.BaseStream.Position += 3;  	else if (FindAoBInFile (reader' keyRef - 100' new byte[] {  		0x8b'  		0x86  	}' 100))  		reader.BaseStream.Position += 2;  	else  		throw new Exception ("could not find start of StringPool::offset_ms_aString");  	offset_StringPool__ms_aString = reader.ReadInt32 () - ImageBase;  	Status ("StringPool::ms_aString located at {0:X8}"' offset_StringPool__ms_aString);  	//search for xrefs to function StringPool::GetString(uint' char)   	int[] xref = FindCalls (offset_StringPool__GetString_uint_char' 2);  	if (xref.Length != 2)  		throw new Exception ("failed to find references to StringPool::GetString(uint' char)");  	//search for start of StringPool::GetString(uint)  	if (!FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x51'  		0x8b  	}' 50) && !FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x55'  		0x8b  	}' 50))  		throw new Exception ("could not find start of GetString(uint)");  	int offset_StringPool__GetString_uint = (int)reader.BaseStream.Position;  	Status ("StringPool::GetString(uint) located at {0:X8}"' offset_StringPool__GetString_uint);  	//search for start of StringPool::GetString(uint' ushort)  	for (reader.BaseStream.Position = xref [1]; (reader.ReadUInt32 () & 0xffffff00) != 0x000cc200; reader.BaseStream.Position -= 5)  		;  	//seek the start of function StringPool::GetString(uint' char)  	while (reader.ReadByte () == 0xcc)  		;  	// allign  	reader.BaseStream.Position -= 1;  	int offset_StringPool__GetString_uint_ushort = (int)reader.BaseStream.Position;  	Status ("StringPool::GetString(uint' ushort) located at {0:X8}"' offset_StringPool__GetString_uint_ushort);  	//search for xrefs to function StringPool::GetString(uint)  	xref = FindCalls (offset_StringPool__GetString_uint' 1);  	if (xref.Length != 1)  		throw new Exception ("failed to find references to StringPool::GetString(uint)");  	//search for start of function StringPool::GetBSTR(uint)  	reader.BaseStream.Position -= 100;  	// should be enough  	if (!FindAoBInFile (reader' (int)reader.BaseStream.Position' new byte[] {  		0xb8'  		0xaa'  		0xaa'  		0xaa'  		0x00  	}))  		for (reader.BaseStream.Position = xref [0]; (reader.ReadUInt32 () & 0xff00ff00) != 0x0000c200; reader.BaseStream.Position -= 5)  			;  	//seek the start of function StringPool::GetString(uint' char)  	while (reader.ReadByte () == 0xcc)  		;  	// allign  	reader.BaseStream.Position -= 1;  	int offset_StringPool__GetBSTR_uint = (int)reader.BaseStream.Position;  	Status ("StringPool::GetBSTR(uint) located at {0:X8}"' offset_StringPool__GetBSTR_uint);  	//search for xrefs to function StringPool::GetString(uint' ushort)  	xref = FindCalls (offset_StringPool__GetString_uint_ushort' 1);  	if (xref.Length != 1)  		throw new Exception ("failed to find references to StringPool::GetString(uint' ushort)");  	//search for start of function StringPool::GetStringW(uint)  	if (!FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x51'  		0x8b  	}' 50) && !FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x55'  		0x8b  	}' 50))  		throw new Exception ("could not find start of GetStringW(uint)");  	int offset_StringPool__GetStringW_uint = (int)reader.BaseStream.Position;  	Status ("StringPool::GetStringW(uint) located at {0:X8}"' offset_StringPool__GetStringW_uint);  	ms_nSize = GetIntFromOffset (offset_StringPool__ms_aKey + 16 + 4);  	Status ("Amount of strings: {0}"' ms_nSize);  	if (MessageBox.Show ("Scan for references to strings in the client? This can take a while."' "Warning"' MessageBoxButtons.YesNo' MessageBoxIcon.Warning) == DialogResult.Yes) {  		Status ("Searching for references to GetString' GetStringW' and GetBSTR");  		List<int> GetStringCalls = new List<int> ();  		List<int> GetStringWCalls = new List<int> ();  		List<int> GetBSTRCalls = new List<int> ();  		for (reader.BaseStream.Position = 0; reader.BaseStream.Position < reader.BaseStream.Length;) {  			//int lol = (int)((float)reader.BaseStream.Position / reader.BaseStream.Length * 100);  			//if (lol > MainForm.toolStripProgressBar1.Value)  			//{  			//    MainForm.Invoke(() => MainForm.toolStripProgressBar1.Value = lol);  			//    MainForm.Invoke(() => MainForm.Update());  			//} too expensive  			if (reader.ReadByte () != 0xE8)  				// call  				continue;  			int offset = reader.ReadInt32 ();  			if (reader.BaseStream.Position + offset == offset_StringPool__GetString_uint)  				GetStringCalls.Add ((int)reader.BaseStream.Position - 5);  			else if (reader.BaseStream.Position + offset == offset_StringPool__GetStringW_uint)  				GetStringWCalls.Add ((int)reader.BaseStream.Position - 5);  			else if (reader.BaseStream.Position + offset == offset_StringPool__GetBSTR_uint)  				GetBSTRCalls.Add ((int)reader.BaseStream.Position - 5);  			else  				reader.BaseStream.Position -= 4;  		}  		List<int> GetStringFail = new List<int> ();  		foreach (int addr in GetStringCalls) {  			reader.BaseStream.Position = addr;  			reader.BaseStream.Position -= 2;  			if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  			 {  				GetStringFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 7;  			if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  			 {  				GetStringFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 2;  			if (reader.ReadByte () != 0x50)// push eax  			 {  				GetStringFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 6;  			if (reader.ReadByte () != 0x68)// push dword  			 {  				GetStringFail.Add (addr);  				continue;  			}  			int idx = reader.ReadInt32 ();  			if (idx > ms_nSize - 1)  				GetStringFail.Add (addr);  			else  				GetString.Add (addr' idx);  		}  		List<int> GetStringWFail = new List<int> ();  		foreach (int addr in GetStringWCalls) {  			reader.BaseStream.Position = addr;  			reader.BaseStream.Position -= 2;  			if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 7;  			if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 2;  			if (reader.ReadByte () != 0x50)// push eax  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 6;  			if (reader.ReadByte () != 0x68)// push dword  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			int idx = reader.ReadInt32 ();  			if (idx > ms_nSize - 1)  				GetStringWFail.Add (addr);  			else  				GetStringW.Add (addr' idx);  		}  		List<int> GetBSTRFail = new List<int> ();  		foreach (int addr in GetBSTRCalls) {  			reader.BaseStream.Position = addr;  			reader.BaseStream.Position -= 2;  			if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 7;  			if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 2;  			if (reader.ReadByte () != 0x50)// push eax  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 6;  			if (reader.ReadByte () != 0x68)// push dword  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			int idx = reader.ReadInt32 ();  			if (idx > ms_nSize - 1)  				GetBSTRFail.Add (addr);  			else  				GetBSTR.Add (addr' idx);  		}  		Status ("Failed to find index of {0} references"' GetStringFail.Count + GetStringWFail.Count + GetBSTRFail.Count);  	}  	Status ("Successfully found index of {0} references"' GetString.Count + GetBSTR.Count + GetStringW.Count);  	Status ("Decoding strings");  	for (int index = 0; index < ms_nSize; ++index)  		if (index != -1 && index <= 0xffff)  			Strings.Add (index' StringPoolDecode (index));  	Status ("Populating table");  	foreach (var s in Strings)  		MainForm.Invoke (() => MainForm.dataTable.Rows.Add (s.Key' s.Value' string.Empty));  	foreach (var a in GetString)  		MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetString")));  	foreach (var a in GetBSTR)  		MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetBSTR")));  	foreach (var a in GetStringW)  		MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetStringW")));  }  else if (StringDecodeMethod == 1)// StringDecoder   {  	MainForm.Invoke (() => MainForm.Text += " [StringDecoder]");  	int type = 0;  	int name = 0;  	int offset = 0;  	//search for CStringDecoder::DelayedLoad' which contains the resource type and name  	if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00'  		0x89'  		0x45'  		0xF4'  		0x6A'  		0xAA'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x8B'  		0x4D'  		0xF4'  		0x51'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 12;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 1;  		name = reader.ReadInt32 ();  	}  	else if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00'  		0x6A'  		0xAA'  		0x8B'  		0xF8'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x57'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 9;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 3;  		name = reader.ReadInt32 ();  	}  	else if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0xAA'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 1;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 1;  		name = reader.ReadInt32 ();  	}  	else  		throw new Exception ("Failed to determine type and name of resource.");  	//search for start of function CStringDecoder::DelayedLoad()  	reader.BaseStream.Position -= 50;  	// should be enough  	FindAoBInFile (reader' (int)reader.BaseStream.Position' new byte[] {  		0x55'  		0x8B'  		0xEC'  		0x83'  		0xEC'  		0x10  	});  	int offset_CStringDecoder__DelayedLoad = (int)reader.BaseStream.Position;  	for (reader.BaseStream.Position = 0; reader.BaseStream.Position < reader.BaseStream.Length;) {  		if (reader.ReadByte () != 0xE8)  			// call  			continue;  		int offse = reader.ReadInt32 ();  		if (reader.BaseStream.Position + offse == offset_CStringDecoder__DelayedLoad) {  			Status ("{0:X8} reference to offset_CStringDecoder__DelayedLoad = {1:X8}"' reader.BaseStream.Position - 5' offse);  			break;  		}  	}  	ImageResourceDirectory tier1 = (ImageResourceDirectory)root.GetEntry (type).Entry;  	ImageResourceDirectory tier2 = (ImageResourceDirectory)tier1.GetEntry (name).Entry;  	rsrcStringDataEntry = (ImageResourceDataEntry)tier2.Entrys [0].Entry;  	rsrcStringDataPosition = rsrcPointerToRawData + (rsrcStringDataEntry.OffsetToData - rsrcVirtualAddress);  	m_nCount = GetWordFromIndex (0);  	Status ("Amount of strings: {0}"' m_nCount);  	for (int i = 1; i < m_nCount; ++i)  		MainForm.Invoke (() => MainForm.dataTable.Rows.Add (i' StringDecoderDecode (i)' string.Format ("{0:X8}"' rsrcStringDataPosition + i * 4)));  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: if (StringDecodeMethod == 0)// StringPool   {  	MainForm.Invoke (() => MainForm.Text += " [StringPool]");  	int offset_StringPool__ms_aKey = (int)reader.BaseStream.Position;  	Status ("StringPool::ms_aKey located at {0:X8}"' offset_StringPool__ms_aKey);  	int keyRef = 0;  	// Only GetString references ms_aKey  	byte[] bytes = new byte[5];  	bytes [0] = 0x68;  	// push offset  	Buffer.BlockCopy (BitConverter.GetBytes (ImageBase + offset_StringPool__ms_aKey)' 0' bytes' 1' 4);  	if (FindAoBInFile (reader' 0' bytes))  		keyRef = (int)reader.BaseStream.Position;  	reader.BaseStream.Position = keyRef;  	while (true) {  		byte[] asdf = reader.ReadBytes (5);  		if (asdf [4] == 0xc3)// retn  		 {  			bool die = true;  			foreach (byte b in asdf)  				if (b == 0xe8)// call  				 {  					die = false;  					break;  				}  			if (die)  				break;  		}  		reader.BaseStream.Position -= 6;  	}  	while (reader.ReadByte () == 0xcc)  		;  	// allign  	reader.BaseStream.Position -= 1;  	int offset_StringPool__GetString_uint_char = (int)reader.BaseStream.Position;  	Status ("StringPool::GetString(uint' char) located at {0:X8}"' offset_StringPool__GetString_uint_char);  	//search for StringPool::offset_ms_aString  	if (FindAoBInFile (reader' keyRef - 100' new byte[] {  		0x8b'  		0x0c  	}' 100))  		reader.BaseStream.Position += 3;  	else if (FindAoBInFile (reader' keyRef - 100' new byte[] {  		0x8b'  		0x86  	}' 100))  		reader.BaseStream.Position += 2;  	else  		throw new Exception ("could not find start of StringPool::offset_ms_aString");  	offset_StringPool__ms_aString = reader.ReadInt32 () - ImageBase;  	Status ("StringPool::ms_aString located at {0:X8}"' offset_StringPool__ms_aString);  	//search for xrefs to function StringPool::GetString(uint' char)   	int[] xref = FindCalls (offset_StringPool__GetString_uint_char' 2);  	if (xref.Length != 2)  		throw new Exception ("failed to find references to StringPool::GetString(uint' char)");  	//search for start of StringPool::GetString(uint)  	if (!FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x51'  		0x8b  	}' 50) && !FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x55'  		0x8b  	}' 50))  		throw new Exception ("could not find start of GetString(uint)");  	int offset_StringPool__GetString_uint = (int)reader.BaseStream.Position;  	Status ("StringPool::GetString(uint) located at {0:X8}"' offset_StringPool__GetString_uint);  	//search for start of StringPool::GetString(uint' ushort)  	for (reader.BaseStream.Position = xref [1]; (reader.ReadUInt32 () & 0xffffff00) != 0x000cc200; reader.BaseStream.Position -= 5)  		;  	//seek the start of function StringPool::GetString(uint' char)  	while (reader.ReadByte () == 0xcc)  		;  	// allign  	reader.BaseStream.Position -= 1;  	int offset_StringPool__GetString_uint_ushort = (int)reader.BaseStream.Position;  	Status ("StringPool::GetString(uint' ushort) located at {0:X8}"' offset_StringPool__GetString_uint_ushort);  	//search for xrefs to function StringPool::GetString(uint)  	xref = FindCalls (offset_StringPool__GetString_uint' 1);  	if (xref.Length != 1)  		throw new Exception ("failed to find references to StringPool::GetString(uint)");  	//search for start of function StringPool::GetBSTR(uint)  	reader.BaseStream.Position -= 100;  	// should be enough  	if (!FindAoBInFile (reader' (int)reader.BaseStream.Position' new byte[] {  		0xb8'  		0xaa'  		0xaa'  		0xaa'  		0x00  	}))  		for (reader.BaseStream.Position = xref [0]; (reader.ReadUInt32 () & 0xff00ff00) != 0x0000c200; reader.BaseStream.Position -= 5)  			;  	//seek the start of function StringPool::GetString(uint' char)  	while (reader.ReadByte () == 0xcc)  		;  	// allign  	reader.BaseStream.Position -= 1;  	int offset_StringPool__GetBSTR_uint = (int)reader.BaseStream.Position;  	Status ("StringPool::GetBSTR(uint) located at {0:X8}"' offset_StringPool__GetBSTR_uint);  	//search for xrefs to function StringPool::GetString(uint' ushort)  	xref = FindCalls (offset_StringPool__GetString_uint_ushort' 1);  	if (xref.Length != 1)  		throw new Exception ("failed to find references to StringPool::GetString(uint' ushort)");  	//search for start of function StringPool::GetStringW(uint)  	if (!FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x51'  		0x8b  	}' 50) && !FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x55'  		0x8b  	}' 50))  		throw new Exception ("could not find start of GetStringW(uint)");  	int offset_StringPool__GetStringW_uint = (int)reader.BaseStream.Position;  	Status ("StringPool::GetStringW(uint) located at {0:X8}"' offset_StringPool__GetStringW_uint);  	ms_nSize = GetIntFromOffset (offset_StringPool__ms_aKey + 16 + 4);  	Status ("Amount of strings: {0}"' ms_nSize);  	if (MessageBox.Show ("Scan for references to strings in the client? This can take a while."' "Warning"' MessageBoxButtons.YesNo' MessageBoxIcon.Warning) == DialogResult.Yes) {  		Status ("Searching for references to GetString' GetStringW' and GetBSTR");  		List<int> GetStringCalls = new List<int> ();  		List<int> GetStringWCalls = new List<int> ();  		List<int> GetBSTRCalls = new List<int> ();  		for (reader.BaseStream.Position = 0; reader.BaseStream.Position < reader.BaseStream.Length;) {  			//int lol = (int)((float)reader.BaseStream.Position / reader.BaseStream.Length * 100);  			//if (lol > MainForm.toolStripProgressBar1.Value)  			//{  			//    MainForm.Invoke(() => MainForm.toolStripProgressBar1.Value = lol);  			//    MainForm.Invoke(() => MainForm.Update());  			//} too expensive  			if (reader.ReadByte () != 0xE8)  				// call  				continue;  			int offset = reader.ReadInt32 ();  			if (reader.BaseStream.Position + offset == offset_StringPool__GetString_uint)  				GetStringCalls.Add ((int)reader.BaseStream.Position - 5);  			else if (reader.BaseStream.Position + offset == offset_StringPool__GetStringW_uint)  				GetStringWCalls.Add ((int)reader.BaseStream.Position - 5);  			else if (reader.BaseStream.Position + offset == offset_StringPool__GetBSTR_uint)  				GetBSTRCalls.Add ((int)reader.BaseStream.Position - 5);  			else  				reader.BaseStream.Position -= 4;  		}  		List<int> GetStringFail = new List<int> ();  		foreach (int addr in GetStringCalls) {  			reader.BaseStream.Position = addr;  			reader.BaseStream.Position -= 2;  			if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  			 {  				GetStringFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 7;  			if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  			 {  				GetStringFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 2;  			if (reader.ReadByte () != 0x50)// push eax  			 {  				GetStringFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 6;  			if (reader.ReadByte () != 0x68)// push dword  			 {  				GetStringFail.Add (addr);  				continue;  			}  			int idx = reader.ReadInt32 ();  			if (idx > ms_nSize - 1)  				GetStringFail.Add (addr);  			else  				GetString.Add (addr' idx);  		}  		List<int> GetStringWFail = new List<int> ();  		foreach (int addr in GetStringWCalls) {  			reader.BaseStream.Position = addr;  			reader.BaseStream.Position -= 2;  			if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 7;  			if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 2;  			if (reader.ReadByte () != 0x50)// push eax  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 6;  			if (reader.ReadByte () != 0x68)// push dword  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			int idx = reader.ReadInt32 ();  			if (idx > ms_nSize - 1)  				GetStringWFail.Add (addr);  			else  				GetStringW.Add (addr' idx);  		}  		List<int> GetBSTRFail = new List<int> ();  		foreach (int addr in GetBSTRCalls) {  			reader.BaseStream.Position = addr;  			reader.BaseStream.Position -= 2;  			if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 7;  			if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 2;  			if (reader.ReadByte () != 0x50)// push eax  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 6;  			if (reader.ReadByte () != 0x68)// push dword  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			int idx = reader.ReadInt32 ();  			if (idx > ms_nSize - 1)  				GetBSTRFail.Add (addr);  			else  				GetBSTR.Add (addr' idx);  		}  		Status ("Failed to find index of {0} references"' GetStringFail.Count + GetStringWFail.Count + GetBSTRFail.Count);  	}  	Status ("Successfully found index of {0} references"' GetString.Count + GetBSTR.Count + GetStringW.Count);  	Status ("Decoding strings");  	for (int index = 0; index < ms_nSize; ++index)  		if (index != -1 && index <= 0xffff)  			Strings.Add (index' StringPoolDecode (index));  	Status ("Populating table");  	foreach (var s in Strings)  		MainForm.Invoke (() => MainForm.dataTable.Rows.Add (s.Key' s.Value' string.Empty));  	foreach (var a in GetString)  		MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetString")));  	foreach (var a in GetBSTR)  		MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetBSTR")));  	foreach (var a in GetStringW)  		MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetStringW")));  }  else if (StringDecodeMethod == 1)// StringDecoder   {  	MainForm.Invoke (() => MainForm.Text += " [StringDecoder]");  	int type = 0;  	int name = 0;  	int offset = 0;  	//search for CStringDecoder::DelayedLoad' which contains the resource type and name  	if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00'  		0x89'  		0x45'  		0xF4'  		0x6A'  		0xAA'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x8B'  		0x4D'  		0xF4'  		0x51'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 12;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 1;  		name = reader.ReadInt32 ();  	}  	else if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00'  		0x6A'  		0xAA'  		0x8B'  		0xF8'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x57'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 9;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 3;  		name = reader.ReadInt32 ();  	}  	else if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0xAA'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 1;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 1;  		name = reader.ReadInt32 ();  	}  	else  		throw new Exception ("Failed to determine type and name of resource.");  	//search for start of function CStringDecoder::DelayedLoad()  	reader.BaseStream.Position -= 50;  	// should be enough  	FindAoBInFile (reader' (int)reader.BaseStream.Position' new byte[] {  		0x55'  		0x8B'  		0xEC'  		0x83'  		0xEC'  		0x10  	});  	int offset_CStringDecoder__DelayedLoad = (int)reader.BaseStream.Position;  	for (reader.BaseStream.Position = 0; reader.BaseStream.Position < reader.BaseStream.Length;) {  		if (reader.ReadByte () != 0xE8)  			// call  			continue;  		int offse = reader.ReadInt32 ();  		if (reader.BaseStream.Position + offse == offset_CStringDecoder__DelayedLoad) {  			Status ("{0:X8} reference to offset_CStringDecoder__DelayedLoad = {1:X8}"' reader.BaseStream.Position - 5' offse);  			break;  		}  	}  	ImageResourceDirectory tier1 = (ImageResourceDirectory)root.GetEntry (type).Entry;  	ImageResourceDirectory tier2 = (ImageResourceDirectory)tier1.GetEntry (name).Entry;  	rsrcStringDataEntry = (ImageResourceDataEntry)tier2.Entrys [0].Entry;  	rsrcStringDataPosition = rsrcPointerToRawData + (rsrcStringDataEntry.OffsetToData - rsrcVirtualAddress);  	m_nCount = GetWordFromIndex (0);  	Status ("Amount of strings: {0}"' m_nCount);  	for (int i = 1; i < m_nCount; ++i)  		MainForm.Invoke (() => MainForm.dataTable.Rows.Add (i' StringDecoderDecode (i)' string.Format ("{0:X8}"' rsrcStringDataPosition + i * 4)));  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: if (StringDecodeMethod == 0)// StringPool   {  	MainForm.Invoke (() => MainForm.Text += " [StringPool]");  	int offset_StringPool__ms_aKey = (int)reader.BaseStream.Position;  	Status ("StringPool::ms_aKey located at {0:X8}"' offset_StringPool__ms_aKey);  	int keyRef = 0;  	// Only GetString references ms_aKey  	byte[] bytes = new byte[5];  	bytes [0] = 0x68;  	// push offset  	Buffer.BlockCopy (BitConverter.GetBytes (ImageBase + offset_StringPool__ms_aKey)' 0' bytes' 1' 4);  	if (FindAoBInFile (reader' 0' bytes))  		keyRef = (int)reader.BaseStream.Position;  	reader.BaseStream.Position = keyRef;  	while (true) {  		byte[] asdf = reader.ReadBytes (5);  		if (asdf [4] == 0xc3)// retn  		 {  			bool die = true;  			foreach (byte b in asdf)  				if (b == 0xe8)// call  				 {  					die = false;  					break;  				}  			if (die)  				break;  		}  		reader.BaseStream.Position -= 6;  	}  	while (reader.ReadByte () == 0xcc)  		;  	// allign  	reader.BaseStream.Position -= 1;  	int offset_StringPool__GetString_uint_char = (int)reader.BaseStream.Position;  	Status ("StringPool::GetString(uint' char) located at {0:X8}"' offset_StringPool__GetString_uint_char);  	//search for StringPool::offset_ms_aString  	if (FindAoBInFile (reader' keyRef - 100' new byte[] {  		0x8b'  		0x0c  	}' 100))  		reader.BaseStream.Position += 3;  	else if (FindAoBInFile (reader' keyRef - 100' new byte[] {  		0x8b'  		0x86  	}' 100))  		reader.BaseStream.Position += 2;  	else  		throw new Exception ("could not find start of StringPool::offset_ms_aString");  	offset_StringPool__ms_aString = reader.ReadInt32 () - ImageBase;  	Status ("StringPool::ms_aString located at {0:X8}"' offset_StringPool__ms_aString);  	//search for xrefs to function StringPool::GetString(uint' char)   	int[] xref = FindCalls (offset_StringPool__GetString_uint_char' 2);  	if (xref.Length != 2)  		throw new Exception ("failed to find references to StringPool::GetString(uint' char)");  	//search for start of StringPool::GetString(uint)  	if (!FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x51'  		0x8b  	}' 50) && !FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x55'  		0x8b  	}' 50))  		throw new Exception ("could not find start of GetString(uint)");  	int offset_StringPool__GetString_uint = (int)reader.BaseStream.Position;  	Status ("StringPool::GetString(uint) located at {0:X8}"' offset_StringPool__GetString_uint);  	//search for start of StringPool::GetString(uint' ushort)  	for (reader.BaseStream.Position = xref [1]; (reader.ReadUInt32 () & 0xffffff00) != 0x000cc200; reader.BaseStream.Position -= 5)  		;  	//seek the start of function StringPool::GetString(uint' char)  	while (reader.ReadByte () == 0xcc)  		;  	// allign  	reader.BaseStream.Position -= 1;  	int offset_StringPool__GetString_uint_ushort = (int)reader.BaseStream.Position;  	Status ("StringPool::GetString(uint' ushort) located at {0:X8}"' offset_StringPool__GetString_uint_ushort);  	//search for xrefs to function StringPool::GetString(uint)  	xref = FindCalls (offset_StringPool__GetString_uint' 1);  	if (xref.Length != 1)  		throw new Exception ("failed to find references to StringPool::GetString(uint)");  	//search for start of function StringPool::GetBSTR(uint)  	reader.BaseStream.Position -= 100;  	// should be enough  	if (!FindAoBInFile (reader' (int)reader.BaseStream.Position' new byte[] {  		0xb8'  		0xaa'  		0xaa'  		0xaa'  		0x00  	}))  		for (reader.BaseStream.Position = xref [0]; (reader.ReadUInt32 () & 0xff00ff00) != 0x0000c200; reader.BaseStream.Position -= 5)  			;  	//seek the start of function StringPool::GetString(uint' char)  	while (reader.ReadByte () == 0xcc)  		;  	// allign  	reader.BaseStream.Position -= 1;  	int offset_StringPool__GetBSTR_uint = (int)reader.BaseStream.Position;  	Status ("StringPool::GetBSTR(uint) located at {0:X8}"' offset_StringPool__GetBSTR_uint);  	//search for xrefs to function StringPool::GetString(uint' ushort)  	xref = FindCalls (offset_StringPool__GetString_uint_ushort' 1);  	if (xref.Length != 1)  		throw new Exception ("failed to find references to StringPool::GetString(uint' ushort)");  	//search for start of function StringPool::GetStringW(uint)  	if (!FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x51'  		0x8b  	}' 50) && !FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x55'  		0x8b  	}' 50))  		throw new Exception ("could not find start of GetStringW(uint)");  	int offset_StringPool__GetStringW_uint = (int)reader.BaseStream.Position;  	Status ("StringPool::GetStringW(uint) located at {0:X8}"' offset_StringPool__GetStringW_uint);  	ms_nSize = GetIntFromOffset (offset_StringPool__ms_aKey + 16 + 4);  	Status ("Amount of strings: {0}"' ms_nSize);  	if (MessageBox.Show ("Scan for references to strings in the client? This can take a while."' "Warning"' MessageBoxButtons.YesNo' MessageBoxIcon.Warning) == DialogResult.Yes) {  		Status ("Searching for references to GetString' GetStringW' and GetBSTR");  		List<int> GetStringCalls = new List<int> ();  		List<int> GetStringWCalls = new List<int> ();  		List<int> GetBSTRCalls = new List<int> ();  		for (reader.BaseStream.Position = 0; reader.BaseStream.Position < reader.BaseStream.Length;) {  			//int lol = (int)((float)reader.BaseStream.Position / reader.BaseStream.Length * 100);  			//if (lol > MainForm.toolStripProgressBar1.Value)  			//{  			//    MainForm.Invoke(() => MainForm.toolStripProgressBar1.Value = lol);  			//    MainForm.Invoke(() => MainForm.Update());  			//} too expensive  			if (reader.ReadByte () != 0xE8)  				// call  				continue;  			int offset = reader.ReadInt32 ();  			if (reader.BaseStream.Position + offset == offset_StringPool__GetString_uint)  				GetStringCalls.Add ((int)reader.BaseStream.Position - 5);  			else if (reader.BaseStream.Position + offset == offset_StringPool__GetStringW_uint)  				GetStringWCalls.Add ((int)reader.BaseStream.Position - 5);  			else if (reader.BaseStream.Position + offset == offset_StringPool__GetBSTR_uint)  				GetBSTRCalls.Add ((int)reader.BaseStream.Position - 5);  			else  				reader.BaseStream.Position -= 4;  		}  		List<int> GetStringFail = new List<int> ();  		foreach (int addr in GetStringCalls) {  			reader.BaseStream.Position = addr;  			reader.BaseStream.Position -= 2;  			if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  			 {  				GetStringFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 7;  			if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  			 {  				GetStringFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 2;  			if (reader.ReadByte () != 0x50)// push eax  			 {  				GetStringFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 6;  			if (reader.ReadByte () != 0x68)// push dword  			 {  				GetStringFail.Add (addr);  				continue;  			}  			int idx = reader.ReadInt32 ();  			if (idx > ms_nSize - 1)  				GetStringFail.Add (addr);  			else  				GetString.Add (addr' idx);  		}  		List<int> GetStringWFail = new List<int> ();  		foreach (int addr in GetStringWCalls) {  			reader.BaseStream.Position = addr;  			reader.BaseStream.Position -= 2;  			if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 7;  			if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 2;  			if (reader.ReadByte () != 0x50)// push eax  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 6;  			if (reader.ReadByte () != 0x68)// push dword  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			int idx = reader.ReadInt32 ();  			if (idx > ms_nSize - 1)  				GetStringWFail.Add (addr);  			else  				GetStringW.Add (addr' idx);  		}  		List<int> GetBSTRFail = new List<int> ();  		foreach (int addr in GetBSTRCalls) {  			reader.BaseStream.Position = addr;  			reader.BaseStream.Position -= 2;  			if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 7;  			if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 2;  			if (reader.ReadByte () != 0x50)// push eax  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 6;  			if (reader.ReadByte () != 0x68)// push dword  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			int idx = reader.ReadInt32 ();  			if (idx > ms_nSize - 1)  				GetBSTRFail.Add (addr);  			else  				GetBSTR.Add (addr' idx);  		}  		Status ("Failed to find index of {0} references"' GetStringFail.Count + GetStringWFail.Count + GetBSTRFail.Count);  	}  	Status ("Successfully found index of {0} references"' GetString.Count + GetBSTR.Count + GetStringW.Count);  	Status ("Decoding strings");  	for (int index = 0; index < ms_nSize; ++index)  		if (index != -1 && index <= 0xffff)  			Strings.Add (index' StringPoolDecode (index));  	Status ("Populating table");  	foreach (var s in Strings)  		MainForm.Invoke (() => MainForm.dataTable.Rows.Add (s.Key' s.Value' string.Empty));  	foreach (var a in GetString)  		MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetString")));  	foreach (var a in GetBSTR)  		MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetBSTR")));  	foreach (var a in GetStringW)  		MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetStringW")));  }  else if (StringDecodeMethod == 1)// StringDecoder   {  	MainForm.Invoke (() => MainForm.Text += " [StringDecoder]");  	int type = 0;  	int name = 0;  	int offset = 0;  	//search for CStringDecoder::DelayedLoad' which contains the resource type and name  	if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00'  		0x89'  		0x45'  		0xF4'  		0x6A'  		0xAA'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x8B'  		0x4D'  		0xF4'  		0x51'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 12;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 1;  		name = reader.ReadInt32 ();  	}  	else if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00'  		0x6A'  		0xAA'  		0x8B'  		0xF8'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x57'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 9;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 3;  		name = reader.ReadInt32 ();  	}  	else if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0xAA'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 1;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 1;  		name = reader.ReadInt32 ();  	}  	else  		throw new Exception ("Failed to determine type and name of resource.");  	//search for start of function CStringDecoder::DelayedLoad()  	reader.BaseStream.Position -= 50;  	// should be enough  	FindAoBInFile (reader' (int)reader.BaseStream.Position' new byte[] {  		0x55'  		0x8B'  		0xEC'  		0x83'  		0xEC'  		0x10  	});  	int offset_CStringDecoder__DelayedLoad = (int)reader.BaseStream.Position;  	for (reader.BaseStream.Position = 0; reader.BaseStream.Position < reader.BaseStream.Length;) {  		if (reader.ReadByte () != 0xE8)  			// call  			continue;  		int offse = reader.ReadInt32 ();  		if (reader.BaseStream.Position + offse == offset_CStringDecoder__DelayedLoad) {  			Status ("{0:X8} reference to offset_CStringDecoder__DelayedLoad = {1:X8}"' reader.BaseStream.Position - 5' offse);  			break;  		}  	}  	ImageResourceDirectory tier1 = (ImageResourceDirectory)root.GetEntry (type).Entry;  	ImageResourceDirectory tier2 = (ImageResourceDirectory)tier1.GetEntry (name).Entry;  	rsrcStringDataEntry = (ImageResourceDataEntry)tier2.Entrys [0].Entry;  	rsrcStringDataPosition = rsrcPointerToRawData + (rsrcStringDataEntry.OffsetToData - rsrcVirtualAddress);  	m_nCount = GetWordFromIndex (0);  	Status ("Amount of strings: {0}"' m_nCount);  	for (int i = 1; i < m_nCount; ++i)  		MainForm.Invoke (() => MainForm.dataTable.Rows.Add (i' StringDecoderDecode (i)' string.Format ("{0:X8}"' rsrcStringDataPosition + i * 4)));  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: if (StringDecodeMethod == 0)// StringPool   {  	MainForm.Invoke (() => MainForm.Text += " [StringPool]");  	int offset_StringPool__ms_aKey = (int)reader.BaseStream.Position;  	Status ("StringPool::ms_aKey located at {0:X8}"' offset_StringPool__ms_aKey);  	int keyRef = 0;  	// Only GetString references ms_aKey  	byte[] bytes = new byte[5];  	bytes [0] = 0x68;  	// push offset  	Buffer.BlockCopy (BitConverter.GetBytes (ImageBase + offset_StringPool__ms_aKey)' 0' bytes' 1' 4);  	if (FindAoBInFile (reader' 0' bytes))  		keyRef = (int)reader.BaseStream.Position;  	reader.BaseStream.Position = keyRef;  	while (true) {  		byte[] asdf = reader.ReadBytes (5);  		if (asdf [4] == 0xc3)// retn  		 {  			bool die = true;  			foreach (byte b in asdf)  				if (b == 0xe8)// call  				 {  					die = false;  					break;  				}  			if (die)  				break;  		}  		reader.BaseStream.Position -= 6;  	}  	while (reader.ReadByte () == 0xcc)  		;  	// allign  	reader.BaseStream.Position -= 1;  	int offset_StringPool__GetString_uint_char = (int)reader.BaseStream.Position;  	Status ("StringPool::GetString(uint' char) located at {0:X8}"' offset_StringPool__GetString_uint_char);  	//search for StringPool::offset_ms_aString  	if (FindAoBInFile (reader' keyRef - 100' new byte[] {  		0x8b'  		0x0c  	}' 100))  		reader.BaseStream.Position += 3;  	else if (FindAoBInFile (reader' keyRef - 100' new byte[] {  		0x8b'  		0x86  	}' 100))  		reader.BaseStream.Position += 2;  	else  		throw new Exception ("could not find start of StringPool::offset_ms_aString");  	offset_StringPool__ms_aString = reader.ReadInt32 () - ImageBase;  	Status ("StringPool::ms_aString located at {0:X8}"' offset_StringPool__ms_aString);  	//search for xrefs to function StringPool::GetString(uint' char)   	int[] xref = FindCalls (offset_StringPool__GetString_uint_char' 2);  	if (xref.Length != 2)  		throw new Exception ("failed to find references to StringPool::GetString(uint' char)");  	//search for start of StringPool::GetString(uint)  	if (!FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x51'  		0x8b  	}' 50) && !FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x55'  		0x8b  	}' 50))  		throw new Exception ("could not find start of GetString(uint)");  	int offset_StringPool__GetString_uint = (int)reader.BaseStream.Position;  	Status ("StringPool::GetString(uint) located at {0:X8}"' offset_StringPool__GetString_uint);  	//search for start of StringPool::GetString(uint' ushort)  	for (reader.BaseStream.Position = xref [1]; (reader.ReadUInt32 () & 0xffffff00) != 0x000cc200; reader.BaseStream.Position -= 5)  		;  	//seek the start of function StringPool::GetString(uint' char)  	while (reader.ReadByte () == 0xcc)  		;  	// allign  	reader.BaseStream.Position -= 1;  	int offset_StringPool__GetString_uint_ushort = (int)reader.BaseStream.Position;  	Status ("StringPool::GetString(uint' ushort) located at {0:X8}"' offset_StringPool__GetString_uint_ushort);  	//search for xrefs to function StringPool::GetString(uint)  	xref = FindCalls (offset_StringPool__GetString_uint' 1);  	if (xref.Length != 1)  		throw new Exception ("failed to find references to StringPool::GetString(uint)");  	//search for start of function StringPool::GetBSTR(uint)  	reader.BaseStream.Position -= 100;  	// should be enough  	if (!FindAoBInFile (reader' (int)reader.BaseStream.Position' new byte[] {  		0xb8'  		0xaa'  		0xaa'  		0xaa'  		0x00  	}))  		for (reader.BaseStream.Position = xref [0]; (reader.ReadUInt32 () & 0xff00ff00) != 0x0000c200; reader.BaseStream.Position -= 5)  			;  	//seek the start of function StringPool::GetString(uint' char)  	while (reader.ReadByte () == 0xcc)  		;  	// allign  	reader.BaseStream.Position -= 1;  	int offset_StringPool__GetBSTR_uint = (int)reader.BaseStream.Position;  	Status ("StringPool::GetBSTR(uint) located at {0:X8}"' offset_StringPool__GetBSTR_uint);  	//search for xrefs to function StringPool::GetString(uint' ushort)  	xref = FindCalls (offset_StringPool__GetString_uint_ushort' 1);  	if (xref.Length != 1)  		throw new Exception ("failed to find references to StringPool::GetString(uint' ushort)");  	//search for start of function StringPool::GetStringW(uint)  	if (!FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x51'  		0x8b  	}' 50) && !FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x55'  		0x8b  	}' 50))  		throw new Exception ("could not find start of GetStringW(uint)");  	int offset_StringPool__GetStringW_uint = (int)reader.BaseStream.Position;  	Status ("StringPool::GetStringW(uint) located at {0:X8}"' offset_StringPool__GetStringW_uint);  	ms_nSize = GetIntFromOffset (offset_StringPool__ms_aKey + 16 + 4);  	Status ("Amount of strings: {0}"' ms_nSize);  	if (MessageBox.Show ("Scan for references to strings in the client? This can take a while."' "Warning"' MessageBoxButtons.YesNo' MessageBoxIcon.Warning) == DialogResult.Yes) {  		Status ("Searching for references to GetString' GetStringW' and GetBSTR");  		List<int> GetStringCalls = new List<int> ();  		List<int> GetStringWCalls = new List<int> ();  		List<int> GetBSTRCalls = new List<int> ();  		for (reader.BaseStream.Position = 0; reader.BaseStream.Position < reader.BaseStream.Length;) {  			//int lol = (int)((float)reader.BaseStream.Position / reader.BaseStream.Length * 100);  			//if (lol > MainForm.toolStripProgressBar1.Value)  			//{  			//    MainForm.Invoke(() => MainForm.toolStripProgressBar1.Value = lol);  			//    MainForm.Invoke(() => MainForm.Update());  			//} too expensive  			if (reader.ReadByte () != 0xE8)  				// call  				continue;  			int offset = reader.ReadInt32 ();  			if (reader.BaseStream.Position + offset == offset_StringPool__GetString_uint)  				GetStringCalls.Add ((int)reader.BaseStream.Position - 5);  			else if (reader.BaseStream.Position + offset == offset_StringPool__GetStringW_uint)  				GetStringWCalls.Add ((int)reader.BaseStream.Position - 5);  			else if (reader.BaseStream.Position + offset == offset_StringPool__GetBSTR_uint)  				GetBSTRCalls.Add ((int)reader.BaseStream.Position - 5);  			else  				reader.BaseStream.Position -= 4;  		}  		List<int> GetStringFail = new List<int> ();  		foreach (int addr in GetStringCalls) {  			reader.BaseStream.Position = addr;  			reader.BaseStream.Position -= 2;  			if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  			 {  				GetStringFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 7;  			if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  			 {  				GetStringFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 2;  			if (reader.ReadByte () != 0x50)// push eax  			 {  				GetStringFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 6;  			if (reader.ReadByte () != 0x68)// push dword  			 {  				GetStringFail.Add (addr);  				continue;  			}  			int idx = reader.ReadInt32 ();  			if (idx > ms_nSize - 1)  				GetStringFail.Add (addr);  			else  				GetString.Add (addr' idx);  		}  		List<int> GetStringWFail = new List<int> ();  		foreach (int addr in GetStringWCalls) {  			reader.BaseStream.Position = addr;  			reader.BaseStream.Position -= 2;  			if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 7;  			if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 2;  			if (reader.ReadByte () != 0x50)// push eax  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 6;  			if (reader.ReadByte () != 0x68)// push dword  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			int idx = reader.ReadInt32 ();  			if (idx > ms_nSize - 1)  				GetStringWFail.Add (addr);  			else  				GetStringW.Add (addr' idx);  		}  		List<int> GetBSTRFail = new List<int> ();  		foreach (int addr in GetBSTRCalls) {  			reader.BaseStream.Position = addr;  			reader.BaseStream.Position -= 2;  			if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 7;  			if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 2;  			if (reader.ReadByte () != 0x50)// push eax  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 6;  			if (reader.ReadByte () != 0x68)// push dword  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			int idx = reader.ReadInt32 ();  			if (idx > ms_nSize - 1)  				GetBSTRFail.Add (addr);  			else  				GetBSTR.Add (addr' idx);  		}  		Status ("Failed to find index of {0} references"' GetStringFail.Count + GetStringWFail.Count + GetBSTRFail.Count);  	}  	Status ("Successfully found index of {0} references"' GetString.Count + GetBSTR.Count + GetStringW.Count);  	Status ("Decoding strings");  	for (int index = 0; index < ms_nSize; ++index)  		if (index != -1 && index <= 0xffff)  			Strings.Add (index' StringPoolDecode (index));  	Status ("Populating table");  	foreach (var s in Strings)  		MainForm.Invoke (() => MainForm.dataTable.Rows.Add (s.Key' s.Value' string.Empty));  	foreach (var a in GetString)  		MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetString")));  	foreach (var a in GetBSTR)  		MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetBSTR")));  	foreach (var a in GetStringW)  		MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetStringW")));  }  else if (StringDecodeMethod == 1)// StringDecoder   {  	MainForm.Invoke (() => MainForm.Text += " [StringDecoder]");  	int type = 0;  	int name = 0;  	int offset = 0;  	//search for CStringDecoder::DelayedLoad' which contains the resource type and name  	if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00'  		0x89'  		0x45'  		0xF4'  		0x6A'  		0xAA'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x8B'  		0x4D'  		0xF4'  		0x51'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 12;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 1;  		name = reader.ReadInt32 ();  	}  	else if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00'  		0x6A'  		0xAA'  		0x8B'  		0xF8'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x57'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 9;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 3;  		name = reader.ReadInt32 ();  	}  	else if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0xAA'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 1;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 1;  		name = reader.ReadInt32 ();  	}  	else  		throw new Exception ("Failed to determine type and name of resource.");  	//search for start of function CStringDecoder::DelayedLoad()  	reader.BaseStream.Position -= 50;  	// should be enough  	FindAoBInFile (reader' (int)reader.BaseStream.Position' new byte[] {  		0x55'  		0x8B'  		0xEC'  		0x83'  		0xEC'  		0x10  	});  	int offset_CStringDecoder__DelayedLoad = (int)reader.BaseStream.Position;  	for (reader.BaseStream.Position = 0; reader.BaseStream.Position < reader.BaseStream.Length;) {  		if (reader.ReadByte () != 0xE8)  			// call  			continue;  		int offse = reader.ReadInt32 ();  		if (reader.BaseStream.Position + offse == offset_CStringDecoder__DelayedLoad) {  			Status ("{0:X8} reference to offset_CStringDecoder__DelayedLoad = {1:X8}"' reader.BaseStream.Position - 5' offse);  			break;  		}  	}  	ImageResourceDirectory tier1 = (ImageResourceDirectory)root.GetEntry (type).Entry;  	ImageResourceDirectory tier2 = (ImageResourceDirectory)tier1.GetEntry (name).Entry;  	rsrcStringDataEntry = (ImageResourceDataEntry)tier2.Entrys [0].Entry;  	rsrcStringDataPosition = rsrcPointerToRawData + (rsrcStringDataEntry.OffsetToData - rsrcVirtualAddress);  	m_nCount = GetWordFromIndex (0);  	Status ("Amount of strings: {0}"' m_nCount);  	for (int i = 1; i < m_nCount; ++i)  		MainForm.Invoke (() => MainForm.dataTable.Rows.Add (i' StringDecoderDecode (i)' string.Format ("{0:X8}"' rsrcStringDataPosition + i * 4)));  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: if (StringDecodeMethod == 0)// StringPool   {  	MainForm.Invoke (() => MainForm.Text += " [StringPool]");  	int offset_StringPool__ms_aKey = (int)reader.BaseStream.Position;  	Status ("StringPool::ms_aKey located at {0:X8}"' offset_StringPool__ms_aKey);  	int keyRef = 0;  	// Only GetString references ms_aKey  	byte[] bytes = new byte[5];  	bytes [0] = 0x68;  	// push offset  	Buffer.BlockCopy (BitConverter.GetBytes (ImageBase + offset_StringPool__ms_aKey)' 0' bytes' 1' 4);  	if (FindAoBInFile (reader' 0' bytes))  		keyRef = (int)reader.BaseStream.Position;  	reader.BaseStream.Position = keyRef;  	while (true) {  		byte[] asdf = reader.ReadBytes (5);  		if (asdf [4] == 0xc3)// retn  		 {  			bool die = true;  			foreach (byte b in asdf)  				if (b == 0xe8)// call  				 {  					die = false;  					break;  				}  			if (die)  				break;  		}  		reader.BaseStream.Position -= 6;  	}  	while (reader.ReadByte () == 0xcc)  		;  	// allign  	reader.BaseStream.Position -= 1;  	int offset_StringPool__GetString_uint_char = (int)reader.BaseStream.Position;  	Status ("StringPool::GetString(uint' char) located at {0:X8}"' offset_StringPool__GetString_uint_char);  	//search for StringPool::offset_ms_aString  	if (FindAoBInFile (reader' keyRef - 100' new byte[] {  		0x8b'  		0x0c  	}' 100))  		reader.BaseStream.Position += 3;  	else if (FindAoBInFile (reader' keyRef - 100' new byte[] {  		0x8b'  		0x86  	}' 100))  		reader.BaseStream.Position += 2;  	else  		throw new Exception ("could not find start of StringPool::offset_ms_aString");  	offset_StringPool__ms_aString = reader.ReadInt32 () - ImageBase;  	Status ("StringPool::ms_aString located at {0:X8}"' offset_StringPool__ms_aString);  	//search for xrefs to function StringPool::GetString(uint' char)   	int[] xref = FindCalls (offset_StringPool__GetString_uint_char' 2);  	if (xref.Length != 2)  		throw new Exception ("failed to find references to StringPool::GetString(uint' char)");  	//search for start of StringPool::GetString(uint)  	if (!FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x51'  		0x8b  	}' 50) && !FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x55'  		0x8b  	}' 50))  		throw new Exception ("could not find start of GetString(uint)");  	int offset_StringPool__GetString_uint = (int)reader.BaseStream.Position;  	Status ("StringPool::GetString(uint) located at {0:X8}"' offset_StringPool__GetString_uint);  	//search for start of StringPool::GetString(uint' ushort)  	for (reader.BaseStream.Position = xref [1]; (reader.ReadUInt32 () & 0xffffff00) != 0x000cc200; reader.BaseStream.Position -= 5)  		;  	//seek the start of function StringPool::GetString(uint' char)  	while (reader.ReadByte () == 0xcc)  		;  	// allign  	reader.BaseStream.Position -= 1;  	int offset_StringPool__GetString_uint_ushort = (int)reader.BaseStream.Position;  	Status ("StringPool::GetString(uint' ushort) located at {0:X8}"' offset_StringPool__GetString_uint_ushort);  	//search for xrefs to function StringPool::GetString(uint)  	xref = FindCalls (offset_StringPool__GetString_uint' 1);  	if (xref.Length != 1)  		throw new Exception ("failed to find references to StringPool::GetString(uint)");  	//search for start of function StringPool::GetBSTR(uint)  	reader.BaseStream.Position -= 100;  	// should be enough  	if (!FindAoBInFile (reader' (int)reader.BaseStream.Position' new byte[] {  		0xb8'  		0xaa'  		0xaa'  		0xaa'  		0x00  	}))  		for (reader.BaseStream.Position = xref [0]; (reader.ReadUInt32 () & 0xff00ff00) != 0x0000c200; reader.BaseStream.Position -= 5)  			;  	//seek the start of function StringPool::GetString(uint' char)  	while (reader.ReadByte () == 0xcc)  		;  	// allign  	reader.BaseStream.Position -= 1;  	int offset_StringPool__GetBSTR_uint = (int)reader.BaseStream.Position;  	Status ("StringPool::GetBSTR(uint) located at {0:X8}"' offset_StringPool__GetBSTR_uint);  	//search for xrefs to function StringPool::GetString(uint' ushort)  	xref = FindCalls (offset_StringPool__GetString_uint_ushort' 1);  	if (xref.Length != 1)  		throw new Exception ("failed to find references to StringPool::GetString(uint' ushort)");  	//search for start of function StringPool::GetStringW(uint)  	if (!FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x51'  		0x8b  	}' 50) && !FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x55'  		0x8b  	}' 50))  		throw new Exception ("could not find start of GetStringW(uint)");  	int offset_StringPool__GetStringW_uint = (int)reader.BaseStream.Position;  	Status ("StringPool::GetStringW(uint) located at {0:X8}"' offset_StringPool__GetStringW_uint);  	ms_nSize = GetIntFromOffset (offset_StringPool__ms_aKey + 16 + 4);  	Status ("Amount of strings: {0}"' ms_nSize);  	if (MessageBox.Show ("Scan for references to strings in the client? This can take a while."' "Warning"' MessageBoxButtons.YesNo' MessageBoxIcon.Warning) == DialogResult.Yes) {  		Status ("Searching for references to GetString' GetStringW' and GetBSTR");  		List<int> GetStringCalls = new List<int> ();  		List<int> GetStringWCalls = new List<int> ();  		List<int> GetBSTRCalls = new List<int> ();  		for (reader.BaseStream.Position = 0; reader.BaseStream.Position < reader.BaseStream.Length;) {  			//int lol = (int)((float)reader.BaseStream.Position / reader.BaseStream.Length * 100);  			//if (lol > MainForm.toolStripProgressBar1.Value)  			//{  			//    MainForm.Invoke(() => MainForm.toolStripProgressBar1.Value = lol);  			//    MainForm.Invoke(() => MainForm.Update());  			//} too expensive  			if (reader.ReadByte () != 0xE8)  				// call  				continue;  			int offset = reader.ReadInt32 ();  			if (reader.BaseStream.Position + offset == offset_StringPool__GetString_uint)  				GetStringCalls.Add ((int)reader.BaseStream.Position - 5);  			else if (reader.BaseStream.Position + offset == offset_StringPool__GetStringW_uint)  				GetStringWCalls.Add ((int)reader.BaseStream.Position - 5);  			else if (reader.BaseStream.Position + offset == offset_StringPool__GetBSTR_uint)  				GetBSTRCalls.Add ((int)reader.BaseStream.Position - 5);  			else  				reader.BaseStream.Position -= 4;  		}  		List<int> GetStringFail = new List<int> ();  		foreach (int addr in GetStringCalls) {  			reader.BaseStream.Position = addr;  			reader.BaseStream.Position -= 2;  			if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  			 {  				GetStringFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 7;  			if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  			 {  				GetStringFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 2;  			if (reader.ReadByte () != 0x50)// push eax  			 {  				GetStringFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 6;  			if (reader.ReadByte () != 0x68)// push dword  			 {  				GetStringFail.Add (addr);  				continue;  			}  			int idx = reader.ReadInt32 ();  			if (idx > ms_nSize - 1)  				GetStringFail.Add (addr);  			else  				GetString.Add (addr' idx);  		}  		List<int> GetStringWFail = new List<int> ();  		foreach (int addr in GetStringWCalls) {  			reader.BaseStream.Position = addr;  			reader.BaseStream.Position -= 2;  			if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 7;  			if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 2;  			if (reader.ReadByte () != 0x50)// push eax  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 6;  			if (reader.ReadByte () != 0x68)// push dword  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			int idx = reader.ReadInt32 ();  			if (idx > ms_nSize - 1)  				GetStringWFail.Add (addr);  			else  				GetStringW.Add (addr' idx);  		}  		List<int> GetBSTRFail = new List<int> ();  		foreach (int addr in GetBSTRCalls) {  			reader.BaseStream.Position = addr;  			reader.BaseStream.Position -= 2;  			if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 7;  			if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 2;  			if (reader.ReadByte () != 0x50)// push eax  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 6;  			if (reader.ReadByte () != 0x68)// push dword  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			int idx = reader.ReadInt32 ();  			if (idx > ms_nSize - 1)  				GetBSTRFail.Add (addr);  			else  				GetBSTR.Add (addr' idx);  		}  		Status ("Failed to find index of {0} references"' GetStringFail.Count + GetStringWFail.Count + GetBSTRFail.Count);  	}  	Status ("Successfully found index of {0} references"' GetString.Count + GetBSTR.Count + GetStringW.Count);  	Status ("Decoding strings");  	for (int index = 0; index < ms_nSize; ++index)  		if (index != -1 && index <= 0xffff)  			Strings.Add (index' StringPoolDecode (index));  	Status ("Populating table");  	foreach (var s in Strings)  		MainForm.Invoke (() => MainForm.dataTable.Rows.Add (s.Key' s.Value' string.Empty));  	foreach (var a in GetString)  		MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetString")));  	foreach (var a in GetBSTR)  		MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetBSTR")));  	foreach (var a in GetStringW)  		MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetStringW")));  }  else if (StringDecodeMethod == 1)// StringDecoder   {  	MainForm.Invoke (() => MainForm.Text += " [StringDecoder]");  	int type = 0;  	int name = 0;  	int offset = 0;  	//search for CStringDecoder::DelayedLoad' which contains the resource type and name  	if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00'  		0x89'  		0x45'  		0xF4'  		0x6A'  		0xAA'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x8B'  		0x4D'  		0xF4'  		0x51'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 12;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 1;  		name = reader.ReadInt32 ();  	}  	else if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00'  		0x6A'  		0xAA'  		0x8B'  		0xF8'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x57'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 9;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 3;  		name = reader.ReadInt32 ();  	}  	else if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0xAA'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 1;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 1;  		name = reader.ReadInt32 ();  	}  	else  		throw new Exception ("Failed to determine type and name of resource.");  	//search for start of function CStringDecoder::DelayedLoad()  	reader.BaseStream.Position -= 50;  	// should be enough  	FindAoBInFile (reader' (int)reader.BaseStream.Position' new byte[] {  		0x55'  		0x8B'  		0xEC'  		0x83'  		0xEC'  		0x10  	});  	int offset_CStringDecoder__DelayedLoad = (int)reader.BaseStream.Position;  	for (reader.BaseStream.Position = 0; reader.BaseStream.Position < reader.BaseStream.Length;) {  		if (reader.ReadByte () != 0xE8)  			// call  			continue;  		int offse = reader.ReadInt32 ();  		if (reader.BaseStream.Position + offse == offset_CStringDecoder__DelayedLoad) {  			Status ("{0:X8} reference to offset_CStringDecoder__DelayedLoad = {1:X8}"' reader.BaseStream.Position - 5' offse);  			break;  		}  	}  	ImageResourceDirectory tier1 = (ImageResourceDirectory)root.GetEntry (type).Entry;  	ImageResourceDirectory tier2 = (ImageResourceDirectory)tier1.GetEntry (name).Entry;  	rsrcStringDataEntry = (ImageResourceDataEntry)tier2.Entrys [0].Entry;  	rsrcStringDataPosition = rsrcPointerToRawData + (rsrcStringDataEntry.OffsetToData - rsrcVirtualAddress);  	m_nCount = GetWordFromIndex (0);  	Status ("Amount of strings: {0}"' m_nCount);  	for (int i = 1; i < m_nCount; ++i)  		MainForm.Invoke (() => MainForm.dataTable.Rows.Add (i' StringDecoderDecode (i)' string.Format ("{0:X8}"' rsrcStringDataPosition + i * 4)));  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: if (StringDecodeMethod == 0)// StringPool   {  	MainForm.Invoke (() => MainForm.Text += " [StringPool]");  	int offset_StringPool__ms_aKey = (int)reader.BaseStream.Position;  	Status ("StringPool::ms_aKey located at {0:X8}"' offset_StringPool__ms_aKey);  	int keyRef = 0;  	// Only GetString references ms_aKey  	byte[] bytes = new byte[5];  	bytes [0] = 0x68;  	// push offset  	Buffer.BlockCopy (BitConverter.GetBytes (ImageBase + offset_StringPool__ms_aKey)' 0' bytes' 1' 4);  	if (FindAoBInFile (reader' 0' bytes))  		keyRef = (int)reader.BaseStream.Position;  	reader.BaseStream.Position = keyRef;  	while (true) {  		byte[] asdf = reader.ReadBytes (5);  		if (asdf [4] == 0xc3)// retn  		 {  			bool die = true;  			foreach (byte b in asdf)  				if (b == 0xe8)// call  				 {  					die = false;  					break;  				}  			if (die)  				break;  		}  		reader.BaseStream.Position -= 6;  	}  	while (reader.ReadByte () == 0xcc)  		;  	// allign  	reader.BaseStream.Position -= 1;  	int offset_StringPool__GetString_uint_char = (int)reader.BaseStream.Position;  	Status ("StringPool::GetString(uint' char) located at {0:X8}"' offset_StringPool__GetString_uint_char);  	//search for StringPool::offset_ms_aString  	if (FindAoBInFile (reader' keyRef - 100' new byte[] {  		0x8b'  		0x0c  	}' 100))  		reader.BaseStream.Position += 3;  	else if (FindAoBInFile (reader' keyRef - 100' new byte[] {  		0x8b'  		0x86  	}' 100))  		reader.BaseStream.Position += 2;  	else  		throw new Exception ("could not find start of StringPool::offset_ms_aString");  	offset_StringPool__ms_aString = reader.ReadInt32 () - ImageBase;  	Status ("StringPool::ms_aString located at {0:X8}"' offset_StringPool__ms_aString);  	//search for xrefs to function StringPool::GetString(uint' char)   	int[] xref = FindCalls (offset_StringPool__GetString_uint_char' 2);  	if (xref.Length != 2)  		throw new Exception ("failed to find references to StringPool::GetString(uint' char)");  	//search for start of StringPool::GetString(uint)  	if (!FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x51'  		0x8b  	}' 50) && !FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x55'  		0x8b  	}' 50))  		throw new Exception ("could not find start of GetString(uint)");  	int offset_StringPool__GetString_uint = (int)reader.BaseStream.Position;  	Status ("StringPool::GetString(uint) located at {0:X8}"' offset_StringPool__GetString_uint);  	//search for start of StringPool::GetString(uint' ushort)  	for (reader.BaseStream.Position = xref [1]; (reader.ReadUInt32 () & 0xffffff00) != 0x000cc200; reader.BaseStream.Position -= 5)  		;  	//seek the start of function StringPool::GetString(uint' char)  	while (reader.ReadByte () == 0xcc)  		;  	// allign  	reader.BaseStream.Position -= 1;  	int offset_StringPool__GetString_uint_ushort = (int)reader.BaseStream.Position;  	Status ("StringPool::GetString(uint' ushort) located at {0:X8}"' offset_StringPool__GetString_uint_ushort);  	//search for xrefs to function StringPool::GetString(uint)  	xref = FindCalls (offset_StringPool__GetString_uint' 1);  	if (xref.Length != 1)  		throw new Exception ("failed to find references to StringPool::GetString(uint)");  	//search for start of function StringPool::GetBSTR(uint)  	reader.BaseStream.Position -= 100;  	// should be enough  	if (!FindAoBInFile (reader' (int)reader.BaseStream.Position' new byte[] {  		0xb8'  		0xaa'  		0xaa'  		0xaa'  		0x00  	}))  		for (reader.BaseStream.Position = xref [0]; (reader.ReadUInt32 () & 0xff00ff00) != 0x0000c200; reader.BaseStream.Position -= 5)  			;  	//seek the start of function StringPool::GetString(uint' char)  	while (reader.ReadByte () == 0xcc)  		;  	// allign  	reader.BaseStream.Position -= 1;  	int offset_StringPool__GetBSTR_uint = (int)reader.BaseStream.Position;  	Status ("StringPool::GetBSTR(uint) located at {0:X8}"' offset_StringPool__GetBSTR_uint);  	//search for xrefs to function StringPool::GetString(uint' ushort)  	xref = FindCalls (offset_StringPool__GetString_uint_ushort' 1);  	if (xref.Length != 1)  		throw new Exception ("failed to find references to StringPool::GetString(uint' ushort)");  	//search for start of function StringPool::GetStringW(uint)  	if (!FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x51'  		0x8b  	}' 50) && !FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x55'  		0x8b  	}' 50))  		throw new Exception ("could not find start of GetStringW(uint)");  	int offset_StringPool__GetStringW_uint = (int)reader.BaseStream.Position;  	Status ("StringPool::GetStringW(uint) located at {0:X8}"' offset_StringPool__GetStringW_uint);  	ms_nSize = GetIntFromOffset (offset_StringPool__ms_aKey + 16 + 4);  	Status ("Amount of strings: {0}"' ms_nSize);  	if (MessageBox.Show ("Scan for references to strings in the client? This can take a while."' "Warning"' MessageBoxButtons.YesNo' MessageBoxIcon.Warning) == DialogResult.Yes) {  		Status ("Searching for references to GetString' GetStringW' and GetBSTR");  		List<int> GetStringCalls = new List<int> ();  		List<int> GetStringWCalls = new List<int> ();  		List<int> GetBSTRCalls = new List<int> ();  		for (reader.BaseStream.Position = 0; reader.BaseStream.Position < reader.BaseStream.Length;) {  			//int lol = (int)((float)reader.BaseStream.Position / reader.BaseStream.Length * 100);  			//if (lol > MainForm.toolStripProgressBar1.Value)  			//{  			//    MainForm.Invoke(() => MainForm.toolStripProgressBar1.Value = lol);  			//    MainForm.Invoke(() => MainForm.Update());  			//} too expensive  			if (reader.ReadByte () != 0xE8)  				// call  				continue;  			int offset = reader.ReadInt32 ();  			if (reader.BaseStream.Position + offset == offset_StringPool__GetString_uint)  				GetStringCalls.Add ((int)reader.BaseStream.Position - 5);  			else if (reader.BaseStream.Position + offset == offset_StringPool__GetStringW_uint)  				GetStringWCalls.Add ((int)reader.BaseStream.Position - 5);  			else if (reader.BaseStream.Position + offset == offset_StringPool__GetBSTR_uint)  				GetBSTRCalls.Add ((int)reader.BaseStream.Position - 5);  			else  				reader.BaseStream.Position -= 4;  		}  		List<int> GetStringFail = new List<int> ();  		foreach (int addr in GetStringCalls) {  			reader.BaseStream.Position = addr;  			reader.BaseStream.Position -= 2;  			if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  			 {  				GetStringFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 7;  			if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  			 {  				GetStringFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 2;  			if (reader.ReadByte () != 0x50)// push eax  			 {  				GetStringFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 6;  			if (reader.ReadByte () != 0x68)// push dword  			 {  				GetStringFail.Add (addr);  				continue;  			}  			int idx = reader.ReadInt32 ();  			if (idx > ms_nSize - 1)  				GetStringFail.Add (addr);  			else  				GetString.Add (addr' idx);  		}  		List<int> GetStringWFail = new List<int> ();  		foreach (int addr in GetStringWCalls) {  			reader.BaseStream.Position = addr;  			reader.BaseStream.Position -= 2;  			if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 7;  			if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 2;  			if (reader.ReadByte () != 0x50)// push eax  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 6;  			if (reader.ReadByte () != 0x68)// push dword  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			int idx = reader.ReadInt32 ();  			if (idx > ms_nSize - 1)  				GetStringWFail.Add (addr);  			else  				GetStringW.Add (addr' idx);  		}  		List<int> GetBSTRFail = new List<int> ();  		foreach (int addr in GetBSTRCalls) {  			reader.BaseStream.Position = addr;  			reader.BaseStream.Position -= 2;  			if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 7;  			if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 2;  			if (reader.ReadByte () != 0x50)// push eax  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 6;  			if (reader.ReadByte () != 0x68)// push dword  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			int idx = reader.ReadInt32 ();  			if (idx > ms_nSize - 1)  				GetBSTRFail.Add (addr);  			else  				GetBSTR.Add (addr' idx);  		}  		Status ("Failed to find index of {0} references"' GetStringFail.Count + GetStringWFail.Count + GetBSTRFail.Count);  	}  	Status ("Successfully found index of {0} references"' GetString.Count + GetBSTR.Count + GetStringW.Count);  	Status ("Decoding strings");  	for (int index = 0; index < ms_nSize; ++index)  		if (index != -1 && index <= 0xffff)  			Strings.Add (index' StringPoolDecode (index));  	Status ("Populating table");  	foreach (var s in Strings)  		MainForm.Invoke (() => MainForm.dataTable.Rows.Add (s.Key' s.Value' string.Empty));  	foreach (var a in GetString)  		MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetString")));  	foreach (var a in GetBSTR)  		MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetBSTR")));  	foreach (var a in GetStringW)  		MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetStringW")));  }  else if (StringDecodeMethod == 1)// StringDecoder   {  	MainForm.Invoke (() => MainForm.Text += " [StringDecoder]");  	int type = 0;  	int name = 0;  	int offset = 0;  	//search for CStringDecoder::DelayedLoad' which contains the resource type and name  	if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00'  		0x89'  		0x45'  		0xF4'  		0x6A'  		0xAA'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x8B'  		0x4D'  		0xF4'  		0x51'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 12;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 1;  		name = reader.ReadInt32 ();  	}  	else if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00'  		0x6A'  		0xAA'  		0x8B'  		0xF8'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x57'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 9;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 3;  		name = reader.ReadInt32 ();  	}  	else if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0xAA'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 1;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 1;  		name = reader.ReadInt32 ();  	}  	else  		throw new Exception ("Failed to determine type and name of resource.");  	//search for start of function CStringDecoder::DelayedLoad()  	reader.BaseStream.Position -= 50;  	// should be enough  	FindAoBInFile (reader' (int)reader.BaseStream.Position' new byte[] {  		0x55'  		0x8B'  		0xEC'  		0x83'  		0xEC'  		0x10  	});  	int offset_CStringDecoder__DelayedLoad = (int)reader.BaseStream.Position;  	for (reader.BaseStream.Position = 0; reader.BaseStream.Position < reader.BaseStream.Length;) {  		if (reader.ReadByte () != 0xE8)  			// call  			continue;  		int offse = reader.ReadInt32 ();  		if (reader.BaseStream.Position + offse == offset_CStringDecoder__DelayedLoad) {  			Status ("{0:X8} reference to offset_CStringDecoder__DelayedLoad = {1:X8}"' reader.BaseStream.Position - 5' offse);  			break;  		}  	}  	ImageResourceDirectory tier1 = (ImageResourceDirectory)root.GetEntry (type).Entry;  	ImageResourceDirectory tier2 = (ImageResourceDirectory)tier1.GetEntry (name).Entry;  	rsrcStringDataEntry = (ImageResourceDataEntry)tier2.Entrys [0].Entry;  	rsrcStringDataPosition = rsrcPointerToRawData + (rsrcStringDataEntry.OffsetToData - rsrcVirtualAddress);  	m_nCount = GetWordFromIndex (0);  	Status ("Amount of strings: {0}"' m_nCount);  	for (int i = 1; i < m_nCount; ++i)  		MainForm.Invoke (() => MainForm.dataTable.Rows.Add (i' StringDecoderDecode (i)' string.Format ("{0:X8}"' rsrcStringDataPosition + i * 4)));  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: if (StringDecodeMethod == 0)// StringPool   {  	MainForm.Invoke (() => MainForm.Text += " [StringPool]");  	int offset_StringPool__ms_aKey = (int)reader.BaseStream.Position;  	Status ("StringPool::ms_aKey located at {0:X8}"' offset_StringPool__ms_aKey);  	int keyRef = 0;  	// Only GetString references ms_aKey  	byte[] bytes = new byte[5];  	bytes [0] = 0x68;  	// push offset  	Buffer.BlockCopy (BitConverter.GetBytes (ImageBase + offset_StringPool__ms_aKey)' 0' bytes' 1' 4);  	if (FindAoBInFile (reader' 0' bytes))  		keyRef = (int)reader.BaseStream.Position;  	reader.BaseStream.Position = keyRef;  	while (true) {  		byte[] asdf = reader.ReadBytes (5);  		if (asdf [4] == 0xc3)// retn  		 {  			bool die = true;  			foreach (byte b in asdf)  				if (b == 0xe8)// call  				 {  					die = false;  					break;  				}  			if (die)  				break;  		}  		reader.BaseStream.Position -= 6;  	}  	while (reader.ReadByte () == 0xcc)  		;  	// allign  	reader.BaseStream.Position -= 1;  	int offset_StringPool__GetString_uint_char = (int)reader.BaseStream.Position;  	Status ("StringPool::GetString(uint' char) located at {0:X8}"' offset_StringPool__GetString_uint_char);  	//search for StringPool::offset_ms_aString  	if (FindAoBInFile (reader' keyRef - 100' new byte[] {  		0x8b'  		0x0c  	}' 100))  		reader.BaseStream.Position += 3;  	else if (FindAoBInFile (reader' keyRef - 100' new byte[] {  		0x8b'  		0x86  	}' 100))  		reader.BaseStream.Position += 2;  	else  		throw new Exception ("could not find start of StringPool::offset_ms_aString");  	offset_StringPool__ms_aString = reader.ReadInt32 () - ImageBase;  	Status ("StringPool::ms_aString located at {0:X8}"' offset_StringPool__ms_aString);  	//search for xrefs to function StringPool::GetString(uint' char)   	int[] xref = FindCalls (offset_StringPool__GetString_uint_char' 2);  	if (xref.Length != 2)  		throw new Exception ("failed to find references to StringPool::GetString(uint' char)");  	//search for start of StringPool::GetString(uint)  	if (!FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x51'  		0x8b  	}' 50) && !FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x55'  		0x8b  	}' 50))  		throw new Exception ("could not find start of GetString(uint)");  	int offset_StringPool__GetString_uint = (int)reader.BaseStream.Position;  	Status ("StringPool::GetString(uint) located at {0:X8}"' offset_StringPool__GetString_uint);  	//search for start of StringPool::GetString(uint' ushort)  	for (reader.BaseStream.Position = xref [1]; (reader.ReadUInt32 () & 0xffffff00) != 0x000cc200; reader.BaseStream.Position -= 5)  		;  	//seek the start of function StringPool::GetString(uint' char)  	while (reader.ReadByte () == 0xcc)  		;  	// allign  	reader.BaseStream.Position -= 1;  	int offset_StringPool__GetString_uint_ushort = (int)reader.BaseStream.Position;  	Status ("StringPool::GetString(uint' ushort) located at {0:X8}"' offset_StringPool__GetString_uint_ushort);  	//search for xrefs to function StringPool::GetString(uint)  	xref = FindCalls (offset_StringPool__GetString_uint' 1);  	if (xref.Length != 1)  		throw new Exception ("failed to find references to StringPool::GetString(uint)");  	//search for start of function StringPool::GetBSTR(uint)  	reader.BaseStream.Position -= 100;  	// should be enough  	if (!FindAoBInFile (reader' (int)reader.BaseStream.Position' new byte[] {  		0xb8'  		0xaa'  		0xaa'  		0xaa'  		0x00  	}))  		for (reader.BaseStream.Position = xref [0]; (reader.ReadUInt32 () & 0xff00ff00) != 0x0000c200; reader.BaseStream.Position -= 5)  			;  	//seek the start of function StringPool::GetString(uint' char)  	while (reader.ReadByte () == 0xcc)  		;  	// allign  	reader.BaseStream.Position -= 1;  	int offset_StringPool__GetBSTR_uint = (int)reader.BaseStream.Position;  	Status ("StringPool::GetBSTR(uint) located at {0:X8}"' offset_StringPool__GetBSTR_uint);  	//search for xrefs to function StringPool::GetString(uint' ushort)  	xref = FindCalls (offset_StringPool__GetString_uint_ushort' 1);  	if (xref.Length != 1)  		throw new Exception ("failed to find references to StringPool::GetString(uint' ushort)");  	//search for start of function StringPool::GetStringW(uint)  	if (!FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x51'  		0x8b  	}' 50) && !FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x55'  		0x8b  	}' 50))  		throw new Exception ("could not find start of GetStringW(uint)");  	int offset_StringPool__GetStringW_uint = (int)reader.BaseStream.Position;  	Status ("StringPool::GetStringW(uint) located at {0:X8}"' offset_StringPool__GetStringW_uint);  	ms_nSize = GetIntFromOffset (offset_StringPool__ms_aKey + 16 + 4);  	Status ("Amount of strings: {0}"' ms_nSize);  	if (MessageBox.Show ("Scan for references to strings in the client? This can take a while."' "Warning"' MessageBoxButtons.YesNo' MessageBoxIcon.Warning) == DialogResult.Yes) {  		Status ("Searching for references to GetString' GetStringW' and GetBSTR");  		List<int> GetStringCalls = new List<int> ();  		List<int> GetStringWCalls = new List<int> ();  		List<int> GetBSTRCalls = new List<int> ();  		for (reader.BaseStream.Position = 0; reader.BaseStream.Position < reader.BaseStream.Length;) {  			//int lol = (int)((float)reader.BaseStream.Position / reader.BaseStream.Length * 100);  			//if (lol > MainForm.toolStripProgressBar1.Value)  			//{  			//    MainForm.Invoke(() => MainForm.toolStripProgressBar1.Value = lol);  			//    MainForm.Invoke(() => MainForm.Update());  			//} too expensive  			if (reader.ReadByte () != 0xE8)  				// call  				continue;  			int offset = reader.ReadInt32 ();  			if (reader.BaseStream.Position + offset == offset_StringPool__GetString_uint)  				GetStringCalls.Add ((int)reader.BaseStream.Position - 5);  			else if (reader.BaseStream.Position + offset == offset_StringPool__GetStringW_uint)  				GetStringWCalls.Add ((int)reader.BaseStream.Position - 5);  			else if (reader.BaseStream.Position + offset == offset_StringPool__GetBSTR_uint)  				GetBSTRCalls.Add ((int)reader.BaseStream.Position - 5);  			else  				reader.BaseStream.Position -= 4;  		}  		List<int> GetStringFail = new List<int> ();  		foreach (int addr in GetStringCalls) {  			reader.BaseStream.Position = addr;  			reader.BaseStream.Position -= 2;  			if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  			 {  				GetStringFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 7;  			if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  			 {  				GetStringFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 2;  			if (reader.ReadByte () != 0x50)// push eax  			 {  				GetStringFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 6;  			if (reader.ReadByte () != 0x68)// push dword  			 {  				GetStringFail.Add (addr);  				continue;  			}  			int idx = reader.ReadInt32 ();  			if (idx > ms_nSize - 1)  				GetStringFail.Add (addr);  			else  				GetString.Add (addr' idx);  		}  		List<int> GetStringWFail = new List<int> ();  		foreach (int addr in GetStringWCalls) {  			reader.BaseStream.Position = addr;  			reader.BaseStream.Position -= 2;  			if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 7;  			if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 2;  			if (reader.ReadByte () != 0x50)// push eax  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 6;  			if (reader.ReadByte () != 0x68)// push dword  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			int idx = reader.ReadInt32 ();  			if (idx > ms_nSize - 1)  				GetStringWFail.Add (addr);  			else  				GetStringW.Add (addr' idx);  		}  		List<int> GetBSTRFail = new List<int> ();  		foreach (int addr in GetBSTRCalls) {  			reader.BaseStream.Position = addr;  			reader.BaseStream.Position -= 2;  			if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 7;  			if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 2;  			if (reader.ReadByte () != 0x50)// push eax  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 6;  			if (reader.ReadByte () != 0x68)// push dword  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			int idx = reader.ReadInt32 ();  			if (idx > ms_nSize - 1)  				GetBSTRFail.Add (addr);  			else  				GetBSTR.Add (addr' idx);  		}  		Status ("Failed to find index of {0} references"' GetStringFail.Count + GetStringWFail.Count + GetBSTRFail.Count);  	}  	Status ("Successfully found index of {0} references"' GetString.Count + GetBSTR.Count + GetStringW.Count);  	Status ("Decoding strings");  	for (int index = 0; index < ms_nSize; ++index)  		if (index != -1 && index <= 0xffff)  			Strings.Add (index' StringPoolDecode (index));  	Status ("Populating table");  	foreach (var s in Strings)  		MainForm.Invoke (() => MainForm.dataTable.Rows.Add (s.Key' s.Value' string.Empty));  	foreach (var a in GetString)  		MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetString")));  	foreach (var a in GetBSTR)  		MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetBSTR")));  	foreach (var a in GetStringW)  		MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetStringW")));  }  else if (StringDecodeMethod == 1)// StringDecoder   {  	MainForm.Invoke (() => MainForm.Text += " [StringDecoder]");  	int type = 0;  	int name = 0;  	int offset = 0;  	//search for CStringDecoder::DelayedLoad' which contains the resource type and name  	if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00'  		0x89'  		0x45'  		0xF4'  		0x6A'  		0xAA'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x8B'  		0x4D'  		0xF4'  		0x51'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 12;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 1;  		name = reader.ReadInt32 ();  	}  	else if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00'  		0x6A'  		0xAA'  		0x8B'  		0xF8'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x57'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 9;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 3;  		name = reader.ReadInt32 ();  	}  	else if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0xAA'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 1;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 1;  		name = reader.ReadInt32 ();  	}  	else  		throw new Exception ("Failed to determine type and name of resource.");  	//search for start of function CStringDecoder::DelayedLoad()  	reader.BaseStream.Position -= 50;  	// should be enough  	FindAoBInFile (reader' (int)reader.BaseStream.Position' new byte[] {  		0x55'  		0x8B'  		0xEC'  		0x83'  		0xEC'  		0x10  	});  	int offset_CStringDecoder__DelayedLoad = (int)reader.BaseStream.Position;  	for (reader.BaseStream.Position = 0; reader.BaseStream.Position < reader.BaseStream.Length;) {  		if (reader.ReadByte () != 0xE8)  			// call  			continue;  		int offse = reader.ReadInt32 ();  		if (reader.BaseStream.Position + offse == offset_CStringDecoder__DelayedLoad) {  			Status ("{0:X8} reference to offset_CStringDecoder__DelayedLoad = {1:X8}"' reader.BaseStream.Position - 5' offse);  			break;  		}  	}  	ImageResourceDirectory tier1 = (ImageResourceDirectory)root.GetEntry (type).Entry;  	ImageResourceDirectory tier2 = (ImageResourceDirectory)tier1.GetEntry (name).Entry;  	rsrcStringDataEntry = (ImageResourceDataEntry)tier2.Entrys [0].Entry;  	rsrcStringDataPosition = rsrcPointerToRawData + (rsrcStringDataEntry.OffsetToData - rsrcVirtualAddress);  	m_nCount = GetWordFromIndex (0);  	Status ("Amount of strings: {0}"' m_nCount);  	for (int i = 1; i < m_nCount; ++i)  		MainForm.Invoke (() => MainForm.dataTable.Rows.Add (i' StringDecoderDecode (i)' string.Format ("{0:X8}"' rsrcStringDataPosition + i * 4)));  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: if (StringDecodeMethod == 0)// StringPool   {  	MainForm.Invoke (() => MainForm.Text += " [StringPool]");  	int offset_StringPool__ms_aKey = (int)reader.BaseStream.Position;  	Status ("StringPool::ms_aKey located at {0:X8}"' offset_StringPool__ms_aKey);  	int keyRef = 0;  	// Only GetString references ms_aKey  	byte[] bytes = new byte[5];  	bytes [0] = 0x68;  	// push offset  	Buffer.BlockCopy (BitConverter.GetBytes (ImageBase + offset_StringPool__ms_aKey)' 0' bytes' 1' 4);  	if (FindAoBInFile (reader' 0' bytes))  		keyRef = (int)reader.BaseStream.Position;  	reader.BaseStream.Position = keyRef;  	while (true) {  		byte[] asdf = reader.ReadBytes (5);  		if (asdf [4] == 0xc3)// retn  		 {  			bool die = true;  			foreach (byte b in asdf)  				if (b == 0xe8)// call  				 {  					die = false;  					break;  				}  			if (die)  				break;  		}  		reader.BaseStream.Position -= 6;  	}  	while (reader.ReadByte () == 0xcc)  		;  	// allign  	reader.BaseStream.Position -= 1;  	int offset_StringPool__GetString_uint_char = (int)reader.BaseStream.Position;  	Status ("StringPool::GetString(uint' char) located at {0:X8}"' offset_StringPool__GetString_uint_char);  	//search for StringPool::offset_ms_aString  	if (FindAoBInFile (reader' keyRef - 100' new byte[] {  		0x8b'  		0x0c  	}' 100))  		reader.BaseStream.Position += 3;  	else if (FindAoBInFile (reader' keyRef - 100' new byte[] {  		0x8b'  		0x86  	}' 100))  		reader.BaseStream.Position += 2;  	else  		throw new Exception ("could not find start of StringPool::offset_ms_aString");  	offset_StringPool__ms_aString = reader.ReadInt32 () - ImageBase;  	Status ("StringPool::ms_aString located at {0:X8}"' offset_StringPool__ms_aString);  	//search for xrefs to function StringPool::GetString(uint' char)   	int[] xref = FindCalls (offset_StringPool__GetString_uint_char' 2);  	if (xref.Length != 2)  		throw new Exception ("failed to find references to StringPool::GetString(uint' char)");  	//search for start of StringPool::GetString(uint)  	if (!FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x51'  		0x8b  	}' 50) && !FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x55'  		0x8b  	}' 50))  		throw new Exception ("could not find start of GetString(uint)");  	int offset_StringPool__GetString_uint = (int)reader.BaseStream.Position;  	Status ("StringPool::GetString(uint) located at {0:X8}"' offset_StringPool__GetString_uint);  	//search for start of StringPool::GetString(uint' ushort)  	for (reader.BaseStream.Position = xref [1]; (reader.ReadUInt32 () & 0xffffff00) != 0x000cc200; reader.BaseStream.Position -= 5)  		;  	//seek the start of function StringPool::GetString(uint' char)  	while (reader.ReadByte () == 0xcc)  		;  	// allign  	reader.BaseStream.Position -= 1;  	int offset_StringPool__GetString_uint_ushort = (int)reader.BaseStream.Position;  	Status ("StringPool::GetString(uint' ushort) located at {0:X8}"' offset_StringPool__GetString_uint_ushort);  	//search for xrefs to function StringPool::GetString(uint)  	xref = FindCalls (offset_StringPool__GetString_uint' 1);  	if (xref.Length != 1)  		throw new Exception ("failed to find references to StringPool::GetString(uint)");  	//search for start of function StringPool::GetBSTR(uint)  	reader.BaseStream.Position -= 100;  	// should be enough  	if (!FindAoBInFile (reader' (int)reader.BaseStream.Position' new byte[] {  		0xb8'  		0xaa'  		0xaa'  		0xaa'  		0x00  	}))  		for (reader.BaseStream.Position = xref [0]; (reader.ReadUInt32 () & 0xff00ff00) != 0x0000c200; reader.BaseStream.Position -= 5)  			;  	//seek the start of function StringPool::GetString(uint' char)  	while (reader.ReadByte () == 0xcc)  		;  	// allign  	reader.BaseStream.Position -= 1;  	int offset_StringPool__GetBSTR_uint = (int)reader.BaseStream.Position;  	Status ("StringPool::GetBSTR(uint) located at {0:X8}"' offset_StringPool__GetBSTR_uint);  	//search for xrefs to function StringPool::GetString(uint' ushort)  	xref = FindCalls (offset_StringPool__GetString_uint_ushort' 1);  	if (xref.Length != 1)  		throw new Exception ("failed to find references to StringPool::GetString(uint' ushort)");  	//search for start of function StringPool::GetStringW(uint)  	if (!FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x51'  		0x8b  	}' 50) && !FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x55'  		0x8b  	}' 50))  		throw new Exception ("could not find start of GetStringW(uint)");  	int offset_StringPool__GetStringW_uint = (int)reader.BaseStream.Position;  	Status ("StringPool::GetStringW(uint) located at {0:X8}"' offset_StringPool__GetStringW_uint);  	ms_nSize = GetIntFromOffset (offset_StringPool__ms_aKey + 16 + 4);  	Status ("Amount of strings: {0}"' ms_nSize);  	if (MessageBox.Show ("Scan for references to strings in the client? This can take a while."' "Warning"' MessageBoxButtons.YesNo' MessageBoxIcon.Warning) == DialogResult.Yes) {  		Status ("Searching for references to GetString' GetStringW' and GetBSTR");  		List<int> GetStringCalls = new List<int> ();  		List<int> GetStringWCalls = new List<int> ();  		List<int> GetBSTRCalls = new List<int> ();  		for (reader.BaseStream.Position = 0; reader.BaseStream.Position < reader.BaseStream.Length;) {  			//int lol = (int)((float)reader.BaseStream.Position / reader.BaseStream.Length * 100);  			//if (lol > MainForm.toolStripProgressBar1.Value)  			//{  			//    MainForm.Invoke(() => MainForm.toolStripProgressBar1.Value = lol);  			//    MainForm.Invoke(() => MainForm.Update());  			//} too expensive  			if (reader.ReadByte () != 0xE8)  				// call  				continue;  			int offset = reader.ReadInt32 ();  			if (reader.BaseStream.Position + offset == offset_StringPool__GetString_uint)  				GetStringCalls.Add ((int)reader.BaseStream.Position - 5);  			else if (reader.BaseStream.Position + offset == offset_StringPool__GetStringW_uint)  				GetStringWCalls.Add ((int)reader.BaseStream.Position - 5);  			else if (reader.BaseStream.Position + offset == offset_StringPool__GetBSTR_uint)  				GetBSTRCalls.Add ((int)reader.BaseStream.Position - 5);  			else  				reader.BaseStream.Position -= 4;  		}  		List<int> GetStringFail = new List<int> ();  		foreach (int addr in GetStringCalls) {  			reader.BaseStream.Position = addr;  			reader.BaseStream.Position -= 2;  			if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  			 {  				GetStringFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 7;  			if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  			 {  				GetStringFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 2;  			if (reader.ReadByte () != 0x50)// push eax  			 {  				GetStringFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 6;  			if (reader.ReadByte () != 0x68)// push dword  			 {  				GetStringFail.Add (addr);  				continue;  			}  			int idx = reader.ReadInt32 ();  			if (idx > ms_nSize - 1)  				GetStringFail.Add (addr);  			else  				GetString.Add (addr' idx);  		}  		List<int> GetStringWFail = new List<int> ();  		foreach (int addr in GetStringWCalls) {  			reader.BaseStream.Position = addr;  			reader.BaseStream.Position -= 2;  			if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 7;  			if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 2;  			if (reader.ReadByte () != 0x50)// push eax  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 6;  			if (reader.ReadByte () != 0x68)// push dword  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			int idx = reader.ReadInt32 ();  			if (idx > ms_nSize - 1)  				GetStringWFail.Add (addr);  			else  				GetStringW.Add (addr' idx);  		}  		List<int> GetBSTRFail = new List<int> ();  		foreach (int addr in GetBSTRCalls) {  			reader.BaseStream.Position = addr;  			reader.BaseStream.Position -= 2;  			if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 7;  			if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 2;  			if (reader.ReadByte () != 0x50)// push eax  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 6;  			if (reader.ReadByte () != 0x68)// push dword  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			int idx = reader.ReadInt32 ();  			if (idx > ms_nSize - 1)  				GetBSTRFail.Add (addr);  			else  				GetBSTR.Add (addr' idx);  		}  		Status ("Failed to find index of {0} references"' GetStringFail.Count + GetStringWFail.Count + GetBSTRFail.Count);  	}  	Status ("Successfully found index of {0} references"' GetString.Count + GetBSTR.Count + GetStringW.Count);  	Status ("Decoding strings");  	for (int index = 0; index < ms_nSize; ++index)  		if (index != -1 && index <= 0xffff)  			Strings.Add (index' StringPoolDecode (index));  	Status ("Populating table");  	foreach (var s in Strings)  		MainForm.Invoke (() => MainForm.dataTable.Rows.Add (s.Key' s.Value' string.Empty));  	foreach (var a in GetString)  		MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetString")));  	foreach (var a in GetBSTR)  		MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetBSTR")));  	foreach (var a in GetStringW)  		MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetStringW")));  }  else if (StringDecodeMethod == 1)// StringDecoder   {  	MainForm.Invoke (() => MainForm.Text += " [StringDecoder]");  	int type = 0;  	int name = 0;  	int offset = 0;  	//search for CStringDecoder::DelayedLoad' which contains the resource type and name  	if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00'  		0x89'  		0x45'  		0xF4'  		0x6A'  		0xAA'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x8B'  		0x4D'  		0xF4'  		0x51'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 12;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 1;  		name = reader.ReadInt32 ();  	}  	else if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00'  		0x6A'  		0xAA'  		0x8B'  		0xF8'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x57'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 9;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 3;  		name = reader.ReadInt32 ();  	}  	else if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0xAA'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 1;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 1;  		name = reader.ReadInt32 ();  	}  	else  		throw new Exception ("Failed to determine type and name of resource.");  	//search for start of function CStringDecoder::DelayedLoad()  	reader.BaseStream.Position -= 50;  	// should be enough  	FindAoBInFile (reader' (int)reader.BaseStream.Position' new byte[] {  		0x55'  		0x8B'  		0xEC'  		0x83'  		0xEC'  		0x10  	});  	int offset_CStringDecoder__DelayedLoad = (int)reader.BaseStream.Position;  	for (reader.BaseStream.Position = 0; reader.BaseStream.Position < reader.BaseStream.Length;) {  		if (reader.ReadByte () != 0xE8)  			// call  			continue;  		int offse = reader.ReadInt32 ();  		if (reader.BaseStream.Position + offse == offset_CStringDecoder__DelayedLoad) {  			Status ("{0:X8} reference to offset_CStringDecoder__DelayedLoad = {1:X8}"' reader.BaseStream.Position - 5' offse);  			break;  		}  	}  	ImageResourceDirectory tier1 = (ImageResourceDirectory)root.GetEntry (type).Entry;  	ImageResourceDirectory tier2 = (ImageResourceDirectory)tier1.GetEntry (name).Entry;  	rsrcStringDataEntry = (ImageResourceDataEntry)tier2.Entrys [0].Entry;  	rsrcStringDataPosition = rsrcPointerToRawData + (rsrcStringDataEntry.OffsetToData - rsrcVirtualAddress);  	m_nCount = GetWordFromIndex (0);  	Status ("Amount of strings: {0}"' m_nCount);  	for (int i = 1; i < m_nCount; ++i)  		MainForm.Invoke (() => MainForm.dataTable.Rows.Add (i' StringDecoderDecode (i)' string.Format ("{0:X8}"' rsrcStringDataPosition + i * 4)));  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: if (StringDecodeMethod == 0)// StringPool   {  	MainForm.Invoke (() => MainForm.Text += " [StringPool]");  	int offset_StringPool__ms_aKey = (int)reader.BaseStream.Position;  	Status ("StringPool::ms_aKey located at {0:X8}"' offset_StringPool__ms_aKey);  	int keyRef = 0;  	// Only GetString references ms_aKey  	byte[] bytes = new byte[5];  	bytes [0] = 0x68;  	// push offset  	Buffer.BlockCopy (BitConverter.GetBytes (ImageBase + offset_StringPool__ms_aKey)' 0' bytes' 1' 4);  	if (FindAoBInFile (reader' 0' bytes))  		keyRef = (int)reader.BaseStream.Position;  	reader.BaseStream.Position = keyRef;  	while (true) {  		byte[] asdf = reader.ReadBytes (5);  		if (asdf [4] == 0xc3)// retn  		 {  			bool die = true;  			foreach (byte b in asdf)  				if (b == 0xe8)// call  				 {  					die = false;  					break;  				}  			if (die)  				break;  		}  		reader.BaseStream.Position -= 6;  	}  	while (reader.ReadByte () == 0xcc)  		;  	// allign  	reader.BaseStream.Position -= 1;  	int offset_StringPool__GetString_uint_char = (int)reader.BaseStream.Position;  	Status ("StringPool::GetString(uint' char) located at {0:X8}"' offset_StringPool__GetString_uint_char);  	//search for StringPool::offset_ms_aString  	if (FindAoBInFile (reader' keyRef - 100' new byte[] {  		0x8b'  		0x0c  	}' 100))  		reader.BaseStream.Position += 3;  	else if (FindAoBInFile (reader' keyRef - 100' new byte[] {  		0x8b'  		0x86  	}' 100))  		reader.BaseStream.Position += 2;  	else  		throw new Exception ("could not find start of StringPool::offset_ms_aString");  	offset_StringPool__ms_aString = reader.ReadInt32 () - ImageBase;  	Status ("StringPool::ms_aString located at {0:X8}"' offset_StringPool__ms_aString);  	//search for xrefs to function StringPool::GetString(uint' char)   	int[] xref = FindCalls (offset_StringPool__GetString_uint_char' 2);  	if (xref.Length != 2)  		throw new Exception ("failed to find references to StringPool::GetString(uint' char)");  	//search for start of StringPool::GetString(uint)  	if (!FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x51'  		0x8b  	}' 50) && !FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x55'  		0x8b  	}' 50))  		throw new Exception ("could not find start of GetString(uint)");  	int offset_StringPool__GetString_uint = (int)reader.BaseStream.Position;  	Status ("StringPool::GetString(uint) located at {0:X8}"' offset_StringPool__GetString_uint);  	//search for start of StringPool::GetString(uint' ushort)  	for (reader.BaseStream.Position = xref [1]; (reader.ReadUInt32 () & 0xffffff00) != 0x000cc200; reader.BaseStream.Position -= 5)  		;  	//seek the start of function StringPool::GetString(uint' char)  	while (reader.ReadByte () == 0xcc)  		;  	// allign  	reader.BaseStream.Position -= 1;  	int offset_StringPool__GetString_uint_ushort = (int)reader.BaseStream.Position;  	Status ("StringPool::GetString(uint' ushort) located at {0:X8}"' offset_StringPool__GetString_uint_ushort);  	//search for xrefs to function StringPool::GetString(uint)  	xref = FindCalls (offset_StringPool__GetString_uint' 1);  	if (xref.Length != 1)  		throw new Exception ("failed to find references to StringPool::GetString(uint)");  	//search for start of function StringPool::GetBSTR(uint)  	reader.BaseStream.Position -= 100;  	// should be enough  	if (!FindAoBInFile (reader' (int)reader.BaseStream.Position' new byte[] {  		0xb8'  		0xaa'  		0xaa'  		0xaa'  		0x00  	}))  		for (reader.BaseStream.Position = xref [0]; (reader.ReadUInt32 () & 0xff00ff00) != 0x0000c200; reader.BaseStream.Position -= 5)  			;  	//seek the start of function StringPool::GetString(uint' char)  	while (reader.ReadByte () == 0xcc)  		;  	// allign  	reader.BaseStream.Position -= 1;  	int offset_StringPool__GetBSTR_uint = (int)reader.BaseStream.Position;  	Status ("StringPool::GetBSTR(uint) located at {0:X8}"' offset_StringPool__GetBSTR_uint);  	//search for xrefs to function StringPool::GetString(uint' ushort)  	xref = FindCalls (offset_StringPool__GetString_uint_ushort' 1);  	if (xref.Length != 1)  		throw new Exception ("failed to find references to StringPool::GetString(uint' ushort)");  	//search for start of function StringPool::GetStringW(uint)  	if (!FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x51'  		0x8b  	}' 50) && !FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x55'  		0x8b  	}' 50))  		throw new Exception ("could not find start of GetStringW(uint)");  	int offset_StringPool__GetStringW_uint = (int)reader.BaseStream.Position;  	Status ("StringPool::GetStringW(uint) located at {0:X8}"' offset_StringPool__GetStringW_uint);  	ms_nSize = GetIntFromOffset (offset_StringPool__ms_aKey + 16 + 4);  	Status ("Amount of strings: {0}"' ms_nSize);  	if (MessageBox.Show ("Scan for references to strings in the client? This can take a while."' "Warning"' MessageBoxButtons.YesNo' MessageBoxIcon.Warning) == DialogResult.Yes) {  		Status ("Searching for references to GetString' GetStringW' and GetBSTR");  		List<int> GetStringCalls = new List<int> ();  		List<int> GetStringWCalls = new List<int> ();  		List<int> GetBSTRCalls = new List<int> ();  		for (reader.BaseStream.Position = 0; reader.BaseStream.Position < reader.BaseStream.Length;) {  			//int lol = (int)((float)reader.BaseStream.Position / reader.BaseStream.Length * 100);  			//if (lol > MainForm.toolStripProgressBar1.Value)  			//{  			//    MainForm.Invoke(() => MainForm.toolStripProgressBar1.Value = lol);  			//    MainForm.Invoke(() => MainForm.Update());  			//} too expensive  			if (reader.ReadByte () != 0xE8)  				// call  				continue;  			int offset = reader.ReadInt32 ();  			if (reader.BaseStream.Position + offset == offset_StringPool__GetString_uint)  				GetStringCalls.Add ((int)reader.BaseStream.Position - 5);  			else if (reader.BaseStream.Position + offset == offset_StringPool__GetStringW_uint)  				GetStringWCalls.Add ((int)reader.BaseStream.Position - 5);  			else if (reader.BaseStream.Position + offset == offset_StringPool__GetBSTR_uint)  				GetBSTRCalls.Add ((int)reader.BaseStream.Position - 5);  			else  				reader.BaseStream.Position -= 4;  		}  		List<int> GetStringFail = new List<int> ();  		foreach (int addr in GetStringCalls) {  			reader.BaseStream.Position = addr;  			reader.BaseStream.Position -= 2;  			if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  			 {  				GetStringFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 7;  			if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  			 {  				GetStringFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 2;  			if (reader.ReadByte () != 0x50)// push eax  			 {  				GetStringFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 6;  			if (reader.ReadByte () != 0x68)// push dword  			 {  				GetStringFail.Add (addr);  				continue;  			}  			int idx = reader.ReadInt32 ();  			if (idx > ms_nSize - 1)  				GetStringFail.Add (addr);  			else  				GetString.Add (addr' idx);  		}  		List<int> GetStringWFail = new List<int> ();  		foreach (int addr in GetStringWCalls) {  			reader.BaseStream.Position = addr;  			reader.BaseStream.Position -= 2;  			if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 7;  			if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 2;  			if (reader.ReadByte () != 0x50)// push eax  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 6;  			if (reader.ReadByte () != 0x68)// push dword  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			int idx = reader.ReadInt32 ();  			if (idx > ms_nSize - 1)  				GetStringWFail.Add (addr);  			else  				GetStringW.Add (addr' idx);  		}  		List<int> GetBSTRFail = new List<int> ();  		foreach (int addr in GetBSTRCalls) {  			reader.BaseStream.Position = addr;  			reader.BaseStream.Position -= 2;  			if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 7;  			if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 2;  			if (reader.ReadByte () != 0x50)// push eax  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 6;  			if (reader.ReadByte () != 0x68)// push dword  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			int idx = reader.ReadInt32 ();  			if (idx > ms_nSize - 1)  				GetBSTRFail.Add (addr);  			else  				GetBSTR.Add (addr' idx);  		}  		Status ("Failed to find index of {0} references"' GetStringFail.Count + GetStringWFail.Count + GetBSTRFail.Count);  	}  	Status ("Successfully found index of {0} references"' GetString.Count + GetBSTR.Count + GetStringW.Count);  	Status ("Decoding strings");  	for (int index = 0; index < ms_nSize; ++index)  		if (index != -1 && index <= 0xffff)  			Strings.Add (index' StringPoolDecode (index));  	Status ("Populating table");  	foreach (var s in Strings)  		MainForm.Invoke (() => MainForm.dataTable.Rows.Add (s.Key' s.Value' string.Empty));  	foreach (var a in GetString)  		MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetString")));  	foreach (var a in GetBSTR)  		MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetBSTR")));  	foreach (var a in GetStringW)  		MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetStringW")));  }  else if (StringDecodeMethod == 1)// StringDecoder   {  	MainForm.Invoke (() => MainForm.Text += " [StringDecoder]");  	int type = 0;  	int name = 0;  	int offset = 0;  	//search for CStringDecoder::DelayedLoad' which contains the resource type and name  	if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00'  		0x89'  		0x45'  		0xF4'  		0x6A'  		0xAA'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x8B'  		0x4D'  		0xF4'  		0x51'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 12;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 1;  		name = reader.ReadInt32 ();  	}  	else if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00'  		0x6A'  		0xAA'  		0x8B'  		0xF8'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x57'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 9;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 3;  		name = reader.ReadInt32 ();  	}  	else if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0xAA'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 1;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 1;  		name = reader.ReadInt32 ();  	}  	else  		throw new Exception ("Failed to determine type and name of resource.");  	//search for start of function CStringDecoder::DelayedLoad()  	reader.BaseStream.Position -= 50;  	// should be enough  	FindAoBInFile (reader' (int)reader.BaseStream.Position' new byte[] {  		0x55'  		0x8B'  		0xEC'  		0x83'  		0xEC'  		0x10  	});  	int offset_CStringDecoder__DelayedLoad = (int)reader.BaseStream.Position;  	for (reader.BaseStream.Position = 0; reader.BaseStream.Position < reader.BaseStream.Length;) {  		if (reader.ReadByte () != 0xE8)  			// call  			continue;  		int offse = reader.ReadInt32 ();  		if (reader.BaseStream.Position + offse == offset_CStringDecoder__DelayedLoad) {  			Status ("{0:X8} reference to offset_CStringDecoder__DelayedLoad = {1:X8}"' reader.BaseStream.Position - 5' offse);  			break;  		}  	}  	ImageResourceDirectory tier1 = (ImageResourceDirectory)root.GetEntry (type).Entry;  	ImageResourceDirectory tier2 = (ImageResourceDirectory)tier1.GetEntry (name).Entry;  	rsrcStringDataEntry = (ImageResourceDataEntry)tier2.Entrys [0].Entry;  	rsrcStringDataPosition = rsrcPointerToRawData + (rsrcStringDataEntry.OffsetToData - rsrcVirtualAddress);  	m_nCount = GetWordFromIndex (0);  	Status ("Amount of strings: {0}"' m_nCount);  	for (int i = 1; i < m_nCount; ++i)  		MainForm.Invoke (() => MainForm.dataTable.Rows.Add (i' StringDecoderDecode (i)' string.Format ("{0:X8}"' rsrcStringDataPosition + i * 4)));  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: if (StringDecodeMethod == 0)// StringPool   {  	MainForm.Invoke (() => MainForm.Text += " [StringPool]");  	int offset_StringPool__ms_aKey = (int)reader.BaseStream.Position;  	Status ("StringPool::ms_aKey located at {0:X8}"' offset_StringPool__ms_aKey);  	int keyRef = 0;  	// Only GetString references ms_aKey  	byte[] bytes = new byte[5];  	bytes [0] = 0x68;  	// push offset  	Buffer.BlockCopy (BitConverter.GetBytes (ImageBase + offset_StringPool__ms_aKey)' 0' bytes' 1' 4);  	if (FindAoBInFile (reader' 0' bytes))  		keyRef = (int)reader.BaseStream.Position;  	reader.BaseStream.Position = keyRef;  	while (true) {  		byte[] asdf = reader.ReadBytes (5);  		if (asdf [4] == 0xc3)// retn  		 {  			bool die = true;  			foreach (byte b in asdf)  				if (b == 0xe8)// call  				 {  					die = false;  					break;  				}  			if (die)  				break;  		}  		reader.BaseStream.Position -= 6;  	}  	while (reader.ReadByte () == 0xcc)  		;  	// allign  	reader.BaseStream.Position -= 1;  	int offset_StringPool__GetString_uint_char = (int)reader.BaseStream.Position;  	Status ("StringPool::GetString(uint' char) located at {0:X8}"' offset_StringPool__GetString_uint_char);  	//search for StringPool::offset_ms_aString  	if (FindAoBInFile (reader' keyRef - 100' new byte[] {  		0x8b'  		0x0c  	}' 100))  		reader.BaseStream.Position += 3;  	else if (FindAoBInFile (reader' keyRef - 100' new byte[] {  		0x8b'  		0x86  	}' 100))  		reader.BaseStream.Position += 2;  	else  		throw new Exception ("could not find start of StringPool::offset_ms_aString");  	offset_StringPool__ms_aString = reader.ReadInt32 () - ImageBase;  	Status ("StringPool::ms_aString located at {0:X8}"' offset_StringPool__ms_aString);  	//search for xrefs to function StringPool::GetString(uint' char)   	int[] xref = FindCalls (offset_StringPool__GetString_uint_char' 2);  	if (xref.Length != 2)  		throw new Exception ("failed to find references to StringPool::GetString(uint' char)");  	//search for start of StringPool::GetString(uint)  	if (!FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x51'  		0x8b  	}' 50) && !FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x55'  		0x8b  	}' 50))  		throw new Exception ("could not find start of GetString(uint)");  	int offset_StringPool__GetString_uint = (int)reader.BaseStream.Position;  	Status ("StringPool::GetString(uint) located at {0:X8}"' offset_StringPool__GetString_uint);  	//search for start of StringPool::GetString(uint' ushort)  	for (reader.BaseStream.Position = xref [1]; (reader.ReadUInt32 () & 0xffffff00) != 0x000cc200; reader.BaseStream.Position -= 5)  		;  	//seek the start of function StringPool::GetString(uint' char)  	while (reader.ReadByte () == 0xcc)  		;  	// allign  	reader.BaseStream.Position -= 1;  	int offset_StringPool__GetString_uint_ushort = (int)reader.BaseStream.Position;  	Status ("StringPool::GetString(uint' ushort) located at {0:X8}"' offset_StringPool__GetString_uint_ushort);  	//search for xrefs to function StringPool::GetString(uint)  	xref = FindCalls (offset_StringPool__GetString_uint' 1);  	if (xref.Length != 1)  		throw new Exception ("failed to find references to StringPool::GetString(uint)");  	//search for start of function StringPool::GetBSTR(uint)  	reader.BaseStream.Position -= 100;  	// should be enough  	if (!FindAoBInFile (reader' (int)reader.BaseStream.Position' new byte[] {  		0xb8'  		0xaa'  		0xaa'  		0xaa'  		0x00  	}))  		for (reader.BaseStream.Position = xref [0]; (reader.ReadUInt32 () & 0xff00ff00) != 0x0000c200; reader.BaseStream.Position -= 5)  			;  	//seek the start of function StringPool::GetString(uint' char)  	while (reader.ReadByte () == 0xcc)  		;  	// allign  	reader.BaseStream.Position -= 1;  	int offset_StringPool__GetBSTR_uint = (int)reader.BaseStream.Position;  	Status ("StringPool::GetBSTR(uint) located at {0:X8}"' offset_StringPool__GetBSTR_uint);  	//search for xrefs to function StringPool::GetString(uint' ushort)  	xref = FindCalls (offset_StringPool__GetString_uint_ushort' 1);  	if (xref.Length != 1)  		throw new Exception ("failed to find references to StringPool::GetString(uint' ushort)");  	//search for start of function StringPool::GetStringW(uint)  	if (!FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x51'  		0x8b  	}' 50) && !FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x55'  		0x8b  	}' 50))  		throw new Exception ("could not find start of GetStringW(uint)");  	int offset_StringPool__GetStringW_uint = (int)reader.BaseStream.Position;  	Status ("StringPool::GetStringW(uint) located at {0:X8}"' offset_StringPool__GetStringW_uint);  	ms_nSize = GetIntFromOffset (offset_StringPool__ms_aKey + 16 + 4);  	Status ("Amount of strings: {0}"' ms_nSize);  	if (MessageBox.Show ("Scan for references to strings in the client? This can take a while."' "Warning"' MessageBoxButtons.YesNo' MessageBoxIcon.Warning) == DialogResult.Yes) {  		Status ("Searching for references to GetString' GetStringW' and GetBSTR");  		List<int> GetStringCalls = new List<int> ();  		List<int> GetStringWCalls = new List<int> ();  		List<int> GetBSTRCalls = new List<int> ();  		for (reader.BaseStream.Position = 0; reader.BaseStream.Position < reader.BaseStream.Length;) {  			//int lol = (int)((float)reader.BaseStream.Position / reader.BaseStream.Length * 100);  			//if (lol > MainForm.toolStripProgressBar1.Value)  			//{  			//    MainForm.Invoke(() => MainForm.toolStripProgressBar1.Value = lol);  			//    MainForm.Invoke(() => MainForm.Update());  			//} too expensive  			if (reader.ReadByte () != 0xE8)  				// call  				continue;  			int offset = reader.ReadInt32 ();  			if (reader.BaseStream.Position + offset == offset_StringPool__GetString_uint)  				GetStringCalls.Add ((int)reader.BaseStream.Position - 5);  			else if (reader.BaseStream.Position + offset == offset_StringPool__GetStringW_uint)  				GetStringWCalls.Add ((int)reader.BaseStream.Position - 5);  			else if (reader.BaseStream.Position + offset == offset_StringPool__GetBSTR_uint)  				GetBSTRCalls.Add ((int)reader.BaseStream.Position - 5);  			else  				reader.BaseStream.Position -= 4;  		}  		List<int> GetStringFail = new List<int> ();  		foreach (int addr in GetStringCalls) {  			reader.BaseStream.Position = addr;  			reader.BaseStream.Position -= 2;  			if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  			 {  				GetStringFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 7;  			if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  			 {  				GetStringFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 2;  			if (reader.ReadByte () != 0x50)// push eax  			 {  				GetStringFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 6;  			if (reader.ReadByte () != 0x68)// push dword  			 {  				GetStringFail.Add (addr);  				continue;  			}  			int idx = reader.ReadInt32 ();  			if (idx > ms_nSize - 1)  				GetStringFail.Add (addr);  			else  				GetString.Add (addr' idx);  		}  		List<int> GetStringWFail = new List<int> ();  		foreach (int addr in GetStringWCalls) {  			reader.BaseStream.Position = addr;  			reader.BaseStream.Position -= 2;  			if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 7;  			if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 2;  			if (reader.ReadByte () != 0x50)// push eax  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 6;  			if (reader.ReadByte () != 0x68)// push dword  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			int idx = reader.ReadInt32 ();  			if (idx > ms_nSize - 1)  				GetStringWFail.Add (addr);  			else  				GetStringW.Add (addr' idx);  		}  		List<int> GetBSTRFail = new List<int> ();  		foreach (int addr in GetBSTRCalls) {  			reader.BaseStream.Position = addr;  			reader.BaseStream.Position -= 2;  			if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 7;  			if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 2;  			if (reader.ReadByte () != 0x50)// push eax  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 6;  			if (reader.ReadByte () != 0x68)// push dword  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			int idx = reader.ReadInt32 ();  			if (idx > ms_nSize - 1)  				GetBSTRFail.Add (addr);  			else  				GetBSTR.Add (addr' idx);  		}  		Status ("Failed to find index of {0} references"' GetStringFail.Count + GetStringWFail.Count + GetBSTRFail.Count);  	}  	Status ("Successfully found index of {0} references"' GetString.Count + GetBSTR.Count + GetStringW.Count);  	Status ("Decoding strings");  	for (int index = 0; index < ms_nSize; ++index)  		if (index != -1 && index <= 0xffff)  			Strings.Add (index' StringPoolDecode (index));  	Status ("Populating table");  	foreach (var s in Strings)  		MainForm.Invoke (() => MainForm.dataTable.Rows.Add (s.Key' s.Value' string.Empty));  	foreach (var a in GetString)  		MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetString")));  	foreach (var a in GetBSTR)  		MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetBSTR")));  	foreach (var a in GetStringW)  		MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetStringW")));  }  else if (StringDecodeMethod == 1)// StringDecoder   {  	MainForm.Invoke (() => MainForm.Text += " [StringDecoder]");  	int type = 0;  	int name = 0;  	int offset = 0;  	//search for CStringDecoder::DelayedLoad' which contains the resource type and name  	if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00'  		0x89'  		0x45'  		0xF4'  		0x6A'  		0xAA'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x8B'  		0x4D'  		0xF4'  		0x51'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 12;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 1;  		name = reader.ReadInt32 ();  	}  	else if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00'  		0x6A'  		0xAA'  		0x8B'  		0xF8'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x57'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 9;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 3;  		name = reader.ReadInt32 ();  	}  	else if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0xAA'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 1;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 1;  		name = reader.ReadInt32 ();  	}  	else  		throw new Exception ("Failed to determine type and name of resource.");  	//search for start of function CStringDecoder::DelayedLoad()  	reader.BaseStream.Position -= 50;  	// should be enough  	FindAoBInFile (reader' (int)reader.BaseStream.Position' new byte[] {  		0x55'  		0x8B'  		0xEC'  		0x83'  		0xEC'  		0x10  	});  	int offset_CStringDecoder__DelayedLoad = (int)reader.BaseStream.Position;  	for (reader.BaseStream.Position = 0; reader.BaseStream.Position < reader.BaseStream.Length;) {  		if (reader.ReadByte () != 0xE8)  			// call  			continue;  		int offse = reader.ReadInt32 ();  		if (reader.BaseStream.Position + offse == offset_CStringDecoder__DelayedLoad) {  			Status ("{0:X8} reference to offset_CStringDecoder__DelayedLoad = {1:X8}"' reader.BaseStream.Position - 5' offse);  			break;  		}  	}  	ImageResourceDirectory tier1 = (ImageResourceDirectory)root.GetEntry (type).Entry;  	ImageResourceDirectory tier2 = (ImageResourceDirectory)tier1.GetEntry (name).Entry;  	rsrcStringDataEntry = (ImageResourceDataEntry)tier2.Entrys [0].Entry;  	rsrcStringDataPosition = rsrcPointerToRawData + (rsrcStringDataEntry.OffsetToData - rsrcVirtualAddress);  	m_nCount = GetWordFromIndex (0);  	Status ("Amount of strings: {0}"' m_nCount);  	for (int i = 1; i < m_nCount; ++i)  		MainForm.Invoke (() => MainForm.dataTable.Rows.Add (i' StringDecoderDecode (i)' string.Format ("{0:X8}"' rsrcStringDataPosition + i * 4)));  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: if (StringDecodeMethod == 0)// StringPool   {  	MainForm.Invoke (() => MainForm.Text += " [StringPool]");  	int offset_StringPool__ms_aKey = (int)reader.BaseStream.Position;  	Status ("StringPool::ms_aKey located at {0:X8}"' offset_StringPool__ms_aKey);  	int keyRef = 0;  	// Only GetString references ms_aKey  	byte[] bytes = new byte[5];  	bytes [0] = 0x68;  	// push offset  	Buffer.BlockCopy (BitConverter.GetBytes (ImageBase + offset_StringPool__ms_aKey)' 0' bytes' 1' 4);  	if (FindAoBInFile (reader' 0' bytes))  		keyRef = (int)reader.BaseStream.Position;  	reader.BaseStream.Position = keyRef;  	while (true) {  		byte[] asdf = reader.ReadBytes (5);  		if (asdf [4] == 0xc3)// retn  		 {  			bool die = true;  			foreach (byte b in asdf)  				if (b == 0xe8)// call  				 {  					die = false;  					break;  				}  			if (die)  				break;  		}  		reader.BaseStream.Position -= 6;  	}  	while (reader.ReadByte () == 0xcc)  		;  	// allign  	reader.BaseStream.Position -= 1;  	int offset_StringPool__GetString_uint_char = (int)reader.BaseStream.Position;  	Status ("StringPool::GetString(uint' char) located at {0:X8}"' offset_StringPool__GetString_uint_char);  	//search for StringPool::offset_ms_aString  	if (FindAoBInFile (reader' keyRef - 100' new byte[] {  		0x8b'  		0x0c  	}' 100))  		reader.BaseStream.Position += 3;  	else if (FindAoBInFile (reader' keyRef - 100' new byte[] {  		0x8b'  		0x86  	}' 100))  		reader.BaseStream.Position += 2;  	else  		throw new Exception ("could not find start of StringPool::offset_ms_aString");  	offset_StringPool__ms_aString = reader.ReadInt32 () - ImageBase;  	Status ("StringPool::ms_aString located at {0:X8}"' offset_StringPool__ms_aString);  	//search for xrefs to function StringPool::GetString(uint' char)   	int[] xref = FindCalls (offset_StringPool__GetString_uint_char' 2);  	if (xref.Length != 2)  		throw new Exception ("failed to find references to StringPool::GetString(uint' char)");  	//search for start of StringPool::GetString(uint)  	if (!FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x51'  		0x8b  	}' 50) && !FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x55'  		0x8b  	}' 50))  		throw new Exception ("could not find start of GetString(uint)");  	int offset_StringPool__GetString_uint = (int)reader.BaseStream.Position;  	Status ("StringPool::GetString(uint) located at {0:X8}"' offset_StringPool__GetString_uint);  	//search for start of StringPool::GetString(uint' ushort)  	for (reader.BaseStream.Position = xref [1]; (reader.ReadUInt32 () & 0xffffff00) != 0x000cc200; reader.BaseStream.Position -= 5)  		;  	//seek the start of function StringPool::GetString(uint' char)  	while (reader.ReadByte () == 0xcc)  		;  	// allign  	reader.BaseStream.Position -= 1;  	int offset_StringPool__GetString_uint_ushort = (int)reader.BaseStream.Position;  	Status ("StringPool::GetString(uint' ushort) located at {0:X8}"' offset_StringPool__GetString_uint_ushort);  	//search for xrefs to function StringPool::GetString(uint)  	xref = FindCalls (offset_StringPool__GetString_uint' 1);  	if (xref.Length != 1)  		throw new Exception ("failed to find references to StringPool::GetString(uint)");  	//search for start of function StringPool::GetBSTR(uint)  	reader.BaseStream.Position -= 100;  	// should be enough  	if (!FindAoBInFile (reader' (int)reader.BaseStream.Position' new byte[] {  		0xb8'  		0xaa'  		0xaa'  		0xaa'  		0x00  	}))  		for (reader.BaseStream.Position = xref [0]; (reader.ReadUInt32 () & 0xff00ff00) != 0x0000c200; reader.BaseStream.Position -= 5)  			;  	//seek the start of function StringPool::GetString(uint' char)  	while (reader.ReadByte () == 0xcc)  		;  	// allign  	reader.BaseStream.Position -= 1;  	int offset_StringPool__GetBSTR_uint = (int)reader.BaseStream.Position;  	Status ("StringPool::GetBSTR(uint) located at {0:X8}"' offset_StringPool__GetBSTR_uint);  	//search for xrefs to function StringPool::GetString(uint' ushort)  	xref = FindCalls (offset_StringPool__GetString_uint_ushort' 1);  	if (xref.Length != 1)  		throw new Exception ("failed to find references to StringPool::GetString(uint' ushort)");  	//search for start of function StringPool::GetStringW(uint)  	if (!FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x51'  		0x8b  	}' 50) && !FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x55'  		0x8b  	}' 50))  		throw new Exception ("could not find start of GetStringW(uint)");  	int offset_StringPool__GetStringW_uint = (int)reader.BaseStream.Position;  	Status ("StringPool::GetStringW(uint) located at {0:X8}"' offset_StringPool__GetStringW_uint);  	ms_nSize = GetIntFromOffset (offset_StringPool__ms_aKey + 16 + 4);  	Status ("Amount of strings: {0}"' ms_nSize);  	if (MessageBox.Show ("Scan for references to strings in the client? This can take a while."' "Warning"' MessageBoxButtons.YesNo' MessageBoxIcon.Warning) == DialogResult.Yes) {  		Status ("Searching for references to GetString' GetStringW' and GetBSTR");  		List<int> GetStringCalls = new List<int> ();  		List<int> GetStringWCalls = new List<int> ();  		List<int> GetBSTRCalls = new List<int> ();  		for (reader.BaseStream.Position = 0; reader.BaseStream.Position < reader.BaseStream.Length;) {  			//int lol = (int)((float)reader.BaseStream.Position / reader.BaseStream.Length * 100);  			//if (lol > MainForm.toolStripProgressBar1.Value)  			//{  			//    MainForm.Invoke(() => MainForm.toolStripProgressBar1.Value = lol);  			//    MainForm.Invoke(() => MainForm.Update());  			//} too expensive  			if (reader.ReadByte () != 0xE8)  				// call  				continue;  			int offset = reader.ReadInt32 ();  			if (reader.BaseStream.Position + offset == offset_StringPool__GetString_uint)  				GetStringCalls.Add ((int)reader.BaseStream.Position - 5);  			else if (reader.BaseStream.Position + offset == offset_StringPool__GetStringW_uint)  				GetStringWCalls.Add ((int)reader.BaseStream.Position - 5);  			else if (reader.BaseStream.Position + offset == offset_StringPool__GetBSTR_uint)  				GetBSTRCalls.Add ((int)reader.BaseStream.Position - 5);  			else  				reader.BaseStream.Position -= 4;  		}  		List<int> GetStringFail = new List<int> ();  		foreach (int addr in GetStringCalls) {  			reader.BaseStream.Position = addr;  			reader.BaseStream.Position -= 2;  			if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  			 {  				GetStringFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 7;  			if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  			 {  				GetStringFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 2;  			if (reader.ReadByte () != 0x50)// push eax  			 {  				GetStringFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 6;  			if (reader.ReadByte () != 0x68)// push dword  			 {  				GetStringFail.Add (addr);  				continue;  			}  			int idx = reader.ReadInt32 ();  			if (idx > ms_nSize - 1)  				GetStringFail.Add (addr);  			else  				GetString.Add (addr' idx);  		}  		List<int> GetStringWFail = new List<int> ();  		foreach (int addr in GetStringWCalls) {  			reader.BaseStream.Position = addr;  			reader.BaseStream.Position -= 2;  			if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 7;  			if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 2;  			if (reader.ReadByte () != 0x50)// push eax  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 6;  			if (reader.ReadByte () != 0x68)// push dword  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			int idx = reader.ReadInt32 ();  			if (idx > ms_nSize - 1)  				GetStringWFail.Add (addr);  			else  				GetStringW.Add (addr' idx);  		}  		List<int> GetBSTRFail = new List<int> ();  		foreach (int addr in GetBSTRCalls) {  			reader.BaseStream.Position = addr;  			reader.BaseStream.Position -= 2;  			if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 7;  			if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 2;  			if (reader.ReadByte () != 0x50)// push eax  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 6;  			if (reader.ReadByte () != 0x68)// push dword  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			int idx = reader.ReadInt32 ();  			if (idx > ms_nSize - 1)  				GetBSTRFail.Add (addr);  			else  				GetBSTR.Add (addr' idx);  		}  		Status ("Failed to find index of {0} references"' GetStringFail.Count + GetStringWFail.Count + GetBSTRFail.Count);  	}  	Status ("Successfully found index of {0} references"' GetString.Count + GetBSTR.Count + GetStringW.Count);  	Status ("Decoding strings");  	for (int index = 0; index < ms_nSize; ++index)  		if (index != -1 && index <= 0xffff)  			Strings.Add (index' StringPoolDecode (index));  	Status ("Populating table");  	foreach (var s in Strings)  		MainForm.Invoke (() => MainForm.dataTable.Rows.Add (s.Key' s.Value' string.Empty));  	foreach (var a in GetString)  		MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetString")));  	foreach (var a in GetBSTR)  		MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetBSTR")));  	foreach (var a in GetStringW)  		MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetStringW")));  }  else if (StringDecodeMethod == 1)// StringDecoder   {  	MainForm.Invoke (() => MainForm.Text += " [StringDecoder]");  	int type = 0;  	int name = 0;  	int offset = 0;  	//search for CStringDecoder::DelayedLoad' which contains the resource type and name  	if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00'  		0x89'  		0x45'  		0xF4'  		0x6A'  		0xAA'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x8B'  		0x4D'  		0xF4'  		0x51'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 12;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 1;  		name = reader.ReadInt32 ();  	}  	else if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00'  		0x6A'  		0xAA'  		0x8B'  		0xF8'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x57'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 9;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 3;  		name = reader.ReadInt32 ();  	}  	else if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0xAA'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 1;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 1;  		name = reader.ReadInt32 ();  	}  	else  		throw new Exception ("Failed to determine type and name of resource.");  	//search for start of function CStringDecoder::DelayedLoad()  	reader.BaseStream.Position -= 50;  	// should be enough  	FindAoBInFile (reader' (int)reader.BaseStream.Position' new byte[] {  		0x55'  		0x8B'  		0xEC'  		0x83'  		0xEC'  		0x10  	});  	int offset_CStringDecoder__DelayedLoad = (int)reader.BaseStream.Position;  	for (reader.BaseStream.Position = 0; reader.BaseStream.Position < reader.BaseStream.Length;) {  		if (reader.ReadByte () != 0xE8)  			// call  			continue;  		int offse = reader.ReadInt32 ();  		if (reader.BaseStream.Position + offse == offset_CStringDecoder__DelayedLoad) {  			Status ("{0:X8} reference to offset_CStringDecoder__DelayedLoad = {1:X8}"' reader.BaseStream.Position - 5' offse);  			break;  		}  	}  	ImageResourceDirectory tier1 = (ImageResourceDirectory)root.GetEntry (type).Entry;  	ImageResourceDirectory tier2 = (ImageResourceDirectory)tier1.GetEntry (name).Entry;  	rsrcStringDataEntry = (ImageResourceDataEntry)tier2.Entrys [0].Entry;  	rsrcStringDataPosition = rsrcPointerToRawData + (rsrcStringDataEntry.OffsetToData - rsrcVirtualAddress);  	m_nCount = GetWordFromIndex (0);  	Status ("Amount of strings: {0}"' m_nCount);  	for (int i = 1; i < m_nCount; ++i)  		MainForm.Invoke (() => MainForm.dataTable.Rows.Add (i' StringDecoderDecode (i)' string.Format ("{0:X8}"' rsrcStringDataPosition + i * 4)));  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: if (StringDecodeMethod == 0)// StringPool   {  	MainForm.Invoke (() => MainForm.Text += " [StringPool]");  	int offset_StringPool__ms_aKey = (int)reader.BaseStream.Position;  	Status ("StringPool::ms_aKey located at {0:X8}"' offset_StringPool__ms_aKey);  	int keyRef = 0;  	// Only GetString references ms_aKey  	byte[] bytes = new byte[5];  	bytes [0] = 0x68;  	// push offset  	Buffer.BlockCopy (BitConverter.GetBytes (ImageBase + offset_StringPool__ms_aKey)' 0' bytes' 1' 4);  	if (FindAoBInFile (reader' 0' bytes))  		keyRef = (int)reader.BaseStream.Position;  	reader.BaseStream.Position = keyRef;  	while (true) {  		byte[] asdf = reader.ReadBytes (5);  		if (asdf [4] == 0xc3)// retn  		 {  			bool die = true;  			foreach (byte b in asdf)  				if (b == 0xe8)// call  				 {  					die = false;  					break;  				}  			if (die)  				break;  		}  		reader.BaseStream.Position -= 6;  	}  	while (reader.ReadByte () == 0xcc)  		;  	// allign  	reader.BaseStream.Position -= 1;  	int offset_StringPool__GetString_uint_char = (int)reader.BaseStream.Position;  	Status ("StringPool::GetString(uint' char) located at {0:X8}"' offset_StringPool__GetString_uint_char);  	//search for StringPool::offset_ms_aString  	if (FindAoBInFile (reader' keyRef - 100' new byte[] {  		0x8b'  		0x0c  	}' 100))  		reader.BaseStream.Position += 3;  	else if (FindAoBInFile (reader' keyRef - 100' new byte[] {  		0x8b'  		0x86  	}' 100))  		reader.BaseStream.Position += 2;  	else  		throw new Exception ("could not find start of StringPool::offset_ms_aString");  	offset_StringPool__ms_aString = reader.ReadInt32 () - ImageBase;  	Status ("StringPool::ms_aString located at {0:X8}"' offset_StringPool__ms_aString);  	//search for xrefs to function StringPool::GetString(uint' char)   	int[] xref = FindCalls (offset_StringPool__GetString_uint_char' 2);  	if (xref.Length != 2)  		throw new Exception ("failed to find references to StringPool::GetString(uint' char)");  	//search for start of StringPool::GetString(uint)  	if (!FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x51'  		0x8b  	}' 50) && !FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x55'  		0x8b  	}' 50))  		throw new Exception ("could not find start of GetString(uint)");  	int offset_StringPool__GetString_uint = (int)reader.BaseStream.Position;  	Status ("StringPool::GetString(uint) located at {0:X8}"' offset_StringPool__GetString_uint);  	//search for start of StringPool::GetString(uint' ushort)  	for (reader.BaseStream.Position = xref [1]; (reader.ReadUInt32 () & 0xffffff00) != 0x000cc200; reader.BaseStream.Position -= 5)  		;  	//seek the start of function StringPool::GetString(uint' char)  	while (reader.ReadByte () == 0xcc)  		;  	// allign  	reader.BaseStream.Position -= 1;  	int offset_StringPool__GetString_uint_ushort = (int)reader.BaseStream.Position;  	Status ("StringPool::GetString(uint' ushort) located at {0:X8}"' offset_StringPool__GetString_uint_ushort);  	//search for xrefs to function StringPool::GetString(uint)  	xref = FindCalls (offset_StringPool__GetString_uint' 1);  	if (xref.Length != 1)  		throw new Exception ("failed to find references to StringPool::GetString(uint)");  	//search for start of function StringPool::GetBSTR(uint)  	reader.BaseStream.Position -= 100;  	// should be enough  	if (!FindAoBInFile (reader' (int)reader.BaseStream.Position' new byte[] {  		0xb8'  		0xaa'  		0xaa'  		0xaa'  		0x00  	}))  		for (reader.BaseStream.Position = xref [0]; (reader.ReadUInt32 () & 0xff00ff00) != 0x0000c200; reader.BaseStream.Position -= 5)  			;  	//seek the start of function StringPool::GetString(uint' char)  	while (reader.ReadByte () == 0xcc)  		;  	// allign  	reader.BaseStream.Position -= 1;  	int offset_StringPool__GetBSTR_uint = (int)reader.BaseStream.Position;  	Status ("StringPool::GetBSTR(uint) located at {0:X8}"' offset_StringPool__GetBSTR_uint);  	//search for xrefs to function StringPool::GetString(uint' ushort)  	xref = FindCalls (offset_StringPool__GetString_uint_ushort' 1);  	if (xref.Length != 1)  		throw new Exception ("failed to find references to StringPool::GetString(uint' ushort)");  	//search for start of function StringPool::GetStringW(uint)  	if (!FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x51'  		0x8b  	}' 50) && !FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x55'  		0x8b  	}' 50))  		throw new Exception ("could not find start of GetStringW(uint)");  	int offset_StringPool__GetStringW_uint = (int)reader.BaseStream.Position;  	Status ("StringPool::GetStringW(uint) located at {0:X8}"' offset_StringPool__GetStringW_uint);  	ms_nSize = GetIntFromOffset (offset_StringPool__ms_aKey + 16 + 4);  	Status ("Amount of strings: {0}"' ms_nSize);  	if (MessageBox.Show ("Scan for references to strings in the client? This can take a while."' "Warning"' MessageBoxButtons.YesNo' MessageBoxIcon.Warning) == DialogResult.Yes) {  		Status ("Searching for references to GetString' GetStringW' and GetBSTR");  		List<int> GetStringCalls = new List<int> ();  		List<int> GetStringWCalls = new List<int> ();  		List<int> GetBSTRCalls = new List<int> ();  		for (reader.BaseStream.Position = 0; reader.BaseStream.Position < reader.BaseStream.Length;) {  			//int lol = (int)((float)reader.BaseStream.Position / reader.BaseStream.Length * 100);  			//if (lol > MainForm.toolStripProgressBar1.Value)  			//{  			//    MainForm.Invoke(() => MainForm.toolStripProgressBar1.Value = lol);  			//    MainForm.Invoke(() => MainForm.Update());  			//} too expensive  			if (reader.ReadByte () != 0xE8)  				// call  				continue;  			int offset = reader.ReadInt32 ();  			if (reader.BaseStream.Position + offset == offset_StringPool__GetString_uint)  				GetStringCalls.Add ((int)reader.BaseStream.Position - 5);  			else if (reader.BaseStream.Position + offset == offset_StringPool__GetStringW_uint)  				GetStringWCalls.Add ((int)reader.BaseStream.Position - 5);  			else if (reader.BaseStream.Position + offset == offset_StringPool__GetBSTR_uint)  				GetBSTRCalls.Add ((int)reader.BaseStream.Position - 5);  			else  				reader.BaseStream.Position -= 4;  		}  		List<int> GetStringFail = new List<int> ();  		foreach (int addr in GetStringCalls) {  			reader.BaseStream.Position = addr;  			reader.BaseStream.Position -= 2;  			if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  			 {  				GetStringFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 7;  			if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  			 {  				GetStringFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 2;  			if (reader.ReadByte () != 0x50)// push eax  			 {  				GetStringFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 6;  			if (reader.ReadByte () != 0x68)// push dword  			 {  				GetStringFail.Add (addr);  				continue;  			}  			int idx = reader.ReadInt32 ();  			if (idx > ms_nSize - 1)  				GetStringFail.Add (addr);  			else  				GetString.Add (addr' idx);  		}  		List<int> GetStringWFail = new List<int> ();  		foreach (int addr in GetStringWCalls) {  			reader.BaseStream.Position = addr;  			reader.BaseStream.Position -= 2;  			if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 7;  			if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 2;  			if (reader.ReadByte () != 0x50)// push eax  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 6;  			if (reader.ReadByte () != 0x68)// push dword  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			int idx = reader.ReadInt32 ();  			if (idx > ms_nSize - 1)  				GetStringWFail.Add (addr);  			else  				GetStringW.Add (addr' idx);  		}  		List<int> GetBSTRFail = new List<int> ();  		foreach (int addr in GetBSTRCalls) {  			reader.BaseStream.Position = addr;  			reader.BaseStream.Position -= 2;  			if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 7;  			if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 2;  			if (reader.ReadByte () != 0x50)// push eax  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 6;  			if (reader.ReadByte () != 0x68)// push dword  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			int idx = reader.ReadInt32 ();  			if (idx > ms_nSize - 1)  				GetBSTRFail.Add (addr);  			else  				GetBSTR.Add (addr' idx);  		}  		Status ("Failed to find index of {0} references"' GetStringFail.Count + GetStringWFail.Count + GetBSTRFail.Count);  	}  	Status ("Successfully found index of {0} references"' GetString.Count + GetBSTR.Count + GetStringW.Count);  	Status ("Decoding strings");  	for (int index = 0; index < ms_nSize; ++index)  		if (index != -1 && index <= 0xffff)  			Strings.Add (index' StringPoolDecode (index));  	Status ("Populating table");  	foreach (var s in Strings)  		MainForm.Invoke (() => MainForm.dataTable.Rows.Add (s.Key' s.Value' string.Empty));  	foreach (var a in GetString)  		MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetString")));  	foreach (var a in GetBSTR)  		MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetBSTR")));  	foreach (var a in GetStringW)  		MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetStringW")));  }  else if (StringDecodeMethod == 1)// StringDecoder   {  	MainForm.Invoke (() => MainForm.Text += " [StringDecoder]");  	int type = 0;  	int name = 0;  	int offset = 0;  	//search for CStringDecoder::DelayedLoad' which contains the resource type and name  	if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00'  		0x89'  		0x45'  		0xF4'  		0x6A'  		0xAA'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x8B'  		0x4D'  		0xF4'  		0x51'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 12;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 1;  		name = reader.ReadInt32 ();  	}  	else if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00'  		0x6A'  		0xAA'  		0x8B'  		0xF8'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x57'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 9;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 3;  		name = reader.ReadInt32 ();  	}  	else if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0xAA'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 1;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 1;  		name = reader.ReadInt32 ();  	}  	else  		throw new Exception ("Failed to determine type and name of resource.");  	//search for start of function CStringDecoder::DelayedLoad()  	reader.BaseStream.Position -= 50;  	// should be enough  	FindAoBInFile (reader' (int)reader.BaseStream.Position' new byte[] {  		0x55'  		0x8B'  		0xEC'  		0x83'  		0xEC'  		0x10  	});  	int offset_CStringDecoder__DelayedLoad = (int)reader.BaseStream.Position;  	for (reader.BaseStream.Position = 0; reader.BaseStream.Position < reader.BaseStream.Length;) {  		if (reader.ReadByte () != 0xE8)  			// call  			continue;  		int offse = reader.ReadInt32 ();  		if (reader.BaseStream.Position + offse == offset_CStringDecoder__DelayedLoad) {  			Status ("{0:X8} reference to offset_CStringDecoder__DelayedLoad = {1:X8}"' reader.BaseStream.Position - 5' offse);  			break;  		}  	}  	ImageResourceDirectory tier1 = (ImageResourceDirectory)root.GetEntry (type).Entry;  	ImageResourceDirectory tier2 = (ImageResourceDirectory)tier1.GetEntry (name).Entry;  	rsrcStringDataEntry = (ImageResourceDataEntry)tier2.Entrys [0].Entry;  	rsrcStringDataPosition = rsrcPointerToRawData + (rsrcStringDataEntry.OffsetToData - rsrcVirtualAddress);  	m_nCount = GetWordFromIndex (0);  	Status ("Amount of strings: {0}"' m_nCount);  	for (int i = 1; i < m_nCount; ++i)  		MainForm.Invoke (() => MainForm.dataTable.Rows.Add (i' StringDecoderDecode (i)' string.Format ("{0:X8}"' rsrcStringDataPosition + i * 4)));  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: if (StringDecodeMethod == 0)// StringPool   {  	MainForm.Invoke (() => MainForm.Text += " [StringPool]");  	int offset_StringPool__ms_aKey = (int)reader.BaseStream.Position;  	Status ("StringPool::ms_aKey located at {0:X8}"' offset_StringPool__ms_aKey);  	int keyRef = 0;  	// Only GetString references ms_aKey  	byte[] bytes = new byte[5];  	bytes [0] = 0x68;  	// push offset  	Buffer.BlockCopy (BitConverter.GetBytes (ImageBase + offset_StringPool__ms_aKey)' 0' bytes' 1' 4);  	if (FindAoBInFile (reader' 0' bytes))  		keyRef = (int)reader.BaseStream.Position;  	reader.BaseStream.Position = keyRef;  	while (true) {  		byte[] asdf = reader.ReadBytes (5);  		if (asdf [4] == 0xc3)// retn  		 {  			bool die = true;  			foreach (byte b in asdf)  				if (b == 0xe8)// call  				 {  					die = false;  					break;  				}  			if (die)  				break;  		}  		reader.BaseStream.Position -= 6;  	}  	while (reader.ReadByte () == 0xcc)  		;  	// allign  	reader.BaseStream.Position -= 1;  	int offset_StringPool__GetString_uint_char = (int)reader.BaseStream.Position;  	Status ("StringPool::GetString(uint' char) located at {0:X8}"' offset_StringPool__GetString_uint_char);  	//search for StringPool::offset_ms_aString  	if (FindAoBInFile (reader' keyRef - 100' new byte[] {  		0x8b'  		0x0c  	}' 100))  		reader.BaseStream.Position += 3;  	else if (FindAoBInFile (reader' keyRef - 100' new byte[] {  		0x8b'  		0x86  	}' 100))  		reader.BaseStream.Position += 2;  	else  		throw new Exception ("could not find start of StringPool::offset_ms_aString");  	offset_StringPool__ms_aString = reader.ReadInt32 () - ImageBase;  	Status ("StringPool::ms_aString located at {0:X8}"' offset_StringPool__ms_aString);  	//search for xrefs to function StringPool::GetString(uint' char)   	int[] xref = FindCalls (offset_StringPool__GetString_uint_char' 2);  	if (xref.Length != 2)  		throw new Exception ("failed to find references to StringPool::GetString(uint' char)");  	//search for start of StringPool::GetString(uint)  	if (!FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x51'  		0x8b  	}' 50) && !FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x55'  		0x8b  	}' 50))  		throw new Exception ("could not find start of GetString(uint)");  	int offset_StringPool__GetString_uint = (int)reader.BaseStream.Position;  	Status ("StringPool::GetString(uint) located at {0:X8}"' offset_StringPool__GetString_uint);  	//search for start of StringPool::GetString(uint' ushort)  	for (reader.BaseStream.Position = xref [1]; (reader.ReadUInt32 () & 0xffffff00) != 0x000cc200; reader.BaseStream.Position -= 5)  		;  	//seek the start of function StringPool::GetString(uint' char)  	while (reader.ReadByte () == 0xcc)  		;  	// allign  	reader.BaseStream.Position -= 1;  	int offset_StringPool__GetString_uint_ushort = (int)reader.BaseStream.Position;  	Status ("StringPool::GetString(uint' ushort) located at {0:X8}"' offset_StringPool__GetString_uint_ushort);  	//search for xrefs to function StringPool::GetString(uint)  	xref = FindCalls (offset_StringPool__GetString_uint' 1);  	if (xref.Length != 1)  		throw new Exception ("failed to find references to StringPool::GetString(uint)");  	//search for start of function StringPool::GetBSTR(uint)  	reader.BaseStream.Position -= 100;  	// should be enough  	if (!FindAoBInFile (reader' (int)reader.BaseStream.Position' new byte[] {  		0xb8'  		0xaa'  		0xaa'  		0xaa'  		0x00  	}))  		for (reader.BaseStream.Position = xref [0]; (reader.ReadUInt32 () & 0xff00ff00) != 0x0000c200; reader.BaseStream.Position -= 5)  			;  	//seek the start of function StringPool::GetString(uint' char)  	while (reader.ReadByte () == 0xcc)  		;  	// allign  	reader.BaseStream.Position -= 1;  	int offset_StringPool__GetBSTR_uint = (int)reader.BaseStream.Position;  	Status ("StringPool::GetBSTR(uint) located at {0:X8}"' offset_StringPool__GetBSTR_uint);  	//search for xrefs to function StringPool::GetString(uint' ushort)  	xref = FindCalls (offset_StringPool__GetString_uint_ushort' 1);  	if (xref.Length != 1)  		throw new Exception ("failed to find references to StringPool::GetString(uint' ushort)");  	//search for start of function StringPool::GetStringW(uint)  	if (!FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x51'  		0x8b  	}' 50) && !FindAoBInFile (reader' xref [0] - 50' new byte[] {  		0x55'  		0x8b  	}' 50))  		throw new Exception ("could not find start of GetStringW(uint)");  	int offset_StringPool__GetStringW_uint = (int)reader.BaseStream.Position;  	Status ("StringPool::GetStringW(uint) located at {0:X8}"' offset_StringPool__GetStringW_uint);  	ms_nSize = GetIntFromOffset (offset_StringPool__ms_aKey + 16 + 4);  	Status ("Amount of strings: {0}"' ms_nSize);  	if (MessageBox.Show ("Scan for references to strings in the client? This can take a while."' "Warning"' MessageBoxButtons.YesNo' MessageBoxIcon.Warning) == DialogResult.Yes) {  		Status ("Searching for references to GetString' GetStringW' and GetBSTR");  		List<int> GetStringCalls = new List<int> ();  		List<int> GetStringWCalls = new List<int> ();  		List<int> GetBSTRCalls = new List<int> ();  		for (reader.BaseStream.Position = 0; reader.BaseStream.Position < reader.BaseStream.Length;) {  			//int lol = (int)((float)reader.BaseStream.Position / reader.BaseStream.Length * 100);  			//if (lol > MainForm.toolStripProgressBar1.Value)  			//{  			//    MainForm.Invoke(() => MainForm.toolStripProgressBar1.Value = lol);  			//    MainForm.Invoke(() => MainForm.Update());  			//} too expensive  			if (reader.ReadByte () != 0xE8)  				// call  				continue;  			int offset = reader.ReadInt32 ();  			if (reader.BaseStream.Position + offset == offset_StringPool__GetString_uint)  				GetStringCalls.Add ((int)reader.BaseStream.Position - 5);  			else if (reader.BaseStream.Position + offset == offset_StringPool__GetStringW_uint)  				GetStringWCalls.Add ((int)reader.BaseStream.Position - 5);  			else if (reader.BaseStream.Position + offset == offset_StringPool__GetBSTR_uint)  				GetBSTRCalls.Add ((int)reader.BaseStream.Position - 5);  			else  				reader.BaseStream.Position -= 4;  		}  		List<int> GetStringFail = new List<int> ();  		foreach (int addr in GetStringCalls) {  			reader.BaseStream.Position = addr;  			reader.BaseStream.Position -= 2;  			if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  			 {  				GetStringFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 7;  			if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  			 {  				GetStringFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 2;  			if (reader.ReadByte () != 0x50)// push eax  			 {  				GetStringFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 6;  			if (reader.ReadByte () != 0x68)// push dword  			 {  				GetStringFail.Add (addr);  				continue;  			}  			int idx = reader.ReadInt32 ();  			if (idx > ms_nSize - 1)  				GetStringFail.Add (addr);  			else  				GetString.Add (addr' idx);  		}  		List<int> GetStringWFail = new List<int> ();  		foreach (int addr in GetStringWCalls) {  			reader.BaseStream.Position = addr;  			reader.BaseStream.Position -= 2;  			if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 7;  			if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 2;  			if (reader.ReadByte () != 0x50)// push eax  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 6;  			if (reader.ReadByte () != 0x68)// push dword  			 {  				GetStringWFail.Add (addr);  				continue;  			}  			int idx = reader.ReadInt32 ();  			if (idx > ms_nSize - 1)  				GetStringWFail.Add (addr);  			else  				GetStringW.Add (addr' idx);  		}  		List<int> GetBSTRFail = new List<int> ();  		foreach (int addr in GetBSTRCalls) {  			reader.BaseStream.Position = addr;  			reader.BaseStream.Position -= 2;  			if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 7;  			if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 2;  			if (reader.ReadByte () != 0x50)// push eax  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			reader.BaseStream.Position -= 6;  			if (reader.ReadByte () != 0x68)// push dword  			 {  				GetBSTRFail.Add (addr);  				continue;  			}  			int idx = reader.ReadInt32 ();  			if (idx > ms_nSize - 1)  				GetBSTRFail.Add (addr);  			else  				GetBSTR.Add (addr' idx);  		}  		Status ("Failed to find index of {0} references"' GetStringFail.Count + GetStringWFail.Count + GetBSTRFail.Count);  	}  	Status ("Successfully found index of {0} references"' GetString.Count + GetBSTR.Count + GetStringW.Count);  	Status ("Decoding strings");  	for (int index = 0; index < ms_nSize; ++index)  		if (index != -1 && index <= 0xffff)  			Strings.Add (index' StringPoolDecode (index));  	Status ("Populating table");  	foreach (var s in Strings)  		MainForm.Invoke (() => MainForm.dataTable.Rows.Add (s.Key' s.Value' string.Empty));  	foreach (var a in GetString)  		MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetString")));  	foreach (var a in GetBSTR)  		MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetBSTR")));  	foreach (var a in GetStringW)  		MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetStringW")));  }  else if (StringDecodeMethod == 1)// StringDecoder   {  	MainForm.Invoke (() => MainForm.Text += " [StringDecoder]");  	int type = 0;  	int name = 0;  	int offset = 0;  	//search for CStringDecoder::DelayedLoad' which contains the resource type and name  	if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00'  		0x89'  		0x45'  		0xF4'  		0x6A'  		0xAA'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x8B'  		0x4D'  		0xF4'  		0x51'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 12;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 1;  		name = reader.ReadInt32 ();  	}  	else if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00'  		0x6A'  		0xAA'  		0x8B'  		0xF8'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x57'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 9;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 3;  		name = reader.ReadInt32 ();  	}  	else if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0xAA'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 1;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 1;  		name = reader.ReadInt32 ();  	}  	else  		throw new Exception ("Failed to determine type and name of resource.");  	//search for start of function CStringDecoder::DelayedLoad()  	reader.BaseStream.Position -= 50;  	// should be enough  	FindAoBInFile (reader' (int)reader.BaseStream.Position' new byte[] {  		0x55'  		0x8B'  		0xEC'  		0x83'  		0xEC'  		0x10  	});  	int offset_CStringDecoder__DelayedLoad = (int)reader.BaseStream.Position;  	for (reader.BaseStream.Position = 0; reader.BaseStream.Position < reader.BaseStream.Length;) {  		if (reader.ReadByte () != 0xE8)  			// call  			continue;  		int offse = reader.ReadInt32 ();  		if (reader.BaseStream.Position + offse == offset_CStringDecoder__DelayedLoad) {  			Status ("{0:X8} reference to offset_CStringDecoder__DelayedLoad = {1:X8}"' reader.BaseStream.Position - 5' offse);  			break;  		}  	}  	ImageResourceDirectory tier1 = (ImageResourceDirectory)root.GetEntry (type).Entry;  	ImageResourceDirectory tier2 = (ImageResourceDirectory)tier1.GetEntry (name).Entry;  	rsrcStringDataEntry = (ImageResourceDataEntry)tier2.Entrys [0].Entry;  	rsrcStringDataPosition = rsrcPointerToRawData + (rsrcStringDataEntry.OffsetToData - rsrcVirtualAddress);  	m_nCount = GetWordFromIndex (0);  	Status ("Amount of strings: {0}"' m_nCount);  	for (int i = 1; i < m_nCount; ++i)  		MainForm.Invoke (() => MainForm.dataTable.Rows.Add (i' StringDecoderDecode (i)' string.Format ("{0:X8}"' rsrcStringDataPosition + i * 4)));  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: Buffer.BlockCopy (BitConverter.GetBytes (ImageBase + offset_StringPool__ms_aKey)' 0' bytes' 1' 4);  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: while (true) {  	byte[] asdf = reader.ReadBytes (5);  	if (asdf [4] == 0xc3)// retn  	 {  		bool die = true;  		foreach (byte b in asdf)  			if (b == 0xe8)// call  			 {  				die = false;  				break;  			}  		if (die)  			break;  	}  	reader.BaseStream.Position -= 6;  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: while (true) {  	byte[] asdf = reader.ReadBytes (5);  	if (asdf [4] == 0xc3)// retn  	 {  		bool die = true;  		foreach (byte b in asdf)  			if (b == 0xe8)// call  			 {  				die = false;  				break;  			}  		if (die)  			break;  	}  	reader.BaseStream.Position -= 6;  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: while (true) {  	byte[] asdf = reader.ReadBytes (5);  	if (asdf [4] == 0xc3)// retn  	 {  		bool die = true;  		foreach (byte b in asdf)  			if (b == 0xe8)// call  			 {  				die = false;  				break;  			}  		if (die)  			break;  	}  	reader.BaseStream.Position -= 6;  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: if (asdf [4] == 0xc3)// retn   {  	bool die = true;  	foreach (byte b in asdf)  		if (b == 0xe8)// call  		 {  			die = false;  			break;  		}  	if (die)  		break;  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: reader.BaseStream.Position -= 6;  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: if (FindAoBInFile (reader' keyRef - 100' new byte[] {  	0x8b'  	0x0c  }' 100))  	reader.BaseStream.Position += 3;  else if (FindAoBInFile (reader' keyRef - 100' new byte[] {  	0x8b'  	0x86  }' 100))  	reader.BaseStream.Position += 2;  else  	throw new Exception ("could not find start of StringPool::offset_ms_aString");  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: if (FindAoBInFile (reader' keyRef - 100' new byte[] {  	0x8b'  	0x0c  }' 100))  	reader.BaseStream.Position += 3;  else if (FindAoBInFile (reader' keyRef - 100' new byte[] {  	0x8b'  	0x86  }' 100))  	reader.BaseStream.Position += 2;  else  	throw new Exception ("could not find start of StringPool::offset_ms_aString");  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: if (FindAoBInFile (reader' keyRef - 100' new byte[] {  	0x8b'  	0x0c  }' 100))  	reader.BaseStream.Position += 3;  else if (FindAoBInFile (reader' keyRef - 100' new byte[] {  	0x8b'  	0x86  }' 100))  	reader.BaseStream.Position += 2;  else  	throw new Exception ("could not find start of StringPool::offset_ms_aString");  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: if (FindAoBInFile (reader' keyRef - 100' new byte[] {  	0x8b'  	0x0c  }' 100))  	reader.BaseStream.Position += 3;  else if (FindAoBInFile (reader' keyRef - 100' new byte[] {  	0x8b'  	0x86  }' 100))  	reader.BaseStream.Position += 2;  else  	throw new Exception ("could not find start of StringPool::offset_ms_aString");  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: if (FindAoBInFile (reader' keyRef - 100' new byte[] {  	0x8b'  	0x0c  }' 100))  	reader.BaseStream.Position += 3;  else if (FindAoBInFile (reader' keyRef - 100' new byte[] {  	0x8b'  	0x86  }' 100))  	reader.BaseStream.Position += 2;  else  	throw new Exception ("could not find start of StringPool::offset_ms_aString");  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: if (FindAoBInFile (reader' keyRef - 100' new byte[] {  	0x8b'  	0x0c  }' 100))  	reader.BaseStream.Position += 3;  else if (FindAoBInFile (reader' keyRef - 100' new byte[] {  	0x8b'  	0x86  }' 100))  	reader.BaseStream.Position += 2;  else  	throw new Exception ("could not find start of StringPool::offset_ms_aString");  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: reader.BaseStream.Position += 3;  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: if (FindAoBInFile (reader' keyRef - 100' new byte[] {  	0x8b'  	0x86  }' 100))  	reader.BaseStream.Position += 2;  else  	throw new Exception ("could not find start of StringPool::offset_ms_aString");  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: if (FindAoBInFile (reader' keyRef - 100' new byte[] {  	0x8b'  	0x86  }' 100))  	reader.BaseStream.Position += 2;  else  	throw new Exception ("could not find start of StringPool::offset_ms_aString");  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: if (FindAoBInFile (reader' keyRef - 100' new byte[] {  	0x8b'  	0x86  }' 100))  	reader.BaseStream.Position += 2;  else  	throw new Exception ("could not find start of StringPool::offset_ms_aString");  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: reader.BaseStream.Position += 2;  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: if (xref.Length != 2)  	throw new Exception ("failed to find references to StringPool::GetString(uint' char)");  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: if (!FindAoBInFile (reader' xref [0] - 50' new byte[] {  	0x51'  	0x8b  }' 50) && !FindAoBInFile (reader' xref [0] - 50' new byte[] {  	0x55'  	0x8b  }' 50))  	throw new Exception ("could not find start of GetString(uint)");  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: if (!FindAoBInFile (reader' xref [0] - 50' new byte[] {  	0x51'  	0x8b  }' 50) && !FindAoBInFile (reader' xref [0] - 50' new byte[] {  	0x55'  	0x8b  }' 50))  	throw new Exception ("could not find start of GetString(uint)");  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: if (!FindAoBInFile (reader' xref [0] - 50' new byte[] {  	0x51'  	0x8b  }' 50) && !FindAoBInFile (reader' xref [0] - 50' new byte[] {  	0x55'  	0x8b  }' 50))  	throw new Exception ("could not find start of GetString(uint)");  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: if (!FindAoBInFile (reader' xref [0] - 50' new byte[] {  	0x51'  	0x8b  }' 50) && !FindAoBInFile (reader' xref [0] - 50' new byte[] {  	0x55'  	0x8b  }' 50))  	throw new Exception ("could not find start of GetString(uint)");  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: for (reader.BaseStream.Position = xref [1]; (reader.ReadUInt32 () & 0xffffff00) != 0x000cc200; reader.BaseStream.Position -= 5)  	;  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: reader.BaseStream.Position -= 5
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: reader.BaseStream.Position -= 100;  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: if (!FindAoBInFile (reader' (int)reader.BaseStream.Position' new byte[] {  	0xb8'  	0xaa'  	0xaa'  	0xaa'  	0x00  }))  	for (reader.BaseStream.Position = xref [0]; (reader.ReadUInt32 () & 0xff00ff00) != 0x0000c200; reader.BaseStream.Position -= 5)  		;  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: for (reader.BaseStream.Position = xref [0]; (reader.ReadUInt32 () & 0xff00ff00) != 0x0000c200; reader.BaseStream.Position -= 5)  	;  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: reader.BaseStream.Position -= 5
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: if (!FindAoBInFile (reader' xref [0] - 50' new byte[] {  	0x51'  	0x8b  }' 50) && !FindAoBInFile (reader' xref [0] - 50' new byte[] {  	0x55'  	0x8b  }' 50))  	throw new Exception ("could not find start of GetStringW(uint)");  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: if (!FindAoBInFile (reader' xref [0] - 50' new byte[] {  	0x51'  	0x8b  }' 50) && !FindAoBInFile (reader' xref [0] - 50' new byte[] {  	0x55'  	0x8b  }' 50))  	throw new Exception ("could not find start of GetStringW(uint)");  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: if (!FindAoBInFile (reader' xref [0] - 50' new byte[] {  	0x51'  	0x8b  }' 50) && !FindAoBInFile (reader' xref [0] - 50' new byte[] {  	0x55'  	0x8b  }' 50))  	throw new Exception ("could not find start of GetStringW(uint)");  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: if (!FindAoBInFile (reader' xref [0] - 50' new byte[] {  	0x51'  	0x8b  }' 50) && !FindAoBInFile (reader' xref [0] - 50' new byte[] {  	0x55'  	0x8b  }' 50))  	throw new Exception ("could not find start of GetStringW(uint)");  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: ms_nSize = GetIntFromOffset (offset_StringPool__ms_aKey + 16 + 4);  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: ms_nSize = GetIntFromOffset (offset_StringPool__ms_aKey + 16 + 4);  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: if (MessageBox.Show ("Scan for references to strings in the client? This can take a while."' "Warning"' MessageBoxButtons.YesNo' MessageBoxIcon.Warning) == DialogResult.Yes) {  	Status ("Searching for references to GetString' GetStringW' and GetBSTR");  	List<int> GetStringCalls = new List<int> ();  	List<int> GetStringWCalls = new List<int> ();  	List<int> GetBSTRCalls = new List<int> ();  	for (reader.BaseStream.Position = 0; reader.BaseStream.Position < reader.BaseStream.Length;) {  		//int lol = (int)((float)reader.BaseStream.Position / reader.BaseStream.Length * 100);  		//if (lol > MainForm.toolStripProgressBar1.Value)  		//{  		//    MainForm.Invoke(() => MainForm.toolStripProgressBar1.Value = lol);  		//    MainForm.Invoke(() => MainForm.Update());  		//} too expensive  		if (reader.ReadByte () != 0xE8)  			// call  			continue;  		int offset = reader.ReadInt32 ();  		if (reader.BaseStream.Position + offset == offset_StringPool__GetString_uint)  			GetStringCalls.Add ((int)reader.BaseStream.Position - 5);  		else if (reader.BaseStream.Position + offset == offset_StringPool__GetStringW_uint)  			GetStringWCalls.Add ((int)reader.BaseStream.Position - 5);  		else if (reader.BaseStream.Position + offset == offset_StringPool__GetBSTR_uint)  			GetBSTRCalls.Add ((int)reader.BaseStream.Position - 5);  		else  			reader.BaseStream.Position -= 4;  	}  	List<int> GetStringFail = new List<int> ();  	foreach (int addr in GetStringCalls) {  		reader.BaseStream.Position = addr;  		reader.BaseStream.Position -= 2;  		if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  		 {  			GetStringFail.Add (addr);  			continue;  		}  		reader.BaseStream.Position -= 7;  		if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  		 {  			GetStringFail.Add (addr);  			continue;  		}  		reader.BaseStream.Position -= 2;  		if (reader.ReadByte () != 0x50)// push eax  		 {  			GetStringFail.Add (addr);  			continue;  		}  		reader.BaseStream.Position -= 6;  		if (reader.ReadByte () != 0x68)// push dword  		 {  			GetStringFail.Add (addr);  			continue;  		}  		int idx = reader.ReadInt32 ();  		if (idx > ms_nSize - 1)  			GetStringFail.Add (addr);  		else  			GetString.Add (addr' idx);  	}  	List<int> GetStringWFail = new List<int> ();  	foreach (int addr in GetStringWCalls) {  		reader.BaseStream.Position = addr;  		reader.BaseStream.Position -= 2;  		if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  		 {  			GetStringWFail.Add (addr);  			continue;  		}  		reader.BaseStream.Position -= 7;  		if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  		 {  			GetStringWFail.Add (addr);  			continue;  		}  		reader.BaseStream.Position -= 2;  		if (reader.ReadByte () != 0x50)// push eax  		 {  			GetStringWFail.Add (addr);  			continue;  		}  		reader.BaseStream.Position -= 6;  		if (reader.ReadByte () != 0x68)// push dword  		 {  			GetStringWFail.Add (addr);  			continue;  		}  		int idx = reader.ReadInt32 ();  		if (idx > ms_nSize - 1)  			GetStringWFail.Add (addr);  		else  			GetStringW.Add (addr' idx);  	}  	List<int> GetBSTRFail = new List<int> ();  	foreach (int addr in GetBSTRCalls) {  		reader.BaseStream.Position = addr;  		reader.BaseStream.Position -= 2;  		if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  		 {  			GetBSTRFail.Add (addr);  			continue;  		}  		reader.BaseStream.Position -= 7;  		if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  		 {  			GetBSTRFail.Add (addr);  			continue;  		}  		reader.BaseStream.Position -= 2;  		if (reader.ReadByte () != 0x50)// push eax  		 {  			GetBSTRFail.Add (addr);  			continue;  		}  		reader.BaseStream.Position -= 6;  		if (reader.ReadByte () != 0x68)// push dword  		 {  			GetBSTRFail.Add (addr);  			continue;  		}  		int idx = reader.ReadInt32 ();  		if (idx > ms_nSize - 1)  			GetBSTRFail.Add (addr);  		else  			GetBSTR.Add (addr' idx);  	}  	Status ("Failed to find index of {0} references"' GetStringFail.Count + GetStringWFail.Count + GetBSTRFail.Count);  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: if (MessageBox.Show ("Scan for references to strings in the client? This can take a while."' "Warning"' MessageBoxButtons.YesNo' MessageBoxIcon.Warning) == DialogResult.Yes) {  	Status ("Searching for references to GetString' GetStringW' and GetBSTR");  	List<int> GetStringCalls = new List<int> ();  	List<int> GetStringWCalls = new List<int> ();  	List<int> GetBSTRCalls = new List<int> ();  	for (reader.BaseStream.Position = 0; reader.BaseStream.Position < reader.BaseStream.Length;) {  		//int lol = (int)((float)reader.BaseStream.Position / reader.BaseStream.Length * 100);  		//if (lol > MainForm.toolStripProgressBar1.Value)  		//{  		//    MainForm.Invoke(() => MainForm.toolStripProgressBar1.Value = lol);  		//    MainForm.Invoke(() => MainForm.Update());  		//} too expensive  		if (reader.ReadByte () != 0xE8)  			// call  			continue;  		int offset = reader.ReadInt32 ();  		if (reader.BaseStream.Position + offset == offset_StringPool__GetString_uint)  			GetStringCalls.Add ((int)reader.BaseStream.Position - 5);  		else if (reader.BaseStream.Position + offset == offset_StringPool__GetStringW_uint)  			GetStringWCalls.Add ((int)reader.BaseStream.Position - 5);  		else if (reader.BaseStream.Position + offset == offset_StringPool__GetBSTR_uint)  			GetBSTRCalls.Add ((int)reader.BaseStream.Position - 5);  		else  			reader.BaseStream.Position -= 4;  	}  	List<int> GetStringFail = new List<int> ();  	foreach (int addr in GetStringCalls) {  		reader.BaseStream.Position = addr;  		reader.BaseStream.Position -= 2;  		if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  		 {  			GetStringFail.Add (addr);  			continue;  		}  		reader.BaseStream.Position -= 7;  		if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  		 {  			GetStringFail.Add (addr);  			continue;  		}  		reader.BaseStream.Position -= 2;  		if (reader.ReadByte () != 0x50)// push eax  		 {  			GetStringFail.Add (addr);  			continue;  		}  		reader.BaseStream.Position -= 6;  		if (reader.ReadByte () != 0x68)// push dword  		 {  			GetStringFail.Add (addr);  			continue;  		}  		int idx = reader.ReadInt32 ();  		if (idx > ms_nSize - 1)  			GetStringFail.Add (addr);  		else  			GetString.Add (addr' idx);  	}  	List<int> GetStringWFail = new List<int> ();  	foreach (int addr in GetStringWCalls) {  		reader.BaseStream.Position = addr;  		reader.BaseStream.Position -= 2;  		if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  		 {  			GetStringWFail.Add (addr);  			continue;  		}  		reader.BaseStream.Position -= 7;  		if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  		 {  			GetStringWFail.Add (addr);  			continue;  		}  		reader.BaseStream.Position -= 2;  		if (reader.ReadByte () != 0x50)// push eax  		 {  			GetStringWFail.Add (addr);  			continue;  		}  		reader.BaseStream.Position -= 6;  		if (reader.ReadByte () != 0x68)// push dword  		 {  			GetStringWFail.Add (addr);  			continue;  		}  		int idx = reader.ReadInt32 ();  		if (idx > ms_nSize - 1)  			GetStringWFail.Add (addr);  		else  			GetStringW.Add (addr' idx);  	}  	List<int> GetBSTRFail = new List<int> ();  	foreach (int addr in GetBSTRCalls) {  		reader.BaseStream.Position = addr;  		reader.BaseStream.Position -= 2;  		if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  		 {  			GetBSTRFail.Add (addr);  			continue;  		}  		reader.BaseStream.Position -= 7;  		if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  		 {  			GetBSTRFail.Add (addr);  			continue;  		}  		reader.BaseStream.Position -= 2;  		if (reader.ReadByte () != 0x50)// push eax  		 {  			GetBSTRFail.Add (addr);  			continue;  		}  		reader.BaseStream.Position -= 6;  		if (reader.ReadByte () != 0x68)// push dword  		 {  			GetBSTRFail.Add (addr);  			continue;  		}  		int idx = reader.ReadInt32 ();  		if (idx > ms_nSize - 1)  			GetBSTRFail.Add (addr);  		else  			GetBSTR.Add (addr' idx);  	}  	Status ("Failed to find index of {0} references"' GetStringFail.Count + GetStringWFail.Count + GetBSTRFail.Count);  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: if (MessageBox.Show ("Scan for references to strings in the client? This can take a while."' "Warning"' MessageBoxButtons.YesNo' MessageBoxIcon.Warning) == DialogResult.Yes) {  	Status ("Searching for references to GetString' GetStringW' and GetBSTR");  	List<int> GetStringCalls = new List<int> ();  	List<int> GetStringWCalls = new List<int> ();  	List<int> GetBSTRCalls = new List<int> ();  	for (reader.BaseStream.Position = 0; reader.BaseStream.Position < reader.BaseStream.Length;) {  		//int lol = (int)((float)reader.BaseStream.Position / reader.BaseStream.Length * 100);  		//if (lol > MainForm.toolStripProgressBar1.Value)  		//{  		//    MainForm.Invoke(() => MainForm.toolStripProgressBar1.Value = lol);  		//    MainForm.Invoke(() => MainForm.Update());  		//} too expensive  		if (reader.ReadByte () != 0xE8)  			// call  			continue;  		int offset = reader.ReadInt32 ();  		if (reader.BaseStream.Position + offset == offset_StringPool__GetString_uint)  			GetStringCalls.Add ((int)reader.BaseStream.Position - 5);  		else if (reader.BaseStream.Position + offset == offset_StringPool__GetStringW_uint)  			GetStringWCalls.Add ((int)reader.BaseStream.Position - 5);  		else if (reader.BaseStream.Position + offset == offset_StringPool__GetBSTR_uint)  			GetBSTRCalls.Add ((int)reader.BaseStream.Position - 5);  		else  			reader.BaseStream.Position -= 4;  	}  	List<int> GetStringFail = new List<int> ();  	foreach (int addr in GetStringCalls) {  		reader.BaseStream.Position = addr;  		reader.BaseStream.Position -= 2;  		if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  		 {  			GetStringFail.Add (addr);  			continue;  		}  		reader.BaseStream.Position -= 7;  		if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  		 {  			GetStringFail.Add (addr);  			continue;  		}  		reader.BaseStream.Position -= 2;  		if (reader.ReadByte () != 0x50)// push eax  		 {  			GetStringFail.Add (addr);  			continue;  		}  		reader.BaseStream.Position -= 6;  		if (reader.ReadByte () != 0x68)// push dword  		 {  			GetStringFail.Add (addr);  			continue;  		}  		int idx = reader.ReadInt32 ();  		if (idx > ms_nSize - 1)  			GetStringFail.Add (addr);  		else  			GetString.Add (addr' idx);  	}  	List<int> GetStringWFail = new List<int> ();  	foreach (int addr in GetStringWCalls) {  		reader.BaseStream.Position = addr;  		reader.BaseStream.Position -= 2;  		if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  		 {  			GetStringWFail.Add (addr);  			continue;  		}  		reader.BaseStream.Position -= 7;  		if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  		 {  			GetStringWFail.Add (addr);  			continue;  		}  		reader.BaseStream.Position -= 2;  		if (reader.ReadByte () != 0x50)// push eax  		 {  			GetStringWFail.Add (addr);  			continue;  		}  		reader.BaseStream.Position -= 6;  		if (reader.ReadByte () != 0x68)// push dword  		 {  			GetStringWFail.Add (addr);  			continue;  		}  		int idx = reader.ReadInt32 ();  		if (idx > ms_nSize - 1)  			GetStringWFail.Add (addr);  		else  			GetStringW.Add (addr' idx);  	}  	List<int> GetBSTRFail = new List<int> ();  	foreach (int addr in GetBSTRCalls) {  		reader.BaseStream.Position = addr;  		reader.BaseStream.Position -= 2;  		if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  		 {  			GetBSTRFail.Add (addr);  			continue;  		}  		reader.BaseStream.Position -= 7;  		if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  		 {  			GetBSTRFail.Add (addr);  			continue;  		}  		reader.BaseStream.Position -= 2;  		if (reader.ReadByte () != 0x50)// push eax  		 {  			GetBSTRFail.Add (addr);  			continue;  		}  		reader.BaseStream.Position -= 6;  		if (reader.ReadByte () != 0x68)// push dword  		 {  			GetBSTRFail.Add (addr);  			continue;  		}  		int idx = reader.ReadInt32 ();  		if (idx > ms_nSize - 1)  			GetBSTRFail.Add (addr);  		else  			GetBSTR.Add (addr' idx);  	}  	Status ("Failed to find index of {0} references"' GetStringFail.Count + GetStringWFail.Count + GetBSTRFail.Count);  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: if (MessageBox.Show ("Scan for references to strings in the client? This can take a while."' "Warning"' MessageBoxButtons.YesNo' MessageBoxIcon.Warning) == DialogResult.Yes) {  	Status ("Searching for references to GetString' GetStringW' and GetBSTR");  	List<int> GetStringCalls = new List<int> ();  	List<int> GetStringWCalls = new List<int> ();  	List<int> GetBSTRCalls = new List<int> ();  	for (reader.BaseStream.Position = 0; reader.BaseStream.Position < reader.BaseStream.Length;) {  		//int lol = (int)((float)reader.BaseStream.Position / reader.BaseStream.Length * 100);  		//if (lol > MainForm.toolStripProgressBar1.Value)  		//{  		//    MainForm.Invoke(() => MainForm.toolStripProgressBar1.Value = lol);  		//    MainForm.Invoke(() => MainForm.Update());  		//} too expensive  		if (reader.ReadByte () != 0xE8)  			// call  			continue;  		int offset = reader.ReadInt32 ();  		if (reader.BaseStream.Position + offset == offset_StringPool__GetString_uint)  			GetStringCalls.Add ((int)reader.BaseStream.Position - 5);  		else if (reader.BaseStream.Position + offset == offset_StringPool__GetStringW_uint)  			GetStringWCalls.Add ((int)reader.BaseStream.Position - 5);  		else if (reader.BaseStream.Position + offset == offset_StringPool__GetBSTR_uint)  			GetBSTRCalls.Add ((int)reader.BaseStream.Position - 5);  		else  			reader.BaseStream.Position -= 4;  	}  	List<int> GetStringFail = new List<int> ();  	foreach (int addr in GetStringCalls) {  		reader.BaseStream.Position = addr;  		reader.BaseStream.Position -= 2;  		if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  		 {  			GetStringFail.Add (addr);  			continue;  		}  		reader.BaseStream.Position -= 7;  		if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  		 {  			GetStringFail.Add (addr);  			continue;  		}  		reader.BaseStream.Position -= 2;  		if (reader.ReadByte () != 0x50)// push eax  		 {  			GetStringFail.Add (addr);  			continue;  		}  		reader.BaseStream.Position -= 6;  		if (reader.ReadByte () != 0x68)// push dword  		 {  			GetStringFail.Add (addr);  			continue;  		}  		int idx = reader.ReadInt32 ();  		if (idx > ms_nSize - 1)  			GetStringFail.Add (addr);  		else  			GetString.Add (addr' idx);  	}  	List<int> GetStringWFail = new List<int> ();  	foreach (int addr in GetStringWCalls) {  		reader.BaseStream.Position = addr;  		reader.BaseStream.Position -= 2;  		if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  		 {  			GetStringWFail.Add (addr);  			continue;  		}  		reader.BaseStream.Position -= 7;  		if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  		 {  			GetStringWFail.Add (addr);  			continue;  		}  		reader.BaseStream.Position -= 2;  		if (reader.ReadByte () != 0x50)// push eax  		 {  			GetStringWFail.Add (addr);  			continue;  		}  		reader.BaseStream.Position -= 6;  		if (reader.ReadByte () != 0x68)// push dword  		 {  			GetStringWFail.Add (addr);  			continue;  		}  		int idx = reader.ReadInt32 ();  		if (idx > ms_nSize - 1)  			GetStringWFail.Add (addr);  		else  			GetStringW.Add (addr' idx);  	}  	List<int> GetBSTRFail = new List<int> ();  	foreach (int addr in GetBSTRCalls) {  		reader.BaseStream.Position = addr;  		reader.BaseStream.Position -= 2;  		if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  		 {  			GetBSTRFail.Add (addr);  			continue;  		}  		reader.BaseStream.Position -= 7;  		if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  		 {  			GetBSTRFail.Add (addr);  			continue;  		}  		reader.BaseStream.Position -= 2;  		if (reader.ReadByte () != 0x50)// push eax  		 {  			GetBSTRFail.Add (addr);  			continue;  		}  		reader.BaseStream.Position -= 6;  		if (reader.ReadByte () != 0x68)// push dword  		 {  			GetBSTRFail.Add (addr);  			continue;  		}  		int idx = reader.ReadInt32 ();  		if (idx > ms_nSize - 1)  			GetBSTRFail.Add (addr);  		else  			GetBSTR.Add (addr' idx);  	}  	Status ("Failed to find index of {0} references"' GetStringFail.Count + GetStringWFail.Count + GetBSTRFail.Count);  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: if (MessageBox.Show ("Scan for references to strings in the client? This can take a while."' "Warning"' MessageBoxButtons.YesNo' MessageBoxIcon.Warning) == DialogResult.Yes) {  	Status ("Searching for references to GetString' GetStringW' and GetBSTR");  	List<int> GetStringCalls = new List<int> ();  	List<int> GetStringWCalls = new List<int> ();  	List<int> GetBSTRCalls = new List<int> ();  	for (reader.BaseStream.Position = 0; reader.BaseStream.Position < reader.BaseStream.Length;) {  		//int lol = (int)((float)reader.BaseStream.Position / reader.BaseStream.Length * 100);  		//if (lol > MainForm.toolStripProgressBar1.Value)  		//{  		//    MainForm.Invoke(() => MainForm.toolStripProgressBar1.Value = lol);  		//    MainForm.Invoke(() => MainForm.Update());  		//} too expensive  		if (reader.ReadByte () != 0xE8)  			// call  			continue;  		int offset = reader.ReadInt32 ();  		if (reader.BaseStream.Position + offset == offset_StringPool__GetString_uint)  			GetStringCalls.Add ((int)reader.BaseStream.Position - 5);  		else if (reader.BaseStream.Position + offset == offset_StringPool__GetStringW_uint)  			GetStringWCalls.Add ((int)reader.BaseStream.Position - 5);  		else if (reader.BaseStream.Position + offset == offset_StringPool__GetBSTR_uint)  			GetBSTRCalls.Add ((int)reader.BaseStream.Position - 5);  		else  			reader.BaseStream.Position -= 4;  	}  	List<int> GetStringFail = new List<int> ();  	foreach (int addr in GetStringCalls) {  		reader.BaseStream.Position = addr;  		reader.BaseStream.Position -= 2;  		if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  		 {  			GetStringFail.Add (addr);  			continue;  		}  		reader.BaseStream.Position -= 7;  		if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  		 {  			GetStringFail.Add (addr);  			continue;  		}  		reader.BaseStream.Position -= 2;  		if (reader.ReadByte () != 0x50)// push eax  		 {  			GetStringFail.Add (addr);  			continue;  		}  		reader.BaseStream.Position -= 6;  		if (reader.ReadByte () != 0x68)// push dword  		 {  			GetStringFail.Add (addr);  			continue;  		}  		int idx = reader.ReadInt32 ();  		if (idx > ms_nSize - 1)  			GetStringFail.Add (addr);  		else  			GetString.Add (addr' idx);  	}  	List<int> GetStringWFail = new List<int> ();  	foreach (int addr in GetStringWCalls) {  		reader.BaseStream.Position = addr;  		reader.BaseStream.Position -= 2;  		if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  		 {  			GetStringWFail.Add (addr);  			continue;  		}  		reader.BaseStream.Position -= 7;  		if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  		 {  			GetStringWFail.Add (addr);  			continue;  		}  		reader.BaseStream.Position -= 2;  		if (reader.ReadByte () != 0x50)// push eax  		 {  			GetStringWFail.Add (addr);  			continue;  		}  		reader.BaseStream.Position -= 6;  		if (reader.ReadByte () != 0x68)// push dword  		 {  			GetStringWFail.Add (addr);  			continue;  		}  		int idx = reader.ReadInt32 ();  		if (idx > ms_nSize - 1)  			GetStringWFail.Add (addr);  		else  			GetStringW.Add (addr' idx);  	}  	List<int> GetBSTRFail = new List<int> ();  	foreach (int addr in GetBSTRCalls) {  		reader.BaseStream.Position = addr;  		reader.BaseStream.Position -= 2;  		if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  		 {  			GetBSTRFail.Add (addr);  			continue;  		}  		reader.BaseStream.Position -= 7;  		if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  		 {  			GetBSTRFail.Add (addr);  			continue;  		}  		reader.BaseStream.Position -= 2;  		if (reader.ReadByte () != 0x50)// push eax  		 {  			GetBSTRFail.Add (addr);  			continue;  		}  		reader.BaseStream.Position -= 6;  		if (reader.ReadByte () != 0x68)// push dword  		 {  			GetBSTRFail.Add (addr);  			continue;  		}  		int idx = reader.ReadInt32 ();  		if (idx > ms_nSize - 1)  			GetBSTRFail.Add (addr);  		else  			GetBSTR.Add (addr' idx);  	}  	Status ("Failed to find index of {0} references"' GetStringFail.Count + GetStringWFail.Count + GetBSTRFail.Count);  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: if (MessageBox.Show ("Scan for references to strings in the client? This can take a while."' "Warning"' MessageBoxButtons.YesNo' MessageBoxIcon.Warning) == DialogResult.Yes) {  	Status ("Searching for references to GetString' GetStringW' and GetBSTR");  	List<int> GetStringCalls = new List<int> ();  	List<int> GetStringWCalls = new List<int> ();  	List<int> GetBSTRCalls = new List<int> ();  	for (reader.BaseStream.Position = 0; reader.BaseStream.Position < reader.BaseStream.Length;) {  		//int lol = (int)((float)reader.BaseStream.Position / reader.BaseStream.Length * 100);  		//if (lol > MainForm.toolStripProgressBar1.Value)  		//{  		//    MainForm.Invoke(() => MainForm.toolStripProgressBar1.Value = lol);  		//    MainForm.Invoke(() => MainForm.Update());  		//} too expensive  		if (reader.ReadByte () != 0xE8)  			// call  			continue;  		int offset = reader.ReadInt32 ();  		if (reader.BaseStream.Position + offset == offset_StringPool__GetString_uint)  			GetStringCalls.Add ((int)reader.BaseStream.Position - 5);  		else if (reader.BaseStream.Position + offset == offset_StringPool__GetStringW_uint)  			GetStringWCalls.Add ((int)reader.BaseStream.Position - 5);  		else if (reader.BaseStream.Position + offset == offset_StringPool__GetBSTR_uint)  			GetBSTRCalls.Add ((int)reader.BaseStream.Position - 5);  		else  			reader.BaseStream.Position -= 4;  	}  	List<int> GetStringFail = new List<int> ();  	foreach (int addr in GetStringCalls) {  		reader.BaseStream.Position = addr;  		reader.BaseStream.Position -= 2;  		if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  		 {  			GetStringFail.Add (addr);  			continue;  		}  		reader.BaseStream.Position -= 7;  		if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  		 {  			GetStringFail.Add (addr);  			continue;  		}  		reader.BaseStream.Position -= 2;  		if (reader.ReadByte () != 0x50)// push eax  		 {  			GetStringFail.Add (addr);  			continue;  		}  		reader.BaseStream.Position -= 6;  		if (reader.ReadByte () != 0x68)// push dword  		 {  			GetStringFail.Add (addr);  			continue;  		}  		int idx = reader.ReadInt32 ();  		if (idx > ms_nSize - 1)  			GetStringFail.Add (addr);  		else  			GetString.Add (addr' idx);  	}  	List<int> GetStringWFail = new List<int> ();  	foreach (int addr in GetStringWCalls) {  		reader.BaseStream.Position = addr;  		reader.BaseStream.Position -= 2;  		if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  		 {  			GetStringWFail.Add (addr);  			continue;  		}  		reader.BaseStream.Position -= 7;  		if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  		 {  			GetStringWFail.Add (addr);  			continue;  		}  		reader.BaseStream.Position -= 2;  		if (reader.ReadByte () != 0x50)// push eax  		 {  			GetStringWFail.Add (addr);  			continue;  		}  		reader.BaseStream.Position -= 6;  		if (reader.ReadByte () != 0x68)// push dword  		 {  			GetStringWFail.Add (addr);  			continue;  		}  		int idx = reader.ReadInt32 ();  		if (idx > ms_nSize - 1)  			GetStringWFail.Add (addr);  		else  			GetStringW.Add (addr' idx);  	}  	List<int> GetBSTRFail = new List<int> ();  	foreach (int addr in GetBSTRCalls) {  		reader.BaseStream.Position = addr;  		reader.BaseStream.Position -= 2;  		if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  		 {  			GetBSTRFail.Add (addr);  			continue;  		}  		reader.BaseStream.Position -= 7;  		if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  		 {  			GetBSTRFail.Add (addr);  			continue;  		}  		reader.BaseStream.Position -= 2;  		if (reader.ReadByte () != 0x50)// push eax  		 {  			GetBSTRFail.Add (addr);  			continue;  		}  		reader.BaseStream.Position -= 6;  		if (reader.ReadByte () != 0x68)// push dword  		 {  			GetBSTRFail.Add (addr);  			continue;  		}  		int idx = reader.ReadInt32 ();  		if (idx > ms_nSize - 1)  			GetBSTRFail.Add (addr);  		else  			GetBSTR.Add (addr' idx);  	}  	Status ("Failed to find index of {0} references"' GetStringFail.Count + GetStringWFail.Count + GetBSTRFail.Count);  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: if (MessageBox.Show ("Scan for references to strings in the client? This can take a while."' "Warning"' MessageBoxButtons.YesNo' MessageBoxIcon.Warning) == DialogResult.Yes) {  	Status ("Searching for references to GetString' GetStringW' and GetBSTR");  	List<int> GetStringCalls = new List<int> ();  	List<int> GetStringWCalls = new List<int> ();  	List<int> GetBSTRCalls = new List<int> ();  	for (reader.BaseStream.Position = 0; reader.BaseStream.Position < reader.BaseStream.Length;) {  		//int lol = (int)((float)reader.BaseStream.Position / reader.BaseStream.Length * 100);  		//if (lol > MainForm.toolStripProgressBar1.Value)  		//{  		//    MainForm.Invoke(() => MainForm.toolStripProgressBar1.Value = lol);  		//    MainForm.Invoke(() => MainForm.Update());  		//} too expensive  		if (reader.ReadByte () != 0xE8)  			// call  			continue;  		int offset = reader.ReadInt32 ();  		if (reader.BaseStream.Position + offset == offset_StringPool__GetString_uint)  			GetStringCalls.Add ((int)reader.BaseStream.Position - 5);  		else if (reader.BaseStream.Position + offset == offset_StringPool__GetStringW_uint)  			GetStringWCalls.Add ((int)reader.BaseStream.Position - 5);  		else if (reader.BaseStream.Position + offset == offset_StringPool__GetBSTR_uint)  			GetBSTRCalls.Add ((int)reader.BaseStream.Position - 5);  		else  			reader.BaseStream.Position -= 4;  	}  	List<int> GetStringFail = new List<int> ();  	foreach (int addr in GetStringCalls) {  		reader.BaseStream.Position = addr;  		reader.BaseStream.Position -= 2;  		if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  		 {  			GetStringFail.Add (addr);  			continue;  		}  		reader.BaseStream.Position -= 7;  		if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  		 {  			GetStringFail.Add (addr);  			continue;  		}  		reader.BaseStream.Position -= 2;  		if (reader.ReadByte () != 0x50)// push eax  		 {  			GetStringFail.Add (addr);  			continue;  		}  		reader.BaseStream.Position -= 6;  		if (reader.ReadByte () != 0x68)// push dword  		 {  			GetStringFail.Add (addr);  			continue;  		}  		int idx = reader.ReadInt32 ();  		if (idx > ms_nSize - 1)  			GetStringFail.Add (addr);  		else  			GetString.Add (addr' idx);  	}  	List<int> GetStringWFail = new List<int> ();  	foreach (int addr in GetStringWCalls) {  		reader.BaseStream.Position = addr;  		reader.BaseStream.Position -= 2;  		if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  		 {  			GetStringWFail.Add (addr);  			continue;  		}  		reader.BaseStream.Position -= 7;  		if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  		 {  			GetStringWFail.Add (addr);  			continue;  		}  		reader.BaseStream.Position -= 2;  		if (reader.ReadByte () != 0x50)// push eax  		 {  			GetStringWFail.Add (addr);  			continue;  		}  		reader.BaseStream.Position -= 6;  		if (reader.ReadByte () != 0x68)// push dword  		 {  			GetStringWFail.Add (addr);  			continue;  		}  		int idx = reader.ReadInt32 ();  		if (idx > ms_nSize - 1)  			GetStringWFail.Add (addr);  		else  			GetStringW.Add (addr' idx);  	}  	List<int> GetBSTRFail = new List<int> ();  	foreach (int addr in GetBSTRCalls) {  		reader.BaseStream.Position = addr;  		reader.BaseStream.Position -= 2;  		if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  		 {  			GetBSTRFail.Add (addr);  			continue;  		}  		reader.BaseStream.Position -= 7;  		if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  		 {  			GetBSTRFail.Add (addr);  			continue;  		}  		reader.BaseStream.Position -= 2;  		if (reader.ReadByte () != 0x50)// push eax  		 {  			GetBSTRFail.Add (addr);  			continue;  		}  		reader.BaseStream.Position -= 6;  		if (reader.ReadByte () != 0x68)// push dword  		 {  			GetBSTRFail.Add (addr);  			continue;  		}  		int idx = reader.ReadInt32 ();  		if (idx > ms_nSize - 1)  			GetBSTRFail.Add (addr);  		else  			GetBSTR.Add (addr' idx);  	}  	Status ("Failed to find index of {0} references"' GetStringFail.Count + GetStringWFail.Count + GetBSTRFail.Count);  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: if (MessageBox.Show ("Scan for references to strings in the client? This can take a while."' "Warning"' MessageBoxButtons.YesNo' MessageBoxIcon.Warning) == DialogResult.Yes) {  	Status ("Searching for references to GetString' GetStringW' and GetBSTR");  	List<int> GetStringCalls = new List<int> ();  	List<int> GetStringWCalls = new List<int> ();  	List<int> GetBSTRCalls = new List<int> ();  	for (reader.BaseStream.Position = 0; reader.BaseStream.Position < reader.BaseStream.Length;) {  		//int lol = (int)((float)reader.BaseStream.Position / reader.BaseStream.Length * 100);  		//if (lol > MainForm.toolStripProgressBar1.Value)  		//{  		//    MainForm.Invoke(() => MainForm.toolStripProgressBar1.Value = lol);  		//    MainForm.Invoke(() => MainForm.Update());  		//} too expensive  		if (reader.ReadByte () != 0xE8)  			// call  			continue;  		int offset = reader.ReadInt32 ();  		if (reader.BaseStream.Position + offset == offset_StringPool__GetString_uint)  			GetStringCalls.Add ((int)reader.BaseStream.Position - 5);  		else if (reader.BaseStream.Position + offset == offset_StringPool__GetStringW_uint)  			GetStringWCalls.Add ((int)reader.BaseStream.Position - 5);  		else if (reader.BaseStream.Position + offset == offset_StringPool__GetBSTR_uint)  			GetBSTRCalls.Add ((int)reader.BaseStream.Position - 5);  		else  			reader.BaseStream.Position -= 4;  	}  	List<int> GetStringFail = new List<int> ();  	foreach (int addr in GetStringCalls) {  		reader.BaseStream.Position = addr;  		reader.BaseStream.Position -= 2;  		if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  		 {  			GetStringFail.Add (addr);  			continue;  		}  		reader.BaseStream.Position -= 7;  		if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  		 {  			GetStringFail.Add (addr);  			continue;  		}  		reader.BaseStream.Position -= 2;  		if (reader.ReadByte () != 0x50)// push eax  		 {  			GetStringFail.Add (addr);  			continue;  		}  		reader.BaseStream.Position -= 6;  		if (reader.ReadByte () != 0x68)// push dword  		 {  			GetStringFail.Add (addr);  			continue;  		}  		int idx = reader.ReadInt32 ();  		if (idx > ms_nSize - 1)  			GetStringFail.Add (addr);  		else  			GetString.Add (addr' idx);  	}  	List<int> GetStringWFail = new List<int> ();  	foreach (int addr in GetStringWCalls) {  		reader.BaseStream.Position = addr;  		reader.BaseStream.Position -= 2;  		if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  		 {  			GetStringWFail.Add (addr);  			continue;  		}  		reader.BaseStream.Position -= 7;  		if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  		 {  			GetStringWFail.Add (addr);  			continue;  		}  		reader.BaseStream.Position -= 2;  		if (reader.ReadByte () != 0x50)// push eax  		 {  			GetStringWFail.Add (addr);  			continue;  		}  		reader.BaseStream.Position -= 6;  		if (reader.ReadByte () != 0x68)// push dword  		 {  			GetStringWFail.Add (addr);  			continue;  		}  		int idx = reader.ReadInt32 ();  		if (idx > ms_nSize - 1)  			GetStringWFail.Add (addr);  		else  			GetStringW.Add (addr' idx);  	}  	List<int> GetBSTRFail = new List<int> ();  	foreach (int addr in GetBSTRCalls) {  		reader.BaseStream.Position = addr;  		reader.BaseStream.Position -= 2;  		if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  		 {  			GetBSTRFail.Add (addr);  			continue;  		}  		reader.BaseStream.Position -= 7;  		if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  		 {  			GetBSTRFail.Add (addr);  			continue;  		}  		reader.BaseStream.Position -= 2;  		if (reader.ReadByte () != 0x50)// push eax  		 {  			GetBSTRFail.Add (addr);  			continue;  		}  		reader.BaseStream.Position -= 6;  		if (reader.ReadByte () != 0x68)// push dword  		 {  			GetBSTRFail.Add (addr);  			continue;  		}  		int idx = reader.ReadInt32 ();  		if (idx > ms_nSize - 1)  			GetBSTRFail.Add (addr);  		else  			GetBSTR.Add (addr' idx);  	}  	Status ("Failed to find index of {0} references"' GetStringFail.Count + GetStringWFail.Count + GetBSTRFail.Count);  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: if (MessageBox.Show ("Scan for references to strings in the client? This can take a while."' "Warning"' MessageBoxButtons.YesNo' MessageBoxIcon.Warning) == DialogResult.Yes) {  	Status ("Searching for references to GetString' GetStringW' and GetBSTR");  	List<int> GetStringCalls = new List<int> ();  	List<int> GetStringWCalls = new List<int> ();  	List<int> GetBSTRCalls = new List<int> ();  	for (reader.BaseStream.Position = 0; reader.BaseStream.Position < reader.BaseStream.Length;) {  		//int lol = (int)((float)reader.BaseStream.Position / reader.BaseStream.Length * 100);  		//if (lol > MainForm.toolStripProgressBar1.Value)  		//{  		//    MainForm.Invoke(() => MainForm.toolStripProgressBar1.Value = lol);  		//    MainForm.Invoke(() => MainForm.Update());  		//} too expensive  		if (reader.ReadByte () != 0xE8)  			// call  			continue;  		int offset = reader.ReadInt32 ();  		if (reader.BaseStream.Position + offset == offset_StringPool__GetString_uint)  			GetStringCalls.Add ((int)reader.BaseStream.Position - 5);  		else if (reader.BaseStream.Position + offset == offset_StringPool__GetStringW_uint)  			GetStringWCalls.Add ((int)reader.BaseStream.Position - 5);  		else if (reader.BaseStream.Position + offset == offset_StringPool__GetBSTR_uint)  			GetBSTRCalls.Add ((int)reader.BaseStream.Position - 5);  		else  			reader.BaseStream.Position -= 4;  	}  	List<int> GetStringFail = new List<int> ();  	foreach (int addr in GetStringCalls) {  		reader.BaseStream.Position = addr;  		reader.BaseStream.Position -= 2;  		if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  		 {  			GetStringFail.Add (addr);  			continue;  		}  		reader.BaseStream.Position -= 7;  		if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  		 {  			GetStringFail.Add (addr);  			continue;  		}  		reader.BaseStream.Position -= 2;  		if (reader.ReadByte () != 0x50)// push eax  		 {  			GetStringFail.Add (addr);  			continue;  		}  		reader.BaseStream.Position -= 6;  		if (reader.ReadByte () != 0x68)// push dword  		 {  			GetStringFail.Add (addr);  			continue;  		}  		int idx = reader.ReadInt32 ();  		if (idx > ms_nSize - 1)  			GetStringFail.Add (addr);  		else  			GetString.Add (addr' idx);  	}  	List<int> GetStringWFail = new List<int> ();  	foreach (int addr in GetStringWCalls) {  		reader.BaseStream.Position = addr;  		reader.BaseStream.Position -= 2;  		if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  		 {  			GetStringWFail.Add (addr);  			continue;  		}  		reader.BaseStream.Position -= 7;  		if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  		 {  			GetStringWFail.Add (addr);  			continue;  		}  		reader.BaseStream.Position -= 2;  		if (reader.ReadByte () != 0x50)// push eax  		 {  			GetStringWFail.Add (addr);  			continue;  		}  		reader.BaseStream.Position -= 6;  		if (reader.ReadByte () != 0x68)// push dword  		 {  			GetStringWFail.Add (addr);  			continue;  		}  		int idx = reader.ReadInt32 ();  		if (idx > ms_nSize - 1)  			GetStringWFail.Add (addr);  		else  			GetStringW.Add (addr' idx);  	}  	List<int> GetBSTRFail = new List<int> ();  	foreach (int addr in GetBSTRCalls) {  		reader.BaseStream.Position = addr;  		reader.BaseStream.Position -= 2;  		if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  		 {  			GetBSTRFail.Add (addr);  			continue;  		}  		reader.BaseStream.Position -= 7;  		if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  		 {  			GetBSTRFail.Add (addr);  			continue;  		}  		reader.BaseStream.Position -= 2;  		if (reader.ReadByte () != 0x50)// push eax  		 {  			GetBSTRFail.Add (addr);  			continue;  		}  		reader.BaseStream.Position -= 6;  		if (reader.ReadByte () != 0x68)// push dword  		 {  			GetBSTRFail.Add (addr);  			continue;  		}  		int idx = reader.ReadInt32 ();  		if (idx > ms_nSize - 1)  			GetBSTRFail.Add (addr);  		else  			GetBSTR.Add (addr' idx);  	}  	Status ("Failed to find index of {0} references"' GetStringFail.Count + GetStringWFail.Count + GetBSTRFail.Count);  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: if (MessageBox.Show ("Scan for references to strings in the client? This can take a while."' "Warning"' MessageBoxButtons.YesNo' MessageBoxIcon.Warning) == DialogResult.Yes) {  	Status ("Searching for references to GetString' GetStringW' and GetBSTR");  	List<int> GetStringCalls = new List<int> ();  	List<int> GetStringWCalls = new List<int> ();  	List<int> GetBSTRCalls = new List<int> ();  	for (reader.BaseStream.Position = 0; reader.BaseStream.Position < reader.BaseStream.Length;) {  		//int lol = (int)((float)reader.BaseStream.Position / reader.BaseStream.Length * 100);  		//if (lol > MainForm.toolStripProgressBar1.Value)  		//{  		//    MainForm.Invoke(() => MainForm.toolStripProgressBar1.Value = lol);  		//    MainForm.Invoke(() => MainForm.Update());  		//} too expensive  		if (reader.ReadByte () != 0xE8)  			// call  			continue;  		int offset = reader.ReadInt32 ();  		if (reader.BaseStream.Position + offset == offset_StringPool__GetString_uint)  			GetStringCalls.Add ((int)reader.BaseStream.Position - 5);  		else if (reader.BaseStream.Position + offset == offset_StringPool__GetStringW_uint)  			GetStringWCalls.Add ((int)reader.BaseStream.Position - 5);  		else if (reader.BaseStream.Position + offset == offset_StringPool__GetBSTR_uint)  			GetBSTRCalls.Add ((int)reader.BaseStream.Position - 5);  		else  			reader.BaseStream.Position -= 4;  	}  	List<int> GetStringFail = new List<int> ();  	foreach (int addr in GetStringCalls) {  		reader.BaseStream.Position = addr;  		reader.BaseStream.Position -= 2;  		if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  		 {  			GetStringFail.Add (addr);  			continue;  		}  		reader.BaseStream.Position -= 7;  		if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  		 {  			GetStringFail.Add (addr);  			continue;  		}  		reader.BaseStream.Position -= 2;  		if (reader.ReadByte () != 0x50)// push eax  		 {  			GetStringFail.Add (addr);  			continue;  		}  		reader.BaseStream.Position -= 6;  		if (reader.ReadByte () != 0x68)// push dword  		 {  			GetStringFail.Add (addr);  			continue;  		}  		int idx = reader.ReadInt32 ();  		if (idx > ms_nSize - 1)  			GetStringFail.Add (addr);  		else  			GetString.Add (addr' idx);  	}  	List<int> GetStringWFail = new List<int> ();  	foreach (int addr in GetStringWCalls) {  		reader.BaseStream.Position = addr;  		reader.BaseStream.Position -= 2;  		if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  		 {  			GetStringWFail.Add (addr);  			continue;  		}  		reader.BaseStream.Position -= 7;  		if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  		 {  			GetStringWFail.Add (addr);  			continue;  		}  		reader.BaseStream.Position -= 2;  		if (reader.ReadByte () != 0x50)// push eax  		 {  			GetStringWFail.Add (addr);  			continue;  		}  		reader.BaseStream.Position -= 6;  		if (reader.ReadByte () != 0x68)// push dword  		 {  			GetStringWFail.Add (addr);  			continue;  		}  		int idx = reader.ReadInt32 ();  		if (idx > ms_nSize - 1)  			GetStringWFail.Add (addr);  		else  			GetStringW.Add (addr' idx);  	}  	List<int> GetBSTRFail = new List<int> ();  	foreach (int addr in GetBSTRCalls) {  		reader.BaseStream.Position = addr;  		reader.BaseStream.Position -= 2;  		if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  		 {  			GetBSTRFail.Add (addr);  			continue;  		}  		reader.BaseStream.Position -= 7;  		if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  		 {  			GetBSTRFail.Add (addr);  			continue;  		}  		reader.BaseStream.Position -= 2;  		if (reader.ReadByte () != 0x50)// push eax  		 {  			GetBSTRFail.Add (addr);  			continue;  		}  		reader.BaseStream.Position -= 6;  		if (reader.ReadByte () != 0x68)// push dword  		 {  			GetBSTRFail.Add (addr);  			continue;  		}  		int idx = reader.ReadInt32 ();  		if (idx > ms_nSize - 1)  			GetBSTRFail.Add (addr);  		else  			GetBSTR.Add (addr' idx);  	}  	Status ("Failed to find index of {0} references"' GetStringFail.Count + GetStringWFail.Count + GetBSTRFail.Count);  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: if (MessageBox.Show ("Scan for references to strings in the client? This can take a while."' "Warning"' MessageBoxButtons.YesNo' MessageBoxIcon.Warning) == DialogResult.Yes) {  	Status ("Searching for references to GetString' GetStringW' and GetBSTR");  	List<int> GetStringCalls = new List<int> ();  	List<int> GetStringWCalls = new List<int> ();  	List<int> GetBSTRCalls = new List<int> ();  	for (reader.BaseStream.Position = 0; reader.BaseStream.Position < reader.BaseStream.Length;) {  		//int lol = (int)((float)reader.BaseStream.Position / reader.BaseStream.Length * 100);  		//if (lol > MainForm.toolStripProgressBar1.Value)  		//{  		//    MainForm.Invoke(() => MainForm.toolStripProgressBar1.Value = lol);  		//    MainForm.Invoke(() => MainForm.Update());  		//} too expensive  		if (reader.ReadByte () != 0xE8)  			// call  			continue;  		int offset = reader.ReadInt32 ();  		if (reader.BaseStream.Position + offset == offset_StringPool__GetString_uint)  			GetStringCalls.Add ((int)reader.BaseStream.Position - 5);  		else if (reader.BaseStream.Position + offset == offset_StringPool__GetStringW_uint)  			GetStringWCalls.Add ((int)reader.BaseStream.Position - 5);  		else if (reader.BaseStream.Position + offset == offset_StringPool__GetBSTR_uint)  			GetBSTRCalls.Add ((int)reader.BaseStream.Position - 5);  		else  			reader.BaseStream.Position -= 4;  	}  	List<int> GetStringFail = new List<int> ();  	foreach (int addr in GetStringCalls) {  		reader.BaseStream.Position = addr;  		reader.BaseStream.Position -= 2;  		if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  		 {  			GetStringFail.Add (addr);  			continue;  		}  		reader.BaseStream.Position -= 7;  		if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  		 {  			GetStringFail.Add (addr);  			continue;  		}  		reader.BaseStream.Position -= 2;  		if (reader.ReadByte () != 0x50)// push eax  		 {  			GetStringFail.Add (addr);  			continue;  		}  		reader.BaseStream.Position -= 6;  		if (reader.ReadByte () != 0x68)// push dword  		 {  			GetStringFail.Add (addr);  			continue;  		}  		int idx = reader.ReadInt32 ();  		if (idx > ms_nSize - 1)  			GetStringFail.Add (addr);  		else  			GetString.Add (addr' idx);  	}  	List<int> GetStringWFail = new List<int> ();  	foreach (int addr in GetStringWCalls) {  		reader.BaseStream.Position = addr;  		reader.BaseStream.Position -= 2;  		if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  		 {  			GetStringWFail.Add (addr);  			continue;  		}  		reader.BaseStream.Position -= 7;  		if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  		 {  			GetStringWFail.Add (addr);  			continue;  		}  		reader.BaseStream.Position -= 2;  		if (reader.ReadByte () != 0x50)// push eax  		 {  			GetStringWFail.Add (addr);  			continue;  		}  		reader.BaseStream.Position -= 6;  		if (reader.ReadByte () != 0x68)// push dword  		 {  			GetStringWFail.Add (addr);  			continue;  		}  		int idx = reader.ReadInt32 ();  		if (idx > ms_nSize - 1)  			GetStringWFail.Add (addr);  		else  			GetStringW.Add (addr' idx);  	}  	List<int> GetBSTRFail = new List<int> ();  	foreach (int addr in GetBSTRCalls) {  		reader.BaseStream.Position = addr;  		reader.BaseStream.Position -= 2;  		if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  		 {  			GetBSTRFail.Add (addr);  			continue;  		}  		reader.BaseStream.Position -= 7;  		if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  		 {  			GetBSTRFail.Add (addr);  			continue;  		}  		reader.BaseStream.Position -= 2;  		if (reader.ReadByte () != 0x50)// push eax  		 {  			GetBSTRFail.Add (addr);  			continue;  		}  		reader.BaseStream.Position -= 6;  		if (reader.ReadByte () != 0x68)// push dword  		 {  			GetBSTRFail.Add (addr);  			continue;  		}  		int idx = reader.ReadInt32 ();  		if (idx > ms_nSize - 1)  			GetBSTRFail.Add (addr);  		else  			GetBSTR.Add (addr' idx);  	}  	Status ("Failed to find index of {0} references"' GetStringFail.Count + GetStringWFail.Count + GetBSTRFail.Count);  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: if (MessageBox.Show ("Scan for references to strings in the client? This can take a while."' "Warning"' MessageBoxButtons.YesNo' MessageBoxIcon.Warning) == DialogResult.Yes) {  	Status ("Searching for references to GetString' GetStringW' and GetBSTR");  	List<int> GetStringCalls = new List<int> ();  	List<int> GetStringWCalls = new List<int> ();  	List<int> GetBSTRCalls = new List<int> ();  	for (reader.BaseStream.Position = 0; reader.BaseStream.Position < reader.BaseStream.Length;) {  		//int lol = (int)((float)reader.BaseStream.Position / reader.BaseStream.Length * 100);  		//if (lol > MainForm.toolStripProgressBar1.Value)  		//{  		//    MainForm.Invoke(() => MainForm.toolStripProgressBar1.Value = lol);  		//    MainForm.Invoke(() => MainForm.Update());  		//} too expensive  		if (reader.ReadByte () != 0xE8)  			// call  			continue;  		int offset = reader.ReadInt32 ();  		if (reader.BaseStream.Position + offset == offset_StringPool__GetString_uint)  			GetStringCalls.Add ((int)reader.BaseStream.Position - 5);  		else if (reader.BaseStream.Position + offset == offset_StringPool__GetStringW_uint)  			GetStringWCalls.Add ((int)reader.BaseStream.Position - 5);  		else if (reader.BaseStream.Position + offset == offset_StringPool__GetBSTR_uint)  			GetBSTRCalls.Add ((int)reader.BaseStream.Position - 5);  		else  			reader.BaseStream.Position -= 4;  	}  	List<int> GetStringFail = new List<int> ();  	foreach (int addr in GetStringCalls) {  		reader.BaseStream.Position = addr;  		reader.BaseStream.Position -= 2;  		if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  		 {  			GetStringFail.Add (addr);  			continue;  		}  		reader.BaseStream.Position -= 7;  		if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  		 {  			GetStringFail.Add (addr);  			continue;  		}  		reader.BaseStream.Position -= 2;  		if (reader.ReadByte () != 0x50)// push eax  		 {  			GetStringFail.Add (addr);  			continue;  		}  		reader.BaseStream.Position -= 6;  		if (reader.ReadByte () != 0x68)// push dword  		 {  			GetStringFail.Add (addr);  			continue;  		}  		int idx = reader.ReadInt32 ();  		if (idx > ms_nSize - 1)  			GetStringFail.Add (addr);  		else  			GetString.Add (addr' idx);  	}  	List<int> GetStringWFail = new List<int> ();  	foreach (int addr in GetStringWCalls) {  		reader.BaseStream.Position = addr;  		reader.BaseStream.Position -= 2;  		if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  		 {  			GetStringWFail.Add (addr);  			continue;  		}  		reader.BaseStream.Position -= 7;  		if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  		 {  			GetStringWFail.Add (addr);  			continue;  		}  		reader.BaseStream.Position -= 2;  		if (reader.ReadByte () != 0x50)// push eax  		 {  			GetStringWFail.Add (addr);  			continue;  		}  		reader.BaseStream.Position -= 6;  		if (reader.ReadByte () != 0x68)// push dword  		 {  			GetStringWFail.Add (addr);  			continue;  		}  		int idx = reader.ReadInt32 ();  		if (idx > ms_nSize - 1)  			GetStringWFail.Add (addr);  		else  			GetStringW.Add (addr' idx);  	}  	List<int> GetBSTRFail = new List<int> ();  	foreach (int addr in GetBSTRCalls) {  		reader.BaseStream.Position = addr;  		reader.BaseStream.Position -= 2;  		if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  		 {  			GetBSTRFail.Add (addr);  			continue;  		}  		reader.BaseStream.Position -= 7;  		if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  		 {  			GetBSTRFail.Add (addr);  			continue;  		}  		reader.BaseStream.Position -= 2;  		if (reader.ReadByte () != 0x50)// push eax  		 {  			GetBSTRFail.Add (addr);  			continue;  		}  		reader.BaseStream.Position -= 6;  		if (reader.ReadByte () != 0x68)// push dword  		 {  			GetBSTRFail.Add (addr);  			continue;  		}  		int idx = reader.ReadInt32 ();  		if (idx > ms_nSize - 1)  			GetBSTRFail.Add (addr);  		else  			GetBSTR.Add (addr' idx);  	}  	Status ("Failed to find index of {0} references"' GetStringFail.Count + GetStringWFail.Count + GetBSTRFail.Count);  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: if (MessageBox.Show ("Scan for references to strings in the client? This can take a while."' "Warning"' MessageBoxButtons.YesNo' MessageBoxIcon.Warning) == DialogResult.Yes) {  	Status ("Searching for references to GetString' GetStringW' and GetBSTR");  	List<int> GetStringCalls = new List<int> ();  	List<int> GetStringWCalls = new List<int> ();  	List<int> GetBSTRCalls = new List<int> ();  	for (reader.BaseStream.Position = 0; reader.BaseStream.Position < reader.BaseStream.Length;) {  		//int lol = (int)((float)reader.BaseStream.Position / reader.BaseStream.Length * 100);  		//if (lol > MainForm.toolStripProgressBar1.Value)  		//{  		//    MainForm.Invoke(() => MainForm.toolStripProgressBar1.Value = lol);  		//    MainForm.Invoke(() => MainForm.Update());  		//} too expensive  		if (reader.ReadByte () != 0xE8)  			// call  			continue;  		int offset = reader.ReadInt32 ();  		if (reader.BaseStream.Position + offset == offset_StringPool__GetString_uint)  			GetStringCalls.Add ((int)reader.BaseStream.Position - 5);  		else if (reader.BaseStream.Position + offset == offset_StringPool__GetStringW_uint)  			GetStringWCalls.Add ((int)reader.BaseStream.Position - 5);  		else if (reader.BaseStream.Position + offset == offset_StringPool__GetBSTR_uint)  			GetBSTRCalls.Add ((int)reader.BaseStream.Position - 5);  		else  			reader.BaseStream.Position -= 4;  	}  	List<int> GetStringFail = new List<int> ();  	foreach (int addr in GetStringCalls) {  		reader.BaseStream.Position = addr;  		reader.BaseStream.Position -= 2;  		if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  		 {  			GetStringFail.Add (addr);  			continue;  		}  		reader.BaseStream.Position -= 7;  		if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  		 {  			GetStringFail.Add (addr);  			continue;  		}  		reader.BaseStream.Position -= 2;  		if (reader.ReadByte () != 0x50)// push eax  		 {  			GetStringFail.Add (addr);  			continue;  		}  		reader.BaseStream.Position -= 6;  		if (reader.ReadByte () != 0x68)// push dword  		 {  			GetStringFail.Add (addr);  			continue;  		}  		int idx = reader.ReadInt32 ();  		if (idx > ms_nSize - 1)  			GetStringFail.Add (addr);  		else  			GetString.Add (addr' idx);  	}  	List<int> GetStringWFail = new List<int> ();  	foreach (int addr in GetStringWCalls) {  		reader.BaseStream.Position = addr;  		reader.BaseStream.Position -= 2;  		if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  		 {  			GetStringWFail.Add (addr);  			continue;  		}  		reader.BaseStream.Position -= 7;  		if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  		 {  			GetStringWFail.Add (addr);  			continue;  		}  		reader.BaseStream.Position -= 2;  		if (reader.ReadByte () != 0x50)// push eax  		 {  			GetStringWFail.Add (addr);  			continue;  		}  		reader.BaseStream.Position -= 6;  		if (reader.ReadByte () != 0x68)// push dword  		 {  			GetStringWFail.Add (addr);  			continue;  		}  		int idx = reader.ReadInt32 ();  		if (idx > ms_nSize - 1)  			GetStringWFail.Add (addr);  		else  			GetStringW.Add (addr' idx);  	}  	List<int> GetBSTRFail = new List<int> ();  	foreach (int addr in GetBSTRCalls) {  		reader.BaseStream.Position = addr;  		reader.BaseStream.Position -= 2;  		if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  		 {  			GetBSTRFail.Add (addr);  			continue;  		}  		reader.BaseStream.Position -= 7;  		if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  		 {  			GetBSTRFail.Add (addr);  			continue;  		}  		reader.BaseStream.Position -= 2;  		if (reader.ReadByte () != 0x50)// push eax  		 {  			GetBSTRFail.Add (addr);  			continue;  		}  		reader.BaseStream.Position -= 6;  		if (reader.ReadByte () != 0x68)// push dword  		 {  			GetBSTRFail.Add (addr);  			continue;  		}  		int idx = reader.ReadInt32 ();  		if (idx > ms_nSize - 1)  			GetBSTRFail.Add (addr);  		else  			GetBSTR.Add (addr' idx);  	}  	Status ("Failed to find index of {0} references"' GetStringFail.Count + GetStringWFail.Count + GetBSTRFail.Count);  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: if (MessageBox.Show ("Scan for references to strings in the client? This can take a while."' "Warning"' MessageBoxButtons.YesNo' MessageBoxIcon.Warning) == DialogResult.Yes) {  	Status ("Searching for references to GetString' GetStringW' and GetBSTR");  	List<int> GetStringCalls = new List<int> ();  	List<int> GetStringWCalls = new List<int> ();  	List<int> GetBSTRCalls = new List<int> ();  	for (reader.BaseStream.Position = 0; reader.BaseStream.Position < reader.BaseStream.Length;) {  		//int lol = (int)((float)reader.BaseStream.Position / reader.BaseStream.Length * 100);  		//if (lol > MainForm.toolStripProgressBar1.Value)  		//{  		//    MainForm.Invoke(() => MainForm.toolStripProgressBar1.Value = lol);  		//    MainForm.Invoke(() => MainForm.Update());  		//} too expensive  		if (reader.ReadByte () != 0xE8)  			// call  			continue;  		int offset = reader.ReadInt32 ();  		if (reader.BaseStream.Position + offset == offset_StringPool__GetString_uint)  			GetStringCalls.Add ((int)reader.BaseStream.Position - 5);  		else if (reader.BaseStream.Position + offset == offset_StringPool__GetStringW_uint)  			GetStringWCalls.Add ((int)reader.BaseStream.Position - 5);  		else if (reader.BaseStream.Position + offset == offset_StringPool__GetBSTR_uint)  			GetBSTRCalls.Add ((int)reader.BaseStream.Position - 5);  		else  			reader.BaseStream.Position -= 4;  	}  	List<int> GetStringFail = new List<int> ();  	foreach (int addr in GetStringCalls) {  		reader.BaseStream.Position = addr;  		reader.BaseStream.Position -= 2;  		if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  		 {  			GetStringFail.Add (addr);  			continue;  		}  		reader.BaseStream.Position -= 7;  		if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  		 {  			GetStringFail.Add (addr);  			continue;  		}  		reader.BaseStream.Position -= 2;  		if (reader.ReadByte () != 0x50)// push eax  		 {  			GetStringFail.Add (addr);  			continue;  		}  		reader.BaseStream.Position -= 6;  		if (reader.ReadByte () != 0x68)// push dword  		 {  			GetStringFail.Add (addr);  			continue;  		}  		int idx = reader.ReadInt32 ();  		if (idx > ms_nSize - 1)  			GetStringFail.Add (addr);  		else  			GetString.Add (addr' idx);  	}  	List<int> GetStringWFail = new List<int> ();  	foreach (int addr in GetStringWCalls) {  		reader.BaseStream.Position = addr;  		reader.BaseStream.Position -= 2;  		if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  		 {  			GetStringWFail.Add (addr);  			continue;  		}  		reader.BaseStream.Position -= 7;  		if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  		 {  			GetStringWFail.Add (addr);  			continue;  		}  		reader.BaseStream.Position -= 2;  		if (reader.ReadByte () != 0x50)// push eax  		 {  			GetStringWFail.Add (addr);  			continue;  		}  		reader.BaseStream.Position -= 6;  		if (reader.ReadByte () != 0x68)// push dword  		 {  			GetStringWFail.Add (addr);  			continue;  		}  		int idx = reader.ReadInt32 ();  		if (idx > ms_nSize - 1)  			GetStringWFail.Add (addr);  		else  			GetStringW.Add (addr' idx);  	}  	List<int> GetBSTRFail = new List<int> ();  	foreach (int addr in GetBSTRCalls) {  		reader.BaseStream.Position = addr;  		reader.BaseStream.Position -= 2;  		if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  		 {  			GetBSTRFail.Add (addr);  			continue;  		}  		reader.BaseStream.Position -= 7;  		if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  		 {  			GetBSTRFail.Add (addr);  			continue;  		}  		reader.BaseStream.Position -= 2;  		if (reader.ReadByte () != 0x50)// push eax  		 {  			GetBSTRFail.Add (addr);  			continue;  		}  		reader.BaseStream.Position -= 6;  		if (reader.ReadByte () != 0x68)// push dword  		 {  			GetBSTRFail.Add (addr);  			continue;  		}  		int idx = reader.ReadInt32 ();  		if (idx > ms_nSize - 1)  			GetBSTRFail.Add (addr);  		else  			GetBSTR.Add (addr' idx);  	}  	Status ("Failed to find index of {0} references"' GetStringFail.Count + GetStringWFail.Count + GetBSTRFail.Count);  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: if (MessageBox.Show ("Scan for references to strings in the client? This can take a while."' "Warning"' MessageBoxButtons.YesNo' MessageBoxIcon.Warning) == DialogResult.Yes) {  	Status ("Searching for references to GetString' GetStringW' and GetBSTR");  	List<int> GetStringCalls = new List<int> ();  	List<int> GetStringWCalls = new List<int> ();  	List<int> GetBSTRCalls = new List<int> ();  	for (reader.BaseStream.Position = 0; reader.BaseStream.Position < reader.BaseStream.Length;) {  		//int lol = (int)((float)reader.BaseStream.Position / reader.BaseStream.Length * 100);  		//if (lol > MainForm.toolStripProgressBar1.Value)  		//{  		//    MainForm.Invoke(() => MainForm.toolStripProgressBar1.Value = lol);  		//    MainForm.Invoke(() => MainForm.Update());  		//} too expensive  		if (reader.ReadByte () != 0xE8)  			// call  			continue;  		int offset = reader.ReadInt32 ();  		if (reader.BaseStream.Position + offset == offset_StringPool__GetString_uint)  			GetStringCalls.Add ((int)reader.BaseStream.Position - 5);  		else if (reader.BaseStream.Position + offset == offset_StringPool__GetStringW_uint)  			GetStringWCalls.Add ((int)reader.BaseStream.Position - 5);  		else if (reader.BaseStream.Position + offset == offset_StringPool__GetBSTR_uint)  			GetBSTRCalls.Add ((int)reader.BaseStream.Position - 5);  		else  			reader.BaseStream.Position -= 4;  	}  	List<int> GetStringFail = new List<int> ();  	foreach (int addr in GetStringCalls) {  		reader.BaseStream.Position = addr;  		reader.BaseStream.Position -= 2;  		if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  		 {  			GetStringFail.Add (addr);  			continue;  		}  		reader.BaseStream.Position -= 7;  		if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  		 {  			GetStringFail.Add (addr);  			continue;  		}  		reader.BaseStream.Position -= 2;  		if (reader.ReadByte () != 0x50)// push eax  		 {  			GetStringFail.Add (addr);  			continue;  		}  		reader.BaseStream.Position -= 6;  		if (reader.ReadByte () != 0x68)// push dword  		 {  			GetStringFail.Add (addr);  			continue;  		}  		int idx = reader.ReadInt32 ();  		if (idx > ms_nSize - 1)  			GetStringFail.Add (addr);  		else  			GetString.Add (addr' idx);  	}  	List<int> GetStringWFail = new List<int> ();  	foreach (int addr in GetStringWCalls) {  		reader.BaseStream.Position = addr;  		reader.BaseStream.Position -= 2;  		if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  		 {  			GetStringWFail.Add (addr);  			continue;  		}  		reader.BaseStream.Position -= 7;  		if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  		 {  			GetStringWFail.Add (addr);  			continue;  		}  		reader.BaseStream.Position -= 2;  		if (reader.ReadByte () != 0x50)// push eax  		 {  			GetStringWFail.Add (addr);  			continue;  		}  		reader.BaseStream.Position -= 6;  		if (reader.ReadByte () != 0x68)// push dword  		 {  			GetStringWFail.Add (addr);  			continue;  		}  		int idx = reader.ReadInt32 ();  		if (idx > ms_nSize - 1)  			GetStringWFail.Add (addr);  		else  			GetStringW.Add (addr' idx);  	}  	List<int> GetBSTRFail = new List<int> ();  	foreach (int addr in GetBSTRCalls) {  		reader.BaseStream.Position = addr;  		reader.BaseStream.Position -= 2;  		if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  		 {  			GetBSTRFail.Add (addr);  			continue;  		}  		reader.BaseStream.Position -= 7;  		if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  		 {  			GetBSTRFail.Add (addr);  			continue;  		}  		reader.BaseStream.Position -= 2;  		if (reader.ReadByte () != 0x50)// push eax  		 {  			GetBSTRFail.Add (addr);  			continue;  		}  		reader.BaseStream.Position -= 6;  		if (reader.ReadByte () != 0x68)// push dword  		 {  			GetBSTRFail.Add (addr);  			continue;  		}  		int idx = reader.ReadInt32 ();  		if (idx > ms_nSize - 1)  			GetBSTRFail.Add (addr);  		else  			GetBSTR.Add (addr' idx);  	}  	Status ("Failed to find index of {0} references"' GetStringFail.Count + GetStringWFail.Count + GetBSTRFail.Count);  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: if (MessageBox.Show ("Scan for references to strings in the client? This can take a while."' "Warning"' MessageBoxButtons.YesNo' MessageBoxIcon.Warning) == DialogResult.Yes) {  	Status ("Searching for references to GetString' GetStringW' and GetBSTR");  	List<int> GetStringCalls = new List<int> ();  	List<int> GetStringWCalls = new List<int> ();  	List<int> GetBSTRCalls = new List<int> ();  	for (reader.BaseStream.Position = 0; reader.BaseStream.Position < reader.BaseStream.Length;) {  		//int lol = (int)((float)reader.BaseStream.Position / reader.BaseStream.Length * 100);  		//if (lol > MainForm.toolStripProgressBar1.Value)  		//{  		//    MainForm.Invoke(() => MainForm.toolStripProgressBar1.Value = lol);  		//    MainForm.Invoke(() => MainForm.Update());  		//} too expensive  		if (reader.ReadByte () != 0xE8)  			// call  			continue;  		int offset = reader.ReadInt32 ();  		if (reader.BaseStream.Position + offset == offset_StringPool__GetString_uint)  			GetStringCalls.Add ((int)reader.BaseStream.Position - 5);  		else if (reader.BaseStream.Position + offset == offset_StringPool__GetStringW_uint)  			GetStringWCalls.Add ((int)reader.BaseStream.Position - 5);  		else if (reader.BaseStream.Position + offset == offset_StringPool__GetBSTR_uint)  			GetBSTRCalls.Add ((int)reader.BaseStream.Position - 5);  		else  			reader.BaseStream.Position -= 4;  	}  	List<int> GetStringFail = new List<int> ();  	foreach (int addr in GetStringCalls) {  		reader.BaseStream.Position = addr;  		reader.BaseStream.Position -= 2;  		if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  		 {  			GetStringFail.Add (addr);  			continue;  		}  		reader.BaseStream.Position -= 7;  		if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  		 {  			GetStringFail.Add (addr);  			continue;  		}  		reader.BaseStream.Position -= 2;  		if (reader.ReadByte () != 0x50)// push eax  		 {  			GetStringFail.Add (addr);  			continue;  		}  		reader.BaseStream.Position -= 6;  		if (reader.ReadByte () != 0x68)// push dword  		 {  			GetStringFail.Add (addr);  			continue;  		}  		int idx = reader.ReadInt32 ();  		if (idx > ms_nSize - 1)  			GetStringFail.Add (addr);  		else  			GetString.Add (addr' idx);  	}  	List<int> GetStringWFail = new List<int> ();  	foreach (int addr in GetStringWCalls) {  		reader.BaseStream.Position = addr;  		reader.BaseStream.Position -= 2;  		if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  		 {  			GetStringWFail.Add (addr);  			continue;  		}  		reader.BaseStream.Position -= 7;  		if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  		 {  			GetStringWFail.Add (addr);  			continue;  		}  		reader.BaseStream.Position -= 2;  		if (reader.ReadByte () != 0x50)// push eax  		 {  			GetStringWFail.Add (addr);  			continue;  		}  		reader.BaseStream.Position -= 6;  		if (reader.ReadByte () != 0x68)// push dword  		 {  			GetStringWFail.Add (addr);  			continue;  		}  		int idx = reader.ReadInt32 ();  		if (idx > ms_nSize - 1)  			GetStringWFail.Add (addr);  		else  			GetStringW.Add (addr' idx);  	}  	List<int> GetBSTRFail = new List<int> ();  	foreach (int addr in GetBSTRCalls) {  		reader.BaseStream.Position = addr;  		reader.BaseStream.Position -= 2;  		if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  		 {  			GetBSTRFail.Add (addr);  			continue;  		}  		reader.BaseStream.Position -= 7;  		if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  		 {  			GetBSTRFail.Add (addr);  			continue;  		}  		reader.BaseStream.Position -= 2;  		if (reader.ReadByte () != 0x50)// push eax  		 {  			GetBSTRFail.Add (addr);  			continue;  		}  		reader.BaseStream.Position -= 6;  		if (reader.ReadByte () != 0x68)// push dword  		 {  			GetBSTRFail.Add (addr);  			continue;  		}  		int idx = reader.ReadInt32 ();  		if (idx > ms_nSize - 1)  			GetBSTRFail.Add (addr);  		else  			GetBSTR.Add (addr' idx);  	}  	Status ("Failed to find index of {0} references"' GetStringFail.Count + GetStringWFail.Count + GetBSTRFail.Count);  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: for (reader.BaseStream.Position = 0; reader.BaseStream.Position < reader.BaseStream.Length;) {  	//int lol = (int)((float)reader.BaseStream.Position / reader.BaseStream.Length * 100);  	//if (lol > MainForm.toolStripProgressBar1.Value)  	//{  	//    MainForm.Invoke(() => MainForm.toolStripProgressBar1.Value = lol);  	//    MainForm.Invoke(() => MainForm.Update());  	//} too expensive  	if (reader.ReadByte () != 0xE8)  		// call  		continue;  	int offset = reader.ReadInt32 ();  	if (reader.BaseStream.Position + offset == offset_StringPool__GetString_uint)  		GetStringCalls.Add ((int)reader.BaseStream.Position - 5);  	else if (reader.BaseStream.Position + offset == offset_StringPool__GetStringW_uint)  		GetStringWCalls.Add ((int)reader.BaseStream.Position - 5);  	else if (reader.BaseStream.Position + offset == offset_StringPool__GetBSTR_uint)  		GetBSTRCalls.Add ((int)reader.BaseStream.Position - 5);  	else  		reader.BaseStream.Position -= 4;  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: for (reader.BaseStream.Position = 0; reader.BaseStream.Position < reader.BaseStream.Length;) {  	//int lol = (int)((float)reader.BaseStream.Position / reader.BaseStream.Length * 100);  	//if (lol > MainForm.toolStripProgressBar1.Value)  	//{  	//    MainForm.Invoke(() => MainForm.toolStripProgressBar1.Value = lol);  	//    MainForm.Invoke(() => MainForm.Update());  	//} too expensive  	if (reader.ReadByte () != 0xE8)  		// call  		continue;  	int offset = reader.ReadInt32 ();  	if (reader.BaseStream.Position + offset == offset_StringPool__GetString_uint)  		GetStringCalls.Add ((int)reader.BaseStream.Position - 5);  	else if (reader.BaseStream.Position + offset == offset_StringPool__GetStringW_uint)  		GetStringWCalls.Add ((int)reader.BaseStream.Position - 5);  	else if (reader.BaseStream.Position + offset == offset_StringPool__GetBSTR_uint)  		GetBSTRCalls.Add ((int)reader.BaseStream.Position - 5);  	else  		reader.BaseStream.Position -= 4;  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: for (reader.BaseStream.Position = 0; reader.BaseStream.Position < reader.BaseStream.Length;) {  	//int lol = (int)((float)reader.BaseStream.Position / reader.BaseStream.Length * 100);  	//if (lol > MainForm.toolStripProgressBar1.Value)  	//{  	//    MainForm.Invoke(() => MainForm.toolStripProgressBar1.Value = lol);  	//    MainForm.Invoke(() => MainForm.Update());  	//} too expensive  	if (reader.ReadByte () != 0xE8)  		// call  		continue;  	int offset = reader.ReadInt32 ();  	if (reader.BaseStream.Position + offset == offset_StringPool__GetString_uint)  		GetStringCalls.Add ((int)reader.BaseStream.Position - 5);  	else if (reader.BaseStream.Position + offset == offset_StringPool__GetStringW_uint)  		GetStringWCalls.Add ((int)reader.BaseStream.Position - 5);  	else if (reader.BaseStream.Position + offset == offset_StringPool__GetBSTR_uint)  		GetBSTRCalls.Add ((int)reader.BaseStream.Position - 5);  	else  		reader.BaseStream.Position -= 4;  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: for (reader.BaseStream.Position = 0; reader.BaseStream.Position < reader.BaseStream.Length;) {  	//int lol = (int)((float)reader.BaseStream.Position / reader.BaseStream.Length * 100);  	//if (lol > MainForm.toolStripProgressBar1.Value)  	//{  	//    MainForm.Invoke(() => MainForm.toolStripProgressBar1.Value = lol);  	//    MainForm.Invoke(() => MainForm.Update());  	//} too expensive  	if (reader.ReadByte () != 0xE8)  		// call  		continue;  	int offset = reader.ReadInt32 ();  	if (reader.BaseStream.Position + offset == offset_StringPool__GetString_uint)  		GetStringCalls.Add ((int)reader.BaseStream.Position - 5);  	else if (reader.BaseStream.Position + offset == offset_StringPool__GetStringW_uint)  		GetStringWCalls.Add ((int)reader.BaseStream.Position - 5);  	else if (reader.BaseStream.Position + offset == offset_StringPool__GetBSTR_uint)  		GetBSTRCalls.Add ((int)reader.BaseStream.Position - 5);  	else  		reader.BaseStream.Position -= 4;  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: if (reader.BaseStream.Position + offset == offset_StringPool__GetString_uint)  	GetStringCalls.Add ((int)reader.BaseStream.Position - 5);  else if (reader.BaseStream.Position + offset == offset_StringPool__GetStringW_uint)  	GetStringWCalls.Add ((int)reader.BaseStream.Position - 5);  else if (reader.BaseStream.Position + offset == offset_StringPool__GetBSTR_uint)  	GetBSTRCalls.Add ((int)reader.BaseStream.Position - 5);  else  	reader.BaseStream.Position -= 4;  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: if (reader.BaseStream.Position + offset == offset_StringPool__GetString_uint)  	GetStringCalls.Add ((int)reader.BaseStream.Position - 5);  else if (reader.BaseStream.Position + offset == offset_StringPool__GetStringW_uint)  	GetStringWCalls.Add ((int)reader.BaseStream.Position - 5);  else if (reader.BaseStream.Position + offset == offset_StringPool__GetBSTR_uint)  	GetBSTRCalls.Add ((int)reader.BaseStream.Position - 5);  else  	reader.BaseStream.Position -= 4;  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: if (reader.BaseStream.Position + offset == offset_StringPool__GetString_uint)  	GetStringCalls.Add ((int)reader.BaseStream.Position - 5);  else if (reader.BaseStream.Position + offset == offset_StringPool__GetStringW_uint)  	GetStringWCalls.Add ((int)reader.BaseStream.Position - 5);  else if (reader.BaseStream.Position + offset == offset_StringPool__GetBSTR_uint)  	GetBSTRCalls.Add ((int)reader.BaseStream.Position - 5);  else  	reader.BaseStream.Position -= 4;  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: if (reader.BaseStream.Position + offset == offset_StringPool__GetString_uint)  	GetStringCalls.Add ((int)reader.BaseStream.Position - 5);  else if (reader.BaseStream.Position + offset == offset_StringPool__GetStringW_uint)  	GetStringWCalls.Add ((int)reader.BaseStream.Position - 5);  else if (reader.BaseStream.Position + offset == offset_StringPool__GetBSTR_uint)  	GetBSTRCalls.Add ((int)reader.BaseStream.Position - 5);  else  	reader.BaseStream.Position -= 4;  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: GetStringCalls.Add ((int)reader.BaseStream.Position - 5);  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: if (reader.BaseStream.Position + offset == offset_StringPool__GetStringW_uint)  	GetStringWCalls.Add ((int)reader.BaseStream.Position - 5);  else if (reader.BaseStream.Position + offset == offset_StringPool__GetBSTR_uint)  	GetBSTRCalls.Add ((int)reader.BaseStream.Position - 5);  else  	reader.BaseStream.Position -= 4;  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: if (reader.BaseStream.Position + offset == offset_StringPool__GetStringW_uint)  	GetStringWCalls.Add ((int)reader.BaseStream.Position - 5);  else if (reader.BaseStream.Position + offset == offset_StringPool__GetBSTR_uint)  	GetBSTRCalls.Add ((int)reader.BaseStream.Position - 5);  else  	reader.BaseStream.Position -= 4;  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: if (reader.BaseStream.Position + offset == offset_StringPool__GetStringW_uint)  	GetStringWCalls.Add ((int)reader.BaseStream.Position - 5);  else if (reader.BaseStream.Position + offset == offset_StringPool__GetBSTR_uint)  	GetBSTRCalls.Add ((int)reader.BaseStream.Position - 5);  else  	reader.BaseStream.Position -= 4;  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: GetStringWCalls.Add ((int)reader.BaseStream.Position - 5);  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: if (reader.BaseStream.Position + offset == offset_StringPool__GetBSTR_uint)  	GetBSTRCalls.Add ((int)reader.BaseStream.Position - 5);  else  	reader.BaseStream.Position -= 4;  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: if (reader.BaseStream.Position + offset == offset_StringPool__GetBSTR_uint)  	GetBSTRCalls.Add ((int)reader.BaseStream.Position - 5);  else  	reader.BaseStream.Position -= 4;  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: GetBSTRCalls.Add ((int)reader.BaseStream.Position - 5);  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: reader.BaseStream.Position -= 4;  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: foreach (int addr in GetStringCalls) {  	reader.BaseStream.Position = addr;  	reader.BaseStream.Position -= 2;  	if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  	 {  		GetStringFail.Add (addr);  		continue;  	}  	reader.BaseStream.Position -= 7;  	if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  	 {  		GetStringFail.Add (addr);  		continue;  	}  	reader.BaseStream.Position -= 2;  	if (reader.ReadByte () != 0x50)// push eax  	 {  		GetStringFail.Add (addr);  		continue;  	}  	reader.BaseStream.Position -= 6;  	if (reader.ReadByte () != 0x68)// push dword  	 {  		GetStringFail.Add (addr);  		continue;  	}  	int idx = reader.ReadInt32 ();  	if (idx > ms_nSize - 1)  		GetStringFail.Add (addr);  	else  		GetString.Add (addr' idx);  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: foreach (int addr in GetStringCalls) {  	reader.BaseStream.Position = addr;  	reader.BaseStream.Position -= 2;  	if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  	 {  		GetStringFail.Add (addr);  		continue;  	}  	reader.BaseStream.Position -= 7;  	if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  	 {  		GetStringFail.Add (addr);  		continue;  	}  	reader.BaseStream.Position -= 2;  	if (reader.ReadByte () != 0x50)// push eax  	 {  		GetStringFail.Add (addr);  		continue;  	}  	reader.BaseStream.Position -= 6;  	if (reader.ReadByte () != 0x68)// push dword  	 {  		GetStringFail.Add (addr);  		continue;  	}  	int idx = reader.ReadInt32 ();  	if (idx > ms_nSize - 1)  		GetStringFail.Add (addr);  	else  		GetString.Add (addr' idx);  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: foreach (int addr in GetStringCalls) {  	reader.BaseStream.Position = addr;  	reader.BaseStream.Position -= 2;  	if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  	 {  		GetStringFail.Add (addr);  		continue;  	}  	reader.BaseStream.Position -= 7;  	if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  	 {  		GetStringFail.Add (addr);  		continue;  	}  	reader.BaseStream.Position -= 2;  	if (reader.ReadByte () != 0x50)// push eax  	 {  		GetStringFail.Add (addr);  		continue;  	}  	reader.BaseStream.Position -= 6;  	if (reader.ReadByte () != 0x68)// push dword  	 {  		GetStringFail.Add (addr);  		continue;  	}  	int idx = reader.ReadInt32 ();  	if (idx > ms_nSize - 1)  		GetStringFail.Add (addr);  	else  		GetString.Add (addr' idx);  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: foreach (int addr in GetStringCalls) {  	reader.BaseStream.Position = addr;  	reader.BaseStream.Position -= 2;  	if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  	 {  		GetStringFail.Add (addr);  		continue;  	}  	reader.BaseStream.Position -= 7;  	if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  	 {  		GetStringFail.Add (addr);  		continue;  	}  	reader.BaseStream.Position -= 2;  	if (reader.ReadByte () != 0x50)// push eax  	 {  		GetStringFail.Add (addr);  		continue;  	}  	reader.BaseStream.Position -= 6;  	if (reader.ReadByte () != 0x68)// push dword  	 {  		GetStringFail.Add (addr);  		continue;  	}  	int idx = reader.ReadInt32 ();  	if (idx > ms_nSize - 1)  		GetStringFail.Add (addr);  	else  		GetString.Add (addr' idx);  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: reader.BaseStream.Position -= 2;  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: reader.BaseStream.Position -= 7;  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: reader.BaseStream.Position -= 2;  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: reader.BaseStream.Position -= 6;  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: foreach (int addr in GetStringWCalls) {  	reader.BaseStream.Position = addr;  	reader.BaseStream.Position -= 2;  	if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  	 {  		GetStringWFail.Add (addr);  		continue;  	}  	reader.BaseStream.Position -= 7;  	if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  	 {  		GetStringWFail.Add (addr);  		continue;  	}  	reader.BaseStream.Position -= 2;  	if (reader.ReadByte () != 0x50)// push eax  	 {  		GetStringWFail.Add (addr);  		continue;  	}  	reader.BaseStream.Position -= 6;  	if (reader.ReadByte () != 0x68)// push dword  	 {  		GetStringWFail.Add (addr);  		continue;  	}  	int idx = reader.ReadInt32 ();  	if (idx > ms_nSize - 1)  		GetStringWFail.Add (addr);  	else  		GetStringW.Add (addr' idx);  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: foreach (int addr in GetStringWCalls) {  	reader.BaseStream.Position = addr;  	reader.BaseStream.Position -= 2;  	if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  	 {  		GetStringWFail.Add (addr);  		continue;  	}  	reader.BaseStream.Position -= 7;  	if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  	 {  		GetStringWFail.Add (addr);  		continue;  	}  	reader.BaseStream.Position -= 2;  	if (reader.ReadByte () != 0x50)// push eax  	 {  		GetStringWFail.Add (addr);  		continue;  	}  	reader.BaseStream.Position -= 6;  	if (reader.ReadByte () != 0x68)// push dword  	 {  		GetStringWFail.Add (addr);  		continue;  	}  	int idx = reader.ReadInt32 ();  	if (idx > ms_nSize - 1)  		GetStringWFail.Add (addr);  	else  		GetStringW.Add (addr' idx);  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: foreach (int addr in GetStringWCalls) {  	reader.BaseStream.Position = addr;  	reader.BaseStream.Position -= 2;  	if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  	 {  		GetStringWFail.Add (addr);  		continue;  	}  	reader.BaseStream.Position -= 7;  	if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  	 {  		GetStringWFail.Add (addr);  		continue;  	}  	reader.BaseStream.Position -= 2;  	if (reader.ReadByte () != 0x50)// push eax  	 {  		GetStringWFail.Add (addr);  		continue;  	}  	reader.BaseStream.Position -= 6;  	if (reader.ReadByte () != 0x68)// push dword  	 {  		GetStringWFail.Add (addr);  		continue;  	}  	int idx = reader.ReadInt32 ();  	if (idx > ms_nSize - 1)  		GetStringWFail.Add (addr);  	else  		GetStringW.Add (addr' idx);  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: foreach (int addr in GetStringWCalls) {  	reader.BaseStream.Position = addr;  	reader.BaseStream.Position -= 2;  	if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  	 {  		GetStringWFail.Add (addr);  		continue;  	}  	reader.BaseStream.Position -= 7;  	if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  	 {  		GetStringWFail.Add (addr);  		continue;  	}  	reader.BaseStream.Position -= 2;  	if (reader.ReadByte () != 0x50)// push eax  	 {  		GetStringWFail.Add (addr);  		continue;  	}  	reader.BaseStream.Position -= 6;  	if (reader.ReadByte () != 0x68)// push dword  	 {  		GetStringWFail.Add (addr);  		continue;  	}  	int idx = reader.ReadInt32 ();  	if (idx > ms_nSize - 1)  		GetStringWFail.Add (addr);  	else  		GetStringW.Add (addr' idx);  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: reader.BaseStream.Position -= 2;  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: reader.BaseStream.Position -= 7;  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: reader.BaseStream.Position -= 2;  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: reader.BaseStream.Position -= 6;  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: foreach (int addr in GetBSTRCalls) {  	reader.BaseStream.Position = addr;  	reader.BaseStream.Position -= 2;  	if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  	 {  		GetBSTRFail.Add (addr);  		continue;  	}  	reader.BaseStream.Position -= 7;  	if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  	 {  		GetBSTRFail.Add (addr);  		continue;  	}  	reader.BaseStream.Position -= 2;  	if (reader.ReadByte () != 0x50)// push eax  	 {  		GetBSTRFail.Add (addr);  		continue;  	}  	reader.BaseStream.Position -= 6;  	if (reader.ReadByte () != 0x68)// push dword  	 {  		GetBSTRFail.Add (addr);  		continue;  	}  	int idx = reader.ReadInt32 ();  	if (idx > ms_nSize - 1)  		GetBSTRFail.Add (addr);  	else  		GetBSTR.Add (addr' idx);  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: foreach (int addr in GetBSTRCalls) {  	reader.BaseStream.Position = addr;  	reader.BaseStream.Position -= 2;  	if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  	 {  		GetBSTRFail.Add (addr);  		continue;  	}  	reader.BaseStream.Position -= 7;  	if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  	 {  		GetBSTRFail.Add (addr);  		continue;  	}  	reader.BaseStream.Position -= 2;  	if (reader.ReadByte () != 0x50)// push eax  	 {  		GetBSTRFail.Add (addr);  		continue;  	}  	reader.BaseStream.Position -= 6;  	if (reader.ReadByte () != 0x68)// push dword  	 {  		GetBSTRFail.Add (addr);  		continue;  	}  	int idx = reader.ReadInt32 ();  	if (idx > ms_nSize - 1)  		GetBSTRFail.Add (addr);  	else  		GetBSTR.Add (addr' idx);  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: foreach (int addr in GetBSTRCalls) {  	reader.BaseStream.Position = addr;  	reader.BaseStream.Position -= 2;  	if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  	 {  		GetBSTRFail.Add (addr);  		continue;  	}  	reader.BaseStream.Position -= 7;  	if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  	 {  		GetBSTRFail.Add (addr);  		continue;  	}  	reader.BaseStream.Position -= 2;  	if (reader.ReadByte () != 0x50)// push eax  	 {  		GetBSTRFail.Add (addr);  		continue;  	}  	reader.BaseStream.Position -= 6;  	if (reader.ReadByte () != 0x68)// push dword  	 {  		GetBSTRFail.Add (addr);  		continue;  	}  	int idx = reader.ReadInt32 ();  	if (idx > ms_nSize - 1)  		GetBSTRFail.Add (addr);  	else  		GetBSTR.Add (addr' idx);  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: foreach (int addr in GetBSTRCalls) {  	reader.BaseStream.Position = addr;  	reader.BaseStream.Position -= 2;  	if (reader.ReadUInt16 () != 0xC88B)// mov ecx' eax  	 {  		GetBSTRFail.Add (addr);  		continue;  	}  	reader.BaseStream.Position -= 7;  	if (reader.ReadByte () != 0xE8)// StringPool::GetInstance()  	 {  		GetBSTRFail.Add (addr);  		continue;  	}  	reader.BaseStream.Position -= 2;  	if (reader.ReadByte () != 0x50)// push eax  	 {  		GetBSTRFail.Add (addr);  		continue;  	}  	reader.BaseStream.Position -= 6;  	if (reader.ReadByte () != 0x68)// push dword  	 {  		GetBSTRFail.Add (addr);  		continue;  	}  	int idx = reader.ReadInt32 ();  	if (idx > ms_nSize - 1)  		GetBSTRFail.Add (addr);  	else  		GetBSTR.Add (addr' idx);  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: reader.BaseStream.Position -= 2;  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: reader.BaseStream.Position -= 7;  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: reader.BaseStream.Position -= 2;  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: reader.BaseStream.Position -= 6;  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: foreach (var a in GetString)  	MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetString")));  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: foreach (var a in GetString)  	MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetString")));  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetString")));  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetString")));  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: foreach (var a in GetBSTR)  	MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetBSTR")));  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: foreach (var a in GetBSTR)  	MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetBSTR")));  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetBSTR")));  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetBSTR")));  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: foreach (var a in GetStringW)  	MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetStringW")));  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: foreach (var a in GetStringW)  	MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetStringW")));  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetStringW")));  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: MainForm.Invoke (() => MainForm.dataTable.Rows [a.Value].SetField (2' string.Format ("{0}{1:X8}({2})' "' MainForm.dataTable.Rows [a.Value] [2]' a.Key' "GetStringW")));  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: if (StringDecodeMethod == 1)// StringDecoder   {  	MainForm.Invoke (() => MainForm.Text += " [StringDecoder]");  	int type = 0;  	int name = 0;  	int offset = 0;  	//search for CStringDecoder::DelayedLoad' which contains the resource type and name  	if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00'  		0x89'  		0x45'  		0xF4'  		0x6A'  		0xAA'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x8B'  		0x4D'  		0xF4'  		0x51'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 12;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 1;  		name = reader.ReadInt32 ();  	}  	else if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00'  		0x6A'  		0xAA'  		0x8B'  		0xF8'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x57'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 9;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 3;  		name = reader.ReadInt32 ();  	}  	else if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0xAA'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 1;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 1;  		name = reader.ReadInt32 ();  	}  	else  		throw new Exception ("Failed to determine type and name of resource.");  	//search for start of function CStringDecoder::DelayedLoad()  	reader.BaseStream.Position -= 50;  	// should be enough  	FindAoBInFile (reader' (int)reader.BaseStream.Position' new byte[] {  		0x55'  		0x8B'  		0xEC'  		0x83'  		0xEC'  		0x10  	});  	int offset_CStringDecoder__DelayedLoad = (int)reader.BaseStream.Position;  	for (reader.BaseStream.Position = 0; reader.BaseStream.Position < reader.BaseStream.Length;) {  		if (reader.ReadByte () != 0xE8)  			// call  			continue;  		int offse = reader.ReadInt32 ();  		if (reader.BaseStream.Position + offse == offset_CStringDecoder__DelayedLoad) {  			Status ("{0:X8} reference to offset_CStringDecoder__DelayedLoad = {1:X8}"' reader.BaseStream.Position - 5' offse);  			break;  		}  	}  	ImageResourceDirectory tier1 = (ImageResourceDirectory)root.GetEntry (type).Entry;  	ImageResourceDirectory tier2 = (ImageResourceDirectory)tier1.GetEntry (name).Entry;  	rsrcStringDataEntry = (ImageResourceDataEntry)tier2.Entrys [0].Entry;  	rsrcStringDataPosition = rsrcPointerToRawData + (rsrcStringDataEntry.OffsetToData - rsrcVirtualAddress);  	m_nCount = GetWordFromIndex (0);  	Status ("Amount of strings: {0}"' m_nCount);  	for (int i = 1; i < m_nCount; ++i)  		MainForm.Invoke (() => MainForm.dataTable.Rows.Add (i' StringDecoderDecode (i)' string.Format ("{0:X8}"' rsrcStringDataPosition + i * 4)));  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: if (StringDecodeMethod == 1)// StringDecoder   {  	MainForm.Invoke (() => MainForm.Text += " [StringDecoder]");  	int type = 0;  	int name = 0;  	int offset = 0;  	//search for CStringDecoder::DelayedLoad' which contains the resource type and name  	if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00'  		0x89'  		0x45'  		0xF4'  		0x6A'  		0xAA'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x8B'  		0x4D'  		0xF4'  		0x51'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 12;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 1;  		name = reader.ReadInt32 ();  	}  	else if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00'  		0x6A'  		0xAA'  		0x8B'  		0xF8'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x57'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 9;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 3;  		name = reader.ReadInt32 ();  	}  	else if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0xAA'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 1;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 1;  		name = reader.ReadInt32 ();  	}  	else  		throw new Exception ("Failed to determine type and name of resource.");  	//search for start of function CStringDecoder::DelayedLoad()  	reader.BaseStream.Position -= 50;  	// should be enough  	FindAoBInFile (reader' (int)reader.BaseStream.Position' new byte[] {  		0x55'  		0x8B'  		0xEC'  		0x83'  		0xEC'  		0x10  	});  	int offset_CStringDecoder__DelayedLoad = (int)reader.BaseStream.Position;  	for (reader.BaseStream.Position = 0; reader.BaseStream.Position < reader.BaseStream.Length;) {  		if (reader.ReadByte () != 0xE8)  			// call  			continue;  		int offse = reader.ReadInt32 ();  		if (reader.BaseStream.Position + offse == offset_CStringDecoder__DelayedLoad) {  			Status ("{0:X8} reference to offset_CStringDecoder__DelayedLoad = {1:X8}"' reader.BaseStream.Position - 5' offse);  			break;  		}  	}  	ImageResourceDirectory tier1 = (ImageResourceDirectory)root.GetEntry (type).Entry;  	ImageResourceDirectory tier2 = (ImageResourceDirectory)tier1.GetEntry (name).Entry;  	rsrcStringDataEntry = (ImageResourceDataEntry)tier2.Entrys [0].Entry;  	rsrcStringDataPosition = rsrcPointerToRawData + (rsrcStringDataEntry.OffsetToData - rsrcVirtualAddress);  	m_nCount = GetWordFromIndex (0);  	Status ("Amount of strings: {0}"' m_nCount);  	for (int i = 1; i < m_nCount; ++i)  		MainForm.Invoke (() => MainForm.dataTable.Rows.Add (i' StringDecoderDecode (i)' string.Format ("{0:X8}"' rsrcStringDataPosition + i * 4)));  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: if (StringDecodeMethod == 1)// StringDecoder   {  	MainForm.Invoke (() => MainForm.Text += " [StringDecoder]");  	int type = 0;  	int name = 0;  	int offset = 0;  	//search for CStringDecoder::DelayedLoad' which contains the resource type and name  	if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00'  		0x89'  		0x45'  		0xF4'  		0x6A'  		0xAA'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x8B'  		0x4D'  		0xF4'  		0x51'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 12;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 1;  		name = reader.ReadInt32 ();  	}  	else if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00'  		0x6A'  		0xAA'  		0x8B'  		0xF8'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x57'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 9;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 3;  		name = reader.ReadInt32 ();  	}  	else if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0xAA'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 1;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 1;  		name = reader.ReadInt32 ();  	}  	else  		throw new Exception ("Failed to determine type and name of resource.");  	//search for start of function CStringDecoder::DelayedLoad()  	reader.BaseStream.Position -= 50;  	// should be enough  	FindAoBInFile (reader' (int)reader.BaseStream.Position' new byte[] {  		0x55'  		0x8B'  		0xEC'  		0x83'  		0xEC'  		0x10  	});  	int offset_CStringDecoder__DelayedLoad = (int)reader.BaseStream.Position;  	for (reader.BaseStream.Position = 0; reader.BaseStream.Position < reader.BaseStream.Length;) {  		if (reader.ReadByte () != 0xE8)  			// call  			continue;  		int offse = reader.ReadInt32 ();  		if (reader.BaseStream.Position + offse == offset_CStringDecoder__DelayedLoad) {  			Status ("{0:X8} reference to offset_CStringDecoder__DelayedLoad = {1:X8}"' reader.BaseStream.Position - 5' offse);  			break;  		}  	}  	ImageResourceDirectory tier1 = (ImageResourceDirectory)root.GetEntry (type).Entry;  	ImageResourceDirectory tier2 = (ImageResourceDirectory)tier1.GetEntry (name).Entry;  	rsrcStringDataEntry = (ImageResourceDataEntry)tier2.Entrys [0].Entry;  	rsrcStringDataPosition = rsrcPointerToRawData + (rsrcStringDataEntry.OffsetToData - rsrcVirtualAddress);  	m_nCount = GetWordFromIndex (0);  	Status ("Amount of strings: {0}"' m_nCount);  	for (int i = 1; i < m_nCount; ++i)  		MainForm.Invoke (() => MainForm.dataTable.Rows.Add (i' StringDecoderDecode (i)' string.Format ("{0:X8}"' rsrcStringDataPosition + i * 4)));  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: if (StringDecodeMethod == 1)// StringDecoder   {  	MainForm.Invoke (() => MainForm.Text += " [StringDecoder]");  	int type = 0;  	int name = 0;  	int offset = 0;  	//search for CStringDecoder::DelayedLoad' which contains the resource type and name  	if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00'  		0x89'  		0x45'  		0xF4'  		0x6A'  		0xAA'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x8B'  		0x4D'  		0xF4'  		0x51'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 12;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 1;  		name = reader.ReadInt32 ();  	}  	else if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00'  		0x6A'  		0xAA'  		0x8B'  		0xF8'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x57'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 9;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 3;  		name = reader.ReadInt32 ();  	}  	else if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0xAA'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 1;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 1;  		name = reader.ReadInt32 ();  	}  	else  		throw new Exception ("Failed to determine type and name of resource.");  	//search for start of function CStringDecoder::DelayedLoad()  	reader.BaseStream.Position -= 50;  	// should be enough  	FindAoBInFile (reader' (int)reader.BaseStream.Position' new byte[] {  		0x55'  		0x8B'  		0xEC'  		0x83'  		0xEC'  		0x10  	});  	int offset_CStringDecoder__DelayedLoad = (int)reader.BaseStream.Position;  	for (reader.BaseStream.Position = 0; reader.BaseStream.Position < reader.BaseStream.Length;) {  		if (reader.ReadByte () != 0xE8)  			// call  			continue;  		int offse = reader.ReadInt32 ();  		if (reader.BaseStream.Position + offse == offset_CStringDecoder__DelayedLoad) {  			Status ("{0:X8} reference to offset_CStringDecoder__DelayedLoad = {1:X8}"' reader.BaseStream.Position - 5' offse);  			break;  		}  	}  	ImageResourceDirectory tier1 = (ImageResourceDirectory)root.GetEntry (type).Entry;  	ImageResourceDirectory tier2 = (ImageResourceDirectory)tier1.GetEntry (name).Entry;  	rsrcStringDataEntry = (ImageResourceDataEntry)tier2.Entrys [0].Entry;  	rsrcStringDataPosition = rsrcPointerToRawData + (rsrcStringDataEntry.OffsetToData - rsrcVirtualAddress);  	m_nCount = GetWordFromIndex (0);  	Status ("Amount of strings: {0}"' m_nCount);  	for (int i = 1; i < m_nCount; ++i)  		MainForm.Invoke (() => MainForm.dataTable.Rows.Add (i' StringDecoderDecode (i)' string.Format ("{0:X8}"' rsrcStringDataPosition + i * 4)));  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: if (StringDecodeMethod == 1)// StringDecoder   {  	MainForm.Invoke (() => MainForm.Text += " [StringDecoder]");  	int type = 0;  	int name = 0;  	int offset = 0;  	//search for CStringDecoder::DelayedLoad' which contains the resource type and name  	if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00'  		0x89'  		0x45'  		0xF4'  		0x6A'  		0xAA'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x8B'  		0x4D'  		0xF4'  		0x51'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 12;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 1;  		name = reader.ReadInt32 ();  	}  	else if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00'  		0x6A'  		0xAA'  		0x8B'  		0xF8'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x57'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 9;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 3;  		name = reader.ReadInt32 ();  	}  	else if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0xAA'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 1;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 1;  		name = reader.ReadInt32 ();  	}  	else  		throw new Exception ("Failed to determine type and name of resource.");  	//search for start of function CStringDecoder::DelayedLoad()  	reader.BaseStream.Position -= 50;  	// should be enough  	FindAoBInFile (reader' (int)reader.BaseStream.Position' new byte[] {  		0x55'  		0x8B'  		0xEC'  		0x83'  		0xEC'  		0x10  	});  	int offset_CStringDecoder__DelayedLoad = (int)reader.BaseStream.Position;  	for (reader.BaseStream.Position = 0; reader.BaseStream.Position < reader.BaseStream.Length;) {  		if (reader.ReadByte () != 0xE8)  			// call  			continue;  		int offse = reader.ReadInt32 ();  		if (reader.BaseStream.Position + offse == offset_CStringDecoder__DelayedLoad) {  			Status ("{0:X8} reference to offset_CStringDecoder__DelayedLoad = {1:X8}"' reader.BaseStream.Position - 5' offse);  			break;  		}  	}  	ImageResourceDirectory tier1 = (ImageResourceDirectory)root.GetEntry (type).Entry;  	ImageResourceDirectory tier2 = (ImageResourceDirectory)tier1.GetEntry (name).Entry;  	rsrcStringDataEntry = (ImageResourceDataEntry)tier2.Entrys [0].Entry;  	rsrcStringDataPosition = rsrcPointerToRawData + (rsrcStringDataEntry.OffsetToData - rsrcVirtualAddress);  	m_nCount = GetWordFromIndex (0);  	Status ("Amount of strings: {0}"' m_nCount);  	for (int i = 1; i < m_nCount; ++i)  		MainForm.Invoke (() => MainForm.dataTable.Rows.Add (i' StringDecoderDecode (i)' string.Format ("{0:X8}"' rsrcStringDataPosition + i * 4)));  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: if (StringDecodeMethod == 1)// StringDecoder   {  	MainForm.Invoke (() => MainForm.Text += " [StringDecoder]");  	int type = 0;  	int name = 0;  	int offset = 0;  	//search for CStringDecoder::DelayedLoad' which contains the resource type and name  	if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00'  		0x89'  		0x45'  		0xF4'  		0x6A'  		0xAA'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x8B'  		0x4D'  		0xF4'  		0x51'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 12;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 1;  		name = reader.ReadInt32 ();  	}  	else if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00'  		0x6A'  		0xAA'  		0x8B'  		0xF8'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x57'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 9;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 3;  		name = reader.ReadInt32 ();  	}  	else if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  		0x6A'  		0xAA'  		0x68'  		0xAA'  		0xAA'  		0x00'  		0x00'  		0x6A'  		0x00'  		0xFF'  		0x15'  		0xAA'  		0xAA'  		0xAA'  		0x00  	})) {  		offset = (int)reader.BaseStream.Position;  		reader.BaseStream.Position += 1;  		type = reader.ReadByte ();  		reader.BaseStream.Position += 1;  		name = reader.ReadInt32 ();  	}  	else  		throw new Exception ("Failed to determine type and name of resource.");  	//search for start of function CStringDecoder::DelayedLoad()  	reader.BaseStream.Position -= 50;  	// should be enough  	FindAoBInFile (reader' (int)reader.BaseStream.Position' new byte[] {  		0x55'  		0x8B'  		0xEC'  		0x83'  		0xEC'  		0x10  	});  	int offset_CStringDecoder__DelayedLoad = (int)reader.BaseStream.Position;  	for (reader.BaseStream.Position = 0; reader.BaseStream.Position < reader.BaseStream.Length;) {  		if (reader.ReadByte () != 0xE8)  			// call  			continue;  		int offse = reader.ReadInt32 ();  		if (reader.BaseStream.Position + offse == offset_CStringDecoder__DelayedLoad) {  			Status ("{0:X8} reference to offset_CStringDecoder__DelayedLoad = {1:X8}"' reader.BaseStream.Position - 5' offse);  			break;  		}  	}  	ImageResourceDirectory tier1 = (ImageResourceDirectory)root.GetEntry (type).Entry;  	ImageResourceDirectory tier2 = (ImageResourceDirectory)tier1.GetEntry (name).Entry;  	rsrcStringDataEntry = (ImageResourceDataEntry)tier2.Entrys [0].Entry;  	rsrcStringDataPosition = rsrcPointerToRawData + (rsrcStringDataEntry.OffsetToData - rsrcVirtualAddress);  	m_nCount = GetWordFromIndex (0);  	Status ("Amount of strings: {0}"' m_nCount);  	for (int i = 1; i < m_nCount; ++i)  		MainForm.Invoke (() => MainForm.dataTable.Rows.Add (i' StringDecoderDecode (i)' string.Format ("{0:X8}"' rsrcStringDataPosition + i * 4)));  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  	0x6A'  	0x00'  	0xFF'  	0x15'  	0xAA'  	0xAA'  	0xAA'  	0x00'  	0x89'  	0x45'  	0xF4'  	0x6A'  	0xAA'  	0x68'  	0xAA'  	0xAA'  	0x00'  	0x00'  	0x8B'  	0x4D'  	0xF4'  	0x51'  	0xFF'  	0x15'  	0xAA'  	0xAA'  	0xAA'  	0x00  })) {  	offset = (int)reader.BaseStream.Position;  	reader.BaseStream.Position += 12;  	type = reader.ReadByte ();  	reader.BaseStream.Position += 1;  	name = reader.ReadInt32 ();  }  else if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  	0x6A'  	0x00'  	0xFF'  	0x15'  	0xAA'  	0xAA'  	0xAA'  	0x00'  	0x6A'  	0xAA'  	0x8B'  	0xF8'  	0x68'  	0xAA'  	0xAA'  	0x00'  	0x00'  	0x57'  	0xFF'  	0x15'  	0xAA'  	0xAA'  	0xAA'  	0x00  })) {  	offset = (int)reader.BaseStream.Position;  	reader.BaseStream.Position += 9;  	type = reader.ReadByte ();  	reader.BaseStream.Position += 3;  	name = reader.ReadInt32 ();  }  else if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  	0x6A'  	0xAA'  	0x68'  	0xAA'  	0xAA'  	0x00'  	0x00'  	0x6A'  	0x00'  	0xFF'  	0x15'  	0xAA'  	0xAA'  	0xAA'  	0x00  })) {  	offset = (int)reader.BaseStream.Position;  	reader.BaseStream.Position += 1;  	type = reader.ReadByte ();  	reader.BaseStream.Position += 1;  	name = reader.ReadInt32 ();  }  else  	throw new Exception ("Failed to determine type and name of resource.");  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  	0x6A'  	0x00'  	0xFF'  	0x15'  	0xAA'  	0xAA'  	0xAA'  	0x00'  	0x89'  	0x45'  	0xF4'  	0x6A'  	0xAA'  	0x68'  	0xAA'  	0xAA'  	0x00'  	0x00'  	0x8B'  	0x4D'  	0xF4'  	0x51'  	0xFF'  	0x15'  	0xAA'  	0xAA'  	0xAA'  	0x00  })) {  	offset = (int)reader.BaseStream.Position;  	reader.BaseStream.Position += 12;  	type = reader.ReadByte ();  	reader.BaseStream.Position += 1;  	name = reader.ReadInt32 ();  }  else if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  	0x6A'  	0x00'  	0xFF'  	0x15'  	0xAA'  	0xAA'  	0xAA'  	0x00'  	0x6A'  	0xAA'  	0x8B'  	0xF8'  	0x68'  	0xAA'  	0xAA'  	0x00'  	0x00'  	0x57'  	0xFF'  	0x15'  	0xAA'  	0xAA'  	0xAA'  	0x00  })) {  	offset = (int)reader.BaseStream.Position;  	reader.BaseStream.Position += 9;  	type = reader.ReadByte ();  	reader.BaseStream.Position += 3;  	name = reader.ReadInt32 ();  }  else if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  	0x6A'  	0xAA'  	0x68'  	0xAA'  	0xAA'  	0x00'  	0x00'  	0x6A'  	0x00'  	0xFF'  	0x15'  	0xAA'  	0xAA'  	0xAA'  	0x00  })) {  	offset = (int)reader.BaseStream.Position;  	reader.BaseStream.Position += 1;  	type = reader.ReadByte ();  	reader.BaseStream.Position += 1;  	name = reader.ReadInt32 ();  }  else  	throw new Exception ("Failed to determine type and name of resource.");  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  	0x6A'  	0x00'  	0xFF'  	0x15'  	0xAA'  	0xAA'  	0xAA'  	0x00'  	0x89'  	0x45'  	0xF4'  	0x6A'  	0xAA'  	0x68'  	0xAA'  	0xAA'  	0x00'  	0x00'  	0x8B'  	0x4D'  	0xF4'  	0x51'  	0xFF'  	0x15'  	0xAA'  	0xAA'  	0xAA'  	0x00  })) {  	offset = (int)reader.BaseStream.Position;  	reader.BaseStream.Position += 12;  	type = reader.ReadByte ();  	reader.BaseStream.Position += 1;  	name = reader.ReadInt32 ();  }  else if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  	0x6A'  	0x00'  	0xFF'  	0x15'  	0xAA'  	0xAA'  	0xAA'  	0x00'  	0x6A'  	0xAA'  	0x8B'  	0xF8'  	0x68'  	0xAA'  	0xAA'  	0x00'  	0x00'  	0x57'  	0xFF'  	0x15'  	0xAA'  	0xAA'  	0xAA'  	0x00  })) {  	offset = (int)reader.BaseStream.Position;  	reader.BaseStream.Position += 9;  	type = reader.ReadByte ();  	reader.BaseStream.Position += 3;  	name = reader.ReadInt32 ();  }  else if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  	0x6A'  	0xAA'  	0x68'  	0xAA'  	0xAA'  	0x00'  	0x00'  	0x6A'  	0x00'  	0xFF'  	0x15'  	0xAA'  	0xAA'  	0xAA'  	0x00  })) {  	offset = (int)reader.BaseStream.Position;  	reader.BaseStream.Position += 1;  	type = reader.ReadByte ();  	reader.BaseStream.Position += 1;  	name = reader.ReadInt32 ();  }  else  	throw new Exception ("Failed to determine type and name of resource.");  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: reader.BaseStream.Position += 12;  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  	0x6A'  	0x00'  	0xFF'  	0x15'  	0xAA'  	0xAA'  	0xAA'  	0x00'  	0x6A'  	0xAA'  	0x8B'  	0xF8'  	0x68'  	0xAA'  	0xAA'  	0x00'  	0x00'  	0x57'  	0xFF'  	0x15'  	0xAA'  	0xAA'  	0xAA'  	0x00  })) {  	offset = (int)reader.BaseStream.Position;  	reader.BaseStream.Position += 9;  	type = reader.ReadByte ();  	reader.BaseStream.Position += 3;  	name = reader.ReadInt32 ();  }  else if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  	0x6A'  	0xAA'  	0x68'  	0xAA'  	0xAA'  	0x00'  	0x00'  	0x6A'  	0x00'  	0xFF'  	0x15'  	0xAA'  	0xAA'  	0xAA'  	0x00  })) {  	offset = (int)reader.BaseStream.Position;  	reader.BaseStream.Position += 1;  	type = reader.ReadByte ();  	reader.BaseStream.Position += 1;  	name = reader.ReadInt32 ();  }  else  	throw new Exception ("Failed to determine type and name of resource.");  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  	0x6A'  	0x00'  	0xFF'  	0x15'  	0xAA'  	0xAA'  	0xAA'  	0x00'  	0x6A'  	0xAA'  	0x8B'  	0xF8'  	0x68'  	0xAA'  	0xAA'  	0x00'  	0x00'  	0x57'  	0xFF'  	0x15'  	0xAA'  	0xAA'  	0xAA'  	0x00  })) {  	offset = (int)reader.BaseStream.Position;  	reader.BaseStream.Position += 9;  	type = reader.ReadByte ();  	reader.BaseStream.Position += 3;  	name = reader.ReadInt32 ();  }  else if (FindAoBInFile (reader' 0x440000 - ImageBase' new byte[] {  	0x6A'  	0xAA'  	0x68'  	0xAA'  	0xAA'  	0x00'  	0x00'  	0x6A'  	0x00'  	0xFF'  	0x15'  	0xAA'  	0xAA'  	0xAA'  	0x00  })) {  	offset = (int)reader.BaseStream.Position;  	reader.BaseStream.Position += 1;  	type = reader.ReadByte ();  	reader.BaseStream.Position += 1;  	name = reader.ReadInt32 ();  }  else  	throw new Exception ("Failed to determine type and name of resource.");  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: reader.BaseStream.Position += 9;  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: reader.BaseStream.Position += 3;  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: reader.BaseStream.Position -= 50;  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: for (reader.BaseStream.Position = 0; reader.BaseStream.Position < reader.BaseStream.Length;) {  	if (reader.ReadByte () != 0xE8)  		// call  		continue;  	int offse = reader.ReadInt32 ();  	if (reader.BaseStream.Position + offse == offset_CStringDecoder__DelayedLoad) {  		Status ("{0:X8} reference to offset_CStringDecoder__DelayedLoad = {1:X8}"' reader.BaseStream.Position - 5' offse);  		break;  	}  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: if (reader.BaseStream.Position + offse == offset_CStringDecoder__DelayedLoad) {  	Status ("{0:X8} reference to offset_CStringDecoder__DelayedLoad = {1:X8}"' reader.BaseStream.Position - 5' offse);  	break;  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: Status ("{0:X8} reference to offset_CStringDecoder__DelayedLoad = {1:X8}"' reader.BaseStream.Position - 5' offse);  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: for (int i = 1; i < m_nCount; ++i)  	MainForm.Invoke (() => MainForm.dataTable.Rows.Add (i' StringDecoderDecode (i)' string.Format ("{0:X8}"' rsrcStringDataPosition + i * 4)));  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: MainForm.Invoke (() => MainForm.dataTable.Rows.Add (i' StringDecoderDecode (i)' string.Format ("{0:X8}"' rsrcStringDataPosition + i * 4)));  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: MainForm.Invoke (() => MainForm.dataGridView1.Columns [1].Width = 300);  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,OpenFile,The following statement contains a magic number: MainForm.Invoke (() => MainForm.dataGridView1.AutoResizeColumn (2));  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,FindCalls,The following statement contains a magic number: for (reader.BaseStream.Position = 0; reader.BaseStream.Position < reader.BaseStream.Length;) {  	if (reader.ReadByte () != 0xE8)  		// call  		continue;  	int offse = reader.ReadInt32 ();  	if (reader.BaseStream.Position + offse == address) {  		ret.Add ((int)reader.BaseStream.Position - 5);  		if (++i == max)  			break;  	}  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,FindCalls,The following statement contains a magic number: if (reader.BaseStream.Position + offse == address) {  	ret.Add ((int)reader.BaseStream.Position - 5);  	if (++i == max)  		break;  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,FindCalls,The following statement contains a magic number: ret.Add ((int)reader.BaseStream.Position - 5);  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,StringPoolEncode,The following statement contains a magic number: reader.BaseStream.Position = offset_StringPool__ms_aString + index * 4;  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,StringPoolDecode,The following statement contains a magic number: reader.BaseStream.Position = offset_StringPool__ms_aString + index * 4;  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,StringPoolDecode,The following statement contains a magic number: return Encoding.GetEncoding (949).GetString (list.ToArray ());  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,rotatel,The following statement contains a magic number: if (bitCount >= 8)  	for (byte i = 0; i < nKeySize; ++i)  		newKey [i] = aKey [((bitCount >> 3) % nKeySize + i) % nKeySize];  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,rotatel,The following statement contains a magic number: if (bitCount >= 8)  	for (byte i = 0; i < nKeySize; ++i)  		newKey [i] = aKey [((bitCount >> 3) % nKeySize + i) % nKeySize];  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,rotatel,The following statement contains a magic number: for (byte i = 0; i < nKeySize; ++i)  	newKey [i] = aKey [((bitCount >> 3) % nKeySize + i) % nKeySize];  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,rotatel,The following statement contains a magic number: newKey [i] = aKey [((bitCount >> 3) % nKeySize + i) % nKeySize];  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,rotatel,The following statement contains a magic number: if ((bitCount & 7) != 0) {  	bitCount &= 7;  	byte b0 = newKey [0];  	for (int i = 0; i < nKeySize; ++i) {  		byte a = 0;  		if (i != nKeySize - 1)  			a = (byte)(newKey [i + 1] >> 8 - bitCount);  		newKey [i] = (byte)(a | (newKey [i] << bitCount));  	}  	newKey [nKeySize - 1] |= (byte)(b0 >> 8 - bitCount);  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,rotatel,The following statement contains a magic number: if ((bitCount & 7) != 0) {  	bitCount &= 7;  	byte b0 = newKey [0];  	for (int i = 0; i < nKeySize; ++i) {  		byte a = 0;  		if (i != nKeySize - 1)  			a = (byte)(newKey [i + 1] >> 8 - bitCount);  		newKey [i] = (byte)(a | (newKey [i] << bitCount));  	}  	newKey [nKeySize - 1] |= (byte)(b0 >> 8 - bitCount);  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,rotatel,The following statement contains a magic number: if ((bitCount & 7) != 0) {  	bitCount &= 7;  	byte b0 = newKey [0];  	for (int i = 0; i < nKeySize; ++i) {  		byte a = 0;  		if (i != nKeySize - 1)  			a = (byte)(newKey [i + 1] >> 8 - bitCount);  		newKey [i] = (byte)(a | (newKey [i] << bitCount));  	}  	newKey [nKeySize - 1] |= (byte)(b0 >> 8 - bitCount);  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,rotatel,The following statement contains a magic number: if ((bitCount & 7) != 0) {  	bitCount &= 7;  	byte b0 = newKey [0];  	for (int i = 0; i < nKeySize; ++i) {  		byte a = 0;  		if (i != nKeySize - 1)  			a = (byte)(newKey [i + 1] >> 8 - bitCount);  		newKey [i] = (byte)(a | (newKey [i] << bitCount));  	}  	newKey [nKeySize - 1] |= (byte)(b0 >> 8 - bitCount);  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,rotatel,The following statement contains a magic number: bitCount &= 7;  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,rotatel,The following statement contains a magic number: for (int i = 0; i < nKeySize; ++i) {  	byte a = 0;  	if (i != nKeySize - 1)  		a = (byte)(newKey [i + 1] >> 8 - bitCount);  	newKey [i] = (byte)(a | (newKey [i] << bitCount));  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,rotatel,The following statement contains a magic number: if (i != nKeySize - 1)  	a = (byte)(newKey [i + 1] >> 8 - bitCount);  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,rotatel,The following statement contains a magic number: a = (byte)(newKey [i + 1] >> 8 - bitCount);  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,rotatel,The following statement contains a magic number: newKey [nKeySize - 1] |= (byte)(b0 >> 8 - bitCount);  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,StringDecoderDecode,The following statement contains a magic number: reader.BaseStream.Position = rsrcStringDataPosition + position + 4;  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,StringDecoderDecode,The following statement contains a magic number: for (int i = 0; i < length >> 2; ++i) {  	uint x = BitConverter.ToUInt32 (a1' i * 4);  	uint y = BitConverter.ToUInt32 (a2' i * 4);  	Buffer.BlockCopy (BitConverter.GetBytes (y.RollLeft (5) ^ x)' 0' aFinal' i * 4' 4);  	checksum2 = y + (x ^ checksum2).RollRight (5);  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,StringDecoderDecode,The following statement contains a magic number: for (int i = 0; i < length >> 2; ++i) {  	uint x = BitConverter.ToUInt32 (a1' i * 4);  	uint y = BitConverter.ToUInt32 (a2' i * 4);  	Buffer.BlockCopy (BitConverter.GetBytes (y.RollLeft (5) ^ x)' 0' aFinal' i * 4' 4);  	checksum2 = y + (x ^ checksum2).RollRight (5);  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,StringDecoderDecode,The following statement contains a magic number: for (int i = 0; i < length >> 2; ++i) {  	uint x = BitConverter.ToUInt32 (a1' i * 4);  	uint y = BitConverter.ToUInt32 (a2' i * 4);  	Buffer.BlockCopy (BitConverter.GetBytes (y.RollLeft (5) ^ x)' 0' aFinal' i * 4' 4);  	checksum2 = y + (x ^ checksum2).RollRight (5);  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,StringDecoderDecode,The following statement contains a magic number: for (int i = 0; i < length >> 2; ++i) {  	uint x = BitConverter.ToUInt32 (a1' i * 4);  	uint y = BitConverter.ToUInt32 (a2' i * 4);  	Buffer.BlockCopy (BitConverter.GetBytes (y.RollLeft (5) ^ x)' 0' aFinal' i * 4' 4);  	checksum2 = y + (x ^ checksum2).RollRight (5);  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,StringDecoderDecode,The following statement contains a magic number: for (int i = 0; i < length >> 2; ++i) {  	uint x = BitConverter.ToUInt32 (a1' i * 4);  	uint y = BitConverter.ToUInt32 (a2' i * 4);  	Buffer.BlockCopy (BitConverter.GetBytes (y.RollLeft (5) ^ x)' 0' aFinal' i * 4' 4);  	checksum2 = y + (x ^ checksum2).RollRight (5);  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,StringDecoderDecode,The following statement contains a magic number: for (int i = 0; i < length >> 2; ++i) {  	uint x = BitConverter.ToUInt32 (a1' i * 4);  	uint y = BitConverter.ToUInt32 (a2' i * 4);  	Buffer.BlockCopy (BitConverter.GetBytes (y.RollLeft (5) ^ x)' 0' aFinal' i * 4' 4);  	checksum2 = y + (x ^ checksum2).RollRight (5);  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,StringDecoderDecode,The following statement contains a magic number: for (int i = 0; i < length >> 2; ++i) {  	uint x = BitConverter.ToUInt32 (a1' i * 4);  	uint y = BitConverter.ToUInt32 (a2' i * 4);  	Buffer.BlockCopy (BitConverter.GetBytes (y.RollLeft (5) ^ x)' 0' aFinal' i * 4' 4);  	checksum2 = y + (x ^ checksum2).RollRight (5);  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,StringDecoderDecode,The following statement contains a magic number: Buffer.BlockCopy (BitConverter.GetBytes (y.RollLeft (5) ^ x)' 0' aFinal' i * 4' 4);  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,StringDecoderDecode,The following statement contains a magic number: Buffer.BlockCopy (BitConverter.GetBytes (y.RollLeft (5) ^ x)' 0' aFinal' i * 4' 4);  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,StringDecoderDecode,The following statement contains a magic number: Buffer.BlockCopy (BitConverter.GetBytes (y.RollLeft (5) ^ x)' 0' aFinal' i * 4' 4);  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,StringDecoderDecode,The following statement contains a magic number: checksum2 = y + (x ^ checksum2).RollRight (5);  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,StringDecoderDecode,The following statement contains a magic number: for (int i = 0; i < remained; i++) {  	byte x = a1 [begin + i];  	byte y = a2 [begin + i];  	aFinal [begin + i] = (byte)(x ^ y);  	checksum2 = y + (x ^ checksum2).RollRight (5);  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,StringDecoderDecode,The following statement contains a magic number: checksum2 = y + (x ^ checksum2).RollRight (5);  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,StringDecoderDecode,The following statement contains a magic number: return Encoding.GetEncoding (949).GetString (aFinal);  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,StringDecoderEncode,The following statement contains a magic number: writer.BaseStream.Position = rsrcStringDataPosition + GetWordFromIndex (4 * index);  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,StringDecoderEncode,The following statement contains a magic number: for (int i = 0; i < length; ++i)  	if (((length - i + 1) < 3 && (length % 4) != 0) || (i & 2) == 0)  		a1 [i] = 0x11;  	else  		a1 [i] = 0;  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,StringDecoderEncode,The following statement contains a magic number: for (int i = 0; i < length; ++i)  	if (((length - i + 1) < 3 && (length % 4) != 0) || (i & 2) == 0)  		a1 [i] = 0x11;  	else  		a1 [i] = 0;  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,StringDecoderEncode,The following statement contains a magic number: for (int i = 0; i < length; ++i)  	if (((length - i + 1) < 3 && (length % 4) != 0) || (i & 2) == 0)  		a1 [i] = 0x11;  	else  		a1 [i] = 0;  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,StringDecoderEncode,The following statement contains a magic number: if (((length - i + 1) < 3 && (length % 4) != 0) || (i & 2) == 0)  	a1 [i] = 0x11;  else  	a1 [i] = 0;  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,StringDecoderEncode,The following statement contains a magic number: if (((length - i + 1) < 3 && (length % 4) != 0) || (i & 2) == 0)  	a1 [i] = 0x11;  else  	a1 [i] = 0;  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,StringDecoderEncode,The following statement contains a magic number: if (((length - i + 1) < 3 && (length % 4) != 0) || (i & 2) == 0)  	a1 [i] = 0x11;  else  	a1 [i] = 0;  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,StringDecoderEncode,The following statement contains a magic number: for (int i = 0; i < length >> 2; ++i) {  	uint x = BitConverter.ToUInt32 (a1' i * 4);  	uint y = BitConverter.ToUInt32 (aFinal' i * 4);  	Buffer.BlockCopy (BitConverter.GetBytes ((y ^ x).RollRight (5))' 0' a2' i * 4' 4);  	checksum2 = BitConverter.ToUInt32 (a2' i * 4) + (checksum2 ^ x).RollRight (5);  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,StringDecoderEncode,The following statement contains a magic number: for (int i = 0; i < length >> 2; ++i) {  	uint x = BitConverter.ToUInt32 (a1' i * 4);  	uint y = BitConverter.ToUInt32 (aFinal' i * 4);  	Buffer.BlockCopy (BitConverter.GetBytes ((y ^ x).RollRight (5))' 0' a2' i * 4' 4);  	checksum2 = BitConverter.ToUInt32 (a2' i * 4) + (checksum2 ^ x).RollRight (5);  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,StringDecoderEncode,The following statement contains a magic number: for (int i = 0; i < length >> 2; ++i) {  	uint x = BitConverter.ToUInt32 (a1' i * 4);  	uint y = BitConverter.ToUInt32 (aFinal' i * 4);  	Buffer.BlockCopy (BitConverter.GetBytes ((y ^ x).RollRight (5))' 0' a2' i * 4' 4);  	checksum2 = BitConverter.ToUInt32 (a2' i * 4) + (checksum2 ^ x).RollRight (5);  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,StringDecoderEncode,The following statement contains a magic number: for (int i = 0; i < length >> 2; ++i) {  	uint x = BitConverter.ToUInt32 (a1' i * 4);  	uint y = BitConverter.ToUInt32 (aFinal' i * 4);  	Buffer.BlockCopy (BitConverter.GetBytes ((y ^ x).RollRight (5))' 0' a2' i * 4' 4);  	checksum2 = BitConverter.ToUInt32 (a2' i * 4) + (checksum2 ^ x).RollRight (5);  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,StringDecoderEncode,The following statement contains a magic number: for (int i = 0; i < length >> 2; ++i) {  	uint x = BitConverter.ToUInt32 (a1' i * 4);  	uint y = BitConverter.ToUInt32 (aFinal' i * 4);  	Buffer.BlockCopy (BitConverter.GetBytes ((y ^ x).RollRight (5))' 0' a2' i * 4' 4);  	checksum2 = BitConverter.ToUInt32 (a2' i * 4) + (checksum2 ^ x).RollRight (5);  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,StringDecoderEncode,The following statement contains a magic number: for (int i = 0; i < length >> 2; ++i) {  	uint x = BitConverter.ToUInt32 (a1' i * 4);  	uint y = BitConverter.ToUInt32 (aFinal' i * 4);  	Buffer.BlockCopy (BitConverter.GetBytes ((y ^ x).RollRight (5))' 0' a2' i * 4' 4);  	checksum2 = BitConverter.ToUInt32 (a2' i * 4) + (checksum2 ^ x).RollRight (5);  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,StringDecoderEncode,The following statement contains a magic number: for (int i = 0; i < length >> 2; ++i) {  	uint x = BitConverter.ToUInt32 (a1' i * 4);  	uint y = BitConverter.ToUInt32 (aFinal' i * 4);  	Buffer.BlockCopy (BitConverter.GetBytes ((y ^ x).RollRight (5))' 0' a2' i * 4' 4);  	checksum2 = BitConverter.ToUInt32 (a2' i * 4) + (checksum2 ^ x).RollRight (5);  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,StringDecoderEncode,The following statement contains a magic number: for (int i = 0; i < length >> 2; ++i) {  	uint x = BitConverter.ToUInt32 (a1' i * 4);  	uint y = BitConverter.ToUInt32 (aFinal' i * 4);  	Buffer.BlockCopy (BitConverter.GetBytes ((y ^ x).RollRight (5))' 0' a2' i * 4' 4);  	checksum2 = BitConverter.ToUInt32 (a2' i * 4) + (checksum2 ^ x).RollRight (5);  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,StringDecoderEncode,The following statement contains a magic number: Buffer.BlockCopy (BitConverter.GetBytes ((y ^ x).RollRight (5))' 0' a2' i * 4' 4);  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,StringDecoderEncode,The following statement contains a magic number: Buffer.BlockCopy (BitConverter.GetBytes ((y ^ x).RollRight (5))' 0' a2' i * 4' 4);  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,StringDecoderEncode,The following statement contains a magic number: Buffer.BlockCopy (BitConverter.GetBytes ((y ^ x).RollRight (5))' 0' a2' i * 4' 4);  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,StringDecoderEncode,The following statement contains a magic number: checksum2 = BitConverter.ToUInt32 (a2' i * 4) + (checksum2 ^ x).RollRight (5);  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,StringDecoderEncode,The following statement contains a magic number: checksum2 = BitConverter.ToUInt32 (a2' i * 4) + (checksum2 ^ x).RollRight (5);  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,StringDecoderEncode,The following statement contains a magic number: for (int i = 0; i < remained; ++i) {  	a2 [begin + i] = (byte)(aFinal [i] ^ a1 [i]);  	checksum2 = a2 [begin + i] + (a1 [begin + i] ^ checksum2).RollRight (5);  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,StringDecoderEncode,The following statement contains a magic number: checksum2 = a2 [begin + i] + (a1 [begin + i] ^ checksum2).RollRight (5);  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,ReverseIME,The following statement contains a magic number: foreach (char ch in str.ToCharArray ()) {  	if (ch < 44032 || ch > 55203)// out of range  	 {  		sb.Append (ch);  		continue;  	}  	int a = 0;  	int b = 0;  	int c = 0;  	for (int i = ch - 44032; i >= 588; i -= 588' ++a)  		;  	for (int i = ch - a * 588 - 44032; i >= 28; i -= 28' ++b)  		;  	c = ch - a * 588 - b * 28 - 44032;  	switch (a) {  	case 0:  		sb.Append ("r");  		break;  	case 1:  		sb.Append ("R");  		break;  	case 2:  		sb.Append ("s");  		break;  	case 3:  		sb.Append ("e");  		break;  	case 4:  		sb.Append ("E");  		break;  	case 5:  		sb.Append ("f");  		break;  	case 6:  		sb.Append ("a");  		break;  	case 7:  		sb.Append ("q");  		break;  	case 8:  		sb.Append ("Q");  		break;  	case 9:  		sb.Append ("t");  		break;  	case 10:  		sb.Append ("T");  		break;  	case 11:  		sb.Append ("d");  		break;  	case 12:  		sb.Append ("w");  		break;  	case 13:  		sb.Append ("W");  		break;  	case 14:  		sb.Append ("c");  		break;  	case 15:  		sb.Append ("z");  		break;  	case 16:  		sb.Append ("x");  		break;  	case 17:  		sb.Append ("v");  		break;  	case 18:  		sb.Append ("g");  		break;  	}  	switch (b) {  	case 0:  		sb.Append ("k");  		break;  	case 1:  		sb.Append ("o");  		break;  	case 2:  		sb.Append ("i");  		break;  	case 3:  		sb.Append ("O");  		break;  	case 4:  		sb.Append ("j");  		break;  	case 5:  		sb.Append ("p");  		break;  	case 6:  		sb.Append ("u");  		break;  	case 7:  		sb.Append ("P");  		break;  	case 8:  		sb.Append ("h");  		break;  	case 9:  		sb.Append ("hk");  		break;  	case 10:  		sb.Append ("ho");  		break;  	case 11:  		sb.Append ("hl");  		break;  	case 12:  		sb.Append ("y");  		break;  	case 13:  		sb.Append ("n");  		break;  	case 14:  		sb.Append ("nj");  		break;  	case 15:  		sb.Append ("np");  		break;  	case 16:  		sb.Append ("nl");  		break;  	case 17:  		sb.Append ("b");  		break;  	case 18:  		sb.Append ("m");  		break;  	case 19:  		sb.Append ("ml");  		break;  	case 20:  		sb.Append ("l");  		break;  	}  	switch (c) {  	case 1:  		sb.Append ("r");  		break;  	case 2:  		sb.Append ("R");  		break;  	case 3:  		sb.Append ("rt");  		break;  	case 4:  		sb.Append ("s");  		break;  	case 5:  		sb.Append ("sw");  		break;  	case 6:  		sb.Append ("sg");  		break;  	case 7:  		sb.Append ("e");  		break;  	case 8:  		sb.Append ("f");  		break;  	case 9:  		sb.Append ("fr");  		break;  	case 10:  		sb.Append ("fa");  		break;  	case 11:  		sb.Append ("fq");  		break;  	case 12:  		sb.Append ("ft");  		break;  	case 13:  		sb.Append ("fx");  		break;  	case 14:  		sb.Append ("fv");  		break;  	case 15:  		sb.Append ("fg");  		break;  	case 16:  		sb.Append ("a");  		break;  	case 17:  		sb.Append ("q");  		break;  	case 18:  		sb.Append ("qt");  		break;  	case 19:  		sb.Append ("t");  		break;  	case 20:  		sb.Append ("T");  		break;  	case 21:  		sb.Append ("d");  		break;  	case 22:  		sb.Append ("w");  		break;  	case 23:  		sb.Append ("c");  		break;  	case 24:  		sb.Append ("z");  		break;  	case 25:  		sb.Append ("x");  		break;  	case 26:  		sb.Append ("v");  		break;  	case 27:  		sb.Append ("g");  		break;  	}  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,ReverseIME,The following statement contains a magic number: foreach (char ch in str.ToCharArray ()) {  	if (ch < 44032 || ch > 55203)// out of range  	 {  		sb.Append (ch);  		continue;  	}  	int a = 0;  	int b = 0;  	int c = 0;  	for (int i = ch - 44032; i >= 588; i -= 588' ++a)  		;  	for (int i = ch - a * 588 - 44032; i >= 28; i -= 28' ++b)  		;  	c = ch - a * 588 - b * 28 - 44032;  	switch (a) {  	case 0:  		sb.Append ("r");  		break;  	case 1:  		sb.Append ("R");  		break;  	case 2:  		sb.Append ("s");  		break;  	case 3:  		sb.Append ("e");  		break;  	case 4:  		sb.Append ("E");  		break;  	case 5:  		sb.Append ("f");  		break;  	case 6:  		sb.Append ("a");  		break;  	case 7:  		sb.Append ("q");  		break;  	case 8:  		sb.Append ("Q");  		break;  	case 9:  		sb.Append ("t");  		break;  	case 10:  		sb.Append ("T");  		break;  	case 11:  		sb.Append ("d");  		break;  	case 12:  		sb.Append ("w");  		break;  	case 13:  		sb.Append ("W");  		break;  	case 14:  		sb.Append ("c");  		break;  	case 15:  		sb.Append ("z");  		break;  	case 16:  		sb.Append ("x");  		break;  	case 17:  		sb.Append ("v");  		break;  	case 18:  		sb.Append ("g");  		break;  	}  	switch (b) {  	case 0:  		sb.Append ("k");  		break;  	case 1:  		sb.Append ("o");  		break;  	case 2:  		sb.Append ("i");  		break;  	case 3:  		sb.Append ("O");  		break;  	case 4:  		sb.Append ("j");  		break;  	case 5:  		sb.Append ("p");  		break;  	case 6:  		sb.Append ("u");  		break;  	case 7:  		sb.Append ("P");  		break;  	case 8:  		sb.Append ("h");  		break;  	case 9:  		sb.Append ("hk");  		break;  	case 10:  		sb.Append ("ho");  		break;  	case 11:  		sb.Append ("hl");  		break;  	case 12:  		sb.Append ("y");  		break;  	case 13:  		sb.Append ("n");  		break;  	case 14:  		sb.Append ("nj");  		break;  	case 15:  		sb.Append ("np");  		break;  	case 16:  		sb.Append ("nl");  		break;  	case 17:  		sb.Append ("b");  		break;  	case 18:  		sb.Append ("m");  		break;  	case 19:  		sb.Append ("ml");  		break;  	case 20:  		sb.Append ("l");  		break;  	}  	switch (c) {  	case 1:  		sb.Append ("r");  		break;  	case 2:  		sb.Append ("R");  		break;  	case 3:  		sb.Append ("rt");  		break;  	case 4:  		sb.Append ("s");  		break;  	case 5:  		sb.Append ("sw");  		break;  	case 6:  		sb.Append ("sg");  		break;  	case 7:  		sb.Append ("e");  		break;  	case 8:  		sb.Append ("f");  		break;  	case 9:  		sb.Append ("fr");  		break;  	case 10:  		sb.Append ("fa");  		break;  	case 11:  		sb.Append ("fq");  		break;  	case 12:  		sb.Append ("ft");  		break;  	case 13:  		sb.Append ("fx");  		break;  	case 14:  		sb.Append ("fv");  		break;  	case 15:  		sb.Append ("fg");  		break;  	case 16:  		sb.Append ("a");  		break;  	case 17:  		sb.Append ("q");  		break;  	case 18:  		sb.Append ("qt");  		break;  	case 19:  		sb.Append ("t");  		break;  	case 20:  		sb.Append ("T");  		break;  	case 21:  		sb.Append ("d");  		break;  	case 22:  		sb.Append ("w");  		break;  	case 23:  		sb.Append ("c");  		break;  	case 24:  		sb.Append ("z");  		break;  	case 25:  		sb.Append ("x");  		break;  	case 26:  		sb.Append ("v");  		break;  	case 27:  		sb.Append ("g");  		break;  	}  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,ReverseIME,The following statement contains a magic number: foreach (char ch in str.ToCharArray ()) {  	if (ch < 44032 || ch > 55203)// out of range  	 {  		sb.Append (ch);  		continue;  	}  	int a = 0;  	int b = 0;  	int c = 0;  	for (int i = ch - 44032; i >= 588; i -= 588' ++a)  		;  	for (int i = ch - a * 588 - 44032; i >= 28; i -= 28' ++b)  		;  	c = ch - a * 588 - b * 28 - 44032;  	switch (a) {  	case 0:  		sb.Append ("r");  		break;  	case 1:  		sb.Append ("R");  		break;  	case 2:  		sb.Append ("s");  		break;  	case 3:  		sb.Append ("e");  		break;  	case 4:  		sb.Append ("E");  		break;  	case 5:  		sb.Append ("f");  		break;  	case 6:  		sb.Append ("a");  		break;  	case 7:  		sb.Append ("q");  		break;  	case 8:  		sb.Append ("Q");  		break;  	case 9:  		sb.Append ("t");  		break;  	case 10:  		sb.Append ("T");  		break;  	case 11:  		sb.Append ("d");  		break;  	case 12:  		sb.Append ("w");  		break;  	case 13:  		sb.Append ("W");  		break;  	case 14:  		sb.Append ("c");  		break;  	case 15:  		sb.Append ("z");  		break;  	case 16:  		sb.Append ("x");  		break;  	case 17:  		sb.Append ("v");  		break;  	case 18:  		sb.Append ("g");  		break;  	}  	switch (b) {  	case 0:  		sb.Append ("k");  		break;  	case 1:  		sb.Append ("o");  		break;  	case 2:  		sb.Append ("i");  		break;  	case 3:  		sb.Append ("O");  		break;  	case 4:  		sb.Append ("j");  		break;  	case 5:  		sb.Append ("p");  		break;  	case 6:  		sb.Append ("u");  		break;  	case 7:  		sb.Append ("P");  		break;  	case 8:  		sb.Append ("h");  		break;  	case 9:  		sb.Append ("hk");  		break;  	case 10:  		sb.Append ("ho");  		break;  	case 11:  		sb.Append ("hl");  		break;  	case 12:  		sb.Append ("y");  		break;  	case 13:  		sb.Append ("n");  		break;  	case 14:  		sb.Append ("nj");  		break;  	case 15:  		sb.Append ("np");  		break;  	case 16:  		sb.Append ("nl");  		break;  	case 17:  		sb.Append ("b");  		break;  	case 18:  		sb.Append ("m");  		break;  	case 19:  		sb.Append ("ml");  		break;  	case 20:  		sb.Append ("l");  		break;  	}  	switch (c) {  	case 1:  		sb.Append ("r");  		break;  	case 2:  		sb.Append ("R");  		break;  	case 3:  		sb.Append ("rt");  		break;  	case 4:  		sb.Append ("s");  		break;  	case 5:  		sb.Append ("sw");  		break;  	case 6:  		sb.Append ("sg");  		break;  	case 7:  		sb.Append ("e");  		break;  	case 8:  		sb.Append ("f");  		break;  	case 9:  		sb.Append ("fr");  		break;  	case 10:  		sb.Append ("fa");  		break;  	case 11:  		sb.Append ("fq");  		break;  	case 12:  		sb.Append ("ft");  		break;  	case 13:  		sb.Append ("fx");  		break;  	case 14:  		sb.Append ("fv");  		break;  	case 15:  		sb.Append ("fg");  		break;  	case 16:  		sb.Append ("a");  		break;  	case 17:  		sb.Append ("q");  		break;  	case 18:  		sb.Append ("qt");  		break;  	case 19:  		sb.Append ("t");  		break;  	case 20:  		sb.Append ("T");  		break;  	case 21:  		sb.Append ("d");  		break;  	case 22:  		sb.Append ("w");  		break;  	case 23:  		sb.Append ("c");  		break;  	case 24:  		sb.Append ("z");  		break;  	case 25:  		sb.Append ("x");  		break;  	case 26:  		sb.Append ("v");  		break;  	case 27:  		sb.Append ("g");  		break;  	}  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,ReverseIME,The following statement contains a magic number: foreach (char ch in str.ToCharArray ()) {  	if (ch < 44032 || ch > 55203)// out of range  	 {  		sb.Append (ch);  		continue;  	}  	int a = 0;  	int b = 0;  	int c = 0;  	for (int i = ch - 44032; i >= 588; i -= 588' ++a)  		;  	for (int i = ch - a * 588 - 44032; i >= 28; i -= 28' ++b)  		;  	c = ch - a * 588 - b * 28 - 44032;  	switch (a) {  	case 0:  		sb.Append ("r");  		break;  	case 1:  		sb.Append ("R");  		break;  	case 2:  		sb.Append ("s");  		break;  	case 3:  		sb.Append ("e");  		break;  	case 4:  		sb.Append ("E");  		break;  	case 5:  		sb.Append ("f");  		break;  	case 6:  		sb.Append ("a");  		break;  	case 7:  		sb.Append ("q");  		break;  	case 8:  		sb.Append ("Q");  		break;  	case 9:  		sb.Append ("t");  		break;  	case 10:  		sb.Append ("T");  		break;  	case 11:  		sb.Append ("d");  		break;  	case 12:  		sb.Append ("w");  		break;  	case 13:  		sb.Append ("W");  		break;  	case 14:  		sb.Append ("c");  		break;  	case 15:  		sb.Append ("z");  		break;  	case 16:  		sb.Append ("x");  		break;  	case 17:  		sb.Append ("v");  		break;  	case 18:  		sb.Append ("g");  		break;  	}  	switch (b) {  	case 0:  		sb.Append ("k");  		break;  	case 1:  		sb.Append ("o");  		break;  	case 2:  		sb.Append ("i");  		break;  	case 3:  		sb.Append ("O");  		break;  	case 4:  		sb.Append ("j");  		break;  	case 5:  		sb.Append ("p");  		break;  	case 6:  		sb.Append ("u");  		break;  	case 7:  		sb.Append ("P");  		break;  	case 8:  		sb.Append ("h");  		break;  	case 9:  		sb.Append ("hk");  		break;  	case 10:  		sb.Append ("ho");  		break;  	case 11:  		sb.Append ("hl");  		break;  	case 12:  		sb.Append ("y");  		break;  	case 13:  		sb.Append ("n");  		break;  	case 14:  		sb.Append ("nj");  		break;  	case 15:  		sb.Append ("np");  		break;  	case 16:  		sb.Append ("nl");  		break;  	case 17:  		sb.Append ("b");  		break;  	case 18:  		sb.Append ("m");  		break;  	case 19:  		sb.Append ("ml");  		break;  	case 20:  		sb.Append ("l");  		break;  	}  	switch (c) {  	case 1:  		sb.Append ("r");  		break;  	case 2:  		sb.Append ("R");  		break;  	case 3:  		sb.Append ("rt");  		break;  	case 4:  		sb.Append ("s");  		break;  	case 5:  		sb.Append ("sw");  		break;  	case 6:  		sb.Append ("sg");  		break;  	case 7:  		sb.Append ("e");  		break;  	case 8:  		sb.Append ("f");  		break;  	case 9:  		sb.Append ("fr");  		break;  	case 10:  		sb.Append ("fa");  		break;  	case 11:  		sb.Append ("fq");  		break;  	case 12:  		sb.Append ("ft");  		break;  	case 13:  		sb.Append ("fx");  		break;  	case 14:  		sb.Append ("fv");  		break;  	case 15:  		sb.Append ("fg");  		break;  	case 16:  		sb.Append ("a");  		break;  	case 17:  		sb.Append ("q");  		break;  	case 18:  		sb.Append ("qt");  		break;  	case 19:  		sb.Append ("t");  		break;  	case 20:  		sb.Append ("T");  		break;  	case 21:  		sb.Append ("d");  		break;  	case 22:  		sb.Append ("w");  		break;  	case 23:  		sb.Append ("c");  		break;  	case 24:  		sb.Append ("z");  		break;  	case 25:  		sb.Append ("x");  		break;  	case 26:  		sb.Append ("v");  		break;  	case 27:  		sb.Append ("g");  		break;  	}  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,ReverseIME,The following statement contains a magic number: foreach (char ch in str.ToCharArray ()) {  	if (ch < 44032 || ch > 55203)// out of range  	 {  		sb.Append (ch);  		continue;  	}  	int a = 0;  	int b = 0;  	int c = 0;  	for (int i = ch - 44032; i >= 588; i -= 588' ++a)  		;  	for (int i = ch - a * 588 - 44032; i >= 28; i -= 28' ++b)  		;  	c = ch - a * 588 - b * 28 - 44032;  	switch (a) {  	case 0:  		sb.Append ("r");  		break;  	case 1:  		sb.Append ("R");  		break;  	case 2:  		sb.Append ("s");  		break;  	case 3:  		sb.Append ("e");  		break;  	case 4:  		sb.Append ("E");  		break;  	case 5:  		sb.Append ("f");  		break;  	case 6:  		sb.Append ("a");  		break;  	case 7:  		sb.Append ("q");  		break;  	case 8:  		sb.Append ("Q");  		break;  	case 9:  		sb.Append ("t");  		break;  	case 10:  		sb.Append ("T");  		break;  	case 11:  		sb.Append ("d");  		break;  	case 12:  		sb.Append ("w");  		break;  	case 13:  		sb.Append ("W");  		break;  	case 14:  		sb.Append ("c");  		break;  	case 15:  		sb.Append ("z");  		break;  	case 16:  		sb.Append ("x");  		break;  	case 17:  		sb.Append ("v");  		break;  	case 18:  		sb.Append ("g");  		break;  	}  	switch (b) {  	case 0:  		sb.Append ("k");  		break;  	case 1:  		sb.Append ("o");  		break;  	case 2:  		sb.Append ("i");  		break;  	case 3:  		sb.Append ("O");  		break;  	case 4:  		sb.Append ("j");  		break;  	case 5:  		sb.Append ("p");  		break;  	case 6:  		sb.Append ("u");  		break;  	case 7:  		sb.Append ("P");  		break;  	case 8:  		sb.Append ("h");  		break;  	case 9:  		sb.Append ("hk");  		break;  	case 10:  		sb.Append ("ho");  		break;  	case 11:  		sb.Append ("hl");  		break;  	case 12:  		sb.Append ("y");  		break;  	case 13:  		sb.Append ("n");  		break;  	case 14:  		sb.Append ("nj");  		break;  	case 15:  		sb.Append ("np");  		break;  	case 16:  		sb.Append ("nl");  		break;  	case 17:  		sb.Append ("b");  		break;  	case 18:  		sb.Append ("m");  		break;  	case 19:  		sb.Append ("ml");  		break;  	case 20:  		sb.Append ("l");  		break;  	}  	switch (c) {  	case 1:  		sb.Append ("r");  		break;  	case 2:  		sb.Append ("R");  		break;  	case 3:  		sb.Append ("rt");  		break;  	case 4:  		sb.Append ("s");  		break;  	case 5:  		sb.Append ("sw");  		break;  	case 6:  		sb.Append ("sg");  		break;  	case 7:  		sb.Append ("e");  		break;  	case 8:  		sb.Append ("f");  		break;  	case 9:  		sb.Append ("fr");  		break;  	case 10:  		sb.Append ("fa");  		break;  	case 11:  		sb.Append ("fq");  		break;  	case 12:  		sb.Append ("ft");  		break;  	case 13:  		sb.Append ("fx");  		break;  	case 14:  		sb.Append ("fv");  		break;  	case 15:  		sb.Append ("fg");  		break;  	case 16:  		sb.Append ("a");  		break;  	case 17:  		sb.Append ("q");  		break;  	case 18:  		sb.Append ("qt");  		break;  	case 19:  		sb.Append ("t");  		break;  	case 20:  		sb.Append ("T");  		break;  	case 21:  		sb.Append ("d");  		break;  	case 22:  		sb.Append ("w");  		break;  	case 23:  		sb.Append ("c");  		break;  	case 24:  		sb.Append ("z");  		break;  	case 25:  		sb.Append ("x");  		break;  	case 26:  		sb.Append ("v");  		break;  	case 27:  		sb.Append ("g");  		break;  	}  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,ReverseIME,The following statement contains a magic number: foreach (char ch in str.ToCharArray ()) {  	if (ch < 44032 || ch > 55203)// out of range  	 {  		sb.Append (ch);  		continue;  	}  	int a = 0;  	int b = 0;  	int c = 0;  	for (int i = ch - 44032; i >= 588; i -= 588' ++a)  		;  	for (int i = ch - a * 588 - 44032; i >= 28; i -= 28' ++b)  		;  	c = ch - a * 588 - b * 28 - 44032;  	switch (a) {  	case 0:  		sb.Append ("r");  		break;  	case 1:  		sb.Append ("R");  		break;  	case 2:  		sb.Append ("s");  		break;  	case 3:  		sb.Append ("e");  		break;  	case 4:  		sb.Append ("E");  		break;  	case 5:  		sb.Append ("f");  		break;  	case 6:  		sb.Append ("a");  		break;  	case 7:  		sb.Append ("q");  		break;  	case 8:  		sb.Append ("Q");  		break;  	case 9:  		sb.Append ("t");  		break;  	case 10:  		sb.Append ("T");  		break;  	case 11:  		sb.Append ("d");  		break;  	case 12:  		sb.Append ("w");  		break;  	case 13:  		sb.Append ("W");  		break;  	case 14:  		sb.Append ("c");  		break;  	case 15:  		sb.Append ("z");  		break;  	case 16:  		sb.Append ("x");  		break;  	case 17:  		sb.Append ("v");  		break;  	case 18:  		sb.Append ("g");  		break;  	}  	switch (b) {  	case 0:  		sb.Append ("k");  		break;  	case 1:  		sb.Append ("o");  		break;  	case 2:  		sb.Append ("i");  		break;  	case 3:  		sb.Append ("O");  		break;  	case 4:  		sb.Append ("j");  		break;  	case 5:  		sb.Append ("p");  		break;  	case 6:  		sb.Append ("u");  		break;  	case 7:  		sb.Append ("P");  		break;  	case 8:  		sb.Append ("h");  		break;  	case 9:  		sb.Append ("hk");  		break;  	case 10:  		sb.Append ("ho");  		break;  	case 11:  		sb.Append ("hl");  		break;  	case 12:  		sb.Append ("y");  		break;  	case 13:  		sb.Append ("n");  		break;  	case 14:  		sb.Append ("nj");  		break;  	case 15:  		sb.Append ("np");  		break;  	case 16:  		sb.Append ("nl");  		break;  	case 17:  		sb.Append ("b");  		break;  	case 18:  		sb.Append ("m");  		break;  	case 19:  		sb.Append ("ml");  		break;  	case 20:  		sb.Append ("l");  		break;  	}  	switch (c) {  	case 1:  		sb.Append ("r");  		break;  	case 2:  		sb.Append ("R");  		break;  	case 3:  		sb.Append ("rt");  		break;  	case 4:  		sb.Append ("s");  		break;  	case 5:  		sb.Append ("sw");  		break;  	case 6:  		sb.Append ("sg");  		break;  	case 7:  		sb.Append ("e");  		break;  	case 8:  		sb.Append ("f");  		break;  	case 9:  		sb.Append ("fr");  		break;  	case 10:  		sb.Append ("fa");  		break;  	case 11:  		sb.Append ("fq");  		break;  	case 12:  		sb.Append ("ft");  		break;  	case 13:  		sb.Append ("fx");  		break;  	case 14:  		sb.Append ("fv");  		break;  	case 15:  		sb.Append ("fg");  		break;  	case 16:  		sb.Append ("a");  		break;  	case 17:  		sb.Append ("q");  		break;  	case 18:  		sb.Append ("qt");  		break;  	case 19:  		sb.Append ("t");  		break;  	case 20:  		sb.Append ("T");  		break;  	case 21:  		sb.Append ("d");  		break;  	case 22:  		sb.Append ("w");  		break;  	case 23:  		sb.Append ("c");  		break;  	case 24:  		sb.Append ("z");  		break;  	case 25:  		sb.Append ("x");  		break;  	case 26:  		sb.Append ("v");  		break;  	case 27:  		sb.Append ("g");  		break;  	}  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,ReverseIME,The following statement contains a magic number: foreach (char ch in str.ToCharArray ()) {  	if (ch < 44032 || ch > 55203)// out of range  	 {  		sb.Append (ch);  		continue;  	}  	int a = 0;  	int b = 0;  	int c = 0;  	for (int i = ch - 44032; i >= 588; i -= 588' ++a)  		;  	for (int i = ch - a * 588 - 44032; i >= 28; i -= 28' ++b)  		;  	c = ch - a * 588 - b * 28 - 44032;  	switch (a) {  	case 0:  		sb.Append ("r");  		break;  	case 1:  		sb.Append ("R");  		break;  	case 2:  		sb.Append ("s");  		break;  	case 3:  		sb.Append ("e");  		break;  	case 4:  		sb.Append ("E");  		break;  	case 5:  		sb.Append ("f");  		break;  	case 6:  		sb.Append ("a");  		break;  	case 7:  		sb.Append ("q");  		break;  	case 8:  		sb.Append ("Q");  		break;  	case 9:  		sb.Append ("t");  		break;  	case 10:  		sb.Append ("T");  		break;  	case 11:  		sb.Append ("d");  		break;  	case 12:  		sb.Append ("w");  		break;  	case 13:  		sb.Append ("W");  		break;  	case 14:  		sb.Append ("c");  		break;  	case 15:  		sb.Append ("z");  		break;  	case 16:  		sb.Append ("x");  		break;  	case 17:  		sb.Append ("v");  		break;  	case 18:  		sb.Append ("g");  		break;  	}  	switch (b) {  	case 0:  		sb.Append ("k");  		break;  	case 1:  		sb.Append ("o");  		break;  	case 2:  		sb.Append ("i");  		break;  	case 3:  		sb.Append ("O");  		break;  	case 4:  		sb.Append ("j");  		break;  	case 5:  		sb.Append ("p");  		break;  	case 6:  		sb.Append ("u");  		break;  	case 7:  		sb.Append ("P");  		break;  	case 8:  		sb.Append ("h");  		break;  	case 9:  		sb.Append ("hk");  		break;  	case 10:  		sb.Append ("ho");  		break;  	case 11:  		sb.Append ("hl");  		break;  	case 12:  		sb.Append ("y");  		break;  	case 13:  		sb.Append ("n");  		break;  	case 14:  		sb.Append ("nj");  		break;  	case 15:  		sb.Append ("np");  		break;  	case 16:  		sb.Append ("nl");  		break;  	case 17:  		sb.Append ("b");  		break;  	case 18:  		sb.Append ("m");  		break;  	case 19:  		sb.Append ("ml");  		break;  	case 20:  		sb.Append ("l");  		break;  	}  	switch (c) {  	case 1:  		sb.Append ("r");  		break;  	case 2:  		sb.Append ("R");  		break;  	case 3:  		sb.Append ("rt");  		break;  	case 4:  		sb.Append ("s");  		break;  	case 5:  		sb.Append ("sw");  		break;  	case 6:  		sb.Append ("sg");  		break;  	case 7:  		sb.Append ("e");  		break;  	case 8:  		sb.Append ("f");  		break;  	case 9:  		sb.Append ("fr");  		break;  	case 10:  		sb.Append ("fa");  		break;  	case 11:  		sb.Append ("fq");  		break;  	case 12:  		sb.Append ("ft");  		break;  	case 13:  		sb.Append ("fx");  		break;  	case 14:  		sb.Append ("fv");  		break;  	case 15:  		sb.Append ("fg");  		break;  	case 16:  		sb.Append ("a");  		break;  	case 17:  		sb.Append ("q");  		break;  	case 18:  		sb.Append ("qt");  		break;  	case 19:  		sb.Append ("t");  		break;  	case 20:  		sb.Append ("T");  		break;  	case 21:  		sb.Append ("d");  		break;  	case 22:  		sb.Append ("w");  		break;  	case 23:  		sb.Append ("c");  		break;  	case 24:  		sb.Append ("z");  		break;  	case 25:  		sb.Append ("x");  		break;  	case 26:  		sb.Append ("v");  		break;  	case 27:  		sb.Append ("g");  		break;  	}  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,ReverseIME,The following statement contains a magic number: foreach (char ch in str.ToCharArray ()) {  	if (ch < 44032 || ch > 55203)// out of range  	 {  		sb.Append (ch);  		continue;  	}  	int a = 0;  	int b = 0;  	int c = 0;  	for (int i = ch - 44032; i >= 588; i -= 588' ++a)  		;  	for (int i = ch - a * 588 - 44032; i >= 28; i -= 28' ++b)  		;  	c = ch - a * 588 - b * 28 - 44032;  	switch (a) {  	case 0:  		sb.Append ("r");  		break;  	case 1:  		sb.Append ("R");  		break;  	case 2:  		sb.Append ("s");  		break;  	case 3:  		sb.Append ("e");  		break;  	case 4:  		sb.Append ("E");  		break;  	case 5:  		sb.Append ("f");  		break;  	case 6:  		sb.Append ("a");  		break;  	case 7:  		sb.Append ("q");  		break;  	case 8:  		sb.Append ("Q");  		break;  	case 9:  		sb.Append ("t");  		break;  	case 10:  		sb.Append ("T");  		break;  	case 11:  		sb.Append ("d");  		break;  	case 12:  		sb.Append ("w");  		break;  	case 13:  		sb.Append ("W");  		break;  	case 14:  		sb.Append ("c");  		break;  	case 15:  		sb.Append ("z");  		break;  	case 16:  		sb.Append ("x");  		break;  	case 17:  		sb.Append ("v");  		break;  	case 18:  		sb.Append ("g");  		break;  	}  	switch (b) {  	case 0:  		sb.Append ("k");  		break;  	case 1:  		sb.Append ("o");  		break;  	case 2:  		sb.Append ("i");  		break;  	case 3:  		sb.Append ("O");  		break;  	case 4:  		sb.Append ("j");  		break;  	case 5:  		sb.Append ("p");  		break;  	case 6:  		sb.Append ("u");  		break;  	case 7:  		sb.Append ("P");  		break;  	case 8:  		sb.Append ("h");  		break;  	case 9:  		sb.Append ("hk");  		break;  	case 10:  		sb.Append ("ho");  		break;  	case 11:  		sb.Append ("hl");  		break;  	case 12:  		sb.Append ("y");  		break;  	case 13:  		sb.Append ("n");  		break;  	case 14:  		sb.Append ("nj");  		break;  	case 15:  		sb.Append ("np");  		break;  	case 16:  		sb.Append ("nl");  		break;  	case 17:  		sb.Append ("b");  		break;  	case 18:  		sb.Append ("m");  		break;  	case 19:  		sb.Append ("ml");  		break;  	case 20:  		sb.Append ("l");  		break;  	}  	switch (c) {  	case 1:  		sb.Append ("r");  		break;  	case 2:  		sb.Append ("R");  		break;  	case 3:  		sb.Append ("rt");  		break;  	case 4:  		sb.Append ("s");  		break;  	case 5:  		sb.Append ("sw");  		break;  	case 6:  		sb.Append ("sg");  		break;  	case 7:  		sb.Append ("e");  		break;  	case 8:  		sb.Append ("f");  		break;  	case 9:  		sb.Append ("fr");  		break;  	case 10:  		sb.Append ("fa");  		break;  	case 11:  		sb.Append ("fq");  		break;  	case 12:  		sb.Append ("ft");  		break;  	case 13:  		sb.Append ("fx");  		break;  	case 14:  		sb.Append ("fv");  		break;  	case 15:  		sb.Append ("fg");  		break;  	case 16:  		sb.Append ("a");  		break;  	case 17:  		sb.Append ("q");  		break;  	case 18:  		sb.Append ("qt");  		break;  	case 19:  		sb.Append ("t");  		break;  	case 20:  		sb.Append ("T");  		break;  	case 21:  		sb.Append ("d");  		break;  	case 22:  		sb.Append ("w");  		break;  	case 23:  		sb.Append ("c");  		break;  	case 24:  		sb.Append ("z");  		break;  	case 25:  		sb.Append ("x");  		break;  	case 26:  		sb.Append ("v");  		break;  	case 27:  		sb.Append ("g");  		break;  	}  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,ReverseIME,The following statement contains a magic number: foreach (char ch in str.ToCharArray ()) {  	if (ch < 44032 || ch > 55203)// out of range  	 {  		sb.Append (ch);  		continue;  	}  	int a = 0;  	int b = 0;  	int c = 0;  	for (int i = ch - 44032; i >= 588; i -= 588' ++a)  		;  	for (int i = ch - a * 588 - 44032; i >= 28; i -= 28' ++b)  		;  	c = ch - a * 588 - b * 28 - 44032;  	switch (a) {  	case 0:  		sb.Append ("r");  		break;  	case 1:  		sb.Append ("R");  		break;  	case 2:  		sb.Append ("s");  		break;  	case 3:  		sb.Append ("e");  		break;  	case 4:  		sb.Append ("E");  		break;  	case 5:  		sb.Append ("f");  		break;  	case 6:  		sb.Append ("a");  		break;  	case 7:  		sb.Append ("q");  		break;  	case 8:  		sb.Append ("Q");  		break;  	case 9:  		sb.Append ("t");  		break;  	case 10:  		sb.Append ("T");  		break;  	case 11:  		sb.Append ("d");  		break;  	case 12:  		sb.Append ("w");  		break;  	case 13:  		sb.Append ("W");  		break;  	case 14:  		sb.Append ("c");  		break;  	case 15:  		sb.Append ("z");  		break;  	case 16:  		sb.Append ("x");  		break;  	case 17:  		sb.Append ("v");  		break;  	case 18:  		sb.Append ("g");  		break;  	}  	switch (b) {  	case 0:  		sb.Append ("k");  		break;  	case 1:  		sb.Append ("o");  		break;  	case 2:  		sb.Append ("i");  		break;  	case 3:  		sb.Append ("O");  		break;  	case 4:  		sb.Append ("j");  		break;  	case 5:  		sb.Append ("p");  		break;  	case 6:  		sb.Append ("u");  		break;  	case 7:  		sb.Append ("P");  		break;  	case 8:  		sb.Append ("h");  		break;  	case 9:  		sb.Append ("hk");  		break;  	case 10:  		sb.Append ("ho");  		break;  	case 11:  		sb.Append ("hl");  		break;  	case 12:  		sb.Append ("y");  		break;  	case 13:  		sb.Append ("n");  		break;  	case 14:  		sb.Append ("nj");  		break;  	case 15:  		sb.Append ("np");  		break;  	case 16:  		sb.Append ("nl");  		break;  	case 17:  		sb.Append ("b");  		break;  	case 18:  		sb.Append ("m");  		break;  	case 19:  		sb.Append ("ml");  		break;  	case 20:  		sb.Append ("l");  		break;  	}  	switch (c) {  	case 1:  		sb.Append ("r");  		break;  	case 2:  		sb.Append ("R");  		break;  	case 3:  		sb.Append ("rt");  		break;  	case 4:  		sb.Append ("s");  		break;  	case 5:  		sb.Append ("sw");  		break;  	case 6:  		sb.Append ("sg");  		break;  	case 7:  		sb.Append ("e");  		break;  	case 8:  		sb.Append ("f");  		break;  	case 9:  		sb.Append ("fr");  		break;  	case 10:  		sb.Append ("fa");  		break;  	case 11:  		sb.Append ("fq");  		break;  	case 12:  		sb.Append ("ft");  		break;  	case 13:  		sb.Append ("fx");  		break;  	case 14:  		sb.Append ("fv");  		break;  	case 15:  		sb.Append ("fg");  		break;  	case 16:  		sb.Append ("a");  		break;  	case 17:  		sb.Append ("q");  		break;  	case 18:  		sb.Append ("qt");  		break;  	case 19:  		sb.Append ("t");  		break;  	case 20:  		sb.Append ("T");  		break;  	case 21:  		sb.Append ("d");  		break;  	case 22:  		sb.Append ("w");  		break;  	case 23:  		sb.Append ("c");  		break;  	case 24:  		sb.Append ("z");  		break;  	case 25:  		sb.Append ("x");  		break;  	case 26:  		sb.Append ("v");  		break;  	case 27:  		sb.Append ("g");  		break;  	}  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,ReverseIME,The following statement contains a magic number: foreach (char ch in str.ToCharArray ()) {  	if (ch < 44032 || ch > 55203)// out of range  	 {  		sb.Append (ch);  		continue;  	}  	int a = 0;  	int b = 0;  	int c = 0;  	for (int i = ch - 44032; i >= 588; i -= 588' ++a)  		;  	for (int i = ch - a * 588 - 44032; i >= 28; i -= 28' ++b)  		;  	c = ch - a * 588 - b * 28 - 44032;  	switch (a) {  	case 0:  		sb.Append ("r");  		break;  	case 1:  		sb.Append ("R");  		break;  	case 2:  		sb.Append ("s");  		break;  	case 3:  		sb.Append ("e");  		break;  	case 4:  		sb.Append ("E");  		break;  	case 5:  		sb.Append ("f");  		break;  	case 6:  		sb.Append ("a");  		break;  	case 7:  		sb.Append ("q");  		break;  	case 8:  		sb.Append ("Q");  		break;  	case 9:  		sb.Append ("t");  		break;  	case 10:  		sb.Append ("T");  		break;  	case 11:  		sb.Append ("d");  		break;  	case 12:  		sb.Append ("w");  		break;  	case 13:  		sb.Append ("W");  		break;  	case 14:  		sb.Append ("c");  		break;  	case 15:  		sb.Append ("z");  		break;  	case 16:  		sb.Append ("x");  		break;  	case 17:  		sb.Append ("v");  		break;  	case 18:  		sb.Append ("g");  		break;  	}  	switch (b) {  	case 0:  		sb.Append ("k");  		break;  	case 1:  		sb.Append ("o");  		break;  	case 2:  		sb.Append ("i");  		break;  	case 3:  		sb.Append ("O");  		break;  	case 4:  		sb.Append ("j");  		break;  	case 5:  		sb.Append ("p");  		break;  	case 6:  		sb.Append ("u");  		break;  	case 7:  		sb.Append ("P");  		break;  	case 8:  		sb.Append ("h");  		break;  	case 9:  		sb.Append ("hk");  		break;  	case 10:  		sb.Append ("ho");  		break;  	case 11:  		sb.Append ("hl");  		break;  	case 12:  		sb.Append ("y");  		break;  	case 13:  		sb.Append ("n");  		break;  	case 14:  		sb.Append ("nj");  		break;  	case 15:  		sb.Append ("np");  		break;  	case 16:  		sb.Append ("nl");  		break;  	case 17:  		sb.Append ("b");  		break;  	case 18:  		sb.Append ("m");  		break;  	case 19:  		sb.Append ("ml");  		break;  	case 20:  		sb.Append ("l");  		break;  	}  	switch (c) {  	case 1:  		sb.Append ("r");  		break;  	case 2:  		sb.Append ("R");  		break;  	case 3:  		sb.Append ("rt");  		break;  	case 4:  		sb.Append ("s");  		break;  	case 5:  		sb.Append ("sw");  		break;  	case 6:  		sb.Append ("sg");  		break;  	case 7:  		sb.Append ("e");  		break;  	case 8:  		sb.Append ("f");  		break;  	case 9:  		sb.Append ("fr");  		break;  	case 10:  		sb.Append ("fa");  		break;  	case 11:  		sb.Append ("fq");  		break;  	case 12:  		sb.Append ("ft");  		break;  	case 13:  		sb.Append ("fx");  		break;  	case 14:  		sb.Append ("fv");  		break;  	case 15:  		sb.Append ("fg");  		break;  	case 16:  		sb.Append ("a");  		break;  	case 17:  		sb.Append ("q");  		break;  	case 18:  		sb.Append ("qt");  		break;  	case 19:  		sb.Append ("t");  		break;  	case 20:  		sb.Append ("T");  		break;  	case 21:  		sb.Append ("d");  		break;  	case 22:  		sb.Append ("w");  		break;  	case 23:  		sb.Append ("c");  		break;  	case 24:  		sb.Append ("z");  		break;  	case 25:  		sb.Append ("x");  		break;  	case 26:  		sb.Append ("v");  		break;  	case 27:  		sb.Append ("g");  		break;  	}  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,ReverseIME,The following statement contains a magic number: foreach (char ch in str.ToCharArray ()) {  	if (ch < 44032 || ch > 55203)// out of range  	 {  		sb.Append (ch);  		continue;  	}  	int a = 0;  	int b = 0;  	int c = 0;  	for (int i = ch - 44032; i >= 588; i -= 588' ++a)  		;  	for (int i = ch - a * 588 - 44032; i >= 28; i -= 28' ++b)  		;  	c = ch - a * 588 - b * 28 - 44032;  	switch (a) {  	case 0:  		sb.Append ("r");  		break;  	case 1:  		sb.Append ("R");  		break;  	case 2:  		sb.Append ("s");  		break;  	case 3:  		sb.Append ("e");  		break;  	case 4:  		sb.Append ("E");  		break;  	case 5:  		sb.Append ("f");  		break;  	case 6:  		sb.Append ("a");  		break;  	case 7:  		sb.Append ("q");  		break;  	case 8:  		sb.Append ("Q");  		break;  	case 9:  		sb.Append ("t");  		break;  	case 10:  		sb.Append ("T");  		break;  	case 11:  		sb.Append ("d");  		break;  	case 12:  		sb.Append ("w");  		break;  	case 13:  		sb.Append ("W");  		break;  	case 14:  		sb.Append ("c");  		break;  	case 15:  		sb.Append ("z");  		break;  	case 16:  		sb.Append ("x");  		break;  	case 17:  		sb.Append ("v");  		break;  	case 18:  		sb.Append ("g");  		break;  	}  	switch (b) {  	case 0:  		sb.Append ("k");  		break;  	case 1:  		sb.Append ("o");  		break;  	case 2:  		sb.Append ("i");  		break;  	case 3:  		sb.Append ("O");  		break;  	case 4:  		sb.Append ("j");  		break;  	case 5:  		sb.Append ("p");  		break;  	case 6:  		sb.Append ("u");  		break;  	case 7:  		sb.Append ("P");  		break;  	case 8:  		sb.Append ("h");  		break;  	case 9:  		sb.Append ("hk");  		break;  	case 10:  		sb.Append ("ho");  		break;  	case 11:  		sb.Append ("hl");  		break;  	case 12:  		sb.Append ("y");  		break;  	case 13:  		sb.Append ("n");  		break;  	case 14:  		sb.Append ("nj");  		break;  	case 15:  		sb.Append ("np");  		break;  	case 16:  		sb.Append ("nl");  		break;  	case 17:  		sb.Append ("b");  		break;  	case 18:  		sb.Append ("m");  		break;  	case 19:  		sb.Append ("ml");  		break;  	case 20:  		sb.Append ("l");  		break;  	}  	switch (c) {  	case 1:  		sb.Append ("r");  		break;  	case 2:  		sb.Append ("R");  		break;  	case 3:  		sb.Append ("rt");  		break;  	case 4:  		sb.Append ("s");  		break;  	case 5:  		sb.Append ("sw");  		break;  	case 6:  		sb.Append ("sg");  		break;  	case 7:  		sb.Append ("e");  		break;  	case 8:  		sb.Append ("f");  		break;  	case 9:  		sb.Append ("fr");  		break;  	case 10:  		sb.Append ("fa");  		break;  	case 11:  		sb.Append ("fq");  		break;  	case 12:  		sb.Append ("ft");  		break;  	case 13:  		sb.Append ("fx");  		break;  	case 14:  		sb.Append ("fv");  		break;  	case 15:  		sb.Append ("fg");  		break;  	case 16:  		sb.Append ("a");  		break;  	case 17:  		sb.Append ("q");  		break;  	case 18:  		sb.Append ("qt");  		break;  	case 19:  		sb.Append ("t");  		break;  	case 20:  		sb.Append ("T");  		break;  	case 21:  		sb.Append ("d");  		break;  	case 22:  		sb.Append ("w");  		break;  	case 23:  		sb.Append ("c");  		break;  	case 24:  		sb.Append ("z");  		break;  	case 25:  		sb.Append ("x");  		break;  	case 26:  		sb.Append ("v");  		break;  	case 27:  		sb.Append ("g");  		break;  	}  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,ReverseIME,The following statement contains a magic number: foreach (char ch in str.ToCharArray ()) {  	if (ch < 44032 || ch > 55203)// out of range  	 {  		sb.Append (ch);  		continue;  	}  	int a = 0;  	int b = 0;  	int c = 0;  	for (int i = ch - 44032; i >= 588; i -= 588' ++a)  		;  	for (int i = ch - a * 588 - 44032; i >= 28; i -= 28' ++b)  		;  	c = ch - a * 588 - b * 28 - 44032;  	switch (a) {  	case 0:  		sb.Append ("r");  		break;  	case 1:  		sb.Append ("R");  		break;  	case 2:  		sb.Append ("s");  		break;  	case 3:  		sb.Append ("e");  		break;  	case 4:  		sb.Append ("E");  		break;  	case 5:  		sb.Append ("f");  		break;  	case 6:  		sb.Append ("a");  		break;  	case 7:  		sb.Append ("q");  		break;  	case 8:  		sb.Append ("Q");  		break;  	case 9:  		sb.Append ("t");  		break;  	case 10:  		sb.Append ("T");  		break;  	case 11:  		sb.Append ("d");  		break;  	case 12:  		sb.Append ("w");  		break;  	case 13:  		sb.Append ("W");  		break;  	case 14:  		sb.Append ("c");  		break;  	case 15:  		sb.Append ("z");  		break;  	case 16:  		sb.Append ("x");  		break;  	case 17:  		sb.Append ("v");  		break;  	case 18:  		sb.Append ("g");  		break;  	}  	switch (b) {  	case 0:  		sb.Append ("k");  		break;  	case 1:  		sb.Append ("o");  		break;  	case 2:  		sb.Append ("i");  		break;  	case 3:  		sb.Append ("O");  		break;  	case 4:  		sb.Append ("j");  		break;  	case 5:  		sb.Append ("p");  		break;  	case 6:  		sb.Append ("u");  		break;  	case 7:  		sb.Append ("P");  		break;  	case 8:  		sb.Append ("h");  		break;  	case 9:  		sb.Append ("hk");  		break;  	case 10:  		sb.Append ("ho");  		break;  	case 11:  		sb.Append ("hl");  		break;  	case 12:  		sb.Append ("y");  		break;  	case 13:  		sb.Append ("n");  		break;  	case 14:  		sb.Append ("nj");  		break;  	case 15:  		sb.Append ("np");  		break;  	case 16:  		sb.Append ("nl");  		break;  	case 17:  		sb.Append ("b");  		break;  	case 18:  		sb.Append ("m");  		break;  	case 19:  		sb.Append ("ml");  		break;  	case 20:  		sb.Append ("l");  		break;  	}  	switch (c) {  	case 1:  		sb.Append ("r");  		break;  	case 2:  		sb.Append ("R");  		break;  	case 3:  		sb.Append ("rt");  		break;  	case 4:  		sb.Append ("s");  		break;  	case 5:  		sb.Append ("sw");  		break;  	case 6:  		sb.Append ("sg");  		break;  	case 7:  		sb.Append ("e");  		break;  	case 8:  		sb.Append ("f");  		break;  	case 9:  		sb.Append ("fr");  		break;  	case 10:  		sb.Append ("fa");  		break;  	case 11:  		sb.Append ("fq");  		break;  	case 12:  		sb.Append ("ft");  		break;  	case 13:  		sb.Append ("fx");  		break;  	case 14:  		sb.Append ("fv");  		break;  	case 15:  		sb.Append ("fg");  		break;  	case 16:  		sb.Append ("a");  		break;  	case 17:  		sb.Append ("q");  		break;  	case 18:  		sb.Append ("qt");  		break;  	case 19:  		sb.Append ("t");  		break;  	case 20:  		sb.Append ("T");  		break;  	case 21:  		sb.Append ("d");  		break;  	case 22:  		sb.Append ("w");  		break;  	case 23:  		sb.Append ("c");  		break;  	case 24:  		sb.Append ("z");  		break;  	case 25:  		sb.Append ("x");  		break;  	case 26:  		sb.Append ("v");  		break;  	case 27:  		sb.Append ("g");  		break;  	}  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,ReverseIME,The following statement contains a magic number: foreach (char ch in str.ToCharArray ()) {  	if (ch < 44032 || ch > 55203)// out of range  	 {  		sb.Append (ch);  		continue;  	}  	int a = 0;  	int b = 0;  	int c = 0;  	for (int i = ch - 44032; i >= 588; i -= 588' ++a)  		;  	for (int i = ch - a * 588 - 44032; i >= 28; i -= 28' ++b)  		;  	c = ch - a * 588 - b * 28 - 44032;  	switch (a) {  	case 0:  		sb.Append ("r");  		break;  	case 1:  		sb.Append ("R");  		break;  	case 2:  		sb.Append ("s");  		break;  	case 3:  		sb.Append ("e");  		break;  	case 4:  		sb.Append ("E");  		break;  	case 5:  		sb.Append ("f");  		break;  	case 6:  		sb.Append ("a");  		break;  	case 7:  		sb.Append ("q");  		break;  	case 8:  		sb.Append ("Q");  		break;  	case 9:  		sb.Append ("t");  		break;  	case 10:  		sb.Append ("T");  		break;  	case 11:  		sb.Append ("d");  		break;  	case 12:  		sb.Append ("w");  		break;  	case 13:  		sb.Append ("W");  		break;  	case 14:  		sb.Append ("c");  		break;  	case 15:  		sb.Append ("z");  		break;  	case 16:  		sb.Append ("x");  		break;  	case 17:  		sb.Append ("v");  		break;  	case 18:  		sb.Append ("g");  		break;  	}  	switch (b) {  	case 0:  		sb.Append ("k");  		break;  	case 1:  		sb.Append ("o");  		break;  	case 2:  		sb.Append ("i");  		break;  	case 3:  		sb.Append ("O");  		break;  	case 4:  		sb.Append ("j");  		break;  	case 5:  		sb.Append ("p");  		break;  	case 6:  		sb.Append ("u");  		break;  	case 7:  		sb.Append ("P");  		break;  	case 8:  		sb.Append ("h");  		break;  	case 9:  		sb.Append ("hk");  		break;  	case 10:  		sb.Append ("ho");  		break;  	case 11:  		sb.Append ("hl");  		break;  	case 12:  		sb.Append ("y");  		break;  	case 13:  		sb.Append ("n");  		break;  	case 14:  		sb.Append ("nj");  		break;  	case 15:  		sb.Append ("np");  		break;  	case 16:  		sb.Append ("nl");  		break;  	case 17:  		sb.Append ("b");  		break;  	case 18:  		sb.Append ("m");  		break;  	case 19:  		sb.Append ("ml");  		break;  	case 20:  		sb.Append ("l");  		break;  	}  	switch (c) {  	case 1:  		sb.Append ("r");  		break;  	case 2:  		sb.Append ("R");  		break;  	case 3:  		sb.Append ("rt");  		break;  	case 4:  		sb.Append ("s");  		break;  	case 5:  		sb.Append ("sw");  		break;  	case 6:  		sb.Append ("sg");  		break;  	case 7:  		sb.Append ("e");  		break;  	case 8:  		sb.Append ("f");  		break;  	case 9:  		sb.Append ("fr");  		break;  	case 10:  		sb.Append ("fa");  		break;  	case 11:  		sb.Append ("fq");  		break;  	case 12:  		sb.Append ("ft");  		break;  	case 13:  		sb.Append ("fx");  		break;  	case 14:  		sb.Append ("fv");  		break;  	case 15:  		sb.Append ("fg");  		break;  	case 16:  		sb.Append ("a");  		break;  	case 17:  		sb.Append ("q");  		break;  	case 18:  		sb.Append ("qt");  		break;  	case 19:  		sb.Append ("t");  		break;  	case 20:  		sb.Append ("T");  		break;  	case 21:  		sb.Append ("d");  		break;  	case 22:  		sb.Append ("w");  		break;  	case 23:  		sb.Append ("c");  		break;  	case 24:  		sb.Append ("z");  		break;  	case 25:  		sb.Append ("x");  		break;  	case 26:  		sb.Append ("v");  		break;  	case 27:  		sb.Append ("g");  		break;  	}  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,ReverseIME,The following statement contains a magic number: foreach (char ch in str.ToCharArray ()) {  	if (ch < 44032 || ch > 55203)// out of range  	 {  		sb.Append (ch);  		continue;  	}  	int a = 0;  	int b = 0;  	int c = 0;  	for (int i = ch - 44032; i >= 588; i -= 588' ++a)  		;  	for (int i = ch - a * 588 - 44032; i >= 28; i -= 28' ++b)  		;  	c = ch - a * 588 - b * 28 - 44032;  	switch (a) {  	case 0:  		sb.Append ("r");  		break;  	case 1:  		sb.Append ("R");  		break;  	case 2:  		sb.Append ("s");  		break;  	case 3:  		sb.Append ("e");  		break;  	case 4:  		sb.Append ("E");  		break;  	case 5:  		sb.Append ("f");  		break;  	case 6:  		sb.Append ("a");  		break;  	case 7:  		sb.Append ("q");  		break;  	case 8:  		sb.Append ("Q");  		break;  	case 9:  		sb.Append ("t");  		break;  	case 10:  		sb.Append ("T");  		break;  	case 11:  		sb.Append ("d");  		break;  	case 12:  		sb.Append ("w");  		break;  	case 13:  		sb.Append ("W");  		break;  	case 14:  		sb.Append ("c");  		break;  	case 15:  		sb.Append ("z");  		break;  	case 16:  		sb.Append ("x");  		break;  	case 17:  		sb.Append ("v");  		break;  	case 18:  		sb.Append ("g");  		break;  	}  	switch (b) {  	case 0:  		sb.Append ("k");  		break;  	case 1:  		sb.Append ("o");  		break;  	case 2:  		sb.Append ("i");  		break;  	case 3:  		sb.Append ("O");  		break;  	case 4:  		sb.Append ("j");  		break;  	case 5:  		sb.Append ("p");  		break;  	case 6:  		sb.Append ("u");  		break;  	case 7:  		sb.Append ("P");  		break;  	case 8:  		sb.Append ("h");  		break;  	case 9:  		sb.Append ("hk");  		break;  	case 10:  		sb.Append ("ho");  		break;  	case 11:  		sb.Append ("hl");  		break;  	case 12:  		sb.Append ("y");  		break;  	case 13:  		sb.Append ("n");  		break;  	case 14:  		sb.Append ("nj");  		break;  	case 15:  		sb.Append ("np");  		break;  	case 16:  		sb.Append ("nl");  		break;  	case 17:  		sb.Append ("b");  		break;  	case 18:  		sb.Append ("m");  		break;  	case 19:  		sb.Append ("ml");  		break;  	case 20:  		sb.Append ("l");  		break;  	}  	switch (c) {  	case 1:  		sb.Append ("r");  		break;  	case 2:  		sb.Append ("R");  		break;  	case 3:  		sb.Append ("rt");  		break;  	case 4:  		sb.Append ("s");  		break;  	case 5:  		sb.Append ("sw");  		break;  	case 6:  		sb.Append ("sg");  		break;  	case 7:  		sb.Append ("e");  		break;  	case 8:  		sb.Append ("f");  		break;  	case 9:  		sb.Append ("fr");  		break;  	case 10:  		sb.Append ("fa");  		break;  	case 11:  		sb.Append ("fq");  		break;  	case 12:  		sb.Append ("ft");  		break;  	case 13:  		sb.Append ("fx");  		break;  	case 14:  		sb.Append ("fv");  		break;  	case 15:  		sb.Append ("fg");  		break;  	case 16:  		sb.Append ("a");  		break;  	case 17:  		sb.Append ("q");  		break;  	case 18:  		sb.Append ("qt");  		break;  	case 19:  		sb.Append ("t");  		break;  	case 20:  		sb.Append ("T");  		break;  	case 21:  		sb.Append ("d");  		break;  	case 22:  		sb.Append ("w");  		break;  	case 23:  		sb.Append ("c");  		break;  	case 24:  		sb.Append ("z");  		break;  	case 25:  		sb.Append ("x");  		break;  	case 26:  		sb.Append ("v");  		break;  	case 27:  		sb.Append ("g");  		break;  	}  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,ReverseIME,The following statement contains a magic number: foreach (char ch in str.ToCharArray ()) {  	if (ch < 44032 || ch > 55203)// out of range  	 {  		sb.Append (ch);  		continue;  	}  	int a = 0;  	int b = 0;  	int c = 0;  	for (int i = ch - 44032; i >= 588; i -= 588' ++a)  		;  	for (int i = ch - a * 588 - 44032; i >= 28; i -= 28' ++b)  		;  	c = ch - a * 588 - b * 28 - 44032;  	switch (a) {  	case 0:  		sb.Append ("r");  		break;  	case 1:  		sb.Append ("R");  		break;  	case 2:  		sb.Append ("s");  		break;  	case 3:  		sb.Append ("e");  		break;  	case 4:  		sb.Append ("E");  		break;  	case 5:  		sb.Append ("f");  		break;  	case 6:  		sb.Append ("a");  		break;  	case 7:  		sb.Append ("q");  		break;  	case 8:  		sb.Append ("Q");  		break;  	case 9:  		sb.Append ("t");  		break;  	case 10:  		sb.Append ("T");  		break;  	case 11:  		sb.Append ("d");  		break;  	case 12:  		sb.Append ("w");  		break;  	case 13:  		sb.Append ("W");  		break;  	case 14:  		sb.Append ("c");  		break;  	case 15:  		sb.Append ("z");  		break;  	case 16:  		sb.Append ("x");  		break;  	case 17:  		sb.Append ("v");  		break;  	case 18:  		sb.Append ("g");  		break;  	}  	switch (b) {  	case 0:  		sb.Append ("k");  		break;  	case 1:  		sb.Append ("o");  		break;  	case 2:  		sb.Append ("i");  		break;  	case 3:  		sb.Append ("O");  		break;  	case 4:  		sb.Append ("j");  		break;  	case 5:  		sb.Append ("p");  		break;  	case 6:  		sb.Append ("u");  		break;  	case 7:  		sb.Append ("P");  		break;  	case 8:  		sb.Append ("h");  		break;  	case 9:  		sb.Append ("hk");  		break;  	case 10:  		sb.Append ("ho");  		break;  	case 11:  		sb.Append ("hl");  		break;  	case 12:  		sb.Append ("y");  		break;  	case 13:  		sb.Append ("n");  		break;  	case 14:  		sb.Append ("nj");  		break;  	case 15:  		sb.Append ("np");  		break;  	case 16:  		sb.Append ("nl");  		break;  	case 17:  		sb.Append ("b");  		break;  	case 18:  		sb.Append ("m");  		break;  	case 19:  		sb.Append ("ml");  		break;  	case 20:  		sb.Append ("l");  		break;  	}  	switch (c) {  	case 1:  		sb.Append ("r");  		break;  	case 2:  		sb.Append ("R");  		break;  	case 3:  		sb.Append ("rt");  		break;  	case 4:  		sb.Append ("s");  		break;  	case 5:  		sb.Append ("sw");  		break;  	case 6:  		sb.Append ("sg");  		break;  	case 7:  		sb.Append ("e");  		break;  	case 8:  		sb.Append ("f");  		break;  	case 9:  		sb.Append ("fr");  		break;  	case 10:  		sb.Append ("fa");  		break;  	case 11:  		sb.Append ("fq");  		break;  	case 12:  		sb.Append ("ft");  		break;  	case 13:  		sb.Append ("fx");  		break;  	case 14:  		sb.Append ("fv");  		break;  	case 15:  		sb.Append ("fg");  		break;  	case 16:  		sb.Append ("a");  		break;  	case 17:  		sb.Append ("q");  		break;  	case 18:  		sb.Append ("qt");  		break;  	case 19:  		sb.Append ("t");  		break;  	case 20:  		sb.Append ("T");  		break;  	case 21:  		sb.Append ("d");  		break;  	case 22:  		sb.Append ("w");  		break;  	case 23:  		sb.Append ("c");  		break;  	case 24:  		sb.Append ("z");  		break;  	case 25:  		sb.Append ("x");  		break;  	case 26:  		sb.Append ("v");  		break;  	case 27:  		sb.Append ("g");  		break;  	}  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,ReverseIME,The following statement contains a magic number: foreach (char ch in str.ToCharArray ()) {  	if (ch < 44032 || ch > 55203)// out of range  	 {  		sb.Append (ch);  		continue;  	}  	int a = 0;  	int b = 0;  	int c = 0;  	for (int i = ch - 44032; i >= 588; i -= 588' ++a)  		;  	for (int i = ch - a * 588 - 44032; i >= 28; i -= 28' ++b)  		;  	c = ch - a * 588 - b * 28 - 44032;  	switch (a) {  	case 0:  		sb.Append ("r");  		break;  	case 1:  		sb.Append ("R");  		break;  	case 2:  		sb.Append ("s");  		break;  	case 3:  		sb.Append ("e");  		break;  	case 4:  		sb.Append ("E");  		break;  	case 5:  		sb.Append ("f");  		break;  	case 6:  		sb.Append ("a");  		break;  	case 7:  		sb.Append ("q");  		break;  	case 8:  		sb.Append ("Q");  		break;  	case 9:  		sb.Append ("t");  		break;  	case 10:  		sb.Append ("T");  		break;  	case 11:  		sb.Append ("d");  		break;  	case 12:  		sb.Append ("w");  		break;  	case 13:  		sb.Append ("W");  		break;  	case 14:  		sb.Append ("c");  		break;  	case 15:  		sb.Append ("z");  		break;  	case 16:  		sb.Append ("x");  		break;  	case 17:  		sb.Append ("v");  		break;  	case 18:  		sb.Append ("g");  		break;  	}  	switch (b) {  	case 0:  		sb.Append ("k");  		break;  	case 1:  		sb.Append ("o");  		break;  	case 2:  		sb.Append ("i");  		break;  	case 3:  		sb.Append ("O");  		break;  	case 4:  		sb.Append ("j");  		break;  	case 5:  		sb.Append ("p");  		break;  	case 6:  		sb.Append ("u");  		break;  	case 7:  		sb.Append ("P");  		break;  	case 8:  		sb.Append ("h");  		break;  	case 9:  		sb.Append ("hk");  		break;  	case 10:  		sb.Append ("ho");  		break;  	case 11:  		sb.Append ("hl");  		break;  	case 12:  		sb.Append ("y");  		break;  	case 13:  		sb.Append ("n");  		break;  	case 14:  		sb.Append ("nj");  		break;  	case 15:  		sb.Append ("np");  		break;  	case 16:  		sb.Append ("nl");  		break;  	case 17:  		sb.Append ("b");  		break;  	case 18:  		sb.Append ("m");  		break;  	case 19:  		sb.Append ("ml");  		break;  	case 20:  		sb.Append ("l");  		break;  	}  	switch (c) {  	case 1:  		sb.Append ("r");  		break;  	case 2:  		sb.Append ("R");  		break;  	case 3:  		sb.Append ("rt");  		break;  	case 4:  		sb.Append ("s");  		break;  	case 5:  		sb.Append ("sw");  		break;  	case 6:  		sb.Append ("sg");  		break;  	case 7:  		sb.Append ("e");  		break;  	case 8:  		sb.Append ("f");  		break;  	case 9:  		sb.Append ("fr");  		break;  	case 10:  		sb.Append ("fa");  		break;  	case 11:  		sb.Append ("fq");  		break;  	case 12:  		sb.Append ("ft");  		break;  	case 13:  		sb.Append ("fx");  		break;  	case 14:  		sb.Append ("fv");  		break;  	case 15:  		sb.Append ("fg");  		break;  	case 16:  		sb.Append ("a");  		break;  	case 17:  		sb.Append ("q");  		break;  	case 18:  		sb.Append ("qt");  		break;  	case 19:  		sb.Append ("t");  		break;  	case 20:  		sb.Append ("T");  		break;  	case 21:  		sb.Append ("d");  		break;  	case 22:  		sb.Append ("w");  		break;  	case 23:  		sb.Append ("c");  		break;  	case 24:  		sb.Append ("z");  		break;  	case 25:  		sb.Append ("x");  		break;  	case 26:  		sb.Append ("v");  		break;  	case 27:  		sb.Append ("g");  		break;  	}  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,ReverseIME,The following statement contains a magic number: foreach (char ch in str.ToCharArray ()) {  	if (ch < 44032 || ch > 55203)// out of range  	 {  		sb.Append (ch);  		continue;  	}  	int a = 0;  	int b = 0;  	int c = 0;  	for (int i = ch - 44032; i >= 588; i -= 588' ++a)  		;  	for (int i = ch - a * 588 - 44032; i >= 28; i -= 28' ++b)  		;  	c = ch - a * 588 - b * 28 - 44032;  	switch (a) {  	case 0:  		sb.Append ("r");  		break;  	case 1:  		sb.Append ("R");  		break;  	case 2:  		sb.Append ("s");  		break;  	case 3:  		sb.Append ("e");  		break;  	case 4:  		sb.Append ("E");  		break;  	case 5:  		sb.Append ("f");  		break;  	case 6:  		sb.Append ("a");  		break;  	case 7:  		sb.Append ("q");  		break;  	case 8:  		sb.Append ("Q");  		break;  	case 9:  		sb.Append ("t");  		break;  	case 10:  		sb.Append ("T");  		break;  	case 11:  		sb.Append ("d");  		break;  	case 12:  		sb.Append ("w");  		break;  	case 13:  		sb.Append ("W");  		break;  	case 14:  		sb.Append ("c");  		break;  	case 15:  		sb.Append ("z");  		break;  	case 16:  		sb.Append ("x");  		break;  	case 17:  		sb.Append ("v");  		break;  	case 18:  		sb.Append ("g");  		break;  	}  	switch (b) {  	case 0:  		sb.Append ("k");  		break;  	case 1:  		sb.Append ("o");  		break;  	case 2:  		sb.Append ("i");  		break;  	case 3:  		sb.Append ("O");  		break;  	case 4:  		sb.Append ("j");  		break;  	case 5:  		sb.Append ("p");  		break;  	case 6:  		sb.Append ("u");  		break;  	case 7:  		sb.Append ("P");  		break;  	case 8:  		sb.Append ("h");  		break;  	case 9:  		sb.Append ("hk");  		break;  	case 10:  		sb.Append ("ho");  		break;  	case 11:  		sb.Append ("hl");  		break;  	case 12:  		sb.Append ("y");  		break;  	case 13:  		sb.Append ("n");  		break;  	case 14:  		sb.Append ("nj");  		break;  	case 15:  		sb.Append ("np");  		break;  	case 16:  		sb.Append ("nl");  		break;  	case 17:  		sb.Append ("b");  		break;  	case 18:  		sb.Append ("m");  		break;  	case 19:  		sb.Append ("ml");  		break;  	case 20:  		sb.Append ("l");  		break;  	}  	switch (c) {  	case 1:  		sb.Append ("r");  		break;  	case 2:  		sb.Append ("R");  		break;  	case 3:  		sb.Append ("rt");  		break;  	case 4:  		sb.Append ("s");  		break;  	case 5:  		sb.Append ("sw");  		break;  	case 6:  		sb.Append ("sg");  		break;  	case 7:  		sb.Append ("e");  		break;  	case 8:  		sb.Append ("f");  		break;  	case 9:  		sb.Append ("fr");  		break;  	case 10:  		sb.Append ("fa");  		break;  	case 11:  		sb.Append ("fq");  		break;  	case 12:  		sb.Append ("ft");  		break;  	case 13:  		sb.Append ("fx");  		break;  	case 14:  		sb.Append ("fv");  		break;  	case 15:  		sb.Append ("fg");  		break;  	case 16:  		sb.Append ("a");  		break;  	case 17:  		sb.Append ("q");  		break;  	case 18:  		sb.Append ("qt");  		break;  	case 19:  		sb.Append ("t");  		break;  	case 20:  		sb.Append ("T");  		break;  	case 21:  		sb.Append ("d");  		break;  	case 22:  		sb.Append ("w");  		break;  	case 23:  		sb.Append ("c");  		break;  	case 24:  		sb.Append ("z");  		break;  	case 25:  		sb.Append ("x");  		break;  	case 26:  		sb.Append ("v");  		break;  	case 27:  		sb.Append ("g");  		break;  	}  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,ReverseIME,The following statement contains a magic number: foreach (char ch in str.ToCharArray ()) {  	if (ch < 44032 || ch > 55203)// out of range  	 {  		sb.Append (ch);  		continue;  	}  	int a = 0;  	int b = 0;  	int c = 0;  	for (int i = ch - 44032; i >= 588; i -= 588' ++a)  		;  	for (int i = ch - a * 588 - 44032; i >= 28; i -= 28' ++b)  		;  	c = ch - a * 588 - b * 28 - 44032;  	switch (a) {  	case 0:  		sb.Append ("r");  		break;  	case 1:  		sb.Append ("R");  		break;  	case 2:  		sb.Append ("s");  		break;  	case 3:  		sb.Append ("e");  		break;  	case 4:  		sb.Append ("E");  		break;  	case 5:  		sb.Append ("f");  		break;  	case 6:  		sb.Append ("a");  		break;  	case 7:  		sb.Append ("q");  		break;  	case 8:  		sb.Append ("Q");  		break;  	case 9:  		sb.Append ("t");  		break;  	case 10:  		sb.Append ("T");  		break;  	case 11:  		sb.Append ("d");  		break;  	case 12:  		sb.Append ("w");  		break;  	case 13:  		sb.Append ("W");  		break;  	case 14:  		sb.Append ("c");  		break;  	case 15:  		sb.Append ("z");  		break;  	case 16:  		sb.Append ("x");  		break;  	case 17:  		sb.Append ("v");  		break;  	case 18:  		sb.Append ("g");  		break;  	}  	switch (b) {  	case 0:  		sb.Append ("k");  		break;  	case 1:  		sb.Append ("o");  		break;  	case 2:  		sb.Append ("i");  		break;  	case 3:  		sb.Append ("O");  		break;  	case 4:  		sb.Append ("j");  		break;  	case 5:  		sb.Append ("p");  		break;  	case 6:  		sb.Append ("u");  		break;  	case 7:  		sb.Append ("P");  		break;  	case 8:  		sb.Append ("h");  		break;  	case 9:  		sb.Append ("hk");  		break;  	case 10:  		sb.Append ("ho");  		break;  	case 11:  		sb.Append ("hl");  		break;  	case 12:  		sb.Append ("y");  		break;  	case 13:  		sb.Append ("n");  		break;  	case 14:  		sb.Append ("nj");  		break;  	case 15:  		sb.Append ("np");  		break;  	case 16:  		sb.Append ("nl");  		break;  	case 17:  		sb.Append ("b");  		break;  	case 18:  		sb.Append ("m");  		break;  	case 19:  		sb.Append ("ml");  		break;  	case 20:  		sb.Append ("l");  		break;  	}  	switch (c) {  	case 1:  		sb.Append ("r");  		break;  	case 2:  		sb.Append ("R");  		break;  	case 3:  		sb.Append ("rt");  		break;  	case 4:  		sb.Append ("s");  		break;  	case 5:  		sb.Append ("sw");  		break;  	case 6:  		sb.Append ("sg");  		break;  	case 7:  		sb.Append ("e");  		break;  	case 8:  		sb.Append ("f");  		break;  	case 9:  		sb.Append ("fr");  		break;  	case 10:  		sb.Append ("fa");  		break;  	case 11:  		sb.Append ("fq");  		break;  	case 12:  		sb.Append ("ft");  		break;  	case 13:  		sb.Append ("fx");  		break;  	case 14:  		sb.Append ("fv");  		break;  	case 15:  		sb.Append ("fg");  		break;  	case 16:  		sb.Append ("a");  		break;  	case 17:  		sb.Append ("q");  		break;  	case 18:  		sb.Append ("qt");  		break;  	case 19:  		sb.Append ("t");  		break;  	case 20:  		sb.Append ("T");  		break;  	case 21:  		sb.Append ("d");  		break;  	case 22:  		sb.Append ("w");  		break;  	case 23:  		sb.Append ("c");  		break;  	case 24:  		sb.Append ("z");  		break;  	case 25:  		sb.Append ("x");  		break;  	case 26:  		sb.Append ("v");  		break;  	case 27:  		sb.Append ("g");  		break;  	}  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,ReverseIME,The following statement contains a magic number: foreach (char ch in str.ToCharArray ()) {  	if (ch < 44032 || ch > 55203)// out of range  	 {  		sb.Append (ch);  		continue;  	}  	int a = 0;  	int b = 0;  	int c = 0;  	for (int i = ch - 44032; i >= 588; i -= 588' ++a)  		;  	for (int i = ch - a * 588 - 44032; i >= 28; i -= 28' ++b)  		;  	c = ch - a * 588 - b * 28 - 44032;  	switch (a) {  	case 0:  		sb.Append ("r");  		break;  	case 1:  		sb.Append ("R");  		break;  	case 2:  		sb.Append ("s");  		break;  	case 3:  		sb.Append ("e");  		break;  	case 4:  		sb.Append ("E");  		break;  	case 5:  		sb.Append ("f");  		break;  	case 6:  		sb.Append ("a");  		break;  	case 7:  		sb.Append ("q");  		break;  	case 8:  		sb.Append ("Q");  		break;  	case 9:  		sb.Append ("t");  		break;  	case 10:  		sb.Append ("T");  		break;  	case 11:  		sb.Append ("d");  		break;  	case 12:  		sb.Append ("w");  		break;  	case 13:  		sb.Append ("W");  		break;  	case 14:  		sb.Append ("c");  		break;  	case 15:  		sb.Append ("z");  		break;  	case 16:  		sb.Append ("x");  		break;  	case 17:  		sb.Append ("v");  		break;  	case 18:  		sb.Append ("g");  		break;  	}  	switch (b) {  	case 0:  		sb.Append ("k");  		break;  	case 1:  		sb.Append ("o");  		break;  	case 2:  		sb.Append ("i");  		break;  	case 3:  		sb.Append ("O");  		break;  	case 4:  		sb.Append ("j");  		break;  	case 5:  		sb.Append ("p");  		break;  	case 6:  		sb.Append ("u");  		break;  	case 7:  		sb.Append ("P");  		break;  	case 8:  		sb.Append ("h");  		break;  	case 9:  		sb.Append ("hk");  		break;  	case 10:  		sb.Append ("ho");  		break;  	case 11:  		sb.Append ("hl");  		break;  	case 12:  		sb.Append ("y");  		break;  	case 13:  		sb.Append ("n");  		break;  	case 14:  		sb.Append ("nj");  		break;  	case 15:  		sb.Append ("np");  		break;  	case 16:  		sb.Append ("nl");  		break;  	case 17:  		sb.Append ("b");  		break;  	case 18:  		sb.Append ("m");  		break;  	case 19:  		sb.Append ("ml");  		break;  	case 20:  		sb.Append ("l");  		break;  	}  	switch (c) {  	case 1:  		sb.Append ("r");  		break;  	case 2:  		sb.Append ("R");  		break;  	case 3:  		sb.Append ("rt");  		break;  	case 4:  		sb.Append ("s");  		break;  	case 5:  		sb.Append ("sw");  		break;  	case 6:  		sb.Append ("sg");  		break;  	case 7:  		sb.Append ("e");  		break;  	case 8:  		sb.Append ("f");  		break;  	case 9:  		sb.Append ("fr");  		break;  	case 10:  		sb.Append ("fa");  		break;  	case 11:  		sb.Append ("fq");  		break;  	case 12:  		sb.Append ("ft");  		break;  	case 13:  		sb.Append ("fx");  		break;  	case 14:  		sb.Append ("fv");  		break;  	case 15:  		sb.Append ("fg");  		break;  	case 16:  		sb.Append ("a");  		break;  	case 17:  		sb.Append ("q");  		break;  	case 18:  		sb.Append ("qt");  		break;  	case 19:  		sb.Append ("t");  		break;  	case 20:  		sb.Append ("T");  		break;  	case 21:  		sb.Append ("d");  		break;  	case 22:  		sb.Append ("w");  		break;  	case 23:  		sb.Append ("c");  		break;  	case 24:  		sb.Append ("z");  		break;  	case 25:  		sb.Append ("x");  		break;  	case 26:  		sb.Append ("v");  		break;  	case 27:  		sb.Append ("g");  		break;  	}  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,ReverseIME,The following statement contains a magic number: foreach (char ch in str.ToCharArray ()) {  	if (ch < 44032 || ch > 55203)// out of range  	 {  		sb.Append (ch);  		continue;  	}  	int a = 0;  	int b = 0;  	int c = 0;  	for (int i = ch - 44032; i >= 588; i -= 588' ++a)  		;  	for (int i = ch - a * 588 - 44032; i >= 28; i -= 28' ++b)  		;  	c = ch - a * 588 - b * 28 - 44032;  	switch (a) {  	case 0:  		sb.Append ("r");  		break;  	case 1:  		sb.Append ("R");  		break;  	case 2:  		sb.Append ("s");  		break;  	case 3:  		sb.Append ("e");  		break;  	case 4:  		sb.Append ("E");  		break;  	case 5:  		sb.Append ("f");  		break;  	case 6:  		sb.Append ("a");  		break;  	case 7:  		sb.Append ("q");  		break;  	case 8:  		sb.Append ("Q");  		break;  	case 9:  		sb.Append ("t");  		break;  	case 10:  		sb.Append ("T");  		break;  	case 11:  		sb.Append ("d");  		break;  	case 12:  		sb.Append ("w");  		break;  	case 13:  		sb.Append ("W");  		break;  	case 14:  		sb.Append ("c");  		break;  	case 15:  		sb.Append ("z");  		break;  	case 16:  		sb.Append ("x");  		break;  	case 17:  		sb.Append ("v");  		break;  	case 18:  		sb.Append ("g");  		break;  	}  	switch (b) {  	case 0:  		sb.Append ("k");  		break;  	case 1:  		sb.Append ("o");  		break;  	case 2:  		sb.Append ("i");  		break;  	case 3:  		sb.Append ("O");  		break;  	case 4:  		sb.Append ("j");  		break;  	case 5:  		sb.Append ("p");  		break;  	case 6:  		sb.Append ("u");  		break;  	case 7:  		sb.Append ("P");  		break;  	case 8:  		sb.Append ("h");  		break;  	case 9:  		sb.Append ("hk");  		break;  	case 10:  		sb.Append ("ho");  		break;  	case 11:  		sb.Append ("hl");  		break;  	case 12:  		sb.Append ("y");  		break;  	case 13:  		sb.Append ("n");  		break;  	case 14:  		sb.Append ("nj");  		break;  	case 15:  		sb.Append ("np");  		break;  	case 16:  		sb.Append ("nl");  		break;  	case 17:  		sb.Append ("b");  		break;  	case 18:  		sb.Append ("m");  		break;  	case 19:  		sb.Append ("ml");  		break;  	case 20:  		sb.Append ("l");  		break;  	}  	switch (c) {  	case 1:  		sb.Append ("r");  		break;  	case 2:  		sb.Append ("R");  		break;  	case 3:  		sb.Append ("rt");  		break;  	case 4:  		sb.Append ("s");  		break;  	case 5:  		sb.Append ("sw");  		break;  	case 6:  		sb.Append ("sg");  		break;  	case 7:  		sb.Append ("e");  		break;  	case 8:  		sb.Append ("f");  		break;  	case 9:  		sb.Append ("fr");  		break;  	case 10:  		sb.Append ("fa");  		break;  	case 11:  		sb.Append ("fq");  		break;  	case 12:  		sb.Append ("ft");  		break;  	case 13:  		sb.Append ("fx");  		break;  	case 14:  		sb.Append ("fv");  		break;  	case 15:  		sb.Append ("fg");  		break;  	case 16:  		sb.Append ("a");  		break;  	case 17:  		sb.Append ("q");  		break;  	case 18:  		sb.Append ("qt");  		break;  	case 19:  		sb.Append ("t");  		break;  	case 20:  		sb.Append ("T");  		break;  	case 21:  		sb.Append ("d");  		break;  	case 22:  		sb.Append ("w");  		break;  	case 23:  		sb.Append ("c");  		break;  	case 24:  		sb.Append ("z");  		break;  	case 25:  		sb.Append ("x");  		break;  	case 26:  		sb.Append ("v");  		break;  	case 27:  		sb.Append ("g");  		break;  	}  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,ReverseIME,The following statement contains a magic number: foreach (char ch in str.ToCharArray ()) {  	if (ch < 44032 || ch > 55203)// out of range  	 {  		sb.Append (ch);  		continue;  	}  	int a = 0;  	int b = 0;  	int c = 0;  	for (int i = ch - 44032; i >= 588; i -= 588' ++a)  		;  	for (int i = ch - a * 588 - 44032; i >= 28; i -= 28' ++b)  		;  	c = ch - a * 588 - b * 28 - 44032;  	switch (a) {  	case 0:  		sb.Append ("r");  		break;  	case 1:  		sb.Append ("R");  		break;  	case 2:  		sb.Append ("s");  		break;  	case 3:  		sb.Append ("e");  		break;  	case 4:  		sb.Append ("E");  		break;  	case 5:  		sb.Append ("f");  		break;  	case 6:  		sb.Append ("a");  		break;  	case 7:  		sb.Append ("q");  		break;  	case 8:  		sb.Append ("Q");  		break;  	case 9:  		sb.Append ("t");  		break;  	case 10:  		sb.Append ("T");  		break;  	case 11:  		sb.Append ("d");  		break;  	case 12:  		sb.Append ("w");  		break;  	case 13:  		sb.Append ("W");  		break;  	case 14:  		sb.Append ("c");  		break;  	case 15:  		sb.Append ("z");  		break;  	case 16:  		sb.Append ("x");  		break;  	case 17:  		sb.Append ("v");  		break;  	case 18:  		sb.Append ("g");  		break;  	}  	switch (b) {  	case 0:  		sb.Append ("k");  		break;  	case 1:  		sb.Append ("o");  		break;  	case 2:  		sb.Append ("i");  		break;  	case 3:  		sb.Append ("O");  		break;  	case 4:  		sb.Append ("j");  		break;  	case 5:  		sb.Append ("p");  		break;  	case 6:  		sb.Append ("u");  		break;  	case 7:  		sb.Append ("P");  		break;  	case 8:  		sb.Append ("h");  		break;  	case 9:  		sb.Append ("hk");  		break;  	case 10:  		sb.Append ("ho");  		break;  	case 11:  		sb.Append ("hl");  		break;  	case 12:  		sb.Append ("y");  		break;  	case 13:  		sb.Append ("n");  		break;  	case 14:  		sb.Append ("nj");  		break;  	case 15:  		sb.Append ("np");  		break;  	case 16:  		sb.Append ("nl");  		break;  	case 17:  		sb.Append ("b");  		break;  	case 18:  		sb.Append ("m");  		break;  	case 19:  		sb.Append ("ml");  		break;  	case 20:  		sb.Append ("l");  		break;  	}  	switch (c) {  	case 1:  		sb.Append ("r");  		break;  	case 2:  		sb.Append ("R");  		break;  	case 3:  		sb.Append ("rt");  		break;  	case 4:  		sb.Append ("s");  		break;  	case 5:  		sb.Append ("sw");  		break;  	case 6:  		sb.Append ("sg");  		break;  	case 7:  		sb.Append ("e");  		break;  	case 8:  		sb.Append ("f");  		break;  	case 9:  		sb.Append ("fr");  		break;  	case 10:  		sb.Append ("fa");  		break;  	case 11:  		sb.Append ("fq");  		break;  	case 12:  		sb.Append ("ft");  		break;  	case 13:  		sb.Append ("fx");  		break;  	case 14:  		sb.Append ("fv");  		break;  	case 15:  		sb.Append ("fg");  		break;  	case 16:  		sb.Append ("a");  		break;  	case 17:  		sb.Append ("q");  		break;  	case 18:  		sb.Append ("qt");  		break;  	case 19:  		sb.Append ("t");  		break;  	case 20:  		sb.Append ("T");  		break;  	case 21:  		sb.Append ("d");  		break;  	case 22:  		sb.Append ("w");  		break;  	case 23:  		sb.Append ("c");  		break;  	case 24:  		sb.Append ("z");  		break;  	case 25:  		sb.Append ("x");  		break;  	case 26:  		sb.Append ("v");  		break;  	case 27:  		sb.Append ("g");  		break;  	}  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,ReverseIME,The following statement contains a magic number: foreach (char ch in str.ToCharArray ()) {  	if (ch < 44032 || ch > 55203)// out of range  	 {  		sb.Append (ch);  		continue;  	}  	int a = 0;  	int b = 0;  	int c = 0;  	for (int i = ch - 44032; i >= 588; i -= 588' ++a)  		;  	for (int i = ch - a * 588 - 44032; i >= 28; i -= 28' ++b)  		;  	c = ch - a * 588 - b * 28 - 44032;  	switch (a) {  	case 0:  		sb.Append ("r");  		break;  	case 1:  		sb.Append ("R");  		break;  	case 2:  		sb.Append ("s");  		break;  	case 3:  		sb.Append ("e");  		break;  	case 4:  		sb.Append ("E");  		break;  	case 5:  		sb.Append ("f");  		break;  	case 6:  		sb.Append ("a");  		break;  	case 7:  		sb.Append ("q");  		break;  	case 8:  		sb.Append ("Q");  		break;  	case 9:  		sb.Append ("t");  		break;  	case 10:  		sb.Append ("T");  		break;  	case 11:  		sb.Append ("d");  		break;  	case 12:  		sb.Append ("w");  		break;  	case 13:  		sb.Append ("W");  		break;  	case 14:  		sb.Append ("c");  		break;  	case 15:  		sb.Append ("z");  		break;  	case 16:  		sb.Append ("x");  		break;  	case 17:  		sb.Append ("v");  		break;  	case 18:  		sb.Append ("g");  		break;  	}  	switch (b) {  	case 0:  		sb.Append ("k");  		break;  	case 1:  		sb.Append ("o");  		break;  	case 2:  		sb.Append ("i");  		break;  	case 3:  		sb.Append ("O");  		break;  	case 4:  		sb.Append ("j");  		break;  	case 5:  		sb.Append ("p");  		break;  	case 6:  		sb.Append ("u");  		break;  	case 7:  		sb.Append ("P");  		break;  	case 8:  		sb.Append ("h");  		break;  	case 9:  		sb.Append ("hk");  		break;  	case 10:  		sb.Append ("ho");  		break;  	case 11:  		sb.Append ("hl");  		break;  	case 12:  		sb.Append ("y");  		break;  	case 13:  		sb.Append ("n");  		break;  	case 14:  		sb.Append ("nj");  		break;  	case 15:  		sb.Append ("np");  		break;  	case 16:  		sb.Append ("nl");  		break;  	case 17:  		sb.Append ("b");  		break;  	case 18:  		sb.Append ("m");  		break;  	case 19:  		sb.Append ("ml");  		break;  	case 20:  		sb.Append ("l");  		break;  	}  	switch (c) {  	case 1:  		sb.Append ("r");  		break;  	case 2:  		sb.Append ("R");  		break;  	case 3:  		sb.Append ("rt");  		break;  	case 4:  		sb.Append ("s");  		break;  	case 5:  		sb.Append ("sw");  		break;  	case 6:  		sb.Append ("sg");  		break;  	case 7:  		sb.Append ("e");  		break;  	case 8:  		sb.Append ("f");  		break;  	case 9:  		sb.Append ("fr");  		break;  	case 10:  		sb.Append ("fa");  		break;  	case 11:  		sb.Append ("fq");  		break;  	case 12:  		sb.Append ("ft");  		break;  	case 13:  		sb.Append ("fx");  		break;  	case 14:  		sb.Append ("fv");  		break;  	case 15:  		sb.Append ("fg");  		break;  	case 16:  		sb.Append ("a");  		break;  	case 17:  		sb.Append ("q");  		break;  	case 18:  		sb.Append ("qt");  		break;  	case 19:  		sb.Append ("t");  		break;  	case 20:  		sb.Append ("T");  		break;  	case 21:  		sb.Append ("d");  		break;  	case 22:  		sb.Append ("w");  		break;  	case 23:  		sb.Append ("c");  		break;  	case 24:  		sb.Append ("z");  		break;  	case 25:  		sb.Append ("x");  		break;  	case 26:  		sb.Append ("v");  		break;  	case 27:  		sb.Append ("g");  		break;  	}  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,ReverseIME,The following statement contains a magic number: foreach (char ch in str.ToCharArray ()) {  	if (ch < 44032 || ch > 55203)// out of range  	 {  		sb.Append (ch);  		continue;  	}  	int a = 0;  	int b = 0;  	int c = 0;  	for (int i = ch - 44032; i >= 588; i -= 588' ++a)  		;  	for (int i = ch - a * 588 - 44032; i >= 28; i -= 28' ++b)  		;  	c = ch - a * 588 - b * 28 - 44032;  	switch (a) {  	case 0:  		sb.Append ("r");  		break;  	case 1:  		sb.Append ("R");  		break;  	case 2:  		sb.Append ("s");  		break;  	case 3:  		sb.Append ("e");  		break;  	case 4:  		sb.Append ("E");  		break;  	case 5:  		sb.Append ("f");  		break;  	case 6:  		sb.Append ("a");  		break;  	case 7:  		sb.Append ("q");  		break;  	case 8:  		sb.Append ("Q");  		break;  	case 9:  		sb.Append ("t");  		break;  	case 10:  		sb.Append ("T");  		break;  	case 11:  		sb.Append ("d");  		break;  	case 12:  		sb.Append ("w");  		break;  	case 13:  		sb.Append ("W");  		break;  	case 14:  		sb.Append ("c");  		break;  	case 15:  		sb.Append ("z");  		break;  	case 16:  		sb.Append ("x");  		break;  	case 17:  		sb.Append ("v");  		break;  	case 18:  		sb.Append ("g");  		break;  	}  	switch (b) {  	case 0:  		sb.Append ("k");  		break;  	case 1:  		sb.Append ("o");  		break;  	case 2:  		sb.Append ("i");  		break;  	case 3:  		sb.Append ("O");  		break;  	case 4:  		sb.Append ("j");  		break;  	case 5:  		sb.Append ("p");  		break;  	case 6:  		sb.Append ("u");  		break;  	case 7:  		sb.Append ("P");  		break;  	case 8:  		sb.Append ("h");  		break;  	case 9:  		sb.Append ("hk");  		break;  	case 10:  		sb.Append ("ho");  		break;  	case 11:  		sb.Append ("hl");  		break;  	case 12:  		sb.Append ("y");  		break;  	case 13:  		sb.Append ("n");  		break;  	case 14:  		sb.Append ("nj");  		break;  	case 15:  		sb.Append ("np");  		break;  	case 16:  		sb.Append ("nl");  		break;  	case 17:  		sb.Append ("b");  		break;  	case 18:  		sb.Append ("m");  		break;  	case 19:  		sb.Append ("ml");  		break;  	case 20:  		sb.Append ("l");  		break;  	}  	switch (c) {  	case 1:  		sb.Append ("r");  		break;  	case 2:  		sb.Append ("R");  		break;  	case 3:  		sb.Append ("rt");  		break;  	case 4:  		sb.Append ("s");  		break;  	case 5:  		sb.Append ("sw");  		break;  	case 6:  		sb.Append ("sg");  		break;  	case 7:  		sb.Append ("e");  		break;  	case 8:  		sb.Append ("f");  		break;  	case 9:  		sb.Append ("fr");  		break;  	case 10:  		sb.Append ("fa");  		break;  	case 11:  		sb.Append ("fq");  		break;  	case 12:  		sb.Append ("ft");  		break;  	case 13:  		sb.Append ("fx");  		break;  	case 14:  		sb.Append ("fv");  		break;  	case 15:  		sb.Append ("fg");  		break;  	case 16:  		sb.Append ("a");  		break;  	case 17:  		sb.Append ("q");  		break;  	case 18:  		sb.Append ("qt");  		break;  	case 19:  		sb.Append ("t");  		break;  	case 20:  		sb.Append ("T");  		break;  	case 21:  		sb.Append ("d");  		break;  	case 22:  		sb.Append ("w");  		break;  	case 23:  		sb.Append ("c");  		break;  	case 24:  		sb.Append ("z");  		break;  	case 25:  		sb.Append ("x");  		break;  	case 26:  		sb.Append ("v");  		break;  	case 27:  		sb.Append ("g");  		break;  	}  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,ReverseIME,The following statement contains a magic number: foreach (char ch in str.ToCharArray ()) {  	if (ch < 44032 || ch > 55203)// out of range  	 {  		sb.Append (ch);  		continue;  	}  	int a = 0;  	int b = 0;  	int c = 0;  	for (int i = ch - 44032; i >= 588; i -= 588' ++a)  		;  	for (int i = ch - a * 588 - 44032; i >= 28; i -= 28' ++b)  		;  	c = ch - a * 588 - b * 28 - 44032;  	switch (a) {  	case 0:  		sb.Append ("r");  		break;  	case 1:  		sb.Append ("R");  		break;  	case 2:  		sb.Append ("s");  		break;  	case 3:  		sb.Append ("e");  		break;  	case 4:  		sb.Append ("E");  		break;  	case 5:  		sb.Append ("f");  		break;  	case 6:  		sb.Append ("a");  		break;  	case 7:  		sb.Append ("q");  		break;  	case 8:  		sb.Append ("Q");  		break;  	case 9:  		sb.Append ("t");  		break;  	case 10:  		sb.Append ("T");  		break;  	case 11:  		sb.Append ("d");  		break;  	case 12:  		sb.Append ("w");  		break;  	case 13:  		sb.Append ("W");  		break;  	case 14:  		sb.Append ("c");  		break;  	case 15:  		sb.Append ("z");  		break;  	case 16:  		sb.Append ("x");  		break;  	case 17:  		sb.Append ("v");  		break;  	case 18:  		sb.Append ("g");  		break;  	}  	switch (b) {  	case 0:  		sb.Append ("k");  		break;  	case 1:  		sb.Append ("o");  		break;  	case 2:  		sb.Append ("i");  		break;  	case 3:  		sb.Append ("O");  		break;  	case 4:  		sb.Append ("j");  		break;  	case 5:  		sb.Append ("p");  		break;  	case 6:  		sb.Append ("u");  		break;  	case 7:  		sb.Append ("P");  		break;  	case 8:  		sb.Append ("h");  		break;  	case 9:  		sb.Append ("hk");  		break;  	case 10:  		sb.Append ("ho");  		break;  	case 11:  		sb.Append ("hl");  		break;  	case 12:  		sb.Append ("y");  		break;  	case 13:  		sb.Append ("n");  		break;  	case 14:  		sb.Append ("nj");  		break;  	case 15:  		sb.Append ("np");  		break;  	case 16:  		sb.Append ("nl");  		break;  	case 17:  		sb.Append ("b");  		break;  	case 18:  		sb.Append ("m");  		break;  	case 19:  		sb.Append ("ml");  		break;  	case 20:  		sb.Append ("l");  		break;  	}  	switch (c) {  	case 1:  		sb.Append ("r");  		break;  	case 2:  		sb.Append ("R");  		break;  	case 3:  		sb.Append ("rt");  		break;  	case 4:  		sb.Append ("s");  		break;  	case 5:  		sb.Append ("sw");  		break;  	case 6:  		sb.Append ("sg");  		break;  	case 7:  		sb.Append ("e");  		break;  	case 8:  		sb.Append ("f");  		break;  	case 9:  		sb.Append ("fr");  		break;  	case 10:  		sb.Append ("fa");  		break;  	case 11:  		sb.Append ("fq");  		break;  	case 12:  		sb.Append ("ft");  		break;  	case 13:  		sb.Append ("fx");  		break;  	case 14:  		sb.Append ("fv");  		break;  	case 15:  		sb.Append ("fg");  		break;  	case 16:  		sb.Append ("a");  		break;  	case 17:  		sb.Append ("q");  		break;  	case 18:  		sb.Append ("qt");  		break;  	case 19:  		sb.Append ("t");  		break;  	case 20:  		sb.Append ("T");  		break;  	case 21:  		sb.Append ("d");  		break;  	case 22:  		sb.Append ("w");  		break;  	case 23:  		sb.Append ("c");  		break;  	case 24:  		sb.Append ("z");  		break;  	case 25:  		sb.Append ("x");  		break;  	case 26:  		sb.Append ("v");  		break;  	case 27:  		sb.Append ("g");  		break;  	}  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,ReverseIME,The following statement contains a magic number: foreach (char ch in str.ToCharArray ()) {  	if (ch < 44032 || ch > 55203)// out of range  	 {  		sb.Append (ch);  		continue;  	}  	int a = 0;  	int b = 0;  	int c = 0;  	for (int i = ch - 44032; i >= 588; i -= 588' ++a)  		;  	for (int i = ch - a * 588 - 44032; i >= 28; i -= 28' ++b)  		;  	c = ch - a * 588 - b * 28 - 44032;  	switch (a) {  	case 0:  		sb.Append ("r");  		break;  	case 1:  		sb.Append ("R");  		break;  	case 2:  		sb.Append ("s");  		break;  	case 3:  		sb.Append ("e");  		break;  	case 4:  		sb.Append ("E");  		break;  	case 5:  		sb.Append ("f");  		break;  	case 6:  		sb.Append ("a");  		break;  	case 7:  		sb.Append ("q");  		break;  	case 8:  		sb.Append ("Q");  		break;  	case 9:  		sb.Append ("t");  		break;  	case 10:  		sb.Append ("T");  		break;  	case 11:  		sb.Append ("d");  		break;  	case 12:  		sb.Append ("w");  		break;  	case 13:  		sb.Append ("W");  		break;  	case 14:  		sb.Append ("c");  		break;  	case 15:  		sb.Append ("z");  		break;  	case 16:  		sb.Append ("x");  		break;  	case 17:  		sb.Append ("v");  		break;  	case 18:  		sb.Append ("g");  		break;  	}  	switch (b) {  	case 0:  		sb.Append ("k");  		break;  	case 1:  		sb.Append ("o");  		break;  	case 2:  		sb.Append ("i");  		break;  	case 3:  		sb.Append ("O");  		break;  	case 4:  		sb.Append ("j");  		break;  	case 5:  		sb.Append ("p");  		break;  	case 6:  		sb.Append ("u");  		break;  	case 7:  		sb.Append ("P");  		break;  	case 8:  		sb.Append ("h");  		break;  	case 9:  		sb.Append ("hk");  		break;  	case 10:  		sb.Append ("ho");  		break;  	case 11:  		sb.Append ("hl");  		break;  	case 12:  		sb.Append ("y");  		break;  	case 13:  		sb.Append ("n");  		break;  	case 14:  		sb.Append ("nj");  		break;  	case 15:  		sb.Append ("np");  		break;  	case 16:  		sb.Append ("nl");  		break;  	case 17:  		sb.Append ("b");  		break;  	case 18:  		sb.Append ("m");  		break;  	case 19:  		sb.Append ("ml");  		break;  	case 20:  		sb.Append ("l");  		break;  	}  	switch (c) {  	case 1:  		sb.Append ("r");  		break;  	case 2:  		sb.Append ("R");  		break;  	case 3:  		sb.Append ("rt");  		break;  	case 4:  		sb.Append ("s");  		break;  	case 5:  		sb.Append ("sw");  		break;  	case 6:  		sb.Append ("sg");  		break;  	case 7:  		sb.Append ("e");  		break;  	case 8:  		sb.Append ("f");  		break;  	case 9:  		sb.Append ("fr");  		break;  	case 10:  		sb.Append ("fa");  		break;  	case 11:  		sb.Append ("fq");  		break;  	case 12:  		sb.Append ("ft");  		break;  	case 13:  		sb.Append ("fx");  		break;  	case 14:  		sb.Append ("fv");  		break;  	case 15:  		sb.Append ("fg");  		break;  	case 16:  		sb.Append ("a");  		break;  	case 17:  		sb.Append ("q");  		break;  	case 18:  		sb.Append ("qt");  		break;  	case 19:  		sb.Append ("t");  		break;  	case 20:  		sb.Append ("T");  		break;  	case 21:  		sb.Append ("d");  		break;  	case 22:  		sb.Append ("w");  		break;  	case 23:  		sb.Append ("c");  		break;  	case 24:  		sb.Append ("z");  		break;  	case 25:  		sb.Append ("x");  		break;  	case 26:  		sb.Append ("v");  		break;  	case 27:  		sb.Append ("g");  		break;  	}  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,ReverseIME,The following statement contains a magic number: foreach (char ch in str.ToCharArray ()) {  	if (ch < 44032 || ch > 55203)// out of range  	 {  		sb.Append (ch);  		continue;  	}  	int a = 0;  	int b = 0;  	int c = 0;  	for (int i = ch - 44032; i >= 588; i -= 588' ++a)  		;  	for (int i = ch - a * 588 - 44032; i >= 28; i -= 28' ++b)  		;  	c = ch - a * 588 - b * 28 - 44032;  	switch (a) {  	case 0:  		sb.Append ("r");  		break;  	case 1:  		sb.Append ("R");  		break;  	case 2:  		sb.Append ("s");  		break;  	case 3:  		sb.Append ("e");  		break;  	case 4:  		sb.Append ("E");  		break;  	case 5:  		sb.Append ("f");  		break;  	case 6:  		sb.Append ("a");  		break;  	case 7:  		sb.Append ("q");  		break;  	case 8:  		sb.Append ("Q");  		break;  	case 9:  		sb.Append ("t");  		break;  	case 10:  		sb.Append ("T");  		break;  	case 11:  		sb.Append ("d");  		break;  	case 12:  		sb.Append ("w");  		break;  	case 13:  		sb.Append ("W");  		break;  	case 14:  		sb.Append ("c");  		break;  	case 15:  		sb.Append ("z");  		break;  	case 16:  		sb.Append ("x");  		break;  	case 17:  		sb.Append ("v");  		break;  	case 18:  		sb.Append ("g");  		break;  	}  	switch (b) {  	case 0:  		sb.Append ("k");  		break;  	case 1:  		sb.Append ("o");  		break;  	case 2:  		sb.Append ("i");  		break;  	case 3:  		sb.Append ("O");  		break;  	case 4:  		sb.Append ("j");  		break;  	case 5:  		sb.Append ("p");  		break;  	case 6:  		sb.Append ("u");  		break;  	case 7:  		sb.Append ("P");  		break;  	case 8:  		sb.Append ("h");  		break;  	case 9:  		sb.Append ("hk");  		break;  	case 10:  		sb.Append ("ho");  		break;  	case 11:  		sb.Append ("hl");  		break;  	case 12:  		sb.Append ("y");  		break;  	case 13:  		sb.Append ("n");  		break;  	case 14:  		sb.Append ("nj");  		break;  	case 15:  		sb.Append ("np");  		break;  	case 16:  		sb.Append ("nl");  		break;  	case 17:  		sb.Append ("b");  		break;  	case 18:  		sb.Append ("m");  		break;  	case 19:  		sb.Append ("ml");  		break;  	case 20:  		sb.Append ("l");  		break;  	}  	switch (c) {  	case 1:  		sb.Append ("r");  		break;  	case 2:  		sb.Append ("R");  		break;  	case 3:  		sb.Append ("rt");  		break;  	case 4:  		sb.Append ("s");  		break;  	case 5:  		sb.Append ("sw");  		break;  	case 6:  		sb.Append ("sg");  		break;  	case 7:  		sb.Append ("e");  		break;  	case 8:  		sb.Append ("f");  		break;  	case 9:  		sb.Append ("fr");  		break;  	case 10:  		sb.Append ("fa");  		break;  	case 11:  		sb.Append ("fq");  		break;  	case 12:  		sb.Append ("ft");  		break;  	case 13:  		sb.Append ("fx");  		break;  	case 14:  		sb.Append ("fv");  		break;  	case 15:  		sb.Append ("fg");  		break;  	case 16:  		sb.Append ("a");  		break;  	case 17:  		sb.Append ("q");  		break;  	case 18:  		sb.Append ("qt");  		break;  	case 19:  		sb.Append ("t");  		break;  	case 20:  		sb.Append ("T");  		break;  	case 21:  		sb.Append ("d");  		break;  	case 22:  		sb.Append ("w");  		break;  	case 23:  		sb.Append ("c");  		break;  	case 24:  		sb.Append ("z");  		break;  	case 25:  		sb.Append ("x");  		break;  	case 26:  		sb.Append ("v");  		break;  	case 27:  		sb.Append ("g");  		break;  	}  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,ReverseIME,The following statement contains a magic number: foreach (char ch in str.ToCharArray ()) {  	if (ch < 44032 || ch > 55203)// out of range  	 {  		sb.Append (ch);  		continue;  	}  	int a = 0;  	int b = 0;  	int c = 0;  	for (int i = ch - 44032; i >= 588; i -= 588' ++a)  		;  	for (int i = ch - a * 588 - 44032; i >= 28; i -= 28' ++b)  		;  	c = ch - a * 588 - b * 28 - 44032;  	switch (a) {  	case 0:  		sb.Append ("r");  		break;  	case 1:  		sb.Append ("R");  		break;  	case 2:  		sb.Append ("s");  		break;  	case 3:  		sb.Append ("e");  		break;  	case 4:  		sb.Append ("E");  		break;  	case 5:  		sb.Append ("f");  		break;  	case 6:  		sb.Append ("a");  		break;  	case 7:  		sb.Append ("q");  		break;  	case 8:  		sb.Append ("Q");  		break;  	case 9:  		sb.Append ("t");  		break;  	case 10:  		sb.Append ("T");  		break;  	case 11:  		sb.Append ("d");  		break;  	case 12:  		sb.Append ("w");  		break;  	case 13:  		sb.Append ("W");  		break;  	case 14:  		sb.Append ("c");  		break;  	case 15:  		sb.Append ("z");  		break;  	case 16:  		sb.Append ("x");  		break;  	case 17:  		sb.Append ("v");  		break;  	case 18:  		sb.Append ("g");  		break;  	}  	switch (b) {  	case 0:  		sb.Append ("k");  		break;  	case 1:  		sb.Append ("o");  		break;  	case 2:  		sb.Append ("i");  		break;  	case 3:  		sb.Append ("O");  		break;  	case 4:  		sb.Append ("j");  		break;  	case 5:  		sb.Append ("p");  		break;  	case 6:  		sb.Append ("u");  		break;  	case 7:  		sb.Append ("P");  		break;  	case 8:  		sb.Append ("h");  		break;  	case 9:  		sb.Append ("hk");  		break;  	case 10:  		sb.Append ("ho");  		break;  	case 11:  		sb.Append ("hl");  		break;  	case 12:  		sb.Append ("y");  		break;  	case 13:  		sb.Append ("n");  		break;  	case 14:  		sb.Append ("nj");  		break;  	case 15:  		sb.Append ("np");  		break;  	case 16:  		sb.Append ("nl");  		break;  	case 17:  		sb.Append ("b");  		break;  	case 18:  		sb.Append ("m");  		break;  	case 19:  		sb.Append ("ml");  		break;  	case 20:  		sb.Append ("l");  		break;  	}  	switch (c) {  	case 1:  		sb.Append ("r");  		break;  	case 2:  		sb.Append ("R");  		break;  	case 3:  		sb.Append ("rt");  		break;  	case 4:  		sb.Append ("s");  		break;  	case 5:  		sb.Append ("sw");  		break;  	case 6:  		sb.Append ("sg");  		break;  	case 7:  		sb.Append ("e");  		break;  	case 8:  		sb.Append ("f");  		break;  	case 9:  		sb.Append ("fr");  		break;  	case 10:  		sb.Append ("fa");  		break;  	case 11:  		sb.Append ("fq");  		break;  	case 12:  		sb.Append ("ft");  		break;  	case 13:  		sb.Append ("fx");  		break;  	case 14:  		sb.Append ("fv");  		break;  	case 15:  		sb.Append ("fg");  		break;  	case 16:  		sb.Append ("a");  		break;  	case 17:  		sb.Append ("q");  		break;  	case 18:  		sb.Append ("qt");  		break;  	case 19:  		sb.Append ("t");  		break;  	case 20:  		sb.Append ("T");  		break;  	case 21:  		sb.Append ("d");  		break;  	case 22:  		sb.Append ("w");  		break;  	case 23:  		sb.Append ("c");  		break;  	case 24:  		sb.Append ("z");  		break;  	case 25:  		sb.Append ("x");  		break;  	case 26:  		sb.Append ("v");  		break;  	case 27:  		sb.Append ("g");  		break;  	}  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,ReverseIME,The following statement contains a magic number: foreach (char ch in str.ToCharArray ()) {  	if (ch < 44032 || ch > 55203)// out of range  	 {  		sb.Append (ch);  		continue;  	}  	int a = 0;  	int b = 0;  	int c = 0;  	for (int i = ch - 44032; i >= 588; i -= 588' ++a)  		;  	for (int i = ch - a * 588 - 44032; i >= 28; i -= 28' ++b)  		;  	c = ch - a * 588 - b * 28 - 44032;  	switch (a) {  	case 0:  		sb.Append ("r");  		break;  	case 1:  		sb.Append ("R");  		break;  	case 2:  		sb.Append ("s");  		break;  	case 3:  		sb.Append ("e");  		break;  	case 4:  		sb.Append ("E");  		break;  	case 5:  		sb.Append ("f");  		break;  	case 6:  		sb.Append ("a");  		break;  	case 7:  		sb.Append ("q");  		break;  	case 8:  		sb.Append ("Q");  		break;  	case 9:  		sb.Append ("t");  		break;  	case 10:  		sb.Append ("T");  		break;  	case 11:  		sb.Append ("d");  		break;  	case 12:  		sb.Append ("w");  		break;  	case 13:  		sb.Append ("W");  		break;  	case 14:  		sb.Append ("c");  		break;  	case 15:  		sb.Append ("z");  		break;  	case 16:  		sb.Append ("x");  		break;  	case 17:  		sb.Append ("v");  		break;  	case 18:  		sb.Append ("g");  		break;  	}  	switch (b) {  	case 0:  		sb.Append ("k");  		break;  	case 1:  		sb.Append ("o");  		break;  	case 2:  		sb.Append ("i");  		break;  	case 3:  		sb.Append ("O");  		break;  	case 4:  		sb.Append ("j");  		break;  	case 5:  		sb.Append ("p");  		break;  	case 6:  		sb.Append ("u");  		break;  	case 7:  		sb.Append ("P");  		break;  	case 8:  		sb.Append ("h");  		break;  	case 9:  		sb.Append ("hk");  		break;  	case 10:  		sb.Append ("ho");  		break;  	case 11:  		sb.Append ("hl");  		break;  	case 12:  		sb.Append ("y");  		break;  	case 13:  		sb.Append ("n");  		break;  	case 14:  		sb.Append ("nj");  		break;  	case 15:  		sb.Append ("np");  		break;  	case 16:  		sb.Append ("nl");  		break;  	case 17:  		sb.Append ("b");  		break;  	case 18:  		sb.Append ("m");  		break;  	case 19:  		sb.Append ("ml");  		break;  	case 20:  		sb.Append ("l");  		break;  	}  	switch (c) {  	case 1:  		sb.Append ("r");  		break;  	case 2:  		sb.Append ("R");  		break;  	case 3:  		sb.Append ("rt");  		break;  	case 4:  		sb.Append ("s");  		break;  	case 5:  		sb.Append ("sw");  		break;  	case 6:  		sb.Append ("sg");  		break;  	case 7:  		sb.Append ("e");  		break;  	case 8:  		sb.Append ("f");  		break;  	case 9:  		sb.Append ("fr");  		break;  	case 10:  		sb.Append ("fa");  		break;  	case 11:  		sb.Append ("fq");  		break;  	case 12:  		sb.Append ("ft");  		break;  	case 13:  		sb.Append ("fx");  		break;  	case 14:  		sb.Append ("fv");  		break;  	case 15:  		sb.Append ("fg");  		break;  	case 16:  		sb.Append ("a");  		break;  	case 17:  		sb.Append ("q");  		break;  	case 18:  		sb.Append ("qt");  		break;  	case 19:  		sb.Append ("t");  		break;  	case 20:  		sb.Append ("T");  		break;  	case 21:  		sb.Append ("d");  		break;  	case 22:  		sb.Append ("w");  		break;  	case 23:  		sb.Append ("c");  		break;  	case 24:  		sb.Append ("z");  		break;  	case 25:  		sb.Append ("x");  		break;  	case 26:  		sb.Append ("v");  		break;  	case 27:  		sb.Append ("g");  		break;  	}  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,ReverseIME,The following statement contains a magic number: foreach (char ch in str.ToCharArray ()) {  	if (ch < 44032 || ch > 55203)// out of range  	 {  		sb.Append (ch);  		continue;  	}  	int a = 0;  	int b = 0;  	int c = 0;  	for (int i = ch - 44032; i >= 588; i -= 588' ++a)  		;  	for (int i = ch - a * 588 - 44032; i >= 28; i -= 28' ++b)  		;  	c = ch - a * 588 - b * 28 - 44032;  	switch (a) {  	case 0:  		sb.Append ("r");  		break;  	case 1:  		sb.Append ("R");  		break;  	case 2:  		sb.Append ("s");  		break;  	case 3:  		sb.Append ("e");  		break;  	case 4:  		sb.Append ("E");  		break;  	case 5:  		sb.Append ("f");  		break;  	case 6:  		sb.Append ("a");  		break;  	case 7:  		sb.Append ("q");  		break;  	case 8:  		sb.Append ("Q");  		break;  	case 9:  		sb.Append ("t");  		break;  	case 10:  		sb.Append ("T");  		break;  	case 11:  		sb.Append ("d");  		break;  	case 12:  		sb.Append ("w");  		break;  	case 13:  		sb.Append ("W");  		break;  	case 14:  		sb.Append ("c");  		break;  	case 15:  		sb.Append ("z");  		break;  	case 16:  		sb.Append ("x");  		break;  	case 17:  		sb.Append ("v");  		break;  	case 18:  		sb.Append ("g");  		break;  	}  	switch (b) {  	case 0:  		sb.Append ("k");  		break;  	case 1:  		sb.Append ("o");  		break;  	case 2:  		sb.Append ("i");  		break;  	case 3:  		sb.Append ("O");  		break;  	case 4:  		sb.Append ("j");  		break;  	case 5:  		sb.Append ("p");  		break;  	case 6:  		sb.Append ("u");  		break;  	case 7:  		sb.Append ("P");  		break;  	case 8:  		sb.Append ("h");  		break;  	case 9:  		sb.Append ("hk");  		break;  	case 10:  		sb.Append ("ho");  		break;  	case 11:  		sb.Append ("hl");  		break;  	case 12:  		sb.Append ("y");  		break;  	case 13:  		sb.Append ("n");  		break;  	case 14:  		sb.Append ("nj");  		break;  	case 15:  		sb.Append ("np");  		break;  	case 16:  		sb.Append ("nl");  		break;  	case 17:  		sb.Append ("b");  		break;  	case 18:  		sb.Append ("m");  		break;  	case 19:  		sb.Append ("ml");  		break;  	case 20:  		sb.Append ("l");  		break;  	}  	switch (c) {  	case 1:  		sb.Append ("r");  		break;  	case 2:  		sb.Append ("R");  		break;  	case 3:  		sb.Append ("rt");  		break;  	case 4:  		sb.Append ("s");  		break;  	case 5:  		sb.Append ("sw");  		break;  	case 6:  		sb.Append ("sg");  		break;  	case 7:  		sb.Append ("e");  		break;  	case 8:  		sb.Append ("f");  		break;  	case 9:  		sb.Append ("fr");  		break;  	case 10:  		sb.Append ("fa");  		break;  	case 11:  		sb.Append ("fq");  		break;  	case 12:  		sb.Append ("ft");  		break;  	case 13:  		sb.Append ("fx");  		break;  	case 14:  		sb.Append ("fv");  		break;  	case 15:  		sb.Append ("fg");  		break;  	case 16:  		sb.Append ("a");  		break;  	case 17:  		sb.Append ("q");  		break;  	case 18:  		sb.Append ("qt");  		break;  	case 19:  		sb.Append ("t");  		break;  	case 20:  		sb.Append ("T");  		break;  	case 21:  		sb.Append ("d");  		break;  	case 22:  		sb.Append ("w");  		break;  	case 23:  		sb.Append ("c");  		break;  	case 24:  		sb.Append ("z");  		break;  	case 25:  		sb.Append ("x");  		break;  	case 26:  		sb.Append ("v");  		break;  	case 27:  		sb.Append ("g");  		break;  	}  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,ReverseIME,The following statement contains a magic number: foreach (char ch in str.ToCharArray ()) {  	if (ch < 44032 || ch > 55203)// out of range  	 {  		sb.Append (ch);  		continue;  	}  	int a = 0;  	int b = 0;  	int c = 0;  	for (int i = ch - 44032; i >= 588; i -= 588' ++a)  		;  	for (int i = ch - a * 588 - 44032; i >= 28; i -= 28' ++b)  		;  	c = ch - a * 588 - b * 28 - 44032;  	switch (a) {  	case 0:  		sb.Append ("r");  		break;  	case 1:  		sb.Append ("R");  		break;  	case 2:  		sb.Append ("s");  		break;  	case 3:  		sb.Append ("e");  		break;  	case 4:  		sb.Append ("E");  		break;  	case 5:  		sb.Append ("f");  		break;  	case 6:  		sb.Append ("a");  		break;  	case 7:  		sb.Append ("q");  		break;  	case 8:  		sb.Append ("Q");  		break;  	case 9:  		sb.Append ("t");  		break;  	case 10:  		sb.Append ("T");  		break;  	case 11:  		sb.Append ("d");  		break;  	case 12:  		sb.Append ("w");  		break;  	case 13:  		sb.Append ("W");  		break;  	case 14:  		sb.Append ("c");  		break;  	case 15:  		sb.Append ("z");  		break;  	case 16:  		sb.Append ("x");  		break;  	case 17:  		sb.Append ("v");  		break;  	case 18:  		sb.Append ("g");  		break;  	}  	switch (b) {  	case 0:  		sb.Append ("k");  		break;  	case 1:  		sb.Append ("o");  		break;  	case 2:  		sb.Append ("i");  		break;  	case 3:  		sb.Append ("O");  		break;  	case 4:  		sb.Append ("j");  		break;  	case 5:  		sb.Append ("p");  		break;  	case 6:  		sb.Append ("u");  		break;  	case 7:  		sb.Append ("P");  		break;  	case 8:  		sb.Append ("h");  		break;  	case 9:  		sb.Append ("hk");  		break;  	case 10:  		sb.Append ("ho");  		break;  	case 11:  		sb.Append ("hl");  		break;  	case 12:  		sb.Append ("y");  		break;  	case 13:  		sb.Append ("n");  		break;  	case 14:  		sb.Append ("nj");  		break;  	case 15:  		sb.Append ("np");  		break;  	case 16:  		sb.Append ("nl");  		break;  	case 17:  		sb.Append ("b");  		break;  	case 18:  		sb.Append ("m");  		break;  	case 19:  		sb.Append ("ml");  		break;  	case 20:  		sb.Append ("l");  		break;  	}  	switch (c) {  	case 1:  		sb.Append ("r");  		break;  	case 2:  		sb.Append ("R");  		break;  	case 3:  		sb.Append ("rt");  		break;  	case 4:  		sb.Append ("s");  		break;  	case 5:  		sb.Append ("sw");  		break;  	case 6:  		sb.Append ("sg");  		break;  	case 7:  		sb.Append ("e");  		break;  	case 8:  		sb.Append ("f");  		break;  	case 9:  		sb.Append ("fr");  		break;  	case 10:  		sb.Append ("fa");  		break;  	case 11:  		sb.Append ("fq");  		break;  	case 12:  		sb.Append ("ft");  		break;  	case 13:  		sb.Append ("fx");  		break;  	case 14:  		sb.Append ("fv");  		break;  	case 15:  		sb.Append ("fg");  		break;  	case 16:  		sb.Append ("a");  		break;  	case 17:  		sb.Append ("q");  		break;  	case 18:  		sb.Append ("qt");  		break;  	case 19:  		sb.Append ("t");  		break;  	case 20:  		sb.Append ("T");  		break;  	case 21:  		sb.Append ("d");  		break;  	case 22:  		sb.Append ("w");  		break;  	case 23:  		sb.Append ("c");  		break;  	case 24:  		sb.Append ("z");  		break;  	case 25:  		sb.Append ("x");  		break;  	case 26:  		sb.Append ("v");  		break;  	case 27:  		sb.Append ("g");  		break;  	}  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,ReverseIME,The following statement contains a magic number: foreach (char ch in str.ToCharArray ()) {  	if (ch < 44032 || ch > 55203)// out of range  	 {  		sb.Append (ch);  		continue;  	}  	int a = 0;  	int b = 0;  	int c = 0;  	for (int i = ch - 44032; i >= 588; i -= 588' ++a)  		;  	for (int i = ch - a * 588 - 44032; i >= 28; i -= 28' ++b)  		;  	c = ch - a * 588 - b * 28 - 44032;  	switch (a) {  	case 0:  		sb.Append ("r");  		break;  	case 1:  		sb.Append ("R");  		break;  	case 2:  		sb.Append ("s");  		break;  	case 3:  		sb.Append ("e");  		break;  	case 4:  		sb.Append ("E");  		break;  	case 5:  		sb.Append ("f");  		break;  	case 6:  		sb.Append ("a");  		break;  	case 7:  		sb.Append ("q");  		break;  	case 8:  		sb.Append ("Q");  		break;  	case 9:  		sb.Append ("t");  		break;  	case 10:  		sb.Append ("T");  		break;  	case 11:  		sb.Append ("d");  		break;  	case 12:  		sb.Append ("w");  		break;  	case 13:  		sb.Append ("W");  		break;  	case 14:  		sb.Append ("c");  		break;  	case 15:  		sb.Append ("z");  		break;  	case 16:  		sb.Append ("x");  		break;  	case 17:  		sb.Append ("v");  		break;  	case 18:  		sb.Append ("g");  		break;  	}  	switch (b) {  	case 0:  		sb.Append ("k");  		break;  	case 1:  		sb.Append ("o");  		break;  	case 2:  		sb.Append ("i");  		break;  	case 3:  		sb.Append ("O");  		break;  	case 4:  		sb.Append ("j");  		break;  	case 5:  		sb.Append ("p");  		break;  	case 6:  		sb.Append ("u");  		break;  	case 7:  		sb.Append ("P");  		break;  	case 8:  		sb.Append ("h");  		break;  	case 9:  		sb.Append ("hk");  		break;  	case 10:  		sb.Append ("ho");  		break;  	case 11:  		sb.Append ("hl");  		break;  	case 12:  		sb.Append ("y");  		break;  	case 13:  		sb.Append ("n");  		break;  	case 14:  		sb.Append ("nj");  		break;  	case 15:  		sb.Append ("np");  		break;  	case 16:  		sb.Append ("nl");  		break;  	case 17:  		sb.Append ("b");  		break;  	case 18:  		sb.Append ("m");  		break;  	case 19:  		sb.Append ("ml");  		break;  	case 20:  		sb.Append ("l");  		break;  	}  	switch (c) {  	case 1:  		sb.Append ("r");  		break;  	case 2:  		sb.Append ("R");  		break;  	case 3:  		sb.Append ("rt");  		break;  	case 4:  		sb.Append ("s");  		break;  	case 5:  		sb.Append ("sw");  		break;  	case 6:  		sb.Append ("sg");  		break;  	case 7:  		sb.Append ("e");  		break;  	case 8:  		sb.Append ("f");  		break;  	case 9:  		sb.Append ("fr");  		break;  	case 10:  		sb.Append ("fa");  		break;  	case 11:  		sb.Append ("fq");  		break;  	case 12:  		sb.Append ("ft");  		break;  	case 13:  		sb.Append ("fx");  		break;  	case 14:  		sb.Append ("fv");  		break;  	case 15:  		sb.Append ("fg");  		break;  	case 16:  		sb.Append ("a");  		break;  	case 17:  		sb.Append ("q");  		break;  	case 18:  		sb.Append ("qt");  		break;  	case 19:  		sb.Append ("t");  		break;  	case 20:  		sb.Append ("T");  		break;  	case 21:  		sb.Append ("d");  		break;  	case 22:  		sb.Append ("w");  		break;  	case 23:  		sb.Append ("c");  		break;  	case 24:  		sb.Append ("z");  		break;  	case 25:  		sb.Append ("x");  		break;  	case 26:  		sb.Append ("v");  		break;  	case 27:  		sb.Append ("g");  		break;  	}  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,ReverseIME,The following statement contains a magic number: foreach (char ch in str.ToCharArray ()) {  	if (ch < 44032 || ch > 55203)// out of range  	 {  		sb.Append (ch);  		continue;  	}  	int a = 0;  	int b = 0;  	int c = 0;  	for (int i = ch - 44032; i >= 588; i -= 588' ++a)  		;  	for (int i = ch - a * 588 - 44032; i >= 28; i -= 28' ++b)  		;  	c = ch - a * 588 - b * 28 - 44032;  	switch (a) {  	case 0:  		sb.Append ("r");  		break;  	case 1:  		sb.Append ("R");  		break;  	case 2:  		sb.Append ("s");  		break;  	case 3:  		sb.Append ("e");  		break;  	case 4:  		sb.Append ("E");  		break;  	case 5:  		sb.Append ("f");  		break;  	case 6:  		sb.Append ("a");  		break;  	case 7:  		sb.Append ("q");  		break;  	case 8:  		sb.Append ("Q");  		break;  	case 9:  		sb.Append ("t");  		break;  	case 10:  		sb.Append ("T");  		break;  	case 11:  		sb.Append ("d");  		break;  	case 12:  		sb.Append ("w");  		break;  	case 13:  		sb.Append ("W");  		break;  	case 14:  		sb.Append ("c");  		break;  	case 15:  		sb.Append ("z");  		break;  	case 16:  		sb.Append ("x");  		break;  	case 17:  		sb.Append ("v");  		break;  	case 18:  		sb.Append ("g");  		break;  	}  	switch (b) {  	case 0:  		sb.Append ("k");  		break;  	case 1:  		sb.Append ("o");  		break;  	case 2:  		sb.Append ("i");  		break;  	case 3:  		sb.Append ("O");  		break;  	case 4:  		sb.Append ("j");  		break;  	case 5:  		sb.Append ("p");  		break;  	case 6:  		sb.Append ("u");  		break;  	case 7:  		sb.Append ("P");  		break;  	case 8:  		sb.Append ("h");  		break;  	case 9:  		sb.Append ("hk");  		break;  	case 10:  		sb.Append ("ho");  		break;  	case 11:  		sb.Append ("hl");  		break;  	case 12:  		sb.Append ("y");  		break;  	case 13:  		sb.Append ("n");  		break;  	case 14:  		sb.Append ("nj");  		break;  	case 15:  		sb.Append ("np");  		break;  	case 16:  		sb.Append ("nl");  		break;  	case 17:  		sb.Append ("b");  		break;  	case 18:  		sb.Append ("m");  		break;  	case 19:  		sb.Append ("ml");  		break;  	case 20:  		sb.Append ("l");  		break;  	}  	switch (c) {  	case 1:  		sb.Append ("r");  		break;  	case 2:  		sb.Append ("R");  		break;  	case 3:  		sb.Append ("rt");  		break;  	case 4:  		sb.Append ("s");  		break;  	case 5:  		sb.Append ("sw");  		break;  	case 6:  		sb.Append ("sg");  		break;  	case 7:  		sb.Append ("e");  		break;  	case 8:  		sb.Append ("f");  		break;  	case 9:  		sb.Append ("fr");  		break;  	case 10:  		sb.Append ("fa");  		break;  	case 11:  		sb.Append ("fq");  		break;  	case 12:  		sb.Append ("ft");  		break;  	case 13:  		sb.Append ("fx");  		break;  	case 14:  		sb.Append ("fv");  		break;  	case 15:  		sb.Append ("fg");  		break;  	case 16:  		sb.Append ("a");  		break;  	case 17:  		sb.Append ("q");  		break;  	case 18:  		sb.Append ("qt");  		break;  	case 19:  		sb.Append ("t");  		break;  	case 20:  		sb.Append ("T");  		break;  	case 21:  		sb.Append ("d");  		break;  	case 22:  		sb.Append ("w");  		break;  	case 23:  		sb.Append ("c");  		break;  	case 24:  		sb.Append ("z");  		break;  	case 25:  		sb.Append ("x");  		break;  	case 26:  		sb.Append ("v");  		break;  	case 27:  		sb.Append ("g");  		break;  	}  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,ReverseIME,The following statement contains a magic number: foreach (char ch in str.ToCharArray ()) {  	if (ch < 44032 || ch > 55203)// out of range  	 {  		sb.Append (ch);  		continue;  	}  	int a = 0;  	int b = 0;  	int c = 0;  	for (int i = ch - 44032; i >= 588; i -= 588' ++a)  		;  	for (int i = ch - a * 588 - 44032; i >= 28; i -= 28' ++b)  		;  	c = ch - a * 588 - b * 28 - 44032;  	switch (a) {  	case 0:  		sb.Append ("r");  		break;  	case 1:  		sb.Append ("R");  		break;  	case 2:  		sb.Append ("s");  		break;  	case 3:  		sb.Append ("e");  		break;  	case 4:  		sb.Append ("E");  		break;  	case 5:  		sb.Append ("f");  		break;  	case 6:  		sb.Append ("a");  		break;  	case 7:  		sb.Append ("q");  		break;  	case 8:  		sb.Append ("Q");  		break;  	case 9:  		sb.Append ("t");  		break;  	case 10:  		sb.Append ("T");  		break;  	case 11:  		sb.Append ("d");  		break;  	case 12:  		sb.Append ("w");  		break;  	case 13:  		sb.Append ("W");  		break;  	case 14:  		sb.Append ("c");  		break;  	case 15:  		sb.Append ("z");  		break;  	case 16:  		sb.Append ("x");  		break;  	case 17:  		sb.Append ("v");  		break;  	case 18:  		sb.Append ("g");  		break;  	}  	switch (b) {  	case 0:  		sb.Append ("k");  		break;  	case 1:  		sb.Append ("o");  		break;  	case 2:  		sb.Append ("i");  		break;  	case 3:  		sb.Append ("O");  		break;  	case 4:  		sb.Append ("j");  		break;  	case 5:  		sb.Append ("p");  		break;  	case 6:  		sb.Append ("u");  		break;  	case 7:  		sb.Append ("P");  		break;  	case 8:  		sb.Append ("h");  		break;  	case 9:  		sb.Append ("hk");  		break;  	case 10:  		sb.Append ("ho");  		break;  	case 11:  		sb.Append ("hl");  		break;  	case 12:  		sb.Append ("y");  		break;  	case 13:  		sb.Append ("n");  		break;  	case 14:  		sb.Append ("nj");  		break;  	case 15:  		sb.Append ("np");  		break;  	case 16:  		sb.Append ("nl");  		break;  	case 17:  		sb.Append ("b");  		break;  	case 18:  		sb.Append ("m");  		break;  	case 19:  		sb.Append ("ml");  		break;  	case 20:  		sb.Append ("l");  		break;  	}  	switch (c) {  	case 1:  		sb.Append ("r");  		break;  	case 2:  		sb.Append ("R");  		break;  	case 3:  		sb.Append ("rt");  		break;  	case 4:  		sb.Append ("s");  		break;  	case 5:  		sb.Append ("sw");  		break;  	case 6:  		sb.Append ("sg");  		break;  	case 7:  		sb.Append ("e");  		break;  	case 8:  		sb.Append ("f");  		break;  	case 9:  		sb.Append ("fr");  		break;  	case 10:  		sb.Append ("fa");  		break;  	case 11:  		sb.Append ("fq");  		break;  	case 12:  		sb.Append ("ft");  		break;  	case 13:  		sb.Append ("fx");  		break;  	case 14:  		sb.Append ("fv");  		break;  	case 15:  		sb.Append ("fg");  		break;  	case 16:  		sb.Append ("a");  		break;  	case 17:  		sb.Append ("q");  		break;  	case 18:  		sb.Append ("qt");  		break;  	case 19:  		sb.Append ("t");  		break;  	case 20:  		sb.Append ("T");  		break;  	case 21:  		sb.Append ("d");  		break;  	case 22:  		sb.Append ("w");  		break;  	case 23:  		sb.Append ("c");  		break;  	case 24:  		sb.Append ("z");  		break;  	case 25:  		sb.Append ("x");  		break;  	case 26:  		sb.Append ("v");  		break;  	case 27:  		sb.Append ("g");  		break;  	}  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,ReverseIME,The following statement contains a magic number: foreach (char ch in str.ToCharArray ()) {  	if (ch < 44032 || ch > 55203)// out of range  	 {  		sb.Append (ch);  		continue;  	}  	int a = 0;  	int b = 0;  	int c = 0;  	for (int i = ch - 44032; i >= 588; i -= 588' ++a)  		;  	for (int i = ch - a * 588 - 44032; i >= 28; i -= 28' ++b)  		;  	c = ch - a * 588 - b * 28 - 44032;  	switch (a) {  	case 0:  		sb.Append ("r");  		break;  	case 1:  		sb.Append ("R");  		break;  	case 2:  		sb.Append ("s");  		break;  	case 3:  		sb.Append ("e");  		break;  	case 4:  		sb.Append ("E");  		break;  	case 5:  		sb.Append ("f");  		break;  	case 6:  		sb.Append ("a");  		break;  	case 7:  		sb.Append ("q");  		break;  	case 8:  		sb.Append ("Q");  		break;  	case 9:  		sb.Append ("t");  		break;  	case 10:  		sb.Append ("T");  		break;  	case 11:  		sb.Append ("d");  		break;  	case 12:  		sb.Append ("w");  		break;  	case 13:  		sb.Append ("W");  		break;  	case 14:  		sb.Append ("c");  		break;  	case 15:  		sb.Append ("z");  		break;  	case 16:  		sb.Append ("x");  		break;  	case 17:  		sb.Append ("v");  		break;  	case 18:  		sb.Append ("g");  		break;  	}  	switch (b) {  	case 0:  		sb.Append ("k");  		break;  	case 1:  		sb.Append ("o");  		break;  	case 2:  		sb.Append ("i");  		break;  	case 3:  		sb.Append ("O");  		break;  	case 4:  		sb.Append ("j");  		break;  	case 5:  		sb.Append ("p");  		break;  	case 6:  		sb.Append ("u");  		break;  	case 7:  		sb.Append ("P");  		break;  	case 8:  		sb.Append ("h");  		break;  	case 9:  		sb.Append ("hk");  		break;  	case 10:  		sb.Append ("ho");  		break;  	case 11:  		sb.Append ("hl");  		break;  	case 12:  		sb.Append ("y");  		break;  	case 13:  		sb.Append ("n");  		break;  	case 14:  		sb.Append ("nj");  		break;  	case 15:  		sb.Append ("np");  		break;  	case 16:  		sb.Append ("nl");  		break;  	case 17:  		sb.Append ("b");  		break;  	case 18:  		sb.Append ("m");  		break;  	case 19:  		sb.Append ("ml");  		break;  	case 20:  		sb.Append ("l");  		break;  	}  	switch (c) {  	case 1:  		sb.Append ("r");  		break;  	case 2:  		sb.Append ("R");  		break;  	case 3:  		sb.Append ("rt");  		break;  	case 4:  		sb.Append ("s");  		break;  	case 5:  		sb.Append ("sw");  		break;  	case 6:  		sb.Append ("sg");  		break;  	case 7:  		sb.Append ("e");  		break;  	case 8:  		sb.Append ("f");  		break;  	case 9:  		sb.Append ("fr");  		break;  	case 10:  		sb.Append ("fa");  		break;  	case 11:  		sb.Append ("fq");  		break;  	case 12:  		sb.Append ("ft");  		break;  	case 13:  		sb.Append ("fx");  		break;  	case 14:  		sb.Append ("fv");  		break;  	case 15:  		sb.Append ("fg");  		break;  	case 16:  		sb.Append ("a");  		break;  	case 17:  		sb.Append ("q");  		break;  	case 18:  		sb.Append ("qt");  		break;  	case 19:  		sb.Append ("t");  		break;  	case 20:  		sb.Append ("T");  		break;  	case 21:  		sb.Append ("d");  		break;  	case 22:  		sb.Append ("w");  		break;  	case 23:  		sb.Append ("c");  		break;  	case 24:  		sb.Append ("z");  		break;  	case 25:  		sb.Append ("x");  		break;  	case 26:  		sb.Append ("v");  		break;  	case 27:  		sb.Append ("g");  		break;  	}  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,ReverseIME,The following statement contains a magic number: foreach (char ch in str.ToCharArray ()) {  	if (ch < 44032 || ch > 55203)// out of range  	 {  		sb.Append (ch);  		continue;  	}  	int a = 0;  	int b = 0;  	int c = 0;  	for (int i = ch - 44032; i >= 588; i -= 588' ++a)  		;  	for (int i = ch - a * 588 - 44032; i >= 28; i -= 28' ++b)  		;  	c = ch - a * 588 - b * 28 - 44032;  	switch (a) {  	case 0:  		sb.Append ("r");  		break;  	case 1:  		sb.Append ("R");  		break;  	case 2:  		sb.Append ("s");  		break;  	case 3:  		sb.Append ("e");  		break;  	case 4:  		sb.Append ("E");  		break;  	case 5:  		sb.Append ("f");  		break;  	case 6:  		sb.Append ("a");  		break;  	case 7:  		sb.Append ("q");  		break;  	case 8:  		sb.Append ("Q");  		break;  	case 9:  		sb.Append ("t");  		break;  	case 10:  		sb.Append ("T");  		break;  	case 11:  		sb.Append ("d");  		break;  	case 12:  		sb.Append ("w");  		break;  	case 13:  		sb.Append ("W");  		break;  	case 14:  		sb.Append ("c");  		break;  	case 15:  		sb.Append ("z");  		break;  	case 16:  		sb.Append ("x");  		break;  	case 17:  		sb.Append ("v");  		break;  	case 18:  		sb.Append ("g");  		break;  	}  	switch (b) {  	case 0:  		sb.Append ("k");  		break;  	case 1:  		sb.Append ("o");  		break;  	case 2:  		sb.Append ("i");  		break;  	case 3:  		sb.Append ("O");  		break;  	case 4:  		sb.Append ("j");  		break;  	case 5:  		sb.Append ("p");  		break;  	case 6:  		sb.Append ("u");  		break;  	case 7:  		sb.Append ("P");  		break;  	case 8:  		sb.Append ("h");  		break;  	case 9:  		sb.Append ("hk");  		break;  	case 10:  		sb.Append ("ho");  		break;  	case 11:  		sb.Append ("hl");  		break;  	case 12:  		sb.Append ("y");  		break;  	case 13:  		sb.Append ("n");  		break;  	case 14:  		sb.Append ("nj");  		break;  	case 15:  		sb.Append ("np");  		break;  	case 16:  		sb.Append ("nl");  		break;  	case 17:  		sb.Append ("b");  		break;  	case 18:  		sb.Append ("m");  		break;  	case 19:  		sb.Append ("ml");  		break;  	case 20:  		sb.Append ("l");  		break;  	}  	switch (c) {  	case 1:  		sb.Append ("r");  		break;  	case 2:  		sb.Append ("R");  		break;  	case 3:  		sb.Append ("rt");  		break;  	case 4:  		sb.Append ("s");  		break;  	case 5:  		sb.Append ("sw");  		break;  	case 6:  		sb.Append ("sg");  		break;  	case 7:  		sb.Append ("e");  		break;  	case 8:  		sb.Append ("f");  		break;  	case 9:  		sb.Append ("fr");  		break;  	case 10:  		sb.Append ("fa");  		break;  	case 11:  		sb.Append ("fq");  		break;  	case 12:  		sb.Append ("ft");  		break;  	case 13:  		sb.Append ("fx");  		break;  	case 14:  		sb.Append ("fv");  		break;  	case 15:  		sb.Append ("fg");  		break;  	case 16:  		sb.Append ("a");  		break;  	case 17:  		sb.Append ("q");  		break;  	case 18:  		sb.Append ("qt");  		break;  	case 19:  		sb.Append ("t");  		break;  	case 20:  		sb.Append ("T");  		break;  	case 21:  		sb.Append ("d");  		break;  	case 22:  		sb.Append ("w");  		break;  	case 23:  		sb.Append ("c");  		break;  	case 24:  		sb.Append ("z");  		break;  	case 25:  		sb.Append ("x");  		break;  	case 26:  		sb.Append ("v");  		break;  	case 27:  		sb.Append ("g");  		break;  	}  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,ReverseIME,The following statement contains a magic number: foreach (char ch in str.ToCharArray ()) {  	if (ch < 44032 || ch > 55203)// out of range  	 {  		sb.Append (ch);  		continue;  	}  	int a = 0;  	int b = 0;  	int c = 0;  	for (int i = ch - 44032; i >= 588; i -= 588' ++a)  		;  	for (int i = ch - a * 588 - 44032; i >= 28; i -= 28' ++b)  		;  	c = ch - a * 588 - b * 28 - 44032;  	switch (a) {  	case 0:  		sb.Append ("r");  		break;  	case 1:  		sb.Append ("R");  		break;  	case 2:  		sb.Append ("s");  		break;  	case 3:  		sb.Append ("e");  		break;  	case 4:  		sb.Append ("E");  		break;  	case 5:  		sb.Append ("f");  		break;  	case 6:  		sb.Append ("a");  		break;  	case 7:  		sb.Append ("q");  		break;  	case 8:  		sb.Append ("Q");  		break;  	case 9:  		sb.Append ("t");  		break;  	case 10:  		sb.Append ("T");  		break;  	case 11:  		sb.Append ("d");  		break;  	case 12:  		sb.Append ("w");  		break;  	case 13:  		sb.Append ("W");  		break;  	case 14:  		sb.Append ("c");  		break;  	case 15:  		sb.Append ("z");  		break;  	case 16:  		sb.Append ("x");  		break;  	case 17:  		sb.Append ("v");  		break;  	case 18:  		sb.Append ("g");  		break;  	}  	switch (b) {  	case 0:  		sb.Append ("k");  		break;  	case 1:  		sb.Append ("o");  		break;  	case 2:  		sb.Append ("i");  		break;  	case 3:  		sb.Append ("O");  		break;  	case 4:  		sb.Append ("j");  		break;  	case 5:  		sb.Append ("p");  		break;  	case 6:  		sb.Append ("u");  		break;  	case 7:  		sb.Append ("P");  		break;  	case 8:  		sb.Append ("h");  		break;  	case 9:  		sb.Append ("hk");  		break;  	case 10:  		sb.Append ("ho");  		break;  	case 11:  		sb.Append ("hl");  		break;  	case 12:  		sb.Append ("y");  		break;  	case 13:  		sb.Append ("n");  		break;  	case 14:  		sb.Append ("nj");  		break;  	case 15:  		sb.Append ("np");  		break;  	case 16:  		sb.Append ("nl");  		break;  	case 17:  		sb.Append ("b");  		break;  	case 18:  		sb.Append ("m");  		break;  	case 19:  		sb.Append ("ml");  		break;  	case 20:  		sb.Append ("l");  		break;  	}  	switch (c) {  	case 1:  		sb.Append ("r");  		break;  	case 2:  		sb.Append ("R");  		break;  	case 3:  		sb.Append ("rt");  		break;  	case 4:  		sb.Append ("s");  		break;  	case 5:  		sb.Append ("sw");  		break;  	case 6:  		sb.Append ("sg");  		break;  	case 7:  		sb.Append ("e");  		break;  	case 8:  		sb.Append ("f");  		break;  	case 9:  		sb.Append ("fr");  		break;  	case 10:  		sb.Append ("fa");  		break;  	case 11:  		sb.Append ("fq");  		break;  	case 12:  		sb.Append ("ft");  		break;  	case 13:  		sb.Append ("fx");  		break;  	case 14:  		sb.Append ("fv");  		break;  	case 15:  		sb.Append ("fg");  		break;  	case 16:  		sb.Append ("a");  		break;  	case 17:  		sb.Append ("q");  		break;  	case 18:  		sb.Append ("qt");  		break;  	case 19:  		sb.Append ("t");  		break;  	case 20:  		sb.Append ("T");  		break;  	case 21:  		sb.Append ("d");  		break;  	case 22:  		sb.Append ("w");  		break;  	case 23:  		sb.Append ("c");  		break;  	case 24:  		sb.Append ("z");  		break;  	case 25:  		sb.Append ("x");  		break;  	case 26:  		sb.Append ("v");  		break;  	case 27:  		sb.Append ("g");  		break;  	}  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,ReverseIME,The following statement contains a magic number: foreach (char ch in str.ToCharArray ()) {  	if (ch < 44032 || ch > 55203)// out of range  	 {  		sb.Append (ch);  		continue;  	}  	int a = 0;  	int b = 0;  	int c = 0;  	for (int i = ch - 44032; i >= 588; i -= 588' ++a)  		;  	for (int i = ch - a * 588 - 44032; i >= 28; i -= 28' ++b)  		;  	c = ch - a * 588 - b * 28 - 44032;  	switch (a) {  	case 0:  		sb.Append ("r");  		break;  	case 1:  		sb.Append ("R");  		break;  	case 2:  		sb.Append ("s");  		break;  	case 3:  		sb.Append ("e");  		break;  	case 4:  		sb.Append ("E");  		break;  	case 5:  		sb.Append ("f");  		break;  	case 6:  		sb.Append ("a");  		break;  	case 7:  		sb.Append ("q");  		break;  	case 8:  		sb.Append ("Q");  		break;  	case 9:  		sb.Append ("t");  		break;  	case 10:  		sb.Append ("T");  		break;  	case 11:  		sb.Append ("d");  		break;  	case 12:  		sb.Append ("w");  		break;  	case 13:  		sb.Append ("W");  		break;  	case 14:  		sb.Append ("c");  		break;  	case 15:  		sb.Append ("z");  		break;  	case 16:  		sb.Append ("x");  		break;  	case 17:  		sb.Append ("v");  		break;  	case 18:  		sb.Append ("g");  		break;  	}  	switch (b) {  	case 0:  		sb.Append ("k");  		break;  	case 1:  		sb.Append ("o");  		break;  	case 2:  		sb.Append ("i");  		break;  	case 3:  		sb.Append ("O");  		break;  	case 4:  		sb.Append ("j");  		break;  	case 5:  		sb.Append ("p");  		break;  	case 6:  		sb.Append ("u");  		break;  	case 7:  		sb.Append ("P");  		break;  	case 8:  		sb.Append ("h");  		break;  	case 9:  		sb.Append ("hk");  		break;  	case 10:  		sb.Append ("ho");  		break;  	case 11:  		sb.Append ("hl");  		break;  	case 12:  		sb.Append ("y");  		break;  	case 13:  		sb.Append ("n");  		break;  	case 14:  		sb.Append ("nj");  		break;  	case 15:  		sb.Append ("np");  		break;  	case 16:  		sb.Append ("nl");  		break;  	case 17:  		sb.Append ("b");  		break;  	case 18:  		sb.Append ("m");  		break;  	case 19:  		sb.Append ("ml");  		break;  	case 20:  		sb.Append ("l");  		break;  	}  	switch (c) {  	case 1:  		sb.Append ("r");  		break;  	case 2:  		sb.Append ("R");  		break;  	case 3:  		sb.Append ("rt");  		break;  	case 4:  		sb.Append ("s");  		break;  	case 5:  		sb.Append ("sw");  		break;  	case 6:  		sb.Append ("sg");  		break;  	case 7:  		sb.Append ("e");  		break;  	case 8:  		sb.Append ("f");  		break;  	case 9:  		sb.Append ("fr");  		break;  	case 10:  		sb.Append ("fa");  		break;  	case 11:  		sb.Append ("fq");  		break;  	case 12:  		sb.Append ("ft");  		break;  	case 13:  		sb.Append ("fx");  		break;  	case 14:  		sb.Append ("fv");  		break;  	case 15:  		sb.Append ("fg");  		break;  	case 16:  		sb.Append ("a");  		break;  	case 17:  		sb.Append ("q");  		break;  	case 18:  		sb.Append ("qt");  		break;  	case 19:  		sb.Append ("t");  		break;  	case 20:  		sb.Append ("T");  		break;  	case 21:  		sb.Append ("d");  		break;  	case 22:  		sb.Append ("w");  		break;  	case 23:  		sb.Append ("c");  		break;  	case 24:  		sb.Append ("z");  		break;  	case 25:  		sb.Append ("x");  		break;  	case 26:  		sb.Append ("v");  		break;  	case 27:  		sb.Append ("g");  		break;  	}  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,ReverseIME,The following statement contains a magic number: foreach (char ch in str.ToCharArray ()) {  	if (ch < 44032 || ch > 55203)// out of range  	 {  		sb.Append (ch);  		continue;  	}  	int a = 0;  	int b = 0;  	int c = 0;  	for (int i = ch - 44032; i >= 588; i -= 588' ++a)  		;  	for (int i = ch - a * 588 - 44032; i >= 28; i -= 28' ++b)  		;  	c = ch - a * 588 - b * 28 - 44032;  	switch (a) {  	case 0:  		sb.Append ("r");  		break;  	case 1:  		sb.Append ("R");  		break;  	case 2:  		sb.Append ("s");  		break;  	case 3:  		sb.Append ("e");  		break;  	case 4:  		sb.Append ("E");  		break;  	case 5:  		sb.Append ("f");  		break;  	case 6:  		sb.Append ("a");  		break;  	case 7:  		sb.Append ("q");  		break;  	case 8:  		sb.Append ("Q");  		break;  	case 9:  		sb.Append ("t");  		break;  	case 10:  		sb.Append ("T");  		break;  	case 11:  		sb.Append ("d");  		break;  	case 12:  		sb.Append ("w");  		break;  	case 13:  		sb.Append ("W");  		break;  	case 14:  		sb.Append ("c");  		break;  	case 15:  		sb.Append ("z");  		break;  	case 16:  		sb.Append ("x");  		break;  	case 17:  		sb.Append ("v");  		break;  	case 18:  		sb.Append ("g");  		break;  	}  	switch (b) {  	case 0:  		sb.Append ("k");  		break;  	case 1:  		sb.Append ("o");  		break;  	case 2:  		sb.Append ("i");  		break;  	case 3:  		sb.Append ("O");  		break;  	case 4:  		sb.Append ("j");  		break;  	case 5:  		sb.Append ("p");  		break;  	case 6:  		sb.Append ("u");  		break;  	case 7:  		sb.Append ("P");  		break;  	case 8:  		sb.Append ("h");  		break;  	case 9:  		sb.Append ("hk");  		break;  	case 10:  		sb.Append ("ho");  		break;  	case 11:  		sb.Append ("hl");  		break;  	case 12:  		sb.Append ("y");  		break;  	case 13:  		sb.Append ("n");  		break;  	case 14:  		sb.Append ("nj");  		break;  	case 15:  		sb.Append ("np");  		break;  	case 16:  		sb.Append ("nl");  		break;  	case 17:  		sb.Append ("b");  		break;  	case 18:  		sb.Append ("m");  		break;  	case 19:  		sb.Append ("ml");  		break;  	case 20:  		sb.Append ("l");  		break;  	}  	switch (c) {  	case 1:  		sb.Append ("r");  		break;  	case 2:  		sb.Append ("R");  		break;  	case 3:  		sb.Append ("rt");  		break;  	case 4:  		sb.Append ("s");  		break;  	case 5:  		sb.Append ("sw");  		break;  	case 6:  		sb.Append ("sg");  		break;  	case 7:  		sb.Append ("e");  		break;  	case 8:  		sb.Append ("f");  		break;  	case 9:  		sb.Append ("fr");  		break;  	case 10:  		sb.Append ("fa");  		break;  	case 11:  		sb.Append ("fq");  		break;  	case 12:  		sb.Append ("ft");  		break;  	case 13:  		sb.Append ("fx");  		break;  	case 14:  		sb.Append ("fv");  		break;  	case 15:  		sb.Append ("fg");  		break;  	case 16:  		sb.Append ("a");  		break;  	case 17:  		sb.Append ("q");  		break;  	case 18:  		sb.Append ("qt");  		break;  	case 19:  		sb.Append ("t");  		break;  	case 20:  		sb.Append ("T");  		break;  	case 21:  		sb.Append ("d");  		break;  	case 22:  		sb.Append ("w");  		break;  	case 23:  		sb.Append ("c");  		break;  	case 24:  		sb.Append ("z");  		break;  	case 25:  		sb.Append ("x");  		break;  	case 26:  		sb.Append ("v");  		break;  	case 27:  		sb.Append ("g");  		break;  	}  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,ReverseIME,The following statement contains a magic number: foreach (char ch in str.ToCharArray ()) {  	if (ch < 44032 || ch > 55203)// out of range  	 {  		sb.Append (ch);  		continue;  	}  	int a = 0;  	int b = 0;  	int c = 0;  	for (int i = ch - 44032; i >= 588; i -= 588' ++a)  		;  	for (int i = ch - a * 588 - 44032; i >= 28; i -= 28' ++b)  		;  	c = ch - a * 588 - b * 28 - 44032;  	switch (a) {  	case 0:  		sb.Append ("r");  		break;  	case 1:  		sb.Append ("R");  		break;  	case 2:  		sb.Append ("s");  		break;  	case 3:  		sb.Append ("e");  		break;  	case 4:  		sb.Append ("E");  		break;  	case 5:  		sb.Append ("f");  		break;  	case 6:  		sb.Append ("a");  		break;  	case 7:  		sb.Append ("q");  		break;  	case 8:  		sb.Append ("Q");  		break;  	case 9:  		sb.Append ("t");  		break;  	case 10:  		sb.Append ("T");  		break;  	case 11:  		sb.Append ("d");  		break;  	case 12:  		sb.Append ("w");  		break;  	case 13:  		sb.Append ("W");  		break;  	case 14:  		sb.Append ("c");  		break;  	case 15:  		sb.Append ("z");  		break;  	case 16:  		sb.Append ("x");  		break;  	case 17:  		sb.Append ("v");  		break;  	case 18:  		sb.Append ("g");  		break;  	}  	switch (b) {  	case 0:  		sb.Append ("k");  		break;  	case 1:  		sb.Append ("o");  		break;  	case 2:  		sb.Append ("i");  		break;  	case 3:  		sb.Append ("O");  		break;  	case 4:  		sb.Append ("j");  		break;  	case 5:  		sb.Append ("p");  		break;  	case 6:  		sb.Append ("u");  		break;  	case 7:  		sb.Append ("P");  		break;  	case 8:  		sb.Append ("h");  		break;  	case 9:  		sb.Append ("hk");  		break;  	case 10:  		sb.Append ("ho");  		break;  	case 11:  		sb.Append ("hl");  		break;  	case 12:  		sb.Append ("y");  		break;  	case 13:  		sb.Append ("n");  		break;  	case 14:  		sb.Append ("nj");  		break;  	case 15:  		sb.Append ("np");  		break;  	case 16:  		sb.Append ("nl");  		break;  	case 17:  		sb.Append ("b");  		break;  	case 18:  		sb.Append ("m");  		break;  	case 19:  		sb.Append ("ml");  		break;  	case 20:  		sb.Append ("l");  		break;  	}  	switch (c) {  	case 1:  		sb.Append ("r");  		break;  	case 2:  		sb.Append ("R");  		break;  	case 3:  		sb.Append ("rt");  		break;  	case 4:  		sb.Append ("s");  		break;  	case 5:  		sb.Append ("sw");  		break;  	case 6:  		sb.Append ("sg");  		break;  	case 7:  		sb.Append ("e");  		break;  	case 8:  		sb.Append ("f");  		break;  	case 9:  		sb.Append ("fr");  		break;  	case 10:  		sb.Append ("fa");  		break;  	case 11:  		sb.Append ("fq");  		break;  	case 12:  		sb.Append ("ft");  		break;  	case 13:  		sb.Append ("fx");  		break;  	case 14:  		sb.Append ("fv");  		break;  	case 15:  		sb.Append ("fg");  		break;  	case 16:  		sb.Append ("a");  		break;  	case 17:  		sb.Append ("q");  		break;  	case 18:  		sb.Append ("qt");  		break;  	case 19:  		sb.Append ("t");  		break;  	case 20:  		sb.Append ("T");  		break;  	case 21:  		sb.Append ("d");  		break;  	case 22:  		sb.Append ("w");  		break;  	case 23:  		sb.Append ("c");  		break;  	case 24:  		sb.Append ("z");  		break;  	case 25:  		sb.Append ("x");  		break;  	case 26:  		sb.Append ("v");  		break;  	case 27:  		sb.Append ("g");  		break;  	}  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,ReverseIME,The following statement contains a magic number: foreach (char ch in str.ToCharArray ()) {  	if (ch < 44032 || ch > 55203)// out of range  	 {  		sb.Append (ch);  		continue;  	}  	int a = 0;  	int b = 0;  	int c = 0;  	for (int i = ch - 44032; i >= 588; i -= 588' ++a)  		;  	for (int i = ch - a * 588 - 44032; i >= 28; i -= 28' ++b)  		;  	c = ch - a * 588 - b * 28 - 44032;  	switch (a) {  	case 0:  		sb.Append ("r");  		break;  	case 1:  		sb.Append ("R");  		break;  	case 2:  		sb.Append ("s");  		break;  	case 3:  		sb.Append ("e");  		break;  	case 4:  		sb.Append ("E");  		break;  	case 5:  		sb.Append ("f");  		break;  	case 6:  		sb.Append ("a");  		break;  	case 7:  		sb.Append ("q");  		break;  	case 8:  		sb.Append ("Q");  		break;  	case 9:  		sb.Append ("t");  		break;  	case 10:  		sb.Append ("T");  		break;  	case 11:  		sb.Append ("d");  		break;  	case 12:  		sb.Append ("w");  		break;  	case 13:  		sb.Append ("W");  		break;  	case 14:  		sb.Append ("c");  		break;  	case 15:  		sb.Append ("z");  		break;  	case 16:  		sb.Append ("x");  		break;  	case 17:  		sb.Append ("v");  		break;  	case 18:  		sb.Append ("g");  		break;  	}  	switch (b) {  	case 0:  		sb.Append ("k");  		break;  	case 1:  		sb.Append ("o");  		break;  	case 2:  		sb.Append ("i");  		break;  	case 3:  		sb.Append ("O");  		break;  	case 4:  		sb.Append ("j");  		break;  	case 5:  		sb.Append ("p");  		break;  	case 6:  		sb.Append ("u");  		break;  	case 7:  		sb.Append ("P");  		break;  	case 8:  		sb.Append ("h");  		break;  	case 9:  		sb.Append ("hk");  		break;  	case 10:  		sb.Append ("ho");  		break;  	case 11:  		sb.Append ("hl");  		break;  	case 12:  		sb.Append ("y");  		break;  	case 13:  		sb.Append ("n");  		break;  	case 14:  		sb.Append ("nj");  		break;  	case 15:  		sb.Append ("np");  		break;  	case 16:  		sb.Append ("nl");  		break;  	case 17:  		sb.Append ("b");  		break;  	case 18:  		sb.Append ("m");  		break;  	case 19:  		sb.Append ("ml");  		break;  	case 20:  		sb.Append ("l");  		break;  	}  	switch (c) {  	case 1:  		sb.Append ("r");  		break;  	case 2:  		sb.Append ("R");  		break;  	case 3:  		sb.Append ("rt");  		break;  	case 4:  		sb.Append ("s");  		break;  	case 5:  		sb.Append ("sw");  		break;  	case 6:  		sb.Append ("sg");  		break;  	case 7:  		sb.Append ("e");  		break;  	case 8:  		sb.Append ("f");  		break;  	case 9:  		sb.Append ("fr");  		break;  	case 10:  		sb.Append ("fa");  		break;  	case 11:  		sb.Append ("fq");  		break;  	case 12:  		sb.Append ("ft");  		break;  	case 13:  		sb.Append ("fx");  		break;  	case 14:  		sb.Append ("fv");  		break;  	case 15:  		sb.Append ("fg");  		break;  	case 16:  		sb.Append ("a");  		break;  	case 17:  		sb.Append ("q");  		break;  	case 18:  		sb.Append ("qt");  		break;  	case 19:  		sb.Append ("t");  		break;  	case 20:  		sb.Append ("T");  		break;  	case 21:  		sb.Append ("d");  		break;  	case 22:  		sb.Append ("w");  		break;  	case 23:  		sb.Append ("c");  		break;  	case 24:  		sb.Append ("z");  		break;  	case 25:  		sb.Append ("x");  		break;  	case 26:  		sb.Append ("v");  		break;  	case 27:  		sb.Append ("g");  		break;  	}  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,ReverseIME,The following statement contains a magic number: foreach (char ch in str.ToCharArray ()) {  	if (ch < 44032 || ch > 55203)// out of range  	 {  		sb.Append (ch);  		continue;  	}  	int a = 0;  	int b = 0;  	int c = 0;  	for (int i = ch - 44032; i >= 588; i -= 588' ++a)  		;  	for (int i = ch - a * 588 - 44032; i >= 28; i -= 28' ++b)  		;  	c = ch - a * 588 - b * 28 - 44032;  	switch (a) {  	case 0:  		sb.Append ("r");  		break;  	case 1:  		sb.Append ("R");  		break;  	case 2:  		sb.Append ("s");  		break;  	case 3:  		sb.Append ("e");  		break;  	case 4:  		sb.Append ("E");  		break;  	case 5:  		sb.Append ("f");  		break;  	case 6:  		sb.Append ("a");  		break;  	case 7:  		sb.Append ("q");  		break;  	case 8:  		sb.Append ("Q");  		break;  	case 9:  		sb.Append ("t");  		break;  	case 10:  		sb.Append ("T");  		break;  	case 11:  		sb.Append ("d");  		break;  	case 12:  		sb.Append ("w");  		break;  	case 13:  		sb.Append ("W");  		break;  	case 14:  		sb.Append ("c");  		break;  	case 15:  		sb.Append ("z");  		break;  	case 16:  		sb.Append ("x");  		break;  	case 17:  		sb.Append ("v");  		break;  	case 18:  		sb.Append ("g");  		break;  	}  	switch (b) {  	case 0:  		sb.Append ("k");  		break;  	case 1:  		sb.Append ("o");  		break;  	case 2:  		sb.Append ("i");  		break;  	case 3:  		sb.Append ("O");  		break;  	case 4:  		sb.Append ("j");  		break;  	case 5:  		sb.Append ("p");  		break;  	case 6:  		sb.Append ("u");  		break;  	case 7:  		sb.Append ("P");  		break;  	case 8:  		sb.Append ("h");  		break;  	case 9:  		sb.Append ("hk");  		break;  	case 10:  		sb.Append ("ho");  		break;  	case 11:  		sb.Append ("hl");  		break;  	case 12:  		sb.Append ("y");  		break;  	case 13:  		sb.Append ("n");  		break;  	case 14:  		sb.Append ("nj");  		break;  	case 15:  		sb.Append ("np");  		break;  	case 16:  		sb.Append ("nl");  		break;  	case 17:  		sb.Append ("b");  		break;  	case 18:  		sb.Append ("m");  		break;  	case 19:  		sb.Append ("ml");  		break;  	case 20:  		sb.Append ("l");  		break;  	}  	switch (c) {  	case 1:  		sb.Append ("r");  		break;  	case 2:  		sb.Append ("R");  		break;  	case 3:  		sb.Append ("rt");  		break;  	case 4:  		sb.Append ("s");  		break;  	case 5:  		sb.Append ("sw");  		break;  	case 6:  		sb.Append ("sg");  		break;  	case 7:  		sb.Append ("e");  		break;  	case 8:  		sb.Append ("f");  		break;  	case 9:  		sb.Append ("fr");  		break;  	case 10:  		sb.Append ("fa");  		break;  	case 11:  		sb.Append ("fq");  		break;  	case 12:  		sb.Append ("ft");  		break;  	case 13:  		sb.Append ("fx");  		break;  	case 14:  		sb.Append ("fv");  		break;  	case 15:  		sb.Append ("fg");  		break;  	case 16:  		sb.Append ("a");  		break;  	case 17:  		sb.Append ("q");  		break;  	case 18:  		sb.Append ("qt");  		break;  	case 19:  		sb.Append ("t");  		break;  	case 20:  		sb.Append ("T");  		break;  	case 21:  		sb.Append ("d");  		break;  	case 22:  		sb.Append ("w");  		break;  	case 23:  		sb.Append ("c");  		break;  	case 24:  		sb.Append ("z");  		break;  	case 25:  		sb.Append ("x");  		break;  	case 26:  		sb.Append ("v");  		break;  	case 27:  		sb.Append ("g");  		break;  	}  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,ReverseIME,The following statement contains a magic number: foreach (char ch in str.ToCharArray ()) {  	if (ch < 44032 || ch > 55203)// out of range  	 {  		sb.Append (ch);  		continue;  	}  	int a = 0;  	int b = 0;  	int c = 0;  	for (int i = ch - 44032; i >= 588; i -= 588' ++a)  		;  	for (int i = ch - a * 588 - 44032; i >= 28; i -= 28' ++b)  		;  	c = ch - a * 588 - b * 28 - 44032;  	switch (a) {  	case 0:  		sb.Append ("r");  		break;  	case 1:  		sb.Append ("R");  		break;  	case 2:  		sb.Append ("s");  		break;  	case 3:  		sb.Append ("e");  		break;  	case 4:  		sb.Append ("E");  		break;  	case 5:  		sb.Append ("f");  		break;  	case 6:  		sb.Append ("a");  		break;  	case 7:  		sb.Append ("q");  		break;  	case 8:  		sb.Append ("Q");  		break;  	case 9:  		sb.Append ("t");  		break;  	case 10:  		sb.Append ("T");  		break;  	case 11:  		sb.Append ("d");  		break;  	case 12:  		sb.Append ("w");  		break;  	case 13:  		sb.Append ("W");  		break;  	case 14:  		sb.Append ("c");  		break;  	case 15:  		sb.Append ("z");  		break;  	case 16:  		sb.Append ("x");  		break;  	case 17:  		sb.Append ("v");  		break;  	case 18:  		sb.Append ("g");  		break;  	}  	switch (b) {  	case 0:  		sb.Append ("k");  		break;  	case 1:  		sb.Append ("o");  		break;  	case 2:  		sb.Append ("i");  		break;  	case 3:  		sb.Append ("O");  		break;  	case 4:  		sb.Append ("j");  		break;  	case 5:  		sb.Append ("p");  		break;  	case 6:  		sb.Append ("u");  		break;  	case 7:  		sb.Append ("P");  		break;  	case 8:  		sb.Append ("h");  		break;  	case 9:  		sb.Append ("hk");  		break;  	case 10:  		sb.Append ("ho");  		break;  	case 11:  		sb.Append ("hl");  		break;  	case 12:  		sb.Append ("y");  		break;  	case 13:  		sb.Append ("n");  		break;  	case 14:  		sb.Append ("nj");  		break;  	case 15:  		sb.Append ("np");  		break;  	case 16:  		sb.Append ("nl");  		break;  	case 17:  		sb.Append ("b");  		break;  	case 18:  		sb.Append ("m");  		break;  	case 19:  		sb.Append ("ml");  		break;  	case 20:  		sb.Append ("l");  		break;  	}  	switch (c) {  	case 1:  		sb.Append ("r");  		break;  	case 2:  		sb.Append ("R");  		break;  	case 3:  		sb.Append ("rt");  		break;  	case 4:  		sb.Append ("s");  		break;  	case 5:  		sb.Append ("sw");  		break;  	case 6:  		sb.Append ("sg");  		break;  	case 7:  		sb.Append ("e");  		break;  	case 8:  		sb.Append ("f");  		break;  	case 9:  		sb.Append ("fr");  		break;  	case 10:  		sb.Append ("fa");  		break;  	case 11:  		sb.Append ("fq");  		break;  	case 12:  		sb.Append ("ft");  		break;  	case 13:  		sb.Append ("fx");  		break;  	case 14:  		sb.Append ("fv");  		break;  	case 15:  		sb.Append ("fg");  		break;  	case 16:  		sb.Append ("a");  		break;  	case 17:  		sb.Append ("q");  		break;  	case 18:  		sb.Append ("qt");  		break;  	case 19:  		sb.Append ("t");  		break;  	case 20:  		sb.Append ("T");  		break;  	case 21:  		sb.Append ("d");  		break;  	case 22:  		sb.Append ("w");  		break;  	case 23:  		sb.Append ("c");  		break;  	case 24:  		sb.Append ("z");  		break;  	case 25:  		sb.Append ("x");  		break;  	case 26:  		sb.Append ("v");  		break;  	case 27:  		sb.Append ("g");  		break;  	}  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,ReverseIME,The following statement contains a magic number: foreach (char ch in str.ToCharArray ()) {  	if (ch < 44032 || ch > 55203)// out of range  	 {  		sb.Append (ch);  		continue;  	}  	int a = 0;  	int b = 0;  	int c = 0;  	for (int i = ch - 44032; i >= 588; i -= 588' ++a)  		;  	for (int i = ch - a * 588 - 44032; i >= 28; i -= 28' ++b)  		;  	c = ch - a * 588 - b * 28 - 44032;  	switch (a) {  	case 0:  		sb.Append ("r");  		break;  	case 1:  		sb.Append ("R");  		break;  	case 2:  		sb.Append ("s");  		break;  	case 3:  		sb.Append ("e");  		break;  	case 4:  		sb.Append ("E");  		break;  	case 5:  		sb.Append ("f");  		break;  	case 6:  		sb.Append ("a");  		break;  	case 7:  		sb.Append ("q");  		break;  	case 8:  		sb.Append ("Q");  		break;  	case 9:  		sb.Append ("t");  		break;  	case 10:  		sb.Append ("T");  		break;  	case 11:  		sb.Append ("d");  		break;  	case 12:  		sb.Append ("w");  		break;  	case 13:  		sb.Append ("W");  		break;  	case 14:  		sb.Append ("c");  		break;  	case 15:  		sb.Append ("z");  		break;  	case 16:  		sb.Append ("x");  		break;  	case 17:  		sb.Append ("v");  		break;  	case 18:  		sb.Append ("g");  		break;  	}  	switch (b) {  	case 0:  		sb.Append ("k");  		break;  	case 1:  		sb.Append ("o");  		break;  	case 2:  		sb.Append ("i");  		break;  	case 3:  		sb.Append ("O");  		break;  	case 4:  		sb.Append ("j");  		break;  	case 5:  		sb.Append ("p");  		break;  	case 6:  		sb.Append ("u");  		break;  	case 7:  		sb.Append ("P");  		break;  	case 8:  		sb.Append ("h");  		break;  	case 9:  		sb.Append ("hk");  		break;  	case 10:  		sb.Append ("ho");  		break;  	case 11:  		sb.Append ("hl");  		break;  	case 12:  		sb.Append ("y");  		break;  	case 13:  		sb.Append ("n");  		break;  	case 14:  		sb.Append ("nj");  		break;  	case 15:  		sb.Append ("np");  		break;  	case 16:  		sb.Append ("nl");  		break;  	case 17:  		sb.Append ("b");  		break;  	case 18:  		sb.Append ("m");  		break;  	case 19:  		sb.Append ("ml");  		break;  	case 20:  		sb.Append ("l");  		break;  	}  	switch (c) {  	case 1:  		sb.Append ("r");  		break;  	case 2:  		sb.Append ("R");  		break;  	case 3:  		sb.Append ("rt");  		break;  	case 4:  		sb.Append ("s");  		break;  	case 5:  		sb.Append ("sw");  		break;  	case 6:  		sb.Append ("sg");  		break;  	case 7:  		sb.Append ("e");  		break;  	case 8:  		sb.Append ("f");  		break;  	case 9:  		sb.Append ("fr");  		break;  	case 10:  		sb.Append ("fa");  		break;  	case 11:  		sb.Append ("fq");  		break;  	case 12:  		sb.Append ("ft");  		break;  	case 13:  		sb.Append ("fx");  		break;  	case 14:  		sb.Append ("fv");  		break;  	case 15:  		sb.Append ("fg");  		break;  	case 16:  		sb.Append ("a");  		break;  	case 17:  		sb.Append ("q");  		break;  	case 18:  		sb.Append ("qt");  		break;  	case 19:  		sb.Append ("t");  		break;  	case 20:  		sb.Append ("T");  		break;  	case 21:  		sb.Append ("d");  		break;  	case 22:  		sb.Append ("w");  		break;  	case 23:  		sb.Append ("c");  		break;  	case 24:  		sb.Append ("z");  		break;  	case 25:  		sb.Append ("x");  		break;  	case 26:  		sb.Append ("v");  		break;  	case 27:  		sb.Append ("g");  		break;  	}  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,ReverseIME,The following statement contains a magic number: foreach (char ch in str.ToCharArray ()) {  	if (ch < 44032 || ch > 55203)// out of range  	 {  		sb.Append (ch);  		continue;  	}  	int a = 0;  	int b = 0;  	int c = 0;  	for (int i = ch - 44032; i >= 588; i -= 588' ++a)  		;  	for (int i = ch - a * 588 - 44032; i >= 28; i -= 28' ++b)  		;  	c = ch - a * 588 - b * 28 - 44032;  	switch (a) {  	case 0:  		sb.Append ("r");  		break;  	case 1:  		sb.Append ("R");  		break;  	case 2:  		sb.Append ("s");  		break;  	case 3:  		sb.Append ("e");  		break;  	case 4:  		sb.Append ("E");  		break;  	case 5:  		sb.Append ("f");  		break;  	case 6:  		sb.Append ("a");  		break;  	case 7:  		sb.Append ("q");  		break;  	case 8:  		sb.Append ("Q");  		break;  	case 9:  		sb.Append ("t");  		break;  	case 10:  		sb.Append ("T");  		break;  	case 11:  		sb.Append ("d");  		break;  	case 12:  		sb.Append ("w");  		break;  	case 13:  		sb.Append ("W");  		break;  	case 14:  		sb.Append ("c");  		break;  	case 15:  		sb.Append ("z");  		break;  	case 16:  		sb.Append ("x");  		break;  	case 17:  		sb.Append ("v");  		break;  	case 18:  		sb.Append ("g");  		break;  	}  	switch (b) {  	case 0:  		sb.Append ("k");  		break;  	case 1:  		sb.Append ("o");  		break;  	case 2:  		sb.Append ("i");  		break;  	case 3:  		sb.Append ("O");  		break;  	case 4:  		sb.Append ("j");  		break;  	case 5:  		sb.Append ("p");  		break;  	case 6:  		sb.Append ("u");  		break;  	case 7:  		sb.Append ("P");  		break;  	case 8:  		sb.Append ("h");  		break;  	case 9:  		sb.Append ("hk");  		break;  	case 10:  		sb.Append ("ho");  		break;  	case 11:  		sb.Append ("hl");  		break;  	case 12:  		sb.Append ("y");  		break;  	case 13:  		sb.Append ("n");  		break;  	case 14:  		sb.Append ("nj");  		break;  	case 15:  		sb.Append ("np");  		break;  	case 16:  		sb.Append ("nl");  		break;  	case 17:  		sb.Append ("b");  		break;  	case 18:  		sb.Append ("m");  		break;  	case 19:  		sb.Append ("ml");  		break;  	case 20:  		sb.Append ("l");  		break;  	}  	switch (c) {  	case 1:  		sb.Append ("r");  		break;  	case 2:  		sb.Append ("R");  		break;  	case 3:  		sb.Append ("rt");  		break;  	case 4:  		sb.Append ("s");  		break;  	case 5:  		sb.Append ("sw");  		break;  	case 6:  		sb.Append ("sg");  		break;  	case 7:  		sb.Append ("e");  		break;  	case 8:  		sb.Append ("f");  		break;  	case 9:  		sb.Append ("fr");  		break;  	case 10:  		sb.Append ("fa");  		break;  	case 11:  		sb.Append ("fq");  		break;  	case 12:  		sb.Append ("ft");  		break;  	case 13:  		sb.Append ("fx");  		break;  	case 14:  		sb.Append ("fv");  		break;  	case 15:  		sb.Append ("fg");  		break;  	case 16:  		sb.Append ("a");  		break;  	case 17:  		sb.Append ("q");  		break;  	case 18:  		sb.Append ("qt");  		break;  	case 19:  		sb.Append ("t");  		break;  	case 20:  		sb.Append ("T");  		break;  	case 21:  		sb.Append ("d");  		break;  	case 22:  		sb.Append ("w");  		break;  	case 23:  		sb.Append ("c");  		break;  	case 24:  		sb.Append ("z");  		break;  	case 25:  		sb.Append ("x");  		break;  	case 26:  		sb.Append ("v");  		break;  	case 27:  		sb.Append ("g");  		break;  	}  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,ReverseIME,The following statement contains a magic number: foreach (char ch in str.ToCharArray ()) {  	if (ch < 44032 || ch > 55203)// out of range  	 {  		sb.Append (ch);  		continue;  	}  	int a = 0;  	int b = 0;  	int c = 0;  	for (int i = ch - 44032; i >= 588; i -= 588' ++a)  		;  	for (int i = ch - a * 588 - 44032; i >= 28; i -= 28' ++b)  		;  	c = ch - a * 588 - b * 28 - 44032;  	switch (a) {  	case 0:  		sb.Append ("r");  		break;  	case 1:  		sb.Append ("R");  		break;  	case 2:  		sb.Append ("s");  		break;  	case 3:  		sb.Append ("e");  		break;  	case 4:  		sb.Append ("E");  		break;  	case 5:  		sb.Append ("f");  		break;  	case 6:  		sb.Append ("a");  		break;  	case 7:  		sb.Append ("q");  		break;  	case 8:  		sb.Append ("Q");  		break;  	case 9:  		sb.Append ("t");  		break;  	case 10:  		sb.Append ("T");  		break;  	case 11:  		sb.Append ("d");  		break;  	case 12:  		sb.Append ("w");  		break;  	case 13:  		sb.Append ("W");  		break;  	case 14:  		sb.Append ("c");  		break;  	case 15:  		sb.Append ("z");  		break;  	case 16:  		sb.Append ("x");  		break;  	case 17:  		sb.Append ("v");  		break;  	case 18:  		sb.Append ("g");  		break;  	}  	switch (b) {  	case 0:  		sb.Append ("k");  		break;  	case 1:  		sb.Append ("o");  		break;  	case 2:  		sb.Append ("i");  		break;  	case 3:  		sb.Append ("O");  		break;  	case 4:  		sb.Append ("j");  		break;  	case 5:  		sb.Append ("p");  		break;  	case 6:  		sb.Append ("u");  		break;  	case 7:  		sb.Append ("P");  		break;  	case 8:  		sb.Append ("h");  		break;  	case 9:  		sb.Append ("hk");  		break;  	case 10:  		sb.Append ("ho");  		break;  	case 11:  		sb.Append ("hl");  		break;  	case 12:  		sb.Append ("y");  		break;  	case 13:  		sb.Append ("n");  		break;  	case 14:  		sb.Append ("nj");  		break;  	case 15:  		sb.Append ("np");  		break;  	case 16:  		sb.Append ("nl");  		break;  	case 17:  		sb.Append ("b");  		break;  	case 18:  		sb.Append ("m");  		break;  	case 19:  		sb.Append ("ml");  		break;  	case 20:  		sb.Append ("l");  		break;  	}  	switch (c) {  	case 1:  		sb.Append ("r");  		break;  	case 2:  		sb.Append ("R");  		break;  	case 3:  		sb.Append ("rt");  		break;  	case 4:  		sb.Append ("s");  		break;  	case 5:  		sb.Append ("sw");  		break;  	case 6:  		sb.Append ("sg");  		break;  	case 7:  		sb.Append ("e");  		break;  	case 8:  		sb.Append ("f");  		break;  	case 9:  		sb.Append ("fr");  		break;  	case 10:  		sb.Append ("fa");  		break;  	case 11:  		sb.Append ("fq");  		break;  	case 12:  		sb.Append ("ft");  		break;  	case 13:  		sb.Append ("fx");  		break;  	case 14:  		sb.Append ("fv");  		break;  	case 15:  		sb.Append ("fg");  		break;  	case 16:  		sb.Append ("a");  		break;  	case 17:  		sb.Append ("q");  		break;  	case 18:  		sb.Append ("qt");  		break;  	case 19:  		sb.Append ("t");  		break;  	case 20:  		sb.Append ("T");  		break;  	case 21:  		sb.Append ("d");  		break;  	case 22:  		sb.Append ("w");  		break;  	case 23:  		sb.Append ("c");  		break;  	case 24:  		sb.Append ("z");  		break;  	case 25:  		sb.Append ("x");  		break;  	case 26:  		sb.Append ("v");  		break;  	case 27:  		sb.Append ("g");  		break;  	}  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,ReverseIME,The following statement contains a magic number: foreach (char ch in str.ToCharArray ()) {  	if (ch < 44032 || ch > 55203)// out of range  	 {  		sb.Append (ch);  		continue;  	}  	int a = 0;  	int b = 0;  	int c = 0;  	for (int i = ch - 44032; i >= 588; i -= 588' ++a)  		;  	for (int i = ch - a * 588 - 44032; i >= 28; i -= 28' ++b)  		;  	c = ch - a * 588 - b * 28 - 44032;  	switch (a) {  	case 0:  		sb.Append ("r");  		break;  	case 1:  		sb.Append ("R");  		break;  	case 2:  		sb.Append ("s");  		break;  	case 3:  		sb.Append ("e");  		break;  	case 4:  		sb.Append ("E");  		break;  	case 5:  		sb.Append ("f");  		break;  	case 6:  		sb.Append ("a");  		break;  	case 7:  		sb.Append ("q");  		break;  	case 8:  		sb.Append ("Q");  		break;  	case 9:  		sb.Append ("t");  		break;  	case 10:  		sb.Append ("T");  		break;  	case 11:  		sb.Append ("d");  		break;  	case 12:  		sb.Append ("w");  		break;  	case 13:  		sb.Append ("W");  		break;  	case 14:  		sb.Append ("c");  		break;  	case 15:  		sb.Append ("z");  		break;  	case 16:  		sb.Append ("x");  		break;  	case 17:  		sb.Append ("v");  		break;  	case 18:  		sb.Append ("g");  		break;  	}  	switch (b) {  	case 0:  		sb.Append ("k");  		break;  	case 1:  		sb.Append ("o");  		break;  	case 2:  		sb.Append ("i");  		break;  	case 3:  		sb.Append ("O");  		break;  	case 4:  		sb.Append ("j");  		break;  	case 5:  		sb.Append ("p");  		break;  	case 6:  		sb.Append ("u");  		break;  	case 7:  		sb.Append ("P");  		break;  	case 8:  		sb.Append ("h");  		break;  	case 9:  		sb.Append ("hk");  		break;  	case 10:  		sb.Append ("ho");  		break;  	case 11:  		sb.Append ("hl");  		break;  	case 12:  		sb.Append ("y");  		break;  	case 13:  		sb.Append ("n");  		break;  	case 14:  		sb.Append ("nj");  		break;  	case 15:  		sb.Append ("np");  		break;  	case 16:  		sb.Append ("nl");  		break;  	case 17:  		sb.Append ("b");  		break;  	case 18:  		sb.Append ("m");  		break;  	case 19:  		sb.Append ("ml");  		break;  	case 20:  		sb.Append ("l");  		break;  	}  	switch (c) {  	case 1:  		sb.Append ("r");  		break;  	case 2:  		sb.Append ("R");  		break;  	case 3:  		sb.Append ("rt");  		break;  	case 4:  		sb.Append ("s");  		break;  	case 5:  		sb.Append ("sw");  		break;  	case 6:  		sb.Append ("sg");  		break;  	case 7:  		sb.Append ("e");  		break;  	case 8:  		sb.Append ("f");  		break;  	case 9:  		sb.Append ("fr");  		break;  	case 10:  		sb.Append ("fa");  		break;  	case 11:  		sb.Append ("fq");  		break;  	case 12:  		sb.Append ("ft");  		break;  	case 13:  		sb.Append ("fx");  		break;  	case 14:  		sb.Append ("fv");  		break;  	case 15:  		sb.Append ("fg");  		break;  	case 16:  		sb.Append ("a");  		break;  	case 17:  		sb.Append ("q");  		break;  	case 18:  		sb.Append ("qt");  		break;  	case 19:  		sb.Append ("t");  		break;  	case 20:  		sb.Append ("T");  		break;  	case 21:  		sb.Append ("d");  		break;  	case 22:  		sb.Append ("w");  		break;  	case 23:  		sb.Append ("c");  		break;  	case 24:  		sb.Append ("z");  		break;  	case 25:  		sb.Append ("x");  		break;  	case 26:  		sb.Append ("v");  		break;  	case 27:  		sb.Append ("g");  		break;  	}  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,ReverseIME,The following statement contains a magic number: foreach (char ch in str.ToCharArray ()) {  	if (ch < 44032 || ch > 55203)// out of range  	 {  		sb.Append (ch);  		continue;  	}  	int a = 0;  	int b = 0;  	int c = 0;  	for (int i = ch - 44032; i >= 588; i -= 588' ++a)  		;  	for (int i = ch - a * 588 - 44032; i >= 28; i -= 28' ++b)  		;  	c = ch - a * 588 - b * 28 - 44032;  	switch (a) {  	case 0:  		sb.Append ("r");  		break;  	case 1:  		sb.Append ("R");  		break;  	case 2:  		sb.Append ("s");  		break;  	case 3:  		sb.Append ("e");  		break;  	case 4:  		sb.Append ("E");  		break;  	case 5:  		sb.Append ("f");  		break;  	case 6:  		sb.Append ("a");  		break;  	case 7:  		sb.Append ("q");  		break;  	case 8:  		sb.Append ("Q");  		break;  	case 9:  		sb.Append ("t");  		break;  	case 10:  		sb.Append ("T");  		break;  	case 11:  		sb.Append ("d");  		break;  	case 12:  		sb.Append ("w");  		break;  	case 13:  		sb.Append ("W");  		break;  	case 14:  		sb.Append ("c");  		break;  	case 15:  		sb.Append ("z");  		break;  	case 16:  		sb.Append ("x");  		break;  	case 17:  		sb.Append ("v");  		break;  	case 18:  		sb.Append ("g");  		break;  	}  	switch (b) {  	case 0:  		sb.Append ("k");  		break;  	case 1:  		sb.Append ("o");  		break;  	case 2:  		sb.Append ("i");  		break;  	case 3:  		sb.Append ("O");  		break;  	case 4:  		sb.Append ("j");  		break;  	case 5:  		sb.Append ("p");  		break;  	case 6:  		sb.Append ("u");  		break;  	case 7:  		sb.Append ("P");  		break;  	case 8:  		sb.Append ("h");  		break;  	case 9:  		sb.Append ("hk");  		break;  	case 10:  		sb.Append ("ho");  		break;  	case 11:  		sb.Append ("hl");  		break;  	case 12:  		sb.Append ("y");  		break;  	case 13:  		sb.Append ("n");  		break;  	case 14:  		sb.Append ("nj");  		break;  	case 15:  		sb.Append ("np");  		break;  	case 16:  		sb.Append ("nl");  		break;  	case 17:  		sb.Append ("b");  		break;  	case 18:  		sb.Append ("m");  		break;  	case 19:  		sb.Append ("ml");  		break;  	case 20:  		sb.Append ("l");  		break;  	}  	switch (c) {  	case 1:  		sb.Append ("r");  		break;  	case 2:  		sb.Append ("R");  		break;  	case 3:  		sb.Append ("rt");  		break;  	case 4:  		sb.Append ("s");  		break;  	case 5:  		sb.Append ("sw");  		break;  	case 6:  		sb.Append ("sg");  		break;  	case 7:  		sb.Append ("e");  		break;  	case 8:  		sb.Append ("f");  		break;  	case 9:  		sb.Append ("fr");  		break;  	case 10:  		sb.Append ("fa");  		break;  	case 11:  		sb.Append ("fq");  		break;  	case 12:  		sb.Append ("ft");  		break;  	case 13:  		sb.Append ("fx");  		break;  	case 14:  		sb.Append ("fv");  		break;  	case 15:  		sb.Append ("fg");  		break;  	case 16:  		sb.Append ("a");  		break;  	case 17:  		sb.Append ("q");  		break;  	case 18:  		sb.Append ("qt");  		break;  	case 19:  		sb.Append ("t");  		break;  	case 20:  		sb.Append ("T");  		break;  	case 21:  		sb.Append ("d");  		break;  	case 22:  		sb.Append ("w");  		break;  	case 23:  		sb.Append ("c");  		break;  	case 24:  		sb.Append ("z");  		break;  	case 25:  		sb.Append ("x");  		break;  	case 26:  		sb.Append ("v");  		break;  	case 27:  		sb.Append ("g");  		break;  	}  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,ReverseIME,The following statement contains a magic number: foreach (char ch in str.ToCharArray ()) {  	if (ch < 44032 || ch > 55203)// out of range  	 {  		sb.Append (ch);  		continue;  	}  	int a = 0;  	int b = 0;  	int c = 0;  	for (int i = ch - 44032; i >= 588; i -= 588' ++a)  		;  	for (int i = ch - a * 588 - 44032; i >= 28; i -= 28' ++b)  		;  	c = ch - a * 588 - b * 28 - 44032;  	switch (a) {  	case 0:  		sb.Append ("r");  		break;  	case 1:  		sb.Append ("R");  		break;  	case 2:  		sb.Append ("s");  		break;  	case 3:  		sb.Append ("e");  		break;  	case 4:  		sb.Append ("E");  		break;  	case 5:  		sb.Append ("f");  		break;  	case 6:  		sb.Append ("a");  		break;  	case 7:  		sb.Append ("q");  		break;  	case 8:  		sb.Append ("Q");  		break;  	case 9:  		sb.Append ("t");  		break;  	case 10:  		sb.Append ("T");  		break;  	case 11:  		sb.Append ("d");  		break;  	case 12:  		sb.Append ("w");  		break;  	case 13:  		sb.Append ("W");  		break;  	case 14:  		sb.Append ("c");  		break;  	case 15:  		sb.Append ("z");  		break;  	case 16:  		sb.Append ("x");  		break;  	case 17:  		sb.Append ("v");  		break;  	case 18:  		sb.Append ("g");  		break;  	}  	switch (b) {  	case 0:  		sb.Append ("k");  		break;  	case 1:  		sb.Append ("o");  		break;  	case 2:  		sb.Append ("i");  		break;  	case 3:  		sb.Append ("O");  		break;  	case 4:  		sb.Append ("j");  		break;  	case 5:  		sb.Append ("p");  		break;  	case 6:  		sb.Append ("u");  		break;  	case 7:  		sb.Append ("P");  		break;  	case 8:  		sb.Append ("h");  		break;  	case 9:  		sb.Append ("hk");  		break;  	case 10:  		sb.Append ("ho");  		break;  	case 11:  		sb.Append ("hl");  		break;  	case 12:  		sb.Append ("y");  		break;  	case 13:  		sb.Append ("n");  		break;  	case 14:  		sb.Append ("nj");  		break;  	case 15:  		sb.Append ("np");  		break;  	case 16:  		sb.Append ("nl");  		break;  	case 17:  		sb.Append ("b");  		break;  	case 18:  		sb.Append ("m");  		break;  	case 19:  		sb.Append ("ml");  		break;  	case 20:  		sb.Append ("l");  		break;  	}  	switch (c) {  	case 1:  		sb.Append ("r");  		break;  	case 2:  		sb.Append ("R");  		break;  	case 3:  		sb.Append ("rt");  		break;  	case 4:  		sb.Append ("s");  		break;  	case 5:  		sb.Append ("sw");  		break;  	case 6:  		sb.Append ("sg");  		break;  	case 7:  		sb.Append ("e");  		break;  	case 8:  		sb.Append ("f");  		break;  	case 9:  		sb.Append ("fr");  		break;  	case 10:  		sb.Append ("fa");  		break;  	case 11:  		sb.Append ("fq");  		break;  	case 12:  		sb.Append ("ft");  		break;  	case 13:  		sb.Append ("fx");  		break;  	case 14:  		sb.Append ("fv");  		break;  	case 15:  		sb.Append ("fg");  		break;  	case 16:  		sb.Append ("a");  		break;  	case 17:  		sb.Append ("q");  		break;  	case 18:  		sb.Append ("qt");  		break;  	case 19:  		sb.Append ("t");  		break;  	case 20:  		sb.Append ("T");  		break;  	case 21:  		sb.Append ("d");  		break;  	case 22:  		sb.Append ("w");  		break;  	case 23:  		sb.Append ("c");  		break;  	case 24:  		sb.Append ("z");  		break;  	case 25:  		sb.Append ("x");  		break;  	case 26:  		sb.Append ("v");  		break;  	case 27:  		sb.Append ("g");  		break;  	}  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,ReverseIME,The following statement contains a magic number: foreach (char ch in str.ToCharArray ()) {  	if (ch < 44032 || ch > 55203)// out of range  	 {  		sb.Append (ch);  		continue;  	}  	int a = 0;  	int b = 0;  	int c = 0;  	for (int i = ch - 44032; i >= 588; i -= 588' ++a)  		;  	for (int i = ch - a * 588 - 44032; i >= 28; i -= 28' ++b)  		;  	c = ch - a * 588 - b * 28 - 44032;  	switch (a) {  	case 0:  		sb.Append ("r");  		break;  	case 1:  		sb.Append ("R");  		break;  	case 2:  		sb.Append ("s");  		break;  	case 3:  		sb.Append ("e");  		break;  	case 4:  		sb.Append ("E");  		break;  	case 5:  		sb.Append ("f");  		break;  	case 6:  		sb.Append ("a");  		break;  	case 7:  		sb.Append ("q");  		break;  	case 8:  		sb.Append ("Q");  		break;  	case 9:  		sb.Append ("t");  		break;  	case 10:  		sb.Append ("T");  		break;  	case 11:  		sb.Append ("d");  		break;  	case 12:  		sb.Append ("w");  		break;  	case 13:  		sb.Append ("W");  		break;  	case 14:  		sb.Append ("c");  		break;  	case 15:  		sb.Append ("z");  		break;  	case 16:  		sb.Append ("x");  		break;  	case 17:  		sb.Append ("v");  		break;  	case 18:  		sb.Append ("g");  		break;  	}  	switch (b) {  	case 0:  		sb.Append ("k");  		break;  	case 1:  		sb.Append ("o");  		break;  	case 2:  		sb.Append ("i");  		break;  	case 3:  		sb.Append ("O");  		break;  	case 4:  		sb.Append ("j");  		break;  	case 5:  		sb.Append ("p");  		break;  	case 6:  		sb.Append ("u");  		break;  	case 7:  		sb.Append ("P");  		break;  	case 8:  		sb.Append ("h");  		break;  	case 9:  		sb.Append ("hk");  		break;  	case 10:  		sb.Append ("ho");  		break;  	case 11:  		sb.Append ("hl");  		break;  	case 12:  		sb.Append ("y");  		break;  	case 13:  		sb.Append ("n");  		break;  	case 14:  		sb.Append ("nj");  		break;  	case 15:  		sb.Append ("np");  		break;  	case 16:  		sb.Append ("nl");  		break;  	case 17:  		sb.Append ("b");  		break;  	case 18:  		sb.Append ("m");  		break;  	case 19:  		sb.Append ("ml");  		break;  	case 20:  		sb.Append ("l");  		break;  	}  	switch (c) {  	case 1:  		sb.Append ("r");  		break;  	case 2:  		sb.Append ("R");  		break;  	case 3:  		sb.Append ("rt");  		break;  	case 4:  		sb.Append ("s");  		break;  	case 5:  		sb.Append ("sw");  		break;  	case 6:  		sb.Append ("sg");  		break;  	case 7:  		sb.Append ("e");  		break;  	case 8:  		sb.Append ("f");  		break;  	case 9:  		sb.Append ("fr");  		break;  	case 10:  		sb.Append ("fa");  		break;  	case 11:  		sb.Append ("fq");  		break;  	case 12:  		sb.Append ("ft");  		break;  	case 13:  		sb.Append ("fx");  		break;  	case 14:  		sb.Append ("fv");  		break;  	case 15:  		sb.Append ("fg");  		break;  	case 16:  		sb.Append ("a");  		break;  	case 17:  		sb.Append ("q");  		break;  	case 18:  		sb.Append ("qt");  		break;  	case 19:  		sb.Append ("t");  		break;  	case 20:  		sb.Append ("T");  		break;  	case 21:  		sb.Append ("d");  		break;  	case 22:  		sb.Append ("w");  		break;  	case 23:  		sb.Append ("c");  		break;  	case 24:  		sb.Append ("z");  		break;  	case 25:  		sb.Append ("x");  		break;  	case 26:  		sb.Append ("v");  		break;  	case 27:  		sb.Append ("g");  		break;  	}  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,ReverseIME,The following statement contains a magic number: foreach (char ch in str.ToCharArray ()) {  	if (ch < 44032 || ch > 55203)// out of range  	 {  		sb.Append (ch);  		continue;  	}  	int a = 0;  	int b = 0;  	int c = 0;  	for (int i = ch - 44032; i >= 588; i -= 588' ++a)  		;  	for (int i = ch - a * 588 - 44032; i >= 28; i -= 28' ++b)  		;  	c = ch - a * 588 - b * 28 - 44032;  	switch (a) {  	case 0:  		sb.Append ("r");  		break;  	case 1:  		sb.Append ("R");  		break;  	case 2:  		sb.Append ("s");  		break;  	case 3:  		sb.Append ("e");  		break;  	case 4:  		sb.Append ("E");  		break;  	case 5:  		sb.Append ("f");  		break;  	case 6:  		sb.Append ("a");  		break;  	case 7:  		sb.Append ("q");  		break;  	case 8:  		sb.Append ("Q");  		break;  	case 9:  		sb.Append ("t");  		break;  	case 10:  		sb.Append ("T");  		break;  	case 11:  		sb.Append ("d");  		break;  	case 12:  		sb.Append ("w");  		break;  	case 13:  		sb.Append ("W");  		break;  	case 14:  		sb.Append ("c");  		break;  	case 15:  		sb.Append ("z");  		break;  	case 16:  		sb.Append ("x");  		break;  	case 17:  		sb.Append ("v");  		break;  	case 18:  		sb.Append ("g");  		break;  	}  	switch (b) {  	case 0:  		sb.Append ("k");  		break;  	case 1:  		sb.Append ("o");  		break;  	case 2:  		sb.Append ("i");  		break;  	case 3:  		sb.Append ("O");  		break;  	case 4:  		sb.Append ("j");  		break;  	case 5:  		sb.Append ("p");  		break;  	case 6:  		sb.Append ("u");  		break;  	case 7:  		sb.Append ("P");  		break;  	case 8:  		sb.Append ("h");  		break;  	case 9:  		sb.Append ("hk");  		break;  	case 10:  		sb.Append ("ho");  		break;  	case 11:  		sb.Append ("hl");  		break;  	case 12:  		sb.Append ("y");  		break;  	case 13:  		sb.Append ("n");  		break;  	case 14:  		sb.Append ("nj");  		break;  	case 15:  		sb.Append ("np");  		break;  	case 16:  		sb.Append ("nl");  		break;  	case 17:  		sb.Append ("b");  		break;  	case 18:  		sb.Append ("m");  		break;  	case 19:  		sb.Append ("ml");  		break;  	case 20:  		sb.Append ("l");  		break;  	}  	switch (c) {  	case 1:  		sb.Append ("r");  		break;  	case 2:  		sb.Append ("R");  		break;  	case 3:  		sb.Append ("rt");  		break;  	case 4:  		sb.Append ("s");  		break;  	case 5:  		sb.Append ("sw");  		break;  	case 6:  		sb.Append ("sg");  		break;  	case 7:  		sb.Append ("e");  		break;  	case 8:  		sb.Append ("f");  		break;  	case 9:  		sb.Append ("fr");  		break;  	case 10:  		sb.Append ("fa");  		break;  	case 11:  		sb.Append ("fq");  		break;  	case 12:  		sb.Append ("ft");  		break;  	case 13:  		sb.Append ("fx");  		break;  	case 14:  		sb.Append ("fv");  		break;  	case 15:  		sb.Append ("fg");  		break;  	case 16:  		sb.Append ("a");  		break;  	case 17:  		sb.Append ("q");  		break;  	case 18:  		sb.Append ("qt");  		break;  	case 19:  		sb.Append ("t");  		break;  	case 20:  		sb.Append ("T");  		break;  	case 21:  		sb.Append ("d");  		break;  	case 22:  		sb.Append ("w");  		break;  	case 23:  		sb.Append ("c");  		break;  	case 24:  		sb.Append ("z");  		break;  	case 25:  		sb.Append ("x");  		break;  	case 26:  		sb.Append ("v");  		break;  	case 27:  		sb.Append ("g");  		break;  	}  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,ReverseIME,The following statement contains a magic number: foreach (char ch in str.ToCharArray ()) {  	if (ch < 44032 || ch > 55203)// out of range  	 {  		sb.Append (ch);  		continue;  	}  	int a = 0;  	int b = 0;  	int c = 0;  	for (int i = ch - 44032; i >= 588; i -= 588' ++a)  		;  	for (int i = ch - a * 588 - 44032; i >= 28; i -= 28' ++b)  		;  	c = ch - a * 588 - b * 28 - 44032;  	switch (a) {  	case 0:  		sb.Append ("r");  		break;  	case 1:  		sb.Append ("R");  		break;  	case 2:  		sb.Append ("s");  		break;  	case 3:  		sb.Append ("e");  		break;  	case 4:  		sb.Append ("E");  		break;  	case 5:  		sb.Append ("f");  		break;  	case 6:  		sb.Append ("a");  		break;  	case 7:  		sb.Append ("q");  		break;  	case 8:  		sb.Append ("Q");  		break;  	case 9:  		sb.Append ("t");  		break;  	case 10:  		sb.Append ("T");  		break;  	case 11:  		sb.Append ("d");  		break;  	case 12:  		sb.Append ("w");  		break;  	case 13:  		sb.Append ("W");  		break;  	case 14:  		sb.Append ("c");  		break;  	case 15:  		sb.Append ("z");  		break;  	case 16:  		sb.Append ("x");  		break;  	case 17:  		sb.Append ("v");  		break;  	case 18:  		sb.Append ("g");  		break;  	}  	switch (b) {  	case 0:  		sb.Append ("k");  		break;  	case 1:  		sb.Append ("o");  		break;  	case 2:  		sb.Append ("i");  		break;  	case 3:  		sb.Append ("O");  		break;  	case 4:  		sb.Append ("j");  		break;  	case 5:  		sb.Append ("p");  		break;  	case 6:  		sb.Append ("u");  		break;  	case 7:  		sb.Append ("P");  		break;  	case 8:  		sb.Append ("h");  		break;  	case 9:  		sb.Append ("hk");  		break;  	case 10:  		sb.Append ("ho");  		break;  	case 11:  		sb.Append ("hl");  		break;  	case 12:  		sb.Append ("y");  		break;  	case 13:  		sb.Append ("n");  		break;  	case 14:  		sb.Append ("nj");  		break;  	case 15:  		sb.Append ("np");  		break;  	case 16:  		sb.Append ("nl");  		break;  	case 17:  		sb.Append ("b");  		break;  	case 18:  		sb.Append ("m");  		break;  	case 19:  		sb.Append ("ml");  		break;  	case 20:  		sb.Append ("l");  		break;  	}  	switch (c) {  	case 1:  		sb.Append ("r");  		break;  	case 2:  		sb.Append ("R");  		break;  	case 3:  		sb.Append ("rt");  		break;  	case 4:  		sb.Append ("s");  		break;  	case 5:  		sb.Append ("sw");  		break;  	case 6:  		sb.Append ("sg");  		break;  	case 7:  		sb.Append ("e");  		break;  	case 8:  		sb.Append ("f");  		break;  	case 9:  		sb.Append ("fr");  		break;  	case 10:  		sb.Append ("fa");  		break;  	case 11:  		sb.Append ("fq");  		break;  	case 12:  		sb.Append ("ft");  		break;  	case 13:  		sb.Append ("fx");  		break;  	case 14:  		sb.Append ("fv");  		break;  	case 15:  		sb.Append ("fg");  		break;  	case 16:  		sb.Append ("a");  		break;  	case 17:  		sb.Append ("q");  		break;  	case 18:  		sb.Append ("qt");  		break;  	case 19:  		sb.Append ("t");  		break;  	case 20:  		sb.Append ("T");  		break;  	case 21:  		sb.Append ("d");  		break;  	case 22:  		sb.Append ("w");  		break;  	case 23:  		sb.Append ("c");  		break;  	case 24:  		sb.Append ("z");  		break;  	case 25:  		sb.Append ("x");  		break;  	case 26:  		sb.Append ("v");  		break;  	case 27:  		sb.Append ("g");  		break;  	}  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,ReverseIME,The following statement contains a magic number: foreach (char ch in str.ToCharArray ()) {  	if (ch < 44032 || ch > 55203)// out of range  	 {  		sb.Append (ch);  		continue;  	}  	int a = 0;  	int b = 0;  	int c = 0;  	for (int i = ch - 44032; i >= 588; i -= 588' ++a)  		;  	for (int i = ch - a * 588 - 44032; i >= 28; i -= 28' ++b)  		;  	c = ch - a * 588 - b * 28 - 44032;  	switch (a) {  	case 0:  		sb.Append ("r");  		break;  	case 1:  		sb.Append ("R");  		break;  	case 2:  		sb.Append ("s");  		break;  	case 3:  		sb.Append ("e");  		break;  	case 4:  		sb.Append ("E");  		break;  	case 5:  		sb.Append ("f");  		break;  	case 6:  		sb.Append ("a");  		break;  	case 7:  		sb.Append ("q");  		break;  	case 8:  		sb.Append ("Q");  		break;  	case 9:  		sb.Append ("t");  		break;  	case 10:  		sb.Append ("T");  		break;  	case 11:  		sb.Append ("d");  		break;  	case 12:  		sb.Append ("w");  		break;  	case 13:  		sb.Append ("W");  		break;  	case 14:  		sb.Append ("c");  		break;  	case 15:  		sb.Append ("z");  		break;  	case 16:  		sb.Append ("x");  		break;  	case 17:  		sb.Append ("v");  		break;  	case 18:  		sb.Append ("g");  		break;  	}  	switch (b) {  	case 0:  		sb.Append ("k");  		break;  	case 1:  		sb.Append ("o");  		break;  	case 2:  		sb.Append ("i");  		break;  	case 3:  		sb.Append ("O");  		break;  	case 4:  		sb.Append ("j");  		break;  	case 5:  		sb.Append ("p");  		break;  	case 6:  		sb.Append ("u");  		break;  	case 7:  		sb.Append ("P");  		break;  	case 8:  		sb.Append ("h");  		break;  	case 9:  		sb.Append ("hk");  		break;  	case 10:  		sb.Append ("ho");  		break;  	case 11:  		sb.Append ("hl");  		break;  	case 12:  		sb.Append ("y");  		break;  	case 13:  		sb.Append ("n");  		break;  	case 14:  		sb.Append ("nj");  		break;  	case 15:  		sb.Append ("np");  		break;  	case 16:  		sb.Append ("nl");  		break;  	case 17:  		sb.Append ("b");  		break;  	case 18:  		sb.Append ("m");  		break;  	case 19:  		sb.Append ("ml");  		break;  	case 20:  		sb.Append ("l");  		break;  	}  	switch (c) {  	case 1:  		sb.Append ("r");  		break;  	case 2:  		sb.Append ("R");  		break;  	case 3:  		sb.Append ("rt");  		break;  	case 4:  		sb.Append ("s");  		break;  	case 5:  		sb.Append ("sw");  		break;  	case 6:  		sb.Append ("sg");  		break;  	case 7:  		sb.Append ("e");  		break;  	case 8:  		sb.Append ("f");  		break;  	case 9:  		sb.Append ("fr");  		break;  	case 10:  		sb.Append ("fa");  		break;  	case 11:  		sb.Append ("fq");  		break;  	case 12:  		sb.Append ("ft");  		break;  	case 13:  		sb.Append ("fx");  		break;  	case 14:  		sb.Append ("fv");  		break;  	case 15:  		sb.Append ("fg");  		break;  	case 16:  		sb.Append ("a");  		break;  	case 17:  		sb.Append ("q");  		break;  	case 18:  		sb.Append ("qt");  		break;  	case 19:  		sb.Append ("t");  		break;  	case 20:  		sb.Append ("T");  		break;  	case 21:  		sb.Append ("d");  		break;  	case 22:  		sb.Append ("w");  		break;  	case 23:  		sb.Append ("c");  		break;  	case 24:  		sb.Append ("z");  		break;  	case 25:  		sb.Append ("x");  		break;  	case 26:  		sb.Append ("v");  		break;  	case 27:  		sb.Append ("g");  		break;  	}  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,ReverseIME,The following statement contains a magic number: foreach (char ch in str.ToCharArray ()) {  	if (ch < 44032 || ch > 55203)// out of range  	 {  		sb.Append (ch);  		continue;  	}  	int a = 0;  	int b = 0;  	int c = 0;  	for (int i = ch - 44032; i >= 588; i -= 588' ++a)  		;  	for (int i = ch - a * 588 - 44032; i >= 28; i -= 28' ++b)  		;  	c = ch - a * 588 - b * 28 - 44032;  	switch (a) {  	case 0:  		sb.Append ("r");  		break;  	case 1:  		sb.Append ("R");  		break;  	case 2:  		sb.Append ("s");  		break;  	case 3:  		sb.Append ("e");  		break;  	case 4:  		sb.Append ("E");  		break;  	case 5:  		sb.Append ("f");  		break;  	case 6:  		sb.Append ("a");  		break;  	case 7:  		sb.Append ("q");  		break;  	case 8:  		sb.Append ("Q");  		break;  	case 9:  		sb.Append ("t");  		break;  	case 10:  		sb.Append ("T");  		break;  	case 11:  		sb.Append ("d");  		break;  	case 12:  		sb.Append ("w");  		break;  	case 13:  		sb.Append ("W");  		break;  	case 14:  		sb.Append ("c");  		break;  	case 15:  		sb.Append ("z");  		break;  	case 16:  		sb.Append ("x");  		break;  	case 17:  		sb.Append ("v");  		break;  	case 18:  		sb.Append ("g");  		break;  	}  	switch (b) {  	case 0:  		sb.Append ("k");  		break;  	case 1:  		sb.Append ("o");  		break;  	case 2:  		sb.Append ("i");  		break;  	case 3:  		sb.Append ("O");  		break;  	case 4:  		sb.Append ("j");  		break;  	case 5:  		sb.Append ("p");  		break;  	case 6:  		sb.Append ("u");  		break;  	case 7:  		sb.Append ("P");  		break;  	case 8:  		sb.Append ("h");  		break;  	case 9:  		sb.Append ("hk");  		break;  	case 10:  		sb.Append ("ho");  		break;  	case 11:  		sb.Append ("hl");  		break;  	case 12:  		sb.Append ("y");  		break;  	case 13:  		sb.Append ("n");  		break;  	case 14:  		sb.Append ("nj");  		break;  	case 15:  		sb.Append ("np");  		break;  	case 16:  		sb.Append ("nl");  		break;  	case 17:  		sb.Append ("b");  		break;  	case 18:  		sb.Append ("m");  		break;  	case 19:  		sb.Append ("ml");  		break;  	case 20:  		sb.Append ("l");  		break;  	}  	switch (c) {  	case 1:  		sb.Append ("r");  		break;  	case 2:  		sb.Append ("R");  		break;  	case 3:  		sb.Append ("rt");  		break;  	case 4:  		sb.Append ("s");  		break;  	case 5:  		sb.Append ("sw");  		break;  	case 6:  		sb.Append ("sg");  		break;  	case 7:  		sb.Append ("e");  		break;  	case 8:  		sb.Append ("f");  		break;  	case 9:  		sb.Append ("fr");  		break;  	case 10:  		sb.Append ("fa");  		break;  	case 11:  		sb.Append ("fq");  		break;  	case 12:  		sb.Append ("ft");  		break;  	case 13:  		sb.Append ("fx");  		break;  	case 14:  		sb.Append ("fv");  		break;  	case 15:  		sb.Append ("fg");  		break;  	case 16:  		sb.Append ("a");  		break;  	case 17:  		sb.Append ("q");  		break;  	case 18:  		sb.Append ("qt");  		break;  	case 19:  		sb.Append ("t");  		break;  	case 20:  		sb.Append ("T");  		break;  	case 21:  		sb.Append ("d");  		break;  	case 22:  		sb.Append ("w");  		break;  	case 23:  		sb.Append ("c");  		break;  	case 24:  		sb.Append ("z");  		break;  	case 25:  		sb.Append ("x");  		break;  	case 26:  		sb.Append ("v");  		break;  	case 27:  		sb.Append ("g");  		break;  	}  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,ReverseIME,The following statement contains a magic number: foreach (char ch in str.ToCharArray ()) {  	if (ch < 44032 || ch > 55203)// out of range  	 {  		sb.Append (ch);  		continue;  	}  	int a = 0;  	int b = 0;  	int c = 0;  	for (int i = ch - 44032; i >= 588; i -= 588' ++a)  		;  	for (int i = ch - a * 588 - 44032; i >= 28; i -= 28' ++b)  		;  	c = ch - a * 588 - b * 28 - 44032;  	switch (a) {  	case 0:  		sb.Append ("r");  		break;  	case 1:  		sb.Append ("R");  		break;  	case 2:  		sb.Append ("s");  		break;  	case 3:  		sb.Append ("e");  		break;  	case 4:  		sb.Append ("E");  		break;  	case 5:  		sb.Append ("f");  		break;  	case 6:  		sb.Append ("a");  		break;  	case 7:  		sb.Append ("q");  		break;  	case 8:  		sb.Append ("Q");  		break;  	case 9:  		sb.Append ("t");  		break;  	case 10:  		sb.Append ("T");  		break;  	case 11:  		sb.Append ("d");  		break;  	case 12:  		sb.Append ("w");  		break;  	case 13:  		sb.Append ("W");  		break;  	case 14:  		sb.Append ("c");  		break;  	case 15:  		sb.Append ("z");  		break;  	case 16:  		sb.Append ("x");  		break;  	case 17:  		sb.Append ("v");  		break;  	case 18:  		sb.Append ("g");  		break;  	}  	switch (b) {  	case 0:  		sb.Append ("k");  		break;  	case 1:  		sb.Append ("o");  		break;  	case 2:  		sb.Append ("i");  		break;  	case 3:  		sb.Append ("O");  		break;  	case 4:  		sb.Append ("j");  		break;  	case 5:  		sb.Append ("p");  		break;  	case 6:  		sb.Append ("u");  		break;  	case 7:  		sb.Append ("P");  		break;  	case 8:  		sb.Append ("h");  		break;  	case 9:  		sb.Append ("hk");  		break;  	case 10:  		sb.Append ("ho");  		break;  	case 11:  		sb.Append ("hl");  		break;  	case 12:  		sb.Append ("y");  		break;  	case 13:  		sb.Append ("n");  		break;  	case 14:  		sb.Append ("nj");  		break;  	case 15:  		sb.Append ("np");  		break;  	case 16:  		sb.Append ("nl");  		break;  	case 17:  		sb.Append ("b");  		break;  	case 18:  		sb.Append ("m");  		break;  	case 19:  		sb.Append ("ml");  		break;  	case 20:  		sb.Append ("l");  		break;  	}  	switch (c) {  	case 1:  		sb.Append ("r");  		break;  	case 2:  		sb.Append ("R");  		break;  	case 3:  		sb.Append ("rt");  		break;  	case 4:  		sb.Append ("s");  		break;  	case 5:  		sb.Append ("sw");  		break;  	case 6:  		sb.Append ("sg");  		break;  	case 7:  		sb.Append ("e");  		break;  	case 8:  		sb.Append ("f");  		break;  	case 9:  		sb.Append ("fr");  		break;  	case 10:  		sb.Append ("fa");  		break;  	case 11:  		sb.Append ("fq");  		break;  	case 12:  		sb.Append ("ft");  		break;  	case 13:  		sb.Append ("fx");  		break;  	case 14:  		sb.Append ("fv");  		break;  	case 15:  		sb.Append ("fg");  		break;  	case 16:  		sb.Append ("a");  		break;  	case 17:  		sb.Append ("q");  		break;  	case 18:  		sb.Append ("qt");  		break;  	case 19:  		sb.Append ("t");  		break;  	case 20:  		sb.Append ("T");  		break;  	case 21:  		sb.Append ("d");  		break;  	case 22:  		sb.Append ("w");  		break;  	case 23:  		sb.Append ("c");  		break;  	case 24:  		sb.Append ("z");  		break;  	case 25:  		sb.Append ("x");  		break;  	case 26:  		sb.Append ("v");  		break;  	case 27:  		sb.Append ("g");  		break;  	}  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,ReverseIME,The following statement contains a magic number: foreach (char ch in str.ToCharArray ()) {  	if (ch < 44032 || ch > 55203)// out of range  	 {  		sb.Append (ch);  		continue;  	}  	int a = 0;  	int b = 0;  	int c = 0;  	for (int i = ch - 44032; i >= 588; i -= 588' ++a)  		;  	for (int i = ch - a * 588 - 44032; i >= 28; i -= 28' ++b)  		;  	c = ch - a * 588 - b * 28 - 44032;  	switch (a) {  	case 0:  		sb.Append ("r");  		break;  	case 1:  		sb.Append ("R");  		break;  	case 2:  		sb.Append ("s");  		break;  	case 3:  		sb.Append ("e");  		break;  	case 4:  		sb.Append ("E");  		break;  	case 5:  		sb.Append ("f");  		break;  	case 6:  		sb.Append ("a");  		break;  	case 7:  		sb.Append ("q");  		break;  	case 8:  		sb.Append ("Q");  		break;  	case 9:  		sb.Append ("t");  		break;  	case 10:  		sb.Append ("T");  		break;  	case 11:  		sb.Append ("d");  		break;  	case 12:  		sb.Append ("w");  		break;  	case 13:  		sb.Append ("W");  		break;  	case 14:  		sb.Append ("c");  		break;  	case 15:  		sb.Append ("z");  		break;  	case 16:  		sb.Append ("x");  		break;  	case 17:  		sb.Append ("v");  		break;  	case 18:  		sb.Append ("g");  		break;  	}  	switch (b) {  	case 0:  		sb.Append ("k");  		break;  	case 1:  		sb.Append ("o");  		break;  	case 2:  		sb.Append ("i");  		break;  	case 3:  		sb.Append ("O");  		break;  	case 4:  		sb.Append ("j");  		break;  	case 5:  		sb.Append ("p");  		break;  	case 6:  		sb.Append ("u");  		break;  	case 7:  		sb.Append ("P");  		break;  	case 8:  		sb.Append ("h");  		break;  	case 9:  		sb.Append ("hk");  		break;  	case 10:  		sb.Append ("ho");  		break;  	case 11:  		sb.Append ("hl");  		break;  	case 12:  		sb.Append ("y");  		break;  	case 13:  		sb.Append ("n");  		break;  	case 14:  		sb.Append ("nj");  		break;  	case 15:  		sb.Append ("np");  		break;  	case 16:  		sb.Append ("nl");  		break;  	case 17:  		sb.Append ("b");  		break;  	case 18:  		sb.Append ("m");  		break;  	case 19:  		sb.Append ("ml");  		break;  	case 20:  		sb.Append ("l");  		break;  	}  	switch (c) {  	case 1:  		sb.Append ("r");  		break;  	case 2:  		sb.Append ("R");  		break;  	case 3:  		sb.Append ("rt");  		break;  	case 4:  		sb.Append ("s");  		break;  	case 5:  		sb.Append ("sw");  		break;  	case 6:  		sb.Append ("sg");  		break;  	case 7:  		sb.Append ("e");  		break;  	case 8:  		sb.Append ("f");  		break;  	case 9:  		sb.Append ("fr");  		break;  	case 10:  		sb.Append ("fa");  		break;  	case 11:  		sb.Append ("fq");  		break;  	case 12:  		sb.Append ("ft");  		break;  	case 13:  		sb.Append ("fx");  		break;  	case 14:  		sb.Append ("fv");  		break;  	case 15:  		sb.Append ("fg");  		break;  	case 16:  		sb.Append ("a");  		break;  	case 17:  		sb.Append ("q");  		break;  	case 18:  		sb.Append ("qt");  		break;  	case 19:  		sb.Append ("t");  		break;  	case 20:  		sb.Append ("T");  		break;  	case 21:  		sb.Append ("d");  		break;  	case 22:  		sb.Append ("w");  		break;  	case 23:  		sb.Append ("c");  		break;  	case 24:  		sb.Append ("z");  		break;  	case 25:  		sb.Append ("x");  		break;  	case 26:  		sb.Append ("v");  		break;  	case 27:  		sb.Append ("g");  		break;  	}  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,ReverseIME,The following statement contains a magic number: foreach (char ch in str.ToCharArray ()) {  	if (ch < 44032 || ch > 55203)// out of range  	 {  		sb.Append (ch);  		continue;  	}  	int a = 0;  	int b = 0;  	int c = 0;  	for (int i = ch - 44032; i >= 588; i -= 588' ++a)  		;  	for (int i = ch - a * 588 - 44032; i >= 28; i -= 28' ++b)  		;  	c = ch - a * 588 - b * 28 - 44032;  	switch (a) {  	case 0:  		sb.Append ("r");  		break;  	case 1:  		sb.Append ("R");  		break;  	case 2:  		sb.Append ("s");  		break;  	case 3:  		sb.Append ("e");  		break;  	case 4:  		sb.Append ("E");  		break;  	case 5:  		sb.Append ("f");  		break;  	case 6:  		sb.Append ("a");  		break;  	case 7:  		sb.Append ("q");  		break;  	case 8:  		sb.Append ("Q");  		break;  	case 9:  		sb.Append ("t");  		break;  	case 10:  		sb.Append ("T");  		break;  	case 11:  		sb.Append ("d");  		break;  	case 12:  		sb.Append ("w");  		break;  	case 13:  		sb.Append ("W");  		break;  	case 14:  		sb.Append ("c");  		break;  	case 15:  		sb.Append ("z");  		break;  	case 16:  		sb.Append ("x");  		break;  	case 17:  		sb.Append ("v");  		break;  	case 18:  		sb.Append ("g");  		break;  	}  	switch (b) {  	case 0:  		sb.Append ("k");  		break;  	case 1:  		sb.Append ("o");  		break;  	case 2:  		sb.Append ("i");  		break;  	case 3:  		sb.Append ("O");  		break;  	case 4:  		sb.Append ("j");  		break;  	case 5:  		sb.Append ("p");  		break;  	case 6:  		sb.Append ("u");  		break;  	case 7:  		sb.Append ("P");  		break;  	case 8:  		sb.Append ("h");  		break;  	case 9:  		sb.Append ("hk");  		break;  	case 10:  		sb.Append ("ho");  		break;  	case 11:  		sb.Append ("hl");  		break;  	case 12:  		sb.Append ("y");  		break;  	case 13:  		sb.Append ("n");  		break;  	case 14:  		sb.Append ("nj");  		break;  	case 15:  		sb.Append ("np");  		break;  	case 16:  		sb.Append ("nl");  		break;  	case 17:  		sb.Append ("b");  		break;  	case 18:  		sb.Append ("m");  		break;  	case 19:  		sb.Append ("ml");  		break;  	case 20:  		sb.Append ("l");  		break;  	}  	switch (c) {  	case 1:  		sb.Append ("r");  		break;  	case 2:  		sb.Append ("R");  		break;  	case 3:  		sb.Append ("rt");  		break;  	case 4:  		sb.Append ("s");  		break;  	case 5:  		sb.Append ("sw");  		break;  	case 6:  		sb.Append ("sg");  		break;  	case 7:  		sb.Append ("e");  		break;  	case 8:  		sb.Append ("f");  		break;  	case 9:  		sb.Append ("fr");  		break;  	case 10:  		sb.Append ("fa");  		break;  	case 11:  		sb.Append ("fq");  		break;  	case 12:  		sb.Append ("ft");  		break;  	case 13:  		sb.Append ("fx");  		break;  	case 14:  		sb.Append ("fv");  		break;  	case 15:  		sb.Append ("fg");  		break;  	case 16:  		sb.Append ("a");  		break;  	case 17:  		sb.Append ("q");  		break;  	case 18:  		sb.Append ("qt");  		break;  	case 19:  		sb.Append ("t");  		break;  	case 20:  		sb.Append ("T");  		break;  	case 21:  		sb.Append ("d");  		break;  	case 22:  		sb.Append ("w");  		break;  	case 23:  		sb.Append ("c");  		break;  	case 24:  		sb.Append ("z");  		break;  	case 25:  		sb.Append ("x");  		break;  	case 26:  		sb.Append ("v");  		break;  	case 27:  		sb.Append ("g");  		break;  	}  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,ReverseIME,The following statement contains a magic number: foreach (char ch in str.ToCharArray ()) {  	if (ch < 44032 || ch > 55203)// out of range  	 {  		sb.Append (ch);  		continue;  	}  	int a = 0;  	int b = 0;  	int c = 0;  	for (int i = ch - 44032; i >= 588; i -= 588' ++a)  		;  	for (int i = ch - a * 588 - 44032; i >= 28; i -= 28' ++b)  		;  	c = ch - a * 588 - b * 28 - 44032;  	switch (a) {  	case 0:  		sb.Append ("r");  		break;  	case 1:  		sb.Append ("R");  		break;  	case 2:  		sb.Append ("s");  		break;  	case 3:  		sb.Append ("e");  		break;  	case 4:  		sb.Append ("E");  		break;  	case 5:  		sb.Append ("f");  		break;  	case 6:  		sb.Append ("a");  		break;  	case 7:  		sb.Append ("q");  		break;  	case 8:  		sb.Append ("Q");  		break;  	case 9:  		sb.Append ("t");  		break;  	case 10:  		sb.Append ("T");  		break;  	case 11:  		sb.Append ("d");  		break;  	case 12:  		sb.Append ("w");  		break;  	case 13:  		sb.Append ("W");  		break;  	case 14:  		sb.Append ("c");  		break;  	case 15:  		sb.Append ("z");  		break;  	case 16:  		sb.Append ("x");  		break;  	case 17:  		sb.Append ("v");  		break;  	case 18:  		sb.Append ("g");  		break;  	}  	switch (b) {  	case 0:  		sb.Append ("k");  		break;  	case 1:  		sb.Append ("o");  		break;  	case 2:  		sb.Append ("i");  		break;  	case 3:  		sb.Append ("O");  		break;  	case 4:  		sb.Append ("j");  		break;  	case 5:  		sb.Append ("p");  		break;  	case 6:  		sb.Append ("u");  		break;  	case 7:  		sb.Append ("P");  		break;  	case 8:  		sb.Append ("h");  		break;  	case 9:  		sb.Append ("hk");  		break;  	case 10:  		sb.Append ("ho");  		break;  	case 11:  		sb.Append ("hl");  		break;  	case 12:  		sb.Append ("y");  		break;  	case 13:  		sb.Append ("n");  		break;  	case 14:  		sb.Append ("nj");  		break;  	case 15:  		sb.Append ("np");  		break;  	case 16:  		sb.Append ("nl");  		break;  	case 17:  		sb.Append ("b");  		break;  	case 18:  		sb.Append ("m");  		break;  	case 19:  		sb.Append ("ml");  		break;  	case 20:  		sb.Append ("l");  		break;  	}  	switch (c) {  	case 1:  		sb.Append ("r");  		break;  	case 2:  		sb.Append ("R");  		break;  	case 3:  		sb.Append ("rt");  		break;  	case 4:  		sb.Append ("s");  		break;  	case 5:  		sb.Append ("sw");  		break;  	case 6:  		sb.Append ("sg");  		break;  	case 7:  		sb.Append ("e");  		break;  	case 8:  		sb.Append ("f");  		break;  	case 9:  		sb.Append ("fr");  		break;  	case 10:  		sb.Append ("fa");  		break;  	case 11:  		sb.Append ("fq");  		break;  	case 12:  		sb.Append ("ft");  		break;  	case 13:  		sb.Append ("fx");  		break;  	case 14:  		sb.Append ("fv");  		break;  	case 15:  		sb.Append ("fg");  		break;  	case 16:  		sb.Append ("a");  		break;  	case 17:  		sb.Append ("q");  		break;  	case 18:  		sb.Append ("qt");  		break;  	case 19:  		sb.Append ("t");  		break;  	case 20:  		sb.Append ("T");  		break;  	case 21:  		sb.Append ("d");  		break;  	case 22:  		sb.Append ("w");  		break;  	case 23:  		sb.Append ("c");  		break;  	case 24:  		sb.Append ("z");  		break;  	case 25:  		sb.Append ("x");  		break;  	case 26:  		sb.Append ("v");  		break;  	case 27:  		sb.Append ("g");  		break;  	}  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,ReverseIME,The following statement contains a magic number: foreach (char ch in str.ToCharArray ()) {  	if (ch < 44032 || ch > 55203)// out of range  	 {  		sb.Append (ch);  		continue;  	}  	int a = 0;  	int b = 0;  	int c = 0;  	for (int i = ch - 44032; i >= 588; i -= 588' ++a)  		;  	for (int i = ch - a * 588 - 44032; i >= 28; i -= 28' ++b)  		;  	c = ch - a * 588 - b * 28 - 44032;  	switch (a) {  	case 0:  		sb.Append ("r");  		break;  	case 1:  		sb.Append ("R");  		break;  	case 2:  		sb.Append ("s");  		break;  	case 3:  		sb.Append ("e");  		break;  	case 4:  		sb.Append ("E");  		break;  	case 5:  		sb.Append ("f");  		break;  	case 6:  		sb.Append ("a");  		break;  	case 7:  		sb.Append ("q");  		break;  	case 8:  		sb.Append ("Q");  		break;  	case 9:  		sb.Append ("t");  		break;  	case 10:  		sb.Append ("T");  		break;  	case 11:  		sb.Append ("d");  		break;  	case 12:  		sb.Append ("w");  		break;  	case 13:  		sb.Append ("W");  		break;  	case 14:  		sb.Append ("c");  		break;  	case 15:  		sb.Append ("z");  		break;  	case 16:  		sb.Append ("x");  		break;  	case 17:  		sb.Append ("v");  		break;  	case 18:  		sb.Append ("g");  		break;  	}  	switch (b) {  	case 0:  		sb.Append ("k");  		break;  	case 1:  		sb.Append ("o");  		break;  	case 2:  		sb.Append ("i");  		break;  	case 3:  		sb.Append ("O");  		break;  	case 4:  		sb.Append ("j");  		break;  	case 5:  		sb.Append ("p");  		break;  	case 6:  		sb.Append ("u");  		break;  	case 7:  		sb.Append ("P");  		break;  	case 8:  		sb.Append ("h");  		break;  	case 9:  		sb.Append ("hk");  		break;  	case 10:  		sb.Append ("ho");  		break;  	case 11:  		sb.Append ("hl");  		break;  	case 12:  		sb.Append ("y");  		break;  	case 13:  		sb.Append ("n");  		break;  	case 14:  		sb.Append ("nj");  		break;  	case 15:  		sb.Append ("np");  		break;  	case 16:  		sb.Append ("nl");  		break;  	case 17:  		sb.Append ("b");  		break;  	case 18:  		sb.Append ("m");  		break;  	case 19:  		sb.Append ("ml");  		break;  	case 20:  		sb.Append ("l");  		break;  	}  	switch (c) {  	case 1:  		sb.Append ("r");  		break;  	case 2:  		sb.Append ("R");  		break;  	case 3:  		sb.Append ("rt");  		break;  	case 4:  		sb.Append ("s");  		break;  	case 5:  		sb.Append ("sw");  		break;  	case 6:  		sb.Append ("sg");  		break;  	case 7:  		sb.Append ("e");  		break;  	case 8:  		sb.Append ("f");  		break;  	case 9:  		sb.Append ("fr");  		break;  	case 10:  		sb.Append ("fa");  		break;  	case 11:  		sb.Append ("fq");  		break;  	case 12:  		sb.Append ("ft");  		break;  	case 13:  		sb.Append ("fx");  		break;  	case 14:  		sb.Append ("fv");  		break;  	case 15:  		sb.Append ("fg");  		break;  	case 16:  		sb.Append ("a");  		break;  	case 17:  		sb.Append ("q");  		break;  	case 18:  		sb.Append ("qt");  		break;  	case 19:  		sb.Append ("t");  		break;  	case 20:  		sb.Append ("T");  		break;  	case 21:  		sb.Append ("d");  		break;  	case 22:  		sb.Append ("w");  		break;  	case 23:  		sb.Append ("c");  		break;  	case 24:  		sb.Append ("z");  		break;  	case 25:  		sb.Append ("x");  		break;  	case 26:  		sb.Append ("v");  		break;  	case 27:  		sb.Append ("g");  		break;  	}  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,ReverseIME,The following statement contains a magic number: foreach (char ch in str.ToCharArray ()) {  	if (ch < 44032 || ch > 55203)// out of range  	 {  		sb.Append (ch);  		continue;  	}  	int a = 0;  	int b = 0;  	int c = 0;  	for (int i = ch - 44032; i >= 588; i -= 588' ++a)  		;  	for (int i = ch - a * 588 - 44032; i >= 28; i -= 28' ++b)  		;  	c = ch - a * 588 - b * 28 - 44032;  	switch (a) {  	case 0:  		sb.Append ("r");  		break;  	case 1:  		sb.Append ("R");  		break;  	case 2:  		sb.Append ("s");  		break;  	case 3:  		sb.Append ("e");  		break;  	case 4:  		sb.Append ("E");  		break;  	case 5:  		sb.Append ("f");  		break;  	case 6:  		sb.Append ("a");  		break;  	case 7:  		sb.Append ("q");  		break;  	case 8:  		sb.Append ("Q");  		break;  	case 9:  		sb.Append ("t");  		break;  	case 10:  		sb.Append ("T");  		break;  	case 11:  		sb.Append ("d");  		break;  	case 12:  		sb.Append ("w");  		break;  	case 13:  		sb.Append ("W");  		break;  	case 14:  		sb.Append ("c");  		break;  	case 15:  		sb.Append ("z");  		break;  	case 16:  		sb.Append ("x");  		break;  	case 17:  		sb.Append ("v");  		break;  	case 18:  		sb.Append ("g");  		break;  	}  	switch (b) {  	case 0:  		sb.Append ("k");  		break;  	case 1:  		sb.Append ("o");  		break;  	case 2:  		sb.Append ("i");  		break;  	case 3:  		sb.Append ("O");  		break;  	case 4:  		sb.Append ("j");  		break;  	case 5:  		sb.Append ("p");  		break;  	case 6:  		sb.Append ("u");  		break;  	case 7:  		sb.Append ("P");  		break;  	case 8:  		sb.Append ("h");  		break;  	case 9:  		sb.Append ("hk");  		break;  	case 10:  		sb.Append ("ho");  		break;  	case 11:  		sb.Append ("hl");  		break;  	case 12:  		sb.Append ("y");  		break;  	case 13:  		sb.Append ("n");  		break;  	case 14:  		sb.Append ("nj");  		break;  	case 15:  		sb.Append ("np");  		break;  	case 16:  		sb.Append ("nl");  		break;  	case 17:  		sb.Append ("b");  		break;  	case 18:  		sb.Append ("m");  		break;  	case 19:  		sb.Append ("ml");  		break;  	case 20:  		sb.Append ("l");  		break;  	}  	switch (c) {  	case 1:  		sb.Append ("r");  		break;  	case 2:  		sb.Append ("R");  		break;  	case 3:  		sb.Append ("rt");  		break;  	case 4:  		sb.Append ("s");  		break;  	case 5:  		sb.Append ("sw");  		break;  	case 6:  		sb.Append ("sg");  		break;  	case 7:  		sb.Append ("e");  		break;  	case 8:  		sb.Append ("f");  		break;  	case 9:  		sb.Append ("fr");  		break;  	case 10:  		sb.Append ("fa");  		break;  	case 11:  		sb.Append ("fq");  		break;  	case 12:  		sb.Append ("ft");  		break;  	case 13:  		sb.Append ("fx");  		break;  	case 14:  		sb.Append ("fv");  		break;  	case 15:  		sb.Append ("fg");  		break;  	case 16:  		sb.Append ("a");  		break;  	case 17:  		sb.Append ("q");  		break;  	case 18:  		sb.Append ("qt");  		break;  	case 19:  		sb.Append ("t");  		break;  	case 20:  		sb.Append ("T");  		break;  	case 21:  		sb.Append ("d");  		break;  	case 22:  		sb.Append ("w");  		break;  	case 23:  		sb.Append ("c");  		break;  	case 24:  		sb.Append ("z");  		break;  	case 25:  		sb.Append ("x");  		break;  	case 26:  		sb.Append ("v");  		break;  	case 27:  		sb.Append ("g");  		break;  	}  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,ReverseIME,The following statement contains a magic number: foreach (char ch in str.ToCharArray ()) {  	if (ch < 44032 || ch > 55203)// out of range  	 {  		sb.Append (ch);  		continue;  	}  	int a = 0;  	int b = 0;  	int c = 0;  	for (int i = ch - 44032; i >= 588; i -= 588' ++a)  		;  	for (int i = ch - a * 588 - 44032; i >= 28; i -= 28' ++b)  		;  	c = ch - a * 588 - b * 28 - 44032;  	switch (a) {  	case 0:  		sb.Append ("r");  		break;  	case 1:  		sb.Append ("R");  		break;  	case 2:  		sb.Append ("s");  		break;  	case 3:  		sb.Append ("e");  		break;  	case 4:  		sb.Append ("E");  		break;  	case 5:  		sb.Append ("f");  		break;  	case 6:  		sb.Append ("a");  		break;  	case 7:  		sb.Append ("q");  		break;  	case 8:  		sb.Append ("Q");  		break;  	case 9:  		sb.Append ("t");  		break;  	case 10:  		sb.Append ("T");  		break;  	case 11:  		sb.Append ("d");  		break;  	case 12:  		sb.Append ("w");  		break;  	case 13:  		sb.Append ("W");  		break;  	case 14:  		sb.Append ("c");  		break;  	case 15:  		sb.Append ("z");  		break;  	case 16:  		sb.Append ("x");  		break;  	case 17:  		sb.Append ("v");  		break;  	case 18:  		sb.Append ("g");  		break;  	}  	switch (b) {  	case 0:  		sb.Append ("k");  		break;  	case 1:  		sb.Append ("o");  		break;  	case 2:  		sb.Append ("i");  		break;  	case 3:  		sb.Append ("O");  		break;  	case 4:  		sb.Append ("j");  		break;  	case 5:  		sb.Append ("p");  		break;  	case 6:  		sb.Append ("u");  		break;  	case 7:  		sb.Append ("P");  		break;  	case 8:  		sb.Append ("h");  		break;  	case 9:  		sb.Append ("hk");  		break;  	case 10:  		sb.Append ("ho");  		break;  	case 11:  		sb.Append ("hl");  		break;  	case 12:  		sb.Append ("y");  		break;  	case 13:  		sb.Append ("n");  		break;  	case 14:  		sb.Append ("nj");  		break;  	case 15:  		sb.Append ("np");  		break;  	case 16:  		sb.Append ("nl");  		break;  	case 17:  		sb.Append ("b");  		break;  	case 18:  		sb.Append ("m");  		break;  	case 19:  		sb.Append ("ml");  		break;  	case 20:  		sb.Append ("l");  		break;  	}  	switch (c) {  	case 1:  		sb.Append ("r");  		break;  	case 2:  		sb.Append ("R");  		break;  	case 3:  		sb.Append ("rt");  		break;  	case 4:  		sb.Append ("s");  		break;  	case 5:  		sb.Append ("sw");  		break;  	case 6:  		sb.Append ("sg");  		break;  	case 7:  		sb.Append ("e");  		break;  	case 8:  		sb.Append ("f");  		break;  	case 9:  		sb.Append ("fr");  		break;  	case 10:  		sb.Append ("fa");  		break;  	case 11:  		sb.Append ("fq");  		break;  	case 12:  		sb.Append ("ft");  		break;  	case 13:  		sb.Append ("fx");  		break;  	case 14:  		sb.Append ("fv");  		break;  	case 15:  		sb.Append ("fg");  		break;  	case 16:  		sb.Append ("a");  		break;  	case 17:  		sb.Append ("q");  		break;  	case 18:  		sb.Append ("qt");  		break;  	case 19:  		sb.Append ("t");  		break;  	case 20:  		sb.Append ("T");  		break;  	case 21:  		sb.Append ("d");  		break;  	case 22:  		sb.Append ("w");  		break;  	case 23:  		sb.Append ("c");  		break;  	case 24:  		sb.Append ("z");  		break;  	case 25:  		sb.Append ("x");  		break;  	case 26:  		sb.Append ("v");  		break;  	case 27:  		sb.Append ("g");  		break;  	}  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,ReverseIME,The following statement contains a magic number: foreach (char ch in str.ToCharArray ()) {  	if (ch < 44032 || ch > 55203)// out of range  	 {  		sb.Append (ch);  		continue;  	}  	int a = 0;  	int b = 0;  	int c = 0;  	for (int i = ch - 44032; i >= 588; i -= 588' ++a)  		;  	for (int i = ch - a * 588 - 44032; i >= 28; i -= 28' ++b)  		;  	c = ch - a * 588 - b * 28 - 44032;  	switch (a) {  	case 0:  		sb.Append ("r");  		break;  	case 1:  		sb.Append ("R");  		break;  	case 2:  		sb.Append ("s");  		break;  	case 3:  		sb.Append ("e");  		break;  	case 4:  		sb.Append ("E");  		break;  	case 5:  		sb.Append ("f");  		break;  	case 6:  		sb.Append ("a");  		break;  	case 7:  		sb.Append ("q");  		break;  	case 8:  		sb.Append ("Q");  		break;  	case 9:  		sb.Append ("t");  		break;  	case 10:  		sb.Append ("T");  		break;  	case 11:  		sb.Append ("d");  		break;  	case 12:  		sb.Append ("w");  		break;  	case 13:  		sb.Append ("W");  		break;  	case 14:  		sb.Append ("c");  		break;  	case 15:  		sb.Append ("z");  		break;  	case 16:  		sb.Append ("x");  		break;  	case 17:  		sb.Append ("v");  		break;  	case 18:  		sb.Append ("g");  		break;  	}  	switch (b) {  	case 0:  		sb.Append ("k");  		break;  	case 1:  		sb.Append ("o");  		break;  	case 2:  		sb.Append ("i");  		break;  	case 3:  		sb.Append ("O");  		break;  	case 4:  		sb.Append ("j");  		break;  	case 5:  		sb.Append ("p");  		break;  	case 6:  		sb.Append ("u");  		break;  	case 7:  		sb.Append ("P");  		break;  	case 8:  		sb.Append ("h");  		break;  	case 9:  		sb.Append ("hk");  		break;  	case 10:  		sb.Append ("ho");  		break;  	case 11:  		sb.Append ("hl");  		break;  	case 12:  		sb.Append ("y");  		break;  	case 13:  		sb.Append ("n");  		break;  	case 14:  		sb.Append ("nj");  		break;  	case 15:  		sb.Append ("np");  		break;  	case 16:  		sb.Append ("nl");  		break;  	case 17:  		sb.Append ("b");  		break;  	case 18:  		sb.Append ("m");  		break;  	case 19:  		sb.Append ("ml");  		break;  	case 20:  		sb.Append ("l");  		break;  	}  	switch (c) {  	case 1:  		sb.Append ("r");  		break;  	case 2:  		sb.Append ("R");  		break;  	case 3:  		sb.Append ("rt");  		break;  	case 4:  		sb.Append ("s");  		break;  	case 5:  		sb.Append ("sw");  		break;  	case 6:  		sb.Append ("sg");  		break;  	case 7:  		sb.Append ("e");  		break;  	case 8:  		sb.Append ("f");  		break;  	case 9:  		sb.Append ("fr");  		break;  	case 10:  		sb.Append ("fa");  		break;  	case 11:  		sb.Append ("fq");  		break;  	case 12:  		sb.Append ("ft");  		break;  	case 13:  		sb.Append ("fx");  		break;  	case 14:  		sb.Append ("fv");  		break;  	case 15:  		sb.Append ("fg");  		break;  	case 16:  		sb.Append ("a");  		break;  	case 17:  		sb.Append ("q");  		break;  	case 18:  		sb.Append ("qt");  		break;  	case 19:  		sb.Append ("t");  		break;  	case 20:  		sb.Append ("T");  		break;  	case 21:  		sb.Append ("d");  		break;  	case 22:  		sb.Append ("w");  		break;  	case 23:  		sb.Append ("c");  		break;  	case 24:  		sb.Append ("z");  		break;  	case 25:  		sb.Append ("x");  		break;  	case 26:  		sb.Append ("v");  		break;  	case 27:  		sb.Append ("g");  		break;  	}  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,ReverseIME,The following statement contains a magic number: foreach (char ch in str.ToCharArray ()) {  	if (ch < 44032 || ch > 55203)// out of range  	 {  		sb.Append (ch);  		continue;  	}  	int a = 0;  	int b = 0;  	int c = 0;  	for (int i = ch - 44032; i >= 588; i -= 588' ++a)  		;  	for (int i = ch - a * 588 - 44032; i >= 28; i -= 28' ++b)  		;  	c = ch - a * 588 - b * 28 - 44032;  	switch (a) {  	case 0:  		sb.Append ("r");  		break;  	case 1:  		sb.Append ("R");  		break;  	case 2:  		sb.Append ("s");  		break;  	case 3:  		sb.Append ("e");  		break;  	case 4:  		sb.Append ("E");  		break;  	case 5:  		sb.Append ("f");  		break;  	case 6:  		sb.Append ("a");  		break;  	case 7:  		sb.Append ("q");  		break;  	case 8:  		sb.Append ("Q");  		break;  	case 9:  		sb.Append ("t");  		break;  	case 10:  		sb.Append ("T");  		break;  	case 11:  		sb.Append ("d");  		break;  	case 12:  		sb.Append ("w");  		break;  	case 13:  		sb.Append ("W");  		break;  	case 14:  		sb.Append ("c");  		break;  	case 15:  		sb.Append ("z");  		break;  	case 16:  		sb.Append ("x");  		break;  	case 17:  		sb.Append ("v");  		break;  	case 18:  		sb.Append ("g");  		break;  	}  	switch (b) {  	case 0:  		sb.Append ("k");  		break;  	case 1:  		sb.Append ("o");  		break;  	case 2:  		sb.Append ("i");  		break;  	case 3:  		sb.Append ("O");  		break;  	case 4:  		sb.Append ("j");  		break;  	case 5:  		sb.Append ("p");  		break;  	case 6:  		sb.Append ("u");  		break;  	case 7:  		sb.Append ("P");  		break;  	case 8:  		sb.Append ("h");  		break;  	case 9:  		sb.Append ("hk");  		break;  	case 10:  		sb.Append ("ho");  		break;  	case 11:  		sb.Append ("hl");  		break;  	case 12:  		sb.Append ("y");  		break;  	case 13:  		sb.Append ("n");  		break;  	case 14:  		sb.Append ("nj");  		break;  	case 15:  		sb.Append ("np");  		break;  	case 16:  		sb.Append ("nl");  		break;  	case 17:  		sb.Append ("b");  		break;  	case 18:  		sb.Append ("m");  		break;  	case 19:  		sb.Append ("ml");  		break;  	case 20:  		sb.Append ("l");  		break;  	}  	switch (c) {  	case 1:  		sb.Append ("r");  		break;  	case 2:  		sb.Append ("R");  		break;  	case 3:  		sb.Append ("rt");  		break;  	case 4:  		sb.Append ("s");  		break;  	case 5:  		sb.Append ("sw");  		break;  	case 6:  		sb.Append ("sg");  		break;  	case 7:  		sb.Append ("e");  		break;  	case 8:  		sb.Append ("f");  		break;  	case 9:  		sb.Append ("fr");  		break;  	case 10:  		sb.Append ("fa");  		break;  	case 11:  		sb.Append ("fq");  		break;  	case 12:  		sb.Append ("ft");  		break;  	case 13:  		sb.Append ("fx");  		break;  	case 14:  		sb.Append ("fv");  		break;  	case 15:  		sb.Append ("fg");  		break;  	case 16:  		sb.Append ("a");  		break;  	case 17:  		sb.Append ("q");  		break;  	case 18:  		sb.Append ("qt");  		break;  	case 19:  		sb.Append ("t");  		break;  	case 20:  		sb.Append ("T");  		break;  	case 21:  		sb.Append ("d");  		break;  	case 22:  		sb.Append ("w");  		break;  	case 23:  		sb.Append ("c");  		break;  	case 24:  		sb.Append ("z");  		break;  	case 25:  		sb.Append ("x");  		break;  	case 26:  		sb.Append ("v");  		break;  	case 27:  		sb.Append ("g");  		break;  	}  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,ReverseIME,The following statement contains a magic number: foreach (char ch in str.ToCharArray ()) {  	if (ch < 44032 || ch > 55203)// out of range  	 {  		sb.Append (ch);  		continue;  	}  	int a = 0;  	int b = 0;  	int c = 0;  	for (int i = ch - 44032; i >= 588; i -= 588' ++a)  		;  	for (int i = ch - a * 588 - 44032; i >= 28; i -= 28' ++b)  		;  	c = ch - a * 588 - b * 28 - 44032;  	switch (a) {  	case 0:  		sb.Append ("r");  		break;  	case 1:  		sb.Append ("R");  		break;  	case 2:  		sb.Append ("s");  		break;  	case 3:  		sb.Append ("e");  		break;  	case 4:  		sb.Append ("E");  		break;  	case 5:  		sb.Append ("f");  		break;  	case 6:  		sb.Append ("a");  		break;  	case 7:  		sb.Append ("q");  		break;  	case 8:  		sb.Append ("Q");  		break;  	case 9:  		sb.Append ("t");  		break;  	case 10:  		sb.Append ("T");  		break;  	case 11:  		sb.Append ("d");  		break;  	case 12:  		sb.Append ("w");  		break;  	case 13:  		sb.Append ("W");  		break;  	case 14:  		sb.Append ("c");  		break;  	case 15:  		sb.Append ("z");  		break;  	case 16:  		sb.Append ("x");  		break;  	case 17:  		sb.Append ("v");  		break;  	case 18:  		sb.Append ("g");  		break;  	}  	switch (b) {  	case 0:  		sb.Append ("k");  		break;  	case 1:  		sb.Append ("o");  		break;  	case 2:  		sb.Append ("i");  		break;  	case 3:  		sb.Append ("O");  		break;  	case 4:  		sb.Append ("j");  		break;  	case 5:  		sb.Append ("p");  		break;  	case 6:  		sb.Append ("u");  		break;  	case 7:  		sb.Append ("P");  		break;  	case 8:  		sb.Append ("h");  		break;  	case 9:  		sb.Append ("hk");  		break;  	case 10:  		sb.Append ("ho");  		break;  	case 11:  		sb.Append ("hl");  		break;  	case 12:  		sb.Append ("y");  		break;  	case 13:  		sb.Append ("n");  		break;  	case 14:  		sb.Append ("nj");  		break;  	case 15:  		sb.Append ("np");  		break;  	case 16:  		sb.Append ("nl");  		break;  	case 17:  		sb.Append ("b");  		break;  	case 18:  		sb.Append ("m");  		break;  	case 19:  		sb.Append ("ml");  		break;  	case 20:  		sb.Append ("l");  		break;  	}  	switch (c) {  	case 1:  		sb.Append ("r");  		break;  	case 2:  		sb.Append ("R");  		break;  	case 3:  		sb.Append ("rt");  		break;  	case 4:  		sb.Append ("s");  		break;  	case 5:  		sb.Append ("sw");  		break;  	case 6:  		sb.Append ("sg");  		break;  	case 7:  		sb.Append ("e");  		break;  	case 8:  		sb.Append ("f");  		break;  	case 9:  		sb.Append ("fr");  		break;  	case 10:  		sb.Append ("fa");  		break;  	case 11:  		sb.Append ("fq");  		break;  	case 12:  		sb.Append ("ft");  		break;  	case 13:  		sb.Append ("fx");  		break;  	case 14:  		sb.Append ("fv");  		break;  	case 15:  		sb.Append ("fg");  		break;  	case 16:  		sb.Append ("a");  		break;  	case 17:  		sb.Append ("q");  		break;  	case 18:  		sb.Append ("qt");  		break;  	case 19:  		sb.Append ("t");  		break;  	case 20:  		sb.Append ("T");  		break;  	case 21:  		sb.Append ("d");  		break;  	case 22:  		sb.Append ("w");  		break;  	case 23:  		sb.Append ("c");  		break;  	case 24:  		sb.Append ("z");  		break;  	case 25:  		sb.Append ("x");  		break;  	case 26:  		sb.Append ("v");  		break;  	case 27:  		sb.Append ("g");  		break;  	}  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,ReverseIME,The following statement contains a magic number: foreach (char ch in str.ToCharArray ()) {  	if (ch < 44032 || ch > 55203)// out of range  	 {  		sb.Append (ch);  		continue;  	}  	int a = 0;  	int b = 0;  	int c = 0;  	for (int i = ch - 44032; i >= 588; i -= 588' ++a)  		;  	for (int i = ch - a * 588 - 44032; i >= 28; i -= 28' ++b)  		;  	c = ch - a * 588 - b * 28 - 44032;  	switch (a) {  	case 0:  		sb.Append ("r");  		break;  	case 1:  		sb.Append ("R");  		break;  	case 2:  		sb.Append ("s");  		break;  	case 3:  		sb.Append ("e");  		break;  	case 4:  		sb.Append ("E");  		break;  	case 5:  		sb.Append ("f");  		break;  	case 6:  		sb.Append ("a");  		break;  	case 7:  		sb.Append ("q");  		break;  	case 8:  		sb.Append ("Q");  		break;  	case 9:  		sb.Append ("t");  		break;  	case 10:  		sb.Append ("T");  		break;  	case 11:  		sb.Append ("d");  		break;  	case 12:  		sb.Append ("w");  		break;  	case 13:  		sb.Append ("W");  		break;  	case 14:  		sb.Append ("c");  		break;  	case 15:  		sb.Append ("z");  		break;  	case 16:  		sb.Append ("x");  		break;  	case 17:  		sb.Append ("v");  		break;  	case 18:  		sb.Append ("g");  		break;  	}  	switch (b) {  	case 0:  		sb.Append ("k");  		break;  	case 1:  		sb.Append ("o");  		break;  	case 2:  		sb.Append ("i");  		break;  	case 3:  		sb.Append ("O");  		break;  	case 4:  		sb.Append ("j");  		break;  	case 5:  		sb.Append ("p");  		break;  	case 6:  		sb.Append ("u");  		break;  	case 7:  		sb.Append ("P");  		break;  	case 8:  		sb.Append ("h");  		break;  	case 9:  		sb.Append ("hk");  		break;  	case 10:  		sb.Append ("ho");  		break;  	case 11:  		sb.Append ("hl");  		break;  	case 12:  		sb.Append ("y");  		break;  	case 13:  		sb.Append ("n");  		break;  	case 14:  		sb.Append ("nj");  		break;  	case 15:  		sb.Append ("np");  		break;  	case 16:  		sb.Append ("nl");  		break;  	case 17:  		sb.Append ("b");  		break;  	case 18:  		sb.Append ("m");  		break;  	case 19:  		sb.Append ("ml");  		break;  	case 20:  		sb.Append ("l");  		break;  	}  	switch (c) {  	case 1:  		sb.Append ("r");  		break;  	case 2:  		sb.Append ("R");  		break;  	case 3:  		sb.Append ("rt");  		break;  	case 4:  		sb.Append ("s");  		break;  	case 5:  		sb.Append ("sw");  		break;  	case 6:  		sb.Append ("sg");  		break;  	case 7:  		sb.Append ("e");  		break;  	case 8:  		sb.Append ("f");  		break;  	case 9:  		sb.Append ("fr");  		break;  	case 10:  		sb.Append ("fa");  		break;  	case 11:  		sb.Append ("fq");  		break;  	case 12:  		sb.Append ("ft");  		break;  	case 13:  		sb.Append ("fx");  		break;  	case 14:  		sb.Append ("fv");  		break;  	case 15:  		sb.Append ("fg");  		break;  	case 16:  		sb.Append ("a");  		break;  	case 17:  		sb.Append ("q");  		break;  	case 18:  		sb.Append ("qt");  		break;  	case 19:  		sb.Append ("t");  		break;  	case 20:  		sb.Append ("T");  		break;  	case 21:  		sb.Append ("d");  		break;  	case 22:  		sb.Append ("w");  		break;  	case 23:  		sb.Append ("c");  		break;  	case 24:  		sb.Append ("z");  		break;  	case 25:  		sb.Append ("x");  		break;  	case 26:  		sb.Append ("v");  		break;  	case 27:  		sb.Append ("g");  		break;  	}  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,ReverseIME,The following statement contains a magic number: foreach (char ch in str.ToCharArray ()) {  	if (ch < 44032 || ch > 55203)// out of range  	 {  		sb.Append (ch);  		continue;  	}  	int a = 0;  	int b = 0;  	int c = 0;  	for (int i = ch - 44032; i >= 588; i -= 588' ++a)  		;  	for (int i = ch - a * 588 - 44032; i >= 28; i -= 28' ++b)  		;  	c = ch - a * 588 - b * 28 - 44032;  	switch (a) {  	case 0:  		sb.Append ("r");  		break;  	case 1:  		sb.Append ("R");  		break;  	case 2:  		sb.Append ("s");  		break;  	case 3:  		sb.Append ("e");  		break;  	case 4:  		sb.Append ("E");  		break;  	case 5:  		sb.Append ("f");  		break;  	case 6:  		sb.Append ("a");  		break;  	case 7:  		sb.Append ("q");  		break;  	case 8:  		sb.Append ("Q");  		break;  	case 9:  		sb.Append ("t");  		break;  	case 10:  		sb.Append ("T");  		break;  	case 11:  		sb.Append ("d");  		break;  	case 12:  		sb.Append ("w");  		break;  	case 13:  		sb.Append ("W");  		break;  	case 14:  		sb.Append ("c");  		break;  	case 15:  		sb.Append ("z");  		break;  	case 16:  		sb.Append ("x");  		break;  	case 17:  		sb.Append ("v");  		break;  	case 18:  		sb.Append ("g");  		break;  	}  	switch (b) {  	case 0:  		sb.Append ("k");  		break;  	case 1:  		sb.Append ("o");  		break;  	case 2:  		sb.Append ("i");  		break;  	case 3:  		sb.Append ("O");  		break;  	case 4:  		sb.Append ("j");  		break;  	case 5:  		sb.Append ("p");  		break;  	case 6:  		sb.Append ("u");  		break;  	case 7:  		sb.Append ("P");  		break;  	case 8:  		sb.Append ("h");  		break;  	case 9:  		sb.Append ("hk");  		break;  	case 10:  		sb.Append ("ho");  		break;  	case 11:  		sb.Append ("hl");  		break;  	case 12:  		sb.Append ("y");  		break;  	case 13:  		sb.Append ("n");  		break;  	case 14:  		sb.Append ("nj");  		break;  	case 15:  		sb.Append ("np");  		break;  	case 16:  		sb.Append ("nl");  		break;  	case 17:  		sb.Append ("b");  		break;  	case 18:  		sb.Append ("m");  		break;  	case 19:  		sb.Append ("ml");  		break;  	case 20:  		sb.Append ("l");  		break;  	}  	switch (c) {  	case 1:  		sb.Append ("r");  		break;  	case 2:  		sb.Append ("R");  		break;  	case 3:  		sb.Append ("rt");  		break;  	case 4:  		sb.Append ("s");  		break;  	case 5:  		sb.Append ("sw");  		break;  	case 6:  		sb.Append ("sg");  		break;  	case 7:  		sb.Append ("e");  		break;  	case 8:  		sb.Append ("f");  		break;  	case 9:  		sb.Append ("fr");  		break;  	case 10:  		sb.Append ("fa");  		break;  	case 11:  		sb.Append ("fq");  		break;  	case 12:  		sb.Append ("ft");  		break;  	case 13:  		sb.Append ("fx");  		break;  	case 14:  		sb.Append ("fv");  		break;  	case 15:  		sb.Append ("fg");  		break;  	case 16:  		sb.Append ("a");  		break;  	case 17:  		sb.Append ("q");  		break;  	case 18:  		sb.Append ("qt");  		break;  	case 19:  		sb.Append ("t");  		break;  	case 20:  		sb.Append ("T");  		break;  	case 21:  		sb.Append ("d");  		break;  	case 22:  		sb.Append ("w");  		break;  	case 23:  		sb.Append ("c");  		break;  	case 24:  		sb.Append ("z");  		break;  	case 25:  		sb.Append ("x");  		break;  	case 26:  		sb.Append ("v");  		break;  	case 27:  		sb.Append ("g");  		break;  	}  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,ReverseIME,The following statement contains a magic number: foreach (char ch in str.ToCharArray ()) {  	if (ch < 44032 || ch > 55203)// out of range  	 {  		sb.Append (ch);  		continue;  	}  	int a = 0;  	int b = 0;  	int c = 0;  	for (int i = ch - 44032; i >= 588; i -= 588' ++a)  		;  	for (int i = ch - a * 588 - 44032; i >= 28; i -= 28' ++b)  		;  	c = ch - a * 588 - b * 28 - 44032;  	switch (a) {  	case 0:  		sb.Append ("r");  		break;  	case 1:  		sb.Append ("R");  		break;  	case 2:  		sb.Append ("s");  		break;  	case 3:  		sb.Append ("e");  		break;  	case 4:  		sb.Append ("E");  		break;  	case 5:  		sb.Append ("f");  		break;  	case 6:  		sb.Append ("a");  		break;  	case 7:  		sb.Append ("q");  		break;  	case 8:  		sb.Append ("Q");  		break;  	case 9:  		sb.Append ("t");  		break;  	case 10:  		sb.Append ("T");  		break;  	case 11:  		sb.Append ("d");  		break;  	case 12:  		sb.Append ("w");  		break;  	case 13:  		sb.Append ("W");  		break;  	case 14:  		sb.Append ("c");  		break;  	case 15:  		sb.Append ("z");  		break;  	case 16:  		sb.Append ("x");  		break;  	case 17:  		sb.Append ("v");  		break;  	case 18:  		sb.Append ("g");  		break;  	}  	switch (b) {  	case 0:  		sb.Append ("k");  		break;  	case 1:  		sb.Append ("o");  		break;  	case 2:  		sb.Append ("i");  		break;  	case 3:  		sb.Append ("O");  		break;  	case 4:  		sb.Append ("j");  		break;  	case 5:  		sb.Append ("p");  		break;  	case 6:  		sb.Append ("u");  		break;  	case 7:  		sb.Append ("P");  		break;  	case 8:  		sb.Append ("h");  		break;  	case 9:  		sb.Append ("hk");  		break;  	case 10:  		sb.Append ("ho");  		break;  	case 11:  		sb.Append ("hl");  		break;  	case 12:  		sb.Append ("y");  		break;  	case 13:  		sb.Append ("n");  		break;  	case 14:  		sb.Append ("nj");  		break;  	case 15:  		sb.Append ("np");  		break;  	case 16:  		sb.Append ("nl");  		break;  	case 17:  		sb.Append ("b");  		break;  	case 18:  		sb.Append ("m");  		break;  	case 19:  		sb.Append ("ml");  		break;  	case 20:  		sb.Append ("l");  		break;  	}  	switch (c) {  	case 1:  		sb.Append ("r");  		break;  	case 2:  		sb.Append ("R");  		break;  	case 3:  		sb.Append ("rt");  		break;  	case 4:  		sb.Append ("s");  		break;  	case 5:  		sb.Append ("sw");  		break;  	case 6:  		sb.Append ("sg");  		break;  	case 7:  		sb.Append ("e");  		break;  	case 8:  		sb.Append ("f");  		break;  	case 9:  		sb.Append ("fr");  		break;  	case 10:  		sb.Append ("fa");  		break;  	case 11:  		sb.Append ("fq");  		break;  	case 12:  		sb.Append ("ft");  		break;  	case 13:  		sb.Append ("fx");  		break;  	case 14:  		sb.Append ("fv");  		break;  	case 15:  		sb.Append ("fg");  		break;  	case 16:  		sb.Append ("a");  		break;  	case 17:  		sb.Append ("q");  		break;  	case 18:  		sb.Append ("qt");  		break;  	case 19:  		sb.Append ("t");  		break;  	case 20:  		sb.Append ("T");  		break;  	case 21:  		sb.Append ("d");  		break;  	case 22:  		sb.Append ("w");  		break;  	case 23:  		sb.Append ("c");  		break;  	case 24:  		sb.Append ("z");  		break;  	case 25:  		sb.Append ("x");  		break;  	case 26:  		sb.Append ("v");  		break;  	case 27:  		sb.Append ("g");  		break;  	}  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,ReverseIME,The following statement contains a magic number: foreach (char ch in str.ToCharArray ()) {  	if (ch < 44032 || ch > 55203)// out of range  	 {  		sb.Append (ch);  		continue;  	}  	int a = 0;  	int b = 0;  	int c = 0;  	for (int i = ch - 44032; i >= 588; i -= 588' ++a)  		;  	for (int i = ch - a * 588 - 44032; i >= 28; i -= 28' ++b)  		;  	c = ch - a * 588 - b * 28 - 44032;  	switch (a) {  	case 0:  		sb.Append ("r");  		break;  	case 1:  		sb.Append ("R");  		break;  	case 2:  		sb.Append ("s");  		break;  	case 3:  		sb.Append ("e");  		break;  	case 4:  		sb.Append ("E");  		break;  	case 5:  		sb.Append ("f");  		break;  	case 6:  		sb.Append ("a");  		break;  	case 7:  		sb.Append ("q");  		break;  	case 8:  		sb.Append ("Q");  		break;  	case 9:  		sb.Append ("t");  		break;  	case 10:  		sb.Append ("T");  		break;  	case 11:  		sb.Append ("d");  		break;  	case 12:  		sb.Append ("w");  		break;  	case 13:  		sb.Append ("W");  		break;  	case 14:  		sb.Append ("c");  		break;  	case 15:  		sb.Append ("z");  		break;  	case 16:  		sb.Append ("x");  		break;  	case 17:  		sb.Append ("v");  		break;  	case 18:  		sb.Append ("g");  		break;  	}  	switch (b) {  	case 0:  		sb.Append ("k");  		break;  	case 1:  		sb.Append ("o");  		break;  	case 2:  		sb.Append ("i");  		break;  	case 3:  		sb.Append ("O");  		break;  	case 4:  		sb.Append ("j");  		break;  	case 5:  		sb.Append ("p");  		break;  	case 6:  		sb.Append ("u");  		break;  	case 7:  		sb.Append ("P");  		break;  	case 8:  		sb.Append ("h");  		break;  	case 9:  		sb.Append ("hk");  		break;  	case 10:  		sb.Append ("ho");  		break;  	case 11:  		sb.Append ("hl");  		break;  	case 12:  		sb.Append ("y");  		break;  	case 13:  		sb.Append ("n");  		break;  	case 14:  		sb.Append ("nj");  		break;  	case 15:  		sb.Append ("np");  		break;  	case 16:  		sb.Append ("nl");  		break;  	case 17:  		sb.Append ("b");  		break;  	case 18:  		sb.Append ("m");  		break;  	case 19:  		sb.Append ("ml");  		break;  	case 20:  		sb.Append ("l");  		break;  	}  	switch (c) {  	case 1:  		sb.Append ("r");  		break;  	case 2:  		sb.Append ("R");  		break;  	case 3:  		sb.Append ("rt");  		break;  	case 4:  		sb.Append ("s");  		break;  	case 5:  		sb.Append ("sw");  		break;  	case 6:  		sb.Append ("sg");  		break;  	case 7:  		sb.Append ("e");  		break;  	case 8:  		sb.Append ("f");  		break;  	case 9:  		sb.Append ("fr");  		break;  	case 10:  		sb.Append ("fa");  		break;  	case 11:  		sb.Append ("fq");  		break;  	case 12:  		sb.Append ("ft");  		break;  	case 13:  		sb.Append ("fx");  		break;  	case 14:  		sb.Append ("fv");  		break;  	case 15:  		sb.Append ("fg");  		break;  	case 16:  		sb.Append ("a");  		break;  	case 17:  		sb.Append ("q");  		break;  	case 18:  		sb.Append ("qt");  		break;  	case 19:  		sb.Append ("t");  		break;  	case 20:  		sb.Append ("T");  		break;  	case 21:  		sb.Append ("d");  		break;  	case 22:  		sb.Append ("w");  		break;  	case 23:  		sb.Append ("c");  		break;  	case 24:  		sb.Append ("z");  		break;  	case 25:  		sb.Append ("x");  		break;  	case 26:  		sb.Append ("v");  		break;  	case 27:  		sb.Append ("g");  		break;  	}  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,ReverseIME,The following statement contains a magic number: foreach (char ch in str.ToCharArray ()) {  	if (ch < 44032 || ch > 55203)// out of range  	 {  		sb.Append (ch);  		continue;  	}  	int a = 0;  	int b = 0;  	int c = 0;  	for (int i = ch - 44032; i >= 588; i -= 588' ++a)  		;  	for (int i = ch - a * 588 - 44032; i >= 28; i -= 28' ++b)  		;  	c = ch - a * 588 - b * 28 - 44032;  	switch (a) {  	case 0:  		sb.Append ("r");  		break;  	case 1:  		sb.Append ("R");  		break;  	case 2:  		sb.Append ("s");  		break;  	case 3:  		sb.Append ("e");  		break;  	case 4:  		sb.Append ("E");  		break;  	case 5:  		sb.Append ("f");  		break;  	case 6:  		sb.Append ("a");  		break;  	case 7:  		sb.Append ("q");  		break;  	case 8:  		sb.Append ("Q");  		break;  	case 9:  		sb.Append ("t");  		break;  	case 10:  		sb.Append ("T");  		break;  	case 11:  		sb.Append ("d");  		break;  	case 12:  		sb.Append ("w");  		break;  	case 13:  		sb.Append ("W");  		break;  	case 14:  		sb.Append ("c");  		break;  	case 15:  		sb.Append ("z");  		break;  	case 16:  		sb.Append ("x");  		break;  	case 17:  		sb.Append ("v");  		break;  	case 18:  		sb.Append ("g");  		break;  	}  	switch (b) {  	case 0:  		sb.Append ("k");  		break;  	case 1:  		sb.Append ("o");  		break;  	case 2:  		sb.Append ("i");  		break;  	case 3:  		sb.Append ("O");  		break;  	case 4:  		sb.Append ("j");  		break;  	case 5:  		sb.Append ("p");  		break;  	case 6:  		sb.Append ("u");  		break;  	case 7:  		sb.Append ("P");  		break;  	case 8:  		sb.Append ("h");  		break;  	case 9:  		sb.Append ("hk");  		break;  	case 10:  		sb.Append ("ho");  		break;  	case 11:  		sb.Append ("hl");  		break;  	case 12:  		sb.Append ("y");  		break;  	case 13:  		sb.Append ("n");  		break;  	case 14:  		sb.Append ("nj");  		break;  	case 15:  		sb.Append ("np");  		break;  	case 16:  		sb.Append ("nl");  		break;  	case 17:  		sb.Append ("b");  		break;  	case 18:  		sb.Append ("m");  		break;  	case 19:  		sb.Append ("ml");  		break;  	case 20:  		sb.Append ("l");  		break;  	}  	switch (c) {  	case 1:  		sb.Append ("r");  		break;  	case 2:  		sb.Append ("R");  		break;  	case 3:  		sb.Append ("rt");  		break;  	case 4:  		sb.Append ("s");  		break;  	case 5:  		sb.Append ("sw");  		break;  	case 6:  		sb.Append ("sg");  		break;  	case 7:  		sb.Append ("e");  		break;  	case 8:  		sb.Append ("f");  		break;  	case 9:  		sb.Append ("fr");  		break;  	case 10:  		sb.Append ("fa");  		break;  	case 11:  		sb.Append ("fq");  		break;  	case 12:  		sb.Append ("ft");  		break;  	case 13:  		sb.Append ("fx");  		break;  	case 14:  		sb.Append ("fv");  		break;  	case 15:  		sb.Append ("fg");  		break;  	case 16:  		sb.Append ("a");  		break;  	case 17:  		sb.Append ("q");  		break;  	case 18:  		sb.Append ("qt");  		break;  	case 19:  		sb.Append ("t");  		break;  	case 20:  		sb.Append ("T");  		break;  	case 21:  		sb.Append ("d");  		break;  	case 22:  		sb.Append ("w");  		break;  	case 23:  		sb.Append ("c");  		break;  	case 24:  		sb.Append ("z");  		break;  	case 25:  		sb.Append ("x");  		break;  	case 26:  		sb.Append ("v");  		break;  	case 27:  		sb.Append ("g");  		break;  	}  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,ReverseIME,The following statement contains a magic number: foreach (char ch in str.ToCharArray ()) {  	if (ch < 44032 || ch > 55203)// out of range  	 {  		sb.Append (ch);  		continue;  	}  	int a = 0;  	int b = 0;  	int c = 0;  	for (int i = ch - 44032; i >= 588; i -= 588' ++a)  		;  	for (int i = ch - a * 588 - 44032; i >= 28; i -= 28' ++b)  		;  	c = ch - a * 588 - b * 28 - 44032;  	switch (a) {  	case 0:  		sb.Append ("r");  		break;  	case 1:  		sb.Append ("R");  		break;  	case 2:  		sb.Append ("s");  		break;  	case 3:  		sb.Append ("e");  		break;  	case 4:  		sb.Append ("E");  		break;  	case 5:  		sb.Append ("f");  		break;  	case 6:  		sb.Append ("a");  		break;  	case 7:  		sb.Append ("q");  		break;  	case 8:  		sb.Append ("Q");  		break;  	case 9:  		sb.Append ("t");  		break;  	case 10:  		sb.Append ("T");  		break;  	case 11:  		sb.Append ("d");  		break;  	case 12:  		sb.Append ("w");  		break;  	case 13:  		sb.Append ("W");  		break;  	case 14:  		sb.Append ("c");  		break;  	case 15:  		sb.Append ("z");  		break;  	case 16:  		sb.Append ("x");  		break;  	case 17:  		sb.Append ("v");  		break;  	case 18:  		sb.Append ("g");  		break;  	}  	switch (b) {  	case 0:  		sb.Append ("k");  		break;  	case 1:  		sb.Append ("o");  		break;  	case 2:  		sb.Append ("i");  		break;  	case 3:  		sb.Append ("O");  		break;  	case 4:  		sb.Append ("j");  		break;  	case 5:  		sb.Append ("p");  		break;  	case 6:  		sb.Append ("u");  		break;  	case 7:  		sb.Append ("P");  		break;  	case 8:  		sb.Append ("h");  		break;  	case 9:  		sb.Append ("hk");  		break;  	case 10:  		sb.Append ("ho");  		break;  	case 11:  		sb.Append ("hl");  		break;  	case 12:  		sb.Append ("y");  		break;  	case 13:  		sb.Append ("n");  		break;  	case 14:  		sb.Append ("nj");  		break;  	case 15:  		sb.Append ("np");  		break;  	case 16:  		sb.Append ("nl");  		break;  	case 17:  		sb.Append ("b");  		break;  	case 18:  		sb.Append ("m");  		break;  	case 19:  		sb.Append ("ml");  		break;  	case 20:  		sb.Append ("l");  		break;  	}  	switch (c) {  	case 1:  		sb.Append ("r");  		break;  	case 2:  		sb.Append ("R");  		break;  	case 3:  		sb.Append ("rt");  		break;  	case 4:  		sb.Append ("s");  		break;  	case 5:  		sb.Append ("sw");  		break;  	case 6:  		sb.Append ("sg");  		break;  	case 7:  		sb.Append ("e");  		break;  	case 8:  		sb.Append ("f");  		break;  	case 9:  		sb.Append ("fr");  		break;  	case 10:  		sb.Append ("fa");  		break;  	case 11:  		sb.Append ("fq");  		break;  	case 12:  		sb.Append ("ft");  		break;  	case 13:  		sb.Append ("fx");  		break;  	case 14:  		sb.Append ("fv");  		break;  	case 15:  		sb.Append ("fg");  		break;  	case 16:  		sb.Append ("a");  		break;  	case 17:  		sb.Append ("q");  		break;  	case 18:  		sb.Append ("qt");  		break;  	case 19:  		sb.Append ("t");  		break;  	case 20:  		sb.Append ("T");  		break;  	case 21:  		sb.Append ("d");  		break;  	case 22:  		sb.Append ("w");  		break;  	case 23:  		sb.Append ("c");  		break;  	case 24:  		sb.Append ("z");  		break;  	case 25:  		sb.Append ("x");  		break;  	case 26:  		sb.Append ("v");  		break;  	case 27:  		sb.Append ("g");  		break;  	}  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,ReverseIME,The following statement contains a magic number: foreach (char ch in str.ToCharArray ()) {  	if (ch < 44032 || ch > 55203)// out of range  	 {  		sb.Append (ch);  		continue;  	}  	int a = 0;  	int b = 0;  	int c = 0;  	for (int i = ch - 44032; i >= 588; i -= 588' ++a)  		;  	for (int i = ch - a * 588 - 44032; i >= 28; i -= 28' ++b)  		;  	c = ch - a * 588 - b * 28 - 44032;  	switch (a) {  	case 0:  		sb.Append ("r");  		break;  	case 1:  		sb.Append ("R");  		break;  	case 2:  		sb.Append ("s");  		break;  	case 3:  		sb.Append ("e");  		break;  	case 4:  		sb.Append ("E");  		break;  	case 5:  		sb.Append ("f");  		break;  	case 6:  		sb.Append ("a");  		break;  	case 7:  		sb.Append ("q");  		break;  	case 8:  		sb.Append ("Q");  		break;  	case 9:  		sb.Append ("t");  		break;  	case 10:  		sb.Append ("T");  		break;  	case 11:  		sb.Append ("d");  		break;  	case 12:  		sb.Append ("w");  		break;  	case 13:  		sb.Append ("W");  		break;  	case 14:  		sb.Append ("c");  		break;  	case 15:  		sb.Append ("z");  		break;  	case 16:  		sb.Append ("x");  		break;  	case 17:  		sb.Append ("v");  		break;  	case 18:  		sb.Append ("g");  		break;  	}  	switch (b) {  	case 0:  		sb.Append ("k");  		break;  	case 1:  		sb.Append ("o");  		break;  	case 2:  		sb.Append ("i");  		break;  	case 3:  		sb.Append ("O");  		break;  	case 4:  		sb.Append ("j");  		break;  	case 5:  		sb.Append ("p");  		break;  	case 6:  		sb.Append ("u");  		break;  	case 7:  		sb.Append ("P");  		break;  	case 8:  		sb.Append ("h");  		break;  	case 9:  		sb.Append ("hk");  		break;  	case 10:  		sb.Append ("ho");  		break;  	case 11:  		sb.Append ("hl");  		break;  	case 12:  		sb.Append ("y");  		break;  	case 13:  		sb.Append ("n");  		break;  	case 14:  		sb.Append ("nj");  		break;  	case 15:  		sb.Append ("np");  		break;  	case 16:  		sb.Append ("nl");  		break;  	case 17:  		sb.Append ("b");  		break;  	case 18:  		sb.Append ("m");  		break;  	case 19:  		sb.Append ("ml");  		break;  	case 20:  		sb.Append ("l");  		break;  	}  	switch (c) {  	case 1:  		sb.Append ("r");  		break;  	case 2:  		sb.Append ("R");  		break;  	case 3:  		sb.Append ("rt");  		break;  	case 4:  		sb.Append ("s");  		break;  	case 5:  		sb.Append ("sw");  		break;  	case 6:  		sb.Append ("sg");  		break;  	case 7:  		sb.Append ("e");  		break;  	case 8:  		sb.Append ("f");  		break;  	case 9:  		sb.Append ("fr");  		break;  	case 10:  		sb.Append ("fa");  		break;  	case 11:  		sb.Append ("fq");  		break;  	case 12:  		sb.Append ("ft");  		break;  	case 13:  		sb.Append ("fx");  		break;  	case 14:  		sb.Append ("fv");  		break;  	case 15:  		sb.Append ("fg");  		break;  	case 16:  		sb.Append ("a");  		break;  	case 17:  		sb.Append ("q");  		break;  	case 18:  		sb.Append ("qt");  		break;  	case 19:  		sb.Append ("t");  		break;  	case 20:  		sb.Append ("T");  		break;  	case 21:  		sb.Append ("d");  		break;  	case 22:  		sb.Append ("w");  		break;  	case 23:  		sb.Append ("c");  		break;  	case 24:  		sb.Append ("z");  		break;  	case 25:  		sb.Append ("x");  		break;  	case 26:  		sb.Append ("v");  		break;  	case 27:  		sb.Append ("g");  		break;  	}  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,ReverseIME,The following statement contains a magic number: foreach (char ch in str.ToCharArray ()) {  	if (ch < 44032 || ch > 55203)// out of range  	 {  		sb.Append (ch);  		continue;  	}  	int a = 0;  	int b = 0;  	int c = 0;  	for (int i = ch - 44032; i >= 588; i -= 588' ++a)  		;  	for (int i = ch - a * 588 - 44032; i >= 28; i -= 28' ++b)  		;  	c = ch - a * 588 - b * 28 - 44032;  	switch (a) {  	case 0:  		sb.Append ("r");  		break;  	case 1:  		sb.Append ("R");  		break;  	case 2:  		sb.Append ("s");  		break;  	case 3:  		sb.Append ("e");  		break;  	case 4:  		sb.Append ("E");  		break;  	case 5:  		sb.Append ("f");  		break;  	case 6:  		sb.Append ("a");  		break;  	case 7:  		sb.Append ("q");  		break;  	case 8:  		sb.Append ("Q");  		break;  	case 9:  		sb.Append ("t");  		break;  	case 10:  		sb.Append ("T");  		break;  	case 11:  		sb.Append ("d");  		break;  	case 12:  		sb.Append ("w");  		break;  	case 13:  		sb.Append ("W");  		break;  	case 14:  		sb.Append ("c");  		break;  	case 15:  		sb.Append ("z");  		break;  	case 16:  		sb.Append ("x");  		break;  	case 17:  		sb.Append ("v");  		break;  	case 18:  		sb.Append ("g");  		break;  	}  	switch (b) {  	case 0:  		sb.Append ("k");  		break;  	case 1:  		sb.Append ("o");  		break;  	case 2:  		sb.Append ("i");  		break;  	case 3:  		sb.Append ("O");  		break;  	case 4:  		sb.Append ("j");  		break;  	case 5:  		sb.Append ("p");  		break;  	case 6:  		sb.Append ("u");  		break;  	case 7:  		sb.Append ("P");  		break;  	case 8:  		sb.Append ("h");  		break;  	case 9:  		sb.Append ("hk");  		break;  	case 10:  		sb.Append ("ho");  		break;  	case 11:  		sb.Append ("hl");  		break;  	case 12:  		sb.Append ("y");  		break;  	case 13:  		sb.Append ("n");  		break;  	case 14:  		sb.Append ("nj");  		break;  	case 15:  		sb.Append ("np");  		break;  	case 16:  		sb.Append ("nl");  		break;  	case 17:  		sb.Append ("b");  		break;  	case 18:  		sb.Append ("m");  		break;  	case 19:  		sb.Append ("ml");  		break;  	case 20:  		sb.Append ("l");  		break;  	}  	switch (c) {  	case 1:  		sb.Append ("r");  		break;  	case 2:  		sb.Append ("R");  		break;  	case 3:  		sb.Append ("rt");  		break;  	case 4:  		sb.Append ("s");  		break;  	case 5:  		sb.Append ("sw");  		break;  	case 6:  		sb.Append ("sg");  		break;  	case 7:  		sb.Append ("e");  		break;  	case 8:  		sb.Append ("f");  		break;  	case 9:  		sb.Append ("fr");  		break;  	case 10:  		sb.Append ("fa");  		break;  	case 11:  		sb.Append ("fq");  		break;  	case 12:  		sb.Append ("ft");  		break;  	case 13:  		sb.Append ("fx");  		break;  	case 14:  		sb.Append ("fv");  		break;  	case 15:  		sb.Append ("fg");  		break;  	case 16:  		sb.Append ("a");  		break;  	case 17:  		sb.Append ("q");  		break;  	case 18:  		sb.Append ("qt");  		break;  	case 19:  		sb.Append ("t");  		break;  	case 20:  		sb.Append ("T");  		break;  	case 21:  		sb.Append ("d");  		break;  	case 22:  		sb.Append ("w");  		break;  	case 23:  		sb.Append ("c");  		break;  	case 24:  		sb.Append ("z");  		break;  	case 25:  		sb.Append ("x");  		break;  	case 26:  		sb.Append ("v");  		break;  	case 27:  		sb.Append ("g");  		break;  	}  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,ReverseIME,The following statement contains a magic number: foreach (char ch in str.ToCharArray ()) {  	if (ch < 44032 || ch > 55203)// out of range  	 {  		sb.Append (ch);  		continue;  	}  	int a = 0;  	int b = 0;  	int c = 0;  	for (int i = ch - 44032; i >= 588; i -= 588' ++a)  		;  	for (int i = ch - a * 588 - 44032; i >= 28; i -= 28' ++b)  		;  	c = ch - a * 588 - b * 28 - 44032;  	switch (a) {  	case 0:  		sb.Append ("r");  		break;  	case 1:  		sb.Append ("R");  		break;  	case 2:  		sb.Append ("s");  		break;  	case 3:  		sb.Append ("e");  		break;  	case 4:  		sb.Append ("E");  		break;  	case 5:  		sb.Append ("f");  		break;  	case 6:  		sb.Append ("a");  		break;  	case 7:  		sb.Append ("q");  		break;  	case 8:  		sb.Append ("Q");  		break;  	case 9:  		sb.Append ("t");  		break;  	case 10:  		sb.Append ("T");  		break;  	case 11:  		sb.Append ("d");  		break;  	case 12:  		sb.Append ("w");  		break;  	case 13:  		sb.Append ("W");  		break;  	case 14:  		sb.Append ("c");  		break;  	case 15:  		sb.Append ("z");  		break;  	case 16:  		sb.Append ("x");  		break;  	case 17:  		sb.Append ("v");  		break;  	case 18:  		sb.Append ("g");  		break;  	}  	switch (b) {  	case 0:  		sb.Append ("k");  		break;  	case 1:  		sb.Append ("o");  		break;  	case 2:  		sb.Append ("i");  		break;  	case 3:  		sb.Append ("O");  		break;  	case 4:  		sb.Append ("j");  		break;  	case 5:  		sb.Append ("p");  		break;  	case 6:  		sb.Append ("u");  		break;  	case 7:  		sb.Append ("P");  		break;  	case 8:  		sb.Append ("h");  		break;  	case 9:  		sb.Append ("hk");  		break;  	case 10:  		sb.Append ("ho");  		break;  	case 11:  		sb.Append ("hl");  		break;  	case 12:  		sb.Append ("y");  		break;  	case 13:  		sb.Append ("n");  		break;  	case 14:  		sb.Append ("nj");  		break;  	case 15:  		sb.Append ("np");  		break;  	case 16:  		sb.Append ("nl");  		break;  	case 17:  		sb.Append ("b");  		break;  	case 18:  		sb.Append ("m");  		break;  	case 19:  		sb.Append ("ml");  		break;  	case 20:  		sb.Append ("l");  		break;  	}  	switch (c) {  	case 1:  		sb.Append ("r");  		break;  	case 2:  		sb.Append ("R");  		break;  	case 3:  		sb.Append ("rt");  		break;  	case 4:  		sb.Append ("s");  		break;  	case 5:  		sb.Append ("sw");  		break;  	case 6:  		sb.Append ("sg");  		break;  	case 7:  		sb.Append ("e");  		break;  	case 8:  		sb.Append ("f");  		break;  	case 9:  		sb.Append ("fr");  		break;  	case 10:  		sb.Append ("fa");  		break;  	case 11:  		sb.Append ("fq");  		break;  	case 12:  		sb.Append ("ft");  		break;  	case 13:  		sb.Append ("fx");  		break;  	case 14:  		sb.Append ("fv");  		break;  	case 15:  		sb.Append ("fg");  		break;  	case 16:  		sb.Append ("a");  		break;  	case 17:  		sb.Append ("q");  		break;  	case 18:  		sb.Append ("qt");  		break;  	case 19:  		sb.Append ("t");  		break;  	case 20:  		sb.Append ("T");  		break;  	case 21:  		sb.Append ("d");  		break;  	case 22:  		sb.Append ("w");  		break;  	case 23:  		sb.Append ("c");  		break;  	case 24:  		sb.Append ("z");  		break;  	case 25:  		sb.Append ("x");  		break;  	case 26:  		sb.Append ("v");  		break;  	case 27:  		sb.Append ("g");  		break;  	}  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,ReverseIME,The following statement contains a magic number: foreach (char ch in str.ToCharArray ()) {  	if (ch < 44032 || ch > 55203)// out of range  	 {  		sb.Append (ch);  		continue;  	}  	int a = 0;  	int b = 0;  	int c = 0;  	for (int i = ch - 44032; i >= 588; i -= 588' ++a)  		;  	for (int i = ch - a * 588 - 44032; i >= 28; i -= 28' ++b)  		;  	c = ch - a * 588 - b * 28 - 44032;  	switch (a) {  	case 0:  		sb.Append ("r");  		break;  	case 1:  		sb.Append ("R");  		break;  	case 2:  		sb.Append ("s");  		break;  	case 3:  		sb.Append ("e");  		break;  	case 4:  		sb.Append ("E");  		break;  	case 5:  		sb.Append ("f");  		break;  	case 6:  		sb.Append ("a");  		break;  	case 7:  		sb.Append ("q");  		break;  	case 8:  		sb.Append ("Q");  		break;  	case 9:  		sb.Append ("t");  		break;  	case 10:  		sb.Append ("T");  		break;  	case 11:  		sb.Append ("d");  		break;  	case 12:  		sb.Append ("w");  		break;  	case 13:  		sb.Append ("W");  		break;  	case 14:  		sb.Append ("c");  		break;  	case 15:  		sb.Append ("z");  		break;  	case 16:  		sb.Append ("x");  		break;  	case 17:  		sb.Append ("v");  		break;  	case 18:  		sb.Append ("g");  		break;  	}  	switch (b) {  	case 0:  		sb.Append ("k");  		break;  	case 1:  		sb.Append ("o");  		break;  	case 2:  		sb.Append ("i");  		break;  	case 3:  		sb.Append ("O");  		break;  	case 4:  		sb.Append ("j");  		break;  	case 5:  		sb.Append ("p");  		break;  	case 6:  		sb.Append ("u");  		break;  	case 7:  		sb.Append ("P");  		break;  	case 8:  		sb.Append ("h");  		break;  	case 9:  		sb.Append ("hk");  		break;  	case 10:  		sb.Append ("ho");  		break;  	case 11:  		sb.Append ("hl");  		break;  	case 12:  		sb.Append ("y");  		break;  	case 13:  		sb.Append ("n");  		break;  	case 14:  		sb.Append ("nj");  		break;  	case 15:  		sb.Append ("np");  		break;  	case 16:  		sb.Append ("nl");  		break;  	case 17:  		sb.Append ("b");  		break;  	case 18:  		sb.Append ("m");  		break;  	case 19:  		sb.Append ("ml");  		break;  	case 20:  		sb.Append ("l");  		break;  	}  	switch (c) {  	case 1:  		sb.Append ("r");  		break;  	case 2:  		sb.Append ("R");  		break;  	case 3:  		sb.Append ("rt");  		break;  	case 4:  		sb.Append ("s");  		break;  	case 5:  		sb.Append ("sw");  		break;  	case 6:  		sb.Append ("sg");  		break;  	case 7:  		sb.Append ("e");  		break;  	case 8:  		sb.Append ("f");  		break;  	case 9:  		sb.Append ("fr");  		break;  	case 10:  		sb.Append ("fa");  		break;  	case 11:  		sb.Append ("fq");  		break;  	case 12:  		sb.Append ("ft");  		break;  	case 13:  		sb.Append ("fx");  		break;  	case 14:  		sb.Append ("fv");  		break;  	case 15:  		sb.Append ("fg");  		break;  	case 16:  		sb.Append ("a");  		break;  	case 17:  		sb.Append ("q");  		break;  	case 18:  		sb.Append ("qt");  		break;  	case 19:  		sb.Append ("t");  		break;  	case 20:  		sb.Append ("T");  		break;  	case 21:  		sb.Append ("d");  		break;  	case 22:  		sb.Append ("w");  		break;  	case 23:  		sb.Append ("c");  		break;  	case 24:  		sb.Append ("z");  		break;  	case 25:  		sb.Append ("x");  		break;  	case 26:  		sb.Append ("v");  		break;  	case 27:  		sb.Append ("g");  		break;  	}  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,ReverseIME,The following statement contains a magic number: foreach (char ch in str.ToCharArray ()) {  	if (ch < 44032 || ch > 55203)// out of range  	 {  		sb.Append (ch);  		continue;  	}  	int a = 0;  	int b = 0;  	int c = 0;  	for (int i = ch - 44032; i >= 588; i -= 588' ++a)  		;  	for (int i = ch - a * 588 - 44032; i >= 28; i -= 28' ++b)  		;  	c = ch - a * 588 - b * 28 - 44032;  	switch (a) {  	case 0:  		sb.Append ("r");  		break;  	case 1:  		sb.Append ("R");  		break;  	case 2:  		sb.Append ("s");  		break;  	case 3:  		sb.Append ("e");  		break;  	case 4:  		sb.Append ("E");  		break;  	case 5:  		sb.Append ("f");  		break;  	case 6:  		sb.Append ("a");  		break;  	case 7:  		sb.Append ("q");  		break;  	case 8:  		sb.Append ("Q");  		break;  	case 9:  		sb.Append ("t");  		break;  	case 10:  		sb.Append ("T");  		break;  	case 11:  		sb.Append ("d");  		break;  	case 12:  		sb.Append ("w");  		break;  	case 13:  		sb.Append ("W");  		break;  	case 14:  		sb.Append ("c");  		break;  	case 15:  		sb.Append ("z");  		break;  	case 16:  		sb.Append ("x");  		break;  	case 17:  		sb.Append ("v");  		break;  	case 18:  		sb.Append ("g");  		break;  	}  	switch (b) {  	case 0:  		sb.Append ("k");  		break;  	case 1:  		sb.Append ("o");  		break;  	case 2:  		sb.Append ("i");  		break;  	case 3:  		sb.Append ("O");  		break;  	case 4:  		sb.Append ("j");  		break;  	case 5:  		sb.Append ("p");  		break;  	case 6:  		sb.Append ("u");  		break;  	case 7:  		sb.Append ("P");  		break;  	case 8:  		sb.Append ("h");  		break;  	case 9:  		sb.Append ("hk");  		break;  	case 10:  		sb.Append ("ho");  		break;  	case 11:  		sb.Append ("hl");  		break;  	case 12:  		sb.Append ("y");  		break;  	case 13:  		sb.Append ("n");  		break;  	case 14:  		sb.Append ("nj");  		break;  	case 15:  		sb.Append ("np");  		break;  	case 16:  		sb.Append ("nl");  		break;  	case 17:  		sb.Append ("b");  		break;  	case 18:  		sb.Append ("m");  		break;  	case 19:  		sb.Append ("ml");  		break;  	case 20:  		sb.Append ("l");  		break;  	}  	switch (c) {  	case 1:  		sb.Append ("r");  		break;  	case 2:  		sb.Append ("R");  		break;  	case 3:  		sb.Append ("rt");  		break;  	case 4:  		sb.Append ("s");  		break;  	case 5:  		sb.Append ("sw");  		break;  	case 6:  		sb.Append ("sg");  		break;  	case 7:  		sb.Append ("e");  		break;  	case 8:  		sb.Append ("f");  		break;  	case 9:  		sb.Append ("fr");  		break;  	case 10:  		sb.Append ("fa");  		break;  	case 11:  		sb.Append ("fq");  		break;  	case 12:  		sb.Append ("ft");  		break;  	case 13:  		sb.Append ("fx");  		break;  	case 14:  		sb.Append ("fv");  		break;  	case 15:  		sb.Append ("fg");  		break;  	case 16:  		sb.Append ("a");  		break;  	case 17:  		sb.Append ("q");  		break;  	case 18:  		sb.Append ("qt");  		break;  	case 19:  		sb.Append ("t");  		break;  	case 20:  		sb.Append ("T");  		break;  	case 21:  		sb.Append ("d");  		break;  	case 22:  		sb.Append ("w");  		break;  	case 23:  		sb.Append ("c");  		break;  	case 24:  		sb.Append ("z");  		break;  	case 25:  		sb.Append ("x");  		break;  	case 26:  		sb.Append ("v");  		break;  	case 27:  		sb.Append ("g");  		break;  	}  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,ReverseIME,The following statement contains a magic number: if (ch < 44032 || ch > 55203)// out of range   {  	sb.Append (ch);  	continue;  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,ReverseIME,The following statement contains a magic number: if (ch < 44032 || ch > 55203)// out of range   {  	sb.Append (ch);  	continue;  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,ReverseIME,The following statement contains a magic number: for (int i = ch - 44032; i >= 588; i -= 588' ++a)  	;  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,ReverseIME,The following statement contains a magic number: for (int i = ch - 44032; i >= 588; i -= 588' ++a)  	;  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,ReverseIME,The following statement contains a magic number: for (int i = ch - 44032; i >= 588; i -= 588' ++a)  	;  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,ReverseIME,The following statement contains a magic number: i -= 588
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,ReverseIME,The following statement contains a magic number: for (int i = ch - a * 588 - 44032; i >= 28; i -= 28' ++b)  	;  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,ReverseIME,The following statement contains a magic number: for (int i = ch - a * 588 - 44032; i >= 28; i -= 28' ++b)  	;  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,ReverseIME,The following statement contains a magic number: for (int i = ch - a * 588 - 44032; i >= 28; i -= 28' ++b)  	;  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,ReverseIME,The following statement contains a magic number: for (int i = ch - a * 588 - 44032; i >= 28; i -= 28' ++b)  	;  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,ReverseIME,The following statement contains a magic number: i -= 28
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,ReverseIME,The following statement contains a magic number: c = ch - a * 588 - b * 28 - 44032;  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,ReverseIME,The following statement contains a magic number: c = ch - a * 588 - b * 28 - 44032;  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,ReverseIME,The following statement contains a magic number: c = ch - a * 588 - b * 28 - 44032;  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,ReverseIME,The following statement contains a magic number: switch (a) {  case 0:  	sb.Append ("r");  	break;  case 1:  	sb.Append ("R");  	break;  case 2:  	sb.Append ("s");  	break;  case 3:  	sb.Append ("e");  	break;  case 4:  	sb.Append ("E");  	break;  case 5:  	sb.Append ("f");  	break;  case 6:  	sb.Append ("a");  	break;  case 7:  	sb.Append ("q");  	break;  case 8:  	sb.Append ("Q");  	break;  case 9:  	sb.Append ("t");  	break;  case 10:  	sb.Append ("T");  	break;  case 11:  	sb.Append ("d");  	break;  case 12:  	sb.Append ("w");  	break;  case 13:  	sb.Append ("W");  	break;  case 14:  	sb.Append ("c");  	break;  case 15:  	sb.Append ("z");  	break;  case 16:  	sb.Append ("x");  	break;  case 17:  	sb.Append ("v");  	break;  case 18:  	sb.Append ("g");  	break;  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,ReverseIME,The following statement contains a magic number: switch (a) {  case 0:  	sb.Append ("r");  	break;  case 1:  	sb.Append ("R");  	break;  case 2:  	sb.Append ("s");  	break;  case 3:  	sb.Append ("e");  	break;  case 4:  	sb.Append ("E");  	break;  case 5:  	sb.Append ("f");  	break;  case 6:  	sb.Append ("a");  	break;  case 7:  	sb.Append ("q");  	break;  case 8:  	sb.Append ("Q");  	break;  case 9:  	sb.Append ("t");  	break;  case 10:  	sb.Append ("T");  	break;  case 11:  	sb.Append ("d");  	break;  case 12:  	sb.Append ("w");  	break;  case 13:  	sb.Append ("W");  	break;  case 14:  	sb.Append ("c");  	break;  case 15:  	sb.Append ("z");  	break;  case 16:  	sb.Append ("x");  	break;  case 17:  	sb.Append ("v");  	break;  case 18:  	sb.Append ("g");  	break;  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,ReverseIME,The following statement contains a magic number: switch (a) {  case 0:  	sb.Append ("r");  	break;  case 1:  	sb.Append ("R");  	break;  case 2:  	sb.Append ("s");  	break;  case 3:  	sb.Append ("e");  	break;  case 4:  	sb.Append ("E");  	break;  case 5:  	sb.Append ("f");  	break;  case 6:  	sb.Append ("a");  	break;  case 7:  	sb.Append ("q");  	break;  case 8:  	sb.Append ("Q");  	break;  case 9:  	sb.Append ("t");  	break;  case 10:  	sb.Append ("T");  	break;  case 11:  	sb.Append ("d");  	break;  case 12:  	sb.Append ("w");  	break;  case 13:  	sb.Append ("W");  	break;  case 14:  	sb.Append ("c");  	break;  case 15:  	sb.Append ("z");  	break;  case 16:  	sb.Append ("x");  	break;  case 17:  	sb.Append ("v");  	break;  case 18:  	sb.Append ("g");  	break;  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,ReverseIME,The following statement contains a magic number: switch (a) {  case 0:  	sb.Append ("r");  	break;  case 1:  	sb.Append ("R");  	break;  case 2:  	sb.Append ("s");  	break;  case 3:  	sb.Append ("e");  	break;  case 4:  	sb.Append ("E");  	break;  case 5:  	sb.Append ("f");  	break;  case 6:  	sb.Append ("a");  	break;  case 7:  	sb.Append ("q");  	break;  case 8:  	sb.Append ("Q");  	break;  case 9:  	sb.Append ("t");  	break;  case 10:  	sb.Append ("T");  	break;  case 11:  	sb.Append ("d");  	break;  case 12:  	sb.Append ("w");  	break;  case 13:  	sb.Append ("W");  	break;  case 14:  	sb.Append ("c");  	break;  case 15:  	sb.Append ("z");  	break;  case 16:  	sb.Append ("x");  	break;  case 17:  	sb.Append ("v");  	break;  case 18:  	sb.Append ("g");  	break;  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,ReverseIME,The following statement contains a magic number: switch (a) {  case 0:  	sb.Append ("r");  	break;  case 1:  	sb.Append ("R");  	break;  case 2:  	sb.Append ("s");  	break;  case 3:  	sb.Append ("e");  	break;  case 4:  	sb.Append ("E");  	break;  case 5:  	sb.Append ("f");  	break;  case 6:  	sb.Append ("a");  	break;  case 7:  	sb.Append ("q");  	break;  case 8:  	sb.Append ("Q");  	break;  case 9:  	sb.Append ("t");  	break;  case 10:  	sb.Append ("T");  	break;  case 11:  	sb.Append ("d");  	break;  case 12:  	sb.Append ("w");  	break;  case 13:  	sb.Append ("W");  	break;  case 14:  	sb.Append ("c");  	break;  case 15:  	sb.Append ("z");  	break;  case 16:  	sb.Append ("x");  	break;  case 17:  	sb.Append ("v");  	break;  case 18:  	sb.Append ("g");  	break;  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,ReverseIME,The following statement contains a magic number: switch (a) {  case 0:  	sb.Append ("r");  	break;  case 1:  	sb.Append ("R");  	break;  case 2:  	sb.Append ("s");  	break;  case 3:  	sb.Append ("e");  	break;  case 4:  	sb.Append ("E");  	break;  case 5:  	sb.Append ("f");  	break;  case 6:  	sb.Append ("a");  	break;  case 7:  	sb.Append ("q");  	break;  case 8:  	sb.Append ("Q");  	break;  case 9:  	sb.Append ("t");  	break;  case 10:  	sb.Append ("T");  	break;  case 11:  	sb.Append ("d");  	break;  case 12:  	sb.Append ("w");  	break;  case 13:  	sb.Append ("W");  	break;  case 14:  	sb.Append ("c");  	break;  case 15:  	sb.Append ("z");  	break;  case 16:  	sb.Append ("x");  	break;  case 17:  	sb.Append ("v");  	break;  case 18:  	sb.Append ("g");  	break;  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,ReverseIME,The following statement contains a magic number: switch (a) {  case 0:  	sb.Append ("r");  	break;  case 1:  	sb.Append ("R");  	break;  case 2:  	sb.Append ("s");  	break;  case 3:  	sb.Append ("e");  	break;  case 4:  	sb.Append ("E");  	break;  case 5:  	sb.Append ("f");  	break;  case 6:  	sb.Append ("a");  	break;  case 7:  	sb.Append ("q");  	break;  case 8:  	sb.Append ("Q");  	break;  case 9:  	sb.Append ("t");  	break;  case 10:  	sb.Append ("T");  	break;  case 11:  	sb.Append ("d");  	break;  case 12:  	sb.Append ("w");  	break;  case 13:  	sb.Append ("W");  	break;  case 14:  	sb.Append ("c");  	break;  case 15:  	sb.Append ("z");  	break;  case 16:  	sb.Append ("x");  	break;  case 17:  	sb.Append ("v");  	break;  case 18:  	sb.Append ("g");  	break;  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,ReverseIME,The following statement contains a magic number: switch (a) {  case 0:  	sb.Append ("r");  	break;  case 1:  	sb.Append ("R");  	break;  case 2:  	sb.Append ("s");  	break;  case 3:  	sb.Append ("e");  	break;  case 4:  	sb.Append ("E");  	break;  case 5:  	sb.Append ("f");  	break;  case 6:  	sb.Append ("a");  	break;  case 7:  	sb.Append ("q");  	break;  case 8:  	sb.Append ("Q");  	break;  case 9:  	sb.Append ("t");  	break;  case 10:  	sb.Append ("T");  	break;  case 11:  	sb.Append ("d");  	break;  case 12:  	sb.Append ("w");  	break;  case 13:  	sb.Append ("W");  	break;  case 14:  	sb.Append ("c");  	break;  case 15:  	sb.Append ("z");  	break;  case 16:  	sb.Append ("x");  	break;  case 17:  	sb.Append ("v");  	break;  case 18:  	sb.Append ("g");  	break;  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,ReverseIME,The following statement contains a magic number: switch (a) {  case 0:  	sb.Append ("r");  	break;  case 1:  	sb.Append ("R");  	break;  case 2:  	sb.Append ("s");  	break;  case 3:  	sb.Append ("e");  	break;  case 4:  	sb.Append ("E");  	break;  case 5:  	sb.Append ("f");  	break;  case 6:  	sb.Append ("a");  	break;  case 7:  	sb.Append ("q");  	break;  case 8:  	sb.Append ("Q");  	break;  case 9:  	sb.Append ("t");  	break;  case 10:  	sb.Append ("T");  	break;  case 11:  	sb.Append ("d");  	break;  case 12:  	sb.Append ("w");  	break;  case 13:  	sb.Append ("W");  	break;  case 14:  	sb.Append ("c");  	break;  case 15:  	sb.Append ("z");  	break;  case 16:  	sb.Append ("x");  	break;  case 17:  	sb.Append ("v");  	break;  case 18:  	sb.Append ("g");  	break;  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,ReverseIME,The following statement contains a magic number: switch (a) {  case 0:  	sb.Append ("r");  	break;  case 1:  	sb.Append ("R");  	break;  case 2:  	sb.Append ("s");  	break;  case 3:  	sb.Append ("e");  	break;  case 4:  	sb.Append ("E");  	break;  case 5:  	sb.Append ("f");  	break;  case 6:  	sb.Append ("a");  	break;  case 7:  	sb.Append ("q");  	break;  case 8:  	sb.Append ("Q");  	break;  case 9:  	sb.Append ("t");  	break;  case 10:  	sb.Append ("T");  	break;  case 11:  	sb.Append ("d");  	break;  case 12:  	sb.Append ("w");  	break;  case 13:  	sb.Append ("W");  	break;  case 14:  	sb.Append ("c");  	break;  case 15:  	sb.Append ("z");  	break;  case 16:  	sb.Append ("x");  	break;  case 17:  	sb.Append ("v");  	break;  case 18:  	sb.Append ("g");  	break;  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,ReverseIME,The following statement contains a magic number: switch (a) {  case 0:  	sb.Append ("r");  	break;  case 1:  	sb.Append ("R");  	break;  case 2:  	sb.Append ("s");  	break;  case 3:  	sb.Append ("e");  	break;  case 4:  	sb.Append ("E");  	break;  case 5:  	sb.Append ("f");  	break;  case 6:  	sb.Append ("a");  	break;  case 7:  	sb.Append ("q");  	break;  case 8:  	sb.Append ("Q");  	break;  case 9:  	sb.Append ("t");  	break;  case 10:  	sb.Append ("T");  	break;  case 11:  	sb.Append ("d");  	break;  case 12:  	sb.Append ("w");  	break;  case 13:  	sb.Append ("W");  	break;  case 14:  	sb.Append ("c");  	break;  case 15:  	sb.Append ("z");  	break;  case 16:  	sb.Append ("x");  	break;  case 17:  	sb.Append ("v");  	break;  case 18:  	sb.Append ("g");  	break;  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,ReverseIME,The following statement contains a magic number: switch (a) {  case 0:  	sb.Append ("r");  	break;  case 1:  	sb.Append ("R");  	break;  case 2:  	sb.Append ("s");  	break;  case 3:  	sb.Append ("e");  	break;  case 4:  	sb.Append ("E");  	break;  case 5:  	sb.Append ("f");  	break;  case 6:  	sb.Append ("a");  	break;  case 7:  	sb.Append ("q");  	break;  case 8:  	sb.Append ("Q");  	break;  case 9:  	sb.Append ("t");  	break;  case 10:  	sb.Append ("T");  	break;  case 11:  	sb.Append ("d");  	break;  case 12:  	sb.Append ("w");  	break;  case 13:  	sb.Append ("W");  	break;  case 14:  	sb.Append ("c");  	break;  case 15:  	sb.Append ("z");  	break;  case 16:  	sb.Append ("x");  	break;  case 17:  	sb.Append ("v");  	break;  case 18:  	sb.Append ("g");  	break;  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,ReverseIME,The following statement contains a magic number: switch (a) {  case 0:  	sb.Append ("r");  	break;  case 1:  	sb.Append ("R");  	break;  case 2:  	sb.Append ("s");  	break;  case 3:  	sb.Append ("e");  	break;  case 4:  	sb.Append ("E");  	break;  case 5:  	sb.Append ("f");  	break;  case 6:  	sb.Append ("a");  	break;  case 7:  	sb.Append ("q");  	break;  case 8:  	sb.Append ("Q");  	break;  case 9:  	sb.Append ("t");  	break;  case 10:  	sb.Append ("T");  	break;  case 11:  	sb.Append ("d");  	break;  case 12:  	sb.Append ("w");  	break;  case 13:  	sb.Append ("W");  	break;  case 14:  	sb.Append ("c");  	break;  case 15:  	sb.Append ("z");  	break;  case 16:  	sb.Append ("x");  	break;  case 17:  	sb.Append ("v");  	break;  case 18:  	sb.Append ("g");  	break;  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,ReverseIME,The following statement contains a magic number: switch (a) {  case 0:  	sb.Append ("r");  	break;  case 1:  	sb.Append ("R");  	break;  case 2:  	sb.Append ("s");  	break;  case 3:  	sb.Append ("e");  	break;  case 4:  	sb.Append ("E");  	break;  case 5:  	sb.Append ("f");  	break;  case 6:  	sb.Append ("a");  	break;  case 7:  	sb.Append ("q");  	break;  case 8:  	sb.Append ("Q");  	break;  case 9:  	sb.Append ("t");  	break;  case 10:  	sb.Append ("T");  	break;  case 11:  	sb.Append ("d");  	break;  case 12:  	sb.Append ("w");  	break;  case 13:  	sb.Append ("W");  	break;  case 14:  	sb.Append ("c");  	break;  case 15:  	sb.Append ("z");  	break;  case 16:  	sb.Append ("x");  	break;  case 17:  	sb.Append ("v");  	break;  case 18:  	sb.Append ("g");  	break;  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,ReverseIME,The following statement contains a magic number: switch (a) {  case 0:  	sb.Append ("r");  	break;  case 1:  	sb.Append ("R");  	break;  case 2:  	sb.Append ("s");  	break;  case 3:  	sb.Append ("e");  	break;  case 4:  	sb.Append ("E");  	break;  case 5:  	sb.Append ("f");  	break;  case 6:  	sb.Append ("a");  	break;  case 7:  	sb.Append ("q");  	break;  case 8:  	sb.Append ("Q");  	break;  case 9:  	sb.Append ("t");  	break;  case 10:  	sb.Append ("T");  	break;  case 11:  	sb.Append ("d");  	break;  case 12:  	sb.Append ("w");  	break;  case 13:  	sb.Append ("W");  	break;  case 14:  	sb.Append ("c");  	break;  case 15:  	sb.Append ("z");  	break;  case 16:  	sb.Append ("x");  	break;  case 17:  	sb.Append ("v");  	break;  case 18:  	sb.Append ("g");  	break;  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,ReverseIME,The following statement contains a magic number: switch (a) {  case 0:  	sb.Append ("r");  	break;  case 1:  	sb.Append ("R");  	break;  case 2:  	sb.Append ("s");  	break;  case 3:  	sb.Append ("e");  	break;  case 4:  	sb.Append ("E");  	break;  case 5:  	sb.Append ("f");  	break;  case 6:  	sb.Append ("a");  	break;  case 7:  	sb.Append ("q");  	break;  case 8:  	sb.Append ("Q");  	break;  case 9:  	sb.Append ("t");  	break;  case 10:  	sb.Append ("T");  	break;  case 11:  	sb.Append ("d");  	break;  case 12:  	sb.Append ("w");  	break;  case 13:  	sb.Append ("W");  	break;  case 14:  	sb.Append ("c");  	break;  case 15:  	sb.Append ("z");  	break;  case 16:  	sb.Append ("x");  	break;  case 17:  	sb.Append ("v");  	break;  case 18:  	sb.Append ("g");  	break;  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,ReverseIME,The following statement contains a magic number: switch (a) {  case 0:  	sb.Append ("r");  	break;  case 1:  	sb.Append ("R");  	break;  case 2:  	sb.Append ("s");  	break;  case 3:  	sb.Append ("e");  	break;  case 4:  	sb.Append ("E");  	break;  case 5:  	sb.Append ("f");  	break;  case 6:  	sb.Append ("a");  	break;  case 7:  	sb.Append ("q");  	break;  case 8:  	sb.Append ("Q");  	break;  case 9:  	sb.Append ("t");  	break;  case 10:  	sb.Append ("T");  	break;  case 11:  	sb.Append ("d");  	break;  case 12:  	sb.Append ("w");  	break;  case 13:  	sb.Append ("W");  	break;  case 14:  	sb.Append ("c");  	break;  case 15:  	sb.Append ("z");  	break;  case 16:  	sb.Append ("x");  	break;  case 17:  	sb.Append ("v");  	break;  case 18:  	sb.Append ("g");  	break;  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,ReverseIME,The following statement contains a magic number: switch (b) {  case 0:  	sb.Append ("k");  	break;  case 1:  	sb.Append ("o");  	break;  case 2:  	sb.Append ("i");  	break;  case 3:  	sb.Append ("O");  	break;  case 4:  	sb.Append ("j");  	break;  case 5:  	sb.Append ("p");  	break;  case 6:  	sb.Append ("u");  	break;  case 7:  	sb.Append ("P");  	break;  case 8:  	sb.Append ("h");  	break;  case 9:  	sb.Append ("hk");  	break;  case 10:  	sb.Append ("ho");  	break;  case 11:  	sb.Append ("hl");  	break;  case 12:  	sb.Append ("y");  	break;  case 13:  	sb.Append ("n");  	break;  case 14:  	sb.Append ("nj");  	break;  case 15:  	sb.Append ("np");  	break;  case 16:  	sb.Append ("nl");  	break;  case 17:  	sb.Append ("b");  	break;  case 18:  	sb.Append ("m");  	break;  case 19:  	sb.Append ("ml");  	break;  case 20:  	sb.Append ("l");  	break;  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,ReverseIME,The following statement contains a magic number: switch (b) {  case 0:  	sb.Append ("k");  	break;  case 1:  	sb.Append ("o");  	break;  case 2:  	sb.Append ("i");  	break;  case 3:  	sb.Append ("O");  	break;  case 4:  	sb.Append ("j");  	break;  case 5:  	sb.Append ("p");  	break;  case 6:  	sb.Append ("u");  	break;  case 7:  	sb.Append ("P");  	break;  case 8:  	sb.Append ("h");  	break;  case 9:  	sb.Append ("hk");  	break;  case 10:  	sb.Append ("ho");  	break;  case 11:  	sb.Append ("hl");  	break;  case 12:  	sb.Append ("y");  	break;  case 13:  	sb.Append ("n");  	break;  case 14:  	sb.Append ("nj");  	break;  case 15:  	sb.Append ("np");  	break;  case 16:  	sb.Append ("nl");  	break;  case 17:  	sb.Append ("b");  	break;  case 18:  	sb.Append ("m");  	break;  case 19:  	sb.Append ("ml");  	break;  case 20:  	sb.Append ("l");  	break;  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,ReverseIME,The following statement contains a magic number: switch (b) {  case 0:  	sb.Append ("k");  	break;  case 1:  	sb.Append ("o");  	break;  case 2:  	sb.Append ("i");  	break;  case 3:  	sb.Append ("O");  	break;  case 4:  	sb.Append ("j");  	break;  case 5:  	sb.Append ("p");  	break;  case 6:  	sb.Append ("u");  	break;  case 7:  	sb.Append ("P");  	break;  case 8:  	sb.Append ("h");  	break;  case 9:  	sb.Append ("hk");  	break;  case 10:  	sb.Append ("ho");  	break;  case 11:  	sb.Append ("hl");  	break;  case 12:  	sb.Append ("y");  	break;  case 13:  	sb.Append ("n");  	break;  case 14:  	sb.Append ("nj");  	break;  case 15:  	sb.Append ("np");  	break;  case 16:  	sb.Append ("nl");  	break;  case 17:  	sb.Append ("b");  	break;  case 18:  	sb.Append ("m");  	break;  case 19:  	sb.Append ("ml");  	break;  case 20:  	sb.Append ("l");  	break;  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,ReverseIME,The following statement contains a magic number: switch (b) {  case 0:  	sb.Append ("k");  	break;  case 1:  	sb.Append ("o");  	break;  case 2:  	sb.Append ("i");  	break;  case 3:  	sb.Append ("O");  	break;  case 4:  	sb.Append ("j");  	break;  case 5:  	sb.Append ("p");  	break;  case 6:  	sb.Append ("u");  	break;  case 7:  	sb.Append ("P");  	break;  case 8:  	sb.Append ("h");  	break;  case 9:  	sb.Append ("hk");  	break;  case 10:  	sb.Append ("ho");  	break;  case 11:  	sb.Append ("hl");  	break;  case 12:  	sb.Append ("y");  	break;  case 13:  	sb.Append ("n");  	break;  case 14:  	sb.Append ("nj");  	break;  case 15:  	sb.Append ("np");  	break;  case 16:  	sb.Append ("nl");  	break;  case 17:  	sb.Append ("b");  	break;  case 18:  	sb.Append ("m");  	break;  case 19:  	sb.Append ("ml");  	break;  case 20:  	sb.Append ("l");  	break;  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,ReverseIME,The following statement contains a magic number: switch (b) {  case 0:  	sb.Append ("k");  	break;  case 1:  	sb.Append ("o");  	break;  case 2:  	sb.Append ("i");  	break;  case 3:  	sb.Append ("O");  	break;  case 4:  	sb.Append ("j");  	break;  case 5:  	sb.Append ("p");  	break;  case 6:  	sb.Append ("u");  	break;  case 7:  	sb.Append ("P");  	break;  case 8:  	sb.Append ("h");  	break;  case 9:  	sb.Append ("hk");  	break;  case 10:  	sb.Append ("ho");  	break;  case 11:  	sb.Append ("hl");  	break;  case 12:  	sb.Append ("y");  	break;  case 13:  	sb.Append ("n");  	break;  case 14:  	sb.Append ("nj");  	break;  case 15:  	sb.Append ("np");  	break;  case 16:  	sb.Append ("nl");  	break;  case 17:  	sb.Append ("b");  	break;  case 18:  	sb.Append ("m");  	break;  case 19:  	sb.Append ("ml");  	break;  case 20:  	sb.Append ("l");  	break;  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,ReverseIME,The following statement contains a magic number: switch (b) {  case 0:  	sb.Append ("k");  	break;  case 1:  	sb.Append ("o");  	break;  case 2:  	sb.Append ("i");  	break;  case 3:  	sb.Append ("O");  	break;  case 4:  	sb.Append ("j");  	break;  case 5:  	sb.Append ("p");  	break;  case 6:  	sb.Append ("u");  	break;  case 7:  	sb.Append ("P");  	break;  case 8:  	sb.Append ("h");  	break;  case 9:  	sb.Append ("hk");  	break;  case 10:  	sb.Append ("ho");  	break;  case 11:  	sb.Append ("hl");  	break;  case 12:  	sb.Append ("y");  	break;  case 13:  	sb.Append ("n");  	break;  case 14:  	sb.Append ("nj");  	break;  case 15:  	sb.Append ("np");  	break;  case 16:  	sb.Append ("nl");  	break;  case 17:  	sb.Append ("b");  	break;  case 18:  	sb.Append ("m");  	break;  case 19:  	sb.Append ("ml");  	break;  case 20:  	sb.Append ("l");  	break;  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,ReverseIME,The following statement contains a magic number: switch (b) {  case 0:  	sb.Append ("k");  	break;  case 1:  	sb.Append ("o");  	break;  case 2:  	sb.Append ("i");  	break;  case 3:  	sb.Append ("O");  	break;  case 4:  	sb.Append ("j");  	break;  case 5:  	sb.Append ("p");  	break;  case 6:  	sb.Append ("u");  	break;  case 7:  	sb.Append ("P");  	break;  case 8:  	sb.Append ("h");  	break;  case 9:  	sb.Append ("hk");  	break;  case 10:  	sb.Append ("ho");  	break;  case 11:  	sb.Append ("hl");  	break;  case 12:  	sb.Append ("y");  	break;  case 13:  	sb.Append ("n");  	break;  case 14:  	sb.Append ("nj");  	break;  case 15:  	sb.Append ("np");  	break;  case 16:  	sb.Append ("nl");  	break;  case 17:  	sb.Append ("b");  	break;  case 18:  	sb.Append ("m");  	break;  case 19:  	sb.Append ("ml");  	break;  case 20:  	sb.Append ("l");  	break;  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,ReverseIME,The following statement contains a magic number: switch (b) {  case 0:  	sb.Append ("k");  	break;  case 1:  	sb.Append ("o");  	break;  case 2:  	sb.Append ("i");  	break;  case 3:  	sb.Append ("O");  	break;  case 4:  	sb.Append ("j");  	break;  case 5:  	sb.Append ("p");  	break;  case 6:  	sb.Append ("u");  	break;  case 7:  	sb.Append ("P");  	break;  case 8:  	sb.Append ("h");  	break;  case 9:  	sb.Append ("hk");  	break;  case 10:  	sb.Append ("ho");  	break;  case 11:  	sb.Append ("hl");  	break;  case 12:  	sb.Append ("y");  	break;  case 13:  	sb.Append ("n");  	break;  case 14:  	sb.Append ("nj");  	break;  case 15:  	sb.Append ("np");  	break;  case 16:  	sb.Append ("nl");  	break;  case 17:  	sb.Append ("b");  	break;  case 18:  	sb.Append ("m");  	break;  case 19:  	sb.Append ("ml");  	break;  case 20:  	sb.Append ("l");  	break;  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,ReverseIME,The following statement contains a magic number: switch (b) {  case 0:  	sb.Append ("k");  	break;  case 1:  	sb.Append ("o");  	break;  case 2:  	sb.Append ("i");  	break;  case 3:  	sb.Append ("O");  	break;  case 4:  	sb.Append ("j");  	break;  case 5:  	sb.Append ("p");  	break;  case 6:  	sb.Append ("u");  	break;  case 7:  	sb.Append ("P");  	break;  case 8:  	sb.Append ("h");  	break;  case 9:  	sb.Append ("hk");  	break;  case 10:  	sb.Append ("ho");  	break;  case 11:  	sb.Append ("hl");  	break;  case 12:  	sb.Append ("y");  	break;  case 13:  	sb.Append ("n");  	break;  case 14:  	sb.Append ("nj");  	break;  case 15:  	sb.Append ("np");  	break;  case 16:  	sb.Append ("nl");  	break;  case 17:  	sb.Append ("b");  	break;  case 18:  	sb.Append ("m");  	break;  case 19:  	sb.Append ("ml");  	break;  case 20:  	sb.Append ("l");  	break;  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,ReverseIME,The following statement contains a magic number: switch (b) {  case 0:  	sb.Append ("k");  	break;  case 1:  	sb.Append ("o");  	break;  case 2:  	sb.Append ("i");  	break;  case 3:  	sb.Append ("O");  	break;  case 4:  	sb.Append ("j");  	break;  case 5:  	sb.Append ("p");  	break;  case 6:  	sb.Append ("u");  	break;  case 7:  	sb.Append ("P");  	break;  case 8:  	sb.Append ("h");  	break;  case 9:  	sb.Append ("hk");  	break;  case 10:  	sb.Append ("ho");  	break;  case 11:  	sb.Append ("hl");  	break;  case 12:  	sb.Append ("y");  	break;  case 13:  	sb.Append ("n");  	break;  case 14:  	sb.Append ("nj");  	break;  case 15:  	sb.Append ("np");  	break;  case 16:  	sb.Append ("nl");  	break;  case 17:  	sb.Append ("b");  	break;  case 18:  	sb.Append ("m");  	break;  case 19:  	sb.Append ("ml");  	break;  case 20:  	sb.Append ("l");  	break;  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,ReverseIME,The following statement contains a magic number: switch (b) {  case 0:  	sb.Append ("k");  	break;  case 1:  	sb.Append ("o");  	break;  case 2:  	sb.Append ("i");  	break;  case 3:  	sb.Append ("O");  	break;  case 4:  	sb.Append ("j");  	break;  case 5:  	sb.Append ("p");  	break;  case 6:  	sb.Append ("u");  	break;  case 7:  	sb.Append ("P");  	break;  case 8:  	sb.Append ("h");  	break;  case 9:  	sb.Append ("hk");  	break;  case 10:  	sb.Append ("ho");  	break;  case 11:  	sb.Append ("hl");  	break;  case 12:  	sb.Append ("y");  	break;  case 13:  	sb.Append ("n");  	break;  case 14:  	sb.Append ("nj");  	break;  case 15:  	sb.Append ("np");  	break;  case 16:  	sb.Append ("nl");  	break;  case 17:  	sb.Append ("b");  	break;  case 18:  	sb.Append ("m");  	break;  case 19:  	sb.Append ("ml");  	break;  case 20:  	sb.Append ("l");  	break;  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,ReverseIME,The following statement contains a magic number: switch (b) {  case 0:  	sb.Append ("k");  	break;  case 1:  	sb.Append ("o");  	break;  case 2:  	sb.Append ("i");  	break;  case 3:  	sb.Append ("O");  	break;  case 4:  	sb.Append ("j");  	break;  case 5:  	sb.Append ("p");  	break;  case 6:  	sb.Append ("u");  	break;  case 7:  	sb.Append ("P");  	break;  case 8:  	sb.Append ("h");  	break;  case 9:  	sb.Append ("hk");  	break;  case 10:  	sb.Append ("ho");  	break;  case 11:  	sb.Append ("hl");  	break;  case 12:  	sb.Append ("y");  	break;  case 13:  	sb.Append ("n");  	break;  case 14:  	sb.Append ("nj");  	break;  case 15:  	sb.Append ("np");  	break;  case 16:  	sb.Append ("nl");  	break;  case 17:  	sb.Append ("b");  	break;  case 18:  	sb.Append ("m");  	break;  case 19:  	sb.Append ("ml");  	break;  case 20:  	sb.Append ("l");  	break;  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,ReverseIME,The following statement contains a magic number: switch (b) {  case 0:  	sb.Append ("k");  	break;  case 1:  	sb.Append ("o");  	break;  case 2:  	sb.Append ("i");  	break;  case 3:  	sb.Append ("O");  	break;  case 4:  	sb.Append ("j");  	break;  case 5:  	sb.Append ("p");  	break;  case 6:  	sb.Append ("u");  	break;  case 7:  	sb.Append ("P");  	break;  case 8:  	sb.Append ("h");  	break;  case 9:  	sb.Append ("hk");  	break;  case 10:  	sb.Append ("ho");  	break;  case 11:  	sb.Append ("hl");  	break;  case 12:  	sb.Append ("y");  	break;  case 13:  	sb.Append ("n");  	break;  case 14:  	sb.Append ("nj");  	break;  case 15:  	sb.Append ("np");  	break;  case 16:  	sb.Append ("nl");  	break;  case 17:  	sb.Append ("b");  	break;  case 18:  	sb.Append ("m");  	break;  case 19:  	sb.Append ("ml");  	break;  case 20:  	sb.Append ("l");  	break;  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,ReverseIME,The following statement contains a magic number: switch (b) {  case 0:  	sb.Append ("k");  	break;  case 1:  	sb.Append ("o");  	break;  case 2:  	sb.Append ("i");  	break;  case 3:  	sb.Append ("O");  	break;  case 4:  	sb.Append ("j");  	break;  case 5:  	sb.Append ("p");  	break;  case 6:  	sb.Append ("u");  	break;  case 7:  	sb.Append ("P");  	break;  case 8:  	sb.Append ("h");  	break;  case 9:  	sb.Append ("hk");  	break;  case 10:  	sb.Append ("ho");  	break;  case 11:  	sb.Append ("hl");  	break;  case 12:  	sb.Append ("y");  	break;  case 13:  	sb.Append ("n");  	break;  case 14:  	sb.Append ("nj");  	break;  case 15:  	sb.Append ("np");  	break;  case 16:  	sb.Append ("nl");  	break;  case 17:  	sb.Append ("b");  	break;  case 18:  	sb.Append ("m");  	break;  case 19:  	sb.Append ("ml");  	break;  case 20:  	sb.Append ("l");  	break;  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,ReverseIME,The following statement contains a magic number: switch (b) {  case 0:  	sb.Append ("k");  	break;  case 1:  	sb.Append ("o");  	break;  case 2:  	sb.Append ("i");  	break;  case 3:  	sb.Append ("O");  	break;  case 4:  	sb.Append ("j");  	break;  case 5:  	sb.Append ("p");  	break;  case 6:  	sb.Append ("u");  	break;  case 7:  	sb.Append ("P");  	break;  case 8:  	sb.Append ("h");  	break;  case 9:  	sb.Append ("hk");  	break;  case 10:  	sb.Append ("ho");  	break;  case 11:  	sb.Append ("hl");  	break;  case 12:  	sb.Append ("y");  	break;  case 13:  	sb.Append ("n");  	break;  case 14:  	sb.Append ("nj");  	break;  case 15:  	sb.Append ("np");  	break;  case 16:  	sb.Append ("nl");  	break;  case 17:  	sb.Append ("b");  	break;  case 18:  	sb.Append ("m");  	break;  case 19:  	sb.Append ("ml");  	break;  case 20:  	sb.Append ("l");  	break;  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,ReverseIME,The following statement contains a magic number: switch (b) {  case 0:  	sb.Append ("k");  	break;  case 1:  	sb.Append ("o");  	break;  case 2:  	sb.Append ("i");  	break;  case 3:  	sb.Append ("O");  	break;  case 4:  	sb.Append ("j");  	break;  case 5:  	sb.Append ("p");  	break;  case 6:  	sb.Append ("u");  	break;  case 7:  	sb.Append ("P");  	break;  case 8:  	sb.Append ("h");  	break;  case 9:  	sb.Append ("hk");  	break;  case 10:  	sb.Append ("ho");  	break;  case 11:  	sb.Append ("hl");  	break;  case 12:  	sb.Append ("y");  	break;  case 13:  	sb.Append ("n");  	break;  case 14:  	sb.Append ("nj");  	break;  case 15:  	sb.Append ("np");  	break;  case 16:  	sb.Append ("nl");  	break;  case 17:  	sb.Append ("b");  	break;  case 18:  	sb.Append ("m");  	break;  case 19:  	sb.Append ("ml");  	break;  case 20:  	sb.Append ("l");  	break;  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,ReverseIME,The following statement contains a magic number: switch (b) {  case 0:  	sb.Append ("k");  	break;  case 1:  	sb.Append ("o");  	break;  case 2:  	sb.Append ("i");  	break;  case 3:  	sb.Append ("O");  	break;  case 4:  	sb.Append ("j");  	break;  case 5:  	sb.Append ("p");  	break;  case 6:  	sb.Append ("u");  	break;  case 7:  	sb.Append ("P");  	break;  case 8:  	sb.Append ("h");  	break;  case 9:  	sb.Append ("hk");  	break;  case 10:  	sb.Append ("ho");  	break;  case 11:  	sb.Append ("hl");  	break;  case 12:  	sb.Append ("y");  	break;  case 13:  	sb.Append ("n");  	break;  case 14:  	sb.Append ("nj");  	break;  case 15:  	sb.Append ("np");  	break;  case 16:  	sb.Append ("nl");  	break;  case 17:  	sb.Append ("b");  	break;  case 18:  	sb.Append ("m");  	break;  case 19:  	sb.Append ("ml");  	break;  case 20:  	sb.Append ("l");  	break;  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,ReverseIME,The following statement contains a magic number: switch (b) {  case 0:  	sb.Append ("k");  	break;  case 1:  	sb.Append ("o");  	break;  case 2:  	sb.Append ("i");  	break;  case 3:  	sb.Append ("O");  	break;  case 4:  	sb.Append ("j");  	break;  case 5:  	sb.Append ("p");  	break;  case 6:  	sb.Append ("u");  	break;  case 7:  	sb.Append ("P");  	break;  case 8:  	sb.Append ("h");  	break;  case 9:  	sb.Append ("hk");  	break;  case 10:  	sb.Append ("ho");  	break;  case 11:  	sb.Append ("hl");  	break;  case 12:  	sb.Append ("y");  	break;  case 13:  	sb.Append ("n");  	break;  case 14:  	sb.Append ("nj");  	break;  case 15:  	sb.Append ("np");  	break;  case 16:  	sb.Append ("nl");  	break;  case 17:  	sb.Append ("b");  	break;  case 18:  	sb.Append ("m");  	break;  case 19:  	sb.Append ("ml");  	break;  case 20:  	sb.Append ("l");  	break;  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,ReverseIME,The following statement contains a magic number: switch (b) {  case 0:  	sb.Append ("k");  	break;  case 1:  	sb.Append ("o");  	break;  case 2:  	sb.Append ("i");  	break;  case 3:  	sb.Append ("O");  	break;  case 4:  	sb.Append ("j");  	break;  case 5:  	sb.Append ("p");  	break;  case 6:  	sb.Append ("u");  	break;  case 7:  	sb.Append ("P");  	break;  case 8:  	sb.Append ("h");  	break;  case 9:  	sb.Append ("hk");  	break;  case 10:  	sb.Append ("ho");  	break;  case 11:  	sb.Append ("hl");  	break;  case 12:  	sb.Append ("y");  	break;  case 13:  	sb.Append ("n");  	break;  case 14:  	sb.Append ("nj");  	break;  case 15:  	sb.Append ("np");  	break;  case 16:  	sb.Append ("nl");  	break;  case 17:  	sb.Append ("b");  	break;  case 18:  	sb.Append ("m");  	break;  case 19:  	sb.Append ("ml");  	break;  case 20:  	sb.Append ("l");  	break;  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,ReverseIME,The following statement contains a magic number: switch (c) {  case 1:  	sb.Append ("r");  	break;  case 2:  	sb.Append ("R");  	break;  case 3:  	sb.Append ("rt");  	break;  case 4:  	sb.Append ("s");  	break;  case 5:  	sb.Append ("sw");  	break;  case 6:  	sb.Append ("sg");  	break;  case 7:  	sb.Append ("e");  	break;  case 8:  	sb.Append ("f");  	break;  case 9:  	sb.Append ("fr");  	break;  case 10:  	sb.Append ("fa");  	break;  case 11:  	sb.Append ("fq");  	break;  case 12:  	sb.Append ("ft");  	break;  case 13:  	sb.Append ("fx");  	break;  case 14:  	sb.Append ("fv");  	break;  case 15:  	sb.Append ("fg");  	break;  case 16:  	sb.Append ("a");  	break;  case 17:  	sb.Append ("q");  	break;  case 18:  	sb.Append ("qt");  	break;  case 19:  	sb.Append ("t");  	break;  case 20:  	sb.Append ("T");  	break;  case 21:  	sb.Append ("d");  	break;  case 22:  	sb.Append ("w");  	break;  case 23:  	sb.Append ("c");  	break;  case 24:  	sb.Append ("z");  	break;  case 25:  	sb.Append ("x");  	break;  case 26:  	sb.Append ("v");  	break;  case 27:  	sb.Append ("g");  	break;  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,ReverseIME,The following statement contains a magic number: switch (c) {  case 1:  	sb.Append ("r");  	break;  case 2:  	sb.Append ("R");  	break;  case 3:  	sb.Append ("rt");  	break;  case 4:  	sb.Append ("s");  	break;  case 5:  	sb.Append ("sw");  	break;  case 6:  	sb.Append ("sg");  	break;  case 7:  	sb.Append ("e");  	break;  case 8:  	sb.Append ("f");  	break;  case 9:  	sb.Append ("fr");  	break;  case 10:  	sb.Append ("fa");  	break;  case 11:  	sb.Append ("fq");  	break;  case 12:  	sb.Append ("ft");  	break;  case 13:  	sb.Append ("fx");  	break;  case 14:  	sb.Append ("fv");  	break;  case 15:  	sb.Append ("fg");  	break;  case 16:  	sb.Append ("a");  	break;  case 17:  	sb.Append ("q");  	break;  case 18:  	sb.Append ("qt");  	break;  case 19:  	sb.Append ("t");  	break;  case 20:  	sb.Append ("T");  	break;  case 21:  	sb.Append ("d");  	break;  case 22:  	sb.Append ("w");  	break;  case 23:  	sb.Append ("c");  	break;  case 24:  	sb.Append ("z");  	break;  case 25:  	sb.Append ("x");  	break;  case 26:  	sb.Append ("v");  	break;  case 27:  	sb.Append ("g");  	break;  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,ReverseIME,The following statement contains a magic number: switch (c) {  case 1:  	sb.Append ("r");  	break;  case 2:  	sb.Append ("R");  	break;  case 3:  	sb.Append ("rt");  	break;  case 4:  	sb.Append ("s");  	break;  case 5:  	sb.Append ("sw");  	break;  case 6:  	sb.Append ("sg");  	break;  case 7:  	sb.Append ("e");  	break;  case 8:  	sb.Append ("f");  	break;  case 9:  	sb.Append ("fr");  	break;  case 10:  	sb.Append ("fa");  	break;  case 11:  	sb.Append ("fq");  	break;  case 12:  	sb.Append ("ft");  	break;  case 13:  	sb.Append ("fx");  	break;  case 14:  	sb.Append ("fv");  	break;  case 15:  	sb.Append ("fg");  	break;  case 16:  	sb.Append ("a");  	break;  case 17:  	sb.Append ("q");  	break;  case 18:  	sb.Append ("qt");  	break;  case 19:  	sb.Append ("t");  	break;  case 20:  	sb.Append ("T");  	break;  case 21:  	sb.Append ("d");  	break;  case 22:  	sb.Append ("w");  	break;  case 23:  	sb.Append ("c");  	break;  case 24:  	sb.Append ("z");  	break;  case 25:  	sb.Append ("x");  	break;  case 26:  	sb.Append ("v");  	break;  case 27:  	sb.Append ("g");  	break;  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,ReverseIME,The following statement contains a magic number: switch (c) {  case 1:  	sb.Append ("r");  	break;  case 2:  	sb.Append ("R");  	break;  case 3:  	sb.Append ("rt");  	break;  case 4:  	sb.Append ("s");  	break;  case 5:  	sb.Append ("sw");  	break;  case 6:  	sb.Append ("sg");  	break;  case 7:  	sb.Append ("e");  	break;  case 8:  	sb.Append ("f");  	break;  case 9:  	sb.Append ("fr");  	break;  case 10:  	sb.Append ("fa");  	break;  case 11:  	sb.Append ("fq");  	break;  case 12:  	sb.Append ("ft");  	break;  case 13:  	sb.Append ("fx");  	break;  case 14:  	sb.Append ("fv");  	break;  case 15:  	sb.Append ("fg");  	break;  case 16:  	sb.Append ("a");  	break;  case 17:  	sb.Append ("q");  	break;  case 18:  	sb.Append ("qt");  	break;  case 19:  	sb.Append ("t");  	break;  case 20:  	sb.Append ("T");  	break;  case 21:  	sb.Append ("d");  	break;  case 22:  	sb.Append ("w");  	break;  case 23:  	sb.Append ("c");  	break;  case 24:  	sb.Append ("z");  	break;  case 25:  	sb.Append ("x");  	break;  case 26:  	sb.Append ("v");  	break;  case 27:  	sb.Append ("g");  	break;  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,ReverseIME,The following statement contains a magic number: switch (c) {  case 1:  	sb.Append ("r");  	break;  case 2:  	sb.Append ("R");  	break;  case 3:  	sb.Append ("rt");  	break;  case 4:  	sb.Append ("s");  	break;  case 5:  	sb.Append ("sw");  	break;  case 6:  	sb.Append ("sg");  	break;  case 7:  	sb.Append ("e");  	break;  case 8:  	sb.Append ("f");  	break;  case 9:  	sb.Append ("fr");  	break;  case 10:  	sb.Append ("fa");  	break;  case 11:  	sb.Append ("fq");  	break;  case 12:  	sb.Append ("ft");  	break;  case 13:  	sb.Append ("fx");  	break;  case 14:  	sb.Append ("fv");  	break;  case 15:  	sb.Append ("fg");  	break;  case 16:  	sb.Append ("a");  	break;  case 17:  	sb.Append ("q");  	break;  case 18:  	sb.Append ("qt");  	break;  case 19:  	sb.Append ("t");  	break;  case 20:  	sb.Append ("T");  	break;  case 21:  	sb.Append ("d");  	break;  case 22:  	sb.Append ("w");  	break;  case 23:  	sb.Append ("c");  	break;  case 24:  	sb.Append ("z");  	break;  case 25:  	sb.Append ("x");  	break;  case 26:  	sb.Append ("v");  	break;  case 27:  	sb.Append ("g");  	break;  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,ReverseIME,The following statement contains a magic number: switch (c) {  case 1:  	sb.Append ("r");  	break;  case 2:  	sb.Append ("R");  	break;  case 3:  	sb.Append ("rt");  	break;  case 4:  	sb.Append ("s");  	break;  case 5:  	sb.Append ("sw");  	break;  case 6:  	sb.Append ("sg");  	break;  case 7:  	sb.Append ("e");  	break;  case 8:  	sb.Append ("f");  	break;  case 9:  	sb.Append ("fr");  	break;  case 10:  	sb.Append ("fa");  	break;  case 11:  	sb.Append ("fq");  	break;  case 12:  	sb.Append ("ft");  	break;  case 13:  	sb.Append ("fx");  	break;  case 14:  	sb.Append ("fv");  	break;  case 15:  	sb.Append ("fg");  	break;  case 16:  	sb.Append ("a");  	break;  case 17:  	sb.Append ("q");  	break;  case 18:  	sb.Append ("qt");  	break;  case 19:  	sb.Append ("t");  	break;  case 20:  	sb.Append ("T");  	break;  case 21:  	sb.Append ("d");  	break;  case 22:  	sb.Append ("w");  	break;  case 23:  	sb.Append ("c");  	break;  case 24:  	sb.Append ("z");  	break;  case 25:  	sb.Append ("x");  	break;  case 26:  	sb.Append ("v");  	break;  case 27:  	sb.Append ("g");  	break;  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,ReverseIME,The following statement contains a magic number: switch (c) {  case 1:  	sb.Append ("r");  	break;  case 2:  	sb.Append ("R");  	break;  case 3:  	sb.Append ("rt");  	break;  case 4:  	sb.Append ("s");  	break;  case 5:  	sb.Append ("sw");  	break;  case 6:  	sb.Append ("sg");  	break;  case 7:  	sb.Append ("e");  	break;  case 8:  	sb.Append ("f");  	break;  case 9:  	sb.Append ("fr");  	break;  case 10:  	sb.Append ("fa");  	break;  case 11:  	sb.Append ("fq");  	break;  case 12:  	sb.Append ("ft");  	break;  case 13:  	sb.Append ("fx");  	break;  case 14:  	sb.Append ("fv");  	break;  case 15:  	sb.Append ("fg");  	break;  case 16:  	sb.Append ("a");  	break;  case 17:  	sb.Append ("q");  	break;  case 18:  	sb.Append ("qt");  	break;  case 19:  	sb.Append ("t");  	break;  case 20:  	sb.Append ("T");  	break;  case 21:  	sb.Append ("d");  	break;  case 22:  	sb.Append ("w");  	break;  case 23:  	sb.Append ("c");  	break;  case 24:  	sb.Append ("z");  	break;  case 25:  	sb.Append ("x");  	break;  case 26:  	sb.Append ("v");  	break;  case 27:  	sb.Append ("g");  	break;  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,ReverseIME,The following statement contains a magic number: switch (c) {  case 1:  	sb.Append ("r");  	break;  case 2:  	sb.Append ("R");  	break;  case 3:  	sb.Append ("rt");  	break;  case 4:  	sb.Append ("s");  	break;  case 5:  	sb.Append ("sw");  	break;  case 6:  	sb.Append ("sg");  	break;  case 7:  	sb.Append ("e");  	break;  case 8:  	sb.Append ("f");  	break;  case 9:  	sb.Append ("fr");  	break;  case 10:  	sb.Append ("fa");  	break;  case 11:  	sb.Append ("fq");  	break;  case 12:  	sb.Append ("ft");  	break;  case 13:  	sb.Append ("fx");  	break;  case 14:  	sb.Append ("fv");  	break;  case 15:  	sb.Append ("fg");  	break;  case 16:  	sb.Append ("a");  	break;  case 17:  	sb.Append ("q");  	break;  case 18:  	sb.Append ("qt");  	break;  case 19:  	sb.Append ("t");  	break;  case 20:  	sb.Append ("T");  	break;  case 21:  	sb.Append ("d");  	break;  case 22:  	sb.Append ("w");  	break;  case 23:  	sb.Append ("c");  	break;  case 24:  	sb.Append ("z");  	break;  case 25:  	sb.Append ("x");  	break;  case 26:  	sb.Append ("v");  	break;  case 27:  	sb.Append ("g");  	break;  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,ReverseIME,The following statement contains a magic number: switch (c) {  case 1:  	sb.Append ("r");  	break;  case 2:  	sb.Append ("R");  	break;  case 3:  	sb.Append ("rt");  	break;  case 4:  	sb.Append ("s");  	break;  case 5:  	sb.Append ("sw");  	break;  case 6:  	sb.Append ("sg");  	break;  case 7:  	sb.Append ("e");  	break;  case 8:  	sb.Append ("f");  	break;  case 9:  	sb.Append ("fr");  	break;  case 10:  	sb.Append ("fa");  	break;  case 11:  	sb.Append ("fq");  	break;  case 12:  	sb.Append ("ft");  	break;  case 13:  	sb.Append ("fx");  	break;  case 14:  	sb.Append ("fv");  	break;  case 15:  	sb.Append ("fg");  	break;  case 16:  	sb.Append ("a");  	break;  case 17:  	sb.Append ("q");  	break;  case 18:  	sb.Append ("qt");  	break;  case 19:  	sb.Append ("t");  	break;  case 20:  	sb.Append ("T");  	break;  case 21:  	sb.Append ("d");  	break;  case 22:  	sb.Append ("w");  	break;  case 23:  	sb.Append ("c");  	break;  case 24:  	sb.Append ("z");  	break;  case 25:  	sb.Append ("x");  	break;  case 26:  	sb.Append ("v");  	break;  case 27:  	sb.Append ("g");  	break;  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,ReverseIME,The following statement contains a magic number: switch (c) {  case 1:  	sb.Append ("r");  	break;  case 2:  	sb.Append ("R");  	break;  case 3:  	sb.Append ("rt");  	break;  case 4:  	sb.Append ("s");  	break;  case 5:  	sb.Append ("sw");  	break;  case 6:  	sb.Append ("sg");  	break;  case 7:  	sb.Append ("e");  	break;  case 8:  	sb.Append ("f");  	break;  case 9:  	sb.Append ("fr");  	break;  case 10:  	sb.Append ("fa");  	break;  case 11:  	sb.Append ("fq");  	break;  case 12:  	sb.Append ("ft");  	break;  case 13:  	sb.Append ("fx");  	break;  case 14:  	sb.Append ("fv");  	break;  case 15:  	sb.Append ("fg");  	break;  case 16:  	sb.Append ("a");  	break;  case 17:  	sb.Append ("q");  	break;  case 18:  	sb.Append ("qt");  	break;  case 19:  	sb.Append ("t");  	break;  case 20:  	sb.Append ("T");  	break;  case 21:  	sb.Append ("d");  	break;  case 22:  	sb.Append ("w");  	break;  case 23:  	sb.Append ("c");  	break;  case 24:  	sb.Append ("z");  	break;  case 25:  	sb.Append ("x");  	break;  case 26:  	sb.Append ("v");  	break;  case 27:  	sb.Append ("g");  	break;  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,ReverseIME,The following statement contains a magic number: switch (c) {  case 1:  	sb.Append ("r");  	break;  case 2:  	sb.Append ("R");  	break;  case 3:  	sb.Append ("rt");  	break;  case 4:  	sb.Append ("s");  	break;  case 5:  	sb.Append ("sw");  	break;  case 6:  	sb.Append ("sg");  	break;  case 7:  	sb.Append ("e");  	break;  case 8:  	sb.Append ("f");  	break;  case 9:  	sb.Append ("fr");  	break;  case 10:  	sb.Append ("fa");  	break;  case 11:  	sb.Append ("fq");  	break;  case 12:  	sb.Append ("ft");  	break;  case 13:  	sb.Append ("fx");  	break;  case 14:  	sb.Append ("fv");  	break;  case 15:  	sb.Append ("fg");  	break;  case 16:  	sb.Append ("a");  	break;  case 17:  	sb.Append ("q");  	break;  case 18:  	sb.Append ("qt");  	break;  case 19:  	sb.Append ("t");  	break;  case 20:  	sb.Append ("T");  	break;  case 21:  	sb.Append ("d");  	break;  case 22:  	sb.Append ("w");  	break;  case 23:  	sb.Append ("c");  	break;  case 24:  	sb.Append ("z");  	break;  case 25:  	sb.Append ("x");  	break;  case 26:  	sb.Append ("v");  	break;  case 27:  	sb.Append ("g");  	break;  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,ReverseIME,The following statement contains a magic number: switch (c) {  case 1:  	sb.Append ("r");  	break;  case 2:  	sb.Append ("R");  	break;  case 3:  	sb.Append ("rt");  	break;  case 4:  	sb.Append ("s");  	break;  case 5:  	sb.Append ("sw");  	break;  case 6:  	sb.Append ("sg");  	break;  case 7:  	sb.Append ("e");  	break;  case 8:  	sb.Append ("f");  	break;  case 9:  	sb.Append ("fr");  	break;  case 10:  	sb.Append ("fa");  	break;  case 11:  	sb.Append ("fq");  	break;  case 12:  	sb.Append ("ft");  	break;  case 13:  	sb.Append ("fx");  	break;  case 14:  	sb.Append ("fv");  	break;  case 15:  	sb.Append ("fg");  	break;  case 16:  	sb.Append ("a");  	break;  case 17:  	sb.Append ("q");  	break;  case 18:  	sb.Append ("qt");  	break;  case 19:  	sb.Append ("t");  	break;  case 20:  	sb.Append ("T");  	break;  case 21:  	sb.Append ("d");  	break;  case 22:  	sb.Append ("w");  	break;  case 23:  	sb.Append ("c");  	break;  case 24:  	sb.Append ("z");  	break;  case 25:  	sb.Append ("x");  	break;  case 26:  	sb.Append ("v");  	break;  case 27:  	sb.Append ("g");  	break;  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,ReverseIME,The following statement contains a magic number: switch (c) {  case 1:  	sb.Append ("r");  	break;  case 2:  	sb.Append ("R");  	break;  case 3:  	sb.Append ("rt");  	break;  case 4:  	sb.Append ("s");  	break;  case 5:  	sb.Append ("sw");  	break;  case 6:  	sb.Append ("sg");  	break;  case 7:  	sb.Append ("e");  	break;  case 8:  	sb.Append ("f");  	break;  case 9:  	sb.Append ("fr");  	break;  case 10:  	sb.Append ("fa");  	break;  case 11:  	sb.Append ("fq");  	break;  case 12:  	sb.Append ("ft");  	break;  case 13:  	sb.Append ("fx");  	break;  case 14:  	sb.Append ("fv");  	break;  case 15:  	sb.Append ("fg");  	break;  case 16:  	sb.Append ("a");  	break;  case 17:  	sb.Append ("q");  	break;  case 18:  	sb.Append ("qt");  	break;  case 19:  	sb.Append ("t");  	break;  case 20:  	sb.Append ("T");  	break;  case 21:  	sb.Append ("d");  	break;  case 22:  	sb.Append ("w");  	break;  case 23:  	sb.Append ("c");  	break;  case 24:  	sb.Append ("z");  	break;  case 25:  	sb.Append ("x");  	break;  case 26:  	sb.Append ("v");  	break;  case 27:  	sb.Append ("g");  	break;  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,ReverseIME,The following statement contains a magic number: switch (c) {  case 1:  	sb.Append ("r");  	break;  case 2:  	sb.Append ("R");  	break;  case 3:  	sb.Append ("rt");  	break;  case 4:  	sb.Append ("s");  	break;  case 5:  	sb.Append ("sw");  	break;  case 6:  	sb.Append ("sg");  	break;  case 7:  	sb.Append ("e");  	break;  case 8:  	sb.Append ("f");  	break;  case 9:  	sb.Append ("fr");  	break;  case 10:  	sb.Append ("fa");  	break;  case 11:  	sb.Append ("fq");  	break;  case 12:  	sb.Append ("ft");  	break;  case 13:  	sb.Append ("fx");  	break;  case 14:  	sb.Append ("fv");  	break;  case 15:  	sb.Append ("fg");  	break;  case 16:  	sb.Append ("a");  	break;  case 17:  	sb.Append ("q");  	break;  case 18:  	sb.Append ("qt");  	break;  case 19:  	sb.Append ("t");  	break;  case 20:  	sb.Append ("T");  	break;  case 21:  	sb.Append ("d");  	break;  case 22:  	sb.Append ("w");  	break;  case 23:  	sb.Append ("c");  	break;  case 24:  	sb.Append ("z");  	break;  case 25:  	sb.Append ("x");  	break;  case 26:  	sb.Append ("v");  	break;  case 27:  	sb.Append ("g");  	break;  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,ReverseIME,The following statement contains a magic number: switch (c) {  case 1:  	sb.Append ("r");  	break;  case 2:  	sb.Append ("R");  	break;  case 3:  	sb.Append ("rt");  	break;  case 4:  	sb.Append ("s");  	break;  case 5:  	sb.Append ("sw");  	break;  case 6:  	sb.Append ("sg");  	break;  case 7:  	sb.Append ("e");  	break;  case 8:  	sb.Append ("f");  	break;  case 9:  	sb.Append ("fr");  	break;  case 10:  	sb.Append ("fa");  	break;  case 11:  	sb.Append ("fq");  	break;  case 12:  	sb.Append ("ft");  	break;  case 13:  	sb.Append ("fx");  	break;  case 14:  	sb.Append ("fv");  	break;  case 15:  	sb.Append ("fg");  	break;  case 16:  	sb.Append ("a");  	break;  case 17:  	sb.Append ("q");  	break;  case 18:  	sb.Append ("qt");  	break;  case 19:  	sb.Append ("t");  	break;  case 20:  	sb.Append ("T");  	break;  case 21:  	sb.Append ("d");  	break;  case 22:  	sb.Append ("w");  	break;  case 23:  	sb.Append ("c");  	break;  case 24:  	sb.Append ("z");  	break;  case 25:  	sb.Append ("x");  	break;  case 26:  	sb.Append ("v");  	break;  case 27:  	sb.Append ("g");  	break;  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,ReverseIME,The following statement contains a magic number: switch (c) {  case 1:  	sb.Append ("r");  	break;  case 2:  	sb.Append ("R");  	break;  case 3:  	sb.Append ("rt");  	break;  case 4:  	sb.Append ("s");  	break;  case 5:  	sb.Append ("sw");  	break;  case 6:  	sb.Append ("sg");  	break;  case 7:  	sb.Append ("e");  	break;  case 8:  	sb.Append ("f");  	break;  case 9:  	sb.Append ("fr");  	break;  case 10:  	sb.Append ("fa");  	break;  case 11:  	sb.Append ("fq");  	break;  case 12:  	sb.Append ("ft");  	break;  case 13:  	sb.Append ("fx");  	break;  case 14:  	sb.Append ("fv");  	break;  case 15:  	sb.Append ("fg");  	break;  case 16:  	sb.Append ("a");  	break;  case 17:  	sb.Append ("q");  	break;  case 18:  	sb.Append ("qt");  	break;  case 19:  	sb.Append ("t");  	break;  case 20:  	sb.Append ("T");  	break;  case 21:  	sb.Append ("d");  	break;  case 22:  	sb.Append ("w");  	break;  case 23:  	sb.Append ("c");  	break;  case 24:  	sb.Append ("z");  	break;  case 25:  	sb.Append ("x");  	break;  case 26:  	sb.Append ("v");  	break;  case 27:  	sb.Append ("g");  	break;  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,ReverseIME,The following statement contains a magic number: switch (c) {  case 1:  	sb.Append ("r");  	break;  case 2:  	sb.Append ("R");  	break;  case 3:  	sb.Append ("rt");  	break;  case 4:  	sb.Append ("s");  	break;  case 5:  	sb.Append ("sw");  	break;  case 6:  	sb.Append ("sg");  	break;  case 7:  	sb.Append ("e");  	break;  case 8:  	sb.Append ("f");  	break;  case 9:  	sb.Append ("fr");  	break;  case 10:  	sb.Append ("fa");  	break;  case 11:  	sb.Append ("fq");  	break;  case 12:  	sb.Append ("ft");  	break;  case 13:  	sb.Append ("fx");  	break;  case 14:  	sb.Append ("fv");  	break;  case 15:  	sb.Append ("fg");  	break;  case 16:  	sb.Append ("a");  	break;  case 17:  	sb.Append ("q");  	break;  case 18:  	sb.Append ("qt");  	break;  case 19:  	sb.Append ("t");  	break;  case 20:  	sb.Append ("T");  	break;  case 21:  	sb.Append ("d");  	break;  case 22:  	sb.Append ("w");  	break;  case 23:  	sb.Append ("c");  	break;  case 24:  	sb.Append ("z");  	break;  case 25:  	sb.Append ("x");  	break;  case 26:  	sb.Append ("v");  	break;  case 27:  	sb.Append ("g");  	break;  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,ReverseIME,The following statement contains a magic number: switch (c) {  case 1:  	sb.Append ("r");  	break;  case 2:  	sb.Append ("R");  	break;  case 3:  	sb.Append ("rt");  	break;  case 4:  	sb.Append ("s");  	break;  case 5:  	sb.Append ("sw");  	break;  case 6:  	sb.Append ("sg");  	break;  case 7:  	sb.Append ("e");  	break;  case 8:  	sb.Append ("f");  	break;  case 9:  	sb.Append ("fr");  	break;  case 10:  	sb.Append ("fa");  	break;  case 11:  	sb.Append ("fq");  	break;  case 12:  	sb.Append ("ft");  	break;  case 13:  	sb.Append ("fx");  	break;  case 14:  	sb.Append ("fv");  	break;  case 15:  	sb.Append ("fg");  	break;  case 16:  	sb.Append ("a");  	break;  case 17:  	sb.Append ("q");  	break;  case 18:  	sb.Append ("qt");  	break;  case 19:  	sb.Append ("t");  	break;  case 20:  	sb.Append ("T");  	break;  case 21:  	sb.Append ("d");  	break;  case 22:  	sb.Append ("w");  	break;  case 23:  	sb.Append ("c");  	break;  case 24:  	sb.Append ("z");  	break;  case 25:  	sb.Append ("x");  	break;  case 26:  	sb.Append ("v");  	break;  case 27:  	sb.Append ("g");  	break;  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,ReverseIME,The following statement contains a magic number: switch (c) {  case 1:  	sb.Append ("r");  	break;  case 2:  	sb.Append ("R");  	break;  case 3:  	sb.Append ("rt");  	break;  case 4:  	sb.Append ("s");  	break;  case 5:  	sb.Append ("sw");  	break;  case 6:  	sb.Append ("sg");  	break;  case 7:  	sb.Append ("e");  	break;  case 8:  	sb.Append ("f");  	break;  case 9:  	sb.Append ("fr");  	break;  case 10:  	sb.Append ("fa");  	break;  case 11:  	sb.Append ("fq");  	break;  case 12:  	sb.Append ("ft");  	break;  case 13:  	sb.Append ("fx");  	break;  case 14:  	sb.Append ("fv");  	break;  case 15:  	sb.Append ("fg");  	break;  case 16:  	sb.Append ("a");  	break;  case 17:  	sb.Append ("q");  	break;  case 18:  	sb.Append ("qt");  	break;  case 19:  	sb.Append ("t");  	break;  case 20:  	sb.Append ("T");  	break;  case 21:  	sb.Append ("d");  	break;  case 22:  	sb.Append ("w");  	break;  case 23:  	sb.Append ("c");  	break;  case 24:  	sb.Append ("z");  	break;  case 25:  	sb.Append ("x");  	break;  case 26:  	sb.Append ("v");  	break;  case 27:  	sb.Append ("g");  	break;  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,ReverseIME,The following statement contains a magic number: switch (c) {  case 1:  	sb.Append ("r");  	break;  case 2:  	sb.Append ("R");  	break;  case 3:  	sb.Append ("rt");  	break;  case 4:  	sb.Append ("s");  	break;  case 5:  	sb.Append ("sw");  	break;  case 6:  	sb.Append ("sg");  	break;  case 7:  	sb.Append ("e");  	break;  case 8:  	sb.Append ("f");  	break;  case 9:  	sb.Append ("fr");  	break;  case 10:  	sb.Append ("fa");  	break;  case 11:  	sb.Append ("fq");  	break;  case 12:  	sb.Append ("ft");  	break;  case 13:  	sb.Append ("fx");  	break;  case 14:  	sb.Append ("fv");  	break;  case 15:  	sb.Append ("fg");  	break;  case 16:  	sb.Append ("a");  	break;  case 17:  	sb.Append ("q");  	break;  case 18:  	sb.Append ("qt");  	break;  case 19:  	sb.Append ("t");  	break;  case 20:  	sb.Append ("T");  	break;  case 21:  	sb.Append ("d");  	break;  case 22:  	sb.Append ("w");  	break;  case 23:  	sb.Append ("c");  	break;  case 24:  	sb.Append ("z");  	break;  case 25:  	sb.Append ("x");  	break;  case 26:  	sb.Append ("v");  	break;  case 27:  	sb.Append ("g");  	break;  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,ReverseIME,The following statement contains a magic number: switch (c) {  case 1:  	sb.Append ("r");  	break;  case 2:  	sb.Append ("R");  	break;  case 3:  	sb.Append ("rt");  	break;  case 4:  	sb.Append ("s");  	break;  case 5:  	sb.Append ("sw");  	break;  case 6:  	sb.Append ("sg");  	break;  case 7:  	sb.Append ("e");  	break;  case 8:  	sb.Append ("f");  	break;  case 9:  	sb.Append ("fr");  	break;  case 10:  	sb.Append ("fa");  	break;  case 11:  	sb.Append ("fq");  	break;  case 12:  	sb.Append ("ft");  	break;  case 13:  	sb.Append ("fx");  	break;  case 14:  	sb.Append ("fv");  	break;  case 15:  	sb.Append ("fg");  	break;  case 16:  	sb.Append ("a");  	break;  case 17:  	sb.Append ("q");  	break;  case 18:  	sb.Append ("qt");  	break;  case 19:  	sb.Append ("t");  	break;  case 20:  	sb.Append ("T");  	break;  case 21:  	sb.Append ("d");  	break;  case 22:  	sb.Append ("w");  	break;  case 23:  	sb.Append ("c");  	break;  case 24:  	sb.Append ("z");  	break;  case 25:  	sb.Append ("x");  	break;  case 26:  	sb.Append ("v");  	break;  case 27:  	sb.Append ("g");  	break;  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,ReverseIME,The following statement contains a magic number: switch (c) {  case 1:  	sb.Append ("r");  	break;  case 2:  	sb.Append ("R");  	break;  case 3:  	sb.Append ("rt");  	break;  case 4:  	sb.Append ("s");  	break;  case 5:  	sb.Append ("sw");  	break;  case 6:  	sb.Append ("sg");  	break;  case 7:  	sb.Append ("e");  	break;  case 8:  	sb.Append ("f");  	break;  case 9:  	sb.Append ("fr");  	break;  case 10:  	sb.Append ("fa");  	break;  case 11:  	sb.Append ("fq");  	break;  case 12:  	sb.Append ("ft");  	break;  case 13:  	sb.Append ("fx");  	break;  case 14:  	sb.Append ("fv");  	break;  case 15:  	sb.Append ("fg");  	break;  case 16:  	sb.Append ("a");  	break;  case 17:  	sb.Append ("q");  	break;  case 18:  	sb.Append ("qt");  	break;  case 19:  	sb.Append ("t");  	break;  case 20:  	sb.Append ("T");  	break;  case 21:  	sb.Append ("d");  	break;  case 22:  	sb.Append ("w");  	break;  case 23:  	sb.Append ("c");  	break;  case 24:  	sb.Append ("z");  	break;  case 25:  	sb.Append ("x");  	break;  case 26:  	sb.Append ("v");  	break;  case 27:  	sb.Append ("g");  	break;  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,ReverseIME,The following statement contains a magic number: switch (c) {  case 1:  	sb.Append ("r");  	break;  case 2:  	sb.Append ("R");  	break;  case 3:  	sb.Append ("rt");  	break;  case 4:  	sb.Append ("s");  	break;  case 5:  	sb.Append ("sw");  	break;  case 6:  	sb.Append ("sg");  	break;  case 7:  	sb.Append ("e");  	break;  case 8:  	sb.Append ("f");  	break;  case 9:  	sb.Append ("fr");  	break;  case 10:  	sb.Append ("fa");  	break;  case 11:  	sb.Append ("fq");  	break;  case 12:  	sb.Append ("ft");  	break;  case 13:  	sb.Append ("fx");  	break;  case 14:  	sb.Append ("fv");  	break;  case 15:  	sb.Append ("fg");  	break;  case 16:  	sb.Append ("a");  	break;  case 17:  	sb.Append ("q");  	break;  case 18:  	sb.Append ("qt");  	break;  case 19:  	sb.Append ("t");  	break;  case 20:  	sb.Append ("T");  	break;  case 21:  	sb.Append ("d");  	break;  case 22:  	sb.Append ("w");  	break;  case 23:  	sb.Append ("c");  	break;  case 24:  	sb.Append ("z");  	break;  case 25:  	sb.Append ("x");  	break;  case 26:  	sb.Append ("v");  	break;  case 27:  	sb.Append ("g");  	break;  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,ReverseIME,The following statement contains a magic number: switch (c) {  case 1:  	sb.Append ("r");  	break;  case 2:  	sb.Append ("R");  	break;  case 3:  	sb.Append ("rt");  	break;  case 4:  	sb.Append ("s");  	break;  case 5:  	sb.Append ("sw");  	break;  case 6:  	sb.Append ("sg");  	break;  case 7:  	sb.Append ("e");  	break;  case 8:  	sb.Append ("f");  	break;  case 9:  	sb.Append ("fr");  	break;  case 10:  	sb.Append ("fa");  	break;  case 11:  	sb.Append ("fq");  	break;  case 12:  	sb.Append ("ft");  	break;  case 13:  	sb.Append ("fx");  	break;  case 14:  	sb.Append ("fv");  	break;  case 15:  	sb.Append ("fg");  	break;  case 16:  	sb.Append ("a");  	break;  case 17:  	sb.Append ("q");  	break;  case 18:  	sb.Append ("qt");  	break;  case 19:  	sb.Append ("t");  	break;  case 20:  	sb.Append ("T");  	break;  case 21:  	sb.Append ("d");  	break;  case 22:  	sb.Append ("w");  	break;  case 23:  	sb.Append ("c");  	break;  case 24:  	sb.Append ("z");  	break;  case 25:  	sb.Append ("x");  	break;  case 26:  	sb.Append ("v");  	break;  case 27:  	sb.Append ("g");  	break;  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,ReverseIME,The following statement contains a magic number: switch (c) {  case 1:  	sb.Append ("r");  	break;  case 2:  	sb.Append ("R");  	break;  case 3:  	sb.Append ("rt");  	break;  case 4:  	sb.Append ("s");  	break;  case 5:  	sb.Append ("sw");  	break;  case 6:  	sb.Append ("sg");  	break;  case 7:  	sb.Append ("e");  	break;  case 8:  	sb.Append ("f");  	break;  case 9:  	sb.Append ("fr");  	break;  case 10:  	sb.Append ("fa");  	break;  case 11:  	sb.Append ("fq");  	break;  case 12:  	sb.Append ("ft");  	break;  case 13:  	sb.Append ("fx");  	break;  case 14:  	sb.Append ("fv");  	break;  case 15:  	sb.Append ("fg");  	break;  case 16:  	sb.Append ("a");  	break;  case 17:  	sb.Append ("q");  	break;  case 18:  	sb.Append ("qt");  	break;  case 19:  	sb.Append ("t");  	break;  case 20:  	sb.Append ("T");  	break;  case 21:  	sb.Append ("d");  	break;  case 22:  	sb.Append ("w");  	break;  case 23:  	sb.Append ("c");  	break;  case 24:  	sb.Append ("z");  	break;  case 25:  	sb.Append ("x");  	break;  case 26:  	sb.Append ("v");  	break;  case 27:  	sb.Append ("g");  	break;  }  
Magic Number,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,ReverseIME,The following statement contains a magic number: switch (c) {  case 1:  	sb.Append ("r");  	break;  case 2:  	sb.Append ("R");  	break;  case 3:  	sb.Append ("rt");  	break;  case 4:  	sb.Append ("s");  	break;  case 5:  	sb.Append ("sw");  	break;  case 6:  	sb.Append ("sg");  	break;  case 7:  	sb.Append ("e");  	break;  case 8:  	sb.Append ("f");  	break;  case 9:  	sb.Append ("fr");  	break;  case 10:  	sb.Append ("fa");  	break;  case 11:  	sb.Append ("fq");  	break;  case 12:  	sb.Append ("ft");  	break;  case 13:  	sb.Append ("fx");  	break;  case 14:  	sb.Append ("fv");  	break;  case 15:  	sb.Append ("fg");  	break;  case 16:  	sb.Append ("a");  	break;  case 17:  	sb.Append ("q");  	break;  case 18:  	sb.Append ("qt");  	break;  case 19:  	sb.Append ("t");  	break;  case 20:  	sb.Append ("T");  	break;  case 21:  	sb.Append ("d");  	break;  case 22:  	sb.Append ("w");  	break;  case 23:  	sb.Append ("c");  	break;  case 24:  	sb.Append ("z");  	break;  case 25:  	sb.Append ("x");  	break;  case 26:  	sb.Append ("v");  	break;  case 27:  	sb.Append ("g");  	break;  }  
Missing Default,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,ReverseIME,The following switch statement is missing a default case: switch (a) {  case 0:  	sb.Append ("r");  	break;  case 1:  	sb.Append ("R");  	break;  case 2:  	sb.Append ("s");  	break;  case 3:  	sb.Append ("e");  	break;  case 4:  	sb.Append ("E");  	break;  case 5:  	sb.Append ("f");  	break;  case 6:  	sb.Append ("a");  	break;  case 7:  	sb.Append ("q");  	break;  case 8:  	sb.Append ("Q");  	break;  case 9:  	sb.Append ("t");  	break;  case 10:  	sb.Append ("T");  	break;  case 11:  	sb.Append ("d");  	break;  case 12:  	sb.Append ("w");  	break;  case 13:  	sb.Append ("W");  	break;  case 14:  	sb.Append ("c");  	break;  case 15:  	sb.Append ("z");  	break;  case 16:  	sb.Append ("x");  	break;  case 17:  	sb.Append ("v");  	break;  case 18:  	sb.Append ("g");  	break;  }  
Missing Default,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,ReverseIME,The following switch statement is missing a default case: switch (b) {  case 0:  	sb.Append ("k");  	break;  case 1:  	sb.Append ("o");  	break;  case 2:  	sb.Append ("i");  	break;  case 3:  	sb.Append ("O");  	break;  case 4:  	sb.Append ("j");  	break;  case 5:  	sb.Append ("p");  	break;  case 6:  	sb.Append ("u");  	break;  case 7:  	sb.Append ("P");  	break;  case 8:  	sb.Append ("h");  	break;  case 9:  	sb.Append ("hk");  	break;  case 10:  	sb.Append ("ho");  	break;  case 11:  	sb.Append ("hl");  	break;  case 12:  	sb.Append ("y");  	break;  case 13:  	sb.Append ("n");  	break;  case 14:  	sb.Append ("nj");  	break;  case 15:  	sb.Append ("np");  	break;  case 16:  	sb.Append ("nl");  	break;  case 17:  	sb.Append ("b");  	break;  case 18:  	sb.Append ("m");  	break;  case 19:  	sb.Append ("ml");  	break;  case 20:  	sb.Append ("l");  	break;  }  
Missing Default,StringDec,Program,C:\repos\wahlao_StringDec\Program.cs,ReverseIME,The following switch statement is missing a default case: switch (c) {  case 1:  	sb.Append ("r");  	break;  case 2:  	sb.Append ("R");  	break;  case 3:  	sb.Append ("rt");  	break;  case 4:  	sb.Append ("s");  	break;  case 5:  	sb.Append ("sw");  	break;  case 6:  	sb.Append ("sg");  	break;  case 7:  	sb.Append ("e");  	break;  case 8:  	sb.Append ("f");  	break;  case 9:  	sb.Append ("fr");  	break;  case 10:  	sb.Append ("fa");  	break;  case 11:  	sb.Append ("fq");  	break;  case 12:  	sb.Append ("ft");  	break;  case 13:  	sb.Append ("fx");  	break;  case 14:  	sb.Append ("fv");  	break;  case 15:  	sb.Append ("fg");  	break;  case 16:  	sb.Append ("a");  	break;  case 17:  	sb.Append ("q");  	break;  case 18:  	sb.Append ("qt");  	break;  case 19:  	sb.Append ("t");  	break;  case 20:  	sb.Append ("T");  	break;  case 21:  	sb.Append ("d");  	break;  case 22:  	sb.Append ("w");  	break;  case 23:  	sb.Append ("c");  	break;  case 24:  	sb.Append ("z");  	break;  case 25:  	sb.Append ("x");  	break;  case 26:  	sb.Append ("v");  	break;  case 27:  	sb.Append ("g");  	break;  }  
