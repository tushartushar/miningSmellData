Implementation smell,Namespace,Class,File,Method,Description
Complex Method,NHttp,HttpClient,C:\repos\pvginkel_NHttp\NHttp\HttpClient.cs,BuildResponseHeaders,Cyclomatic complexity of the method is 8
Complex Method,NHttp,HttpMultiPartRequestParser,C:\repos\pvginkel_NHttp\NHttp\HttpMultiPartRequestParser.cs,ParseHeaders,Cyclomatic complexity of the method is 8
Complex Method,NHttp,HttpReadBuffer,C:\repos\pvginkel_NHttp\NHttp\HttpReadBuffer.cs,CopyToStream,Cyclomatic complexity of the method is 10
Complex Method,NHttp,HttpRequest,C:\repos\pvginkel_NHttp\NHttp\HttpRequest.cs,ParseHeaders,Cyclomatic complexity of the method is 12
Complex Method,NHttp,HttpRequest,C:\repos\pvginkel_NHttp\NHttp\HttpRequest.cs,ParseMultiPartItems,Cyclomatic complexity of the method is 9
Complex Method,NHttp,HttpUtil,C:\repos\pvginkel_NHttp\NHttp\HttpUtil.cs,HtmlDecode,Cyclomatic complexity of the method is 12
Long Parameter List,NHttp,HttpOutputStream,C:\repos\pvginkel_NHttp\NHttp\HttpOutputStream.cs,BeginRead,The method has 5 parameters. Parameters: buffer' offset' count' callback' state
Long Parameter List,NHttp,HttpOutputStream,C:\repos\pvginkel_NHttp\NHttp\HttpOutputStream.cs,BeginWrite,The method has 5 parameters. Parameters: buffer' offset' count' callback' state
Complex Conditional,NHttp,HttpClient,C:\repos\pvginkel_NHttp\NHttp\HttpClient.cs,ProcessRequestCompleted,The conditional expression  "!_errored &&                  Server.State == HttpServerState.Started &&                  Headers.TryGetValue("Connection"' out connectionHeader) &&                  String.Equals(connectionHeader' "keep-alive"' StringComparison.OrdinalIgnoreCase)"  is complex.
Complex Conditional,NHttp,HttpUtil,C:\repos\pvginkel_NHttp\NHttp\HttpUtil.cs,UriDecode,The conditional expression  "value[i] == '%' &&                      i < value.Length - 2 &&                      IsHex(value[i + 1]) &&                      IsHex(value[i + 2])"  is complex.
Empty Catch Block,NHttp,HttpServer,C:\repos\pvginkel_NHttp\NHttp\HttpServer.cs,AcceptTcpClientCallback,The method has an empty catch block.
Empty Catch Block,NHttp,HttpTimeoutManager,C:\repos\pvginkel_NHttp\NHttp\HttpTimeoutManager.cs,ProcessQueue,The method has an empty catch block.
Empty Catch Block,NHttp,LogManager,C:\repos\pvginkel_NHttp\NHttp\LogManager.cs,LogManager,The method has an empty catch block.
Magic Number,NHttp,HttpClient,C:\repos\pvginkel_NHttp\NHttp\HttpClient.cs,ProcessProlog,The following statement contains a magic number: Request = match.Groups[2].Value;
Magic Number,NHttp,HttpClient,C:\repos\pvginkel_NHttp\NHttp\HttpClient.cs,ProcessProlog,The following statement contains a magic number: Protocol = match.Groups[3].Value;
Magic Number,NHttp,HttpClient,C:\repos\pvginkel_NHttp\NHttp\HttpClient.cs,ProcessHeaders,The following statement contains a magic number: while ((line = ReadBuffer.ReadLine()) != null)              {                  // Have we completed receiving the headers?                    if (line.Length == 0)                  {                      // Reset the read buffer which resets the bytes read.                        ReadBuffer.Reset();                        // Start processing the body of the request.                        _state = ClientState.ReadingContent;                        ProcessContent();                        return;                  }                    string[] parts = line.Split(new[] { ':' }' 2);                    if (parts.Length != 2)                      throw new ProtocolException("Received header without colon");                    Headers[parts[0].Trim()] = parts[1].Trim();              }
Magic Number,NHttp,HttpClient,C:\repos\pvginkel_NHttp\NHttp\HttpClient.cs,ProcessHeaders,The following statement contains a magic number: while ((line = ReadBuffer.ReadLine()) != null)              {                  // Have we completed receiving the headers?                    if (line.Length == 0)                  {                      // Reset the read buffer which resets the bytes read.                        ReadBuffer.Reset();                        // Start processing the body of the request.                        _state = ClientState.ReadingContent;                        ProcessContent();                        return;                  }                    string[] parts = line.Split(new[] { ':' }' 2);                    if (parts.Length != 2)                      throw new ProtocolException("Received header without colon");                    Headers[parts[0].Trim()] = parts[1].Trim();              }
Magic Number,NHttp,HttpClient,C:\repos\pvginkel_NHttp\NHttp\HttpClient.cs,ProcessContentLengthHeader,The following statement contains a magic number: if (Headers.TryGetValue("Content-Length"' out contentLengthHeader))              {                  int contentLength;                    if (!int.TryParse(contentLengthHeader' out contentLength))                      throw new ProtocolException(String.Format("Could not parse Content-Length header '{0}'"' contentLengthHeader));                    string contentTypeHeader;                  string contentType = null;                  string contentTypeExtra = null;                    if (Headers.TryGetValue("Content-Type"' out contentTypeHeader))                  {                      string[] parts = contentTypeHeader.Split(new[] { ';' }' 2);                        contentType = parts[0].Trim().ToLowerInvariant();                      contentTypeExtra = parts.Length == 2 ? parts[1].Trim() : null;                  }                    if (_parser != null)                  {                      _parser.Dispose();                      _parser = null;                  }                    switch (contentType)                  {                      case "application/x-www-form-urlencoded":                          _parser = new HttpUrlEncodedRequestParser(this' contentLength);                          break;                        case "multipart/form-data":                          string boundary = null;                            if (contentTypeExtra != null)                          {                              string[] parts = contentTypeExtra.Split(new[] { '=' }' 2);                                if (                                  parts.Length == 2 &&                                  String.Equals(parts[0]' "boundary"' StringComparison.OrdinalIgnoreCase)                              )                                  boundary = parts[1];                          }                            if (boundary == null)                              throw new ProtocolException("Expected boundary with multipart content type");                            _parser = new HttpMultiPartRequestParser(this' contentLength' boundary);                          break;                        default:                          _parser = new HttpUnknownRequestParser(this' contentLength);                          break;                  }                    // We've made a parser available. Recurs back to start processing                  // with the parser.                    ProcessContent();                  return true;              }
Magic Number,NHttp,HttpClient,C:\repos\pvginkel_NHttp\NHttp\HttpClient.cs,ProcessContentLengthHeader,The following statement contains a magic number: if (Headers.TryGetValue("Content-Length"' out contentLengthHeader))              {                  int contentLength;                    if (!int.TryParse(contentLengthHeader' out contentLength))                      throw new ProtocolException(String.Format("Could not parse Content-Length header '{0}'"' contentLengthHeader));                    string contentTypeHeader;                  string contentType = null;                  string contentTypeExtra = null;                    if (Headers.TryGetValue("Content-Type"' out contentTypeHeader))                  {                      string[] parts = contentTypeHeader.Split(new[] { ';' }' 2);                        contentType = parts[0].Trim().ToLowerInvariant();                      contentTypeExtra = parts.Length == 2 ? parts[1].Trim() : null;                  }                    if (_parser != null)                  {                      _parser.Dispose();                      _parser = null;                  }                    switch (contentType)                  {                      case "application/x-www-form-urlencoded":                          _parser = new HttpUrlEncodedRequestParser(this' contentLength);                          break;                        case "multipart/form-data":                          string boundary = null;                            if (contentTypeExtra != null)                          {                              string[] parts = contentTypeExtra.Split(new[] { '=' }' 2);                                if (                                  parts.Length == 2 &&                                  String.Equals(parts[0]' "boundary"' StringComparison.OrdinalIgnoreCase)                              )                                  boundary = parts[1];                          }                            if (boundary == null)                              throw new ProtocolException("Expected boundary with multipart content type");                            _parser = new HttpMultiPartRequestParser(this' contentLength' boundary);                          break;                        default:                          _parser = new HttpUnknownRequestParser(this' contentLength);                          break;                  }                    // We've made a parser available. Recurs back to start processing                  // with the parser.                    ProcessContent();                  return true;              }
Magic Number,NHttp,HttpClient,C:\repos\pvginkel_NHttp\NHttp\HttpClient.cs,ProcessContentLengthHeader,The following statement contains a magic number: if (Headers.TryGetValue("Content-Length"' out contentLengthHeader))              {                  int contentLength;                    if (!int.TryParse(contentLengthHeader' out contentLength))                      throw new ProtocolException(String.Format("Could not parse Content-Length header '{0}'"' contentLengthHeader));                    string contentTypeHeader;                  string contentType = null;                  string contentTypeExtra = null;                    if (Headers.TryGetValue("Content-Type"' out contentTypeHeader))                  {                      string[] parts = contentTypeHeader.Split(new[] { ';' }' 2);                        contentType = parts[0].Trim().ToLowerInvariant();                      contentTypeExtra = parts.Length == 2 ? parts[1].Trim() : null;                  }                    if (_parser != null)                  {                      _parser.Dispose();                      _parser = null;                  }                    switch (contentType)                  {                      case "application/x-www-form-urlencoded":                          _parser = new HttpUrlEncodedRequestParser(this' contentLength);                          break;                        case "multipart/form-data":                          string boundary = null;                            if (contentTypeExtra != null)                          {                              string[] parts = contentTypeExtra.Split(new[] { '=' }' 2);                                if (                                  parts.Length == 2 &&                                  String.Equals(parts[0]' "boundary"' StringComparison.OrdinalIgnoreCase)                              )                                  boundary = parts[1];                          }                            if (boundary == null)                              throw new ProtocolException("Expected boundary with multipart content type");                            _parser = new HttpMultiPartRequestParser(this' contentLength' boundary);                          break;                        default:                          _parser = new HttpUnknownRequestParser(this' contentLength);                          break;                  }                    // We've made a parser available. Recurs back to start processing                  // with the parser.                    ProcessContent();                  return true;              }
Magic Number,NHttp,HttpClient,C:\repos\pvginkel_NHttp\NHttp\HttpClient.cs,ProcessContentLengthHeader,The following statement contains a magic number: if (Headers.TryGetValue("Content-Length"' out contentLengthHeader))              {                  int contentLength;                    if (!int.TryParse(contentLengthHeader' out contentLength))                      throw new ProtocolException(String.Format("Could not parse Content-Length header '{0}'"' contentLengthHeader));                    string contentTypeHeader;                  string contentType = null;                  string contentTypeExtra = null;                    if (Headers.TryGetValue("Content-Type"' out contentTypeHeader))                  {                      string[] parts = contentTypeHeader.Split(new[] { ';' }' 2);                        contentType = parts[0].Trim().ToLowerInvariant();                      contentTypeExtra = parts.Length == 2 ? parts[1].Trim() : null;                  }                    if (_parser != null)                  {                      _parser.Dispose();                      _parser = null;                  }                    switch (contentType)                  {                      case "application/x-www-form-urlencoded":                          _parser = new HttpUrlEncodedRequestParser(this' contentLength);                          break;                        case "multipart/form-data":                          string boundary = null;                            if (contentTypeExtra != null)                          {                              string[] parts = contentTypeExtra.Split(new[] { '=' }' 2);                                if (                                  parts.Length == 2 &&                                  String.Equals(parts[0]' "boundary"' StringComparison.OrdinalIgnoreCase)                              )                                  boundary = parts[1];                          }                            if (boundary == null)                              throw new ProtocolException("Expected boundary with multipart content type");                            _parser = new HttpMultiPartRequestParser(this' contentLength' boundary);                          break;                        default:                          _parser = new HttpUnknownRequestParser(this' contentLength);                          break;                  }                    // We've made a parser available. Recurs back to start processing                  // with the parser.                    ProcessContent();                  return true;              }
Magic Number,NHttp,HttpClient,C:\repos\pvginkel_NHttp\NHttp\HttpClient.cs,ProcessException,The following statement contains a magic number: try              {                  if (_context == null)                      _context = new HttpContext(this);                    _context.Response.Status = "500 Internal Server Error";                    bool handled;                    try                  {                      handled = Server.RaiseUnhandledException(_context' exception);                  }                  catch                  {                      handled = false;                  }                    if (!handled && _context.Response.OutputStream.CanWrite)                  {                      string resourceName = GetType().Namespace + ".Resources.InternalServerError.html";                        using (var stream = GetType().Assembly.GetManifestResourceStream(resourceName))                      {                          byte[] buffer = new byte[4096];                          int read;                            while ((read = stream.Read(buffer' 0' buffer.Length)) != 0)                          {                              _context.Response.OutputStream.Write(buffer' 0' read);                          }                      }                  }                    WriteResponseHeaders();              }              catch (Exception ex)              {                  Log.Info("Failed to process internal server error response"' ex);                    Dispose();              }
Magic Number,NHttp,HttpCookie,C:\repos\pvginkel_NHttp\NHttp\HttpCookie.cs,HttpCookie,The following statement contains a magic number: if (value != null)              {                  if (value.Contains("&") || value.Contains("="))                  {                      string[] parts = value.Split('&');                        foreach (string part in parts)                      {                          name = null;                          value = null;                            if (part.Length > 0)                          {                              string[] partParts = part.Split(new[] { '=' }' 2);                                name = partParts[0];                              value = partParts.Length == 1 ? null : partParts[1];                          }                            Values.Add(name' value);                      }                  }                  else                  {                      Value = value;                  }              }
Magic Number,NHttp,HttpMultiPartRequestParser,C:\repos\pvginkel_NHttp\NHttp\HttpMultiPartRequestParser.cs,ParseHeaders,The following statement contains a magic number: while ((line = Client.ReadBuffer.ReadLine()) != null)              {                  string[] parts;                    if (line.Length == 0)                  {                      // Test whether we're reading a file or a field.                        string contentDispositionHeader;                        if (!_headers.TryGetValue("Content-Disposition"' out contentDispositionHeader))                          throw new ProtocolException("Expected Content-Disposition header with multipart");                        parts = contentDispositionHeader.Split(';');                        _readingFile = false;                        for (int i = 0; i < parts.Length; i++)                      {                          string part = parts[i].Trim();                            if (part.StartsWith("filename="' StringComparison.OrdinalIgnoreCase))                          {                              _readingFile = true;                              break;                          }                      }                        // Prepare our state for whether we're reading a file                      // or a field.                        if (_readingFile)                      {                          _fileName = Path.GetTempFileName();                          _fileStream = File.Create(_fileName' 4096' FileOptions.DeleteOnClose);                      }                      else                      {                          if (_fieldStream == null)                          {                              _fieldStream = new MemoryStream();                          }                          else                          {                              _fieldStream.Position = 0;                              _fieldStream.SetLength(0);                          }                      }                        _state = ParserState.ReadingContent;                        ParseContent();                      return;                  }                    parts = line.Split(new[] { ':' }' 2);                    if (parts.Length != 2)                      throw new ProtocolException("Received header without colon");                    _headers[parts[0].Trim()] = parts[1].Trim();              }
Magic Number,NHttp,HttpMultiPartRequestParser,C:\repos\pvginkel_NHttp\NHttp\HttpMultiPartRequestParser.cs,ParseHeaders,The following statement contains a magic number: while ((line = Client.ReadBuffer.ReadLine()) != null)              {                  string[] parts;                    if (line.Length == 0)                  {                      // Test whether we're reading a file or a field.                        string contentDispositionHeader;                        if (!_headers.TryGetValue("Content-Disposition"' out contentDispositionHeader))                          throw new ProtocolException("Expected Content-Disposition header with multipart");                        parts = contentDispositionHeader.Split(';');                        _readingFile = false;                        for (int i = 0; i < parts.Length; i++)                      {                          string part = parts[i].Trim();                            if (part.StartsWith("filename="' StringComparison.OrdinalIgnoreCase))                          {                              _readingFile = true;                              break;                          }                      }                        // Prepare our state for whether we're reading a file                      // or a field.                        if (_readingFile)                      {                          _fileName = Path.GetTempFileName();                          _fileStream = File.Create(_fileName' 4096' FileOptions.DeleteOnClose);                      }                      else                      {                          if (_fieldStream == null)                          {                              _fieldStream = new MemoryStream();                          }                          else                          {                              _fieldStream.Position = 0;                              _fieldStream.SetLength(0);                          }                      }                        _state = ParserState.ReadingContent;                        ParseContent();                      return;                  }                    parts = line.Split(new[] { ':' }' 2);                    if (parts.Length != 2)                      throw new ProtocolException("Received header without colon");                    _headers[parts[0].Trim()] = parts[1].Trim();              }
Magic Number,NHttp,HttpMultiPartRequestParser,C:\repos\pvginkel_NHttp\NHttp\HttpMultiPartRequestParser.cs,ParseHeaders,The following statement contains a magic number: while ((line = Client.ReadBuffer.ReadLine()) != null)              {                  string[] parts;                    if (line.Length == 0)                  {                      // Test whether we're reading a file or a field.                        string contentDispositionHeader;                        if (!_headers.TryGetValue("Content-Disposition"' out contentDispositionHeader))                          throw new ProtocolException("Expected Content-Disposition header with multipart");                        parts = contentDispositionHeader.Split(';');                        _readingFile = false;                        for (int i = 0; i < parts.Length; i++)                      {                          string part = parts[i].Trim();                            if (part.StartsWith("filename="' StringComparison.OrdinalIgnoreCase))                          {                              _readingFile = true;                              break;                          }                      }                        // Prepare our state for whether we're reading a file                      // or a field.                        if (_readingFile)                      {                          _fileName = Path.GetTempFileName();                          _fileStream = File.Create(_fileName' 4096' FileOptions.DeleteOnClose);                      }                      else                      {                          if (_fieldStream == null)                          {                              _fieldStream = new MemoryStream();                          }                          else                          {                              _fieldStream.Position = 0;                              _fieldStream.SetLength(0);                          }                      }                        _state = ParserState.ReadingContent;                        ParseContent();                      return;                  }                    parts = line.Split(new[] { ':' }' 2);                    if (parts.Length != 2)                      throw new ProtocolException("Received header without colon");                    _headers[parts[0].Trim()] = parts[1].Trim();              }
Magic Number,NHttp,HttpReadBuffer,C:\repos\pvginkel_NHttp\NHttp\HttpReadBuffer.cs,BeginRead,The following statement contains a magic number: if (_offset == _available)              {                  // If the offset is at the end' we can just reset the                  // positions.                    _offset = 0;                  _available = 0;              }              else if (_buffer.Length - _available < _bufferSize)              {                  // If there is less than the initial buffer size room left'                  // we need to move some data.                    if (_buffer.Length - (_available - _offset) < _bufferSize)                  {                      // If the available size is less than the initial buffer size'                      // enlarge the buffer.                        var buffer = new byte[_buffer.Length * 2];                        // Copy the unprocessed bytes to the start of the new buffer.                        Array.Copy(_buffer' _offset' buffer' 0' _available - _offset);                        _buffer = buffer;                  }                  else                  {                      // Else' just move the unprocessed bytes to the beginning.                        Array.Copy(_buffer' _offset' _buffer' 0' _available - _offset);                  }                    // Reset the position and available to reflect the moved                  // bytes.                    _available -= _offset;                  _offset = 0;              }
Magic Number,NHttp,HttpRequest,C:\repos\pvginkel_NHttp\NHttp\HttpRequest.cs,ParseHeaders,The following statement contains a magic number: if (client.Headers.TryGetValue("Content-Type"' out header))              {                  string[] parts = header.Split(new[] { ';' }' 2);                    ContentType = parts[0].Trim();                    if (parts.Length == 2)                  {                      string[] encoding = parts[1].Trim().Split(new[] { '=' }' 2);                        if (encoding.Length == 2 && String.Equals(encoding[0]' "charset"' StringComparison.OrdinalIgnoreCase))                      {                          ContentEncoding = Encoding.GetEncoding(encoding[1]);                      }                  }              }
Magic Number,NHttp,HttpRequest,C:\repos\pvginkel_NHttp\NHttp\HttpRequest.cs,ParseHeaders,The following statement contains a magic number: if (client.Headers.TryGetValue("Content-Type"' out header))              {                  string[] parts = header.Split(new[] { ';' }' 2);                    ContentType = parts[0].Trim();                    if (parts.Length == 2)                  {                      string[] encoding = parts[1].Trim().Split(new[] { '=' }' 2);                        if (encoding.Length == 2 && String.Equals(encoding[0]' "charset"' StringComparison.OrdinalIgnoreCase))                      {                          ContentEncoding = Encoding.GetEncoding(encoding[1]);                      }                  }              }
Magic Number,NHttp,HttpRequest,C:\repos\pvginkel_NHttp\NHttp\HttpRequest.cs,ParseHeaders,The following statement contains a magic number: if (client.Headers.TryGetValue("Content-Type"' out header))              {                  string[] parts = header.Split(new[] { ';' }' 2);                    ContentType = parts[0].Trim();                    if (parts.Length == 2)                  {                      string[] encoding = parts[1].Trim().Split(new[] { '=' }' 2);                        if (encoding.Length == 2 && String.Equals(encoding[0]' "charset"' StringComparison.OrdinalIgnoreCase))                      {                          ContentEncoding = Encoding.GetEncoding(encoding[1]);                      }                  }              }
Magic Number,NHttp,HttpRequest,C:\repos\pvginkel_NHttp\NHttp\HttpRequest.cs,ParseHeaders,The following statement contains a magic number: if (client.Headers.TryGetValue("Content-Type"' out header))              {                  string[] parts = header.Split(new[] { ';' }' 2);                    ContentType = parts[0].Trim();                    if (parts.Length == 2)                  {                      string[] encoding = parts[1].Trim().Split(new[] { '=' }' 2);                        if (encoding.Length == 2 && String.Equals(encoding[0]' "charset"' StringComparison.OrdinalIgnoreCase))                      {                          ContentEncoding = Encoding.GetEncoding(encoding[1]);                      }                  }              }
Magic Number,NHttp,HttpRequest,C:\repos\pvginkel_NHttp\NHttp\HttpRequest.cs,ParseHeaders,The following statement contains a magic number: if (client.Headers.TryGetValue("Cookie"' out header))              {                  string[] parts = header.Split(';');                    foreach (string part in parts)                  {                      string[] partParts = part.Split(new[] { '=' }' 2);                        string name = partParts[0].Trim();                      string value = partParts.Length == 1 ? null : partParts[1];                        Cookies.AddCookie(new HttpCookie(name' value)' true);                  }              }
Magic Number,NHttp,HttpRequest,C:\repos\pvginkel_NHttp\NHttp\HttpRequest.cs,ParseMultiPartItems,The following statement contains a magic number: foreach (var item in client.MultiPartItems)              {                  string contentType = null;                  string name = null;                  string fileName = null;                    string header;                    if (item.Headers.TryGetValue("Content-Disposition"' out header))                  {                      string[] parts = header.Split(';');                        for (int i = 0; i < parts.Length; i++)                      {                          string part = parts[i].Trim();                            if (part.StartsWith("name="))                              name = ParseContentDispositionItem(part.Substring(5));                          else if (part.StartsWith("filename="))                              fileName = ParseContentDispositionItem(part.Substring(9));                      }                  }                    if (item.Headers.TryGetValue("Content-Type"' out header))                      contentType = header;                    if (name == null)                  {                      Log.Info("Received multipart item without name");                      continue;                  }                    if (item.Value != null)                  {                      Form[name] = item.Value;                  }                  else                  {                      Files.AddFile(name' new HttpPostedFile((int)item.Stream.Length' contentType' fileName' item.Stream));                  }              }
Magic Number,NHttp,HttpRequest,C:\repos\pvginkel_NHttp\NHttp\HttpRequest.cs,ParseMultiPartItems,The following statement contains a magic number: foreach (var item in client.MultiPartItems)              {                  string contentType = null;                  string name = null;                  string fileName = null;                    string header;                    if (item.Headers.TryGetValue("Content-Disposition"' out header))                  {                      string[] parts = header.Split(';');                        for (int i = 0; i < parts.Length; i++)                      {                          string part = parts[i].Trim();                            if (part.StartsWith("name="))                              name = ParseContentDispositionItem(part.Substring(5));                          else if (part.StartsWith("filename="))                              fileName = ParseContentDispositionItem(part.Substring(9));                      }                  }                    if (item.Headers.TryGetValue("Content-Type"' out header))                      contentType = header;                    if (name == null)                  {                      Log.Info("Received multipart item without name");                      continue;                  }                    if (item.Value != null)                  {                      Form[name] = item.Value;                  }                  else                  {                      Files.AddFile(name' new HttpPostedFile((int)item.Stream.Length' contentType' fileName' item.Stream));                  }              }
Magic Number,NHttp,HttpRequest,C:\repos\pvginkel_NHttp\NHttp\HttpRequest.cs,ParseContentDispositionItem,The following statement contains a magic number: if (value.Length >= 2 && value[0] == '"' && value[value.Length - 1] == '"')                  value = value.Substring(1' value.Length - 2);
Magic Number,NHttp,HttpRequest,C:\repos\pvginkel_NHttp\NHttp\HttpRequest.cs,ParseContentDispositionItem,The following statement contains a magic number: if (value.Length >= 2 && value[0] == '"' && value[value.Length - 1] == '"')                  value = value.Substring(1' value.Length - 2);
Magic Number,NHttp,HttpRequest,C:\repos\pvginkel_NHttp\NHttp\HttpRequest.cs,ParsePath,The following statement contains a magic number: string[] parts = client.Request.Split(new[] { '?' }' 2);
Magic Number,NHttp,HttpRequest,C:\repos\pvginkel_NHttp\NHttp\HttpRequest.cs,ParsePath,The following statement contains a magic number: if (parts.Length == 2)                   HttpUtil.UrlDecodeTo(parts[1]' QueryString);
Magic Number,NHttp,HttpRequest,C:\repos\pvginkel_NHttp\NHttp\HttpRequest.cs,ParsePath,The following statement contains a magic number: if (client.Headers.TryGetValue("Host"' out hostHeader))              {                  parts = hostHeader.Split(new[] { ':' }' 2);                    host = parts[0];                    if (parts.Length == 2)                      port = parts[1];                  else                      port = null;              }              else              {                  var endPoint = client.Server.EndPoint;                    host = endPoint.Address.ToString();                                    if (endPoint.Port == 80)                      port = null;                  else                      port = endPoint.Port.ToString(CultureInfo.InvariantCulture);              }
Magic Number,NHttp,HttpRequest,C:\repos\pvginkel_NHttp\NHttp\HttpRequest.cs,ParsePath,The following statement contains a magic number: if (client.Headers.TryGetValue("Host"' out hostHeader))              {                  parts = hostHeader.Split(new[] { ':' }' 2);                    host = parts[0];                    if (parts.Length == 2)                      port = parts[1];                  else                      port = null;              }              else              {                  var endPoint = client.Server.EndPoint;                    host = endPoint.Address.ToString();                                    if (endPoint.Port == 80)                      port = null;                  else                      port = endPoint.Port.ToString(CultureInfo.InvariantCulture);              }
Magic Number,NHttp,HttpRequest,C:\repos\pvginkel_NHttp\NHttp\HttpRequest.cs,ParsePath,The following statement contains a magic number: if (client.Headers.TryGetValue("Host"' out hostHeader))              {                  parts = hostHeader.Split(new[] { ':' }' 2);                    host = parts[0];                    if (parts.Length == 2)                      port = parts[1];                  else                      port = null;              }              else              {                  var endPoint = client.Server.EndPoint;                    host = endPoint.Address.ToString();                                    if (endPoint.Port == 80)                      port = null;                  else                      port = endPoint.Port.ToString(CultureInfo.InvariantCulture);              }
Magic Number,NHttp,HttpRequest,C:\repos\pvginkel_NHttp\NHttp\HttpRequest.cs,BuildServerVariables,The following statement contains a magic number: string[] parts = client.Request.Split(new[] { '?' }' 2);
Magic Number,NHttp,HttpRequest,C:\repos\pvginkel_NHttp\NHttp\HttpRequest.cs,BuildServerVariables,The following statement contains a magic number: ServerVariables["QUERY_STRING"] = parts.Length == 2 ? parts[1] : "";
Magic Number,NHttp,HttpResponse,C:\repos\pvginkel_NHttp\NHttp\HttpResponse.cs,HttpResponse,The following statement contains a magic number: StatusCode = 200;
Magic Number,NHttp,HttpResponse,C:\repos\pvginkel_NHttp\NHttp\HttpResponse.cs,Redirect,The following statement contains a magic number: StatusCode = permanent ? 301 : 302;
Magic Number,NHttp,HttpResponse,C:\repos\pvginkel_NHttp\NHttp\HttpResponse.cs,Redirect,The following statement contains a magic number: StatusCode = permanent ? 301 : 302;
Magic Number,NHttp,HttpServer,C:\repos\pvginkel_NHttp\NHttp\HttpServer.cs,HttpServer,The following statement contains a magic number: ReadBufferSize = 4096;
Magic Number,NHttp,HttpServer,C:\repos\pvginkel_NHttp\NHttp\HttpServer.cs,HttpServer,The following statement contains a magic number: WriteBufferSize = 4096;
Magic Number,NHttp,HttpServer,C:\repos\pvginkel_NHttp\NHttp\HttpServer.cs,HttpServer,The following statement contains a magic number: ShutdownTimeout = TimeSpan.FromSeconds(30);
Magic Number,NHttp,HttpServer,C:\repos\pvginkel_NHttp\NHttp\HttpServer.cs,HttpServer,The following statement contains a magic number: ReadTimeout = TimeSpan.FromSeconds(90);
Magic Number,NHttp,HttpServer,C:\repos\pvginkel_NHttp\NHttp\HttpServer.cs,HttpServer,The following statement contains a magic number: WriteTimeout = TimeSpan.FromSeconds(90);
Magic Number,NHttp,HttpUtil,C:\repos\pvginkel_NHttp\NHttp\HttpUtil.cs,UrlDecodeTo,The following statement contains a magic number: foreach (string part in parts)              {                  string[] item = part.Split(new[] { '=' }' 2);                    string key = UriDecode(item[0]' encoding);                  string value = item.Length == 1 ? "" : UriDecode(item[1]' encoding);                    target.Add(key' value);              }
Magic Number,NHttp,HttpUtil,C:\repos\pvginkel_NHttp\NHttp\HttpUtil.cs,UriDecode,The following statement contains a magic number: for (int i = 0; i < value.Length; i++)              {                  if (                      value[i] == '%' &&                      i < value.Length - 2 &&                      IsHex(value[i + 1]) &&                      IsHex(value[i + 2])                  ) {                      result[length++] = (byte)(HexToInt(value[i + 1]) * 16 + HexToInt(value[i + 2]));                        i += 2;                  }                  else if (value[i] == '+')                  {                      result[length++] = (byte)' ';                  }                  else                  {                      int c = value[i];                        if (c > byte.MaxValue)                          throw new InvalidOperationException("URI contained unexpected character");                        result[length++] = (byte)c;                  }              }
Magic Number,NHttp,HttpUtil,C:\repos\pvginkel_NHttp\NHttp\HttpUtil.cs,UriDecode,The following statement contains a magic number: for (int i = 0; i < value.Length; i++)              {                  if (                      value[i] == '%' &&                      i < value.Length - 2 &&                      IsHex(value[i + 1]) &&                      IsHex(value[i + 2])                  ) {                      result[length++] = (byte)(HexToInt(value[i + 1]) * 16 + HexToInt(value[i + 2]));                        i += 2;                  }                  else if (value[i] == '+')                  {                      result[length++] = (byte)' ';                  }                  else                  {                      int c = value[i];                        if (c > byte.MaxValue)                          throw new InvalidOperationException("URI contained unexpected character");                        result[length++] = (byte)c;                  }              }
Magic Number,NHttp,HttpUtil,C:\repos\pvginkel_NHttp\NHttp\HttpUtil.cs,UriDecode,The following statement contains a magic number: for (int i = 0; i < value.Length; i++)              {                  if (                      value[i] == '%' &&                      i < value.Length - 2 &&                      IsHex(value[i + 1]) &&                      IsHex(value[i + 2])                  ) {                      result[length++] = (byte)(HexToInt(value[i + 1]) * 16 + HexToInt(value[i + 2]));                        i += 2;                  }                  else if (value[i] == '+')                  {                      result[length++] = (byte)' ';                  }                  else                  {                      int c = value[i];                        if (c > byte.MaxValue)                          throw new InvalidOperationException("URI contained unexpected character");                        result[length++] = (byte)c;                  }              }
Magic Number,NHttp,HttpUtil,C:\repos\pvginkel_NHttp\NHttp\HttpUtil.cs,UriDecode,The following statement contains a magic number: for (int i = 0; i < value.Length; i++)              {                  if (                      value[i] == '%' &&                      i < value.Length - 2 &&                      IsHex(value[i + 1]) &&                      IsHex(value[i + 2])                  ) {                      result[length++] = (byte)(HexToInt(value[i + 1]) * 16 + HexToInt(value[i + 2]));                        i += 2;                  }                  else if (value[i] == '+')                  {                      result[length++] = (byte)' ';                  }                  else                  {                      int c = value[i];                        if (c > byte.MaxValue)                          throw new InvalidOperationException("URI contained unexpected character");                        result[length++] = (byte)c;                  }              }
Magic Number,NHttp,HttpUtil,C:\repos\pvginkel_NHttp\NHttp\HttpUtil.cs,UriDecode,The following statement contains a magic number: for (int i = 0; i < value.Length; i++)              {                  if (                      value[i] == '%' &&                      i < value.Length - 2 &&                      IsHex(value[i + 1]) &&                      IsHex(value[i + 2])                  ) {                      result[length++] = (byte)(HexToInt(value[i + 1]) * 16 + HexToInt(value[i + 2]));                        i += 2;                  }                  else if (value[i] == '+')                  {                      result[length++] = (byte)' ';                  }                  else                  {                      int c = value[i];                        if (c > byte.MaxValue)                          throw new InvalidOperationException("URI contained unexpected character");                        result[length++] = (byte)c;                  }              }
Magic Number,NHttp,HttpUtil,C:\repos\pvginkel_NHttp\NHttp\HttpUtil.cs,HexToInt,The following statement contains a magic number: switch (value)              {                  case '0':                  case '1':                  case '2':                  case '3':                  case '4':                  case '5':                  case '6':                  case '7':                  case '8':                  case '9':                      return value - '0';                    case 'a':                  case 'b':                  case 'c':                  case 'd':                  case 'e':                  case 'f':                      return (value - 'a') + 10;                    case 'A':                  case 'B':                  case 'C':                  case 'D':                  case 'E':                  case 'F':                      return (value - 'A') + 10;                    default:                      throw new ArgumentOutOfRangeException("value");              }
Magic Number,NHttp,HttpUtil,C:\repos\pvginkel_NHttp\NHttp\HttpUtil.cs,HexToInt,The following statement contains a magic number: switch (value)              {                  case '0':                  case '1':                  case '2':                  case '3':                  case '4':                  case '5':                  case '6':                  case '7':                  case '8':                  case '9':                      return value - '0';                    case 'a':                  case 'b':                  case 'c':                  case 'd':                  case 'e':                  case 'f':                      return (value - 'a') + 10;                    case 'A':                  case 'B':                  case 'C':                  case 'D':                  case 'E':                  case 'F':                      return (value - 'A') + 10;                    default:                      throw new ArgumentOutOfRangeException("value");              }
Magic Number,NHttp,HttpUtil,C:\repos\pvginkel_NHttp\NHttp\HttpUtil.cs,HtmlDecode,The following statement contains a magic number: for (int i = 0; i < value.Length; i++)              {                  if (value[i] == '&' && value.Length > i + 2)                  {                      // Scan for the ;.                        int maxSearch = Math.Min(value.Length' i + _longestHtmlEntity + 2);                      int endPosition = -1;                        for (int j = i + 1; j < maxSearch; j++)                      {                          if (value[j] == ';')                          {                              endPosition = j;                              break;                          }                      }                        // If we did not find an end separator' just skip over this                      // entity and treat is at text.                        if (endPosition == -1)                      {                          sb.Append(value[i]);                          continue;                      }                        // Are we in a numeric separator?                        if (value[i + 1] == '#')                      {                          int offset = 2;                            bool isHexNumeric = false;                            if (value[i + 2] == 'x' || value[i + 2] == 'X')                          {                              isHexNumeric = true;                              offset++;                          }                            // All parts of the numeric separator must be digits.                            bool isNumeric = true;                            for (int j = i + offset; j < endPosition; j++)                          {                              if (!(                                  Char.IsDigit(value[j]) ||                                  (isHexNumeric && HttpUtil.IsHex(value[j]))                              ))                              {                                  isNumeric = false;                                  break;                              }                          }                            // If not all numeric' just skip over this                          // entity and treat is at text.                            if (!isNumeric)                          {                              sb.Append(value[i]);                              continue;                          }                            // Convert the numeric entity to unicode.                            string numericEntity = value.Substring(i + offset' endPosition - (i + offset));                            sb.Append((char)int.Parse(numericEntity' isHexNumeric ? NumberStyles.HexNumber : NumberStyles.Integer));                            i = endPosition;                      }                      else                      {                          string entity = value.Substring(i + 1' endPosition - (i + 1));                            int codePoint;                            if (_htmlEntitiesByEntity.TryGetValue(entity' out codePoint))                          {                              sb.Append((char)codePoint);                                i = endPosition;                          }                          else                          {                              // If we don't know the entity' just skip over this                              // entity and treat is at text.                                sb.Append(value[i]);                          }                      }                  }                  else                  {                      sb.Append(value[i]);                  }              }
Magic Number,NHttp,HttpUtil,C:\repos\pvginkel_NHttp\NHttp\HttpUtil.cs,HtmlDecode,The following statement contains a magic number: for (int i = 0; i < value.Length; i++)              {                  if (value[i] == '&' && value.Length > i + 2)                  {                      // Scan for the ;.                        int maxSearch = Math.Min(value.Length' i + _longestHtmlEntity + 2);                      int endPosition = -1;                        for (int j = i + 1; j < maxSearch; j++)                      {                          if (value[j] == ';')                          {                              endPosition = j;                              break;                          }                      }                        // If we did not find an end separator' just skip over this                      // entity and treat is at text.                        if (endPosition == -1)                      {                          sb.Append(value[i]);                          continue;                      }                        // Are we in a numeric separator?                        if (value[i + 1] == '#')                      {                          int offset = 2;                            bool isHexNumeric = false;                            if (value[i + 2] == 'x' || value[i + 2] == 'X')                          {                              isHexNumeric = true;                              offset++;                          }                            // All parts of the numeric separator must be digits.                            bool isNumeric = true;                            for (int j = i + offset; j < endPosition; j++)                          {                              if (!(                                  Char.IsDigit(value[j]) ||                                  (isHexNumeric && HttpUtil.IsHex(value[j]))                              ))                              {                                  isNumeric = false;                                  break;                              }                          }                            // If not all numeric' just skip over this                          // entity and treat is at text.                            if (!isNumeric)                          {                              sb.Append(value[i]);                              continue;                          }                            // Convert the numeric entity to unicode.                            string numericEntity = value.Substring(i + offset' endPosition - (i + offset));                            sb.Append((char)int.Parse(numericEntity' isHexNumeric ? NumberStyles.HexNumber : NumberStyles.Integer));                            i = endPosition;                      }                      else                      {                          string entity = value.Substring(i + 1' endPosition - (i + 1));                            int codePoint;                            if (_htmlEntitiesByEntity.TryGetValue(entity' out codePoint))                          {                              sb.Append((char)codePoint);                                i = endPosition;                          }                          else                          {                              // If we don't know the entity' just skip over this                              // entity and treat is at text.                                sb.Append(value[i]);                          }                      }                  }                  else                  {                      sb.Append(value[i]);                  }              }
Magic Number,NHttp,HttpUtil,C:\repos\pvginkel_NHttp\NHttp\HttpUtil.cs,HtmlDecode,The following statement contains a magic number: for (int i = 0; i < value.Length; i++)              {                  if (value[i] == '&' && value.Length > i + 2)                  {                      // Scan for the ;.                        int maxSearch = Math.Min(value.Length' i + _longestHtmlEntity + 2);                      int endPosition = -1;                        for (int j = i + 1; j < maxSearch; j++)                      {                          if (value[j] == ';')                          {                              endPosition = j;                              break;                          }                      }                        // If we did not find an end separator' just skip over this                      // entity and treat is at text.                        if (endPosition == -1)                      {                          sb.Append(value[i]);                          continue;                      }                        // Are we in a numeric separator?                        if (value[i + 1] == '#')                      {                          int offset = 2;                            bool isHexNumeric = false;                            if (value[i + 2] == 'x' || value[i + 2] == 'X')                          {                              isHexNumeric = true;                              offset++;                          }                            // All parts of the numeric separator must be digits.                            bool isNumeric = true;                            for (int j = i + offset; j < endPosition; j++)                          {                              if (!(                                  Char.IsDigit(value[j]) ||                                  (isHexNumeric && HttpUtil.IsHex(value[j]))                              ))                              {                                  isNumeric = false;                                  break;                              }                          }                            // If not all numeric' just skip over this                          // entity and treat is at text.                            if (!isNumeric)                          {                              sb.Append(value[i]);                              continue;                          }                            // Convert the numeric entity to unicode.                            string numericEntity = value.Substring(i + offset' endPosition - (i + offset));                            sb.Append((char)int.Parse(numericEntity' isHexNumeric ? NumberStyles.HexNumber : NumberStyles.Integer));                            i = endPosition;                      }                      else                      {                          string entity = value.Substring(i + 1' endPosition - (i + 1));                            int codePoint;                            if (_htmlEntitiesByEntity.TryGetValue(entity' out codePoint))                          {                              sb.Append((char)codePoint);                                i = endPosition;                          }                          else                          {                              // If we don't know the entity' just skip over this                              // entity and treat is at text.                                sb.Append(value[i]);                          }                      }                  }                  else                  {                      sb.Append(value[i]);                  }              }
Magic Number,NHttp,HttpUtil,C:\repos\pvginkel_NHttp\NHttp\HttpUtil.cs,HtmlDecode,The following statement contains a magic number: for (int i = 0; i < value.Length; i++)              {                  if (value[i] == '&' && value.Length > i + 2)                  {                      // Scan for the ;.                        int maxSearch = Math.Min(value.Length' i + _longestHtmlEntity + 2);                      int endPosition = -1;                        for (int j = i + 1; j < maxSearch; j++)                      {                          if (value[j] == ';')                          {                              endPosition = j;                              break;                          }                      }                        // If we did not find an end separator' just skip over this                      // entity and treat is at text.                        if (endPosition == -1)                      {                          sb.Append(value[i]);                          continue;                      }                        // Are we in a numeric separator?                        if (value[i + 1] == '#')                      {                          int offset = 2;                            bool isHexNumeric = false;                            if (value[i + 2] == 'x' || value[i + 2] == 'X')                          {                              isHexNumeric = true;                              offset++;                          }                            // All parts of the numeric separator must be digits.                            bool isNumeric = true;                            for (int j = i + offset; j < endPosition; j++)                          {                              if (!(                                  Char.IsDigit(value[j]) ||                                  (isHexNumeric && HttpUtil.IsHex(value[j]))                              ))                              {                                  isNumeric = false;                                  break;                              }                          }                            // If not all numeric' just skip over this                          // entity and treat is at text.                            if (!isNumeric)                          {                              sb.Append(value[i]);                              continue;                          }                            // Convert the numeric entity to unicode.                            string numericEntity = value.Substring(i + offset' endPosition - (i + offset));                            sb.Append((char)int.Parse(numericEntity' isHexNumeric ? NumberStyles.HexNumber : NumberStyles.Integer));                            i = endPosition;                      }                      else                      {                          string entity = value.Substring(i + 1' endPosition - (i + 1));                            int codePoint;                            if (_htmlEntitiesByEntity.TryGetValue(entity' out codePoint))                          {                              sb.Append((char)codePoint);                                i = endPosition;                          }                          else                          {                              // If we don't know the entity' just skip over this                              // entity and treat is at text.                                sb.Append(value[i]);                          }                      }                  }                  else                  {                      sb.Append(value[i]);                  }              }
Magic Number,NHttp,HttpUtil,C:\repos\pvginkel_NHttp\NHttp\HttpUtil.cs,HtmlDecode,The following statement contains a magic number: for (int i = 0; i < value.Length; i++)              {                  if (value[i] == '&' && value.Length > i + 2)                  {                      // Scan for the ;.                        int maxSearch = Math.Min(value.Length' i + _longestHtmlEntity + 2);                      int endPosition = -1;                        for (int j = i + 1; j < maxSearch; j++)                      {                          if (value[j] == ';')                          {                              endPosition = j;                              break;                          }                      }                        // If we did not find an end separator' just skip over this                      // entity and treat is at text.                        if (endPosition == -1)                      {                          sb.Append(value[i]);                          continue;                      }                        // Are we in a numeric separator?                        if (value[i + 1] == '#')                      {                          int offset = 2;                            bool isHexNumeric = false;                            if (value[i + 2] == 'x' || value[i + 2] == 'X')                          {                              isHexNumeric = true;                              offset++;                          }                            // All parts of the numeric separator must be digits.                            bool isNumeric = true;                            for (int j = i + offset; j < endPosition; j++)                          {                              if (!(                                  Char.IsDigit(value[j]) ||                                  (isHexNumeric && HttpUtil.IsHex(value[j]))                              ))                              {                                  isNumeric = false;                                  break;                              }                          }                            // If not all numeric' just skip over this                          // entity and treat is at text.                            if (!isNumeric)                          {                              sb.Append(value[i]);                              continue;                          }                            // Convert the numeric entity to unicode.                            string numericEntity = value.Substring(i + offset' endPosition - (i + offset));                            sb.Append((char)int.Parse(numericEntity' isHexNumeric ? NumberStyles.HexNumber : NumberStyles.Integer));                            i = endPosition;                      }                      else                      {                          string entity = value.Substring(i + 1' endPosition - (i + 1));                            int codePoint;                            if (_htmlEntitiesByEntity.TryGetValue(entity' out codePoint))                          {                              sb.Append((char)codePoint);                                i = endPosition;                          }                          else                          {                              // If we don't know the entity' just skip over this                              // entity and treat is at text.                                sb.Append(value[i]);                          }                      }                  }                  else                  {                      sb.Append(value[i]);                  }              }
Missing Default,NHttp,HttpMultiPartRequestParser,C:\repos\pvginkel_NHttp\NHttp\HttpMultiPartRequestParser.cs,Parse,The following switch statement is missing a default case: switch (_state)              {                  case ParserState.BeforeFirstHeaders:                      ParseFirstHeader();                      break;                    case ParserState.ReadingHeaders:                      ParseHeaders();                      break;                    case ParserState.ReadingContent:                      ParseContent();                      break;                    case ParserState.ReadingBoundary:                      ParseBoundary();                      break;              }
