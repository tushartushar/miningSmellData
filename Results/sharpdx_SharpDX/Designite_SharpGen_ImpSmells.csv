Implementation smell,Namespace,Class,File,Method,Description
Long Method,SharpGen.Generator,InterfaceTransform,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\Generator\InterfaceTransform.cs,Process,The method has 185 lines of code.
Long Method,SharpGen.Generator,InterfaceTransform,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\Generator\InterfaceTransform.cs,CreateProperties,The method has 133 lines of code.
Long Method,SharpGen.Generator,MethodTransform,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\Generator\MethodTransform.cs,Process,The method has 149 lines of code.
Long Method,SharpGen.Generator,StructTransform,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\Generator\StructTransform.cs,Process,The method has 146 lines of code.
Long Method,SharpGen.Generator,TransformManager,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\Generator\TransformManager.cs,ProcessConfigFile,The method has 171 lines of code.
Long Method,SharpGen.Generator,TransformManager,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\Generator\TransformManager.cs,GetCsType,The method has 145 lines of code.
Long Method,SharpGen.Parser,CppParser,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\Parser\CppParser.cs,Init,The method has 169 lines of code.
Long Method,SharpGen.Parser,CppParser,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\Parser\CppParser.cs,ParseAnnotations,The method has 121 lines of code.
Long Method,SharpGen.Parser,CppParser,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\Parser\CppParser.cs,ApplyDocumentation,The method has 178 lines of code.
Complex Method,SharpGen.Config,ConfigFile,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\Config\ConfigFile.cs,ExpandVariables,Cyclomatic complexity of the method is 9
Complex Method,SharpGen.CppModel,CppElement,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\CppModel\CppElement.cs,Find,Cyclomatic complexity of the method is 10
Complex Method,SharpGen.Doc,DocProviderMsdn,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\Doc\DocProviderMsdn.cs,ParseSubNodes,Cyclomatic complexity of the method is 10
Complex Method,SharpGen.Doc,DocProviderMsdn,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\Doc\DocProviderMsdn.cs,ParseDocumentation,Cyclomatic complexity of the method is 11
Complex Method,SharpGen.Model,InteropMethodSignature,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\Model\InteropMethodSignature.cs,Equals,Cyclomatic complexity of the method is 9
Complex Method,SharpGen.Generator,EnumTransform,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\Generator\EnumTransform.cs,Process,Cyclomatic complexity of the method is 11
Complex Method,SharpGen.Generator,InterfaceTransform,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\Generator\InterfaceTransform.cs,Process,Cyclomatic complexity of the method is 29
Complex Method,SharpGen.Generator,InterfaceTransform,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\Generator\InterfaceTransform.cs,DuplicateMethodSpecial,Cyclomatic complexity of the method is 9
Complex Method,SharpGen.Generator,InterfaceTransform,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\Generator\InterfaceTransform.cs,CreateProperties,Cyclomatic complexity of the method is 19
Complex Method,SharpGen.Generator,MethodTransform,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\Generator\MethodTransform.cs,Process,Cyclomatic complexity of the method is 15
Complex Method,SharpGen.Generator,StructTransform,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\Generator\StructTransform.cs,Process,Cyclomatic complexity of the method is 11
Complex Method,SharpGen.Generator,TransformManager,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\Generator\TransformManager.cs,ProcessConfigFile,Cyclomatic complexity of the method is 18
Complex Method,SharpGen.Generator,TransformManager,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\Generator\TransformManager.cs,Generate,Cyclomatic complexity of the method is 11
Complex Method,SharpGen.Generator,TransformManager,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\Generator\TransformManager.cs,GetCsType,Cyclomatic complexity of the method is 9
Complex Method,SharpGen.Generator,TransformManager,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\Generator\TransformManager.cs,GetShortNameForType,Cyclomatic complexity of the method is 15
Complex Method,SharpGen.Generator,TransformManager,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\Generator\TransformManager.cs,PrintStatistics,Cyclomatic complexity of the method is 10
Complex Method,SharpGen.Generator,NamingRulesManager,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\Generator\NamingRulesManager.cs,ConvertToPascalCase,Cyclomatic complexity of the method is 11
Complex Method,SharpGen.Parser,CastXml,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\Parser\CastXml.cs,GetIncludePaths,Cyclomatic complexity of the method is 8
Complex Method,SharpGen.Parser,CppParser,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\Parser\CppParser.cs,Init,Cyclomatic complexity of the method is 40
Complex Method,SharpGen.Parser,CppParser,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\Parser\CppParser.cs,Run,Cyclomatic complexity of the method is 10
Complex Method,SharpGen.Parser,CppParser,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\Parser\CppParser.cs,Parse,Cyclomatic complexity of the method is 9
Complex Method,SharpGen.Parser,CppParser,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\Parser\CppParser.cs,ParseAnnotations,Cyclomatic complexity of the method is 11
Complex Method,SharpGen.Parser,CppParser,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\Parser\CppParser.cs,ParseInterface,Cyclomatic complexity of the method is 15
Complex Method,SharpGen.Parser,CppParser,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\Parser\CppParser.cs,ParseStructOrUnion,Cyclomatic complexity of the method is 16
Complex Method,SharpGen.Parser,CppParser,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\Parser\CppParser.cs,ParseAllElements,Cyclomatic complexity of the method is 11
Complex Method,SharpGen.Parser,CppParser,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\Parser\CppParser.cs,ApplyDocumentation,Cyclomatic complexity of the method is 35
Complex Method,SharpGen.TextTemplating,TemplateEngine,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\TextTemplating\TemplateEngine.cs,ProcessTemplate,Cyclomatic complexity of the method is 9
Long Parameter List,SharpGen.Logging,ConsoleLogger,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\Logging\ConsoleLogger.cs,Log,The method has 6 parameters. Parameters: logLevel' logLocation' context' message' exception' parameters
Long Parameter List,SharpGen.Logging,ILogger,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\Logging\ILogger.cs,Log,The method has 6 parameters. Parameters: logLevel' logLocation' context' message' exception' parameters
Long Parameter List,SharpGen.Logging,LoggerBase,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\Logging\LoggerBase.cs,Log,The method has 6 parameters. Parameters: logLevel' logLocation' context' message' exception' parameters
Long Parameter List,SharpGen.Logging,LoggerBase,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\Logging\LoggerBase.cs,FormatMessage,The method has 6 parameters. Parameters: logLevel' logLocation' context' message' exception' parameters
Long Parameter List,SharpGen.Generator,TransformManager,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\Generator\TransformManager.cs,AddConstantFromMacroToCSharpType,The method has 6 parameters. Parameters: macroRegexp' fullNameCSharpType' type' fieldName' valueMap' visibility
Long Parameter List,SharpGen.Generator,TransformManager,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\Generator\TransformManager.cs,AddConstantToCSharpType,The method has 5 parameters. Parameters: cppElement' csClassName' typeName' fieldName' value
Long Identifier,SharpGen.Generator,InterfaceTransform,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\Generator\InterfaceTransform.cs,,The length of the parameter _mapMoveMethodToInnerInterface is 30.
Long Identifier,SharpGen.Parser,CppParser,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\Parser\CppParser.cs,,The length of the parameter _mapIncludeToAnonymousEnumCount is 31.
Long Identifier,SharpGen.Bing,Error,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\Service References\Bing\Reference.cs,,The length of the parameter sourceTypeErrorCodeFieldSpecified is 33.
Long Identifier,SharpGen.Bing,InstantAnswerResult,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\Service References\Bing\Reference.cs,,The length of the parameter instantAnswerSpecificDataField is 30.
Long Identifier,SharpGen.MTPS,getContentResponse,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\Service References\MTPS\Reference.cs,,The length of the parameter availableVersionsAndLocalesField is 32.
Long Statement,SharpGen.Config,BindRule,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\Config\BindRule.cs,ToString,The length of the statement  "            return string.Format(System.Globalization.CultureInfo.InvariantCulture' "{0} from:{1} to:{2} marshal:{3}"' base.ToString()' From' To' Marshal); " is 143.
Long Statement,SharpGen.Config,ContextRule,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\Config\ContextRule.cs,ToString,The length of the statement  "            return string.Format(System.Globalization.CultureInfo.InvariantCulture' "{0} Ids:{1}"' base.ToString()' (Ids != null) ? Ids.ToString() : ""); " is 141.
Long Statement,SharpGen.Config,MoveRule,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\Config\MoveRule.cs,ToString,The length of the statement  "            return string.Format(System.Globalization.CultureInfo.InvariantCulture' "{0} to:{1} property:{2} base:{3}"' base.ToString()' To' Property' Base); " is 145.
Long Statement,SharpGen.Config,CreateExtensionRule,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\Config\CreateExtensionRule.cs,ToString,The length of the statement  "            return string.Format(System.Globalization.CultureInfo.InvariantCulture' "{0} visibility:{1}"' base.ToString()' Visibility.HasValue ? Visibility.Value.ToString() : "undef"); " is 172.
Long Statement,SharpGen.Config,DefineExtensionRule,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\Config\DefineExtensionRule.cs,ToString,The length of the statement  "            return string.Format(System.Globalization.CultureInfo.InvariantCulture' "{0} {1} {2}"' base.ToString()' SizeOf.HasValue ? "sizeof:" + SizeOf.Value : ""' Align.HasValue ? "align:" + Align.Value : ""); " is 199.
Long Statement,SharpGen.Config,MappingBaseRule,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\Config\MappingBaseRule.cs,ToString,The length of the statement  "                    type = ((XmlAttributeAttribute) (property.GetCustomAttributes(typeof (XmlAttributeAttribute)' false)[0])).AttributeName + ":" + " is 127.
Long Statement,SharpGen.Config,ConfigFile,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\Config\ConfigFile.cs,ExpandVariables,The length of the statement  "                    propertyInfo.SetValue(objectToExpand' ExpandVariables(propertyInfo.GetValue(objectToExpand' null)' expandDynamicVariable)' null); " is 129.
Long Statement,SharpGen.Config,ConfigFile,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\Config\ConfigFile.cs,Load,The length of the statement  "                config = (ConfigFile)deserializer.Deserialize(new StringReader(Preprocessor.Preprocess(File.ReadAllText(file)' macros))); " is 121.
Long Statement,SharpGen.Config,NamingRuleShort,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\Config\NamingRuleShort.cs,ToString,The length of the statement  "            return string.Format(System.Globalization.CultureInfo.InvariantCulture' "naming-rule-short: \"{0}\" => \"{1}\""' Name' Value); " is 126.
Long Statement,SharpGen.Config,ConstantRule,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\Config\ConstantRule.cs,ToString,The length of the statement  "            return string.Format(System.Globalization.CultureInfo.InvariantCulture' "{0} from-{1}:{2} class:{3} cpp-type:{4} cpp-cast:{5} type:{6} name:{7} value:{8}"' base.ToString()' Macro!=null?"macro":"guid"'  Macro ?? Guid' ClassName' CppType' CppCast' Type' Name' Value); " is 265.
Long Statement,SharpGen.CppModel,CppField,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\CppModel\CppField.cs,Equals,The length of the statement  "            return base.Equals(other) && other.Offset == Offset && other.IsBitField.Equals(IsBitField) && other.BitOffset == BitOffset; " is 123.
Long Statement,SharpGen,CodeGenApp,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\CodeGenApp.cs,Init,The length of the statement  "                Logger.Message("Config files [{0}] changed"' string.Join("'"' Config.ConfigFilesLoaded.Select(file => Path.GetFileName(file.AbsoluteFilePath)))); " is 145.
Long Statement,SharpGen,ProgressForm,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\ProgressForm.cs,InitializeComponent,The length of the statement  "            System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(ProgressForm)); " is 132.
Long Statement,SharpGen,ProgressForm,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\ProgressForm.cs,InitializeComponent,The length of the statement  "            this.progressBar1.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left)  " is 145.
Long Statement,SharpGen,ProgressForm,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\ProgressForm.cs,InitializeComponent,The length of the statement  "            this.buttonAbort.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right))); " is 147.
Long Statement,SharpGen,Utilities,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\Utilities.cs,EscapeXml,The length of the statement  "            return stringToEscape.Replace("&"' "&amp;").Replace("<"' "&lt;").Replace(">"' "&gt;").Replace("\""' "&quot;").Replace("'"' "&apos;");             " is 133.
Long Statement,SharpGen,Utilities,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\Utilities.cs,ImportXmlTypes,The length of the statement  "                if (((exception is ThreadAbortException) || (exception is StackOverflowException)) || (exception is OutOfMemoryException)) " is 122.
Long Statement,SharpGen,Utilities,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\Utilities.cs,SGenThisAssembly,The length of the statement  "            if (!File.Exists(assemblySerializer) || File.GetLastWriteTime(typeof(Utilities).Assembly.Location) > assemblySerializerTime) " is 124.
Long Statement,SharpGen,Utilities,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\Utilities.cs,ContainsCppIdentifier,The length of the statement  "			return Regex.IsMatch(str' string.Format(@"\b{0}\b"' Regex.Escape(identifier))' RegexOptions.CultureInvariant | RegexOptions.IgnoreCase); " is 136.
Long Statement,SharpGen,Utility,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\Utility.cs,EscapeHtml,The length of the statement  "            return stringToEscape.Replace("&"' "&amp;").Replace("<"' "&lt;").Replace(">"' "&gt;").Replace("\""' "&quot;").Replace("'"' "&apos;"); " is 133.
Long Statement,SharpGen,Utility,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\Utility.cs,GetFrameworkRootDirectory,The length of the statement  "                frameworkRootDirectory = Path.GetFullPath(Registry.LocalMachine.OpenSubKey(@"Software\Microsoft\.NetFramework"' false).GetValue("InstallRoot").ToString()); " is 155.
Long Statement,SharpGen.Doc,DocProviderMsdn,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\Doc\DocProviderMsdn.cs,GetFromUrl,The length of the statement  "                /*This content has moved to <a href=\"http://msdn.microsoft.com/en-us/library/microsoft.directx_sdk.reference.dideviceobjectinstance(v=VS.85).aspx?appId=Dev10IDEF1&amp;l=ENUS&amp;k=kDIDEVICEOBJECTINSTANCE);k(DevLang-&quot;C++&quot;);k(TargetOS-WINDOWS)&amp;rd=true\" " is 266.
Long Statement,SharpGen.Logging,LoggerBase,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\Logging\LoggerBase.cs,FormatMessage,The length of the statement  "            lineMessage.AppendFormat("{0}:{1}"' levelName == "fatal" ? "error:fatal":levelName ' FormatMessage(context' message' parameters)); " is 130.
Long Statement,SharpGen.Logging,LoggerBase,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\Logging\LoggerBase.cs,FormatMessage,The length of the statement  "            lineMessage.AppendFormat("{0}{1}"' (context != null) ? " in " + context + " " : ""' message != null ? string.Format(message' parameters) : ""); " is 143.
Long Statement,SharpGen.Model,CsInterface,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\Model\CsInterface.cs,ToString,The length of the statement  "            return string.Format(System.Globalization.CultureInfo.InvariantCulture' "csinterface {0} => {1}"' CppElementName' QualifiedName); " is 129.
Long Statement,SharpGen.Model,CppElementExtensions,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\Model\CppElement.Extensions.cs,GetTypeNameWithMapping,The length of the statement  "            throw new ArgumentException(string.Format(System.Globalization.CultureInfo.InvariantCulture' "Cannot get type name from type {0}"' cppType)); " is 141.
Long Statement,SharpGen.Model,CppElementExtensions,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\Model\CppElement.Extensions.cs,ProcessTag,The length of the statement  "                           if (fromTag.FunctionDllName != null) tag.FunctionDllName = RegexRename(pathREgex' element.FullName' fromTag.FunctionDllName); " is 125.
Long Statement,SharpGen.Generator,InterfaceTransform,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\Generator\InterfaceTransform.cs,Process,The length of the statement  "                                { Name = innerInterfaceName' PropertyAccesName = keyValuePair.Value.PropertyAccessName' Base = parentCsInterface ?? DefaultInterfaceCppObject }; " is 144.
Long Statement,SharpGen.Generator,InterfaceTransform,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\Generator\InterfaceTransform.cs,CreateProperties,The length of the statement  "                if ((property.Getter != null && !property.Getter.AllowProperty) || (property.Setter != null && !property.Setter.AllowProperty)) " is 127.
Long Statement,SharpGen.Generator,MethodTransform,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\Generator\MethodTransform.cs,RegisterNativeInteropSignature,The length of the statement  "                throw new ArgumentException(string.Format(System.Globalization.CultureInfo.InvariantCulture' "Invalid return type {0} for method {1}"' csMethod.ReturnType.PublicType.QualifiedName' csMethod.CppElement)); " is 203.
Long Statement,SharpGen.Generator,MethodTransform,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\Generator\MethodTransform.cs,RegisterNativeInteropSignature,The length of the statement  "                        throw new ArgumentException(string.Format(System.Globalization.CultureInfo.InvariantCulture' "Invalid parameter {0} for method {1}"' param.PublicType.QualifiedName' csMethod.CppElement)); " is 187.
Long Statement,SharpGen.Generator,MethodTransform,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\Generator\MethodTransform.cs,Process,The length of the statement  "            if (method.CheckReturnType && method.ReturnType.PublicType != null && method.ReturnType.PublicType.QualifiedName == "SharpDX.Result") " is 133.
Long Statement,SharpGen.Generator,MethodTransform,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\Generator\MethodTransform.cs,Process,The length of the statement  "                                 (parameterAttribute == CsParameterAttribute.Out || hasArray || parameterAttribute == CsParameterAttribute.RefIn || parameterAttribute == CsParameterAttribute.Ref)) " is 163.
Long Statement,SharpGen.Generator,StructTransform,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\Generator\StructTransform.cs,Process,The length of the statement  "                                "The field [{0}] in structure [{1}] has pointer alignment within a structure that contains an union. An explicit layout cannot be handled on both x86/x64. This structure needs manual layout (remove fields from definition) and write them manually in xml mapping files"' " is 268.
Long Statement,SharpGen.Generator,TransformManager,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\Generator\TransformManager.cs,Init,The length of the statement  "                    Logger.Progress(30 + (indexFile*30)/numberOfConfigFilesToParse' "Processing mapping rules [{0}]"' configFile.Assembly ?? configFile.Id); " is 136.
Long Statement,SharpGen.Generator,TransformManager,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\Generator\TransformManager.cs,CheckAssemblyUpdate,The length of the statement  "            string updateForMessage = (assembly.IsToUpdate) ? "Config changed. Need to update from" : "Config unchanged. No need to update from"; " is 133.
Long Statement,SharpGen.Generator,TransformManager,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\Generator\TransformManager.cs,Generate,The length of the statement  "                    Path.GetFullPath(Path.Combine(Path.Combine(Path.GetDirectoryName(GetType().Assembly.Location)' "..\\..\\Templates\\")' templateFileName)); " is 138.
Long Statement,SharpGen.Generator,TransformManager,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\Generator\TransformManager.cs,Generate,The length of the statement  "                            foreach(var oldGeneratedFile in Directory.EnumerateFiles(generatedDirectoryForAssembly' "*.cs"' SearchOption.AllDirectories)) " is 125.
Long Statement,SharpGen.Generator,TransformManager,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\Generator\TransformManager.cs,GetCsType,The length of the statement  "                                      HasPointer = !string.IsNullOrEmpty(cppType.Pointer) && (cppType.Pointer.Contains("*") || cppType.Pointer.Contains("&"))' " is 120.
Long Statement,SharpGen.Generator,TransformManager,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\Generator\TransformManager.cs,GetCsType,The length of the statement  "            interopType.SizeOf = interopType.MarshalType.SizeOf*((interopType.ArrayDimensionValue > 1) ? interopType.ArrayDimensionValue : 1); " is 130.
Long Statement,SharpGen.Generator,TransformManager,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\Generator\TransformManager.cs,BindType,The length of the statement  "                Logger.Error("Mapping C++ element [{0}] to CSharp type [{1}/{2}] is already mapped to [{3}/{4}]"' cppName' type.CppElementName' " is 127.
Long Statement,SharpGen.Generator,TransformManager,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\Generator\TransformManager.cs,HandleConstantRule,The length of the statement  "            AddConstantFromMacroToCSharpType(constantRule.Macro ?? constantRule.Guid' constantRule.ClassName' constantRule.Type' constantRule.Name' constantRule.Value' constantRule.Visibility); " is 181.
Long Statement,SharpGen.Generator,TransformManager,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\Generator\TransformManager.cs,AddConstantFromMacroToCSharpType,The length of the statement  "                string finalFieldName = fieldName == null ? macroDef.Name : NamingRules.ConvertToPascalCase(regex.Replace(macroDef.Name' fieldName)' NamingFlags.Default); " is 154.
Long Statement,SharpGen.Generator,TransformManager,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\Generator\TransformManager.cs,AddConstantFromMacroToCSharpType,The length of the statement  "                string finalValue = valueMap == null ? macroDef.Value : string.Format(valueMap' macroDef.Name' macroDef.Value' finalFieldName' CurrentNamespaceName); " is 149.
Long Statement,SharpGen.Generator,TransformManager,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\Generator\TransformManager.cs,AddConstantFromMacroToCSharpType,The length of the statement  "                AddConstantToCSharpType(macroDef' fullNameCSharpType' type' finalFieldName' finalValue).Visibility = visibility.HasValue " is 120.
Long Statement,SharpGen.Generator,TransformManager,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\Generator\TransformManager.cs,AddConstantFromMacroToCSharpType,The length of the statement  "                string finalFieldName = fieldName == null ? guidDef.Name : NamingRules.ConvertToPascalCase(regex.Replace(guidDef.Name' fieldName)' NamingFlags.Default); " is 152.
Long Statement,SharpGen.Generator,TransformManager,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\Generator\TransformManager.cs,AddConstantFromMacroToCSharpType,The length of the statement  "                string finalValue = valueMap == null ? guidDef.Guid.ToString() : string.Format(valueMap' guidDef.Name' guidDef.Guid.ToString()' finalFieldName' CurrentNamespaceName); " is 166.
Long Statement,SharpGen.Parser,CastXml,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\Parser\CastXml.cs,ProcessErrorFromHeaderFile,The length of the statement  "                        Logger.PushLocation(matchError.Groups[1].Value' int.Parse(matchError.Groups[2].Value)' int.Parse(matchError.Groups[3].Value)); " is 126.
Long Statement,SharpGen.Parser,CppParser,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\Parser\CppParser.cs,CreateVariableFromMacro,The length of the statement  "                    // string finalValue = string.IsNullOrEmpty(cstRule.Value) ? macroDef.Value : regexValue.Replace(macroDef.Value' cstRule.Value); " is 128.
Long Statement,SharpGen.Parser,CppParser,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\Parser\CppParser.cs,CreateVariableFromMacro,The length of the statement  "                    builder.AppendFormat("extern \"C\" {0} {1} = {3}{2};\n"' cstRule.CppType ?? cstRule.Type' macroName' macroDef.Name' cstRule.CppCast ?? ""); " is 139.
Long Statement,SharpGen.Parser,CppParser,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\Parser\CppParser.cs,ParseInterface,The length of the statement  "                Logger.Error("Binding is missing for interface type [{0}] defined in file [{1}]"' cppInterface.Name' _mapIdToXElement[xElement.AttributeValue("file")].AttributeValue("name")); " is 175.
Long Statement,SharpGen.Parser,CppParser,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\Parser\CppParser.cs,ParseInterface,The length of the statement  "                        Logger.Error("Error binding interface type [{0}] defined in file [{1}]. Interface is inherited and binded to [{2}] and not valid for inheritance"' baseTypeName' baseTypeFile' bindedValueTo); " is 190.
Long Statement,SharpGen.Parser,CppParser,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\Parser\CppParser.cs,ParseInterface,The length of the statement  "            // Since GCC always lays them out in the order declared' we have to modify the order of the methods to match Visual C++. " is 120.
Long Statement,SharpGen.Parser,CppParser,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\Parser\CppParser.cs,ParseGuid,The length of the statement  "            return new Guid(values[0]' (short)values[1]' (short)values[2]' (byte)values[3]' (byte)values[4]' (byte)values[5]' (byte)values[6]' (byte)values[7]' " is 147.
Long Statement,SharpGen.Parser,CppParser,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\Parser\CppParser.cs,ResolveAndFillType,The length of the statement  "                            //Logger.Error("Binding is missing for type [{0}] defined in file [{1}]"' string.Join("/"' fullTypeName)' _mapIdToXElement[xType.AttributeValue("file")].AttributeValue("name")); " is 177.
Long Statement,SharpGen.Parser,CppParser,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\Parser\CppParser.cs,ResolveAndFillType,The length of the statement  "                        throw new InvalidOperationException(string.Format(System.Globalization.CultureInfo.InvariantCulture' "Unexpected tag type [{0}]"' xType.Name.LocalName)); " is 153.
Long Statement,SharpGen.TextTemplating,TemplateEngine,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\TextTemplating\TemplateEngine.cs,AddDoTemplateCode,The length of the statement  "                throw new InvalidOperationException(string.Format(System.Globalization.CultureInfo.InvariantCulture' "Cannot add Process code [{0}] after Process Class level code"' content)); " is 175.
Long Statement,SharpGen.TextTemplating,TemplateEngine,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\TextTemplating\TemplateEngine.cs,ProcessTemplate,The length of the statement  "                parametersCode.Append(string.Format(System.Globalization.CultureInfo.InvariantCulture' "public {0} {1} {{ get; set; }}\n"' parameterValueType.Type.FullName' parameterValueType.Name)); " is 183.
Long Statement,SharpGen.TextTemplating,TemplateEngine,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\TextTemplating\TemplateEngine.cs,ProcessTemplate,The length of the statement  "            string templateSourceCode = string.Format(GenericTemplateCodeText' importNamespaceCode' parametersCode' _doTemplateCode' _doTemplateClassCode); " is 143.
Long Statement,SharpGen.TextTemplating,TemplateEngine,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\TextTemplating\TemplateEngine.cs,ProcessTemplate,The length of the statement  "            var codeProvider = new Microsoft.CSharp.CSharpCodeProvider(new Dictionary<string' string>() { { "CompilerVersion"' "v4.0" } }); " is 127.
Long Statement,SharpGen.MTPS,ContentServicePortTypeClient,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\Service References\MTPS\Reference.cs,GetNavigationPaths,The length of the statement  "            SharpGen.MTPS.GetNavigationPathsResponse1 retVal = ((SharpGen.MTPS.ContentServicePortType)(this)).GetNavigationPaths(inValue); " is 126.
Complex Conditional,SharpGen.Generator,InterfaceTransform,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\Generator\InterfaceTransform.cs,CreateProperties,The conditional expression  "(cSharpMethod.IsHResult || !cSharpMethod.HasReturnType) && parameterCount == 1 &&                          parameterList[0].IsOut && !parameterList[0].IsArray"  is complex.
Complex Conditional,SharpGen.Generator,InterfaceTransform,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\Generator\InterfaceTransform.cs,CreateProperties,The conditional expression  "(cSharpMethod.IsHResult || !cSharpMethod.HasReturnType) && parameterCount == 1 &&                          (parameterList[0].IsRefIn || parameterList[0].IsIn || parameterList[0].IsRef) && !parameterList[0].IsArray"  is complex.
Complex Conditional,SharpGen.Generator,InterfaceTransform,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\Generator\InterfaceTransform.cs,CreateProperties,The conditional expression  "(property.Getter != null && !property.Getter.AllowProperty) || (property.Setter != null && !property.Setter.AllowProperty)"  is complex.
Complex Conditional,SharpGen.Generator,MethodTransform,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\Generator\MethodTransform.cs,Process,The conditional expression  "publicType is CsStruct &&                                   (parameterAttribute == CsParameterAttribute.Out || hasArray || parameterAttribute == CsParameterAttribute.RefIn || parameterAttribute == CsParameterAttribute.Ref)"  is complex.
Complex Conditional,SharpGen.Parser,CppParser,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\Parser\CppParser.cs,ParseInterface,The conditional expression  "baseTypeName != "IUnknown" && baseTypeName != "IDispatch" && (                              bindedValueTo == "SharpDX.ComObject"                              || bindedValueTo == "System.IntPtr")"  is complex.
Virtual Method Call from Constructor,SharpGen.Generator,TransformManager,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\Generator\TransformManager.cs,TransformManager,The constructor "TransformManager" calls a virtual method "Init".
Virtual Method Call from Constructor,SharpGen.Generator,TransformManager,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\Generator\TransformManager.cs,TransformManager,The constructor "TransformManager" calls a virtual method "Init".
Virtual Method Call from Constructor,SharpGen.Generator,TransformManager,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\Generator\TransformManager.cs,TransformManager,The constructor "TransformManager" calls a virtual method "Init".
Virtual Method Call from Constructor,SharpGen.Generator,TransformManager,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\Generator\TransformManager.cs,TransformManager,The constructor "TransformManager" calls a virtual method "Init".
Empty Catch Block,SharpGen.Doc,DocProviderMsdn,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\Doc\DocProviderMsdn.cs,GetDocFromMTPS,The method has an empty catch block.
Empty Catch Block,SharpGen.Doc,DocProviderMsdn,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\Doc\DocProviderMsdn.cs,GetShortId,The method has an empty catch block.
Empty Catch Block,SharpGen.Generator,TransformManager,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\Generator\TransformManager.cs,Generate,The method has an empty catch block.
Empty Catch Block,SharpGen.Generator,TransformManager,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\Generator\TransformManager.cs,ImportType,The method has an empty catch block.
Empty Catch Block,SharpGen.TextTemplating,TemplateEngine,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\TextTemplating\TemplateEngine.cs,ProcessTemplate,The method has an empty catch block.
Magic Number,SharpGen.CppModel,CppField,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\CppModel\CppField.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  int result = base.GetHashCode();                  result = (result*397) ^ Offset;                  result = (result*397) ^ IsBitField.GetHashCode();                  result = (result*397) ^ BitOffset;                  return result;              }
Magic Number,SharpGen.CppModel,CppField,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\CppModel\CppField.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  int result = base.GetHashCode();                  result = (result*397) ^ Offset;                  result = (result*397) ^ IsBitField.GetHashCode();                  result = (result*397) ^ BitOffset;                  return result;              }
Magic Number,SharpGen.CppModel,CppField,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\CppModel\CppField.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  int result = base.GetHashCode();                  result = (result*397) ^ Offset;                  result = (result*397) ^ IsBitField.GetHashCode();                  result = (result*397) ^ BitOffset;                  return result;              }
Magic Number,SharpGen.CppModel,CppType,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\CppModel\CppType.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  return ((TypeName != null ? TypeName.GetHashCode() : 0)*397) ^ (Pointer != null ? Pointer.GetHashCode() : 0);              }
Magic Number,SharpGen,CodeGenApp,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\CodeGenApp.cs,Run,The following statement contains a magic number: try              {                  // Run the parser                  var parser = new Parser.CppParser                                   {                                       IsGeneratingDoc = IsGeneratingDoc'                                       DocProviderAssembly = DocProviderAssemblyPath'                                       // @"..\..\..\DocProviderFromMsdn\bin\debug\DocProviderFromMsdn.exe"'                                       ForceParsing = _isAssemblyNew'                                       CastXmlExecutablePath = CastXmlExecutablePath                                   };                    // Init the parser                  parser.Init(Config);                    if (Logger.HasErrors)                      Logger.Fatal("Initializing parser failed");                    // Run the parser                  var group = parser.Run();                    if (Logger.HasErrors)                      Logger.Fatal("C++ compiler failed to parse header files");                    // Run the main mapping process                  var transformer = new TransformManager                  {                      GeneratedPath = _generatedPath'                      ForceGenerator = _isAssemblyNew'                      AppType = AppType                  };                    transformer.Init(group' Config);                    if (Logger.HasErrors)                      Logger.Fatal("Mapping rules initialization failed");                    transformer.Generate();                    if (Logger.HasErrors)                      Logger.Fatal("Code generation failed");                      // Print statistics                  parser.PrintStatistics();                  transformer.PrintStatistics();                    // Output all elements                  var fileWriter = new StreamWriter("SharpGen_rename.log");                  transformer.NamingRules.DumpRenames(fileWriter);                  fileWriter.Close();                    // Update Checkfile for assembly                  File.WriteAllText(_assemblyCheckFile' "");                  File.SetLastWriteTime(_assemblyCheckFile' _assemblyDatetime);                    // Update Checkfile for all config files                  File.WriteAllText(_allConfigCheck' "");                  File.SetLastWriteTime(_allConfigCheck' DateTime.Now);              }              finally              {                  Logger.Progress(100' "Finished");              }
Magic Number,SharpGen,ProgressForm,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\ProgressForm.cs,InitializeComponent,The following statement contains a magic number: this.progressBar1.Location = new System.Drawing.Point(12' 12);
Magic Number,SharpGen,ProgressForm,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\ProgressForm.cs,InitializeComponent,The following statement contains a magic number: this.progressBar1.Location = new System.Drawing.Point(12' 12);
Magic Number,SharpGen,ProgressForm,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\ProgressForm.cs,InitializeComponent,The following statement contains a magic number: this.progressBar1.Size = new System.Drawing.Size(327' 23);
Magic Number,SharpGen,ProgressForm,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\ProgressForm.cs,InitializeComponent,The following statement contains a magic number: this.progressBar1.Size = new System.Drawing.Size(327' 23);
Magic Number,SharpGen,ProgressForm,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\ProgressForm.cs,InitializeComponent,The following statement contains a magic number: this.buttonAbort.Location = new System.Drawing.Point(349' 12);
Magic Number,SharpGen,ProgressForm,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\ProgressForm.cs,InitializeComponent,The following statement contains a magic number: this.buttonAbort.Location = new System.Drawing.Point(349' 12);
Magic Number,SharpGen,ProgressForm,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\ProgressForm.cs,InitializeComponent,The following statement contains a magic number: this.buttonAbort.Size = new System.Drawing.Size(75' 23);
Magic Number,SharpGen,ProgressForm,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\ProgressForm.cs,InitializeComponent,The following statement contains a magic number: this.buttonAbort.Size = new System.Drawing.Size(75' 23);
Magic Number,SharpGen,ProgressForm,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\ProgressForm.cs,InitializeComponent,The following statement contains a magic number: this.statusStrip1.Location = new System.Drawing.Point(0' 44);
Magic Number,SharpGen,ProgressForm,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\ProgressForm.cs,InitializeComponent,The following statement contains a magic number: this.statusStrip1.Size = new System.Drawing.Size(436' 22);
Magic Number,SharpGen,ProgressForm,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\ProgressForm.cs,InitializeComponent,The following statement contains a magic number: this.statusStrip1.Size = new System.Drawing.Size(436' 22);
Magic Number,SharpGen,ProgressForm,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\ProgressForm.cs,InitializeComponent,The following statement contains a magic number: this.statusStrip1.TabIndex = 2;
Magic Number,SharpGen,ProgressForm,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\ProgressForm.cs,InitializeComponent,The following statement contains a magic number: this.statusLabel.Size = new System.Drawing.Size(16' 17);
Magic Number,SharpGen,ProgressForm,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\ProgressForm.cs,InitializeComponent,The following statement contains a magic number: this.statusLabel.Size = new System.Drawing.Size(16' 17);
Magic Number,SharpGen,ProgressForm,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\ProgressForm.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(436' 66);
Magic Number,SharpGen,ProgressForm,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\ProgressForm.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(436' 66);
Magic Number,SharpGen.Doc,DocProviderMsdn,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\Doc\DocProviderMsdn.cs,FindDocumentation,The following statement contains a magic number: if (name.EndsWith("A") || name.EndsWith("W"))              {                  string previouewChar = new string(name[name.Length - 2]' 1);                    if (previouewChar.ToUpper() != previouewChar)                  {                      name = name.Substring(0' name.Length - 1);                  }              }
Magic Number,SharpGen.Doc,DocProviderMsdn,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\Doc\DocProviderMsdn.cs,GetDocumentationFromCacheOrMsdn,The following statement contains a magic number: if (UseArchive)              {                  OpenArchive();                  var zipEntry = _zipFile.GetEntry(fileName);                  if (zipEntry != null)                  {                      var streamInput = new StreamReader(_zipFile.GetInputStream(zipEntry));                      doc = streamInput.ReadToEnd();                      streamInput.Close();                  }                  else                  {                      // Begin update if zip is not updated                      if (!isZipUpdated)                      {                          _zipFile.BeginUpdate();                          isZipUpdated = true;                      }                        Logger.Progress(20 + (counter/50) % 10' "Fetching C++ documentation ([{0}]) from MSDN"' name);                        doc = GetDocumentationFromMsdn(name);                                            _zipFile.Add(new ZipEntryStreamSource(doc)' fileName);                        // Commit update every 20 files                      filesAddedToArchive++;                      if ((filesAddedToArchive % 20) == 0)                      {                          // Force a Flush of the archive                          CloseArchive(true);                      }                  }              } else              {                  fileName = OutputPath + Path.DirectorySeparatorChar + fileName;                    if (!File.Exists(fileName))                  {                      Logger.Progress(20 + (counter / 50) % 10' "Fetching C++ documentation ([{0}]) from MSDN"' name);                        doc = GetDocumentationFromMsdn(name);                      File.WriteAllText(fileName' doc);                  }                  else                  {                      doc = File.ReadAllText(fileName);                  }              }
Magic Number,SharpGen.Doc,DocProviderMsdn,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\Doc\DocProviderMsdn.cs,GetDocumentationFromCacheOrMsdn,The following statement contains a magic number: if (UseArchive)              {                  OpenArchive();                  var zipEntry = _zipFile.GetEntry(fileName);                  if (zipEntry != null)                  {                      var streamInput = new StreamReader(_zipFile.GetInputStream(zipEntry));                      doc = streamInput.ReadToEnd();                      streamInput.Close();                  }                  else                  {                      // Begin update if zip is not updated                      if (!isZipUpdated)                      {                          _zipFile.BeginUpdate();                          isZipUpdated = true;                      }                        Logger.Progress(20 + (counter/50) % 10' "Fetching C++ documentation ([{0}]) from MSDN"' name);                        doc = GetDocumentationFromMsdn(name);                                            _zipFile.Add(new ZipEntryStreamSource(doc)' fileName);                        // Commit update every 20 files                      filesAddedToArchive++;                      if ((filesAddedToArchive % 20) == 0)                      {                          // Force a Flush of the archive                          CloseArchive(true);                      }                  }              } else              {                  fileName = OutputPath + Path.DirectorySeparatorChar + fileName;                    if (!File.Exists(fileName))                  {                      Logger.Progress(20 + (counter / 50) % 10' "Fetching C++ documentation ([{0}]) from MSDN"' name);                        doc = GetDocumentationFromMsdn(name);                      File.WriteAllText(fileName' doc);                  }                  else                  {                      doc = File.ReadAllText(fileName);                  }              }
Magic Number,SharpGen.Doc,DocProviderMsdn,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\Doc\DocProviderMsdn.cs,GetDocumentationFromCacheOrMsdn,The following statement contains a magic number: if (UseArchive)              {                  OpenArchive();                  var zipEntry = _zipFile.GetEntry(fileName);                  if (zipEntry != null)                  {                      var streamInput = new StreamReader(_zipFile.GetInputStream(zipEntry));                      doc = streamInput.ReadToEnd();                      streamInput.Close();                  }                  else                  {                      // Begin update if zip is not updated                      if (!isZipUpdated)                      {                          _zipFile.BeginUpdate();                          isZipUpdated = true;                      }                        Logger.Progress(20 + (counter/50) % 10' "Fetching C++ documentation ([{0}]) from MSDN"' name);                        doc = GetDocumentationFromMsdn(name);                                            _zipFile.Add(new ZipEntryStreamSource(doc)' fileName);                        // Commit update every 20 files                      filesAddedToArchive++;                      if ((filesAddedToArchive % 20) == 0)                      {                          // Force a Flush of the archive                          CloseArchive(true);                      }                  }              } else              {                  fileName = OutputPath + Path.DirectorySeparatorChar + fileName;                    if (!File.Exists(fileName))                  {                      Logger.Progress(20 + (counter / 50) % 10' "Fetching C++ documentation ([{0}]) from MSDN"' name);                        doc = GetDocumentationFromMsdn(name);                      File.WriteAllText(fileName' doc);                  }                  else                  {                      doc = File.ReadAllText(fileName);                  }              }
Magic Number,SharpGen.Doc,DocProviderMsdn,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\Doc\DocProviderMsdn.cs,GetDocumentationFromCacheOrMsdn,The following statement contains a magic number: if (UseArchive)              {                  OpenArchive();                  var zipEntry = _zipFile.GetEntry(fileName);                  if (zipEntry != null)                  {                      var streamInput = new StreamReader(_zipFile.GetInputStream(zipEntry));                      doc = streamInput.ReadToEnd();                      streamInput.Close();                  }                  else                  {                      // Begin update if zip is not updated                      if (!isZipUpdated)                      {                          _zipFile.BeginUpdate();                          isZipUpdated = true;                      }                        Logger.Progress(20 + (counter/50) % 10' "Fetching C++ documentation ([{0}]) from MSDN"' name);                        doc = GetDocumentationFromMsdn(name);                                            _zipFile.Add(new ZipEntryStreamSource(doc)' fileName);                        // Commit update every 20 files                      filesAddedToArchive++;                      if ((filesAddedToArchive % 20) == 0)                      {                          // Force a Flush of the archive                          CloseArchive(true);                      }                  }              } else              {                  fileName = OutputPath + Path.DirectorySeparatorChar + fileName;                    if (!File.Exists(fileName))                  {                      Logger.Progress(20 + (counter / 50) % 10' "Fetching C++ documentation ([{0}]) from MSDN"' name);                        doc = GetDocumentationFromMsdn(name);                      File.WriteAllText(fileName' doc);                  }                  else                  {                      doc = File.ReadAllText(fileName);                  }              }
Magic Number,SharpGen.Doc,DocProviderMsdn,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\Doc\DocProviderMsdn.cs,GetDocumentationFromCacheOrMsdn,The following statement contains a magic number: if (UseArchive)              {                  OpenArchive();                  var zipEntry = _zipFile.GetEntry(fileName);                  if (zipEntry != null)                  {                      var streamInput = new StreamReader(_zipFile.GetInputStream(zipEntry));                      doc = streamInput.ReadToEnd();                      streamInput.Close();                  }                  else                  {                      // Begin update if zip is not updated                      if (!isZipUpdated)                      {                          _zipFile.BeginUpdate();                          isZipUpdated = true;                      }                        Logger.Progress(20 + (counter/50) % 10' "Fetching C++ documentation ([{0}]) from MSDN"' name);                        doc = GetDocumentationFromMsdn(name);                                            _zipFile.Add(new ZipEntryStreamSource(doc)' fileName);                        // Commit update every 20 files                      filesAddedToArchive++;                      if ((filesAddedToArchive % 20) == 0)                      {                          // Force a Flush of the archive                          CloseArchive(true);                      }                  }              } else              {                  fileName = OutputPath + Path.DirectorySeparatorChar + fileName;                    if (!File.Exists(fileName))                  {                      Logger.Progress(20 + (counter / 50) % 10' "Fetching C++ documentation ([{0}]) from MSDN"' name);                        doc = GetDocumentationFromMsdn(name);                      File.WriteAllText(fileName' doc);                  }                  else                  {                      doc = File.ReadAllText(fileName);                  }              }
Magic Number,SharpGen.Doc,DocProviderMsdn,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\Doc\DocProviderMsdn.cs,GetDocumentationFromCacheOrMsdn,The following statement contains a magic number: if (UseArchive)              {                  OpenArchive();                  var zipEntry = _zipFile.GetEntry(fileName);                  if (zipEntry != null)                  {                      var streamInput = new StreamReader(_zipFile.GetInputStream(zipEntry));                      doc = streamInput.ReadToEnd();                      streamInput.Close();                  }                  else                  {                      // Begin update if zip is not updated                      if (!isZipUpdated)                      {                          _zipFile.BeginUpdate();                          isZipUpdated = true;                      }                        Logger.Progress(20 + (counter/50) % 10' "Fetching C++ documentation ([{0}]) from MSDN"' name);                        doc = GetDocumentationFromMsdn(name);                                            _zipFile.Add(new ZipEntryStreamSource(doc)' fileName);                        // Commit update every 20 files                      filesAddedToArchive++;                      if ((filesAddedToArchive % 20) == 0)                      {                          // Force a Flush of the archive                          CloseArchive(true);                      }                  }              } else              {                  fileName = OutputPath + Path.DirectorySeparatorChar + fileName;                    if (!File.Exists(fileName))                  {                      Logger.Progress(20 + (counter / 50) % 10' "Fetching C++ documentation ([{0}]) from MSDN"' name);                        doc = GetDocumentationFromMsdn(name);                      File.WriteAllText(fileName' doc);                  }                  else                  {                      doc = File.ReadAllText(fileName);                  }              }
Magic Number,SharpGen.Doc,DocProviderMsdn,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\Doc\DocProviderMsdn.cs,GetDocumentationFromCacheOrMsdn,The following statement contains a magic number: if (UseArchive)              {                  OpenArchive();                  var zipEntry = _zipFile.GetEntry(fileName);                  if (zipEntry != null)                  {                      var streamInput = new StreamReader(_zipFile.GetInputStream(zipEntry));                      doc = streamInput.ReadToEnd();                      streamInput.Close();                  }                  else                  {                      // Begin update if zip is not updated                      if (!isZipUpdated)                      {                          _zipFile.BeginUpdate();                          isZipUpdated = true;                      }                        Logger.Progress(20 + (counter/50) % 10' "Fetching C++ documentation ([{0}]) from MSDN"' name);                        doc = GetDocumentationFromMsdn(name);                                            _zipFile.Add(new ZipEntryStreamSource(doc)' fileName);                        // Commit update every 20 files                      filesAddedToArchive++;                      if ((filesAddedToArchive % 20) == 0)                      {                          // Force a Flush of the archive                          CloseArchive(true);                      }                  }              } else              {                  fileName = OutputPath + Path.DirectorySeparatorChar + fileName;                    if (!File.Exists(fileName))                  {                      Logger.Progress(20 + (counter / 50) % 10' "Fetching C++ documentation ([{0}]) from MSDN"' name);                        doc = GetDocumentationFromMsdn(name);                      File.WriteAllText(fileName' doc);                  }                  else                  {                      doc = File.ReadAllText(fileName);                  }              }
Magic Number,SharpGen.Logging,LoggerBase,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\Logging\LoggerBase.cs,LogException,The following statement contains a magic number: while ((line = reader.ReadLine()) != null)              {                  Match match = regex.Match(line);                  if (match.Success)                  {                      string methodLocation = match.Groups[1].Value;                      string fileName = match.Groups[2].Value;                      int lineNumber;                      int.TryParse(match.Groups[3].Value' out lineNumber);                      Log( LogLevel.Error' new LogLocation(fileName' lineNumber' 1)' methodLocation' "Exception"' null);                  }                  else                  {                      // Escape a line                      Log(LogLevel.Error' logLocation' null' line.Replace("{"' "{{").Replace("}"' "}}")' null);                  }              }
Magic Number,SharpGen.Logging,LoggerBase,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\Logging\LoggerBase.cs,LogException,The following statement contains a magic number: while ((line = reader.ReadLine()) != null)              {                  Match match = regex.Match(line);                  if (match.Success)                  {                      string methodLocation = match.Groups[1].Value;                      string fileName = match.Groups[2].Value;                      int lineNumber;                      int.TryParse(match.Groups[3].Value' out lineNumber);                      Log( LogLevel.Error' new LogLocation(fileName' lineNumber' 1)' methodLocation' "Exception"' null);                  }                  else                  {                      // Escape a line                      Log(LogLevel.Error' logLocation' null' line.Replace("{"' "{{").Replace("}"' "}}")' null);                  }              }
Magic Number,SharpGen.Model,CsEnumItem,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\Model\CsEnumItem.cs,CsEnumItem,The following statement contains a magic number: SizeOf = 4;
Magic Number,SharpGen.Model,CsEnum,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\Model\CsEnum.cs,CsEnum,The following statement contains a magic number: SizeOf = 4;
Magic Number,SharpGen.Model,CsTypeBase,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\Model\CsTypeBase.cs,CalculateAlignment,The following statement contains a magic number: if (Type == typeof(long) || Type == typeof(ulong) || Type == typeof(double))              {                  return 8;              }
Magic Number,SharpGen.Model,CsTypeBase,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\Model\CsTypeBase.cs,CalculateAlignment,The following statement contains a magic number: if (Type == typeof(int) || Type == typeof(uint) ||                  Type == typeof(float))              {                  return 4;              }
Magic Number,SharpGen.Model,CsTypeBase,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\Model\CsTypeBase.cs,CalculateAlignment,The following statement contains a magic number: if (Type == typeof(short) || Type == typeof(ushort) || Type == typeof(char))              {                  return 2;              }
Magic Number,SharpGen.Model,CsTypeBase,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\Model\CsTypeBase.cs,CalculateAlignment,The following statement contains a magic number: return 4;
Magic Number,SharpGen.Generator,EnumTransform,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\Generator\EnumTransform.cs,Process,The following statement contains a magic number: switch (typeName)              {                  case "byte":                      newEnum.Type = typeof(byte);                      newEnum.SizeOf = 1;                      break;                  case "short":                      newEnum.Type = typeof(short);                      newEnum.SizeOf = 1;                      break;                  case "int":                      newEnum.Type = typeof(int);                      newEnum.SizeOf = 4;                      break;                  default:                      Logger.Error("Invalid type [{0}] for enum [{1}]. Types supported are : int' byte' short"' typeName' cppEnum);                      break;              }
Magic Number,SharpGen.Generator,EnumTransform,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\Generator\EnumTransform.cs,Process,The following statement contains a magic number: for (int i = rootName.Length; i >= 4 && !isRootNameFound; i--)              {                  rootNameFound = rootName.Substring(0' i);                    isRootNameFound = true;                  foreach (var cppEnumItem in cppEnum.EnumItems)                  {                      if (!cppEnumItem.Name.StartsWith(rootNameFound))                      {                          isRootNameFound = false;                          break;                      }                  }              }
Magic Number,SharpGen.Generator,TransformManager,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\Generator\TransformManager.cs,Init,The following statement contains a magic number: foreach (var configFile in configFiles)              {                  if (configFile.IsMappingToProcess)                  {                      Logger.Progress(30 + (indexFile*30)/numberOfConfigFilesToParse' "Processing mapping rules [{0}]"' configFile.Assembly ?? configFile.Id);                      ProcessConfigFile(configFile);                      indexFile++;                  }              }
Magic Number,SharpGen.Generator,TransformManager,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\Generator\TransformManager.cs,Init,The following statement contains a magic number: foreach (var configFile in configFiles)              {                  if (configFile.IsMappingToProcess)                  {                      Logger.Progress(30 + (indexFile*30)/numberOfConfigFilesToParse' "Processing mapping rules [{0}]"' configFile.Assembly ?? configFile.Id);                      ProcessConfigFile(configFile);                      indexFile++;                  }              }
Magic Number,SharpGen.Generator,TransformManager,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\Generator\TransformManager.cs,Generate,The following statement contains a magic number: foreach (string templateName in templateNames)              {                  Logger.Progress(85 + (indexToGenerate*15/templateNames.Length)' "Generating code for {0}..."' templateName);                  indexToGenerate++;                    Logger.Message("\nGenerate {0}"' templateName);                  string templateFileName = templateName + ".tt";                    string input = Utilities.GetResourceAsString("Templates." + templateFileName);                    // Sets the template file name                  engine.TemplateFileName =                      Path.GetFullPath(Path.Combine(Path.Combine(Path.GetDirectoryName(GetType().Assembly.Location)' "..\\..\\Templates\\")' templateFileName));                    // Iterates on assemblies                  foreach (var csAssembly in Assemblies)                  {                      if (!csAssembly.IsToUpdate)                          continue;                        engine.SetParameter("Assembly"' csAssembly);                        string generatedDirectoryForAssembly = Path.Combine(csAssembly.RootDirectory' "Generated"' AppType);                        // Remove the generated directory before creating it                      if (!directoryToCreate.Contains(generatedDirectoryForAssembly))                      {                          directoryToCreate.Add(generatedDirectoryForAssembly);                          if (Directory.Exists(generatedDirectoryForAssembly))                          {                              foreach(var oldGeneratedFile in Directory.EnumerateFiles(generatedDirectoryForAssembly' "*.cs"' SearchOption.AllDirectories))                              {                                  try                                  {                                        File.Delete(oldGeneratedFile);                                  }                                  catch (Exception ex)                                  {                                  }                              }                          }                      }                        if (!Directory.Exists(generatedDirectoryForAssembly))                          Directory.CreateDirectory(generatedDirectoryForAssembly);                        Logger.Message("Process Assembly {0} => {1}"' csAssembly.Name' generatedDirectoryForAssembly);                        // LocalInterop is once generated per assembly                      if (templateName == "LocalInterop")                      {                          Logger.Message("\tProcess Interop {0} => {1}"' csAssembly.Name' generatedDirectoryForAssembly);                            //Transform the text template.                          string output = engine.ProcessTemplate(input);                          string outputFileName = Path.GetFileNameWithoutExtension(templateFileName);                            outputFileName = Path.Combine(generatedDirectoryForAssembly' outputFileName);                          outputFileName = outputFileName + ".cs";                          File.WriteAllText(outputFileName' output' Encoding.ASCII);                      }                      else                      {                          // Else' iterates on each namespace                          foreach (var csNamespace in csAssembly.Namespaces)                          {                              engine.SetParameter("Namespace"' csNamespace);                                string subDirectory = csNamespace.OutputDirectory ?? ".";                                string nameSpaceDirectory = generatedDirectoryForAssembly + "\\" + subDirectory;                              if (!Directory.Exists(nameSpaceDirectory))                                  Directory.CreateDirectory(nameSpaceDirectory);                                Logger.Message("\tProcess Namespace {0} => {1}"' csNamespace.Name' nameSpaceDirectory);                                ////host.Session = new TextTemplatingSession();                              //host.Session = host.CreateSession();                                //Transform the text template.                              string output = engine.ProcessTemplate(input);                              string outputFileName = Path.GetFileNameWithoutExtension(templateFileName);                                outputFileName = Path.Combine(nameSpaceDirectory' outputFileName);                              outputFileName = outputFileName + ".cs";                              File.WriteAllText(outputFileName' output' Encoding.ASCII);                          }                      }                  }              }
Magic Number,SharpGen.Generator,TransformManager,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\Generator\TransformManager.cs,Generate,The following statement contains a magic number: foreach (string templateName in templateNames)              {                  Logger.Progress(85 + (indexToGenerate*15/templateNames.Length)' "Generating code for {0}..."' templateName);                  indexToGenerate++;                    Logger.Message("\nGenerate {0}"' templateName);                  string templateFileName = templateName + ".tt";                    string input = Utilities.GetResourceAsString("Templates." + templateFileName);                    // Sets the template file name                  engine.TemplateFileName =                      Path.GetFullPath(Path.Combine(Path.Combine(Path.GetDirectoryName(GetType().Assembly.Location)' "..\\..\\Templates\\")' templateFileName));                    // Iterates on assemblies                  foreach (var csAssembly in Assemblies)                  {                      if (!csAssembly.IsToUpdate)                          continue;                        engine.SetParameter("Assembly"' csAssembly);                        string generatedDirectoryForAssembly = Path.Combine(csAssembly.RootDirectory' "Generated"' AppType);                        // Remove the generated directory before creating it                      if (!directoryToCreate.Contains(generatedDirectoryForAssembly))                      {                          directoryToCreate.Add(generatedDirectoryForAssembly);                          if (Directory.Exists(generatedDirectoryForAssembly))                          {                              foreach(var oldGeneratedFile in Directory.EnumerateFiles(generatedDirectoryForAssembly' "*.cs"' SearchOption.AllDirectories))                              {                                  try                                  {                                        File.Delete(oldGeneratedFile);                                  }                                  catch (Exception ex)                                  {                                  }                              }                          }                      }                        if (!Directory.Exists(generatedDirectoryForAssembly))                          Directory.CreateDirectory(generatedDirectoryForAssembly);                        Logger.Message("Process Assembly {0} => {1}"' csAssembly.Name' generatedDirectoryForAssembly);                        // LocalInterop is once generated per assembly                      if (templateName == "LocalInterop")                      {                          Logger.Message("\tProcess Interop {0} => {1}"' csAssembly.Name' generatedDirectoryForAssembly);                            //Transform the text template.                          string output = engine.ProcessTemplate(input);                          string outputFileName = Path.GetFileNameWithoutExtension(templateFileName);                            outputFileName = Path.Combine(generatedDirectoryForAssembly' outputFileName);                          outputFileName = outputFileName + ".cs";                          File.WriteAllText(outputFileName' output' Encoding.ASCII);                      }                      else                      {                          // Else' iterates on each namespace                          foreach (var csNamespace in csAssembly.Namespaces)                          {                              engine.SetParameter("Namespace"' csNamespace);                                string subDirectory = csNamespace.OutputDirectory ?? ".";                                string nameSpaceDirectory = generatedDirectoryForAssembly + "\\" + subDirectory;                              if (!Directory.Exists(nameSpaceDirectory))                                  Directory.CreateDirectory(nameSpaceDirectory);                                Logger.Message("\tProcess Namespace {0} => {1}"' csNamespace.Name' nameSpaceDirectory);                                ////host.Session = new TextTemplatingSession();                              //host.Session = host.CreateSession();                                //Transform the text template.                              string output = engine.ProcessTemplate(input);                              string outputFileName = Path.GetFileNameWithoutExtension(templateFileName);                                outputFileName = Path.Combine(nameSpaceDirectory' outputFileName);                              outputFileName = outputFileName + ".cs";                              File.WriteAllText(outputFileName' output' Encoding.ASCII);                          }                      }                  }              }
Magic Number,SharpGen.Generator,TransformManager,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\Generator\TransformManager.cs,Transform,The following statement contains a magic number: Logger.Progress(65' "Transforming enums...");
Magic Number,SharpGen.Generator,TransformManager,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\Generator\TransformManager.cs,Transform,The following statement contains a magic number: Logger.Progress(70' "Transforming structs...");
Magic Number,SharpGen.Generator,TransformManager,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\Generator\TransformManager.cs,Transform,The following statement contains a magic number: Logger.Progress(75' "Transforming interfaces...");
Magic Number,SharpGen.Generator,TransformManager,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\Generator\TransformManager.cs,Transform,The following statement contains a magic number: Logger.Progress(80' "Transforming functions...");
Magic Number,SharpGen.Generator,NamingRulesManager,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\Generator\NamingRulesManager.cs,Rename,The following statement contains a magic number: if (hasPointer)              {                  if (oldName.StartsWith("pp"))                      name = name.Substring(2) + "Out";                  else if (oldName.StartsWith("p"))                      name = name.Substring(1) + "Ref";              }
Magic Number,SharpGen.Parser,CastXml,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\Parser\CastXml.cs,ProcessErrorFromHeaderFile,The following statement contains a magic number: try              {                  if (e.Data != null)                  {                        var matchError = matchFileErrorRegex.Match(e.Data);                        bool lineFiltered = false;                      foreach (var filterError in _filterErrors)                      {                          if (filterError.Match(e.Data).Success)                          {                              lineFiltered = true;                              break;                          }                        }                      string errorText = e.Data;                        if (matchError.Success)                      {                          Logger.PushLocation(matchError.Groups[1].Value' int.Parse(matchError.Groups[2].Value)' int.Parse(matchError.Groups[3].Value));                          popContext = true;                          errorText = matchError.Groups[4].Value;                      }                        if (!lineFiltered)                      {                          if (MatchError.Match(e.Data).Success)                              Logger.Error(errorText);                          else                              Logger.Warning(errorText);                      }                      else                      {                          Logger.Warning(errorText);                      }                  }              }              finally              {                  if (popContext)                      Logger.PopLocation();              }
Magic Number,SharpGen.Parser,CastXml,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\Parser\CastXml.cs,ProcessErrorFromHeaderFile,The following statement contains a magic number: try              {                  if (e.Data != null)                  {                        var matchError = matchFileErrorRegex.Match(e.Data);                        bool lineFiltered = false;                      foreach (var filterError in _filterErrors)                      {                          if (filterError.Match(e.Data).Success)                          {                              lineFiltered = true;                              break;                          }                        }                      string errorText = e.Data;                        if (matchError.Success)                      {                          Logger.PushLocation(matchError.Groups[1].Value' int.Parse(matchError.Groups[2].Value)' int.Parse(matchError.Groups[3].Value));                          popContext = true;                          errorText = matchError.Groups[4].Value;                      }                        if (!lineFiltered)                      {                          if (MatchError.Match(e.Data).Success)                              Logger.Error(errorText);                          else                              Logger.Warning(errorText);                      }                      else                      {                          Logger.Warning(errorText);                      }                  }              }              finally              {                  if (popContext)                      Logger.PopLocation();              }
Magic Number,SharpGen.Parser,CastXml,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\Parser\CastXml.cs,ProcessErrorFromHeaderFile,The following statement contains a magic number: try              {                  if (e.Data != null)                  {                        var matchError = matchFileErrorRegex.Match(e.Data);                        bool lineFiltered = false;                      foreach (var filterError in _filterErrors)                      {                          if (filterError.Match(e.Data).Success)                          {                              lineFiltered = true;                              break;                          }                        }                      string errorText = e.Data;                        if (matchError.Success)                      {                          Logger.PushLocation(matchError.Groups[1].Value' int.Parse(matchError.Groups[2].Value)' int.Parse(matchError.Groups[3].Value));                          popContext = true;                          errorText = matchError.Groups[4].Value;                      }                        if (!lineFiltered)                      {                          if (MatchError.Match(e.Data).Success)                              Logger.Error(errorText);                          else                              Logger.Warning(errorText);                      }                      else                      {                          Logger.Warning(errorText);                      }                  }              }              finally              {                  if (popContext)                      Logger.PopLocation();              }
Magic Number,SharpGen.Parser,MacroManager,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\Parser\MacroManager.cs,ParseLine,The following statement contains a magic number: if (!String.IsNullOrEmpty(line))              {                  Match result = MatchIncludeLine.Match(line);                  if (result.Success)                  {                      if (result.Groups[1].Value.StartsWith("<"))                          _currentMacros = null;                      else                      {                          var currentFile = Path.GetFileName(result.Groups[1].Value).ToLower();                          if (!_mapIncludeToMacros.TryGetValue(currentFile' out _currentMacros))                          {                              _currentMacros = new Dictionary<string'string>();                              _mapIncludeToMacros.Add(currentFile' _currentMacros);                          }                      }                  }                  else if (_currentMacros != null)                  {                                          result = MatchDefine.Match(line);                      if (result.Success)                      {                          string value = result.Groups[2].Value.TrimEnd();                          if (!string.IsNullOrEmpty(value))                          {                              _currentMacros.Remove(result.Groups[1].Value);                              _currentMacros.Add(result.Groups[1].Value' value);                          }                      }                  }              }
Magic Number,SharpGen.Parser,CppParser,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\Parser\CppParser.cs,Run,The following statement contains a magic number: if (_isConfigUpdated)              {                  Logger.Message("Config files changed.");                    string progressMessage = "Parsing C++ headers starts' please wait...";                    Logger.Progress(10' progressMessage);                    StreamReader xmlReader = null;                  try                  {                      // TODO Rebuild group                        var macroManager = new MacroManager(_gccxml);                      macroManager.Parse(_configRootHeader' _group);                        // Dump includes                      foreach (var configFile in _configRoot.ConfigFilesLoaded)                      {                          // Dump Create from macros                          if (_filesWithCreateFromMacros.Contains(configFile.Id) && configFile.IsConfigUpdated)                          {                              var extensionWriter = new StreamWriter(configFile.ExtensionFileName);                                foreach (var typeBaseRule in configFile.Extension)                              {                                  if (CheckIfRuleIsCreatingHeadersExtension(typeBaseRule))                                      extensionWriter.Write(CreateCppFromMacro(typeBaseRule));                                  else if (typeBaseRule is ContextRule)                                      HandleContextRule(configFile' (ContextRule) typeBaseRule);                              }                              extensionWriter.Close();                          }                      }                        Logger.Progress(15' progressMessage);                        xmlReader = _gccxml.Process(_configRootHeader);                      if (xmlReader != null)                      {                          Parse(xmlReader);                            // If doc must be generated                          if (IsGeneratingDoc)                              ApplyDocumentation();                      }                        Logger.Progress(30' progressMessage);                        // Save back the C++ parsed includes                      _group.Write(GroupFileName);                  }                  catch (Exception ex)                  {                      Logger.Error("Unexpected error"' ex);                  }                  finally                  {                      if (xmlReader != null)                          xmlReader.Close();                        // Write back GCCXML document on the disk                      if (GccXmlDoc != null)                          GccXmlDoc.Save(GccXmlFileName);                      Logger.Message("Parsing headers is finished.");                  }              }              else              {                  Logger.Progress(10' "Config files unchanged. Read previous C++ parsing...");                  _group = CppModule.Read(GroupFileName);              }
Magic Number,SharpGen.Parser,CppParser,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\Parser\CppParser.cs,Run,The following statement contains a magic number: if (_isConfigUpdated)              {                  Logger.Message("Config files changed.");                    string progressMessage = "Parsing C++ headers starts' please wait...";                    Logger.Progress(10' progressMessage);                    StreamReader xmlReader = null;                  try                  {                      // TODO Rebuild group                        var macroManager = new MacroManager(_gccxml);                      macroManager.Parse(_configRootHeader' _group);                        // Dump includes                      foreach (var configFile in _configRoot.ConfigFilesLoaded)                      {                          // Dump Create from macros                          if (_filesWithCreateFromMacros.Contains(configFile.Id) && configFile.IsConfigUpdated)                          {                              var extensionWriter = new StreamWriter(configFile.ExtensionFileName);                                foreach (var typeBaseRule in configFile.Extension)                              {                                  if (CheckIfRuleIsCreatingHeadersExtension(typeBaseRule))                                      extensionWriter.Write(CreateCppFromMacro(typeBaseRule));                                  else if (typeBaseRule is ContextRule)                                      HandleContextRule(configFile' (ContextRule) typeBaseRule);                              }                              extensionWriter.Close();                          }                      }                        Logger.Progress(15' progressMessage);                        xmlReader = _gccxml.Process(_configRootHeader);                      if (xmlReader != null)                      {                          Parse(xmlReader);                            // If doc must be generated                          if (IsGeneratingDoc)                              ApplyDocumentation();                      }                        Logger.Progress(30' progressMessage);                        // Save back the C++ parsed includes                      _group.Write(GroupFileName);                  }                  catch (Exception ex)                  {                      Logger.Error("Unexpected error"' ex);                  }                  finally                  {                      if (xmlReader != null)                          xmlReader.Close();                        // Write back GCCXML document on the disk                      if (GccXmlDoc != null)                          GccXmlDoc.Save(GccXmlFileName);                      Logger.Message("Parsing headers is finished.");                  }              }              else              {                  Logger.Progress(10' "Config files unchanged. Read previous C++ parsing...");                  _group = CppModule.Read(GroupFileName);              }
Magic Number,SharpGen.Parser,CppParser,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\Parser\CppParser.cs,Run,The following statement contains a magic number: if (_isConfigUpdated)              {                  Logger.Message("Config files changed.");                    string progressMessage = "Parsing C++ headers starts' please wait...";                    Logger.Progress(10' progressMessage);                    StreamReader xmlReader = null;                  try                  {                      // TODO Rebuild group                        var macroManager = new MacroManager(_gccxml);                      macroManager.Parse(_configRootHeader' _group);                        // Dump includes                      foreach (var configFile in _configRoot.ConfigFilesLoaded)                      {                          // Dump Create from macros                          if (_filesWithCreateFromMacros.Contains(configFile.Id) && configFile.IsConfigUpdated)                          {                              var extensionWriter = new StreamWriter(configFile.ExtensionFileName);                                foreach (var typeBaseRule in configFile.Extension)                              {                                  if (CheckIfRuleIsCreatingHeadersExtension(typeBaseRule))                                      extensionWriter.Write(CreateCppFromMacro(typeBaseRule));                                  else if (typeBaseRule is ContextRule)                                      HandleContextRule(configFile' (ContextRule) typeBaseRule);                              }                              extensionWriter.Close();                          }                      }                        Logger.Progress(15' progressMessage);                        xmlReader = _gccxml.Process(_configRootHeader);                      if (xmlReader != null)                      {                          Parse(xmlReader);                            // If doc must be generated                          if (IsGeneratingDoc)                              ApplyDocumentation();                      }                        Logger.Progress(30' progressMessage);                        // Save back the C++ parsed includes                      _group.Write(GroupFileName);                  }                  catch (Exception ex)                  {                      Logger.Error("Unexpected error"' ex);                  }                  finally                  {                      if (xmlReader != null)                          xmlReader.Close();                        // Write back GCCXML document on the disk                      if (GccXmlDoc != null)                          GccXmlDoc.Save(GccXmlFileName);                      Logger.Message("Parsing headers is finished.");                  }              }              else              {                  Logger.Progress(10' "Config files unchanged. Read previous C++ parsing...");                  _group = CppModule.Read(GroupFileName);              }
Magic Number,SharpGen.Parser,CppParser,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\Parser\CppParser.cs,Run,The following statement contains a magic number: if (_isConfigUpdated)              {                  Logger.Message("Config files changed.");                    string progressMessage = "Parsing C++ headers starts' please wait...";                    Logger.Progress(10' progressMessage);                    StreamReader xmlReader = null;                  try                  {                      // TODO Rebuild group                        var macroManager = new MacroManager(_gccxml);                      macroManager.Parse(_configRootHeader' _group);                        // Dump includes                      foreach (var configFile in _configRoot.ConfigFilesLoaded)                      {                          // Dump Create from macros                          if (_filesWithCreateFromMacros.Contains(configFile.Id) && configFile.IsConfigUpdated)                          {                              var extensionWriter = new StreamWriter(configFile.ExtensionFileName);                                foreach (var typeBaseRule in configFile.Extension)                              {                                  if (CheckIfRuleIsCreatingHeadersExtension(typeBaseRule))                                      extensionWriter.Write(CreateCppFromMacro(typeBaseRule));                                  else if (typeBaseRule is ContextRule)                                      HandleContextRule(configFile' (ContextRule) typeBaseRule);                              }                              extensionWriter.Close();                          }                      }                        Logger.Progress(15' progressMessage);                        xmlReader = _gccxml.Process(_configRootHeader);                      if (xmlReader != null)                      {                          Parse(xmlReader);                            // If doc must be generated                          if (IsGeneratingDoc)                              ApplyDocumentation();                      }                        Logger.Progress(30' progressMessage);                        // Save back the C++ parsed includes                      _group.Write(GroupFileName);                  }                  catch (Exception ex)                  {                      Logger.Error("Unexpected error"' ex);                  }                  finally                  {                      if (xmlReader != null)                          xmlReader.Close();                        // Write back GCCXML document on the disk                      if (GccXmlDoc != null)                          GccXmlDoc.Save(GccXmlFileName);                      Logger.Message("Parsing headers is finished.");                  }              }              else              {                  Logger.Progress(10' "Config files unchanged. Read previous C++ parsing...");                  _group = CppModule.Read(GroupFileName);              }
Magic Number,SharpGen.Parser,CppParser,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\Parser\CppParser.cs,ParseStructOrUnion,The following statement contains a magic number: cppStruct.Align = int.Parse(xElement.AttributeValue("align"))/8;
Magic Number,SharpGen.Parser,CppParser,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\Parser\CppParser.cs,ParseStructOrUnion,The following statement contains a magic number: if (cppStruct.Align == 4)                  cppStruct.Align = 0;
Magic Number,SharpGen.Parser,CppParser,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\Parser\CppParser.cs,ParseGuid,The following statement contains a magic number: if (guidElements.Length != 11)                  return null;
Magic Number,SharpGen.Parser,CppParser,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\Parser\CppParser.cs,ParseGuid,The following statement contains a magic number: return new Guid(values[0]' (short)values[1]' (short)values[2]' (byte)values[3]' (byte)values[4]' (byte)values[5]' (byte)values[6]' (byte)values[7]'                       (byte)values[8]' (byte)values[9]' (byte)values[10]);
Magic Number,SharpGen.Parser,CppParser,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\Parser\CppParser.cs,ParseGuid,The following statement contains a magic number: return new Guid(values[0]' (short)values[1]' (short)values[2]' (byte)values[3]' (byte)values[4]' (byte)values[5]' (byte)values[6]' (byte)values[7]'                       (byte)values[8]' (byte)values[9]' (byte)values[10]);
Magic Number,SharpGen.Parser,CppParser,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\Parser\CppParser.cs,ParseGuid,The following statement contains a magic number: return new Guid(values[0]' (short)values[1]' (short)values[2]' (byte)values[3]' (byte)values[4]' (byte)values[5]' (byte)values[6]' (byte)values[7]'                       (byte)values[8]' (byte)values[9]' (byte)values[10]);
Magic Number,SharpGen.Parser,CppParser,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\Parser\CppParser.cs,ParseGuid,The following statement contains a magic number: return new Guid(values[0]' (short)values[1]' (short)values[2]' (byte)values[3]' (byte)values[4]' (byte)values[5]' (byte)values[6]' (byte)values[7]'                       (byte)values[8]' (byte)values[9]' (byte)values[10]);
Magic Number,SharpGen.Parser,CppParser,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\Parser\CppParser.cs,ParseGuid,The following statement contains a magic number: return new Guid(values[0]' (short)values[1]' (short)values[2]' (byte)values[3]' (byte)values[4]' (byte)values[5]' (byte)values[6]' (byte)values[7]'                       (byte)values[8]' (byte)values[9]' (byte)values[10]);
Magic Number,SharpGen.Parser,CppParser,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\Parser\CppParser.cs,ParseGuid,The following statement contains a magic number: return new Guid(values[0]' (short)values[1]' (short)values[2]' (byte)values[3]' (byte)values[4]' (byte)values[5]' (byte)values[6]' (byte)values[7]'                       (byte)values[8]' (byte)values[9]' (byte)values[10]);
Magic Number,SharpGen.Parser,CppParser,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\Parser\CppParser.cs,ParseGuid,The following statement contains a magic number: return new Guid(values[0]' (short)values[1]' (short)values[2]' (byte)values[3]' (byte)values[4]' (byte)values[5]' (byte)values[6]' (byte)values[7]'                       (byte)values[8]' (byte)values[9]' (byte)values[10]);
Magic Number,SharpGen.Parser,CppParser,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\Parser\CppParser.cs,ParseGuid,The following statement contains a magic number: return new Guid(values[0]' (short)values[1]' (short)values[2]' (byte)values[3]' (byte)values[4]' (byte)values[5]' (byte)values[6]' (byte)values[7]'                       (byte)values[8]' (byte)values[9]' (byte)values[10]);
Magic Number,SharpGen.Parser,CppParser,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\Parser\CppParser.cs,ParseGuid,The following statement contains a magic number: return new Guid(values[0]' (short)values[1]' (short)values[2]' (byte)values[3]' (byte)values[4]' (byte)values[5]' (byte)values[6]' (byte)values[7]'                       (byte)values[8]' (byte)values[9]' (byte)values[10]);
Magic Number,SharpGen.Parser,CppParser,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\Parser\CppParser.cs,ConvertFundamentalType,The following statement contains a magic number: if (longCount == 2)                  outputType = "longlong";
Magic Number,SharpGen.Parser,CppParser,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\Parser\CppParser.cs,ApplyDocumentation,The following statement contains a magic number: Logger.Progress(20' "Applying C++ documentation");
Magic Number,SharpGen.TextTemplating,Tokeniser,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\TextTemplating\Tokenizer.cs,GetBlockEnd,The following statement contains a magic number: for (; position < content.Length; position++)              {                  char c = content[position];                  nextStateTagStartLocation = nextStateLocation;                  nextStateLocation = nextStateLocation.AddCol();                  if (c == '\r')                  {                      if (position + 1 < content.Length && content[position + 1] == '\n')                          position++;                      nextStateLocation = nextStateLocation.AddLine();                  }                  else if (c == '\n')                  {                      nextStateLocation = nextStateLocation.AddLine();                  }                  else if (c == '>' && content[position - 1] == '#' && content[position - 2] != '\\')                  {                      value = content.Substring(start' position - start - 1);                      position++;                      TagEndLocation = nextStateLocation;                        //skip newlines directly after blocks' unless they're expressions                      if (State != State.Expression && (position += IsNewLine()) > 0)                      {                          nextStateLocation = nextStateLocation.AddLine();                      }                      return State.Content;                  }              }
Magic Number,SharpGen.TextTemplating,Tokeniser,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\TextTemplating\Tokenizer.cs,NextStateInContent,The following statement contains a magic number: for (; position < content.Length; position++)              {                  char c = content[position];                  nextStateTagStartLocation = nextStateLocation;                  nextStateLocation = nextStateLocation.AddCol();                  if (c == '\r')                  {                      if (position + 1 < content.Length && content[position + 1] == '\n')                          position++;                      nextStateLocation = nextStateLocation.AddLine();                  }                  else if (c == '\n')                  {                      nextStateLocation = nextStateLocation.AddLine();                  }                  else if (c == '<' && position + 2 < content.Length && content[position + 1] == '#')                  {                      TagEndLocation = nextStateLocation;                      char type = content[position + 2];                      if (type == '@')                      {                          nextStateLocation = nextStateLocation.AddCols(2);                          value = content.Substring(start' position - start);                          position += 3;                          return State.Directive;                      }                      else if (type == '=')                      {                          nextStateLocation = nextStateLocation.AddCols(2);                          value = content.Substring(start' position - start);                          position += 3;                          return State.Expression;                      }                      else if (type == '+')                      {                          nextStateLocation = nextStateLocation.AddCols(2);                          value = content.Substring(start' position - start);                          position += 3;                          return State.Helper;                      }                      else                      {                          value = content.Substring(start' position - start);                          nextStateLocation = nextStateLocation.AddCol();                          position += 2;                          return State.Block;                      }                  }              }
Magic Number,SharpGen.TextTemplating,Tokeniser,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\TextTemplating\Tokenizer.cs,NextStateInContent,The following statement contains a magic number: for (; position < content.Length; position++)              {                  char c = content[position];                  nextStateTagStartLocation = nextStateLocation;                  nextStateLocation = nextStateLocation.AddCol();                  if (c == '\r')                  {                      if (position + 1 < content.Length && content[position + 1] == '\n')                          position++;                      nextStateLocation = nextStateLocation.AddLine();                  }                  else if (c == '\n')                  {                      nextStateLocation = nextStateLocation.AddLine();                  }                  else if (c == '<' && position + 2 < content.Length && content[position + 1] == '#')                  {                      TagEndLocation = nextStateLocation;                      char type = content[position + 2];                      if (type == '@')                      {                          nextStateLocation = nextStateLocation.AddCols(2);                          value = content.Substring(start' position - start);                          position += 3;                          return State.Directive;                      }                      else if (type == '=')                      {                          nextStateLocation = nextStateLocation.AddCols(2);                          value = content.Substring(start' position - start);                          position += 3;                          return State.Expression;                      }                      else if (type == '+')                      {                          nextStateLocation = nextStateLocation.AddCols(2);                          value = content.Substring(start' position - start);                          position += 3;                          return State.Helper;                      }                      else                      {                          value = content.Substring(start' position - start);                          nextStateLocation = nextStateLocation.AddCol();                          position += 2;                          return State.Block;                      }                  }              }
Magic Number,SharpGen.TextTemplating,Tokeniser,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\TextTemplating\Tokenizer.cs,NextStateInContent,The following statement contains a magic number: for (; position < content.Length; position++)              {                  char c = content[position];                  nextStateTagStartLocation = nextStateLocation;                  nextStateLocation = nextStateLocation.AddCol();                  if (c == '\r')                  {                      if (position + 1 < content.Length && content[position + 1] == '\n')                          position++;                      nextStateLocation = nextStateLocation.AddLine();                  }                  else if (c == '\n')                  {                      nextStateLocation = nextStateLocation.AddLine();                  }                  else if (c == '<' && position + 2 < content.Length && content[position + 1] == '#')                  {                      TagEndLocation = nextStateLocation;                      char type = content[position + 2];                      if (type == '@')                      {                          nextStateLocation = nextStateLocation.AddCols(2);                          value = content.Substring(start' position - start);                          position += 3;                          return State.Directive;                      }                      else if (type == '=')                      {                          nextStateLocation = nextStateLocation.AddCols(2);                          value = content.Substring(start' position - start);                          position += 3;                          return State.Expression;                      }                      else if (type == '+')                      {                          nextStateLocation = nextStateLocation.AddCols(2);                          value = content.Substring(start' position - start);                          position += 3;                          return State.Helper;                      }                      else                      {                          value = content.Substring(start' position - start);                          nextStateLocation = nextStateLocation.AddCol();                          position += 2;                          return State.Block;                      }                  }              }
Magic Number,SharpGen.TextTemplating,Tokeniser,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\TextTemplating\Tokenizer.cs,NextStateInContent,The following statement contains a magic number: for (; position < content.Length; position++)              {                  char c = content[position];                  nextStateTagStartLocation = nextStateLocation;                  nextStateLocation = nextStateLocation.AddCol();                  if (c == '\r')                  {                      if (position + 1 < content.Length && content[position + 1] == '\n')                          position++;                      nextStateLocation = nextStateLocation.AddLine();                  }                  else if (c == '\n')                  {                      nextStateLocation = nextStateLocation.AddLine();                  }                  else if (c == '<' && position + 2 < content.Length && content[position + 1] == '#')                  {                      TagEndLocation = nextStateLocation;                      char type = content[position + 2];                      if (type == '@')                      {                          nextStateLocation = nextStateLocation.AddCols(2);                          value = content.Substring(start' position - start);                          position += 3;                          return State.Directive;                      }                      else if (type == '=')                      {                          nextStateLocation = nextStateLocation.AddCols(2);                          value = content.Substring(start' position - start);                          position += 3;                          return State.Expression;                      }                      else if (type == '+')                      {                          nextStateLocation = nextStateLocation.AddCols(2);                          value = content.Substring(start' position - start);                          position += 3;                          return State.Helper;                      }                      else                      {                          value = content.Substring(start' position - start);                          nextStateLocation = nextStateLocation.AddCol();                          position += 2;                          return State.Block;                      }                  }              }
Magic Number,SharpGen.TextTemplating,Tokeniser,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\TextTemplating\Tokenizer.cs,NextStateInContent,The following statement contains a magic number: for (; position < content.Length; position++)              {                  char c = content[position];                  nextStateTagStartLocation = nextStateLocation;                  nextStateLocation = nextStateLocation.AddCol();                  if (c == '\r')                  {                      if (position + 1 < content.Length && content[position + 1] == '\n')                          position++;                      nextStateLocation = nextStateLocation.AddLine();                  }                  else if (c == '\n')                  {                      nextStateLocation = nextStateLocation.AddLine();                  }                  else if (c == '<' && position + 2 < content.Length && content[position + 1] == '#')                  {                      TagEndLocation = nextStateLocation;                      char type = content[position + 2];                      if (type == '@')                      {                          nextStateLocation = nextStateLocation.AddCols(2);                          value = content.Substring(start' position - start);                          position += 3;                          return State.Directive;                      }                      else if (type == '=')                      {                          nextStateLocation = nextStateLocation.AddCols(2);                          value = content.Substring(start' position - start);                          position += 3;                          return State.Expression;                      }                      else if (type == '+')                      {                          nextStateLocation = nextStateLocation.AddCols(2);                          value = content.Substring(start' position - start);                          position += 3;                          return State.Helper;                      }                      else                      {                          value = content.Substring(start' position - start);                          nextStateLocation = nextStateLocation.AddCol();                          position += 2;                          return State.Block;                      }                  }              }
Magic Number,SharpGen.TextTemplating,Tokeniser,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\TextTemplating\Tokenizer.cs,NextStateInContent,The following statement contains a magic number: for (; position < content.Length; position++)              {                  char c = content[position];                  nextStateTagStartLocation = nextStateLocation;                  nextStateLocation = nextStateLocation.AddCol();                  if (c == '\r')                  {                      if (position + 1 < content.Length && content[position + 1] == '\n')                          position++;                      nextStateLocation = nextStateLocation.AddLine();                  }                  else if (c == '\n')                  {                      nextStateLocation = nextStateLocation.AddLine();                  }                  else if (c == '<' && position + 2 < content.Length && content[position + 1] == '#')                  {                      TagEndLocation = nextStateLocation;                      char type = content[position + 2];                      if (type == '@')                      {                          nextStateLocation = nextStateLocation.AddCols(2);                          value = content.Substring(start' position - start);                          position += 3;                          return State.Directive;                      }                      else if (type == '=')                      {                          nextStateLocation = nextStateLocation.AddCols(2);                          value = content.Substring(start' position - start);                          position += 3;                          return State.Expression;                      }                      else if (type == '+')                      {                          nextStateLocation = nextStateLocation.AddCols(2);                          value = content.Substring(start' position - start);                          position += 3;                          return State.Helper;                      }                      else                      {                          value = content.Substring(start' position - start);                          nextStateLocation = nextStateLocation.AddCol();                          position += 2;                          return State.Block;                      }                  }              }
Magic Number,SharpGen.TextTemplating,Tokeniser,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\TextTemplating\Tokenizer.cs,NextStateInContent,The following statement contains a magic number: for (; position < content.Length; position++)              {                  char c = content[position];                  nextStateTagStartLocation = nextStateLocation;                  nextStateLocation = nextStateLocation.AddCol();                  if (c == '\r')                  {                      if (position + 1 < content.Length && content[position + 1] == '\n')                          position++;                      nextStateLocation = nextStateLocation.AddLine();                  }                  else if (c == '\n')                  {                      nextStateLocation = nextStateLocation.AddLine();                  }                  else if (c == '<' && position + 2 < content.Length && content[position + 1] == '#')                  {                      TagEndLocation = nextStateLocation;                      char type = content[position + 2];                      if (type == '@')                      {                          nextStateLocation = nextStateLocation.AddCols(2);                          value = content.Substring(start' position - start);                          position += 3;                          return State.Directive;                      }                      else if (type == '=')                      {                          nextStateLocation = nextStateLocation.AddCols(2);                          value = content.Substring(start' position - start);                          position += 3;                          return State.Expression;                      }                      else if (type == '+')                      {                          nextStateLocation = nextStateLocation.AddCols(2);                          value = content.Substring(start' position - start);                          position += 3;                          return State.Helper;                      }                      else                      {                          value = content.Substring(start' position - start);                          nextStateLocation = nextStateLocation.AddCol();                          position += 2;                          return State.Block;                      }                  }              }
Magic Number,SharpGen.TextTemplating,Tokeniser,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\TextTemplating\Tokenizer.cs,NextStateInContent,The following statement contains a magic number: for (; position < content.Length; position++)              {                  char c = content[position];                  nextStateTagStartLocation = nextStateLocation;                  nextStateLocation = nextStateLocation.AddCol();                  if (c == '\r')                  {                      if (position + 1 < content.Length && content[position + 1] == '\n')                          position++;                      nextStateLocation = nextStateLocation.AddLine();                  }                  else if (c == '\n')                  {                      nextStateLocation = nextStateLocation.AddLine();                  }                  else if (c == '<' && position + 2 < content.Length && content[position + 1] == '#')                  {                      TagEndLocation = nextStateLocation;                      char type = content[position + 2];                      if (type == '@')                      {                          nextStateLocation = nextStateLocation.AddCols(2);                          value = content.Substring(start' position - start);                          position += 3;                          return State.Directive;                      }                      else if (type == '=')                      {                          nextStateLocation = nextStateLocation.AddCols(2);                          value = content.Substring(start' position - start);                          position += 3;                          return State.Expression;                      }                      else if (type == '+')                      {                          nextStateLocation = nextStateLocation.AddCols(2);                          value = content.Substring(start' position - start);                          position += 3;                          return State.Helper;                      }                      else                      {                          value = content.Substring(start' position - start);                          nextStateLocation = nextStateLocation.AddCol();                          position += 2;                          return State.Block;                      }                  }              }
Magic Number,SharpGen.TextTemplating,Tokeniser,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\TextTemplating\Tokenizer.cs,NextStateInContent,The following statement contains a magic number: for (; position < content.Length; position++)              {                  char c = content[position];                  nextStateTagStartLocation = nextStateLocation;                  nextStateLocation = nextStateLocation.AddCol();                  if (c == '\r')                  {                      if (position + 1 < content.Length && content[position + 1] == '\n')                          position++;                      nextStateLocation = nextStateLocation.AddLine();                  }                  else if (c == '\n')                  {                      nextStateLocation = nextStateLocation.AddLine();                  }                  else if (c == '<' && position + 2 < content.Length && content[position + 1] == '#')                  {                      TagEndLocation = nextStateLocation;                      char type = content[position + 2];                      if (type == '@')                      {                          nextStateLocation = nextStateLocation.AddCols(2);                          value = content.Substring(start' position - start);                          position += 3;                          return State.Directive;                      }                      else if (type == '=')                      {                          nextStateLocation = nextStateLocation.AddCols(2);                          value = content.Substring(start' position - start);                          position += 3;                          return State.Expression;                      }                      else if (type == '+')                      {                          nextStateLocation = nextStateLocation.AddCols(2);                          value = content.Substring(start' position - start);                          position += 3;                          return State.Helper;                      }                      else                      {                          value = content.Substring(start' position - start);                          nextStateLocation = nextStateLocation.AddCol();                          position += 2;                          return State.Block;                      }                  }              }
Magic Number,SharpGen.TextTemplating,Tokeniser,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\TextTemplating\Tokenizer.cs,NextStateInDirective,The following statement contains a magic number: for (; position < content.Length; position++)              {                  char c = content[position];                  if (c == '\r')                  {                      if (position + 1 < content.Length && content[position + 1] == '\n')                          position++;                      nextStateLocation = nextStateLocation.AddLine();                  }                  else if (c == '\n')                  {                      nextStateLocation = nextStateLocation.AddLine();                  }                  else if (Char.IsLetter(c))                  {                      return State.DirectiveName;                  }                  else if (c == '=')                  {                      nextStateLocation = nextStateLocation.AddCol();                      position++;                      return State.DirectiveValue;                  }                  else if (c == '#' && position + 1 < content.Length && content[position + 1] == '>')                  {                      position += 2;                      TagEndLocation = nextStateLocation.AddCols(2);                      nextStateLocation = nextStateLocation.AddCols(3);                        //skip newlines directly after directives                      if ((position += IsNewLine()) > 0)                      {                          nextStateLocation = nextStateLocation.AddLine();                      }                        return State.Content;                  }                  else if (!Char.IsWhiteSpace(c))                  {                      throw new ParserException("Directive ended unexpectedly with character '" + c + "'"' nextStateLocation);                  }                  else                  {                      nextStateLocation = nextStateLocation.AddCol();                  }              }
Magic Number,SharpGen.TextTemplating,Tokeniser,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\TextTemplating\Tokenizer.cs,NextStateInDirective,The following statement contains a magic number: for (; position < content.Length; position++)              {                  char c = content[position];                  if (c == '\r')                  {                      if (position + 1 < content.Length && content[position + 1] == '\n')                          position++;                      nextStateLocation = nextStateLocation.AddLine();                  }                  else if (c == '\n')                  {                      nextStateLocation = nextStateLocation.AddLine();                  }                  else if (Char.IsLetter(c))                  {                      return State.DirectiveName;                  }                  else if (c == '=')                  {                      nextStateLocation = nextStateLocation.AddCol();                      position++;                      return State.DirectiveValue;                  }                  else if (c == '#' && position + 1 < content.Length && content[position + 1] == '>')                  {                      position += 2;                      TagEndLocation = nextStateLocation.AddCols(2);                      nextStateLocation = nextStateLocation.AddCols(3);                        //skip newlines directly after directives                      if ((position += IsNewLine()) > 0)                      {                          nextStateLocation = nextStateLocation.AddLine();                      }                        return State.Content;                  }                  else if (!Char.IsWhiteSpace(c))                  {                      throw new ParserException("Directive ended unexpectedly with character '" + c + "'"' nextStateLocation);                  }                  else                  {                      nextStateLocation = nextStateLocation.AddCol();                  }              }
Magic Number,SharpGen.TextTemplating,Tokeniser,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\TextTemplating\Tokenizer.cs,NextStateInDirective,The following statement contains a magic number: for (; position < content.Length; position++)              {                  char c = content[position];                  if (c == '\r')                  {                      if (position + 1 < content.Length && content[position + 1] == '\n')                          position++;                      nextStateLocation = nextStateLocation.AddLine();                  }                  else if (c == '\n')                  {                      nextStateLocation = nextStateLocation.AddLine();                  }                  else if (Char.IsLetter(c))                  {                      return State.DirectiveName;                  }                  else if (c == '=')                  {                      nextStateLocation = nextStateLocation.AddCol();                      position++;                      return State.DirectiveValue;                  }                  else if (c == '#' && position + 1 < content.Length && content[position + 1] == '>')                  {                      position += 2;                      TagEndLocation = nextStateLocation.AddCols(2);                      nextStateLocation = nextStateLocation.AddCols(3);                        //skip newlines directly after directives                      if ((position += IsNewLine()) > 0)                      {                          nextStateLocation = nextStateLocation.AddLine();                      }                        return State.Content;                  }                  else if (!Char.IsWhiteSpace(c))                  {                      throw new ParserException("Directive ended unexpectedly with character '" + c + "'"' nextStateLocation);                  }                  else                  {                      nextStateLocation = nextStateLocation.AddCol();                  }              }
Magic Number,SharpGen.Bing,NewsRequest,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\Service References\Bing\Reference.cs,NewsRequest,The following statement contains a magic number: this.countField = ((uint)(10));
Missing Default,SharpGen.Generator,TransformManager,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\Generator\TransformManager.cs,GetCsType,The following switch statement is missing a default case: switch (typeName)                  {                      case "char":                          publicType = ImportType(typeof (string));                          marshalType = ImportType(typeof (IntPtr));                          break;                      case "wchar_t":                          publicType = ImportType(typeof (string));                          marshalType = ImportType(typeof (IntPtr));                          interopType.IsWideChar = true;                          break;                  }
Missing Default,SharpGen.Parser,CastXml,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\Parser\CastXml.cs,GetIncludePaths,The following switch statement is missing a default case: switch (hiveStr)                          {                              case "HKEY_LOCAL_MACHINE":                                  hive = RegistryHive.LocalMachine;                                  break;                              case "HKEY_CURRENT_USER":                                  hive = RegistryHive.CurrentUser;                                  break;                              case "HKEY_CURRENT_CONFIG":                                  hive = RegistryHive.CurrentConfig;                                  break;                          }
Missing Default,SharpGen.Parser,CppParser,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\Parser\CppParser.cs,Parse,The following switch statement is missing a default case: switch (xStruct.Name.LocalName)                      {                          case CastXml.TagStruct:                          case CastXml.TagUnion:                          case CastXml.TagEnumeration:                              string structName = xStruct.AttributeValue("name");                              // Rename all structure starting with tagXXXX to XXXX                              //if (structName.Length > 4 && structName.StartsWith("tag") && Char.IsUpper(structName[3]))                              //    structName = structName.Substring(3);                                if (structName.StartsWith("tag") || structName.StartsWith("_") || string.IsNullOrEmpty(structName))                              {                                  var typeName = xTypedef.AttributeValue("name");                                  xStruct.SetAttributeValue("name"' typeName);                                  //Logger.Message("Use typedef to rename [{0}] to [{1}]"' structName' typeName);                              }                              break;                      }
Missing Default,SharpGen.Parser,CppParser,C:\repos\sharpdx_SharpDX\Source\Tools\SharpGen\Parser\CppParser.cs,ParseAllElements,The following switch statement is missing a default case: switch (name)                      {                          case CastXml.TagEnumeration:                              cppElement = ParseEnum(xElement);                              break;                          case CastXml.TagFunction:                              // TODO: Find btter criteria for exclusion. In CastXML extern="1" only indicates an explicit external storage modifier.                              // For now' exlude inline functions instead; may not be sensible since by default all functions have external linkage.                              if (xElement.AttributeValue("inline") == null)                                  cppElement = ParseFunction(xElement);                              break;                          case CastXml.TagStruct:                              if (xElement.AttributeValue("abstract") != null)                                  cppElement = ParseInterface(xElement);                              else                                  cppElement = ParseStructOrUnion(xElement);                              break;                          case CastXml.TagUnion:                              cppElement = ParseStructOrUnion(xElement);                              break;                          case CastXml.TagVariable:                              if (xElement.AttributeValue("init") != null)                                  cppElement = ParseVariable(xElement);                              break;                      }
