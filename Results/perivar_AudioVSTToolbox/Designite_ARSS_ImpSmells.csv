Implementation smell,Namespace,Class,File,Method,Description
Long Method,ARSS,Arss,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\Arss.cs,SettingsInput,The method has 260 lines of code.
Long Method,ARSS,Arss,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\Arss.cs,Main,The method has 350 lines of code.
Long Method,ARSS,DSP,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\DSP.cs,Analyze,The method has 144 lines of code.
Long Method,ARSS,DSP,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\DSP.cs,SynthesizeNoise,The method has 115 lines of code.
Complex Method,ARSS,Arss,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\Arss.cs,SettingsInput,Cyclomatic complexity of the method is 45
Complex Method,ARSS,Arss,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\Arss.cs,Main,Cyclomatic complexity of the method is 18
Complex Method,ARSS,DSP,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\DSP.cs,Analyze,Cyclomatic complexity of the method is 15
Complex Method,ARSS,DSP,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\DSP.cs,SynthesizeNoise,Cyclomatic complexity of the method is 11
Complex Method,ARSS,ImageIO,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\ImageIO.cs,BMPRead,Cyclomatic complexity of the method is 8
Complex Method,ARSS,ImageIO,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\ImageIO.cs,BMPWrite,Cyclomatic complexity of the method is 8
Complex Method,ARSS,SoundIO,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\SoundIO.cs,ReadWaveFile,Cyclomatic complexity of the method is 12
Complex Method,ARSS,SoundIO,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\SoundIO.cs,WriteWaveFile,Cyclomatic complexity of the method is 8
Long Parameter List,ARSS,Arss,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\Arss.cs,SettingsInput,The method has 9 parameters. Parameters: bands' samplecount' samplerate' basefreq' maxfreq' pixpersec' bandsperoctave' Xsize' mode
Long Parameter List,ARSS,DSP,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\DSP.cs,BlackmanSquareInterpolation,The method has 6 parameters. Parameters: in' out' inputLength' outputLength' lut' lut_size
Long Parameter List,ARSS,DSP,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\DSP.cs,Analyze,The method has 8 parameters. Parameters: s' samplecount' samplerate' Xsize' bands' bandsperoctave' pixpersec' minFreq
Long Parameter List,ARSS,DSP,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\DSP.cs,SynthesizeSine,The method has 8 parameters. Parameters: d' Xsize' bands' samplecount' samplerate' minFreq' pixpersec' bpo
Long Parameter List,ARSS,DSP,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\DSP.cs,SynthesizeNoise,The method has 8 parameters. Parameters: d' Xsize' bands' samplecount' samplerate' minFreq' pixpersec' bpo
Long Parameter List,ARSS,SoundIO,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\SoundIO.cs,WriteWaveFile,The method has 6 parameters. Parameters: wavfile' sound' channels' samplecount' samplerate' format_param
Long Parameter List,ArssSpectrogram,Filterbank,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\ArssSpectrogram\Filterbank.cs,GetFilterbank,The method has 5 parameters. Parameters: type' scale' base' bandwidth' overlap
Long Statement,ARSS,Arss,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\Arss.cs,SettingsInput,The length of the statement  "					Console.Error.WriteLine("Please provide a sample rate for your output sound.\nUse --sample-rate (-r).\nExiting with error.\n"); " is 127.
Long Statement,ARSS,Arss,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\Arss.cs,SettingsInput,The length of the statement  "					Console.Error.WriteLine("You have set one parameter too many.\nUnset either --min-freq (-min)' --max-freq (-max)' --bpo (-b)\nExiting with error.\n"); " is 150.
Long Statement,ARSS,Arss,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\Arss.cs,SettingsInput,The length of the statement  "					Console.Error.WriteLine("You have set one parameter too many.\nUnset either --min-freq (-min)' --max-freq (-max)' --bpo (-b) or --height (-y)\nExiting with error.\n"); " is 167.
Long Statement,ARSS,Arss,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\Arss.cs,SettingsInput,The length of the statement  "				Console.Error.WriteLine("You cannot define both the image width and the horizontal resolution.\nUnset either --pps (-p) or --width (-x)\nExiting with error.\n"); " is 161.
Long Statement,ARSS,Arss,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\Arss.cs,SettingsInput,The length of the statement  "				maxfreq = Math.Pow(DSP.LOGBASE' (bands-1) / bandsperoctave) * (basefreq * samplerate); // calculate the upper frequency in Hz " is 125.
Long Statement,ARSS,Arss,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\Arss.cs,PrintHelp,The length of the statement  "			              + "--format-param' -f [integer]  Output format option. This is bit-depth for WAV files (8/16/32' default: 32). No option for BMP files.\n"); " is 140.
Long Statement,ARSS,Arss,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\Arss.cs,Main,The length of the statement  "						Console.Error.WriteLine("You can only have two file names as parameters.\nRemove parameter \"%s\".\nExiting with error.\n"' args[i]); " is 133.
Long Statement,ARSS,Arss,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\Arss.cs,Main,The length of the statement  "					Console.Error.WriteLine("The output file {0} could not be opened.\nPlease make sure it isn't opened by any other program and press Return.\nExiting with error.\n"' out_name); " is 174.
Long Statement,ARSS,Arss,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\Arss.cs,Main,The length of the statement  "					Console.Error.WriteLine("The output file {0} could not be opened.\nPlease make sure it isn't opened by any other program and press Return.\n"' out_name); " is 153.
Long Statement,ARSS,Arss,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\Arss.cs,Main,The length of the statement  "						Console.Error.WriteLine("Please specify an operation mode.\nUse either --analysis (-a)' --sine (-s) or --noise (-n).\nExiting with error.\n"); " is 142.
Long Statement,ARSS,Arss,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\Arss.cs,Main,The length of the statement  "				SettingsInput(ref Ysize' ref samplecount' ref samplerate' ref basefreq' ref maxfreq' ref pixpersec' ref bpo' ref Xsize' Mode.Analysis); // User settings input " is 158.
Long Statement,ARSS,Arss,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\Arss.cs,Main,The length of the statement  "				image = DSP.Analyze(ref sound[0]' ref samplecount' ref samplerate' ref Xsize' ref Ysize' ref bpo' ref pixpersec' ref basefreq); // Analysis " is 139.
Long Statement,ARSS,Arss,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\Arss.cs,Main,The length of the statement  "				string fileNameSine = @"C:\Users\perivar.nerseth\Documents\My Projects\CommonUtils\Library\Tests\Passacaglia' Handel-Sine-86bmp.wav"; " is 133.
Long Statement,ARSS,Arss,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\Arss.cs,Main,The length of the statement  "				string fileNameSaw = @"C:\Users\perivar.nerseth\Documents\My Projects\CommonUtils\Library\Tests\Passacaglia' Handel-Saw-86bmp.wav"; " is 131.
Long Statement,ARSS,Arss,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\Arss.cs,Main,The length of the statement  "				string fileNamePiano = @"C:\Users\perivar.nerseth\Documents\My Projects\CommonUtils\Library\Tests\Passacaglia' Handel-Piano-86bmp.wav"; " is 135.
Long Statement,ARSS,Arss,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\Arss.cs,Main,The length of the statement  "				CommonUtils.Audio.NAudio.AudioUtilsNAudio.WriteIEEE32WaveFileMono("test2.wav"' samplerate' MathUtils.DoubleToFloat(soundSynth2)); " is 129.
Long Statement,ARSS,Arss,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\Arss.cs,Main,The length of the statement  "				SettingsInput(ref Ysize' ref samplecount' ref samplerate' ref basefreq' ref maxfreq' ref pixpersec' ref bpo' ref Xsize' Mode.Synthesis_Sine); // User settings input " is 164.
Long Statement,ARSS,Arss,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\Arss.cs,Main,The length of the statement  "					sound[0] = DSP.SynthesizeSine(ref image' ref Xsize' ref Ysize' ref samplecount' ref samplerate' ref basefreq' ref pixpersec' ref bpo); // Sine synthesis " is 152.
Long Statement,ARSS,Arss,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\Arss.cs,Main,The length of the statement  "					sound[0] = DSP.SynthesizeNoise(ref image' ref Xsize' ref Ysize' ref samplecount' ref samplerate' ref basefreq' ref pixpersec' ref bpo); // Noise synthesis " is 154.
Long Statement,ARSS,Arss,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\Arss.cs,Main,The length of the statement  "			Console.Write("Processing time : {0:D2} m  {1:D2} s  {2:D2} ms\n"' duration.Minutes' duration.Seconds' duration.Milliseconds); " is 126.
Long Statement,ARSS,DSP,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\DSP.cs,Analyze,The length of the statement  "			//CommonUtils.FFT.AudioAnalyzer.GetLogFrequenciesIndex(samplerate' minFreq*samplerate' maxFreq*samplerate' bands-1' 1024' 2' out logFrequenciesIndex' out logFrequencies); " is 170.
Long Statement,ARSS,DSP,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\DSP.cs,Analyze,The length of the statement  "				paddedLength = samplecount - 1 + Util.RoundToClosestInt(2.0 * 5.0/((freqCentral[0] * Math.Pow(LOGBASE' -1.0/bandsperoctave)) * (1.0 - Math.Pow(LOGBASE' -1.0/bandsperoctave)))); " is 176.
Long Statement,ARSS,DSP,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\DSP.cs,Analyze,The length of the statement  "			paddedLength = Util.RoundToClosestInt((double) Util.NextLowPrimes((int) Util.RoundToClosestInt(paddedLength * pixpersec)) / pixpersec); " is 135.
Long Statement,ARSS,DSP,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\DSP.cs,Analyze,The length of the statement  "				bandIndexStart = Util.RoundToClosestInt(LogPositionToFrequency((double)(bandCounter-1)/(double)(bands-1)' minFreq' maxFreq) * paddedLength); " is 140.
Long Statement,ARSS,DSP,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\DSP.cs,Analyze,The length of the statement  "				bandIndexEnd = Util.RoundToClosestInt(LogPositionToFrequency((double)(bandCounter+1)/(double)(bands-1)' minFreq' maxFreq) * paddedLength); " is 138.
Long Statement,ARSS,DSP,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\DSP.cs,Analyze,The length of the statement  "				Console.Write("{0'4:D}/{1:D} (FFT size: {2'6:D})   {3:f2} Hz - {4:f2} Hz\r"' bandCounter+1' bands' filteredLength' (double) bandIndexStart*samplerate/paddedLength' (double) bandIndexEnd*samplerate/paddedLength); " is 211.
Long Statement,ARSS,DSP,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\DSP.cs,Analyze,The length of the statement  "					logFreqIterator = FrequencyToLogPosition((double)(i+bandIndexStart) / (double) paddedLength' minFreq' maxFreq); // calculation of the logarithmic position " is 154.
Long Statement,ARSS,DSP,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\DSP.cs,Analyze,The length of the statement  "					@out[currentBandIndex] = BlackmanDownsampling(@out[currentBandIndex]' filteredLength' envelopeDownsampledLength); // Blackman downsampling " is 138.
Long Statement,ARSS,DSP,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\DSP.cs,SynthesizeSine,The length of the statement  "			int shiftedBandCenterIndex = 0;		// Bc is the index of the band's centre in the frequency domain on sband (its imaginary match being sbsize-Bc) " is 143.
Long Statement,ARSS,DSP,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\DSP.cs,SynthesizeSine,The length of the statement  "			int envelopeFFTSize = 0;			// Mh is the length of the real or imaginary part of the envelope's FFT' DC element included and Nyquist element excluded " is 148.
Long Statement,ARSS,DSP,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\DSP.cs,SynthesizeSine,The length of the statement  "			int soundFFTSize = 0;				// Mn is the length of the real or imaginary part of the sound's FFT' DC element included and Nyquist element excluded " is 143.
Long Statement,ARSS,DSP,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\DSP.cs,SynthesizeSine,The length of the statement  "			// Bc is the index of the band's centre in the frequency domain on sband (its imaginary match being shiftedBandSize-shiftedBandCenterIndex) " is 139.
Long Statement,ARSS,DSP,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\DSP.cs,SynthesizeSine,The length of the statement  "			// Mh is the length of the real or imaginary part of the envelope's FFT' DC element included and Nyquist element excluded " is 121.
Long Statement,ARSS,DSP,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\DSP.cs,SynthesizeSine,The length of the statement  "				newSignalBandCenterIndex = Util.RoundToClosestInt(freq[bandCounter] * samplecount); // band's centre index (envelope's DC element) " is 130.
Long Statement,ARSS,DSP,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\DSP.cs,SynthesizeSine,The length of the statement  "				Console.Write("{0'4:D}/{1:D}   {2:f2} Hz\r"' bandCounter+1' bands' (double) newSignalBandCenterIndex * samplerate / samplecount); " is 129.
Long Statement,ARSS,DSP,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\DSP.cs,SynthesizeSine,The length of the statement  "					if (newSignalBandCenterIndex-shiftedBandCenterIndex+i > 0 && newSignalBandCenterIndex-shiftedBandCenterIndex+i < soundFFTSize) { " is 128.
Long Statement,ARSS,DSP,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\DSP.cs,SynthesizeSine,The length of the statement  "						s[samplecount-(i+newSignalBandCenterIndex-shiftedBandCenterIndex)] += shiftedBand[shiftedBandSize-i] * filter[i]; // Imaginary part " is 131.
Long Statement,ARSS,DSP,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\DSP.cs,SynthesizeNoise,The length of the statement  "			int loop_size_min = 0; 					// minimum required size for the filter bank loop' in samples. Calculated from the longest windowed sinc's length " is 141.
Long Statement,ARSS,DSP,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\DSP.cs,SynthesizeNoise,The length of the statement  "				loop_size_min = Util.RoundToClosestInt(2.0 * 5.0/((freq[0] * Math.Pow(2.0' -1.0/bpo)) * (1.0 - Math.Pow(2.0' -1.0/bpo)))); " is 122.
Long Statement,ARSS,DSP,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\DSP.cs,SynthesizeNoise,The length of the statement  "				bandIndexStart = Util.RoundToClosestInt(LogPositionToFrequency((double)(ib-1)/(double)(bands-1)' minFreq' maxfreq) * loop_size); " is 128.
Long Statement,ARSS,DSP,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\DSP.cs,SynthesizeNoise,The length of the statement  "				bandIndexEnd = Util.RoundToClosestInt(LogPositionToFrequency((double)(ib+1)/(double)(bands-1)' minFreq' maxfreq) * loop_size); " is 126.
Long Statement,ARSS,DSP,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\DSP.cs,SynthesizeNoise,The length of the statement  "				Console.Write("{0'4:D}/{1:D}   {2:f2} Hz - {3:f2} Hz\r"' ib+1' bands' (double) bandIndexStart *samplerate/loop_size' (double) bandIndexEnd *samplerate/loop_size); " is 162.
Long Statement,ARSS,DSP,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\DSP.cs,SynthesizeNoise,The length of the statement  "					LogFreqIterator = FrequencyToLogPosition((double) i / (double) loop_size' minFreq' maxfreq); // calculation of the logarithmic position " is 135.
Long Statement,ARSS,DSP,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\DSP.cs,BrightnessControl,The length of the statement  "			// Actually this is based on the idea of converting values to decibels' for example' 0.01 becomes -40 dB' dividing them by ratio' so if ratio is 2 then -40 dB/2 = -20 dB' and then turning it back to regular values' so -20 dB becomes 0.1 " is 236.
Long Statement,ARSS,DSP,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\DSP.cs,FrequencyToLogPosition,The length of the statement  "				return Math.Log(((x - min) * (min * Math.Pow(LOGBASE' logDelta) - min) / (max - min) + min) / Math.Log(LOGBASE)) * Math.Log(2.0) / delta; " is 137.
Long Statement,ArssSpectrogram,LogFilterbank,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\ArssSpectrogram\Filterbank.cs,GetBand,The length of the statement  "			//Console.Out.WriteLine("Low freq: {0}' Highfreq: {1}"' SpectrogramUtils.Cent2Freq(loglow)' SpectrogramUtils.Cent2Freq(loghigh)); " is 129.
Long Statement,ArssSpectrogram,Spectrogram,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\ArssSpectrogram\Spectrogram.cs,ToImage,The length of the statement  "					Console.Write("Processing band {0} of {1} ({2:0.00} Hz - {3:0.00} Hz = {4:0.00} Hz)\r"' bandidx' bands' range.First/filterscale' range.Second/filterscale' (range.Second-range.First)/filterscale); " is 195.
Long Statement,ArssSpectrogram,Spectrogram,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\ArssSpectrogram\Spectrogram.cs,ToImage,The length of the statement  "			Console.Out.WriteLine("(real)lowfreq: {0:0.00} (real)highfreq: {1:0.00}"' range.First / filterscale' range.Second/filterscale); " is 127.
Long Statement,ArssSpectrogram,Spectrogram,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\ArssSpectrogram\Spectrogram.cs,SynthetizeSine,The length of the statement  "						filterband[i] *= x - ((0.5/(2.0 * Math.PI)) * Math.Sin(2.0 * Math.PI *x) + (0.08/(4.0 * Math.PI)) * Math.Sin(4.0 * Math.PI *x) / 0.42); " is 135.
Long Statement,ArssSpectrogram,Spectrogram,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\ArssSpectrogram\Spectrogram.cs,SynthetizeSine,The length of the statement  "					//std::cout << bandidx << ". filterband size: " << filterband.Length << "; start: " << filterbank->GetBand(bandidx).first <<"; end: " << filterbank->GetBand(bandidx).second << "\n"; " is 181.
Long Statement,ArssSpectrogram,Spectrogram,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\ArssSpectrogram\Spectrogram.cs,SynthetizeSine,The length of the statement  "						filterband[i] *= x - ((0.5/(2.0 * Math.PI)) * Math.Sin(2.0 * Math.PI *x) + (0.08/(4.0 * Math.PI)) * Math.Sin(4.0 * Math.PI *x) / 0.42); " is 135.
Long Statement,ArssSpectrogram,Spectrogram,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\ArssSpectrogram\Spectrogram.cs,SynthetizeSine,The length of the statement  "					//std::cout << bandidx << ". filterband size: " << filterband.Length << "; start: " << filterbank->GetBand(bandidx).first <<"; end: " << filterbank->GetBand(bandidx).second << "\n"; " is 181.
Long Statement,ArssSpectrogram,Spectrogram,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\ArssSpectrogram\Spectrogram.cs,SynthetizeNoise,The length of the statement  "					//std.copy(noise.begin()+range.first' noise.begin()+Math.Min(range.second' top_index)' filtered_noise.begin()+range.first); " is 123.
Long Statement,ArssSpectrogram,Spectrogram,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\ArssSpectrogram\Spectrogram.cs,Serialized,The length of the statement  "		desc << "Spectrogram:" << delimiter << bandwidth << delimiter << basefreq << delimiter << maxfreq << delimiter << overlap *100 << delimiter << pixpersec << delimiter << (int)window << delimiter << (int)intensity_axis << delimiter << (int)frequency_axis << delimiter; " is 266.
Complex Conditional,ARSS,Arss,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\Arss.cs,SettingsInput,The conditional expression  "(mode == Mode.Analysis && set_x == 0 && set_pps == 0)  			    || (set_pps == 0 && (mode == Mode.Synthesis_Sine || mode == Mode.Synthesis_Noise))"  is complex.
Complex Conditional,ARSS,Arss,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\Arss.cs,Main,The conditional expression  "in_name.EndsWith(".wav") &&  			    (mode == Mode.None || mode == Mode.Synthesis_Sine || mode == Mode.Synthesis_Noise)"  is complex.
Complex Conditional,ARSS,SoundIO,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\SoundIO.cs,ReadWaveFile,The conditional expression  "(i == 5) || (i == 6) || (i == 9) || (i == 10)"  is complex.
Complex Conditional,ARSS,SoundIO,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\SoundIO.cs,WriteWaveFile,The conditional expression  "(i == 5) || (i == 6) || (i == 9) || (i == 10)"  is complex.
Magic Number,ARSS,Arss,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\Arss.cs,SettingsInput,The following statement contains a magic number: if (samplerate == 0)  			{  				if (Util.quiet)  				{  					Console.Error.WriteLine("Please provide a sample rate for your output sound.\nUse --sample-rate (-r).\nExiting with error.\n");  					Environment.Exit(1);  				}  				  				#region Output settings querying  				Console.Write("Sample rate [44100] : "); // Query for a samplerate  				samplerate = (int) Util.ReadUserInputFloat();  				  				if (samplerate == 0) {  					samplerate = 44100; // Default value  				}  				#endregion  			}
Magic Number,ARSS,Arss,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\Arss.cs,SettingsInput,The following statement contains a magic number: if (unset == 4)  			{  				if (mode == Mode.Analysis) {  					Console.Error.WriteLine("You have set one parameter too many.\nUnset either --min-freq (-min)' --max-freq (-max)' --bpo (-b)\nExiting with error.\n");  				}  				if (mode == Mode.Synthesis_Sine || mode == Mode.Synthesis_Noise) {  					Console.Error.WriteLine("You have set one parameter too many.\nUnset either --min-freq (-min)' --max-freq (-max)' --bpo (-b) or --height (-y)\nExiting with error.\n");  				}  				Environment.Exit(1);  			}
Magic Number,ARSS,Arss,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\Arss.cs,SettingsInput,The following statement contains a magic number: if (set_x+set_pps == 2 && mode == Mode.Analysis)  			{  				Console.Error.WriteLine("You cannot define both the image width and the horizontal resolution.\nUnset either --pps (-p) or --width (-x)\nExiting with error.\n");  				Environment.Exit(1);  			}
Magic Number,ARSS,Arss,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\Arss.cs,SettingsInput,The following statement contains a magic number: if (freqcfg != null) // load settings from file if it exists  			{  				// load values from it if they haven't been set yet  				if (basefreq == 0) {  					basefreq = double.Parse(freqcfg.ReadLine());  				} else{  					trash = double.Parse(freqcfg.ReadLine());  				}  				  				if (maxfreq == 0) {  					maxfreq = double.Parse(freqcfg.ReadLine());  				} else {  					trash = double.Parse(freqcfg.ReadLine());  				}  				  				if (bandsperoctave == 0) {  					bandsperoctave = double.Parse(freqcfg.ReadLine());  				} else {  					trash = double.Parse(freqcfg.ReadLine());  				}  				  				if (pixpersec == 0) {  					pixpersec = double.Parse(freqcfg.ReadLine());  				} else {  					trash = double.Parse(freqcfg.ReadLine());  				}  			}  			else  			{  				// otherwise load default values  				if (basefreq == 0) {  					basefreq = 27.5;  				}  				if (maxfreq == 0) {  					maxfreq = 20000;  				}  				if (bandsperoctave == 0) {  					bandsperoctave = 12;  				}  				if (pixpersec == 0) {  					pixpersec = 150;  				}  			}
Magic Number,ARSS,Arss,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\Arss.cs,SettingsInput,The following statement contains a magic number: if (freqcfg != null) // load settings from file if it exists  			{  				// load values from it if they haven't been set yet  				if (basefreq == 0) {  					basefreq = double.Parse(freqcfg.ReadLine());  				} else{  					trash = double.Parse(freqcfg.ReadLine());  				}  				  				if (maxfreq == 0) {  					maxfreq = double.Parse(freqcfg.ReadLine());  				} else {  					trash = double.Parse(freqcfg.ReadLine());  				}  				  				if (bandsperoctave == 0) {  					bandsperoctave = double.Parse(freqcfg.ReadLine());  				} else {  					trash = double.Parse(freqcfg.ReadLine());  				}  				  				if (pixpersec == 0) {  					pixpersec = double.Parse(freqcfg.ReadLine());  				} else {  					trash = double.Parse(freqcfg.ReadLine());  				}  			}  			else  			{  				// otherwise load default values  				if (basefreq == 0) {  					basefreq = 27.5;  				}  				if (maxfreq == 0) {  					maxfreq = 20000;  				}  				if (bandsperoctave == 0) {  					bandsperoctave = 12;  				}  				if (pixpersec == 0) {  					pixpersec = 150;  				}  			}
Magic Number,ARSS,Arss,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\Arss.cs,SettingsInput,The following statement contains a magic number: if (freqcfg != null) // load settings from file if it exists  			{  				// load values from it if they haven't been set yet  				if (basefreq == 0) {  					basefreq = double.Parse(freqcfg.ReadLine());  				} else{  					trash = double.Parse(freqcfg.ReadLine());  				}  				  				if (maxfreq == 0) {  					maxfreq = double.Parse(freqcfg.ReadLine());  				} else {  					trash = double.Parse(freqcfg.ReadLine());  				}  				  				if (bandsperoctave == 0) {  					bandsperoctave = double.Parse(freqcfg.ReadLine());  				} else {  					trash = double.Parse(freqcfg.ReadLine());  				}  				  				if (pixpersec == 0) {  					pixpersec = double.Parse(freqcfg.ReadLine());  				} else {  					trash = double.Parse(freqcfg.ReadLine());  				}  			}  			else  			{  				// otherwise load default values  				if (basefreq == 0) {  					basefreq = 27.5;  				}  				if (maxfreq == 0) {  					maxfreq = 20000;  				}  				if (bandsperoctave == 0) {  					bandsperoctave = 12;  				}  				if (pixpersec == 0) {  					pixpersec = 150;  				}  			}
Magic Number,ARSS,Arss,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\Arss.cs,SettingsInput,The following statement contains a magic number: if (freqcfg != null) // load settings from file if it exists  			{  				// load values from it if they haven't been set yet  				if (basefreq == 0) {  					basefreq = double.Parse(freqcfg.ReadLine());  				} else{  					trash = double.Parse(freqcfg.ReadLine());  				}  				  				if (maxfreq == 0) {  					maxfreq = double.Parse(freqcfg.ReadLine());  				} else {  					trash = double.Parse(freqcfg.ReadLine());  				}  				  				if (bandsperoctave == 0) {  					bandsperoctave = double.Parse(freqcfg.ReadLine());  				} else {  					trash = double.Parse(freqcfg.ReadLine());  				}  				  				if (pixpersec == 0) {  					pixpersec = double.Parse(freqcfg.ReadLine());  				} else {  					trash = double.Parse(freqcfg.ReadLine());  				}  			}  			else  			{  				// otherwise load default values  				if (basefreq == 0) {  					basefreq = 27.5;  				}  				if (maxfreq == 0) {  					maxfreq = 20000;  				}  				if (bandsperoctave == 0) {  					bandsperoctave = 12;  				}  				if (pixpersec == 0) {  					pixpersec = 150;  				}  			}
Magic Number,ARSS,Arss,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\Arss.cs,SettingsInput,The following statement contains a magic number: if (unset<3 && set_min == 0)  			{  				if (Util.quiet)  				{  					Console.Error.WriteLine("Please define a minimum frequency.\nUse --min-freq (-min).\nExiting with error.\n");  					Environment.Exit(1);  				}  				Console.Write("Min. frequency (Hz) [{0:f3}]: "' basefreq);  				floatUserInput = Util.ReadUserInputFloat();  				if (floatUserInput != 0) {  					basefreq = floatUserInput;  				}  				unset++;  				set_min = 1;  			}
Magic Number,ARSS,Arss,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\Arss.cs,SettingsInput,The following statement contains a magic number: if (unset<3 && set_bpo == 0)  			{  				if (Util.quiet)  				{  					Console.Error.WriteLine("Please define a bands per octave setting.\nUse --bpo (-b).\nExiting with error.\n");  					Environment.Exit(1);  				}  				Console.Write("Bands per octave [{0:f3}]: "' bandsperoctave);  				floatUserInput = Util.ReadUserInputFloat();  				if (floatUserInput != 0) {  					bandsperoctave = floatUserInput;  				}  				unset++;  				set_bpo = 1;  			}
Magic Number,ARSS,Arss,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\Arss.cs,SettingsInput,The following statement contains a magic number: if (unset<3 && set_max == 0)  			{  				double f = 0;  				int i = 0;  				do  				{  					i++;  					f = basefreq * Math.Pow(DSP.LOGBASE' (i / bandsperoctave));  				}  				while (f < 0.5);  				  				maxAllowedFreq = basefreq * Math.Pow(DSP.LOGBASE' ((i-2) / bandsperoctave)) * samplerate; // max allowed frequency    				if (maxfreq > maxAllowedFreq) {  					if (Util.FMod(maxAllowedFreq' 1.0) == 0.0) {  						// replaces the "Upper frequency limit above Nyquist frequency" warning  						maxfreq = maxAllowedFreq;  					} else {  						maxfreq = maxAllowedFreq - Util.FMod(maxAllowedFreq' 1.0);  					}  				}    				if (mode == Mode.Analysis) // if we're in Analysis mode  				{  					if (Util.quiet)  					{  						Console.Error.WriteLine("Please define a maximum frequency.\nUse --max-freq (-max).\nExiting with error.\n");  						Environment.Exit(1);  					}  					Console.Write("Max. frequency (Hz) (up to {0:f3}) [{1:f3}]: "' maxAllowedFreq' maxfreq);  					floatUserInput = Util.ReadUserInputFloat();  					if (floatUserInput != 0) {  						maxfreq = floatUserInput;  					}    					if (maxfreq > maxAllowedFreq) {  						// replaces the "Upper frequency limit above Nyquist frequency" warning  						if (Util.FMod(maxAllowedFreq' 1.0) == 0.0) {  							maxfreq = maxAllowedFreq;  						} else {  							maxfreq = maxAllowedFreq - Util.FMod(maxAllowedFreq' 1.0);  						}  					}  				}    				unset++;  				set_max = 1;  			}
Magic Number,ARSS,Arss,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\Arss.cs,SettingsInput,The following statement contains a magic number: if (unset<3 && set_max == 0)  			{  				double f = 0;  				int i = 0;  				do  				{  					i++;  					f = basefreq * Math.Pow(DSP.LOGBASE' (i / bandsperoctave));  				}  				while (f < 0.5);  				  				maxAllowedFreq = basefreq * Math.Pow(DSP.LOGBASE' ((i-2) / bandsperoctave)) * samplerate; // max allowed frequency    				if (maxfreq > maxAllowedFreq) {  					if (Util.FMod(maxAllowedFreq' 1.0) == 0.0) {  						// replaces the "Upper frequency limit above Nyquist frequency" warning  						maxfreq = maxAllowedFreq;  					} else {  						maxfreq = maxAllowedFreq - Util.FMod(maxAllowedFreq' 1.0);  					}  				}    				if (mode == Mode.Analysis) // if we're in Analysis mode  				{  					if (Util.quiet)  					{  						Console.Error.WriteLine("Please define a maximum frequency.\nUse --max-freq (-max).\nExiting with error.\n");  						Environment.Exit(1);  					}  					Console.Write("Max. frequency (Hz) (up to {0:f3}) [{1:f3}]: "' maxAllowedFreq' maxfreq);  					floatUserInput = Util.ReadUserInputFloat();  					if (floatUserInput != 0) {  						maxfreq = floatUserInput;  					}    					if (maxfreq > maxAllowedFreq) {  						// replaces the "Upper frequency limit above Nyquist frequency" warning  						if (Util.FMod(maxAllowedFreq' 1.0) == 0.0) {  							maxfreq = maxAllowedFreq;  						} else {  							maxfreq = maxAllowedFreq - Util.FMod(maxAllowedFreq' 1.0);  						}  					}  				}    				unset++;  				set_max = 1;  			}
Magic Number,ARSS,Arss,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\Arss.cs,SettingsInput,The following statement contains a magic number: if (unset<3 && set_max == 0)  			{  				double f = 0;  				int i = 0;  				do  				{  					i++;  					f = basefreq * Math.Pow(DSP.LOGBASE' (i / bandsperoctave));  				}  				while (f < 0.5);  				  				maxAllowedFreq = basefreq * Math.Pow(DSP.LOGBASE' ((i-2) / bandsperoctave)) * samplerate; // max allowed frequency    				if (maxfreq > maxAllowedFreq) {  					if (Util.FMod(maxAllowedFreq' 1.0) == 0.0) {  						// replaces the "Upper frequency limit above Nyquist frequency" warning  						maxfreq = maxAllowedFreq;  					} else {  						maxfreq = maxAllowedFreq - Util.FMod(maxAllowedFreq' 1.0);  					}  				}    				if (mode == Mode.Analysis) // if we're in Analysis mode  				{  					if (Util.quiet)  					{  						Console.Error.WriteLine("Please define a maximum frequency.\nUse --max-freq (-max).\nExiting with error.\n");  						Environment.Exit(1);  					}  					Console.Write("Max. frequency (Hz) (up to {0:f3}) [{1:f3}]: "' maxAllowedFreq' maxfreq);  					floatUserInput = Util.ReadUserInputFloat();  					if (floatUserInput != 0) {  						maxfreq = floatUserInput;  					}    					if (maxfreq > maxAllowedFreq) {  						// replaces the "Upper frequency limit above Nyquist frequency" warning  						if (Util.FMod(maxAllowedFreq' 1.0) == 0.0) {  							maxfreq = maxAllowedFreq;  						} else {  							maxfreq = maxAllowedFreq - Util.FMod(maxAllowedFreq' 1.0);  						}  					}  				}    				unset++;  				set_max = 1;  			}
Magic Number,ARSS,Arss,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\Arss.cs,Main,The following statement contains a magic number: if (mode == Mode.Synthesis_Sine || mode == Mode.Synthesis_Noise) {  				sound = new double[1][];  				  				image = ImageIO.BMPRead(fin' ref Ysize' ref Xsize); // Image input    				// if the output format parameter is undefined  				if (format_param == 0) {  					if (!Util.quiet) {  						// if prompting is allowed  						format_param = SoundIO.ReadUserWaveOutParameters();  					} else {  						format_param = 32; // default is 32  					}  				}    				SettingsInput(ref Ysize' ref samplecount' ref samplerate' ref basefreq' ref maxfreq' ref pixpersec' ref bpo' ref Xsize' Mode.Synthesis_Sine); // User settings input    				if (brightness!=1.0) {  					DSP.BrightnessControl(ref image' ref Ysize' ref Xsize' brightness);  				}    				if (mode == Mode.Synthesis_Sine) {  					sound[0] = DSP.SynthesizeSine(ref image' ref Xsize' ref Ysize' ref samplecount' ref samplerate' ref basefreq' ref pixpersec' ref bpo); // Sine synthesis  				} else {  					sound[0] = DSP.SynthesizeNoise(ref image' ref Xsize' ref Ysize' ref samplecount' ref samplerate' ref basefreq' ref pixpersec' ref bpo); // Noise synthesis  				}    				SoundIO.WriteWaveFile(fout' sound' 1' samplecount' samplerate' format_param);  			}
Magic Number,ARSS,DSP,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\DSP.cs,FrequencyArray,The following statement contains a magic number: if (LogPositionToFrequency((double) bands / (double)(bands-1)' basefreq' maxfreq) > 0.5) {  				// TODO change sampling rate instead  				Console.Write("Warning: Upper frequency limit above Nyquist frequency\n");  			}
Magic Number,ARSS,DSP,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\DSP.cs,BlackmanDownsampling,The following statement contains a magic number: for (int i = 0; i < outputLength; i++)  			{  				pos_in = (double) i * ratio;    				coef_sum = 0;    				for (int j = Util.RoundUpToClosestInt(pos_in - ratio); j<=pos_in + ratio; j++)  				{  					if (j >= 0 && j < inputLength) // if the read sample is within bounds  					{  						double x = j - pos_in + ratio; // calculate position within the Blackman function  						coef = 0.42 - 0.5 * Math.Cos(PI * x * ratio_i) + 0.08 * Math.Cos(2 *PI * x * ratio_i);  						coef_sum += coef;  						@out[i] += @in[j] * coef; // convolve  					}  				}    				@out[i] /= coef_sum;  			}
Magic Number,ARSS,DSP,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\DSP.cs,BlackmanDownsampling,The following statement contains a magic number: for (int i = 0; i < outputLength; i++)  			{  				pos_in = (double) i * ratio;    				coef_sum = 0;    				for (int j = Util.RoundUpToClosestInt(pos_in - ratio); j<=pos_in + ratio; j++)  				{  					if (j >= 0 && j < inputLength) // if the read sample is within bounds  					{  						double x = j - pos_in + ratio; // calculate position within the Blackman function  						coef = 0.42 - 0.5 * Math.Cos(PI * x * ratio_i) + 0.08 * Math.Cos(2 *PI * x * ratio_i);  						coef_sum += coef;  						@out[i] += @in[j] * coef; // convolve  					}  				}    				@out[i] /= coef_sum;  			}
Magic Number,ARSS,DSP,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\DSP.cs,BlackmanDownsampling,The following statement contains a magic number: for (int i = 0; i < outputLength; i++)  			{  				pos_in = (double) i * ratio;    				coef_sum = 0;    				for (int j = Util.RoundUpToClosestInt(pos_in - ratio); j<=pos_in + ratio; j++)  				{  					if (j >= 0 && j < inputLength) // if the read sample is within bounds  					{  						double x = j - pos_in + ratio; // calculate position within the Blackman function  						coef = 0.42 - 0.5 * Math.Cos(PI * x * ratio_i) + 0.08 * Math.Cos(2 *PI * x * ratio_i);  						coef_sum += coef;  						@out[i] += @in[j] * coef; // convolve  					}  				}    				@out[i] /= coef_sum;  			}
Magic Number,ARSS,DSP,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\DSP.cs,BlackmanDownsampling,The following statement contains a magic number: for (int i = 0; i < outputLength; i++)  			{  				pos_in = (double) i * ratio;    				coef_sum = 0;    				for (int j = Util.RoundUpToClosestInt(pos_in - ratio); j<=pos_in + ratio; j++)  				{  					if (j >= 0 && j < inputLength) // if the read sample is within bounds  					{  						double x = j - pos_in + ratio; // calculate position within the Blackman function  						coef = 0.42 - 0.5 * Math.Cos(PI * x * ratio_i) + 0.08 * Math.Cos(2 *PI * x * ratio_i);  						coef_sum += coef;  						@out[i] += @in[j] * coef; // convolve  					}  				}    				@out[i] /= coef_sum;  			}
Magic Number,ARSS,DSP,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\DSP.cs,BlackmanSquareLookupTable,The following statement contains a magic number: double bar = PI * (3.0 / (double) size) * (1.0/1.5);
Magic Number,ARSS,DSP,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\DSP.cs,BlackmanSquareLookupTable,The following statement contains a magic number: double bar = PI * (3.0 / (double) size) * (1.0/1.5);
Magic Number,ARSS,DSP,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\DSP.cs,BlackmanSquareLookupTable,The following statement contains a magic number: const double f1 = -0.6595044010905501;
Magic Number,ARSS,DSP,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\DSP.cs,BlackmanSquareLookupTable,The following statement contains a magic number: const double f2 = 0.1601741366715479;
Magic Number,ARSS,DSP,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\DSP.cs,BlackmanSquareLookupTable,The following statement contains a magic number: const double f4 = -0.0010709178680006;
Magic Number,ARSS,DSP,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\DSP.cs,BlackmanSquareLookupTable,The following statement contains a magic number: const double f5 = 0.0001450093579222;
Magic Number,ARSS,DSP,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\DSP.cs,BlackmanSquareLookupTable,The following statement contains a magic number: const double f7 = 0.0001008528049040;
Magic Number,ARSS,DSP,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\DSP.cs,BlackmanSquareLookupTable,The following statement contains a magic number: const double f8 = 0.0000653092892874;
Magic Number,ARSS,DSP,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\DSP.cs,BlackmanSquareLookupTable,The following statement contains a magic number: const double f10 = 0.0000293385615146;
Magic Number,ARSS,DSP,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\DSP.cs,BlackmanSquareLookupTable,The following statement contains a magic number: const double f11 = 0.0000205351559060;
Magic Number,ARSS,DSP,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\DSP.cs,BlackmanSquareLookupTable,The following statement contains a magic number: const double f13 = 0.0000108567682890;
Magic Number,ARSS,DSP,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\DSP.cs,BlackmanSquareLookupTable,The following statement contains a magic number: const double f14 = 0.0000081549460136;
Magic Number,ARSS,DSP,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\DSP.cs,BlackmanSquareLookupTable,The following statement contains a magic number: const double f16 = 0.0000048519309366;
Magic Number,ARSS,DSP,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\DSP.cs,BlackmanSquareLookupTable,The following statement contains a magic number: const double f17 = 0.0000038284344102;
Magic Number,ARSS,DSP,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\DSP.cs,BlackmanSquareLookupTable,The following statement contains a magic number: const double f19 = 0.0000024753630724;
Magic Number,ARSS,DSP,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\DSP.cs,BlackmanSquareLookupTable,The following statement contains a magic number: for (int i = 0; i < size; i++) {  				foo = (double) i * bar;  				coef = 0;    				coef += Math.Cos(foo) * f1 - f1;  				coef += Math.Cos(2.0 * foo) * f2 - f2;  				coef += Math.Cos(4.0 * foo) * f4 - f4;  				coef += Math.Cos(5.0 * foo) * f5 - f5;  				coef += Math.Cos(7.0 * foo) * f7 - f7;  				coef += Math.Cos(8.0 * foo) * f8 - f8;  				coef += Math.Cos(10.0 * foo) * f10 - f10;  				coef += Math.Cos(11.0 * foo) * f11 - f11;  				coef += Math.Cos(13.0 * foo) * f13 - f13;  				coef += Math.Cos(14.0 * foo) * f14 - f14;  				coef += Math.Cos(16.0 * foo) * f16 - f16;  				coef += Math.Cos(17.0 * foo) * f17 - f17;  				coef += Math.Cos(19.0 * foo) * f19 - f19;    				lut[i] = coef;  			}
Magic Number,ARSS,DSP,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\DSP.cs,BlackmanSquareLookupTable,The following statement contains a magic number: for (int i = 0; i < size; i++) {  				foo = (double) i * bar;  				coef = 0;    				coef += Math.Cos(foo) * f1 - f1;  				coef += Math.Cos(2.0 * foo) * f2 - f2;  				coef += Math.Cos(4.0 * foo) * f4 - f4;  				coef += Math.Cos(5.0 * foo) * f5 - f5;  				coef += Math.Cos(7.0 * foo) * f7 - f7;  				coef += Math.Cos(8.0 * foo) * f8 - f8;  				coef += Math.Cos(10.0 * foo) * f10 - f10;  				coef += Math.Cos(11.0 * foo) * f11 - f11;  				coef += Math.Cos(13.0 * foo) * f13 - f13;  				coef += Math.Cos(14.0 * foo) * f14 - f14;  				coef += Math.Cos(16.0 * foo) * f16 - f16;  				coef += Math.Cos(17.0 * foo) * f17 - f17;  				coef += Math.Cos(19.0 * foo) * f19 - f19;    				lut[i] = coef;  			}
Magic Number,ARSS,DSP,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\DSP.cs,BlackmanSquareLookupTable,The following statement contains a magic number: for (int i = 0; i < size; i++) {  				foo = (double) i * bar;  				coef = 0;    				coef += Math.Cos(foo) * f1 - f1;  				coef += Math.Cos(2.0 * foo) * f2 - f2;  				coef += Math.Cos(4.0 * foo) * f4 - f4;  				coef += Math.Cos(5.0 * foo) * f5 - f5;  				coef += Math.Cos(7.0 * foo) * f7 - f7;  				coef += Math.Cos(8.0 * foo) * f8 - f8;  				coef += Math.Cos(10.0 * foo) * f10 - f10;  				coef += Math.Cos(11.0 * foo) * f11 - f11;  				coef += Math.Cos(13.0 * foo) * f13 - f13;  				coef += Math.Cos(14.0 * foo) * f14 - f14;  				coef += Math.Cos(16.0 * foo) * f16 - f16;  				coef += Math.Cos(17.0 * foo) * f17 - f17;  				coef += Math.Cos(19.0 * foo) * f19 - f19;    				lut[i] = coef;  			}
Magic Number,ARSS,DSP,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\DSP.cs,BlackmanSquareLookupTable,The following statement contains a magic number: for (int i = 0; i < size; i++) {  				foo = (double) i * bar;  				coef = 0;    				coef += Math.Cos(foo) * f1 - f1;  				coef += Math.Cos(2.0 * foo) * f2 - f2;  				coef += Math.Cos(4.0 * foo) * f4 - f4;  				coef += Math.Cos(5.0 * foo) * f5 - f5;  				coef += Math.Cos(7.0 * foo) * f7 - f7;  				coef += Math.Cos(8.0 * foo) * f8 - f8;  				coef += Math.Cos(10.0 * foo) * f10 - f10;  				coef += Math.Cos(11.0 * foo) * f11 - f11;  				coef += Math.Cos(13.0 * foo) * f13 - f13;  				coef += Math.Cos(14.0 * foo) * f14 - f14;  				coef += Math.Cos(16.0 * foo) * f16 - f16;  				coef += Math.Cos(17.0 * foo) * f17 - f17;  				coef += Math.Cos(19.0 * foo) * f19 - f19;    				lut[i] = coef;  			}
Magic Number,ARSS,DSP,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\DSP.cs,BlackmanSquareLookupTable,The following statement contains a magic number: for (int i = 0; i < size; i++) {  				foo = (double) i * bar;  				coef = 0;    				coef += Math.Cos(foo) * f1 - f1;  				coef += Math.Cos(2.0 * foo) * f2 - f2;  				coef += Math.Cos(4.0 * foo) * f4 - f4;  				coef += Math.Cos(5.0 * foo) * f5 - f5;  				coef += Math.Cos(7.0 * foo) * f7 - f7;  				coef += Math.Cos(8.0 * foo) * f8 - f8;  				coef += Math.Cos(10.0 * foo) * f10 - f10;  				coef += Math.Cos(11.0 * foo) * f11 - f11;  				coef += Math.Cos(13.0 * foo) * f13 - f13;  				coef += Math.Cos(14.0 * foo) * f14 - f14;  				coef += Math.Cos(16.0 * foo) * f16 - f16;  				coef += Math.Cos(17.0 * foo) * f17 - f17;  				coef += Math.Cos(19.0 * foo) * f19 - f19;    				lut[i] = coef;  			}
Magic Number,ARSS,DSP,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\DSP.cs,BlackmanSquareLookupTable,The following statement contains a magic number: for (int i = 0; i < size; i++) {  				foo = (double) i * bar;  				coef = 0;    				coef += Math.Cos(foo) * f1 - f1;  				coef += Math.Cos(2.0 * foo) * f2 - f2;  				coef += Math.Cos(4.0 * foo) * f4 - f4;  				coef += Math.Cos(5.0 * foo) * f5 - f5;  				coef += Math.Cos(7.0 * foo) * f7 - f7;  				coef += Math.Cos(8.0 * foo) * f8 - f8;  				coef += Math.Cos(10.0 * foo) * f10 - f10;  				coef += Math.Cos(11.0 * foo) * f11 - f11;  				coef += Math.Cos(13.0 * foo) * f13 - f13;  				coef += Math.Cos(14.0 * foo) * f14 - f14;  				coef += Math.Cos(16.0 * foo) * f16 - f16;  				coef += Math.Cos(17.0 * foo) * f17 - f17;  				coef += Math.Cos(19.0 * foo) * f19 - f19;    				lut[i] = coef;  			}
Magic Number,ARSS,DSP,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\DSP.cs,BlackmanSquareLookupTable,The following statement contains a magic number: for (int i = 0; i < size; i++) {  				foo = (double) i * bar;  				coef = 0;    				coef += Math.Cos(foo) * f1 - f1;  				coef += Math.Cos(2.0 * foo) * f2 - f2;  				coef += Math.Cos(4.0 * foo) * f4 - f4;  				coef += Math.Cos(5.0 * foo) * f5 - f5;  				coef += Math.Cos(7.0 * foo) * f7 - f7;  				coef += Math.Cos(8.0 * foo) * f8 - f8;  				coef += Math.Cos(10.0 * foo) * f10 - f10;  				coef += Math.Cos(11.0 * foo) * f11 - f11;  				coef += Math.Cos(13.0 * foo) * f13 - f13;  				coef += Math.Cos(14.0 * foo) * f14 - f14;  				coef += Math.Cos(16.0 * foo) * f16 - f16;  				coef += Math.Cos(17.0 * foo) * f17 - f17;  				coef += Math.Cos(19.0 * foo) * f19 - f19;    				lut[i] = coef;  			}
Magic Number,ARSS,DSP,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\DSP.cs,BlackmanSquareLookupTable,The following statement contains a magic number: for (int i = 0; i < size; i++) {  				foo = (double) i * bar;  				coef = 0;    				coef += Math.Cos(foo) * f1 - f1;  				coef += Math.Cos(2.0 * foo) * f2 - f2;  				coef += Math.Cos(4.0 * foo) * f4 - f4;  				coef += Math.Cos(5.0 * foo) * f5 - f5;  				coef += Math.Cos(7.0 * foo) * f7 - f7;  				coef += Math.Cos(8.0 * foo) * f8 - f8;  				coef += Math.Cos(10.0 * foo) * f10 - f10;  				coef += Math.Cos(11.0 * foo) * f11 - f11;  				coef += Math.Cos(13.0 * foo) * f13 - f13;  				coef += Math.Cos(14.0 * foo) * f14 - f14;  				coef += Math.Cos(16.0 * foo) * f16 - f16;  				coef += Math.Cos(17.0 * foo) * f17 - f17;  				coef += Math.Cos(19.0 * foo) * f19 - f19;    				lut[i] = coef;  			}
Magic Number,ARSS,DSP,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\DSP.cs,BlackmanSquareLookupTable,The following statement contains a magic number: for (int i = 0; i < size; i++) {  				foo = (double) i * bar;  				coef = 0;    				coef += Math.Cos(foo) * f1 - f1;  				coef += Math.Cos(2.0 * foo) * f2 - f2;  				coef += Math.Cos(4.0 * foo) * f4 - f4;  				coef += Math.Cos(5.0 * foo) * f5 - f5;  				coef += Math.Cos(7.0 * foo) * f7 - f7;  				coef += Math.Cos(8.0 * foo) * f8 - f8;  				coef += Math.Cos(10.0 * foo) * f10 - f10;  				coef += Math.Cos(11.0 * foo) * f11 - f11;  				coef += Math.Cos(13.0 * foo) * f13 - f13;  				coef += Math.Cos(14.0 * foo) * f14 - f14;  				coef += Math.Cos(16.0 * foo) * f16 - f16;  				coef += Math.Cos(17.0 * foo) * f17 - f17;  				coef += Math.Cos(19.0 * foo) * f19 - f19;    				lut[i] = coef;  			}
Magic Number,ARSS,DSP,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\DSP.cs,BlackmanSquareLookupTable,The following statement contains a magic number: for (int i = 0; i < size; i++) {  				foo = (double) i * bar;  				coef = 0;    				coef += Math.Cos(foo) * f1 - f1;  				coef += Math.Cos(2.0 * foo) * f2 - f2;  				coef += Math.Cos(4.0 * foo) * f4 - f4;  				coef += Math.Cos(5.0 * foo) * f5 - f5;  				coef += Math.Cos(7.0 * foo) * f7 - f7;  				coef += Math.Cos(8.0 * foo) * f8 - f8;  				coef += Math.Cos(10.0 * foo) * f10 - f10;  				coef += Math.Cos(11.0 * foo) * f11 - f11;  				coef += Math.Cos(13.0 * foo) * f13 - f13;  				coef += Math.Cos(14.0 * foo) * f14 - f14;  				coef += Math.Cos(16.0 * foo) * f16 - f16;  				coef += Math.Cos(17.0 * foo) * f17 - f17;  				coef += Math.Cos(19.0 * foo) * f19 - f19;    				lut[i] = coef;  			}
Magic Number,ARSS,DSP,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\DSP.cs,BlackmanSquareLookupTable,The following statement contains a magic number: for (int i = 0; i < size; i++) {  				foo = (double) i * bar;  				coef = 0;    				coef += Math.Cos(foo) * f1 - f1;  				coef += Math.Cos(2.0 * foo) * f2 - f2;  				coef += Math.Cos(4.0 * foo) * f4 - f4;  				coef += Math.Cos(5.0 * foo) * f5 - f5;  				coef += Math.Cos(7.0 * foo) * f7 - f7;  				coef += Math.Cos(8.0 * foo) * f8 - f8;  				coef += Math.Cos(10.0 * foo) * f10 - f10;  				coef += Math.Cos(11.0 * foo) * f11 - f11;  				coef += Math.Cos(13.0 * foo) * f13 - f13;  				coef += Math.Cos(14.0 * foo) * f14 - f14;  				coef += Math.Cos(16.0 * foo) * f16 - f16;  				coef += Math.Cos(17.0 * foo) * f17 - f17;  				coef += Math.Cos(19.0 * foo) * f19 - f19;    				lut[i] = coef;  			}
Magic Number,ARSS,DSP,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\DSP.cs,BlackmanSquareLookupTable,The following statement contains a magic number: for (int i = 0; i < size; i++) {  				foo = (double) i * bar;  				coef = 0;    				coef += Math.Cos(foo) * f1 - f1;  				coef += Math.Cos(2.0 * foo) * f2 - f2;  				coef += Math.Cos(4.0 * foo) * f4 - f4;  				coef += Math.Cos(5.0 * foo) * f5 - f5;  				coef += Math.Cos(7.0 * foo) * f7 - f7;  				coef += Math.Cos(8.0 * foo) * f8 - f8;  				coef += Math.Cos(10.0 * foo) * f10 - f10;  				coef += Math.Cos(11.0 * foo) * f11 - f11;  				coef += Math.Cos(13.0 * foo) * f13 - f13;  				coef += Math.Cos(14.0 * foo) * f14 - f14;  				coef += Math.Cos(16.0 * foo) * f16 - f16;  				coef += Math.Cos(17.0 * foo) * f17 - f17;  				coef += Math.Cos(19.0 * foo) * f19 - f19;    				lut[i] = coef;  			}
Magic Number,ARSS,DSP,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\DSP.cs,BlackmanSquareInterpolation,The following statement contains a magic number: double foo = (double) lut_size / 3.0;
Magic Number,ARSS,DSP,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\DSP.cs,BlackmanSquareInterpolation,The following statement contains a magic number: for (int i = 0; i < outputLength; i++) {  				pos_in = (double) i * ratio;    				j_stop = (int) (pos_in + 1.5);    				j_start = j_stop - 2;  				if (j_start < 0) {  					j_start = 0;  				}    				// The boundary check is done after j_start is calculated to avoid miscalculating it  				if (j_stop >= inputLength) {  					j_stop = inputLength - 1;  				}    				for (int j = j_start; j <= j_stop; j++) {  					x = j - pos_in + 1.5; // calculate position within the Blackman square function in the [0.0 ; 3.0] range  					pos_lut = x * foo;  					pos_luti = (int) pos_lut;    					// modulo of the index  					mod_pos = Util.FMod(pos_lut' 1.0);    					if (pos_luti + 1 < lut.Length) {  						y0 = lut[pos_luti]; // interpolate linearly between the two closest values  						y1 = lut[pos_luti + 1];  						coef = y0 + mod_pos * (y1 - y0); // linear interpolation    						@out[i] += @in[j] * coef; // convolve  					}  				}  			}
Magic Number,ARSS,DSP,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\DSP.cs,BlackmanSquareInterpolation,The following statement contains a magic number: for (int i = 0; i < outputLength; i++) {  				pos_in = (double) i * ratio;    				j_stop = (int) (pos_in + 1.5);    				j_start = j_stop - 2;  				if (j_start < 0) {  					j_start = 0;  				}    				// The boundary check is done after j_start is calculated to avoid miscalculating it  				if (j_stop >= inputLength) {  					j_stop = inputLength - 1;  				}    				for (int j = j_start; j <= j_stop; j++) {  					x = j - pos_in + 1.5; // calculate position within the Blackman square function in the [0.0 ; 3.0] range  					pos_lut = x * foo;  					pos_luti = (int) pos_lut;    					// modulo of the index  					mod_pos = Util.FMod(pos_lut' 1.0);    					if (pos_luti + 1 < lut.Length) {  						y0 = lut[pos_luti]; // interpolate linearly between the two closest values  						y1 = lut[pos_luti + 1];  						coef = y0 + mod_pos * (y1 - y0); // linear interpolation    						@out[i] += @in[j] * coef; // convolve  					}  				}  			}
Magic Number,ARSS,DSP,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\DSP.cs,BlackmanSquareInterpolation,The following statement contains a magic number: for (int i = 0; i < outputLength; i++) {  				pos_in = (double) i * ratio;    				j_stop = (int) (pos_in + 1.5);    				j_start = j_stop - 2;  				if (j_start < 0) {  					j_start = 0;  				}    				// The boundary check is done after j_start is calculated to avoid miscalculating it  				if (j_stop >= inputLength) {  					j_stop = inputLength - 1;  				}    				for (int j = j_start; j <= j_stop; j++) {  					x = j - pos_in + 1.5; // calculate position within the Blackman square function in the [0.0 ; 3.0] range  					pos_lut = x * foo;  					pos_luti = (int) pos_lut;    					// modulo of the index  					mod_pos = Util.FMod(pos_lut' 1.0);    					if (pos_luti + 1 < lut.Length) {  						y0 = lut[pos_luti]; // interpolate linearly between the two closest values  						y1 = lut[pos_luti + 1];  						coef = y0 + mod_pos * (y1 - y0); // linear interpolation    						@out[i] += @in[j] * coef; // convolve  					}  				}  			}
Magic Number,ARSS,DSP,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\DSP.cs,Analyze,The following statement contains a magic number: if (LOGBASE == 1.0) {  				paddedLength = samplecount - 1 + Util.RoundToClosestInt(5.0/ freqCentral[1]-freqCentral[0]); // linear mode  			} else {  				paddedLength = samplecount - 1 + Util.RoundToClosestInt(2.0 * 5.0/((freqCentral[0] * Math.Pow(LOGBASE' -1.0/bandsperoctave)) * (1.0 - Math.Pow(LOGBASE' -1.0/bandsperoctave))));  			}
Magic Number,ARSS,DSP,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\DSP.cs,Analyze,The following statement contains a magic number: if (LOGBASE == 1.0) {  				paddedLength = samplecount - 1 + Util.RoundToClosestInt(5.0/ freqCentral[1]-freqCentral[0]); // linear mode  			} else {  				paddedLength = samplecount - 1 + Util.RoundToClosestInt(2.0 * 5.0/((freqCentral[0] * Math.Pow(LOGBASE' -1.0/bandsperoctave)) * (1.0 - Math.Pow(LOGBASE' -1.0/bandsperoctave))));  			}
Magic Number,ARSS,DSP,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\DSP.cs,Analyze,The following statement contains a magic number: if (LOGBASE == 1.0) {  				paddedLength = samplecount - 1 + Util.RoundToClosestInt(5.0/ freqCentral[1]-freqCentral[0]); // linear mode  			} else {  				paddedLength = samplecount - 1 + Util.RoundToClosestInt(2.0 * 5.0/((freqCentral[0] * Math.Pow(LOGBASE' -1.0/bandsperoctave)) * (1.0 - Math.Pow(LOGBASE' -1.0/bandsperoctave))));  			}
Magic Number,ARSS,DSP,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\DSP.cs,Analyze,The following statement contains a magic number: if (paddedLength % 2 == 1)  { // if Mb is odd  				paddedLength++; // make it even (for the sake of simplicity)  			}
Magic Number,ARSS,DSP,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\DSP.cs,Analyze,The following statement contains a magic number: for (int bandCounter = 0; bandCounter < bands; bandCounter++) {  				#region Filtering  				bandIndexStart = Util.RoundToClosestInt(LogPositionToFrequency((double)(bandCounter-1)/(double)(bands-1)' minFreq' maxFreq) * paddedLength);  				bandIndexEnd = Util.RoundToClosestInt(LogPositionToFrequency((double)(bandCounter+1)/(double)(bands-1)' minFreq' maxFreq) * paddedLength);  				logBandFreqStart = FrequencyToLogPosition((double) bandIndexStart / (double) paddedLength' minFreq' maxFreq);  				logBandFreqEnd = FrequencyToLogPosition((double) bandIndexEnd / (double) paddedLength' minFreq' maxFreq);    				// stop reading if reaching the Nyquist frequency  				if (bandIndexEnd > paddedLength/2) {  					bandIndexEnd = paddedLength/2;  				}    				// ensure the band index is at least 1  				if (bandIndexStart < 1) {  					bandIndexStart = 1;  				}    				// the actual band length  				int bandIndexLength = bandIndexEnd-bandIndexStart + 1;  				  				// Mc is the length of the filtered signal  				// '*2' because the filtering is on both real and imaginary parts'  				// '+1' for the DC.  				// No Nyquist component since the signal length is necessarily odd  				filteredLength = (bandIndexEnd-bandIndexStart)*2 + 1;    				// if the band is going to be too narrow  				if (envelopeDownsampledLength > filteredLength) {  					filteredLength = envelopeDownsampledLength;  				}    				// round the larger bands up to the next integer made of 2^n * 3^m  				if (envelopeDownsampledLength < filteredLength) {  					filteredLength = Util.NextLowPrimes(filteredLength);  				}    				Console.Write("{0'4:D}/{1:D} (FFT size: {2'6:D})   {3:f2} Hz - {4:f2} Hz\r"' bandCounter+1' bands' filteredLength' (double) bandIndexStart*samplerate/paddedLength' (double) bandIndexEnd*samplerate/paddedLength);    				int currentBandIndex = bands-bandCounter-1;  				  				@out[currentBandIndex] = new double[filteredLength+1];    				for (int i = 0; i < bandIndexLength-1; i++) {  					logFreqIterator = FrequencyToLogPosition((double)(i+bandIndexStart) / (double) paddedLength' minFreq' maxFreq); // calculation of the logarithmic position  					logFreqIterator = (logFreqIterator-logBandFreqStart)/(logBandFreqEnd-logBandFreqStart);  					coef = 0.5 - 0.5 * Math.Cos(2.0 * PI * logFreqIterator); // Hann function  					  					@out[currentBandIndex][i+1] = s[i+1+bandIndexStart] * coef;  					@out[currentBandIndex][filteredLength-1-i] = s[paddedLength-bandIndexStart-1-i] * coef;  				}  				#endregion    				#region 90 rotation  				filterBandRotated = new double[filteredLength+1];  				  				// Rotation : Re' = Im; Im' = -Re  				for (int i = 0; i < bandIndexLength-1; i++) {  					filterBandRotated[i+1] = @out[currentBandIndex][filteredLength-1-i]; // Re' = Im  					filterBandRotated[filteredLength-1-i] = -@out[currentBandIndex][i+1]; 	// Im' = -Re  				}  				#endregion    				#region Envelope detection    				// In-place IFFT of the filtered band signal  				FFT(ref @out[currentBandIndex]' ref @out[currentBandIndex]' filteredLength' FFTMethod.IDFT);  				  				// In-place IFFT of the filtered band signal rotated by 90  				FFT(ref filterBandRotated' ref filterBandRotated' filteredLength' FFTMethod.IDFT);    				for (int i = 0; i < filteredLength; i++) {  					// Magnitude of the analytic signal  					// out[bands-ib-1][i] = sqrt(out[bands-ib-1][i]*out[bands-ib-1][i] + h[i]*h[i]);  					double x = @out[currentBandIndex][i];  					double y = filterBandRotated[i];  					double mag = Math.Sqrt(x*x + y*y);  					@out[currentBandIndex][i] = mag;  				}  				#endregion    				#region Downsampling  				if (filteredLength < envelopeDownsampledLength) { // if the band doesn't have to be resampled  					Array.Resize<double>(ref @out[currentBandIndex]' envelopeDownsampledLength); // simply ignore the end of it  				}  				  				// If the band *has* to be downsampled  				if (filteredLength > envelopeDownsampledLength) {  					@out[currentBandIndex] = BlackmanDownsampling(@out[currentBandIndex]' filteredLength' envelopeDownsampledLength); // Blackman downsampling  				}  				#endregion    				// Tail chopping  				Array.Resize<double>(ref @out[currentBandIndex]' Xsize);  			}
Magic Number,ARSS,DSP,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\DSP.cs,Analyze,The following statement contains a magic number: for (int bandCounter = 0; bandCounter < bands; bandCounter++) {  				#region Filtering  				bandIndexStart = Util.RoundToClosestInt(LogPositionToFrequency((double)(bandCounter-1)/(double)(bands-1)' minFreq' maxFreq) * paddedLength);  				bandIndexEnd = Util.RoundToClosestInt(LogPositionToFrequency((double)(bandCounter+1)/(double)(bands-1)' minFreq' maxFreq) * paddedLength);  				logBandFreqStart = FrequencyToLogPosition((double) bandIndexStart / (double) paddedLength' minFreq' maxFreq);  				logBandFreqEnd = FrequencyToLogPosition((double) bandIndexEnd / (double) paddedLength' minFreq' maxFreq);    				// stop reading if reaching the Nyquist frequency  				if (bandIndexEnd > paddedLength/2) {  					bandIndexEnd = paddedLength/2;  				}    				// ensure the band index is at least 1  				if (bandIndexStart < 1) {  					bandIndexStart = 1;  				}    				// the actual band length  				int bandIndexLength = bandIndexEnd-bandIndexStart + 1;  				  				// Mc is the length of the filtered signal  				// '*2' because the filtering is on both real and imaginary parts'  				// '+1' for the DC.  				// No Nyquist component since the signal length is necessarily odd  				filteredLength = (bandIndexEnd-bandIndexStart)*2 + 1;    				// if the band is going to be too narrow  				if (envelopeDownsampledLength > filteredLength) {  					filteredLength = envelopeDownsampledLength;  				}    				// round the larger bands up to the next integer made of 2^n * 3^m  				if (envelopeDownsampledLength < filteredLength) {  					filteredLength = Util.NextLowPrimes(filteredLength);  				}    				Console.Write("{0'4:D}/{1:D} (FFT size: {2'6:D})   {3:f2} Hz - {4:f2} Hz\r"' bandCounter+1' bands' filteredLength' (double) bandIndexStart*samplerate/paddedLength' (double) bandIndexEnd*samplerate/paddedLength);    				int currentBandIndex = bands-bandCounter-1;  				  				@out[currentBandIndex] = new double[filteredLength+1];    				for (int i = 0; i < bandIndexLength-1; i++) {  					logFreqIterator = FrequencyToLogPosition((double)(i+bandIndexStart) / (double) paddedLength' minFreq' maxFreq); // calculation of the logarithmic position  					logFreqIterator = (logFreqIterator-logBandFreqStart)/(logBandFreqEnd-logBandFreqStart);  					coef = 0.5 - 0.5 * Math.Cos(2.0 * PI * logFreqIterator); // Hann function  					  					@out[currentBandIndex][i+1] = s[i+1+bandIndexStart] * coef;  					@out[currentBandIndex][filteredLength-1-i] = s[paddedLength-bandIndexStart-1-i] * coef;  				}  				#endregion    				#region 90 rotation  				filterBandRotated = new double[filteredLength+1];  				  				// Rotation : Re' = Im; Im' = -Re  				for (int i = 0; i < bandIndexLength-1; i++) {  					filterBandRotated[i+1] = @out[currentBandIndex][filteredLength-1-i]; // Re' = Im  					filterBandRotated[filteredLength-1-i] = -@out[currentBandIndex][i+1]; 	// Im' = -Re  				}  				#endregion    				#region Envelope detection    				// In-place IFFT of the filtered band signal  				FFT(ref @out[currentBandIndex]' ref @out[currentBandIndex]' filteredLength' FFTMethod.IDFT);  				  				// In-place IFFT of the filtered band signal rotated by 90  				FFT(ref filterBandRotated' ref filterBandRotated' filteredLength' FFTMethod.IDFT);    				for (int i = 0; i < filteredLength; i++) {  					// Magnitude of the analytic signal  					// out[bands-ib-1][i] = sqrt(out[bands-ib-1][i]*out[bands-ib-1][i] + h[i]*h[i]);  					double x = @out[currentBandIndex][i];  					double y = filterBandRotated[i];  					double mag = Math.Sqrt(x*x + y*y);  					@out[currentBandIndex][i] = mag;  				}  				#endregion    				#region Downsampling  				if (filteredLength < envelopeDownsampledLength) { // if the band doesn't have to be resampled  					Array.Resize<double>(ref @out[currentBandIndex]' envelopeDownsampledLength); // simply ignore the end of it  				}  				  				// If the band *has* to be downsampled  				if (filteredLength > envelopeDownsampledLength) {  					@out[currentBandIndex] = BlackmanDownsampling(@out[currentBandIndex]' filteredLength' envelopeDownsampledLength); // Blackman downsampling  				}  				#endregion    				// Tail chopping  				Array.Resize<double>(ref @out[currentBandIndex]' Xsize);  			}
Magic Number,ARSS,DSP,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\DSP.cs,Analyze,The following statement contains a magic number: for (int bandCounter = 0; bandCounter < bands; bandCounter++) {  				#region Filtering  				bandIndexStart = Util.RoundToClosestInt(LogPositionToFrequency((double)(bandCounter-1)/(double)(bands-1)' minFreq' maxFreq) * paddedLength);  				bandIndexEnd = Util.RoundToClosestInt(LogPositionToFrequency((double)(bandCounter+1)/(double)(bands-1)' minFreq' maxFreq) * paddedLength);  				logBandFreqStart = FrequencyToLogPosition((double) bandIndexStart / (double) paddedLength' minFreq' maxFreq);  				logBandFreqEnd = FrequencyToLogPosition((double) bandIndexEnd / (double) paddedLength' minFreq' maxFreq);    				// stop reading if reaching the Nyquist frequency  				if (bandIndexEnd > paddedLength/2) {  					bandIndexEnd = paddedLength/2;  				}    				// ensure the band index is at least 1  				if (bandIndexStart < 1) {  					bandIndexStart = 1;  				}    				// the actual band length  				int bandIndexLength = bandIndexEnd-bandIndexStart + 1;  				  				// Mc is the length of the filtered signal  				// '*2' because the filtering is on both real and imaginary parts'  				// '+1' for the DC.  				// No Nyquist component since the signal length is necessarily odd  				filteredLength = (bandIndexEnd-bandIndexStart)*2 + 1;    				// if the band is going to be too narrow  				if (envelopeDownsampledLength > filteredLength) {  					filteredLength = envelopeDownsampledLength;  				}    				// round the larger bands up to the next integer made of 2^n * 3^m  				if (envelopeDownsampledLength < filteredLength) {  					filteredLength = Util.NextLowPrimes(filteredLength);  				}    				Console.Write("{0'4:D}/{1:D} (FFT size: {2'6:D})   {3:f2} Hz - {4:f2} Hz\r"' bandCounter+1' bands' filteredLength' (double) bandIndexStart*samplerate/paddedLength' (double) bandIndexEnd*samplerate/paddedLength);    				int currentBandIndex = bands-bandCounter-1;  				  				@out[currentBandIndex] = new double[filteredLength+1];    				for (int i = 0; i < bandIndexLength-1; i++) {  					logFreqIterator = FrequencyToLogPosition((double)(i+bandIndexStart) / (double) paddedLength' minFreq' maxFreq); // calculation of the logarithmic position  					logFreqIterator = (logFreqIterator-logBandFreqStart)/(logBandFreqEnd-logBandFreqStart);  					coef = 0.5 - 0.5 * Math.Cos(2.0 * PI * logFreqIterator); // Hann function  					  					@out[currentBandIndex][i+1] = s[i+1+bandIndexStart] * coef;  					@out[currentBandIndex][filteredLength-1-i] = s[paddedLength-bandIndexStart-1-i] * coef;  				}  				#endregion    				#region 90 rotation  				filterBandRotated = new double[filteredLength+1];  				  				// Rotation : Re' = Im; Im' = -Re  				for (int i = 0; i < bandIndexLength-1; i++) {  					filterBandRotated[i+1] = @out[currentBandIndex][filteredLength-1-i]; // Re' = Im  					filterBandRotated[filteredLength-1-i] = -@out[currentBandIndex][i+1]; 	// Im' = -Re  				}  				#endregion    				#region Envelope detection    				// In-place IFFT of the filtered band signal  				FFT(ref @out[currentBandIndex]' ref @out[currentBandIndex]' filteredLength' FFTMethod.IDFT);  				  				// In-place IFFT of the filtered band signal rotated by 90  				FFT(ref filterBandRotated' ref filterBandRotated' filteredLength' FFTMethod.IDFT);    				for (int i = 0; i < filteredLength; i++) {  					// Magnitude of the analytic signal  					// out[bands-ib-1][i] = sqrt(out[bands-ib-1][i]*out[bands-ib-1][i] + h[i]*h[i]);  					double x = @out[currentBandIndex][i];  					double y = filterBandRotated[i];  					double mag = Math.Sqrt(x*x + y*y);  					@out[currentBandIndex][i] = mag;  				}  				#endregion    				#region Downsampling  				if (filteredLength < envelopeDownsampledLength) { // if the band doesn't have to be resampled  					Array.Resize<double>(ref @out[currentBandIndex]' envelopeDownsampledLength); // simply ignore the end of it  				}  				  				// If the band *has* to be downsampled  				if (filteredLength > envelopeDownsampledLength) {  					@out[currentBandIndex] = BlackmanDownsampling(@out[currentBandIndex]' filteredLength' envelopeDownsampledLength); // Blackman downsampling  				}  				#endregion    				// Tail chopping  				Array.Resize<double>(ref @out[currentBandIndex]' Xsize);  			}
Magic Number,ARSS,DSP,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\DSP.cs,Analyze,The following statement contains a magic number: for (int bandCounter = 0; bandCounter < bands; bandCounter++) {  				#region Filtering  				bandIndexStart = Util.RoundToClosestInt(LogPositionToFrequency((double)(bandCounter-1)/(double)(bands-1)' minFreq' maxFreq) * paddedLength);  				bandIndexEnd = Util.RoundToClosestInt(LogPositionToFrequency((double)(bandCounter+1)/(double)(bands-1)' minFreq' maxFreq) * paddedLength);  				logBandFreqStart = FrequencyToLogPosition((double) bandIndexStart / (double) paddedLength' minFreq' maxFreq);  				logBandFreqEnd = FrequencyToLogPosition((double) bandIndexEnd / (double) paddedLength' minFreq' maxFreq);    				// stop reading if reaching the Nyquist frequency  				if (bandIndexEnd > paddedLength/2) {  					bandIndexEnd = paddedLength/2;  				}    				// ensure the band index is at least 1  				if (bandIndexStart < 1) {  					bandIndexStart = 1;  				}    				// the actual band length  				int bandIndexLength = bandIndexEnd-bandIndexStart + 1;  				  				// Mc is the length of the filtered signal  				// '*2' because the filtering is on both real and imaginary parts'  				// '+1' for the DC.  				// No Nyquist component since the signal length is necessarily odd  				filteredLength = (bandIndexEnd-bandIndexStart)*2 + 1;    				// if the band is going to be too narrow  				if (envelopeDownsampledLength > filteredLength) {  					filteredLength = envelopeDownsampledLength;  				}    				// round the larger bands up to the next integer made of 2^n * 3^m  				if (envelopeDownsampledLength < filteredLength) {  					filteredLength = Util.NextLowPrimes(filteredLength);  				}    				Console.Write("{0'4:D}/{1:D} (FFT size: {2'6:D})   {3:f2} Hz - {4:f2} Hz\r"' bandCounter+1' bands' filteredLength' (double) bandIndexStart*samplerate/paddedLength' (double) bandIndexEnd*samplerate/paddedLength);    				int currentBandIndex = bands-bandCounter-1;  				  				@out[currentBandIndex] = new double[filteredLength+1];    				for (int i = 0; i < bandIndexLength-1; i++) {  					logFreqIterator = FrequencyToLogPosition((double)(i+bandIndexStart) / (double) paddedLength' minFreq' maxFreq); // calculation of the logarithmic position  					logFreqIterator = (logFreqIterator-logBandFreqStart)/(logBandFreqEnd-logBandFreqStart);  					coef = 0.5 - 0.5 * Math.Cos(2.0 * PI * logFreqIterator); // Hann function  					  					@out[currentBandIndex][i+1] = s[i+1+bandIndexStart] * coef;  					@out[currentBandIndex][filteredLength-1-i] = s[paddedLength-bandIndexStart-1-i] * coef;  				}  				#endregion    				#region 90 rotation  				filterBandRotated = new double[filteredLength+1];  				  				// Rotation : Re' = Im; Im' = -Re  				for (int i = 0; i < bandIndexLength-1; i++) {  					filterBandRotated[i+1] = @out[currentBandIndex][filteredLength-1-i]; // Re' = Im  					filterBandRotated[filteredLength-1-i] = -@out[currentBandIndex][i+1]; 	// Im' = -Re  				}  				#endregion    				#region Envelope detection    				// In-place IFFT of the filtered band signal  				FFT(ref @out[currentBandIndex]' ref @out[currentBandIndex]' filteredLength' FFTMethod.IDFT);  				  				// In-place IFFT of the filtered band signal rotated by 90  				FFT(ref filterBandRotated' ref filterBandRotated' filteredLength' FFTMethod.IDFT);    				for (int i = 0; i < filteredLength; i++) {  					// Magnitude of the analytic signal  					// out[bands-ib-1][i] = sqrt(out[bands-ib-1][i]*out[bands-ib-1][i] + h[i]*h[i]);  					double x = @out[currentBandIndex][i];  					double y = filterBandRotated[i];  					double mag = Math.Sqrt(x*x + y*y);  					@out[currentBandIndex][i] = mag;  				}  				#endregion    				#region Downsampling  				if (filteredLength < envelopeDownsampledLength) { // if the band doesn't have to be resampled  					Array.Resize<double>(ref @out[currentBandIndex]' envelopeDownsampledLength); // simply ignore the end of it  				}  				  				// If the band *has* to be downsampled  				if (filteredLength > envelopeDownsampledLength) {  					@out[currentBandIndex] = BlackmanDownsampling(@out[currentBandIndex]' filteredLength' envelopeDownsampledLength); // Blackman downsampling  				}  				#endregion    				// Tail chopping  				Array.Resize<double>(ref @out[currentBandIndex]' Xsize);  			}
Magic Number,ARSS,DSP,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\DSP.cs,Analyze,The following statement contains a magic number: for (int bandCounter = 0; bandCounter < bands; bandCounter++) {  				#region Filtering  				bandIndexStart = Util.RoundToClosestInt(LogPositionToFrequency((double)(bandCounter-1)/(double)(bands-1)' minFreq' maxFreq) * paddedLength);  				bandIndexEnd = Util.RoundToClosestInt(LogPositionToFrequency((double)(bandCounter+1)/(double)(bands-1)' minFreq' maxFreq) * paddedLength);  				logBandFreqStart = FrequencyToLogPosition((double) bandIndexStart / (double) paddedLength' minFreq' maxFreq);  				logBandFreqEnd = FrequencyToLogPosition((double) bandIndexEnd / (double) paddedLength' minFreq' maxFreq);    				// stop reading if reaching the Nyquist frequency  				if (bandIndexEnd > paddedLength/2) {  					bandIndexEnd = paddedLength/2;  				}    				// ensure the band index is at least 1  				if (bandIndexStart < 1) {  					bandIndexStart = 1;  				}    				// the actual band length  				int bandIndexLength = bandIndexEnd-bandIndexStart + 1;  				  				// Mc is the length of the filtered signal  				// '*2' because the filtering is on both real and imaginary parts'  				// '+1' for the DC.  				// No Nyquist component since the signal length is necessarily odd  				filteredLength = (bandIndexEnd-bandIndexStart)*2 + 1;    				// if the band is going to be too narrow  				if (envelopeDownsampledLength > filteredLength) {  					filteredLength = envelopeDownsampledLength;  				}    				// round the larger bands up to the next integer made of 2^n * 3^m  				if (envelopeDownsampledLength < filteredLength) {  					filteredLength = Util.NextLowPrimes(filteredLength);  				}    				Console.Write("{0'4:D}/{1:D} (FFT size: {2'6:D})   {3:f2} Hz - {4:f2} Hz\r"' bandCounter+1' bands' filteredLength' (double) bandIndexStart*samplerate/paddedLength' (double) bandIndexEnd*samplerate/paddedLength);    				int currentBandIndex = bands-bandCounter-1;  				  				@out[currentBandIndex] = new double[filteredLength+1];    				for (int i = 0; i < bandIndexLength-1; i++) {  					logFreqIterator = FrequencyToLogPosition((double)(i+bandIndexStart) / (double) paddedLength' minFreq' maxFreq); // calculation of the logarithmic position  					logFreqIterator = (logFreqIterator-logBandFreqStart)/(logBandFreqEnd-logBandFreqStart);  					coef = 0.5 - 0.5 * Math.Cos(2.0 * PI * logFreqIterator); // Hann function  					  					@out[currentBandIndex][i+1] = s[i+1+bandIndexStart] * coef;  					@out[currentBandIndex][filteredLength-1-i] = s[paddedLength-bandIndexStart-1-i] * coef;  				}  				#endregion    				#region 90 rotation  				filterBandRotated = new double[filteredLength+1];  				  				// Rotation : Re' = Im; Im' = -Re  				for (int i = 0; i < bandIndexLength-1; i++) {  					filterBandRotated[i+1] = @out[currentBandIndex][filteredLength-1-i]; // Re' = Im  					filterBandRotated[filteredLength-1-i] = -@out[currentBandIndex][i+1]; 	// Im' = -Re  				}  				#endregion    				#region Envelope detection    				// In-place IFFT of the filtered band signal  				FFT(ref @out[currentBandIndex]' ref @out[currentBandIndex]' filteredLength' FFTMethod.IDFT);  				  				// In-place IFFT of the filtered band signal rotated by 90  				FFT(ref filterBandRotated' ref filterBandRotated' filteredLength' FFTMethod.IDFT);    				for (int i = 0; i < filteredLength; i++) {  					// Magnitude of the analytic signal  					// out[bands-ib-1][i] = sqrt(out[bands-ib-1][i]*out[bands-ib-1][i] + h[i]*h[i]);  					double x = @out[currentBandIndex][i];  					double y = filterBandRotated[i];  					double mag = Math.Sqrt(x*x + y*y);  					@out[currentBandIndex][i] = mag;  				}  				#endregion    				#region Downsampling  				if (filteredLength < envelopeDownsampledLength) { // if the band doesn't have to be resampled  					Array.Resize<double>(ref @out[currentBandIndex]' envelopeDownsampledLength); // simply ignore the end of it  				}  				  				// If the band *has* to be downsampled  				if (filteredLength > envelopeDownsampledLength) {  					@out[currentBandIndex] = BlackmanDownsampling(@out[currentBandIndex]' filteredLength' envelopeDownsampledLength); // Blackman downsampling  				}  				#endregion    				// Tail chopping  				Array.Resize<double>(ref @out[currentBandIndex]' Xsize);  			}
Magic Number,ARSS,DSP,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\DSP.cs,Analyze,The following statement contains a magic number: for (int bandCounter = 0; bandCounter < bands; bandCounter++) {  				#region Filtering  				bandIndexStart = Util.RoundToClosestInt(LogPositionToFrequency((double)(bandCounter-1)/(double)(bands-1)' minFreq' maxFreq) * paddedLength);  				bandIndexEnd = Util.RoundToClosestInt(LogPositionToFrequency((double)(bandCounter+1)/(double)(bands-1)' minFreq' maxFreq) * paddedLength);  				logBandFreqStart = FrequencyToLogPosition((double) bandIndexStart / (double) paddedLength' minFreq' maxFreq);  				logBandFreqEnd = FrequencyToLogPosition((double) bandIndexEnd / (double) paddedLength' minFreq' maxFreq);    				// stop reading if reaching the Nyquist frequency  				if (bandIndexEnd > paddedLength/2) {  					bandIndexEnd = paddedLength/2;  				}    				// ensure the band index is at least 1  				if (bandIndexStart < 1) {  					bandIndexStart = 1;  				}    				// the actual band length  				int bandIndexLength = bandIndexEnd-bandIndexStart + 1;  				  				// Mc is the length of the filtered signal  				// '*2' because the filtering is on both real and imaginary parts'  				// '+1' for the DC.  				// No Nyquist component since the signal length is necessarily odd  				filteredLength = (bandIndexEnd-bandIndexStart)*2 + 1;    				// if the band is going to be too narrow  				if (envelopeDownsampledLength > filteredLength) {  					filteredLength = envelopeDownsampledLength;  				}    				// round the larger bands up to the next integer made of 2^n * 3^m  				if (envelopeDownsampledLength < filteredLength) {  					filteredLength = Util.NextLowPrimes(filteredLength);  				}    				Console.Write("{0'4:D}/{1:D} (FFT size: {2'6:D})   {3:f2} Hz - {4:f2} Hz\r"' bandCounter+1' bands' filteredLength' (double) bandIndexStart*samplerate/paddedLength' (double) bandIndexEnd*samplerate/paddedLength);    				int currentBandIndex = bands-bandCounter-1;  				  				@out[currentBandIndex] = new double[filteredLength+1];    				for (int i = 0; i < bandIndexLength-1; i++) {  					logFreqIterator = FrequencyToLogPosition((double)(i+bandIndexStart) / (double) paddedLength' minFreq' maxFreq); // calculation of the logarithmic position  					logFreqIterator = (logFreqIterator-logBandFreqStart)/(logBandFreqEnd-logBandFreqStart);  					coef = 0.5 - 0.5 * Math.Cos(2.0 * PI * logFreqIterator); // Hann function  					  					@out[currentBandIndex][i+1] = s[i+1+bandIndexStart] * coef;  					@out[currentBandIndex][filteredLength-1-i] = s[paddedLength-bandIndexStart-1-i] * coef;  				}  				#endregion    				#region 90 rotation  				filterBandRotated = new double[filteredLength+1];  				  				// Rotation : Re' = Im; Im' = -Re  				for (int i = 0; i < bandIndexLength-1; i++) {  					filterBandRotated[i+1] = @out[currentBandIndex][filteredLength-1-i]; // Re' = Im  					filterBandRotated[filteredLength-1-i] = -@out[currentBandIndex][i+1]; 	// Im' = -Re  				}  				#endregion    				#region Envelope detection    				// In-place IFFT of the filtered band signal  				FFT(ref @out[currentBandIndex]' ref @out[currentBandIndex]' filteredLength' FFTMethod.IDFT);  				  				// In-place IFFT of the filtered band signal rotated by 90  				FFT(ref filterBandRotated' ref filterBandRotated' filteredLength' FFTMethod.IDFT);    				for (int i = 0; i < filteredLength; i++) {  					// Magnitude of the analytic signal  					// out[bands-ib-1][i] = sqrt(out[bands-ib-1][i]*out[bands-ib-1][i] + h[i]*h[i]);  					double x = @out[currentBandIndex][i];  					double y = filterBandRotated[i];  					double mag = Math.Sqrt(x*x + y*y);  					@out[currentBandIndex][i] = mag;  				}  				#endregion    				#region Downsampling  				if (filteredLength < envelopeDownsampledLength) { // if the band doesn't have to be resampled  					Array.Resize<double>(ref @out[currentBandIndex]' envelopeDownsampledLength); // simply ignore the end of it  				}  				  				// If the band *has* to be downsampled  				if (filteredLength > envelopeDownsampledLength) {  					@out[currentBandIndex] = BlackmanDownsampling(@out[currentBandIndex]' filteredLength' envelopeDownsampledLength); // Blackman downsampling  				}  				#endregion    				// Tail chopping  				Array.Resize<double>(ref @out[currentBandIndex]' Xsize);  			}
Magic Number,ARSS,DSP,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\DSP.cs,WindowedSincMax,The following statement contains a magic number: for (int i = 0; i < bwl; i++) {  				x = (double) i / tbw; // position calculation between 0.0 and 1.0  				// antiderivative of the Blackman window function  				coef = 0.42 * x - (0.5/(2.0 * PI)) * Math.Sin(2.0 * PI * x) + (0.08/(4.0 * PI)) * Math.Sin(4.0 *PI *x);  				coef *= 1.0 / 0.42;  				h[i+1] = coef;  				h[length-1-i] = coef;  			}
Magic Number,ARSS,DSP,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\DSP.cs,WindowedSincMax,The following statement contains a magic number: for (int i = 0; i < bwl; i++) {  				x = (double) i / tbw; // position calculation between 0.0 and 1.0  				// antiderivative of the Blackman window function  				coef = 0.42 * x - (0.5/(2.0 * PI)) * Math.Sin(2.0 * PI * x) + (0.08/(4.0 * PI)) * Math.Sin(4.0 *PI *x);  				coef *= 1.0 / 0.42;  				h[i+1] = coef;  				h[length-1-i] = coef;  			}
Magic Number,ARSS,DSP,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\DSP.cs,WindowedSincMax,The following statement contains a magic number: for (int i = 0; i < bwl; i++) {  				x = (double) i / tbw; // position calculation between 0.0 and 1.0  				// antiderivative of the Blackman window function  				coef = 0.42 * x - (0.5/(2.0 * PI)) * Math.Sin(2.0 * PI * x) + (0.08/(4.0 * PI)) * Math.Sin(4.0 *PI *x);  				coef *= 1.0 / 0.42;  				h[i+1] = coef;  				h[length-1-i] = coef;  			}
Magic Number,ARSS,DSP,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\DSP.cs,WindowedSincMax,The following statement contains a magic number: for (int i = 0; i < bwl; i++) {  				x = (double) i / tbw; // position calculation between 0.0 and 1.0  				// antiderivative of the Blackman window function  				coef = 0.42 * x - (0.5/(2.0 * PI)) * Math.Sin(2.0 * PI * x) + (0.08/(4.0 * PI)) * Math.Sin(4.0 *PI *x);  				coef *= 1.0 / 0.42;  				h[i+1] = coef;  				h[length-1-i] = coef;  			}
Magic Number,ARSS,DSP,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\DSP.cs,WindowedSincMax,The following statement contains a magic number: for (int i = 0; i < bwl; i++) {  				x = (double) i / tbw; // position calculation between 0.0 and 1.0  				// antiderivative of the Blackman window function  				coef = 0.42 * x - (0.5/(2.0 * PI)) * Math.Sin(2.0 * PI * x) + (0.08/(4.0 * PI)) * Math.Sin(4.0 *PI *x);  				coef *= 1.0 / 0.42;  				h[i+1] = coef;  				h[length-1-i] = coef;  			}
Magic Number,ARSS,DSP,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\DSP.cs,WindowedSincMax,The following statement contains a magic number: for (int i = 0; i < bwl; i++) {  				x = (double) i / tbw; // position calculation between 0.0 and 1.0  				// antiderivative of the Blackman window function  				coef = 0.42 * x - (0.5/(2.0 * PI)) * Math.Sin(2.0 * PI * x) + (0.08/(4.0 * PI)) * Math.Sin(4.0 *PI *x);  				coef *= 1.0 / 0.42;  				h[i+1] = coef;  				h[length-1-i] = coef;  			}
Magic Number,ARSS,DSP,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\DSP.cs,WindowedSincMax,The following statement contains a magic number: for (int i = 0; i < bwl; i++) {  				x = (double) i / tbw; // position calculation between 0.0 and 1.0  				// antiderivative of the Blackman window function  				coef = 0.42 * x - (0.5/(2.0 * PI)) * Math.Sin(2.0 * PI * x) + (0.08/(4.0 * PI)) * Math.Sin(4.0 *PI *x);  				coef *= 1.0 / 0.42;  				h[i+1] = coef;  				h[length-1-i] = coef;  			}
Magic Number,ARSS,DSP,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\DSP.cs,WindowedSincMax,The following statement contains a magic number: for (int i = 0; i < bwl; i++) {  				x = (double) i / tbw; // position calculation between 0.0 and 1.0  				// antiderivative of the Blackman window function  				coef = 0.42 * x - (0.5/(2.0 * PI)) * Math.Sin(2.0 * PI * x) + (0.08/(4.0 * PI)) * Math.Sin(4.0 *PI *x);  				coef *= 1.0 / 0.42;  				h[i+1] = coef;  				h[length-1-i] = coef;  			}
Magic Number,ARSS,DSP,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\DSP.cs,SynthesizeSine,The following statement contains a magic number: var sine = new double[4];
Magic Number,ARSS,DSP,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\DSP.cs,SynthesizeSine,The following statement contains a magic number: shiftedBandSize = Util.NextLowPrimes(Xsize * 2);
Magic Number,ARSS,DSP,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\DSP.cs,SynthesizeSine,The following statement contains a magic number: samplecount = Util.RoundToClosestInt(0.5 * (double) shiftedBandSize/pixpersec);
Magic Number,ARSS,DSP,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\DSP.cs,SynthesizeSine,The following statement contains a magic number: shiftedBandCenterIndex = Util.RoundToClosestInt(0.25 * (double) shiftedBandSize);
Magic Number,ARSS,DSP,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\DSP.cs,SynthesizeSine,The following statement contains a magic number: for (int bandCounter = 0; bandCounter < bands; bandCounter++) {  				  				// reset sband  				Array.Clear(shiftedBand' 0' shiftedBand.Length);  				  				#region Frequency shifting  				rphase = Util.DoubleRandom() * PI; // random phase between -pi and +pi    				for (int i = 0; i < 4; i++) {  					// generating the random sine LUT (look up table)  					sine[i] = Math.Cos(i * 2.0 * PI * 0.25 + rphase);  				}    				int currentBandIndex = bands-bandCounter-1;  				for (int i = 0; i < Xsize; i++) { // envelope sampling rate * 2 and frequency shifting by 0.25  					if ((i & 1) == 0) {  						shiftedBand[i<<1] = d[currentBandIndex][i] * sine[0];  						shiftedBand[(i<<1) + 1] = d[currentBandIndex][i] * sine[1];  					} else {  						shiftedBand[i<<1] = d[currentBandIndex][i] * sine[2];  						shiftedBand[(i<<1) + 1] = d[currentBandIndex][i] * sine[3];  					}  				}  				#endregion Frequency shifting    				// FFT of the envelope  				FFT(ref shiftedBand' ref shiftedBand' shiftedBandSize' FFTMethod.DFT);  				  				// Fc is the index of the band's centre in the frequency domain on the new signal  				newSignalBandCenterIndex = Util.RoundToClosestInt(freq[bandCounter] * samplecount); // band's centre index (envelope's DC element)    				Console.Write("{0'4:D}/{1:D}   {2:f2} Hz\r"' bandCounter+1' bands' (double) newSignalBandCenterIndex * samplerate / samplecount);    				#region Write FFT  				for (int i = 1; i < envelopeFFTSize; i++) {  					// if we're between frequencies 0 and 0.5 of the new signal and that we're not at Fc (newSignalBandCenterIndex)  					if (newSignalBandCenterIndex-shiftedBandCenterIndex+i > 0 && newSignalBandCenterIndex-shiftedBandCenterIndex+i < soundFFTSize) {  						s[i+newSignalBandCenterIndex-shiftedBandCenterIndex] += shiftedBand[i] * filter[i]; // Real part  						s[samplecount-(i+newSignalBandCenterIndex-shiftedBandCenterIndex)] += shiftedBand[shiftedBandSize-i] * filter[i]; // Imaginary part  					}  				}  				#endregion Write FFT  			}
Magic Number,ARSS,DSP,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\DSP.cs,SynthesizeSine,The following statement contains a magic number: for (int bandCounter = 0; bandCounter < bands; bandCounter++) {  				  				// reset sband  				Array.Clear(shiftedBand' 0' shiftedBand.Length);  				  				#region Frequency shifting  				rphase = Util.DoubleRandom() * PI; // random phase between -pi and +pi    				for (int i = 0; i < 4; i++) {  					// generating the random sine LUT (look up table)  					sine[i] = Math.Cos(i * 2.0 * PI * 0.25 + rphase);  				}    				int currentBandIndex = bands-bandCounter-1;  				for (int i = 0; i < Xsize; i++) { // envelope sampling rate * 2 and frequency shifting by 0.25  					if ((i & 1) == 0) {  						shiftedBand[i<<1] = d[currentBandIndex][i] * sine[0];  						shiftedBand[(i<<1) + 1] = d[currentBandIndex][i] * sine[1];  					} else {  						shiftedBand[i<<1] = d[currentBandIndex][i] * sine[2];  						shiftedBand[(i<<1) + 1] = d[currentBandIndex][i] * sine[3];  					}  				}  				#endregion Frequency shifting    				// FFT of the envelope  				FFT(ref shiftedBand' ref shiftedBand' shiftedBandSize' FFTMethod.DFT);  				  				// Fc is the index of the band's centre in the frequency domain on the new signal  				newSignalBandCenterIndex = Util.RoundToClosestInt(freq[bandCounter] * samplecount); // band's centre index (envelope's DC element)    				Console.Write("{0'4:D}/{1:D}   {2:f2} Hz\r"' bandCounter+1' bands' (double) newSignalBandCenterIndex * samplerate / samplecount);    				#region Write FFT  				for (int i = 1; i < envelopeFFTSize; i++) {  					// if we're between frequencies 0 and 0.5 of the new signal and that we're not at Fc (newSignalBandCenterIndex)  					if (newSignalBandCenterIndex-shiftedBandCenterIndex+i > 0 && newSignalBandCenterIndex-shiftedBandCenterIndex+i < soundFFTSize) {  						s[i+newSignalBandCenterIndex-shiftedBandCenterIndex] += shiftedBand[i] * filter[i]; // Real part  						s[samplecount-(i+newSignalBandCenterIndex-shiftedBandCenterIndex)] += shiftedBand[shiftedBandSize-i] * filter[i]; // Imaginary part  					}  				}  				#endregion Write FFT  			}
Magic Number,ARSS,DSP,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\DSP.cs,SynthesizeSine,The following statement contains a magic number: for (int bandCounter = 0; bandCounter < bands; bandCounter++) {  				  				// reset sband  				Array.Clear(shiftedBand' 0' shiftedBand.Length);  				  				#region Frequency shifting  				rphase = Util.DoubleRandom() * PI; // random phase between -pi and +pi    				for (int i = 0; i < 4; i++) {  					// generating the random sine LUT (look up table)  					sine[i] = Math.Cos(i * 2.0 * PI * 0.25 + rphase);  				}    				int currentBandIndex = bands-bandCounter-1;  				for (int i = 0; i < Xsize; i++) { // envelope sampling rate * 2 and frequency shifting by 0.25  					if ((i & 1) == 0) {  						shiftedBand[i<<1] = d[currentBandIndex][i] * sine[0];  						shiftedBand[(i<<1) + 1] = d[currentBandIndex][i] * sine[1];  					} else {  						shiftedBand[i<<1] = d[currentBandIndex][i] * sine[2];  						shiftedBand[(i<<1) + 1] = d[currentBandIndex][i] * sine[3];  					}  				}  				#endregion Frequency shifting    				// FFT of the envelope  				FFT(ref shiftedBand' ref shiftedBand' shiftedBandSize' FFTMethod.DFT);  				  				// Fc is the index of the band's centre in the frequency domain on the new signal  				newSignalBandCenterIndex = Util.RoundToClosestInt(freq[bandCounter] * samplecount); // band's centre index (envelope's DC element)    				Console.Write("{0'4:D}/{1:D}   {2:f2} Hz\r"' bandCounter+1' bands' (double) newSignalBandCenterIndex * samplerate / samplecount);    				#region Write FFT  				for (int i = 1; i < envelopeFFTSize; i++) {  					// if we're between frequencies 0 and 0.5 of the new signal and that we're not at Fc (newSignalBandCenterIndex)  					if (newSignalBandCenterIndex-shiftedBandCenterIndex+i > 0 && newSignalBandCenterIndex-shiftedBandCenterIndex+i < soundFFTSize) {  						s[i+newSignalBandCenterIndex-shiftedBandCenterIndex] += shiftedBand[i] * filter[i]; // Real part  						s[samplecount-(i+newSignalBandCenterIndex-shiftedBandCenterIndex)] += shiftedBand[shiftedBandSize-i] * filter[i]; // Imaginary part  					}  				}  				#endregion Write FFT  			}
Magic Number,ARSS,DSP,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\DSP.cs,SynthesizeSine,The following statement contains a magic number: for (int bandCounter = 0; bandCounter < bands; bandCounter++) {  				  				// reset sband  				Array.Clear(shiftedBand' 0' shiftedBand.Length);  				  				#region Frequency shifting  				rphase = Util.DoubleRandom() * PI; // random phase between -pi and +pi    				for (int i = 0; i < 4; i++) {  					// generating the random sine LUT (look up table)  					sine[i] = Math.Cos(i * 2.0 * PI * 0.25 + rphase);  				}    				int currentBandIndex = bands-bandCounter-1;  				for (int i = 0; i < Xsize; i++) { // envelope sampling rate * 2 and frequency shifting by 0.25  					if ((i & 1) == 0) {  						shiftedBand[i<<1] = d[currentBandIndex][i] * sine[0];  						shiftedBand[(i<<1) + 1] = d[currentBandIndex][i] * sine[1];  					} else {  						shiftedBand[i<<1] = d[currentBandIndex][i] * sine[2];  						shiftedBand[(i<<1) + 1] = d[currentBandIndex][i] * sine[3];  					}  				}  				#endregion Frequency shifting    				// FFT of the envelope  				FFT(ref shiftedBand' ref shiftedBand' shiftedBandSize' FFTMethod.DFT);  				  				// Fc is the index of the band's centre in the frequency domain on the new signal  				newSignalBandCenterIndex = Util.RoundToClosestInt(freq[bandCounter] * samplecount); // band's centre index (envelope's DC element)    				Console.Write("{0'4:D}/{1:D}   {2:f2} Hz\r"' bandCounter+1' bands' (double) newSignalBandCenterIndex * samplerate / samplecount);    				#region Write FFT  				for (int i = 1; i < envelopeFFTSize; i++) {  					// if we're between frequencies 0 and 0.5 of the new signal and that we're not at Fc (newSignalBandCenterIndex)  					if (newSignalBandCenterIndex-shiftedBandCenterIndex+i > 0 && newSignalBandCenterIndex-shiftedBandCenterIndex+i < soundFFTSize) {  						s[i+newSignalBandCenterIndex-shiftedBandCenterIndex] += shiftedBand[i] * filter[i]; // Real part  						s[samplecount-(i+newSignalBandCenterIndex-shiftedBandCenterIndex)] += shiftedBand[shiftedBandSize-i] * filter[i]; // Imaginary part  					}  				}  				#endregion Write FFT  			}
Magic Number,ARSS,DSP,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\DSP.cs,SynthesizeSine,The following statement contains a magic number: for (int bandCounter = 0; bandCounter < bands; bandCounter++) {  				  				// reset sband  				Array.Clear(shiftedBand' 0' shiftedBand.Length);  				  				#region Frequency shifting  				rphase = Util.DoubleRandom() * PI; // random phase between -pi and +pi    				for (int i = 0; i < 4; i++) {  					// generating the random sine LUT (look up table)  					sine[i] = Math.Cos(i * 2.0 * PI * 0.25 + rphase);  				}    				int currentBandIndex = bands-bandCounter-1;  				for (int i = 0; i < Xsize; i++) { // envelope sampling rate * 2 and frequency shifting by 0.25  					if ((i & 1) == 0) {  						shiftedBand[i<<1] = d[currentBandIndex][i] * sine[0];  						shiftedBand[(i<<1) + 1] = d[currentBandIndex][i] * sine[1];  					} else {  						shiftedBand[i<<1] = d[currentBandIndex][i] * sine[2];  						shiftedBand[(i<<1) + 1] = d[currentBandIndex][i] * sine[3];  					}  				}  				#endregion Frequency shifting    				// FFT of the envelope  				FFT(ref shiftedBand' ref shiftedBand' shiftedBandSize' FFTMethod.DFT);  				  				// Fc is the index of the band's centre in the frequency domain on the new signal  				newSignalBandCenterIndex = Util.RoundToClosestInt(freq[bandCounter] * samplecount); // band's centre index (envelope's DC element)    				Console.Write("{0'4:D}/{1:D}   {2:f2} Hz\r"' bandCounter+1' bands' (double) newSignalBandCenterIndex * samplerate / samplecount);    				#region Write FFT  				for (int i = 1; i < envelopeFFTSize; i++) {  					// if we're between frequencies 0 and 0.5 of the new signal and that we're not at Fc (newSignalBandCenterIndex)  					if (newSignalBandCenterIndex-shiftedBandCenterIndex+i > 0 && newSignalBandCenterIndex-shiftedBandCenterIndex+i < soundFFTSize) {  						s[i+newSignalBandCenterIndex-shiftedBandCenterIndex] += shiftedBand[i] * filter[i]; // Real part  						s[samplecount-(i+newSignalBandCenterIndex-shiftedBandCenterIndex)] += shiftedBand[shiftedBandSize-i] * filter[i]; // Imaginary part  					}  				}  				#endregion Write FFT  			}
Magic Number,ARSS,DSP,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\DSP.cs,SynthesizeNoise,The following statement contains a magic number: if (LOGBASE == 1.0) {  				// linear mode  				loop_size_min = Util.RoundToClosestInt(4.0 * 5.0/ freq[1]-freq[0]);  			} else {  				// this is the estimate of how many samples the longest FIR  				// will take up in the time domain  				loop_size_min = Util.RoundToClosestInt(2.0 * 5.0/((freq[0] * Math.Pow(2.0' -1.0/bpo)) * (1.0 - Math.Pow(2.0' -1.0/bpo))));  			}
Magic Number,ARSS,DSP,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\DSP.cs,SynthesizeNoise,The following statement contains a magic number: if (LOGBASE == 1.0) {  				// linear mode  				loop_size_min = Util.RoundToClosestInt(4.0 * 5.0/ freq[1]-freq[0]);  			} else {  				// this is the estimate of how many samples the longest FIR  				// will take up in the time domain  				loop_size_min = Util.RoundToClosestInt(2.0 * 5.0/((freq[0] * Math.Pow(2.0' -1.0/bpo)) * (1.0 - Math.Pow(2.0' -1.0/bpo))));  			}
Magic Number,ARSS,DSP,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\DSP.cs,SynthesizeNoise,The following statement contains a magic number: if (LOGBASE == 1.0) {  				// linear mode  				loop_size_min = Util.RoundToClosestInt(4.0 * 5.0/ freq[1]-freq[0]);  			} else {  				// this is the estimate of how many samples the longest FIR  				// will take up in the time domain  				loop_size_min = Util.RoundToClosestInt(2.0 * 5.0/((freq[0] * Math.Pow(2.0' -1.0/bpo)) * (1.0 - Math.Pow(2.0' -1.0/bpo))));  			}
Magic Number,ARSS,DSP,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\DSP.cs,SynthesizeNoise,The following statement contains a magic number: if (LOGBASE == 1.0) {  				// linear mode  				loop_size_min = Util.RoundToClosestInt(4.0 * 5.0/ freq[1]-freq[0]);  			} else {  				// this is the estimate of how many samples the longest FIR  				// will take up in the time domain  				loop_size_min = Util.RoundToClosestInt(2.0 * 5.0/((freq[0] * Math.Pow(2.0' -1.0/bpo)) * (1.0 - Math.Pow(2.0' -1.0/bpo))));  			}
Magic Number,ARSS,DSP,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\DSP.cs,SynthesizeNoise,The following statement contains a magic number: if (LOGBASE == 1.0) {  				// linear mode  				loop_size_min = Util.RoundToClosestInt(4.0 * 5.0/ freq[1]-freq[0]);  			} else {  				// this is the estimate of how many samples the longest FIR  				// will take up in the time domain  				loop_size_min = Util.RoundToClosestInt(2.0 * 5.0/((freq[0] * Math.Pow(2.0' -1.0/bpo)) * (1.0 - Math.Pow(2.0' -1.0/bpo))));  			}
Magic Number,ARSS,DSP,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\DSP.cs,SynthesizeNoise,The following statement contains a magic number: if (LOGBASE == 1.0) {  				// linear mode  				loop_size_min = Util.RoundToClosestInt(4.0 * 5.0/ freq[1]-freq[0]);  			} else {  				// this is the estimate of how many samples the longest FIR  				// will take up in the time domain  				loop_size_min = Util.RoundToClosestInt(2.0 * 5.0/((freq[0] * Math.Pow(2.0' -1.0/bpo)) * (1.0 - Math.Pow(2.0' -1.0/bpo))));  			}
Magic Number,ARSS,DSP,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\DSP.cs,SynthesizeNoise,The following statement contains a magic number: for (int i = 1; i < (loop_size+1)>>1; i++) {  				mag = Math.Pow((double) i' 0.5 - 0.5 * LOGBASE); // FIXME something's not necessarily right with that formula  				phase = Util.DoubleRandom() * PI; // random phase between -pi and +pi    				pink_noise[i] = mag * Math.Cos(phase); // real part  				pink_noise[loop_size-i] = mag * Math.Sin(phase); // imaginary part  			}
Magic Number,ARSS,DSP,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\DSP.cs,SynthesizeNoise,The following statement contains a magic number: for (int i = 1; i < (loop_size+1)>>1; i++) {  				mag = Math.Pow((double) i' 0.5 - 0.5 * LOGBASE); // FIXME something's not necessarily right with that formula  				phase = Util.DoubleRandom() * PI; // random phase between -pi and +pi    				pink_noise[i] = mag * Math.Cos(phase); // real part  				pink_noise[loop_size-i] = mag * Math.Sin(phase); // imaginary part  			}
Magic Number,ARSS,DSP,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\DSP.cs,SynthesizeNoise,The following statement contains a magic number: for (int ib = 0; ib < bands; ib++) {  				// reset filtered noise  				Array.Clear(noise' 0' noise.Length);  				  				#region Filtering  				bandIndexStart = Util.RoundToClosestInt(LogPositionToFrequency((double)(ib-1)/(double)(bands-1)' minFreq' maxfreq) * loop_size);  				bandIndexEnd = Util.RoundToClosestInt(LogPositionToFrequency((double)(ib+1)/(double)(bands-1)' minFreq' maxfreq) * loop_size);  				LogBandFreqStart = FrequencyToLogPosition((double) bandIndexStart / (double) loop_size' minFreq' maxfreq);  				LogBandFreqEnd = FrequencyToLogPosition((double) bandIndexEnd / (double) loop_size' minFreq' maxfreq);    				if (bandIndexEnd > loop_size/2) {  					bandIndexEnd = loop_size/2; // stop reading if reaching the Nyquist frequency  				}    				if (bandIndexStart < 1) {  					bandIndexStart = 1;  				}    				Console.Write("{0'4:D}/{1:D}   {2:f2} Hz - {3:f2} Hz\r"' ib+1' bands' (double) bandIndexStart *samplerate/loop_size' (double) bandIndexEnd *samplerate/loop_size);    				for (int i = bandIndexStart; i < bandIndexEnd; i++) {  					LogFreqIterator = FrequencyToLogPosition((double) i / (double) loop_size' minFreq' maxfreq); // calculation of the logarithmic position  					LogFreqIterator = (LogFreqIterator-LogBandFreqStart)/(LogBandFreqEnd-LogBandFreqStart);  					coef = 0.5 - 0.5 *Math.Cos(2.0 * PI * LogFreqIterator); // Hann function  					noise[i+1] = pink_noise[i+1] * coef;  					noise[loop_size-1-i] = pink_noise[loop_size-1-i] * coef;  				}  				#endregion Filtering    				// IFFT of the filtered noise  				FFT(ref noise' ref noise' loop_size' FFTMethod.IDFT);  				  				// allocation of the interpolated envelope  				envelope = new double[samplecount];  				  				// interpolation of the envelope  				// this is the slowest part of the noise synthesis  				BlackmanSquareInterpolation(ref d[bands-ib-1]' ref envelope' ref Xsize' ref samplecount' ref lut' BMSQ_LUT_SIZE);  				  				int il = 0;  				for (int i = 0; i < samplecount; i++)  				{  					s[i] += envelope[i] * noise[il]; // modulation  					il++; // increment loop iterator  					  					// if the array iterator has reached the end of the array' it's reset  					if (il == loop_size) {  						il = 0;  					}  				}  			}
Magic Number,ARSS,DSP,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\DSP.cs,SynthesizeNoise,The following statement contains a magic number: for (int ib = 0; ib < bands; ib++) {  				// reset filtered noise  				Array.Clear(noise' 0' noise.Length);  				  				#region Filtering  				bandIndexStart = Util.RoundToClosestInt(LogPositionToFrequency((double)(ib-1)/(double)(bands-1)' minFreq' maxfreq) * loop_size);  				bandIndexEnd = Util.RoundToClosestInt(LogPositionToFrequency((double)(ib+1)/(double)(bands-1)' minFreq' maxfreq) * loop_size);  				LogBandFreqStart = FrequencyToLogPosition((double) bandIndexStart / (double) loop_size' minFreq' maxfreq);  				LogBandFreqEnd = FrequencyToLogPosition((double) bandIndexEnd / (double) loop_size' minFreq' maxfreq);    				if (bandIndexEnd > loop_size/2) {  					bandIndexEnd = loop_size/2; // stop reading if reaching the Nyquist frequency  				}    				if (bandIndexStart < 1) {  					bandIndexStart = 1;  				}    				Console.Write("{0'4:D}/{1:D}   {2:f2} Hz - {3:f2} Hz\r"' ib+1' bands' (double) bandIndexStart *samplerate/loop_size' (double) bandIndexEnd *samplerate/loop_size);    				for (int i = bandIndexStart; i < bandIndexEnd; i++) {  					LogFreqIterator = FrequencyToLogPosition((double) i / (double) loop_size' minFreq' maxfreq); // calculation of the logarithmic position  					LogFreqIterator = (LogFreqIterator-LogBandFreqStart)/(LogBandFreqEnd-LogBandFreqStart);  					coef = 0.5 - 0.5 *Math.Cos(2.0 * PI * LogFreqIterator); // Hann function  					noise[i+1] = pink_noise[i+1] * coef;  					noise[loop_size-1-i] = pink_noise[loop_size-1-i] * coef;  				}  				#endregion Filtering    				// IFFT of the filtered noise  				FFT(ref noise' ref noise' loop_size' FFTMethod.IDFT);  				  				// allocation of the interpolated envelope  				envelope = new double[samplecount];  				  				// interpolation of the envelope  				// this is the slowest part of the noise synthesis  				BlackmanSquareInterpolation(ref d[bands-ib-1]' ref envelope' ref Xsize' ref samplecount' ref lut' BMSQ_LUT_SIZE);  				  				int il = 0;  				for (int i = 0; i < samplecount; i++)  				{  					s[i] += envelope[i] * noise[il]; // modulation  					il++; // increment loop iterator  					  					// if the array iterator has reached the end of the array' it's reset  					if (il == loop_size) {  						il = 0;  					}  				}  			}
Magic Number,ARSS,DSP,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\DSP.cs,SynthesizeNoise,The following statement contains a magic number: for (int ib = 0; ib < bands; ib++) {  				// reset filtered noise  				Array.Clear(noise' 0' noise.Length);  				  				#region Filtering  				bandIndexStart = Util.RoundToClosestInt(LogPositionToFrequency((double)(ib-1)/(double)(bands-1)' minFreq' maxfreq) * loop_size);  				bandIndexEnd = Util.RoundToClosestInt(LogPositionToFrequency((double)(ib+1)/(double)(bands-1)' minFreq' maxfreq) * loop_size);  				LogBandFreqStart = FrequencyToLogPosition((double) bandIndexStart / (double) loop_size' minFreq' maxfreq);  				LogBandFreqEnd = FrequencyToLogPosition((double) bandIndexEnd / (double) loop_size' minFreq' maxfreq);    				if (bandIndexEnd > loop_size/2) {  					bandIndexEnd = loop_size/2; // stop reading if reaching the Nyquist frequency  				}    				if (bandIndexStart < 1) {  					bandIndexStart = 1;  				}    				Console.Write("{0'4:D}/{1:D}   {2:f2} Hz - {3:f2} Hz\r"' ib+1' bands' (double) bandIndexStart *samplerate/loop_size' (double) bandIndexEnd *samplerate/loop_size);    				for (int i = bandIndexStart; i < bandIndexEnd; i++) {  					LogFreqIterator = FrequencyToLogPosition((double) i / (double) loop_size' minFreq' maxfreq); // calculation of the logarithmic position  					LogFreqIterator = (LogFreqIterator-LogBandFreqStart)/(LogBandFreqEnd-LogBandFreqStart);  					coef = 0.5 - 0.5 *Math.Cos(2.0 * PI * LogFreqIterator); // Hann function  					noise[i+1] = pink_noise[i+1] * coef;  					noise[loop_size-1-i] = pink_noise[loop_size-1-i] * coef;  				}  				#endregion Filtering    				// IFFT of the filtered noise  				FFT(ref noise' ref noise' loop_size' FFTMethod.IDFT);  				  				// allocation of the interpolated envelope  				envelope = new double[samplecount];  				  				// interpolation of the envelope  				// this is the slowest part of the noise synthesis  				BlackmanSquareInterpolation(ref d[bands-ib-1]' ref envelope' ref Xsize' ref samplecount' ref lut' BMSQ_LUT_SIZE);  				  				int il = 0;  				for (int i = 0; i < samplecount; i++)  				{  					s[i] += envelope[i] * noise[il]; // modulation  					il++; // increment loop iterator  					  					// if the array iterator has reached the end of the array' it's reset  					if (il == loop_size) {  						il = 0;  					}  				}  			}
Magic Number,ARSS,DSP,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\DSP.cs,SynthesizeNoise,The following statement contains a magic number: for (int ib = 0; ib < bands; ib++) {  				// reset filtered noise  				Array.Clear(noise' 0' noise.Length);  				  				#region Filtering  				bandIndexStart = Util.RoundToClosestInt(LogPositionToFrequency((double)(ib-1)/(double)(bands-1)' minFreq' maxfreq) * loop_size);  				bandIndexEnd = Util.RoundToClosestInt(LogPositionToFrequency((double)(ib+1)/(double)(bands-1)' minFreq' maxfreq) * loop_size);  				LogBandFreqStart = FrequencyToLogPosition((double) bandIndexStart / (double) loop_size' minFreq' maxfreq);  				LogBandFreqEnd = FrequencyToLogPosition((double) bandIndexEnd / (double) loop_size' minFreq' maxfreq);    				if (bandIndexEnd > loop_size/2) {  					bandIndexEnd = loop_size/2; // stop reading if reaching the Nyquist frequency  				}    				if (bandIndexStart < 1) {  					bandIndexStart = 1;  				}    				Console.Write("{0'4:D}/{1:D}   {2:f2} Hz - {3:f2} Hz\r"' ib+1' bands' (double) bandIndexStart *samplerate/loop_size' (double) bandIndexEnd *samplerate/loop_size);    				for (int i = bandIndexStart; i < bandIndexEnd; i++) {  					LogFreqIterator = FrequencyToLogPosition((double) i / (double) loop_size' minFreq' maxfreq); // calculation of the logarithmic position  					LogFreqIterator = (LogFreqIterator-LogBandFreqStart)/(LogBandFreqEnd-LogBandFreqStart);  					coef = 0.5 - 0.5 *Math.Cos(2.0 * PI * LogFreqIterator); // Hann function  					noise[i+1] = pink_noise[i+1] * coef;  					noise[loop_size-1-i] = pink_noise[loop_size-1-i] * coef;  				}  				#endregion Filtering    				// IFFT of the filtered noise  				FFT(ref noise' ref noise' loop_size' FFTMethod.IDFT);  				  				// allocation of the interpolated envelope  				envelope = new double[samplecount];  				  				// interpolation of the envelope  				// this is the slowest part of the noise synthesis  				BlackmanSquareInterpolation(ref d[bands-ib-1]' ref envelope' ref Xsize' ref samplecount' ref lut' BMSQ_LUT_SIZE);  				  				int il = 0;  				for (int i = 0; i < samplecount; i++)  				{  					s[i] += envelope[i] * noise[il]; // modulation  					il++; // increment loop iterator  					  					// if the array iterator has reached the end of the array' it's reset  					if (il == loop_size) {  						il = 0;  					}  				}  			}
Magic Number,ARSS,DSP,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\DSP.cs,SynthesizeNoise,The following statement contains a magic number: for (int ib = 0; ib < bands; ib++) {  				// reset filtered noise  				Array.Clear(noise' 0' noise.Length);  				  				#region Filtering  				bandIndexStart = Util.RoundToClosestInt(LogPositionToFrequency((double)(ib-1)/(double)(bands-1)' minFreq' maxfreq) * loop_size);  				bandIndexEnd = Util.RoundToClosestInt(LogPositionToFrequency((double)(ib+1)/(double)(bands-1)' minFreq' maxfreq) * loop_size);  				LogBandFreqStart = FrequencyToLogPosition((double) bandIndexStart / (double) loop_size' minFreq' maxfreq);  				LogBandFreqEnd = FrequencyToLogPosition((double) bandIndexEnd / (double) loop_size' minFreq' maxfreq);    				if (bandIndexEnd > loop_size/2) {  					bandIndexEnd = loop_size/2; // stop reading if reaching the Nyquist frequency  				}    				if (bandIndexStart < 1) {  					bandIndexStart = 1;  				}    				Console.Write("{0'4:D}/{1:D}   {2:f2} Hz - {3:f2} Hz\r"' ib+1' bands' (double) bandIndexStart *samplerate/loop_size' (double) bandIndexEnd *samplerate/loop_size);    				for (int i = bandIndexStart; i < bandIndexEnd; i++) {  					LogFreqIterator = FrequencyToLogPosition((double) i / (double) loop_size' minFreq' maxfreq); // calculation of the logarithmic position  					LogFreqIterator = (LogFreqIterator-LogBandFreqStart)/(LogBandFreqEnd-LogBandFreqStart);  					coef = 0.5 - 0.5 *Math.Cos(2.0 * PI * LogFreqIterator); // Hann function  					noise[i+1] = pink_noise[i+1] * coef;  					noise[loop_size-1-i] = pink_noise[loop_size-1-i] * coef;  				}  				#endregion Filtering    				// IFFT of the filtered noise  				FFT(ref noise' ref noise' loop_size' FFTMethod.IDFT);  				  				// allocation of the interpolated envelope  				envelope = new double[samplecount];  				  				// interpolation of the envelope  				// this is the slowest part of the noise synthesis  				BlackmanSquareInterpolation(ref d[bands-ib-1]' ref envelope' ref Xsize' ref samplecount' ref lut' BMSQ_LUT_SIZE);  				  				int il = 0;  				for (int i = 0; i < samplecount; i++)  				{  					s[i] += envelope[i] * noise[il]; // modulation  					il++; // increment loop iterator  					  					// if the array iterator has reached the end of the array' it's reset  					if (il == loop_size) {  						il = 0;  					}  				}  			}
Magic Number,ARSS,DSP,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\DSP.cs,LogPositionToFrequency,The following statement contains a magic number: if (LOGBASE == 1.0) {  				return x * (max - min) + min;  			} else {  				double logMin = Math.Log(min);  				double logMax = Math.Log(max);  				double delta = (logMax - logMin) / Math.Log(2.0);  				  				return (max - min) * (min * Math.Pow(LOGBASE' x * delta) - min) / (min * Math.Pow(LOGBASE' delta) - min) + min;  			}
Magic Number,ARSS,DSP,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\DSP.cs,FrequencyToLogPosition,The following statement contains a magic number: if (LOGBASE == 1.0) {  				return (x - min)/(max-min);  			} else {  				double logMin = Math.Log(min);  				double logMax = Math.Log(max);  				double delta = (logMax - logMin);  				double logDelta = delta / Math.Log(2.0);    				return Math.Log(((x - min) * (min * Math.Pow(LOGBASE' logDelta) - min) / (max - min) + min) / Math.Log(LOGBASE)) * Math.Log(2.0) / delta;  			}
Magic Number,ARSS,DSP,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\DSP.cs,FrequencyToLogPosition,The following statement contains a magic number: if (LOGBASE == 1.0) {  				return (x - min)/(max-min);  			} else {  				double logMin = Math.Log(min);  				double logMax = Math.Log(max);  				double delta = (logMax - logMin);  				double logDelta = delta / Math.Log(2.0);    				return Math.Log(((x - min) * (min * Math.Pow(LOGBASE' logDelta) - min) / (max - min) + min) / Math.Log(LOGBASE)) * Math.Log(2.0) / delta;  			}
Magic Number,ARSS,ImageIO,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\ImageIO.cs,BMPRead,The following statement contains a magic number: if (Util.ReadUInt16(bmpfile) != 19778) // "BM" format tag check  			{  				Console.Error.WriteLine("This file is not in BMP format\n");  				Util.ReadUserReturn();  				Environment.Exit(1);  			}
Magic Number,ARSS,ImageIO,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\ImageIO.cs,BMPRead,The following statement contains a magic number: bmpfile.Seek(8' SeekOrigin.Current);
Magic Number,ARSS,ImageIO,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\ImageIO.cs,BMPRead,The following statement contains a magic number: offset = (int) Util.ReadUInt32(bmpfile) - 54;
Magic Number,ARSS,ImageIO,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\ImageIO.cs,BMPRead,The following statement contains a magic number: bmpfile.Seek(4' SeekOrigin.Current);
Magic Number,ARSS,ImageIO,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\ImageIO.cs,BMPRead,The following statement contains a magic number: bmpfile.Seek(2' SeekOrigin.Current);
Magic Number,ARSS,ImageIO,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\ImageIO.cs,BMPRead,The following statement contains a magic number: if (Util.ReadUInt16(bmpfile) != 24) // Only format supported  			{  				Console.Error.WriteLine("Wrong BMP format' BMP images must be in 24-bit colour\n");  				Util.ReadUserReturn();  				Environment.Exit(1);  			}
Magic Number,ARSS,ImageIO,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\ImageIO.cs,BMPRead,The following statement contains a magic number: bmpfile.Seek(24+offset' SeekOrigin.Current);
Magic Number,ARSS,ImageIO,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\ImageIO.cs,BMPRead,The following statement contains a magic number: zerobytes = (byte)(4 - ((x *3) & 3));
Magic Number,ARSS,ImageIO,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\ImageIO.cs,BMPRead,The following statement contains a magic number: zerobytes = (byte)(4 - ((x *3) & 3));
Magic Number,ARSS,ImageIO,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\ImageIO.cs,BMPRead,The following statement contains a magic number: zerobytes = (byte)(4 - ((x *3) & 3));
Magic Number,ARSS,ImageIO,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\ImageIO.cs,BMPRead,The following statement contains a magic number: if (zerobytes == 4) {  				zerobytes = 0;  			}
Magic Number,ARSS,ImageIO,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\ImageIO.cs,BMPRead,The following statement contains a magic number: for (iy = y-1; iy!=-1; iy--) {  				for (ix = 0; ix< x; ix++) {  					for (ic = 2;ic!=-1;ic--) {  						val = bmpfile.ReadByte();  						image[iy][ix] += (double) val * (1.0/(255.0 * 3.0)); // Conversion to grey by averaging the three channels  					}  				}    				bmpfile.Seek(zerobytes' SeekOrigin.Current); // skipping padding bytes  			}
Magic Number,ARSS,ImageIO,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\ImageIO.cs,BMPRead,The following statement contains a magic number: for (iy = y-1; iy!=-1; iy--) {  				for (ix = 0; ix< x; ix++) {  					for (ic = 2;ic!=-1;ic--) {  						val = bmpfile.ReadByte();  						image[iy][ix] += (double) val * (1.0/(255.0 * 3.0)); // Conversion to grey by averaging the three channels  					}  				}    				bmpfile.Seek(zerobytes' SeekOrigin.Current); // skipping padding bytes  			}
Magic Number,ARSS,ImageIO,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\ImageIO.cs,BMPRead,The following statement contains a magic number: for (iy = y-1; iy!=-1; iy--) {  				for (ix = 0; ix< x; ix++) {  					for (ic = 2;ic!=-1;ic--) {  						val = bmpfile.ReadByte();  						image[iy][ix] += (double) val * (1.0/(255.0 * 3.0)); // Conversion to grey by averaging the three channels  					}  				}    				bmpfile.Seek(zerobytes' SeekOrigin.Current); // skipping padding bytes  			}
Magic Number,ARSS,ImageIO,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\ImageIO.cs,BMPWrite,The following statement contains a magic number: zerobytes = (byte) (4 - ((x *3) & 3));
Magic Number,ARSS,ImageIO,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\ImageIO.cs,BMPWrite,The following statement contains a magic number: zerobytes = (byte) (4 - ((x *3) & 3));
Magic Number,ARSS,ImageIO,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\ImageIO.cs,BMPWrite,The following statement contains a magic number: zerobytes = (byte) (4 - ((x *3) & 3));
Magic Number,ARSS,ImageIO,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\ImageIO.cs,BMPWrite,The following statement contains a magic number: if (zerobytes == 4) {  				zerobytes = 0;  			}
Magic Number,ARSS,ImageIO,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\ImageIO.cs,BMPWrite,The following statement contains a magic number: filesize = 56 + ((x *3)+zerobytes) * y;
Magic Number,ARSS,ImageIO,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\ImageIO.cs,BMPWrite,The following statement contains a magic number: filesize = 56 + ((x *3)+zerobytes) * y;
Magic Number,ARSS,ImageIO,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\ImageIO.cs,BMPWrite,The following statement contains a magic number: imagesize = 2 + ((x *3)+zerobytes) * y;
Magic Number,ARSS,ImageIO,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\ImageIO.cs,BMPWrite,The following statement contains a magic number: imagesize = 2 + ((x *3)+zerobytes) * y;
Magic Number,ARSS,ImageIO,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\ImageIO.cs,BMPWrite,The following statement contains a magic number: Util.WriteUInt16(19778' bmpfile);
Magic Number,ARSS,ImageIO,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\ImageIO.cs,BMPWrite,The following statement contains a magic number: Util.WriteUInt32(54' bmpfile);
Magic Number,ARSS,ImageIO,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\ImageIO.cs,BMPWrite,The following statement contains a magic number: Util.WriteUInt32(40' bmpfile);
Magic Number,ARSS,ImageIO,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\ImageIO.cs,BMPWrite,The following statement contains a magic number: Util.WriteUInt32(24' bmpfile);
Magic Number,ARSS,ImageIO,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\ImageIO.cs,BMPWrite,The following statement contains a magic number: Util.WriteUInt32(2834' bmpfile);
Magic Number,ARSS,ImageIO,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\ImageIO.cs,BMPWrite,The following statement contains a magic number: Util.WriteUInt32(2834' bmpfile);
Magic Number,ARSS,ImageIO,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\ImageIO.cs,BMPWrite,The following statement contains a magic number: for (iy = y-1; iy!=-1; iy--) {  				for (ix = 0; ix<x; ix++) {  					  					// define color  					vald = image[iy][ix] * 255.0;    					if (vald > 255.0) {  						vald = 255.0;  					}    					if (vald < 0.0) {  						vald = 0.0;  					}  					  					val = (byte) vald;    					for (ic = 2; ic!=-1; ic--) {  						bmpfile.Write(val);  					}  				}  				  				// write padding bytes  				for (i = 0; i<zerobytes; i++) {  					bmpfile.Write(zero);  				}  			}
Magic Number,ARSS,ImageIO,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\ImageIO.cs,BMPWrite,The following statement contains a magic number: for (iy = y-1; iy!=-1; iy--) {  				for (ix = 0; ix<x; ix++) {  					  					// define color  					vald = image[iy][ix] * 255.0;    					if (vald > 255.0) {  						vald = 255.0;  					}    					if (vald < 0.0) {  						vald = 0.0;  					}  					  					val = (byte) vald;    					for (ic = 2; ic!=-1; ic--) {  						bmpfile.Write(val);  					}  				}  				  				// write padding bytes  				for (i = 0; i<zerobytes; i++) {  					bmpfile.Write(zero);  				}  			}
Magic Number,ARSS,ImageIO,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\ImageIO.cs,BMPWrite,The following statement contains a magic number: for (iy = y-1; iy!=-1; iy--) {  				for (ix = 0; ix<x; ix++) {  					  					// define color  					vald = image[iy][ix] * 255.0;    					if (vald > 255.0) {  						vald = 255.0;  					}    					if (vald < 0.0) {  						vald = 0.0;  					}  					  					val = (byte) vald;    					for (ic = 2; ic!=-1; ic--) {  						bmpfile.Write(val);  					}  				}  				  				// write padding bytes  				for (i = 0; i<zerobytes; i++) {  					bmpfile.Write(zero);  				}  			}
Magic Number,ARSS,ImageIO,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\ImageIO.cs,BMPWrite,The following statement contains a magic number: for (iy = y-1; iy!=-1; iy--) {  				for (ix = 0; ix<x; ix++) {  					  					// define color  					vald = image[iy][ix] * 255.0;    					if (vald > 255.0) {  						vald = 255.0;  					}    					if (vald < 0.0) {  						vald = 0.0;  					}  					  					val = (byte) vald;    					for (ic = 2; ic!=-1; ic--) {  						bmpfile.Write(val);  					}  				}  				  				// write padding bytes  				for (i = 0; i<zerobytes; i++) {  					bmpfile.Write(zero);  				}  			}
Magic Number,ARSS,SoundIO,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\SoundIO.cs,Read8Bit,The following statement contains a magic number: for (int i = 0; i < samplecount; i++) {  				for (int ic = 0; ic < channels; ic++)  				{  					byte @byte = wavfile.ReadByte();  					sound[ic][i] = (double) @byte / 128.0 - 1.0;  				}  			}
Magic Number,ARSS,SoundIO,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\SoundIO.cs,Write8Bit,The following statement contains a magic number: for (int i = 0; i < samplecount; i++) {  				for (int ic = 0; ic < channels; ic++)  				{  					int val = Util.RoundToClosestInt((sound[ic][i] + 1) * 128);  					  					if (val > 255)  						val = 255;  					if (val < 0)  						val = 0;    					byte @byte = (byte) val;    					wavfile.Write(@byte);  				}  			}
Magic Number,ARSS,SoundIO,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\SoundIO.cs,Write8Bit,The following statement contains a magic number: for (int i = 0; i < samplecount; i++) {  				for (int ic = 0; ic < channels; ic++)  				{  					int val = Util.RoundToClosestInt((sound[ic][i] + 1) * 128);  					  					if (val > 255)  						val = 255;  					if (val < 0)  						val = 0;    					byte @byte = (byte) val;    					wavfile.Write(@byte);  				}  			}
Magic Number,ARSS,SoundIO,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\SoundIO.cs,Write8Bit,The following statement contains a magic number: for (int i = 0; i < samplecount; i++) {  				for (int ic = 0; ic < channels; ic++)  				{  					int val = Util.RoundToClosestInt((sound[ic][i] + 1) * 128);  					  					if (val > 255)  						val = 255;  					if (val < 0)  						val = 0;    					byte @byte = (byte) val;    					wavfile.Write(@byte);  				}  			}
Magic Number,ARSS,SoundIO,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\SoundIO.cs,Read16Bit,The following statement contains a magic number: for (int i = 0; i < samplecount; i++) {  				for (int ic = 0; ic < channels; ic++) {  					double d = (double) wavfile.ReadInt16();  					d = d / 32768.0;  					sound[ic][i] = d;  				}  			}
Magic Number,ARSS,SoundIO,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\SoundIO.cs,Write16Bit,The following statement contains a magic number: for (int i = 0; i<samplecount; i++) {  				for (int ic = 0;ic<channels;ic++)  				{  					int val = Util.RoundToClosestInt(sound[ic][i] * 32768);  					  					if (val > 32767)  						val = 32767;  					if (val < -32768)  						val = -32768;    					wavfile.Write((Int16) val);  				}  			}
Magic Number,ARSS,SoundIO,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\SoundIO.cs,Write16Bit,The following statement contains a magic number: for (int i = 0; i<samplecount; i++) {  				for (int ic = 0;ic<channels;ic++)  				{  					int val = Util.RoundToClosestInt(sound[ic][i] * 32768);  					  					if (val > 32767)  						val = 32767;  					if (val < -32768)  						val = -32768;    					wavfile.Write((Int16) val);  				}  			}
Magic Number,ARSS,SoundIO,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\SoundIO.cs,Write16Bit,The following statement contains a magic number: for (int i = 0; i<samplecount; i++) {  				for (int ic = 0;ic<channels;ic++)  				{  					int val = Util.RoundToClosestInt(sound[ic][i] * 32768);  					  					if (val > 32767)  						val = 32767;  					if (val < -32768)  						val = -32768;    					wavfile.Write((Int16) val);  				}  			}
Magic Number,ARSS,SoundIO,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\SoundIO.cs,Write16Bit,The following statement contains a magic number: for (int i = 0; i<samplecount; i++) {  				for (int ic = 0;ic<channels;ic++)  				{  					int val = Util.RoundToClosestInt(sound[ic][i] * 32768);  					  					if (val > 32767)  						val = 32767;  					if (val < -32768)  						val = -32768;    					wavfile.Write((Int16) val);  				}  			}
Magic Number,ARSS,SoundIO,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\SoundIO.cs,Write16Bit,The following statement contains a magic number: for (int i = 0; i<samplecount; i++) {  				for (int ic = 0;ic<channels;ic++)  				{  					int val = Util.RoundToClosestInt(sound[ic][i] * 32768);  					  					if (val > 32767)  						val = 32767;  					if (val < -32768)  						val = -32768;    					wavfile.Write((Int16) val);  				}  			}
Magic Number,ARSS,SoundIO,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\SoundIO.cs,Read32Bit,The following statement contains a magic number: for (int i = 0; i < samplecount; i++) {  				for (int ic = 0; ic < channels; ic++) {  					double d = (double) wavfile.ReadInt32();  					d = d / 2147483648.0;  					sound[ic][i] = d;  				}  			}
Magic Number,ARSS,SoundIO,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\SoundIO.cs,Write32Bit,The following statement contains a magic number: for (int i = 0; i < samplecount; i++) {  				for (int ic = 0; ic < channels; ic++) {  					int val = Util.RoundToClosestInt(sound[ic][i] * 2147483648);  					  					if (val > 2147483647)  						val = 2147483647;  					if (val < -2147483648)  						val = -2147483648;    					wavfile.Write((int) val);  				}  			}
Magic Number,ARSS,SoundIO,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\SoundIO.cs,Write32Bit,The following statement contains a magic number: for (int i = 0; i < samplecount; i++) {  				for (int ic = 0; ic < channels; ic++) {  					int val = Util.RoundToClosestInt(sound[ic][i] * 2147483648);  					  					if (val > 2147483647)  						val = 2147483647;  					if (val < -2147483648)  						val = -2147483648;    					wavfile.Write((int) val);  				}  			}
Magic Number,ARSS,SoundIO,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\SoundIO.cs,Write32Bit,The following statement contains a magic number: for (int i = 0; i < samplecount; i++) {  				for (int ic = 0; ic < channels; ic++) {  					int val = Util.RoundToClosestInt(sound[ic][i] * 2147483648);  					  					if (val > 2147483647)  						val = 2147483647;  					if (val < -2147483648)  						val = -2147483648;    					wavfile.Write((int) val);  				}  			}
Magic Number,ARSS,SoundIO,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\SoundIO.cs,Write32Bit,The following statement contains a magic number: for (int i = 0; i < samplecount; i++) {  				for (int ic = 0; ic < channels; ic++) {  					int val = Util.RoundToClosestInt(sound[ic][i] * 2147483648);  					  					if (val > 2147483647)  						val = 2147483647;  					if (val < -2147483648)  						val = -2147483648;    					wavfile.Write((int) val);  				}  			}
Magic Number,ARSS,SoundIO,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\SoundIO.cs,Write32Bit,The following statement contains a magic number: for (int i = 0; i < samplecount; i++) {  				for (int ic = 0; ic < channels; ic++) {  					int val = Util.RoundToClosestInt(sound[ic][i] * 2147483648);  					  					if (val > 2147483647)  						val = 2147483647;  					if (val < -2147483648)  						val = -2147483648;    					wavfile.Write((int) val);  				}  			}
Magic Number,ARSS,SoundIO,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\SoundIO.cs,ReadWaveFile,The following statement contains a magic number: var tag = new int[13];
Magic Number,ARSS,SoundIO,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\SoundIO.cs,ReadWaveFile,The following statement contains a magic number: for (i = 0; i < 13; i++) {  				tag[i] = 0;    				if ((i == 5) || (i == 6) || (i == 9) || (i == 10)) {  					tag[i] = Util.ReadUInt16(wavfile);  				} else {  					tag[i] = (int) Util.ReadUInt32(wavfile);  				}  			}
Magic Number,ARSS,SoundIO,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\SoundIO.cs,ReadWaveFile,The following statement contains a magic number: for (i = 0; i < 13; i++) {  				tag[i] = 0;    				if ((i == 5) || (i == 6) || (i == 9) || (i == 10)) {  					tag[i] = Util.ReadUInt16(wavfile);  				} else {  					tag[i] = (int) Util.ReadUInt32(wavfile);  				}  			}
Magic Number,ARSS,SoundIO,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\SoundIO.cs,ReadWaveFile,The following statement contains a magic number: for (i = 0; i < 13; i++) {  				tag[i] = 0;    				if ((i == 5) || (i == 6) || (i == 9) || (i == 10)) {  					tag[i] = Util.ReadUInt16(wavfile);  				} else {  					tag[i] = (int) Util.ReadUInt32(wavfile);  				}  			}
Magic Number,ARSS,SoundIO,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\SoundIO.cs,ReadWaveFile,The following statement contains a magic number: for (i = 0; i < 13; i++) {  				tag[i] = 0;    				if ((i == 5) || (i == 6) || (i == 9) || (i == 10)) {  					tag[i] = Util.ReadUInt16(wavfile);  				} else {  					tag[i] = (int) Util.ReadUInt32(wavfile);  				}  			}
Magic Number,ARSS,SoundIO,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\SoundIO.cs,ReadWaveFile,The following statement contains a magic number: for (i = 0; i < 13; i++) {  				tag[i] = 0;    				if ((i == 5) || (i == 6) || (i == 9) || (i == 10)) {  					tag[i] = Util.ReadUInt16(wavfile);  				} else {  					tag[i] = (int) Util.ReadUInt32(wavfile);  				}  			}
Magic Number,ARSS,SoundIO,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\SoundIO.cs,ReadWaveFile,The following statement contains a magic number: if (tag[0] != RIFF || tag[2] != WAVE)  			{  				Console.Error.WriteLine("This file is not in WAVE format\n");  				Util.ReadUserReturn();  				Environment.Exit(1);  			}
Magic Number,ARSS,SoundIO,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\SoundIO.cs,ReadWaveFile,The following statement contains a magic number: if (tag[3] != FMT || tag[4] != 16 || tag[11] != DATA)  			{  				Console.Error.WriteLine("This WAVE file format is not currently supported\n");  				Util.ReadUserReturn();  				Environment.Exit(1);  			}
Magic Number,ARSS,SoundIO,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\SoundIO.cs,ReadWaveFile,The following statement contains a magic number: if (tag[3] != FMT || tag[4] != 16 || tag[11] != DATA)  			{  				Console.Error.WriteLine("This WAVE file format is not currently supported\n");  				Util.ReadUserReturn();  				Environment.Exit(1);  			}
Magic Number,ARSS,SoundIO,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\SoundIO.cs,ReadWaveFile,The following statement contains a magic number: if (tag[3] != FMT || tag[4] != 16 || tag[11] != DATA)  			{  				Console.Error.WriteLine("This WAVE file format is not currently supported\n");  				Util.ReadUserReturn();  				Environment.Exit(1);  			}
Magic Number,ARSS,SoundIO,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\SoundIO.cs,ReadWaveFile,The following statement contains a magic number: if (tag[3] != FMT || tag[4] != 16 || tag[11] != DATA)  			{  				Console.Error.WriteLine("This WAVE file format is not currently supported\n");  				Util.ReadUserReturn();  				Environment.Exit(1);  			}
Magic Number,ARSS,SoundIO,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\SoundIO.cs,ReadWaveFile,The following statement contains a magic number: if (tag[10] == 24)  			{  				Console.Error.WriteLine("24 bit PCM WAVE files are not currently supported\n");  				Util.ReadUserReturn();  				Environment.Exit(1);  			}
Magic Number,ARSS,SoundIO,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\SoundIO.cs,ReadWaveFile,The following statement contains a magic number: if (tag[10] == 24)  			{  				Console.Error.WriteLine("24 bit PCM WAVE files are not currently supported\n");  				Util.ReadUserReturn();  				Environment.Exit(1);  			}
Magic Number,ARSS,SoundIO,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\SoundIO.cs,ReadWaveFile,The following statement contains a magic number: if (tag[5] != WAVE_FORMAT_PCM && tag[5] != WAVE_FORMAT_IEEE_FLOAT) {  				Console.Error.WriteLine("Non PCM WAVE files are not currently supported\n");  				Util.ReadUserReturn();  				Environment.Exit(1);  			}
Magic Number,ARSS,SoundIO,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\SoundIO.cs,ReadWaveFile,The following statement contains a magic number: if (tag[5] != WAVE_FORMAT_PCM && tag[5] != WAVE_FORMAT_IEEE_FLOAT) {  				Console.Error.WriteLine("Non PCM WAVE files are not currently supported\n");  				Util.ReadUserReturn();  				Environment.Exit(1);  			}
Magic Number,ARSS,SoundIO,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\SoundIO.cs,ReadWaveFile,The following statement contains a magic number: channels = tag[6];
Magic Number,ARSS,SoundIO,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\SoundIO.cs,ReadWaveFile,The following statement contains a magic number: samplecount = tag[12] / (tag[10] / 8) / channels;
Magic Number,ARSS,SoundIO,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\SoundIO.cs,ReadWaveFile,The following statement contains a magic number: samplecount = tag[12] / (tag[10] / 8) / channels;
Magic Number,ARSS,SoundIO,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\SoundIO.cs,ReadWaveFile,The following statement contains a magic number: samplecount = tag[12] / (tag[10] / 8) / channels;
Magic Number,ARSS,SoundIO,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\SoundIO.cs,ReadWaveFile,The following statement contains a magic number: samplerate = tag[7];
Magic Number,ARSS,SoundIO,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\SoundIO.cs,ReadWaveFile,The following statement contains a magic number: if (tag[10] == 8) {  				Read8Bit(wavfile' sound' samplecount' channels);  			}
Magic Number,ARSS,SoundIO,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\SoundIO.cs,ReadWaveFile,The following statement contains a magic number: if (tag[10] == 8) {  				Read8Bit(wavfile' sound' samplecount' channels);  			}
Magic Number,ARSS,SoundIO,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\SoundIO.cs,ReadWaveFile,The following statement contains a magic number: if (tag[10] == 16) {  				Read16Bit(wavfile' sound' samplecount' channels);  			}
Magic Number,ARSS,SoundIO,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\SoundIO.cs,ReadWaveFile,The following statement contains a magic number: if (tag[10] == 16) {  				Read16Bit(wavfile' sound' samplecount' channels);  			}
Magic Number,ARSS,SoundIO,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\SoundIO.cs,ReadWaveFile,The following statement contains a magic number: if (tag[10] == 32) {  				if (tag[5] == WAVE_FORMAT_PCM) {  					Read32Bit(wavfile' sound' samplecount' channels);  				} else if (tag[5] == WAVE_FORMAT_IEEE_FLOAT) {  					Read32BitFloat(wavfile' sound' samplecount' channels);  				}  			}
Magic Number,ARSS,SoundIO,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\SoundIO.cs,ReadWaveFile,The following statement contains a magic number: if (tag[10] == 32) {  				if (tag[5] == WAVE_FORMAT_PCM) {  					Read32Bit(wavfile' sound' samplecount' channels);  				} else if (tag[5] == WAVE_FORMAT_IEEE_FLOAT) {  					Read32BitFloat(wavfile' sound' samplecount' channels);  				}  			}
Magic Number,ARSS,SoundIO,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\SoundIO.cs,ReadWaveFile,The following statement contains a magic number: if (tag[10] == 32) {  				if (tag[5] == WAVE_FORMAT_PCM) {  					Read32Bit(wavfile' sound' samplecount' channels);  				} else if (tag[5] == WAVE_FORMAT_IEEE_FLOAT) {  					Read32BitFloat(wavfile' sound' samplecount' channels);  				}  			}
Magic Number,ARSS,SoundIO,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\SoundIO.cs,ReadWaveFile,The following statement contains a magic number: if (tag[10] == 32) {  				if (tag[5] == WAVE_FORMAT_PCM) {  					Read32Bit(wavfile' sound' samplecount' channels);  				} else if (tag[5] == WAVE_FORMAT_IEEE_FLOAT) {  					Read32BitFloat(wavfile' sound' samplecount' channels);  				}  			}
Magic Number,ARSS,SoundIO,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\SoundIO.cs,WriteWaveFile,The following statement contains a magic number: int[] tag = {1179011410' 0' 1163280727' 544501094' 16' 1' 1' 0' 0' 0' 0' 1635017060' 0' 0};
Magic Number,ARSS,SoundIO,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\SoundIO.cs,WriteWaveFile,The following statement contains a magic number: int[] tag = {1179011410' 0' 1163280727' 544501094' 16' 1' 1' 0' 0' 0' 0' 1635017060' 0' 0};
Magic Number,ARSS,SoundIO,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\SoundIO.cs,WriteWaveFile,The following statement contains a magic number: int[] tag = {1179011410' 0' 1163280727' 544501094' 16' 1' 1' 0' 0' 0' 0' 1635017060' 0' 0};
Magic Number,ARSS,SoundIO,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\SoundIO.cs,WriteWaveFile,The following statement contains a magic number: int[] tag = {1179011410' 0' 1163280727' 544501094' 16' 1' 1' 0' 0' 0' 0' 1635017060' 0' 0};
Magic Number,ARSS,SoundIO,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\SoundIO.cs,WriteWaveFile,The following statement contains a magic number: int[] tag = {1179011410' 0' 1163280727' 544501094' 16' 1' 1' 0' 0' 0' 0' 1635017060' 0' 0};
Magic Number,ARSS,SoundIO,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\SoundIO.cs,WriteWaveFile,The following statement contains a magic number: tag[12] = samplecount*(format_param/8)*channels;
Magic Number,ARSS,SoundIO,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\SoundIO.cs,WriteWaveFile,The following statement contains a magic number: tag[12] = samplecount*(format_param/8)*channels;
Magic Number,ARSS,SoundIO,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\SoundIO.cs,WriteWaveFile,The following statement contains a magic number: tag[1] = tag[12]+36;
Magic Number,ARSS,SoundIO,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\SoundIO.cs,WriteWaveFile,The following statement contains a magic number: tag[1] = tag[12]+36;
Magic Number,ARSS,SoundIO,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\SoundIO.cs,WriteWaveFile,The following statement contains a magic number: tag[7] = samplerate;
Magic Number,ARSS,SoundIO,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\SoundIO.cs,WriteWaveFile,The following statement contains a magic number: tag[8] = samplerate *format_param/8;
Magic Number,ARSS,SoundIO,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\SoundIO.cs,WriteWaveFile,The following statement contains a magic number: tag[8] = samplerate *format_param/8;
Magic Number,ARSS,SoundIO,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\SoundIO.cs,WriteWaveFile,The following statement contains a magic number: tag[9] = format_param/8;
Magic Number,ARSS,SoundIO,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\SoundIO.cs,WriteWaveFile,The following statement contains a magic number: tag[9] = format_param/8;
Magic Number,ARSS,SoundIO,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\SoundIO.cs,WriteWaveFile,The following statement contains a magic number: tag[6] = channels;
Magic Number,ARSS,SoundIO,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\SoundIO.cs,WriteWaveFile,The following statement contains a magic number: tag[10] = format_param;
Magic Number,ARSS,SoundIO,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\SoundIO.cs,WriteWaveFile,The following statement contains a magic number: if ((format_param == 8) || (format_param == 16))  				tag[5] = 1;
Magic Number,ARSS,SoundIO,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\SoundIO.cs,WriteWaveFile,The following statement contains a magic number: if ((format_param == 8) || (format_param == 16))  				tag[5] = 1;
Magic Number,ARSS,SoundIO,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\SoundIO.cs,WriteWaveFile,The following statement contains a magic number: if ((format_param == 8) || (format_param == 16))  				tag[5] = 1;
Magic Number,ARSS,SoundIO,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\SoundIO.cs,WriteWaveFile,The following statement contains a magic number: if (format_param == 32)  				tag[5] = 3;
Magic Number,ARSS,SoundIO,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\SoundIO.cs,WriteWaveFile,The following statement contains a magic number: if (format_param == 32)  				tag[5] = 3;
Magic Number,ARSS,SoundIO,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\SoundIO.cs,WriteWaveFile,The following statement contains a magic number: if (format_param == 32)  				tag[5] = 3;
Magic Number,ARSS,SoundIO,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\SoundIO.cs,WriteWaveFile,The following statement contains a magic number: for (i = 0; i<13; i++) {  				if ((i == 5) || (i == 6) || (i == 9) || (i == 10)) {  					Util.WriteUInt16((ushort)tag[i]' wavfile);  				} else {  					Util.WriteUInt32((uint)tag[i]' wavfile);  				}  			}
Magic Number,ARSS,SoundIO,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\SoundIO.cs,WriteWaveFile,The following statement contains a magic number: for (i = 0; i<13; i++) {  				if ((i == 5) || (i == 6) || (i == 9) || (i == 10)) {  					Util.WriteUInt16((ushort)tag[i]' wavfile);  				} else {  					Util.WriteUInt32((uint)tag[i]' wavfile);  				}  			}
Magic Number,ARSS,SoundIO,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\SoundIO.cs,WriteWaveFile,The following statement contains a magic number: for (i = 0; i<13; i++) {  				if ((i == 5) || (i == 6) || (i == 9) || (i == 10)) {  					Util.WriteUInt16((ushort)tag[i]' wavfile);  				} else {  					Util.WriteUInt32((uint)tag[i]' wavfile);  				}  			}
Magic Number,ARSS,SoundIO,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\SoundIO.cs,WriteWaveFile,The following statement contains a magic number: for (i = 0; i<13; i++) {  				if ((i == 5) || (i == 6) || (i == 9) || (i == 10)) {  					Util.WriteUInt16((ushort)tag[i]' wavfile);  				} else {  					Util.WriteUInt32((uint)tag[i]' wavfile);  				}  			}
Magic Number,ARSS,SoundIO,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\SoundIO.cs,WriteWaveFile,The following statement contains a magic number: for (i = 0; i<13; i++) {  				if ((i == 5) || (i == 6) || (i == 9) || (i == 10)) {  					Util.WriteUInt16((ushort)tag[i]' wavfile);  				} else {  					Util.WriteUInt32((uint)tag[i]' wavfile);  				}  			}
Magic Number,ARSS,SoundIO,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\SoundIO.cs,WriteWaveFile,The following statement contains a magic number: if (format_param == 8)  				Write8Bit(wavfile' sound' samplecount' channels);
Magic Number,ARSS,SoundIO,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\SoundIO.cs,WriteWaveFile,The following statement contains a magic number: if (format_param == 16)  				Write16Bit(wavfile' sound' samplecount' channels);
Magic Number,ARSS,SoundIO,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\SoundIO.cs,WriteWaveFile,The following statement contains a magic number: if (format_param == 32)  				Write32BitFloat(wavfile' sound' samplecount' channels);
Magic Number,ARSS,SoundIO,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\SoundIO.cs,ReadUserWaveOutParameters,The following statement contains a magic number: do  			{  				Console.Write("Bits per sample (8/16/32) [16] : ");  				bps = (int) Util.ReadUserInputFloat();  				if (bps == 0) {  					bps = 16;  				}  			}  			while (bps!=8 && bps!=16 && bps!=32);
Magic Number,ARSS,SoundIO,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\SoundIO.cs,ReadUserWaveOutParameters,The following statement contains a magic number: do  			{  				Console.Write("Bits per sample (8/16/32) [16] : ");  				bps = (int) Util.ReadUserInputFloat();  				if (bps == 0) {  					bps = 16;  				}  			}  			while (bps!=8 && bps!=16 && bps!=32);
Magic Number,ARSS,SoundIO,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\SoundIO.cs,ReadUserWaveOutParameters,The following statement contains a magic number: do  			{  				Console.Write("Bits per sample (8/16/32) [16] : ");  				bps = (int) Util.ReadUserInputFloat();  				if (bps == 0) {  					bps = 16;  				}  			}  			while (bps!=8 && bps!=16 && bps!=32);
Magic Number,ARSS,SoundIO,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\SoundIO.cs,ReadUserWaveOutParameters,The following statement contains a magic number: do  			{  				Console.Write("Bits per sample (8/16/32) [16] : ");  				bps = (int) Util.ReadUserInputFloat();  				if (bps == 0) {  					bps = 16;  				}  			}  			while (bps!=8 && bps!=16 && bps!=32);
Magic Number,ARSS,Tests,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\Tests\Tests.cs,TestSpectrogramFFT,The following statement contains a magic number: Assert.That(doubles' Is.EqualTo(ifft).AsCollection.Within(0.001)' "fail at [0]");
Magic Number,ARSS,Util,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\Util.cs,NextLowPrimes,The following statement contains a magic number: int[] validPrimes = { 2' 3 };
Magic Number,ARSS,Util,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\Util.cs,NextLowPrimes,The following statement contains a magic number: int[] validPrimes = { 2' 3 };
Magic Number,ArssSpectrogram,LinearFilterbank,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\ArssSpectrogram\Filterbank.cs,LinearFilterbank,The following statement contains a magic number: startidx_ = Math.Max(scale_ * @base-bandwidth_/ 2' 0.0);
Magic Number,ArssSpectrogram,LinearFilterbank,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\ArssSpectrogram\Filterbank.cs,GetCenter,The following statement contains a magic number: return startidx_ + i *step_ + bandwidth_ / 2.0;
Magic Number,ArssSpectrogram,LogFilterbank,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\ArssSpectrogram\Filterbank.cs,NumBandsEst,The following statement contains a magic number: return (SpectrogramUtils.Freq2Cent(maxfreq)-logstart_) / logstep_ + 4;
Magic Number,ArssSpectrogram,LogFilterbank,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\ArssSpectrogram\Filterbank.cs,GetBand,The following statement contains a magic number: double loglow = logcenter - centsperband_/ 2.0;
Magic Number,ArssSpectrogram,Palette,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\ArssSpectrogram\Palette.cs,Palette,The following statement contains a magic number: for (int i = 0; i < 256; ++i)  				colors_.Add(Color.FromArgb(i' i' i));
Magic Number,ArssSpectrogram,Spectrogram,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\ArssSpectrogram\Spectrogram.cs,Spectrogram,The following statement contains a magic number: bandwidth = 201;
Magic Number,ArssSpectrogram,Spectrogram,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\ArssSpectrogram\Spectrogram.cs,Spectrogram,The following statement contains a magic number: basefreq = 27.5;
Magic Number,ArssSpectrogram,Spectrogram,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\ArssSpectrogram\Spectrogram.cs,Spectrogram,The following statement contains a magic number: maxfreq = 20000;
Magic Number,ArssSpectrogram,Spectrogram,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\ArssSpectrogram\Spectrogram.cs,Spectrogram,The following statement contains a magic number: overlap = 0.5;
Magic Number,ArssSpectrogram,Spectrogram,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\ArssSpectrogram\Spectrogram.cs,Spectrogram,The following statement contains a magic number: pixpersec = 150;
Magic Number,ArssSpectrogram,Spectrogram,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\ArssSpectrogram\Spectrogram.cs,ToImage,The following statement contains a magic number: using (new DebugTimer("Spectrogram: ToImage()"))  			{  				Console.Out.WriteLine("Spectrogram: Transform Sound to Image");  				  				Complex[] spectrum = SpectrogramUtils.padded_FFT(ref signal);  				  				//const size_t width = (spectrum.size()-1)*2*pixpersec/samplerate;  				double lastSpectrumIndex = spectrum.Length - 1; // last spectrum index  				double pixelsPerSample = (double) pixpersec/ (double) samplerate;  				double widthDouble = lastSpectrumIndex * 2 * pixelsPerSample;  				int width = MathUtils.RoundAwayFromZero(widthDouble);  				Console.Out.WriteLine("Width: {0}"' width);  				//int testWidt = (int) (signal.Length * pixpersec);    				// transformation of frequency in hz to index in spectrum  				double filterscale = ((double)spectrum.Length*2) / samplerate;  				Console.Out.WriteLine("Filterscale: {0}"' filterscale);    				Filterbank filterbank = Filterbank.GetFilterbank(frequency_axis' filterscale' basefreq' bandwidth' overlap);  				int bands = (int) filterbank.NumBandsEst(maxfreq);  				int top_index = (int) ((double)maxfreq * filterscale);  				  				// maxfreq has to be at most nyquist  				Debug.Assert(top_index <= spectrum.Length);    				//std::vector<real_vec> image_data;  				var image_data = new List<double[]>();  				  				for (int bandidx = 0;; ++bandidx) {  					// TODO: support cancelling this process  					  					// filtering  					Pair<int'int> range = filterbank.GetBand(bandidx);  					  					// Output progress  					Console.Write("Processing band {0} of {1} ({2:0.00} Hz - {3:0.00} Hz = {4:0.00} Hz)\r"' bandidx' bands' range.First/filterscale' range.Second/filterscale' (range.Second-range.First)/filterscale);  					  					/*  			Console.Out.WriteLine("-----");  			Console.Out.WriteLine("spectrum size: {0}"' spectrum.Length);  			Console.Out.WriteLine("lowidx: {0:0.00} highidx: {1:0.00}"' range.First' range.Second);  			Console.Out.WriteLine("(real)lowfreq: {0:0.00} (real)highfreq: {1:0.00}"' range.First / filterscale' range.Second/filterscale);  			Console.Out.WriteLine("actual width: {0:0.00} hz"' (range.Second-range.First)/filterscale);  			Console.Out.WriteLine("vertical values: {0:0.00}"' (range.Second-range.First));  			Console.Out.WriteLine("crowd sample: {0:0.00}"' (range.Second-range.First-1)*2);  			Console.Out.WriteLine("theoretically staci: {0:0.00} hz samplerate"' 2*(range.Second-range.First)/filterscale);  			Console.Out.WriteLine("width: {0}"' width);  					 */  					  					// take the complex samples	specified by the range and copy into filterband  					int filterbandLength = range.Second - range.First;  					var filterband = new Complex[filterbandLength];  					//std::copy(spectrum.begin()+range.first'  					//          spectrum.begin()+std::min(range.second' top_index)'  					//          filterband.begin());  					int sourceIndexStart = range.First;  					int sourceIndexEnd = Math.Min(range.Second' top_index);  					int length = sourceIndexEnd - sourceIndexStart;  					if (sourceIndexStart < sourceIndexEnd) {  						Array.Copy(spectrum' sourceIndexStart' filterband' 0' length);  					}  					  					// if the first range index is higher than the maximum index' we have reached the end  					if (range.First > top_index) {  						break;  					}  					// if the second range index is higher than the maximum index' we are at the last band  					if (range.Second > top_index) {  						//std::fill(filterband.begin()+top_index-range.first'  						//          filterband.end()' Complex(0'0));  						// not neccesary as c# already defaults the rest of the array to a Complex(0'0)  					}    					// windowing  					ApplyWindow(ref filterband' range.First' filterscale);    					// envelope detection  					double[] envelope = SpectrogramUtils.GetEnvelope(ref filterband);  					  					// resampling  					envelope = SpectrogramUtils.Resample(envelope' width);  					  					image_data.Add(envelope);  				}    				SpectrogramUtils.NormalizeImageCutoffNegative(ref image_data);    				return MakeImage(image_data);  			}
Magic Number,ArssSpectrogram,Spectrogram,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\ArssSpectrogram\Spectrogram.cs,ToImage,The following statement contains a magic number: using (new DebugTimer("Spectrogram: ToImage()"))  			{  				Console.Out.WriteLine("Spectrogram: Transform Sound to Image");  				  				Complex[] spectrum = SpectrogramUtils.padded_FFT(ref signal);  				  				//const size_t width = (spectrum.size()-1)*2*pixpersec/samplerate;  				double lastSpectrumIndex = spectrum.Length - 1; // last spectrum index  				double pixelsPerSample = (double) pixpersec/ (double) samplerate;  				double widthDouble = lastSpectrumIndex * 2 * pixelsPerSample;  				int width = MathUtils.RoundAwayFromZero(widthDouble);  				Console.Out.WriteLine("Width: {0}"' width);  				//int testWidt = (int) (signal.Length * pixpersec);    				// transformation of frequency in hz to index in spectrum  				double filterscale = ((double)spectrum.Length*2) / samplerate;  				Console.Out.WriteLine("Filterscale: {0}"' filterscale);    				Filterbank filterbank = Filterbank.GetFilterbank(frequency_axis' filterscale' basefreq' bandwidth' overlap);  				int bands = (int) filterbank.NumBandsEst(maxfreq);  				int top_index = (int) ((double)maxfreq * filterscale);  				  				// maxfreq has to be at most nyquist  				Debug.Assert(top_index <= spectrum.Length);    				//std::vector<real_vec> image_data;  				var image_data = new List<double[]>();  				  				for (int bandidx = 0;; ++bandidx) {  					// TODO: support cancelling this process  					  					// filtering  					Pair<int'int> range = filterbank.GetBand(bandidx);  					  					// Output progress  					Console.Write("Processing band {0} of {1} ({2:0.00} Hz - {3:0.00} Hz = {4:0.00} Hz)\r"' bandidx' bands' range.First/filterscale' range.Second/filterscale' (range.Second-range.First)/filterscale);  					  					/*  			Console.Out.WriteLine("-----");  			Console.Out.WriteLine("spectrum size: {0}"' spectrum.Length);  			Console.Out.WriteLine("lowidx: {0:0.00} highidx: {1:0.00}"' range.First' range.Second);  			Console.Out.WriteLine("(real)lowfreq: {0:0.00} (real)highfreq: {1:0.00}"' range.First / filterscale' range.Second/filterscale);  			Console.Out.WriteLine("actual width: {0:0.00} hz"' (range.Second-range.First)/filterscale);  			Console.Out.WriteLine("vertical values: {0:0.00}"' (range.Second-range.First));  			Console.Out.WriteLine("crowd sample: {0:0.00}"' (range.Second-range.First-1)*2);  			Console.Out.WriteLine("theoretically staci: {0:0.00} hz samplerate"' 2*(range.Second-range.First)/filterscale);  			Console.Out.WriteLine("width: {0}"' width);  					 */  					  					// take the complex samples	specified by the range and copy into filterband  					int filterbandLength = range.Second - range.First;  					var filterband = new Complex[filterbandLength];  					//std::copy(spectrum.begin()+range.first'  					//          spectrum.begin()+std::min(range.second' top_index)'  					//          filterband.begin());  					int sourceIndexStart = range.First;  					int sourceIndexEnd = Math.Min(range.Second' top_index);  					int length = sourceIndexEnd - sourceIndexStart;  					if (sourceIndexStart < sourceIndexEnd) {  						Array.Copy(spectrum' sourceIndexStart' filterband' 0' length);  					}  					  					// if the first range index is higher than the maximum index' we have reached the end  					if (range.First > top_index) {  						break;  					}  					// if the second range index is higher than the maximum index' we are at the last band  					if (range.Second > top_index) {  						//std::fill(filterband.begin()+top_index-range.first'  						//          filterband.end()' Complex(0'0));  						// not neccesary as c# already defaults the rest of the array to a Complex(0'0)  					}    					// windowing  					ApplyWindow(ref filterband' range.First' filterscale);    					// envelope detection  					double[] envelope = SpectrogramUtils.GetEnvelope(ref filterband);  					  					// resampling  					envelope = SpectrogramUtils.Resample(envelope' width);  					  					image_data.Add(envelope);  				}    				SpectrogramUtils.NormalizeImageCutoffNegative(ref image_data);    				return MakeImage(image_data);  			}
Magic Number,ArssSpectrogram,Spectrogram,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\ArssSpectrogram\Spectrogram.cs,SynthetizeSine,The following statement contains a magic number: using (new DebugTimer("Spectrogram: SynthetizeSine(double[][])"))  			{  				int samples = x_Width * samplerate/pixpersec;  				var spectrum = new Complex[samples/2+1];    				double filterscale = ((double)spectrum.Length*2)/samplerate;    				Filterbank filterbank = Filterbank.GetFilterbank(frequency_axis' filterscale' basefreq' bandwidth' overlap);    				for (int bandidx = 0; bandidx < y_Height; ++bandidx) {  					// TODO: support cancelling this process    					OutputBandProgress(bandidx+1' y_Height);    					//double[] envelope = EnvelopeFromSpectrogram(image' bandidx);  					double[] envelope = image[bandidx];  					// Find maximum number when all numbers are made positive.  					//double max = envelope.Max((b) => Math.Abs(b));  					//Console.WriteLine(max);    					#region Frequency shifting  					  					// random phase between +-pi  					double phase = SpectrogramUtils.RandomDoubleMinus1ToPlus1() * Math.PI;    					var bandsignal = new double[envelope.Length*2];  					for (int j = 0; j < 4; ++j) {  						double sine = Math.Cos(j * Math.PI/2 + phase);  						for (int i = j; i < bandsignal.Length; i += 4) {  							bandsignal[i] = envelope[i/2] * sine;  						}  					}  					#endregion  					  					// FFT of the envelope  					var filterband = SpectrogramUtils.padded_FFT(ref bandsignal);    					// Windowed-Sinc Filtering (frequency-domain filter)  					for (int i = 0; i < filterband.Length; ++i) {  						double x = (double)i/filterband.Length;  						  						// normalized blackman window antiderivative  						filterband[i] *= x - ((0.5/(2.0 * Math.PI)) * Math.Sin(2.0 * Math.PI *x) + (0.08/(4.0 * Math.PI)) * Math.Sin(4.0 * Math.PI *x) / 0.42);  					}    					//Console.Out.WriteLine("Spectrum size: {0}"' spectrum.Length);  					//std::cout << bandidx << ". filterband size: " << filterband.Length << "; start: " << filterbank->GetBand(bandidx).first <<"; end: " << filterbank->GetBand(bandidx).second << "\n";    					double center = filterbank.GetCenter(bandidx);  					double offset = Math.Max((double)0' center - filterband.Length/2);  					  					//Console.Out.WriteLine("Offset: {0} = {1} hz"' offset' offset/filterscale);  					  					for (int i = 0; i < filterband.Length; ++i) {  						int spectrumIndex = (int) (offset + i);  						if (spectrumIndex > 0 && spectrumIndex < spectrum.Length) {  							spectrum[spectrumIndex] += filterband[i];  						}  					}  				}    				double[] @out = SpectrogramUtils.padded_IFFT(ref spectrum);  				  				Console.Out.WriteLine("Samples: {0} -> {1}"' @out.Length' samples);  				  				SpectrogramUtils.NormalizeSignal(ref @out);  				return @out;  			}
Magic Number,ArssSpectrogram,Spectrogram,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\ArssSpectrogram\Spectrogram.cs,SynthetizeSine,The following statement contains a magic number: using (new DebugTimer("Spectrogram: SynthetizeSine(double[][])"))  			{  				int samples = x_Width * samplerate/pixpersec;  				var spectrum = new Complex[samples/2+1];    				double filterscale = ((double)spectrum.Length*2)/samplerate;    				Filterbank filterbank = Filterbank.GetFilterbank(frequency_axis' filterscale' basefreq' bandwidth' overlap);    				for (int bandidx = 0; bandidx < y_Height; ++bandidx) {  					// TODO: support cancelling this process    					OutputBandProgress(bandidx+1' y_Height);    					//double[] envelope = EnvelopeFromSpectrogram(image' bandidx);  					double[] envelope = image[bandidx];  					// Find maximum number when all numbers are made positive.  					//double max = envelope.Max((b) => Math.Abs(b));  					//Console.WriteLine(max);    					#region Frequency shifting  					  					// random phase between +-pi  					double phase = SpectrogramUtils.RandomDoubleMinus1ToPlus1() * Math.PI;    					var bandsignal = new double[envelope.Length*2];  					for (int j = 0; j < 4; ++j) {  						double sine = Math.Cos(j * Math.PI/2 + phase);  						for (int i = j; i < bandsignal.Length; i += 4) {  							bandsignal[i] = envelope[i/2] * sine;  						}  					}  					#endregion  					  					// FFT of the envelope  					var filterband = SpectrogramUtils.padded_FFT(ref bandsignal);    					// Windowed-Sinc Filtering (frequency-domain filter)  					for (int i = 0; i < filterband.Length; ++i) {  						double x = (double)i/filterband.Length;  						  						// normalized blackman window antiderivative  						filterband[i] *= x - ((0.5/(2.0 * Math.PI)) * Math.Sin(2.0 * Math.PI *x) + (0.08/(4.0 * Math.PI)) * Math.Sin(4.0 * Math.PI *x) / 0.42);  					}    					//Console.Out.WriteLine("Spectrum size: {0}"' spectrum.Length);  					//std::cout << bandidx << ". filterband size: " << filterband.Length << "; start: " << filterbank->GetBand(bandidx).first <<"; end: " << filterbank->GetBand(bandidx).second << "\n";    					double center = filterbank.GetCenter(bandidx);  					double offset = Math.Max((double)0' center - filterband.Length/2);  					  					//Console.Out.WriteLine("Offset: {0} = {1} hz"' offset' offset/filterscale);  					  					for (int i = 0; i < filterband.Length; ++i) {  						int spectrumIndex = (int) (offset + i);  						if (spectrumIndex > 0 && spectrumIndex < spectrum.Length) {  							spectrum[spectrumIndex] += filterband[i];  						}  					}  				}    				double[] @out = SpectrogramUtils.padded_IFFT(ref spectrum);  				  				Console.Out.WriteLine("Samples: {0} -> {1}"' @out.Length' samples);  				  				SpectrogramUtils.NormalizeSignal(ref @out);  				return @out;  			}
Magic Number,ArssSpectrogram,Spectrogram,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\ArssSpectrogram\Spectrogram.cs,SynthetizeSine,The following statement contains a magic number: using (new DebugTimer("Spectrogram: SynthetizeSine(double[][])"))  			{  				int samples = x_Width * samplerate/pixpersec;  				var spectrum = new Complex[samples/2+1];    				double filterscale = ((double)spectrum.Length*2)/samplerate;    				Filterbank filterbank = Filterbank.GetFilterbank(frequency_axis' filterscale' basefreq' bandwidth' overlap);    				for (int bandidx = 0; bandidx < y_Height; ++bandidx) {  					// TODO: support cancelling this process    					OutputBandProgress(bandidx+1' y_Height);    					//double[] envelope = EnvelopeFromSpectrogram(image' bandidx);  					double[] envelope = image[bandidx];  					// Find maximum number when all numbers are made positive.  					//double max = envelope.Max((b) => Math.Abs(b));  					//Console.WriteLine(max);    					#region Frequency shifting  					  					// random phase between +-pi  					double phase = SpectrogramUtils.RandomDoubleMinus1ToPlus1() * Math.PI;    					var bandsignal = new double[envelope.Length*2];  					for (int j = 0; j < 4; ++j) {  						double sine = Math.Cos(j * Math.PI/2 + phase);  						for (int i = j; i < bandsignal.Length; i += 4) {  							bandsignal[i] = envelope[i/2] * sine;  						}  					}  					#endregion  					  					// FFT of the envelope  					var filterband = SpectrogramUtils.padded_FFT(ref bandsignal);    					// Windowed-Sinc Filtering (frequency-domain filter)  					for (int i = 0; i < filterband.Length; ++i) {  						double x = (double)i/filterband.Length;  						  						// normalized blackman window antiderivative  						filterband[i] *= x - ((0.5/(2.0 * Math.PI)) * Math.Sin(2.0 * Math.PI *x) + (0.08/(4.0 * Math.PI)) * Math.Sin(4.0 * Math.PI *x) / 0.42);  					}    					//Console.Out.WriteLine("Spectrum size: {0}"' spectrum.Length);  					//std::cout << bandidx << ". filterband size: " << filterband.Length << "; start: " << filterbank->GetBand(bandidx).first <<"; end: " << filterbank->GetBand(bandidx).second << "\n";    					double center = filterbank.GetCenter(bandidx);  					double offset = Math.Max((double)0' center - filterband.Length/2);  					  					//Console.Out.WriteLine("Offset: {0} = {1} hz"' offset' offset/filterscale);  					  					for (int i = 0; i < filterband.Length; ++i) {  						int spectrumIndex = (int) (offset + i);  						if (spectrumIndex > 0 && spectrumIndex < spectrum.Length) {  							spectrum[spectrumIndex] += filterband[i];  						}  					}  				}    				double[] @out = SpectrogramUtils.padded_IFFT(ref spectrum);  				  				Console.Out.WriteLine("Samples: {0} -> {1}"' @out.Length' samples);  				  				SpectrogramUtils.NormalizeSignal(ref @out);  				return @out;  			}
Magic Number,ArssSpectrogram,Spectrogram,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\ArssSpectrogram\Spectrogram.cs,SynthetizeSine,The following statement contains a magic number: using (new DebugTimer("Spectrogram: SynthetizeSine(double[][])"))  			{  				int samples = x_Width * samplerate/pixpersec;  				var spectrum = new Complex[samples/2+1];    				double filterscale = ((double)spectrum.Length*2)/samplerate;    				Filterbank filterbank = Filterbank.GetFilterbank(frequency_axis' filterscale' basefreq' bandwidth' overlap);    				for (int bandidx = 0; bandidx < y_Height; ++bandidx) {  					// TODO: support cancelling this process    					OutputBandProgress(bandidx+1' y_Height);    					//double[] envelope = EnvelopeFromSpectrogram(image' bandidx);  					double[] envelope = image[bandidx];  					// Find maximum number when all numbers are made positive.  					//double max = envelope.Max((b) => Math.Abs(b));  					//Console.WriteLine(max);    					#region Frequency shifting  					  					// random phase between +-pi  					double phase = SpectrogramUtils.RandomDoubleMinus1ToPlus1() * Math.PI;    					var bandsignal = new double[envelope.Length*2];  					for (int j = 0; j < 4; ++j) {  						double sine = Math.Cos(j * Math.PI/2 + phase);  						for (int i = j; i < bandsignal.Length; i += 4) {  							bandsignal[i] = envelope[i/2] * sine;  						}  					}  					#endregion  					  					// FFT of the envelope  					var filterband = SpectrogramUtils.padded_FFT(ref bandsignal);    					// Windowed-Sinc Filtering (frequency-domain filter)  					for (int i = 0; i < filterband.Length; ++i) {  						double x = (double)i/filterband.Length;  						  						// normalized blackman window antiderivative  						filterband[i] *= x - ((0.5/(2.0 * Math.PI)) * Math.Sin(2.0 * Math.PI *x) + (0.08/(4.0 * Math.PI)) * Math.Sin(4.0 * Math.PI *x) / 0.42);  					}    					//Console.Out.WriteLine("Spectrum size: {0}"' spectrum.Length);  					//std::cout << bandidx << ". filterband size: " << filterband.Length << "; start: " << filterbank->GetBand(bandidx).first <<"; end: " << filterbank->GetBand(bandidx).second << "\n";    					double center = filterbank.GetCenter(bandidx);  					double offset = Math.Max((double)0' center - filterband.Length/2);  					  					//Console.Out.WriteLine("Offset: {0} = {1} hz"' offset' offset/filterscale);  					  					for (int i = 0; i < filterband.Length; ++i) {  						int spectrumIndex = (int) (offset + i);  						if (spectrumIndex > 0 && spectrumIndex < spectrum.Length) {  							spectrum[spectrumIndex] += filterband[i];  						}  					}  				}    				double[] @out = SpectrogramUtils.padded_IFFT(ref spectrum);  				  				Console.Out.WriteLine("Samples: {0} -> {1}"' @out.Length' samples);  				  				SpectrogramUtils.NormalizeSignal(ref @out);  				return @out;  			}
Magic Number,ArssSpectrogram,Spectrogram,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\ArssSpectrogram\Spectrogram.cs,SynthetizeSine,The following statement contains a magic number: using (new DebugTimer("Spectrogram: SynthetizeSine(double[][])"))  			{  				int samples = x_Width * samplerate/pixpersec;  				var spectrum = new Complex[samples/2+1];    				double filterscale = ((double)spectrum.Length*2)/samplerate;    				Filterbank filterbank = Filterbank.GetFilterbank(frequency_axis' filterscale' basefreq' bandwidth' overlap);    				for (int bandidx = 0; bandidx < y_Height; ++bandidx) {  					// TODO: support cancelling this process    					OutputBandProgress(bandidx+1' y_Height);    					//double[] envelope = EnvelopeFromSpectrogram(image' bandidx);  					double[] envelope = image[bandidx];  					// Find maximum number when all numbers are made positive.  					//double max = envelope.Max((b) => Math.Abs(b));  					//Console.WriteLine(max);    					#region Frequency shifting  					  					// random phase between +-pi  					double phase = SpectrogramUtils.RandomDoubleMinus1ToPlus1() * Math.PI;    					var bandsignal = new double[envelope.Length*2];  					for (int j = 0; j < 4; ++j) {  						double sine = Math.Cos(j * Math.PI/2 + phase);  						for (int i = j; i < bandsignal.Length; i += 4) {  							bandsignal[i] = envelope[i/2] * sine;  						}  					}  					#endregion  					  					// FFT of the envelope  					var filterband = SpectrogramUtils.padded_FFT(ref bandsignal);    					// Windowed-Sinc Filtering (frequency-domain filter)  					for (int i = 0; i < filterband.Length; ++i) {  						double x = (double)i/filterband.Length;  						  						// normalized blackman window antiderivative  						filterband[i] *= x - ((0.5/(2.0 * Math.PI)) * Math.Sin(2.0 * Math.PI *x) + (0.08/(4.0 * Math.PI)) * Math.Sin(4.0 * Math.PI *x) / 0.42);  					}    					//Console.Out.WriteLine("Spectrum size: {0}"' spectrum.Length);  					//std::cout << bandidx << ". filterband size: " << filterband.Length << "; start: " << filterbank->GetBand(bandidx).first <<"; end: " << filterbank->GetBand(bandidx).second << "\n";    					double center = filterbank.GetCenter(bandidx);  					double offset = Math.Max((double)0' center - filterband.Length/2);  					  					//Console.Out.WriteLine("Offset: {0} = {1} hz"' offset' offset/filterscale);  					  					for (int i = 0; i < filterband.Length; ++i) {  						int spectrumIndex = (int) (offset + i);  						if (spectrumIndex > 0 && spectrumIndex < spectrum.Length) {  							spectrum[spectrumIndex] += filterband[i];  						}  					}  				}    				double[] @out = SpectrogramUtils.padded_IFFT(ref spectrum);  				  				Console.Out.WriteLine("Samples: {0} -> {1}"' @out.Length' samples);  				  				SpectrogramUtils.NormalizeSignal(ref @out);  				return @out;  			}
Magic Number,ArssSpectrogram,Spectrogram,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\ArssSpectrogram\Spectrogram.cs,SynthetizeSine,The following statement contains a magic number: using (new DebugTimer("Spectrogram: SynthetizeSine(double[][])"))  			{  				int samples = x_Width * samplerate/pixpersec;  				var spectrum = new Complex[samples/2+1];    				double filterscale = ((double)spectrum.Length*2)/samplerate;    				Filterbank filterbank = Filterbank.GetFilterbank(frequency_axis' filterscale' basefreq' bandwidth' overlap);    				for (int bandidx = 0; bandidx < y_Height; ++bandidx) {  					// TODO: support cancelling this process    					OutputBandProgress(bandidx+1' y_Height);    					//double[] envelope = EnvelopeFromSpectrogram(image' bandidx);  					double[] envelope = image[bandidx];  					// Find maximum number when all numbers are made positive.  					//double max = envelope.Max((b) => Math.Abs(b));  					//Console.WriteLine(max);    					#region Frequency shifting  					  					// random phase between +-pi  					double phase = SpectrogramUtils.RandomDoubleMinus1ToPlus1() * Math.PI;    					var bandsignal = new double[envelope.Length*2];  					for (int j = 0; j < 4; ++j) {  						double sine = Math.Cos(j * Math.PI/2 + phase);  						for (int i = j; i < bandsignal.Length; i += 4) {  							bandsignal[i] = envelope[i/2] * sine;  						}  					}  					#endregion  					  					// FFT of the envelope  					var filterband = SpectrogramUtils.padded_FFT(ref bandsignal);    					// Windowed-Sinc Filtering (frequency-domain filter)  					for (int i = 0; i < filterband.Length; ++i) {  						double x = (double)i/filterband.Length;  						  						// normalized blackman window antiderivative  						filterband[i] *= x - ((0.5/(2.0 * Math.PI)) * Math.Sin(2.0 * Math.PI *x) + (0.08/(4.0 * Math.PI)) * Math.Sin(4.0 * Math.PI *x) / 0.42);  					}    					//Console.Out.WriteLine("Spectrum size: {0}"' spectrum.Length);  					//std::cout << bandidx << ". filterband size: " << filterband.Length << "; start: " << filterbank->GetBand(bandidx).first <<"; end: " << filterbank->GetBand(bandidx).second << "\n";    					double center = filterbank.GetCenter(bandidx);  					double offset = Math.Max((double)0' center - filterband.Length/2);  					  					//Console.Out.WriteLine("Offset: {0} = {1} hz"' offset' offset/filterscale);  					  					for (int i = 0; i < filterband.Length; ++i) {  						int spectrumIndex = (int) (offset + i);  						if (spectrumIndex > 0 && spectrumIndex < spectrum.Length) {  							spectrum[spectrumIndex] += filterband[i];  						}  					}  				}    				double[] @out = SpectrogramUtils.padded_IFFT(ref spectrum);  				  				Console.Out.WriteLine("Samples: {0} -> {1}"' @out.Length' samples);  				  				SpectrogramUtils.NormalizeSignal(ref @out);  				return @out;  			}
Magic Number,ArssSpectrogram,Spectrogram,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\ArssSpectrogram\Spectrogram.cs,SynthetizeSine,The following statement contains a magic number: using (new DebugTimer("Spectrogram: SynthetizeSine(double[][])"))  			{  				int samples = x_Width * samplerate/pixpersec;  				var spectrum = new Complex[samples/2+1];    				double filterscale = ((double)spectrum.Length*2)/samplerate;    				Filterbank filterbank = Filterbank.GetFilterbank(frequency_axis' filterscale' basefreq' bandwidth' overlap);    				for (int bandidx = 0; bandidx < y_Height; ++bandidx) {  					// TODO: support cancelling this process    					OutputBandProgress(bandidx+1' y_Height);    					//double[] envelope = EnvelopeFromSpectrogram(image' bandidx);  					double[] envelope = image[bandidx];  					// Find maximum number when all numbers are made positive.  					//double max = envelope.Max((b) => Math.Abs(b));  					//Console.WriteLine(max);    					#region Frequency shifting  					  					// random phase between +-pi  					double phase = SpectrogramUtils.RandomDoubleMinus1ToPlus1() * Math.PI;    					var bandsignal = new double[envelope.Length*2];  					for (int j = 0; j < 4; ++j) {  						double sine = Math.Cos(j * Math.PI/2 + phase);  						for (int i = j; i < bandsignal.Length; i += 4) {  							bandsignal[i] = envelope[i/2] * sine;  						}  					}  					#endregion  					  					// FFT of the envelope  					var filterband = SpectrogramUtils.padded_FFT(ref bandsignal);    					// Windowed-Sinc Filtering (frequency-domain filter)  					for (int i = 0; i < filterband.Length; ++i) {  						double x = (double)i/filterband.Length;  						  						// normalized blackman window antiderivative  						filterband[i] *= x - ((0.5/(2.0 * Math.PI)) * Math.Sin(2.0 * Math.PI *x) + (0.08/(4.0 * Math.PI)) * Math.Sin(4.0 * Math.PI *x) / 0.42);  					}    					//Console.Out.WriteLine("Spectrum size: {0}"' spectrum.Length);  					//std::cout << bandidx << ". filterband size: " << filterband.Length << "; start: " << filterbank->GetBand(bandidx).first <<"; end: " << filterbank->GetBand(bandidx).second << "\n";    					double center = filterbank.GetCenter(bandidx);  					double offset = Math.Max((double)0' center - filterband.Length/2);  					  					//Console.Out.WriteLine("Offset: {0} = {1} hz"' offset' offset/filterscale);  					  					for (int i = 0; i < filterband.Length; ++i) {  						int spectrumIndex = (int) (offset + i);  						if (spectrumIndex > 0 && spectrumIndex < spectrum.Length) {  							spectrum[spectrumIndex] += filterband[i];  						}  					}  				}    				double[] @out = SpectrogramUtils.padded_IFFT(ref spectrum);  				  				Console.Out.WriteLine("Samples: {0} -> {1}"' @out.Length' samples);  				  				SpectrogramUtils.NormalizeSignal(ref @out);  				return @out;  			}
Magic Number,ArssSpectrogram,Spectrogram,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\ArssSpectrogram\Spectrogram.cs,SynthetizeSine,The following statement contains a magic number: using (new DebugTimer("Spectrogram: SynthetizeSine(double[][])"))  			{  				int samples = x_Width * samplerate/pixpersec;  				var spectrum = new Complex[samples/2+1];    				double filterscale = ((double)spectrum.Length*2)/samplerate;    				Filterbank filterbank = Filterbank.GetFilterbank(frequency_axis' filterscale' basefreq' bandwidth' overlap);    				for (int bandidx = 0; bandidx < y_Height; ++bandidx) {  					// TODO: support cancelling this process    					OutputBandProgress(bandidx+1' y_Height);    					//double[] envelope = EnvelopeFromSpectrogram(image' bandidx);  					double[] envelope = image[bandidx];  					// Find maximum number when all numbers are made positive.  					//double max = envelope.Max((b) => Math.Abs(b));  					//Console.WriteLine(max);    					#region Frequency shifting  					  					// random phase between +-pi  					double phase = SpectrogramUtils.RandomDoubleMinus1ToPlus1() * Math.PI;    					var bandsignal = new double[envelope.Length*2];  					for (int j = 0; j < 4; ++j) {  						double sine = Math.Cos(j * Math.PI/2 + phase);  						for (int i = j; i < bandsignal.Length; i += 4) {  							bandsignal[i] = envelope[i/2] * sine;  						}  					}  					#endregion  					  					// FFT of the envelope  					var filterband = SpectrogramUtils.padded_FFT(ref bandsignal);    					// Windowed-Sinc Filtering (frequency-domain filter)  					for (int i = 0; i < filterband.Length; ++i) {  						double x = (double)i/filterband.Length;  						  						// normalized blackman window antiderivative  						filterband[i] *= x - ((0.5/(2.0 * Math.PI)) * Math.Sin(2.0 * Math.PI *x) + (0.08/(4.0 * Math.PI)) * Math.Sin(4.0 * Math.PI *x) / 0.42);  					}    					//Console.Out.WriteLine("Spectrum size: {0}"' spectrum.Length);  					//std::cout << bandidx << ". filterband size: " << filterband.Length << "; start: " << filterbank->GetBand(bandidx).first <<"; end: " << filterbank->GetBand(bandidx).second << "\n";    					double center = filterbank.GetCenter(bandidx);  					double offset = Math.Max((double)0' center - filterband.Length/2);  					  					//Console.Out.WriteLine("Offset: {0} = {1} hz"' offset' offset/filterscale);  					  					for (int i = 0; i < filterband.Length; ++i) {  						int spectrumIndex = (int) (offset + i);  						if (spectrumIndex > 0 && spectrumIndex < spectrum.Length) {  							spectrum[spectrumIndex] += filterband[i];  						}  					}  				}    				double[] @out = SpectrogramUtils.padded_IFFT(ref spectrum);  				  				Console.Out.WriteLine("Samples: {0} -> {1}"' @out.Length' samples);  				  				SpectrogramUtils.NormalizeSignal(ref @out);  				return @out;  			}
Magic Number,ArssSpectrogram,Spectrogram,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\ArssSpectrogram\Spectrogram.cs,SynthetizeSine,The following statement contains a magic number: using (new DebugTimer("Spectrogram: SynthetizeSine(double[][])"))  			{  				int samples = x_Width * samplerate/pixpersec;  				var spectrum = new Complex[samples/2+1];    				double filterscale = ((double)spectrum.Length*2)/samplerate;    				Filterbank filterbank = Filterbank.GetFilterbank(frequency_axis' filterscale' basefreq' bandwidth' overlap);    				for (int bandidx = 0; bandidx < y_Height; ++bandidx) {  					// TODO: support cancelling this process    					OutputBandProgress(bandidx+1' y_Height);    					//double[] envelope = EnvelopeFromSpectrogram(image' bandidx);  					double[] envelope = image[bandidx];  					// Find maximum number when all numbers are made positive.  					//double max = envelope.Max((b) => Math.Abs(b));  					//Console.WriteLine(max);    					#region Frequency shifting  					  					// random phase between +-pi  					double phase = SpectrogramUtils.RandomDoubleMinus1ToPlus1() * Math.PI;    					var bandsignal = new double[envelope.Length*2];  					for (int j = 0; j < 4; ++j) {  						double sine = Math.Cos(j * Math.PI/2 + phase);  						for (int i = j; i < bandsignal.Length; i += 4) {  							bandsignal[i] = envelope[i/2] * sine;  						}  					}  					#endregion  					  					// FFT of the envelope  					var filterband = SpectrogramUtils.padded_FFT(ref bandsignal);    					// Windowed-Sinc Filtering (frequency-domain filter)  					for (int i = 0; i < filterband.Length; ++i) {  						double x = (double)i/filterband.Length;  						  						// normalized blackman window antiderivative  						filterband[i] *= x - ((0.5/(2.0 * Math.PI)) * Math.Sin(2.0 * Math.PI *x) + (0.08/(4.0 * Math.PI)) * Math.Sin(4.0 * Math.PI *x) / 0.42);  					}    					//Console.Out.WriteLine("Spectrum size: {0}"' spectrum.Length);  					//std::cout << bandidx << ". filterband size: " << filterband.Length << "; start: " << filterbank->GetBand(bandidx).first <<"; end: " << filterbank->GetBand(bandidx).second << "\n";    					double center = filterbank.GetCenter(bandidx);  					double offset = Math.Max((double)0' center - filterband.Length/2);  					  					//Console.Out.WriteLine("Offset: {0} = {1} hz"' offset' offset/filterscale);  					  					for (int i = 0; i < filterband.Length; ++i) {  						int spectrumIndex = (int) (offset + i);  						if (spectrumIndex > 0 && spectrumIndex < spectrum.Length) {  							spectrum[spectrumIndex] += filterband[i];  						}  					}  				}    				double[] @out = SpectrogramUtils.padded_IFFT(ref spectrum);  				  				Console.Out.WriteLine("Samples: {0} -> {1}"' @out.Length' samples);  				  				SpectrogramUtils.NormalizeSignal(ref @out);  				return @out;  			}
Magic Number,ArssSpectrogram,Spectrogram,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\ArssSpectrogram\Spectrogram.cs,SynthetizeSine,The following statement contains a magic number: using (new DebugTimer("Spectrogram: SynthetizeSine(double[][])"))  			{  				int samples = x_Width * samplerate/pixpersec;  				var spectrum = new Complex[samples/2+1];    				double filterscale = ((double)spectrum.Length*2)/samplerate;    				Filterbank filterbank = Filterbank.GetFilterbank(frequency_axis' filterscale' basefreq' bandwidth' overlap);    				for (int bandidx = 0; bandidx < y_Height; ++bandidx) {  					// TODO: support cancelling this process    					OutputBandProgress(bandidx+1' y_Height);    					//double[] envelope = EnvelopeFromSpectrogram(image' bandidx);  					double[] envelope = image[bandidx];  					// Find maximum number when all numbers are made positive.  					//double max = envelope.Max((b) => Math.Abs(b));  					//Console.WriteLine(max);    					#region Frequency shifting  					  					// random phase between +-pi  					double phase = SpectrogramUtils.RandomDoubleMinus1ToPlus1() * Math.PI;    					var bandsignal = new double[envelope.Length*2];  					for (int j = 0; j < 4; ++j) {  						double sine = Math.Cos(j * Math.PI/2 + phase);  						for (int i = j; i < bandsignal.Length; i += 4) {  							bandsignal[i] = envelope[i/2] * sine;  						}  					}  					#endregion  					  					// FFT of the envelope  					var filterband = SpectrogramUtils.padded_FFT(ref bandsignal);    					// Windowed-Sinc Filtering (frequency-domain filter)  					for (int i = 0; i < filterband.Length; ++i) {  						double x = (double)i/filterband.Length;  						  						// normalized blackman window antiderivative  						filterband[i] *= x - ((0.5/(2.0 * Math.PI)) * Math.Sin(2.0 * Math.PI *x) + (0.08/(4.0 * Math.PI)) * Math.Sin(4.0 * Math.PI *x) / 0.42);  					}    					//Console.Out.WriteLine("Spectrum size: {0}"' spectrum.Length);  					//std::cout << bandidx << ". filterband size: " << filterband.Length << "; start: " << filterbank->GetBand(bandidx).first <<"; end: " << filterbank->GetBand(bandidx).second << "\n";    					double center = filterbank.GetCenter(bandidx);  					double offset = Math.Max((double)0' center - filterband.Length/2);  					  					//Console.Out.WriteLine("Offset: {0} = {1} hz"' offset' offset/filterscale);  					  					for (int i = 0; i < filterband.Length; ++i) {  						int spectrumIndex = (int) (offset + i);  						if (spectrumIndex > 0 && spectrumIndex < spectrum.Length) {  							spectrum[spectrumIndex] += filterband[i];  						}  					}  				}    				double[] @out = SpectrogramUtils.padded_IFFT(ref spectrum);  				  				Console.Out.WriteLine("Samples: {0} -> {1}"' @out.Length' samples);  				  				SpectrogramUtils.NormalizeSignal(ref @out);  				return @out;  			}
Magic Number,ArssSpectrogram,Spectrogram,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\ArssSpectrogram\Spectrogram.cs,SynthetizeSine,The following statement contains a magic number: using (new DebugTimer("Spectrogram: SynthetizeSine(double[][])"))  			{  				int samples = x_Width * samplerate/pixpersec;  				var spectrum = new Complex[samples/2+1];    				double filterscale = ((double)spectrum.Length*2)/samplerate;    				Filterbank filterbank = Filterbank.GetFilterbank(frequency_axis' filterscale' basefreq' bandwidth' overlap);    				for (int bandidx = 0; bandidx < y_Height; ++bandidx) {  					// TODO: support cancelling this process    					OutputBandProgress(bandidx+1' y_Height);    					//double[] envelope = EnvelopeFromSpectrogram(image' bandidx);  					double[] envelope = image[bandidx];  					// Find maximum number when all numbers are made positive.  					//double max = envelope.Max((b) => Math.Abs(b));  					//Console.WriteLine(max);    					#region Frequency shifting  					  					// random phase between +-pi  					double phase = SpectrogramUtils.RandomDoubleMinus1ToPlus1() * Math.PI;    					var bandsignal = new double[envelope.Length*2];  					for (int j = 0; j < 4; ++j) {  						double sine = Math.Cos(j * Math.PI/2 + phase);  						for (int i = j; i < bandsignal.Length; i += 4) {  							bandsignal[i] = envelope[i/2] * sine;  						}  					}  					#endregion  					  					// FFT of the envelope  					var filterband = SpectrogramUtils.padded_FFT(ref bandsignal);    					// Windowed-Sinc Filtering (frequency-domain filter)  					for (int i = 0; i < filterband.Length; ++i) {  						double x = (double)i/filterband.Length;  						  						// normalized blackman window antiderivative  						filterband[i] *= x - ((0.5/(2.0 * Math.PI)) * Math.Sin(2.0 * Math.PI *x) + (0.08/(4.0 * Math.PI)) * Math.Sin(4.0 * Math.PI *x) / 0.42);  					}    					//Console.Out.WriteLine("Spectrum size: {0}"' spectrum.Length);  					//std::cout << bandidx << ". filterband size: " << filterband.Length << "; start: " << filterbank->GetBand(bandidx).first <<"; end: " << filterbank->GetBand(bandidx).second << "\n";    					double center = filterbank.GetCenter(bandidx);  					double offset = Math.Max((double)0' center - filterband.Length/2);  					  					//Console.Out.WriteLine("Offset: {0} = {1} hz"' offset' offset/filterscale);  					  					for (int i = 0; i < filterband.Length; ++i) {  						int spectrumIndex = (int) (offset + i);  						if (spectrumIndex > 0 && spectrumIndex < spectrum.Length) {  							spectrum[spectrumIndex] += filterband[i];  						}  					}  				}    				double[] @out = SpectrogramUtils.padded_IFFT(ref spectrum);  				  				Console.Out.WriteLine("Samples: {0} -> {1}"' @out.Length' samples);  				  				SpectrogramUtils.NormalizeSignal(ref @out);  				return @out;  			}
Magic Number,ArssSpectrogram,Spectrogram,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\ArssSpectrogram\Spectrogram.cs,SynthetizeSine,The following statement contains a magic number: using (new DebugTimer("Spectrogram: SynthetizeSine(double[][])"))  			{  				int samples = x_Width * samplerate/pixpersec;  				var spectrum = new Complex[samples/2+1];    				double filterscale = ((double)spectrum.Length*2)/samplerate;    				Filterbank filterbank = Filterbank.GetFilterbank(frequency_axis' filterscale' basefreq' bandwidth' overlap);    				for (int bandidx = 0; bandidx < y_Height; ++bandidx) {  					// TODO: support cancelling this process    					OutputBandProgress(bandidx+1' y_Height);    					//double[] envelope = EnvelopeFromSpectrogram(image' bandidx);  					double[] envelope = image[bandidx];  					// Find maximum number when all numbers are made positive.  					//double max = envelope.Max((b) => Math.Abs(b));  					//Console.WriteLine(max);    					#region Frequency shifting  					  					// random phase between +-pi  					double phase = SpectrogramUtils.RandomDoubleMinus1ToPlus1() * Math.PI;    					var bandsignal = new double[envelope.Length*2];  					for (int j = 0; j < 4; ++j) {  						double sine = Math.Cos(j * Math.PI/2 + phase);  						for (int i = j; i < bandsignal.Length; i += 4) {  							bandsignal[i] = envelope[i/2] * sine;  						}  					}  					#endregion  					  					// FFT of the envelope  					var filterband = SpectrogramUtils.padded_FFT(ref bandsignal);    					// Windowed-Sinc Filtering (frequency-domain filter)  					for (int i = 0; i < filterband.Length; ++i) {  						double x = (double)i/filterband.Length;  						  						// normalized blackman window antiderivative  						filterband[i] *= x - ((0.5/(2.0 * Math.PI)) * Math.Sin(2.0 * Math.PI *x) + (0.08/(4.0 * Math.PI)) * Math.Sin(4.0 * Math.PI *x) / 0.42);  					}    					//Console.Out.WriteLine("Spectrum size: {0}"' spectrum.Length);  					//std::cout << bandidx << ". filterband size: " << filterband.Length << "; start: " << filterbank->GetBand(bandidx).first <<"; end: " << filterbank->GetBand(bandidx).second << "\n";    					double center = filterbank.GetCenter(bandidx);  					double offset = Math.Max((double)0' center - filterband.Length/2);  					  					//Console.Out.WriteLine("Offset: {0} = {1} hz"' offset' offset/filterscale);  					  					for (int i = 0; i < filterband.Length; ++i) {  						int spectrumIndex = (int) (offset + i);  						if (spectrumIndex > 0 && spectrumIndex < spectrum.Length) {  							spectrum[spectrumIndex] += filterband[i];  						}  					}  				}    				double[] @out = SpectrogramUtils.padded_IFFT(ref spectrum);  				  				Console.Out.WriteLine("Samples: {0} -> {1}"' @out.Length' samples);  				  				SpectrogramUtils.NormalizeSignal(ref @out);  				return @out;  			}
Magic Number,ArssSpectrogram,Spectrogram,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\ArssSpectrogram\Spectrogram.cs,SynthetizeSine,The following statement contains a magic number: using (new DebugTimer("Spectrogram: SynthetizeSine(double[][])"))  			{  				int samples = x_Width * samplerate/pixpersec;  				var spectrum = new Complex[samples/2+1];    				double filterscale = ((double)spectrum.Length*2)/samplerate;    				Filterbank filterbank = Filterbank.GetFilterbank(frequency_axis' filterscale' basefreq' bandwidth' overlap);    				for (int bandidx = 0; bandidx < y_Height; ++bandidx) {  					// TODO: support cancelling this process    					OutputBandProgress(bandidx+1' y_Height);    					//double[] envelope = EnvelopeFromSpectrogram(image' bandidx);  					double[] envelope = image[bandidx];  					// Find maximum number when all numbers are made positive.  					//double max = envelope.Max((b) => Math.Abs(b));  					//Console.WriteLine(max);    					#region Frequency shifting  					  					// random phase between +-pi  					double phase = SpectrogramUtils.RandomDoubleMinus1ToPlus1() * Math.PI;    					var bandsignal = new double[envelope.Length*2];  					for (int j = 0; j < 4; ++j) {  						double sine = Math.Cos(j * Math.PI/2 + phase);  						for (int i = j; i < bandsignal.Length; i += 4) {  							bandsignal[i] = envelope[i/2] * sine;  						}  					}  					#endregion  					  					// FFT of the envelope  					var filterband = SpectrogramUtils.padded_FFT(ref bandsignal);    					// Windowed-Sinc Filtering (frequency-domain filter)  					for (int i = 0; i < filterband.Length; ++i) {  						double x = (double)i/filterband.Length;  						  						// normalized blackman window antiderivative  						filterband[i] *= x - ((0.5/(2.0 * Math.PI)) * Math.Sin(2.0 * Math.PI *x) + (0.08/(4.0 * Math.PI)) * Math.Sin(4.0 * Math.PI *x) / 0.42);  					}    					//Console.Out.WriteLine("Spectrum size: {0}"' spectrum.Length);  					//std::cout << bandidx << ". filterband size: " << filterband.Length << "; start: " << filterbank->GetBand(bandidx).first <<"; end: " << filterbank->GetBand(bandidx).second << "\n";    					double center = filterbank.GetCenter(bandidx);  					double offset = Math.Max((double)0' center - filterband.Length/2);  					  					//Console.Out.WriteLine("Offset: {0} = {1} hz"' offset' offset/filterscale);  					  					for (int i = 0; i < filterband.Length; ++i) {  						int spectrumIndex = (int) (offset + i);  						if (spectrumIndex > 0 && spectrumIndex < spectrum.Length) {  							spectrum[spectrumIndex] += filterband[i];  						}  					}  				}    				double[] @out = SpectrogramUtils.padded_IFFT(ref spectrum);  				  				Console.Out.WriteLine("Samples: {0} -> {1}"' @out.Length' samples);  				  				SpectrogramUtils.NormalizeSignal(ref @out);  				return @out;  			}
Magic Number,ArssSpectrogram,Spectrogram,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\ArssSpectrogram\Spectrogram.cs,SynthetizeSine,The following statement contains a magic number: using (new DebugTimer("Spectrogram: SynthetizeSine(double[][])"))  			{  				int samples = x_Width * samplerate/pixpersec;  				var spectrum = new Complex[samples/2+1];    				double filterscale = ((double)spectrum.Length*2)/samplerate;    				Filterbank filterbank = Filterbank.GetFilterbank(frequency_axis' filterscale' basefreq' bandwidth' overlap);    				for (int bandidx = 0; bandidx < y_Height; ++bandidx) {  					// TODO: support cancelling this process    					OutputBandProgress(bandidx+1' y_Height);    					//double[] envelope = EnvelopeFromSpectrogram(image' bandidx);  					double[] envelope = image[bandidx];  					// Find maximum number when all numbers are made positive.  					//double max = envelope.Max((b) => Math.Abs(b));  					//Console.WriteLine(max);    					#region Frequency shifting  					  					// random phase between +-pi  					double phase = SpectrogramUtils.RandomDoubleMinus1ToPlus1() * Math.PI;    					var bandsignal = new double[envelope.Length*2];  					for (int j = 0; j < 4; ++j) {  						double sine = Math.Cos(j * Math.PI/2 + phase);  						for (int i = j; i < bandsignal.Length; i += 4) {  							bandsignal[i] = envelope[i/2] * sine;  						}  					}  					#endregion  					  					// FFT of the envelope  					var filterband = SpectrogramUtils.padded_FFT(ref bandsignal);    					// Windowed-Sinc Filtering (frequency-domain filter)  					for (int i = 0; i < filterband.Length; ++i) {  						double x = (double)i/filterband.Length;  						  						// normalized blackman window antiderivative  						filterband[i] *= x - ((0.5/(2.0 * Math.PI)) * Math.Sin(2.0 * Math.PI *x) + (0.08/(4.0 * Math.PI)) * Math.Sin(4.0 * Math.PI *x) / 0.42);  					}    					//Console.Out.WriteLine("Spectrum size: {0}"' spectrum.Length);  					//std::cout << bandidx << ". filterband size: " << filterband.Length << "; start: " << filterbank->GetBand(bandidx).first <<"; end: " << filterbank->GetBand(bandidx).second << "\n";    					double center = filterbank.GetCenter(bandidx);  					double offset = Math.Max((double)0' center - filterband.Length/2);  					  					//Console.Out.WriteLine("Offset: {0} = {1} hz"' offset' offset/filterscale);  					  					for (int i = 0; i < filterband.Length; ++i) {  						int spectrumIndex = (int) (offset + i);  						if (spectrumIndex > 0 && spectrumIndex < spectrum.Length) {  							spectrum[spectrumIndex] += filterband[i];  						}  					}  				}    				double[] @out = SpectrogramUtils.padded_IFFT(ref spectrum);  				  				Console.Out.WriteLine("Samples: {0} -> {1}"' @out.Length' samples);  				  				SpectrogramUtils.NormalizeSignal(ref @out);  				return @out;  			}
Magic Number,ArssSpectrogram,Spectrogram,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\ArssSpectrogram\Spectrogram.cs,SynthetizeSine,The following statement contains a magic number: using (new DebugTimer("Spectrogram: SynthetizeSine(double[][])"))  			{  				int samples = x_Width * samplerate/pixpersec;  				var spectrum = new Complex[samples/2+1];    				double filterscale = ((double)spectrum.Length*2)/samplerate;    				Filterbank filterbank = Filterbank.GetFilterbank(frequency_axis' filterscale' basefreq' bandwidth' overlap);    				for (int bandidx = 0; bandidx < y_Height; ++bandidx) {  					// TODO: support cancelling this process    					OutputBandProgress(bandidx+1' y_Height);    					//double[] envelope = EnvelopeFromSpectrogram(image' bandidx);  					double[] envelope = image[bandidx];  					// Find maximum number when all numbers are made positive.  					//double max = envelope.Max((b) => Math.Abs(b));  					//Console.WriteLine(max);    					#region Frequency shifting  					  					// random phase between +-pi  					double phase = SpectrogramUtils.RandomDoubleMinus1ToPlus1() * Math.PI;    					var bandsignal = new double[envelope.Length*2];  					for (int j = 0; j < 4; ++j) {  						double sine = Math.Cos(j * Math.PI/2 + phase);  						for (int i = j; i < bandsignal.Length; i += 4) {  							bandsignal[i] = envelope[i/2] * sine;  						}  					}  					#endregion  					  					// FFT of the envelope  					var filterband = SpectrogramUtils.padded_FFT(ref bandsignal);    					// Windowed-Sinc Filtering (frequency-domain filter)  					for (int i = 0; i < filterband.Length; ++i) {  						double x = (double)i/filterband.Length;  						  						// normalized blackman window antiderivative  						filterband[i] *= x - ((0.5/(2.0 * Math.PI)) * Math.Sin(2.0 * Math.PI *x) + (0.08/(4.0 * Math.PI)) * Math.Sin(4.0 * Math.PI *x) / 0.42);  					}    					//Console.Out.WriteLine("Spectrum size: {0}"' spectrum.Length);  					//std::cout << bandidx << ". filterband size: " << filterband.Length << "; start: " << filterbank->GetBand(bandidx).first <<"; end: " << filterbank->GetBand(bandidx).second << "\n";    					double center = filterbank.GetCenter(bandidx);  					double offset = Math.Max((double)0' center - filterband.Length/2);  					  					//Console.Out.WriteLine("Offset: {0} = {1} hz"' offset' offset/filterscale);  					  					for (int i = 0; i < filterband.Length; ++i) {  						int spectrumIndex = (int) (offset + i);  						if (spectrumIndex > 0 && spectrumIndex < spectrum.Length) {  							spectrum[spectrumIndex] += filterband[i];  						}  					}  				}    				double[] @out = SpectrogramUtils.padded_IFFT(ref spectrum);  				  				Console.Out.WriteLine("Samples: {0} -> {1}"' @out.Length' samples);  				  				SpectrogramUtils.NormalizeSignal(ref @out);  				return @out;  			}
Magic Number,ArssSpectrogram,Spectrogram,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\ArssSpectrogram\Spectrogram.cs,SynthetizeSine,The following statement contains a magic number: using (new DebugTimer("Spectrogram: SynthetizeSine(Bitmap)"))  			{  				int samples = image.Width * samplerate/pixpersec;  				var spectrum = new Complex[samples/2+1];    				double filterscale = ((double)spectrum.Length*2)/samplerate;    				Filterbank filterbank = Filterbank.GetFilterbank(frequency_axis' filterscale' basefreq' bandwidth' overlap);    				for (int bandidx = 0; bandidx < image.Height; ++bandidx) {  					// TODO: support cancelling this process    					OutputBandProgress(bandidx' image.Height);    					double[] envelope = EnvelopeFromSpectrogram(image' bandidx);  					// Find maximum number when all numbers are made positive.  					//double max = envelope.Max((b) => Math.Abs(b));  					//Console.WriteLine(max);    					// random phase between +-pi  					double phase = SpectrogramUtils.RandomDoubleMinus1ToPlus1() * Math.PI;    					var bandsignal = new double[envelope.Length*2];  					for (int j = 0; j < 4; ++j) {  						double sine = Math.Cos(j * Math.PI/2 + phase);  						for (int i = j; i < bandsignal.Length; i += 4) {  							bandsignal[i] = envelope[i/2] * sine;  						}  					}  					  					var filterband = SpectrogramUtils.padded_FFT(ref bandsignal);    					for (int i = 0; i < filterband.Length; ++i) {  						double x = (double)i/filterband.Length;  						  						// normalized blackman window antiderivative  						filterband[i] *= x - ((0.5/(2.0 * Math.PI)) * Math.Sin(2.0 * Math.PI *x) + (0.08/(4.0 * Math.PI)) * Math.Sin(4.0 * Math.PI *x) / 0.42);  					}    					//Console.Out.WriteLine("Spectrum size: {0}"' spectrum.Length);  					//std::cout << bandidx << ". filterband size: " << filterband.Length << "; start: " << filterbank->GetBand(bandidx).first <<"; end: " << filterbank->GetBand(bandidx).second << "\n";    					double center = filterbank.GetCenter(bandidx);  					double offset = Math.Max((double)0' center - filterband.Length/2);  					  					//Console.Out.WriteLine("Offset: {0} = {1} hz"' offset' offset/filterscale);  					  					for (int i = 0; i < filterband.Length; ++i) {  						int spectrumIndex = (int) (offset + i);  						if (spectrumIndex > 0 && spectrumIndex < spectrum.Length) {  							spectrum[spectrumIndex] += filterband[i];  						}  					}  				}    				double[] @out = SpectrogramUtils.padded_IFFT(ref spectrum);  				  				Console.Out.WriteLine("Samples: {0} -> {1}"' @out.Length' samples);  				  				SpectrogramUtils.NormalizeSignal(ref @out);  				return @out;  			}
Magic Number,ArssSpectrogram,Spectrogram,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\ArssSpectrogram\Spectrogram.cs,SynthetizeSine,The following statement contains a magic number: using (new DebugTimer("Spectrogram: SynthetizeSine(Bitmap)"))  			{  				int samples = image.Width * samplerate/pixpersec;  				var spectrum = new Complex[samples/2+1];    				double filterscale = ((double)spectrum.Length*2)/samplerate;    				Filterbank filterbank = Filterbank.GetFilterbank(frequency_axis' filterscale' basefreq' bandwidth' overlap);    				for (int bandidx = 0; bandidx < image.Height; ++bandidx) {  					// TODO: support cancelling this process    					OutputBandProgress(bandidx' image.Height);    					double[] envelope = EnvelopeFromSpectrogram(image' bandidx);  					// Find maximum number when all numbers are made positive.  					//double max = envelope.Max((b) => Math.Abs(b));  					//Console.WriteLine(max);    					// random phase between +-pi  					double phase = SpectrogramUtils.RandomDoubleMinus1ToPlus1() * Math.PI;    					var bandsignal = new double[envelope.Length*2];  					for (int j = 0; j < 4; ++j) {  						double sine = Math.Cos(j * Math.PI/2 + phase);  						for (int i = j; i < bandsignal.Length; i += 4) {  							bandsignal[i] = envelope[i/2] * sine;  						}  					}  					  					var filterband = SpectrogramUtils.padded_FFT(ref bandsignal);    					for (int i = 0; i < filterband.Length; ++i) {  						double x = (double)i/filterband.Length;  						  						// normalized blackman window antiderivative  						filterband[i] *= x - ((0.5/(2.0 * Math.PI)) * Math.Sin(2.0 * Math.PI *x) + (0.08/(4.0 * Math.PI)) * Math.Sin(4.0 * Math.PI *x) / 0.42);  					}    					//Console.Out.WriteLine("Spectrum size: {0}"' spectrum.Length);  					//std::cout << bandidx << ". filterband size: " << filterband.Length << "; start: " << filterbank->GetBand(bandidx).first <<"; end: " << filterbank->GetBand(bandidx).second << "\n";    					double center = filterbank.GetCenter(bandidx);  					double offset = Math.Max((double)0' center - filterband.Length/2);  					  					//Console.Out.WriteLine("Offset: {0} = {1} hz"' offset' offset/filterscale);  					  					for (int i = 0; i < filterband.Length; ++i) {  						int spectrumIndex = (int) (offset + i);  						if (spectrumIndex > 0 && spectrumIndex < spectrum.Length) {  							spectrum[spectrumIndex] += filterband[i];  						}  					}  				}    				double[] @out = SpectrogramUtils.padded_IFFT(ref spectrum);  				  				Console.Out.WriteLine("Samples: {0} -> {1}"' @out.Length' samples);  				  				SpectrogramUtils.NormalizeSignal(ref @out);  				return @out;  			}
Magic Number,ArssSpectrogram,Spectrogram,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\ArssSpectrogram\Spectrogram.cs,SynthetizeSine,The following statement contains a magic number: using (new DebugTimer("Spectrogram: SynthetizeSine(Bitmap)"))  			{  				int samples = image.Width * samplerate/pixpersec;  				var spectrum = new Complex[samples/2+1];    				double filterscale = ((double)spectrum.Length*2)/samplerate;    				Filterbank filterbank = Filterbank.GetFilterbank(frequency_axis' filterscale' basefreq' bandwidth' overlap);    				for (int bandidx = 0; bandidx < image.Height; ++bandidx) {  					// TODO: support cancelling this process    					OutputBandProgress(bandidx' image.Height);    					double[] envelope = EnvelopeFromSpectrogram(image' bandidx);  					// Find maximum number when all numbers are made positive.  					//double max = envelope.Max((b) => Math.Abs(b));  					//Console.WriteLine(max);    					// random phase between +-pi  					double phase = SpectrogramUtils.RandomDoubleMinus1ToPlus1() * Math.PI;    					var bandsignal = new double[envelope.Length*2];  					for (int j = 0; j < 4; ++j) {  						double sine = Math.Cos(j * Math.PI/2 + phase);  						for (int i = j; i < bandsignal.Length; i += 4) {  							bandsignal[i] = envelope[i/2] * sine;  						}  					}  					  					var filterband = SpectrogramUtils.padded_FFT(ref bandsignal);    					for (int i = 0; i < filterband.Length; ++i) {  						double x = (double)i/filterband.Length;  						  						// normalized blackman window antiderivative  						filterband[i] *= x - ((0.5/(2.0 * Math.PI)) * Math.Sin(2.0 * Math.PI *x) + (0.08/(4.0 * Math.PI)) * Math.Sin(4.0 * Math.PI *x) / 0.42);  					}    					//Console.Out.WriteLine("Spectrum size: {0}"' spectrum.Length);  					//std::cout << bandidx << ". filterband size: " << filterband.Length << "; start: " << filterbank->GetBand(bandidx).first <<"; end: " << filterbank->GetBand(bandidx).second << "\n";    					double center = filterbank.GetCenter(bandidx);  					double offset = Math.Max((double)0' center - filterband.Length/2);  					  					//Console.Out.WriteLine("Offset: {0} = {1} hz"' offset' offset/filterscale);  					  					for (int i = 0; i < filterband.Length; ++i) {  						int spectrumIndex = (int) (offset + i);  						if (spectrumIndex > 0 && spectrumIndex < spectrum.Length) {  							spectrum[spectrumIndex] += filterband[i];  						}  					}  				}    				double[] @out = SpectrogramUtils.padded_IFFT(ref spectrum);  				  				Console.Out.WriteLine("Samples: {0} -> {1}"' @out.Length' samples);  				  				SpectrogramUtils.NormalizeSignal(ref @out);  				return @out;  			}
Magic Number,ArssSpectrogram,Spectrogram,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\ArssSpectrogram\Spectrogram.cs,SynthetizeSine,The following statement contains a magic number: using (new DebugTimer("Spectrogram: SynthetizeSine(Bitmap)"))  			{  				int samples = image.Width * samplerate/pixpersec;  				var spectrum = new Complex[samples/2+1];    				double filterscale = ((double)spectrum.Length*2)/samplerate;    				Filterbank filterbank = Filterbank.GetFilterbank(frequency_axis' filterscale' basefreq' bandwidth' overlap);    				for (int bandidx = 0; bandidx < image.Height; ++bandidx) {  					// TODO: support cancelling this process    					OutputBandProgress(bandidx' image.Height);    					double[] envelope = EnvelopeFromSpectrogram(image' bandidx);  					// Find maximum number when all numbers are made positive.  					//double max = envelope.Max((b) => Math.Abs(b));  					//Console.WriteLine(max);    					// random phase between +-pi  					double phase = SpectrogramUtils.RandomDoubleMinus1ToPlus1() * Math.PI;    					var bandsignal = new double[envelope.Length*2];  					for (int j = 0; j < 4; ++j) {  						double sine = Math.Cos(j * Math.PI/2 + phase);  						for (int i = j; i < bandsignal.Length; i += 4) {  							bandsignal[i] = envelope[i/2] * sine;  						}  					}  					  					var filterband = SpectrogramUtils.padded_FFT(ref bandsignal);    					for (int i = 0; i < filterband.Length; ++i) {  						double x = (double)i/filterband.Length;  						  						// normalized blackman window antiderivative  						filterband[i] *= x - ((0.5/(2.0 * Math.PI)) * Math.Sin(2.0 * Math.PI *x) + (0.08/(4.0 * Math.PI)) * Math.Sin(4.0 * Math.PI *x) / 0.42);  					}    					//Console.Out.WriteLine("Spectrum size: {0}"' spectrum.Length);  					//std::cout << bandidx << ". filterband size: " << filterband.Length << "; start: " << filterbank->GetBand(bandidx).first <<"; end: " << filterbank->GetBand(bandidx).second << "\n";    					double center = filterbank.GetCenter(bandidx);  					double offset = Math.Max((double)0' center - filterband.Length/2);  					  					//Console.Out.WriteLine("Offset: {0} = {1} hz"' offset' offset/filterscale);  					  					for (int i = 0; i < filterband.Length; ++i) {  						int spectrumIndex = (int) (offset + i);  						if (spectrumIndex > 0 && spectrumIndex < spectrum.Length) {  							spectrum[spectrumIndex] += filterband[i];  						}  					}  				}    				double[] @out = SpectrogramUtils.padded_IFFT(ref spectrum);  				  				Console.Out.WriteLine("Samples: {0} -> {1}"' @out.Length' samples);  				  				SpectrogramUtils.NormalizeSignal(ref @out);  				return @out;  			}
Magic Number,ArssSpectrogram,Spectrogram,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\ArssSpectrogram\Spectrogram.cs,SynthetizeSine,The following statement contains a magic number: using (new DebugTimer("Spectrogram: SynthetizeSine(Bitmap)"))  			{  				int samples = image.Width * samplerate/pixpersec;  				var spectrum = new Complex[samples/2+1];    				double filterscale = ((double)spectrum.Length*2)/samplerate;    				Filterbank filterbank = Filterbank.GetFilterbank(frequency_axis' filterscale' basefreq' bandwidth' overlap);    				for (int bandidx = 0; bandidx < image.Height; ++bandidx) {  					// TODO: support cancelling this process    					OutputBandProgress(bandidx' image.Height);    					double[] envelope = EnvelopeFromSpectrogram(image' bandidx);  					// Find maximum number when all numbers are made positive.  					//double max = envelope.Max((b) => Math.Abs(b));  					//Console.WriteLine(max);    					// random phase between +-pi  					double phase = SpectrogramUtils.RandomDoubleMinus1ToPlus1() * Math.PI;    					var bandsignal = new double[envelope.Length*2];  					for (int j = 0; j < 4; ++j) {  						double sine = Math.Cos(j * Math.PI/2 + phase);  						for (int i = j; i < bandsignal.Length; i += 4) {  							bandsignal[i] = envelope[i/2] * sine;  						}  					}  					  					var filterband = SpectrogramUtils.padded_FFT(ref bandsignal);    					for (int i = 0; i < filterband.Length; ++i) {  						double x = (double)i/filterband.Length;  						  						// normalized blackman window antiderivative  						filterband[i] *= x - ((0.5/(2.0 * Math.PI)) * Math.Sin(2.0 * Math.PI *x) + (0.08/(4.0 * Math.PI)) * Math.Sin(4.0 * Math.PI *x) / 0.42);  					}    					//Console.Out.WriteLine("Spectrum size: {0}"' spectrum.Length);  					//std::cout << bandidx << ". filterband size: " << filterband.Length << "; start: " << filterbank->GetBand(bandidx).first <<"; end: " << filterbank->GetBand(bandidx).second << "\n";    					double center = filterbank.GetCenter(bandidx);  					double offset = Math.Max((double)0' center - filterband.Length/2);  					  					//Console.Out.WriteLine("Offset: {0} = {1} hz"' offset' offset/filterscale);  					  					for (int i = 0; i < filterband.Length; ++i) {  						int spectrumIndex = (int) (offset + i);  						if (spectrumIndex > 0 && spectrumIndex < spectrum.Length) {  							spectrum[spectrumIndex] += filterband[i];  						}  					}  				}    				double[] @out = SpectrogramUtils.padded_IFFT(ref spectrum);  				  				Console.Out.WriteLine("Samples: {0} -> {1}"' @out.Length' samples);  				  				SpectrogramUtils.NormalizeSignal(ref @out);  				return @out;  			}
Magic Number,ArssSpectrogram,Spectrogram,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\ArssSpectrogram\Spectrogram.cs,SynthetizeSine,The following statement contains a magic number: using (new DebugTimer("Spectrogram: SynthetizeSine(Bitmap)"))  			{  				int samples = image.Width * samplerate/pixpersec;  				var spectrum = new Complex[samples/2+1];    				double filterscale = ((double)spectrum.Length*2)/samplerate;    				Filterbank filterbank = Filterbank.GetFilterbank(frequency_axis' filterscale' basefreq' bandwidth' overlap);    				for (int bandidx = 0; bandidx < image.Height; ++bandidx) {  					// TODO: support cancelling this process    					OutputBandProgress(bandidx' image.Height);    					double[] envelope = EnvelopeFromSpectrogram(image' bandidx);  					// Find maximum number when all numbers are made positive.  					//double max = envelope.Max((b) => Math.Abs(b));  					//Console.WriteLine(max);    					// random phase between +-pi  					double phase = SpectrogramUtils.RandomDoubleMinus1ToPlus1() * Math.PI;    					var bandsignal = new double[envelope.Length*2];  					for (int j = 0; j < 4; ++j) {  						double sine = Math.Cos(j * Math.PI/2 + phase);  						for (int i = j; i < bandsignal.Length; i += 4) {  							bandsignal[i] = envelope[i/2] * sine;  						}  					}  					  					var filterband = SpectrogramUtils.padded_FFT(ref bandsignal);    					for (int i = 0; i < filterband.Length; ++i) {  						double x = (double)i/filterband.Length;  						  						// normalized blackman window antiderivative  						filterband[i] *= x - ((0.5/(2.0 * Math.PI)) * Math.Sin(2.0 * Math.PI *x) + (0.08/(4.0 * Math.PI)) * Math.Sin(4.0 * Math.PI *x) / 0.42);  					}    					//Console.Out.WriteLine("Spectrum size: {0}"' spectrum.Length);  					//std::cout << bandidx << ". filterband size: " << filterband.Length << "; start: " << filterbank->GetBand(bandidx).first <<"; end: " << filterbank->GetBand(bandidx).second << "\n";    					double center = filterbank.GetCenter(bandidx);  					double offset = Math.Max((double)0' center - filterband.Length/2);  					  					//Console.Out.WriteLine("Offset: {0} = {1} hz"' offset' offset/filterscale);  					  					for (int i = 0; i < filterband.Length; ++i) {  						int spectrumIndex = (int) (offset + i);  						if (spectrumIndex > 0 && spectrumIndex < spectrum.Length) {  							spectrum[spectrumIndex] += filterband[i];  						}  					}  				}    				double[] @out = SpectrogramUtils.padded_IFFT(ref spectrum);  				  				Console.Out.WriteLine("Samples: {0} -> {1}"' @out.Length' samples);  				  				SpectrogramUtils.NormalizeSignal(ref @out);  				return @out;  			}
Magic Number,ArssSpectrogram,Spectrogram,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\ArssSpectrogram\Spectrogram.cs,SynthetizeSine,The following statement contains a magic number: using (new DebugTimer("Spectrogram: SynthetizeSine(Bitmap)"))  			{  				int samples = image.Width * samplerate/pixpersec;  				var spectrum = new Complex[samples/2+1];    				double filterscale = ((double)spectrum.Length*2)/samplerate;    				Filterbank filterbank = Filterbank.GetFilterbank(frequency_axis' filterscale' basefreq' bandwidth' overlap);    				for (int bandidx = 0; bandidx < image.Height; ++bandidx) {  					// TODO: support cancelling this process    					OutputBandProgress(bandidx' image.Height);    					double[] envelope = EnvelopeFromSpectrogram(image' bandidx);  					// Find maximum number when all numbers are made positive.  					//double max = envelope.Max((b) => Math.Abs(b));  					//Console.WriteLine(max);    					// random phase between +-pi  					double phase = SpectrogramUtils.RandomDoubleMinus1ToPlus1() * Math.PI;    					var bandsignal = new double[envelope.Length*2];  					for (int j = 0; j < 4; ++j) {  						double sine = Math.Cos(j * Math.PI/2 + phase);  						for (int i = j; i < bandsignal.Length; i += 4) {  							bandsignal[i] = envelope[i/2] * sine;  						}  					}  					  					var filterband = SpectrogramUtils.padded_FFT(ref bandsignal);    					for (int i = 0; i < filterband.Length; ++i) {  						double x = (double)i/filterband.Length;  						  						// normalized blackman window antiderivative  						filterband[i] *= x - ((0.5/(2.0 * Math.PI)) * Math.Sin(2.0 * Math.PI *x) + (0.08/(4.0 * Math.PI)) * Math.Sin(4.0 * Math.PI *x) / 0.42);  					}    					//Console.Out.WriteLine("Spectrum size: {0}"' spectrum.Length);  					//std::cout << bandidx << ". filterband size: " << filterband.Length << "; start: " << filterbank->GetBand(bandidx).first <<"; end: " << filterbank->GetBand(bandidx).second << "\n";    					double center = filterbank.GetCenter(bandidx);  					double offset = Math.Max((double)0' center - filterband.Length/2);  					  					//Console.Out.WriteLine("Offset: {0} = {1} hz"' offset' offset/filterscale);  					  					for (int i = 0; i < filterband.Length; ++i) {  						int spectrumIndex = (int) (offset + i);  						if (spectrumIndex > 0 && spectrumIndex < spectrum.Length) {  							spectrum[spectrumIndex] += filterband[i];  						}  					}  				}    				double[] @out = SpectrogramUtils.padded_IFFT(ref spectrum);  				  				Console.Out.WriteLine("Samples: {0} -> {1}"' @out.Length' samples);  				  				SpectrogramUtils.NormalizeSignal(ref @out);  				return @out;  			}
Magic Number,ArssSpectrogram,Spectrogram,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\ArssSpectrogram\Spectrogram.cs,SynthetizeSine,The following statement contains a magic number: using (new DebugTimer("Spectrogram: SynthetizeSine(Bitmap)"))  			{  				int samples = image.Width * samplerate/pixpersec;  				var spectrum = new Complex[samples/2+1];    				double filterscale = ((double)spectrum.Length*2)/samplerate;    				Filterbank filterbank = Filterbank.GetFilterbank(frequency_axis' filterscale' basefreq' bandwidth' overlap);    				for (int bandidx = 0; bandidx < image.Height; ++bandidx) {  					// TODO: support cancelling this process    					OutputBandProgress(bandidx' image.Height);    					double[] envelope = EnvelopeFromSpectrogram(image' bandidx);  					// Find maximum number when all numbers are made positive.  					//double max = envelope.Max((b) => Math.Abs(b));  					//Console.WriteLine(max);    					// random phase between +-pi  					double phase = SpectrogramUtils.RandomDoubleMinus1ToPlus1() * Math.PI;    					var bandsignal = new double[envelope.Length*2];  					for (int j = 0; j < 4; ++j) {  						double sine = Math.Cos(j * Math.PI/2 + phase);  						for (int i = j; i < bandsignal.Length; i += 4) {  							bandsignal[i] = envelope[i/2] * sine;  						}  					}  					  					var filterband = SpectrogramUtils.padded_FFT(ref bandsignal);    					for (int i = 0; i < filterband.Length; ++i) {  						double x = (double)i/filterband.Length;  						  						// normalized blackman window antiderivative  						filterband[i] *= x - ((0.5/(2.0 * Math.PI)) * Math.Sin(2.0 * Math.PI *x) + (0.08/(4.0 * Math.PI)) * Math.Sin(4.0 * Math.PI *x) / 0.42);  					}    					//Console.Out.WriteLine("Spectrum size: {0}"' spectrum.Length);  					//std::cout << bandidx << ". filterband size: " << filterband.Length << "; start: " << filterbank->GetBand(bandidx).first <<"; end: " << filterbank->GetBand(bandidx).second << "\n";    					double center = filterbank.GetCenter(bandidx);  					double offset = Math.Max((double)0' center - filterband.Length/2);  					  					//Console.Out.WriteLine("Offset: {0} = {1} hz"' offset' offset/filterscale);  					  					for (int i = 0; i < filterband.Length; ++i) {  						int spectrumIndex = (int) (offset + i);  						if (spectrumIndex > 0 && spectrumIndex < spectrum.Length) {  							spectrum[spectrumIndex] += filterband[i];  						}  					}  				}    				double[] @out = SpectrogramUtils.padded_IFFT(ref spectrum);  				  				Console.Out.WriteLine("Samples: {0} -> {1}"' @out.Length' samples);  				  				SpectrogramUtils.NormalizeSignal(ref @out);  				return @out;  			}
Magic Number,ArssSpectrogram,Spectrogram,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\ArssSpectrogram\Spectrogram.cs,SynthetizeSine,The following statement contains a magic number: using (new DebugTimer("Spectrogram: SynthetizeSine(Bitmap)"))  			{  				int samples = image.Width * samplerate/pixpersec;  				var spectrum = new Complex[samples/2+1];    				double filterscale = ((double)spectrum.Length*2)/samplerate;    				Filterbank filterbank = Filterbank.GetFilterbank(frequency_axis' filterscale' basefreq' bandwidth' overlap);    				for (int bandidx = 0; bandidx < image.Height; ++bandidx) {  					// TODO: support cancelling this process    					OutputBandProgress(bandidx' image.Height);    					double[] envelope = EnvelopeFromSpectrogram(image' bandidx);  					// Find maximum number when all numbers are made positive.  					//double max = envelope.Max((b) => Math.Abs(b));  					//Console.WriteLine(max);    					// random phase between +-pi  					double phase = SpectrogramUtils.RandomDoubleMinus1ToPlus1() * Math.PI;    					var bandsignal = new double[envelope.Length*2];  					for (int j = 0; j < 4; ++j) {  						double sine = Math.Cos(j * Math.PI/2 + phase);  						for (int i = j; i < bandsignal.Length; i += 4) {  							bandsignal[i] = envelope[i/2] * sine;  						}  					}  					  					var filterband = SpectrogramUtils.padded_FFT(ref bandsignal);    					for (int i = 0; i < filterband.Length; ++i) {  						double x = (double)i/filterband.Length;  						  						// normalized blackman window antiderivative  						filterband[i] *= x - ((0.5/(2.0 * Math.PI)) * Math.Sin(2.0 * Math.PI *x) + (0.08/(4.0 * Math.PI)) * Math.Sin(4.0 * Math.PI *x) / 0.42);  					}    					//Console.Out.WriteLine("Spectrum size: {0}"' spectrum.Length);  					//std::cout << bandidx << ". filterband size: " << filterband.Length << "; start: " << filterbank->GetBand(bandidx).first <<"; end: " << filterbank->GetBand(bandidx).second << "\n";    					double center = filterbank.GetCenter(bandidx);  					double offset = Math.Max((double)0' center - filterband.Length/2);  					  					//Console.Out.WriteLine("Offset: {0} = {1} hz"' offset' offset/filterscale);  					  					for (int i = 0; i < filterband.Length; ++i) {  						int spectrumIndex = (int) (offset + i);  						if (spectrumIndex > 0 && spectrumIndex < spectrum.Length) {  							spectrum[spectrumIndex] += filterband[i];  						}  					}  				}    				double[] @out = SpectrogramUtils.padded_IFFT(ref spectrum);  				  				Console.Out.WriteLine("Samples: {0} -> {1}"' @out.Length' samples);  				  				SpectrogramUtils.NormalizeSignal(ref @out);  				return @out;  			}
Magic Number,ArssSpectrogram,Spectrogram,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\ArssSpectrogram\Spectrogram.cs,SynthetizeSine,The following statement contains a magic number: using (new DebugTimer("Spectrogram: SynthetizeSine(Bitmap)"))  			{  				int samples = image.Width * samplerate/pixpersec;  				var spectrum = new Complex[samples/2+1];    				double filterscale = ((double)spectrum.Length*2)/samplerate;    				Filterbank filterbank = Filterbank.GetFilterbank(frequency_axis' filterscale' basefreq' bandwidth' overlap);    				for (int bandidx = 0; bandidx < image.Height; ++bandidx) {  					// TODO: support cancelling this process    					OutputBandProgress(bandidx' image.Height);    					double[] envelope = EnvelopeFromSpectrogram(image' bandidx);  					// Find maximum number when all numbers are made positive.  					//double max = envelope.Max((b) => Math.Abs(b));  					//Console.WriteLine(max);    					// random phase between +-pi  					double phase = SpectrogramUtils.RandomDoubleMinus1ToPlus1() * Math.PI;    					var bandsignal = new double[envelope.Length*2];  					for (int j = 0; j < 4; ++j) {  						double sine = Math.Cos(j * Math.PI/2 + phase);  						for (int i = j; i < bandsignal.Length; i += 4) {  							bandsignal[i] = envelope[i/2] * sine;  						}  					}  					  					var filterband = SpectrogramUtils.padded_FFT(ref bandsignal);    					for (int i = 0; i < filterband.Length; ++i) {  						double x = (double)i/filterband.Length;  						  						// normalized blackman window antiderivative  						filterband[i] *= x - ((0.5/(2.0 * Math.PI)) * Math.Sin(2.0 * Math.PI *x) + (0.08/(4.0 * Math.PI)) * Math.Sin(4.0 * Math.PI *x) / 0.42);  					}    					//Console.Out.WriteLine("Spectrum size: {0}"' spectrum.Length);  					//std::cout << bandidx << ". filterband size: " << filterband.Length << "; start: " << filterbank->GetBand(bandidx).first <<"; end: " << filterbank->GetBand(bandidx).second << "\n";    					double center = filterbank.GetCenter(bandidx);  					double offset = Math.Max((double)0' center - filterband.Length/2);  					  					//Console.Out.WriteLine("Offset: {0} = {1} hz"' offset' offset/filterscale);  					  					for (int i = 0; i < filterband.Length; ++i) {  						int spectrumIndex = (int) (offset + i);  						if (spectrumIndex > 0 && spectrumIndex < spectrum.Length) {  							spectrum[spectrumIndex] += filterband[i];  						}  					}  				}    				double[] @out = SpectrogramUtils.padded_IFFT(ref spectrum);  				  				Console.Out.WriteLine("Samples: {0} -> {1}"' @out.Length' samples);  				  				SpectrogramUtils.NormalizeSignal(ref @out);  				return @out;  			}
Magic Number,ArssSpectrogram,Spectrogram,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\ArssSpectrogram\Spectrogram.cs,SynthetizeSine,The following statement contains a magic number: using (new DebugTimer("Spectrogram: SynthetizeSine(Bitmap)"))  			{  				int samples = image.Width * samplerate/pixpersec;  				var spectrum = new Complex[samples/2+1];    				double filterscale = ((double)spectrum.Length*2)/samplerate;    				Filterbank filterbank = Filterbank.GetFilterbank(frequency_axis' filterscale' basefreq' bandwidth' overlap);    				for (int bandidx = 0; bandidx < image.Height; ++bandidx) {  					// TODO: support cancelling this process    					OutputBandProgress(bandidx' image.Height);    					double[] envelope = EnvelopeFromSpectrogram(image' bandidx);  					// Find maximum number when all numbers are made positive.  					//double max = envelope.Max((b) => Math.Abs(b));  					//Console.WriteLine(max);    					// random phase between +-pi  					double phase = SpectrogramUtils.RandomDoubleMinus1ToPlus1() * Math.PI;    					var bandsignal = new double[envelope.Length*2];  					for (int j = 0; j < 4; ++j) {  						double sine = Math.Cos(j * Math.PI/2 + phase);  						for (int i = j; i < bandsignal.Length; i += 4) {  							bandsignal[i] = envelope[i/2] * sine;  						}  					}  					  					var filterband = SpectrogramUtils.padded_FFT(ref bandsignal);    					for (int i = 0; i < filterband.Length; ++i) {  						double x = (double)i/filterband.Length;  						  						// normalized blackman window antiderivative  						filterband[i] *= x - ((0.5/(2.0 * Math.PI)) * Math.Sin(2.0 * Math.PI *x) + (0.08/(4.0 * Math.PI)) * Math.Sin(4.0 * Math.PI *x) / 0.42);  					}    					//Console.Out.WriteLine("Spectrum size: {0}"' spectrum.Length);  					//std::cout << bandidx << ". filterband size: " << filterband.Length << "; start: " << filterbank->GetBand(bandidx).first <<"; end: " << filterbank->GetBand(bandidx).second << "\n";    					double center = filterbank.GetCenter(bandidx);  					double offset = Math.Max((double)0' center - filterband.Length/2);  					  					//Console.Out.WriteLine("Offset: {0} = {1} hz"' offset' offset/filterscale);  					  					for (int i = 0; i < filterband.Length; ++i) {  						int spectrumIndex = (int) (offset + i);  						if (spectrumIndex > 0 && spectrumIndex < spectrum.Length) {  							spectrum[spectrumIndex] += filterband[i];  						}  					}  				}    				double[] @out = SpectrogramUtils.padded_IFFT(ref spectrum);  				  				Console.Out.WriteLine("Samples: {0} -> {1}"' @out.Length' samples);  				  				SpectrogramUtils.NormalizeSignal(ref @out);  				return @out;  			}
Magic Number,ArssSpectrogram,Spectrogram,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\ArssSpectrogram\Spectrogram.cs,SynthetizeSine,The following statement contains a magic number: using (new DebugTimer("Spectrogram: SynthetizeSine(Bitmap)"))  			{  				int samples = image.Width * samplerate/pixpersec;  				var spectrum = new Complex[samples/2+1];    				double filterscale = ((double)spectrum.Length*2)/samplerate;    				Filterbank filterbank = Filterbank.GetFilterbank(frequency_axis' filterscale' basefreq' bandwidth' overlap);    				for (int bandidx = 0; bandidx < image.Height; ++bandidx) {  					// TODO: support cancelling this process    					OutputBandProgress(bandidx' image.Height);    					double[] envelope = EnvelopeFromSpectrogram(image' bandidx);  					// Find maximum number when all numbers are made positive.  					//double max = envelope.Max((b) => Math.Abs(b));  					//Console.WriteLine(max);    					// random phase between +-pi  					double phase = SpectrogramUtils.RandomDoubleMinus1ToPlus1() * Math.PI;    					var bandsignal = new double[envelope.Length*2];  					for (int j = 0; j < 4; ++j) {  						double sine = Math.Cos(j * Math.PI/2 + phase);  						for (int i = j; i < bandsignal.Length; i += 4) {  							bandsignal[i] = envelope[i/2] * sine;  						}  					}  					  					var filterband = SpectrogramUtils.padded_FFT(ref bandsignal);    					for (int i = 0; i < filterband.Length; ++i) {  						double x = (double)i/filterband.Length;  						  						// normalized blackman window antiderivative  						filterband[i] *= x - ((0.5/(2.0 * Math.PI)) * Math.Sin(2.0 * Math.PI *x) + (0.08/(4.0 * Math.PI)) * Math.Sin(4.0 * Math.PI *x) / 0.42);  					}    					//Console.Out.WriteLine("Spectrum size: {0}"' spectrum.Length);  					//std::cout << bandidx << ". filterband size: " << filterband.Length << "; start: " << filterbank->GetBand(bandidx).first <<"; end: " << filterbank->GetBand(bandidx).second << "\n";    					double center = filterbank.GetCenter(bandidx);  					double offset = Math.Max((double)0' center - filterband.Length/2);  					  					//Console.Out.WriteLine("Offset: {0} = {1} hz"' offset' offset/filterscale);  					  					for (int i = 0; i < filterband.Length; ++i) {  						int spectrumIndex = (int) (offset + i);  						if (spectrumIndex > 0 && spectrumIndex < spectrum.Length) {  							spectrum[spectrumIndex] += filterband[i];  						}  					}  				}    				double[] @out = SpectrogramUtils.padded_IFFT(ref spectrum);  				  				Console.Out.WriteLine("Samples: {0} -> {1}"' @out.Length' samples);  				  				SpectrogramUtils.NormalizeSignal(ref @out);  				return @out;  			}
Magic Number,ArssSpectrogram,Spectrogram,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\ArssSpectrogram\Spectrogram.cs,SynthetizeSine,The following statement contains a magic number: using (new DebugTimer("Spectrogram: SynthetizeSine(Bitmap)"))  			{  				int samples = image.Width * samplerate/pixpersec;  				var spectrum = new Complex[samples/2+1];    				double filterscale = ((double)spectrum.Length*2)/samplerate;    				Filterbank filterbank = Filterbank.GetFilterbank(frequency_axis' filterscale' basefreq' bandwidth' overlap);    				for (int bandidx = 0; bandidx < image.Height; ++bandidx) {  					// TODO: support cancelling this process    					OutputBandProgress(bandidx' image.Height);    					double[] envelope = EnvelopeFromSpectrogram(image' bandidx);  					// Find maximum number when all numbers are made positive.  					//double max = envelope.Max((b) => Math.Abs(b));  					//Console.WriteLine(max);    					// random phase between +-pi  					double phase = SpectrogramUtils.RandomDoubleMinus1ToPlus1() * Math.PI;    					var bandsignal = new double[envelope.Length*2];  					for (int j = 0; j < 4; ++j) {  						double sine = Math.Cos(j * Math.PI/2 + phase);  						for (int i = j; i < bandsignal.Length; i += 4) {  							bandsignal[i] = envelope[i/2] * sine;  						}  					}  					  					var filterband = SpectrogramUtils.padded_FFT(ref bandsignal);    					for (int i = 0; i < filterband.Length; ++i) {  						double x = (double)i/filterband.Length;  						  						// normalized blackman window antiderivative  						filterband[i] *= x - ((0.5/(2.0 * Math.PI)) * Math.Sin(2.0 * Math.PI *x) + (0.08/(4.0 * Math.PI)) * Math.Sin(4.0 * Math.PI *x) / 0.42);  					}    					//Console.Out.WriteLine("Spectrum size: {0}"' spectrum.Length);  					//std::cout << bandidx << ". filterband size: " << filterband.Length << "; start: " << filterbank->GetBand(bandidx).first <<"; end: " << filterbank->GetBand(bandidx).second << "\n";    					double center = filterbank.GetCenter(bandidx);  					double offset = Math.Max((double)0' center - filterband.Length/2);  					  					//Console.Out.WriteLine("Offset: {0} = {1} hz"' offset' offset/filterscale);  					  					for (int i = 0; i < filterband.Length; ++i) {  						int spectrumIndex = (int) (offset + i);  						if (spectrumIndex > 0 && spectrumIndex < spectrum.Length) {  							spectrum[spectrumIndex] += filterband[i];  						}  					}  				}    				double[] @out = SpectrogramUtils.padded_IFFT(ref spectrum);  				  				Console.Out.WriteLine("Samples: {0} -> {1}"' @out.Length' samples);  				  				SpectrogramUtils.NormalizeSignal(ref @out);  				return @out;  			}
Magic Number,ArssSpectrogram,Spectrogram,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\ArssSpectrogram\Spectrogram.cs,SynthetizeSine,The following statement contains a magic number: using (new DebugTimer("Spectrogram: SynthetizeSine(Bitmap)"))  			{  				int samples = image.Width * samplerate/pixpersec;  				var spectrum = new Complex[samples/2+1];    				double filterscale = ((double)spectrum.Length*2)/samplerate;    				Filterbank filterbank = Filterbank.GetFilterbank(frequency_axis' filterscale' basefreq' bandwidth' overlap);    				for (int bandidx = 0; bandidx < image.Height; ++bandidx) {  					// TODO: support cancelling this process    					OutputBandProgress(bandidx' image.Height);    					double[] envelope = EnvelopeFromSpectrogram(image' bandidx);  					// Find maximum number when all numbers are made positive.  					//double max = envelope.Max((b) => Math.Abs(b));  					//Console.WriteLine(max);    					// random phase between +-pi  					double phase = SpectrogramUtils.RandomDoubleMinus1ToPlus1() * Math.PI;    					var bandsignal = new double[envelope.Length*2];  					for (int j = 0; j < 4; ++j) {  						double sine = Math.Cos(j * Math.PI/2 + phase);  						for (int i = j; i < bandsignal.Length; i += 4) {  							bandsignal[i] = envelope[i/2] * sine;  						}  					}  					  					var filterband = SpectrogramUtils.padded_FFT(ref bandsignal);    					for (int i = 0; i < filterband.Length; ++i) {  						double x = (double)i/filterband.Length;  						  						// normalized blackman window antiderivative  						filterband[i] *= x - ((0.5/(2.0 * Math.PI)) * Math.Sin(2.0 * Math.PI *x) + (0.08/(4.0 * Math.PI)) * Math.Sin(4.0 * Math.PI *x) / 0.42);  					}    					//Console.Out.WriteLine("Spectrum size: {0}"' spectrum.Length);  					//std::cout << bandidx << ". filterband size: " << filterband.Length << "; start: " << filterbank->GetBand(bandidx).first <<"; end: " << filterbank->GetBand(bandidx).second << "\n";    					double center = filterbank.GetCenter(bandidx);  					double offset = Math.Max((double)0' center - filterband.Length/2);  					  					//Console.Out.WriteLine("Offset: {0} = {1} hz"' offset' offset/filterscale);  					  					for (int i = 0; i < filterband.Length; ++i) {  						int spectrumIndex = (int) (offset + i);  						if (spectrumIndex > 0 && spectrumIndex < spectrum.Length) {  							spectrum[spectrumIndex] += filterband[i];  						}  					}  				}    				double[] @out = SpectrogramUtils.padded_IFFT(ref spectrum);  				  				Console.Out.WriteLine("Samples: {0} -> {1}"' @out.Length' samples);  				  				SpectrogramUtils.NormalizeSignal(ref @out);  				return @out;  			}
Magic Number,ArssSpectrogram,Spectrogram,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\ArssSpectrogram\Spectrogram.cs,SynthetizeSine,The following statement contains a magic number: using (new DebugTimer("Spectrogram: SynthetizeSine(Bitmap)"))  			{  				int samples = image.Width * samplerate/pixpersec;  				var spectrum = new Complex[samples/2+1];    				double filterscale = ((double)spectrum.Length*2)/samplerate;    				Filterbank filterbank = Filterbank.GetFilterbank(frequency_axis' filterscale' basefreq' bandwidth' overlap);    				for (int bandidx = 0; bandidx < image.Height; ++bandidx) {  					// TODO: support cancelling this process    					OutputBandProgress(bandidx' image.Height);    					double[] envelope = EnvelopeFromSpectrogram(image' bandidx);  					// Find maximum number when all numbers are made positive.  					//double max = envelope.Max((b) => Math.Abs(b));  					//Console.WriteLine(max);    					// random phase between +-pi  					double phase = SpectrogramUtils.RandomDoubleMinus1ToPlus1() * Math.PI;    					var bandsignal = new double[envelope.Length*2];  					for (int j = 0; j < 4; ++j) {  						double sine = Math.Cos(j * Math.PI/2 + phase);  						for (int i = j; i < bandsignal.Length; i += 4) {  							bandsignal[i] = envelope[i/2] * sine;  						}  					}  					  					var filterband = SpectrogramUtils.padded_FFT(ref bandsignal);    					for (int i = 0; i < filterband.Length; ++i) {  						double x = (double)i/filterband.Length;  						  						// normalized blackman window antiderivative  						filterband[i] *= x - ((0.5/(2.0 * Math.PI)) * Math.Sin(2.0 * Math.PI *x) + (0.08/(4.0 * Math.PI)) * Math.Sin(4.0 * Math.PI *x) / 0.42);  					}    					//Console.Out.WriteLine("Spectrum size: {0}"' spectrum.Length);  					//std::cout << bandidx << ". filterband size: " << filterband.Length << "; start: " << filterbank->GetBand(bandidx).first <<"; end: " << filterbank->GetBand(bandidx).second << "\n";    					double center = filterbank.GetCenter(bandidx);  					double offset = Math.Max((double)0' center - filterband.Length/2);  					  					//Console.Out.WriteLine("Offset: {0} = {1} hz"' offset' offset/filterscale);  					  					for (int i = 0; i < filterband.Length; ++i) {  						int spectrumIndex = (int) (offset + i);  						if (spectrumIndex > 0 && spectrumIndex < spectrum.Length) {  							spectrum[spectrumIndex] += filterband[i];  						}  					}  				}    				double[] @out = SpectrogramUtils.padded_IFFT(ref spectrum);  				  				Console.Out.WriteLine("Samples: {0} -> {1}"' @out.Length' samples);  				  				SpectrogramUtils.NormalizeSignal(ref @out);  				return @out;  			}
Magic Number,ArssSpectrogram,Spectrogram,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\ArssSpectrogram\Spectrogram.cs,SynthetizeNoise,The following statement contains a magic number: using (new DebugTimer("Spectrogram: SynthetizeNoise()"))  			{  				int samples = (int) image.Width * samplerate/pixpersec;    				Complex[] noise = SpectrogramUtils.GetPinkNoise(samplerate * 10); // 10 sec loop    				double filterscale = ((double)noise.Length*2)/samplerate;  				Filterbank filterbank = Filterbank.GetFilterbank(frequency_axis' filterscale' basefreq' bandwidth' overlap);    				int top_index = (int) (maxfreq * filterscale);    				var @out = new double[samples];    				for (int bandidx = 0; bandidx < image.Height; ++bandidx) {  					//if (cancelled())  					//	return List<int>();  					OutputBandProgress(bandidx' image.Height-1);    					// filter noise  					Pair<int'int> range = filterbank.GetBand(bandidx);  					//std::cout << bandidx << "/"<<image.height()<<"\n";  					Console.Out.WriteLine("(noise) sample: {0}"' range.Second-range.First);    					var filtered_noise = new Complex[noise.Length];  					// TODO: copy noise into filtered_noise array  					//std.copy(noise.begin()+range.first' noise.begin()+Math.Min(range.second' top_index)' filtered_noise.begin()+range.first);  					  					//apply_window(filtered_noise' range.first' filterscale);  					  					// ifft noise  					double[] noise_mod = SpectrogramUtils.padded_IFFT(ref filtered_noise);  					  					// resample spectrogram band  					double[] envelope = SpectrogramUtils.Resample(EnvelopeFromSpectrogram(image' bandidx)' samples);  					  					// modulate with looped noise  					for (uint i = 0; i < samples; ++i) {  						@out[i] += envelope[i] * noise_mod[i % noise_mod.Length];  					}  				}  				  				SpectrogramUtils.NormalizeSignal(ref @out);  				return @out;  			}
Magic Number,ArssSpectrogram,Spectrogram,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\ArssSpectrogram\Spectrogram.cs,SynthetizeNoise,The following statement contains a magic number: using (new DebugTimer("Spectrogram: SynthetizeNoise()"))  			{  				int samples = (int) image.Width * samplerate/pixpersec;    				Complex[] noise = SpectrogramUtils.GetPinkNoise(samplerate * 10); // 10 sec loop    				double filterscale = ((double)noise.Length*2)/samplerate;  				Filterbank filterbank = Filterbank.GetFilterbank(frequency_axis' filterscale' basefreq' bandwidth' overlap);    				int top_index = (int) (maxfreq * filterscale);    				var @out = new double[samples];    				for (int bandidx = 0; bandidx < image.Height; ++bandidx) {  					//if (cancelled())  					//	return List<int>();  					OutputBandProgress(bandidx' image.Height-1);    					// filter noise  					Pair<int'int> range = filterbank.GetBand(bandidx);  					//std::cout << bandidx << "/"<<image.height()<<"\n";  					Console.Out.WriteLine("(noise) sample: {0}"' range.Second-range.First);    					var filtered_noise = new Complex[noise.Length];  					// TODO: copy noise into filtered_noise array  					//std.copy(noise.begin()+range.first' noise.begin()+Math.Min(range.second' top_index)' filtered_noise.begin()+range.first);  					  					//apply_window(filtered_noise' range.first' filterscale);  					  					// ifft noise  					double[] noise_mod = SpectrogramUtils.padded_IFFT(ref filtered_noise);  					  					// resample spectrogram band  					double[] envelope = SpectrogramUtils.Resample(EnvelopeFromSpectrogram(image' bandidx)' samples);  					  					// modulate with looped noise  					for (uint i = 0; i < samples; ++i) {  						@out[i] += envelope[i] * noise_mod[i % noise_mod.Length];  					}  				}  				  				SpectrogramUtils.NormalizeSignal(ref @out);  				return @out;  			}
Magic Number,ArssSpectrogram,SpectrogramUtils,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\ArssSpectrogram\SpectrogramUtils.cs,padded_FFT,The following statement contains a magic number: int padded = n > 256 ? Util.NextLowPrimes(n) : n;
Magic Number,ArssSpectrogram,SpectrogramUtils,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\ArssSpectrogram\SpectrogramUtils.cs,padded_IFFT,The following statement contains a magic number: int n = (@in.Length - 1) * 2;
Magic Number,ArssSpectrogram,SpectrogramUtils,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\ArssSpectrogram\SpectrogramUtils.cs,padded_IFFT,The following statement contains a magic number: int padded = n > 256 ? Util.NextLowPrimes(n) : n;
Magic Number,ArssSpectrogram,SpectrogramUtils,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\ArssSpectrogram\SpectrogramUtils.cs,padded_IFFT,The following statement contains a magic number: Array.Resize<Complex>(ref @in' padded / 2 + 1);
Magic Number,ArssSpectrogram,SpectrogramUtils,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\ArssSpectrogram\SpectrogramUtils.cs,padded_IFFT,The following statement contains a magic number: Array.Resize<Complex>(ref @in' n / 2 + 1);
Magic Number,ArssSpectrogram,SpectrogramUtils,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\ArssSpectrogram\SpectrogramUtils.cs,Log10Scale,The following statement contains a magic number: return Math.Log10(1 + 9 * val);
Magic Number,ArssSpectrogram,SpectrogramUtils,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\ArssSpectrogram\SpectrogramUtils.cs,Log10ScaleInverse,The following statement contains a magic number: return (Math.Pow(10' val) -1) / 9;
Magic Number,ArssSpectrogram,SpectrogramUtils,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\ArssSpectrogram\SpectrogramUtils.cs,Log10ScaleInverse,The following statement contains a magic number: return (Math.Pow(10' val) -1) / 9;
Magic Number,ArssSpectrogram,SpectrogramUtils,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\ArssSpectrogram\SpectrogramUtils.cs,Cent2Freq,The following statement contains a magic number: return Math.Pow(2' cents / 1200);
Magic Number,ArssSpectrogram,SpectrogramUtils,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\ArssSpectrogram\SpectrogramUtils.cs,Cent2Freq,The following statement contains a magic number: return Math.Pow(2' cents / 1200);
Magic Number,ArssSpectrogram,SpectrogramUtils,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\ArssSpectrogram\SpectrogramUtils.cs,Freq2Cent,The following statement contains a magic number: return Math.Log(freq) / Math.Log(2) * 1200;
Magic Number,ArssSpectrogram,SpectrogramUtils,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\ArssSpectrogram\SpectrogramUtils.cs,Freq2Cent,The following statement contains a magic number: return Math.Log(freq) / Math.Log(2) * 1200;
Magic Number,ArssSpectrogram,SpectrogramUtils,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\ArssSpectrogram\SpectrogramUtils.cs,Cent2Oct,The following statement contains a magic number: return cents / 1200;
Magic Number,ArssSpectrogram,SpectrogramUtils,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\ArssSpectrogram\SpectrogramUtils.cs,Oct2Cent,The following statement contains a magic number: return oct * 1200;
Magic Number,ArssSpectrogram,SpectrogramUtils,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\ArssSpectrogram\SpectrogramUtils.cs,Resample,The following statement contains a magic number: if (ratio >= 256) {  				return Resample(Resample(@in' @in.Length*50)' len);  			} else if (ratio <= 1.0/256) {  				return Resample(Resample(@in' @in.Length/50)' len);  			}
Magic Number,ArssSpectrogram,SpectrogramUtils,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\ArssSpectrogram\SpectrogramUtils.cs,Resample,The following statement contains a magic number: if (ratio >= 256) {  				return Resample(Resample(@in' @in.Length*50)' len);  			} else if (ratio <= 1.0/256) {  				return Resample(Resample(@in' @in.Length/50)' len);  			}
Magic Number,ArssSpectrogram,SpectrogramUtils,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\ArssSpectrogram\SpectrogramUtils.cs,Resample,The following statement contains a magic number: if (ratio >= 256) {  				return Resample(Resample(@in' @in.Length*50)' len);  			} else if (ratio <= 1.0/256) {  				return Resample(Resample(@in' @in.Length/50)' len);  			}
Magic Number,ArssSpectrogram,SpectrogramUtils,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\ArssSpectrogram\SpectrogramUtils.cs,Resample,The following statement contains a magic number: if (ratio >= 256) {  				return Resample(Resample(@in' @in.Length*50)' len);  			} else if (ratio <= 1.0/256) {  				return Resample(Resample(@in' @in.Length/50)' len);  			}
Magic Number,ArssSpectrogram,SpectrogramUtils,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\ArssSpectrogram\SpectrogramUtils.cs,BlackmanWindow,The following statement contains a magic number: return Math.Max(0.42 - 0.5 * Math.Cos(2 * Math.PI * x) + 0.08 * Math.Cos(4 * Math.PI * x)' 0.0);
Magic Number,ArssSpectrogram,SpectrogramUtils,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\ArssSpectrogram\SpectrogramUtils.cs,BlackmanWindow,The following statement contains a magic number: return Math.Max(0.42 - 0.5 * Math.Cos(2 * Math.PI * x) + 0.08 * Math.Cos(4 * Math.PI * x)' 0.0);
Magic Number,ArssSpectrogram,SpectrogramUtils,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\ArssSpectrogram\SpectrogramUtils.cs,BlackmanWindow,The following statement contains a magic number: return Math.Max(0.42 - 0.5 * Math.Cos(2 * Math.PI * x) + 0.08 * Math.Cos(4 * Math.PI * x)' 0.0);
Magic Number,ArssSpectrogram,SpectrogramUtils,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\ArssSpectrogram\SpectrogramUtils.cs,BlackmanWindow,The following statement contains a magic number: return Math.Max(0.42 - 0.5 * Math.Cos(2 * Math.PI * x) + 0.08 * Math.Cos(4 * Math.PI * x)' 0.0);
Magic Number,ArssSpectrogram,SpectrogramUtils,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\ArssSpectrogram\SpectrogramUtils.cs,BlackmanWindow,The following statement contains a magic number: return Math.Max(0.42 - 0.5 * Math.Cos(2 * Math.PI * x) + 0.08 * Math.Cos(4 * Math.PI * x)' 0.0);
Magic Number,ArssSpectrogram,SpectrogramUtils,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\ArssSpectrogram\SpectrogramUtils.cs,HannWindow,The following statement contains a magic number: return 0.5 * (1 - Math.Cos(x * 2 * Math.PI));
Magic Number,ArssSpectrogram,SpectrogramUtils,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\ArssSpectrogram\SpectrogramUtils.cs,HannWindow,The following statement contains a magic number: return 0.5 * (1 - Math.Cos(x * 2 * Math.PI));
Magic Number,ArssSpectrogram,SpectrogramUtils,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\ArssSpectrogram\SpectrogramUtils.cs,TriangularWindow,The following statement contains a magic number: return 1 - Math.Abs( 2 * (x - 0.5));
Magic Number,ArssSpectrogram,SpectrogramUtils,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\ArssSpectrogram\SpectrogramUtils.cs,TriangularWindow,The following statement contains a magic number: return 1 - Math.Abs( 2 * (x - 0.5));
Magic Number,ArssSpectrogram,SpectrogramUtils,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\ArssSpectrogram\SpectrogramUtils.cs,GetPinkNoise,The following statement contains a magic number: for (int i = 0; i < (size+1)/2; ++i)  			{  				double mag = Math.Pow((double) i' -0.5f);  				//double phase = (2 * RandomDouble() -1) * Math.PI; //+-pi random phase  				double phase = RandomDoubleMinus1ToPlus1() * Math.PI; // random phase between -pi and +pi  				var complex = new Complex(mag * Math.Cos(phase)' mag * Math.Sin(phase));  				res[i] = complex;  			}
Missing Default,ARSS,DSP,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\DSP.cs,FFT,The following switch statement is missing a default case: switch(method) {  				case FFTMethod.DFT:  					// fftw_kind.R2HC: input is expected to be real while output is returned in the halfcomplex format  					fftw_plan fft = fftw_plan.r2r_1d(N' complexInput' complexOutput' fftw_kind.R2HC' fftw_flags.Estimate);  					fft.Execute();  					@out = complexOutput.Values;  					  					// free up memory  					fft = null;  					break;  				case FFTMethod.IDFT:  					// fftw_kind.HC2R: input is expected to be halfcomplex format while output is returned as real  					fftw_plan ifft = fftw_plan.r2r_1d(N' complexInput' complexOutput' fftw_kind.HC2R' fftw_flags.Estimate);  					ifft.Execute();  					//@out = complexOutput.ValuesDividedByN; // dividing by N gives the correct scale  					@out = complexOutput.Values;    					// free up memory  					ifft = null;  					break;  				case FFTMethod.DHT:  					fftw_plan dht = fftw_plan.r2r_1d(N' complexInput' complexOutput' fftw_kind.DHT' fftw_flags.Estimate);  					dht.Execute();  					@out = complexOutput.Values;    					// free up memory  					dht = null;  					break;  			}
Missing Default,ArssSpectrogram,Spectrogram,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\ArssSpectrogram\Spectrogram.cs,Synthetize,The following switch statement is missing a default case: switch (type) {  				case SynthesisType.SYNTHESIS_SINE:  					return SynthetizeSine(image' samplerate);  				case SynthesisType.SYNTHESIS_NOISE:  					return SynthetizeNoise(image' samplerate);  			}
Missing Default,ArssSpectrogram,SpectrogramUtils,C:\repos\perivar_AudioVSTToolbox\ARSSCSharp\ArssSpectrogram\SpectrogramUtils.cs,BrightnessCorrection,The following switch statement is missing a default case: switch (correction) {  				case BrightCorrection.BRIGHT_NONE:  					return intensity;  				case BrightCorrection.BRIGHT_SQRT:  					return Math.Sqrt(intensity);  			}
