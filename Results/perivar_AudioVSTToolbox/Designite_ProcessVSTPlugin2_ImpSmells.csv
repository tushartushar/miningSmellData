Implementation smell,Namespace,Class,File,Method,Description
Long Method,ProcessVSTPlugin2,ProcessVSTPlugin,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\ProcessVSTPlugin.cs,ProcessOffline,The method has 106 lines of code.
Complex Method,NAudio.Wave,RecordableMixerStream32,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\NAudio\RecordableMixerStream32.cs,Read,Cyclomatic complexity of the method is 8
Complex Method,ProcessVSTPlugin2,ProcessVSTPlugin,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\ProcessVSTPlugin.cs,ProcessOffline,Cyclomatic complexity of the method is 8
Complex Method,ProcessVSTPlugin2,ProcessVSTPlugin,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\ProcessVSTPlugin.cs,ProcessRealTime,Cyclomatic complexity of the method is 14
Complex Method,ProcessVSTPlugin2,Program,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\Program.cs,Main,Cyclomatic complexity of the method is 11
Long Parameter List,ProcessVSTPlugin2,ProcessVSTPlugin,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\ProcessVSTPlugin.cs,ProcessOffline,The method has 5 parameters. Parameters: waveInputFilePath' waveOutputFilePath' pluginPath' fxpFilePath' volume
Long Parameter List,ProcessVSTPlugin2,ProcessVSTPlugin,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\ProcessVSTPlugin.cs,ProcessRealTime,The method has 5 parameters. Parameters: waveInputFilePath' waveOutputFilePath' pluginPath' fxpFilePath' volume
Long Parameter List,ProcessVSTPlugin2,ProcessVSTPlugin,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\ProcessVSTPlugin.cs,Process,The method has 6 parameters. Parameters: waveInputFilePath' waveOutputFilePath' pluginPath' fxpFilePath' volume' doPlay
Long Statement,CommonUtils.VSTPlugin,UtilityAudio,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\Utility\UtilityAudio.cs,OpenAudio,The length of the statement  "			if (UsedLibrary != AudioLibrary.Null ||(playbackDevice != null && playbackDevice.PlaybackState == PlaybackState.Playing)) return false; " is 135.
Long Statement,CommonUtils.VSTPlugin,UtilityAudio,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\Utility\UtilityAudio.cs,LoadSample,The length of the statement  "					else if (reader.WaveFormat.BitsPerSample == 32 && reader.WaveFormat.Encoding == WaveFormatEncoding.Pcm) Stream = new WaveChannel32To32(reader); " is 143.
Long Statement,CommonUtils.VSTPlugin,VST,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\VST.cs,getPluginInfo,The length of the statement  "				pluginInfo.Add("CanDo: " + VstPluginCanDo.Bypass + PluginContext.PluginCommandStub.CanDo(VstCanDoHelper.ToString(VstPluginCanDo.Bypass)).ToString()); " is 149.
Long Statement,CommonUtils.VSTPlugin,VST,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\VST.cs,getPluginInfo,The length of the statement  "				pluginInfo.Add("CanDo: " + VstPluginCanDo.MidiProgramNames + PluginContext.PluginCommandStub.CanDo(VstCanDoHelper.ToString(VstPluginCanDo.MidiProgramNames)).ToString()); " is 169.
Long Statement,CommonUtils.VSTPlugin,VST,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\VST.cs,getPluginInfo,The length of the statement  "				pluginInfo.Add("CanDo: " + VstPluginCanDo.Offline + PluginContext.PluginCommandStub.CanDo(VstCanDoHelper.ToString(VstPluginCanDo.Offline)).ToString()); " is 151.
Long Statement,CommonUtils.VSTPlugin,VST,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\VST.cs,getPluginInfo,The length of the statement  "				pluginInfo.Add("CanDo: " + VstPluginCanDo.ReceiveVstEvents + PluginContext.PluginCommandStub.CanDo(VstCanDoHelper.ToString(VstPluginCanDo.ReceiveVstEvents)).ToString()); " is 169.
Long Statement,CommonUtils.VSTPlugin,VST,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\VST.cs,getPluginInfo,The length of the statement  "				pluginInfo.Add("CanDo: " + VstPluginCanDo.ReceiveVstMidiEvent + PluginContext.PluginCommandStub.CanDo(VstCanDoHelper.ToString(VstPluginCanDo.ReceiveVstMidiEvent)).ToString()); " is 175.
Long Statement,CommonUtils.VSTPlugin,VST,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\VST.cs,getPluginInfo,The length of the statement  "				pluginInfo.Add("CanDo: " + VstPluginCanDo.ReceiveVstTimeInfo + PluginContext.PluginCommandStub.CanDo(VstCanDoHelper.ToString(VstPluginCanDo.ReceiveVstTimeInfo)).ToString()); " is 173.
Long Statement,CommonUtils.VSTPlugin,VST,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\VST.cs,getPluginInfo,The length of the statement  "				pluginInfo.Add("CanDo: " + VstPluginCanDo.SendVstEvents + PluginContext.PluginCommandStub.CanDo(VstCanDoHelper.ToString(VstPluginCanDo.SendVstEvents)).ToString()); " is 163.
Long Statement,CommonUtils.VSTPlugin,VST,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\VST.cs,getPluginInfo,The length of the statement  "				pluginInfo.Add("CanDo: " + VstPluginCanDo.SendVstMidiEvent + PluginContext.PluginCommandStub.CanDo(VstCanDoHelper.ToString(VstPluginCanDo.SendVstMidiEvent)).ToString()); " is 169.
Long Statement,CommonUtils.VSTPlugin,VST,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\VST.cs,getPluginInfo,The length of the statement  "				pluginInfo.Add("CanDo: " + VstPluginCanDo.ConformsToWindowRules + PluginContext.PluginCommandStub.CanDo(VstCanDoHelper.ToString(VstPluginCanDo.ConformsToWindowRules)).ToString()); " is 179.
Long Statement,CommonUtils.VSTPlugin,VST,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\VST.cs,getPluginInfo,The length of the statement  "				pluginInfo.Add("CanDo: " + VstPluginCanDo.Metapass + PluginContext.PluginCommandStub.CanDo(VstCanDoHelper.ToString(VstPluginCanDo.Metapass)).ToString()); " is 153.
Long Statement,CommonUtils.VSTPlugin,VST,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\VST.cs,getPluginInfo,The length of the statement  "				pluginInfo.Add("CanDo: " + VstPluginCanDo.MixDryWet + PluginContext.PluginCommandStub.CanDo(VstCanDoHelper.ToString(VstPluginCanDo.MixDryWet)).ToString()); " is 155.
Long Statement,CommonUtils.VSTPlugin,VST,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\VST.cs,getPluginInfo,The length of the statement  "				pluginInfo.Add("CanDo: " + VstPluginCanDo.Multipass + PluginContext.PluginCommandStub.CanDo(VstCanDoHelper.ToString(VstPluginCanDo.Multipass)).ToString()); " is 155.
Long Statement,CommonUtils.VSTPlugin,VST,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\VST.cs,getPluginInfo,The length of the statement  "				pluginInfo.Add("CanDo: " + VstPluginCanDo.NoRealTime + PluginContext.PluginCommandStub.CanDo(VstCanDoHelper.ToString(VstPluginCanDo.NoRealTime)).ToString()); " is 157.
Long Statement,CommonUtils.VSTPlugin,VST,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\VST.cs,getPluginInfo,The length of the statement  "				pluginInfo.Add("CanDo: " + VstPluginCanDo.PlugAsChannelInsert + PluginContext.PluginCommandStub.CanDo(VstCanDoHelper.ToString(VstPluginCanDo.PlugAsChannelInsert)).ToString()); " is 175.
Long Statement,CommonUtils.VSTPlugin,VST,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\VST.cs,getPluginInfo,The length of the statement  "				pluginInfo.Add("CanDo: " + VstPluginCanDo.PlugAsSend + PluginContext.PluginCommandStub.CanDo(VstCanDoHelper.ToString(VstPluginCanDo.PlugAsSend)).ToString()); " is 157.
Long Statement,CommonUtils.VSTPlugin,VST,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\VST.cs,getPluginInfo,The length of the statement  "				pluginInfo.Add("CanDo: " + VstPluginCanDo.SendVstTimeInfo + PluginContext.PluginCommandStub.CanDo(VstCanDoHelper.ToString(VstPluginCanDo.SendVstTimeInfo)).ToString()); " is 167.
Long Statement,CommonUtils.VSTPlugin,VST,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\VST.cs,getPluginInfo,The length of the statement  "				pluginInfo.Add("CanDo: " + VstPluginCanDo.x1in1out + PluginContext.PluginCommandStub.CanDo(VstCanDoHelper.ToString(VstPluginCanDo.x1in1out)).ToString()); " is 153.
Long Statement,CommonUtils.VSTPlugin,VST,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\VST.cs,getPluginInfo,The length of the statement  "				pluginInfo.Add("CanDo: " + VstPluginCanDo.x1in2out + PluginContext.PluginCommandStub.CanDo(VstCanDoHelper.ToString(VstPluginCanDo.x1in2out)).ToString()); " is 153.
Long Statement,CommonUtils.VSTPlugin,VST,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\VST.cs,getPluginInfo,The length of the statement  "				pluginInfo.Add("CanDo: " + VstPluginCanDo.x2in1out + PluginContext.PluginCommandStub.CanDo(VstCanDoHelper.ToString(VstPluginCanDo.x2in1out)).ToString()); " is 153.
Long Statement,CommonUtils.VSTPlugin,VST,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\VST.cs,getPluginInfo,The length of the statement  "				pluginInfo.Add("CanDo: " + VstPluginCanDo.x2in2out + PluginContext.PluginCommandStub.CanDo(VstCanDoHelper.ToString(VstPluginCanDo.x2in2out)).ToString()); " is 153.
Long Statement,CommonUtils.VSTPlugin,VST,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\VST.cs,getPluginInfo,The length of the statement  "				pluginInfo.Add("CanDo: " + VstPluginCanDo.x2in4out + PluginContext.PluginCommandStub.CanDo(VstCanDoHelper.ToString(VstPluginCanDo.x2in4out)).ToString()); " is 153.
Long Statement,CommonUtils.VSTPlugin,VST,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\VST.cs,getPluginInfo,The length of the statement  "				pluginInfo.Add("CanDo: " + VstPluginCanDo.x4in2out + PluginContext.PluginCommandStub.CanDo(VstCanDoHelper.ToString(VstPluginCanDo.x4in2out)).ToString()); " is 153.
Long Statement,CommonUtils.VSTPlugin,VST,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\VST.cs,getPluginInfo,The length of the statement  "				pluginInfo.Add("CanDo: " + VstPluginCanDo.x4in4out + PluginContext.PluginCommandStub.CanDo(VstCanDoHelper.ToString(VstPluginCanDo.x4in4out)).ToString()); " is 153.
Long Statement,CommonUtils.VSTPlugin,VST,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\VST.cs,getPluginInfo,The length of the statement  "				pluginInfo.Add("CanDo: " + VstPluginCanDo.x4in8out + PluginContext.PluginCommandStub.CanDo(VstCanDoHelper.ToString(VstPluginCanDo.x4in8out)).ToString()); " is 153.
Long Statement,CommonUtils.VSTPlugin,VST,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\VST.cs,getPluginInfo,The length of the statement  "				pluginInfo.Add("CanDo: " + VstPluginCanDo.x8in4out + PluginContext.PluginCommandStub.CanDo(VstCanDoHelper.ToString(VstPluginCanDo.x8in4out)).ToString()); " is 153.
Long Statement,CommonUtils.VSTPlugin,VST,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\VST.cs,getPluginInfo,The length of the statement  "				pluginInfo.Add("CanDo: " + VstPluginCanDo.x8in8out + PluginContext.PluginCommandStub.CanDo(VstCanDoHelper.ToString(VstPluginCanDo.x8in8out)).ToString()); " is 153.
Long Statement,CommonUtils.VSTPlugin,VST,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\VST.cs,getPluginInfo,The length of the statement  "					pluginInfo.Add(String.Format("Parameter Index: {0} Parameter Name: {1} Display: {2} Label: {3} Can be automated: {4}"' i' name' display' label' canBeAutomated)); " is 161.
Long Statement,NAudio.Wave,RecordableMixerStream32,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\NAudio\RecordableMixerStream32.cs,Read,The length of the statement  "					//System.Diagnostics.Debug.Assert(readFromThisStream == count' "A mixer input stream did not provide the requested amount of data"); " is 132.
Long Statement,NAudio.Wave,RecordableMixerStream32,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\NAudio\RecordableMixerStream32.cs,Read,The length of the statement  "			// If streamToDisk has been enabled the mixed audio will be streamed directly to a wave file' so we need to send the data to the wave file writer " is 145.
Long Statement,NAudio.Wave,WaveChannel24To32,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\NAudio\WaveChannel24To32.cs,MonoToStereo,The length of the statement  "                    int Buffer = (pSourceBuffer[n * 3]) | (pSourceBuffer[(n * 3) + 1] << 8) | (pSourceBuffer[(n * 3) + 2] << 16) + (Add << 24); " is 123.
Long Statement,NAudio.Wave,WaveChannel24To32,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\NAudio\WaveChannel24To32.cs,AdjustVolume,The length of the statement  "                    int leftBuffer = (pSourceBuffer[n * 3]) | (pSourceBuffer[(n * 3) + 1] << 8) | (pSourceBuffer[(n * 3) + 2] << 16) +(lAdd << 24); " is 127.
Long Statement,NAudio.Wave,WaveChannel24To32,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\NAudio\WaveChannel24To32.cs,AdjustVolume,The length of the statement  "                    int rightBuffer = (pSourceBuffer[(n + 1) * 3]) | (pSourceBuffer[(n + 1) * 3 + 1] << 8) | (pSourceBuffer[(n + 1) * 3 + 2] << 16) +(rAdd << 24); " is 142.
Long Statement,NAudio.Wave,WaveChannel32To32,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\NAudio\WaveChannel32To32.cs,AdjustVolume,The length of the statement  "                    int leftBuffer = (pSourceBuffer[n * 4]) | (pSourceBuffer[(n * 4) + 1] << 8) | (pSourceBuffer[(n * 4) + 2] << 16) + (pSourceBuffer[(n * 4) + 3] << 24); " is 150.
Long Statement,NAudio.Wave,WaveChannel32To32,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\NAudio\WaveChannel32To32.cs,AdjustVolume,The length of the statement  "                    int rightBuffer = (pSourceBuffer[(n + 1) * 4]) | (pSourceBuffer[(n + 1) * 4 + 1] << 8) | (pSourceBuffer[(n + 1) * 4 + 2] << 16) + (pSourceBuffer[(n + 1) * 4 + 3] << 24); " is 169.
Long Statement,ProcessVSTPlugin2,ProcessVSTPlugin,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\ProcessVSTPlugin.cs,ProcessRealTime,The length of the statement  "				if(vst.PluginContext.PluginCommandStub.CanDo(VstCanDoHelper.ToString(VstPluginCanDo.NoRealTime)) == VstCanDoResult.Yes) { " is 121.
Magic Number,CommonUtils.VSTPlugin,HostCommandStub,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\HostCommandStub.cs,GetBlockSize,The following statement contains a magic number: return 512;
Magic Number,CommonUtils.VSTPlugin,HostCommandStub,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\HostCommandStub.cs,GetTimeInfo,The following statement contains a magic number: vstTimeInfo.SampleRate = 44100;
Magic Number,CommonUtils.VSTPlugin,HostCommandStub,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\HostCommandStub.cs,GetTimeInfo,The following statement contains a magic number: vstTimeInfo.Tempo = 120.0;
Magic Number,CommonUtils.VSTPlugin,HostCommandStub,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\HostCommandStub.cs,GetTimeInfo,The following statement contains a magic number: vstTimeInfo.TimeSignatureNumerator = 4;
Magic Number,CommonUtils.VSTPlugin,HostCommandStub,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\HostCommandStub.cs,GetTimeInfo,The following statement contains a magic number: vstTimeInfo.TimeSignatureDenominator = 4;
Magic Number,CommonUtils.VSTPlugin,HostCommandStub,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\HostCommandStub.cs,GetVendorVersion,The following statement contains a magic number: return 2400;
Magic Number,CommonUtils.VSTPlugin,HostCommandStub,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\HostCommandStub.cs,GetVersion,The following statement contains a magic number: return 2400;
Magic Number,CommonUtils.VSTPlugin,VSTStream,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\NAudio\VSTStream.cs,ProcessReplace,The following statement contains a magic number: lock (this) {  				if (blockSize != BlockSize) UpdateBlockSize(blockSize);  				  				// check if we are processing a wavestream (VST) or if this is audio outputting only (VSTi)  				if (wavStream != null) {  					if (wavStream.Position == 0) {  						RaisePlayingStarted();  					}  					  					int sampleCount = blockSize*2;  					int sampleCountx4 = sampleCount * 4;  					int loopSize = sampleCount / WaveFormat.Channels;  					  					// Convert byte array into float array and store in Vst Buffers  					// naudio reads an buffer of interlaced float's  					// must take every 4th byte and convert to float  					// Vst.Net audio buffer format (-1 to 1 floats).  					var naudioBuf = new byte[blockSize * WaveFormat.Channels * 4];  					int bytesRead = wavStream.Read(naudioBuf' 0' sampleCountx4);  					  					// populate the inputbuffers with the incoming wave stream  					// TODO: do not use unsafe - but like this http://vstnet.codeplex.com/discussions/246206 ?  					// this whole section is modelled after http://vstnet.codeplex.com/discussions/228692  					unsafe  					{  						fixed (byte* byteBuf = &naudioBuf[0])  						{  							float* floatBuf = (float*)byteBuf;  							int j = 0;  							for (int i = 0; i < loopSize; i++)  							{  								inputBuffers[0][i] = *(floatBuf + j);  								j++;  								inputBuffers[1][i] = *(floatBuf + j);  								j++;  							}  						}  					}  				}  				  				try  				{  					//pluginContext.PluginCommandStub.MainsChanged(true);  					pluginContext.PluginCommandStub.StartProcess();  					pluginContext.PluginCommandStub.ProcessReplacing(inputBuffers' outputBuffers);  					pluginContext.PluginCommandStub.StopProcess();  					//pluginContext.PluginCommandStub.MainsChanged(false);  				}  				catch (Exception ex)  				{  					Console.Out.WriteLine(ex.Message);  				}    				int indexOutput = 0;    				float maxL = float.MinValue;  				float maxR = float.MinValue;    				for (int j = 0; j < BlockSize; j++)  				{  					output[indexOutput] = outputBuffers[0][j];  					output[indexOutput + 1] = outputBuffers[1][j];    					maxL = Math.Max(maxL' output[indexOutput]);  					maxR = Math.Max(maxR' output[indexOutput + 1]);  					indexOutput += 2;  				}    				// try to find when processing input file has reached  				// zero volume level  				float almostZero = 0.0000001f;  				if (maxL < almostZero && maxR < almostZero) {  					//Console.Out.Write("-");  					  					// don't stop until we have x consequetive silence calls after each other  					if (foundSilenceCounter >= 5) {  						if (wavStream != null && wavStream.CurrentTime >= wavStream.TotalTime) {  							RaisePlayingStopped();  						}  					} else {  						foundSilenceCounter++;  					}  				} else {  					foundSilenceCounter = 0;  					//Console.Out.Write(".");  				}  				RaiseProcessCalled(maxL' maxR);  			}
Magic Number,CommonUtils.VSTPlugin,VSTStream,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\NAudio\VSTStream.cs,ProcessReplace,The following statement contains a magic number: lock (this) {  				if (blockSize != BlockSize) UpdateBlockSize(blockSize);  				  				// check if we are processing a wavestream (VST) or if this is audio outputting only (VSTi)  				if (wavStream != null) {  					if (wavStream.Position == 0) {  						RaisePlayingStarted();  					}  					  					int sampleCount = blockSize*2;  					int sampleCountx4 = sampleCount * 4;  					int loopSize = sampleCount / WaveFormat.Channels;  					  					// Convert byte array into float array and store in Vst Buffers  					// naudio reads an buffer of interlaced float's  					// must take every 4th byte and convert to float  					// Vst.Net audio buffer format (-1 to 1 floats).  					var naudioBuf = new byte[blockSize * WaveFormat.Channels * 4];  					int bytesRead = wavStream.Read(naudioBuf' 0' sampleCountx4);  					  					// populate the inputbuffers with the incoming wave stream  					// TODO: do not use unsafe - but like this http://vstnet.codeplex.com/discussions/246206 ?  					// this whole section is modelled after http://vstnet.codeplex.com/discussions/228692  					unsafe  					{  						fixed (byte* byteBuf = &naudioBuf[0])  						{  							float* floatBuf = (float*)byteBuf;  							int j = 0;  							for (int i = 0; i < loopSize; i++)  							{  								inputBuffers[0][i] = *(floatBuf + j);  								j++;  								inputBuffers[1][i] = *(floatBuf + j);  								j++;  							}  						}  					}  				}  				  				try  				{  					//pluginContext.PluginCommandStub.MainsChanged(true);  					pluginContext.PluginCommandStub.StartProcess();  					pluginContext.PluginCommandStub.ProcessReplacing(inputBuffers' outputBuffers);  					pluginContext.PluginCommandStub.StopProcess();  					//pluginContext.PluginCommandStub.MainsChanged(false);  				}  				catch (Exception ex)  				{  					Console.Out.WriteLine(ex.Message);  				}    				int indexOutput = 0;    				float maxL = float.MinValue;  				float maxR = float.MinValue;    				for (int j = 0; j < BlockSize; j++)  				{  					output[indexOutput] = outputBuffers[0][j];  					output[indexOutput + 1] = outputBuffers[1][j];    					maxL = Math.Max(maxL' output[indexOutput]);  					maxR = Math.Max(maxR' output[indexOutput + 1]);  					indexOutput += 2;  				}    				// try to find when processing input file has reached  				// zero volume level  				float almostZero = 0.0000001f;  				if (maxL < almostZero && maxR < almostZero) {  					//Console.Out.Write("-");  					  					// don't stop until we have x consequetive silence calls after each other  					if (foundSilenceCounter >= 5) {  						if (wavStream != null && wavStream.CurrentTime >= wavStream.TotalTime) {  							RaisePlayingStopped();  						}  					} else {  						foundSilenceCounter++;  					}  				} else {  					foundSilenceCounter = 0;  					//Console.Out.Write(".");  				}  				RaiseProcessCalled(maxL' maxR);  			}
Magic Number,CommonUtils.VSTPlugin,VSTStream,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\NAudio\VSTStream.cs,ProcessReplace,The following statement contains a magic number: lock (this) {  				if (blockSize != BlockSize) UpdateBlockSize(blockSize);  				  				// check if we are processing a wavestream (VST) or if this is audio outputting only (VSTi)  				if (wavStream != null) {  					if (wavStream.Position == 0) {  						RaisePlayingStarted();  					}  					  					int sampleCount = blockSize*2;  					int sampleCountx4 = sampleCount * 4;  					int loopSize = sampleCount / WaveFormat.Channels;  					  					// Convert byte array into float array and store in Vst Buffers  					// naudio reads an buffer of interlaced float's  					// must take every 4th byte and convert to float  					// Vst.Net audio buffer format (-1 to 1 floats).  					var naudioBuf = new byte[blockSize * WaveFormat.Channels * 4];  					int bytesRead = wavStream.Read(naudioBuf' 0' sampleCountx4);  					  					// populate the inputbuffers with the incoming wave stream  					// TODO: do not use unsafe - but like this http://vstnet.codeplex.com/discussions/246206 ?  					// this whole section is modelled after http://vstnet.codeplex.com/discussions/228692  					unsafe  					{  						fixed (byte* byteBuf = &naudioBuf[0])  						{  							float* floatBuf = (float*)byteBuf;  							int j = 0;  							for (int i = 0; i < loopSize; i++)  							{  								inputBuffers[0][i] = *(floatBuf + j);  								j++;  								inputBuffers[1][i] = *(floatBuf + j);  								j++;  							}  						}  					}  				}  				  				try  				{  					//pluginContext.PluginCommandStub.MainsChanged(true);  					pluginContext.PluginCommandStub.StartProcess();  					pluginContext.PluginCommandStub.ProcessReplacing(inputBuffers' outputBuffers);  					pluginContext.PluginCommandStub.StopProcess();  					//pluginContext.PluginCommandStub.MainsChanged(false);  				}  				catch (Exception ex)  				{  					Console.Out.WriteLine(ex.Message);  				}    				int indexOutput = 0;    				float maxL = float.MinValue;  				float maxR = float.MinValue;    				for (int j = 0; j < BlockSize; j++)  				{  					output[indexOutput] = outputBuffers[0][j];  					output[indexOutput + 1] = outputBuffers[1][j];    					maxL = Math.Max(maxL' output[indexOutput]);  					maxR = Math.Max(maxR' output[indexOutput + 1]);  					indexOutput += 2;  				}    				// try to find when processing input file has reached  				// zero volume level  				float almostZero = 0.0000001f;  				if (maxL < almostZero && maxR < almostZero) {  					//Console.Out.Write("-");  					  					// don't stop until we have x consequetive silence calls after each other  					if (foundSilenceCounter >= 5) {  						if (wavStream != null && wavStream.CurrentTime >= wavStream.TotalTime) {  							RaisePlayingStopped();  						}  					} else {  						foundSilenceCounter++;  					}  				} else {  					foundSilenceCounter = 0;  					//Console.Out.Write(".");  				}  				RaiseProcessCalled(maxL' maxR);  			}
Magic Number,CommonUtils.VSTPlugin,VSTStream,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\NAudio\VSTStream.cs,ProcessReplace,The following statement contains a magic number: lock (this) {  				if (blockSize != BlockSize) UpdateBlockSize(blockSize);  				  				// check if we are processing a wavestream (VST) or if this is audio outputting only (VSTi)  				if (wavStream != null) {  					if (wavStream.Position == 0) {  						RaisePlayingStarted();  					}  					  					int sampleCount = blockSize*2;  					int sampleCountx4 = sampleCount * 4;  					int loopSize = sampleCount / WaveFormat.Channels;  					  					// Convert byte array into float array and store in Vst Buffers  					// naudio reads an buffer of interlaced float's  					// must take every 4th byte and convert to float  					// Vst.Net audio buffer format (-1 to 1 floats).  					var naudioBuf = new byte[blockSize * WaveFormat.Channels * 4];  					int bytesRead = wavStream.Read(naudioBuf' 0' sampleCountx4);  					  					// populate the inputbuffers with the incoming wave stream  					// TODO: do not use unsafe - but like this http://vstnet.codeplex.com/discussions/246206 ?  					// this whole section is modelled after http://vstnet.codeplex.com/discussions/228692  					unsafe  					{  						fixed (byte* byteBuf = &naudioBuf[0])  						{  							float* floatBuf = (float*)byteBuf;  							int j = 0;  							for (int i = 0; i < loopSize; i++)  							{  								inputBuffers[0][i] = *(floatBuf + j);  								j++;  								inputBuffers[1][i] = *(floatBuf + j);  								j++;  							}  						}  					}  				}  				  				try  				{  					//pluginContext.PluginCommandStub.MainsChanged(true);  					pluginContext.PluginCommandStub.StartProcess();  					pluginContext.PluginCommandStub.ProcessReplacing(inputBuffers' outputBuffers);  					pluginContext.PluginCommandStub.StopProcess();  					//pluginContext.PluginCommandStub.MainsChanged(false);  				}  				catch (Exception ex)  				{  					Console.Out.WriteLine(ex.Message);  				}    				int indexOutput = 0;    				float maxL = float.MinValue;  				float maxR = float.MinValue;    				for (int j = 0; j < BlockSize; j++)  				{  					output[indexOutput] = outputBuffers[0][j];  					output[indexOutput + 1] = outputBuffers[1][j];    					maxL = Math.Max(maxL' output[indexOutput]);  					maxR = Math.Max(maxR' output[indexOutput + 1]);  					indexOutput += 2;  				}    				// try to find when processing input file has reached  				// zero volume level  				float almostZero = 0.0000001f;  				if (maxL < almostZero && maxR < almostZero) {  					//Console.Out.Write("-");  					  					// don't stop until we have x consequetive silence calls after each other  					if (foundSilenceCounter >= 5) {  						if (wavStream != null && wavStream.CurrentTime >= wavStream.TotalTime) {  							RaisePlayingStopped();  						}  					} else {  						foundSilenceCounter++;  					}  				} else {  					foundSilenceCounter = 0;  					//Console.Out.Write(".");  				}  				RaiseProcessCalled(maxL' maxR);  			}
Magic Number,CommonUtils.VSTPlugin,VSTStream,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\NAudio\VSTStream.cs,ProcessReplace,The following statement contains a magic number: lock (this) {  				if (blockSize != BlockSize) UpdateBlockSize(blockSize);  				  				// check if we are processing a wavestream (VST) or if this is audio outputting only (VSTi)  				if (wavStream != null) {  					if (wavStream.Position == 0) {  						RaisePlayingStarted();  					}  					  					int sampleCount = blockSize*2;  					int sampleCountx4 = sampleCount * 4;  					int loopSize = sampleCount / WaveFormat.Channels;  					  					// Convert byte array into float array and store in Vst Buffers  					// naudio reads an buffer of interlaced float's  					// must take every 4th byte and convert to float  					// Vst.Net audio buffer format (-1 to 1 floats).  					var naudioBuf = new byte[blockSize * WaveFormat.Channels * 4];  					int bytesRead = wavStream.Read(naudioBuf' 0' sampleCountx4);  					  					// populate the inputbuffers with the incoming wave stream  					// TODO: do not use unsafe - but like this http://vstnet.codeplex.com/discussions/246206 ?  					// this whole section is modelled after http://vstnet.codeplex.com/discussions/228692  					unsafe  					{  						fixed (byte* byteBuf = &naudioBuf[0])  						{  							float* floatBuf = (float*)byteBuf;  							int j = 0;  							for (int i = 0; i < loopSize; i++)  							{  								inputBuffers[0][i] = *(floatBuf + j);  								j++;  								inputBuffers[1][i] = *(floatBuf + j);  								j++;  							}  						}  					}  				}  				  				try  				{  					//pluginContext.PluginCommandStub.MainsChanged(true);  					pluginContext.PluginCommandStub.StartProcess();  					pluginContext.PluginCommandStub.ProcessReplacing(inputBuffers' outputBuffers);  					pluginContext.PluginCommandStub.StopProcess();  					//pluginContext.PluginCommandStub.MainsChanged(false);  				}  				catch (Exception ex)  				{  					Console.Out.WriteLine(ex.Message);  				}    				int indexOutput = 0;    				float maxL = float.MinValue;  				float maxR = float.MinValue;    				for (int j = 0; j < BlockSize; j++)  				{  					output[indexOutput] = outputBuffers[0][j];  					output[indexOutput + 1] = outputBuffers[1][j];    					maxL = Math.Max(maxL' output[indexOutput]);  					maxR = Math.Max(maxR' output[indexOutput + 1]);  					indexOutput += 2;  				}    				// try to find when processing input file has reached  				// zero volume level  				float almostZero = 0.0000001f;  				if (maxL < almostZero && maxR < almostZero) {  					//Console.Out.Write("-");  					  					// don't stop until we have x consequetive silence calls after each other  					if (foundSilenceCounter >= 5) {  						if (wavStream != null && wavStream.CurrentTime >= wavStream.TotalTime) {  							RaisePlayingStopped();  						}  					} else {  						foundSilenceCounter++;  					}  				} else {  					foundSilenceCounter = 0;  					//Console.Out.Write(".");  				}  				RaiseProcessCalled(maxL' maxR);  			}
Magic Number,CommonUtils.VSTPlugin,VSTStream,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\NAudio\VSTStream.cs,Read,The following statement contains a magic number: float[] tempBuffer = ProcessReplace(sampleCount / 2);
Magic Number,CommonUtils.VSTPlugin,VSTStream,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\NAudio\VSTStream.cs,Read,The following statement contains a magic number: int samplesRequired = count / 4;
Magic Number,CommonUtils.VSTPlugin,VSTStream,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\NAudio\VSTStream.cs,Read,The following statement contains a magic number: int samplesRead = Read(waveBuffer.FloatBuffer' offset / 4' samplesRequired);
Magic Number,CommonUtils.VSTPlugin,VSTStream,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\NAudio\VSTStream.cs,Read,The following statement contains a magic number: return samplesRead * 4;
Magic Number,CommonUtils.VSTPlugin,UtilityAudio,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\Utility\UtilityAudio.cs,LoadSample,The following statement contains a magic number: try  			{  				if (UsedLibrary == AudioLibrary.NAudio)  				{  					//NAUDIO  					var reader = new WaveFileReader(SamplePath);  					WaveStream Stream = null;  					if (reader.WaveFormat.BitsPerSample == 16) Stream = new WaveChannel16To32(reader);  					else if (reader.WaveFormat.BitsPerSample == 24) Stream = new WaveChannel24To32(reader);  					else if (reader.WaveFormat.BitsPerSample == 32 && reader.WaveFormat.Encoding == WaveFormatEncoding.Pcm) Stream = new WaveChannel32To32(reader);  					else if (reader.WaveFormat.BitsPerSample == 32 && reader.WaveFormat.Encoding == WaveFormatEncoding.IeeeFloat) {  						Console.Out.WriteLine("Attention!");  						Stream = new WaveChannel32(new Wave32To16Stream(reader));  					}  					if (Stream != null)  					{  						if (Stream is WaveChannel16To32) ((WaveChannel16To32)Stream).Volume = 0.0f;  						else if (Stream is WaveChannel24To32) ((WaveChannel24To32)Stream).Volume = 0.0f;  						else if (Stream is WaveChannel32To32) ((WaveChannel32To32)Stream).Volume = 0.0f;  						else if (Stream is WaveChannel32) ((WaveChannel32)Stream).Volume = 0.0f;  						Samples.Add(Stream);  						Mixer32.AddInputStream(Stream);  						return Samples.Count - 1;  					}  					//=============================================  				}  			}  			catch (Exception ex)  			{  				Console.Out.WriteLine(ex.Message);  			}
Magic Number,CommonUtils.VSTPlugin,UtilityAudio,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\Utility\UtilityAudio.cs,LoadSample,The following statement contains a magic number: try  			{  				if (UsedLibrary == AudioLibrary.NAudio)  				{  					//NAUDIO  					var reader = new WaveFileReader(SamplePath);  					WaveStream Stream = null;  					if (reader.WaveFormat.BitsPerSample == 16) Stream = new WaveChannel16To32(reader);  					else if (reader.WaveFormat.BitsPerSample == 24) Stream = new WaveChannel24To32(reader);  					else if (reader.WaveFormat.BitsPerSample == 32 && reader.WaveFormat.Encoding == WaveFormatEncoding.Pcm) Stream = new WaveChannel32To32(reader);  					else if (reader.WaveFormat.BitsPerSample == 32 && reader.WaveFormat.Encoding == WaveFormatEncoding.IeeeFloat) {  						Console.Out.WriteLine("Attention!");  						Stream = new WaveChannel32(new Wave32To16Stream(reader));  					}  					if (Stream != null)  					{  						if (Stream is WaveChannel16To32) ((WaveChannel16To32)Stream).Volume = 0.0f;  						else if (Stream is WaveChannel24To32) ((WaveChannel24To32)Stream).Volume = 0.0f;  						else if (Stream is WaveChannel32To32) ((WaveChannel32To32)Stream).Volume = 0.0f;  						else if (Stream is WaveChannel32) ((WaveChannel32)Stream).Volume = 0.0f;  						Samples.Add(Stream);  						Mixer32.AddInputStream(Stream);  						return Samples.Count - 1;  					}  					//=============================================  				}  			}  			catch (Exception ex)  			{  				Console.Out.WriteLine(ex.Message);  			}
Magic Number,CommonUtils.VSTPlugin,UtilityAudio,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\Utility\UtilityAudio.cs,LoadSample,The following statement contains a magic number: try  			{  				if (UsedLibrary == AudioLibrary.NAudio)  				{  					//NAUDIO  					var reader = new WaveFileReader(SamplePath);  					WaveStream Stream = null;  					if (reader.WaveFormat.BitsPerSample == 16) Stream = new WaveChannel16To32(reader);  					else if (reader.WaveFormat.BitsPerSample == 24) Stream = new WaveChannel24To32(reader);  					else if (reader.WaveFormat.BitsPerSample == 32 && reader.WaveFormat.Encoding == WaveFormatEncoding.Pcm) Stream = new WaveChannel32To32(reader);  					else if (reader.WaveFormat.BitsPerSample == 32 && reader.WaveFormat.Encoding == WaveFormatEncoding.IeeeFloat) {  						Console.Out.WriteLine("Attention!");  						Stream = new WaveChannel32(new Wave32To16Stream(reader));  					}  					if (Stream != null)  					{  						if (Stream is WaveChannel16To32) ((WaveChannel16To32)Stream).Volume = 0.0f;  						else if (Stream is WaveChannel24To32) ((WaveChannel24To32)Stream).Volume = 0.0f;  						else if (Stream is WaveChannel32To32) ((WaveChannel32To32)Stream).Volume = 0.0f;  						else if (Stream is WaveChannel32) ((WaveChannel32)Stream).Volume = 0.0f;  						Samples.Add(Stream);  						Mixer32.AddInputStream(Stream);  						return Samples.Count - 1;  					}  					//=============================================  				}  			}  			catch (Exception ex)  			{  				Console.Out.WriteLine(ex.Message);  			}
Magic Number,CommonUtils.VSTPlugin,UtilityAudio,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\Utility\UtilityAudio.cs,LoadSample,The following statement contains a magic number: try  			{  				if (UsedLibrary == AudioLibrary.NAudio)  				{  					//NAUDIO  					var reader = new WaveFileReader(SamplePath);  					WaveStream Stream = null;  					if (reader.WaveFormat.BitsPerSample == 16) Stream = new WaveChannel16To32(reader);  					else if (reader.WaveFormat.BitsPerSample == 24) Stream = new WaveChannel24To32(reader);  					else if (reader.WaveFormat.BitsPerSample == 32 && reader.WaveFormat.Encoding == WaveFormatEncoding.Pcm) Stream = new WaveChannel32To32(reader);  					else if (reader.WaveFormat.BitsPerSample == 32 && reader.WaveFormat.Encoding == WaveFormatEncoding.IeeeFloat) {  						Console.Out.WriteLine("Attention!");  						Stream = new WaveChannel32(new Wave32To16Stream(reader));  					}  					if (Stream != null)  					{  						if (Stream is WaveChannel16To32) ((WaveChannel16To32)Stream).Volume = 0.0f;  						else if (Stream is WaveChannel24To32) ((WaveChannel24To32)Stream).Volume = 0.0f;  						else if (Stream is WaveChannel32To32) ((WaveChannel32To32)Stream).Volume = 0.0f;  						else if (Stream is WaveChannel32) ((WaveChannel32)Stream).Volume = 0.0f;  						Samples.Add(Stream);  						Mixer32.AddInputStream(Stream);  						return Samples.Count - 1;  					}  					//=============================================  				}  			}  			catch (Exception ex)  			{  				Console.Out.WriteLine(ex.Message);  			}
Magic Number,CommonUtils.VSTPlugin,VST,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\VST.cs,MIDI,The following statement contains a magic number: var midiData = new byte[4];
Magic Number,CommonUtils.VSTPlugin,VST,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\VST.cs,MIDI,The following statement contains a magic number: midiData[2] = Val2;
Magic Number,CommonUtils.VSTPlugin,VST,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\VST.cs,MIDI,The following statement contains a magic number: midiData[3] = 0;
Magic Number,CommonUtils.VSTPlugin,VST,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\VST.cs,MIDI,The following statement contains a magic number: var vse = new VstMidiEvent(/*DeltaFrames*/ 0'  			                                    /*NoteLength*/ 0'  			                                    /*NoteOffset*/  0'  			                                    midiData'  			                                    /*Detune*/        0'  			                                    /*NoteOffVelocity*/ 127);
Magic Number,NAudio.Wave,RecordableMixerStream32,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\NAudio\RecordableMixerStream32.cs,RecordableMixerStream32,The following statement contains a magic number: this.bytesPerSample = 4;
Magic Number,NAudio.Wave,RecordableMixerStream32,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\NAudio\RecordableMixerStream32.cs,AddInputStream,The following statement contains a magic number: if (waveStream.WaveFormat.BitsPerSample != 32)  				throw new ArgumentException("Only 32 bit audio currently supported"' "waveStream.WaveFormat");
Magic Number,NAudio.Wave,RecordableMixerStream32,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\NAudio\RecordableMixerStream32.cs,Sum32BitAudio,The following statement contains a magic number: fixed (byte* pDestBuffer = &destBuffer[offset]'  			       pSourceBuffer = &sourceBuffer[0])  			{  				float* pfDestBuffer = (float*)pDestBuffer;  				float* pfReadBuffer = (float*)pSourceBuffer;  				int samplesRead = bytesRead / 4;  				//BlockEffects(samplesRead/2);  				for (int n = 0; n < samplesRead; n+=2)  				{  					pfDestBuffer[n] += pfReadBuffer[n];  					pfDestBuffer[n+1] += pfReadBuffer[n+1];  					//ApplyEffects(ref pfDestBuffer[n]' ref pfDestBuffer[n + 1]);  				}  			}
Magic Number,NAudio.Wave,RecordableMixerStream32,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\NAudio\RecordableMixerStream32.cs,Sum32BitAudio,The following statement contains a magic number: fixed (byte* pDestBuffer = &destBuffer[offset]'  			       pSourceBuffer = &sourceBuffer[0])  			{  				float* pfDestBuffer = (float*)pDestBuffer;  				float* pfReadBuffer = (float*)pSourceBuffer;  				int samplesRead = bytesRead / 4;  				//BlockEffects(samplesRead/2);  				for (int n = 0; n < samplesRead; n+=2)  				{  					pfDestBuffer[n] += pfReadBuffer[n];  					pfDestBuffer[n+1] += pfReadBuffer[n+1];  					//ApplyEffects(ref pfDestBuffer[n]' ref pfDestBuffer[n + 1]);  				}  			}
Magic Number,NAudio.Wave,Wave24To16Stream,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\NAudio\Wave24To16Stream.cs,Wave24To16Stream,The following statement contains a magic number: if (sourceStream.WaveFormat.BitsPerSample != 24)                  throw new ApplicationException("Only 24 bit Floating point supported");
Magic Number,NAudio.Wave,Wave24To16Stream,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\NAudio\Wave24To16Stream.cs,Wave24To16Stream,The following statement contains a magic number: waveFormat = new WaveFormat(sourceStream.WaveFormat.SampleRate' 16' sourceStream.WaveFormat.Channels);
Magic Number,NAudio.Wave,Wave24To16Stream,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\NAudio\Wave24To16Stream.cs,Wave24To16Stream,The following statement contains a magic number: length = sourceStream.Length / 2;
Magic Number,NAudio.Wave,Wave24To16Stream,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\NAudio\Wave24To16Stream.cs,Wave24To16Stream,The following statement contains a magic number: position = sourceStream.Position / 2;
Magic Number,NAudio.Wave,Wave24To16Stream,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\NAudio\Wave24To16Stream.cs,Read,The following statement contains a magic number: byte[] sourceBuffer = new byte[numBytes * 2];
Magic Number,NAudio.Wave,Wave24To16Stream,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\NAudio\Wave24To16Stream.cs,Read,The following statement contains a magic number: int bytesRead = sourceStream.Read(sourceBuffer' 0' numBytes * 2);
Magic Number,NAudio.Wave,Wave24To16Stream,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\NAudio\Wave24To16Stream.cs,Read,The following statement contains a magic number: position += (bytesRead / 2);
Magic Number,NAudio.Wave,Wave24To16Stream,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\NAudio\Wave24To16Stream.cs,Read,The following statement contains a magic number: return bytesRead / 2;
Magic Number,NAudio.Wave,Wave24To16Stream,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\NAudio\Wave24To16Stream.cs,Convert24To16,The following statement contains a magic number: fixed (byte* pDestBuffer = &destBuffer[offset]'                  pSourceBuffer = &sourceBuffer[0])              {                  short* psDestBuffer = (short*)pDestBuffer;                  float* pfSourceBuffer = (float*)pSourceBuffer;                    int samplesRead = bytesRead / 4;                  for (int n = 0; n < samplesRead; n++)                  {                      float sampleVal = pfSourceBuffer[n] * volume;                      if (sampleVal > 1.0f)                      {                          psDestBuffer[n] = short.MaxValue;                          clip = true;                      }                      else if (sampleVal < -1.0f)                      {                          psDestBuffer[n] = short.MinValue;                          clip = true;                      }                      else                      {                          psDestBuffer[n] = (short)(sampleVal * 32767);                      }                  }              }
Magic Number,NAudio.Wave,Wave24To16Stream,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\NAudio\Wave24To16Stream.cs,Convert24To16,The following statement contains a magic number: fixed (byte* pDestBuffer = &destBuffer[offset]'                  pSourceBuffer = &sourceBuffer[0])              {                  short* psDestBuffer = (short*)pDestBuffer;                  float* pfSourceBuffer = (float*)pSourceBuffer;                    int samplesRead = bytesRead / 4;                  for (int n = 0; n < samplesRead; n++)                  {                      float sampleVal = pfSourceBuffer[n] * volume;                      if (sampleVal > 1.0f)                      {                          psDestBuffer[n] = short.MaxValue;                          clip = true;                      }                      else if (sampleVal < -1.0f)                      {                          psDestBuffer[n] = short.MinValue;                          clip = true;                      }                      else                      {                          psDestBuffer[n] = (short)(sampleVal * 32767);                      }                  }              }
Magic Number,NAudio.Wave,WaveChannel16To32,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\NAudio\WaveChannel16To32.cs,WaveChannel16To32,The following statement contains a magic number: if (sourceStream.WaveFormat.BitsPerSample != 16)                  throw new ApplicationException("Only 16 bit audio supported");
Magic Number,NAudio.Wave,WaveChannel16To32,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\NAudio\WaveChannel16To32.cs,WaveChannel16To32,The following statement contains a magic number: waveFormat = WaveFormat.CreateIeeeFloatWaveFormat(sourceStream.WaveFormat.SampleRate' 2);
Magic Number,NAudio.Wave,WaveChannel16To32,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\NAudio\WaveChannel16To32.cs,WaveChannel16To32,The following statement contains a magic number: destBytesPerSample = 8;
Magic Number,NAudio.Wave,WaveChannel16To32,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\NAudio\WaveChannel16To32.cs,WaveChannel16To32,The following statement contains a magic number: sourceBytesPerSample = sourceStream.WaveFormat.Channels * sourceStream.WaveFormat.BitsPerSample / 8;
Magic Number,NAudio.Wave,WaveChannel16To32,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\NAudio\WaveChannel16To32.cs,Read,The following statement contains a magic number: if (bytesWritten < numBytes)              {                  if (sourceStream.WaveFormat.Channels == 1)                  {                      int sourceBytesRequired = (numBytes - bytesWritten) / 4;                      byte[] sourceBuffer = GetSourceBuffer(sourceBytesRequired);                      int read = sourceStream.Read(sourceBuffer' 0' sourceBytesRequired);                      MonoToStereo(destBuffer' offset + bytesWritten' sourceBuffer' read);                      bytesWritten += (read * 4);                  }                  else                  {                      int sourceBytesRequired = (numBytes - bytesWritten) / 2;                      byte[] sourceBuffer = GetSourceBuffer(sourceBytesRequired);                      int read = sourceStream.Read(sourceBuffer' 0' sourceBytesRequired);                      AdjustVolume(destBuffer' offset + bytesWritten' sourceBuffer' read);                      bytesWritten += (read * 2);                  }              }
Magic Number,NAudio.Wave,WaveChannel16To32,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\NAudio\WaveChannel16To32.cs,Read,The following statement contains a magic number: if (bytesWritten < numBytes)              {                  if (sourceStream.WaveFormat.Channels == 1)                  {                      int sourceBytesRequired = (numBytes - bytesWritten) / 4;                      byte[] sourceBuffer = GetSourceBuffer(sourceBytesRequired);                      int read = sourceStream.Read(sourceBuffer' 0' sourceBytesRequired);                      MonoToStereo(destBuffer' offset + bytesWritten' sourceBuffer' read);                      bytesWritten += (read * 4);                  }                  else                  {                      int sourceBytesRequired = (numBytes - bytesWritten) / 2;                      byte[] sourceBuffer = GetSourceBuffer(sourceBytesRequired);                      int read = sourceStream.Read(sourceBuffer' 0' sourceBytesRequired);                      AdjustVolume(destBuffer' offset + bytesWritten' sourceBuffer' read);                      bytesWritten += (read * 2);                  }              }
Magic Number,NAudio.Wave,WaveChannel16To32,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\NAudio\WaveChannel16To32.cs,Read,The following statement contains a magic number: if (bytesWritten < numBytes)              {                  if (sourceStream.WaveFormat.Channels == 1)                  {                      int sourceBytesRequired = (numBytes - bytesWritten) / 4;                      byte[] sourceBuffer = GetSourceBuffer(sourceBytesRequired);                      int read = sourceStream.Read(sourceBuffer' 0' sourceBytesRequired);                      MonoToStereo(destBuffer' offset + bytesWritten' sourceBuffer' read);                      bytesWritten += (read * 4);                  }                  else                  {                      int sourceBytesRequired = (numBytes - bytesWritten) / 2;                      byte[] sourceBuffer = GetSourceBuffer(sourceBytesRequired);                      int read = sourceStream.Read(sourceBuffer' 0' sourceBytesRequired);                      AdjustVolume(destBuffer' offset + bytesWritten' sourceBuffer' read);                      bytesWritten += (read * 2);                  }              }
Magic Number,NAudio.Wave,WaveChannel16To32,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\NAudio\WaveChannel16To32.cs,Read,The following statement contains a magic number: if (bytesWritten < numBytes)              {                  if (sourceStream.WaveFormat.Channels == 1)                  {                      int sourceBytesRequired = (numBytes - bytesWritten) / 4;                      byte[] sourceBuffer = GetSourceBuffer(sourceBytesRequired);                      int read = sourceStream.Read(sourceBuffer' 0' sourceBytesRequired);                      MonoToStereo(destBuffer' offset + bytesWritten' sourceBuffer' read);                      bytesWritten += (read * 4);                  }                  else                  {                      int sourceBytesRequired = (numBytes - bytesWritten) / 2;                      byte[] sourceBuffer = GetSourceBuffer(sourceBytesRequired);                      int read = sourceStream.Read(sourceBuffer' 0' sourceBytesRequired);                      AdjustVolume(destBuffer' offset + bytesWritten' sourceBuffer' read);                      bytesWritten += (read * 2);                  }              }
Magic Number,NAudio.Wave,WaveChannel16To32,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\NAudio\WaveChannel16To32.cs,MonoToStereo,The following statement contains a magic number: fixed (byte* pDestBuffer = &destBuffer[offset]'                  pSourceBuffer = &sourceBuffer[0])              {                  float* pfDestBuffer = (float*)pDestBuffer;                  short* psSourceBuffer = (short*)pSourceBuffer;                    // implement better panning laws.                   float leftVolume = (pan <= 0) ? volume : (volume * (1 - pan) / 2.0f);                  float rightVolume = (pan >= 0) ? volume : (volume * (pan + 1) / 2.0f);                  leftVolume = leftVolume / 32768f;                  rightVolume = rightVolume / 32768f;                  int samplesRead = bytesRead / 2;                  //BlockEffects(samplesRead);                  for (int n = 0; n < samplesRead; n++)                  {                      pfDestBuffer[n * 2] = psSourceBuffer[n] * leftVolume;                      pfDestBuffer[n * 2 + 1] = psSourceBuffer[n] * rightVolume;                      //ApplyEffects(ref pfDestBuffer[n * 2]' ref pfDestBuffer[n * 2 + 1]);                      if (Sample != null) RaiseSample(pfDestBuffer[n * 2]' pfDestBuffer[n * 2 + 1]);                  }              }
Magic Number,NAudio.Wave,WaveChannel16To32,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\NAudio\WaveChannel16To32.cs,MonoToStereo,The following statement contains a magic number: fixed (byte* pDestBuffer = &destBuffer[offset]'                  pSourceBuffer = &sourceBuffer[0])              {                  float* pfDestBuffer = (float*)pDestBuffer;                  short* psSourceBuffer = (short*)pSourceBuffer;                    // implement better panning laws.                   float leftVolume = (pan <= 0) ? volume : (volume * (1 - pan) / 2.0f);                  float rightVolume = (pan >= 0) ? volume : (volume * (pan + 1) / 2.0f);                  leftVolume = leftVolume / 32768f;                  rightVolume = rightVolume / 32768f;                  int samplesRead = bytesRead / 2;                  //BlockEffects(samplesRead);                  for (int n = 0; n < samplesRead; n++)                  {                      pfDestBuffer[n * 2] = psSourceBuffer[n] * leftVolume;                      pfDestBuffer[n * 2 + 1] = psSourceBuffer[n] * rightVolume;                      //ApplyEffects(ref pfDestBuffer[n * 2]' ref pfDestBuffer[n * 2 + 1]);                      if (Sample != null) RaiseSample(pfDestBuffer[n * 2]' pfDestBuffer[n * 2 + 1]);                  }              }
Magic Number,NAudio.Wave,WaveChannel16To32,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\NAudio\WaveChannel16To32.cs,MonoToStereo,The following statement contains a magic number: fixed (byte* pDestBuffer = &destBuffer[offset]'                  pSourceBuffer = &sourceBuffer[0])              {                  float* pfDestBuffer = (float*)pDestBuffer;                  short* psSourceBuffer = (short*)pSourceBuffer;                    // implement better panning laws.                   float leftVolume = (pan <= 0) ? volume : (volume * (1 - pan) / 2.0f);                  float rightVolume = (pan >= 0) ? volume : (volume * (pan + 1) / 2.0f);                  leftVolume = leftVolume / 32768f;                  rightVolume = rightVolume / 32768f;                  int samplesRead = bytesRead / 2;                  //BlockEffects(samplesRead);                  for (int n = 0; n < samplesRead; n++)                  {                      pfDestBuffer[n * 2] = psSourceBuffer[n] * leftVolume;                      pfDestBuffer[n * 2 + 1] = psSourceBuffer[n] * rightVolume;                      //ApplyEffects(ref pfDestBuffer[n * 2]' ref pfDestBuffer[n * 2 + 1]);                      if (Sample != null) RaiseSample(pfDestBuffer[n * 2]' pfDestBuffer[n * 2 + 1]);                  }              }
Magic Number,NAudio.Wave,WaveChannel16To32,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\NAudio\WaveChannel16To32.cs,MonoToStereo,The following statement contains a magic number: fixed (byte* pDestBuffer = &destBuffer[offset]'                  pSourceBuffer = &sourceBuffer[0])              {                  float* pfDestBuffer = (float*)pDestBuffer;                  short* psSourceBuffer = (short*)pSourceBuffer;                    // implement better panning laws.                   float leftVolume = (pan <= 0) ? volume : (volume * (1 - pan) / 2.0f);                  float rightVolume = (pan >= 0) ? volume : (volume * (pan + 1) / 2.0f);                  leftVolume = leftVolume / 32768f;                  rightVolume = rightVolume / 32768f;                  int samplesRead = bytesRead / 2;                  //BlockEffects(samplesRead);                  for (int n = 0; n < samplesRead; n++)                  {                      pfDestBuffer[n * 2] = psSourceBuffer[n] * leftVolume;                      pfDestBuffer[n * 2 + 1] = psSourceBuffer[n] * rightVolume;                      //ApplyEffects(ref pfDestBuffer[n * 2]' ref pfDestBuffer[n * 2 + 1]);                      if (Sample != null) RaiseSample(pfDestBuffer[n * 2]' pfDestBuffer[n * 2 + 1]);                  }              }
Magic Number,NAudio.Wave,WaveChannel16To32,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\NAudio\WaveChannel16To32.cs,MonoToStereo,The following statement contains a magic number: fixed (byte* pDestBuffer = &destBuffer[offset]'                  pSourceBuffer = &sourceBuffer[0])              {                  float* pfDestBuffer = (float*)pDestBuffer;                  short* psSourceBuffer = (short*)pSourceBuffer;                    // implement better panning laws.                   float leftVolume = (pan <= 0) ? volume : (volume * (1 - pan) / 2.0f);                  float rightVolume = (pan >= 0) ? volume : (volume * (pan + 1) / 2.0f);                  leftVolume = leftVolume / 32768f;                  rightVolume = rightVolume / 32768f;                  int samplesRead = bytesRead / 2;                  //BlockEffects(samplesRead);                  for (int n = 0; n < samplesRead; n++)                  {                      pfDestBuffer[n * 2] = psSourceBuffer[n] * leftVolume;                      pfDestBuffer[n * 2 + 1] = psSourceBuffer[n] * rightVolume;                      //ApplyEffects(ref pfDestBuffer[n * 2]' ref pfDestBuffer[n * 2 + 1]);                      if (Sample != null) RaiseSample(pfDestBuffer[n * 2]' pfDestBuffer[n * 2 + 1]);                  }              }
Magic Number,NAudio.Wave,WaveChannel16To32,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\NAudio\WaveChannel16To32.cs,AdjustVolume,The following statement contains a magic number: fixed (byte* pDestBuffer = &destBuffer[offset]'                  pSourceBuffer = &sourceBuffer[0])              {                  float* pfDestBuffer = (float*)pDestBuffer;                  short* psSourceBuffer = (short*)pSourceBuffer;                    // implement better panning laws.                   float leftVolume = (pan <= 0) ? volume : (volume * (1 - pan) / 2.0f);                  float rightVolume = (pan >= 0) ? volume : (volume * (pan + 1) / 2.0f);                    leftVolume = leftVolume / 32768f;                  rightVolume = rightVolume / 32768f;                  //float leftVolume = (volume * (1 - pan) / 2.0f) / 32768f;                  //float rightVolume = (volume * (pan + 1) / 2.0f) / 32768f;                    int samplesRead = bytesRead / 2;                  //BlockEffects(samplesRead / 2);                  for (int n = 0; n < samplesRead; n += 2)                  {                      pfDestBuffer[n] = psSourceBuffer[n] * leftVolume;                      pfDestBuffer[n + 1] = psSourceBuffer[n + 1] * rightVolume;                      //ApplyEffects(ref pfDestBuffer[n]' ref pfDestBuffer[n + 1]);                      if (Sample != null) RaiseSample(pfDestBuffer[n]' pfDestBuffer[n + 1]);                  }              }
Magic Number,NAudio.Wave,WaveChannel16To32,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\NAudio\WaveChannel16To32.cs,AdjustVolume,The following statement contains a magic number: fixed (byte* pDestBuffer = &destBuffer[offset]'                  pSourceBuffer = &sourceBuffer[0])              {                  float* pfDestBuffer = (float*)pDestBuffer;                  short* psSourceBuffer = (short*)pSourceBuffer;                    // implement better panning laws.                   float leftVolume = (pan <= 0) ? volume : (volume * (1 - pan) / 2.0f);                  float rightVolume = (pan >= 0) ? volume : (volume * (pan + 1) / 2.0f);                    leftVolume = leftVolume / 32768f;                  rightVolume = rightVolume / 32768f;                  //float leftVolume = (volume * (1 - pan) / 2.0f) / 32768f;                  //float rightVolume = (volume * (pan + 1) / 2.0f) / 32768f;                    int samplesRead = bytesRead / 2;                  //BlockEffects(samplesRead / 2);                  for (int n = 0; n < samplesRead; n += 2)                  {                      pfDestBuffer[n] = psSourceBuffer[n] * leftVolume;                      pfDestBuffer[n + 1] = psSourceBuffer[n + 1] * rightVolume;                      //ApplyEffects(ref pfDestBuffer[n]' ref pfDestBuffer[n + 1]);                      if (Sample != null) RaiseSample(pfDestBuffer[n]' pfDestBuffer[n + 1]);                  }              }
Magic Number,NAudio.Wave,WaveChannel24To32,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\NAudio\WaveChannel24To32.cs,WaveChannel24To32,The following statement contains a magic number: if (sourceStream.WaveFormat.BitsPerSample != 24)                  throw new ApplicationException("Only 24 bit audio supported");
Magic Number,NAudio.Wave,WaveChannel24To32,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\NAudio\WaveChannel24To32.cs,WaveChannel24To32,The following statement contains a magic number: waveFormat = WaveFormat.CreateIeeeFloatWaveFormat(sourceStream.WaveFormat.SampleRate' 2);
Magic Number,NAudio.Wave,WaveChannel24To32,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\NAudio\WaveChannel24To32.cs,WaveChannel24To32,The following statement contains a magic number: destBytesPerSample = 8;
Magic Number,NAudio.Wave,WaveChannel24To32,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\NAudio\WaveChannel24To32.cs,WaveChannel24To32,The following statement contains a magic number: sourceBytesPerSample = sourceStream.WaveFormat.Channels * sourceStream.WaveFormat.BitsPerSample / 8;
Magic Number,NAudio.Wave,WaveChannel24To32,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\NAudio\WaveChannel24To32.cs,Read,The following statement contains a magic number: if (bytesWritten < numBytes)              {                  if (sourceStream.WaveFormat.Channels == 1)                  {                      int sourceBytesRequired = (numBytes - bytesWritten)*3 / 8;                      byte[] sourceBuffer = GetSourceBuffer(sourceBytesRequired);                      int read = sourceStream.Read(sourceBuffer' 0' sourceBytesRequired);                      MonoToStereo(destBuffer' offset + bytesWritten' sourceBuffer' read);                      bytesWritten += ((read * 8)/3);                  }                  else                  {                      int sourceBytesRequired = ((numBytes - bytesWritten) * 3) / 4;                      byte[] sourceBuffer = GetSourceBuffer(sourceBytesRequired);                      int read = sourceStream.Read(sourceBuffer' 0' sourceBytesRequired);                      AdjustVolume(destBuffer' offset + bytesWritten' sourceBuffer' read);                      bytesWritten += ((read * 4) / 3);                  }              }
Magic Number,NAudio.Wave,WaveChannel24To32,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\NAudio\WaveChannel24To32.cs,Read,The following statement contains a magic number: if (bytesWritten < numBytes)              {                  if (sourceStream.WaveFormat.Channels == 1)                  {                      int sourceBytesRequired = (numBytes - bytesWritten)*3 / 8;                      byte[] sourceBuffer = GetSourceBuffer(sourceBytesRequired);                      int read = sourceStream.Read(sourceBuffer' 0' sourceBytesRequired);                      MonoToStereo(destBuffer' offset + bytesWritten' sourceBuffer' read);                      bytesWritten += ((read * 8)/3);                  }                  else                  {                      int sourceBytesRequired = ((numBytes - bytesWritten) * 3) / 4;                      byte[] sourceBuffer = GetSourceBuffer(sourceBytesRequired);                      int read = sourceStream.Read(sourceBuffer' 0' sourceBytesRequired);                      AdjustVolume(destBuffer' offset + bytesWritten' sourceBuffer' read);                      bytesWritten += ((read * 4) / 3);                  }              }
Magic Number,NAudio.Wave,WaveChannel24To32,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\NAudio\WaveChannel24To32.cs,Read,The following statement contains a magic number: if (bytesWritten < numBytes)              {                  if (sourceStream.WaveFormat.Channels == 1)                  {                      int sourceBytesRequired = (numBytes - bytesWritten)*3 / 8;                      byte[] sourceBuffer = GetSourceBuffer(sourceBytesRequired);                      int read = sourceStream.Read(sourceBuffer' 0' sourceBytesRequired);                      MonoToStereo(destBuffer' offset + bytesWritten' sourceBuffer' read);                      bytesWritten += ((read * 8)/3);                  }                  else                  {                      int sourceBytesRequired = ((numBytes - bytesWritten) * 3) / 4;                      byte[] sourceBuffer = GetSourceBuffer(sourceBytesRequired);                      int read = sourceStream.Read(sourceBuffer' 0' sourceBytesRequired);                      AdjustVolume(destBuffer' offset + bytesWritten' sourceBuffer' read);                      bytesWritten += ((read * 4) / 3);                  }              }
Magic Number,NAudio.Wave,WaveChannel24To32,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\NAudio\WaveChannel24To32.cs,Read,The following statement contains a magic number: if (bytesWritten < numBytes)              {                  if (sourceStream.WaveFormat.Channels == 1)                  {                      int sourceBytesRequired = (numBytes - bytesWritten)*3 / 8;                      byte[] sourceBuffer = GetSourceBuffer(sourceBytesRequired);                      int read = sourceStream.Read(sourceBuffer' 0' sourceBytesRequired);                      MonoToStereo(destBuffer' offset + bytesWritten' sourceBuffer' read);                      bytesWritten += ((read * 8)/3);                  }                  else                  {                      int sourceBytesRequired = ((numBytes - bytesWritten) * 3) / 4;                      byte[] sourceBuffer = GetSourceBuffer(sourceBytesRequired);                      int read = sourceStream.Read(sourceBuffer' 0' sourceBytesRequired);                      AdjustVolume(destBuffer' offset + bytesWritten' sourceBuffer' read);                      bytesWritten += ((read * 4) / 3);                  }              }
Magic Number,NAudio.Wave,WaveChannel24To32,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\NAudio\WaveChannel24To32.cs,Read,The following statement contains a magic number: if (bytesWritten < numBytes)              {                  if (sourceStream.WaveFormat.Channels == 1)                  {                      int sourceBytesRequired = (numBytes - bytesWritten)*3 / 8;                      byte[] sourceBuffer = GetSourceBuffer(sourceBytesRequired);                      int read = sourceStream.Read(sourceBuffer' 0' sourceBytesRequired);                      MonoToStereo(destBuffer' offset + bytesWritten' sourceBuffer' read);                      bytesWritten += ((read * 8)/3);                  }                  else                  {                      int sourceBytesRequired = ((numBytes - bytesWritten) * 3) / 4;                      byte[] sourceBuffer = GetSourceBuffer(sourceBytesRequired);                      int read = sourceStream.Read(sourceBuffer' 0' sourceBytesRequired);                      AdjustVolume(destBuffer' offset + bytesWritten' sourceBuffer' read);                      bytesWritten += ((read * 4) / 3);                  }              }
Magic Number,NAudio.Wave,WaveChannel24To32,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\NAudio\WaveChannel24To32.cs,Read,The following statement contains a magic number: if (bytesWritten < numBytes)              {                  if (sourceStream.WaveFormat.Channels == 1)                  {                      int sourceBytesRequired = (numBytes - bytesWritten)*3 / 8;                      byte[] sourceBuffer = GetSourceBuffer(sourceBytesRequired);                      int read = sourceStream.Read(sourceBuffer' 0' sourceBytesRequired);                      MonoToStereo(destBuffer' offset + bytesWritten' sourceBuffer' read);                      bytesWritten += ((read * 8)/3);                  }                  else                  {                      int sourceBytesRequired = ((numBytes - bytesWritten) * 3) / 4;                      byte[] sourceBuffer = GetSourceBuffer(sourceBytesRequired);                      int read = sourceStream.Read(sourceBuffer' 0' sourceBytesRequired);                      AdjustVolume(destBuffer' offset + bytesWritten' sourceBuffer' read);                      bytesWritten += ((read * 4) / 3);                  }              }
Magic Number,NAudio.Wave,WaveChannel24To32,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\NAudio\WaveChannel24To32.cs,Read,The following statement contains a magic number: if (bytesWritten < numBytes)              {                  if (sourceStream.WaveFormat.Channels == 1)                  {                      int sourceBytesRequired = (numBytes - bytesWritten)*3 / 8;                      byte[] sourceBuffer = GetSourceBuffer(sourceBytesRequired);                      int read = sourceStream.Read(sourceBuffer' 0' sourceBytesRequired);                      MonoToStereo(destBuffer' offset + bytesWritten' sourceBuffer' read);                      bytesWritten += ((read * 8)/3);                  }                  else                  {                      int sourceBytesRequired = ((numBytes - bytesWritten) * 3) / 4;                      byte[] sourceBuffer = GetSourceBuffer(sourceBytesRequired);                      int read = sourceStream.Read(sourceBuffer' 0' sourceBytesRequired);                      AdjustVolume(destBuffer' offset + bytesWritten' sourceBuffer' read);                      bytesWritten += ((read * 4) / 3);                  }              }
Magic Number,NAudio.Wave,WaveChannel24To32,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\NAudio\WaveChannel24To32.cs,Read,The following statement contains a magic number: if (bytesWritten < numBytes)              {                  if (sourceStream.WaveFormat.Channels == 1)                  {                      int sourceBytesRequired = (numBytes - bytesWritten)*3 / 8;                      byte[] sourceBuffer = GetSourceBuffer(sourceBytesRequired);                      int read = sourceStream.Read(sourceBuffer' 0' sourceBytesRequired);                      MonoToStereo(destBuffer' offset + bytesWritten' sourceBuffer' read);                      bytesWritten += ((read * 8)/3);                  }                  else                  {                      int sourceBytesRequired = ((numBytes - bytesWritten) * 3) / 4;                      byte[] sourceBuffer = GetSourceBuffer(sourceBytesRequired);                      int read = sourceStream.Read(sourceBuffer' 0' sourceBytesRequired);                      AdjustVolume(destBuffer' offset + bytesWritten' sourceBuffer' read);                      bytesWritten += ((read * 4) / 3);                  }              }
Magic Number,NAudio.Wave,WaveChannel24To32,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\NAudio\WaveChannel24To32.cs,MonoToStereo,The following statement contains a magic number: fixed (byte* pDestBuffer = &destBuffer[offset]'                  pSourceBuffer = &sourceBuffer[0])              {                  float* pfDestBuffer = (float*)pDestBuffer;                  short* psSourceBuffer = (short*)pSourceBuffer;                    // implement better panning laws.                   float leftVolume = (pan <= 0) ? volume : (volume * (1 - pan) / 2.0f);                  float rightVolume = (pan >= 0) ? volume : (volume * (pan + 1) / 2.0f);                  leftVolume = leftVolume / (float)0xffffff;                  rightVolume = rightVolume / (float)0xffffff;                  int samplesRead = bytesRead / 3;                  //BlockEffects(samplesRead);                  for (int n = 0; n < samplesRead; n++)                  {                      int Add = pSourceBuffer[(n * 3) + 2] > 0x7f ? 0xff : 0x00;                      int Buffer = (pSourceBuffer[n * 3]) | (pSourceBuffer[(n * 3) + 1] << 8) | (pSourceBuffer[(n * 3) + 2] << 16) + (Add << 24);                      pfDestBuffer[n*2] = Buffer * leftVolume;                      pfDestBuffer[n*2 + 1] = Buffer * rightVolume;                      //ApplyEffects(ref pfDestBuffer[n * 2]'ref pfDestBuffer[n * 2 + 1]);                      if (Sample != null) RaiseSample(pfDestBuffer[n*2]' pfDestBuffer[n*2 + 1]);                  }              }
Magic Number,NAudio.Wave,WaveChannel24To32,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\NAudio\WaveChannel24To32.cs,MonoToStereo,The following statement contains a magic number: fixed (byte* pDestBuffer = &destBuffer[offset]'                  pSourceBuffer = &sourceBuffer[0])              {                  float* pfDestBuffer = (float*)pDestBuffer;                  short* psSourceBuffer = (short*)pSourceBuffer;                    // implement better panning laws.                   float leftVolume = (pan <= 0) ? volume : (volume * (1 - pan) / 2.0f);                  float rightVolume = (pan >= 0) ? volume : (volume * (pan + 1) / 2.0f);                  leftVolume = leftVolume / (float)0xffffff;                  rightVolume = rightVolume / (float)0xffffff;                  int samplesRead = bytesRead / 3;                  //BlockEffects(samplesRead);                  for (int n = 0; n < samplesRead; n++)                  {                      int Add = pSourceBuffer[(n * 3) + 2] > 0x7f ? 0xff : 0x00;                      int Buffer = (pSourceBuffer[n * 3]) | (pSourceBuffer[(n * 3) + 1] << 8) | (pSourceBuffer[(n * 3) + 2] << 16) + (Add << 24);                      pfDestBuffer[n*2] = Buffer * leftVolume;                      pfDestBuffer[n*2 + 1] = Buffer * rightVolume;                      //ApplyEffects(ref pfDestBuffer[n * 2]'ref pfDestBuffer[n * 2 + 1]);                      if (Sample != null) RaiseSample(pfDestBuffer[n*2]' pfDestBuffer[n*2 + 1]);                  }              }
Magic Number,NAudio.Wave,WaveChannel24To32,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\NAudio\WaveChannel24To32.cs,MonoToStereo,The following statement contains a magic number: fixed (byte* pDestBuffer = &destBuffer[offset]'                  pSourceBuffer = &sourceBuffer[0])              {                  float* pfDestBuffer = (float*)pDestBuffer;                  short* psSourceBuffer = (short*)pSourceBuffer;                    // implement better panning laws.                   float leftVolume = (pan <= 0) ? volume : (volume * (1 - pan) / 2.0f);                  float rightVolume = (pan >= 0) ? volume : (volume * (pan + 1) / 2.0f);                  leftVolume = leftVolume / (float)0xffffff;                  rightVolume = rightVolume / (float)0xffffff;                  int samplesRead = bytesRead / 3;                  //BlockEffects(samplesRead);                  for (int n = 0; n < samplesRead; n++)                  {                      int Add = pSourceBuffer[(n * 3) + 2] > 0x7f ? 0xff : 0x00;                      int Buffer = (pSourceBuffer[n * 3]) | (pSourceBuffer[(n * 3) + 1] << 8) | (pSourceBuffer[(n * 3) + 2] << 16) + (Add << 24);                      pfDestBuffer[n*2] = Buffer * leftVolume;                      pfDestBuffer[n*2 + 1] = Buffer * rightVolume;                      //ApplyEffects(ref pfDestBuffer[n * 2]'ref pfDestBuffer[n * 2 + 1]);                      if (Sample != null) RaiseSample(pfDestBuffer[n*2]' pfDestBuffer[n*2 + 1]);                  }              }
Magic Number,NAudio.Wave,WaveChannel24To32,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\NAudio\WaveChannel24To32.cs,MonoToStereo,The following statement contains a magic number: fixed (byte* pDestBuffer = &destBuffer[offset]'                  pSourceBuffer = &sourceBuffer[0])              {                  float* pfDestBuffer = (float*)pDestBuffer;                  short* psSourceBuffer = (short*)pSourceBuffer;                    // implement better panning laws.                   float leftVolume = (pan <= 0) ? volume : (volume * (1 - pan) / 2.0f);                  float rightVolume = (pan >= 0) ? volume : (volume * (pan + 1) / 2.0f);                  leftVolume = leftVolume / (float)0xffffff;                  rightVolume = rightVolume / (float)0xffffff;                  int samplesRead = bytesRead / 3;                  //BlockEffects(samplesRead);                  for (int n = 0; n < samplesRead; n++)                  {                      int Add = pSourceBuffer[(n * 3) + 2] > 0x7f ? 0xff : 0x00;                      int Buffer = (pSourceBuffer[n * 3]) | (pSourceBuffer[(n * 3) + 1] << 8) | (pSourceBuffer[(n * 3) + 2] << 16) + (Add << 24);                      pfDestBuffer[n*2] = Buffer * leftVolume;                      pfDestBuffer[n*2 + 1] = Buffer * rightVolume;                      //ApplyEffects(ref pfDestBuffer[n * 2]'ref pfDestBuffer[n * 2 + 1]);                      if (Sample != null) RaiseSample(pfDestBuffer[n*2]' pfDestBuffer[n*2 + 1]);                  }              }
Magic Number,NAudio.Wave,WaveChannel24To32,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\NAudio\WaveChannel24To32.cs,MonoToStereo,The following statement contains a magic number: fixed (byte* pDestBuffer = &destBuffer[offset]'                  pSourceBuffer = &sourceBuffer[0])              {                  float* pfDestBuffer = (float*)pDestBuffer;                  short* psSourceBuffer = (short*)pSourceBuffer;                    // implement better panning laws.                   float leftVolume = (pan <= 0) ? volume : (volume * (1 - pan) / 2.0f);                  float rightVolume = (pan >= 0) ? volume : (volume * (pan + 1) / 2.0f);                  leftVolume = leftVolume / (float)0xffffff;                  rightVolume = rightVolume / (float)0xffffff;                  int samplesRead = bytesRead / 3;                  //BlockEffects(samplesRead);                  for (int n = 0; n < samplesRead; n++)                  {                      int Add = pSourceBuffer[(n * 3) + 2] > 0x7f ? 0xff : 0x00;                      int Buffer = (pSourceBuffer[n * 3]) | (pSourceBuffer[(n * 3) + 1] << 8) | (pSourceBuffer[(n * 3) + 2] << 16) + (Add << 24);                      pfDestBuffer[n*2] = Buffer * leftVolume;                      pfDestBuffer[n*2 + 1] = Buffer * rightVolume;                      //ApplyEffects(ref pfDestBuffer[n * 2]'ref pfDestBuffer[n * 2 + 1]);                      if (Sample != null) RaiseSample(pfDestBuffer[n*2]' pfDestBuffer[n*2 + 1]);                  }              }
Magic Number,NAudio.Wave,WaveChannel24To32,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\NAudio\WaveChannel24To32.cs,MonoToStereo,The following statement contains a magic number: fixed (byte* pDestBuffer = &destBuffer[offset]'                  pSourceBuffer = &sourceBuffer[0])              {                  float* pfDestBuffer = (float*)pDestBuffer;                  short* psSourceBuffer = (short*)pSourceBuffer;                    // implement better panning laws.                   float leftVolume = (pan <= 0) ? volume : (volume * (1 - pan) / 2.0f);                  float rightVolume = (pan >= 0) ? volume : (volume * (pan + 1) / 2.0f);                  leftVolume = leftVolume / (float)0xffffff;                  rightVolume = rightVolume / (float)0xffffff;                  int samplesRead = bytesRead / 3;                  //BlockEffects(samplesRead);                  for (int n = 0; n < samplesRead; n++)                  {                      int Add = pSourceBuffer[(n * 3) + 2] > 0x7f ? 0xff : 0x00;                      int Buffer = (pSourceBuffer[n * 3]) | (pSourceBuffer[(n * 3) + 1] << 8) | (pSourceBuffer[(n * 3) + 2] << 16) + (Add << 24);                      pfDestBuffer[n*2] = Buffer * leftVolume;                      pfDestBuffer[n*2 + 1] = Buffer * rightVolume;                      //ApplyEffects(ref pfDestBuffer[n * 2]'ref pfDestBuffer[n * 2 + 1]);                      if (Sample != null) RaiseSample(pfDestBuffer[n*2]' pfDestBuffer[n*2 + 1]);                  }              }
Magic Number,NAudio.Wave,WaveChannel24To32,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\NAudio\WaveChannel24To32.cs,MonoToStereo,The following statement contains a magic number: fixed (byte* pDestBuffer = &destBuffer[offset]'                  pSourceBuffer = &sourceBuffer[0])              {                  float* pfDestBuffer = (float*)pDestBuffer;                  short* psSourceBuffer = (short*)pSourceBuffer;                    // implement better panning laws.                   float leftVolume = (pan <= 0) ? volume : (volume * (1 - pan) / 2.0f);                  float rightVolume = (pan >= 0) ? volume : (volume * (pan + 1) / 2.0f);                  leftVolume = leftVolume / (float)0xffffff;                  rightVolume = rightVolume / (float)0xffffff;                  int samplesRead = bytesRead / 3;                  //BlockEffects(samplesRead);                  for (int n = 0; n < samplesRead; n++)                  {                      int Add = pSourceBuffer[(n * 3) + 2] > 0x7f ? 0xff : 0x00;                      int Buffer = (pSourceBuffer[n * 3]) | (pSourceBuffer[(n * 3) + 1] << 8) | (pSourceBuffer[(n * 3) + 2] << 16) + (Add << 24);                      pfDestBuffer[n*2] = Buffer * leftVolume;                      pfDestBuffer[n*2 + 1] = Buffer * rightVolume;                      //ApplyEffects(ref pfDestBuffer[n * 2]'ref pfDestBuffer[n * 2 + 1]);                      if (Sample != null) RaiseSample(pfDestBuffer[n*2]' pfDestBuffer[n*2 + 1]);                  }              }
Magic Number,NAudio.Wave,WaveChannel24To32,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\NAudio\WaveChannel24To32.cs,MonoToStereo,The following statement contains a magic number: fixed (byte* pDestBuffer = &destBuffer[offset]'                  pSourceBuffer = &sourceBuffer[0])              {                  float* pfDestBuffer = (float*)pDestBuffer;                  short* psSourceBuffer = (short*)pSourceBuffer;                    // implement better panning laws.                   float leftVolume = (pan <= 0) ? volume : (volume * (1 - pan) / 2.0f);                  float rightVolume = (pan >= 0) ? volume : (volume * (pan + 1) / 2.0f);                  leftVolume = leftVolume / (float)0xffffff;                  rightVolume = rightVolume / (float)0xffffff;                  int samplesRead = bytesRead / 3;                  //BlockEffects(samplesRead);                  for (int n = 0; n < samplesRead; n++)                  {                      int Add = pSourceBuffer[(n * 3) + 2] > 0x7f ? 0xff : 0x00;                      int Buffer = (pSourceBuffer[n * 3]) | (pSourceBuffer[(n * 3) + 1] << 8) | (pSourceBuffer[(n * 3) + 2] << 16) + (Add << 24);                      pfDestBuffer[n*2] = Buffer * leftVolume;                      pfDestBuffer[n*2 + 1] = Buffer * rightVolume;                      //ApplyEffects(ref pfDestBuffer[n * 2]'ref pfDestBuffer[n * 2 + 1]);                      if (Sample != null) RaiseSample(pfDestBuffer[n*2]' pfDestBuffer[n*2 + 1]);                  }              }
Magic Number,NAudio.Wave,WaveChannel24To32,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\NAudio\WaveChannel24To32.cs,MonoToStereo,The following statement contains a magic number: fixed (byte* pDestBuffer = &destBuffer[offset]'                  pSourceBuffer = &sourceBuffer[0])              {                  float* pfDestBuffer = (float*)pDestBuffer;                  short* psSourceBuffer = (short*)pSourceBuffer;                    // implement better panning laws.                   float leftVolume = (pan <= 0) ? volume : (volume * (1 - pan) / 2.0f);                  float rightVolume = (pan >= 0) ? volume : (volume * (pan + 1) / 2.0f);                  leftVolume = leftVolume / (float)0xffffff;                  rightVolume = rightVolume / (float)0xffffff;                  int samplesRead = bytesRead / 3;                  //BlockEffects(samplesRead);                  for (int n = 0; n < samplesRead; n++)                  {                      int Add = pSourceBuffer[(n * 3) + 2] > 0x7f ? 0xff : 0x00;                      int Buffer = (pSourceBuffer[n * 3]) | (pSourceBuffer[(n * 3) + 1] << 8) | (pSourceBuffer[(n * 3) + 2] << 16) + (Add << 24);                      pfDestBuffer[n*2] = Buffer * leftVolume;                      pfDestBuffer[n*2 + 1] = Buffer * rightVolume;                      //ApplyEffects(ref pfDestBuffer[n * 2]'ref pfDestBuffer[n * 2 + 1]);                      if (Sample != null) RaiseSample(pfDestBuffer[n*2]' pfDestBuffer[n*2 + 1]);                  }              }
Magic Number,NAudio.Wave,WaveChannel24To32,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\NAudio\WaveChannel24To32.cs,MonoToStereo,The following statement contains a magic number: fixed (byte* pDestBuffer = &destBuffer[offset]'                  pSourceBuffer = &sourceBuffer[0])              {                  float* pfDestBuffer = (float*)pDestBuffer;                  short* psSourceBuffer = (short*)pSourceBuffer;                    // implement better panning laws.                   float leftVolume = (pan <= 0) ? volume : (volume * (1 - pan) / 2.0f);                  float rightVolume = (pan >= 0) ? volume : (volume * (pan + 1) / 2.0f);                  leftVolume = leftVolume / (float)0xffffff;                  rightVolume = rightVolume / (float)0xffffff;                  int samplesRead = bytesRead / 3;                  //BlockEffects(samplesRead);                  for (int n = 0; n < samplesRead; n++)                  {                      int Add = pSourceBuffer[(n * 3) + 2] > 0x7f ? 0xff : 0x00;                      int Buffer = (pSourceBuffer[n * 3]) | (pSourceBuffer[(n * 3) + 1] << 8) | (pSourceBuffer[(n * 3) + 2] << 16) + (Add << 24);                      pfDestBuffer[n*2] = Buffer * leftVolume;                      pfDestBuffer[n*2 + 1] = Buffer * rightVolume;                      //ApplyEffects(ref pfDestBuffer[n * 2]'ref pfDestBuffer[n * 2 + 1]);                      if (Sample != null) RaiseSample(pfDestBuffer[n*2]' pfDestBuffer[n*2 + 1]);                  }              }
Magic Number,NAudio.Wave,WaveChannel24To32,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\NAudio\WaveChannel24To32.cs,MonoToStereo,The following statement contains a magic number: fixed (byte* pDestBuffer = &destBuffer[offset]'                  pSourceBuffer = &sourceBuffer[0])              {                  float* pfDestBuffer = (float*)pDestBuffer;                  short* psSourceBuffer = (short*)pSourceBuffer;                    // implement better panning laws.                   float leftVolume = (pan <= 0) ? volume : (volume * (1 - pan) / 2.0f);                  float rightVolume = (pan >= 0) ? volume : (volume * (pan + 1) / 2.0f);                  leftVolume = leftVolume / (float)0xffffff;                  rightVolume = rightVolume / (float)0xffffff;                  int samplesRead = bytesRead / 3;                  //BlockEffects(samplesRead);                  for (int n = 0; n < samplesRead; n++)                  {                      int Add = pSourceBuffer[(n * 3) + 2] > 0x7f ? 0xff : 0x00;                      int Buffer = (pSourceBuffer[n * 3]) | (pSourceBuffer[(n * 3) + 1] << 8) | (pSourceBuffer[(n * 3) + 2] << 16) + (Add << 24);                      pfDestBuffer[n*2] = Buffer * leftVolume;                      pfDestBuffer[n*2 + 1] = Buffer * rightVolume;                      //ApplyEffects(ref pfDestBuffer[n * 2]'ref pfDestBuffer[n * 2 + 1]);                      if (Sample != null) RaiseSample(pfDestBuffer[n*2]' pfDestBuffer[n*2 + 1]);                  }              }
Magic Number,NAudio.Wave,WaveChannel24To32,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\NAudio\WaveChannel24To32.cs,MonoToStereo,The following statement contains a magic number: fixed (byte* pDestBuffer = &destBuffer[offset]'                  pSourceBuffer = &sourceBuffer[0])              {                  float* pfDestBuffer = (float*)pDestBuffer;                  short* psSourceBuffer = (short*)pSourceBuffer;                    // implement better panning laws.                   float leftVolume = (pan <= 0) ? volume : (volume * (1 - pan) / 2.0f);                  float rightVolume = (pan >= 0) ? volume : (volume * (pan + 1) / 2.0f);                  leftVolume = leftVolume / (float)0xffffff;                  rightVolume = rightVolume / (float)0xffffff;                  int samplesRead = bytesRead / 3;                  //BlockEffects(samplesRead);                  for (int n = 0; n < samplesRead; n++)                  {                      int Add = pSourceBuffer[(n * 3) + 2] > 0x7f ? 0xff : 0x00;                      int Buffer = (pSourceBuffer[n * 3]) | (pSourceBuffer[(n * 3) + 1] << 8) | (pSourceBuffer[(n * 3) + 2] << 16) + (Add << 24);                      pfDestBuffer[n*2] = Buffer * leftVolume;                      pfDestBuffer[n*2 + 1] = Buffer * rightVolume;                      //ApplyEffects(ref pfDestBuffer[n * 2]'ref pfDestBuffer[n * 2 + 1]);                      if (Sample != null) RaiseSample(pfDestBuffer[n*2]' pfDestBuffer[n*2 + 1]);                  }              }
Magic Number,NAudio.Wave,WaveChannel24To32,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\NAudio\WaveChannel24To32.cs,MonoToStereo,The following statement contains a magic number: fixed (byte* pDestBuffer = &destBuffer[offset]'                  pSourceBuffer = &sourceBuffer[0])              {                  float* pfDestBuffer = (float*)pDestBuffer;                  short* psSourceBuffer = (short*)pSourceBuffer;                    // implement better panning laws.                   float leftVolume = (pan <= 0) ? volume : (volume * (1 - pan) / 2.0f);                  float rightVolume = (pan >= 0) ? volume : (volume * (pan + 1) / 2.0f);                  leftVolume = leftVolume / (float)0xffffff;                  rightVolume = rightVolume / (float)0xffffff;                  int samplesRead = bytesRead / 3;                  //BlockEffects(samplesRead);                  for (int n = 0; n < samplesRead; n++)                  {                      int Add = pSourceBuffer[(n * 3) + 2] > 0x7f ? 0xff : 0x00;                      int Buffer = (pSourceBuffer[n * 3]) | (pSourceBuffer[(n * 3) + 1] << 8) | (pSourceBuffer[(n * 3) + 2] << 16) + (Add << 24);                      pfDestBuffer[n*2] = Buffer * leftVolume;                      pfDestBuffer[n*2 + 1] = Buffer * rightVolume;                      //ApplyEffects(ref pfDestBuffer[n * 2]'ref pfDestBuffer[n * 2 + 1]);                      if (Sample != null) RaiseSample(pfDestBuffer[n*2]' pfDestBuffer[n*2 + 1]);                  }              }
Magic Number,NAudio.Wave,WaveChannel24To32,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\NAudio\WaveChannel24To32.cs,MonoToStereo,The following statement contains a magic number: fixed (byte* pDestBuffer = &destBuffer[offset]'                  pSourceBuffer = &sourceBuffer[0])              {                  float* pfDestBuffer = (float*)pDestBuffer;                  short* psSourceBuffer = (short*)pSourceBuffer;                    // implement better panning laws.                   float leftVolume = (pan <= 0) ? volume : (volume * (1 - pan) / 2.0f);                  float rightVolume = (pan >= 0) ? volume : (volume * (pan + 1) / 2.0f);                  leftVolume = leftVolume / (float)0xffffff;                  rightVolume = rightVolume / (float)0xffffff;                  int samplesRead = bytesRead / 3;                  //BlockEffects(samplesRead);                  for (int n = 0; n < samplesRead; n++)                  {                      int Add = pSourceBuffer[(n * 3) + 2] > 0x7f ? 0xff : 0x00;                      int Buffer = (pSourceBuffer[n * 3]) | (pSourceBuffer[(n * 3) + 1] << 8) | (pSourceBuffer[(n * 3) + 2] << 16) + (Add << 24);                      pfDestBuffer[n*2] = Buffer * leftVolume;                      pfDestBuffer[n*2 + 1] = Buffer * rightVolume;                      //ApplyEffects(ref pfDestBuffer[n * 2]'ref pfDestBuffer[n * 2 + 1]);                      if (Sample != null) RaiseSample(pfDestBuffer[n*2]' pfDestBuffer[n*2 + 1]);                  }              }
Magic Number,NAudio.Wave,WaveChannel24To32,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\NAudio\WaveChannel24To32.cs,AdjustVolume,The following statement contains a magic number: fixed (byte* pDestBuffer = &destBuffer[offset]'                  pSourceBuffer = &sourceBuffer[0])              {                  float* pfDestBuffer = (float*)pDestBuffer;                    // implement better panning laws.                   float leftVolume = (pan <= 0) ? volume : (volume * (1 - pan) / 2.0f);                  float rightVolume = (pan >= 0) ? volume : (volume * (pan + 1) / 2.0f);                    leftVolume = leftVolume / (float)0xffffff;// 0x800000;                  rightVolume = rightVolume / (float)0xffffff;//0x800000;                  //float leftVolume = (volume * (1 - pan) / 2.0f) / 32768f;                  //float rightVolume = (volume * (pan + 1) / 2.0f) / 32768f;                    int samplesRead = bytesRead / 3;                  //BlockEffects(samplesRead / 2);                  for (int n = 0; n < samplesRead; n += 2)                  {                      int lAdd = pSourceBuffer[(n * 3) + 2] > 0x7f ? 0xff : 0x00;                      int rAdd = pSourceBuffer[(n + 1) * 3 + 2] > 0x7f ? 0xff : 0x00;                      int leftBuffer = (pSourceBuffer[n * 3]) | (pSourceBuffer[(n * 3) + 1] << 8) | (pSourceBuffer[(n * 3) + 2] << 16) +(lAdd << 24);                      int rightBuffer = (pSourceBuffer[(n + 1) * 3]) | (pSourceBuffer[(n + 1) * 3 + 1] << 8) | (pSourceBuffer[(n + 1) * 3 + 2] << 16) +(rAdd << 24);                      pfDestBuffer[n] = leftBuffer * leftVolume;                      pfDestBuffer[n + 1] = rightBuffer * rightVolume;                      //ApplyEffects(ref pfDestBuffer[n]' ref pfDestBuffer[n + 1]);                      if (Sample != null) RaiseSample(pfDestBuffer[n]' pfDestBuffer[n + 1]);                  }              }
Magic Number,NAudio.Wave,WaveChannel24To32,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\NAudio\WaveChannel24To32.cs,AdjustVolume,The following statement contains a magic number: fixed (byte* pDestBuffer = &destBuffer[offset]'                  pSourceBuffer = &sourceBuffer[0])              {                  float* pfDestBuffer = (float*)pDestBuffer;                    // implement better panning laws.                   float leftVolume = (pan <= 0) ? volume : (volume * (1 - pan) / 2.0f);                  float rightVolume = (pan >= 0) ? volume : (volume * (pan + 1) / 2.0f);                    leftVolume = leftVolume / (float)0xffffff;// 0x800000;                  rightVolume = rightVolume / (float)0xffffff;//0x800000;                  //float leftVolume = (volume * (1 - pan) / 2.0f) / 32768f;                  //float rightVolume = (volume * (pan + 1) / 2.0f) / 32768f;                    int samplesRead = bytesRead / 3;                  //BlockEffects(samplesRead / 2);                  for (int n = 0; n < samplesRead; n += 2)                  {                      int lAdd = pSourceBuffer[(n * 3) + 2] > 0x7f ? 0xff : 0x00;                      int rAdd = pSourceBuffer[(n + 1) * 3 + 2] > 0x7f ? 0xff : 0x00;                      int leftBuffer = (pSourceBuffer[n * 3]) | (pSourceBuffer[(n * 3) + 1] << 8) | (pSourceBuffer[(n * 3) + 2] << 16) +(lAdd << 24);                      int rightBuffer = (pSourceBuffer[(n + 1) * 3]) | (pSourceBuffer[(n + 1) * 3 + 1] << 8) | (pSourceBuffer[(n + 1) * 3 + 2] << 16) +(rAdd << 24);                      pfDestBuffer[n] = leftBuffer * leftVolume;                      pfDestBuffer[n + 1] = rightBuffer * rightVolume;                      //ApplyEffects(ref pfDestBuffer[n]' ref pfDestBuffer[n + 1]);                      if (Sample != null) RaiseSample(pfDestBuffer[n]' pfDestBuffer[n + 1]);                  }              }
Magic Number,NAudio.Wave,WaveChannel24To32,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\NAudio\WaveChannel24To32.cs,AdjustVolume,The following statement contains a magic number: fixed (byte* pDestBuffer = &destBuffer[offset]'                  pSourceBuffer = &sourceBuffer[0])              {                  float* pfDestBuffer = (float*)pDestBuffer;                    // implement better panning laws.                   float leftVolume = (pan <= 0) ? volume : (volume * (1 - pan) / 2.0f);                  float rightVolume = (pan >= 0) ? volume : (volume * (pan + 1) / 2.0f);                    leftVolume = leftVolume / (float)0xffffff;// 0x800000;                  rightVolume = rightVolume / (float)0xffffff;//0x800000;                  //float leftVolume = (volume * (1 - pan) / 2.0f) / 32768f;                  //float rightVolume = (volume * (pan + 1) / 2.0f) / 32768f;                    int samplesRead = bytesRead / 3;                  //BlockEffects(samplesRead / 2);                  for (int n = 0; n < samplesRead; n += 2)                  {                      int lAdd = pSourceBuffer[(n * 3) + 2] > 0x7f ? 0xff : 0x00;                      int rAdd = pSourceBuffer[(n + 1) * 3 + 2] > 0x7f ? 0xff : 0x00;                      int leftBuffer = (pSourceBuffer[n * 3]) | (pSourceBuffer[(n * 3) + 1] << 8) | (pSourceBuffer[(n * 3) + 2] << 16) +(lAdd << 24);                      int rightBuffer = (pSourceBuffer[(n + 1) * 3]) | (pSourceBuffer[(n + 1) * 3 + 1] << 8) | (pSourceBuffer[(n + 1) * 3 + 2] << 16) +(rAdd << 24);                      pfDestBuffer[n] = leftBuffer * leftVolume;                      pfDestBuffer[n + 1] = rightBuffer * rightVolume;                      //ApplyEffects(ref pfDestBuffer[n]' ref pfDestBuffer[n + 1]);                      if (Sample != null) RaiseSample(pfDestBuffer[n]' pfDestBuffer[n + 1]);                  }              }
Magic Number,NAudio.Wave,WaveChannel24To32,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\NAudio\WaveChannel24To32.cs,AdjustVolume,The following statement contains a magic number: fixed (byte* pDestBuffer = &destBuffer[offset]'                  pSourceBuffer = &sourceBuffer[0])              {                  float* pfDestBuffer = (float*)pDestBuffer;                    // implement better panning laws.                   float leftVolume = (pan <= 0) ? volume : (volume * (1 - pan) / 2.0f);                  float rightVolume = (pan >= 0) ? volume : (volume * (pan + 1) / 2.0f);                    leftVolume = leftVolume / (float)0xffffff;// 0x800000;                  rightVolume = rightVolume / (float)0xffffff;//0x800000;                  //float leftVolume = (volume * (1 - pan) / 2.0f) / 32768f;                  //float rightVolume = (volume * (pan + 1) / 2.0f) / 32768f;                    int samplesRead = bytesRead / 3;                  //BlockEffects(samplesRead / 2);                  for (int n = 0; n < samplesRead; n += 2)                  {                      int lAdd = pSourceBuffer[(n * 3) + 2] > 0x7f ? 0xff : 0x00;                      int rAdd = pSourceBuffer[(n + 1) * 3 + 2] > 0x7f ? 0xff : 0x00;                      int leftBuffer = (pSourceBuffer[n * 3]) | (pSourceBuffer[(n * 3) + 1] << 8) | (pSourceBuffer[(n * 3) + 2] << 16) +(lAdd << 24);                      int rightBuffer = (pSourceBuffer[(n + 1) * 3]) | (pSourceBuffer[(n + 1) * 3 + 1] << 8) | (pSourceBuffer[(n + 1) * 3 + 2] << 16) +(rAdd << 24);                      pfDestBuffer[n] = leftBuffer * leftVolume;                      pfDestBuffer[n + 1] = rightBuffer * rightVolume;                      //ApplyEffects(ref pfDestBuffer[n]' ref pfDestBuffer[n + 1]);                      if (Sample != null) RaiseSample(pfDestBuffer[n]' pfDestBuffer[n + 1]);                  }              }
Magic Number,NAudio.Wave,WaveChannel24To32,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\NAudio\WaveChannel24To32.cs,AdjustVolume,The following statement contains a magic number: fixed (byte* pDestBuffer = &destBuffer[offset]'                  pSourceBuffer = &sourceBuffer[0])              {                  float* pfDestBuffer = (float*)pDestBuffer;                    // implement better panning laws.                   float leftVolume = (pan <= 0) ? volume : (volume * (1 - pan) / 2.0f);                  float rightVolume = (pan >= 0) ? volume : (volume * (pan + 1) / 2.0f);                    leftVolume = leftVolume / (float)0xffffff;// 0x800000;                  rightVolume = rightVolume / (float)0xffffff;//0x800000;                  //float leftVolume = (volume * (1 - pan) / 2.0f) / 32768f;                  //float rightVolume = (volume * (pan + 1) / 2.0f) / 32768f;                    int samplesRead = bytesRead / 3;                  //BlockEffects(samplesRead / 2);                  for (int n = 0; n < samplesRead; n += 2)                  {                      int lAdd = pSourceBuffer[(n * 3) + 2] > 0x7f ? 0xff : 0x00;                      int rAdd = pSourceBuffer[(n + 1) * 3 + 2] > 0x7f ? 0xff : 0x00;                      int leftBuffer = (pSourceBuffer[n * 3]) | (pSourceBuffer[(n * 3) + 1] << 8) | (pSourceBuffer[(n * 3) + 2] << 16) +(lAdd << 24);                      int rightBuffer = (pSourceBuffer[(n + 1) * 3]) | (pSourceBuffer[(n + 1) * 3 + 1] << 8) | (pSourceBuffer[(n + 1) * 3 + 2] << 16) +(rAdd << 24);                      pfDestBuffer[n] = leftBuffer * leftVolume;                      pfDestBuffer[n + 1] = rightBuffer * rightVolume;                      //ApplyEffects(ref pfDestBuffer[n]' ref pfDestBuffer[n + 1]);                      if (Sample != null) RaiseSample(pfDestBuffer[n]' pfDestBuffer[n + 1]);                  }              }
Magic Number,NAudio.Wave,WaveChannel24To32,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\NAudio\WaveChannel24To32.cs,AdjustVolume,The following statement contains a magic number: fixed (byte* pDestBuffer = &destBuffer[offset]'                  pSourceBuffer = &sourceBuffer[0])              {                  float* pfDestBuffer = (float*)pDestBuffer;                    // implement better panning laws.                   float leftVolume = (pan <= 0) ? volume : (volume * (1 - pan) / 2.0f);                  float rightVolume = (pan >= 0) ? volume : (volume * (pan + 1) / 2.0f);                    leftVolume = leftVolume / (float)0xffffff;// 0x800000;                  rightVolume = rightVolume / (float)0xffffff;//0x800000;                  //float leftVolume = (volume * (1 - pan) / 2.0f) / 32768f;                  //float rightVolume = (volume * (pan + 1) / 2.0f) / 32768f;                    int samplesRead = bytesRead / 3;                  //BlockEffects(samplesRead / 2);                  for (int n = 0; n < samplesRead; n += 2)                  {                      int lAdd = pSourceBuffer[(n * 3) + 2] > 0x7f ? 0xff : 0x00;                      int rAdd = pSourceBuffer[(n + 1) * 3 + 2] > 0x7f ? 0xff : 0x00;                      int leftBuffer = (pSourceBuffer[n * 3]) | (pSourceBuffer[(n * 3) + 1] << 8) | (pSourceBuffer[(n * 3) + 2] << 16) +(lAdd << 24);                      int rightBuffer = (pSourceBuffer[(n + 1) * 3]) | (pSourceBuffer[(n + 1) * 3 + 1] << 8) | (pSourceBuffer[(n + 1) * 3 + 2] << 16) +(rAdd << 24);                      pfDestBuffer[n] = leftBuffer * leftVolume;                      pfDestBuffer[n + 1] = rightBuffer * rightVolume;                      //ApplyEffects(ref pfDestBuffer[n]' ref pfDestBuffer[n + 1]);                      if (Sample != null) RaiseSample(pfDestBuffer[n]' pfDestBuffer[n + 1]);                  }              }
Magic Number,NAudio.Wave,WaveChannel24To32,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\NAudio\WaveChannel24To32.cs,AdjustVolume,The following statement contains a magic number: fixed (byte* pDestBuffer = &destBuffer[offset]'                  pSourceBuffer = &sourceBuffer[0])              {                  float* pfDestBuffer = (float*)pDestBuffer;                    // implement better panning laws.                   float leftVolume = (pan <= 0) ? volume : (volume * (1 - pan) / 2.0f);                  float rightVolume = (pan >= 0) ? volume : (volume * (pan + 1) / 2.0f);                    leftVolume = leftVolume / (float)0xffffff;// 0x800000;                  rightVolume = rightVolume / (float)0xffffff;//0x800000;                  //float leftVolume = (volume * (1 - pan) / 2.0f) / 32768f;                  //float rightVolume = (volume * (pan + 1) / 2.0f) / 32768f;                    int samplesRead = bytesRead / 3;                  //BlockEffects(samplesRead / 2);                  for (int n = 0; n < samplesRead; n += 2)                  {                      int lAdd = pSourceBuffer[(n * 3) + 2] > 0x7f ? 0xff : 0x00;                      int rAdd = pSourceBuffer[(n + 1) * 3 + 2] > 0x7f ? 0xff : 0x00;                      int leftBuffer = (pSourceBuffer[n * 3]) | (pSourceBuffer[(n * 3) + 1] << 8) | (pSourceBuffer[(n * 3) + 2] << 16) +(lAdd << 24);                      int rightBuffer = (pSourceBuffer[(n + 1) * 3]) | (pSourceBuffer[(n + 1) * 3 + 1] << 8) | (pSourceBuffer[(n + 1) * 3 + 2] << 16) +(rAdd << 24);                      pfDestBuffer[n] = leftBuffer * leftVolume;                      pfDestBuffer[n + 1] = rightBuffer * rightVolume;                      //ApplyEffects(ref pfDestBuffer[n]' ref pfDestBuffer[n + 1]);                      if (Sample != null) RaiseSample(pfDestBuffer[n]' pfDestBuffer[n + 1]);                  }              }
Magic Number,NAudio.Wave,WaveChannel24To32,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\NAudio\WaveChannel24To32.cs,AdjustVolume,The following statement contains a magic number: fixed (byte* pDestBuffer = &destBuffer[offset]'                  pSourceBuffer = &sourceBuffer[0])              {                  float* pfDestBuffer = (float*)pDestBuffer;                    // implement better panning laws.                   float leftVolume = (pan <= 0) ? volume : (volume * (1 - pan) / 2.0f);                  float rightVolume = (pan >= 0) ? volume : (volume * (pan + 1) / 2.0f);                    leftVolume = leftVolume / (float)0xffffff;// 0x800000;                  rightVolume = rightVolume / (float)0xffffff;//0x800000;                  //float leftVolume = (volume * (1 - pan) / 2.0f) / 32768f;                  //float rightVolume = (volume * (pan + 1) / 2.0f) / 32768f;                    int samplesRead = bytesRead / 3;                  //BlockEffects(samplesRead / 2);                  for (int n = 0; n < samplesRead; n += 2)                  {                      int lAdd = pSourceBuffer[(n * 3) + 2] > 0x7f ? 0xff : 0x00;                      int rAdd = pSourceBuffer[(n + 1) * 3 + 2] > 0x7f ? 0xff : 0x00;                      int leftBuffer = (pSourceBuffer[n * 3]) | (pSourceBuffer[(n * 3) + 1] << 8) | (pSourceBuffer[(n * 3) + 2] << 16) +(lAdd << 24);                      int rightBuffer = (pSourceBuffer[(n + 1) * 3]) | (pSourceBuffer[(n + 1) * 3 + 1] << 8) | (pSourceBuffer[(n + 1) * 3 + 2] << 16) +(rAdd << 24);                      pfDestBuffer[n] = leftBuffer * leftVolume;                      pfDestBuffer[n + 1] = rightBuffer * rightVolume;                      //ApplyEffects(ref pfDestBuffer[n]' ref pfDestBuffer[n + 1]);                      if (Sample != null) RaiseSample(pfDestBuffer[n]' pfDestBuffer[n + 1]);                  }              }
Magic Number,NAudio.Wave,WaveChannel24To32,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\NAudio\WaveChannel24To32.cs,AdjustVolume,The following statement contains a magic number: fixed (byte* pDestBuffer = &destBuffer[offset]'                  pSourceBuffer = &sourceBuffer[0])              {                  float* pfDestBuffer = (float*)pDestBuffer;                    // implement better panning laws.                   float leftVolume = (pan <= 0) ? volume : (volume * (1 - pan) / 2.0f);                  float rightVolume = (pan >= 0) ? volume : (volume * (pan + 1) / 2.0f);                    leftVolume = leftVolume / (float)0xffffff;// 0x800000;                  rightVolume = rightVolume / (float)0xffffff;//0x800000;                  //float leftVolume = (volume * (1 - pan) / 2.0f) / 32768f;                  //float rightVolume = (volume * (pan + 1) / 2.0f) / 32768f;                    int samplesRead = bytesRead / 3;                  //BlockEffects(samplesRead / 2);                  for (int n = 0; n < samplesRead; n += 2)                  {                      int lAdd = pSourceBuffer[(n * 3) + 2] > 0x7f ? 0xff : 0x00;                      int rAdd = pSourceBuffer[(n + 1) * 3 + 2] > 0x7f ? 0xff : 0x00;                      int leftBuffer = (pSourceBuffer[n * 3]) | (pSourceBuffer[(n * 3) + 1] << 8) | (pSourceBuffer[(n * 3) + 2] << 16) +(lAdd << 24);                      int rightBuffer = (pSourceBuffer[(n + 1) * 3]) | (pSourceBuffer[(n + 1) * 3 + 1] << 8) | (pSourceBuffer[(n + 1) * 3 + 2] << 16) +(rAdd << 24);                      pfDestBuffer[n] = leftBuffer * leftVolume;                      pfDestBuffer[n + 1] = rightBuffer * rightVolume;                      //ApplyEffects(ref pfDestBuffer[n]' ref pfDestBuffer[n + 1]);                      if (Sample != null) RaiseSample(pfDestBuffer[n]' pfDestBuffer[n + 1]);                  }              }
Magic Number,NAudio.Wave,WaveChannel24To32,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\NAudio\WaveChannel24To32.cs,AdjustVolume,The following statement contains a magic number: fixed (byte* pDestBuffer = &destBuffer[offset]'                  pSourceBuffer = &sourceBuffer[0])              {                  float* pfDestBuffer = (float*)pDestBuffer;                    // implement better panning laws.                   float leftVolume = (pan <= 0) ? volume : (volume * (1 - pan) / 2.0f);                  float rightVolume = (pan >= 0) ? volume : (volume * (pan + 1) / 2.0f);                    leftVolume = leftVolume / (float)0xffffff;// 0x800000;                  rightVolume = rightVolume / (float)0xffffff;//0x800000;                  //float leftVolume = (volume * (1 - pan) / 2.0f) / 32768f;                  //float rightVolume = (volume * (pan + 1) / 2.0f) / 32768f;                    int samplesRead = bytesRead / 3;                  //BlockEffects(samplesRead / 2);                  for (int n = 0; n < samplesRead; n += 2)                  {                      int lAdd = pSourceBuffer[(n * 3) + 2] > 0x7f ? 0xff : 0x00;                      int rAdd = pSourceBuffer[(n + 1) * 3 + 2] > 0x7f ? 0xff : 0x00;                      int leftBuffer = (pSourceBuffer[n * 3]) | (pSourceBuffer[(n * 3) + 1] << 8) | (pSourceBuffer[(n * 3) + 2] << 16) +(lAdd << 24);                      int rightBuffer = (pSourceBuffer[(n + 1) * 3]) | (pSourceBuffer[(n + 1) * 3 + 1] << 8) | (pSourceBuffer[(n + 1) * 3 + 2] << 16) +(rAdd << 24);                      pfDestBuffer[n] = leftBuffer * leftVolume;                      pfDestBuffer[n + 1] = rightBuffer * rightVolume;                      //ApplyEffects(ref pfDestBuffer[n]' ref pfDestBuffer[n + 1]);                      if (Sample != null) RaiseSample(pfDestBuffer[n]' pfDestBuffer[n + 1]);                  }              }
Magic Number,NAudio.Wave,WaveChannel24To32,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\NAudio\WaveChannel24To32.cs,AdjustVolume,The following statement contains a magic number: fixed (byte* pDestBuffer = &destBuffer[offset]'                  pSourceBuffer = &sourceBuffer[0])              {                  float* pfDestBuffer = (float*)pDestBuffer;                    // implement better panning laws.                   float leftVolume = (pan <= 0) ? volume : (volume * (1 - pan) / 2.0f);                  float rightVolume = (pan >= 0) ? volume : (volume * (pan + 1) / 2.0f);                    leftVolume = leftVolume / (float)0xffffff;// 0x800000;                  rightVolume = rightVolume / (float)0xffffff;//0x800000;                  //float leftVolume = (volume * (1 - pan) / 2.0f) / 32768f;                  //float rightVolume = (volume * (pan + 1) / 2.0f) / 32768f;                    int samplesRead = bytesRead / 3;                  //BlockEffects(samplesRead / 2);                  for (int n = 0; n < samplesRead; n += 2)                  {                      int lAdd = pSourceBuffer[(n * 3) + 2] > 0x7f ? 0xff : 0x00;                      int rAdd = pSourceBuffer[(n + 1) * 3 + 2] > 0x7f ? 0xff : 0x00;                      int leftBuffer = (pSourceBuffer[n * 3]) | (pSourceBuffer[(n * 3) + 1] << 8) | (pSourceBuffer[(n * 3) + 2] << 16) +(lAdd << 24);                      int rightBuffer = (pSourceBuffer[(n + 1) * 3]) | (pSourceBuffer[(n + 1) * 3 + 1] << 8) | (pSourceBuffer[(n + 1) * 3 + 2] << 16) +(rAdd << 24);                      pfDestBuffer[n] = leftBuffer * leftVolume;                      pfDestBuffer[n + 1] = rightBuffer * rightVolume;                      //ApplyEffects(ref pfDestBuffer[n]' ref pfDestBuffer[n + 1]);                      if (Sample != null) RaiseSample(pfDestBuffer[n]' pfDestBuffer[n + 1]);                  }              }
Magic Number,NAudio.Wave,WaveChannel24To32,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\NAudio\WaveChannel24To32.cs,AdjustVolume,The following statement contains a magic number: fixed (byte* pDestBuffer = &destBuffer[offset]'                  pSourceBuffer = &sourceBuffer[0])              {                  float* pfDestBuffer = (float*)pDestBuffer;                    // implement better panning laws.                   float leftVolume = (pan <= 0) ? volume : (volume * (1 - pan) / 2.0f);                  float rightVolume = (pan >= 0) ? volume : (volume * (pan + 1) / 2.0f);                    leftVolume = leftVolume / (float)0xffffff;// 0x800000;                  rightVolume = rightVolume / (float)0xffffff;//0x800000;                  //float leftVolume = (volume * (1 - pan) / 2.0f) / 32768f;                  //float rightVolume = (volume * (pan + 1) / 2.0f) / 32768f;                    int samplesRead = bytesRead / 3;                  //BlockEffects(samplesRead / 2);                  for (int n = 0; n < samplesRead; n += 2)                  {                      int lAdd = pSourceBuffer[(n * 3) + 2] > 0x7f ? 0xff : 0x00;                      int rAdd = pSourceBuffer[(n + 1) * 3 + 2] > 0x7f ? 0xff : 0x00;                      int leftBuffer = (pSourceBuffer[n * 3]) | (pSourceBuffer[(n * 3) + 1] << 8) | (pSourceBuffer[(n * 3) + 2] << 16) +(lAdd << 24);                      int rightBuffer = (pSourceBuffer[(n + 1) * 3]) | (pSourceBuffer[(n + 1) * 3 + 1] << 8) | (pSourceBuffer[(n + 1) * 3 + 2] << 16) +(rAdd << 24);                      pfDestBuffer[n] = leftBuffer * leftVolume;                      pfDestBuffer[n + 1] = rightBuffer * rightVolume;                      //ApplyEffects(ref pfDestBuffer[n]' ref pfDestBuffer[n + 1]);                      if (Sample != null) RaiseSample(pfDestBuffer[n]' pfDestBuffer[n + 1]);                  }              }
Magic Number,NAudio.Wave,WaveChannel24To32,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\NAudio\WaveChannel24To32.cs,AdjustVolume,The following statement contains a magic number: fixed (byte* pDestBuffer = &destBuffer[offset]'                  pSourceBuffer = &sourceBuffer[0])              {                  float* pfDestBuffer = (float*)pDestBuffer;                    // implement better panning laws.                   float leftVolume = (pan <= 0) ? volume : (volume * (1 - pan) / 2.0f);                  float rightVolume = (pan >= 0) ? volume : (volume * (pan + 1) / 2.0f);                    leftVolume = leftVolume / (float)0xffffff;// 0x800000;                  rightVolume = rightVolume / (float)0xffffff;//0x800000;                  //float leftVolume = (volume * (1 - pan) / 2.0f) / 32768f;                  //float rightVolume = (volume * (pan + 1) / 2.0f) / 32768f;                    int samplesRead = bytesRead / 3;                  //BlockEffects(samplesRead / 2);                  for (int n = 0; n < samplesRead; n += 2)                  {                      int lAdd = pSourceBuffer[(n * 3) + 2] > 0x7f ? 0xff : 0x00;                      int rAdd = pSourceBuffer[(n + 1) * 3 + 2] > 0x7f ? 0xff : 0x00;                      int leftBuffer = (pSourceBuffer[n * 3]) | (pSourceBuffer[(n * 3) + 1] << 8) | (pSourceBuffer[(n * 3) + 2] << 16) +(lAdd << 24);                      int rightBuffer = (pSourceBuffer[(n + 1) * 3]) | (pSourceBuffer[(n + 1) * 3 + 1] << 8) | (pSourceBuffer[(n + 1) * 3 + 2] << 16) +(rAdd << 24);                      pfDestBuffer[n] = leftBuffer * leftVolume;                      pfDestBuffer[n + 1] = rightBuffer * rightVolume;                      //ApplyEffects(ref pfDestBuffer[n]' ref pfDestBuffer[n + 1]);                      if (Sample != null) RaiseSample(pfDestBuffer[n]' pfDestBuffer[n + 1]);                  }              }
Magic Number,NAudio.Wave,WaveChannel24To32,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\NAudio\WaveChannel24To32.cs,AdjustVolume,The following statement contains a magic number: fixed (byte* pDestBuffer = &destBuffer[offset]'                  pSourceBuffer = &sourceBuffer[0])              {                  float* pfDestBuffer = (float*)pDestBuffer;                    // implement better panning laws.                   float leftVolume = (pan <= 0) ? volume : (volume * (1 - pan) / 2.0f);                  float rightVolume = (pan >= 0) ? volume : (volume * (pan + 1) / 2.0f);                    leftVolume = leftVolume / (float)0xffffff;// 0x800000;                  rightVolume = rightVolume / (float)0xffffff;//0x800000;                  //float leftVolume = (volume * (1 - pan) / 2.0f) / 32768f;                  //float rightVolume = (volume * (pan + 1) / 2.0f) / 32768f;                    int samplesRead = bytesRead / 3;                  //BlockEffects(samplesRead / 2);                  for (int n = 0; n < samplesRead; n += 2)                  {                      int lAdd = pSourceBuffer[(n * 3) + 2] > 0x7f ? 0xff : 0x00;                      int rAdd = pSourceBuffer[(n + 1) * 3 + 2] > 0x7f ? 0xff : 0x00;                      int leftBuffer = (pSourceBuffer[n * 3]) | (pSourceBuffer[(n * 3) + 1] << 8) | (pSourceBuffer[(n * 3) + 2] << 16) +(lAdd << 24);                      int rightBuffer = (pSourceBuffer[(n + 1) * 3]) | (pSourceBuffer[(n + 1) * 3 + 1] << 8) | (pSourceBuffer[(n + 1) * 3 + 2] << 16) +(rAdd << 24);                      pfDestBuffer[n] = leftBuffer * leftVolume;                      pfDestBuffer[n + 1] = rightBuffer * rightVolume;                      //ApplyEffects(ref pfDestBuffer[n]' ref pfDestBuffer[n + 1]);                      if (Sample != null) RaiseSample(pfDestBuffer[n]' pfDestBuffer[n + 1]);                  }              }
Magic Number,NAudio.Wave,WaveChannel24To32,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\NAudio\WaveChannel24To32.cs,AdjustVolume,The following statement contains a magic number: fixed (byte* pDestBuffer = &destBuffer[offset]'                  pSourceBuffer = &sourceBuffer[0])              {                  float* pfDestBuffer = (float*)pDestBuffer;                    // implement better panning laws.                   float leftVolume = (pan <= 0) ? volume : (volume * (1 - pan) / 2.0f);                  float rightVolume = (pan >= 0) ? volume : (volume * (pan + 1) / 2.0f);                    leftVolume = leftVolume / (float)0xffffff;// 0x800000;                  rightVolume = rightVolume / (float)0xffffff;//0x800000;                  //float leftVolume = (volume * (1 - pan) / 2.0f) / 32768f;                  //float rightVolume = (volume * (pan + 1) / 2.0f) / 32768f;                    int samplesRead = bytesRead / 3;                  //BlockEffects(samplesRead / 2);                  for (int n = 0; n < samplesRead; n += 2)                  {                      int lAdd = pSourceBuffer[(n * 3) + 2] > 0x7f ? 0xff : 0x00;                      int rAdd = pSourceBuffer[(n + 1) * 3 + 2] > 0x7f ? 0xff : 0x00;                      int leftBuffer = (pSourceBuffer[n * 3]) | (pSourceBuffer[(n * 3) + 1] << 8) | (pSourceBuffer[(n * 3) + 2] << 16) +(lAdd << 24);                      int rightBuffer = (pSourceBuffer[(n + 1) * 3]) | (pSourceBuffer[(n + 1) * 3 + 1] << 8) | (pSourceBuffer[(n + 1) * 3 + 2] << 16) +(rAdd << 24);                      pfDestBuffer[n] = leftBuffer * leftVolume;                      pfDestBuffer[n + 1] = rightBuffer * rightVolume;                      //ApplyEffects(ref pfDestBuffer[n]' ref pfDestBuffer[n + 1]);                      if (Sample != null) RaiseSample(pfDestBuffer[n]' pfDestBuffer[n + 1]);                  }              }
Magic Number,NAudio.Wave,WaveChannel24To32,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\NAudio\WaveChannel24To32.cs,AdjustVolume,The following statement contains a magic number: fixed (byte* pDestBuffer = &destBuffer[offset]'                  pSourceBuffer = &sourceBuffer[0])              {                  float* pfDestBuffer = (float*)pDestBuffer;                    // implement better panning laws.                   float leftVolume = (pan <= 0) ? volume : (volume * (1 - pan) / 2.0f);                  float rightVolume = (pan >= 0) ? volume : (volume * (pan + 1) / 2.0f);                    leftVolume = leftVolume / (float)0xffffff;// 0x800000;                  rightVolume = rightVolume / (float)0xffffff;//0x800000;                  //float leftVolume = (volume * (1 - pan) / 2.0f) / 32768f;                  //float rightVolume = (volume * (pan + 1) / 2.0f) / 32768f;                    int samplesRead = bytesRead / 3;                  //BlockEffects(samplesRead / 2);                  for (int n = 0; n < samplesRead; n += 2)                  {                      int lAdd = pSourceBuffer[(n * 3) + 2] > 0x7f ? 0xff : 0x00;                      int rAdd = pSourceBuffer[(n + 1) * 3 + 2] > 0x7f ? 0xff : 0x00;                      int leftBuffer = (pSourceBuffer[n * 3]) | (pSourceBuffer[(n * 3) + 1] << 8) | (pSourceBuffer[(n * 3) + 2] << 16) +(lAdd << 24);                      int rightBuffer = (pSourceBuffer[(n + 1) * 3]) | (pSourceBuffer[(n + 1) * 3 + 1] << 8) | (pSourceBuffer[(n + 1) * 3 + 2] << 16) +(rAdd << 24);                      pfDestBuffer[n] = leftBuffer * leftVolume;                      pfDestBuffer[n + 1] = rightBuffer * rightVolume;                      //ApplyEffects(ref pfDestBuffer[n]' ref pfDestBuffer[n + 1]);                      if (Sample != null) RaiseSample(pfDestBuffer[n]' pfDestBuffer[n + 1]);                  }              }
Magic Number,NAudio.Wave,WaveChannel24To32,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\NAudio\WaveChannel24To32.cs,AdjustVolume,The following statement contains a magic number: fixed (byte* pDestBuffer = &destBuffer[offset]'                  pSourceBuffer = &sourceBuffer[0])              {                  float* pfDestBuffer = (float*)pDestBuffer;                    // implement better panning laws.                   float leftVolume = (pan <= 0) ? volume : (volume * (1 - pan) / 2.0f);                  float rightVolume = (pan >= 0) ? volume : (volume * (pan + 1) / 2.0f);                    leftVolume = leftVolume / (float)0xffffff;// 0x800000;                  rightVolume = rightVolume / (float)0xffffff;//0x800000;                  //float leftVolume = (volume * (1 - pan) / 2.0f) / 32768f;                  //float rightVolume = (volume * (pan + 1) / 2.0f) / 32768f;                    int samplesRead = bytesRead / 3;                  //BlockEffects(samplesRead / 2);                  for (int n = 0; n < samplesRead; n += 2)                  {                      int lAdd = pSourceBuffer[(n * 3) + 2] > 0x7f ? 0xff : 0x00;                      int rAdd = pSourceBuffer[(n + 1) * 3 + 2] > 0x7f ? 0xff : 0x00;                      int leftBuffer = (pSourceBuffer[n * 3]) | (pSourceBuffer[(n * 3) + 1] << 8) | (pSourceBuffer[(n * 3) + 2] << 16) +(lAdd << 24);                      int rightBuffer = (pSourceBuffer[(n + 1) * 3]) | (pSourceBuffer[(n + 1) * 3 + 1] << 8) | (pSourceBuffer[(n + 1) * 3 + 2] << 16) +(rAdd << 24);                      pfDestBuffer[n] = leftBuffer * leftVolume;                      pfDestBuffer[n + 1] = rightBuffer * rightVolume;                      //ApplyEffects(ref pfDestBuffer[n]' ref pfDestBuffer[n + 1]);                      if (Sample != null) RaiseSample(pfDestBuffer[n]' pfDestBuffer[n + 1]);                  }              }
Magic Number,NAudio.Wave,WaveChannel24To32,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\NAudio\WaveChannel24To32.cs,AdjustVolume,The following statement contains a magic number: fixed (byte* pDestBuffer = &destBuffer[offset]'                  pSourceBuffer = &sourceBuffer[0])              {                  float* pfDestBuffer = (float*)pDestBuffer;                    // implement better panning laws.                   float leftVolume = (pan <= 0) ? volume : (volume * (1 - pan) / 2.0f);                  float rightVolume = (pan >= 0) ? volume : (volume * (pan + 1) / 2.0f);                    leftVolume = leftVolume / (float)0xffffff;// 0x800000;                  rightVolume = rightVolume / (float)0xffffff;//0x800000;                  //float leftVolume = (volume * (1 - pan) / 2.0f) / 32768f;                  //float rightVolume = (volume * (pan + 1) / 2.0f) / 32768f;                    int samplesRead = bytesRead / 3;                  //BlockEffects(samplesRead / 2);                  for (int n = 0; n < samplesRead; n += 2)                  {                      int lAdd = pSourceBuffer[(n * 3) + 2] > 0x7f ? 0xff : 0x00;                      int rAdd = pSourceBuffer[(n + 1) * 3 + 2] > 0x7f ? 0xff : 0x00;                      int leftBuffer = (pSourceBuffer[n * 3]) | (pSourceBuffer[(n * 3) + 1] << 8) | (pSourceBuffer[(n * 3) + 2] << 16) +(lAdd << 24);                      int rightBuffer = (pSourceBuffer[(n + 1) * 3]) | (pSourceBuffer[(n + 1) * 3 + 1] << 8) | (pSourceBuffer[(n + 1) * 3 + 2] << 16) +(rAdd << 24);                      pfDestBuffer[n] = leftBuffer * leftVolume;                      pfDestBuffer[n + 1] = rightBuffer * rightVolume;                      //ApplyEffects(ref pfDestBuffer[n]' ref pfDestBuffer[n + 1]);                      if (Sample != null) RaiseSample(pfDestBuffer[n]' pfDestBuffer[n + 1]);                  }              }
Magic Number,NAudio.Wave,WaveChannel24To32,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\NAudio\WaveChannel24To32.cs,AdjustVolume,The following statement contains a magic number: fixed (byte* pDestBuffer = &destBuffer[offset]'                  pSourceBuffer = &sourceBuffer[0])              {                  float* pfDestBuffer = (float*)pDestBuffer;                    // implement better panning laws.                   float leftVolume = (pan <= 0) ? volume : (volume * (1 - pan) / 2.0f);                  float rightVolume = (pan >= 0) ? volume : (volume * (pan + 1) / 2.0f);                    leftVolume = leftVolume / (float)0xffffff;// 0x800000;                  rightVolume = rightVolume / (float)0xffffff;//0x800000;                  //float leftVolume = (volume * (1 - pan) / 2.0f) / 32768f;                  //float rightVolume = (volume * (pan + 1) / 2.0f) / 32768f;                    int samplesRead = bytesRead / 3;                  //BlockEffects(samplesRead / 2);                  for (int n = 0; n < samplesRead; n += 2)                  {                      int lAdd = pSourceBuffer[(n * 3) + 2] > 0x7f ? 0xff : 0x00;                      int rAdd = pSourceBuffer[(n + 1) * 3 + 2] > 0x7f ? 0xff : 0x00;                      int leftBuffer = (pSourceBuffer[n * 3]) | (pSourceBuffer[(n * 3) + 1] << 8) | (pSourceBuffer[(n * 3) + 2] << 16) +(lAdd << 24);                      int rightBuffer = (pSourceBuffer[(n + 1) * 3]) | (pSourceBuffer[(n + 1) * 3 + 1] << 8) | (pSourceBuffer[(n + 1) * 3 + 2] << 16) +(rAdd << 24);                      pfDestBuffer[n] = leftBuffer * leftVolume;                      pfDestBuffer[n + 1] = rightBuffer * rightVolume;                      //ApplyEffects(ref pfDestBuffer[n]' ref pfDestBuffer[n + 1]);                      if (Sample != null) RaiseSample(pfDestBuffer[n]' pfDestBuffer[n + 1]);                  }              }
Magic Number,NAudio.Wave,WaveChannel24To32,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\NAudio\WaveChannel24To32.cs,AdjustVolume,The following statement contains a magic number: fixed (byte* pDestBuffer = &destBuffer[offset]'                  pSourceBuffer = &sourceBuffer[0])              {                  float* pfDestBuffer = (float*)pDestBuffer;                    // implement better panning laws.                   float leftVolume = (pan <= 0) ? volume : (volume * (1 - pan) / 2.0f);                  float rightVolume = (pan >= 0) ? volume : (volume * (pan + 1) / 2.0f);                    leftVolume = leftVolume / (float)0xffffff;// 0x800000;                  rightVolume = rightVolume / (float)0xffffff;//0x800000;                  //float leftVolume = (volume * (1 - pan) / 2.0f) / 32768f;                  //float rightVolume = (volume * (pan + 1) / 2.0f) / 32768f;                    int samplesRead = bytesRead / 3;                  //BlockEffects(samplesRead / 2);                  for (int n = 0; n < samplesRead; n += 2)                  {                      int lAdd = pSourceBuffer[(n * 3) + 2] > 0x7f ? 0xff : 0x00;                      int rAdd = pSourceBuffer[(n + 1) * 3 + 2] > 0x7f ? 0xff : 0x00;                      int leftBuffer = (pSourceBuffer[n * 3]) | (pSourceBuffer[(n * 3) + 1] << 8) | (pSourceBuffer[(n * 3) + 2] << 16) +(lAdd << 24);                      int rightBuffer = (pSourceBuffer[(n + 1) * 3]) | (pSourceBuffer[(n + 1) * 3 + 1] << 8) | (pSourceBuffer[(n + 1) * 3 + 2] << 16) +(rAdd << 24);                      pfDestBuffer[n] = leftBuffer * leftVolume;                      pfDestBuffer[n + 1] = rightBuffer * rightVolume;                      //ApplyEffects(ref pfDestBuffer[n]' ref pfDestBuffer[n + 1]);                      if (Sample != null) RaiseSample(pfDestBuffer[n]' pfDestBuffer[n + 1]);                  }              }
Magic Number,NAudio.Wave,WaveChannel32To32,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\NAudio\WaveChannel32To32.cs,WaveChannel32To32,The following statement contains a magic number: if (sourceStream.WaveFormat.BitsPerSample != 32)                  throw new ApplicationException("Only 32 bit audio supported");
Magic Number,NAudio.Wave,WaveChannel32To32,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\NAudio\WaveChannel32To32.cs,WaveChannel32To32,The following statement contains a magic number: waveFormat = WaveFormat.CreateIeeeFloatWaveFormat(sourceStream.WaveFormat.SampleRate' 2);
Magic Number,NAudio.Wave,WaveChannel32To32,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\NAudio\WaveChannel32To32.cs,WaveChannel32To32,The following statement contains a magic number: destBytesPerSample = 8;
Magic Number,NAudio.Wave,WaveChannel32To32,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\NAudio\WaveChannel32To32.cs,WaveChannel32To32,The following statement contains a magic number: sourceBytesPerSample = sourceStream.WaveFormat.Channels * sourceStream.WaveFormat.BitsPerSample / 8;
Magic Number,NAudio.Wave,WaveChannel32To32,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\NAudio\WaveChannel32To32.cs,Read,The following statement contains a magic number: if (bytesWritten < numBytes)              {                  if (sourceStream.WaveFormat.Channels == 1)                  {                      int sourceBytesRequired = (numBytes - bytesWritten);                      byte[] sourceBuffer = GetSourceBuffer(sourceBytesRequired);                      int read = sourceStream.Read(sourceBuffer' 0' sourceBytesRequired);                      MonoToStereo(destBuffer' offset + bytesWritten' sourceBuffer' read);                      bytesWritten += (read * 2);                  }                  else                  {                      int sourceBytesRequired = (numBytes - bytesWritten);                      byte[] sourceBuffer = GetSourceBuffer(sourceBytesRequired);                      int read = sourceStream.Read(sourceBuffer' 0' sourceBytesRequired);                      AdjustVolume(destBuffer' offset + bytesWritten' sourceBuffer' read);                      bytesWritten += read;                  }              }
Magic Number,NAudio.Wave,WaveChannel32To32,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\NAudio\WaveChannel32To32.cs,MonoToStereo,The following statement contains a magic number: fixed (byte* pDestBuffer = &destBuffer[offset]'                  pSourceBuffer = &sourceBuffer[0])              {                  float* pfDestBuffer = (float*)pDestBuffer;                  short* psSourceBuffer = (short*)pSourceBuffer;                    // implement better panning laws.                   float leftVolume = (pan <= 0) ? volume : (volume * (1 - pan) / 2.0f);                  float rightVolume = (pan >= 0) ? volume : (volume * (pan + 1) / 2.0f);                  leftVolume = leftVolume / 32768f;                  rightVolume = rightVolume / 32768f;                  int samplesRead = bytesRead / 2;                  //BlockEffects(samplesRead);                  for (int n = 0; n < samplesRead; n++)                  {                      pfDestBuffer[n * 2] = psSourceBuffer[n] * leftVolume;                      pfDestBuffer[n * 2 + 1] = psSourceBuffer[n] * rightVolume;                      //ApplyEffects(ref pfDestBuffer[n * 2]' ref pfDestBuffer[n * 2 + 1]);                      if (Sample != null) RaiseSample(pfDestBuffer[n * 2]' pfDestBuffer[n * 2 + 1]);                  }              }
Magic Number,NAudio.Wave,WaveChannel32To32,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\NAudio\WaveChannel32To32.cs,MonoToStereo,The following statement contains a magic number: fixed (byte* pDestBuffer = &destBuffer[offset]'                  pSourceBuffer = &sourceBuffer[0])              {                  float* pfDestBuffer = (float*)pDestBuffer;                  short* psSourceBuffer = (short*)pSourceBuffer;                    // implement better panning laws.                   float leftVolume = (pan <= 0) ? volume : (volume * (1 - pan) / 2.0f);                  float rightVolume = (pan >= 0) ? volume : (volume * (pan + 1) / 2.0f);                  leftVolume = leftVolume / 32768f;                  rightVolume = rightVolume / 32768f;                  int samplesRead = bytesRead / 2;                  //BlockEffects(samplesRead);                  for (int n = 0; n < samplesRead; n++)                  {                      pfDestBuffer[n * 2] = psSourceBuffer[n] * leftVolume;                      pfDestBuffer[n * 2 + 1] = psSourceBuffer[n] * rightVolume;                      //ApplyEffects(ref pfDestBuffer[n * 2]' ref pfDestBuffer[n * 2 + 1]);                      if (Sample != null) RaiseSample(pfDestBuffer[n * 2]' pfDestBuffer[n * 2 + 1]);                  }              }
Magic Number,NAudio.Wave,WaveChannel32To32,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\NAudio\WaveChannel32To32.cs,MonoToStereo,The following statement contains a magic number: fixed (byte* pDestBuffer = &destBuffer[offset]'                  pSourceBuffer = &sourceBuffer[0])              {                  float* pfDestBuffer = (float*)pDestBuffer;                  short* psSourceBuffer = (short*)pSourceBuffer;                    // implement better panning laws.                   float leftVolume = (pan <= 0) ? volume : (volume * (1 - pan) / 2.0f);                  float rightVolume = (pan >= 0) ? volume : (volume * (pan + 1) / 2.0f);                  leftVolume = leftVolume / 32768f;                  rightVolume = rightVolume / 32768f;                  int samplesRead = bytesRead / 2;                  //BlockEffects(samplesRead);                  for (int n = 0; n < samplesRead; n++)                  {                      pfDestBuffer[n * 2] = psSourceBuffer[n] * leftVolume;                      pfDestBuffer[n * 2 + 1] = psSourceBuffer[n] * rightVolume;                      //ApplyEffects(ref pfDestBuffer[n * 2]' ref pfDestBuffer[n * 2 + 1]);                      if (Sample != null) RaiseSample(pfDestBuffer[n * 2]' pfDestBuffer[n * 2 + 1]);                  }              }
Magic Number,NAudio.Wave,WaveChannel32To32,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\NAudio\WaveChannel32To32.cs,MonoToStereo,The following statement contains a magic number: fixed (byte* pDestBuffer = &destBuffer[offset]'                  pSourceBuffer = &sourceBuffer[0])              {                  float* pfDestBuffer = (float*)pDestBuffer;                  short* psSourceBuffer = (short*)pSourceBuffer;                    // implement better panning laws.                   float leftVolume = (pan <= 0) ? volume : (volume * (1 - pan) / 2.0f);                  float rightVolume = (pan >= 0) ? volume : (volume * (pan + 1) / 2.0f);                  leftVolume = leftVolume / 32768f;                  rightVolume = rightVolume / 32768f;                  int samplesRead = bytesRead / 2;                  //BlockEffects(samplesRead);                  for (int n = 0; n < samplesRead; n++)                  {                      pfDestBuffer[n * 2] = psSourceBuffer[n] * leftVolume;                      pfDestBuffer[n * 2 + 1] = psSourceBuffer[n] * rightVolume;                      //ApplyEffects(ref pfDestBuffer[n * 2]' ref pfDestBuffer[n * 2 + 1]);                      if (Sample != null) RaiseSample(pfDestBuffer[n * 2]' pfDestBuffer[n * 2 + 1]);                  }              }
Magic Number,NAudio.Wave,WaveChannel32To32,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\NAudio\WaveChannel32To32.cs,MonoToStereo,The following statement contains a magic number: fixed (byte* pDestBuffer = &destBuffer[offset]'                  pSourceBuffer = &sourceBuffer[0])              {                  float* pfDestBuffer = (float*)pDestBuffer;                  short* psSourceBuffer = (short*)pSourceBuffer;                    // implement better panning laws.                   float leftVolume = (pan <= 0) ? volume : (volume * (1 - pan) / 2.0f);                  float rightVolume = (pan >= 0) ? volume : (volume * (pan + 1) / 2.0f);                  leftVolume = leftVolume / 32768f;                  rightVolume = rightVolume / 32768f;                  int samplesRead = bytesRead / 2;                  //BlockEffects(samplesRead);                  for (int n = 0; n < samplesRead; n++)                  {                      pfDestBuffer[n * 2] = psSourceBuffer[n] * leftVolume;                      pfDestBuffer[n * 2 + 1] = psSourceBuffer[n] * rightVolume;                      //ApplyEffects(ref pfDestBuffer[n * 2]' ref pfDestBuffer[n * 2 + 1]);                      if (Sample != null) RaiseSample(pfDestBuffer[n * 2]' pfDestBuffer[n * 2 + 1]);                  }              }
Magic Number,NAudio.Wave,WaveChannel32To32,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\NAudio\WaveChannel32To32.cs,AdjustVolume,The following statement contains a magic number: fixed (byte* pDestBuffer = &destBuffer[offset]'                  pSourceBuffer = &sourceBuffer[0])              {                  float* pfDestBuffer = (float*)pDestBuffer;                    // implement better panning laws.                   float leftVolume = (pan <= 0) ? volume : (volume * (1 - pan) / 2.0f);                  float rightVolume = (pan >= 0) ? volume : (volume * (pan + 1) / 2.0f);                    leftVolume = leftVolume / (float)0xffffffff;;                  rightVolume = rightVolume / (float)0xffffffff;;                  //float leftVolume = (volume * (1 - pan) / 2.0f) / 32768f;                  //float rightVolume = (volume * (pan + 1) / 2.0f) / 32768f;                    int samplesRead = bytesRead / 4;                  //BlockEffects(samplesRead / 2);                  for (int n = 0; n < samplesRead; n += 2)                  {                      int leftBuffer = (pSourceBuffer[n * 4]) | (pSourceBuffer[(n * 4) + 1] << 8) | (pSourceBuffer[(n * 4) + 2] << 16) + (pSourceBuffer[(n * 4) + 3] << 24);                      int rightBuffer = (pSourceBuffer[(n + 1) * 4]) | (pSourceBuffer[(n + 1) * 4 + 1] << 8) | (pSourceBuffer[(n + 1) * 4 + 2] << 16) + (pSourceBuffer[(n + 1) * 4 + 3] << 24);                      pfDestBuffer[n] = leftBuffer * leftVolume;                      pfDestBuffer[n + 1] = rightBuffer * rightVolume;                      //ApplyEffects(ref pfDestBuffer[n]' ref pfDestBuffer[n + 1]);                      if (Sample != null) RaiseSample(pfDestBuffer[n]' pfDestBuffer[n + 1]);                  }              }
Magic Number,NAudio.Wave,WaveChannel32To32,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\NAudio\WaveChannel32To32.cs,AdjustVolume,The following statement contains a magic number: fixed (byte* pDestBuffer = &destBuffer[offset]'                  pSourceBuffer = &sourceBuffer[0])              {                  float* pfDestBuffer = (float*)pDestBuffer;                    // implement better panning laws.                   float leftVolume = (pan <= 0) ? volume : (volume * (1 - pan) / 2.0f);                  float rightVolume = (pan >= 0) ? volume : (volume * (pan + 1) / 2.0f);                    leftVolume = leftVolume / (float)0xffffffff;;                  rightVolume = rightVolume / (float)0xffffffff;;                  //float leftVolume = (volume * (1 - pan) / 2.0f) / 32768f;                  //float rightVolume = (volume * (pan + 1) / 2.0f) / 32768f;                    int samplesRead = bytesRead / 4;                  //BlockEffects(samplesRead / 2);                  for (int n = 0; n < samplesRead; n += 2)                  {                      int leftBuffer = (pSourceBuffer[n * 4]) | (pSourceBuffer[(n * 4) + 1] << 8) | (pSourceBuffer[(n * 4) + 2] << 16) + (pSourceBuffer[(n * 4) + 3] << 24);                      int rightBuffer = (pSourceBuffer[(n + 1) * 4]) | (pSourceBuffer[(n + 1) * 4 + 1] << 8) | (pSourceBuffer[(n + 1) * 4 + 2] << 16) + (pSourceBuffer[(n + 1) * 4 + 3] << 24);                      pfDestBuffer[n] = leftBuffer * leftVolume;                      pfDestBuffer[n + 1] = rightBuffer * rightVolume;                      //ApplyEffects(ref pfDestBuffer[n]' ref pfDestBuffer[n + 1]);                      if (Sample != null) RaiseSample(pfDestBuffer[n]' pfDestBuffer[n + 1]);                  }              }
Magic Number,NAudio.Wave,WaveChannel32To32,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\NAudio\WaveChannel32To32.cs,AdjustVolume,The following statement contains a magic number: fixed (byte* pDestBuffer = &destBuffer[offset]'                  pSourceBuffer = &sourceBuffer[0])              {                  float* pfDestBuffer = (float*)pDestBuffer;                    // implement better panning laws.                   float leftVolume = (pan <= 0) ? volume : (volume * (1 - pan) / 2.0f);                  float rightVolume = (pan >= 0) ? volume : (volume * (pan + 1) / 2.0f);                    leftVolume = leftVolume / (float)0xffffffff;;                  rightVolume = rightVolume / (float)0xffffffff;;                  //float leftVolume = (volume * (1 - pan) / 2.0f) / 32768f;                  //float rightVolume = (volume * (pan + 1) / 2.0f) / 32768f;                    int samplesRead = bytesRead / 4;                  //BlockEffects(samplesRead / 2);                  for (int n = 0; n < samplesRead; n += 2)                  {                      int leftBuffer = (pSourceBuffer[n * 4]) | (pSourceBuffer[(n * 4) + 1] << 8) | (pSourceBuffer[(n * 4) + 2] << 16) + (pSourceBuffer[(n * 4) + 3] << 24);                      int rightBuffer = (pSourceBuffer[(n + 1) * 4]) | (pSourceBuffer[(n + 1) * 4 + 1] << 8) | (pSourceBuffer[(n + 1) * 4 + 2] << 16) + (pSourceBuffer[(n + 1) * 4 + 3] << 24);                      pfDestBuffer[n] = leftBuffer * leftVolume;                      pfDestBuffer[n + 1] = rightBuffer * rightVolume;                      //ApplyEffects(ref pfDestBuffer[n]' ref pfDestBuffer[n + 1]);                      if (Sample != null) RaiseSample(pfDestBuffer[n]' pfDestBuffer[n + 1]);                  }              }
Magic Number,NAudio.Wave,WaveChannel32To32,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\NAudio\WaveChannel32To32.cs,AdjustVolume,The following statement contains a magic number: fixed (byte* pDestBuffer = &destBuffer[offset]'                  pSourceBuffer = &sourceBuffer[0])              {                  float* pfDestBuffer = (float*)pDestBuffer;                    // implement better panning laws.                   float leftVolume = (pan <= 0) ? volume : (volume * (1 - pan) / 2.0f);                  float rightVolume = (pan >= 0) ? volume : (volume * (pan + 1) / 2.0f);                    leftVolume = leftVolume / (float)0xffffffff;;                  rightVolume = rightVolume / (float)0xffffffff;;                  //float leftVolume = (volume * (1 - pan) / 2.0f) / 32768f;                  //float rightVolume = (volume * (pan + 1) / 2.0f) / 32768f;                    int samplesRead = bytesRead / 4;                  //BlockEffects(samplesRead / 2);                  for (int n = 0; n < samplesRead; n += 2)                  {                      int leftBuffer = (pSourceBuffer[n * 4]) | (pSourceBuffer[(n * 4) + 1] << 8) | (pSourceBuffer[(n * 4) + 2] << 16) + (pSourceBuffer[(n * 4) + 3] << 24);                      int rightBuffer = (pSourceBuffer[(n + 1) * 4]) | (pSourceBuffer[(n + 1) * 4 + 1] << 8) | (pSourceBuffer[(n + 1) * 4 + 2] << 16) + (pSourceBuffer[(n + 1) * 4 + 3] << 24);                      pfDestBuffer[n] = leftBuffer * leftVolume;                      pfDestBuffer[n + 1] = rightBuffer * rightVolume;                      //ApplyEffects(ref pfDestBuffer[n]' ref pfDestBuffer[n + 1]);                      if (Sample != null) RaiseSample(pfDestBuffer[n]' pfDestBuffer[n + 1]);                  }              }
Magic Number,NAudio.Wave,WaveChannel32To32,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\NAudio\WaveChannel32To32.cs,AdjustVolume,The following statement contains a magic number: fixed (byte* pDestBuffer = &destBuffer[offset]'                  pSourceBuffer = &sourceBuffer[0])              {                  float* pfDestBuffer = (float*)pDestBuffer;                    // implement better panning laws.                   float leftVolume = (pan <= 0) ? volume : (volume * (1 - pan) / 2.0f);                  float rightVolume = (pan >= 0) ? volume : (volume * (pan + 1) / 2.0f);                    leftVolume = leftVolume / (float)0xffffffff;;                  rightVolume = rightVolume / (float)0xffffffff;;                  //float leftVolume = (volume * (1 - pan) / 2.0f) / 32768f;                  //float rightVolume = (volume * (pan + 1) / 2.0f) / 32768f;                    int samplesRead = bytesRead / 4;                  //BlockEffects(samplesRead / 2);                  for (int n = 0; n < samplesRead; n += 2)                  {                      int leftBuffer = (pSourceBuffer[n * 4]) | (pSourceBuffer[(n * 4) + 1] << 8) | (pSourceBuffer[(n * 4) + 2] << 16) + (pSourceBuffer[(n * 4) + 3] << 24);                      int rightBuffer = (pSourceBuffer[(n + 1) * 4]) | (pSourceBuffer[(n + 1) * 4 + 1] << 8) | (pSourceBuffer[(n + 1) * 4 + 2] << 16) + (pSourceBuffer[(n + 1) * 4 + 3] << 24);                      pfDestBuffer[n] = leftBuffer * leftVolume;                      pfDestBuffer[n + 1] = rightBuffer * rightVolume;                      //ApplyEffects(ref pfDestBuffer[n]' ref pfDestBuffer[n + 1]);                      if (Sample != null) RaiseSample(pfDestBuffer[n]' pfDestBuffer[n + 1]);                  }              }
Magic Number,NAudio.Wave,WaveChannel32To32,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\NAudio\WaveChannel32To32.cs,AdjustVolume,The following statement contains a magic number: fixed (byte* pDestBuffer = &destBuffer[offset]'                  pSourceBuffer = &sourceBuffer[0])              {                  float* pfDestBuffer = (float*)pDestBuffer;                    // implement better panning laws.                   float leftVolume = (pan <= 0) ? volume : (volume * (1 - pan) / 2.0f);                  float rightVolume = (pan >= 0) ? volume : (volume * (pan + 1) / 2.0f);                    leftVolume = leftVolume / (float)0xffffffff;;                  rightVolume = rightVolume / (float)0xffffffff;;                  //float leftVolume = (volume * (1 - pan) / 2.0f) / 32768f;                  //float rightVolume = (volume * (pan + 1) / 2.0f) / 32768f;                    int samplesRead = bytesRead / 4;                  //BlockEffects(samplesRead / 2);                  for (int n = 0; n < samplesRead; n += 2)                  {                      int leftBuffer = (pSourceBuffer[n * 4]) | (pSourceBuffer[(n * 4) + 1] << 8) | (pSourceBuffer[(n * 4) + 2] << 16) + (pSourceBuffer[(n * 4) + 3] << 24);                      int rightBuffer = (pSourceBuffer[(n + 1) * 4]) | (pSourceBuffer[(n + 1) * 4 + 1] << 8) | (pSourceBuffer[(n + 1) * 4 + 2] << 16) + (pSourceBuffer[(n + 1) * 4 + 3] << 24);                      pfDestBuffer[n] = leftBuffer * leftVolume;                      pfDestBuffer[n + 1] = rightBuffer * rightVolume;                      //ApplyEffects(ref pfDestBuffer[n]' ref pfDestBuffer[n + 1]);                      if (Sample != null) RaiseSample(pfDestBuffer[n]' pfDestBuffer[n + 1]);                  }              }
Magic Number,NAudio.Wave,WaveChannel32To32,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\NAudio\WaveChannel32To32.cs,AdjustVolume,The following statement contains a magic number: fixed (byte* pDestBuffer = &destBuffer[offset]'                  pSourceBuffer = &sourceBuffer[0])              {                  float* pfDestBuffer = (float*)pDestBuffer;                    // implement better panning laws.                   float leftVolume = (pan <= 0) ? volume : (volume * (1 - pan) / 2.0f);                  float rightVolume = (pan >= 0) ? volume : (volume * (pan + 1) / 2.0f);                    leftVolume = leftVolume / (float)0xffffffff;;                  rightVolume = rightVolume / (float)0xffffffff;;                  //float leftVolume = (volume * (1 - pan) / 2.0f) / 32768f;                  //float rightVolume = (volume * (pan + 1) / 2.0f) / 32768f;                    int samplesRead = bytesRead / 4;                  //BlockEffects(samplesRead / 2);                  for (int n = 0; n < samplesRead; n += 2)                  {                      int leftBuffer = (pSourceBuffer[n * 4]) | (pSourceBuffer[(n * 4) + 1] << 8) | (pSourceBuffer[(n * 4) + 2] << 16) + (pSourceBuffer[(n * 4) + 3] << 24);                      int rightBuffer = (pSourceBuffer[(n + 1) * 4]) | (pSourceBuffer[(n + 1) * 4 + 1] << 8) | (pSourceBuffer[(n + 1) * 4 + 2] << 16) + (pSourceBuffer[(n + 1) * 4 + 3] << 24);                      pfDestBuffer[n] = leftBuffer * leftVolume;                      pfDestBuffer[n + 1] = rightBuffer * rightVolume;                      //ApplyEffects(ref pfDestBuffer[n]' ref pfDestBuffer[n + 1]);                      if (Sample != null) RaiseSample(pfDestBuffer[n]' pfDestBuffer[n + 1]);                  }              }
Magic Number,NAudio.Wave,WaveChannel32To32,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\NAudio\WaveChannel32To32.cs,AdjustVolume,The following statement contains a magic number: fixed (byte* pDestBuffer = &destBuffer[offset]'                  pSourceBuffer = &sourceBuffer[0])              {                  float* pfDestBuffer = (float*)pDestBuffer;                    // implement better panning laws.                   float leftVolume = (pan <= 0) ? volume : (volume * (1 - pan) / 2.0f);                  float rightVolume = (pan >= 0) ? volume : (volume * (pan + 1) / 2.0f);                    leftVolume = leftVolume / (float)0xffffffff;;                  rightVolume = rightVolume / (float)0xffffffff;;                  //float leftVolume = (volume * (1 - pan) / 2.0f) / 32768f;                  //float rightVolume = (volume * (pan + 1) / 2.0f) / 32768f;                    int samplesRead = bytesRead / 4;                  //BlockEffects(samplesRead / 2);                  for (int n = 0; n < samplesRead; n += 2)                  {                      int leftBuffer = (pSourceBuffer[n * 4]) | (pSourceBuffer[(n * 4) + 1] << 8) | (pSourceBuffer[(n * 4) + 2] << 16) + (pSourceBuffer[(n * 4) + 3] << 24);                      int rightBuffer = (pSourceBuffer[(n + 1) * 4]) | (pSourceBuffer[(n + 1) * 4 + 1] << 8) | (pSourceBuffer[(n + 1) * 4 + 2] << 16) + (pSourceBuffer[(n + 1) * 4 + 3] << 24);                      pfDestBuffer[n] = leftBuffer * leftVolume;                      pfDestBuffer[n + 1] = rightBuffer * rightVolume;                      //ApplyEffects(ref pfDestBuffer[n]' ref pfDestBuffer[n + 1]);                      if (Sample != null) RaiseSample(pfDestBuffer[n]' pfDestBuffer[n + 1]);                  }              }
Magic Number,NAudio.Wave,WaveChannel32To32,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\NAudio\WaveChannel32To32.cs,AdjustVolume,The following statement contains a magic number: fixed (byte* pDestBuffer = &destBuffer[offset]'                  pSourceBuffer = &sourceBuffer[0])              {                  float* pfDestBuffer = (float*)pDestBuffer;                    // implement better panning laws.                   float leftVolume = (pan <= 0) ? volume : (volume * (1 - pan) / 2.0f);                  float rightVolume = (pan >= 0) ? volume : (volume * (pan + 1) / 2.0f);                    leftVolume = leftVolume / (float)0xffffffff;;                  rightVolume = rightVolume / (float)0xffffffff;;                  //float leftVolume = (volume * (1 - pan) / 2.0f) / 32768f;                  //float rightVolume = (volume * (pan + 1) / 2.0f) / 32768f;                    int samplesRead = bytesRead / 4;                  //BlockEffects(samplesRead / 2);                  for (int n = 0; n < samplesRead; n += 2)                  {                      int leftBuffer = (pSourceBuffer[n * 4]) | (pSourceBuffer[(n * 4) + 1] << 8) | (pSourceBuffer[(n * 4) + 2] << 16) + (pSourceBuffer[(n * 4) + 3] << 24);                      int rightBuffer = (pSourceBuffer[(n + 1) * 4]) | (pSourceBuffer[(n + 1) * 4 + 1] << 8) | (pSourceBuffer[(n + 1) * 4 + 2] << 16) + (pSourceBuffer[(n + 1) * 4 + 3] << 24);                      pfDestBuffer[n] = leftBuffer * leftVolume;                      pfDestBuffer[n + 1] = rightBuffer * rightVolume;                      //ApplyEffects(ref pfDestBuffer[n]' ref pfDestBuffer[n + 1]);                      if (Sample != null) RaiseSample(pfDestBuffer[n]' pfDestBuffer[n + 1]);                  }              }
Magic Number,NAudio.Wave,WaveChannel32To32,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\NAudio\WaveChannel32To32.cs,AdjustVolume,The following statement contains a magic number: fixed (byte* pDestBuffer = &destBuffer[offset]'                  pSourceBuffer = &sourceBuffer[0])              {                  float* pfDestBuffer = (float*)pDestBuffer;                    // implement better panning laws.                   float leftVolume = (pan <= 0) ? volume : (volume * (1 - pan) / 2.0f);                  float rightVolume = (pan >= 0) ? volume : (volume * (pan + 1) / 2.0f);                    leftVolume = leftVolume / (float)0xffffffff;;                  rightVolume = rightVolume / (float)0xffffffff;;                  //float leftVolume = (volume * (1 - pan) / 2.0f) / 32768f;                  //float rightVolume = (volume * (pan + 1) / 2.0f) / 32768f;                    int samplesRead = bytesRead / 4;                  //BlockEffects(samplesRead / 2);                  for (int n = 0; n < samplesRead; n += 2)                  {                      int leftBuffer = (pSourceBuffer[n * 4]) | (pSourceBuffer[(n * 4) + 1] << 8) | (pSourceBuffer[(n * 4) + 2] << 16) + (pSourceBuffer[(n * 4) + 3] << 24);                      int rightBuffer = (pSourceBuffer[(n + 1) * 4]) | (pSourceBuffer[(n + 1) * 4 + 1] << 8) | (pSourceBuffer[(n + 1) * 4 + 2] << 16) + (pSourceBuffer[(n + 1) * 4 + 3] << 24);                      pfDestBuffer[n] = leftBuffer * leftVolume;                      pfDestBuffer[n + 1] = rightBuffer * rightVolume;                      //ApplyEffects(ref pfDestBuffer[n]' ref pfDestBuffer[n + 1]);                      if (Sample != null) RaiseSample(pfDestBuffer[n]' pfDestBuffer[n + 1]);                  }              }
Magic Number,NAudio.Wave,WaveChannel32To32,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\NAudio\WaveChannel32To32.cs,AdjustVolume,The following statement contains a magic number: fixed (byte* pDestBuffer = &destBuffer[offset]'                  pSourceBuffer = &sourceBuffer[0])              {                  float* pfDestBuffer = (float*)pDestBuffer;                    // implement better panning laws.                   float leftVolume = (pan <= 0) ? volume : (volume * (1 - pan) / 2.0f);                  float rightVolume = (pan >= 0) ? volume : (volume * (pan + 1) / 2.0f);                    leftVolume = leftVolume / (float)0xffffffff;;                  rightVolume = rightVolume / (float)0xffffffff;;                  //float leftVolume = (volume * (1 - pan) / 2.0f) / 32768f;                  //float rightVolume = (volume * (pan + 1) / 2.0f) / 32768f;                    int samplesRead = bytesRead / 4;                  //BlockEffects(samplesRead / 2);                  for (int n = 0; n < samplesRead; n += 2)                  {                      int leftBuffer = (pSourceBuffer[n * 4]) | (pSourceBuffer[(n * 4) + 1] << 8) | (pSourceBuffer[(n * 4) + 2] << 16) + (pSourceBuffer[(n * 4) + 3] << 24);                      int rightBuffer = (pSourceBuffer[(n + 1) * 4]) | (pSourceBuffer[(n + 1) * 4 + 1] << 8) | (pSourceBuffer[(n + 1) * 4 + 2] << 16) + (pSourceBuffer[(n + 1) * 4 + 3] << 24);                      pfDestBuffer[n] = leftBuffer * leftVolume;                      pfDestBuffer[n + 1] = rightBuffer * rightVolume;                      //ApplyEffects(ref pfDestBuffer[n]' ref pfDestBuffer[n + 1]);                      if (Sample != null) RaiseSample(pfDestBuffer[n]' pfDestBuffer[n + 1]);                  }              }
Magic Number,NAudio.Wave,WaveChannel32To32,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\NAudio\WaveChannel32To32.cs,AdjustVolume,The following statement contains a magic number: fixed (byte* pDestBuffer = &destBuffer[offset]'                  pSourceBuffer = &sourceBuffer[0])              {                  float* pfDestBuffer = (float*)pDestBuffer;                    // implement better panning laws.                   float leftVolume = (pan <= 0) ? volume : (volume * (1 - pan) / 2.0f);                  float rightVolume = (pan >= 0) ? volume : (volume * (pan + 1) / 2.0f);                    leftVolume = leftVolume / (float)0xffffffff;;                  rightVolume = rightVolume / (float)0xffffffff;;                  //float leftVolume = (volume * (1 - pan) / 2.0f) / 32768f;                  //float rightVolume = (volume * (pan + 1) / 2.0f) / 32768f;                    int samplesRead = bytesRead / 4;                  //BlockEffects(samplesRead / 2);                  for (int n = 0; n < samplesRead; n += 2)                  {                      int leftBuffer = (pSourceBuffer[n * 4]) | (pSourceBuffer[(n * 4) + 1] << 8) | (pSourceBuffer[(n * 4) + 2] << 16) + (pSourceBuffer[(n * 4) + 3] << 24);                      int rightBuffer = (pSourceBuffer[(n + 1) * 4]) | (pSourceBuffer[(n + 1) * 4 + 1] << 8) | (pSourceBuffer[(n + 1) * 4 + 2] << 16) + (pSourceBuffer[(n + 1) * 4 + 3] << 24);                      pfDestBuffer[n] = leftBuffer * leftVolume;                      pfDestBuffer[n + 1] = rightBuffer * rightVolume;                      //ApplyEffects(ref pfDestBuffer[n]' ref pfDestBuffer[n + 1]);                      if (Sample != null) RaiseSample(pfDestBuffer[n]' pfDestBuffer[n + 1]);                  }              }
Magic Number,NAudio.Wave,WaveChannel32To32,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\NAudio\WaveChannel32To32.cs,AdjustVolume,The following statement contains a magic number: fixed (byte* pDestBuffer = &destBuffer[offset]'                  pSourceBuffer = &sourceBuffer[0])              {                  float* pfDestBuffer = (float*)pDestBuffer;                    // implement better panning laws.                   float leftVolume = (pan <= 0) ? volume : (volume * (1 - pan) / 2.0f);                  float rightVolume = (pan >= 0) ? volume : (volume * (pan + 1) / 2.0f);                    leftVolume = leftVolume / (float)0xffffffff;;                  rightVolume = rightVolume / (float)0xffffffff;;                  //float leftVolume = (volume * (1 - pan) / 2.0f) / 32768f;                  //float rightVolume = (volume * (pan + 1) / 2.0f) / 32768f;                    int samplesRead = bytesRead / 4;                  //BlockEffects(samplesRead / 2);                  for (int n = 0; n < samplesRead; n += 2)                  {                      int leftBuffer = (pSourceBuffer[n * 4]) | (pSourceBuffer[(n * 4) + 1] << 8) | (pSourceBuffer[(n * 4) + 2] << 16) + (pSourceBuffer[(n * 4) + 3] << 24);                      int rightBuffer = (pSourceBuffer[(n + 1) * 4]) | (pSourceBuffer[(n + 1) * 4 + 1] << 8) | (pSourceBuffer[(n + 1) * 4 + 2] << 16) + (pSourceBuffer[(n + 1) * 4 + 3] << 24);                      pfDestBuffer[n] = leftBuffer * leftVolume;                      pfDestBuffer[n + 1] = rightBuffer * rightVolume;                      //ApplyEffects(ref pfDestBuffer[n]' ref pfDestBuffer[n + 1]);                      if (Sample != null) RaiseSample(pfDestBuffer[n]' pfDestBuffer[n + 1]);                  }              }
Magic Number,NAudio.Wave,WaveChannel32To32,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\NAudio\WaveChannel32To32.cs,AdjustVolume,The following statement contains a magic number: fixed (byte* pDestBuffer = &destBuffer[offset]'                  pSourceBuffer = &sourceBuffer[0])              {                  float* pfDestBuffer = (float*)pDestBuffer;                    // implement better panning laws.                   float leftVolume = (pan <= 0) ? volume : (volume * (1 - pan) / 2.0f);                  float rightVolume = (pan >= 0) ? volume : (volume * (pan + 1) / 2.0f);                    leftVolume = leftVolume / (float)0xffffffff;;                  rightVolume = rightVolume / (float)0xffffffff;;                  //float leftVolume = (volume * (1 - pan) / 2.0f) / 32768f;                  //float rightVolume = (volume * (pan + 1) / 2.0f) / 32768f;                    int samplesRead = bytesRead / 4;                  //BlockEffects(samplesRead / 2);                  for (int n = 0; n < samplesRead; n += 2)                  {                      int leftBuffer = (pSourceBuffer[n * 4]) | (pSourceBuffer[(n * 4) + 1] << 8) | (pSourceBuffer[(n * 4) + 2] << 16) + (pSourceBuffer[(n * 4) + 3] << 24);                      int rightBuffer = (pSourceBuffer[(n + 1) * 4]) | (pSourceBuffer[(n + 1) * 4 + 1] << 8) | (pSourceBuffer[(n + 1) * 4 + 2] << 16) + (pSourceBuffer[(n + 1) * 4 + 3] << 24);                      pfDestBuffer[n] = leftBuffer * leftVolume;                      pfDestBuffer[n + 1] = rightBuffer * rightVolume;                      //ApplyEffects(ref pfDestBuffer[n]' ref pfDestBuffer[n + 1]);                      if (Sample != null) RaiseSample(pfDestBuffer[n]' pfDestBuffer[n + 1]);                  }              }
Magic Number,NAudio.Wave,WaveChannel32To32,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\NAudio\WaveChannel32To32.cs,AdjustVolume,The following statement contains a magic number: fixed (byte* pDestBuffer = &destBuffer[offset]'                  pSourceBuffer = &sourceBuffer[0])              {                  float* pfDestBuffer = (float*)pDestBuffer;                    // implement better panning laws.                   float leftVolume = (pan <= 0) ? volume : (volume * (1 - pan) / 2.0f);                  float rightVolume = (pan >= 0) ? volume : (volume * (pan + 1) / 2.0f);                    leftVolume = leftVolume / (float)0xffffffff;;                  rightVolume = rightVolume / (float)0xffffffff;;                  //float leftVolume = (volume * (1 - pan) / 2.0f) / 32768f;                  //float rightVolume = (volume * (pan + 1) / 2.0f) / 32768f;                    int samplesRead = bytesRead / 4;                  //BlockEffects(samplesRead / 2);                  for (int n = 0; n < samplesRead; n += 2)                  {                      int leftBuffer = (pSourceBuffer[n * 4]) | (pSourceBuffer[(n * 4) + 1] << 8) | (pSourceBuffer[(n * 4) + 2] << 16) + (pSourceBuffer[(n * 4) + 3] << 24);                      int rightBuffer = (pSourceBuffer[(n + 1) * 4]) | (pSourceBuffer[(n + 1) * 4 + 1] << 8) | (pSourceBuffer[(n + 1) * 4 + 2] << 16) + (pSourceBuffer[(n + 1) * 4 + 3] << 24);                      pfDestBuffer[n] = leftBuffer * leftVolume;                      pfDestBuffer[n + 1] = rightBuffer * rightVolume;                      //ApplyEffects(ref pfDestBuffer[n]' ref pfDestBuffer[n + 1]);                      if (Sample != null) RaiseSample(pfDestBuffer[n]' pfDestBuffer[n + 1]);                  }              }
Magic Number,NAudio.Wave,WaveChannel32To32,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\NAudio\WaveChannel32To32.cs,AdjustVolume,The following statement contains a magic number: fixed (byte* pDestBuffer = &destBuffer[offset]'                  pSourceBuffer = &sourceBuffer[0])              {                  float* pfDestBuffer = (float*)pDestBuffer;                    // implement better panning laws.                   float leftVolume = (pan <= 0) ? volume : (volume * (1 - pan) / 2.0f);                  float rightVolume = (pan >= 0) ? volume : (volume * (pan + 1) / 2.0f);                    leftVolume = leftVolume / (float)0xffffffff;;                  rightVolume = rightVolume / (float)0xffffffff;;                  //float leftVolume = (volume * (1 - pan) / 2.0f) / 32768f;                  //float rightVolume = (volume * (pan + 1) / 2.0f) / 32768f;                    int samplesRead = bytesRead / 4;                  //BlockEffects(samplesRead / 2);                  for (int n = 0; n < samplesRead; n += 2)                  {                      int leftBuffer = (pSourceBuffer[n * 4]) | (pSourceBuffer[(n * 4) + 1] << 8) | (pSourceBuffer[(n * 4) + 2] << 16) + (pSourceBuffer[(n * 4) + 3] << 24);                      int rightBuffer = (pSourceBuffer[(n + 1) * 4]) | (pSourceBuffer[(n + 1) * 4 + 1] << 8) | (pSourceBuffer[(n + 1) * 4 + 2] << 16) + (pSourceBuffer[(n + 1) * 4 + 3] << 24);                      pfDestBuffer[n] = leftBuffer * leftVolume;                      pfDestBuffer[n + 1] = rightBuffer * rightVolume;                      //ApplyEffects(ref pfDestBuffer[n]' ref pfDestBuffer[n + 1]);                      if (Sample != null) RaiseSample(pfDestBuffer[n]' pfDestBuffer[n + 1]);                  }              }
Magic Number,NAudio.Wave,WaveChannel32To32,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\NAudio\WaveChannel32To32.cs,AdjustVolume,The following statement contains a magic number: fixed (byte* pDestBuffer = &destBuffer[offset]'                  pSourceBuffer = &sourceBuffer[0])              {                  float* pfDestBuffer = (float*)pDestBuffer;                    // implement better panning laws.                   float leftVolume = (pan <= 0) ? volume : (volume * (1 - pan) / 2.0f);                  float rightVolume = (pan >= 0) ? volume : (volume * (pan + 1) / 2.0f);                    leftVolume = leftVolume / (float)0xffffffff;;                  rightVolume = rightVolume / (float)0xffffffff;;                  //float leftVolume = (volume * (1 - pan) / 2.0f) / 32768f;                  //float rightVolume = (volume * (pan + 1) / 2.0f) / 32768f;                    int samplesRead = bytesRead / 4;                  //BlockEffects(samplesRead / 2);                  for (int n = 0; n < samplesRead; n += 2)                  {                      int leftBuffer = (pSourceBuffer[n * 4]) | (pSourceBuffer[(n * 4) + 1] << 8) | (pSourceBuffer[(n * 4) + 2] << 16) + (pSourceBuffer[(n * 4) + 3] << 24);                      int rightBuffer = (pSourceBuffer[(n + 1) * 4]) | (pSourceBuffer[(n + 1) * 4 + 1] << 8) | (pSourceBuffer[(n + 1) * 4 + 2] << 16) + (pSourceBuffer[(n + 1) * 4 + 3] << 24);                      pfDestBuffer[n] = leftBuffer * leftVolume;                      pfDestBuffer[n + 1] = rightBuffer * rightVolume;                      //ApplyEffects(ref pfDestBuffer[n]' ref pfDestBuffer[n + 1]);                      if (Sample != null) RaiseSample(pfDestBuffer[n]' pfDestBuffer[n + 1]);                  }              }
Magic Number,NAudio.Wave,WaveChannel32To32,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\NAudio\WaveChannel32To32.cs,AdjustVolume,The following statement contains a magic number: fixed (byte* pDestBuffer = &destBuffer[offset]'                  pSourceBuffer = &sourceBuffer[0])              {                  float* pfDestBuffer = (float*)pDestBuffer;                    // implement better panning laws.                   float leftVolume = (pan <= 0) ? volume : (volume * (1 - pan) / 2.0f);                  float rightVolume = (pan >= 0) ? volume : (volume * (pan + 1) / 2.0f);                    leftVolume = leftVolume / (float)0xffffffff;;                  rightVolume = rightVolume / (float)0xffffffff;;                  //float leftVolume = (volume * (1 - pan) / 2.0f) / 32768f;                  //float rightVolume = (volume * (pan + 1) / 2.0f) / 32768f;                    int samplesRead = bytesRead / 4;                  //BlockEffects(samplesRead / 2);                  for (int n = 0; n < samplesRead; n += 2)                  {                      int leftBuffer = (pSourceBuffer[n * 4]) | (pSourceBuffer[(n * 4) + 1] << 8) | (pSourceBuffer[(n * 4) + 2] << 16) + (pSourceBuffer[(n * 4) + 3] << 24);                      int rightBuffer = (pSourceBuffer[(n + 1) * 4]) | (pSourceBuffer[(n + 1) * 4 + 1] << 8) | (pSourceBuffer[(n + 1) * 4 + 2] << 16) + (pSourceBuffer[(n + 1) * 4 + 3] << 24);                      pfDestBuffer[n] = leftBuffer * leftVolume;                      pfDestBuffer[n + 1] = rightBuffer * rightVolume;                      //ApplyEffects(ref pfDestBuffer[n]' ref pfDestBuffer[n + 1]);                      if (Sample != null) RaiseSample(pfDestBuffer[n]' pfDestBuffer[n + 1]);                  }              }
Magic Number,NAudio.Wave,WaveChannel32To32,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\NAudio\WaveChannel32To32.cs,AdjustVolume,The following statement contains a magic number: fixed (byte* pDestBuffer = &destBuffer[offset]'                  pSourceBuffer = &sourceBuffer[0])              {                  float* pfDestBuffer = (float*)pDestBuffer;                    // implement better panning laws.                   float leftVolume = (pan <= 0) ? volume : (volume * (1 - pan) / 2.0f);                  float rightVolume = (pan >= 0) ? volume : (volume * (pan + 1) / 2.0f);                    leftVolume = leftVolume / (float)0xffffffff;;                  rightVolume = rightVolume / (float)0xffffffff;;                  //float leftVolume = (volume * (1 - pan) / 2.0f) / 32768f;                  //float rightVolume = (volume * (pan + 1) / 2.0f) / 32768f;                    int samplesRead = bytesRead / 4;                  //BlockEffects(samplesRead / 2);                  for (int n = 0; n < samplesRead; n += 2)                  {                      int leftBuffer = (pSourceBuffer[n * 4]) | (pSourceBuffer[(n * 4) + 1] << 8) | (pSourceBuffer[(n * 4) + 2] << 16) + (pSourceBuffer[(n * 4) + 3] << 24);                      int rightBuffer = (pSourceBuffer[(n + 1) * 4]) | (pSourceBuffer[(n + 1) * 4 + 1] << 8) | (pSourceBuffer[(n + 1) * 4 + 2] << 16) + (pSourceBuffer[(n + 1) * 4 + 3] << 24);                      pfDestBuffer[n] = leftBuffer * leftVolume;                      pfDestBuffer[n + 1] = rightBuffer * rightVolume;                      //ApplyEffects(ref pfDestBuffer[n]' ref pfDestBuffer[n + 1]);                      if (Sample != null) RaiseSample(pfDestBuffer[n]' pfDestBuffer[n + 1]);                  }              }
Magic Number,NAudio.Wave,WaveChannel32To32,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\NAudio\WaveChannel32To32.cs,AdjustVolume,The following statement contains a magic number: fixed (byte* pDestBuffer = &destBuffer[offset]'                  pSourceBuffer = &sourceBuffer[0])              {                  float* pfDestBuffer = (float*)pDestBuffer;                    // implement better panning laws.                   float leftVolume = (pan <= 0) ? volume : (volume * (1 - pan) / 2.0f);                  float rightVolume = (pan >= 0) ? volume : (volume * (pan + 1) / 2.0f);                    leftVolume = leftVolume / (float)0xffffffff;;                  rightVolume = rightVolume / (float)0xffffffff;;                  //float leftVolume = (volume * (1 - pan) / 2.0f) / 32768f;                  //float rightVolume = (volume * (pan + 1) / 2.0f) / 32768f;                    int samplesRead = bytesRead / 4;                  //BlockEffects(samplesRead / 2);                  for (int n = 0; n < samplesRead; n += 2)                  {                      int leftBuffer = (pSourceBuffer[n * 4]) | (pSourceBuffer[(n * 4) + 1] << 8) | (pSourceBuffer[(n * 4) + 2] << 16) + (pSourceBuffer[(n * 4) + 3] << 24);                      int rightBuffer = (pSourceBuffer[(n + 1) * 4]) | (pSourceBuffer[(n + 1) * 4 + 1] << 8) | (pSourceBuffer[(n + 1) * 4 + 2] << 16) + (pSourceBuffer[(n + 1) * 4 + 3] << 24);                      pfDestBuffer[n] = leftBuffer * leftVolume;                      pfDestBuffer[n + 1] = rightBuffer * rightVolume;                      //ApplyEffects(ref pfDestBuffer[n]' ref pfDestBuffer[n + 1]);                      if (Sample != null) RaiseSample(pfDestBuffer[n]' pfDestBuffer[n + 1]);                  }              }
Magic Number,microDrum,Wave32To16Stream,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\NAudio\Wave32To16Stream.cs,Wave32To16Stream,The following statement contains a magic number: if (sourceStream.WaveFormat.BitsPerSample != 32)                  throw new ApplicationException("Only 32 bit Floating point supported");
Magic Number,microDrum,Wave32To16Stream,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\NAudio\Wave32To16Stream.cs,Wave32To16Stream,The following statement contains a magic number: waveFormat = new WaveFormat(sourceStream.WaveFormat.SampleRate' 16' sourceStream.WaveFormat.Channels);
Magic Number,microDrum,Wave32To16Stream,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\NAudio\Wave32To16Stream.cs,Wave32To16Stream,The following statement contains a magic number: length = sourceStream.Length / 2;
Magic Number,microDrum,Wave32To16Stream,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\NAudio\Wave32To16Stream.cs,Wave32To16Stream,The following statement contains a magic number: position = sourceStream.Position / 2;
Magic Number,microDrum,Wave32To16Stream,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\NAudio\Wave32To16Stream.cs,Read,The following statement contains a magic number: byte[] sourceBuffer = new byte[numBytes * 2];
Magic Number,microDrum,Wave32To16Stream,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\NAudio\Wave32To16Stream.cs,Read,The following statement contains a magic number: int bytesRead = sourceStream.Read(sourceBuffer' 0' numBytes * 2);
Magic Number,microDrum,Wave32To16Stream,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\NAudio\Wave32To16Stream.cs,Read,The following statement contains a magic number: position += (bytesRead / 2);
Magic Number,microDrum,Wave32To16Stream,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\NAudio\Wave32To16Stream.cs,Read,The following statement contains a magic number: return bytesRead / 2;
Magic Number,microDrum,Wave32To16Stream,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\NAudio\Wave32To16Stream.cs,Convert32To16,The following statement contains a magic number: fixed (byte* pDestBuffer = &destBuffer[offset]'                  pSourceBuffer = &sourceBuffer[0])              {                  short* psDestBuffer = (short*)pDestBuffer;                  float* pfSourceBuffer = (float*)pSourceBuffer;                    int samplesRead = bytesRead / 4;                  for (int n = 0; n < samplesRead; n++)                  {                      float sampleVal = pfSourceBuffer[n] * volume;                      if (sampleVal > 1.0f)                      {                          psDestBuffer[n] = short.MaxValue;                          clip = true;                      }                      else if (sampleVal < -1.0f)                      {                          psDestBuffer[n] = short.MinValue;                          clip = true;                      }                      else                      {                          psDestBuffer[n] = (short)(sampleVal * 32767);                      }                  }              }
Magic Number,microDrum,Wave32To16Stream,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\NAudio\Wave32To16Stream.cs,Convert32To16,The following statement contains a magic number: fixed (byte* pDestBuffer = &destBuffer[offset]'                  pSourceBuffer = &sourceBuffer[0])              {                  short* psDestBuffer = (short*)pDestBuffer;                  float* pfSourceBuffer = (float*)pSourceBuffer;                    int samplesRead = bytesRead / 4;                  for (int n = 0; n < samplesRead; n++)                  {                      float sampleVal = pfSourceBuffer[n] * volume;                      if (sampleVal > 1.0f)                      {                          psDestBuffer[n] = short.MaxValue;                          clip = true;                      }                      else if (sampleVal < -1.0f)                      {                          psDestBuffer[n] = short.MinValue;                          clip = true;                      }                      else                      {                          psDestBuffer[n] = (short)(sampleVal * 32767);                      }                  }              }
Magic Number,ProcessVSTPlugin2,ProcessVSTPlugin,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\ProcessVSTPlugin.cs,ProcessOffline,The following statement contains a magic number: var buffer = new byte[512*4];
Magic Number,ProcessVSTPlugin2,ProcessVSTPlugin,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\ProcessVSTPlugin.cs,ProcessOffline,The following statement contains a magic number: var buffer = new byte[512*4];
Magic Number,ProcessVSTPlugin2,ProcessVSTPlugin,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\ProcessVSTPlugin.cs,ProcessOffline,The following statement contains a magic number: using (var ms = new MemoryStream())  			{  				vstStream.SetInputWave(waveInputFilePath' volume);  				vstStream.DoProcess = true;  				  				// wait a little while  				Thread.Sleep(1000);  				  				// keep on reading until it stops playing.  				while (!stoppedPlaying)  				{  					int read = vstStream.Read(buffer' 0' buffer.Length);  					if (read <= 0) {  						break;  					}  					ms.Write(buffer' 0' read);  				}  				  				// save  				using (WaveStream ws = new RawSourceWaveStream(ms' vstStream.WaveFormat))  				{  					ws.Position = 0;  					WaveFileWriter.CreateWaveFile(waveOutputFilePath' ws);  				}  			}
Magic Number,ProcessVSTPlugin2,ProcessVSTPlugin,C:\repos\perivar_AudioVSTToolbox\ProcessVSTPlugin2\ProcessVSTPlugin.cs,ProcessRealTime,The following statement contains a magic number: while (!stoppedPlaying)  			{  				Thread.Sleep(50);  			}
