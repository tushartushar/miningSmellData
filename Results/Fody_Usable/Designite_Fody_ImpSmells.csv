Implementation smell,Namespace,Class,File,Method,Description
Long Method,Custom.Decompiler.Ast,AstBuilder,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\AstBuilder.cs,ConvertType,The method has 120 lines of code.
Long Method,Custom.Decompiler.Ast,AstMethodBodyBuilder,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\AstMethodBodyBuilder.cs,TransformNode,The method has 107 lines of code.
Long Method,Custom.Decompiler.Ast,AstMethodBodyBuilder,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\AstMethodBodyBuilder.cs,TransformByteCode,The method has 642 lines of code.
Long Method,Custom.Decompiler.Ast,AstMethodBodyBuilder,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\AstMethodBodyBuilder.cs,TransformCall,The method has 104 lines of code.
Long Method,Custom.Decompiler.Ast.Transforms,DelegateConstruction,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\Transforms\DelegateConstruction.cs,VisitBlockStatement,The method has 133 lines of code.
Long Method,Custom.Decompiler.Ast.Transforms,ExpressionTreeConverter,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\Transforms\ExpressionTreeConverter.cs,Convert,The method has 148 lines of code.
Long Method,Custom.Decompiler.Ast.Transforms,IntroduceQueryExpressions,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\Transforms\IntroduceQueryExpressions.cs,DecompileQuery,The method has 192 lines of code.
Long Method,Custom.Decompiler.Disassembler,ReflectionDisassembler,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Disassembler\ReflectionDisassembler.cs,WriteNativeType,The method has 210 lines of code.
Long Method,Custom.Decompiler.ILAst,AsyncDecompiler,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\AsyncDecompiler.cs,MatchTaskCreationPattern,The method has 101 lines of code.
Long Method,Custom.Decompiler.ILAst,ILAstBuilder,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstBuilder.cs,StackAnalysis,The method has 252 lines of code.
Long Method,Custom.Decompiler.ILAst,ILAstOptimizer,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,Optimize,The method has 175 lines of code.
Long Method,Custom.Decompiler.ILAst,ILCodeUtil,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILCodes.cs,ExpandMacro,The method has 224 lines of code.
Long Method,Custom.Decompiler.ILAst,LoopsAndConditions,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\LoopsAndConditions.cs,FindConditions,The method has 160 lines of code.
Long Method,Custom.Decompiler.ILAst,StateRangeAnalysis,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\StateRange.cs,AssignStateRanges,The method has 103 lines of code.
Long Method,Custom.Decompiler.ILAst,TypeAnalysis,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\TypeAnalysis.cs,DoInferTypeForExpression,The method has 571 lines of code.
Complex Method,Custom.Decompiler.Ast,AstBuilder,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\AstBuilder.cs,CreateType,Cyclomatic complexity of the method is 21
Complex Method,Custom.Decompiler.Ast,AstBuilder,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\AstBuilder.cs,ConvertType,Cyclomatic complexity of the method is 34
Complex Method,Custom.Decompiler.Ast,AstBuilder,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\AstBuilder.cs,ConvertModifiers,Cyclomatic complexity of the method is 9
Complex Method,Custom.Decompiler.Ast,AstBuilder,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\AstBuilder.cs,ConvertModifiers,Cyclomatic complexity of the method is 10
Complex Method,Custom.Decompiler.Ast,AstBuilder,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\AstBuilder.cs,ConvertModifiers,Cyclomatic complexity of the method is 14
Complex Method,Custom.Decompiler.Ast,AstBuilder,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\AstBuilder.cs,AddTypeMembers,Cyclomatic complexity of the method is 10
Complex Method,Custom.Decompiler.Ast,AstBuilder,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\AstBuilder.cs,CreateMethod,Cyclomatic complexity of the method is 11
Complex Method,Custom.Decompiler.Ast,AstBuilder,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\AstBuilder.cs,MakeConstraints,Cyclomatic complexity of the method is 8
Complex Method,Custom.Decompiler.Ast,AstBuilder,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\AstBuilder.cs,CreateProperty,Cyclomatic complexity of the method is 17
Complex Method,Custom.Decompiler.Ast,AstBuilder,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\AstBuilder.cs,MakeParameters,Cyclomatic complexity of the method is 13
Complex Method,Custom.Decompiler.Ast,AstBuilder,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\AstBuilder.cs,ConvertAttributes,Cyclomatic complexity of the method is 20
Complex Method,Custom.Decompiler.Ast,AstBuilder,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\AstBuilder.cs,ConvertAttributes,Cyclomatic complexity of the method is 38
Complex Method,Custom.Decompiler.Ast,AstBuilder,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\AstBuilder.cs,ConvertMarshalInfo,Cyclomatic complexity of the method is 11
Complex Method,Custom.Decompiler.Ast,AstBuilder,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\AstBuilder.cs,ConvertCustomAttributes,Cyclomatic complexity of the method is 18
Complex Method,Custom.Decompiler.Ast,AstBuilder,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\AstBuilder.cs,ConvertSecurityAttributes,Cyclomatic complexity of the method is 11
Complex Method,Custom.Decompiler.Ast,AstBuilder,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\AstBuilder.cs,MakePrimitive,Cyclomatic complexity of the method is 27
Complex Method,Custom.Decompiler.Ast,AstMethodBodyBuilder,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\AstMethodBodyBuilder.cs,TransformNode,Cyclomatic complexity of the method is 20
Complex Method,Custom.Decompiler.Ast,AstMethodBodyBuilder,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\AstMethodBodyBuilder.cs,TransformByteCode,Cyclomatic complexity of the method is 251
Complex Method,Custom.Decompiler.Ast,AstMethodBodyBuilder,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\AstMethodBodyBuilder.cs,DivideBySize,Cyclomatic complexity of the method is 17
Complex Method,Custom.Decompiler.Ast,AstMethodBodyBuilder,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\AstMethodBodyBuilder.cs,TransformCall,Cyclomatic complexity of the method is 26
Complex Method,Custom.Decompiler.Ast,AstMethodBodyBuilder,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\AstMethodBodyBuilder.cs,FormatByteCodeOperand,Cyclomatic complexity of the method is 9
Complex Method,Custom.Decompiler.Ast,AstMethodBodyBuilder,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\AstMethodBodyBuilder.cs,Convert,Cyclomatic complexity of the method is 9
Complex Method,Custom.Decompiler.Ast,NameVariables,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\NameVariables.cs,AssignNamesToVariables,Cyclomatic complexity of the method is 13
Complex Method,Custom.Decompiler.Ast,NameVariables,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\NameVariables.cs,GenerateNameForVariable,Cyclomatic complexity of the method is 27
Complex Method,Custom.Decompiler.Ast,NameVariables,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\NameVariables.cs,GetNameFromExpression,Cyclomatic complexity of the method is 11
Complex Method,Custom.Decompiler.Ast,NameVariables,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\NameVariables.cs,GetNameForArgument,Cyclomatic complexity of the method is 20
Complex Method,Custom.Decompiler.Ast,TextOutputFormatter,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\TextOutputFormatter.cs,WriteComment,Cyclomatic complexity of the method is 22
Complex Method,Custom.Decompiler.Ast,TypesHierarchyHelpers,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\TypesHierarchyHelpers.cs,FindBaseMethods,Cyclomatic complexity of the method is 8
Complex Method,Custom.Decompiler.Ast,TypesHierarchyHelpers,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\TypesHierarchyHelpers.cs,FindBaseProperties,Cyclomatic complexity of the method is 10
Complex Method,Custom.Decompiler.Ast,TypesHierarchyHelpers,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\TypesHierarchyHelpers.cs,FindBaseEvents,Cyclomatic complexity of the method is 8
Complex Method,Custom.Decompiler,CecilExtensions,F:\newReposMay17\Fody_Usable\Fody\Decompiler\CecilExtensions.cs,GetPushDelta,Cyclomatic complexity of the method is 12
Complex Method,Custom.Decompiler,CecilExtensions,F:\newReposMay17\Fody_Usable\Fody\Decompiler\CecilExtensions.cs,GetPopDelta,Cyclomatic complexity of the method is 29
Complex Method,Custom.Decompiler,CecilExtensions,F:\newReposMay17\Fody_Usable\Fody\Decompiler\CecilExtensions.cs,GetAccessorMethods,Cyclomatic complexity of the method is 9
Complex Method,Custom.Decompiler.Ast.Transforms,AddCheckedBlocks,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\Transforms\AddCheckedBlocks.cs,GetResult,Cyclomatic complexity of the method is 12
Complex Method,Custom.Decompiler.Ast.Transforms,ConvertConstructorCallIntoInitializer,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\Transforms\ConvertConstructorCallIntoInitializer.cs,HandleInstanceFieldInitializers,Cyclomatic complexity of the method is 12
Complex Method,Custom.Decompiler.Ast.Transforms,ConvertConstructorCallIntoInitializer,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\Transforms\ConvertConstructorCallIntoInitializer.cs,HandleStaticFieldInitializers,Cyclomatic complexity of the method is 9
Complex Method,Custom.Decompiler.Ast.Transforms,DeclareVariables,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\Transforms\DeclareVariables.cs,DeclareVariableInBlock,Cyclomatic complexity of the method is 13
Complex Method,Custom.Decompiler.Ast.Transforms,DeclareVariables,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\Transforms\DeclareVariables.cs,CanMoveVariableUseIntoSubBlock,Cyclomatic complexity of the method is 12
Complex Method,Custom.Decompiler.Ast.Transforms,DeclareVariables,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\Transforms\DeclareVariables.cs,UsesVariable,Cyclomatic complexity of the method is 9
Complex Method,Custom.Decompiler.Ast.Transforms,DelegateConstruction,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\Transforms\DelegateConstruction.cs,VisitObjectCreateExpression,Cyclomatic complexity of the method is 11
Complex Method,Custom.Decompiler.Ast.Transforms,DelegateConstruction,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\Transforms\DelegateConstruction.cs,HandleAnonymousMethod,Cyclomatic complexity of the method is 8
Complex Method,Custom.Decompiler.Ast.Transforms,DelegateConstruction,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\Transforms\DelegateConstruction.cs,VisitBlockStatement,Cyclomatic complexity of the method is 29
Complex Method,Custom.Decompiler.Ast.Transforms,DelegateConstruction,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\Transforms\DelegateConstruction.cs,EnsureVariableNameIsAvailable,Cyclomatic complexity of the method is 14
Complex Method,Custom.Decompiler.Ast.Transforms,ExpressionTreeConverter,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\Transforms\ExpressionTreeConverter.cs,Convert,Cyclomatic complexity of the method is 66
Complex Method,Custom.Decompiler.Ast.Transforms,ExpressionTreeConverter,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\Transforms\ExpressionTreeConverter.cs,ConvertCall,Cyclomatic complexity of the method is 10
Complex Method,Custom.Decompiler.Ast.Transforms,ExpressionTreeConverter,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\Transforms\ExpressionTreeConverter.cs,ConvertBinaryOperator,Cyclomatic complexity of the method is 8
Complex Method,Custom.Decompiler.Ast.Transforms,ExpressionTreeConverter,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\Transforms\ExpressionTreeConverter.cs,ConvertMemberBindings,Cyclomatic complexity of the method is 12
Complex Method,Custom.Decompiler.Ast.Transforms,IntroduceExtensionMethods,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\Transforms\IntroduceExtensionMethods.cs,Run,Cyclomatic complexity of the method is 8
Complex Method,Custom.Decompiler.Ast.Transforms,IntroduceQueryExpressions,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\Transforms\IntroduceQueryExpressions.cs,DecompileQuery,Cyclomatic complexity of the method is 31
Complex Method,Custom.Decompiler.Ast.Transforms,PatternStatementTransform,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\Transforms\PatternStatementTransform.cs,TransformForeach,Cyclomatic complexity of the method is 8
Complex Method,Custom.Decompiler.Ast.Transforms,PatternStatementTransform,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\Transforms\PatternStatementTransform.cs,TransformSwitchOnString,Cyclomatic complexity of the method is 10
Complex Method,Custom.Decompiler.Ast.Transforms,PushNegation,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\Transforms\PushNegation.cs,VisitUnaryOperatorExpression,Cyclomatic complexity of the method is 33
Complex Method,Custom.Decompiler.Ast.Transforms,ReplaceMethodCallsWithOperators,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\Transforms\ReplaceMethodCallsWithOperators.cs,ProcessInvocationExpression,Cyclomatic complexity of the method is 24
Complex Method,Custom.Decompiler.Ast.Transforms,ReplaceMethodCallsWithOperators,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\Transforms\ReplaceMethodCallsWithOperators.cs,GetBinaryOperatorTypeFromMetadataName,Cyclomatic complexity of the method is 17
Complex Method,Custom.Decompiler.Ast.Transforms,ReplaceMethodCallsWithOperators,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\Transforms\ReplaceMethodCallsWithOperators.cs,VisitAssignmentExpression,Cyclomatic complexity of the method is 8
Complex Method,Custom.Decompiler.Ast.Transforms,ReplaceMethodCallsWithOperators,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\Transforms\ReplaceMethodCallsWithOperators.cs,GetAssignmentOperatorForBinaryOperator,Cyclomatic complexity of the method is 11
Complex Method,Custom.Decompiler.Disassembler,DisassemblerHelpers,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Disassembler\DisassemblerHelpers.cs,WriteTo,Cyclomatic complexity of the method is 10
Complex Method,Custom.Decompiler.Disassembler,DisassemblerHelpers,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Disassembler\DisassemblerHelpers.cs,WriteTo,Cyclomatic complexity of the method is 19
Complex Method,Custom.Decompiler.Disassembler,DisassemblerHelpers,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Disassembler\DisassemblerHelpers.cs,WriteOperand,Cyclomatic complexity of the method is 26
Complex Method,Custom.Decompiler.Disassembler,DisassemblerHelpers,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Disassembler\DisassemblerHelpers.cs,PrimitiveTypeName,Cyclomatic complexity of the method is 17
Complex Method,Custom.Decompiler.Disassembler,ILStructure,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Disassembler\ILStructure.cs,ILStructure,Cyclomatic complexity of the method is 13
Complex Method,Custom.Decompiler.Disassembler,ILStructure,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Disassembler\ILStructure.cs,FindAllBranches,Cyclomatic complexity of the method is 10
Complex Method,Custom.Decompiler.Disassembler,MethodBodyDisassembler,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Disassembler\MethodBodyDisassembler.cs,Disassemble,Cyclomatic complexity of the method is 12
Complex Method,Custom.Decompiler.Disassembler,MethodBodyDisassembler,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Disassembler\MethodBodyDisassembler.cs,WriteStructureHeader,Cyclomatic complexity of the method is 20
Complex Method,Custom.Decompiler.Disassembler,MethodBodyDisassembler,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Disassembler\MethodBodyDisassembler.cs,WriteStructureFooter,Cyclomatic complexity of the method is 14
Complex Method,Custom.Decompiler.Disassembler,ReflectionDisassembler,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Disassembler\ReflectionDisassembler.cs,DisassembleMethodInternal,Cyclomatic complexity of the method is 25
Complex Method,Custom.Decompiler.Disassembler,ReflectionDisassembler,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Disassembler\ReflectionDisassembler.cs,WriteSecurityDeclarations,Cyclomatic complexity of the method is 55
Complex Method,Custom.Decompiler.Disassembler,ReflectionDisassembler,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Disassembler\ReflectionDisassembler.cs,WriteNativeType,Cyclomatic complexity of the method is 192
Complex Method,Custom.Decompiler.Disassembler,ReflectionDisassembler,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Disassembler\ReflectionDisassembler.cs,DisassembleType,Cyclomatic complexity of the method is 18
Complex Method,Custom.Decompiler.Disassembler,ReflectionDisassembler,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Disassembler\ReflectionDisassembler.cs,WriteTypeParameters,Cyclomatic complexity of the method is 12
Complex Method,Custom.Decompiler.FlowAnalysis,ControlFlowGraph,F:\newReposMay17\Fody_Usable\Fody\Decompiler\FlowAnalysis\ControlFlowGraph.cs,ExportGraph,Cyclomatic complexity of the method is 13
Complex Method,Custom.Decompiler.FlowAnalysis,ControlFlowGraphBuilder,F:\newReposMay17\Fody_Usable\Fody\Decompiler\FlowAnalysis\ControlFlowGraphBuilder.cs,CalculateHasIncomingJumps,Cyclomatic complexity of the method is 8
Complex Method,Custom.Decompiler.FlowAnalysis,ControlFlowGraphBuilder,F:\newReposMay17\Fody_Usable\Fody\Decompiler\FlowAnalysis\ControlFlowGraphBuilder.cs,CreateNodes,Cyclomatic complexity of the method is 10
Complex Method,Custom.Decompiler.FlowAnalysis,ControlFlowGraphBuilder,F:\newReposMay17\Fody_Usable\Fody\Decompiler\FlowAnalysis\ControlFlowGraphBuilder.cs,CreateRegularControlFlow,Cyclomatic complexity of the method is 21
Complex Method,Custom.Decompiler.FlowAnalysis,ControlFlowGraphBuilder,F:\newReposMay17\Fody_Usable\Fody\Decompiler\FlowAnalysis\ControlFlowGraphBuilder.cs,IsBranch,Cyclomatic complexity of the method is 8
Complex Method,Custom.Decompiler.FlowAnalysis,ControlFlowNode,F:\newReposMay17\Fody_Usable\Fody\Decompiler\FlowAnalysis\ControlFlowNode.cs,ToString,Cyclomatic complexity of the method is 18
Complex Method,Custom.Decompiler.FlowAnalysis,ControlStructureDetector,F:\newReposMay17\Fody_Usable\Fody\Decompiler\FlowAnalysis\ControlStructureDetector.cs,FindLoops,Cyclomatic complexity of the method is 8
Complex Method,Custom.Decompiler.FlowAnalysis,OpCodeInfo,F:\newReposMay17\Fody_Usable\Fody\Decompiler\FlowAnalysis\OpCodeInfo.cs,IsUnconditionalBranch,Cyclomatic complexity of the method is 8
Complex Method,Custom.Decompiler.FlowAnalysis,SimplifyByRefCalls,F:\newReposMay17\Fody_Usable\Fody\Decompiler\FlowAnalysis\SimplifyByRefCalls.cs,MakeByRefCallsSimple,Cyclomatic complexity of the method is 14
Complex Method,Custom.Decompiler.FlowAnalysis,SsaForm,F:\newReposMay17\Fody_Usable\Fody\Decompiler\FlowAnalysis\SsaForm.cs,ExportVariableGraph,Cyclomatic complexity of the method is 9
Complex Method,Custom.Decompiler.FlowAnalysis,SsaForm,F:\newReposMay17\Fody_Usable\Fody\Decompiler\FlowAnalysis\SsaForm.cs,ComputeVariableUsage,Cyclomatic complexity of the method is 11
Complex Method,Custom.Decompiler.FlowAnalysis,SsaFormBuilder,F:\newReposMay17\Fody_Usable\Fody\Decompiler\FlowAnalysis\SsaFormBuilder.cs,SsaFormBuilder,Cyclomatic complexity of the method is 8
Complex Method,Custom.Decompiler.FlowAnalysis,SsaFormBuilder,F:\newReposMay17\Fody_Usable\Fody\Decompiler\FlowAnalysis\SsaFormBuilder.cs,CreateInstructions,Cyclomatic complexity of the method is 21
Complex Method,Custom.Decompiler.FlowAnalysis,SsaFormBuilder,F:\newReposMay17\Fody_Usable\Fody\Decompiler\FlowAnalysis\SsaFormBuilder.cs,DetermineOperands,Cyclomatic complexity of the method is 26
Complex Method,Custom.Decompiler.FlowAnalysis,SsaInstruction,F:\newReposMay17\Fody_Usable\Fody\Decompiler\FlowAnalysis\SsaInstruction.cs,WriteTo,Cyclomatic complexity of the method is 12
Complex Method,Custom.Decompiler.FlowAnalysis,SsaOptimization,F:\newReposMay17\Fody_Usable\Fody\Decompiler\FlowAnalysis\SsaOptimization.cs,RemoveDeadAssignments,Cyclomatic complexity of the method is 11
Complex Method,Custom.Decompiler.FlowAnalysis,TransformToSsa,F:\newReposMay17\Fody_Usable\Fody\Decompiler\FlowAnalysis\TransformToSsa.cs,CollectInformationAboutOriginalVariableUse,Cyclomatic complexity of the method is 10
Complex Method,Custom.Decompiler.FlowAnalysis,TransformToSsa,F:\newReposMay17\Fody_Usable\Fody\Decompiler\FlowAnalysis\TransformToSsa.cs,PlacePhiFunctions,Cyclomatic complexity of the method is 8
Complex Method,Custom.Decompiler.ILAst,AsyncDecompiler,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\AsyncDecompiler.cs,MatchTaskCreationPattern,Cyclomatic complexity of the method is 12
Complex Method,Custom.Decompiler.ILAst,AsyncDecompiler,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\AsyncDecompiler.cs,AnalyzeMoveNext,Cyclomatic complexity of the method is 11
Complex Method,Custom.Decompiler.ILAst,AsyncDecompiler,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\AsyncDecompiler.cs,HandleAwait,Cyclomatic complexity of the method is 11
Complex Method,Custom.Decompiler.ILAst,AsyncDecompiler,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\AsyncDecompiler.cs,Step2,Cyclomatic complexity of the method is 13
Complex Method,Custom.Decompiler.ILAst,GotoRemoval,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\GotoRemoval.cs,RemoveGotos,Cyclomatic complexity of the method is 8
Complex Method,Custom.Decompiler.ILAst,GotoRemoval,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\GotoRemoval.cs,RemoveRedundantCode,Cyclomatic complexity of the method is 14
Complex Method,Custom.Decompiler.ILAst,GotoRemoval,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\GotoRemoval.cs,Enter,Cyclomatic complexity of the method is 23
Complex Method,Custom.Decompiler.ILAst,GotoRemoval,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\GotoRemoval.cs,Exit,Cyclomatic complexity of the method is 8
Complex Method,Custom.Decompiler.ILAst,ILAstBuilder,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstBuilder.cs,StackAnalysis,Cyclomatic complexity of the method is 45
Complex Method,Custom.Decompiler.ILAst,ILAstBuilder,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstBuilder.cs,ConvertLocalVariables,Cyclomatic complexity of the method is 8
Complex Method,Custom.Decompiler.ILAst,ILAstBuilder,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstBuilder.cs,ConvertParameters,Cyclomatic complexity of the method is 20
Complex Method,Custom.Decompiler.ILAst,ILAstBuilder,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstBuilder.cs,ConvertToAst,Cyclomatic complexity of the method is 21
Complex Method,Custom.Decompiler.ILAst,ILAstBuilder,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstBuilder.cs,ConvertToAst,Cyclomatic complexity of the method is 10
Complex Method,Custom.Decompiler.ILAst,ILAstOptimizer,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,Optimize,Cyclomatic complexity of the method is 16
Complex Method,Custom.Decompiler.ILAst,ILAstOptimizer,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,RemoveRedundantCode,Cyclomatic complexity of the method is 17
Complex Method,Custom.Decompiler.ILAst,ILAstOptimizer,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,ReduceBranchInstructionSet,Cyclomatic complexity of the method is 42
Complex Method,Custom.Decompiler.ILAst,ILAstOptimizer,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,IntroducePropertyAccessInstructions,Cyclomatic complexity of the method is 23
Complex Method,Custom.Decompiler.ILAst,ILAstOptimizer,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,DuplicateReturnStatements,Cyclomatic complexity of the method is 14
Complex Method,Custom.Decompiler.ILAst,ILAstOptimizer,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,FlattenBasicBlocks,Cyclomatic complexity of the method is 9
Complex Method,Custom.Decompiler.ILAst,ILAstOptimizer,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,ReduceIfNesting,Cyclomatic complexity of the method is 9
Complex Method,Custom.Decompiler.ILAst,ILAstOptimizer,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,ReplaceVariables,Cyclomatic complexity of the method is 8
Complex Method,Custom.Decompiler.ILAst,ILAstOptimizer,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,TransformArrayInitializers,Cyclomatic complexity of the method is 8
Complex Method,Custom.Decompiler.ILAst,ILAstOptimizer,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,DecodeArrayInitializer,Cyclomatic complexity of the method is 16
Complex Method,Custom.Decompiler.ILAst,ILAstOptimizer,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,LoadCodeFor,Cyclomatic complexity of the method is 14
Complex Method,Custom.Decompiler.ILAst,ILAstOptimizer,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,ElementSizeOf,Cyclomatic complexity of the method is 14
Complex Method,Custom.Decompiler.ILAst,ILAstOptimizer,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,TransformObjectInitializers,Cyclomatic complexity of the method is 8
Complex Method,Custom.Decompiler.ILAst,ILAstOptimizer,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,AdjustInitializerStack,Cyclomatic complexity of the method is 12
Complex Method,Custom.Decompiler.ILAst,ILAstOptimizer,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,SimplifyLdObjAndStObj,Cyclomatic complexity of the method is 29
Complex Method,Custom.Decompiler.ILAst,ILAstOptimizer,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,StoreCanBeConvertedToAssignment,Cyclomatic complexity of the method is 10
Complex Method,Custom.Decompiler.ILAst,ILAstOptimizer,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,MakeCompoundAssignment,Cyclomatic complexity of the method is 20
Complex Method,Custom.Decompiler.ILAst,ILAstOptimizer,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,CanBeRepresentedAsCompoundAssignment,Cyclomatic complexity of the method is 24
Complex Method,Custom.Decompiler.ILAst,ILAstOptimizer,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,IntroducePostIncrementForVariables,Cyclomatic complexity of the method is 26
Complex Method,Custom.Decompiler.ILAst,ILAstOptimizer,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,IntroducePostIncrementForInstanceFields,Cyclomatic complexity of the method is 10
Complex Method,Custom.Decompiler.ILAst,ILAstOptimizer,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,GetIncrementCode,Cyclomatic complexity of the method is 26
Complex Method,Custom.Decompiler.ILAst,ILAstOptimizer,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,IntroduceFixedStatements,Cyclomatic complexity of the method is 8
Complex Method,Custom.Decompiler.ILAst,ILAstOptimizer,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,MatchFixedInitializer,Cyclomatic complexity of the method is 9
Complex Method,Custom.Decompiler.ILAst,ILAstOptimizer,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,SimplifyLogicNotArgument,Cyclomatic complexity of the method is 31
Complex Method,Custom.Decompiler.ILAst,ILAstOptimizer,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,SimplifyShiftOperators,Cyclomatic complexity of the method is 11
Complex Method,Custom.Decompiler.ILAst,ILAstOptimizerExtensionMethods,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,HasNoSideEffects,Cyclomatic complexity of the method is 10
Complex Method,Custom.Decompiler.ILAst,ILAstOptimizerExtensionMethods,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,IsStoreToArray,Cyclomatic complexity of the method is 10
Complex Method,Custom.Decompiler.ILAst,ILAstOptimizerExtensionMethods,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,IsLoadFromArray,Cyclomatic complexity of the method is 13
Complex Method,Custom.Decompiler.ILAst,ILAstOptimizerExtensionMethods,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,CanBeExpressionStatement,Cyclomatic complexity of the method is 22
Complex Method,Custom.Decompiler.ILAst,ILRange,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstTypes.cs,Invert,Cyclomatic complexity of the method is 8
Complex Method,Custom.Decompiler.ILAst,ILExpression,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstTypes.cs,WriteTo,Cyclomatic complexity of the method is 21
Complex Method,Custom.Decompiler.ILAst,ILCodeUtil,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILCodes.cs,IsConditionalControlFlow,Cyclomatic complexity of the method is 26
Complex Method,Custom.Decompiler.ILAst,ILCodeUtil,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILCodes.cs,IsUnconditionalControlFlow,Cyclomatic complexity of the method is 13
Complex Method,Custom.Decompiler.ILAst,ILCodeUtil,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILCodes.cs,ExpandMacro,Cyclomatic complexity of the method is 220
Complex Method,Custom.Decompiler.ILAst,ILInlining,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILInlining.cs,AnalyzeNode,Cyclomatic complexity of the method is 11
Complex Method,Custom.Decompiler.ILAst,ILInlining,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILInlining.cs,InlineAllInBlock,Cyclomatic complexity of the method is 8
Complex Method,Custom.Decompiler.ILAst,ILInlining,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILInlining.cs,IsGeneratedValueTypeTemporary,Cyclomatic complexity of the method is 51
Complex Method,Custom.Decompiler.ILAst,ILInlining,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILInlining.cs,IsSafeForInlineOver,Cyclomatic complexity of the method is 16
Complex Method,Custom.Decompiler.ILAst,ILInlining,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILInlining.cs,CopyPropagation,Cyclomatic complexity of the method is 9
Complex Method,Custom.Decompiler.ILAst,ILInlining,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILInlining.cs,CanPerformCopyPropagation,Cyclomatic complexity of the method is 9
Complex Method,Custom.Decompiler.ILAst,LoopsAndConditions,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\LoopsAndConditions.cs,FindLoops,Cyclomatic complexity of the method is 10
Complex Method,Custom.Decompiler.ILAst,LoopsAndConditions,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\LoopsAndConditions.cs,FindConditions,Cyclomatic complexity of the method is 20
Complex Method,Custom.Decompiler.ILAst,SimpleControlFlow,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\SimpleControlFlow.cs,SimplifyTernaryOperator,Cyclomatic complexity of the method is 9
Complex Method,Custom.Decompiler.ILAst,StateRangeAnalysis,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\StateRange.cs,AssignStateRanges,Cyclomatic complexity of the method is 35
Complex Method,Custom.Decompiler.ILAst,SymbolicEvaluationContext,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\SymbolicExecution.cs,Eval,Cyclomatic complexity of the method is 19
Complex Method,Custom.Decompiler.ILAst,TypeAnalysis,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\TypeAnalysis.cs,RunInference,Cyclomatic complexity of the method is 14
Complex Method,Custom.Decompiler.ILAst,TypeAnalysis,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\TypeAnalysis.cs,DoInferTypeForExpression,Cyclomatic complexity of the method is 295
Complex Method,Custom.Decompiler.ILAst,TypeAnalysis,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\TypeAnalysis.cs,SubstituteTypeArgs,Cyclomatic complexity of the method is 15
Complex Method,Custom.Decompiler.ILAst,TypeAnalysis,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\TypeAnalysis.cs,GetInformationAmount,Cyclomatic complexity of the method is 16
Complex Method,Custom.Decompiler.ILAst,TypeAnalysis,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\TypeAnalysis.cs,IsSigned,Cyclomatic complexity of the method is 12
Complex Method,Custom.Decompiler.ILAst,TypeAnalysis,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\TypeAnalysis.cs,GetTypeCode,Cyclomatic complexity of the method is 14
Complex Method,Custom.Decompiler.ILAst,YieldReturnDecompiler,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\YieldReturnDecompiler.cs,AnalyzeMoveNext,Cyclomatic complexity of the method is 19
Complex Method,Custom.Decompiler.ILAst,YieldReturnDecompiler,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\YieldReturnDecompiler.cs,ConvertBody,Cyclomatic complexity of the method is 20
Complex Method,Custom.Decompiler.ILAst,YieldReturnDecompiler,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\YieldReturnDecompiler.cs,TranslateFieldsToLocalAccess,Cyclomatic complexity of the method is 18
Long Parameter List,Custom.Decompiler.Ast.Transforms,DeclareVariables,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\Transforms\DeclareVariables.cs,DeclareVariableInBlock,The method has 6 parameters.
Long Parameter List,Custom.Decompiler.Ast.Transforms,DeclareVariables,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\Transforms\DeclareVariables.cs,FindDeclarationPoint,The method has 5 parameters.
Long Parameter List,Custom.Decompiler.Disassembler,MethodBodyDisassembler,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Disassembler\MethodBodyDisassembler.cs,WriteStructureBody,The method has 5 parameters.
Long Parameter List,Custom.Decompiler.FlowAnalysis,SsaForm,F:\newReposMay17\Fody_Usable\Fody\Decompiler\FlowAnalysis\SsaForm.cs,SsaForm,The method has 5 parameters.
Long Parameter List,Custom.Decompiler.FlowAnalysis,SsaFormBuilder,F:\newReposMay17\Fody_Usable\Fody\Decompiler\FlowAnalysis\SsaFormBuilder.cs,DetermineOperands,The method has 6 parameters.
Long Parameter List,Custom.Decompiler.FlowAnalysis,SsaInstruction,F:\newReposMay17\Fody_Usable\Fody\Decompiler\FlowAnalysis\SsaInstruction.cs,SsaInstruction,The method has 7 parameters.
Long Parameter List,Custom.Decompiler.ILAst,ILAstOptimizer,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,ForwardScanInitializeArrayRuntimeHelper,The method has 7 parameters.
Long Parameter List,Custom.Decompiler.ILAst,ILAstOptimizer,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,ParseObjectInitializer,The method has 6 parameters.
Long Parameter List,Custom.Decompiler.ILAst,ILAstOptimizer,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,AdjustInitializerStack,The method has 5 parameters.
Long Parameter List,Custom.Decompiler.ILAst,ILAstOptimizer,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,MatchFixedInitializer,The method has 5 parameters.
Long Parameter List,Custom.Decompiler.ILAst,ILInlining,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILInlining.cs,IsGeneratedValueTypeTemporary,The method has 5 parameters.
Long Parameter List,Custom.Decompiler.ILAst,ILInlining,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILInlining.cs,FindLoadInNext,The method has 5 parameters.
Long Parameter List,Custom.Decompiler.ILAst,PatternMatching,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\PatternMatching.cs,Match,The method has 5 parameters.
Long Parameter List,Custom.Decompiler.ILAst,PatternMatching,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\PatternMatching.cs,MatchSingleAndBr,The method has 5 parameters.
Long Parameter List,Custom.Decompiler.ILAst,PatternMatching,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\PatternMatching.cs,MatchLastAndBr,The method has 5 parameters.
Long Parameter List,Custom.Decompiler.ILAst,StateRangeAnalysis,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\StateRange.cs,CreateLabelRangeMapping,The method has 5 parameters.
Long Parameter List,Custom.Decompiler.ILAst,TypeAnalysis,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\TypeAnalysis.cs,HandleConversion,The method has 5 parameters.
Long Parameter List,Custom.Decompiler.ILAst,TypeAnalysis,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\TypeAnalysis.cs,InferBinaryArguments,The method has 6 parameters.
Long Identifier,Custom.Decompiler.Ast.Transforms,AddCheckedBlocks,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\Transforms\AddCheckedBlocks.cs,GetResultFromBlock,The length of the parameter costCheckedContextUncheckedBlockOpen is 36.
Long Identifier,Custom.Decompiler.Ast.Transforms,AddCheckedBlocks,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\Transforms\AddCheckedBlocks.cs,GetResultFromBlock,The length of the parameter nodesCheckedContextUncheckedBlockOpen is 37.
Long Identifier,Custom.Decompiler.Ast.Transforms,AddCheckedBlocks,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\Transforms\AddCheckedBlocks.cs,GetResultFromBlock,The length of the parameter costUncheckedContextCheckedBlockOpen is 36.
Long Identifier,Custom.Decompiler.Ast.Transforms,AddCheckedBlocks,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\Transforms\AddCheckedBlocks.cs,GetResultFromBlock,The length of the parameter nodesUncheckedContextCheckedBlockOpen is 37.
Long Identifier,Custom.Decompiler.Ast.Transforms,ConvertConstructorCallIntoInitializer,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\Transforms\ConvertConstructorCallIntoInitializer.cs,HandleInstanceFieldInitializers,The length of the parameter instanceCtorsNotChainingWithThis is 32.
Long Identifier,Custom.Decompiler.Ast.Transforms,DelegateConstruction,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\Transforms\DelegateConstruction.cs,HandleAnonymousMethod,The length of the parameter parameterReferencingIdentifiers is 31.
Long Identifier,Custom.Decompiler.Ast.Transforms,DelegateConstruction,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\Transforms\DelegateConstruction.cs,VisitBlockStatement,The length of the parameter isDisplayClassParentPointerAssignment is 37.
Long Identifier,Custom.Decompiler.ILAst,AsyncDecompiler,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\AsyncDecompiler.cs,MatchTaskCreationPattern,The length of the parameter loadStateMachineForBuilderExpr is 30.
Long Identifier,Custom.Decompiler.ILAst,AsyncDecompiler,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\AsyncDecompiler.cs,MatchTaskCreationPattern,The length of the parameter loadStateMachineForBuilderExpr2 is 31.
Long Identifier,Custom.Decompiler.ILAst,ILAstOptimizer,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,TransformArrayInitializers,The length of the parameter maxConsecutiveDefaultValueExpressions is 37.
Long Identifier,Custom.Decompiler.ILAst,TypeAnalysis,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\TypeAnalysis.cs,RunInference,The length of the parameter numberOfExpressionsAlreadyInferred is 34.
Long Identifier,Custom.Decompiler.ILAst,TypeAnalysis,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\TypeAnalysis.cs,RunInference,The length of the parameter assignVariableTypesBasedOnPartialInformation is 44.
Long Identifier,Custom.Decompiler.ILAst,TypeAnalysis,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\TypeAnalysis.cs,RunInference,The length of the parameter anyArgumentIsMissingExpectedType is 32.
Long Statement,Custom.Decompiler.Ast,AstBuilder,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\AstBuilder.cs,IsAnonymousMethodCacheField,The length of the statement  "	return field.Name.StartsWith ("CS$<>"' StringComparison.Ordinal) || field.Name.StartsWith ("<>f__am"' StringComparison.Ordinal); " is 128.
Long Statement,Custom.Decompiler.Ast,AstBuilder,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\AstBuilder.cs,IsClosureType,The length of the statement  "	return type.HasGeneratedName () && type.IsCompilerGenerated () && (type.Name.Contains ("DisplayClass") || type.Name.Contains ("AnonStorey")); " is 141.
Long Statement,Custom.Decompiler.Ast,AstBuilder,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\AstBuilder.cs,AddAssembly,The length of the statement  "					Type = new SimpleType ("AssemblyVersion").WithAnnotation (new TypeReference ("System.Reflection"' "AssemblyVersionAttribute"' moduleDefinition' moduleDefinition.TypeSystem.CoreLibrary))' " is 186.
Long Statement,Custom.Decompiler.Ast,AstBuilder,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\AstBuilder.cs,AddTypeForwarderAttributes,The length of the statement  "						Type = new SimpleType ("TypeForwardedTo").WithAnnotation (new TypeReference ("System.Runtime.CompilerServices"' "TypeForwardedToAttribute"' module' module.TypeSystem.CoreLibrary))' " is 180.
Long Statement,Custom.Decompiler.Ast,AstBuilder,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\AstBuilder.cs,ConvertType,The length of the statement  "		return ConvertType ((type as Mono.Cecil.ByReferenceType).ElementType' typeAttributes' ref typeIndex' options).MakePointerType (); " is 129.
Long Statement,Custom.Decompiler.Ast,AstBuilder,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\AstBuilder.cs,ConvertType,The length of the statement  "		return ConvertType ((type as Mono.Cecil.PointerType).ElementType' typeAttributes' ref typeIndex' options).MakePointerType (); " is 125.
Long Statement,Custom.Decompiler.Ast,AstBuilder,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\AstBuilder.cs,ConvertType,The length of the statement  "		return ConvertType ((type as Mono.Cecil.ArrayType).ElementType' typeAttributes' ref typeIndex' options).MakeArrayType ((type as Mono.Cecil.ArrayType).Rank); " is 156.
Long Statement,Custom.Decompiler.Ast,AstBuilder,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\AstBuilder.cs,ConvertType,The length of the statement  "		if (gType.ElementType.Namespace == "System" && gType.ElementType.Name == "Nullable`1" && gType.GenericArguments.Count == 1) { " is 125.
Long Statement,Custom.Decompiler.Ast,AstBuilder,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\AstBuilder.cs,ConvertType,The length of the statement  "		AstType baseType = ConvertType (gType.ElementType' typeAttributes' ref typeIndex' options & ~ConvertTypeOptions.IncludeTypeParameterDefinitions); " is 145.
Long Statement,Custom.Decompiler.Ast,AstBuilder,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\AstBuilder.cs,ConvertType,The length of the statement  "		AstType typeRef = ConvertType (type.DeclaringType' typeAttributes' ref typeIndex' options & ~ConvertTypeOptions.IncludeTypeParameterDefinitions); " is 145.
Long Statement,Custom.Decompiler.Ast,AstBuilder,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\AstBuilder.cs,ConvertType,The length of the statement  "		string namepart = ICSharpCode.NRefactory.TypeSystem.ReflectionHelper.SplitTypeParameterCountFromReflectionName (type.Name); " is 123.
Long Statement,Custom.Decompiler.Ast,AstBuilder,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\AstBuilder.cs,ConvertType,The length of the statement  "		if ((options & ConvertTypeOptions.IncludeTypeParameterDefinitions) == ConvertTypeOptions.IncludeTypeParameterDefinitions) { " is 123.
Long Statement,Custom.Decompiler.Ast,AstBuilder,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\AstBuilder.cs,ConvertType,The length of the statement  "			if ((options & ConvertTypeOptions.IncludeTypeParameterDefinitions) == ConvertTypeOptions.IncludeTypeParameterDefinitions) { " is 123.
Long Statement,Custom.Decompiler.Ast,AstBuilder,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\AstBuilder.cs,ApplyTypeArgumentsTo,The length of the statement  "			ICSharpCode.NRefactory.TypeSystem.ReflectionHelper.SplitTypeParameterCountFromReflectionName (type.Name' out typeParameterCount); " is 129.
Long Statement,Custom.Decompiler.Ast,AstBuilder,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\AstBuilder.cs,CreateMethod,The length of the statement  "	// constraints for override and explicit interface implementation methods are inherited from the base method' so they cannot be specified directly " is 146.
Long Statement,Custom.Decompiler.Ast,AstBuilder,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\AstBuilder.cs,CreateConstructor,The length of the statement  "		astMethod.Body.InsertChildAfter (null' new Comment (" Note: this type is marked as 'beforefieldinit'.")' Roles.Comment); " is 120.
Long Statement,Custom.Decompiler.Ast,AstBuilder,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\AstBuilder.cs,CreateProperty,The length of the statement  "						astProp.Modifiers = FixUpVisibility ((astProp.Modifiers & ~Modifiers.VisibilityMask) | (propVisibilityModifiers & Modifiers.VisibilityMask)); " is 141.
Long Statement,Custom.Decompiler.Ast,AstBuilder,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\AstBuilder.cs,CreateProperty,The length of the statement  "			// TODO: add some kind of notification (a comment?) about possible problems with decompiled code due to unresolved references. " is 126.
Long Statement,Custom.Decompiler.Ast,AstBuilder,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\AstBuilder.cs,CreateField,The length of the statement  "		initializer.Initializer = CreateExpressionForConstant (fieldDef.Constant' fieldDef.FieldType' fieldDef.DeclaringType.IsEnum); " is 125.
Long Statement,Custom.Decompiler.Ast,AstBuilder,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\AstBuilder.cs,ConvertAttributes,The length of the statement  "	LayoutKind defaultLayoutKind = (typeDefinition.IsValueType && !typeDefinition.IsEnum) ? LayoutKind.Sequential : LayoutKind.Auto; " is 128.
Long Statement,Custom.Decompiler.Ast,AstBuilder,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\AstBuilder.cs,ConvertAttributes,The length of the statement  "	if (layoutKind != defaultLayoutKind || charSet != CharSet.Ansi || typeDefinition.PackingSize > 0 || typeDefinition.ClassSize > 0) { " is 131.
Long Statement,Custom.Decompiler.Ast,AstBuilder,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\AstBuilder.cs,ConvertAttributes,The length of the statement  "			dllImport.AddNamedArgument ("CallingConvention"' new IdentifierExpression ("CallingConvention").Member (callingConvention.ToString ())); " is 136.
Long Statement,Custom.Decompiler.Ast,AstBuilder,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\AstBuilder.cs,ConvertAttributes,The length of the statement  "		TypeReference methodImplOptions = new TypeReference ("System.Runtime.CompilerServices"' "MethodImplOptions"' methodDefinition.Module' methodDefinition.Module.TypeSystem.CoreLibrary); " is 182.
Long Statement,Custom.Decompiler.Ast,AstBuilder,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\AstBuilder.cs,ConvertMarshalInfo,The length of the statement  "	var unmanagedType = new TypeReference ("System.Runtime.InteropServices"' "UnmanagedType"' module' module.TypeSystem.CoreLibrary); " is 129.
Long Statement,Custom.Decompiler.Ast,AstBuilder,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\AstBuilder.cs,CreateNonCustomAttribute,The length of the statement  "		attr.Type.AddAnnotation (new TypeReference (attributeType.Namespace' attributeType.Name' module' module.TypeSystem.CoreLibrary)); " is 129.
Long Statement,Custom.Decompiler.Ast,AstBuilder,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\AstBuilder.cs,ConvertCustomAttributes,The length of the statement  "			if (customAttribute.AttributeType.Name == "ExtensionAttribute" && customAttribute.AttributeType.Namespace == "System.Runtime.CompilerServices") { " is 145.
Long Statement,Custom.Decompiler.Ast,AstBuilder,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\AstBuilder.cs,ConvertCustomAttributes,The length of the statement  "			if (customAttribute.AttributeType.Name == "ParamArrayAttribute" && customAttribute.AttributeType.Namespace == "System") { " is 121.
Long Statement,Custom.Decompiler.Ast,AstBuilder,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\AstBuilder.cs,ConvertCustomAttributes,The length of the statement  "				if (customAttribute.AttributeType.Name == "DebuggerStepThroughAttribute" && customAttribute.AttributeType.Namespace == "System.Diagnostics") { " is 142.
Long Statement,Custom.Decompiler.Ast,AstBuilder,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\AstBuilder.cs,ConvertCustomAttributes,The length of the statement  "				if (customAttribute.AttributeType.Name == "AsyncStateMachineAttribute" && customAttribute.AttributeType.Namespace == "System.Runtime.CompilerServices") { " is 153.
Long Statement,Custom.Decompiler.Ast,AstBuilder,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\AstBuilder.cs,ConvertCustomAttributes,The length of the statement  "					var propertyReference = resolvedAttributeType != null ? resolvedAttributeType.Properties.FirstOrDefault (pr => pr.Name == propertyNamedArg.Name) : null; " is 152.
Long Statement,Custom.Decompiler.Ast,AstBuilder,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\AstBuilder.cs,ConvertCustomAttributes,The length of the statement  "					var fieldReference = resolvedAttributeType != null ? resolvedAttributeType.Fields.FirstOrDefault (f => f.Name == fieldNamedArg.Name) : null; " is 140.
Long Statement,Custom.Decompiler.Ast,AstBuilder,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\AstBuilder.cs,ConvertSecurityAttributes,The length of the statement  "			var securityActionType = new TypeReference ("System.Security.Permissions"' "SecurityAction"' module' module.TypeSystem.CoreLibrary); " is 132.
Long Statement,Custom.Decompiler.Ast,AstBuilder,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\AstBuilder.cs,ConvertSecurityAttributes,The length of the statement  "					var propertyReference = resolvedAttributeType != null ? resolvedAttributeType.Properties.FirstOrDefault (pr => pr.Name == propertyNamedArg.Name) : null; " is 152.
Long Statement,Custom.Decompiler.Ast,AstBuilder,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\AstBuilder.cs,ConvertSecurityAttributes,The length of the statement  "					var fieldReference = resolvedAttributeType != null ? resolvedAttributeType.Fields.FirstOrDefault (f => f.Name == fieldNamedArg.Name) : null; " is 140.
Long Statement,Custom.Decompiler.Ast,AstBuilder,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\AstBuilder.cs,MakePrimitive,The length of the statement  "			return new Ast.PrimitiveExpression (CSharpPrimitiveCast.Cast (enumBaseTypeCode' val' false)).CastTo (ConvertType (type)); " is 121.
Long Statement,Custom.Decompiler.Ast,AstBuilder,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\AstBuilder.cs,SetNewModifier,The length of the statement  "		// TODO: add some kind of notification (a comment?) about possible problems with decompiled code due to unresolved references. " is 126.
Long Statement,Custom.Decompiler.Ast,AstBuilder,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\AstBuilder.cs,AnyIsHiddenBy,The length of the statement  "	return members.Any (m => m.Name == derived.Name && (condition == null || condition (m)) && TypesHierarchyHelpers.IsVisibleFromDerived (m' derived.DeclaringType)); " is 162.
Long Statement,Custom.Decompiler.Ast,AstMethodBodyBuilder,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\AstMethodBodyBuilder.cs,CreateMethodBody,The length of the statement  "	var localVariables = ilMethod.GetSelfAndChildrenRecursive<ILExpression> ().Select (e => e.Operand as ILVariable).Where (v => v != null && !v.IsParameter).Distinct (); " is 166.
Long Statement,Custom.Decompiler.Ast,AstMethodBodyBuilder,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\AstMethodBodyBuilder.cs,TransformNode,The length of the statement  "		List<ILRange> ilRanges = ILRange.OrderAndJoint (node.GetSelfAndChildrenRecursive<ILExpression> ().SelectMany (e => e.ILRanges)); " is 128.
Long Statement,Custom.Decompiler.Ast,AstMethodBodyBuilder,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\AstMethodBodyBuilder.cs,TransformNode,The length of the statement  "			Condition = ilLoop.Condition != null ? (Expression)TransformExpression (ilLoop.Condition) : new PrimitiveExpression (true)' " is 123.
Long Statement,Custom.Decompiler.Ast,AstMethodBodyBuilder,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\AstMethodBodyBuilder.cs,TransformNode,The length of the statement  "			if (catchClause.ExceptionVariable == null && (catchClause.ExceptionType == null || catchClause.ExceptionType.MetadataType == MetadataType.Object)) { " is 148.
Long Statement,Custom.Decompiler.Ast,AstMethodBodyBuilder,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\AstMethodBodyBuilder.cs,TransformExpression,The length of the statement  "	List<ILRange> ilRanges = ILRange.OrderAndJoint (expr.GetSelfAndChildrenRecursive<ILExpression> ().SelectMany (e => e.ILRanges)); " is 128.
Long Statement,Custom.Decompiler.Ast,AstMethodBodyBuilder,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\AstMethodBodyBuilder.cs,TransformByteCode,The length of the statement  "		boe.AddAnnotation (byteCode.Code == ILCode.Add ? AddCheckedBlocks.UncheckedAnnotation : AddCheckedBlocks.CheckedAnnotation); " is 124.
Long Statement,Custom.Decompiler.Ast,AstMethodBodyBuilder,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\AstMethodBodyBuilder.cs,TransformByteCode,The length of the statement  "		boe.AddAnnotation (byteCode.Code == ILCode.Sub ? AddCheckedBlocks.UncheckedAnnotation : AddCheckedBlocks.CheckedAnnotation); " is 124.
Long Statement,Custom.Decompiler.Ast,AstMethodBodyBuilder,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\AstMethodBodyBuilder.cs,TransformByteCode,The length of the statement  "		return new Ast.BinaryOperatorExpression (arg1' BinaryOperatorType.Multiply' arg2).WithAnnotation (AddCheckedBlocks.UncheckedAnnotation); " is 136.
Long Statement,Custom.Decompiler.Ast,AstMethodBodyBuilder,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\AstMethodBodyBuilder.cs,TransformByteCode,The length of the statement  "		return new Ast.BinaryOperatorExpression (arg1' BinaryOperatorType.Multiply' arg2).WithAnnotation (AddCheckedBlocks.CheckedAnnotation); " is 134.
Long Statement,Custom.Decompiler.Ast,AstMethodBodyBuilder,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\AstMethodBodyBuilder.cs,TransformByteCode,The length of the statement  "		return new Ast.BinaryOperatorExpression (arg1' BinaryOperatorType.Multiply' arg2).WithAnnotation (AddCheckedBlocks.CheckedAnnotation); " is 134.
Long Statement,Custom.Decompiler.Ast,AstMethodBodyBuilder,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\AstMethodBodyBuilder.cs,TransformByteCode,The length of the statement  "		return new Ast.UnaryOperatorExpression (UnaryOperatorType.Minus' arg1).WithAnnotation (AddCheckedBlocks.UncheckedAnnotation); " is 125.
Long Statement,Custom.Decompiler.Ast,AstMethodBodyBuilder,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\AstMethodBodyBuilder.cs,TransformByteCode,The length of the statement  "		var uoe = new Ast.UnaryOperatorExpression ((int)byteCode.Operand > 0 ? UnaryOperatorType.PostIncrement : UnaryOperatorType.PostDecrement' arg1); " is 144.
Long Statement,Custom.Decompiler.Ast,AstMethodBodyBuilder,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\AstMethodBodyBuilder.cs,TransformByteCode,The length of the statement  "		uoe.AddAnnotation ((byteCode.Code == ILCode.PostIncrement) ? AddCheckedBlocks.UncheckedAnnotation : AddCheckedBlocks.CheckedAnnotation); " is 136.
Long Statement,Custom.Decompiler.Ast,AstMethodBodyBuilder,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\AstMethodBodyBuilder.cs,TransformByteCode,The length of the statement  "		if (arg1 is AsExpression && byteCode.Arguments [0].Code == ILCode.Isinst && TypeAnalysis.IsSameType (operand as TypeReference' byteCode.Arguments [0].Operand as TypeReference)) " is 176.
Long Statement,Custom.Decompiler.Ast,AstMethodBodyBuilder,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\AstMethodBodyBuilder.cs,TransformByteCode,The length of the statement  "		if ((byteCode.Arguments [0].InferredType != null && byteCode.Arguments [0].InferredType.IsGenericParameter) || ((Cecil.TypeReference)operand).IsGenericParameter) " is 161.
Long Statement,Custom.Decompiler.Ast,AstMethodBodyBuilder,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\AstMethodBodyBuilder.cs,TransformByteCode,The length of the statement  "		return new IdentifierExpression ("ldftn").Invoke (expr).WithAnnotation (new Transforms.DelegateConstruction.Annotation (false)); " is 128.
Long Statement,Custom.Decompiler.Ast,AstMethodBodyBuilder,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\AstMethodBodyBuilder.cs,TransformByteCode,The length of the statement  "		return new IdentifierExpression ("ldvirtftn").Invoke (expr).WithAnnotation (new Transforms.DelegateConstruction.Annotation (true)); " is 131.
Long Statement,Custom.Decompiler.Ast,AstMethodBodyBuilder,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\AstMethodBodyBuilder.cs,TransformByteCode,The length of the statement  "		return AstBuilder.ConvertType (((FieldReference)operand).DeclaringType).Member (((FieldReference)operand).Name).WithAnnotation (operand); " is 137.
Long Statement,Custom.Decompiler.Ast,AstMethodBodyBuilder,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\AstMethodBodyBuilder.cs,TransformByteCode,The length of the statement  "		return new AssignmentExpression (AstBuilder.ConvertType (((FieldReference)operand).DeclaringType).Member (((FieldReference)operand).Name).WithAnnotation (operand)' arg1); " is 170.
Long Statement,Custom.Decompiler.Ast,AstMethodBodyBuilder,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\AstMethodBodyBuilder.cs,TransformByteCode,The length of the statement  "		return MakeRef (AstBuilder.ConvertType (((FieldReference)operand).DeclaringType).Member (((FieldReference)operand).Name).WithAnnotation (operand)); " is 147.
Long Statement,Custom.Decompiler.Ast,AstMethodBodyBuilder,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\AstMethodBodyBuilder.cs,TransformByteCode,The length of the statement  "				var methodParameters = mr.Parameters.Select (p => new TypeReferenceExpression (AstBuilder.ConvertType (p.ParameterType))); " is 122.
Long Statement,Custom.Decompiler.Ast,AstMethodBodyBuilder,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\AstMethodBodyBuilder.cs,TransformByteCode,The length of the statement  "			return new IdentifierExpression (loadName).Invoke (referencedEntity).WithAnnotation (new LdTokenAnnotation ()).Member (handleName); " is 131.
Long Statement,Custom.Decompiler.Ast,AstMethodBodyBuilder,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\AstMethodBodyBuilder.cs,TransformCall,The length of the statement  "					return new Ast.AssignmentExpression (target.Member (prop.Name).WithAnnotation (prop).WithAnnotation (cecilMethod)' methodArgs [0]); " is 131.
Long Statement,Custom.Decompiler.Ast,AstMethodBodyBuilder,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\AstMethodBodyBuilder.cs,TransformCall,The length of the statement  "				return new AssignmentExpression (target.Indexer (methodArgs.GetRange (0' methodArgs.Count - 1)).WithAnnotation (indexer).WithAnnotation (cecilMethod)' methodArgs [methodArgs.Count - 1]); " is 186.
Long Statement,Custom.Decompiler.Ast,AstMethodBodyBuilder,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\AstMethodBodyBuilder.cs,TransformCall,The length of the statement  "		} else if (cecilMethodDef.Name == "Invoke" && cecilMethodDef.DeclaringType.BaseType != null && cecilMethodDef.DeclaringType.BaseType.FullName == "System.MulticastDelegate") { " is 174.
Long Statement,Custom.Decompiler.Ast,AstMethodBodyBuilder,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\AstMethodBodyBuilder.cs,Convert,The length of the statement  "		return Convert (new UnaryOperatorExpression (UnaryOperatorType.AddressOf' ((DirectionExpression)expr).Expression.Detach ())' new PointerType (((ByReferenceType)actualType).ElementType)' reqType); " is 195.
Long Statement,Custom.Decompiler.Ast,AstMethodBodyBuilder,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\AstMethodBodyBuilder.cs,Convert,The length of the statement  "		bool actualIsPrimitiveType = actualIsIntegerOrEnum || actualType.MetadataType == MetadataType.Single || actualType.MetadataType == MetadataType.Double; " is 151.
Long Statement,Custom.Decompiler.Ast,AstMethodBodyBuilder,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\AstMethodBodyBuilder.cs,Convert,The length of the statement  "		bool requiredIsPrimitiveType = requiredIsIntegerOrEnum || reqType.MetadataType == MetadataType.Single || reqType.MetadataType == MetadataType.Double; " is 149.
Long Statement,Custom.Decompiler.Ast,NameVariables,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\NameVariables.cs,GetNameFromExpression,The length of the statement  "		} else if (mr.Name.StartsWith ("Get"' StringComparison.OrdinalIgnoreCase) && mr.Name.Length >= 4 && char.IsUpper (mr.Name [3])) { " is 129.
Long Statement,Custom.Decompiler.Ast,NameVariables,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\NameVariables.cs,GetNameForArgument,The length of the statement  "			} else if (methodRef.Name.StartsWith ("Set"' StringComparison.OrdinalIgnoreCase) && methodRef.Name.Length >= 4 && char.IsUpper (methodRef.Name [3])) { " is 150.
Long Statement,Custom.Decompiler.Ast,TextOutputFormatter,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\TextOutputFormatter.cs,GetCurrentMemberReference,The length of the statement  "	if ((node.Role == Roles.Type && node.Parent is ObjectCreateExpression) || (memberRef == null && node.Role == Roles.TargetExpression && (node.Parent is InvocationExpression || node.Parent is ObjectCreateExpression))) { " is 217.
Long Statement,Custom.Decompiler.Ast,TextOutputFormatter,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\TextOutputFormatter.cs,StartNode,The length of the statement  "	if (node is EntityDeclaration && node.Annotation<MemberReference> () != null && node.GetChildByRole (Roles.Identifier).IsNull) " is 126.
Long Statement,Custom.Decompiler.Ast,TextOutputFormatter,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\TextOutputFormatter.cs,IsDefinition,The length of the statement  "	return node is EntityDeclaration || (node is VariableInitializer && node.Parent is FieldDeclaration) || node is FixedVariableInitializer; " is 137.
Long Statement,Custom.Decompiler.Ast,TypesHierarchyHelpers,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\TypesHierarchyHelpers.cs,IsBaseMethod,The length of the statement  "		if (!parentMethod.HasParameters || !childMethod.HasParameters || parentMethod.Parameters.Count != childMethod.Parameters.Count) " is 127.
Long Statement,Custom.Decompiler.Ast,TypesHierarchyHelpers,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\TypesHierarchyHelpers.cs,IsBaseProperty,The length of the statement  "		if (!parentProperty.HasParameters || !childProperty.HasParameters || parentProperty.Parameters.Count != childProperty.Parameters.Count) " is 135.
Long Statement,Custom.Decompiler.Ast,TypesHierarchyHelpers,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\TypesHierarchyHelpers.cs,FindBaseProperties,The length of the statement  "			if (MatchProperty (baseType.ApplyTo (baseProperty)' gProperty) && IsVisibleFromDerived (baseProperty' property.DeclaringType)) { " is 128.
Long Statement,Custom.Decompiler.Ast,TypesHierarchyHelpers,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\TypesHierarchyHelpers.cs,MatchMethod,The length of the statement  "		if (!mCandidate.HasGenericParameters || !mMethod.HasGenericParameters || mCandidate.GenericParameters.Count != mMethod.GenericParameters.Count) " is 143.
Long Statement,Custom.Decompiler.Ast,TypesHierarchyHelpers,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\TypesHierarchyHelpers.cs,MatchInterfaceMethod,The length of the statement  "		var methodContext = new GenericContext<TypeDefinition> (interfaceContextType.Resolve ()' ((GenericInstanceType)interfaceContextType).GenericArguments); " is 151.
Long Statement,Custom.Decompiler.Ast,TypesHierarchyHelpers,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\TypesHierarchyHelpers.cs,MatchProperty,The length of the statement  "			if (!MatchParameters (candidate.ApplyTo (mCandidate.Parameters [index])' property.ApplyTo (mProperty.Parameters [index]))) " is 122.
Long Statement,Custom.Decompiler.Ast,TypesHierarchyHelpers,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\TypesHierarchyHelpers.cs,BaseTypes,The length of the statement  "			type = new GenericContext<TypeDefinition> (genericBaseType.ResolveOrThrow ()' genericBaseType.GenericArguments.Select (t => type.ResolveWithContext (t))); " is 154.
Long Statement,Custom.Decompiler.Ast,TypesHierarchyHelpers,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\TypesHierarchyHelpers.cs,CreateGenericContext,The length of the statement  "	return type.HasGenericParameters ? new GenericContext<TypeDefinition> (type' type.GenericParameters) : new GenericContext<TypeDefinition> (type); " is 145.
Long Statement,Custom.Decompiler,CecilExtensions,F:\newReposMay17\Fody_Usable\Fody\Decompiler\CecilExtensions.cs,IsAnonymousType,The length of the statement  "	if (string.IsNullOrEmpty (type.Namespace) && type.HasGeneratedName () && (type.Name.Contains ("AnonType") || type.Name.Contains ("AnonymousType"))) { " is 149.
Long Statement,Custom.Decompiler,CecilExtensions,F:\newReposMay17\Fody_Usable\Fody\Decompiler\CecilExtensions.cs,GetDefaultMemberName,The length of the statement  "			if (ca.Constructor.DeclaringType.Name == "DefaultMemberAttribute" && ca.Constructor.DeclaringType.Namespace == "System.Reflection" && ca.Constructor.FullName == @"System.Void System.Reflection.DefaultMemberAttribute::.ctor(System.String)") { " is 241.
Long Statement,Custom.Decompiler,SourceCodeMapping,F:\newReposMay17\Fody_Usable\Fody\Decompiler\CodeMappings.cs,ToArray,The length of the statement  "	currentList.AddRange (ILRange.OrderAndJoint (MemberMapping.MemberCodeMappings.FindAll (m => m.StartLocation.Line == this.StartLocation.Line).ConvertAll<ILRange> (m => m.ILInstructionOffset))); " is 192.
Long Statement,Custom.Decompiler,CodeMappings,F:\newReposMay17\Fody_Usable\Fody\Decompiler\CodeMappings.cs,GetInstructionByTokenAndOffset,The length of the statement  "	var map = codeMapping.MemberCodeMappings.Find (m => m.ILInstructionOffset.From <= ilOffset && ilOffset < m.ILInstructionOffset.To); " is 131.
Long Statement,Custom.Decompiler,CodeMappings,F:\newReposMay17\Fody_Usable\Fody\Decompiler\CodeMappings.cs,GetInstructionByTokenAndOffset,The length of the statement  "	var codeMapping = mapping.MemberCodeMappings.Find (cm => cm.ILInstructionOffset.From <= ilOffset && ilOffset <= cm.ILInstructionOffset.To - 1); " is 143.
Long Statement,Custom.Decompiler.Ast.Transforms,AddCheckedBlocks,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\Transforms\AddCheckedBlocks.cs,GetResultFromBlock,The length of the statement  "			nodesCheckedContext = nodesCheckedContextUncheckedBlockOpen + new InsertedBlock (uncheckedBlockStart' statement' false); " is 120.
Long Statement,Custom.Decompiler.Ast.Transforms,AddCheckedBlocks,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\Transforms\AddCheckedBlocks.cs,GetResult,The length of the statement  "					result.NodesToInsertInUncheckedContext = result.NodesToInsertInCheckedContext + new ConvertCompoundAssignment (expr' true); " is 123.
Long Statement,Custom.Decompiler.Ast.Transforms,AddCheckedBlocks,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\Transforms\AddCheckedBlocks.cs,GetResult,The length of the statement  "					result.NodesToInsertInCheckedContext = result.NodesToInsertInUncheckedContext + new ConvertCompoundAssignment (expr' false); " is 124.
Long Statement,Custom.Decompiler.Ast.Transforms,ConvertConstructorCallIntoInitializer,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\Transforms\ConvertConstructorCallIntoInitializer.cs,HandleInstanceFieldInitializers,The length of the statement  "	var instanceCtors = members.OfType<ConstructorDeclaration> ().Where (c => (c.Modifiers & Modifiers.Static) == 0).ToArray (); " is 124.
Long Statement,Custom.Decompiler.Ast.Transforms,ConvertConstructorCallIntoInitializer,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\Transforms\ConvertConstructorCallIntoInitializer.cs,HandleInstanceFieldInitializers,The length of the statement  "	var instanceCtorsNotChainingWithThis = instanceCtors.Where (ctor => !thisCallPattern.IsMatch (ctor.Body.Statements.FirstOrDefault ())).ToArray (); " is 146.
Long Statement,Custom.Decompiler.Ast.Transforms,ConvertConstructorCallIntoInitializer,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\Transforms\ConvertConstructorCallIntoInitializer.cs,HandleInstanceFieldInitializers,The length of the statement  "			FieldDefinition fieldDef = m.Get<AstNode> ("fieldAccess").Single ().Annotation<FieldReference> ().ResolveWithinSameModule (); " is 125.
Long Statement,Custom.Decompiler.Ast.Transforms,ConvertConstructorCallIntoInitializer,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\Transforms\ConvertConstructorCallIntoInitializer.cs,RemoveSingleEmptyConstructor,The length of the statement  "	var instanceCtors = typeDeclaration.Members.OfType<ConstructorDeclaration> ().Where (c => (c.Modifiers & Modifiers.Static) == 0).ToArray (); " is 140.
Long Statement,Custom.Decompiler.Ast.Transforms,ConvertConstructorCallIntoInitializer,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\Transforms\ConvertConstructorCallIntoInitializer.cs,RemoveSingleEmptyConstructor,The length of the statement  "		emptyCtor.Modifiers = ((typeDeclaration.Modifiers & Modifiers.Abstract) == Modifiers.Abstract ? Modifiers.Protected : Modifiers.Public); " is 136.
Long Statement,Custom.Decompiler.Ast.Transforms,ConvertConstructorCallIntoInitializer,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\Transforms\ConvertConstructorCallIntoInitializer.cs,HandleStaticFieldInitializers,The length of the statement  "	var staticCtor = members.OfType<ConstructorDeclaration> ().FirstOrDefault (c => (c.Modifiers & Modifiers.Static) == Modifiers.Static); " is 134.
Long Statement,Custom.Decompiler.Ast.Transforms,ConvertConstructorCallIntoInitializer,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\Transforms\ConvertConstructorCallIntoInitializer.cs,HandleStaticFieldInitializers,The length of the statement  "				FieldDeclaration fieldDecl = members.OfType<FieldDeclaration> ().FirstOrDefault (f => f.Annotation<FieldDefinition> () == fieldDef); " is 132.
Long Statement,Custom.Decompiler.Ast.Transforms,DecimalConstantTransform,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\Transforms\DecimalConstantTransform.cs,VisitFieldDeclaration,The length of the statement  "	if ((fieldDeclaration.Modifiers & staticReadOnly) == staticReadOnly && decimalType.IsMatch (fieldDeclaration.ReturnType)) { " is 123.
Long Statement,Custom.Decompiler.Ast.Transforms,DeclareVariables,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\Transforms\DeclareVariables.cs,Run,The length of the statement  "	// First do all the insertions' then do all the replacements. This is necessary because a replacement might remove our reference point from the AST. " is 148.
Long Statement,Custom.Decompiler.Ast.Transforms,DeclareVariables,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\Transforms\DeclareVariables.cs,Run,The length of the statement  "			VariableInitializer initializer = new VariableInitializer (v.Name' v.ReplacedAssignment.Right.Detach ()).CopyAnnotationsFrom (v.ReplacedAssignment).WithAnnotation (v.ILVariable); " is 178.
Long Statement,Custom.Decompiler.Ast.Transforms,DeclareVariables,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\Transforms\DeclareVariables.cs,Run,The length of the statement  "		var variables = block.Statements.TakeWhile (stmt => stmt is VariableDeclarationStatement).Cast<VariableDeclarationStatement> ().ToList (); " is 138.
Long Statement,Custom.Decompiler.Ast.Transforms,DeclareVariables,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\Transforms\DeclareVariables.cs,DeclareVariableInBlock,The length of the statement  "	bool canMoveVariableIntoSubBlocks = FindDeclarationPoint (daa' variableName' allowPassIntoLoops' block' out declarationPoint); " is 126.
Long Statement,Custom.Decompiler.Ast.Transforms,DeclareVariables,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\Transforms\DeclareVariables.cs,DeclareVariableInBlock,The length of the statement  "				if (TryConvertAssignmentExpressionIntoVariableDeclaration ((Expression)usingStmt.ResourceAcquisition' type' variableName)) " is 122.
Long Statement,Custom.Decompiler.Ast.Transforms,DeclareVariables,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\Transforms\DeclareVariables.cs,FindDeclarationPoint,The length of the statement  "	bool allowPassIntoLoops = varDecl.Variables.Single ().Annotation<DelegateConstruction.CapturedVariableAnnotation> () == null; " is 125.
Long Statement,Custom.Decompiler.Ast.Transforms,DeclareVariables,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\Transforms\DeclareVariables.cs,CanMoveVariableUseIntoSubBlock,The length of the statement  "	if (!allowPassIntoLoops && (stmt is ForStatement || stmt is ForeachStatement || stmt is DoWhileStatement || stmt is WhileStatement)) " is 132.
Long Statement,Custom.Decompiler.Ast.Transforms,DeclareVariables,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\Transforms\DeclareVariables.cs,CanMoveVariableUseIntoSubBlock,The length of the statement  "	// We can move the variable into a sub-block only if the variable is used in only that sub-block (and not in expressions such as the loop condition) " is 148.
Long Statement,Custom.Decompiler.Ast.Transforms,DelegateConstruction,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\Transforms\DelegateConstruction.cs,HandleAnonymousMethod,The length of the statement  "	if (target != null && !(target is IdentifierExpression || target is ThisReferenceExpression || target is NullReferenceExpression)) " is 130.
Long Statement,Custom.Decompiler.Ast.Transforms,DelegateConstruction,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\Transforms\DelegateConstruction.cs,VisitBlockStatement,The length of the statement  "		if (displayClassAssignmentMatch.Get<AstType> ("type").Single ().Annotation<TypeReference> ().ResolveWithinSameModule () != type) " is 128.
Long Statement,Custom.Decompiler.Ast.Transforms,DelegateConstruction,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\Transforms\DelegateConstruction.cs,VisitBlockStatement,The length of the statement  "		VariableDeclarationStatement displayClassVarDecl = PatternStatementTransform.FindVariableDeclaration (stmt' variable.Name); " is 123.
Long Statement,Custom.Decompiler.Ast.Transforms,DelegateConstruction,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\Transforms\DelegateConstruction.cs,VisitBlockStatement,The length of the statement  "		List<ILVariable> parameterOccurrances = rootBlock.Descendants.OfType<IdentifierExpression> ().Select (n => n.Annotation<ILVariable> ()).Where (p => p != null && p.IsParameter).ToList (); " is 186.
Long Statement,Custom.Decompiler.Ast.Transforms,DelegateConstruction,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\Transforms\DelegateConstruction.cs,VisitBlockStatement,The length of the statement  "			ExpressionStatement closureFieldAssignmentPattern = new ExpressionStatement (new AssignmentExpression (new NamedNode ("left"' new MemberReferenceExpression { " is 157.
Long Statement,Custom.Decompiler.Ast.Transforms,DelegateConstruction,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\Transforms\DelegateConstruction.cs,VisitBlockStatement,The length of the statement  "				FieldDefinition fieldDef = m.Get<MemberReferenceExpression> ("left").Single ().Annotation<FieldReference> ().ResolveWithinSameModule (); " is 136.
Long Statement,Custom.Decompiler.Ast.Transforms,DelegateConstruction,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\Transforms\DelegateConstruction.cs,VisitBlockStatement,The length of the statement  "	currentlyUsedVariableNames.RemoveRange (numberOfVariablesOutsideBlock' currentlyUsedVariableNames.Count - numberOfVariablesOutsideBlock); " is 137.
Long Statement,Custom.Decompiler.Ast.Transforms,IntroduceExtensionMethods,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\Transforms\IntroduceExtensionMethods.cs,Run,The length of the statement  "							firstArgument = firstArgument.ReplaceWith (expr => expr.CastTo (AstBuilder.ConvertType (d.Parameters.First ().ParameterType))); " is 127.
Long Statement,Custom.Decompiler.Ast.Transforms,IntroduceQueryExpressions,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\Transforms\IntroduceQueryExpressions.cs,Run,The length of the statement  "	// After all queries were decompiled' detect degenerate queries (queries not property terminated with 'select' or 'group') " is 122.
Long Statement,Custom.Decompiler.Ast.Transforms,IntroduceQueryExpressions,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\Transforms\IntroduceQueryExpressions.cs,DecompileQuery,The length of the statement  "			if (MatchSimpleLambda (invocation.Arguments.ElementAt (0)' out parameterName1' out keySelector) && MatchSimpleLambda (invocation.Arguments.ElementAt (1)' out parameterName2' out elementSelector) && parameterName1 == parameterName2) { " is 233.
Long Statement,Custom.Decompiler.Ast.Transforms,PatternStatementTransform,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\Transforms\PatternStatementTransform.cs,TransformUsings,The length of the statement  "	if (usingStatement.EmbeddedStatement.Descendants.OfType<IdentifierExpression> ().Any (ident => ident.Identifier == variableName)) { " is 131.
Long Statement,Custom.Decompiler.Ast.Transforms,PatternStatementTransform,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\Transforms\PatternStatementTransform.cs,TransformUsings,The length of the statement  "				}.CopyAnnotationsFrom (node.Expression).WithAnnotation (m1.Get<AstNode> ("variable").Single ().Annotation<ILVariable> ()) " is 121.
Long Statement,Custom.Decompiler.Ast.Transforms,PatternStatementTransform,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\Transforms\PatternStatementTransform.cs,CanMoveVariableDeclarationIntoStatement,The length of the statement  "	List<BlockStatement> blocks = targetStatement.Ancestors.TakeWhile (block => block != varDecl.Parent).OfType<BlockStatement> ().ToList (); " is 137.
Long Statement,Custom.Decompiler.Ast.Transforms,PatternStatementTransform,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\Transforms\PatternStatementTransform.cs,HasAssignment,The length of the statement  "			if (ident.Parent is AssignmentExpression && ident.Role == AssignmentExpression.LeftRole || ident.Parent is DirectionExpression) { " is 129.
Long Statement,Custom.Decompiler.Ast.Transforms,PatternStatementTransform,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\Transforms\PatternStatementTransform.cs,TransformForeach,The length of the statement  "		// if there are variables outside the loop' we need to put those into the parent block' and that won't work if the direct parent isn't a block " is 142.
Long Statement,Custom.Decompiler.Ast.Transforms,PatternStatementTransform,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\Transforms\PatternStatementTransform.cs,TransformForeach,The length of the statement  "	// Because we look only outside the loop' we won't make the mistake of moving a captured variable across the loop boundary " is 122.
Long Statement,Custom.Decompiler.Ast.Transforms,PatternStatementTransform,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\Transforms\PatternStatementTransform.cs,TransformNonGenericForEach,The length of the statement  "	// Because we look only outside the loop' we won't make the mistake of moving a captured variable across the loop boundary " is 122.
Long Statement,Custom.Decompiler.Ast.Transforms,PatternStatementTransform,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\Transforms\PatternStatementTransform.cs,TransformFor,The length of the statement  "	if (m1.Get<IdentifierExpression> ("variable").Single ().Identifier != m2.Get<IdentifierExpression> ("ident").Single ().Identifier) " is 130.
Long Statement,Custom.Decompiler.Ast.Transforms,PatternStatementTransform,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\Transforms\PatternStatementTransform.cs,TransformDoWhile,The length of the statement  "		doLoop.Condition = new UnaryOperatorExpression (UnaryOperatorType.Not' m.Get<Expression> ("condition").Single ().Detach ()); " is 124.
Long Statement,Custom.Decompiler.Ast.Transforms,PatternStatementTransform,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\Transforms\PatternStatementTransform.cs,TransformLock,The length of the statement  "	if (m1.Get<IdentifierExpression> ("variable").Single ().Identifier == m2.Get<IdentifierExpression> ("flag").Single ().Identifier) { " is 131.
Long Statement,Custom.Decompiler.Ast.Transforms,PatternStatementTransform,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\Transforms\PatternStatementTransform.cs,TransformSwitchOnString,The length of the statement  "	// switchVar must be the same as switchExpr; or switchExpr must be an assignment and switchVar the left side of that assignment " is 127.
Long Statement,Custom.Decompiler.Ast.Transforms,PatternStatementTransform,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\Transforms\PatternStatementTransform.cs,TransformAutomaticProperties,The length of the statement  "		FieldDefinition field = m.Get<AstNode> ("fieldReference").Single ().Annotation<FieldReference> ().ResolveWithinSameModule (); " is 125.
Long Statement,Custom.Decompiler.Ast.Transforms,PushNegation,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\Transforms\PushNegation.cs,VisitUnaryOperatorExpression,The length of the statement  "	if (unary.Operator == UnaryOperatorType.Not && unary.Expression is UnaryOperatorExpression && (unary.Expression as UnaryOperatorExpression).Operator == UnaryOperatorType.Not) { " is 176.
Long Statement,Custom.Decompiler.Ast.Transforms,PushNegation,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\Transforms\PushNegation.cs,VisitBinaryOperatorExpression,The length of the statement  "	if (op == BinaryOperatorType.Equality && rightOperand == true || op == BinaryOperatorType.InEquality && rightOperand == false) { " is 128.
Long Statement,Custom.Decompiler.Ast.Transforms,PushNegation,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\Transforms\PushNegation.cs,VisitBinaryOperatorExpression,The length of the statement  "	} else if (op == BinaryOperatorType.Equality && rightOperand == false || op == BinaryOperatorType.InEquality && rightOperand == true) { " is 135.
Long Statement,Custom.Decompiler.Ast.Transforms,ReplaceMethodCallsWithOperators,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\Transforms\ReplaceMethodCallsWithOperators.cs,ProcessInvocationExpression,The length of the statement  "	case "System.Reflection.FieldInfo System.Reflection.FieldInfo::GetFieldFromHandle(System.RuntimeFieldHandle'System.RuntimeTypeHandle)": " is 135.
Long Statement,Custom.Decompiler.Ast.Transforms,ReplaceMethodCallsWithOperators,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\Transforms\ReplaceMethodCallsWithOperators.cs,ProcessInvocationExpression,The length of the statement  "		invocationExpression.ReplaceWith (new BinaryOperatorExpression (arguments [0]' bop.Value' arguments [1]).WithAnnotation (methodRef)); " is 133.
Long Statement,Custom.Decompiler.Ast.Transforms,ReplaceMethodCallsWithOperators,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\Transforms\ReplaceMethodCallsWithOperators.cs,ProcessInvocationExpression,The length of the statement  "		invocationExpression.ReplaceWith (arguments [0].CastTo (AstBuilder.ConvertType (methodRef.ReturnType' methodRef.MethodReturnType)).WithAnnotation (methodRef)); " is 159.
Long Statement,Custom.Decompiler.Ast.Transforms,ReplaceMethodCallsWithOperators,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\Transforms\ReplaceMethodCallsWithOperators.cs,VisitAssignmentExpression,The length of the statement  "	if (context.Settings.IntroduceIncrementAndDecrement && (assignment.Operator == AssignmentOperatorType.Add || assignment.Operator == AssignmentOperatorType.Subtract)) { " is 167.
Long Statement,Custom.Decompiler.Ast.Transforms,ReplaceMethodCallsWithOperators,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\Transforms\ReplaceMethodCallsWithOperators.cs,VisitAssignmentExpression,The length of the statement  "					type = (assignment.Operator == AssignmentOperatorType.Add) ? UnaryOperatorType.PostIncrement : UnaryOperatorType.PostDecrement; " is 127.
Long Statement,Custom.Decompiler.Ast.Transforms,ReplaceMethodCallsWithOperators,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\Transforms\ReplaceMethodCallsWithOperators.cs,VisitAssignmentExpression,The length of the statement  "				assignment.ReplaceWith (new UnaryOperatorExpression (type' assignment.Left.Detach ()).CopyAnnotationsFrom (assignment)); " is 120.
Long Statement,Custom.Decompiler.Ast.Transforms,ReplaceMethodCallsWithOperators,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\Transforms\ReplaceMethodCallsWithOperators.cs,IsWithoutSideEffects,The length of the statement  "	return left is ThisReferenceExpression || left is IdentifierExpression || left is TypeReferenceExpression || left is BaseReferenceExpression; " is 141.
Long Statement,Custom.Decompiler.Ast.Transforms,ReplaceMethodCallsWithOperators,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\Transforms\ReplaceMethodCallsWithOperators.cs,VisitCastExpression,The length of the statement  "			newNode = newNode.Invoke (method.Parameters.Select (p => new TypeReferenceExpression (AstBuilder.ConvertType (p.ParameterType' p)))); " is 133.
Long Statement,Custom.Decompiler.Disassembler,DisassemblerHelpers,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Disassembler\DisassemblerHelpers.cs,ToInvariantCultureString,The length of the statement  "	return (null != convertible) ? convertible.ToString (System.Globalization.CultureInfo.InvariantCulture) : value.ToString (); " is 124.
Long Statement,Custom.Decompiler.Disassembler,DisassemblerHelpers,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Disassembler\DisassemblerHelpers.cs,WriteTo,The length of the statement  "	ILNameSyntax syntaxForElementTypes = syntax == ILNameSyntax.SignatureNoNamedTypeParameters ? syntax : ILNameSyntax.Signature; " is 125.
Long Statement,Custom.Decompiler.Disassembler,DisassemblerHelpers,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Disassembler\DisassemblerHelpers.cs,WriteTo,The length of the statement  "		} else if ((syntax == ILNameSyntax.Signature || syntax == ILNameSyntax.SignatureNoNamedTypeParameters) && name != null) { " is 121.
Long Statement,Custom.Decompiler.Disassembler,ILStructure,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Disassembler\ILStructure.cs,AddNestedStructure,The length of the statement  "	if (this.Type == ILStructureType.Loop && newStructure.Type == ILStructureType.Loop && newStructure.StartOffset == this.StartOffset) " is 131.
Long Statement,Custom.Decompiler.Disassembler,MethodBodyDisassembler,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Disassembler\MethodBodyDisassembler.cs,WriteStructureBody,The length of the statement  "		if (childIndex < s.Children.Count && s.Children [childIndex].StartOffset <= offset && offset < s.Children [childIndex].EndOffset) { " is 131.
Long Statement,Custom.Decompiler.Disassembler,MethodBodyDisassembler,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Disassembler\MethodBodyDisassembler.cs,WriteStructureBody,The length of the statement  "			prevInstructionWasBranch = inst.OpCode.FlowControl == FlowControl.Branch || inst.OpCode.FlowControl == FlowControl.Cond_Branch || inst.OpCode.FlowControl == FlowControl.Return || inst.OpCode.FlowControl == FlowControl.Throw; " is 224.
Long Statement,Custom.Decompiler.Disassembler,ReflectionDisassembler,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Disassembler\ReflectionDisassembler.cs,DisassembleMethodInternal,The length of the statement  "	WriteFlags (method.ImplAttributes & ~(MethodImplAttributes.CodeTypeMask | MethodImplAttributes.ManagedMask)' methodImpl); " is 121.
Long Statement,Custom.Decompiler.Disassembler,ReflectionDisassembler,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Disassembler\ReflectionDisassembler.cs,DisassembleMethodInternal,The length of the statement  "	CloseBlock ("end of method " + DisassemblerHelpers.Escape (method.DeclaringType.Name) + "::" + DisassemblerHelpers.Escape (method.Name)); " is 137.
Long Statement,Custom.Decompiler.Disassembler,ReflectionDisassembler,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Disassembler\ReflectionDisassembler.cs,WriteSecurityDeclarationArgument,The length of the statement  "		output.Write ("string('{0}')"' ICSharpCode.NRefactory.CSharp.CSharpOutputVisitor.ConvertString ((string)na.Argument.Value).Replace ("'"' "\'")); " is 144.
Long Statement,Custom.Decompiler.Disassembler,ReflectionDisassembler,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Disassembler\ReflectionDisassembler.cs,WriteNativeType,The length of the statement  "		output.Write ("custom(\"{0}\"' \"{1}\""' ICSharpCode.NRefactory.CSharp.CSharpOutputVisitor.ConvertString (cmi.ManagedType.FullName)' ICSharpCode.NRefactory.CSharp.CSharpOutputVisitor.ConvertString (cmi.Cookie)); " is 211.
Long Statement,Custom.Decompiler.Disassembler,ReflectionDisassembler,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Disassembler\ReflectionDisassembler.cs,WriteNativeType,The length of the statement  "			output.Write ("' \"{0}\"' \"{1}\""' cmi.Guid.ToString ()' ICSharpCode.NRefactory.CSharp.CSharpOutputVisitor.ConvertString (cmi.UnmanagedType)); " is 143.
Long Statement,Custom.Decompiler.Disassembler,ReflectionDisassembler,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Disassembler\ReflectionDisassembler.cs,DisassembleField,The length of the statement  "	const FieldAttributes hasXAttributes = FieldAttributes.HasDefault | FieldAttributes.HasFieldMarshal | FieldAttributes.HasFieldRVA; " is 130.
Long Statement,Custom.Decompiler.Disassembler,ReflectionDisassembler,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Disassembler\ReflectionDisassembler.cs,DisassembleType,The length of the statement  "	const TypeAttributes masks = TypeAttributes.ClassSemanticMask | TypeAttributes.VisibilityMask | TypeAttributes.LayoutMask | TypeAttributes.StringFormatMask; " is 156.
Long Statement,Custom.Decompiler.Disassembler,ReflectionDisassembler,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Disassembler\ReflectionDisassembler.cs,WriteAssemblyReferences,The length of the statement  "			output.WriteLine (".ver {0}:{1}:{2}:{3}"' aref.Version.Major' aref.Version.Minor' aref.Version.Build' aref.Version.Revision); " is 125.
Long Statement,Custom.Decompiler.FlowAnalysis,ControlFlowGraphBuilder,F:\newReposMay17\Fody_Usable\Fody\Decompiler\FlowAnalysis\ControlFlowGraphBuilder.cs,CalculateHasIncomingJumps,The length of the statement  "		if (inst.OpCode.OperandType == OperandType.InlineBrTarget || inst.OpCode.OperandType == OperandType.ShortInlineBrTarget) { " is 122.
Long Statement,Custom.Decompiler.FlowAnalysis,ControlFlowGraphBuilder,F:\newReposMay17\Fody_Usable\Fody\Decompiler\FlowAnalysis\ControlFlowGraphBuilder.cs,CreateNodes,The length of the statement  "			endFinallyOrFaultNode = new ControlFlowNode (nodes.Count' handler.HandlerEnd.Offset' ControlFlowNodeType.EndFinallyOrFault); " is 124.
Long Statement,Custom.Decompiler.FlowAnalysis,ControlFlowGraphBuilder,F:\newReposMay17\Fody_Usable\Fody\Decompiler\FlowAnalysis\ControlFlowGraphBuilder.cs,CreateRegularControlFlow,The length of the statement  "			if (node.End.OpCode.OperandType == OperandType.InlineBrTarget || node.End.OpCode.OperandType == OperandType.ShortInlineBrTarget) { " is 130.
Long Statement,Custom.Decompiler.FlowAnalysis,ControlFlowGraphBuilder,F:\newReposMay17\Fody_Usable\Fody\Decompiler\FlowAnalysis\ControlFlowGraphBuilder.cs,FindInnermostHandlerBlock,The length of the statement  "		if (h.TryStart.Offset <= instructionOffset && instructionOffset < h.TryEnd.Offset || h.HandlerStart.Offset <= instructionOffset && instructionOffset < h.HandlerEnd.Offset) { " is 173.
Long Statement,Custom.Decompiler.FlowAnalysis,ControlFlowGraphBuilder,F:\newReposMay17\Fody_Usable\Fody\Decompiler\FlowAnalysis\ControlFlowGraphBuilder.cs,FindParentExceptionHandlerNode,The length of the statement  "	Debug.Assert (exceptionHandler.NodeType == ControlFlowNodeType.CatchHandler || exceptionHandler.NodeType == ControlFlowNodeType.FinallyOrFaultHandler); " is 151.
Long Statement,Custom.Decompiler.FlowAnalysis,ControlFlowNode,F:\newReposMay17\Fody_Usable\Fody\Decompiler\FlowAnalysis\ControlFlowNode.cs,ToString,The length of the statement  "		writer.Write ("DominanceFrontier: " + string.Join ("'"' DominanceFrontier.OrderBy (d => d.BlockIndex).Select (d => d.BlockIndex.ToString ()))); " is 143.
Long Statement,Custom.Decompiler.FlowAnalysis,ControlStructureDetector,F:\newReposMay17\Fody_Usable\Fody\Decompiler\FlowAnalysis\ControlStructureDetector.cs,DetectStructure,The length of the statement  "	ControlStructure root = new ControlStructure (new HashSet<ControlFlowNode> (g.Nodes)' g.EntryPoint' ControlStructureType.Root); " is 127.
Long Statement,Custom.Decompiler.FlowAnalysis,ControlStructureDetector,F:\newReposMay17\Fody_Usable\Fody\Decompiler\FlowAnalysis\ControlStructureDetector.cs,DetectExceptionHandling,The length of the statement  "	// For each exception handler' we determine the nodes and substructures inside that handler' and move them into a new substructure. " is 131.
Long Statement,Custom.Decompiler.FlowAnalysis,ControlStructureDetector,F:\newReposMay17\Fody_Usable\Fody\Decompiler\FlowAnalysis\ControlStructureDetector.cs,DetectExceptionHandling,The length of the statement  "	// This is always possible because exception handlers are guaranteed (by the CLR spec) to be properly nested and non-overlapping; " is 129.
Long Statement,Custom.Decompiler.FlowAnalysis,ControlStructureDetector,F:\newReposMay17\Fody_Usable\Fody\Decompiler\FlowAnalysis\ControlStructureDetector.cs,DetectExceptionHandling,The length of the statement  "		ControlStructure tryBlock = new ControlStructure (tryNodes' g.Nodes.Single (n => n.Start == eh.TryStart)' ControlStructureType.Try); " is 132.
Long Statement,Custom.Decompiler.FlowAnalysis,ControlStructureDetector,F:\newReposMay17\Fody_Usable\Fody\Decompiler\FlowAnalysis\ControlStructureDetector.cs,FindLoops,The length of the statement  "	if (current.Nodes.Contains (node) && node.DominanceFrontier.Contains (node) && !(node == current.EntryPoint && current.Type == ControlStructureType.Loop)) { " is 156.
Long Statement,Custom.Decompiler.FlowAnalysis,SimplifyByRefCalls,F:\newReposMay17\Fody_Usable\Fody\Decompiler\FlowAnalysis\SimplifyByRefCalls.cs,MakeByRefCallSimple,The length of the statement  "			block.Instructions.Insert (instructionIndexInBlock + 1' new SsaInstruction (block' null' addressTakenOf' new SsaVariable[] { " is 124.
Long Statement,Custom.Decompiler.FlowAnalysis,SimplifyByRefCalls,F:\newReposMay17\Fody_Usable\Fody\Decompiler\FlowAnalysis\SimplifyByRefCalls.cs,IsLoadAddress,The length of the statement  "	return inst.Instruction != null && (inst.Instruction.OpCode == OpCodes.Ldloca || inst.Instruction.OpCode == OpCodes.Ldarga); " is 124.
Long Statement,Custom.Decompiler.FlowAnalysis,SimplifyByRefCalls,F:\newReposMay17\Fody_Usable\Fody\Decompiler\FlowAnalysis\SimplifyByRefCalls.cs,MakeInitObjCallSimple,The length of the statement  "		block.Instructions [instructionIndexInBlock] = new SsaInstruction (inst.ParentBlock' null' GetVariableFromLoadAddressInstruction (operand.Definition.Instruction)' null' specialOpCode: SpecialOpCode.InitObj' typeOperand: (TypeReference)inst.Instruction.Operand); " is 261.
Long Statement,Custom.Decompiler.FlowAnalysis,SimplifyByRefCalls,F:\newReposMay17\Fody_Usable\Fody\Decompiler\FlowAnalysis\SimplifyByRefCalls.cs,MakeLoadFieldCallSimple,The length of the statement  "		block.Instructions.Insert (instructionIndexInBlock++' new SsaInstruction (inst.ParentBlock' null' operand' new SsaVariable[] { " is 126.
Long Statement,Custom.Decompiler.FlowAnalysis,SsaFormBuilder,F:\newReposMay17\Fody_Usable\Fody\Decompiler\FlowAnalysis\SsaFormBuilder.cs,CreateSpecialInstructions,The length of the statement  "		ssaForm.EntryPoint.Instructions.Add (new SsaInstruction (ssaForm.EntryPoint' null' v' null' specialOpCode: SpecialOpCode.Parameter)); " is 133.
Long Statement,Custom.Decompiler.FlowAnalysis,SsaFormBuilder,F:\newReposMay17\Fody_Usable\Fody\Decompiler\FlowAnalysis\SsaFormBuilder.cs,CreateSpecialInstructions,The length of the statement  "		ssaForm.EntryPoint.Instructions.Add (new SsaInstruction (ssaForm.EntryPoint' null' v' null' specialOpCode: SpecialOpCode.Uninitialized)); " is 137.
Long Statement,Custom.Decompiler.FlowAnalysis,SsaFormBuilder,F:\newReposMay17\Fody_Usable\Fody\Decompiler\FlowAnalysis\SsaFormBuilder.cs,CreateSpecialInstructions,The length of the statement  "		ssaForm.EntryPoint.Instructions.Add (new SsaInstruction (ssaForm.EntryPoint' null' v' null' specialOpCode: SpecialOpCode.Uninitialized)); " is 137.
Long Statement,Custom.Decompiler.FlowAnalysis,SsaFormBuilder,F:\newReposMay17\Fody_Usable\Fody\Decompiler\FlowAnalysis\SsaFormBuilder.cs,CreateSpecialInstructions,The length of the statement  "			b.Instructions.Add (new SsaInstruction (b' null' stackLocations [0]' null' specialOpCode: SpecialOpCode.Exception' typeOperand: cfg.Nodes [b.BlockIndex].ExceptionHandler.CatchType)); " is 182.
Long Statement,Custom.Decompiler.FlowAnalysis,SsaOptimization,F:\newReposMay17\Fody_Usable\Fody\Decompiler\FlowAnalysis\SsaOptimization.cs,DirectlyStoreToVariables,The length of the statement  "			if (inst.Instruction != null && (inst.Instruction.OpCode == OpCodes.Stloc || inst.Instruction.OpCode == OpCodes.Starg)) { " is 121.
Long Statement,Custom.Decompiler.FlowAnalysis,TransformToSsa,F:\newReposMay17\Fody_Usable\Fody\Decompiler\FlowAnalysis\TransformToSsa.cs,CollectInformationAboutOriginalVariableUse,The length of the statement  "					addressTaken [ssaForm.GetOriginalVariable ((ParameterDefinition)inst.Instruction.Operand).OriginalVariableIndex] = true; " is 120.
Long Statement,Custom.Decompiler.ILAst,AsyncDecompiler,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\AsyncDecompiler.cs,MatchTaskCreationPattern,The length of the statement  "	if (!method.Body [method.Body.Count - 2].Match (ILCode.Call' out startMethod' out loadStartTarget' out loadStartArgument)) " is 122.
Long Statement,Custom.Decompiler.ILAst,AsyncDecompiler,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\AsyncDecompiler.cs,MatchTaskCreationPattern,The length of the statement  "	if (startMethod.Name != "Start" || startMethod.DeclaringType == null || startMethod.DeclaringType.Namespace != "System.Runtime.CompilerServices") " is 145.
Long Statement,Custom.Decompiler.ILAst,AsyncDecompiler,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\AsyncDecompiler.cs,MatchTaskCreationPattern,The length of the statement  "		if (builderField2.ResolveWithinSameModule () != builderField || !loadStateMachineForBuilderExpr2.MatchLdloca (stateMachineVar)) " is 127.
Long Statement,Custom.Decompiler.ILAst,AsyncDecompiler,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\AsyncDecompiler.cs,ValidateCatchBlock,The length of the statement  "	if (!(setExceptionMethod.Name == "SetException" && IsBuilderFieldOnThis (builderExpr) && exceptionExpr.MatchLdloc (catchBlock.ExceptionVariable))) " is 146.
Long Statement,Custom.Decompiler.ILAst,AsyncDecompiler,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\AsyncDecompiler.cs,IsBuilderFieldOnThis,The length of the statement  "	return builderExpr.Match (ILCode.Ldflda' out fieldRef' out target) && fieldRef.ResolveWithinSameModule () == builderField && target.MatchThis (); " is 145.
Long Statement,Custom.Decompiler.ILAst,AsyncDecompiler,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\AsyncDecompiler.cs,MatchStateAssignment,The length of the statement  "		return fieldRef.ResolveWithinSameModule () == stateField && target.MatchThis () && val.Match (ILCode.Ldc_I4' out stateID); " is 122.
Long Statement,Custom.Decompiler.ILAst,AsyncDecompiler,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\AsyncDecompiler.cs,ConvertBody,The length of the statement  "			StateRangeAnalysis rangeAnalysis = new StateRangeAnalysis (tryBody [0]' StateRangeAnalysisMode.AsyncMoveNext' stateField); " is 122.
Long Statement,Custom.Decompiler.ILAst,AsyncDecompiler,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\AsyncDecompiler.cs,HandleAwait,The length of the statement  "	// call(AsyncTaskMethodBuilder::AwaitUnsafeOnCompleted' ldflda(StateMachine::<>t__builder' ldloc(this))' ldloca(CS$0$0001)' ldloc(this)) " is 136.
Long Statement,Custom.Decompiler.ILAst,AsyncDecompiler,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\AsyncDecompiler.cs,Step2,The length of the statement  "	// brtrue(IL_7C' call(valuetype [mscorlib]System.Runtime.CompilerServices.TaskAwaiter`1<bool>::get_IsCompleted' ldloca(CS$0$0001))) " is 131.
Long Statement,Custom.Decompiler.ILAst,AsyncDecompiler,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\AsyncDecompiler.cs,Step2,The length of the statement  "	// arg_8B_0 = call(valuetype [mscorlib]System.Runtime.CompilerServices.TaskAwaiter`1<bool>::GetResult' ldloca(CS$0$0001)) " is 121.
Long Statement,Custom.Decompiler.ILAst,AsyncDecompiler,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\AsyncDecompiler.cs,Step2,The length of the statement  "	if (!(getAwaiterCall.Match (ILCode.Call' out getAwaiterMethod' out awaitedExpr) || getAwaiterCall.Match (ILCode.Callvirt' out getAwaiterMethod' out awaitedExpr))) " is 162.
Long Statement,Custom.Decompiler.ILAst,AsyncDecompiler,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\AsyncDecompiler.cs,Step2,The length of the statement  "	// brtrue(IL_7C' call(valuetype [mscorlib]System.Runtime.CompilerServices.TaskAwaiter`1<bool>::get_IsCompleted' ldloca(CS$0$0001))) " is 131.
Long Statement,Custom.Decompiler.ILAst,GotoRemoval,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\GotoRemoval.cs,RemoveGotos,The length of the statement  "		foreach (ILExpression gotoExpr in method.GetSelfAndChildrenRecursive<ILExpression> (e => e.Code == ILCode.Br || e.Code == ILCode.Leave)) { " is 138.
Long Statement,Custom.Decompiler.ILAst,GotoRemoval,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\GotoRemoval.cs,RemoveRedundantCode,The length of the statement  "	HashSet<ILLabel> liveLabels = new HashSet<ILLabel> (method.GetSelfAndChildrenRecursive<ILExpression> (e => e.IsBranch ()).SelectMany (e => e.GetBranchTargets ())); " is 163.
Long Statement,Custom.Decompiler.ILAst,GotoRemoval,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\GotoRemoval.cs,RemoveRedundantCode,The length of the statement  "		block.Body = block.Body.Where (n => !n.Match (ILCode.Nop) && !(n is ILLabel && !liveLabels.Contains ((ILLabel)n))).ToList (); " is 125.
Long Statement,Custom.Decompiler.ILAst,GotoRemoval,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\GotoRemoval.cs,RemoveRedundantCode,The length of the statement  "				if (ilCase.Body [count - 2].IsUnconditionalControlFlow () && ilCase.Body [count - 1].Match (ILCode.LoopOrSwitchBreak)) { " is 120.
Long Statement,Custom.Decompiler.ILAst,GotoRemoval,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\GotoRemoval.cs,RemoveRedundantCode,The length of the statement  "		if (defaultCase == null || (defaultCase.Body.Count == 1 && defaultCase.Body.Single ().Match (ILCode.LoopOrSwitchBreak))) { " is 122.
Long Statement,Custom.Decompiler.ILAst,GotoRemoval,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\GotoRemoval.cs,RemoveRedundantCode,The length of the statement  "	if (method.Body.Count > 0 && method.Body.Last ().Match (ILCode.Ret) && ((ILExpression)method.Body.Last ()).Arguments.Count == 0) { " is 130.
Long Statement,Custom.Decompiler.ILAst,GotoRemoval,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\GotoRemoval.cs,Enter,The length of the statement  "			if (GetParents (expr).OfType<ILTryCatchBlock> ().FirstOrDefault () == GetParents (target).OfType<ILTryCatchBlock> ().FirstOrDefault ()) " is 135.
Long Statement,Custom.Decompiler.ILAst,ILAstBuilder,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstBuilder.cs,StackAnalysis,The length of the statement  "	var exceptionHandlerStarts = new HashSet<ByteCode> (methodDef.Body.ExceptionHandlers.Select (eh => instrToByteCode [eh.HandlerStart])); " is 135.
Long Statement,Custom.Decompiler.ILAst,ILAstBuilder,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstBuilder.cs,StackAnalysis,The length of the statement  "		StackSlot[] newStack = StackSlot.ModifyStack (byteCode.StackBefore' byteCode.PopCount ?? byteCode.StackBefore.Length' byteCode.PushCount' byteCode); " is 148.
Long Statement,Custom.Decompiler.ILAst,ILAstBuilder,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstBuilder.cs,StackAnalysis,The length of the statement  "			var loadedBy = locVars.Select (locVar => body.SelectMany (bc => bc.StackBefore).Single (s => s.LoadFrom == locVar)).ToList (); " is 126.
Long Statement,Custom.Decompiler.ILAst,ILAstBuilder,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstBuilder.cs,ConvertLocalVariables,The length of the statement  "		if (!optimize || varDef.IsPinned || uses.Any (b => b.VariablesBefore [varDef.Index].UnknownDefinition || (b.Code == ILCode.Ldloca && !IsDeterministicLdloca (b)))) { " is 164.
Long Statement,Custom.Decompiler.ILAst,ILAstBuilder,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstBuilder.cs,ConvertToAst,The length of the statement  "		var handlers = ehs.Where (eh => eh.TryStart.Offset == tryStart && eh.TryEnd.Offset == tryEnd).OrderBy (eh => eh.TryStart.Offset).ToList (); " is 139.
Long Statement,Custom.Decompiler.ILAst,ILAstBuilder,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstBuilder.cs,ConvertToAst,The length of the statement  "			HashSet<ExceptionHandler> nestedEHs = new HashSet<ExceptionHandler> (ehs.Where (eh => (tryStart <= eh.TryStart.Offset && eh.TryEnd.Offset < tryEnd) || (tryStart < eh.TryStart.Offset && eh.TryEnd.Offset <= tryEnd))); " is 215.
Long Statement,Custom.Decompiler.ILAst,ILAstBuilder,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstBuilder.cs,ConvertToAst,The length of the statement  "			HashSet<ExceptionHandler> nestedEHs = new HashSet<ExceptionHandler> (ehs.Where (e => (eh.HandlerStart.Offset <= e.TryStart.Offset && e.TryEnd.Offset < handlerEndOffset) || (eh.HandlerStart.Offset < e.TryStart.Offset && e.TryEnd.Offset <= handlerEndOffset))); " is 258.
Long Statement,Custom.Decompiler.ILAst,ILAstBuilder,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstBuilder.cs,ConvertToAst,The length of the statement  "					if (first != null && first.Code == ILCode.Pop && first.Arguments [0].Code == ILCode.Ldloc && first.Arguments [0].Operand == ldexception.StoreTo [0]) { " is 150.
Long Statement,Custom.Decompiler.ILAst,ILAstOptimizer,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,RemoveRedundantCode,The length of the statement  "	foreach (ILLabel target in method.GetSelfAndChildrenRecursive<ILExpression> (e => e.IsBranch ()).SelectMany (e => e.GetBranchTargets ())) { " is 139.
Long Statement,Custom.Decompiler.ILAst,ILAstOptimizer,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,IntroducePropertyAccessInstructions,The length of the statement  "		if (expr.Arguments [0].Match (ILCode.Ldloc' out target) && expr.Arguments [1].Code == ILCode.Ldvirtftn && expr.Arguments [1].Arguments.Count == 1 && expr.Arguments [1].Arguments [0].MatchLdloc (target)) { " is 204.
Long Statement,Custom.Decompiler.ILAst,ILAstOptimizer,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,RemoveEndFinally,The length of the statement  "	foreach (var tryCatch in method.GetSelfAndChildrenRecursive<ILTryCatchBlock> (tc => tc.FinallyBlock != null).Reverse ()) { " is 122.
Long Statement,Custom.Decompiler.ILAst,ILAstOptimizer,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,RecombineVariables,The length of the statement  "	// The DeclareVariables transformation might then split up the C# variable again if it is used indendently in two separate scopes. " is 130.
Long Statement,Custom.Decompiler.ILAst,ILAstOptimizer,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,ReportUnassignedILRanges,The length of the statement  "	var unassigned = ILRange.Invert (method.GetSelfAndChildrenRecursive<ILExpression> ().SelectMany (e => e.ILRanges)' context.CurrentMethod.Body.CodeSize).ToList (); " is 162.
Long Statement,Custom.Decompiler.ILAst,ILAstOptimizer,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,ReportUnassignedILRanges,The length of the statement  "		Debug.WriteLine (string.Format ("Unassigned ILRanges for {0}.{1}: {2}"' this.context.CurrentMethod.DeclaringType.Name' this.context.CurrentMethod.Name' string.Join ("' "' unassigned.Select (r => r.ToString ())))); " is 213.
Long Statement,Custom.Decompiler.ILAst,ILAstOptimizer,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,TransformArrayInitializers,The length of the statement  "	if (expr.Match (ILCode.Stloc' out v' out newarrExpr) && newarrExpr.Match (ILCode.Newarr' out elementType' out lengthExpr) && lengthExpr.Match (ILCode.Ldc_I4' out arrayLength) && arrayLength > 0) { " is 196.
Long Statement,Custom.Decompiler.ILAst,ILAstOptimizer,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,TransformArrayInitializers,The length of the statement  "		if (ForwardScanInitializeArrayRuntimeHelper (body' pos + 1' v' elementType' arrayLength' out newArr' out initArrayPos)) { " is 121.
Long Statement,Custom.Decompiler.ILAst,ILAstOptimizer,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,TransformArrayInitializers,The length of the statement  "			if (nextExpr != null && nextExpr.Code.IsStoreToArray () && nextExpr.Arguments [0].Match (ILCode.Ldloc' out v3) && v == v3 && nextExpr.Arguments [1].Match (ILCode.Ldc_I4' out arrayPos) && arrayPos >= operands.Count && arrayPos <= operands.Count + maxConsecutiveDefaultValueExpressions && !nextExpr.Arguments [2].ContainsReferenceTo (v3)) { " is 338.
Long Statement,Custom.Decompiler.ILAst,ILAstOptimizer,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,TransformMultidimensionalArrayInitializers,The length of the statement  "	if (expr.Match (ILCode.Stloc' out v' out newarrExpr) && newarrExpr.Match (ILCode.Newobj' out ctor' out ctorArgs) && (arrayType = (ctor.DeclaringType as ArrayType)) != null && arrayType.Rank == ctorArgs.Count) { " is 210.
Long Statement,Custom.Decompiler.ILAst,ILAstOptimizer,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,TransformMultidimensionalArrayInitializers,The length of the statement  "		if (ForwardScanInitializeArrayRuntimeHelper (body' pos + 1' v' arrayType' totalElements' out newArr' out initArrayPos)) { " is 121.
Long Statement,Custom.Decompiler.ILAst,ILAstOptimizer,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,ForwardScanInitializeArrayRuntimeHelper,The length of the statement  "	if (body.ElementAtOrDefault (pos).Match (ILCode.Call' out methodRef' out methodArg1' out methodArg2) && methodRef.DeclaringType.FullName == "System.Runtime.CompilerServices.RuntimeHelpers" && methodRef.Name == "InitializeArray" && methodArg1.Match (ILCode.Ldloc' out v2) && array == v2 && methodArg2.Match (ILCode.Ldtoken' out fieldRef)) { " is 339.
Long Statement,Custom.Decompiler.ILAst,ILAstOptimizer,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,TransformObjectInitializers,The length of the statement  "	ILExpression initializer = ParseObjectInitializer (body' ref pos' v' newObjExpr' IsCollectionType (newObjType)' isValueType); " is 125.
Long Statement,Custom.Decompiler.ILAst,ILAstOptimizer,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,ParseObjectInitializer,The length of the statement  "	ILExpression objectInitializer = new ILExpression (isCollection ? ILCode.InitCollection : ILCode.InitObject' null' newObjExpr); " is 127.
Long Statement,Custom.Decompiler.ILAst,ILAstOptimizer,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,AdjustInitializerStack,The length of the statement  "		ILExpression nestedInitializer = new ILExpression (IsCollectionType (returnType) ? ILCode.InitCollection : ILCode.InitObject' null' g); " is 135.
Long Statement,Custom.Decompiler.ILAst,ILAstOptimizer,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,TransformDecimalCtorToConstant,The length of the statement  "	if (expr.Match (ILCode.Newobj' out r' out args) && r.DeclaringType.Namespace == "System" && r.DeclaringType.Name == "Decimal") { " is 128.
Long Statement,Custom.Decompiler.ILAst,ILAstOptimizer,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,TransformDecimalCtorToConstant,The length of the statement  "			if (expr.Arguments [0].Match (ILCode.Ldc_I4' out lo) && expr.Arguments [1].Match (ILCode.Ldc_I4' out mid) && expr.Arguments [2].Match (ILCode.Ldc_I4' out hi) && expr.Arguments [3].Match (ILCode.Ldc_I4' out isNegative) && expr.Arguments [4].Match (ILCode.Ldc_I4' out scale)) { " is 275.
Long Statement,Custom.Decompiler.ILAst,ILAstOptimizer,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,RemoveConvIFromArrayCreation,The length of the statement  "		if (length.Match (ILCode.Conv_Ovf_I' out input) || length.Match (ILCode.Conv_I' out input) || length.Match (ILCode.Conv_Ovf_I_Un' out input) || length.Match (ILCode.Conv_U' out input)) { " is 186.
Long Statement,Custom.Decompiler.ILAst,ILAstOptimizer,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,CachedDelegateInitializationWithField,The length of the statement  "	if (!(stsfld != null && stsfld.Code == ILCode.Stsfld && ((FieldReference)stsfld.Operand).ResolveWithinSameModule () == field)) " is 126.
Long Statement,Custom.Decompiler.ILAst,ILAstOptimizer,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,CachedDelegateInitializationWithField,The length of the statement  "	if (followingNode != null && followingNode.GetSelfAndChildrenRecursive<ILExpression> ().Count (e => e.Code == ILCode.Ldsfld && ((FieldReference)e.Operand).ResolveWithinSameModule () == field) == 1) { " is 199.
Long Statement,Custom.Decompiler.ILAst,ILAstOptimizer,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,CachedDelegateInitializationWithField,The length of the statement  "				if (parent.Arguments [j].Code == ILCode.Ldsfld && ((FieldReference)parent.Arguments [j].Operand).ResolveWithinSameModule () == field) { " is 135.
Long Statement,Custom.Decompiler.ILAst,ILAstOptimizer,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,CachedDelegateInitializationWithLocal,The length of the statement  "	if (followingNode != null && followingNode.GetSelfAndChildrenRecursive<ILExpression> ().Count (e => e.Code == ILCode.Ldloc && (ILVariable)e.Operand == v) == 1) { " is 161.
Long Statement,Custom.Decompiler.ILAst,ILAstOptimizer,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,CachedDelegateInitializationWithLocal,The length of the statement  "		if (!(inlining.numLdloc.GetOrDefault (v) == 2 && inlining.numStloc.GetOrDefault (v) == 2 && inlining.numLdloca.GetOrDefault (v) == 0)) " is 134.
Long Statement,Custom.Decompiler.ILAst,ILAstOptimizer,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,CachedDelegateInitializationWithLocal,The length of the statement  "				if (storeBlock.Body [j].Match (ILCode.Stloc' out storedVar' out storedExpr) && storedVar == v && storedExpr.Match (ILCode.Ldnull)) { " is 132.
Long Statement,Custom.Decompiler.ILAst,ILAstOptimizer,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,MakeAssignmentExpression,The length of the statement  "	} else if ((nextExpr.Code == ILCode.Stsfld || nextExpr.Code == ILCode.CallSetter || nextExpr.Code == ILCode.CallvirtSetter) && nextExpr.Arguments.Count == 1) { " is 159.
Long Statement,Custom.Decompiler.ILAst,ILAstOptimizer,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,MakeCompoundAssignments,The length of the statement  "	// (which does a reversible transform to the short operator form' as the introduction of checked/unchecked might have to revert to the long form). " is 146.
Long Statement,Custom.Decompiler.ILAst,ILAstOptimizer,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,MakeCompoundAssignment,The length of the statement  "	// in case of compound assignments with a lifted operator the result is inside NullableOf and the operand is inside ValueOf " is 123.
Long Statement,Custom.Decompiler.ILAst,ILAstOptimizer,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,IntroducePostIncrementForInstanceFields,The length of the statement  "	// stelem.any(T' ldloc(instance)' ldloc(pos)' add(stloc(helperVar' ldelem.any(T' ldloc(instance)' ldloc(pos)))' ldc.i4(1))) " is 123.
Long Statement,Custom.Decompiler.ILAst,ILAstOptimizer,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,IntroducePostIncrementForInstanceFields,The length of the statement  "	if (!(expr.Code == ILCode.Stfld || expr.Code.IsStoreToArray () || expr.Code == ILCode.Stobj || expr.Code == ILCode.CallSetter || expr.Code == ILCode.CallvirtSetter)) " is 165.
Long Statement,Custom.Decompiler.ILAst,ILAstOptimizer,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,IntroducePostIncrementForInstanceFields,The length of the statement  "		if (!(TypeAnalysis.IsSameType (getField.DeclaringType' setField.DeclaringType) && getField.Name == setField.Name && TypeAnalysis.IsSameType (getField.FieldType' setField.FieldType))) { " is 184.
Long Statement,Custom.Decompiler.ILAst,ILAstOptimizer,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,MatchFixedInitializer,The length of the statement  "		if (ifStmt.TrueBlock != null && ifStmt.TrueBlock.Body.Count == 1 && ifStmt.TrueBlock.Body [0].Match (ILCode.Stloc' out pinnedVar' out trueValue) && pinnedVar.IsPinned && IsNullOrZero (trueValue)) { " is 197.
Long Statement,Custom.Decompiler.ILAst,ILAstOptimizer,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,MatchFixedInitializer,The length of the statement  "				if (fixedStmt.Initializers.Count == 1 && fixedStmt.BodyBlock.Body.Count == 0 && fixedStmt.Initializers [0].Match (ILCode.Stloc' out stlocVar' out falseValue) && stlocVar == pinnedVar) { " is 185.
Long Statement,Custom.Decompiler.ILAst,ILAstOptimizer,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,MatchFixedInitializer,The length of the statement  "					if (falseValue.Code == ILCode.Ldelema && falseValue.Arguments [0].Match (ILCode.Ldloc' out loadedVariable) && loadedVariable == arrayVariable && IsNullOrZero (falseValue.Arguments [1])) { " is 187.
Long Statement,Custom.Decompiler.ILAst,ILAstOptimizer,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,MatchFixedInitializer,The length of the statement  "							if (inlining.numLdloc.GetOrDefault (arrayVariable) == 2 && inlining.numStloc.GetOrDefault (arrayVariable) == 1 && inlining.numLdloca.GetOrDefault (arrayVariable) == 0) { " is 169.
Long Statement,Custom.Decompiler.ILAst,ILAstOptimizer,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,MatchFixedArrayInitializerCondition,The length of the statement  "		if (initValue.Match (ILCode.Ldloc' out arrayVar) || initValue.Match (ILCode.Stloc' out arrayVar' out arrayVarInitializer)) { " is 124.
Long Statement,Custom.Decompiler.ILAst,ILAstOptimizer,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,HandleStringFixing,The length of the statement  "	if (!(body [pos].Match (ILCode.Stloc' out var1' out varAssignment) && varAssignment.Match (ILCode.Stloc' out var2' out ptrInitialization))) " is 139.
Long Statement,Custom.Decompiler.ILAst,ILAstOptimizer,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,HandleStringFixing,The length of the statement  "	if (!(ifStmt != null && ifStmt.TrueBlock != null && ifStmt.TrueBlock.Body.Count == 1 && (ifStmt.FalseBlock == null || ifStmt.FalseBlock.Body.Count == 0))) " is 154.
Long Statement,Custom.Decompiler.ILAst,ILAstOptimizer,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,HandleStringFixing,The length of the statement  "	if (!(ifStmt.TrueBlock.Body [0].Match (ILCode.Stloc' out assignedVar' out assignedExpr) && assignedVar == var2 && assignedExpr.Code == ILCode.Add)) " is 147.
Long Statement,Custom.Decompiler.ILAst,ILAstOptimizer,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,HandleStringFixing,The length of the statement  "	if (!(assignedExpr.Arguments [1].Match (ILCode.Call' out calledMethod) || assignedExpr.Arguments [1].Match (ILCode.CallGetter' out calledMethod))) " is 146.
Long Statement,Custom.Decompiler.ILAst,ILAstOptimizer,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,HandleStringFixing,The length of the statement  "	if (!(calledMethod.Name == "get_OffsetToStringData" && calledMethod.DeclaringType.FullName == "System.Runtime.CompilerServices.RuntimeHelpers")) " is 144.
Long Statement,Custom.Decompiler.ILAst,ILAstOptimizer,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,SimplifyLogicNot,The length of the statement  "	if (expr.Code == ILCode.Ceq && TypeAnalysis.IsBoolean (expr.Arguments [0].InferredType) && (a = expr.Arguments [1]).Code == ILCode.Ldc_I4 && (int)a.Operand == 0) { " is 163.
Long Statement,Custom.Decompiler.ILAst,ILAstOptimizer,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,MatchParameterVariableAssignment,The length of the statement  "	if (!(parameterMethod.Name == "Parameter" && parameterMethod.DeclaringType.FullName == "System.Linq.Expressions.Expression")) " is 125.
Long Statement,Custom.Decompiler.ILAst,ILInlining,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILInlining.cs,IsGeneratedValueTypeTemporary,The length of the statement  "			if (arg.Code == ILCode.CallGetter || arg.Code == ILCode.CallvirtGetter || arg.Code == ILCode.Call || arg.Code == ILCode.Callvirt) { " is 131.
Long Statement,Custom.Decompiler.ILAst,ILInlining,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILInlining.cs,FindLoadInNext,The length of the statement  "		if (i == 1 && (expr.Code == ILCode.LogicAnd || expr.Code == ILCode.LogicOr || expr.Code == ILCode.TernaryOp || expr.Code == ILCode.NullCoalescing)) " is 147.
Long Statement,Custom.Decompiler.ILAst,ILInlining,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILInlining.cs,CopyPropagation,The length of the statement  "			if (block.Body [i].Match (ILCode.Stloc' out v' out copiedExpr) && !v.IsParameter && numStloc.GetOrDefault (v) == 1 && numLdloca.GetOrDefault (v) == 0 && CanPerformCopyPropagation (copiedExpr' v)) { " is 197.
Long Statement,Custom.Decompiler.ILAst,LoopsAndConditions,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\LoopsAndConditions.cs,BuildGraph,The length of the statement  "		foreach (ILLabel target in node.GetSelfAndChildrenRecursive<ILExpression> (e => e.IsBranch ()).SelectMany (e => e.GetBranchTargets ())) { " is 137.
Long Statement,Custom.Decompiler.ILAst,LoopsAndConditions,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\LoopsAndConditions.cs,BuildGraph,The length of the statement  "			if (labelToCfNode.TryGetValue (target' out destination) && (destination != source || target == node.Body.FirstOrDefault ())) { " is 126.
Long Statement,Custom.Decompiler.ILAst,LoopsAndConditions,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\LoopsAndConditions.cs,FindLoops,The length of the statement  "				if ((!loopContents.Contains (trueTarget) && loopContents.Contains (falseTarget)) || (loopContents.Contains (trueTarget) && !loopContents.Contains (falseTarget))) { " is 163.
Long Statement,Custom.Decompiler.ILAst,PatternMatching,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\PatternMatching.cs,MatchSingleAndBr,The length of the statement  "	if (bb.Body.Count == 3 && bb.Body [0] is ILLabel && bb.Body [1].Match (code' out operand' out arg) && bb.Body [2].Match (ILCode.Br' out brLabel)) { " is 147.
Long Statement,Custom.Decompiler.ILAst,PatternMatching,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\PatternMatching.cs,MatchLastAndBr,The length of the statement  "	if (bb.Body.ElementAtOrDefault (bb.Body.Count - 2).Match (code' out operand' out arg) && bb.Body.LastOrDefault ().Match (ILCode.Br' out brLabel)) { " is 147.
Long Statement,Custom.Decompiler.ILAst,SimpleControlFlow,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\SimpleControlFlow.cs,SimplifyTernaryOperator,The length of the statement  "	if (head.MatchLastAndBr (ILCode.Brtrue' out trueLabel' out condExpr' out falseLabel) && labelGlobalRefCount [trueLabel] == 1 && labelGlobalRefCount [falseLabel] == 1 && ((labelToBasicBlock [trueLabel].MatchSingleAndBr (ILCode.Stloc' out trueLocVar' out trueExpr' out trueFall) && labelToBasicBlock [falseLabel].MatchSingleAndBr (ILCode.Stloc' out falseLocVar' out falseExpr' out falseFall) && trueLocVar == falseLocVar && trueFall == falseFall) || (labelToBasicBlock [trueLabel].MatchSingle (ILCode.Ret' out unused' out trueExpr) && labelToBasicBlock [falseLabel].MatchSingle (ILCode.Ret' out unused' out falseExpr))) && body.Contains (labelToBasicBlock [trueLabel]) && body.Contains (labelToBasicBlock [falseLabel])) { " is 719.
Long Statement,Custom.Decompiler.ILAst,SimpleControlFlow,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\SimpleControlFlow.cs,SimplifyTernaryOperator,The length of the statement  "		if (retTypeIsBoolean && trueExpr.Match (ILCode.Ldc_I4' out leftBoolVal) && falseExpr.Match (ILCode.Ldc_I4' out rightBoolVal) && ((leftBoolVal != 0 && rightBoolVal == 0) || (leftBoolVal == 0 && rightBoolVal != 0))) { " is 215.
Long Statement,Custom.Decompiler.ILAst,SimpleControlFlow,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\SimpleControlFlow.cs,SimplifyTernaryOperator,The length of the statement  "		} else if ((retTypeIsBoolean || TypeAnalysis.IsBoolean (falseExpr.InferredType)) && trueExpr.Match (ILCode.Ldc_I4' out leftBoolVal) && (leftBoolVal == 0 || leftBoolVal == 1)) { " is 176.
Long Statement,Custom.Decompiler.ILAst,SimpleControlFlow,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\SimpleControlFlow.cs,SimplifyTernaryOperator,The length of the statement  "				newExpr = MakeLeftAssociativeShortCircuit (ILCode.LogicAnd' new ILExpression (ILCode.LogicNot' null' condExpr)' falseExpr); " is 123.
Long Statement,Custom.Decompiler.ILAst,SimpleControlFlow,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\SimpleControlFlow.cs,SimplifyTernaryOperator,The length of the statement  "		} else if ((retTypeIsBoolean || TypeAnalysis.IsBoolean (trueExpr.InferredType)) && falseExpr.Match (ILCode.Ldc_I4' out rightBoolVal) && (rightBoolVal == 0 || rightBoolVal == 1)) { " is 179.
Long Statement,Custom.Decompiler.ILAst,SimpleControlFlow,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\SimpleControlFlow.cs,SimplifyTernaryOperator,The length of the statement  "				newExpr = MakeLeftAssociativeShortCircuit (ILCode.LogicOr' new ILExpression (ILCode.LogicNot' null' condExpr)' trueExpr); " is 121.
Long Statement,Custom.Decompiler.ILAst,SimpleControlFlow,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\SimpleControlFlow.cs,SimplifyNullCoalescing,The length of the statement  "	if (head.Body.Count >= 3 && head.Body [head.Body.Count - 3].Match (ILCode.Stloc' out v' out leftExpr) && leftExpr.Match (ILCode.Ldloc' out leftVar) && head.MatchLastAndBr (ILCode.Brtrue' out endBBLabel' out leftExpr2' out rightBBLabel) && leftExpr2.MatchLdloc (leftVar) && labelToBasicBlock.TryGetValue (rightBBLabel' out rightBB) && rightBB.MatchSingleAndBr (ILCode.Stloc' out v2' out rightExpr' out endBBLabel2) && v == v2 && endBBLabel == endBBLabel2 && labelGlobalRefCount.GetOrDefault (rightBBLabel) == 1 && body.Contains (rightBB)) { " is 539.
Long Statement,Custom.Decompiler.ILAst,SimpleControlFlow,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\SimpleControlFlow.cs,SimplifyNullCoalescing,The length of the statement  "		head.Body.Add (new ILExpression (ILCode.Stloc' v' new ILExpression (ILCode.NullCoalescing' null' leftExpr' rightExpr))); " is 120.
Long Statement,Custom.Decompiler.ILAst,SimpleControlFlow,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\SimpleControlFlow.cs,SimplifyShortCircuit,The length of the statement  "			if (body.Contains (nextBasicBlock) && nextBasicBlock != head && labelGlobalRefCount [(ILLabel)nextBasicBlock.Body.First ()] == 1 && nextBasicBlock.MatchSingleAndBr (ILCode.Brtrue' out nextTrueLablel' out nextCondExpr' out nextFalseLabel) && (otherLablel == nextFalseLabel || otherLablel == nextTrueLablel)) { " is 308.
Long Statement,Custom.Decompiler.ILAst,SimpleControlFlow,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\SimpleControlFlow.cs,SimplifyShortCircuit,The length of the statement  "					logicExpr = MakeLeftAssociativeShortCircuit (ILCode.LogicAnd' negate ? new ILExpression (ILCode.LogicNot' null' condExpr) : condExpr' nextCondExpr); " is 148.
Long Statement,Custom.Decompiler.ILAst,SimpleControlFlow,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\SimpleControlFlow.cs,SimplifyShortCircuit,The length of the statement  "					logicExpr = MakeLeftAssociativeShortCircuit (ILCode.LogicOr' negate ? condExpr : new ILExpression (ILCode.LogicNot' null' condExpr)' nextCondExpr); " is 147.
Long Statement,Custom.Decompiler.ILAst,SimpleControlFlow,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\SimpleControlFlow.cs,JoinBasicBlocks,The length of the statement  "	if (!head.Body.ElementAtOrDefault (head.Body.Count - 2).IsConditionalControlFlow () && head.Body.Last ().Match (ILCode.Br' out nextLabel) && labelGlobalRefCount [nextLabel] == 1 && labelToBasicBlock.TryGetValue (nextLabel' out nextBB) && body.Contains (nextBB) && nextBB.Body.First () == nextLabel && !nextBB.Body.OfType<ILTryCatchBlock> ().Any ()) { " is 350.
Long Statement,Custom.Decompiler.ILAst,SymbolicEvaluationContext,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\SymbolicExecution.cs,Eval,The length of the statement  "		return new SymbolicValue (expr.Code == ILCode.Ceq ? SymbolicValueType.StateEquals : SymbolicValueType.StateInEquals' unchecked(right.Constant - left.Constant)); " is 160.
Long Statement,Custom.Decompiler.ILAst,TypeAnalysis,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\TypeAnalysis.cs,CreateDependencyGraph,The length of the statement  "	if (catchBlock != null && catchBlock.ExceptionVariable != null && catchBlock.ExceptionType != null && catchBlock.ExceptionVariable.Type == null) { " is 146.
Long Statement,Custom.Decompiler.ILAst,TypeAnalysis,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\TypeAnalysis.cs,IdentifySingleLoadVariables,The length of the statement  "		if (g.Count () == 1 && g.Single ().Expression.GetSelfAndChildrenRecursive<ILExpression> ().Count (e => e.Operand == v) == 1) { " is 126.
Long Statement,Custom.Decompiler.ILAst,TypeAnalysis,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\TypeAnalysis.cs,RunInference,The length of the statement  "			if (!expr.Done && expr.Dependencies.TrueForAll (v => v.Type != null || singleLoadVariables.Contains (v)) && (expr.DependsOnSingleLoad == null || expr.DependsOnSingleLoad.Type != null || ignoreSingleLoadDependencies)) { " is 218.
Long Statement,Custom.Decompiler.ILAst,TypeAnalysis,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\TypeAnalysis.cs,RunInference,The length of the statement  "			if (v.Type == null && (assignVariableTypesBasedOnPartialInformation ? pair.Value.Any (e => e.Done) : pair.Value.All (e => e.Done))) { " is 133.
Long Statement,Custom.Decompiler.ILAst,TypeAnalysis,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\TypeAnalysis.cs,DoInferTypeForExpression,The length of the statement  "					InferTypeForExpression (expr.Arguments [0]' MakeRefIfValueType (method.DeclaringType' expr.GetPrefix (ILCode.Constrained))); " is 124.
Long Statement,Custom.Decompiler.ILAst,TypeAnalysis,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\TypeAnalysis.cs,DoInferTypeForExpression,The length of the statement  "					InferTypeForExpression (expr.Arguments [i]' SubstituteTypeArgs (method.Parameters [method.HasThis ? i - 1 : i].ParameterType' method)); " is 135.
Long Statement,Custom.Decompiler.ILAst,TypeAnalysis,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\TypeAnalysis.cs,DoInferTypeForExpression,The length of the statement  "			InferTypeForExpression (expr.Arguments [0]' MakeRefIfValueType (((FieldReference)expr.Operand).DeclaringType' expr.GetPrefix (ILCode.Constrained))); " is 148.
Long Statement,Custom.Decompiler.ILAst,TypeAnalysis,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\TypeAnalysis.cs,DoInferTypeForExpression,The length of the statement  "			InferTypeForExpression (expr.Arguments [0]' MakeRefIfValueType (((FieldReference)expr.Operand).DeclaringType' expr.GetPrefix (ILCode.Constrained))); " is 148.
Long Statement,Custom.Decompiler.ILAst,TypeAnalysis,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\TypeAnalysis.cs,DoInferTypeForExpression,The length of the statement  "			InferTypeForExpression (expr.Arguments [0]' MakeRefIfValueType (((FieldReference)expr.Operand).DeclaringType' expr.GetPrefix (ILCode.Constrained))); " is 148.
Long Statement,Custom.Decompiler.ILAst,TypeAnalysis,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\TypeAnalysis.cs,DoInferTypeForExpression,The length of the statement  "			else if (infoAmount == GetInformationAmount (operandType) && IsSigned (elementType) != null && IsSigned (operandType) != null) " is 126.
Long Statement,Custom.Decompiler.ILAst,TypeAnalysis,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\TypeAnalysis.cs,DoInferTypeForExpression,The length of the statement  "		if (expectedType != null && (expectedType.MetadataType == MetadataType.Int32 || expectedType.MetadataType == MetadataType.UInt32 || expectedType.MetadataType == MetadataType.Int64 || expectedType.MetadataType == MetadataType.UInt64)) " is 233.
Long Statement,Custom.Decompiler.ILAst,TypeAnalysis,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\TypeAnalysis.cs,DoInferTypeForExpression,The length of the statement  "		return (expectedType != null && expectedType.MetadataType == MetadataType.Single) ? typeSystem.Single : typeSystem.Double; " is 122.
Long Statement,Custom.Decompiler.ILAst,TypeAnalysis,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\TypeAnalysis.cs,HandleConversion,The length of the statement  "	TypeReference resultType = (GetInformationAmount (expectedType) == targetBitSize && IsSigned (expectedType) == targetSigned) ? expectedType : targetType; " is 153.
Long Statement,Custom.Decompiler.ILAst,TypeAnalysis,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\TypeAnalysis.cs,CreateNullableType,The length of the statement  "	var t = new GenericInstanceType (new TypeReference ("System"' "Nullable`1"' module' module.TypeSystem.CoreLibrary' true)); " is 122.
Long Statement,Custom.Decompiler.ILAst,TypeAnalysis,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\TypeAnalysis.cs,GetEnumUnderlyingType,The length of the statement  "	// unfortunately we cannot rely on enumType.IsValueType here - it's not set when the instruction operand is a typeref (as opposed to a typespec) " is 144.
Long Statement,Custom.Decompiler.ILAst,TypeAnalysis,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\TypeAnalysis.cs,IsEnum,The length of the statement  "	// unfortunately we cannot rely on type.IsValueType here - it's not set when the instruction operand is a typeref (as opposed to a typespec) " is 140.
Long Statement,Custom.Decompiler.ILAst,YieldReturnDecompiler,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\YieldReturnDecompiler.cs,AnalyzeCtor,The length of the statement  "		if (node.Match (ILCode.Stfld' out field' out instExpr' out stExpr) && instExpr.MatchThis () && stExpr.Match (ILCode.Ldloc' out arg) && arg.IsParameter && arg.OriginalParameter.Index == 0) { " is 189.
Long Statement,Custom.Decompiler.ILAst,YieldReturnDecompiler,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\YieldReturnDecompiler.cs,AnalyzeCurrentProperty,The length of the statement  "	MethodDefinition getCurrentMethod = enumeratorType.Methods.FirstOrDefault (m => m.Name.StartsWith ("System.Collections.Generic.IEnumerator"' StringComparison.Ordinal) && m.Name.EndsWith (".get_Current"' StringComparison.Ordinal)); " is 230.
Long Statement,Custom.Decompiler.ILAst,YieldReturnDecompiler,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\YieldReturnDecompiler.cs,AnalyzeCurrentProperty,The length of the statement  "		if (method.Body [0].Match (ILCode.Ret' out retExpr) && retExpr.Match (ILCode.Ldfld' out field' out ldFromObj) && ldFromObj.MatchThis ()) { " is 138.
Long Statement,Custom.Decompiler.ILAst,YieldReturnDecompiler,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\YieldReturnDecompiler.cs,AnalyzeCurrentProperty,The length of the statement  "		if (method.Body [0].Match (ILCode.Stloc' out v' out stExpr) && stExpr.Match (ILCode.Ldfld' out field' out ldFromObj) && ldFromObj.MatchThis () && method.Body [1].Match (ILCode.Ret' out retExpr) && retExpr.Match (ILCode.Ldloc' out v2) && v == v2) { " is 247.
Long Statement,Custom.Decompiler.ILAst,YieldReturnDecompiler,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\YieldReturnDecompiler.cs,ResolveIEnumerableIEnumeratorFieldMapping,The length of the statement  "	MethodDefinition getEnumeratorMethod = enumeratorType.Methods.FirstOrDefault (m => m.Name.StartsWith ("System.Collections.Generic.IEnumerable"' StringComparison.Ordinal) && m.Name.EndsWith (".GetEnumerator"' StringComparison.Ordinal)); " is 235.
Long Statement,Custom.Decompiler.ILAst,YieldReturnDecompiler,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\YieldReturnDecompiler.cs,ResolveIEnumerableIEnumeratorFieldMapping,The length of the statement  "		if (node.Match (ILCode.Stfld' out stField' out stToObj' out stExpr) && stExpr.Match (ILCode.Ldfld' out ldField' out ldFromObj) && ldFromObj.MatchThis ()) { " is 155.
Long Statement,Custom.Decompiler.ILAst,YieldReturnDecompiler,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\YieldReturnDecompiler.cs,ConvertBody,The length of the statement  "			if (br == null || !(br.Code == ILCode.Br || br.Code == ILCode.Leave) || br.Operand != returnLabel || expr.Arguments [0].Code != ILCode.Ldc_I4) " is 142.
Complex Conditional,Custom.Decompiler.Ast,AstBuilder,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\AstBuilder.cs,MemberIsHidden,The conditional expression  "method.IsGetter || method.IsSetter || method.IsAddOn || method.IsRemoveOn"  is complex.
Complex Conditional,Custom.Decompiler.Ast,AstBuilder,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\AstBuilder.cs,CreateProperty,The conditional expression  "accessor.IsVirtual && !accessor.IsNewSlot && (propDef.GetMethod == null || propDef.SetMethod == null)"  is complex.
Complex Conditional,Custom.Decompiler.Ast,AstBuilder,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\AstBuilder.cs,ConvertAttributes,The conditional expression  "layoutKind != defaultLayoutKind || charSet != CharSet.Ansi || typeDefinition.PackingSize > 0 || typeDefinition.ClassSize > 0"  is complex.
Complex Conditional,Custom.Decompiler.Ast,NameVariables,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\NameVariables.cs,GetNameByType,The conditional expression  "name.Length >= 3 && name [0] == 'I' && char.IsUpper (name [1]) && char.IsLower (name [2])"  is complex.
Complex Conditional,Custom.Decompiler.Ast,TextOutputFormatter,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\TextOutputFormatter.cs,GetCurrentMemberReference,The conditional expression  "(node.Role == Roles.Type && node.Parent is ObjectCreateExpression) || (memberRef == null && node.Role == Roles.TargetExpression && (node.Parent is InvocationExpression || node.Parent is ObjectCreateExpression))"  is complex.
Complex Conditional,Custom.Decompiler,CecilExtensions,F:\newReposMay17\Fody_Usable\Fody\Decompiler\CecilExtensions.cs,IsAnonymousType,The conditional expression  "string.IsNullOrEmpty (type.Namespace) && type.HasGeneratedName () && (type.Name.Contains ("AnonType") || type.Name.Contains ("AnonymousType"))"  is complex.
Complex Conditional,Custom.Decompiler.Ast.Transforms,TypePattern,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\Transforms\CustomPatterns.cs,DoMatch,The conditional expression  "ct != null && !ct.HasNullableSpecifier && ct.PointerRank == 0 && !ct.ArraySpecifiers.Any ()"  is complex.
Complex Conditional,Custom.Decompiler.Ast.Transforms,DeclareVariables,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\Transforms\DeclareVariables.cs,CanMoveVariableUseIntoSubBlock,The conditional expression  "!allowPassIntoLoops && (stmt is ForStatement || stmt is ForeachStatement || stmt is DoWhileStatement || stmt is WhileStatement)"  is complex.
Complex Conditional,Custom.Decompiler.Ast.Transforms,DelegateConstruction,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\Transforms\DelegateConstruction.cs,HandleAnonymousMethod,The conditional expression  "target != null && !(target is IdentifierExpression || target is ThisReferenceExpression || target is NullReferenceExpression)"  is complex.
Complex Conditional,Custom.Decompiler.Ast.Transforms,IntroduceExtensionMethods,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\Transforms\IntroduceExtensionMethods.cs,Run,The conditional expression  "mre != null && mre.Target is TypeReferenceExpression && methodReference != null && invocation.Arguments.Any ()"  is complex.
Complex Conditional,Custom.Decompiler.Ast.Transforms,PatternStatementTransform,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\Transforms\PatternStatementTransform.cs,TryGetPairFrom,The conditional expression  "arg1 != null && arg2 != null && arg1.Value is string && arg2.Value is int"  is complex.
Complex Conditional,Custom.Decompiler.Ast.Transforms,PushNegation,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\Transforms\PushNegation.cs,VisitBinaryOperatorExpression,The conditional expression  "op == BinaryOperatorType.Equality && rightOperand == true || op == BinaryOperatorType.InEquality && rightOperand == false"  is complex.
Complex Conditional,Custom.Decompiler.Ast.Transforms,PushNegation,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\Transforms\PushNegation.cs,VisitBinaryOperatorExpression,The conditional expression  "op == BinaryOperatorType.Equality && rightOperand == false || op == BinaryOperatorType.InEquality && rightOperand == true"  is complex.
Complex Conditional,Custom.Decompiler.FlowAnalysis,ControlFlowGraphBuilder,F:\newReposMay17\Fody_Usable\Fody\Decompiler\FlowAnalysis\ControlFlowGraphBuilder.cs,FindInnermostHandlerBlock,The conditional expression  "h.TryStart.Offset <= instructionOffset && instructionOffset < h.TryEnd.Offset || h.HandlerStart.Offset <= instructionOffset && instructionOffset < h.HandlerEnd.Offset"  is complex.
Complex Conditional,Custom.Decompiler.FlowAnalysis,ControlStructureDetector,F:\newReposMay17\Fody_Usable\Fody\Decompiler\FlowAnalysis\ControlStructureDetector.cs,FindLoops,The conditional expression  "current.Nodes.Contains (node) && node.DominanceFrontier.Contains (node) && !(node == current.EntryPoint && current.Type == ControlStructureType.Loop)"  is complex.
Complex Conditional,Custom.Decompiler.FlowAnalysis,SsaOptimization,F:\newReposMay17\Fody_Usable\Fody\Decompiler\FlowAnalysis\SsaOptimization.cs,DirectlyStoreToVariables,The conditional expression  "target.IsSingleAssignment && temp.IsSingleAssignment && temp.Usage.Count == 1 && temp.IsStackLocation"  is complex.
Complex Conditional,Custom.Decompiler.ILAst,ILAstBuilder,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstBuilder.cs,ConvertLocalVariables,The conditional expression  "!optimize || varDef.IsPinned || uses.Any (b => b.VariablesBefore [varDef.Index].UnknownDefinition || (b.Code == ILCode.Ldloca && !IsDeterministicLdloca (b)))"  is complex.
Complex Conditional,Custom.Decompiler.ILAst,ILAstBuilder,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstBuilder.cs,ConvertParameters,The conditional expression  "this.Parameters.Count > 0 && (methodDef.IsSetter || methodDef.IsAddOn || methodDef.IsRemoveOn)"  is complex.
Complex Conditional,Custom.Decompiler.ILAst,ILAstBuilder,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstBuilder.cs,ConvertToAst,The conditional expression  "first != null && first.Code == ILCode.Pop && first.Arguments [0].Code == ILCode.Ldloc && first.Arguments [0].Operand == ldexception.StoreTo [0]"  is complex.
Complex Conditional,Custom.Decompiler.ILAst,ILAstOptimizer,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,IntroducePropertyAccessInstructions,The conditional expression  "expr.Arguments [0].Match (ILCode.Ldloc' out target) && expr.Arguments [1].Code == ILCode.Ldvirtftn && expr.Arguments [1].Arguments.Count == 1 && expr.Arguments [1].Arguments [0].MatchLdloc (target)"  is complex.
Complex Conditional,Custom.Decompiler.ILAst,ILAstOptimizer,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,SplitToBasicBlocks,The conditional expression  "currNode is ILLabel || currNode is ILTryCatchBlock || // Counts as label  lastNode.IsConditionalControlFlow () || lastNode.IsUnconditionalControlFlow ()"  is complex.
Complex Conditional,Custom.Decompiler.ILAst,ILAstOptimizer,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,TransformArrayInitializers,The conditional expression  "expr.Match (ILCode.Stloc' out v' out newarrExpr) && newarrExpr.Match (ILCode.Newarr' out elementType' out lengthExpr) && lengthExpr.Match (ILCode.Ldc_I4' out arrayLength) && arrayLength > 0"  is complex.
Complex Conditional,Custom.Decompiler.ILAst,ILAstOptimizer,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,TransformArrayInitializers,The conditional expression  "nextExpr != null && nextExpr.Code.IsStoreToArray () && nextExpr.Arguments [0].Match (ILCode.Ldloc' out v3) && v == v3 && nextExpr.Arguments [1].Match (ILCode.Ldc_I4' out arrayPos) && arrayPos >= operands.Count && arrayPos <= operands.Count + maxConsecutiveDefaultValueExpressions && !nextExpr.Arguments [2].ContainsReferenceTo (v3)"  is complex.
Complex Conditional,Custom.Decompiler.ILAst,ILAstOptimizer,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,TransformMultidimensionalArrayInitializers,The conditional expression  "expr.Match (ILCode.Stloc' out v' out newarrExpr) && newarrExpr.Match (ILCode.Newobj' out ctor' out ctorArgs) && (arrayType = (ctor.DeclaringType as ArrayType)) != null && arrayType.Rank == ctorArgs.Count"  is complex.
Complex Conditional,Custom.Decompiler.ILAst,ILAstOptimizer,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,ForwardScanInitializeArrayRuntimeHelper,The conditional expression  "body.ElementAtOrDefault (pos).Match (ILCode.Call' out methodRef' out methodArg1' out methodArg2) && methodRef.DeclaringType.FullName == "System.Runtime.CompilerServices.RuntimeHelpers" && methodRef.Name == "InitializeArray" && methodArg1.Match (ILCode.Ldloc' out v2) && array == v2 && methodArg2.Match (ILCode.Ldtoken' out fieldRef)"  is complex.
Complex Conditional,Custom.Decompiler.ILAst,ILAstOptimizer,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,TransformDecimalCtorToConstant,The conditional expression  "expr.Arguments [0].Match (ILCode.Ldc_I4' out lo) && expr.Arguments [1].Match (ILCode.Ldc_I4' out mid) && expr.Arguments [2].Match (ILCode.Ldc_I4' out hi) && expr.Arguments [3].Match (ILCode.Ldc_I4' out isNegative) && expr.Arguments [4].Match (ILCode.Ldc_I4' out scale)"  is complex.
Complex Conditional,Custom.Decompiler.ILAst,ILAstOptimizer,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,RemoveConvIFromArrayCreation,The conditional expression  "length.Match (ILCode.Conv_Ovf_I' out input) || length.Match (ILCode.Conv_I' out input) || length.Match (ILCode.Conv_Ovf_I_Un' out input) || length.Match (ILCode.Conv_U' out input)"  is complex.
Complex Conditional,Custom.Decompiler.ILAst,ILAstOptimizer,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,CachedDelegateInitializationWithField,The conditional expression  "c == null || c.Condition == null && c.TrueBlock == null || c.FalseBlock == null"  is complex.
Complex Conditional,Custom.Decompiler.ILAst,ILAstOptimizer,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,CachedDelegateInitializationWithLocal,The conditional expression  "c == null || c.Condition == null && c.TrueBlock == null || c.FalseBlock == null"  is complex.
Complex Conditional,Custom.Decompiler.ILAst,ILAstOptimizer,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,MakeAssignmentExpression,The conditional expression  "(nextExpr.Code == ILCode.Stsfld || nextExpr.Code == ILCode.CallSetter || nextExpr.Code == ILCode.CallvirtSetter) && nextExpr.Arguments.Count == 1"  is complex.
Complex Conditional,Custom.Decompiler.ILAst,ILAstOptimizer,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,IntroducePostIncrementForInstanceFields,The conditional expression  "!(expr.Code == ILCode.Stfld || expr.Code.IsStoreToArray () || expr.Code == ILCode.Stobj || expr.Code == ILCode.CallSetter || expr.Code == ILCode.CallvirtSetter)"  is complex.
Complex Conditional,Custom.Decompiler.ILAst,ILAstOptimizer,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,IntroduceFixedStatements,The conditional expression  "expr != null && expr.Code == ILCode.Stloc && expr.Operand == pinnedVar && IsNullOrZero (expr.Arguments [0])"  is complex.
Complex Conditional,Custom.Decompiler.ILAst,ILAstOptimizer,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,MatchFixedInitializer,The conditional expression  "ifStmt.TrueBlock != null && ifStmt.TrueBlock.Body.Count == 1 && ifStmt.TrueBlock.Body [0].Match (ILCode.Stloc' out pinnedVar' out trueValue) && pinnedVar.IsPinned && IsNullOrZero (trueValue)"  is complex.
Complex Conditional,Custom.Decompiler.ILAst,ILAstOptimizer,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,MatchFixedInitializer,The conditional expression  "fixedStmt.Initializers.Count == 1 && fixedStmt.BodyBlock.Body.Count == 0 && fixedStmt.Initializers [0].Match (ILCode.Stloc' out stlocVar' out falseValue) && stlocVar == pinnedVar"  is complex.
Complex Conditional,Custom.Decompiler.ILAst,ILAstOptimizer,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,MatchFixedInitializer,The conditional expression  "falseValue.Code == ILCode.Ldelema && falseValue.Arguments [0].Match (ILCode.Ldloc' out loadedVariable) && loadedVariable == arrayVariable && IsNullOrZero (falseValue.Arguments [1])"  is complex.
Complex Conditional,Custom.Decompiler.ILAst,ILAstOptimizer,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,HandleStringFixing,The conditional expression  "!(ifStmt != null && ifStmt.TrueBlock != null && ifStmt.TrueBlock.Body.Count == 1 && (ifStmt.FalseBlock == null || ifStmt.FalseBlock.Body.Count == 0))"  is complex.
Complex Conditional,Custom.Decompiler.ILAst,ILAstOptimizer,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,SimplifyLogicNot,The conditional expression  "expr.Code == ILCode.Ceq && TypeAnalysis.IsBoolean (expr.Arguments [0].InferredType) && (a = expr.Arguments [1]).Code == ILCode.Ldc_I4 && (int)a.Operand == 0"  is complex.
Complex Conditional,Custom.Decompiler.ILAst,ILInlining,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILInlining.cs,IsGeneratedValueTypeTemporary,The conditional expression  "arg.Code == ILCode.CallGetter || arg.Code == ILCode.CallvirtGetter || arg.Code == ILCode.Call || arg.Code == ILCode.Callvirt"  is complex.
Complex Conditional,Custom.Decompiler.ILAst,ILInlining,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILInlining.cs,FindLoadInNext,The conditional expression  "i == 1 && (expr.Code == ILCode.LogicAnd || expr.Code == ILCode.LogicOr || expr.Code == ILCode.TernaryOp || expr.Code == ILCode.NullCoalescing)"  is complex.
Complex Conditional,Custom.Decompiler.ILAst,ILInlining,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILInlining.cs,CopyPropagation,The conditional expression  "block.Body [i].Match (ILCode.Stloc' out v' out copiedExpr) && !v.IsParameter && numStloc.GetOrDefault (v) == 1 && numLdloca.GetOrDefault (v) == 0 && CanPerformCopyPropagation (copiedExpr' v)"  is complex.
Complex Conditional,Custom.Decompiler.ILAst,LoopsAndConditions,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\LoopsAndConditions.cs,FindLoops,The conditional expression  "scope.Contains (node) && node.DominanceFrontier.Contains (node) && (node != entryPoint || !excludeEntryPoint)"  is complex.
Complex Conditional,Custom.Decompiler.ILAst,LoopsAndConditions,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\LoopsAndConditions.cs,FindLoops,The conditional expression  "(!loopContents.Contains (trueTarget) && loopContents.Contains (falseTarget)) || (loopContents.Contains (trueTarget) && !loopContents.Contains (falseTarget))"  is complex.
Complex Conditional,Custom.Decompiler.ILAst,PatternMatching,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\PatternMatching.cs,Match,The conditional expression  "expr != null && expr.Prefixes == null && expr.Code == code && expr.Arguments.Count == 0"  is complex.
Complex Conditional,Custom.Decompiler.ILAst,PatternMatching,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\PatternMatching.cs,MatchSingleAndBr,The conditional expression  "bb.Body.Count == 3 && bb.Body [0] is ILLabel && bb.Body [1].Match (code' out operand' out arg) && bb.Body [2].Match (ILCode.Br' out brLabel)"  is complex.
Complex Conditional,Custom.Decompiler.ILAst,SimpleControlFlow,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\SimpleControlFlow.cs,SimplifyTernaryOperator,The conditional expression  "head.MatchLastAndBr (ILCode.Brtrue' out trueLabel' out condExpr' out falseLabel) && labelGlobalRefCount [trueLabel] == 1 && labelGlobalRefCount [falseLabel] == 1 && ((labelToBasicBlock [trueLabel].MatchSingleAndBr (ILCode.Stloc' out trueLocVar' out trueExpr' out trueFall) && labelToBasicBlock [falseLabel].MatchSingleAndBr (ILCode.Stloc' out falseLocVar' out falseExpr' out falseFall) && trueLocVar == falseLocVar && trueFall == falseFall) || (labelToBasicBlock [trueLabel].MatchSingle (ILCode.Ret' out unused' out trueExpr) && labelToBasicBlock [falseLabel].MatchSingle (ILCode.Ret' out unused' out falseExpr))) && body.Contains (labelToBasicBlock [trueLabel]) && body.Contains (labelToBasicBlock [falseLabel])"  is complex.
Complex Conditional,Custom.Decompiler.ILAst,SimpleControlFlow,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\SimpleControlFlow.cs,SimplifyTernaryOperator,The conditional expression  "retTypeIsBoolean && trueExpr.Match (ILCode.Ldc_I4' out leftBoolVal) && falseExpr.Match (ILCode.Ldc_I4' out rightBoolVal) && ((leftBoolVal != 0 && rightBoolVal == 0) || (leftBoolVal == 0 && rightBoolVal != 0))"  is complex.
Complex Conditional,Custom.Decompiler.ILAst,SimpleControlFlow,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\SimpleControlFlow.cs,SimplifyTernaryOperator,The conditional expression  "(retTypeIsBoolean || TypeAnalysis.IsBoolean (falseExpr.InferredType)) && trueExpr.Match (ILCode.Ldc_I4' out leftBoolVal) && (leftBoolVal == 0 || leftBoolVal == 1)"  is complex.
Complex Conditional,Custom.Decompiler.ILAst,SimpleControlFlow,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\SimpleControlFlow.cs,SimplifyTernaryOperator,The conditional expression  "(retTypeIsBoolean || TypeAnalysis.IsBoolean (trueExpr.InferredType)) && falseExpr.Match (ILCode.Ldc_I4' out rightBoolVal) && (rightBoolVal == 0 || rightBoolVal == 1)"  is complex.
Complex Conditional,Custom.Decompiler.ILAst,SimpleControlFlow,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\SimpleControlFlow.cs,SimplifyNullCoalescing,The conditional expression  "head.Body.Count >= 3 && head.Body [head.Body.Count - 3].Match (ILCode.Stloc' out v' out leftExpr) && leftExpr.Match (ILCode.Ldloc' out leftVar) && head.MatchLastAndBr (ILCode.Brtrue' out endBBLabel' out leftExpr2' out rightBBLabel) && leftExpr2.MatchLdloc (leftVar) && labelToBasicBlock.TryGetValue (rightBBLabel' out rightBB) && rightBB.MatchSingleAndBr (ILCode.Stloc' out v2' out rightExpr' out endBBLabel2) && v == v2 && endBBLabel == endBBLabel2 && labelGlobalRefCount.GetOrDefault (rightBBLabel) == 1 && body.Contains (rightBB)"  is complex.
Complex Conditional,Custom.Decompiler.ILAst,SimpleControlFlow,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\SimpleControlFlow.cs,SimplifyShortCircuit,The conditional expression  "body.Contains (nextBasicBlock) && nextBasicBlock != head && labelGlobalRefCount [(ILLabel)nextBasicBlock.Body.First ()] == 1 && nextBasicBlock.MatchSingleAndBr (ILCode.Brtrue' out nextTrueLablel' out nextCondExpr' out nextFalseLabel) && (otherLablel == nextFalseLabel || otherLablel == nextTrueLablel)"  is complex.
Complex Conditional,Custom.Decompiler.ILAst,SimpleControlFlow,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\SimpleControlFlow.cs,JoinBasicBlocks,The conditional expression  "!head.Body.ElementAtOrDefault (head.Body.Count - 2).IsConditionalControlFlow () && head.Body.Last ().Match (ILCode.Br' out nextLabel) && labelGlobalRefCount [nextLabel] == 1 && labelToBasicBlock.TryGetValue (nextLabel' out nextBB) && body.Contains (nextBB) && nextBB.Body.First () == nextLabel && !nextBB.Body.OfType<ILTryCatchBlock> ().Any ()"  is complex.
Complex Conditional,Custom.Decompiler.ILAst,TypeAnalysis,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\TypeAnalysis.cs,CreateDependencyGraph,The conditional expression  "catchBlock != null && catchBlock.ExceptionVariable != null && catchBlock.ExceptionType != null && catchBlock.ExceptionVariable.Type == null"  is complex.
Complex Conditional,Custom.Decompiler.ILAst,TypeAnalysis,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\TypeAnalysis.cs,RunInference,The conditional expression  "!expr.Done && expr.Dependencies.TrueForAll (v => v.Type != null || singleLoadVariables.Contains (v)) && (expr.DependsOnSingleLoad == null || expr.DependsOnSingleLoad.Type != null || ignoreSingleLoadDependencies)"  is complex.
Complex Conditional,Custom.Decompiler.ILAst,TypeAnalysis,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\TypeAnalysis.cs,DoInferTypeForExpression,The conditional expression  "expectedType != null && (expectedType.MetadataType == MetadataType.Int32 || expectedType.MetadataType == MetadataType.UInt32 || expectedType.MetadataType == MetadataType.Int64 || expectedType.MetadataType == MetadataType.UInt64)"  is complex.
Complex Conditional,Custom.Decompiler.ILAst,YieldReturnDecompiler,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\YieldReturnDecompiler.cs,AnalyzeCtor,The conditional expression  "node.Match (ILCode.Stfld' out field' out instExpr' out stExpr) && instExpr.MatchThis () && stExpr.Match (ILCode.Ldloc' out arg) && arg.IsParameter && arg.OriginalParameter.Index == 0"  is complex.
Complex Conditional,Custom.Decompiler.ILAst,YieldReturnDecompiler,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\YieldReturnDecompiler.cs,AnalyzeCurrentProperty,The conditional expression  "method.Body [0].Match (ILCode.Stloc' out v' out stExpr) && stExpr.Match (ILCode.Ldfld' out field' out ldFromObj) && ldFromObj.MatchThis () && method.Body [1].Match (ILCode.Ret' out retExpr) && retExpr.Match (ILCode.Ldloc' out v2) && v == v2"  is complex.
Complex Conditional,Custom.Decompiler.ILAst,YieldReturnDecompiler,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\YieldReturnDecompiler.cs,AnalyzeMoveNext,The conditional expression  "leave != null && (leave.Code == ILCode.Br || leave.Code == ILCode.Leave) && leave.Operand == returnLabel"  is complex.
Complex Conditional,Custom.Decompiler.ILAst,YieldReturnDecompiler,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\YieldReturnDecompiler.cs,ConvertBody,The conditional expression  "returnVariable != null && expr != null && expr.Code == ILCode.Stloc && expr.Operand == returnVariable"  is complex.
Complex Conditional,Custom.Decompiler.ILAst,YieldReturnDecompiler,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\YieldReturnDecompiler.cs,ConvertBody,The conditional expression  "br == null || !(br.Code == ILCode.Br || br.Code == ILCode.Leave) || br.Operand != returnLabel || expr.Arguments [0].Code != ILCode.Ldc_I4"  is complex.
Complex Conditional,Custom.Decompiler.ILAst,YieldReturnDecompiler,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\YieldReturnDecompiler.cs,ConvertBody,The conditional expression  "expr != null && expr.Code == ILCode.Call && expr.Arguments.Count == 1 && expr.Arguments [0].MatchThis ()"  is complex.
Complex Conditional,Custom.Decompiler.ILAst,YieldReturnDecompiler,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\YieldReturnDecompiler.cs,ConvertBody,The conditional expression  "br == null || !(br.Code == ILCode.Br || br.Code == ILCode.Leave) || br.Operand != returnFalseLabel"  is complex.
Empty Catch Block,Custom.Decompiler.Ast,AstBuilder,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\AstBuilder.cs,CreateProperty,The method has an empty catch block.
Empty Catch Block,Custom.Decompiler.Ast,AstBuilder,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\AstBuilder.cs,SetNewModifier,The method has an empty catch block.
Magic Number,Custom.Decompiler.Ast,AstMethodBodyBuilder,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\AstMethodBodyBuilder.cs,DivideBySize,The following statement contains a magic number: switch (TypeAnalysis.GetInformationAmount (type)) {  case 1:  case 8:  	sizeOfExpression = new PrimitiveExpression (1);  	break;  case 16:  	sizeOfExpression = new PrimitiveExpression (2);  	break;  case 32:  	sizeOfExpression = new PrimitiveExpression (4);  	break;  case 64:  	sizeOfExpression = new PrimitiveExpression (8);  	break;  default:  	sizeOfExpression = new SizeOfExpression {  		Type = AstBuilder.ConvertType (type)  	};  	break;  }  
Magic Number,Custom.Decompiler.Ast,AstMethodBodyBuilder,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\AstMethodBodyBuilder.cs,DivideBySize,The following statement contains a magic number: switch (TypeAnalysis.GetInformationAmount (type)) {  case 1:  case 8:  	sizeOfExpression = new PrimitiveExpression (1);  	break;  case 16:  	sizeOfExpression = new PrimitiveExpression (2);  	break;  case 32:  	sizeOfExpression = new PrimitiveExpression (4);  	break;  case 64:  	sizeOfExpression = new PrimitiveExpression (8);  	break;  default:  	sizeOfExpression = new SizeOfExpression {  		Type = AstBuilder.ConvertType (type)  	};  	break;  }  
Magic Number,Custom.Decompiler.Ast,AstMethodBodyBuilder,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\AstMethodBodyBuilder.cs,DivideBySize,The following statement contains a magic number: switch (TypeAnalysis.GetInformationAmount (type)) {  case 1:  case 8:  	sizeOfExpression = new PrimitiveExpression (1);  	break;  case 16:  	sizeOfExpression = new PrimitiveExpression (2);  	break;  case 32:  	sizeOfExpression = new PrimitiveExpression (4);  	break;  case 64:  	sizeOfExpression = new PrimitiveExpression (8);  	break;  default:  	sizeOfExpression = new SizeOfExpression {  		Type = AstBuilder.ConvertType (type)  	};  	break;  }  
Magic Number,Custom.Decompiler.Ast,AstMethodBodyBuilder,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\AstMethodBodyBuilder.cs,DivideBySize,The following statement contains a magic number: switch (TypeAnalysis.GetInformationAmount (type)) {  case 1:  case 8:  	sizeOfExpression = new PrimitiveExpression (1);  	break;  case 16:  	sizeOfExpression = new PrimitiveExpression (2);  	break;  case 32:  	sizeOfExpression = new PrimitiveExpression (4);  	break;  case 64:  	sizeOfExpression = new PrimitiveExpression (8);  	break;  default:  	sizeOfExpression = new SizeOfExpression {  		Type = AstBuilder.ConvertType (type)  	};  	break;  }  
Magic Number,Custom.Decompiler.Ast,AstMethodBodyBuilder,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\AstMethodBodyBuilder.cs,DivideBySize,The following statement contains a magic number: switch (TypeAnalysis.GetInformationAmount (type)) {  case 1:  case 8:  	sizeOfExpression = new PrimitiveExpression (1);  	break;  case 16:  	sizeOfExpression = new PrimitiveExpression (2);  	break;  case 32:  	sizeOfExpression = new PrimitiveExpression (4);  	break;  case 64:  	sizeOfExpression = new PrimitiveExpression (8);  	break;  default:  	sizeOfExpression = new SizeOfExpression {  		Type = AstBuilder.ConvertType (type)  	};  	break;  }  
Magic Number,Custom.Decompiler.Ast,AstMethodBodyBuilder,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\AstMethodBodyBuilder.cs,DivideBySize,The following statement contains a magic number: switch (TypeAnalysis.GetInformationAmount (type)) {  case 1:  case 8:  	sizeOfExpression = new PrimitiveExpression (1);  	break;  case 16:  	sizeOfExpression = new PrimitiveExpression (2);  	break;  case 32:  	sizeOfExpression = new PrimitiveExpression (4);  	break;  case 64:  	sizeOfExpression = new PrimitiveExpression (8);  	break;  default:  	sizeOfExpression = new SizeOfExpression {  		Type = AstBuilder.ConvertType (type)  	};  	break;  }  
Magic Number,Custom.Decompiler.Ast,AstMethodBodyBuilder,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\AstMethodBodyBuilder.cs,DivideBySize,The following statement contains a magic number: switch (TypeAnalysis.GetInformationAmount (type)) {  case 1:  case 8:  	sizeOfExpression = new PrimitiveExpression (1);  	break;  case 16:  	sizeOfExpression = new PrimitiveExpression (2);  	break;  case 32:  	sizeOfExpression = new PrimitiveExpression (4);  	break;  case 64:  	sizeOfExpression = new PrimitiveExpression (8);  	break;  default:  	sizeOfExpression = new SizeOfExpression {  		Type = AstBuilder.ConvertType (type)  	};  	break;  }  
Magic Number,Custom.Decompiler.Ast,AstMethodBodyBuilder,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\AstMethodBodyBuilder.cs,DivideBySize,The following statement contains a magic number: sizeOfExpression = new PrimitiveExpression (2);  
Magic Number,Custom.Decompiler.Ast,AstMethodBodyBuilder,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\AstMethodBodyBuilder.cs,DivideBySize,The following statement contains a magic number: sizeOfExpression = new PrimitiveExpression (4);  
Magic Number,Custom.Decompiler.Ast,AstMethodBodyBuilder,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\AstMethodBodyBuilder.cs,DivideBySize,The following statement contains a magic number: sizeOfExpression = new PrimitiveExpression (8);  
Magic Number,Custom.Decompiler.Ast,AstMethodBodyBuilder,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\AstMethodBodyBuilder.cs,TransformCall,The following statement contains a magic number: if (cecilMethod.Name == "Get" && cecilMethod.DeclaringType is ArrayType && methodArgs.Count > 1) {  	return target.Indexer (methodArgs);  } else if (cecilMethod.Name == "Set" && cecilMethod.DeclaringType is ArrayType && methodArgs.Count > 2) {  	return new AssignmentExpression (target.Indexer (methodArgs.GetRange (0' methodArgs.Count - 1))' methodArgs.Last ());  }  
Magic Number,Custom.Decompiler.Ast,AstMethodBodyBuilder,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\AstMethodBodyBuilder.cs,TransformCall,The following statement contains a magic number: if (cecilMethod.Name == "Set" && cecilMethod.DeclaringType is ArrayType && methodArgs.Count > 2) {  	return new AssignmentExpression (target.Indexer (methodArgs.GetRange (0' methodArgs.Count - 1))' methodArgs.Last ());  }  
Magic Number,Custom.Decompiler.Ast,NameVariables,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\NameVariables.cs,GetNameFromExpression,The following statement contains a magic number: switch (expr.Code) {  case ILCode.Ldfld:  case ILCode.Ldsfld:  	return CleanUpVariableName (((FieldReference)expr.Operand).Name);  case ILCode.Call:  case ILCode.Callvirt:  case ILCode.CallGetter:  case ILCode.CallvirtGetter:  	MethodReference mr = (MethodReference)expr.Operand;  	if (mr.Name.StartsWith ("get_"' StringComparison.OrdinalIgnoreCase) && mr.Parameters.Count == 0) {  		// use name from properties' but not from indexers  		return CleanUpVariableName (mr.Name.Substring (4));  	} else if (mr.Name.StartsWith ("Get"' StringComparison.OrdinalIgnoreCase) && mr.Name.Length >= 4 && char.IsUpper (mr.Name [3])) {  		// use name from Get-methods  		return CleanUpVariableName (mr.Name.Substring (3));  	}  	break;  }  
Magic Number,Custom.Decompiler.Ast,NameVariables,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\NameVariables.cs,GetNameFromExpression,The following statement contains a magic number: switch (expr.Code) {  case ILCode.Ldfld:  case ILCode.Ldsfld:  	return CleanUpVariableName (((FieldReference)expr.Operand).Name);  case ILCode.Call:  case ILCode.Callvirt:  case ILCode.CallGetter:  case ILCode.CallvirtGetter:  	MethodReference mr = (MethodReference)expr.Operand;  	if (mr.Name.StartsWith ("get_"' StringComparison.OrdinalIgnoreCase) && mr.Parameters.Count == 0) {  		// use name from properties' but not from indexers  		return CleanUpVariableName (mr.Name.Substring (4));  	} else if (mr.Name.StartsWith ("Get"' StringComparison.OrdinalIgnoreCase) && mr.Name.Length >= 4 && char.IsUpper (mr.Name [3])) {  		// use name from Get-methods  		return CleanUpVariableName (mr.Name.Substring (3));  	}  	break;  }  
Magic Number,Custom.Decompiler.Ast,NameVariables,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\NameVariables.cs,GetNameFromExpression,The following statement contains a magic number: switch (expr.Code) {  case ILCode.Ldfld:  case ILCode.Ldsfld:  	return CleanUpVariableName (((FieldReference)expr.Operand).Name);  case ILCode.Call:  case ILCode.Callvirt:  case ILCode.CallGetter:  case ILCode.CallvirtGetter:  	MethodReference mr = (MethodReference)expr.Operand;  	if (mr.Name.StartsWith ("get_"' StringComparison.OrdinalIgnoreCase) && mr.Parameters.Count == 0) {  		// use name from properties' but not from indexers  		return CleanUpVariableName (mr.Name.Substring (4));  	} else if (mr.Name.StartsWith ("Get"' StringComparison.OrdinalIgnoreCase) && mr.Name.Length >= 4 && char.IsUpper (mr.Name [3])) {  		// use name from Get-methods  		return CleanUpVariableName (mr.Name.Substring (3));  	}  	break;  }  
Magic Number,Custom.Decompiler.Ast,NameVariables,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\NameVariables.cs,GetNameFromExpression,The following statement contains a magic number: switch (expr.Code) {  case ILCode.Ldfld:  case ILCode.Ldsfld:  	return CleanUpVariableName (((FieldReference)expr.Operand).Name);  case ILCode.Call:  case ILCode.Callvirt:  case ILCode.CallGetter:  case ILCode.CallvirtGetter:  	MethodReference mr = (MethodReference)expr.Operand;  	if (mr.Name.StartsWith ("get_"' StringComparison.OrdinalIgnoreCase) && mr.Parameters.Count == 0) {  		// use name from properties' but not from indexers  		return CleanUpVariableName (mr.Name.Substring (4));  	} else if (mr.Name.StartsWith ("Get"' StringComparison.OrdinalIgnoreCase) && mr.Name.Length >= 4 && char.IsUpper (mr.Name [3])) {  		// use name from Get-methods  		return CleanUpVariableName (mr.Name.Substring (3));  	}  	break;  }  
Magic Number,Custom.Decompiler.Ast,NameVariables,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\NameVariables.cs,GetNameFromExpression,The following statement contains a magic number: if (mr.Name.StartsWith ("get_"' StringComparison.OrdinalIgnoreCase) && mr.Parameters.Count == 0) {  	// use name from properties' but not from indexers  	return CleanUpVariableName (mr.Name.Substring (4));  } else if (mr.Name.StartsWith ("Get"' StringComparison.OrdinalIgnoreCase) && mr.Name.Length >= 4 && char.IsUpper (mr.Name [3])) {  	// use name from Get-methods  	return CleanUpVariableName (mr.Name.Substring (3));  }  
Magic Number,Custom.Decompiler.Ast,NameVariables,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\NameVariables.cs,GetNameFromExpression,The following statement contains a magic number: if (mr.Name.StartsWith ("get_"' StringComparison.OrdinalIgnoreCase) && mr.Parameters.Count == 0) {  	// use name from properties' but not from indexers  	return CleanUpVariableName (mr.Name.Substring (4));  } else if (mr.Name.StartsWith ("Get"' StringComparison.OrdinalIgnoreCase) && mr.Name.Length >= 4 && char.IsUpper (mr.Name [3])) {  	// use name from Get-methods  	return CleanUpVariableName (mr.Name.Substring (3));  }  
Magic Number,Custom.Decompiler.Ast,NameVariables,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\NameVariables.cs,GetNameFromExpression,The following statement contains a magic number: if (mr.Name.StartsWith ("get_"' StringComparison.OrdinalIgnoreCase) && mr.Parameters.Count == 0) {  	// use name from properties' but not from indexers  	return CleanUpVariableName (mr.Name.Substring (4));  } else if (mr.Name.StartsWith ("Get"' StringComparison.OrdinalIgnoreCase) && mr.Name.Length >= 4 && char.IsUpper (mr.Name [3])) {  	// use name from Get-methods  	return CleanUpVariableName (mr.Name.Substring (3));  }  
Magic Number,Custom.Decompiler.Ast,NameVariables,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\NameVariables.cs,GetNameFromExpression,The following statement contains a magic number: if (mr.Name.StartsWith ("get_"' StringComparison.OrdinalIgnoreCase) && mr.Parameters.Count == 0) {  	// use name from properties' but not from indexers  	return CleanUpVariableName (mr.Name.Substring (4));  } else if (mr.Name.StartsWith ("Get"' StringComparison.OrdinalIgnoreCase) && mr.Name.Length >= 4 && char.IsUpper (mr.Name [3])) {  	// use name from Get-methods  	return CleanUpVariableName (mr.Name.Substring (3));  }  
Magic Number,Custom.Decompiler.Ast,NameVariables,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\NameVariables.cs,GetNameFromExpression,The following statement contains a magic number: return CleanUpVariableName (mr.Name.Substring (4));  
Magic Number,Custom.Decompiler.Ast,NameVariables,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\NameVariables.cs,GetNameFromExpression,The following statement contains a magic number: if (mr.Name.StartsWith ("Get"' StringComparison.OrdinalIgnoreCase) && mr.Name.Length >= 4 && char.IsUpper (mr.Name [3])) {  	// use name from Get-methods  	return CleanUpVariableName (mr.Name.Substring (3));  }  
Magic Number,Custom.Decompiler.Ast,NameVariables,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\NameVariables.cs,GetNameFromExpression,The following statement contains a magic number: if (mr.Name.StartsWith ("Get"' StringComparison.OrdinalIgnoreCase) && mr.Name.Length >= 4 && char.IsUpper (mr.Name [3])) {  	// use name from Get-methods  	return CleanUpVariableName (mr.Name.Substring (3));  }  
Magic Number,Custom.Decompiler.Ast,NameVariables,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\NameVariables.cs,GetNameFromExpression,The following statement contains a magic number: if (mr.Name.StartsWith ("Get"' StringComparison.OrdinalIgnoreCase) && mr.Name.Length >= 4 && char.IsUpper (mr.Name [3])) {  	// use name from Get-methods  	return CleanUpVariableName (mr.Name.Substring (3));  }  
Magic Number,Custom.Decompiler.Ast,NameVariables,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\NameVariables.cs,GetNameFromExpression,The following statement contains a magic number: return CleanUpVariableName (mr.Name.Substring (3));  
Magic Number,Custom.Decompiler.Ast,NameVariables,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\NameVariables.cs,GetNameForArgument,The following statement contains a magic number: switch (parent.Code) {  case ILCode.Stfld:  case ILCode.Stsfld:  	if (i == parent.Arguments.Count - 1)  		// last argument is stored value  		return CleanUpVariableName (((FieldReference)parent.Operand).Name);  	else  		break;  case ILCode.Call:  case ILCode.Callvirt:  case ILCode.Newobj:  case ILCode.CallGetter:  case ILCode.CallvirtGetter:  case ILCode.CallSetter:  case ILCode.CallvirtSetter:  	MethodReference methodRef = (MethodReference)parent.Operand;  	if (methodRef.Parameters.Count == 1 && i == parent.Arguments.Count - 1) {  		// argument might be value of a setter  		if (methodRef.Name.StartsWith ("set_"' StringComparison.OrdinalIgnoreCase)) {  			return CleanUpVariableName (methodRef.Name.Substring (4));  		} else if (methodRef.Name.StartsWith ("Set"' StringComparison.OrdinalIgnoreCase) && methodRef.Name.Length >= 4 && char.IsUpper (methodRef.Name [3])) {  			return CleanUpVariableName (methodRef.Name.Substring (3));  		}  	}  	MethodDefinition methodDef = methodRef.Resolve ();  	if (methodDef != null) {  		var p = methodDef.Parameters.ElementAtOrDefault ((parent.Code != ILCode.Newobj && methodDef.HasThis) ? i - 1 : i);  		if (p != null && !string.IsNullOrEmpty (p.Name))  			return CleanUpVariableName (p.Name);  	}  	break;  case ILCode.Ret:  	return "result";  }  
Magic Number,Custom.Decompiler.Ast,NameVariables,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\NameVariables.cs,GetNameForArgument,The following statement contains a magic number: switch (parent.Code) {  case ILCode.Stfld:  case ILCode.Stsfld:  	if (i == parent.Arguments.Count - 1)  		// last argument is stored value  		return CleanUpVariableName (((FieldReference)parent.Operand).Name);  	else  		break;  case ILCode.Call:  case ILCode.Callvirt:  case ILCode.Newobj:  case ILCode.CallGetter:  case ILCode.CallvirtGetter:  case ILCode.CallSetter:  case ILCode.CallvirtSetter:  	MethodReference methodRef = (MethodReference)parent.Operand;  	if (methodRef.Parameters.Count == 1 && i == parent.Arguments.Count - 1) {  		// argument might be value of a setter  		if (methodRef.Name.StartsWith ("set_"' StringComparison.OrdinalIgnoreCase)) {  			return CleanUpVariableName (methodRef.Name.Substring (4));  		} else if (methodRef.Name.StartsWith ("Set"' StringComparison.OrdinalIgnoreCase) && methodRef.Name.Length >= 4 && char.IsUpper (methodRef.Name [3])) {  			return CleanUpVariableName (methodRef.Name.Substring (3));  		}  	}  	MethodDefinition methodDef = methodRef.Resolve ();  	if (methodDef != null) {  		var p = methodDef.Parameters.ElementAtOrDefault ((parent.Code != ILCode.Newobj && methodDef.HasThis) ? i - 1 : i);  		if (p != null && !string.IsNullOrEmpty (p.Name))  			return CleanUpVariableName (p.Name);  	}  	break;  case ILCode.Ret:  	return "result";  }  
Magic Number,Custom.Decompiler.Ast,NameVariables,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\NameVariables.cs,GetNameForArgument,The following statement contains a magic number: switch (parent.Code) {  case ILCode.Stfld:  case ILCode.Stsfld:  	if (i == parent.Arguments.Count - 1)  		// last argument is stored value  		return CleanUpVariableName (((FieldReference)parent.Operand).Name);  	else  		break;  case ILCode.Call:  case ILCode.Callvirt:  case ILCode.Newobj:  case ILCode.CallGetter:  case ILCode.CallvirtGetter:  case ILCode.CallSetter:  case ILCode.CallvirtSetter:  	MethodReference methodRef = (MethodReference)parent.Operand;  	if (methodRef.Parameters.Count == 1 && i == parent.Arguments.Count - 1) {  		// argument might be value of a setter  		if (methodRef.Name.StartsWith ("set_"' StringComparison.OrdinalIgnoreCase)) {  			return CleanUpVariableName (methodRef.Name.Substring (4));  		} else if (methodRef.Name.StartsWith ("Set"' StringComparison.OrdinalIgnoreCase) && methodRef.Name.Length >= 4 && char.IsUpper (methodRef.Name [3])) {  			return CleanUpVariableName (methodRef.Name.Substring (3));  		}  	}  	MethodDefinition methodDef = methodRef.Resolve ();  	if (methodDef != null) {  		var p = methodDef.Parameters.ElementAtOrDefault ((parent.Code != ILCode.Newobj && methodDef.HasThis) ? i - 1 : i);  		if (p != null && !string.IsNullOrEmpty (p.Name))  			return CleanUpVariableName (p.Name);  	}  	break;  case ILCode.Ret:  	return "result";  }  
Magic Number,Custom.Decompiler.Ast,NameVariables,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\NameVariables.cs,GetNameForArgument,The following statement contains a magic number: switch (parent.Code) {  case ILCode.Stfld:  case ILCode.Stsfld:  	if (i == parent.Arguments.Count - 1)  		// last argument is stored value  		return CleanUpVariableName (((FieldReference)parent.Operand).Name);  	else  		break;  case ILCode.Call:  case ILCode.Callvirt:  case ILCode.Newobj:  case ILCode.CallGetter:  case ILCode.CallvirtGetter:  case ILCode.CallSetter:  case ILCode.CallvirtSetter:  	MethodReference methodRef = (MethodReference)parent.Operand;  	if (methodRef.Parameters.Count == 1 && i == parent.Arguments.Count - 1) {  		// argument might be value of a setter  		if (methodRef.Name.StartsWith ("set_"' StringComparison.OrdinalIgnoreCase)) {  			return CleanUpVariableName (methodRef.Name.Substring (4));  		} else if (methodRef.Name.StartsWith ("Set"' StringComparison.OrdinalIgnoreCase) && methodRef.Name.Length >= 4 && char.IsUpper (methodRef.Name [3])) {  			return CleanUpVariableName (methodRef.Name.Substring (3));  		}  	}  	MethodDefinition methodDef = methodRef.Resolve ();  	if (methodDef != null) {  		var p = methodDef.Parameters.ElementAtOrDefault ((parent.Code != ILCode.Newobj && methodDef.HasThis) ? i - 1 : i);  		if (p != null && !string.IsNullOrEmpty (p.Name))  			return CleanUpVariableName (p.Name);  	}  	break;  case ILCode.Ret:  	return "result";  }  
Magic Number,Custom.Decompiler.Ast,NameVariables,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\NameVariables.cs,GetNameForArgument,The following statement contains a magic number: if (methodRef.Parameters.Count == 1 && i == parent.Arguments.Count - 1) {  	// argument might be value of a setter  	if (methodRef.Name.StartsWith ("set_"' StringComparison.OrdinalIgnoreCase)) {  		return CleanUpVariableName (methodRef.Name.Substring (4));  	} else if (methodRef.Name.StartsWith ("Set"' StringComparison.OrdinalIgnoreCase) && methodRef.Name.Length >= 4 && char.IsUpper (methodRef.Name [3])) {  		return CleanUpVariableName (methodRef.Name.Substring (3));  	}  }  
Magic Number,Custom.Decompiler.Ast,NameVariables,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\NameVariables.cs,GetNameForArgument,The following statement contains a magic number: if (methodRef.Parameters.Count == 1 && i == parent.Arguments.Count - 1) {  	// argument might be value of a setter  	if (methodRef.Name.StartsWith ("set_"' StringComparison.OrdinalIgnoreCase)) {  		return CleanUpVariableName (methodRef.Name.Substring (4));  	} else if (methodRef.Name.StartsWith ("Set"' StringComparison.OrdinalIgnoreCase) && methodRef.Name.Length >= 4 && char.IsUpper (methodRef.Name [3])) {  		return CleanUpVariableName (methodRef.Name.Substring (3));  	}  }  
Magic Number,Custom.Decompiler.Ast,NameVariables,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\NameVariables.cs,GetNameForArgument,The following statement contains a magic number: if (methodRef.Parameters.Count == 1 && i == parent.Arguments.Count - 1) {  	// argument might be value of a setter  	if (methodRef.Name.StartsWith ("set_"' StringComparison.OrdinalIgnoreCase)) {  		return CleanUpVariableName (methodRef.Name.Substring (4));  	} else if (methodRef.Name.StartsWith ("Set"' StringComparison.OrdinalIgnoreCase) && methodRef.Name.Length >= 4 && char.IsUpper (methodRef.Name [3])) {  		return CleanUpVariableName (methodRef.Name.Substring (3));  	}  }  
Magic Number,Custom.Decompiler.Ast,NameVariables,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\NameVariables.cs,GetNameForArgument,The following statement contains a magic number: if (methodRef.Parameters.Count == 1 && i == parent.Arguments.Count - 1) {  	// argument might be value of a setter  	if (methodRef.Name.StartsWith ("set_"' StringComparison.OrdinalIgnoreCase)) {  		return CleanUpVariableName (methodRef.Name.Substring (4));  	} else if (methodRef.Name.StartsWith ("Set"' StringComparison.OrdinalIgnoreCase) && methodRef.Name.Length >= 4 && char.IsUpper (methodRef.Name [3])) {  		return CleanUpVariableName (methodRef.Name.Substring (3));  	}  }  
Magic Number,Custom.Decompiler.Ast,NameVariables,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\NameVariables.cs,GetNameForArgument,The following statement contains a magic number: if (methodRef.Name.StartsWith ("set_"' StringComparison.OrdinalIgnoreCase)) {  	return CleanUpVariableName (methodRef.Name.Substring (4));  } else if (methodRef.Name.StartsWith ("Set"' StringComparison.OrdinalIgnoreCase) && methodRef.Name.Length >= 4 && char.IsUpper (methodRef.Name [3])) {  	return CleanUpVariableName (methodRef.Name.Substring (3));  }  
Magic Number,Custom.Decompiler.Ast,NameVariables,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\NameVariables.cs,GetNameForArgument,The following statement contains a magic number: if (methodRef.Name.StartsWith ("set_"' StringComparison.OrdinalIgnoreCase)) {  	return CleanUpVariableName (methodRef.Name.Substring (4));  } else if (methodRef.Name.StartsWith ("Set"' StringComparison.OrdinalIgnoreCase) && methodRef.Name.Length >= 4 && char.IsUpper (methodRef.Name [3])) {  	return CleanUpVariableName (methodRef.Name.Substring (3));  }  
Magic Number,Custom.Decompiler.Ast,NameVariables,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\NameVariables.cs,GetNameForArgument,The following statement contains a magic number: if (methodRef.Name.StartsWith ("set_"' StringComparison.OrdinalIgnoreCase)) {  	return CleanUpVariableName (methodRef.Name.Substring (4));  } else if (methodRef.Name.StartsWith ("Set"' StringComparison.OrdinalIgnoreCase) && methodRef.Name.Length >= 4 && char.IsUpper (methodRef.Name [3])) {  	return CleanUpVariableName (methodRef.Name.Substring (3));  }  
Magic Number,Custom.Decompiler.Ast,NameVariables,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\NameVariables.cs,GetNameForArgument,The following statement contains a magic number: if (methodRef.Name.StartsWith ("set_"' StringComparison.OrdinalIgnoreCase)) {  	return CleanUpVariableName (methodRef.Name.Substring (4));  } else if (methodRef.Name.StartsWith ("Set"' StringComparison.OrdinalIgnoreCase) && methodRef.Name.Length >= 4 && char.IsUpper (methodRef.Name [3])) {  	return CleanUpVariableName (methodRef.Name.Substring (3));  }  
Magic Number,Custom.Decompiler.Ast,NameVariables,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\NameVariables.cs,GetNameForArgument,The following statement contains a magic number: return CleanUpVariableName (methodRef.Name.Substring (4));  
Magic Number,Custom.Decompiler.Ast,NameVariables,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\NameVariables.cs,GetNameForArgument,The following statement contains a magic number: if (methodRef.Name.StartsWith ("Set"' StringComparison.OrdinalIgnoreCase) && methodRef.Name.Length >= 4 && char.IsUpper (methodRef.Name [3])) {  	return CleanUpVariableName (methodRef.Name.Substring (3));  }  
Magic Number,Custom.Decompiler.Ast,NameVariables,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\NameVariables.cs,GetNameForArgument,The following statement contains a magic number: if (methodRef.Name.StartsWith ("Set"' StringComparison.OrdinalIgnoreCase) && methodRef.Name.Length >= 4 && char.IsUpper (methodRef.Name [3])) {  	return CleanUpVariableName (methodRef.Name.Substring (3));  }  
Magic Number,Custom.Decompiler.Ast,NameVariables,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\NameVariables.cs,GetNameForArgument,The following statement contains a magic number: if (methodRef.Name.StartsWith ("Set"' StringComparison.OrdinalIgnoreCase) && methodRef.Name.Length >= 4 && char.IsUpper (methodRef.Name [3])) {  	return CleanUpVariableName (methodRef.Name.Substring (3));  }  
Magic Number,Custom.Decompiler.Ast,NameVariables,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\NameVariables.cs,GetNameForArgument,The following statement contains a magic number: return CleanUpVariableName (methodRef.Name.Substring (3));  
Magic Number,Custom.Decompiler.Ast,NameVariables,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\NameVariables.cs,GetNameByType,The following statement contains a magic number: if (type.IsArray) {  	name = "array";  } else if (type.IsPointer || type.IsByReference) {  	name = "ptr";  } else if (type.Name.EndsWith ("Exception"' StringComparison.Ordinal)) {  	name = "ex";  } else if (!typeNameToVariableNameDict.TryGetValue (type.FullName' out name)) {  	name = type.Name;  	// remove the 'I' for interfaces  	if (name.Length >= 3 && name [0] == 'I' && char.IsUpper (name [1]) && char.IsLower (name [2]))  		name = name.Substring (1);  	name = CleanUpVariableName (name);  }  
Magic Number,Custom.Decompiler.Ast,NameVariables,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\NameVariables.cs,GetNameByType,The following statement contains a magic number: if (type.IsArray) {  	name = "array";  } else if (type.IsPointer || type.IsByReference) {  	name = "ptr";  } else if (type.Name.EndsWith ("Exception"' StringComparison.Ordinal)) {  	name = "ex";  } else if (!typeNameToVariableNameDict.TryGetValue (type.FullName' out name)) {  	name = type.Name;  	// remove the 'I' for interfaces  	if (name.Length >= 3 && name [0] == 'I' && char.IsUpper (name [1]) && char.IsLower (name [2]))  		name = name.Substring (1);  	name = CleanUpVariableName (name);  }  
Magic Number,Custom.Decompiler.Ast,NameVariables,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\NameVariables.cs,GetNameByType,The following statement contains a magic number: if (type.IsPointer || type.IsByReference) {  	name = "ptr";  } else if (type.Name.EndsWith ("Exception"' StringComparison.Ordinal)) {  	name = "ex";  } else if (!typeNameToVariableNameDict.TryGetValue (type.FullName' out name)) {  	name = type.Name;  	// remove the 'I' for interfaces  	if (name.Length >= 3 && name [0] == 'I' && char.IsUpper (name [1]) && char.IsLower (name [2]))  		name = name.Substring (1);  	name = CleanUpVariableName (name);  }  
Magic Number,Custom.Decompiler.Ast,NameVariables,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\NameVariables.cs,GetNameByType,The following statement contains a magic number: if (type.IsPointer || type.IsByReference) {  	name = "ptr";  } else if (type.Name.EndsWith ("Exception"' StringComparison.Ordinal)) {  	name = "ex";  } else if (!typeNameToVariableNameDict.TryGetValue (type.FullName' out name)) {  	name = type.Name;  	// remove the 'I' for interfaces  	if (name.Length >= 3 && name [0] == 'I' && char.IsUpper (name [1]) && char.IsLower (name [2]))  		name = name.Substring (1);  	name = CleanUpVariableName (name);  }  
Magic Number,Custom.Decompiler.Ast,NameVariables,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\NameVariables.cs,GetNameByType,The following statement contains a magic number: if (type.Name.EndsWith ("Exception"' StringComparison.Ordinal)) {  	name = "ex";  } else if (!typeNameToVariableNameDict.TryGetValue (type.FullName' out name)) {  	name = type.Name;  	// remove the 'I' for interfaces  	if (name.Length >= 3 && name [0] == 'I' && char.IsUpper (name [1]) && char.IsLower (name [2]))  		name = name.Substring (1);  	name = CleanUpVariableName (name);  }  
Magic Number,Custom.Decompiler.Ast,NameVariables,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\NameVariables.cs,GetNameByType,The following statement contains a magic number: if (type.Name.EndsWith ("Exception"' StringComparison.Ordinal)) {  	name = "ex";  } else if (!typeNameToVariableNameDict.TryGetValue (type.FullName' out name)) {  	name = type.Name;  	// remove the 'I' for interfaces  	if (name.Length >= 3 && name [0] == 'I' && char.IsUpper (name [1]) && char.IsLower (name [2]))  		name = name.Substring (1);  	name = CleanUpVariableName (name);  }  
Magic Number,Custom.Decompiler.Ast,NameVariables,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\NameVariables.cs,GetNameByType,The following statement contains a magic number: if (!typeNameToVariableNameDict.TryGetValue (type.FullName' out name)) {  	name = type.Name;  	// remove the 'I' for interfaces  	if (name.Length >= 3 && name [0] == 'I' && char.IsUpper (name [1]) && char.IsLower (name [2]))  		name = name.Substring (1);  	name = CleanUpVariableName (name);  }  
Magic Number,Custom.Decompiler.Ast,NameVariables,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\NameVariables.cs,GetNameByType,The following statement contains a magic number: if (!typeNameToVariableNameDict.TryGetValue (type.FullName' out name)) {  	name = type.Name;  	// remove the 'I' for interfaces  	if (name.Length >= 3 && name [0] == 'I' && char.IsUpper (name [1]) && char.IsLower (name [2]))  		name = name.Substring (1);  	name = CleanUpVariableName (name);  }  
Magic Number,Custom.Decompiler.Ast,NameVariables,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\NameVariables.cs,GetNameByType,The following statement contains a magic number: if (name.Length >= 3 && name [0] == 'I' && char.IsUpper (name [1]) && char.IsLower (name [2]))  	name = name.Substring (1);  
Magic Number,Custom.Decompiler.Ast,NameVariables,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\NameVariables.cs,GetNameByType,The following statement contains a magic number: if (name.Length >= 3 && name [0] == 'I' && char.IsUpper (name [1]) && char.IsLower (name [2]))  	name = name.Substring (1);  
Magic Number,Custom.Decompiler.Ast,NameVariables,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\NameVariables.cs,CleanUpVariableName,The following statement contains a magic number: if (name.Length > 2 && name.StartsWith ("m_"' StringComparison.Ordinal))  	name = name.Substring (2);  else if (name.Length > 1 && name [0] == '_')  	name = name.Substring (1);  
Magic Number,Custom.Decompiler.Ast,NameVariables,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\NameVariables.cs,CleanUpVariableName,The following statement contains a magic number: if (name.Length > 2 && name.StartsWith ("m_"' StringComparison.Ordinal))  	name = name.Substring (2);  else if (name.Length > 1 && name [0] == '_')  	name = name.Substring (1);  
Magic Number,Custom.Decompiler.Ast,NameVariables,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\NameVariables.cs,CleanUpVariableName,The following statement contains a magic number: name = name.Substring (2);  
Magic Number,Custom.Decompiler,CecilExtensions,F:\newReposMay17\Fody_Usable\Fody\Decompiler\CecilExtensions.cs,GetPushDelta,The following statement contains a magic number: switch (code.StackBehaviourPush) {  case StackBehaviour.Push0:  	return 0;  case StackBehaviour.Push1:  case StackBehaviour.Pushi:  case StackBehaviour.Pushi8:  case StackBehaviour.Pushr4:  case StackBehaviour.Pushr8:  case StackBehaviour.Pushref:  	return 1;  case StackBehaviour.Push1_push1:  	return 2;  case StackBehaviour.Varpush:  	if (code.FlowControl != FlowControl.Call)  		break;  	IMethodSignature method = (IMethodSignature)instruction.Operand;  	return IsVoid (method.ReturnType) ? 0 : 1;  }  
Magic Number,Custom.Decompiler,CecilExtensions,F:\newReposMay17\Fody_Usable\Fody\Decompiler\CecilExtensions.cs,GetPushDelta,The following statement contains a magic number: return 2;  
Magic Number,Custom.Decompiler,CecilExtensions,F:\newReposMay17\Fody_Usable\Fody\Decompiler\CecilExtensions.cs,GetPopDelta,The following statement contains a magic number: switch (code.StackBehaviourPop) {  case StackBehaviour.Pop0:  	return 0;  case StackBehaviour.Popi:  case StackBehaviour.Popref:  case StackBehaviour.Pop1:  	return 1;  case StackBehaviour.Pop1_pop1:  case StackBehaviour.Popi_pop1:  case StackBehaviour.Popi_popi:  case StackBehaviour.Popi_popi8:  case StackBehaviour.Popi_popr4:  case StackBehaviour.Popi_popr8:  case StackBehaviour.Popref_pop1:  case StackBehaviour.Popref_popi:  	return 2;  case StackBehaviour.Popi_popi_popi:  case StackBehaviour.Popref_popi_popi:  case StackBehaviour.Popref_popi_popi8:  case StackBehaviour.Popref_popi_popr4:  case StackBehaviour.Popref_popi_popr8:  case StackBehaviour.Popref_popi_popref:  	return 3;  case StackBehaviour.PopAll:  	return null;  case StackBehaviour.Varpop:  	if (code == OpCodes.Ret)  		return methodDef.ReturnType.IsVoid () ? 0 : 1;  	if (code.FlowControl != FlowControl.Call)  		break;  	IMethodSignature method = (IMethodSignature)instruction.Operand;  	int count = method.HasParameters ? method.Parameters.Count : 0;  	if (method.HasThis && code != OpCodes.Newobj)  		++count;  	if (code == OpCodes.Calli)  		++count;  	// calli takes a function pointer in additional to the normal args  	return count;  }  
Magic Number,Custom.Decompiler,CecilExtensions,F:\newReposMay17\Fody_Usable\Fody\Decompiler\CecilExtensions.cs,GetPopDelta,The following statement contains a magic number: switch (code.StackBehaviourPop) {  case StackBehaviour.Pop0:  	return 0;  case StackBehaviour.Popi:  case StackBehaviour.Popref:  case StackBehaviour.Pop1:  	return 1;  case StackBehaviour.Pop1_pop1:  case StackBehaviour.Popi_pop1:  case StackBehaviour.Popi_popi:  case StackBehaviour.Popi_popi8:  case StackBehaviour.Popi_popr4:  case StackBehaviour.Popi_popr8:  case StackBehaviour.Popref_pop1:  case StackBehaviour.Popref_popi:  	return 2;  case StackBehaviour.Popi_popi_popi:  case StackBehaviour.Popref_popi_popi:  case StackBehaviour.Popref_popi_popi8:  case StackBehaviour.Popref_popi_popr4:  case StackBehaviour.Popref_popi_popr8:  case StackBehaviour.Popref_popi_popref:  	return 3;  case StackBehaviour.PopAll:  	return null;  case StackBehaviour.Varpop:  	if (code == OpCodes.Ret)  		return methodDef.ReturnType.IsVoid () ? 0 : 1;  	if (code.FlowControl != FlowControl.Call)  		break;  	IMethodSignature method = (IMethodSignature)instruction.Operand;  	int count = method.HasParameters ? method.Parameters.Count : 0;  	if (method.HasThis && code != OpCodes.Newobj)  		++count;  	if (code == OpCodes.Calli)  		++count;  	// calli takes a function pointer in additional to the normal args  	return count;  }  
Magic Number,Custom.Decompiler,CecilExtensions,F:\newReposMay17\Fody_Usable\Fody\Decompiler\CecilExtensions.cs,GetPopDelta,The following statement contains a magic number: return 2;  
Magic Number,Custom.Decompiler,CecilExtensions,F:\newReposMay17\Fody_Usable\Fody\Decompiler\CecilExtensions.cs,GetPopDelta,The following statement contains a magic number: return 3;  
Magic Number,Custom.Decompiler.Ast.Transforms,AddCheckedBlocks,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\Transforms\AddCheckedBlocks.cs,GetResult,The following statement contains a magic number: if (expr != null) {  	CheckedUncheckedAnnotation annotation = expr.Annotation<CheckedUncheckedAnnotation> ();  	if (annotation != null) {  		// If the annotation requires this node to be in a specific context' add a huge cost to the other context  		// That huge cost gives us the option to ignore a required checked/unchecked expression when there wouldn't be any  		// solution otherwise. (e.g. "for (checked(M().x += 1); true; unchecked(M().x += 2)) {}")  		if (annotation.IsChecked)  			result.CostInUncheckedContext += new Cost (10000' 0);  		else  			result.CostInCheckedContext += new Cost (10000' 0);  	}  	// Embed this node in an checked/unchecked expression:  	if (expr.Parent is ExpressionStatement) {  		// We cannot use checked/unchecked for top-level-expressions.  		// However' we could try converting a compound assignment (checked(a+=b);) or unary operator (checked(a++);)  		// back to its old form.  		if (expr.Annotation<ReplaceMethodCallsWithOperators.RestoreOriginalAssignOperatorAnnotation> () != null) {  			// We use '<' so that expressions are introduced on the deepest level possible (goal 3)  			if (result.CostInCheckedContext + new Cost (1' 1) < result.CostInUncheckedContext) {  				result.CostInUncheckedContext = result.CostInCheckedContext + new Cost (1' 1);  				result.NodesToInsertInUncheckedContext = result.NodesToInsertInCheckedContext + new ConvertCompoundAssignment (expr' true);  			} else if (result.CostInUncheckedContext + new Cost (1' 1) < result.CostInCheckedContext) {  				result.CostInCheckedContext = result.CostInUncheckedContext + new Cost (1' 1);  				result.NodesToInsertInCheckedContext = result.NodesToInsertInUncheckedContext + new ConvertCompoundAssignment (expr' false);  			}  		}  	} else if (expr.Role.IsValid (Expression.Null)) {  		// We use '<' so that expressions are introduced on the deepest level possible (goal 3)  		if (result.CostInCheckedContext + new Cost (0' 1) < result.CostInUncheckedContext) {  			result.CostInUncheckedContext = result.CostInCheckedContext + new Cost (0' 1);  			result.NodesToInsertInUncheckedContext = result.NodesToInsertInCheckedContext + new InsertedExpression (expr' true);  		} else if (result.CostInUncheckedContext + new Cost (0' 1) < result.CostInCheckedContext) {  			result.CostInCheckedContext = result.CostInUncheckedContext + new Cost (0' 1);  			result.NodesToInsertInCheckedContext = result.NodesToInsertInUncheckedContext + new InsertedExpression (expr' false);  		}  	}  }  
Magic Number,Custom.Decompiler.Ast.Transforms,AddCheckedBlocks,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\Transforms\AddCheckedBlocks.cs,GetResult,The following statement contains a magic number: if (expr != null) {  	CheckedUncheckedAnnotation annotation = expr.Annotation<CheckedUncheckedAnnotation> ();  	if (annotation != null) {  		// If the annotation requires this node to be in a specific context' add a huge cost to the other context  		// That huge cost gives us the option to ignore a required checked/unchecked expression when there wouldn't be any  		// solution otherwise. (e.g. "for (checked(M().x += 1); true; unchecked(M().x += 2)) {}")  		if (annotation.IsChecked)  			result.CostInUncheckedContext += new Cost (10000' 0);  		else  			result.CostInCheckedContext += new Cost (10000' 0);  	}  	// Embed this node in an checked/unchecked expression:  	if (expr.Parent is ExpressionStatement) {  		// We cannot use checked/unchecked for top-level-expressions.  		// However' we could try converting a compound assignment (checked(a+=b);) or unary operator (checked(a++);)  		// back to its old form.  		if (expr.Annotation<ReplaceMethodCallsWithOperators.RestoreOriginalAssignOperatorAnnotation> () != null) {  			// We use '<' so that expressions are introduced on the deepest level possible (goal 3)  			if (result.CostInCheckedContext + new Cost (1' 1) < result.CostInUncheckedContext) {  				result.CostInUncheckedContext = result.CostInCheckedContext + new Cost (1' 1);  				result.NodesToInsertInUncheckedContext = result.NodesToInsertInCheckedContext + new ConvertCompoundAssignment (expr' true);  			} else if (result.CostInUncheckedContext + new Cost (1' 1) < result.CostInCheckedContext) {  				result.CostInCheckedContext = result.CostInUncheckedContext + new Cost (1' 1);  				result.NodesToInsertInCheckedContext = result.NodesToInsertInUncheckedContext + new ConvertCompoundAssignment (expr' false);  			}  		}  	} else if (expr.Role.IsValid (Expression.Null)) {  		// We use '<' so that expressions are introduced on the deepest level possible (goal 3)  		if (result.CostInCheckedContext + new Cost (0' 1) < result.CostInUncheckedContext) {  			result.CostInUncheckedContext = result.CostInCheckedContext + new Cost (0' 1);  			result.NodesToInsertInUncheckedContext = result.NodesToInsertInCheckedContext + new InsertedExpression (expr' true);  		} else if (result.CostInUncheckedContext + new Cost (0' 1) < result.CostInCheckedContext) {  			result.CostInCheckedContext = result.CostInUncheckedContext + new Cost (0' 1);  			result.NodesToInsertInCheckedContext = result.NodesToInsertInUncheckedContext + new InsertedExpression (expr' false);  		}  	}  }  
Magic Number,Custom.Decompiler.Ast.Transforms,AddCheckedBlocks,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\Transforms\AddCheckedBlocks.cs,GetResult,The following statement contains a magic number: if (annotation != null) {  	// If the annotation requires this node to be in a specific context' add a huge cost to the other context  	// That huge cost gives us the option to ignore a required checked/unchecked expression when there wouldn't be any  	// solution otherwise. (e.g. "for (checked(M().x += 1); true; unchecked(M().x += 2)) {}")  	if (annotation.IsChecked)  		result.CostInUncheckedContext += new Cost (10000' 0);  	else  		result.CostInCheckedContext += new Cost (10000' 0);  }  
Magic Number,Custom.Decompiler.Ast.Transforms,AddCheckedBlocks,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\Transforms\AddCheckedBlocks.cs,GetResult,The following statement contains a magic number: if (annotation != null) {  	// If the annotation requires this node to be in a specific context' add a huge cost to the other context  	// That huge cost gives us the option to ignore a required checked/unchecked expression when there wouldn't be any  	// solution otherwise. (e.g. "for (checked(M().x += 1); true; unchecked(M().x += 2)) {}")  	if (annotation.IsChecked)  		result.CostInUncheckedContext += new Cost (10000' 0);  	else  		result.CostInCheckedContext += new Cost (10000' 0);  }  
Magic Number,Custom.Decompiler.Ast.Transforms,AddCheckedBlocks,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\Transforms\AddCheckedBlocks.cs,GetResult,The following statement contains a magic number: if (annotation.IsChecked)  	result.CostInUncheckedContext += new Cost (10000' 0);  else  	result.CostInCheckedContext += new Cost (10000' 0);  
Magic Number,Custom.Decompiler.Ast.Transforms,AddCheckedBlocks,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\Transforms\AddCheckedBlocks.cs,GetResult,The following statement contains a magic number: if (annotation.IsChecked)  	result.CostInUncheckedContext += new Cost (10000' 0);  else  	result.CostInCheckedContext += new Cost (10000' 0);  
Magic Number,Custom.Decompiler.Ast.Transforms,AddCheckedBlocks,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\Transforms\AddCheckedBlocks.cs,GetResult,The following statement contains a magic number: result.CostInUncheckedContext += new Cost (10000' 0);  
Magic Number,Custom.Decompiler.Ast.Transforms,AddCheckedBlocks,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\Transforms\AddCheckedBlocks.cs,GetResult,The following statement contains a magic number: result.CostInCheckedContext += new Cost (10000' 0);  
Magic Number,Custom.Decompiler.Ast.Transforms,DelegateConstruction,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\Transforms\DelegateConstruction.cs,VisitObjectCreateExpression,The following statement contains a magic number: if (objectCreateExpression.Arguments.Count == 2) {  	Expression obj = objectCreateExpression.Arguments.First ();  	Expression func = objectCreateExpression.Arguments.Last ();  	Annotation annotation = func.Annotation<Annotation> ();  	if (annotation != null) {  		IdentifierExpression methodIdent = (IdentifierExpression)((InvocationExpression)func).Arguments.Single ();  		MethodReference method = methodIdent.Annotation<MethodReference> ();  		if (method != null) {  			if (HandleAnonymousMethod (objectCreateExpression' obj' method))  				return null;  			// Perform the transformation to "new Action(obj.func)".  			obj.Remove ();  			methodIdent.Remove ();  			if (!annotation.IsVirtual && obj is ThisReferenceExpression) {  				// maybe it's getting the pointer of a base method?  				if (method.DeclaringType.GetElementType () != context.CurrentType) {  					obj = new BaseReferenceExpression ();  				}  			}  			if (!annotation.IsVirtual && obj is NullReferenceExpression && !method.HasThis) {  				// We're loading a static method.  				// However it is possible to load extension methods with an instance' so we compare the number of arguments:  				bool isExtensionMethod = false;  				TypeReference delegateType = objectCreateExpression.Type.Annotation<TypeReference> ();  				if (delegateType != null) {  					TypeDefinition delegateTypeDef = delegateType.Resolve ();  					if (delegateTypeDef != null) {  						MethodDefinition invokeMethod = delegateTypeDef.Methods.FirstOrDefault (m => m.Name == "Invoke");  						if (invokeMethod != null) {  							isExtensionMethod = (invokeMethod.Parameters.Count + 1 == method.Parameters.Count);  						}  					}  				}  				if (!isExtensionMethod) {  					obj = new TypeReferenceExpression {  						Type = AstBuilder.ConvertType (method.DeclaringType)  					};  				}  			}  			// now transform the identifier into a member reference  			MemberReferenceExpression mre = new MemberReferenceExpression ();  			mre.Target = obj;  			mre.MemberName = methodIdent.Identifier;  			methodIdent.TypeArguments.MoveTo (mre.TypeArguments);  			mre.AddAnnotation (method);  			objectCreateExpression.Arguments.Clear ();  			objectCreateExpression.Arguments.Add (mre);  			return null;  		}  	}  }  
Magic Number,Custom.Decompiler.Ast.Transforms,DelegateConstruction,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\Transforms\DelegateConstruction.cs,VisitBlockStatement,The following statement contains a magic number: foreach (ExpressionStatement stmt in blockStatement.Statements.OfType<ExpressionStatement> ().ToArray ()) {  	Match displayClassAssignmentMatch = displayClassAssignmentPattern.Match (stmt);  	if (!displayClassAssignmentMatch.Success)  		continue;  	ILVariable variable = displayClassAssignmentMatch.Get<AstNode> ("variable").Single ().Annotation<ILVariable> ();  	if (variable == null)  		continue;  	TypeDefinition type = variable.Type.ResolveWithinSameModule ();  	if (!IsPotentialClosure (context' type))  		continue;  	if (displayClassAssignmentMatch.Get<AstType> ("type").Single ().Annotation<TypeReference> ().ResolveWithinSameModule () != type)  		continue;  	// Looks like we found a display class creation. Now let's verify that the variable is used only for field accesses:  	bool ok = true;  	foreach (var identExpr in blockStatement.Descendants.OfType<IdentifierExpression> ()) {  		if (identExpr.Identifier == variable.Name && identExpr != displayClassAssignmentMatch.Get ("variable").Single ()) {  			if (!(identExpr.Parent is MemberReferenceExpression && identExpr.Parent.Annotation<FieldReference> () != null))  				ok = false;  		}  	}  	if (!ok)  		continue;  	Dictionary<FieldReference' AstNode> dict = new Dictionary<FieldReference' AstNode> ();  	// Delete the variable declaration statement:  	VariableDeclarationStatement displayClassVarDecl = PatternStatementTransform.FindVariableDeclaration (stmt' variable.Name);  	if (displayClassVarDecl != null)  		displayClassVarDecl.Remove ();  	// Delete the assignment statement:  	AstNode cur = stmt.NextSibling;  	stmt.Remove ();  	// Delete any following statements as long as they assign parameters to the display class  	BlockStatement rootBlock = blockStatement.Ancestors.OfType<BlockStatement> ().LastOrDefault () ?? blockStatement;  	List<ILVariable> parameterOccurrances = rootBlock.Descendants.OfType<IdentifierExpression> ().Select (n => n.Annotation<ILVariable> ()).Where (p => p != null && p.IsParameter).ToList ();  	AstNode next;  	for (; cur != null; cur = next) {  		next = cur.NextSibling;  		// Test for the pattern:  		// "variableName.MemberName = right;"  		ExpressionStatement closureFieldAssignmentPattern = new ExpressionStatement (new AssignmentExpression (new NamedNode ("left"' new MemberReferenceExpression {  			Target = new IdentifierExpression (variable.Name)'  			MemberName = Pattern.AnyString  		})' new AnyNode ("right")));  		Match m = closureFieldAssignmentPattern.Match (cur);  		if (m.Success) {  			FieldDefinition fieldDef = m.Get<MemberReferenceExpression> ("left").Single ().Annotation<FieldReference> ().ResolveWithinSameModule ();  			AstNode right = m.Get<AstNode> ("right").Single ();  			bool isParameter = false;  			bool isDisplayClassParentPointerAssignment = false;  			if (right is ThisReferenceExpression) {  				isParameter = true;  			} else if (right is IdentifierExpression) {  				// handle parameters only if the whole method contains no other occurrence except for 'right'  				ILVariable v = right.Annotation<ILVariable> ();  				isParameter = v.IsParameter && parameterOccurrances.Count (c => c == v) == 1;  				if (!isParameter && IsPotentialClosure (context' v.Type.ResolveWithinSameModule ())) {  					// parent display class within the same method  					// (closure2.localsX = closure1;)  					isDisplayClassParentPointerAssignment = true;  				}  			} else if (right is MemberReferenceExpression) {  				// copy of parent display class reference from an outer lambda  				// closure2.localsX = this.localsY  				MemberReferenceExpression mre = m.Get<MemberReferenceExpression> ("right").Single ();  				do {  					// descend into the targets of the mre as long as the field types are closures  					FieldDefinition fieldDef2 = mre.Annotation<FieldReference> ().ResolveWithinSameModule ();  					if (fieldDef2 == null || !IsPotentialClosure (context' fieldDef2.FieldType.ResolveWithinSameModule ())) {  						break;  					}  					// if we finally get to a this reference' it's copying a display class parent pointer  					if (mre.Target is ThisReferenceExpression) {  						isDisplayClassParentPointerAssignment = true;  					}  					mre = mre.Target as MemberReferenceExpression;  				} while (mre != null);  			}  			if (isParameter || isDisplayClassParentPointerAssignment) {  				dict [fieldDef] = right;  				cur.Remove ();  			} else {  				break;  			}  		} else {  			break;  		}  	}  	// Now create variables for all fields of the display class (except for those that we already handled as parameters)  	List<Tuple<AstType' ILVariable>> variablesToDeclare = new List<Tuple<AstType' ILVariable>> ();  	foreach (FieldDefinition field in type.Fields) {  		if (field.IsStatic)  			continue;  		// skip static fields  		if (dict.ContainsKey (field))  			// skip field if it already was handled as parameter  			continue;  		string capturedVariableName = field.Name;  		if (capturedVariableName.StartsWith ("$VB$Local_"' StringComparison.Ordinal) && capturedVariableName.Length > 10)  			capturedVariableName = capturedVariableName.Substring (10);  		EnsureVariableNameIsAvailable (blockStatement' capturedVariableName);  		currentlyUsedVariableNames.Add (capturedVariableName);  		ILVariable ilVar = new ILVariable {  			IsGenerated = true'  			Name = capturedVariableName'  			Type = field.FieldType'  		};  		variablesToDeclare.Add (Tuple.Create (AstBuilder.ConvertType (field.FieldType' field)' ilVar));  		dict [field] = new IdentifierExpression (capturedVariableName).WithAnnotation (ilVar);  	}  	// Now figure out where the closure was accessed and use the simpler replacement expression there:  	foreach (var identExpr in blockStatement.Descendants.OfType<IdentifierExpression> ()) {  		if (identExpr.Identifier == variable.Name) {  			MemberReferenceExpression mre = (MemberReferenceExpression)identExpr.Parent;  			AstNode replacement;  			if (dict.TryGetValue (mre.Annotation<FieldReference> ().ResolveWithinSameModule ()' out replacement)) {  				mre.ReplaceWith (replacement.Clone ());  			}  		}  	}  	// Now insert the variable declarations (we can do this after the replacements only so that the scope detection works):  	Statement insertionPoint = blockStatement.Statements.FirstOrDefault ();  	foreach (var tuple in variablesToDeclare) {  		var newVarDecl = new VariableDeclarationStatement (tuple.Item1' tuple.Item2.Name);  		newVarDecl.Variables.Single ().AddAnnotation (new CapturedVariableAnnotation ());  		newVarDecl.Variables.Single ().AddAnnotation (tuple.Item2);  		blockStatement.Statements.InsertBefore (insertionPoint' newVarDecl);  	}  }  
Magic Number,Custom.Decompiler.Ast.Transforms,DelegateConstruction,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\Transforms\DelegateConstruction.cs,VisitBlockStatement,The following statement contains a magic number: foreach (ExpressionStatement stmt in blockStatement.Statements.OfType<ExpressionStatement> ().ToArray ()) {  	Match displayClassAssignmentMatch = displayClassAssignmentPattern.Match (stmt);  	if (!displayClassAssignmentMatch.Success)  		continue;  	ILVariable variable = displayClassAssignmentMatch.Get<AstNode> ("variable").Single ().Annotation<ILVariable> ();  	if (variable == null)  		continue;  	TypeDefinition type = variable.Type.ResolveWithinSameModule ();  	if (!IsPotentialClosure (context' type))  		continue;  	if (displayClassAssignmentMatch.Get<AstType> ("type").Single ().Annotation<TypeReference> ().ResolveWithinSameModule () != type)  		continue;  	// Looks like we found a display class creation. Now let's verify that the variable is used only for field accesses:  	bool ok = true;  	foreach (var identExpr in blockStatement.Descendants.OfType<IdentifierExpression> ()) {  		if (identExpr.Identifier == variable.Name && identExpr != displayClassAssignmentMatch.Get ("variable").Single ()) {  			if (!(identExpr.Parent is MemberReferenceExpression && identExpr.Parent.Annotation<FieldReference> () != null))  				ok = false;  		}  	}  	if (!ok)  		continue;  	Dictionary<FieldReference' AstNode> dict = new Dictionary<FieldReference' AstNode> ();  	// Delete the variable declaration statement:  	VariableDeclarationStatement displayClassVarDecl = PatternStatementTransform.FindVariableDeclaration (stmt' variable.Name);  	if (displayClassVarDecl != null)  		displayClassVarDecl.Remove ();  	// Delete the assignment statement:  	AstNode cur = stmt.NextSibling;  	stmt.Remove ();  	// Delete any following statements as long as they assign parameters to the display class  	BlockStatement rootBlock = blockStatement.Ancestors.OfType<BlockStatement> ().LastOrDefault () ?? blockStatement;  	List<ILVariable> parameterOccurrances = rootBlock.Descendants.OfType<IdentifierExpression> ().Select (n => n.Annotation<ILVariable> ()).Where (p => p != null && p.IsParameter).ToList ();  	AstNode next;  	for (; cur != null; cur = next) {  		next = cur.NextSibling;  		// Test for the pattern:  		// "variableName.MemberName = right;"  		ExpressionStatement closureFieldAssignmentPattern = new ExpressionStatement (new AssignmentExpression (new NamedNode ("left"' new MemberReferenceExpression {  			Target = new IdentifierExpression (variable.Name)'  			MemberName = Pattern.AnyString  		})' new AnyNode ("right")));  		Match m = closureFieldAssignmentPattern.Match (cur);  		if (m.Success) {  			FieldDefinition fieldDef = m.Get<MemberReferenceExpression> ("left").Single ().Annotation<FieldReference> ().ResolveWithinSameModule ();  			AstNode right = m.Get<AstNode> ("right").Single ();  			bool isParameter = false;  			bool isDisplayClassParentPointerAssignment = false;  			if (right is ThisReferenceExpression) {  				isParameter = true;  			} else if (right is IdentifierExpression) {  				// handle parameters only if the whole method contains no other occurrence except for 'right'  				ILVariable v = right.Annotation<ILVariable> ();  				isParameter = v.IsParameter && parameterOccurrances.Count (c => c == v) == 1;  				if (!isParameter && IsPotentialClosure (context' v.Type.ResolveWithinSameModule ())) {  					// parent display class within the same method  					// (closure2.localsX = closure1;)  					isDisplayClassParentPointerAssignment = true;  				}  			} else if (right is MemberReferenceExpression) {  				// copy of parent display class reference from an outer lambda  				// closure2.localsX = this.localsY  				MemberReferenceExpression mre = m.Get<MemberReferenceExpression> ("right").Single ();  				do {  					// descend into the targets of the mre as long as the field types are closures  					FieldDefinition fieldDef2 = mre.Annotation<FieldReference> ().ResolveWithinSameModule ();  					if (fieldDef2 == null || !IsPotentialClosure (context' fieldDef2.FieldType.ResolveWithinSameModule ())) {  						break;  					}  					// if we finally get to a this reference' it's copying a display class parent pointer  					if (mre.Target is ThisReferenceExpression) {  						isDisplayClassParentPointerAssignment = true;  					}  					mre = mre.Target as MemberReferenceExpression;  				} while (mre != null);  			}  			if (isParameter || isDisplayClassParentPointerAssignment) {  				dict [fieldDef] = right;  				cur.Remove ();  			} else {  				break;  			}  		} else {  			break;  		}  	}  	// Now create variables for all fields of the display class (except for those that we already handled as parameters)  	List<Tuple<AstType' ILVariable>> variablesToDeclare = new List<Tuple<AstType' ILVariable>> ();  	foreach (FieldDefinition field in type.Fields) {  		if (field.IsStatic)  			continue;  		// skip static fields  		if (dict.ContainsKey (field))  			// skip field if it already was handled as parameter  			continue;  		string capturedVariableName = field.Name;  		if (capturedVariableName.StartsWith ("$VB$Local_"' StringComparison.Ordinal) && capturedVariableName.Length > 10)  			capturedVariableName = capturedVariableName.Substring (10);  		EnsureVariableNameIsAvailable (blockStatement' capturedVariableName);  		currentlyUsedVariableNames.Add (capturedVariableName);  		ILVariable ilVar = new ILVariable {  			IsGenerated = true'  			Name = capturedVariableName'  			Type = field.FieldType'  		};  		variablesToDeclare.Add (Tuple.Create (AstBuilder.ConvertType (field.FieldType' field)' ilVar));  		dict [field] = new IdentifierExpression (capturedVariableName).WithAnnotation (ilVar);  	}  	// Now figure out where the closure was accessed and use the simpler replacement expression there:  	foreach (var identExpr in blockStatement.Descendants.OfType<IdentifierExpression> ()) {  		if (identExpr.Identifier == variable.Name) {  			MemberReferenceExpression mre = (MemberReferenceExpression)identExpr.Parent;  			AstNode replacement;  			if (dict.TryGetValue (mre.Annotation<FieldReference> ().ResolveWithinSameModule ()' out replacement)) {  				mre.ReplaceWith (replacement.Clone ());  			}  		}  	}  	// Now insert the variable declarations (we can do this after the replacements only so that the scope detection works):  	Statement insertionPoint = blockStatement.Statements.FirstOrDefault ();  	foreach (var tuple in variablesToDeclare) {  		var newVarDecl = new VariableDeclarationStatement (tuple.Item1' tuple.Item2.Name);  		newVarDecl.Variables.Single ().AddAnnotation (new CapturedVariableAnnotation ());  		newVarDecl.Variables.Single ().AddAnnotation (tuple.Item2);  		blockStatement.Statements.InsertBefore (insertionPoint' newVarDecl);  	}  }  
Magic Number,Custom.Decompiler.Ast.Transforms,DelegateConstruction,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\Transforms\DelegateConstruction.cs,VisitBlockStatement,The following statement contains a magic number: foreach (FieldDefinition field in type.Fields) {  	if (field.IsStatic)  		continue;  	// skip static fields  	if (dict.ContainsKey (field))  		// skip field if it already was handled as parameter  		continue;  	string capturedVariableName = field.Name;  	if (capturedVariableName.StartsWith ("$VB$Local_"' StringComparison.Ordinal) && capturedVariableName.Length > 10)  		capturedVariableName = capturedVariableName.Substring (10);  	EnsureVariableNameIsAvailable (blockStatement' capturedVariableName);  	currentlyUsedVariableNames.Add (capturedVariableName);  	ILVariable ilVar = new ILVariable {  		IsGenerated = true'  		Name = capturedVariableName'  		Type = field.FieldType'  	};  	variablesToDeclare.Add (Tuple.Create (AstBuilder.ConvertType (field.FieldType' field)' ilVar));  	dict [field] = new IdentifierExpression (capturedVariableName).WithAnnotation (ilVar);  }  
Magic Number,Custom.Decompiler.Ast.Transforms,DelegateConstruction,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\Transforms\DelegateConstruction.cs,VisitBlockStatement,The following statement contains a magic number: foreach (FieldDefinition field in type.Fields) {  	if (field.IsStatic)  		continue;  	// skip static fields  	if (dict.ContainsKey (field))  		// skip field if it already was handled as parameter  		continue;  	string capturedVariableName = field.Name;  	if (capturedVariableName.StartsWith ("$VB$Local_"' StringComparison.Ordinal) && capturedVariableName.Length > 10)  		capturedVariableName = capturedVariableName.Substring (10);  	EnsureVariableNameIsAvailable (blockStatement' capturedVariableName);  	currentlyUsedVariableNames.Add (capturedVariableName);  	ILVariable ilVar = new ILVariable {  		IsGenerated = true'  		Name = capturedVariableName'  		Type = field.FieldType'  	};  	variablesToDeclare.Add (Tuple.Create (AstBuilder.ConvertType (field.FieldType' field)' ilVar));  	dict [field] = new IdentifierExpression (capturedVariableName).WithAnnotation (ilVar);  }  
Magic Number,Custom.Decompiler.Ast.Transforms,DelegateConstruction,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\Transforms\DelegateConstruction.cs,VisitBlockStatement,The following statement contains a magic number: if (capturedVariableName.StartsWith ("$VB$Local_"' StringComparison.Ordinal) && capturedVariableName.Length > 10)  	capturedVariableName = capturedVariableName.Substring (10);  
Magic Number,Custom.Decompiler.Ast.Transforms,DelegateConstruction,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\Transforms\DelegateConstruction.cs,VisitBlockStatement,The following statement contains a magic number: if (capturedVariableName.StartsWith ("$VB$Local_"' StringComparison.Ordinal) && capturedVariableName.Length > 10)  	capturedVariableName = capturedVariableName.Substring (10);  
Magic Number,Custom.Decompiler.Ast.Transforms,DelegateConstruction,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\Transforms\DelegateConstruction.cs,VisitBlockStatement,The following statement contains a magic number: capturedVariableName = capturedVariableName.Substring (10);  
Magic Number,Custom.Decompiler.Ast.Transforms,ExpressionTreeConverter,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\Transforms\ExpressionTreeConverter.cs,CouldBeExpressionTree,The following statement contains a magic number: if (expr != null && expr.Arguments.Count == 2) {  	MethodReference mr = expr.Annotation<MethodReference> ();  	return mr != null && mr.Name == "Lambda" && mr.DeclaringType.FullName == "System.Linq.Expressions.Expression";  }  
Magic Number,Custom.Decompiler.Ast.Transforms,ExpressionTreeConverter,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\Transforms\ExpressionTreeConverter.cs,ConvertLambda,The following statement contains a magic number: if (invocation.Arguments.Count != 2)  	return NotSupported (invocation);  
Magic Number,Custom.Decompiler.Ast.Transforms,ExpressionTreeConverter,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\Transforms\ExpressionTreeConverter.cs,ConvertField,The following statement contains a magic number: if (invocation.Arguments.Count != 2)  	return NotSupported (invocation);  
Magic Number,Custom.Decompiler.Ast.Transforms,ExpressionTreeConverter,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\Transforms\ExpressionTreeConverter.cs,ConvertProperty,The following statement contains a magic number: if (invocation.Arguments.Count != 2)  	return NotSupported (invocation);  
Magic Number,Custom.Decompiler.Ast.Transforms,ExpressionTreeConverter,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\Transforms\ExpressionTreeConverter.cs,GetPropertyName,The following statement contains a magic number: if (name.StartsWith ("get_"' StringComparison.Ordinal) || name.StartsWith ("set_"' StringComparison.Ordinal))  	name = name.Substring (4);  
Magic Number,Custom.Decompiler.Ast.Transforms,ExpressionTreeConverter,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\Transforms\ExpressionTreeConverter.cs,GetPropertyName,The following statement contains a magic number: name = name.Substring (4);  
Magic Number,Custom.Decompiler.Ast.Transforms,ExpressionTreeConverter,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\Transforms\ExpressionTreeConverter.cs,ConvertCall,The following statement contains a magic number: if (invocation.Arguments.Count < 2)  	return NotSupported (invocation);  
Magic Number,Custom.Decompiler.Ast.Transforms,ExpressionTreeConverter,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\Transforms\ExpressionTreeConverter.cs,ConvertCall,The following statement contains a magic number: if (m.Success) {  	target = null;  	firstArgumentPosition = 1;  } else {  	m = getMethodFromHandlePattern.Match (invocation.Arguments.ElementAt (1));  	if (!m.Success)  		return NotSupported (invocation);  	target = invocation.Arguments.ElementAt (0);  	firstArgumentPosition = 2;  }  
Magic Number,Custom.Decompiler.Ast.Transforms,ExpressionTreeConverter,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\Transforms\ExpressionTreeConverter.cs,ConvertCall,The following statement contains a magic number: firstArgumentPosition = 2;  
Magic Number,Custom.Decompiler.Ast.Transforms,ExpressionTreeConverter,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\Transforms\ExpressionTreeConverter.cs,ConvertInvoke,The following statement contains a magic number: if (invocation.Arguments.Count != 2)  	return NotSupported (invocation);  
Magic Number,Custom.Decompiler.Ast.Transforms,ExpressionTreeConverter,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\Transforms\ExpressionTreeConverter.cs,ConvertBinaryOperator,The following statement contains a magic number: if (invocation.Arguments.Count < 2)  	return NotSupported (invocation);  
Magic Number,Custom.Decompiler.Ast.Transforms,ExpressionTreeConverter,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\Transforms\ExpressionTreeConverter.cs,ConvertBinaryOperator,The following statement contains a magic number: switch (invocation.Arguments.Count) {  case 2:  	return boe;  case 3:  	Match m = getMethodFromHandlePattern.Match (invocation.Arguments.ElementAt (2));  	if (m.Success)  		return boe.WithAnnotation (m.Get<AstNode> ("method").Single ().Annotation<MethodReference> ());  	else  		return null;  case 4:  	if (!trueOrFalse.IsMatch (invocation.Arguments.ElementAt (2)))  		return null;  	m = getMethodFromHandlePattern.Match (invocation.Arguments.ElementAt (3));  	if (m.Success)  		return boe.WithAnnotation (m.Get<AstNode> ("method").Single ().Annotation<MethodReference> ());  	else  		return null;  default:  	return NotSupported (invocation);  }  
Magic Number,Custom.Decompiler.Ast.Transforms,ExpressionTreeConverter,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\Transforms\ExpressionTreeConverter.cs,ConvertBinaryOperator,The following statement contains a magic number: switch (invocation.Arguments.Count) {  case 2:  	return boe;  case 3:  	Match m = getMethodFromHandlePattern.Match (invocation.Arguments.ElementAt (2));  	if (m.Success)  		return boe.WithAnnotation (m.Get<AstNode> ("method").Single ().Annotation<MethodReference> ());  	else  		return null;  case 4:  	if (!trueOrFalse.IsMatch (invocation.Arguments.ElementAt (2)))  		return null;  	m = getMethodFromHandlePattern.Match (invocation.Arguments.ElementAt (3));  	if (m.Success)  		return boe.WithAnnotation (m.Get<AstNode> ("method").Single ().Annotation<MethodReference> ());  	else  		return null;  default:  	return NotSupported (invocation);  }  
Magic Number,Custom.Decompiler.Ast.Transforms,ExpressionTreeConverter,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\Transforms\ExpressionTreeConverter.cs,ConvertBinaryOperator,The following statement contains a magic number: switch (invocation.Arguments.Count) {  case 2:  	return boe;  case 3:  	Match m = getMethodFromHandlePattern.Match (invocation.Arguments.ElementAt (2));  	if (m.Success)  		return boe.WithAnnotation (m.Get<AstNode> ("method").Single ().Annotation<MethodReference> ());  	else  		return null;  case 4:  	if (!trueOrFalse.IsMatch (invocation.Arguments.ElementAt (2)))  		return null;  	m = getMethodFromHandlePattern.Match (invocation.Arguments.ElementAt (3));  	if (m.Success)  		return boe.WithAnnotation (m.Get<AstNode> ("method").Single ().Annotation<MethodReference> ());  	else  		return null;  default:  	return NotSupported (invocation);  }  
Magic Number,Custom.Decompiler.Ast.Transforms,ExpressionTreeConverter,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\Transforms\ExpressionTreeConverter.cs,ConvertBinaryOperator,The following statement contains a magic number: switch (invocation.Arguments.Count) {  case 2:  	return boe;  case 3:  	Match m = getMethodFromHandlePattern.Match (invocation.Arguments.ElementAt (2));  	if (m.Success)  		return boe.WithAnnotation (m.Get<AstNode> ("method").Single ().Annotation<MethodReference> ());  	else  		return null;  case 4:  	if (!trueOrFalse.IsMatch (invocation.Arguments.ElementAt (2)))  		return null;  	m = getMethodFromHandlePattern.Match (invocation.Arguments.ElementAt (3));  	if (m.Success)  		return boe.WithAnnotation (m.Get<AstNode> ("method").Single ().Annotation<MethodReference> ());  	else  		return null;  default:  	return NotSupported (invocation);  }  
Magic Number,Custom.Decompiler.Ast.Transforms,ExpressionTreeConverter,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\Transforms\ExpressionTreeConverter.cs,ConvertBinaryOperator,The following statement contains a magic number: switch (invocation.Arguments.Count) {  case 2:  	return boe;  case 3:  	Match m = getMethodFromHandlePattern.Match (invocation.Arguments.ElementAt (2));  	if (m.Success)  		return boe.WithAnnotation (m.Get<AstNode> ("method").Single ().Annotation<MethodReference> ());  	else  		return null;  case 4:  	if (!trueOrFalse.IsMatch (invocation.Arguments.ElementAt (2)))  		return null;  	m = getMethodFromHandlePattern.Match (invocation.Arguments.ElementAt (3));  	if (m.Success)  		return boe.WithAnnotation (m.Get<AstNode> ("method").Single ().Annotation<MethodReference> ());  	else  		return null;  default:  	return NotSupported (invocation);  }  
Magic Number,Custom.Decompiler.Ast.Transforms,ExpressionTreeConverter,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\Transforms\ExpressionTreeConverter.cs,ConvertBinaryOperator,The following statement contains a magic number: switch (invocation.Arguments.Count) {  case 2:  	return boe;  case 3:  	Match m = getMethodFromHandlePattern.Match (invocation.Arguments.ElementAt (2));  	if (m.Success)  		return boe.WithAnnotation (m.Get<AstNode> ("method").Single ().Annotation<MethodReference> ());  	else  		return null;  case 4:  	if (!trueOrFalse.IsMatch (invocation.Arguments.ElementAt (2)))  		return null;  	m = getMethodFromHandlePattern.Match (invocation.Arguments.ElementAt (3));  	if (m.Success)  		return boe.WithAnnotation (m.Get<AstNode> ("method").Single ().Annotation<MethodReference> ());  	else  		return null;  default:  	return NotSupported (invocation);  }  
Magic Number,Custom.Decompiler.Ast.Transforms,ExpressionTreeConverter,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\Transforms\ExpressionTreeConverter.cs,ConvertBinaryOperator,The following statement contains a magic number: if (!trueOrFalse.IsMatch (invocation.Arguments.ElementAt (2)))  	return null;  
Magic Number,Custom.Decompiler.Ast.Transforms,ExpressionTreeConverter,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\Transforms\ExpressionTreeConverter.cs,ConvertBinaryOperator,The following statement contains a magic number: m = getMethodFromHandlePattern.Match (invocation.Arguments.ElementAt (3));  
Magic Number,Custom.Decompiler.Ast.Transforms,ExpressionTreeConverter,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\Transforms\ExpressionTreeConverter.cs,ConvertUnaryOperator,The following statement contains a magic number: switch (invocation.Arguments.Count) {  case 1:  	return uoe;  case 2:  	Match m = getMethodFromHandlePattern.Match (invocation.Arguments.ElementAt (1));  	if (m.Success)  		return uoe.WithAnnotation (m.Get<AstNode> ("method").Single ().Annotation<MethodReference> ());  	else  		return null;  default:  	return NotSupported (invocation);  }  
Magic Number,Custom.Decompiler.Ast.Transforms,ExpressionTreeConverter,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\Transforms\ExpressionTreeConverter.cs,ConvertCondition,The following statement contains a magic number: if (invocation.Arguments.Count != 3)  	return NotSupported (invocation);  
Magic Number,Custom.Decompiler.Ast.Transforms,ExpressionTreeConverter,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\Transforms\ExpressionTreeConverter.cs,ConvertNewObject,The following statement contains a magic number: if (invocation.Arguments.Count < 1 || invocation.Arguments.Count > 3)  	return NotSupported (invocation);  
Magic Number,Custom.Decompiler.Ast.Transforms,ExpressionTreeConverter,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\Transforms\ExpressionTreeConverter.cs,ConvertNewObject,The following statement contains a magic number: if (invocation.Arguments.Count >= 2) {  	IList<Expression> arguments = ConvertExpressionsArray (invocation.Arguments.ElementAtOrDefault (1));  	if (arguments == null)  		return null;  	oce.Arguments.AddRange (arguments);  }  
Magic Number,Custom.Decompiler.Ast.Transforms,ExpressionTreeConverter,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\Transforms\ExpressionTreeConverter.cs,ConvertNewObject,The following statement contains a magic number: if (invocation.Arguments.Count >= 3 && declaringType.IsAnonymousType ()) {  	MethodDefinition resolvedCtor = ctor.Resolve ();  	if (resolvedCtor == null || resolvedCtor.Parameters.Count != oce.Arguments.Count)  		return null;  	AnonymousTypeCreateExpression atce = new AnonymousTypeCreateExpression ();  	var arguments = oce.Arguments.ToArray ();  	if (AstMethodBodyBuilder.CanInferAnonymousTypePropertyNamesFromArguments (arguments' resolvedCtor.Parameters)) {  		oce.Arguments.MoveTo (atce.Initializers);  	} else {  		for (int i = 0; i < resolvedCtor.Parameters.Count; i++) {  			atce.Initializers.Add (new NamedExpression {  				Name = resolvedCtor.Parameters [i].Name'  				Expression = arguments [i].Detach ()  			});  		}  	}  	return atce;  }  
Magic Number,Custom.Decompiler.Ast.Transforms,ExpressionTreeConverter,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\Transforms\ExpressionTreeConverter.cs,ConvertListInit,The following statement contains a magic number: if (invocation.Arguments.Count != 2)  	return NotSupported (invocation);  
Magic Number,Custom.Decompiler.Ast.Transforms,ExpressionTreeConverter,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\Transforms\ExpressionTreeConverter.cs,ConvertMemberInit,The following statement contains a magic number: if (invocation.Arguments.Count != 2)  	return NotSupported (invocation);  
Magic Number,Custom.Decompiler.Ast.Transforms,ExpressionTreeConverter,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\Transforms\ExpressionTreeConverter.cs,ConvertMemberBindings,The following statement contains a magic number: foreach (var binding in m.Get<Expression> ("binding")) {  	InvocationExpression bindingInvocation = binding as InvocationExpression;  	if (bindingInvocation == null || bindingInvocation.Arguments.Count != 2)  		return null;  	MemberReferenceExpression bindingMRE = bindingInvocation.Target as MemberReferenceExpression;  	if (bindingMRE == null || !expressionTypeReference.IsMatch (bindingMRE.Target))  		return null;  	Expression bindingTarget = bindingInvocation.Arguments.ElementAt (0);  	Expression bindingValue = bindingInvocation.Arguments.ElementAt (1);  	string memberName;  	Match m2 = getMethodFromHandlePattern.Match (bindingTarget);  	if (m2.Success) {  		MethodReference setter = m2.Get<AstNode> ("method").Single ().Annotation<MethodReference> ();  		if (setter == null)  			return null;  		memberName = GetPropertyName (setter);  	} else {  		return null;  	}  	Expression convertedValue;  	switch (bindingMRE.MemberName) {  	case "Bind":  		convertedValue = Convert (bindingValue);  		break;  	case "MemberBind":  		convertedValue = ConvertMemberBindings (bindingValue);  		break;  	case "ListBind":  		convertedValue = ConvertElementInit (bindingValue);  		break;  	default:  		return null;  	}  	if (convertedValue == null)  		return null;  	result.Elements.Add (new NamedExpression (memberName' convertedValue));  }  
Magic Number,Custom.Decompiler.Ast.Transforms,ExpressionTreeConverter,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\Transforms\ExpressionTreeConverter.cs,ConvertMemberBindings,The following statement contains a magic number: if (bindingInvocation == null || bindingInvocation.Arguments.Count != 2)  	return null;  
Magic Number,Custom.Decompiler.Ast.Transforms,ExpressionTreeConverter,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\Transforms\ExpressionTreeConverter.cs,ConvertCast,The following statement contains a magic number: if (invocation.Arguments.Count < 2)  	return null;  
Magic Number,Custom.Decompiler.Ast.Transforms,ExpressionTreeConverter,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\Transforms\ExpressionTreeConverter.cs,ConvertCast,The following statement contains a magic number: if (converted != null && type != null) {  	CastExpression cast = converted.CastTo (type);  	cast.AddAnnotation (isChecked ? AddCheckedBlocks.CheckedAnnotation : AddCheckedBlocks.UncheckedAnnotation);  	switch (invocation.Arguments.Count) {  	case 2:  		return cast;  	case 3:  		Match m = getMethodFromHandlePattern.Match (invocation.Arguments.ElementAt (2));  		if (m.Success)  			return cast.WithAnnotation (m.Get<AstNode> ("method").Single ().Annotation<MethodReference> ());  		else  			return null;  	}  }  
Magic Number,Custom.Decompiler.Ast.Transforms,ExpressionTreeConverter,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\Transforms\ExpressionTreeConverter.cs,ConvertCast,The following statement contains a magic number: if (converted != null && type != null) {  	CastExpression cast = converted.CastTo (type);  	cast.AddAnnotation (isChecked ? AddCheckedBlocks.CheckedAnnotation : AddCheckedBlocks.UncheckedAnnotation);  	switch (invocation.Arguments.Count) {  	case 2:  		return cast;  	case 3:  		Match m = getMethodFromHandlePattern.Match (invocation.Arguments.ElementAt (2));  		if (m.Success)  			return cast.WithAnnotation (m.Get<AstNode> ("method").Single ().Annotation<MethodReference> ());  		else  			return null;  	}  }  
Magic Number,Custom.Decompiler.Ast.Transforms,ExpressionTreeConverter,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\Transforms\ExpressionTreeConverter.cs,ConvertCast,The following statement contains a magic number: if (converted != null && type != null) {  	CastExpression cast = converted.CastTo (type);  	cast.AddAnnotation (isChecked ? AddCheckedBlocks.CheckedAnnotation : AddCheckedBlocks.UncheckedAnnotation);  	switch (invocation.Arguments.Count) {  	case 2:  		return cast;  	case 3:  		Match m = getMethodFromHandlePattern.Match (invocation.Arguments.ElementAt (2));  		if (m.Success)  			return cast.WithAnnotation (m.Get<AstNode> ("method").Single ().Annotation<MethodReference> ());  		else  			return null;  	}  }  
Magic Number,Custom.Decompiler.Ast.Transforms,ExpressionTreeConverter,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\Transforms\ExpressionTreeConverter.cs,ConvertCast,The following statement contains a magic number: switch (invocation.Arguments.Count) {  case 2:  	return cast;  case 3:  	Match m = getMethodFromHandlePattern.Match (invocation.Arguments.ElementAt (2));  	if (m.Success)  		return cast.WithAnnotation (m.Get<AstNode> ("method").Single ().Annotation<MethodReference> ());  	else  		return null;  }  
Magic Number,Custom.Decompiler.Ast.Transforms,ExpressionTreeConverter,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\Transforms\ExpressionTreeConverter.cs,ConvertCast,The following statement contains a magic number: switch (invocation.Arguments.Count) {  case 2:  	return cast;  case 3:  	Match m = getMethodFromHandlePattern.Match (invocation.Arguments.ElementAt (2));  	if (m.Success)  		return cast.WithAnnotation (m.Get<AstNode> ("method").Single ().Annotation<MethodReference> ());  	else  		return null;  }  
Magic Number,Custom.Decompiler.Ast.Transforms,ExpressionTreeConverter,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\Transforms\ExpressionTreeConverter.cs,ConvertCast,The following statement contains a magic number: switch (invocation.Arguments.Count) {  case 2:  	return cast;  case 3:  	Match m = getMethodFromHandlePattern.Match (invocation.Arguments.ElementAt (2));  	if (m.Success)  		return cast.WithAnnotation (m.Get<AstNode> ("method").Single ().Annotation<MethodReference> ());  	else  		return null;  }  
Magic Number,Custom.Decompiler.Ast.Transforms,ExpressionTreeConverter,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\Transforms\ExpressionTreeConverter.cs,ConvertTypeAs,The following statement contains a magic number: if (invocation.Arguments.Count != 2)  	return null;  
Magic Number,Custom.Decompiler.Ast.Transforms,ExpressionTreeConverter,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\Transforms\ExpressionTreeConverter.cs,ConvertTypeIs,The following statement contains a magic number: if (invocation.Arguments.Count != 2)  	return null;  
Magic Number,Custom.Decompiler.Ast.Transforms,ExpressionTreeConverter,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\Transforms\ExpressionTreeConverter.cs,ConvertArrayIndex,The following statement contains a magic number: if (invocation.Arguments.Count != 2)  	return NotSupported (invocation);  
Magic Number,Custom.Decompiler.Ast.Transforms,ExpressionTreeConverter,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\Transforms\ExpressionTreeConverter.cs,ConvertNewArrayInit,The following statement contains a magic number: if (invocation.Arguments.Count != 2)  	return NotSupported (invocation);  
Magic Number,Custom.Decompiler.Ast.Transforms,ExpressionTreeConverter,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\Transforms\ExpressionTreeConverter.cs,ConvertNewArrayBounds,The following statement contains a magic number: if (invocation.Arguments.Count != 2)  	return NotSupported (invocation);  
Magic Number,Custom.Decompiler.Ast.Transforms,IntroduceQueryExpressions,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\Transforms\IntroduceQueryExpressions.cs,DecompileQuery,The following statement contains a magic number: switch (mre.MemberName) {  case "Select": {  	if (invocation.Arguments.Count != 1)  		return null;  	string parameterName;  	Expression body;  	if (MatchSimpleLambda (invocation.Arguments.Single ()' out parameterName' out body)) {  		QueryExpression query = new QueryExpression ();  		query.Clauses.Add (new QueryFromClause {  			Identifier = parameterName'  			Expression = mre.Target.Detach ()  		});  		query.Clauses.Add (new QuerySelectClause {  			Expression = body.Detach ()  		});  		return query;  	}  	return null;  }  case "GroupBy": {  	if (invocation.Arguments.Count == 2) {  		string parameterName1' parameterName2;  		Expression keySelector' elementSelector;  		if (MatchSimpleLambda (invocation.Arguments.ElementAt (0)' out parameterName1' out keySelector) && MatchSimpleLambda (invocation.Arguments.ElementAt (1)' out parameterName2' out elementSelector) && parameterName1 == parameterName2) {  			QueryExpression query = new QueryExpression ();  			query.Clauses.Add (new QueryFromClause {  				Identifier = parameterName1'  				Expression = mre.Target.Detach ()  			});  			query.Clauses.Add (new QueryGroupClause {  				Projection = elementSelector.Detach ()'  				Key = keySelector.Detach ()  			});  			return query;  		}  	} else if (invocation.Arguments.Count == 1) {  		string parameterName;  		Expression keySelector;  		if (MatchSimpleLambda (invocation.Arguments.Single ()' out parameterName' out keySelector)) {  			QueryExpression query = new QueryExpression ();  			query.Clauses.Add (new QueryFromClause {  				Identifier = parameterName'  				Expression = mre.Target.Detach ()  			});  			query.Clauses.Add (new QueryGroupClause {  				Projection = new IdentifierExpression (parameterName)'  				Key = keySelector.Detach ()  			});  			return query;  		}  	}  	return null;  }  case "SelectMany": {  	if (invocation.Arguments.Count != 2)  		return null;  	string parameterName;  	Expression collectionSelector;  	if (!MatchSimpleLambda (invocation.Arguments.ElementAt (0)' out parameterName' out collectionSelector))  		return null;  	LambdaExpression lambda = invocation.Arguments.ElementAt (1) as LambdaExpression;  	if (lambda != null && lambda.Parameters.Count == 2 && lambda.Body is Expression) {  		ParameterDeclaration p1 = lambda.Parameters.ElementAt (0);  		ParameterDeclaration p2 = lambda.Parameters.ElementAt (1);  		if (p1.Name == parameterName) {  			QueryExpression query = new QueryExpression ();  			query.Clauses.Add (new QueryFromClause {  				Identifier = p1.Name'  				Expression = mre.Target.Detach ()  			});  			query.Clauses.Add (new QueryFromClause {  				Identifier = p2.Name'  				Expression = collectionSelector.Detach ()  			});  			query.Clauses.Add (new QuerySelectClause {  				Expression = ((Expression)lambda.Body).Detach ()  			});  			return query;  		}  	}  	return null;  }  case "Where": {  	if (invocation.Arguments.Count != 1)  		return null;  	string parameterName;  	Expression body;  	if (MatchSimpleLambda (invocation.Arguments.Single ()' out parameterName' out body)) {  		QueryExpression query = new QueryExpression ();  		query.Clauses.Add (new QueryFromClause {  			Identifier = parameterName'  			Expression = mre.Target.Detach ()  		});  		query.Clauses.Add (new QueryWhereClause {  			Condition = body.Detach ()  		});  		return query;  	}  	return null;  }  case "OrderBy":  case "OrderByDescending":  case "ThenBy":  case "ThenByDescending": {  	if (invocation.Arguments.Count != 1)  		return null;  	string parameterName;  	Expression orderExpression;  	if (MatchSimpleLambda (invocation.Arguments.Single ()' out parameterName' out orderExpression)) {  		if (ValidateThenByChain (invocation' parameterName)) {  			QueryOrderClause orderClause = new QueryOrderClause ();  			InvocationExpression tmp = invocation;  			while (mre.MemberName == "ThenBy" || mre.MemberName == "ThenByDescending") {  				// insert new ordering at beginning  				orderClause.Orderings.InsertAfter (null' new QueryOrdering {  					Expression = orderExpression.Detach ()'  					Direction = (mre.MemberName == "ThenBy" ? QueryOrderingDirection.None : QueryOrderingDirection.Descending)  				});  				tmp = (InvocationExpression)mre.Target;  				mre = (MemberReferenceExpression)tmp.Target;  				MatchSimpleLambda (tmp.Arguments.Single ()' out parameterName' out orderExpression);  			}  			// insert new ordering at beginning  			orderClause.Orderings.InsertAfter (null' new QueryOrdering {  				Expression = orderExpression.Detach ()'  				Direction = (mre.MemberName == "OrderBy" ? QueryOrderingDirection.None : QueryOrderingDirection.Descending)  			});  			QueryExpression query = new QueryExpression ();  			query.Clauses.Add (new QueryFromClause {  				Identifier = parameterName'  				Expression = mre.Target.Detach ()  			});  			query.Clauses.Add (orderClause);  			return query;  		}  	}  	return null;  }  case "Join":  case "GroupJoin": {  	if (invocation.Arguments.Count != 4)  		return null;  	Expression source1 = mre.Target;  	Expression source2 = invocation.Arguments.ElementAt (0);  	string elementName1' elementName2;  	Expression key1' key2;  	if (!MatchSimpleLambda (invocation.Arguments.ElementAt (1)' out elementName1' out key1))  		return null;  	if (!MatchSimpleLambda (invocation.Arguments.ElementAt (2)' out elementName2' out key2))  		return null;  	LambdaExpression lambda = invocation.Arguments.ElementAt (3) as LambdaExpression;  	if (lambda != null && lambda.Parameters.Count == 2 && lambda.Body is Expression) {  		ParameterDeclaration p1 = lambda.Parameters.ElementAt (0);  		ParameterDeclaration p2 = lambda.Parameters.ElementAt (1);  		if (p1.Name == elementName1 && (p2.Name == elementName2 || mre.MemberName == "GroupJoin")) {  			QueryExpression query = new QueryExpression ();  			query.Clauses.Add (new QueryFromClause {  				Identifier = elementName1'  				Expression = source1.Detach ()  			});  			QueryJoinClause joinClause = new QueryJoinClause ();  			joinClause.JoinIdentifier = elementName2;  			// join elementName2  			joinClause.InExpression = source2.Detach ();  			// in source2  			joinClause.OnExpression = key1.Detach ();  			// on key1  			joinClause.EqualsExpression = key2.Detach ();  			// equals key2  			if (mre.MemberName == "GroupJoin") {  				joinClause.IntoIdentifier = p2.Name;  				// into p2.Name  			}  			query.Clauses.Add (joinClause);  			query.Clauses.Add (new QuerySelectClause {  				Expression = ((Expression)lambda.Body).Detach ()  			});  			return query;  		}  	}  	return null;  }  default:  	return null;  }  
Magic Number,Custom.Decompiler.Ast.Transforms,IntroduceQueryExpressions,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\Transforms\IntroduceQueryExpressions.cs,DecompileQuery,The following statement contains a magic number: switch (mre.MemberName) {  case "Select": {  	if (invocation.Arguments.Count != 1)  		return null;  	string parameterName;  	Expression body;  	if (MatchSimpleLambda (invocation.Arguments.Single ()' out parameterName' out body)) {  		QueryExpression query = new QueryExpression ();  		query.Clauses.Add (new QueryFromClause {  			Identifier = parameterName'  			Expression = mre.Target.Detach ()  		});  		query.Clauses.Add (new QuerySelectClause {  			Expression = body.Detach ()  		});  		return query;  	}  	return null;  }  case "GroupBy": {  	if (invocation.Arguments.Count == 2) {  		string parameterName1' parameterName2;  		Expression keySelector' elementSelector;  		if (MatchSimpleLambda (invocation.Arguments.ElementAt (0)' out parameterName1' out keySelector) && MatchSimpleLambda (invocation.Arguments.ElementAt (1)' out parameterName2' out elementSelector) && parameterName1 == parameterName2) {  			QueryExpression query = new QueryExpression ();  			query.Clauses.Add (new QueryFromClause {  				Identifier = parameterName1'  				Expression = mre.Target.Detach ()  			});  			query.Clauses.Add (new QueryGroupClause {  				Projection = elementSelector.Detach ()'  				Key = keySelector.Detach ()  			});  			return query;  		}  	} else if (invocation.Arguments.Count == 1) {  		string parameterName;  		Expression keySelector;  		if (MatchSimpleLambda (invocation.Arguments.Single ()' out parameterName' out keySelector)) {  			QueryExpression query = new QueryExpression ();  			query.Clauses.Add (new QueryFromClause {  				Identifier = parameterName'  				Expression = mre.Target.Detach ()  			});  			query.Clauses.Add (new QueryGroupClause {  				Projection = new IdentifierExpression (parameterName)'  				Key = keySelector.Detach ()  			});  			return query;  		}  	}  	return null;  }  case "SelectMany": {  	if (invocation.Arguments.Count != 2)  		return null;  	string parameterName;  	Expression collectionSelector;  	if (!MatchSimpleLambda (invocation.Arguments.ElementAt (0)' out parameterName' out collectionSelector))  		return null;  	LambdaExpression lambda = invocation.Arguments.ElementAt (1) as LambdaExpression;  	if (lambda != null && lambda.Parameters.Count == 2 && lambda.Body is Expression) {  		ParameterDeclaration p1 = lambda.Parameters.ElementAt (0);  		ParameterDeclaration p2 = lambda.Parameters.ElementAt (1);  		if (p1.Name == parameterName) {  			QueryExpression query = new QueryExpression ();  			query.Clauses.Add (new QueryFromClause {  				Identifier = p1.Name'  				Expression = mre.Target.Detach ()  			});  			query.Clauses.Add (new QueryFromClause {  				Identifier = p2.Name'  				Expression = collectionSelector.Detach ()  			});  			query.Clauses.Add (new QuerySelectClause {  				Expression = ((Expression)lambda.Body).Detach ()  			});  			return query;  		}  	}  	return null;  }  case "Where": {  	if (invocation.Arguments.Count != 1)  		return null;  	string parameterName;  	Expression body;  	if (MatchSimpleLambda (invocation.Arguments.Single ()' out parameterName' out body)) {  		QueryExpression query = new QueryExpression ();  		query.Clauses.Add (new QueryFromClause {  			Identifier = parameterName'  			Expression = mre.Target.Detach ()  		});  		query.Clauses.Add (new QueryWhereClause {  			Condition = body.Detach ()  		});  		return query;  	}  	return null;  }  case "OrderBy":  case "OrderByDescending":  case "ThenBy":  case "ThenByDescending": {  	if (invocation.Arguments.Count != 1)  		return null;  	string parameterName;  	Expression orderExpression;  	if (MatchSimpleLambda (invocation.Arguments.Single ()' out parameterName' out orderExpression)) {  		if (ValidateThenByChain (invocation' parameterName)) {  			QueryOrderClause orderClause = new QueryOrderClause ();  			InvocationExpression tmp = invocation;  			while (mre.MemberName == "ThenBy" || mre.MemberName == "ThenByDescending") {  				// insert new ordering at beginning  				orderClause.Orderings.InsertAfter (null' new QueryOrdering {  					Expression = orderExpression.Detach ()'  					Direction = (mre.MemberName == "ThenBy" ? QueryOrderingDirection.None : QueryOrderingDirection.Descending)  				});  				tmp = (InvocationExpression)mre.Target;  				mre = (MemberReferenceExpression)tmp.Target;  				MatchSimpleLambda (tmp.Arguments.Single ()' out parameterName' out orderExpression);  			}  			// insert new ordering at beginning  			orderClause.Orderings.InsertAfter (null' new QueryOrdering {  				Expression = orderExpression.Detach ()'  				Direction = (mre.MemberName == "OrderBy" ? QueryOrderingDirection.None : QueryOrderingDirection.Descending)  			});  			QueryExpression query = new QueryExpression ();  			query.Clauses.Add (new QueryFromClause {  				Identifier = parameterName'  				Expression = mre.Target.Detach ()  			});  			query.Clauses.Add (orderClause);  			return query;  		}  	}  	return null;  }  case "Join":  case "GroupJoin": {  	if (invocation.Arguments.Count != 4)  		return null;  	Expression source1 = mre.Target;  	Expression source2 = invocation.Arguments.ElementAt (0);  	string elementName1' elementName2;  	Expression key1' key2;  	if (!MatchSimpleLambda (invocation.Arguments.ElementAt (1)' out elementName1' out key1))  		return null;  	if (!MatchSimpleLambda (invocation.Arguments.ElementAt (2)' out elementName2' out key2))  		return null;  	LambdaExpression lambda = invocation.Arguments.ElementAt (3) as LambdaExpression;  	if (lambda != null && lambda.Parameters.Count == 2 && lambda.Body is Expression) {  		ParameterDeclaration p1 = lambda.Parameters.ElementAt (0);  		ParameterDeclaration p2 = lambda.Parameters.ElementAt (1);  		if (p1.Name == elementName1 && (p2.Name == elementName2 || mre.MemberName == "GroupJoin")) {  			QueryExpression query = new QueryExpression ();  			query.Clauses.Add (new QueryFromClause {  				Identifier = elementName1'  				Expression = source1.Detach ()  			});  			QueryJoinClause joinClause = new QueryJoinClause ();  			joinClause.JoinIdentifier = elementName2;  			// join elementName2  			joinClause.InExpression = source2.Detach ();  			// in source2  			joinClause.OnExpression = key1.Detach ();  			// on key1  			joinClause.EqualsExpression = key2.Detach ();  			// equals key2  			if (mre.MemberName == "GroupJoin") {  				joinClause.IntoIdentifier = p2.Name;  				// into p2.Name  			}  			query.Clauses.Add (joinClause);  			query.Clauses.Add (new QuerySelectClause {  				Expression = ((Expression)lambda.Body).Detach ()  			});  			return query;  		}  	}  	return null;  }  default:  	return null;  }  
Magic Number,Custom.Decompiler.Ast.Transforms,IntroduceQueryExpressions,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\Transforms\IntroduceQueryExpressions.cs,DecompileQuery,The following statement contains a magic number: switch (mre.MemberName) {  case "Select": {  	if (invocation.Arguments.Count != 1)  		return null;  	string parameterName;  	Expression body;  	if (MatchSimpleLambda (invocation.Arguments.Single ()' out parameterName' out body)) {  		QueryExpression query = new QueryExpression ();  		query.Clauses.Add (new QueryFromClause {  			Identifier = parameterName'  			Expression = mre.Target.Detach ()  		});  		query.Clauses.Add (new QuerySelectClause {  			Expression = body.Detach ()  		});  		return query;  	}  	return null;  }  case "GroupBy": {  	if (invocation.Arguments.Count == 2) {  		string parameterName1' parameterName2;  		Expression keySelector' elementSelector;  		if (MatchSimpleLambda (invocation.Arguments.ElementAt (0)' out parameterName1' out keySelector) && MatchSimpleLambda (invocation.Arguments.ElementAt (1)' out parameterName2' out elementSelector) && parameterName1 == parameterName2) {  			QueryExpression query = new QueryExpression ();  			query.Clauses.Add (new QueryFromClause {  				Identifier = parameterName1'  				Expression = mre.Target.Detach ()  			});  			query.Clauses.Add (new QueryGroupClause {  				Projection = elementSelector.Detach ()'  				Key = keySelector.Detach ()  			});  			return query;  		}  	} else if (invocation.Arguments.Count == 1) {  		string parameterName;  		Expression keySelector;  		if (MatchSimpleLambda (invocation.Arguments.Single ()' out parameterName' out keySelector)) {  			QueryExpression query = new QueryExpression ();  			query.Clauses.Add (new QueryFromClause {  				Identifier = parameterName'  				Expression = mre.Target.Detach ()  			});  			query.Clauses.Add (new QueryGroupClause {  				Projection = new IdentifierExpression (parameterName)'  				Key = keySelector.Detach ()  			});  			return query;  		}  	}  	return null;  }  case "SelectMany": {  	if (invocation.Arguments.Count != 2)  		return null;  	string parameterName;  	Expression collectionSelector;  	if (!MatchSimpleLambda (invocation.Arguments.ElementAt (0)' out parameterName' out collectionSelector))  		return null;  	LambdaExpression lambda = invocation.Arguments.ElementAt (1) as LambdaExpression;  	if (lambda != null && lambda.Parameters.Count == 2 && lambda.Body is Expression) {  		ParameterDeclaration p1 = lambda.Parameters.ElementAt (0);  		ParameterDeclaration p2 = lambda.Parameters.ElementAt (1);  		if (p1.Name == parameterName) {  			QueryExpression query = new QueryExpression ();  			query.Clauses.Add (new QueryFromClause {  				Identifier = p1.Name'  				Expression = mre.Target.Detach ()  			});  			query.Clauses.Add (new QueryFromClause {  				Identifier = p2.Name'  				Expression = collectionSelector.Detach ()  			});  			query.Clauses.Add (new QuerySelectClause {  				Expression = ((Expression)lambda.Body).Detach ()  			});  			return query;  		}  	}  	return null;  }  case "Where": {  	if (invocation.Arguments.Count != 1)  		return null;  	string parameterName;  	Expression body;  	if (MatchSimpleLambda (invocation.Arguments.Single ()' out parameterName' out body)) {  		QueryExpression query = new QueryExpression ();  		query.Clauses.Add (new QueryFromClause {  			Identifier = parameterName'  			Expression = mre.Target.Detach ()  		});  		query.Clauses.Add (new QueryWhereClause {  			Condition = body.Detach ()  		});  		return query;  	}  	return null;  }  case "OrderBy":  case "OrderByDescending":  case "ThenBy":  case "ThenByDescending": {  	if (invocation.Arguments.Count != 1)  		return null;  	string parameterName;  	Expression orderExpression;  	if (MatchSimpleLambda (invocation.Arguments.Single ()' out parameterName' out orderExpression)) {  		if (ValidateThenByChain (invocation' parameterName)) {  			QueryOrderClause orderClause = new QueryOrderClause ();  			InvocationExpression tmp = invocation;  			while (mre.MemberName == "ThenBy" || mre.MemberName == "ThenByDescending") {  				// insert new ordering at beginning  				orderClause.Orderings.InsertAfter (null' new QueryOrdering {  					Expression = orderExpression.Detach ()'  					Direction = (mre.MemberName == "ThenBy" ? QueryOrderingDirection.None : QueryOrderingDirection.Descending)  				});  				tmp = (InvocationExpression)mre.Target;  				mre = (MemberReferenceExpression)tmp.Target;  				MatchSimpleLambda (tmp.Arguments.Single ()' out parameterName' out orderExpression);  			}  			// insert new ordering at beginning  			orderClause.Orderings.InsertAfter (null' new QueryOrdering {  				Expression = orderExpression.Detach ()'  				Direction = (mre.MemberName == "OrderBy" ? QueryOrderingDirection.None : QueryOrderingDirection.Descending)  			});  			QueryExpression query = new QueryExpression ();  			query.Clauses.Add (new QueryFromClause {  				Identifier = parameterName'  				Expression = mre.Target.Detach ()  			});  			query.Clauses.Add (orderClause);  			return query;  		}  	}  	return null;  }  case "Join":  case "GroupJoin": {  	if (invocation.Arguments.Count != 4)  		return null;  	Expression source1 = mre.Target;  	Expression source2 = invocation.Arguments.ElementAt (0);  	string elementName1' elementName2;  	Expression key1' key2;  	if (!MatchSimpleLambda (invocation.Arguments.ElementAt (1)' out elementName1' out key1))  		return null;  	if (!MatchSimpleLambda (invocation.Arguments.ElementAt (2)' out elementName2' out key2))  		return null;  	LambdaExpression lambda = invocation.Arguments.ElementAt (3) as LambdaExpression;  	if (lambda != null && lambda.Parameters.Count == 2 && lambda.Body is Expression) {  		ParameterDeclaration p1 = lambda.Parameters.ElementAt (0);  		ParameterDeclaration p2 = lambda.Parameters.ElementAt (1);  		if (p1.Name == elementName1 && (p2.Name == elementName2 || mre.MemberName == "GroupJoin")) {  			QueryExpression query = new QueryExpression ();  			query.Clauses.Add (new QueryFromClause {  				Identifier = elementName1'  				Expression = source1.Detach ()  			});  			QueryJoinClause joinClause = new QueryJoinClause ();  			joinClause.JoinIdentifier = elementName2;  			// join elementName2  			joinClause.InExpression = source2.Detach ();  			// in source2  			joinClause.OnExpression = key1.Detach ();  			// on key1  			joinClause.EqualsExpression = key2.Detach ();  			// equals key2  			if (mre.MemberName == "GroupJoin") {  				joinClause.IntoIdentifier = p2.Name;  				// into p2.Name  			}  			query.Clauses.Add (joinClause);  			query.Clauses.Add (new QuerySelectClause {  				Expression = ((Expression)lambda.Body).Detach ()  			});  			return query;  		}  	}  	return null;  }  default:  	return null;  }  
Magic Number,Custom.Decompiler.Ast.Transforms,IntroduceQueryExpressions,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\Transforms\IntroduceQueryExpressions.cs,DecompileQuery,The following statement contains a magic number: switch (mre.MemberName) {  case "Select": {  	if (invocation.Arguments.Count != 1)  		return null;  	string parameterName;  	Expression body;  	if (MatchSimpleLambda (invocation.Arguments.Single ()' out parameterName' out body)) {  		QueryExpression query = new QueryExpression ();  		query.Clauses.Add (new QueryFromClause {  			Identifier = parameterName'  			Expression = mre.Target.Detach ()  		});  		query.Clauses.Add (new QuerySelectClause {  			Expression = body.Detach ()  		});  		return query;  	}  	return null;  }  case "GroupBy": {  	if (invocation.Arguments.Count == 2) {  		string parameterName1' parameterName2;  		Expression keySelector' elementSelector;  		if (MatchSimpleLambda (invocation.Arguments.ElementAt (0)' out parameterName1' out keySelector) && MatchSimpleLambda (invocation.Arguments.ElementAt (1)' out parameterName2' out elementSelector) && parameterName1 == parameterName2) {  			QueryExpression query = new QueryExpression ();  			query.Clauses.Add (new QueryFromClause {  				Identifier = parameterName1'  				Expression = mre.Target.Detach ()  			});  			query.Clauses.Add (new QueryGroupClause {  				Projection = elementSelector.Detach ()'  				Key = keySelector.Detach ()  			});  			return query;  		}  	} else if (invocation.Arguments.Count == 1) {  		string parameterName;  		Expression keySelector;  		if (MatchSimpleLambda (invocation.Arguments.Single ()' out parameterName' out keySelector)) {  			QueryExpression query = new QueryExpression ();  			query.Clauses.Add (new QueryFromClause {  				Identifier = parameterName'  				Expression = mre.Target.Detach ()  			});  			query.Clauses.Add (new QueryGroupClause {  				Projection = new IdentifierExpression (parameterName)'  				Key = keySelector.Detach ()  			});  			return query;  		}  	}  	return null;  }  case "SelectMany": {  	if (invocation.Arguments.Count != 2)  		return null;  	string parameterName;  	Expression collectionSelector;  	if (!MatchSimpleLambda (invocation.Arguments.ElementAt (0)' out parameterName' out collectionSelector))  		return null;  	LambdaExpression lambda = invocation.Arguments.ElementAt (1) as LambdaExpression;  	if (lambda != null && lambda.Parameters.Count == 2 && lambda.Body is Expression) {  		ParameterDeclaration p1 = lambda.Parameters.ElementAt (0);  		ParameterDeclaration p2 = lambda.Parameters.ElementAt (1);  		if (p1.Name == parameterName) {  			QueryExpression query = new QueryExpression ();  			query.Clauses.Add (new QueryFromClause {  				Identifier = p1.Name'  				Expression = mre.Target.Detach ()  			});  			query.Clauses.Add (new QueryFromClause {  				Identifier = p2.Name'  				Expression = collectionSelector.Detach ()  			});  			query.Clauses.Add (new QuerySelectClause {  				Expression = ((Expression)lambda.Body).Detach ()  			});  			return query;  		}  	}  	return null;  }  case "Where": {  	if (invocation.Arguments.Count != 1)  		return null;  	string parameterName;  	Expression body;  	if (MatchSimpleLambda (invocation.Arguments.Single ()' out parameterName' out body)) {  		QueryExpression query = new QueryExpression ();  		query.Clauses.Add (new QueryFromClause {  			Identifier = parameterName'  			Expression = mre.Target.Detach ()  		});  		query.Clauses.Add (new QueryWhereClause {  			Condition = body.Detach ()  		});  		return query;  	}  	return null;  }  case "OrderBy":  case "OrderByDescending":  case "ThenBy":  case "ThenByDescending": {  	if (invocation.Arguments.Count != 1)  		return null;  	string parameterName;  	Expression orderExpression;  	if (MatchSimpleLambda (invocation.Arguments.Single ()' out parameterName' out orderExpression)) {  		if (ValidateThenByChain (invocation' parameterName)) {  			QueryOrderClause orderClause = new QueryOrderClause ();  			InvocationExpression tmp = invocation;  			while (mre.MemberName == "ThenBy" || mre.MemberName == "ThenByDescending") {  				// insert new ordering at beginning  				orderClause.Orderings.InsertAfter (null' new QueryOrdering {  					Expression = orderExpression.Detach ()'  					Direction = (mre.MemberName == "ThenBy" ? QueryOrderingDirection.None : QueryOrderingDirection.Descending)  				});  				tmp = (InvocationExpression)mre.Target;  				mre = (MemberReferenceExpression)tmp.Target;  				MatchSimpleLambda (tmp.Arguments.Single ()' out parameterName' out orderExpression);  			}  			// insert new ordering at beginning  			orderClause.Orderings.InsertAfter (null' new QueryOrdering {  				Expression = orderExpression.Detach ()'  				Direction = (mre.MemberName == "OrderBy" ? QueryOrderingDirection.None : QueryOrderingDirection.Descending)  			});  			QueryExpression query = new QueryExpression ();  			query.Clauses.Add (new QueryFromClause {  				Identifier = parameterName'  				Expression = mre.Target.Detach ()  			});  			query.Clauses.Add (orderClause);  			return query;  		}  	}  	return null;  }  case "Join":  case "GroupJoin": {  	if (invocation.Arguments.Count != 4)  		return null;  	Expression source1 = mre.Target;  	Expression source2 = invocation.Arguments.ElementAt (0);  	string elementName1' elementName2;  	Expression key1' key2;  	if (!MatchSimpleLambda (invocation.Arguments.ElementAt (1)' out elementName1' out key1))  		return null;  	if (!MatchSimpleLambda (invocation.Arguments.ElementAt (2)' out elementName2' out key2))  		return null;  	LambdaExpression lambda = invocation.Arguments.ElementAt (3) as LambdaExpression;  	if (lambda != null && lambda.Parameters.Count == 2 && lambda.Body is Expression) {  		ParameterDeclaration p1 = lambda.Parameters.ElementAt (0);  		ParameterDeclaration p2 = lambda.Parameters.ElementAt (1);  		if (p1.Name == elementName1 && (p2.Name == elementName2 || mre.MemberName == "GroupJoin")) {  			QueryExpression query = new QueryExpression ();  			query.Clauses.Add (new QueryFromClause {  				Identifier = elementName1'  				Expression = source1.Detach ()  			});  			QueryJoinClause joinClause = new QueryJoinClause ();  			joinClause.JoinIdentifier = elementName2;  			// join elementName2  			joinClause.InExpression = source2.Detach ();  			// in source2  			joinClause.OnExpression = key1.Detach ();  			// on key1  			joinClause.EqualsExpression = key2.Detach ();  			// equals key2  			if (mre.MemberName == "GroupJoin") {  				joinClause.IntoIdentifier = p2.Name;  				// into p2.Name  			}  			query.Clauses.Add (joinClause);  			query.Clauses.Add (new QuerySelectClause {  				Expression = ((Expression)lambda.Body).Detach ()  			});  			return query;  		}  	}  	return null;  }  default:  	return null;  }  
Magic Number,Custom.Decompiler.Ast.Transforms,IntroduceQueryExpressions,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\Transforms\IntroduceQueryExpressions.cs,DecompileQuery,The following statement contains a magic number: switch (mre.MemberName) {  case "Select": {  	if (invocation.Arguments.Count != 1)  		return null;  	string parameterName;  	Expression body;  	if (MatchSimpleLambda (invocation.Arguments.Single ()' out parameterName' out body)) {  		QueryExpression query = new QueryExpression ();  		query.Clauses.Add (new QueryFromClause {  			Identifier = parameterName'  			Expression = mre.Target.Detach ()  		});  		query.Clauses.Add (new QuerySelectClause {  			Expression = body.Detach ()  		});  		return query;  	}  	return null;  }  case "GroupBy": {  	if (invocation.Arguments.Count == 2) {  		string parameterName1' parameterName2;  		Expression keySelector' elementSelector;  		if (MatchSimpleLambda (invocation.Arguments.ElementAt (0)' out parameterName1' out keySelector) && MatchSimpleLambda (invocation.Arguments.ElementAt (1)' out parameterName2' out elementSelector) && parameterName1 == parameterName2) {  			QueryExpression query = new QueryExpression ();  			query.Clauses.Add (new QueryFromClause {  				Identifier = parameterName1'  				Expression = mre.Target.Detach ()  			});  			query.Clauses.Add (new QueryGroupClause {  				Projection = elementSelector.Detach ()'  				Key = keySelector.Detach ()  			});  			return query;  		}  	} else if (invocation.Arguments.Count == 1) {  		string parameterName;  		Expression keySelector;  		if (MatchSimpleLambda (invocation.Arguments.Single ()' out parameterName' out keySelector)) {  			QueryExpression query = new QueryExpression ();  			query.Clauses.Add (new QueryFromClause {  				Identifier = parameterName'  				Expression = mre.Target.Detach ()  			});  			query.Clauses.Add (new QueryGroupClause {  				Projection = new IdentifierExpression (parameterName)'  				Key = keySelector.Detach ()  			});  			return query;  		}  	}  	return null;  }  case "SelectMany": {  	if (invocation.Arguments.Count != 2)  		return null;  	string parameterName;  	Expression collectionSelector;  	if (!MatchSimpleLambda (invocation.Arguments.ElementAt (0)' out parameterName' out collectionSelector))  		return null;  	LambdaExpression lambda = invocation.Arguments.ElementAt (1) as LambdaExpression;  	if (lambda != null && lambda.Parameters.Count == 2 && lambda.Body is Expression) {  		ParameterDeclaration p1 = lambda.Parameters.ElementAt (0);  		ParameterDeclaration p2 = lambda.Parameters.ElementAt (1);  		if (p1.Name == parameterName) {  			QueryExpression query = new QueryExpression ();  			query.Clauses.Add (new QueryFromClause {  				Identifier = p1.Name'  				Expression = mre.Target.Detach ()  			});  			query.Clauses.Add (new QueryFromClause {  				Identifier = p2.Name'  				Expression = collectionSelector.Detach ()  			});  			query.Clauses.Add (new QuerySelectClause {  				Expression = ((Expression)lambda.Body).Detach ()  			});  			return query;  		}  	}  	return null;  }  case "Where": {  	if (invocation.Arguments.Count != 1)  		return null;  	string parameterName;  	Expression body;  	if (MatchSimpleLambda (invocation.Arguments.Single ()' out parameterName' out body)) {  		QueryExpression query = new QueryExpression ();  		query.Clauses.Add (new QueryFromClause {  			Identifier = parameterName'  			Expression = mre.Target.Detach ()  		});  		query.Clauses.Add (new QueryWhereClause {  			Condition = body.Detach ()  		});  		return query;  	}  	return null;  }  case "OrderBy":  case "OrderByDescending":  case "ThenBy":  case "ThenByDescending": {  	if (invocation.Arguments.Count != 1)  		return null;  	string parameterName;  	Expression orderExpression;  	if (MatchSimpleLambda (invocation.Arguments.Single ()' out parameterName' out orderExpression)) {  		if (ValidateThenByChain (invocation' parameterName)) {  			QueryOrderClause orderClause = new QueryOrderClause ();  			InvocationExpression tmp = invocation;  			while (mre.MemberName == "ThenBy" || mre.MemberName == "ThenByDescending") {  				// insert new ordering at beginning  				orderClause.Orderings.InsertAfter (null' new QueryOrdering {  					Expression = orderExpression.Detach ()'  					Direction = (mre.MemberName == "ThenBy" ? QueryOrderingDirection.None : QueryOrderingDirection.Descending)  				});  				tmp = (InvocationExpression)mre.Target;  				mre = (MemberReferenceExpression)tmp.Target;  				MatchSimpleLambda (tmp.Arguments.Single ()' out parameterName' out orderExpression);  			}  			// insert new ordering at beginning  			orderClause.Orderings.InsertAfter (null' new QueryOrdering {  				Expression = orderExpression.Detach ()'  				Direction = (mre.MemberName == "OrderBy" ? QueryOrderingDirection.None : QueryOrderingDirection.Descending)  			});  			QueryExpression query = new QueryExpression ();  			query.Clauses.Add (new QueryFromClause {  				Identifier = parameterName'  				Expression = mre.Target.Detach ()  			});  			query.Clauses.Add (orderClause);  			return query;  		}  	}  	return null;  }  case "Join":  case "GroupJoin": {  	if (invocation.Arguments.Count != 4)  		return null;  	Expression source1 = mre.Target;  	Expression source2 = invocation.Arguments.ElementAt (0);  	string elementName1' elementName2;  	Expression key1' key2;  	if (!MatchSimpleLambda (invocation.Arguments.ElementAt (1)' out elementName1' out key1))  		return null;  	if (!MatchSimpleLambda (invocation.Arguments.ElementAt (2)' out elementName2' out key2))  		return null;  	LambdaExpression lambda = invocation.Arguments.ElementAt (3) as LambdaExpression;  	if (lambda != null && lambda.Parameters.Count == 2 && lambda.Body is Expression) {  		ParameterDeclaration p1 = lambda.Parameters.ElementAt (0);  		ParameterDeclaration p2 = lambda.Parameters.ElementAt (1);  		if (p1.Name == elementName1 && (p2.Name == elementName2 || mre.MemberName == "GroupJoin")) {  			QueryExpression query = new QueryExpression ();  			query.Clauses.Add (new QueryFromClause {  				Identifier = elementName1'  				Expression = source1.Detach ()  			});  			QueryJoinClause joinClause = new QueryJoinClause ();  			joinClause.JoinIdentifier = elementName2;  			// join elementName2  			joinClause.InExpression = source2.Detach ();  			// in source2  			joinClause.OnExpression = key1.Detach ();  			// on key1  			joinClause.EqualsExpression = key2.Detach ();  			// equals key2  			if (mre.MemberName == "GroupJoin") {  				joinClause.IntoIdentifier = p2.Name;  				// into p2.Name  			}  			query.Clauses.Add (joinClause);  			query.Clauses.Add (new QuerySelectClause {  				Expression = ((Expression)lambda.Body).Detach ()  			});  			return query;  		}  	}  	return null;  }  default:  	return null;  }  
Magic Number,Custom.Decompiler.Ast.Transforms,IntroduceQueryExpressions,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\Transforms\IntroduceQueryExpressions.cs,DecompileQuery,The following statement contains a magic number: switch (mre.MemberName) {  case "Select": {  	if (invocation.Arguments.Count != 1)  		return null;  	string parameterName;  	Expression body;  	if (MatchSimpleLambda (invocation.Arguments.Single ()' out parameterName' out body)) {  		QueryExpression query = new QueryExpression ();  		query.Clauses.Add (new QueryFromClause {  			Identifier = parameterName'  			Expression = mre.Target.Detach ()  		});  		query.Clauses.Add (new QuerySelectClause {  			Expression = body.Detach ()  		});  		return query;  	}  	return null;  }  case "GroupBy": {  	if (invocation.Arguments.Count == 2) {  		string parameterName1' parameterName2;  		Expression keySelector' elementSelector;  		if (MatchSimpleLambda (invocation.Arguments.ElementAt (0)' out parameterName1' out keySelector) && MatchSimpleLambda (invocation.Arguments.ElementAt (1)' out parameterName2' out elementSelector) && parameterName1 == parameterName2) {  			QueryExpression query = new QueryExpression ();  			query.Clauses.Add (new QueryFromClause {  				Identifier = parameterName1'  				Expression = mre.Target.Detach ()  			});  			query.Clauses.Add (new QueryGroupClause {  				Projection = elementSelector.Detach ()'  				Key = keySelector.Detach ()  			});  			return query;  		}  	} else if (invocation.Arguments.Count == 1) {  		string parameterName;  		Expression keySelector;  		if (MatchSimpleLambda (invocation.Arguments.Single ()' out parameterName' out keySelector)) {  			QueryExpression query = new QueryExpression ();  			query.Clauses.Add (new QueryFromClause {  				Identifier = parameterName'  				Expression = mre.Target.Detach ()  			});  			query.Clauses.Add (new QueryGroupClause {  				Projection = new IdentifierExpression (parameterName)'  				Key = keySelector.Detach ()  			});  			return query;  		}  	}  	return null;  }  case "SelectMany": {  	if (invocation.Arguments.Count != 2)  		return null;  	string parameterName;  	Expression collectionSelector;  	if (!MatchSimpleLambda (invocation.Arguments.ElementAt (0)' out parameterName' out collectionSelector))  		return null;  	LambdaExpression lambda = invocation.Arguments.ElementAt (1) as LambdaExpression;  	if (lambda != null && lambda.Parameters.Count == 2 && lambda.Body is Expression) {  		ParameterDeclaration p1 = lambda.Parameters.ElementAt (0);  		ParameterDeclaration p2 = lambda.Parameters.ElementAt (1);  		if (p1.Name == parameterName) {  			QueryExpression query = new QueryExpression ();  			query.Clauses.Add (new QueryFromClause {  				Identifier = p1.Name'  				Expression = mre.Target.Detach ()  			});  			query.Clauses.Add (new QueryFromClause {  				Identifier = p2.Name'  				Expression = collectionSelector.Detach ()  			});  			query.Clauses.Add (new QuerySelectClause {  				Expression = ((Expression)lambda.Body).Detach ()  			});  			return query;  		}  	}  	return null;  }  case "Where": {  	if (invocation.Arguments.Count != 1)  		return null;  	string parameterName;  	Expression body;  	if (MatchSimpleLambda (invocation.Arguments.Single ()' out parameterName' out body)) {  		QueryExpression query = new QueryExpression ();  		query.Clauses.Add (new QueryFromClause {  			Identifier = parameterName'  			Expression = mre.Target.Detach ()  		});  		query.Clauses.Add (new QueryWhereClause {  			Condition = body.Detach ()  		});  		return query;  	}  	return null;  }  case "OrderBy":  case "OrderByDescending":  case "ThenBy":  case "ThenByDescending": {  	if (invocation.Arguments.Count != 1)  		return null;  	string parameterName;  	Expression orderExpression;  	if (MatchSimpleLambda (invocation.Arguments.Single ()' out parameterName' out orderExpression)) {  		if (ValidateThenByChain (invocation' parameterName)) {  			QueryOrderClause orderClause = new QueryOrderClause ();  			InvocationExpression tmp = invocation;  			while (mre.MemberName == "ThenBy" || mre.MemberName == "ThenByDescending") {  				// insert new ordering at beginning  				orderClause.Orderings.InsertAfter (null' new QueryOrdering {  					Expression = orderExpression.Detach ()'  					Direction = (mre.MemberName == "ThenBy" ? QueryOrderingDirection.None : QueryOrderingDirection.Descending)  				});  				tmp = (InvocationExpression)mre.Target;  				mre = (MemberReferenceExpression)tmp.Target;  				MatchSimpleLambda (tmp.Arguments.Single ()' out parameterName' out orderExpression);  			}  			// insert new ordering at beginning  			orderClause.Orderings.InsertAfter (null' new QueryOrdering {  				Expression = orderExpression.Detach ()'  				Direction = (mre.MemberName == "OrderBy" ? QueryOrderingDirection.None : QueryOrderingDirection.Descending)  			});  			QueryExpression query = new QueryExpression ();  			query.Clauses.Add (new QueryFromClause {  				Identifier = parameterName'  				Expression = mre.Target.Detach ()  			});  			query.Clauses.Add (orderClause);  			return query;  		}  	}  	return null;  }  case "Join":  case "GroupJoin": {  	if (invocation.Arguments.Count != 4)  		return null;  	Expression source1 = mre.Target;  	Expression source2 = invocation.Arguments.ElementAt (0);  	string elementName1' elementName2;  	Expression key1' key2;  	if (!MatchSimpleLambda (invocation.Arguments.ElementAt (1)' out elementName1' out key1))  		return null;  	if (!MatchSimpleLambda (invocation.Arguments.ElementAt (2)' out elementName2' out key2))  		return null;  	LambdaExpression lambda = invocation.Arguments.ElementAt (3) as LambdaExpression;  	if (lambda != null && lambda.Parameters.Count == 2 && lambda.Body is Expression) {  		ParameterDeclaration p1 = lambda.Parameters.ElementAt (0);  		ParameterDeclaration p2 = lambda.Parameters.ElementAt (1);  		if (p1.Name == elementName1 && (p2.Name == elementName2 || mre.MemberName == "GroupJoin")) {  			QueryExpression query = new QueryExpression ();  			query.Clauses.Add (new QueryFromClause {  				Identifier = elementName1'  				Expression = source1.Detach ()  			});  			QueryJoinClause joinClause = new QueryJoinClause ();  			joinClause.JoinIdentifier = elementName2;  			// join elementName2  			joinClause.InExpression = source2.Detach ();  			// in source2  			joinClause.OnExpression = key1.Detach ();  			// on key1  			joinClause.EqualsExpression = key2.Detach ();  			// equals key2  			if (mre.MemberName == "GroupJoin") {  				joinClause.IntoIdentifier = p2.Name;  				// into p2.Name  			}  			query.Clauses.Add (joinClause);  			query.Clauses.Add (new QuerySelectClause {  				Expression = ((Expression)lambda.Body).Detach ()  			});  			return query;  		}  	}  	return null;  }  default:  	return null;  }  
Magic Number,Custom.Decompiler.Ast.Transforms,IntroduceQueryExpressions,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\Transforms\IntroduceQueryExpressions.cs,DecompileQuery,The following statement contains a magic number: switch (mre.MemberName) {  case "Select": {  	if (invocation.Arguments.Count != 1)  		return null;  	string parameterName;  	Expression body;  	if (MatchSimpleLambda (invocation.Arguments.Single ()' out parameterName' out body)) {  		QueryExpression query = new QueryExpression ();  		query.Clauses.Add (new QueryFromClause {  			Identifier = parameterName'  			Expression = mre.Target.Detach ()  		});  		query.Clauses.Add (new QuerySelectClause {  			Expression = body.Detach ()  		});  		return query;  	}  	return null;  }  case "GroupBy": {  	if (invocation.Arguments.Count == 2) {  		string parameterName1' parameterName2;  		Expression keySelector' elementSelector;  		if (MatchSimpleLambda (invocation.Arguments.ElementAt (0)' out parameterName1' out keySelector) && MatchSimpleLambda (invocation.Arguments.ElementAt (1)' out parameterName2' out elementSelector) && parameterName1 == parameterName2) {  			QueryExpression query = new QueryExpression ();  			query.Clauses.Add (new QueryFromClause {  				Identifier = parameterName1'  				Expression = mre.Target.Detach ()  			});  			query.Clauses.Add (new QueryGroupClause {  				Projection = elementSelector.Detach ()'  				Key = keySelector.Detach ()  			});  			return query;  		}  	} else if (invocation.Arguments.Count == 1) {  		string parameterName;  		Expression keySelector;  		if (MatchSimpleLambda (invocation.Arguments.Single ()' out parameterName' out keySelector)) {  			QueryExpression query = new QueryExpression ();  			query.Clauses.Add (new QueryFromClause {  				Identifier = parameterName'  				Expression = mre.Target.Detach ()  			});  			query.Clauses.Add (new QueryGroupClause {  				Projection = new IdentifierExpression (parameterName)'  				Key = keySelector.Detach ()  			});  			return query;  		}  	}  	return null;  }  case "SelectMany": {  	if (invocation.Arguments.Count != 2)  		return null;  	string parameterName;  	Expression collectionSelector;  	if (!MatchSimpleLambda (invocation.Arguments.ElementAt (0)' out parameterName' out collectionSelector))  		return null;  	LambdaExpression lambda = invocation.Arguments.ElementAt (1) as LambdaExpression;  	if (lambda != null && lambda.Parameters.Count == 2 && lambda.Body is Expression) {  		ParameterDeclaration p1 = lambda.Parameters.ElementAt (0);  		ParameterDeclaration p2 = lambda.Parameters.ElementAt (1);  		if (p1.Name == parameterName) {  			QueryExpression query = new QueryExpression ();  			query.Clauses.Add (new QueryFromClause {  				Identifier = p1.Name'  				Expression = mre.Target.Detach ()  			});  			query.Clauses.Add (new QueryFromClause {  				Identifier = p2.Name'  				Expression = collectionSelector.Detach ()  			});  			query.Clauses.Add (new QuerySelectClause {  				Expression = ((Expression)lambda.Body).Detach ()  			});  			return query;  		}  	}  	return null;  }  case "Where": {  	if (invocation.Arguments.Count != 1)  		return null;  	string parameterName;  	Expression body;  	if (MatchSimpleLambda (invocation.Arguments.Single ()' out parameterName' out body)) {  		QueryExpression query = new QueryExpression ();  		query.Clauses.Add (new QueryFromClause {  			Identifier = parameterName'  			Expression = mre.Target.Detach ()  		});  		query.Clauses.Add (new QueryWhereClause {  			Condition = body.Detach ()  		});  		return query;  	}  	return null;  }  case "OrderBy":  case "OrderByDescending":  case "ThenBy":  case "ThenByDescending": {  	if (invocation.Arguments.Count != 1)  		return null;  	string parameterName;  	Expression orderExpression;  	if (MatchSimpleLambda (invocation.Arguments.Single ()' out parameterName' out orderExpression)) {  		if (ValidateThenByChain (invocation' parameterName)) {  			QueryOrderClause orderClause = new QueryOrderClause ();  			InvocationExpression tmp = invocation;  			while (mre.MemberName == "ThenBy" || mre.MemberName == "ThenByDescending") {  				// insert new ordering at beginning  				orderClause.Orderings.InsertAfter (null' new QueryOrdering {  					Expression = orderExpression.Detach ()'  					Direction = (mre.MemberName == "ThenBy" ? QueryOrderingDirection.None : QueryOrderingDirection.Descending)  				});  				tmp = (InvocationExpression)mre.Target;  				mre = (MemberReferenceExpression)tmp.Target;  				MatchSimpleLambda (tmp.Arguments.Single ()' out parameterName' out orderExpression);  			}  			// insert new ordering at beginning  			orderClause.Orderings.InsertAfter (null' new QueryOrdering {  				Expression = orderExpression.Detach ()'  				Direction = (mre.MemberName == "OrderBy" ? QueryOrderingDirection.None : QueryOrderingDirection.Descending)  			});  			QueryExpression query = new QueryExpression ();  			query.Clauses.Add (new QueryFromClause {  				Identifier = parameterName'  				Expression = mre.Target.Detach ()  			});  			query.Clauses.Add (orderClause);  			return query;  		}  	}  	return null;  }  case "Join":  case "GroupJoin": {  	if (invocation.Arguments.Count != 4)  		return null;  	Expression source1 = mre.Target;  	Expression source2 = invocation.Arguments.ElementAt (0);  	string elementName1' elementName2;  	Expression key1' key2;  	if (!MatchSimpleLambda (invocation.Arguments.ElementAt (1)' out elementName1' out key1))  		return null;  	if (!MatchSimpleLambda (invocation.Arguments.ElementAt (2)' out elementName2' out key2))  		return null;  	LambdaExpression lambda = invocation.Arguments.ElementAt (3) as LambdaExpression;  	if (lambda != null && lambda.Parameters.Count == 2 && lambda.Body is Expression) {  		ParameterDeclaration p1 = lambda.Parameters.ElementAt (0);  		ParameterDeclaration p2 = lambda.Parameters.ElementAt (1);  		if (p1.Name == elementName1 && (p2.Name == elementName2 || mre.MemberName == "GroupJoin")) {  			QueryExpression query = new QueryExpression ();  			query.Clauses.Add (new QueryFromClause {  				Identifier = elementName1'  				Expression = source1.Detach ()  			});  			QueryJoinClause joinClause = new QueryJoinClause ();  			joinClause.JoinIdentifier = elementName2;  			// join elementName2  			joinClause.InExpression = source2.Detach ();  			// in source2  			joinClause.OnExpression = key1.Detach ();  			// on key1  			joinClause.EqualsExpression = key2.Detach ();  			// equals key2  			if (mre.MemberName == "GroupJoin") {  				joinClause.IntoIdentifier = p2.Name;  				// into p2.Name  			}  			query.Clauses.Add (joinClause);  			query.Clauses.Add (new QuerySelectClause {  				Expression = ((Expression)lambda.Body).Detach ()  			});  			return query;  		}  	}  	return null;  }  default:  	return null;  }  
Magic Number,Custom.Decompiler.Ast.Transforms,IntroduceQueryExpressions,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\Transforms\IntroduceQueryExpressions.cs,DecompileQuery,The following statement contains a magic number: if (invocation.Arguments.Count == 2) {  	string parameterName1' parameterName2;  	Expression keySelector' elementSelector;  	if (MatchSimpleLambda (invocation.Arguments.ElementAt (0)' out parameterName1' out keySelector) && MatchSimpleLambda (invocation.Arguments.ElementAt (1)' out parameterName2' out elementSelector) && parameterName1 == parameterName2) {  		QueryExpression query = new QueryExpression ();  		query.Clauses.Add (new QueryFromClause {  			Identifier = parameterName1'  			Expression = mre.Target.Detach ()  		});  		query.Clauses.Add (new QueryGroupClause {  			Projection = elementSelector.Detach ()'  			Key = keySelector.Detach ()  		});  		return query;  	}  } else if (invocation.Arguments.Count == 1) {  	string parameterName;  	Expression keySelector;  	if (MatchSimpleLambda (invocation.Arguments.Single ()' out parameterName' out keySelector)) {  		QueryExpression query = new QueryExpression ();  		query.Clauses.Add (new QueryFromClause {  			Identifier = parameterName'  			Expression = mre.Target.Detach ()  		});  		query.Clauses.Add (new QueryGroupClause {  			Projection = new IdentifierExpression (parameterName)'  			Key = keySelector.Detach ()  		});  		return query;  	}  }  
Magic Number,Custom.Decompiler.Ast.Transforms,IntroduceQueryExpressions,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\Transforms\IntroduceQueryExpressions.cs,DecompileQuery,The following statement contains a magic number: if (invocation.Arguments.Count != 2)  	return null;  
Magic Number,Custom.Decompiler.Ast.Transforms,IntroduceQueryExpressions,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\Transforms\IntroduceQueryExpressions.cs,DecompileQuery,The following statement contains a magic number: if (lambda != null && lambda.Parameters.Count == 2 && lambda.Body is Expression) {  	ParameterDeclaration p1 = lambda.Parameters.ElementAt (0);  	ParameterDeclaration p2 = lambda.Parameters.ElementAt (1);  	if (p1.Name == parameterName) {  		QueryExpression query = new QueryExpression ();  		query.Clauses.Add (new QueryFromClause {  			Identifier = p1.Name'  			Expression = mre.Target.Detach ()  		});  		query.Clauses.Add (new QueryFromClause {  			Identifier = p2.Name'  			Expression = collectionSelector.Detach ()  		});  		query.Clauses.Add (new QuerySelectClause {  			Expression = ((Expression)lambda.Body).Detach ()  		});  		return query;  	}  }  
Magic Number,Custom.Decompiler.Ast.Transforms,IntroduceQueryExpressions,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\Transforms\IntroduceQueryExpressions.cs,DecompileQuery,The following statement contains a magic number: if (invocation.Arguments.Count != 4)  	return null;  
Magic Number,Custom.Decompiler.Ast.Transforms,IntroduceQueryExpressions,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\Transforms\IntroduceQueryExpressions.cs,DecompileQuery,The following statement contains a magic number: if (!MatchSimpleLambda (invocation.Arguments.ElementAt (2)' out elementName2' out key2))  	return null;  
Magic Number,Custom.Decompiler.Ast.Transforms,IntroduceQueryExpressions,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\Transforms\IntroduceQueryExpressions.cs,DecompileQuery,The following statement contains a magic number: if (lambda != null && lambda.Parameters.Count == 2 && lambda.Body is Expression) {  	ParameterDeclaration p1 = lambda.Parameters.ElementAt (0);  	ParameterDeclaration p2 = lambda.Parameters.ElementAt (1);  	if (p1.Name == elementName1 && (p2.Name == elementName2 || mre.MemberName == "GroupJoin")) {  		QueryExpression query = new QueryExpression ();  		query.Clauses.Add (new QueryFromClause {  			Identifier = elementName1'  			Expression = source1.Detach ()  		});  		QueryJoinClause joinClause = new QueryJoinClause ();  		joinClause.JoinIdentifier = elementName2;  		// join elementName2  		joinClause.InExpression = source2.Detach ();  		// in source2  		joinClause.OnExpression = key1.Detach ();  		// on key1  		joinClause.EqualsExpression = key2.Detach ();  		// equals key2  		if (mre.MemberName == "GroupJoin") {  			joinClause.IntoIdentifier = p2.Name;  			// into p2.Name  		}  		query.Clauses.Add (joinClause);  		query.Clauses.Add (new QuerySelectClause {  			Expression = ((Expression)lambda.Body).Detach ()  		});  		return query;  	}  }  
Magic Number,Custom.Decompiler.Ast.Transforms,ReplaceMethodCallsWithOperators,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\Transforms\ReplaceMethodCallsWithOperators.cs,ProcessInvocationExpression,The following statement contains a magic number: if (methodRef.Name == "Concat" && methodRef.DeclaringType.FullName == "System.String" && arguments.Length >= 2) {  	invocationExpression.Arguments.Clear ();  	// detach arguments from invocationExpression  	Expression expr = arguments [0];  	for (int i = 1; i < arguments.Length; i++) {  		expr = new BinaryOperatorExpression (expr' BinaryOperatorType.Add' arguments [i]);  	}  	invocationExpression.ReplaceWith (expr);  	return;  }  
Magic Number,Custom.Decompiler.Ast.Transforms,ReplaceMethodCallsWithOperators,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\Transforms\ReplaceMethodCallsWithOperators.cs,ProcessInvocationExpression,The following statement contains a magic number: switch (methodRef.FullName) {  case "System.Type System.Type::GetTypeFromHandle(System.RuntimeTypeHandle)":  	if (arguments.Length == 1) {  		if (typeHandleOnTypeOfPattern.IsMatch (arguments [0])) {  			invocationExpression.ReplaceWith (((MemberReferenceExpression)arguments [0]).Target);  			return;  		}  	}  	break;  case "System.Reflection.FieldInfo System.Reflection.FieldInfo::GetFieldFromHandle(System.RuntimeFieldHandle)":  	if (arguments.Length == 1) {  		MemberReferenceExpression mre = arguments [0] as MemberReferenceExpression;  		if (mre != null && mre.MemberName == "FieldHandle" && mre.Target.Annotation<LdTokenAnnotation> () != null) {  			invocationExpression.ReplaceWith (mre.Target);  			return;  		}  	}  	break;  case "System.Reflection.FieldInfo System.Reflection.FieldInfo::GetFieldFromHandle(System.RuntimeFieldHandle'System.RuntimeTypeHandle)":  	if (arguments.Length == 2) {  		MemberReferenceExpression mre1 = arguments [0] as MemberReferenceExpression;  		MemberReferenceExpression mre2 = arguments [1] as MemberReferenceExpression;  		if (mre1 != null && mre1.MemberName == "FieldHandle" && mre1.Target.Annotation<LdTokenAnnotation> () != null) {  			if (mre2 != null && mre2.MemberName == "TypeHandle" && mre2.Target is TypeOfExpression) {  				Expression oldArg = ((InvocationExpression)mre1.Target).Arguments.Single ();  				FieldReference field = oldArg.Annotation<FieldReference> ();  				if (field != null) {  					AstType declaringType = ((TypeOfExpression)mre2.Target).Type.Detach ();  					oldArg.ReplaceWith (declaringType.Member (field.Name).WithAnnotation (field));  					invocationExpression.ReplaceWith (mre1.Target);  					return;  				}  			}  		}  	}  	break;  }  
Magic Number,Custom.Decompiler.Ast.Transforms,ReplaceMethodCallsWithOperators,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\Transforms\ReplaceMethodCallsWithOperators.cs,ProcessInvocationExpression,The following statement contains a magic number: if (arguments.Length == 2) {  	MemberReferenceExpression mre1 = arguments [0] as MemberReferenceExpression;  	MemberReferenceExpression mre2 = arguments [1] as MemberReferenceExpression;  	if (mre1 != null && mre1.MemberName == "FieldHandle" && mre1.Target.Annotation<LdTokenAnnotation> () != null) {  		if (mre2 != null && mre2.MemberName == "TypeHandle" && mre2.Target is TypeOfExpression) {  			Expression oldArg = ((InvocationExpression)mre1.Target).Arguments.Single ();  			FieldReference field = oldArg.Annotation<FieldReference> ();  			if (field != null) {  				AstType declaringType = ((TypeOfExpression)mre2.Target).Type.Detach ();  				oldArg.ReplaceWith (declaringType.Member (field.Name).WithAnnotation (field));  				invocationExpression.ReplaceWith (mre1.Target);  				return;  			}  		}  	}  }  
Magic Number,Custom.Decompiler.Ast.Transforms,ReplaceMethodCallsWithOperators,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\Transforms\ReplaceMethodCallsWithOperators.cs,ProcessInvocationExpression,The following statement contains a magic number: if (bop != null && arguments.Length == 2) {  	invocationExpression.Arguments.Clear ();  	// detach arguments from invocationExpression  	invocationExpression.ReplaceWith (new BinaryOperatorExpression (arguments [0]' bop.Value' arguments [1]).WithAnnotation (methodRef));  	return;  }  
Magic Number,Custom.Decompiler.Disassembler,ReflectionDisassembler,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Disassembler\ReflectionDisassembler.cs,WriteBlob,The following statement contains a magic number: for (int i = 0; i < blob.Length; i++) {  	if (i % 16 == 0 && i < blob.Length - 1) {  		output.WriteLine ();  	} else {  		output.Write (' ');  	}  	output.Write (blob [i].ToString ("x2"));  }  
Magic Number,Custom.Decompiler.Disassembler,ReflectionDisassembler,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Disassembler\ReflectionDisassembler.cs,WriteBlob,The following statement contains a magic number: if (i % 16 == 0 && i < blob.Length - 1) {  	output.WriteLine ();  } else {  	output.Write (' ');  }  
Magic Number,Custom.Decompiler.FlowAnalysis,ControlFlowGraphBuilder,F:\newReposMay17\Fody_Usable\Fody\Decompiler\FlowAnalysis\ControlFlowGraphBuilder.cs,ControlFlowGraphBuilder,The following statement contains a magic number: exceptionalExit = new ControlFlowNode (2' -1' ControlFlowNodeType.ExceptionalExit);  
Magic Number,Custom.Decompiler.FlowAnalysis,ControlFlowGraphBuilder,F:\newReposMay17\Fody_Usable\Fody\Decompiler\FlowAnalysis\ControlFlowGraphBuilder.cs,ControlFlowGraphBuilder,The following statement contains a magic number: Debug.Assert (nodes.Count == 3);  
Magic Number,Custom.Decompiler.ILAst,AsyncDecompiler,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\AsyncDecompiler.cs,MatchTaskCreationPattern,The following statement contains a magic number: if (method.Body.Count < 5)  	return false;  
Magic Number,Custom.Decompiler.ILAst,AsyncDecompiler,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\AsyncDecompiler.cs,MatchTaskCreationPattern,The following statement contains a magic number: if (!method.Body [method.Body.Count - 2].Match (ILCode.Call' out startMethod' out loadStartTarget' out loadStartArgument))  	return false;  
Magic Number,Custom.Decompiler.ILAst,AsyncDecompiler,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\AsyncDecompiler.cs,MatchTaskCreationPattern,The following statement contains a magic number: if (!method.Body [method.Body.Count - 3].MatchStloc (builderVar' out loadBuilderExpr))  	return false;  
Magic Number,Custom.Decompiler.ILAst,AsyncDecompiler,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\AsyncDecompiler.cs,MatchTaskCreationPattern,The following statement contains a magic number: if (!MatchStFld (method.Body [method.Body.Count - 4]' stateMachineVar' out stateField' out initialStateExpr))  	return false;  
Magic Number,Custom.Decompiler.ILAst,AsyncDecompiler,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\AsyncDecompiler.cs,MatchTaskCreationPattern,The following statement contains a magic number: if (!MatchStFld (method.Body [method.Body.Count - 5]' stateMachineVar' out builderField3' out builderInitialization))  	return false;  
Magic Number,Custom.Decompiler.ILAst,AsyncDecompiler,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\AsyncDecompiler.cs,MatchTaskCreationPattern,The following statement contains a magic number: for (int i = 0; i < method.Body.Count - 5; i++) {  	FieldDefinition field;  	ILExpression fieldInit;  	if (!MatchStFld (method.Body [i]' stateMachineVar' out field' out fieldInit))  		return false;  	ILVariable v;  	if (!fieldInit.Match (ILCode.Ldloc' out v))  		return false;  	if (!v.IsParameter)  		return false;  	fieldToParameterMap [field] = v;  }  
Magic Number,Custom.Decompiler.ILAst,AsyncDecompiler,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\AsyncDecompiler.cs,AnalyzeMoveNext,The following statement contains a magic number: if (ilMethod.Body.Count != 6)  	throw new SymbolicAnalysisFailedException ();  
Magic Number,Custom.Decompiler.ILAst,AsyncDecompiler,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\AsyncDecompiler.cs,AnalyzeMoveNext,The following statement contains a magic number: if (!MatchStateAssignment (ilMethod.Body [2]' out finalState))  	throw new SymbolicAnalysisFailedException ();  
Magic Number,Custom.Decompiler.ILAst,AsyncDecompiler,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\AsyncDecompiler.cs,AnalyzeMoveNext,The following statement contains a magic number: if (methodType == AsyncMethodType.TaskOfT) {  	if (!ilMethod.Body [3].Match (ILCode.Call' out setResultMethod' out builderExpr' out resultExpr))  		throw new SymbolicAnalysisFailedException ();  } else {  	if (!ilMethod.Body [3].Match (ILCode.Call' out setResultMethod' out builderExpr))  		throw new SymbolicAnalysisFailedException ();  }  
Magic Number,Custom.Decompiler.ILAst,AsyncDecompiler,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\AsyncDecompiler.cs,AnalyzeMoveNext,The following statement contains a magic number: if (methodType == AsyncMethodType.TaskOfT) {  	if (!ilMethod.Body [3].Match (ILCode.Call' out setResultMethod' out builderExpr' out resultExpr))  		throw new SymbolicAnalysisFailedException ();  } else {  	if (!ilMethod.Body [3].Match (ILCode.Call' out setResultMethod' out builderExpr))  		throw new SymbolicAnalysisFailedException ();  }  
Magic Number,Custom.Decompiler.ILAst,AsyncDecompiler,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\AsyncDecompiler.cs,AnalyzeMoveNext,The following statement contains a magic number: if (!ilMethod.Body [3].Match (ILCode.Call' out setResultMethod' out builderExpr' out resultExpr))  	throw new SymbolicAnalysisFailedException ();  
Magic Number,Custom.Decompiler.ILAst,AsyncDecompiler,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\AsyncDecompiler.cs,AnalyzeMoveNext,The following statement contains a magic number: if (!ilMethod.Body [3].Match (ILCode.Call' out setResultMethod' out builderExpr))  	throw new SymbolicAnalysisFailedException ();  
Magic Number,Custom.Decompiler.ILAst,AsyncDecompiler,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\AsyncDecompiler.cs,AnalyzeMoveNext,The following statement contains a magic number: exitLabel = ilMethod.Body [4] as ILLabel;  
Magic Number,Custom.Decompiler.ILAst,AsyncDecompiler,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\AsyncDecompiler.cs,ValidateCatchBlock,The following statement contains a magic number: if (catchBlock.Body.Count != 3)  	throw new SymbolicAnalysisFailedException ();  
Magic Number,Custom.Decompiler.ILAst,AsyncDecompiler,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\AsyncDecompiler.cs,ValidateCatchBlock,The following statement contains a magic number: if (!(catchBlock.Body [2].Match (ILCode.Leave' out label) && label == exitLabel))  	throw new SymbolicAnalysisFailedException ();  
Magic Number,Custom.Decompiler.ILAst,AsyncDecompiler,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\AsyncDecompiler.cs,HandleAwait,The following statement contains a magic number: if (callAwaitUnsafeOnCompleted.Arguments.Count != 3)  	throw new SymbolicAnalysisFailedException ();  
Magic Number,Custom.Decompiler.ILAst,AsyncDecompiler,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\AsyncDecompiler.cs,Step2,The following statement contains a magic number: if (!(pos >= 2 && body [pos - 2].MatchStloc (awaiterVar' out getAwaiterCall)))  	return false;  
Magic Number,Custom.Decompiler.ILAst,AsyncDecompiler,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\AsyncDecompiler.cs,Step2,The following statement contains a magic number: if (!(pos >= 2 && body [pos - 2].MatchStloc (awaiterVar' out getAwaiterCall)))  	return false;  
Magic Number,Custom.Decompiler.ILAst,AsyncDecompiler,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\AsyncDecompiler.cs,Step2,The following statement contains a magic number: pos -= 2;  
Magic Number,Custom.Decompiler.ILAst,GotoRemoval,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\GotoRemoval.cs,RemoveRedundantCode,The following statement contains a magic number: foreach (ILSwitch ilSwitch in method.GetSelfAndChildrenRecursive<ILSwitch> ()) {  	foreach (ILBlock ilCase in ilSwitch.CaseBlocks) {  		Debug.Assert (ilCase.EntryGoto == null);  		int count = ilCase.Body.Count;  		if (count >= 2) {  			if (ilCase.Body [count - 2].IsUnconditionalControlFlow () && ilCase.Body [count - 1].Match (ILCode.LoopOrSwitchBreak)) {  				ilCase.Body.RemoveAt (count - 1);  			}  		}  	}  	var defaultCase = ilSwitch.CaseBlocks.SingleOrDefault (cb => cb.Values == null);  	// If there is no default block' remove empty case blocks  	if (defaultCase == null || (defaultCase.Body.Count == 1 && defaultCase.Body.Single ().Match (ILCode.LoopOrSwitchBreak))) {  		ilSwitch.CaseBlocks.RemoveAll (b => b.Body.Count == 1 && b.Body.Single ().Match (ILCode.LoopOrSwitchBreak));  	}  }  
Magic Number,Custom.Decompiler.ILAst,GotoRemoval,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\GotoRemoval.cs,RemoveRedundantCode,The following statement contains a magic number: foreach (ILSwitch ilSwitch in method.GetSelfAndChildrenRecursive<ILSwitch> ()) {  	foreach (ILBlock ilCase in ilSwitch.CaseBlocks) {  		Debug.Assert (ilCase.EntryGoto == null);  		int count = ilCase.Body.Count;  		if (count >= 2) {  			if (ilCase.Body [count - 2].IsUnconditionalControlFlow () && ilCase.Body [count - 1].Match (ILCode.LoopOrSwitchBreak)) {  				ilCase.Body.RemoveAt (count - 1);  			}  		}  	}  	var defaultCase = ilSwitch.CaseBlocks.SingleOrDefault (cb => cb.Values == null);  	// If there is no default block' remove empty case blocks  	if (defaultCase == null || (defaultCase.Body.Count == 1 && defaultCase.Body.Single ().Match (ILCode.LoopOrSwitchBreak))) {  		ilSwitch.CaseBlocks.RemoveAll (b => b.Body.Count == 1 && b.Body.Single ().Match (ILCode.LoopOrSwitchBreak));  	}  }  
Magic Number,Custom.Decompiler.ILAst,GotoRemoval,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\GotoRemoval.cs,RemoveRedundantCode,The following statement contains a magic number: foreach (ILBlock ilCase in ilSwitch.CaseBlocks) {  	Debug.Assert (ilCase.EntryGoto == null);  	int count = ilCase.Body.Count;  	if (count >= 2) {  		if (ilCase.Body [count - 2].IsUnconditionalControlFlow () && ilCase.Body [count - 1].Match (ILCode.LoopOrSwitchBreak)) {  			ilCase.Body.RemoveAt (count - 1);  		}  	}  }  
Magic Number,Custom.Decompiler.ILAst,GotoRemoval,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\GotoRemoval.cs,RemoveRedundantCode,The following statement contains a magic number: foreach (ILBlock ilCase in ilSwitch.CaseBlocks) {  	Debug.Assert (ilCase.EntryGoto == null);  	int count = ilCase.Body.Count;  	if (count >= 2) {  		if (ilCase.Body [count - 2].IsUnconditionalControlFlow () && ilCase.Body [count - 1].Match (ILCode.LoopOrSwitchBreak)) {  			ilCase.Body.RemoveAt (count - 1);  		}  	}  }  
Magic Number,Custom.Decompiler.ILAst,GotoRemoval,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\GotoRemoval.cs,RemoveRedundantCode,The following statement contains a magic number: if (count >= 2) {  	if (ilCase.Body [count - 2].IsUnconditionalControlFlow () && ilCase.Body [count - 1].Match (ILCode.LoopOrSwitchBreak)) {  		ilCase.Body.RemoveAt (count - 1);  	}  }  
Magic Number,Custom.Decompiler.ILAst,GotoRemoval,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\GotoRemoval.cs,RemoveRedundantCode,The following statement contains a magic number: if (count >= 2) {  	if (ilCase.Body [count - 2].IsUnconditionalControlFlow () && ilCase.Body [count - 1].Match (ILCode.LoopOrSwitchBreak)) {  		ilCase.Body.RemoveAt (count - 1);  	}  }  
Magic Number,Custom.Decompiler.ILAst,GotoRemoval,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\GotoRemoval.cs,RemoveRedundantCode,The following statement contains a magic number: if (ilCase.Body [count - 2].IsUnconditionalControlFlow () && ilCase.Body [count - 1].Match (ILCode.LoopOrSwitchBreak)) {  	ilCase.Body.RemoveAt (count - 1);  }  
Magic Number,Custom.Decompiler.ILAst,ILAstOptimizer,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,IntroducePropertyAccessInstructions,The following statement contains a magic number: if (expr.Code == ILCode.Call || expr.Code == ILCode.Callvirt) {  	MethodReference cecilMethod = (MethodReference)expr.Operand;  	if (cecilMethod.DeclaringType is ArrayType) {  		switch (cecilMethod.Name) {  		case "Get":  			expr.Code = ILCode.CallGetter;  			break;  		case "Set":  			expr.Code = ILCode.CallSetter;  			break;  		case "Address":  			ByReferenceType brt = cecilMethod.ReturnType as ByReferenceType;  			if (brt != null) {  				MethodReference getMethod = new MethodReference ("Get"' brt.ElementType' cecilMethod.DeclaringType);  				foreach (var p in cecilMethod.Parameters)  					getMethod.Parameters.Add (p);  				getMethod.HasThis = cecilMethod.HasThis;  				expr.Operand = getMethod;  			}  			expr.Code = ILCode.CallGetter;  			if (parentExpr != null) {  				parentExpr.Arguments [posInParent] = new ILExpression (ILCode.AddressOf' null' expr);  			}  			break;  		}  	} else {  		MethodDefinition cecilMethodDef = cecilMethod.Resolve ();  		if (cecilMethodDef != null) {  			if (cecilMethodDef.IsGetter)  				expr.Code = (expr.Code == ILCode.Call) ? ILCode.CallGetter : ILCode.CallvirtGetter;  			else if (cecilMethodDef.IsSetter)  				expr.Code = (expr.Code == ILCode.Call) ? ILCode.CallSetter : ILCode.CallvirtSetter;  		}  	}  } else if (expr.Code == ILCode.Newobj && expr.Arguments.Count == 2) {  	// Might be 'newobj(SomeDelegate' target' ldvirtftn(F' target))'.  	ILVariable target;  	if (expr.Arguments [0].Match (ILCode.Ldloc' out target) && expr.Arguments [1].Code == ILCode.Ldvirtftn && expr.Arguments [1].Arguments.Count == 1 && expr.Arguments [1].Arguments [0].MatchLdloc (target)) {  		// Remove the 'target' argument from the ldvirtftn instruction.  		// It's not needed in the translation to C#' and needs to be eliminated so that the target expression  		// can be inlined.  		expr.Arguments [1].Arguments.Clear ();  	}  }  
Magic Number,Custom.Decompiler.ILAst,ILAstOptimizer,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,IntroducePropertyAccessInstructions,The following statement contains a magic number: if (expr.Code == ILCode.Newobj && expr.Arguments.Count == 2) {  	// Might be 'newobj(SomeDelegate' target' ldvirtftn(F' target))'.  	ILVariable target;  	if (expr.Arguments [0].Match (ILCode.Ldloc' out target) && expr.Arguments [1].Code == ILCode.Ldvirtftn && expr.Arguments [1].Arguments.Count == 1 && expr.Arguments [1].Arguments [0].MatchLdloc (target)) {  		// Remove the 'target' argument from the ldvirtftn instruction.  		// It's not needed in the translation to C#' and needs to be eliminated so that the target expression  		// can be inlined.  		expr.Arguments [1].Arguments.Clear ();  	}  }  
Magic Number,Custom.Decompiler.ILAst,ILAstOptimizer,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,TransformArrayInitializers,The following statement contains a magic number: if (expr.Match (ILCode.Stloc' out v' out newarrExpr) && newarrExpr.Match (ILCode.Newarr' out elementType' out lengthExpr) && lengthExpr.Match (ILCode.Ldc_I4' out arrayLength) && arrayLength > 0) {  	ILExpression[] newArr;  	int initArrayPos;  	if (ForwardScanInitializeArrayRuntimeHelper (body' pos + 1' v' elementType' arrayLength' out newArr' out initArrayPos)) {  		var arrayType = new ArrayType (elementType' 1);  		arrayType.Dimensions [0] = new ArrayDimension (0' arrayLength);  		body [pos] = new ILExpression (ILCode.Stloc' v' new ILExpression (ILCode.InitArray' arrayType' newArr));  		body.RemoveAt (initArrayPos);  	}  	// Put in a limit so that we don't consume too much memory if the code allocates a huge array  	// and populates it extremely sparsly. However' 255 "null" elements in a row actually occur in the Mono C# compiler!  	const int maxConsecutiveDefaultValueExpressions = 300;  	List<ILExpression> operands = new List<ILExpression> ();  	int numberOfInstructionsToRemove = 0;  	for (int j = pos + 1; j < body.Count; j++) {  		ILExpression nextExpr = body [j] as ILExpression;  		int arrayPos;  		if (nextExpr != null && nextExpr.Code.IsStoreToArray () && nextExpr.Arguments [0].Match (ILCode.Ldloc' out v3) && v == v3 && nextExpr.Arguments [1].Match (ILCode.Ldc_I4' out arrayPos) && arrayPos >= operands.Count && arrayPos <= operands.Count + maxConsecutiveDefaultValueExpressions && !nextExpr.Arguments [2].ContainsReferenceTo (v3)) {  			while (operands.Count < arrayPos)  				operands.Add (new ILExpression (ILCode.DefaultValue' elementType));  			operands.Add (nextExpr.Arguments [2]);  			numberOfInstructionsToRemove++;  		} else {  			break;  		}  	}  	if (operands.Count == arrayLength) {  		var arrayType = new ArrayType (elementType' 1);  		arrayType.Dimensions [0] = new ArrayDimension (0' arrayLength);  		expr.Arguments [0] = new ILExpression (ILCode.InitArray' arrayType' operands);  		body.RemoveRange (pos + 1' numberOfInstructionsToRemove);  		new ILInlining (method).InlineIfPossible (body' ref pos);  		return true;  	}  }  
Magic Number,Custom.Decompiler.ILAst,ILAstOptimizer,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,TransformArrayInitializers,The following statement contains a magic number: if (expr.Match (ILCode.Stloc' out v' out newarrExpr) && newarrExpr.Match (ILCode.Newarr' out elementType' out lengthExpr) && lengthExpr.Match (ILCode.Ldc_I4' out arrayLength) && arrayLength > 0) {  	ILExpression[] newArr;  	int initArrayPos;  	if (ForwardScanInitializeArrayRuntimeHelper (body' pos + 1' v' elementType' arrayLength' out newArr' out initArrayPos)) {  		var arrayType = new ArrayType (elementType' 1);  		arrayType.Dimensions [0] = new ArrayDimension (0' arrayLength);  		body [pos] = new ILExpression (ILCode.Stloc' v' new ILExpression (ILCode.InitArray' arrayType' newArr));  		body.RemoveAt (initArrayPos);  	}  	// Put in a limit so that we don't consume too much memory if the code allocates a huge array  	// and populates it extremely sparsly. However' 255 "null" elements in a row actually occur in the Mono C# compiler!  	const int maxConsecutiveDefaultValueExpressions = 300;  	List<ILExpression> operands = new List<ILExpression> ();  	int numberOfInstructionsToRemove = 0;  	for (int j = pos + 1; j < body.Count; j++) {  		ILExpression nextExpr = body [j] as ILExpression;  		int arrayPos;  		if (nextExpr != null && nextExpr.Code.IsStoreToArray () && nextExpr.Arguments [0].Match (ILCode.Ldloc' out v3) && v == v3 && nextExpr.Arguments [1].Match (ILCode.Ldc_I4' out arrayPos) && arrayPos >= operands.Count && arrayPos <= operands.Count + maxConsecutiveDefaultValueExpressions && !nextExpr.Arguments [2].ContainsReferenceTo (v3)) {  			while (operands.Count < arrayPos)  				operands.Add (new ILExpression (ILCode.DefaultValue' elementType));  			operands.Add (nextExpr.Arguments [2]);  			numberOfInstructionsToRemove++;  		} else {  			break;  		}  	}  	if (operands.Count == arrayLength) {  		var arrayType = new ArrayType (elementType' 1);  		arrayType.Dimensions [0] = new ArrayDimension (0' arrayLength);  		expr.Arguments [0] = new ILExpression (ILCode.InitArray' arrayType' operands);  		body.RemoveRange (pos + 1' numberOfInstructionsToRemove);  		new ILInlining (method).InlineIfPossible (body' ref pos);  		return true;  	}  }  
Magic Number,Custom.Decompiler.ILAst,ILAstOptimizer,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,TransformArrayInitializers,The following statement contains a magic number: if (expr.Match (ILCode.Stloc' out v' out newarrExpr) && newarrExpr.Match (ILCode.Newarr' out elementType' out lengthExpr) && lengthExpr.Match (ILCode.Ldc_I4' out arrayLength) && arrayLength > 0) {  	ILExpression[] newArr;  	int initArrayPos;  	if (ForwardScanInitializeArrayRuntimeHelper (body' pos + 1' v' elementType' arrayLength' out newArr' out initArrayPos)) {  		var arrayType = new ArrayType (elementType' 1);  		arrayType.Dimensions [0] = new ArrayDimension (0' arrayLength);  		body [pos] = new ILExpression (ILCode.Stloc' v' new ILExpression (ILCode.InitArray' arrayType' newArr));  		body.RemoveAt (initArrayPos);  	}  	// Put in a limit so that we don't consume too much memory if the code allocates a huge array  	// and populates it extremely sparsly. However' 255 "null" elements in a row actually occur in the Mono C# compiler!  	const int maxConsecutiveDefaultValueExpressions = 300;  	List<ILExpression> operands = new List<ILExpression> ();  	int numberOfInstructionsToRemove = 0;  	for (int j = pos + 1; j < body.Count; j++) {  		ILExpression nextExpr = body [j] as ILExpression;  		int arrayPos;  		if (nextExpr != null && nextExpr.Code.IsStoreToArray () && nextExpr.Arguments [0].Match (ILCode.Ldloc' out v3) && v == v3 && nextExpr.Arguments [1].Match (ILCode.Ldc_I4' out arrayPos) && arrayPos >= operands.Count && arrayPos <= operands.Count + maxConsecutiveDefaultValueExpressions && !nextExpr.Arguments [2].ContainsReferenceTo (v3)) {  			while (operands.Count < arrayPos)  				operands.Add (new ILExpression (ILCode.DefaultValue' elementType));  			operands.Add (nextExpr.Arguments [2]);  			numberOfInstructionsToRemove++;  		} else {  			break;  		}  	}  	if (operands.Count == arrayLength) {  		var arrayType = new ArrayType (elementType' 1);  		arrayType.Dimensions [0] = new ArrayDimension (0' arrayLength);  		expr.Arguments [0] = new ILExpression (ILCode.InitArray' arrayType' operands);  		body.RemoveRange (pos + 1' numberOfInstructionsToRemove);  		new ILInlining (method).InlineIfPossible (body' ref pos);  		return true;  	}  }  
Magic Number,Custom.Decompiler.ILAst,ILAstOptimizer,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,TransformArrayInitializers,The following statement contains a magic number: for (int j = pos + 1; j < body.Count; j++) {  	ILExpression nextExpr = body [j] as ILExpression;  	int arrayPos;  	if (nextExpr != null && nextExpr.Code.IsStoreToArray () && nextExpr.Arguments [0].Match (ILCode.Ldloc' out v3) && v == v3 && nextExpr.Arguments [1].Match (ILCode.Ldc_I4' out arrayPos) && arrayPos >= operands.Count && arrayPos <= operands.Count + maxConsecutiveDefaultValueExpressions && !nextExpr.Arguments [2].ContainsReferenceTo (v3)) {  		while (operands.Count < arrayPos)  			operands.Add (new ILExpression (ILCode.DefaultValue' elementType));  		operands.Add (nextExpr.Arguments [2]);  		numberOfInstructionsToRemove++;  	} else {  		break;  	}  }  
Magic Number,Custom.Decompiler.ILAst,ILAstOptimizer,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,TransformArrayInitializers,The following statement contains a magic number: for (int j = pos + 1; j < body.Count; j++) {  	ILExpression nextExpr = body [j] as ILExpression;  	int arrayPos;  	if (nextExpr != null && nextExpr.Code.IsStoreToArray () && nextExpr.Arguments [0].Match (ILCode.Ldloc' out v3) && v == v3 && nextExpr.Arguments [1].Match (ILCode.Ldc_I4' out arrayPos) && arrayPos >= operands.Count && arrayPos <= operands.Count + maxConsecutiveDefaultValueExpressions && !nextExpr.Arguments [2].ContainsReferenceTo (v3)) {  		while (operands.Count < arrayPos)  			operands.Add (new ILExpression (ILCode.DefaultValue' elementType));  		operands.Add (nextExpr.Arguments [2]);  		numberOfInstructionsToRemove++;  	} else {  		break;  	}  }  
Magic Number,Custom.Decompiler.ILAst,ILAstOptimizer,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,TransformArrayInitializers,The following statement contains a magic number: if (nextExpr != null && nextExpr.Code.IsStoreToArray () && nextExpr.Arguments [0].Match (ILCode.Ldloc' out v3) && v == v3 && nextExpr.Arguments [1].Match (ILCode.Ldc_I4' out arrayPos) && arrayPos >= operands.Count && arrayPos <= operands.Count + maxConsecutiveDefaultValueExpressions && !nextExpr.Arguments [2].ContainsReferenceTo (v3)) {  	while (operands.Count < arrayPos)  		operands.Add (new ILExpression (ILCode.DefaultValue' elementType));  	operands.Add (nextExpr.Arguments [2]);  	numberOfInstructionsToRemove++;  } else {  	break;  }  
Magic Number,Custom.Decompiler.ILAst,ILAstOptimizer,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,TransformArrayInitializers,The following statement contains a magic number: if (nextExpr != null && nextExpr.Code.IsStoreToArray () && nextExpr.Arguments [0].Match (ILCode.Ldloc' out v3) && v == v3 && nextExpr.Arguments [1].Match (ILCode.Ldc_I4' out arrayPos) && arrayPos >= operands.Count && arrayPos <= operands.Count + maxConsecutiveDefaultValueExpressions && !nextExpr.Arguments [2].ContainsReferenceTo (v3)) {  	while (operands.Count < arrayPos)  		operands.Add (new ILExpression (ILCode.DefaultValue' elementType));  	operands.Add (nextExpr.Arguments [2]);  	numberOfInstructionsToRemove++;  } else {  	break;  }  
Magic Number,Custom.Decompiler.ILAst,ILAstOptimizer,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,TransformArrayInitializers,The following statement contains a magic number: operands.Add (nextExpr.Arguments [2]);  
Magic Number,Custom.Decompiler.ILAst,ILAstOptimizer,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,ElementSizeOf,The following statement contains a magic number: switch (elementType) {  case TypeCode.Boolean:  case TypeCode.Byte:  case TypeCode.SByte:  	return 1;  case TypeCode.Char:  case TypeCode.Int16:  case TypeCode.UInt16:  	return 2;  case TypeCode.Int32:  case TypeCode.UInt32:  case TypeCode.Single:  	return 4;  case TypeCode.Int64:  case TypeCode.UInt64:  case TypeCode.Double:  	return 8;  default:  	throw new ArgumentOutOfRangeException ("elementType");  }  
Magic Number,Custom.Decompiler.ILAst,ILAstOptimizer,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,ElementSizeOf,The following statement contains a magic number: switch (elementType) {  case TypeCode.Boolean:  case TypeCode.Byte:  case TypeCode.SByte:  	return 1;  case TypeCode.Char:  case TypeCode.Int16:  case TypeCode.UInt16:  	return 2;  case TypeCode.Int32:  case TypeCode.UInt32:  case TypeCode.Single:  	return 4;  case TypeCode.Int64:  case TypeCode.UInt64:  case TypeCode.Double:  	return 8;  default:  	throw new ArgumentOutOfRangeException ("elementType");  }  
Magic Number,Custom.Decompiler.ILAst,ILAstOptimizer,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,ElementSizeOf,The following statement contains a magic number: switch (elementType) {  case TypeCode.Boolean:  case TypeCode.Byte:  case TypeCode.SByte:  	return 1;  case TypeCode.Char:  case TypeCode.Int16:  case TypeCode.UInt16:  	return 2;  case TypeCode.Int32:  case TypeCode.UInt32:  case TypeCode.Single:  	return 4;  case TypeCode.Int64:  case TypeCode.UInt64:  case TypeCode.Double:  	return 8;  default:  	throw new ArgumentOutOfRangeException ("elementType");  }  
Magic Number,Custom.Decompiler.ILAst,ILAstOptimizer,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,ElementSizeOf,The following statement contains a magic number: return 2;  
Magic Number,Custom.Decompiler.ILAst,ILAstOptimizer,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,ElementSizeOf,The following statement contains a magic number: return 4;  
Magic Number,Custom.Decompiler.ILAst,ILAstOptimizer,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,ElementSizeOf,The following statement contains a magic number: return 8;  
Magic Number,Custom.Decompiler.ILAst,ILAstOptimizer,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,IsSetterInObjectInitializer,The following statement contains a magic number: if (expr.Code == ILCode.CallvirtSetter || expr.Code == ILCode.CallSetter || expr.Code == ILCode.Stfld) {  	return expr.Arguments.Count == 2;  }  
Magic Number,Custom.Decompiler.ILAst,ILAstOptimizer,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,IsSetterInObjectInitializer,The following statement contains a magic number: return expr.Arguments.Count == 2;  
Magic Number,Custom.Decompiler.ILAst,ILAstOptimizer,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,IsAddMethodCall,The following statement contains a magic number: if (expr.Match (ILCode.Callvirt' out addMethod' out args) || expr.Match (ILCode.Call' out addMethod' out args)) {  	if (addMethod.Name == "Add" && addMethod.HasThis) {  		return args.Count >= 2;  	}  }  
Magic Number,Custom.Decompiler.ILAst,ILAstOptimizer,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,IsAddMethodCall,The following statement contains a magic number: if (addMethod.Name == "Add" && addMethod.HasThis) {  	return args.Count >= 2;  }  
Magic Number,Custom.Decompiler.ILAst,ILAstOptimizer,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,IsAddMethodCall,The following statement contains a magic number: return args.Count >= 2;  
Magic Number,Custom.Decompiler.ILAst,ILAstOptimizer,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,CleanupInitializerStackAfterFailedAdjustment,The following statement contains a magic number: while (initializerStack.Count > 1 && initializerStack [initializerStack.Count - 1].Arguments.Count == 1) {  	ILExpression parent = initializerStack [initializerStack.Count - 2];  	Debug.Assert (parent.Arguments.Last () == initializerStack [initializerStack.Count - 1]);  	parent.Arguments.RemoveAt (parent.Arguments.Count - 1);  	initializerStack.RemoveAt (initializerStack.Count - 1);  }  
Magic Number,Custom.Decompiler.ILAst,ILAstOptimizer,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,TransformDecimalCtorToConstant,The following statement contains a magic number: if (expr.Match (ILCode.Newobj' out r' out args) && r.DeclaringType.Namespace == "System" && r.DeclaringType.Name == "Decimal") {  	if (args.Count == 1) {  		int val;  		if (args [0].Match (ILCode.Ldc_I4' out val)) {  			expr.Code = ILCode.Ldc_Decimal;  			expr.Operand = new decimal (val);  			expr.InferredType = r.DeclaringType;  			expr.Arguments.Clear ();  			return true;  		}  	} else if (args.Count == 5) {  		int lo' mid' hi' isNegative' scale;  		if (expr.Arguments [0].Match (ILCode.Ldc_I4' out lo) && expr.Arguments [1].Match (ILCode.Ldc_I4' out mid) && expr.Arguments [2].Match (ILCode.Ldc_I4' out hi) && expr.Arguments [3].Match (ILCode.Ldc_I4' out isNegative) && expr.Arguments [4].Match (ILCode.Ldc_I4' out scale)) {  			expr.Code = ILCode.Ldc_Decimal;  			expr.Operand = new decimal (lo' mid' hi' isNegative != 0' (byte)scale);  			expr.InferredType = r.DeclaringType;  			expr.Arguments.Clear ();  			return true;  		}  	}  }  
Magic Number,Custom.Decompiler.ILAst,ILAstOptimizer,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,TransformDecimalCtorToConstant,The following statement contains a magic number: if (expr.Match (ILCode.Newobj' out r' out args) && r.DeclaringType.Namespace == "System" && r.DeclaringType.Name == "Decimal") {  	if (args.Count == 1) {  		int val;  		if (args [0].Match (ILCode.Ldc_I4' out val)) {  			expr.Code = ILCode.Ldc_Decimal;  			expr.Operand = new decimal (val);  			expr.InferredType = r.DeclaringType;  			expr.Arguments.Clear ();  			return true;  		}  	} else if (args.Count == 5) {  		int lo' mid' hi' isNegative' scale;  		if (expr.Arguments [0].Match (ILCode.Ldc_I4' out lo) && expr.Arguments [1].Match (ILCode.Ldc_I4' out mid) && expr.Arguments [2].Match (ILCode.Ldc_I4' out hi) && expr.Arguments [3].Match (ILCode.Ldc_I4' out isNegative) && expr.Arguments [4].Match (ILCode.Ldc_I4' out scale)) {  			expr.Code = ILCode.Ldc_Decimal;  			expr.Operand = new decimal (lo' mid' hi' isNegative != 0' (byte)scale);  			expr.InferredType = r.DeclaringType;  			expr.Arguments.Clear ();  			return true;  		}  	}  }  
Magic Number,Custom.Decompiler.ILAst,ILAstOptimizer,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,TransformDecimalCtorToConstant,The following statement contains a magic number: if (expr.Match (ILCode.Newobj' out r' out args) && r.DeclaringType.Namespace == "System" && r.DeclaringType.Name == "Decimal") {  	if (args.Count == 1) {  		int val;  		if (args [0].Match (ILCode.Ldc_I4' out val)) {  			expr.Code = ILCode.Ldc_Decimal;  			expr.Operand = new decimal (val);  			expr.InferredType = r.DeclaringType;  			expr.Arguments.Clear ();  			return true;  		}  	} else if (args.Count == 5) {  		int lo' mid' hi' isNegative' scale;  		if (expr.Arguments [0].Match (ILCode.Ldc_I4' out lo) && expr.Arguments [1].Match (ILCode.Ldc_I4' out mid) && expr.Arguments [2].Match (ILCode.Ldc_I4' out hi) && expr.Arguments [3].Match (ILCode.Ldc_I4' out isNegative) && expr.Arguments [4].Match (ILCode.Ldc_I4' out scale)) {  			expr.Code = ILCode.Ldc_Decimal;  			expr.Operand = new decimal (lo' mid' hi' isNegative != 0' (byte)scale);  			expr.InferredType = r.DeclaringType;  			expr.Arguments.Clear ();  			return true;  		}  	}  }  
Magic Number,Custom.Decompiler.ILAst,ILAstOptimizer,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,TransformDecimalCtorToConstant,The following statement contains a magic number: if (expr.Match (ILCode.Newobj' out r' out args) && r.DeclaringType.Namespace == "System" && r.DeclaringType.Name == "Decimal") {  	if (args.Count == 1) {  		int val;  		if (args [0].Match (ILCode.Ldc_I4' out val)) {  			expr.Code = ILCode.Ldc_Decimal;  			expr.Operand = new decimal (val);  			expr.InferredType = r.DeclaringType;  			expr.Arguments.Clear ();  			return true;  		}  	} else if (args.Count == 5) {  		int lo' mid' hi' isNegative' scale;  		if (expr.Arguments [0].Match (ILCode.Ldc_I4' out lo) && expr.Arguments [1].Match (ILCode.Ldc_I4' out mid) && expr.Arguments [2].Match (ILCode.Ldc_I4' out hi) && expr.Arguments [3].Match (ILCode.Ldc_I4' out isNegative) && expr.Arguments [4].Match (ILCode.Ldc_I4' out scale)) {  			expr.Code = ILCode.Ldc_Decimal;  			expr.Operand = new decimal (lo' mid' hi' isNegative != 0' (byte)scale);  			expr.InferredType = r.DeclaringType;  			expr.Arguments.Clear ();  			return true;  		}  	}  }  
Magic Number,Custom.Decompiler.ILAst,ILAstOptimizer,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,TransformDecimalCtorToConstant,The following statement contains a magic number: if (args.Count == 1) {  	int val;  	if (args [0].Match (ILCode.Ldc_I4' out val)) {  		expr.Code = ILCode.Ldc_Decimal;  		expr.Operand = new decimal (val);  		expr.InferredType = r.DeclaringType;  		expr.Arguments.Clear ();  		return true;  	}  } else if (args.Count == 5) {  	int lo' mid' hi' isNegative' scale;  	if (expr.Arguments [0].Match (ILCode.Ldc_I4' out lo) && expr.Arguments [1].Match (ILCode.Ldc_I4' out mid) && expr.Arguments [2].Match (ILCode.Ldc_I4' out hi) && expr.Arguments [3].Match (ILCode.Ldc_I4' out isNegative) && expr.Arguments [4].Match (ILCode.Ldc_I4' out scale)) {  		expr.Code = ILCode.Ldc_Decimal;  		expr.Operand = new decimal (lo' mid' hi' isNegative != 0' (byte)scale);  		expr.InferredType = r.DeclaringType;  		expr.Arguments.Clear ();  		return true;  	}  }  
Magic Number,Custom.Decompiler.ILAst,ILAstOptimizer,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,TransformDecimalCtorToConstant,The following statement contains a magic number: if (args.Count == 1) {  	int val;  	if (args [0].Match (ILCode.Ldc_I4' out val)) {  		expr.Code = ILCode.Ldc_Decimal;  		expr.Operand = new decimal (val);  		expr.InferredType = r.DeclaringType;  		expr.Arguments.Clear ();  		return true;  	}  } else if (args.Count == 5) {  	int lo' mid' hi' isNegative' scale;  	if (expr.Arguments [0].Match (ILCode.Ldc_I4' out lo) && expr.Arguments [1].Match (ILCode.Ldc_I4' out mid) && expr.Arguments [2].Match (ILCode.Ldc_I4' out hi) && expr.Arguments [3].Match (ILCode.Ldc_I4' out isNegative) && expr.Arguments [4].Match (ILCode.Ldc_I4' out scale)) {  		expr.Code = ILCode.Ldc_Decimal;  		expr.Operand = new decimal (lo' mid' hi' isNegative != 0' (byte)scale);  		expr.InferredType = r.DeclaringType;  		expr.Arguments.Clear ();  		return true;  	}  }  
Magic Number,Custom.Decompiler.ILAst,ILAstOptimizer,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,TransformDecimalCtorToConstant,The following statement contains a magic number: if (args.Count == 1) {  	int val;  	if (args [0].Match (ILCode.Ldc_I4' out val)) {  		expr.Code = ILCode.Ldc_Decimal;  		expr.Operand = new decimal (val);  		expr.InferredType = r.DeclaringType;  		expr.Arguments.Clear ();  		return true;  	}  } else if (args.Count == 5) {  	int lo' mid' hi' isNegative' scale;  	if (expr.Arguments [0].Match (ILCode.Ldc_I4' out lo) && expr.Arguments [1].Match (ILCode.Ldc_I4' out mid) && expr.Arguments [2].Match (ILCode.Ldc_I4' out hi) && expr.Arguments [3].Match (ILCode.Ldc_I4' out isNegative) && expr.Arguments [4].Match (ILCode.Ldc_I4' out scale)) {  		expr.Code = ILCode.Ldc_Decimal;  		expr.Operand = new decimal (lo' mid' hi' isNegative != 0' (byte)scale);  		expr.InferredType = r.DeclaringType;  		expr.Arguments.Clear ();  		return true;  	}  }  
Magic Number,Custom.Decompiler.ILAst,ILAstOptimizer,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,TransformDecimalCtorToConstant,The following statement contains a magic number: if (args.Count == 1) {  	int val;  	if (args [0].Match (ILCode.Ldc_I4' out val)) {  		expr.Code = ILCode.Ldc_Decimal;  		expr.Operand = new decimal (val);  		expr.InferredType = r.DeclaringType;  		expr.Arguments.Clear ();  		return true;  	}  } else if (args.Count == 5) {  	int lo' mid' hi' isNegative' scale;  	if (expr.Arguments [0].Match (ILCode.Ldc_I4' out lo) && expr.Arguments [1].Match (ILCode.Ldc_I4' out mid) && expr.Arguments [2].Match (ILCode.Ldc_I4' out hi) && expr.Arguments [3].Match (ILCode.Ldc_I4' out isNegative) && expr.Arguments [4].Match (ILCode.Ldc_I4' out scale)) {  		expr.Code = ILCode.Ldc_Decimal;  		expr.Operand = new decimal (lo' mid' hi' isNegative != 0' (byte)scale);  		expr.InferredType = r.DeclaringType;  		expr.Arguments.Clear ();  		return true;  	}  }  
Magic Number,Custom.Decompiler.ILAst,ILAstOptimizer,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,TransformDecimalCtorToConstant,The following statement contains a magic number: if (args.Count == 5) {  	int lo' mid' hi' isNegative' scale;  	if (expr.Arguments [0].Match (ILCode.Ldc_I4' out lo) && expr.Arguments [1].Match (ILCode.Ldc_I4' out mid) && expr.Arguments [2].Match (ILCode.Ldc_I4' out hi) && expr.Arguments [3].Match (ILCode.Ldc_I4' out isNegative) && expr.Arguments [4].Match (ILCode.Ldc_I4' out scale)) {  		expr.Code = ILCode.Ldc_Decimal;  		expr.Operand = new decimal (lo' mid' hi' isNegative != 0' (byte)scale);  		expr.InferredType = r.DeclaringType;  		expr.Arguments.Clear ();  		return true;  	}  }  
Magic Number,Custom.Decompiler.ILAst,ILAstOptimizer,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,TransformDecimalCtorToConstant,The following statement contains a magic number: if (args.Count == 5) {  	int lo' mid' hi' isNegative' scale;  	if (expr.Arguments [0].Match (ILCode.Ldc_I4' out lo) && expr.Arguments [1].Match (ILCode.Ldc_I4' out mid) && expr.Arguments [2].Match (ILCode.Ldc_I4' out hi) && expr.Arguments [3].Match (ILCode.Ldc_I4' out isNegative) && expr.Arguments [4].Match (ILCode.Ldc_I4' out scale)) {  		expr.Code = ILCode.Ldc_Decimal;  		expr.Operand = new decimal (lo' mid' hi' isNegative != 0' (byte)scale);  		expr.InferredType = r.DeclaringType;  		expr.Arguments.Clear ();  		return true;  	}  }  
Magic Number,Custom.Decompiler.ILAst,ILAstOptimizer,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,TransformDecimalCtorToConstant,The following statement contains a magic number: if (args.Count == 5) {  	int lo' mid' hi' isNegative' scale;  	if (expr.Arguments [0].Match (ILCode.Ldc_I4' out lo) && expr.Arguments [1].Match (ILCode.Ldc_I4' out mid) && expr.Arguments [2].Match (ILCode.Ldc_I4' out hi) && expr.Arguments [3].Match (ILCode.Ldc_I4' out isNegative) && expr.Arguments [4].Match (ILCode.Ldc_I4' out scale)) {  		expr.Code = ILCode.Ldc_Decimal;  		expr.Operand = new decimal (lo' mid' hi' isNegative != 0' (byte)scale);  		expr.InferredType = r.DeclaringType;  		expr.Arguments.Clear ();  		return true;  	}  }  
Magic Number,Custom.Decompiler.ILAst,ILAstOptimizer,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,TransformDecimalCtorToConstant,The following statement contains a magic number: if (args.Count == 5) {  	int lo' mid' hi' isNegative' scale;  	if (expr.Arguments [0].Match (ILCode.Ldc_I4' out lo) && expr.Arguments [1].Match (ILCode.Ldc_I4' out mid) && expr.Arguments [2].Match (ILCode.Ldc_I4' out hi) && expr.Arguments [3].Match (ILCode.Ldc_I4' out isNegative) && expr.Arguments [4].Match (ILCode.Ldc_I4' out scale)) {  		expr.Code = ILCode.Ldc_Decimal;  		expr.Operand = new decimal (lo' mid' hi' isNegative != 0' (byte)scale);  		expr.InferredType = r.DeclaringType;  		expr.Arguments.Clear ();  		return true;  	}  }  
Magic Number,Custom.Decompiler.ILAst,ILAstOptimizer,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,TransformDecimalCtorToConstant,The following statement contains a magic number: if (expr.Arguments [0].Match (ILCode.Ldc_I4' out lo) && expr.Arguments [1].Match (ILCode.Ldc_I4' out mid) && expr.Arguments [2].Match (ILCode.Ldc_I4' out hi) && expr.Arguments [3].Match (ILCode.Ldc_I4' out isNegative) && expr.Arguments [4].Match (ILCode.Ldc_I4' out scale)) {  	expr.Code = ILCode.Ldc_Decimal;  	expr.Operand = new decimal (lo' mid' hi' isNegative != 0' (byte)scale);  	expr.InferredType = r.DeclaringType;  	expr.Arguments.Clear ();  	return true;  }  
Magic Number,Custom.Decompiler.ILAst,ILAstOptimizer,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,TransformDecimalCtorToConstant,The following statement contains a magic number: if (expr.Arguments [0].Match (ILCode.Ldc_I4' out lo) && expr.Arguments [1].Match (ILCode.Ldc_I4' out mid) && expr.Arguments [2].Match (ILCode.Ldc_I4' out hi) && expr.Arguments [3].Match (ILCode.Ldc_I4' out isNegative) && expr.Arguments [4].Match (ILCode.Ldc_I4' out scale)) {  	expr.Code = ILCode.Ldc_Decimal;  	expr.Operand = new decimal (lo' mid' hi' isNegative != 0' (byte)scale);  	expr.InferredType = r.DeclaringType;  	expr.Arguments.Clear ();  	return true;  }  
Magic Number,Custom.Decompiler.ILAst,ILAstOptimizer,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,TransformDecimalCtorToConstant,The following statement contains a magic number: if (expr.Arguments [0].Match (ILCode.Ldc_I4' out lo) && expr.Arguments [1].Match (ILCode.Ldc_I4' out mid) && expr.Arguments [2].Match (ILCode.Ldc_I4' out hi) && expr.Arguments [3].Match (ILCode.Ldc_I4' out isNegative) && expr.Arguments [4].Match (ILCode.Ldc_I4' out scale)) {  	expr.Code = ILCode.Ldc_Decimal;  	expr.Operand = new decimal (lo' mid' hi' isNegative != 0' (byte)scale);  	expr.InferredType = r.DeclaringType;  	expr.Arguments.Clear ();  	return true;  }  
Magic Number,Custom.Decompiler.ILAst,ILAstOptimizer,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,CachedDelegateInitializationWithField,The following statement contains a magic number: if (!(newObj.Code == ILCode.Newobj && newObj.Arguments.Count == 2))  	return;  
Magic Number,Custom.Decompiler.ILAst,ILAstOptimizer,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,CachedDelegateInitializationWithLocal,The following statement contains a magic number: if (!(newObj.Code == ILCode.Newobj && newObj.Arguments.Count == 2))  	return;  
Magic Number,Custom.Decompiler.ILAst,ILAstOptimizer,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,CachedDelegateInitializationWithLocal,The following statement contains a magic number: if (followingNode != null && followingNode.GetSelfAndChildrenRecursive<ILExpression> ().Count (e => e.Code == ILCode.Ldloc && (ILVariable)e.Operand == v) == 1) {  	ILInlining inlining = new ILInlining (method);  	if (!(inlining.numLdloc.GetOrDefault (v) == 2 && inlining.numStloc.GetOrDefault (v) == 2 && inlining.numLdloca.GetOrDefault (v) == 0))  		return;  	// Find the store instruction that initializes the local to null:  	foreach (ILBlock storeBlock in method.GetSelfAndChildrenRecursive<ILBlock> ()) {  		for (int j = 0; j < storeBlock.Body.Count; j++) {  			ILVariable storedVar;  			ILExpression storedExpr;  			if (storeBlock.Body [j].Match (ILCode.Stloc' out storedVar' out storedExpr) && storedVar == v && storedExpr.Match (ILCode.Ldnull)) {  				// Remove the instruction  				storeBlock.Body.RemoveAt (j);  				if (storeBlock == block && j < i)  					i--;  				break;  			}  		}  	}  	block.Body [i] = stloc;  	// remove the 'if (v==null)'  	inlining = new ILInlining (method);  	inlining.InlineIfPossible (block.Body' ref i);  }  
Magic Number,Custom.Decompiler.ILAst,ILAstOptimizer,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,CachedDelegateInitializationWithLocal,The following statement contains a magic number: if (followingNode != null && followingNode.GetSelfAndChildrenRecursive<ILExpression> ().Count (e => e.Code == ILCode.Ldloc && (ILVariable)e.Operand == v) == 1) {  	ILInlining inlining = new ILInlining (method);  	if (!(inlining.numLdloc.GetOrDefault (v) == 2 && inlining.numStloc.GetOrDefault (v) == 2 && inlining.numLdloca.GetOrDefault (v) == 0))  		return;  	// Find the store instruction that initializes the local to null:  	foreach (ILBlock storeBlock in method.GetSelfAndChildrenRecursive<ILBlock> ()) {  		for (int j = 0; j < storeBlock.Body.Count; j++) {  			ILVariable storedVar;  			ILExpression storedExpr;  			if (storeBlock.Body [j].Match (ILCode.Stloc' out storedVar' out storedExpr) && storedVar == v && storedExpr.Match (ILCode.Ldnull)) {  				// Remove the instruction  				storeBlock.Body.RemoveAt (j);  				if (storeBlock == block && j < i)  					i--;  				break;  			}  		}  	}  	block.Body [i] = stloc;  	// remove the 'if (v==null)'  	inlining = new ILInlining (method);  	inlining.InlineIfPossible (block.Body' ref i);  }  
Magic Number,Custom.Decompiler.ILAst,ILAstOptimizer,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,CachedDelegateInitializationWithLocal,The following statement contains a magic number: if (!(inlining.numLdloc.GetOrDefault (v) == 2 && inlining.numStloc.GetOrDefault (v) == 2 && inlining.numLdloca.GetOrDefault (v) == 0))  	return;  
Magic Number,Custom.Decompiler.ILAst,ILAstOptimizer,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,CachedDelegateInitializationWithLocal,The following statement contains a magic number: if (!(inlining.numLdloc.GetOrDefault (v) == 2 && inlining.numStloc.GetOrDefault (v) == 2 && inlining.numLdloca.GetOrDefault (v) == 0))  	return;  
Magic Number,Custom.Decompiler.ILAst,ILAstOptimizer,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,MakeAssignmentExpression,The following statement contains a magic number: if (nextExpr.Match (ILCode.Stloc' out v' out stLocArg) && stLocArg.MatchLdloc (exprVar)) {  	ILExpression store2 = body.ElementAtOrDefault (pos + 2) as ILExpression;  	if (StoreCanBeConvertedToAssignment (store2' exprVar)) {  		// expr_44 = ...  		// stloc(v1' expr_44)  		// anystore(v2' expr_44)  		// ->  		// stloc(v1' anystore(v2' ...))  		ILInlining inlining = new ILInlining (method);  		if (inlining.numLdloc.GetOrDefault (exprVar) == 2 && inlining.numStloc.GetOrDefault (exprVar) == 1) {  			body.RemoveAt (pos + 2);  			// remove store2  			body.RemoveAt (pos);  			// remove expr = ...  			nextExpr.Arguments [0] = store2;  			store2.Arguments [store2.Arguments.Count - 1] = initializer;  			inlining.InlineIfPossible (body' ref pos);  			return true;  		}  	}  	body.RemoveAt (pos + 1);  	// remove stloc  	nextExpr.Arguments [0] = initializer;  	((ILExpression)body [pos]).Arguments [0] = nextExpr;  	return true;  } else if ((nextExpr.Code == ILCode.Stsfld || nextExpr.Code == ILCode.CallSetter || nextExpr.Code == ILCode.CallvirtSetter) && nextExpr.Arguments.Count == 1) {  	// exprVar = ...  	// stsfld(fld' exprVar)  	// ->  	// exprVar = stsfld(fld' ...))  	if (nextExpr.Arguments [0].MatchLdloc (exprVar)) {  		body.RemoveAt (pos + 1);  		// remove stsfld  		nextExpr.Arguments [0] = initializer;  		((ILExpression)body [pos]).Arguments [0] = nextExpr;  		return true;  	}  }  
Magic Number,Custom.Decompiler.ILAst,ILAstOptimizer,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,MakeAssignmentExpression,The following statement contains a magic number: if (nextExpr.Match (ILCode.Stloc' out v' out stLocArg) && stLocArg.MatchLdloc (exprVar)) {  	ILExpression store2 = body.ElementAtOrDefault (pos + 2) as ILExpression;  	if (StoreCanBeConvertedToAssignment (store2' exprVar)) {  		// expr_44 = ...  		// stloc(v1' expr_44)  		// anystore(v2' expr_44)  		// ->  		// stloc(v1' anystore(v2' ...))  		ILInlining inlining = new ILInlining (method);  		if (inlining.numLdloc.GetOrDefault (exprVar) == 2 && inlining.numStloc.GetOrDefault (exprVar) == 1) {  			body.RemoveAt (pos + 2);  			// remove store2  			body.RemoveAt (pos);  			// remove expr = ...  			nextExpr.Arguments [0] = store2;  			store2.Arguments [store2.Arguments.Count - 1] = initializer;  			inlining.InlineIfPossible (body' ref pos);  			return true;  		}  	}  	body.RemoveAt (pos + 1);  	// remove stloc  	nextExpr.Arguments [0] = initializer;  	((ILExpression)body [pos]).Arguments [0] = nextExpr;  	return true;  } else if ((nextExpr.Code == ILCode.Stsfld || nextExpr.Code == ILCode.CallSetter || nextExpr.Code == ILCode.CallvirtSetter) && nextExpr.Arguments.Count == 1) {  	// exprVar = ...  	// stsfld(fld' exprVar)  	// ->  	// exprVar = stsfld(fld' ...))  	if (nextExpr.Arguments [0].MatchLdloc (exprVar)) {  		body.RemoveAt (pos + 1);  		// remove stsfld  		nextExpr.Arguments [0] = initializer;  		((ILExpression)body [pos]).Arguments [0] = nextExpr;  		return true;  	}  }  
Magic Number,Custom.Decompiler.ILAst,ILAstOptimizer,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,MakeAssignmentExpression,The following statement contains a magic number: if (nextExpr.Match (ILCode.Stloc' out v' out stLocArg) && stLocArg.MatchLdloc (exprVar)) {  	ILExpression store2 = body.ElementAtOrDefault (pos + 2) as ILExpression;  	if (StoreCanBeConvertedToAssignment (store2' exprVar)) {  		// expr_44 = ...  		// stloc(v1' expr_44)  		// anystore(v2' expr_44)  		// ->  		// stloc(v1' anystore(v2' ...))  		ILInlining inlining = new ILInlining (method);  		if (inlining.numLdloc.GetOrDefault (exprVar) == 2 && inlining.numStloc.GetOrDefault (exprVar) == 1) {  			body.RemoveAt (pos + 2);  			// remove store2  			body.RemoveAt (pos);  			// remove expr = ...  			nextExpr.Arguments [0] = store2;  			store2.Arguments [store2.Arguments.Count - 1] = initializer;  			inlining.InlineIfPossible (body' ref pos);  			return true;  		}  	}  	body.RemoveAt (pos + 1);  	// remove stloc  	nextExpr.Arguments [0] = initializer;  	((ILExpression)body [pos]).Arguments [0] = nextExpr;  	return true;  } else if ((nextExpr.Code == ILCode.Stsfld || nextExpr.Code == ILCode.CallSetter || nextExpr.Code == ILCode.CallvirtSetter) && nextExpr.Arguments.Count == 1) {  	// exprVar = ...  	// stsfld(fld' exprVar)  	// ->  	// exprVar = stsfld(fld' ...))  	if (nextExpr.Arguments [0].MatchLdloc (exprVar)) {  		body.RemoveAt (pos + 1);  		// remove stsfld  		nextExpr.Arguments [0] = initializer;  		((ILExpression)body [pos]).Arguments [0] = nextExpr;  		return true;  	}  }  
Magic Number,Custom.Decompiler.ILAst,ILAstOptimizer,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,MakeAssignmentExpression,The following statement contains a magic number: if (StoreCanBeConvertedToAssignment (store2' exprVar)) {  	// expr_44 = ...  	// stloc(v1' expr_44)  	// anystore(v2' expr_44)  	// ->  	// stloc(v1' anystore(v2' ...))  	ILInlining inlining = new ILInlining (method);  	if (inlining.numLdloc.GetOrDefault (exprVar) == 2 && inlining.numStloc.GetOrDefault (exprVar) == 1) {  		body.RemoveAt (pos + 2);  		// remove store2  		body.RemoveAt (pos);  		// remove expr = ...  		nextExpr.Arguments [0] = store2;  		store2.Arguments [store2.Arguments.Count - 1] = initializer;  		inlining.InlineIfPossible (body' ref pos);  		return true;  	}  }  
Magic Number,Custom.Decompiler.ILAst,ILAstOptimizer,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,MakeAssignmentExpression,The following statement contains a magic number: if (StoreCanBeConvertedToAssignment (store2' exprVar)) {  	// expr_44 = ...  	// stloc(v1' expr_44)  	// anystore(v2' expr_44)  	// ->  	// stloc(v1' anystore(v2' ...))  	ILInlining inlining = new ILInlining (method);  	if (inlining.numLdloc.GetOrDefault (exprVar) == 2 && inlining.numStloc.GetOrDefault (exprVar) == 1) {  		body.RemoveAt (pos + 2);  		// remove store2  		body.RemoveAt (pos);  		// remove expr = ...  		nextExpr.Arguments [0] = store2;  		store2.Arguments [store2.Arguments.Count - 1] = initializer;  		inlining.InlineIfPossible (body' ref pos);  		return true;  	}  }  
Magic Number,Custom.Decompiler.ILAst,ILAstOptimizer,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,MakeAssignmentExpression,The following statement contains a magic number: if (inlining.numLdloc.GetOrDefault (exprVar) == 2 && inlining.numStloc.GetOrDefault (exprVar) == 1) {  	body.RemoveAt (pos + 2);  	// remove store2  	body.RemoveAt (pos);  	// remove expr = ...  	nextExpr.Arguments [0] = store2;  	store2.Arguments [store2.Arguments.Count - 1] = initializer;  	inlining.InlineIfPossible (body' ref pos);  	return true;  }  
Magic Number,Custom.Decompiler.ILAst,ILAstOptimizer,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,MakeAssignmentExpression,The following statement contains a magic number: if (inlining.numLdloc.GetOrDefault (exprVar) == 2 && inlining.numStloc.GetOrDefault (exprVar) == 1) {  	body.RemoveAt (pos + 2);  	// remove store2  	body.RemoveAt (pos);  	// remove expr = ...  	nextExpr.Arguments [0] = store2;  	store2.Arguments [store2.Arguments.Count - 1] = initializer;  	inlining.InlineIfPossible (body' ref pos);  	return true;  }  
Magic Number,Custom.Decompiler.ILAst,ILAstOptimizer,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,MakeAssignmentExpression,The following statement contains a magic number: body.RemoveAt (pos + 2);  
Magic Number,Custom.Decompiler.ILAst,ILAstOptimizer,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,CanBeRepresentedAsCompoundAssignment,The following statement contains a magic number: switch (expr.Code) {  case ILCode.Add:  case ILCode.Add_Ovf:  case ILCode.Add_Ovf_Un:  case ILCode.Sub:  case ILCode.Sub_Ovf:  case ILCode.Sub_Ovf_Un:  case ILCode.Mul:  case ILCode.Mul_Ovf:  case ILCode.Mul_Ovf_Un:  case ILCode.Div:  case ILCode.Div_Un:  case ILCode.Rem:  case ILCode.Rem_Un:  case ILCode.And:  case ILCode.Or:  case ILCode.Xor:  case ILCode.Shl:  case ILCode.Shr:  case ILCode.Shr_Un:  	return true;  case ILCode.Call:  	var m = expr.Operand as MethodReference;  	if (m == null || m.HasThis || expr.Arguments.Count != 2)  		return false;  	switch (m.Name) {  	case "op_Addition":  	case "op_Subtraction":  	case "op_Multiply":  	case "op_Division":  	case "op_Modulus":  	case "op_BitwiseAnd":  	case "op_BitwiseOr":  	case "op_ExclusiveOr":  	case "op_LeftShift":  	case "op_RightShift":  		return true;  	default:  		return false;  	}  default:  	return false;  }  
Magic Number,Custom.Decompiler.ILAst,ILAstOptimizer,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,CanBeRepresentedAsCompoundAssignment,The following statement contains a magic number: if (m == null || m.HasThis || expr.Arguments.Count != 2)  	return false;  
Magic Number,Custom.Decompiler.ILAst,ILAstOptimizer,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,MatchFixedInitializer,The following statement contains a magic number: if (ifStmt != null && MatchFixedArrayInitializerCondition (ifStmt.Condition' out arrayLoadingExpr)) {  	ILVariable arrayVariable = (ILVariable)arrayLoadingExpr.Operand;  	ILExpression trueValue;  	if (ifStmt.TrueBlock != null && ifStmt.TrueBlock.Body.Count == 1 && ifStmt.TrueBlock.Body [0].Match (ILCode.Stloc' out pinnedVar' out trueValue) && pinnedVar.IsPinned && IsNullOrZero (trueValue)) {  		if (ifStmt.FalseBlock != null && ifStmt.FalseBlock.Body.Count == 1 && ifStmt.FalseBlock.Body [0] is ILFixedStatement) {  			ILFixedStatement fixedStmt = (ILFixedStatement)ifStmt.FalseBlock.Body [0];  			ILVariable stlocVar;  			ILExpression falseValue;  			if (fixedStmt.Initializers.Count == 1 && fixedStmt.BodyBlock.Body.Count == 0 && fixedStmt.Initializers [0].Match (ILCode.Stloc' out stlocVar' out falseValue) && stlocVar == pinnedVar) {  				ILVariable loadedVariable;  				if (falseValue.Code == ILCode.Ldelema && falseValue.Arguments [0].Match (ILCode.Ldloc' out loadedVariable) && loadedVariable == arrayVariable && IsNullOrZero (falseValue.Arguments [1])) {  					// OK' we detected the pattern for fixing an array.  					// Now check whether the loading expression was a store ot a temp. var  					// that can be eliminated.  					if (arrayLoadingExpr.Code == ILCode.Stloc) {  						ILInlining inlining = new ILInlining (method);  						if (inlining.numLdloc.GetOrDefault (arrayVariable) == 2 && inlining.numStloc.GetOrDefault (arrayVariable) == 1 && inlining.numLdloca.GetOrDefault (arrayVariable) == 0) {  							arrayLoadingExpr = arrayLoadingExpr.Arguments [0];  						}  					}  					initValue = new ILExpression (ILCode.Stloc' pinnedVar' arrayLoadingExpr);  					nextPos = i + 1;  					return true;  				}  			}  		}  	}  }  
Magic Number,Custom.Decompiler.ILAst,ILAstOptimizer,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,MatchFixedInitializer,The following statement contains a magic number: if (ifStmt.TrueBlock != null && ifStmt.TrueBlock.Body.Count == 1 && ifStmt.TrueBlock.Body [0].Match (ILCode.Stloc' out pinnedVar' out trueValue) && pinnedVar.IsPinned && IsNullOrZero (trueValue)) {  	if (ifStmt.FalseBlock != null && ifStmt.FalseBlock.Body.Count == 1 && ifStmt.FalseBlock.Body [0] is ILFixedStatement) {  		ILFixedStatement fixedStmt = (ILFixedStatement)ifStmt.FalseBlock.Body [0];  		ILVariable stlocVar;  		ILExpression falseValue;  		if (fixedStmt.Initializers.Count == 1 && fixedStmt.BodyBlock.Body.Count == 0 && fixedStmt.Initializers [0].Match (ILCode.Stloc' out stlocVar' out falseValue) && stlocVar == pinnedVar) {  			ILVariable loadedVariable;  			if (falseValue.Code == ILCode.Ldelema && falseValue.Arguments [0].Match (ILCode.Ldloc' out loadedVariable) && loadedVariable == arrayVariable && IsNullOrZero (falseValue.Arguments [1])) {  				// OK' we detected the pattern for fixing an array.  				// Now check whether the loading expression was a store ot a temp. var  				// that can be eliminated.  				if (arrayLoadingExpr.Code == ILCode.Stloc) {  					ILInlining inlining = new ILInlining (method);  					if (inlining.numLdloc.GetOrDefault (arrayVariable) == 2 && inlining.numStloc.GetOrDefault (arrayVariable) == 1 && inlining.numLdloca.GetOrDefault (arrayVariable) == 0) {  						arrayLoadingExpr = arrayLoadingExpr.Arguments [0];  					}  				}  				initValue = new ILExpression (ILCode.Stloc' pinnedVar' arrayLoadingExpr);  				nextPos = i + 1;  				return true;  			}  		}  	}  }  
Magic Number,Custom.Decompiler.ILAst,ILAstOptimizer,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,MatchFixedInitializer,The following statement contains a magic number: if (ifStmt.FalseBlock != null && ifStmt.FalseBlock.Body.Count == 1 && ifStmt.FalseBlock.Body [0] is ILFixedStatement) {  	ILFixedStatement fixedStmt = (ILFixedStatement)ifStmt.FalseBlock.Body [0];  	ILVariable stlocVar;  	ILExpression falseValue;  	if (fixedStmt.Initializers.Count == 1 && fixedStmt.BodyBlock.Body.Count == 0 && fixedStmt.Initializers [0].Match (ILCode.Stloc' out stlocVar' out falseValue) && stlocVar == pinnedVar) {  		ILVariable loadedVariable;  		if (falseValue.Code == ILCode.Ldelema && falseValue.Arguments [0].Match (ILCode.Ldloc' out loadedVariable) && loadedVariable == arrayVariable && IsNullOrZero (falseValue.Arguments [1])) {  			// OK' we detected the pattern for fixing an array.  			// Now check whether the loading expression was a store ot a temp. var  			// that can be eliminated.  			if (arrayLoadingExpr.Code == ILCode.Stloc) {  				ILInlining inlining = new ILInlining (method);  				if (inlining.numLdloc.GetOrDefault (arrayVariable) == 2 && inlining.numStloc.GetOrDefault (arrayVariable) == 1 && inlining.numLdloca.GetOrDefault (arrayVariable) == 0) {  					arrayLoadingExpr = arrayLoadingExpr.Arguments [0];  				}  			}  			initValue = new ILExpression (ILCode.Stloc' pinnedVar' arrayLoadingExpr);  			nextPos = i + 1;  			return true;  		}  	}  }  
Magic Number,Custom.Decompiler.ILAst,ILAstOptimizer,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,MatchFixedInitializer,The following statement contains a magic number: if (fixedStmt.Initializers.Count == 1 && fixedStmt.BodyBlock.Body.Count == 0 && fixedStmt.Initializers [0].Match (ILCode.Stloc' out stlocVar' out falseValue) && stlocVar == pinnedVar) {  	ILVariable loadedVariable;  	if (falseValue.Code == ILCode.Ldelema && falseValue.Arguments [0].Match (ILCode.Ldloc' out loadedVariable) && loadedVariable == arrayVariable && IsNullOrZero (falseValue.Arguments [1])) {  		// OK' we detected the pattern for fixing an array.  		// Now check whether the loading expression was a store ot a temp. var  		// that can be eliminated.  		if (arrayLoadingExpr.Code == ILCode.Stloc) {  			ILInlining inlining = new ILInlining (method);  			if (inlining.numLdloc.GetOrDefault (arrayVariable) == 2 && inlining.numStloc.GetOrDefault (arrayVariable) == 1 && inlining.numLdloca.GetOrDefault (arrayVariable) == 0) {  				arrayLoadingExpr = arrayLoadingExpr.Arguments [0];  			}  		}  		initValue = new ILExpression (ILCode.Stloc' pinnedVar' arrayLoadingExpr);  		nextPos = i + 1;  		return true;  	}  }  
Magic Number,Custom.Decompiler.ILAst,ILAstOptimizer,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,MatchFixedInitializer,The following statement contains a magic number: if (falseValue.Code == ILCode.Ldelema && falseValue.Arguments [0].Match (ILCode.Ldloc' out loadedVariable) && loadedVariable == arrayVariable && IsNullOrZero (falseValue.Arguments [1])) {  	// OK' we detected the pattern for fixing an array.  	// Now check whether the loading expression was a store ot a temp. var  	// that can be eliminated.  	if (arrayLoadingExpr.Code == ILCode.Stloc) {  		ILInlining inlining = new ILInlining (method);  		if (inlining.numLdloc.GetOrDefault (arrayVariable) == 2 && inlining.numStloc.GetOrDefault (arrayVariable) == 1 && inlining.numLdloca.GetOrDefault (arrayVariable) == 0) {  			arrayLoadingExpr = arrayLoadingExpr.Arguments [0];  		}  	}  	initValue = new ILExpression (ILCode.Stloc' pinnedVar' arrayLoadingExpr);  	nextPos = i + 1;  	return true;  }  
Magic Number,Custom.Decompiler.ILAst,ILAstOptimizer,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,MatchFixedInitializer,The following statement contains a magic number: if (arrayLoadingExpr.Code == ILCode.Stloc) {  	ILInlining inlining = new ILInlining (method);  	if (inlining.numLdloc.GetOrDefault (arrayVariable) == 2 && inlining.numStloc.GetOrDefault (arrayVariable) == 1 && inlining.numLdloca.GetOrDefault (arrayVariable) == 0) {  		arrayLoadingExpr = arrayLoadingExpr.Arguments [0];  	}  }  
Magic Number,Custom.Decompiler.ILAst,ILAstOptimizer,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,MatchFixedInitializer,The following statement contains a magic number: if (inlining.numLdloc.GetOrDefault (arrayVariable) == 2 && inlining.numStloc.GetOrDefault (arrayVariable) == 1 && inlining.numLdloca.GetOrDefault (arrayVariable) == 0) {  	arrayLoadingExpr = arrayLoadingExpr.Arguments [0];  }  
Magic Number,Custom.Decompiler.ILAst,ILAstOptimizer,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,HandleStringFixing,The following statement contains a magic number: if (body [pos + 2].Match (ILCode.Stloc' out pointerVar' out assignedExpr) && assignedExpr.MatchLdloc (var2)) {  	pos += 3;  	fixedStmtInitializer.Operand = pointerVar;  	return true;  }  
Magic Number,Custom.Decompiler.ILAst,ILAstOptimizer,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,HandleStringFixing,The following statement contains a magic number: if (body [pos + 2].Match (ILCode.Stloc' out pointerVar' out assignedExpr) && assignedExpr.MatchLdloc (var2)) {  	pos += 3;  	fixedStmtInitializer.Operand = pointerVar;  	return true;  }  
Magic Number,Custom.Decompiler.ILAst,ILAstOptimizer,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,HandleStringFixing,The following statement contains a magic number: pos += 3;  
Magic Number,Custom.Decompiler.ILAst,ILAstOptimizer,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,SimplifyShiftOperators,The following statement contains a magic number: switch (expr.InferredType.MetadataType) {  case MetadataType.Int32:  case MetadataType.UInt32:  	mask = 31;  	break;  case MetadataType.Int64:  case MetadataType.UInt64:  	mask = 63;  	break;  default:  	return;  }  
Magic Number,Custom.Decompiler.ILAst,ILAstOptimizer,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,SimplifyShiftOperators,The following statement contains a magic number: switch (expr.InferredType.MetadataType) {  case MetadataType.Int32:  case MetadataType.UInt32:  	mask = 31;  	break;  case MetadataType.Int64:  case MetadataType.UInt64:  	mask = 63;  	break;  default:  	return;  }  
Magic Number,Custom.Decompiler.ILAst,ILAstOptimizer,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,SimplifyShiftOperators,The following statement contains a magic number: mask = 31;  
Magic Number,Custom.Decompiler.ILAst,ILAstOptimizer,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,SimplifyShiftOperators,The following statement contains a magic number: mask = 63;  
Magic Number,Custom.Decompiler.ILAst,ILCodeUtil,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILCodes.cs,ExpandMacro,The following statement contains a magic number: switch (code) {  case ILCode.__Ldarg_0:  	code = ILCode.__Ldarg;  	operand = methodBody.GetParameter (0);  	break;  case ILCode.__Ldarg_1:  	code = ILCode.__Ldarg;  	operand = methodBody.GetParameter (1);  	break;  case ILCode.__Ldarg_2:  	code = ILCode.__Ldarg;  	operand = methodBody.GetParameter (2);  	break;  case ILCode.__Ldarg_3:  	code = ILCode.__Ldarg;  	operand = methodBody.GetParameter (3);  	break;  case ILCode.__Ldloc_0:  	code = ILCode.Ldloc;  	operand = methodBody.Variables [0];  	break;  case ILCode.__Ldloc_1:  	code = ILCode.Ldloc;  	operand = methodBody.Variables [1];  	break;  case ILCode.__Ldloc_2:  	code = ILCode.Ldloc;  	operand = methodBody.Variables [2];  	break;  case ILCode.__Ldloc_3:  	code = ILCode.Ldloc;  	operand = methodBody.Variables [3];  	break;  case ILCode.__Stloc_0:  	code = ILCode.Stloc;  	operand = methodBody.Variables [0];  	break;  case ILCode.__Stloc_1:  	code = ILCode.Stloc;  	operand = methodBody.Variables [1];  	break;  case ILCode.__Stloc_2:  	code = ILCode.Stloc;  	operand = methodBody.Variables [2];  	break;  case ILCode.__Stloc_3:  	code = ILCode.Stloc;  	operand = methodBody.Variables [3];  	break;  case ILCode.__Ldarg_S:  	code = ILCode.__Ldarg;  	break;  case ILCode.__Ldarga_S:  	code = ILCode.__Ldarga;  	break;  case ILCode.__Starg_S:  	code = ILCode.__Starg;  	break;  case ILCode.__Ldloc_S:  	code = ILCode.Ldloc;  	break;  case ILCode.__Ldloca_S:  	code = ILCode.Ldloca;  	break;  case ILCode.__Stloc_S:  	code = ILCode.Stloc;  	break;  case ILCode.__Ldc_I4_M1:  	code = ILCode.Ldc_I4;  	operand = -1;  	break;  case ILCode.__Ldc_I4_0:  	code = ILCode.Ldc_I4;  	operand = 0;  	break;  case ILCode.__Ldc_I4_1:  	code = ILCode.Ldc_I4;  	operand = 1;  	break;  case ILCode.__Ldc_I4_2:  	code = ILCode.Ldc_I4;  	operand = 2;  	break;  case ILCode.__Ldc_I4_3:  	code = ILCode.Ldc_I4;  	operand = 3;  	break;  case ILCode.__Ldc_I4_4:  	code = ILCode.Ldc_I4;  	operand = 4;  	break;  case ILCode.__Ldc_I4_5:  	code = ILCode.Ldc_I4;  	operand = 5;  	break;  case ILCode.__Ldc_I4_6:  	code = ILCode.Ldc_I4;  	operand = 6;  	break;  case ILCode.__Ldc_I4_7:  	code = ILCode.Ldc_I4;  	operand = 7;  	break;  case ILCode.__Ldc_I4_8:  	code = ILCode.Ldc_I4;  	operand = 8;  	break;  case ILCode.__Ldc_I4_S:  	code = ILCode.Ldc_I4;  	operand = (int)(sbyte)operand;  	break;  case ILCode.__Br_S:  	code = ILCode.Br;  	break;  case ILCode.__Brfalse_S:  	code = ILCode.__Brfalse;  	break;  case ILCode.__Brtrue_S:  	code = ILCode.Brtrue;  	break;  case ILCode.__Beq_S:  	code = ILCode.__Beq;  	break;  case ILCode.__Bge_S:  	code = ILCode.__Bge;  	break;  case ILCode.__Bgt_S:  	code = ILCode.__Bgt;  	break;  case ILCode.__Ble_S:  	code = ILCode.__Ble;  	break;  case ILCode.__Blt_S:  	code = ILCode.__Blt;  	break;  case ILCode.__Bne_Un_S:  	code = ILCode.__Bne_Un;  	break;  case ILCode.__Bge_Un_S:  	code = ILCode.__Bge_Un;  	break;  case ILCode.__Bgt_Un_S:  	code = ILCode.__Bgt_Un;  	break;  case ILCode.__Ble_Un_S:  	code = ILCode.__Ble_Un;  	break;  case ILCode.__Blt_Un_S:  	code = ILCode.__Blt_Un;  	break;  case ILCode.__Leave_S:  	code = ILCode.Leave;  	break;  case ILCode.__Ldind_I:  	code = ILCode.Ldobj;  	operand = methodBody.Method.Module.TypeSystem.IntPtr;  	break;  case ILCode.__Ldind_I1:  	code = ILCode.Ldobj;  	operand = methodBody.Method.Module.TypeSystem.SByte;  	break;  case ILCode.__Ldind_I2:  	code = ILCode.Ldobj;  	operand = methodBody.Method.Module.TypeSystem.Int16;  	break;  case ILCode.__Ldind_I4:  	code = ILCode.Ldobj;  	operand = methodBody.Method.Module.TypeSystem.Int32;  	break;  case ILCode.__Ldind_I8:  	code = ILCode.Ldobj;  	operand = methodBody.Method.Module.TypeSystem.Int64;  	break;  case ILCode.__Ldind_U1:  	code = ILCode.Ldobj;  	operand = methodBody.Method.Module.TypeSystem.Byte;  	break;  case ILCode.__Ldind_U2:  	code = ILCode.Ldobj;  	operand = methodBody.Method.Module.TypeSystem.UInt16;  	break;  case ILCode.__Ldind_U4:  	code = ILCode.Ldobj;  	operand = methodBody.Method.Module.TypeSystem.UInt32;  	break;  case ILCode.__Ldind_R4:  	code = ILCode.Ldobj;  	operand = methodBody.Method.Module.TypeSystem.Single;  	break;  case ILCode.__Ldind_R8:  	code = ILCode.Ldobj;  	operand = methodBody.Method.Module.TypeSystem.Double;  	break;  case ILCode.__Stind_I:  	code = ILCode.Stobj;  	operand = methodBody.Method.Module.TypeSystem.IntPtr;  	break;  case ILCode.__Stind_I1:  	code = ILCode.Stobj;  	operand = methodBody.Method.Module.TypeSystem.Byte;  	break;  case ILCode.__Stind_I2:  	code = ILCode.Stobj;  	operand = methodBody.Method.Module.TypeSystem.Int16;  	break;  case ILCode.__Stind_I4:  	code = ILCode.Stobj;  	operand = methodBody.Method.Module.TypeSystem.Int32;  	break;  case ILCode.__Stind_I8:  	code = ILCode.Stobj;  	operand = methodBody.Method.Module.TypeSystem.Int64;  	break;  case ILCode.__Stind_R4:  	code = ILCode.Stobj;  	operand = methodBody.Method.Module.TypeSystem.Single;  	break;  case ILCode.__Stind_R8:  	code = ILCode.Stobj;  	operand = methodBody.Method.Module.TypeSystem.Double;  	break;  }  
Magic Number,Custom.Decompiler.ILAst,ILCodeUtil,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILCodes.cs,ExpandMacro,The following statement contains a magic number: switch (code) {  case ILCode.__Ldarg_0:  	code = ILCode.__Ldarg;  	operand = methodBody.GetParameter (0);  	break;  case ILCode.__Ldarg_1:  	code = ILCode.__Ldarg;  	operand = methodBody.GetParameter (1);  	break;  case ILCode.__Ldarg_2:  	code = ILCode.__Ldarg;  	operand = methodBody.GetParameter (2);  	break;  case ILCode.__Ldarg_3:  	code = ILCode.__Ldarg;  	operand = methodBody.GetParameter (3);  	break;  case ILCode.__Ldloc_0:  	code = ILCode.Ldloc;  	operand = methodBody.Variables [0];  	break;  case ILCode.__Ldloc_1:  	code = ILCode.Ldloc;  	operand = methodBody.Variables [1];  	break;  case ILCode.__Ldloc_2:  	code = ILCode.Ldloc;  	operand = methodBody.Variables [2];  	break;  case ILCode.__Ldloc_3:  	code = ILCode.Ldloc;  	operand = methodBody.Variables [3];  	break;  case ILCode.__Stloc_0:  	code = ILCode.Stloc;  	operand = methodBody.Variables [0];  	break;  case ILCode.__Stloc_1:  	code = ILCode.Stloc;  	operand = methodBody.Variables [1];  	break;  case ILCode.__Stloc_2:  	code = ILCode.Stloc;  	operand = methodBody.Variables [2];  	break;  case ILCode.__Stloc_3:  	code = ILCode.Stloc;  	operand = methodBody.Variables [3];  	break;  case ILCode.__Ldarg_S:  	code = ILCode.__Ldarg;  	break;  case ILCode.__Ldarga_S:  	code = ILCode.__Ldarga;  	break;  case ILCode.__Starg_S:  	code = ILCode.__Starg;  	break;  case ILCode.__Ldloc_S:  	code = ILCode.Ldloc;  	break;  case ILCode.__Ldloca_S:  	code = ILCode.Ldloca;  	break;  case ILCode.__Stloc_S:  	code = ILCode.Stloc;  	break;  case ILCode.__Ldc_I4_M1:  	code = ILCode.Ldc_I4;  	operand = -1;  	break;  case ILCode.__Ldc_I4_0:  	code = ILCode.Ldc_I4;  	operand = 0;  	break;  case ILCode.__Ldc_I4_1:  	code = ILCode.Ldc_I4;  	operand = 1;  	break;  case ILCode.__Ldc_I4_2:  	code = ILCode.Ldc_I4;  	operand = 2;  	break;  case ILCode.__Ldc_I4_3:  	code = ILCode.Ldc_I4;  	operand = 3;  	break;  case ILCode.__Ldc_I4_4:  	code = ILCode.Ldc_I4;  	operand = 4;  	break;  case ILCode.__Ldc_I4_5:  	code = ILCode.Ldc_I4;  	operand = 5;  	break;  case ILCode.__Ldc_I4_6:  	code = ILCode.Ldc_I4;  	operand = 6;  	break;  case ILCode.__Ldc_I4_7:  	code = ILCode.Ldc_I4;  	operand = 7;  	break;  case ILCode.__Ldc_I4_8:  	code = ILCode.Ldc_I4;  	operand = 8;  	break;  case ILCode.__Ldc_I4_S:  	code = ILCode.Ldc_I4;  	operand = (int)(sbyte)operand;  	break;  case ILCode.__Br_S:  	code = ILCode.Br;  	break;  case ILCode.__Brfalse_S:  	code = ILCode.__Brfalse;  	break;  case ILCode.__Brtrue_S:  	code = ILCode.Brtrue;  	break;  case ILCode.__Beq_S:  	code = ILCode.__Beq;  	break;  case ILCode.__Bge_S:  	code = ILCode.__Bge;  	break;  case ILCode.__Bgt_S:  	code = ILCode.__Bgt;  	break;  case ILCode.__Ble_S:  	code = ILCode.__Ble;  	break;  case ILCode.__Blt_S:  	code = ILCode.__Blt;  	break;  case ILCode.__Bne_Un_S:  	code = ILCode.__Bne_Un;  	break;  case ILCode.__Bge_Un_S:  	code = ILCode.__Bge_Un;  	break;  case ILCode.__Bgt_Un_S:  	code = ILCode.__Bgt_Un;  	break;  case ILCode.__Ble_Un_S:  	code = ILCode.__Ble_Un;  	break;  case ILCode.__Blt_Un_S:  	code = ILCode.__Blt_Un;  	break;  case ILCode.__Leave_S:  	code = ILCode.Leave;  	break;  case ILCode.__Ldind_I:  	code = ILCode.Ldobj;  	operand = methodBody.Method.Module.TypeSystem.IntPtr;  	break;  case ILCode.__Ldind_I1:  	code = ILCode.Ldobj;  	operand = methodBody.Method.Module.TypeSystem.SByte;  	break;  case ILCode.__Ldind_I2:  	code = ILCode.Ldobj;  	operand = methodBody.Method.Module.TypeSystem.Int16;  	break;  case ILCode.__Ldind_I4:  	code = ILCode.Ldobj;  	operand = methodBody.Method.Module.TypeSystem.Int32;  	break;  case ILCode.__Ldind_I8:  	code = ILCode.Ldobj;  	operand = methodBody.Method.Module.TypeSystem.Int64;  	break;  case ILCode.__Ldind_U1:  	code = ILCode.Ldobj;  	operand = methodBody.Method.Module.TypeSystem.Byte;  	break;  case ILCode.__Ldind_U2:  	code = ILCode.Ldobj;  	operand = methodBody.Method.Module.TypeSystem.UInt16;  	break;  case ILCode.__Ldind_U4:  	code = ILCode.Ldobj;  	operand = methodBody.Method.Module.TypeSystem.UInt32;  	break;  case ILCode.__Ldind_R4:  	code = ILCode.Ldobj;  	operand = methodBody.Method.Module.TypeSystem.Single;  	break;  case ILCode.__Ldind_R8:  	code = ILCode.Ldobj;  	operand = methodBody.Method.Module.TypeSystem.Double;  	break;  case ILCode.__Stind_I:  	code = ILCode.Stobj;  	operand = methodBody.Method.Module.TypeSystem.IntPtr;  	break;  case ILCode.__Stind_I1:  	code = ILCode.Stobj;  	operand = methodBody.Method.Module.TypeSystem.Byte;  	break;  case ILCode.__Stind_I2:  	code = ILCode.Stobj;  	operand = methodBody.Method.Module.TypeSystem.Int16;  	break;  case ILCode.__Stind_I4:  	code = ILCode.Stobj;  	operand = methodBody.Method.Module.TypeSystem.Int32;  	break;  case ILCode.__Stind_I8:  	code = ILCode.Stobj;  	operand = methodBody.Method.Module.TypeSystem.Int64;  	break;  case ILCode.__Stind_R4:  	code = ILCode.Stobj;  	operand = methodBody.Method.Module.TypeSystem.Single;  	break;  case ILCode.__Stind_R8:  	code = ILCode.Stobj;  	operand = methodBody.Method.Module.TypeSystem.Double;  	break;  }  
Magic Number,Custom.Decompiler.ILAst,ILCodeUtil,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILCodes.cs,ExpandMacro,The following statement contains a magic number: switch (code) {  case ILCode.__Ldarg_0:  	code = ILCode.__Ldarg;  	operand = methodBody.GetParameter (0);  	break;  case ILCode.__Ldarg_1:  	code = ILCode.__Ldarg;  	operand = methodBody.GetParameter (1);  	break;  case ILCode.__Ldarg_2:  	code = ILCode.__Ldarg;  	operand = methodBody.GetParameter (2);  	break;  case ILCode.__Ldarg_3:  	code = ILCode.__Ldarg;  	operand = methodBody.GetParameter (3);  	break;  case ILCode.__Ldloc_0:  	code = ILCode.Ldloc;  	operand = methodBody.Variables [0];  	break;  case ILCode.__Ldloc_1:  	code = ILCode.Ldloc;  	operand = methodBody.Variables [1];  	break;  case ILCode.__Ldloc_2:  	code = ILCode.Ldloc;  	operand = methodBody.Variables [2];  	break;  case ILCode.__Ldloc_3:  	code = ILCode.Ldloc;  	operand = methodBody.Variables [3];  	break;  case ILCode.__Stloc_0:  	code = ILCode.Stloc;  	operand = methodBody.Variables [0];  	break;  case ILCode.__Stloc_1:  	code = ILCode.Stloc;  	operand = methodBody.Variables [1];  	break;  case ILCode.__Stloc_2:  	code = ILCode.Stloc;  	operand = methodBody.Variables [2];  	break;  case ILCode.__Stloc_3:  	code = ILCode.Stloc;  	operand = methodBody.Variables [3];  	break;  case ILCode.__Ldarg_S:  	code = ILCode.__Ldarg;  	break;  case ILCode.__Ldarga_S:  	code = ILCode.__Ldarga;  	break;  case ILCode.__Starg_S:  	code = ILCode.__Starg;  	break;  case ILCode.__Ldloc_S:  	code = ILCode.Ldloc;  	break;  case ILCode.__Ldloca_S:  	code = ILCode.Ldloca;  	break;  case ILCode.__Stloc_S:  	code = ILCode.Stloc;  	break;  case ILCode.__Ldc_I4_M1:  	code = ILCode.Ldc_I4;  	operand = -1;  	break;  case ILCode.__Ldc_I4_0:  	code = ILCode.Ldc_I4;  	operand = 0;  	break;  case ILCode.__Ldc_I4_1:  	code = ILCode.Ldc_I4;  	operand = 1;  	break;  case ILCode.__Ldc_I4_2:  	code = ILCode.Ldc_I4;  	operand = 2;  	break;  case ILCode.__Ldc_I4_3:  	code = ILCode.Ldc_I4;  	operand = 3;  	break;  case ILCode.__Ldc_I4_4:  	code = ILCode.Ldc_I4;  	operand = 4;  	break;  case ILCode.__Ldc_I4_5:  	code = ILCode.Ldc_I4;  	operand = 5;  	break;  case ILCode.__Ldc_I4_6:  	code = ILCode.Ldc_I4;  	operand = 6;  	break;  case ILCode.__Ldc_I4_7:  	code = ILCode.Ldc_I4;  	operand = 7;  	break;  case ILCode.__Ldc_I4_8:  	code = ILCode.Ldc_I4;  	operand = 8;  	break;  case ILCode.__Ldc_I4_S:  	code = ILCode.Ldc_I4;  	operand = (int)(sbyte)operand;  	break;  case ILCode.__Br_S:  	code = ILCode.Br;  	break;  case ILCode.__Brfalse_S:  	code = ILCode.__Brfalse;  	break;  case ILCode.__Brtrue_S:  	code = ILCode.Brtrue;  	break;  case ILCode.__Beq_S:  	code = ILCode.__Beq;  	break;  case ILCode.__Bge_S:  	code = ILCode.__Bge;  	break;  case ILCode.__Bgt_S:  	code = ILCode.__Bgt;  	break;  case ILCode.__Ble_S:  	code = ILCode.__Ble;  	break;  case ILCode.__Blt_S:  	code = ILCode.__Blt;  	break;  case ILCode.__Bne_Un_S:  	code = ILCode.__Bne_Un;  	break;  case ILCode.__Bge_Un_S:  	code = ILCode.__Bge_Un;  	break;  case ILCode.__Bgt_Un_S:  	code = ILCode.__Bgt_Un;  	break;  case ILCode.__Ble_Un_S:  	code = ILCode.__Ble_Un;  	break;  case ILCode.__Blt_Un_S:  	code = ILCode.__Blt_Un;  	break;  case ILCode.__Leave_S:  	code = ILCode.Leave;  	break;  case ILCode.__Ldind_I:  	code = ILCode.Ldobj;  	operand = methodBody.Method.Module.TypeSystem.IntPtr;  	break;  case ILCode.__Ldind_I1:  	code = ILCode.Ldobj;  	operand = methodBody.Method.Module.TypeSystem.SByte;  	break;  case ILCode.__Ldind_I2:  	code = ILCode.Ldobj;  	operand = methodBody.Method.Module.TypeSystem.Int16;  	break;  case ILCode.__Ldind_I4:  	code = ILCode.Ldobj;  	operand = methodBody.Method.Module.TypeSystem.Int32;  	break;  case ILCode.__Ldind_I8:  	code = ILCode.Ldobj;  	operand = methodBody.Method.Module.TypeSystem.Int64;  	break;  case ILCode.__Ldind_U1:  	code = ILCode.Ldobj;  	operand = methodBody.Method.Module.TypeSystem.Byte;  	break;  case ILCode.__Ldind_U2:  	code = ILCode.Ldobj;  	operand = methodBody.Method.Module.TypeSystem.UInt16;  	break;  case ILCode.__Ldind_U4:  	code = ILCode.Ldobj;  	operand = methodBody.Method.Module.TypeSystem.UInt32;  	break;  case ILCode.__Ldind_R4:  	code = ILCode.Ldobj;  	operand = methodBody.Method.Module.TypeSystem.Single;  	break;  case ILCode.__Ldind_R8:  	code = ILCode.Ldobj;  	operand = methodBody.Method.Module.TypeSystem.Double;  	break;  case ILCode.__Stind_I:  	code = ILCode.Stobj;  	operand = methodBody.Method.Module.TypeSystem.IntPtr;  	break;  case ILCode.__Stind_I1:  	code = ILCode.Stobj;  	operand = methodBody.Method.Module.TypeSystem.Byte;  	break;  case ILCode.__Stind_I2:  	code = ILCode.Stobj;  	operand = methodBody.Method.Module.TypeSystem.Int16;  	break;  case ILCode.__Stind_I4:  	code = ILCode.Stobj;  	operand = methodBody.Method.Module.TypeSystem.Int32;  	break;  case ILCode.__Stind_I8:  	code = ILCode.Stobj;  	operand = methodBody.Method.Module.TypeSystem.Int64;  	break;  case ILCode.__Stind_R4:  	code = ILCode.Stobj;  	operand = methodBody.Method.Module.TypeSystem.Single;  	break;  case ILCode.__Stind_R8:  	code = ILCode.Stobj;  	operand = methodBody.Method.Module.TypeSystem.Double;  	break;  }  
Magic Number,Custom.Decompiler.ILAst,ILCodeUtil,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILCodes.cs,ExpandMacro,The following statement contains a magic number: switch (code) {  case ILCode.__Ldarg_0:  	code = ILCode.__Ldarg;  	operand = methodBody.GetParameter (0);  	break;  case ILCode.__Ldarg_1:  	code = ILCode.__Ldarg;  	operand = methodBody.GetParameter (1);  	break;  case ILCode.__Ldarg_2:  	code = ILCode.__Ldarg;  	operand = methodBody.GetParameter (2);  	break;  case ILCode.__Ldarg_3:  	code = ILCode.__Ldarg;  	operand = methodBody.GetParameter (3);  	break;  case ILCode.__Ldloc_0:  	code = ILCode.Ldloc;  	operand = methodBody.Variables [0];  	break;  case ILCode.__Ldloc_1:  	code = ILCode.Ldloc;  	operand = methodBody.Variables [1];  	break;  case ILCode.__Ldloc_2:  	code = ILCode.Ldloc;  	operand = methodBody.Variables [2];  	break;  case ILCode.__Ldloc_3:  	code = ILCode.Ldloc;  	operand = methodBody.Variables [3];  	break;  case ILCode.__Stloc_0:  	code = ILCode.Stloc;  	operand = methodBody.Variables [0];  	break;  case ILCode.__Stloc_1:  	code = ILCode.Stloc;  	operand = methodBody.Variables [1];  	break;  case ILCode.__Stloc_2:  	code = ILCode.Stloc;  	operand = methodBody.Variables [2];  	break;  case ILCode.__Stloc_3:  	code = ILCode.Stloc;  	operand = methodBody.Variables [3];  	break;  case ILCode.__Ldarg_S:  	code = ILCode.__Ldarg;  	break;  case ILCode.__Ldarga_S:  	code = ILCode.__Ldarga;  	break;  case ILCode.__Starg_S:  	code = ILCode.__Starg;  	break;  case ILCode.__Ldloc_S:  	code = ILCode.Ldloc;  	break;  case ILCode.__Ldloca_S:  	code = ILCode.Ldloca;  	break;  case ILCode.__Stloc_S:  	code = ILCode.Stloc;  	break;  case ILCode.__Ldc_I4_M1:  	code = ILCode.Ldc_I4;  	operand = -1;  	break;  case ILCode.__Ldc_I4_0:  	code = ILCode.Ldc_I4;  	operand = 0;  	break;  case ILCode.__Ldc_I4_1:  	code = ILCode.Ldc_I4;  	operand = 1;  	break;  case ILCode.__Ldc_I4_2:  	code = ILCode.Ldc_I4;  	operand = 2;  	break;  case ILCode.__Ldc_I4_3:  	code = ILCode.Ldc_I4;  	operand = 3;  	break;  case ILCode.__Ldc_I4_4:  	code = ILCode.Ldc_I4;  	operand = 4;  	break;  case ILCode.__Ldc_I4_5:  	code = ILCode.Ldc_I4;  	operand = 5;  	break;  case ILCode.__Ldc_I4_6:  	code = ILCode.Ldc_I4;  	operand = 6;  	break;  case ILCode.__Ldc_I4_7:  	code = ILCode.Ldc_I4;  	operand = 7;  	break;  case ILCode.__Ldc_I4_8:  	code = ILCode.Ldc_I4;  	operand = 8;  	break;  case ILCode.__Ldc_I4_S:  	code = ILCode.Ldc_I4;  	operand = (int)(sbyte)operand;  	break;  case ILCode.__Br_S:  	code = ILCode.Br;  	break;  case ILCode.__Brfalse_S:  	code = ILCode.__Brfalse;  	break;  case ILCode.__Brtrue_S:  	code = ILCode.Brtrue;  	break;  case ILCode.__Beq_S:  	code = ILCode.__Beq;  	break;  case ILCode.__Bge_S:  	code = ILCode.__Bge;  	break;  case ILCode.__Bgt_S:  	code = ILCode.__Bgt;  	break;  case ILCode.__Ble_S:  	code = ILCode.__Ble;  	break;  case ILCode.__Blt_S:  	code = ILCode.__Blt;  	break;  case ILCode.__Bne_Un_S:  	code = ILCode.__Bne_Un;  	break;  case ILCode.__Bge_Un_S:  	code = ILCode.__Bge_Un;  	break;  case ILCode.__Bgt_Un_S:  	code = ILCode.__Bgt_Un;  	break;  case ILCode.__Ble_Un_S:  	code = ILCode.__Ble_Un;  	break;  case ILCode.__Blt_Un_S:  	code = ILCode.__Blt_Un;  	break;  case ILCode.__Leave_S:  	code = ILCode.Leave;  	break;  case ILCode.__Ldind_I:  	code = ILCode.Ldobj;  	operand = methodBody.Method.Module.TypeSystem.IntPtr;  	break;  case ILCode.__Ldind_I1:  	code = ILCode.Ldobj;  	operand = methodBody.Method.Module.TypeSystem.SByte;  	break;  case ILCode.__Ldind_I2:  	code = ILCode.Ldobj;  	operand = methodBody.Method.Module.TypeSystem.Int16;  	break;  case ILCode.__Ldind_I4:  	code = ILCode.Ldobj;  	operand = methodBody.Method.Module.TypeSystem.Int32;  	break;  case ILCode.__Ldind_I8:  	code = ILCode.Ldobj;  	operand = methodBody.Method.Module.TypeSystem.Int64;  	break;  case ILCode.__Ldind_U1:  	code = ILCode.Ldobj;  	operand = methodBody.Method.Module.TypeSystem.Byte;  	break;  case ILCode.__Ldind_U2:  	code = ILCode.Ldobj;  	operand = methodBody.Method.Module.TypeSystem.UInt16;  	break;  case ILCode.__Ldind_U4:  	code = ILCode.Ldobj;  	operand = methodBody.Method.Module.TypeSystem.UInt32;  	break;  case ILCode.__Ldind_R4:  	code = ILCode.Ldobj;  	operand = methodBody.Method.Module.TypeSystem.Single;  	break;  case ILCode.__Ldind_R8:  	code = ILCode.Ldobj;  	operand = methodBody.Method.Module.TypeSystem.Double;  	break;  case ILCode.__Stind_I:  	code = ILCode.Stobj;  	operand = methodBody.Method.Module.TypeSystem.IntPtr;  	break;  case ILCode.__Stind_I1:  	code = ILCode.Stobj;  	operand = methodBody.Method.Module.TypeSystem.Byte;  	break;  case ILCode.__Stind_I2:  	code = ILCode.Stobj;  	operand = methodBody.Method.Module.TypeSystem.Int16;  	break;  case ILCode.__Stind_I4:  	code = ILCode.Stobj;  	operand = methodBody.Method.Module.TypeSystem.Int32;  	break;  case ILCode.__Stind_I8:  	code = ILCode.Stobj;  	operand = methodBody.Method.Module.TypeSystem.Int64;  	break;  case ILCode.__Stind_R4:  	code = ILCode.Stobj;  	operand = methodBody.Method.Module.TypeSystem.Single;  	break;  case ILCode.__Stind_R8:  	code = ILCode.Stobj;  	operand = methodBody.Method.Module.TypeSystem.Double;  	break;  }  
Magic Number,Custom.Decompiler.ILAst,ILCodeUtil,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILCodes.cs,ExpandMacro,The following statement contains a magic number: switch (code) {  case ILCode.__Ldarg_0:  	code = ILCode.__Ldarg;  	operand = methodBody.GetParameter (0);  	break;  case ILCode.__Ldarg_1:  	code = ILCode.__Ldarg;  	operand = methodBody.GetParameter (1);  	break;  case ILCode.__Ldarg_2:  	code = ILCode.__Ldarg;  	operand = methodBody.GetParameter (2);  	break;  case ILCode.__Ldarg_3:  	code = ILCode.__Ldarg;  	operand = methodBody.GetParameter (3);  	break;  case ILCode.__Ldloc_0:  	code = ILCode.Ldloc;  	operand = methodBody.Variables [0];  	break;  case ILCode.__Ldloc_1:  	code = ILCode.Ldloc;  	operand = methodBody.Variables [1];  	break;  case ILCode.__Ldloc_2:  	code = ILCode.Ldloc;  	operand = methodBody.Variables [2];  	break;  case ILCode.__Ldloc_3:  	code = ILCode.Ldloc;  	operand = methodBody.Variables [3];  	break;  case ILCode.__Stloc_0:  	code = ILCode.Stloc;  	operand = methodBody.Variables [0];  	break;  case ILCode.__Stloc_1:  	code = ILCode.Stloc;  	operand = methodBody.Variables [1];  	break;  case ILCode.__Stloc_2:  	code = ILCode.Stloc;  	operand = methodBody.Variables [2];  	break;  case ILCode.__Stloc_3:  	code = ILCode.Stloc;  	operand = methodBody.Variables [3];  	break;  case ILCode.__Ldarg_S:  	code = ILCode.__Ldarg;  	break;  case ILCode.__Ldarga_S:  	code = ILCode.__Ldarga;  	break;  case ILCode.__Starg_S:  	code = ILCode.__Starg;  	break;  case ILCode.__Ldloc_S:  	code = ILCode.Ldloc;  	break;  case ILCode.__Ldloca_S:  	code = ILCode.Ldloca;  	break;  case ILCode.__Stloc_S:  	code = ILCode.Stloc;  	break;  case ILCode.__Ldc_I4_M1:  	code = ILCode.Ldc_I4;  	operand = -1;  	break;  case ILCode.__Ldc_I4_0:  	code = ILCode.Ldc_I4;  	operand = 0;  	break;  case ILCode.__Ldc_I4_1:  	code = ILCode.Ldc_I4;  	operand = 1;  	break;  case ILCode.__Ldc_I4_2:  	code = ILCode.Ldc_I4;  	operand = 2;  	break;  case ILCode.__Ldc_I4_3:  	code = ILCode.Ldc_I4;  	operand = 3;  	break;  case ILCode.__Ldc_I4_4:  	code = ILCode.Ldc_I4;  	operand = 4;  	break;  case ILCode.__Ldc_I4_5:  	code = ILCode.Ldc_I4;  	operand = 5;  	break;  case ILCode.__Ldc_I4_6:  	code = ILCode.Ldc_I4;  	operand = 6;  	break;  case ILCode.__Ldc_I4_7:  	code = ILCode.Ldc_I4;  	operand = 7;  	break;  case ILCode.__Ldc_I4_8:  	code = ILCode.Ldc_I4;  	operand = 8;  	break;  case ILCode.__Ldc_I4_S:  	code = ILCode.Ldc_I4;  	operand = (int)(sbyte)operand;  	break;  case ILCode.__Br_S:  	code = ILCode.Br;  	break;  case ILCode.__Brfalse_S:  	code = ILCode.__Brfalse;  	break;  case ILCode.__Brtrue_S:  	code = ILCode.Brtrue;  	break;  case ILCode.__Beq_S:  	code = ILCode.__Beq;  	break;  case ILCode.__Bge_S:  	code = ILCode.__Bge;  	break;  case ILCode.__Bgt_S:  	code = ILCode.__Bgt;  	break;  case ILCode.__Ble_S:  	code = ILCode.__Ble;  	break;  case ILCode.__Blt_S:  	code = ILCode.__Blt;  	break;  case ILCode.__Bne_Un_S:  	code = ILCode.__Bne_Un;  	break;  case ILCode.__Bge_Un_S:  	code = ILCode.__Bge_Un;  	break;  case ILCode.__Bgt_Un_S:  	code = ILCode.__Bgt_Un;  	break;  case ILCode.__Ble_Un_S:  	code = ILCode.__Ble_Un;  	break;  case ILCode.__Blt_Un_S:  	code = ILCode.__Blt_Un;  	break;  case ILCode.__Leave_S:  	code = ILCode.Leave;  	break;  case ILCode.__Ldind_I:  	code = ILCode.Ldobj;  	operand = methodBody.Method.Module.TypeSystem.IntPtr;  	break;  case ILCode.__Ldind_I1:  	code = ILCode.Ldobj;  	operand = methodBody.Method.Module.TypeSystem.SByte;  	break;  case ILCode.__Ldind_I2:  	code = ILCode.Ldobj;  	operand = methodBody.Method.Module.TypeSystem.Int16;  	break;  case ILCode.__Ldind_I4:  	code = ILCode.Ldobj;  	operand = methodBody.Method.Module.TypeSystem.Int32;  	break;  case ILCode.__Ldind_I8:  	code = ILCode.Ldobj;  	operand = methodBody.Method.Module.TypeSystem.Int64;  	break;  case ILCode.__Ldind_U1:  	code = ILCode.Ldobj;  	operand = methodBody.Method.Module.TypeSystem.Byte;  	break;  case ILCode.__Ldind_U2:  	code = ILCode.Ldobj;  	operand = methodBody.Method.Module.TypeSystem.UInt16;  	break;  case ILCode.__Ldind_U4:  	code = ILCode.Ldobj;  	operand = methodBody.Method.Module.TypeSystem.UInt32;  	break;  case ILCode.__Ldind_R4:  	code = ILCode.Ldobj;  	operand = methodBody.Method.Module.TypeSystem.Single;  	break;  case ILCode.__Ldind_R8:  	code = ILCode.Ldobj;  	operand = methodBody.Method.Module.TypeSystem.Double;  	break;  case ILCode.__Stind_I:  	code = ILCode.Stobj;  	operand = methodBody.Method.Module.TypeSystem.IntPtr;  	break;  case ILCode.__Stind_I1:  	code = ILCode.Stobj;  	operand = methodBody.Method.Module.TypeSystem.Byte;  	break;  case ILCode.__Stind_I2:  	code = ILCode.Stobj;  	operand = methodBody.Method.Module.TypeSystem.Int16;  	break;  case ILCode.__Stind_I4:  	code = ILCode.Stobj;  	operand = methodBody.Method.Module.TypeSystem.Int32;  	break;  case ILCode.__Stind_I8:  	code = ILCode.Stobj;  	operand = methodBody.Method.Module.TypeSystem.Int64;  	break;  case ILCode.__Stind_R4:  	code = ILCode.Stobj;  	operand = methodBody.Method.Module.TypeSystem.Single;  	break;  case ILCode.__Stind_R8:  	code = ILCode.Stobj;  	operand = methodBody.Method.Module.TypeSystem.Double;  	break;  }  
Magic Number,Custom.Decompiler.ILAst,ILCodeUtil,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILCodes.cs,ExpandMacro,The following statement contains a magic number: switch (code) {  case ILCode.__Ldarg_0:  	code = ILCode.__Ldarg;  	operand = methodBody.GetParameter (0);  	break;  case ILCode.__Ldarg_1:  	code = ILCode.__Ldarg;  	operand = methodBody.GetParameter (1);  	break;  case ILCode.__Ldarg_2:  	code = ILCode.__Ldarg;  	operand = methodBody.GetParameter (2);  	break;  case ILCode.__Ldarg_3:  	code = ILCode.__Ldarg;  	operand = methodBody.GetParameter (3);  	break;  case ILCode.__Ldloc_0:  	code = ILCode.Ldloc;  	operand = methodBody.Variables [0];  	break;  case ILCode.__Ldloc_1:  	code = ILCode.Ldloc;  	operand = methodBody.Variables [1];  	break;  case ILCode.__Ldloc_2:  	code = ILCode.Ldloc;  	operand = methodBody.Variables [2];  	break;  case ILCode.__Ldloc_3:  	code = ILCode.Ldloc;  	operand = methodBody.Variables [3];  	break;  case ILCode.__Stloc_0:  	code = ILCode.Stloc;  	operand = methodBody.Variables [0];  	break;  case ILCode.__Stloc_1:  	code = ILCode.Stloc;  	operand = methodBody.Variables [1];  	break;  case ILCode.__Stloc_2:  	code = ILCode.Stloc;  	operand = methodBody.Variables [2];  	break;  case ILCode.__Stloc_3:  	code = ILCode.Stloc;  	operand = methodBody.Variables [3];  	break;  case ILCode.__Ldarg_S:  	code = ILCode.__Ldarg;  	break;  case ILCode.__Ldarga_S:  	code = ILCode.__Ldarga;  	break;  case ILCode.__Starg_S:  	code = ILCode.__Starg;  	break;  case ILCode.__Ldloc_S:  	code = ILCode.Ldloc;  	break;  case ILCode.__Ldloca_S:  	code = ILCode.Ldloca;  	break;  case ILCode.__Stloc_S:  	code = ILCode.Stloc;  	break;  case ILCode.__Ldc_I4_M1:  	code = ILCode.Ldc_I4;  	operand = -1;  	break;  case ILCode.__Ldc_I4_0:  	code = ILCode.Ldc_I4;  	operand = 0;  	break;  case ILCode.__Ldc_I4_1:  	code = ILCode.Ldc_I4;  	operand = 1;  	break;  case ILCode.__Ldc_I4_2:  	code = ILCode.Ldc_I4;  	operand = 2;  	break;  case ILCode.__Ldc_I4_3:  	code = ILCode.Ldc_I4;  	operand = 3;  	break;  case ILCode.__Ldc_I4_4:  	code = ILCode.Ldc_I4;  	operand = 4;  	break;  case ILCode.__Ldc_I4_5:  	code = ILCode.Ldc_I4;  	operand = 5;  	break;  case ILCode.__Ldc_I4_6:  	code = ILCode.Ldc_I4;  	operand = 6;  	break;  case ILCode.__Ldc_I4_7:  	code = ILCode.Ldc_I4;  	operand = 7;  	break;  case ILCode.__Ldc_I4_8:  	code = ILCode.Ldc_I4;  	operand = 8;  	break;  case ILCode.__Ldc_I4_S:  	code = ILCode.Ldc_I4;  	operand = (int)(sbyte)operand;  	break;  case ILCode.__Br_S:  	code = ILCode.Br;  	break;  case ILCode.__Brfalse_S:  	code = ILCode.__Brfalse;  	break;  case ILCode.__Brtrue_S:  	code = ILCode.Brtrue;  	break;  case ILCode.__Beq_S:  	code = ILCode.__Beq;  	break;  case ILCode.__Bge_S:  	code = ILCode.__Bge;  	break;  case ILCode.__Bgt_S:  	code = ILCode.__Bgt;  	break;  case ILCode.__Ble_S:  	code = ILCode.__Ble;  	break;  case ILCode.__Blt_S:  	code = ILCode.__Blt;  	break;  case ILCode.__Bne_Un_S:  	code = ILCode.__Bne_Un;  	break;  case ILCode.__Bge_Un_S:  	code = ILCode.__Bge_Un;  	break;  case ILCode.__Bgt_Un_S:  	code = ILCode.__Bgt_Un;  	break;  case ILCode.__Ble_Un_S:  	code = ILCode.__Ble_Un;  	break;  case ILCode.__Blt_Un_S:  	code = ILCode.__Blt_Un;  	break;  case ILCode.__Leave_S:  	code = ILCode.Leave;  	break;  case ILCode.__Ldind_I:  	code = ILCode.Ldobj;  	operand = methodBody.Method.Module.TypeSystem.IntPtr;  	break;  case ILCode.__Ldind_I1:  	code = ILCode.Ldobj;  	operand = methodBody.Method.Module.TypeSystem.SByte;  	break;  case ILCode.__Ldind_I2:  	code = ILCode.Ldobj;  	operand = methodBody.Method.Module.TypeSystem.Int16;  	break;  case ILCode.__Ldind_I4:  	code = ILCode.Ldobj;  	operand = methodBody.Method.Module.TypeSystem.Int32;  	break;  case ILCode.__Ldind_I8:  	code = ILCode.Ldobj;  	operand = methodBody.Method.Module.TypeSystem.Int64;  	break;  case ILCode.__Ldind_U1:  	code = ILCode.Ldobj;  	operand = methodBody.Method.Module.TypeSystem.Byte;  	break;  case ILCode.__Ldind_U2:  	code = ILCode.Ldobj;  	operand = methodBody.Method.Module.TypeSystem.UInt16;  	break;  case ILCode.__Ldind_U4:  	code = ILCode.Ldobj;  	operand = methodBody.Method.Module.TypeSystem.UInt32;  	break;  case ILCode.__Ldind_R4:  	code = ILCode.Ldobj;  	operand = methodBody.Method.Module.TypeSystem.Single;  	break;  case ILCode.__Ldind_R8:  	code = ILCode.Ldobj;  	operand = methodBody.Method.Module.TypeSystem.Double;  	break;  case ILCode.__Stind_I:  	code = ILCode.Stobj;  	operand = methodBody.Method.Module.TypeSystem.IntPtr;  	break;  case ILCode.__Stind_I1:  	code = ILCode.Stobj;  	operand = methodBody.Method.Module.TypeSystem.Byte;  	break;  case ILCode.__Stind_I2:  	code = ILCode.Stobj;  	operand = methodBody.Method.Module.TypeSystem.Int16;  	break;  case ILCode.__Stind_I4:  	code = ILCode.Stobj;  	operand = methodBody.Method.Module.TypeSystem.Int32;  	break;  case ILCode.__Stind_I8:  	code = ILCode.Stobj;  	operand = methodBody.Method.Module.TypeSystem.Int64;  	break;  case ILCode.__Stind_R4:  	code = ILCode.Stobj;  	operand = methodBody.Method.Module.TypeSystem.Single;  	break;  case ILCode.__Stind_R8:  	code = ILCode.Stobj;  	operand = methodBody.Method.Module.TypeSystem.Double;  	break;  }  
Magic Number,Custom.Decompiler.ILAst,ILCodeUtil,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILCodes.cs,ExpandMacro,The following statement contains a magic number: switch (code) {  case ILCode.__Ldarg_0:  	code = ILCode.__Ldarg;  	operand = methodBody.GetParameter (0);  	break;  case ILCode.__Ldarg_1:  	code = ILCode.__Ldarg;  	operand = methodBody.GetParameter (1);  	break;  case ILCode.__Ldarg_2:  	code = ILCode.__Ldarg;  	operand = methodBody.GetParameter (2);  	break;  case ILCode.__Ldarg_3:  	code = ILCode.__Ldarg;  	operand = methodBody.GetParameter (3);  	break;  case ILCode.__Ldloc_0:  	code = ILCode.Ldloc;  	operand = methodBody.Variables [0];  	break;  case ILCode.__Ldloc_1:  	code = ILCode.Ldloc;  	operand = methodBody.Variables [1];  	break;  case ILCode.__Ldloc_2:  	code = ILCode.Ldloc;  	operand = methodBody.Variables [2];  	break;  case ILCode.__Ldloc_3:  	code = ILCode.Ldloc;  	operand = methodBody.Variables [3];  	break;  case ILCode.__Stloc_0:  	code = ILCode.Stloc;  	operand = methodBody.Variables [0];  	break;  case ILCode.__Stloc_1:  	code = ILCode.Stloc;  	operand = methodBody.Variables [1];  	break;  case ILCode.__Stloc_2:  	code = ILCode.Stloc;  	operand = methodBody.Variables [2];  	break;  case ILCode.__Stloc_3:  	code = ILCode.Stloc;  	operand = methodBody.Variables [3];  	break;  case ILCode.__Ldarg_S:  	code = ILCode.__Ldarg;  	break;  case ILCode.__Ldarga_S:  	code = ILCode.__Ldarga;  	break;  case ILCode.__Starg_S:  	code = ILCode.__Starg;  	break;  case ILCode.__Ldloc_S:  	code = ILCode.Ldloc;  	break;  case ILCode.__Ldloca_S:  	code = ILCode.Ldloca;  	break;  case ILCode.__Stloc_S:  	code = ILCode.Stloc;  	break;  case ILCode.__Ldc_I4_M1:  	code = ILCode.Ldc_I4;  	operand = -1;  	break;  case ILCode.__Ldc_I4_0:  	code = ILCode.Ldc_I4;  	operand = 0;  	break;  case ILCode.__Ldc_I4_1:  	code = ILCode.Ldc_I4;  	operand = 1;  	break;  case ILCode.__Ldc_I4_2:  	code = ILCode.Ldc_I4;  	operand = 2;  	break;  case ILCode.__Ldc_I4_3:  	code = ILCode.Ldc_I4;  	operand = 3;  	break;  case ILCode.__Ldc_I4_4:  	code = ILCode.Ldc_I4;  	operand = 4;  	break;  case ILCode.__Ldc_I4_5:  	code = ILCode.Ldc_I4;  	operand = 5;  	break;  case ILCode.__Ldc_I4_6:  	code = ILCode.Ldc_I4;  	operand = 6;  	break;  case ILCode.__Ldc_I4_7:  	code = ILCode.Ldc_I4;  	operand = 7;  	break;  case ILCode.__Ldc_I4_8:  	code = ILCode.Ldc_I4;  	operand = 8;  	break;  case ILCode.__Ldc_I4_S:  	code = ILCode.Ldc_I4;  	operand = (int)(sbyte)operand;  	break;  case ILCode.__Br_S:  	code = ILCode.Br;  	break;  case ILCode.__Brfalse_S:  	code = ILCode.__Brfalse;  	break;  case ILCode.__Brtrue_S:  	code = ILCode.Brtrue;  	break;  case ILCode.__Beq_S:  	code = ILCode.__Beq;  	break;  case ILCode.__Bge_S:  	code = ILCode.__Bge;  	break;  case ILCode.__Bgt_S:  	code = ILCode.__Bgt;  	break;  case ILCode.__Ble_S:  	code = ILCode.__Ble;  	break;  case ILCode.__Blt_S:  	code = ILCode.__Blt;  	break;  case ILCode.__Bne_Un_S:  	code = ILCode.__Bne_Un;  	break;  case ILCode.__Bge_Un_S:  	code = ILCode.__Bge_Un;  	break;  case ILCode.__Bgt_Un_S:  	code = ILCode.__Bgt_Un;  	break;  case ILCode.__Ble_Un_S:  	code = ILCode.__Ble_Un;  	break;  case ILCode.__Blt_Un_S:  	code = ILCode.__Blt_Un;  	break;  case ILCode.__Leave_S:  	code = ILCode.Leave;  	break;  case ILCode.__Ldind_I:  	code = ILCode.Ldobj;  	operand = methodBody.Method.Module.TypeSystem.IntPtr;  	break;  case ILCode.__Ldind_I1:  	code = ILCode.Ldobj;  	operand = methodBody.Method.Module.TypeSystem.SByte;  	break;  case ILCode.__Ldind_I2:  	code = ILCode.Ldobj;  	operand = methodBody.Method.Module.TypeSystem.Int16;  	break;  case ILCode.__Ldind_I4:  	code = ILCode.Ldobj;  	operand = methodBody.Method.Module.TypeSystem.Int32;  	break;  case ILCode.__Ldind_I8:  	code = ILCode.Ldobj;  	operand = methodBody.Method.Module.TypeSystem.Int64;  	break;  case ILCode.__Ldind_U1:  	code = ILCode.Ldobj;  	operand = methodBody.Method.Module.TypeSystem.Byte;  	break;  case ILCode.__Ldind_U2:  	code = ILCode.Ldobj;  	operand = methodBody.Method.Module.TypeSystem.UInt16;  	break;  case ILCode.__Ldind_U4:  	code = ILCode.Ldobj;  	operand = methodBody.Method.Module.TypeSystem.UInt32;  	break;  case ILCode.__Ldind_R4:  	code = ILCode.Ldobj;  	operand = methodBody.Method.Module.TypeSystem.Single;  	break;  case ILCode.__Ldind_R8:  	code = ILCode.Ldobj;  	operand = methodBody.Method.Module.TypeSystem.Double;  	break;  case ILCode.__Stind_I:  	code = ILCode.Stobj;  	operand = methodBody.Method.Module.TypeSystem.IntPtr;  	break;  case ILCode.__Stind_I1:  	code = ILCode.Stobj;  	operand = methodBody.Method.Module.TypeSystem.Byte;  	break;  case ILCode.__Stind_I2:  	code = ILCode.Stobj;  	operand = methodBody.Method.Module.TypeSystem.Int16;  	break;  case ILCode.__Stind_I4:  	code = ILCode.Stobj;  	operand = methodBody.Method.Module.TypeSystem.Int32;  	break;  case ILCode.__Stind_I8:  	code = ILCode.Stobj;  	operand = methodBody.Method.Module.TypeSystem.Int64;  	break;  case ILCode.__Stind_R4:  	code = ILCode.Stobj;  	operand = methodBody.Method.Module.TypeSystem.Single;  	break;  case ILCode.__Stind_R8:  	code = ILCode.Stobj;  	operand = methodBody.Method.Module.TypeSystem.Double;  	break;  }  
Magic Number,Custom.Decompiler.ILAst,ILCodeUtil,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILCodes.cs,ExpandMacro,The following statement contains a magic number: switch (code) {  case ILCode.__Ldarg_0:  	code = ILCode.__Ldarg;  	operand = methodBody.GetParameter (0);  	break;  case ILCode.__Ldarg_1:  	code = ILCode.__Ldarg;  	operand = methodBody.GetParameter (1);  	break;  case ILCode.__Ldarg_2:  	code = ILCode.__Ldarg;  	operand = methodBody.GetParameter (2);  	break;  case ILCode.__Ldarg_3:  	code = ILCode.__Ldarg;  	operand = methodBody.GetParameter (3);  	break;  case ILCode.__Ldloc_0:  	code = ILCode.Ldloc;  	operand = methodBody.Variables [0];  	break;  case ILCode.__Ldloc_1:  	code = ILCode.Ldloc;  	operand = methodBody.Variables [1];  	break;  case ILCode.__Ldloc_2:  	code = ILCode.Ldloc;  	operand = methodBody.Variables [2];  	break;  case ILCode.__Ldloc_3:  	code = ILCode.Ldloc;  	operand = methodBody.Variables [3];  	break;  case ILCode.__Stloc_0:  	code = ILCode.Stloc;  	operand = methodBody.Variables [0];  	break;  case ILCode.__Stloc_1:  	code = ILCode.Stloc;  	operand = methodBody.Variables [1];  	break;  case ILCode.__Stloc_2:  	code = ILCode.Stloc;  	operand = methodBody.Variables [2];  	break;  case ILCode.__Stloc_3:  	code = ILCode.Stloc;  	operand = methodBody.Variables [3];  	break;  case ILCode.__Ldarg_S:  	code = ILCode.__Ldarg;  	break;  case ILCode.__Ldarga_S:  	code = ILCode.__Ldarga;  	break;  case ILCode.__Starg_S:  	code = ILCode.__Starg;  	break;  case ILCode.__Ldloc_S:  	code = ILCode.Ldloc;  	break;  case ILCode.__Ldloca_S:  	code = ILCode.Ldloca;  	break;  case ILCode.__Stloc_S:  	code = ILCode.Stloc;  	break;  case ILCode.__Ldc_I4_M1:  	code = ILCode.Ldc_I4;  	operand = -1;  	break;  case ILCode.__Ldc_I4_0:  	code = ILCode.Ldc_I4;  	operand = 0;  	break;  case ILCode.__Ldc_I4_1:  	code = ILCode.Ldc_I4;  	operand = 1;  	break;  case ILCode.__Ldc_I4_2:  	code = ILCode.Ldc_I4;  	operand = 2;  	break;  case ILCode.__Ldc_I4_3:  	code = ILCode.Ldc_I4;  	operand = 3;  	break;  case ILCode.__Ldc_I4_4:  	code = ILCode.Ldc_I4;  	operand = 4;  	break;  case ILCode.__Ldc_I4_5:  	code = ILCode.Ldc_I4;  	operand = 5;  	break;  case ILCode.__Ldc_I4_6:  	code = ILCode.Ldc_I4;  	operand = 6;  	break;  case ILCode.__Ldc_I4_7:  	code = ILCode.Ldc_I4;  	operand = 7;  	break;  case ILCode.__Ldc_I4_8:  	code = ILCode.Ldc_I4;  	operand = 8;  	break;  case ILCode.__Ldc_I4_S:  	code = ILCode.Ldc_I4;  	operand = (int)(sbyte)operand;  	break;  case ILCode.__Br_S:  	code = ILCode.Br;  	break;  case ILCode.__Brfalse_S:  	code = ILCode.__Brfalse;  	break;  case ILCode.__Brtrue_S:  	code = ILCode.Brtrue;  	break;  case ILCode.__Beq_S:  	code = ILCode.__Beq;  	break;  case ILCode.__Bge_S:  	code = ILCode.__Bge;  	break;  case ILCode.__Bgt_S:  	code = ILCode.__Bgt;  	break;  case ILCode.__Ble_S:  	code = ILCode.__Ble;  	break;  case ILCode.__Blt_S:  	code = ILCode.__Blt;  	break;  case ILCode.__Bne_Un_S:  	code = ILCode.__Bne_Un;  	break;  case ILCode.__Bge_Un_S:  	code = ILCode.__Bge_Un;  	break;  case ILCode.__Bgt_Un_S:  	code = ILCode.__Bgt_Un;  	break;  case ILCode.__Ble_Un_S:  	code = ILCode.__Ble_Un;  	break;  case ILCode.__Blt_Un_S:  	code = ILCode.__Blt_Un;  	break;  case ILCode.__Leave_S:  	code = ILCode.Leave;  	break;  case ILCode.__Ldind_I:  	code = ILCode.Ldobj;  	operand = methodBody.Method.Module.TypeSystem.IntPtr;  	break;  case ILCode.__Ldind_I1:  	code = ILCode.Ldobj;  	operand = methodBody.Method.Module.TypeSystem.SByte;  	break;  case ILCode.__Ldind_I2:  	code = ILCode.Ldobj;  	operand = methodBody.Method.Module.TypeSystem.Int16;  	break;  case ILCode.__Ldind_I4:  	code = ILCode.Ldobj;  	operand = methodBody.Method.Module.TypeSystem.Int32;  	break;  case ILCode.__Ldind_I8:  	code = ILCode.Ldobj;  	operand = methodBody.Method.Module.TypeSystem.Int64;  	break;  case ILCode.__Ldind_U1:  	code = ILCode.Ldobj;  	operand = methodBody.Method.Module.TypeSystem.Byte;  	break;  case ILCode.__Ldind_U2:  	code = ILCode.Ldobj;  	operand = methodBody.Method.Module.TypeSystem.UInt16;  	break;  case ILCode.__Ldind_U4:  	code = ILCode.Ldobj;  	operand = methodBody.Method.Module.TypeSystem.UInt32;  	break;  case ILCode.__Ldind_R4:  	code = ILCode.Ldobj;  	operand = methodBody.Method.Module.TypeSystem.Single;  	break;  case ILCode.__Ldind_R8:  	code = ILCode.Ldobj;  	operand = methodBody.Method.Module.TypeSystem.Double;  	break;  case ILCode.__Stind_I:  	code = ILCode.Stobj;  	operand = methodBody.Method.Module.TypeSystem.IntPtr;  	break;  case ILCode.__Stind_I1:  	code = ILCode.Stobj;  	operand = methodBody.Method.Module.TypeSystem.Byte;  	break;  case ILCode.__Stind_I2:  	code = ILCode.Stobj;  	operand = methodBody.Method.Module.TypeSystem.Int16;  	break;  case ILCode.__Stind_I4:  	code = ILCode.Stobj;  	operand = methodBody.Method.Module.TypeSystem.Int32;  	break;  case ILCode.__Stind_I8:  	code = ILCode.Stobj;  	operand = methodBody.Method.Module.TypeSystem.Int64;  	break;  case ILCode.__Stind_R4:  	code = ILCode.Stobj;  	operand = methodBody.Method.Module.TypeSystem.Single;  	break;  case ILCode.__Stind_R8:  	code = ILCode.Stobj;  	operand = methodBody.Method.Module.TypeSystem.Double;  	break;  }  
Magic Number,Custom.Decompiler.ILAst,ILCodeUtil,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILCodes.cs,ExpandMacro,The following statement contains a magic number: switch (code) {  case ILCode.__Ldarg_0:  	code = ILCode.__Ldarg;  	operand = methodBody.GetParameter (0);  	break;  case ILCode.__Ldarg_1:  	code = ILCode.__Ldarg;  	operand = methodBody.GetParameter (1);  	break;  case ILCode.__Ldarg_2:  	code = ILCode.__Ldarg;  	operand = methodBody.GetParameter (2);  	break;  case ILCode.__Ldarg_3:  	code = ILCode.__Ldarg;  	operand = methodBody.GetParameter (3);  	break;  case ILCode.__Ldloc_0:  	code = ILCode.Ldloc;  	operand = methodBody.Variables [0];  	break;  case ILCode.__Ldloc_1:  	code = ILCode.Ldloc;  	operand = methodBody.Variables [1];  	break;  case ILCode.__Ldloc_2:  	code = ILCode.Ldloc;  	operand = methodBody.Variables [2];  	break;  case ILCode.__Ldloc_3:  	code = ILCode.Ldloc;  	operand = methodBody.Variables [3];  	break;  case ILCode.__Stloc_0:  	code = ILCode.Stloc;  	operand = methodBody.Variables [0];  	break;  case ILCode.__Stloc_1:  	code = ILCode.Stloc;  	operand = methodBody.Variables [1];  	break;  case ILCode.__Stloc_2:  	code = ILCode.Stloc;  	operand = methodBody.Variables [2];  	break;  case ILCode.__Stloc_3:  	code = ILCode.Stloc;  	operand = methodBody.Variables [3];  	break;  case ILCode.__Ldarg_S:  	code = ILCode.__Ldarg;  	break;  case ILCode.__Ldarga_S:  	code = ILCode.__Ldarga;  	break;  case ILCode.__Starg_S:  	code = ILCode.__Starg;  	break;  case ILCode.__Ldloc_S:  	code = ILCode.Ldloc;  	break;  case ILCode.__Ldloca_S:  	code = ILCode.Ldloca;  	break;  case ILCode.__Stloc_S:  	code = ILCode.Stloc;  	break;  case ILCode.__Ldc_I4_M1:  	code = ILCode.Ldc_I4;  	operand = -1;  	break;  case ILCode.__Ldc_I4_0:  	code = ILCode.Ldc_I4;  	operand = 0;  	break;  case ILCode.__Ldc_I4_1:  	code = ILCode.Ldc_I4;  	operand = 1;  	break;  case ILCode.__Ldc_I4_2:  	code = ILCode.Ldc_I4;  	operand = 2;  	break;  case ILCode.__Ldc_I4_3:  	code = ILCode.Ldc_I4;  	operand = 3;  	break;  case ILCode.__Ldc_I4_4:  	code = ILCode.Ldc_I4;  	operand = 4;  	break;  case ILCode.__Ldc_I4_5:  	code = ILCode.Ldc_I4;  	operand = 5;  	break;  case ILCode.__Ldc_I4_6:  	code = ILCode.Ldc_I4;  	operand = 6;  	break;  case ILCode.__Ldc_I4_7:  	code = ILCode.Ldc_I4;  	operand = 7;  	break;  case ILCode.__Ldc_I4_8:  	code = ILCode.Ldc_I4;  	operand = 8;  	break;  case ILCode.__Ldc_I4_S:  	code = ILCode.Ldc_I4;  	operand = (int)(sbyte)operand;  	break;  case ILCode.__Br_S:  	code = ILCode.Br;  	break;  case ILCode.__Brfalse_S:  	code = ILCode.__Brfalse;  	break;  case ILCode.__Brtrue_S:  	code = ILCode.Brtrue;  	break;  case ILCode.__Beq_S:  	code = ILCode.__Beq;  	break;  case ILCode.__Bge_S:  	code = ILCode.__Bge;  	break;  case ILCode.__Bgt_S:  	code = ILCode.__Bgt;  	break;  case ILCode.__Ble_S:  	code = ILCode.__Ble;  	break;  case ILCode.__Blt_S:  	code = ILCode.__Blt;  	break;  case ILCode.__Bne_Un_S:  	code = ILCode.__Bne_Un;  	break;  case ILCode.__Bge_Un_S:  	code = ILCode.__Bge_Un;  	break;  case ILCode.__Bgt_Un_S:  	code = ILCode.__Bgt_Un;  	break;  case ILCode.__Ble_Un_S:  	code = ILCode.__Ble_Un;  	break;  case ILCode.__Blt_Un_S:  	code = ILCode.__Blt_Un;  	break;  case ILCode.__Leave_S:  	code = ILCode.Leave;  	break;  case ILCode.__Ldind_I:  	code = ILCode.Ldobj;  	operand = methodBody.Method.Module.TypeSystem.IntPtr;  	break;  case ILCode.__Ldind_I1:  	code = ILCode.Ldobj;  	operand = methodBody.Method.Module.TypeSystem.SByte;  	break;  case ILCode.__Ldind_I2:  	code = ILCode.Ldobj;  	operand = methodBody.Method.Module.TypeSystem.Int16;  	break;  case ILCode.__Ldind_I4:  	code = ILCode.Ldobj;  	operand = methodBody.Method.Module.TypeSystem.Int32;  	break;  case ILCode.__Ldind_I8:  	code = ILCode.Ldobj;  	operand = methodBody.Method.Module.TypeSystem.Int64;  	break;  case ILCode.__Ldind_U1:  	code = ILCode.Ldobj;  	operand = methodBody.Method.Module.TypeSystem.Byte;  	break;  case ILCode.__Ldind_U2:  	code = ILCode.Ldobj;  	operand = methodBody.Method.Module.TypeSystem.UInt16;  	break;  case ILCode.__Ldind_U4:  	code = ILCode.Ldobj;  	operand = methodBody.Method.Module.TypeSystem.UInt32;  	break;  case ILCode.__Ldind_R4:  	code = ILCode.Ldobj;  	operand = methodBody.Method.Module.TypeSystem.Single;  	break;  case ILCode.__Ldind_R8:  	code = ILCode.Ldobj;  	operand = methodBody.Method.Module.TypeSystem.Double;  	break;  case ILCode.__Stind_I:  	code = ILCode.Stobj;  	operand = methodBody.Method.Module.TypeSystem.IntPtr;  	break;  case ILCode.__Stind_I1:  	code = ILCode.Stobj;  	operand = methodBody.Method.Module.TypeSystem.Byte;  	break;  case ILCode.__Stind_I2:  	code = ILCode.Stobj;  	operand = methodBody.Method.Module.TypeSystem.Int16;  	break;  case ILCode.__Stind_I4:  	code = ILCode.Stobj;  	operand = methodBody.Method.Module.TypeSystem.Int32;  	break;  case ILCode.__Stind_I8:  	code = ILCode.Stobj;  	operand = methodBody.Method.Module.TypeSystem.Int64;  	break;  case ILCode.__Stind_R4:  	code = ILCode.Stobj;  	operand = methodBody.Method.Module.TypeSystem.Single;  	break;  case ILCode.__Stind_R8:  	code = ILCode.Stobj;  	operand = methodBody.Method.Module.TypeSystem.Double;  	break;  }  
Magic Number,Custom.Decompiler.ILAst,ILCodeUtil,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILCodes.cs,ExpandMacro,The following statement contains a magic number: switch (code) {  case ILCode.__Ldarg_0:  	code = ILCode.__Ldarg;  	operand = methodBody.GetParameter (0);  	break;  case ILCode.__Ldarg_1:  	code = ILCode.__Ldarg;  	operand = methodBody.GetParameter (1);  	break;  case ILCode.__Ldarg_2:  	code = ILCode.__Ldarg;  	operand = methodBody.GetParameter (2);  	break;  case ILCode.__Ldarg_3:  	code = ILCode.__Ldarg;  	operand = methodBody.GetParameter (3);  	break;  case ILCode.__Ldloc_0:  	code = ILCode.Ldloc;  	operand = methodBody.Variables [0];  	break;  case ILCode.__Ldloc_1:  	code = ILCode.Ldloc;  	operand = methodBody.Variables [1];  	break;  case ILCode.__Ldloc_2:  	code = ILCode.Ldloc;  	operand = methodBody.Variables [2];  	break;  case ILCode.__Ldloc_3:  	code = ILCode.Ldloc;  	operand = methodBody.Variables [3];  	break;  case ILCode.__Stloc_0:  	code = ILCode.Stloc;  	operand = methodBody.Variables [0];  	break;  case ILCode.__Stloc_1:  	code = ILCode.Stloc;  	operand = methodBody.Variables [1];  	break;  case ILCode.__Stloc_2:  	code = ILCode.Stloc;  	operand = methodBody.Variables [2];  	break;  case ILCode.__Stloc_3:  	code = ILCode.Stloc;  	operand = methodBody.Variables [3];  	break;  case ILCode.__Ldarg_S:  	code = ILCode.__Ldarg;  	break;  case ILCode.__Ldarga_S:  	code = ILCode.__Ldarga;  	break;  case ILCode.__Starg_S:  	code = ILCode.__Starg;  	break;  case ILCode.__Ldloc_S:  	code = ILCode.Ldloc;  	break;  case ILCode.__Ldloca_S:  	code = ILCode.Ldloca;  	break;  case ILCode.__Stloc_S:  	code = ILCode.Stloc;  	break;  case ILCode.__Ldc_I4_M1:  	code = ILCode.Ldc_I4;  	operand = -1;  	break;  case ILCode.__Ldc_I4_0:  	code = ILCode.Ldc_I4;  	operand = 0;  	break;  case ILCode.__Ldc_I4_1:  	code = ILCode.Ldc_I4;  	operand = 1;  	break;  case ILCode.__Ldc_I4_2:  	code = ILCode.Ldc_I4;  	operand = 2;  	break;  case ILCode.__Ldc_I4_3:  	code = ILCode.Ldc_I4;  	operand = 3;  	break;  case ILCode.__Ldc_I4_4:  	code = ILCode.Ldc_I4;  	operand = 4;  	break;  case ILCode.__Ldc_I4_5:  	code = ILCode.Ldc_I4;  	operand = 5;  	break;  case ILCode.__Ldc_I4_6:  	code = ILCode.Ldc_I4;  	operand = 6;  	break;  case ILCode.__Ldc_I4_7:  	code = ILCode.Ldc_I4;  	operand = 7;  	break;  case ILCode.__Ldc_I4_8:  	code = ILCode.Ldc_I4;  	operand = 8;  	break;  case ILCode.__Ldc_I4_S:  	code = ILCode.Ldc_I4;  	operand = (int)(sbyte)operand;  	break;  case ILCode.__Br_S:  	code = ILCode.Br;  	break;  case ILCode.__Brfalse_S:  	code = ILCode.__Brfalse;  	break;  case ILCode.__Brtrue_S:  	code = ILCode.Brtrue;  	break;  case ILCode.__Beq_S:  	code = ILCode.__Beq;  	break;  case ILCode.__Bge_S:  	code = ILCode.__Bge;  	break;  case ILCode.__Bgt_S:  	code = ILCode.__Bgt;  	break;  case ILCode.__Ble_S:  	code = ILCode.__Ble;  	break;  case ILCode.__Blt_S:  	code = ILCode.__Blt;  	break;  case ILCode.__Bne_Un_S:  	code = ILCode.__Bne_Un;  	break;  case ILCode.__Bge_Un_S:  	code = ILCode.__Bge_Un;  	break;  case ILCode.__Bgt_Un_S:  	code = ILCode.__Bgt_Un;  	break;  case ILCode.__Ble_Un_S:  	code = ILCode.__Ble_Un;  	break;  case ILCode.__Blt_Un_S:  	code = ILCode.__Blt_Un;  	break;  case ILCode.__Leave_S:  	code = ILCode.Leave;  	break;  case ILCode.__Ldind_I:  	code = ILCode.Ldobj;  	operand = methodBody.Method.Module.TypeSystem.IntPtr;  	break;  case ILCode.__Ldind_I1:  	code = ILCode.Ldobj;  	operand = methodBody.Method.Module.TypeSystem.SByte;  	break;  case ILCode.__Ldind_I2:  	code = ILCode.Ldobj;  	operand = methodBody.Method.Module.TypeSystem.Int16;  	break;  case ILCode.__Ldind_I4:  	code = ILCode.Ldobj;  	operand = methodBody.Method.Module.TypeSystem.Int32;  	break;  case ILCode.__Ldind_I8:  	code = ILCode.Ldobj;  	operand = methodBody.Method.Module.TypeSystem.Int64;  	break;  case ILCode.__Ldind_U1:  	code = ILCode.Ldobj;  	operand = methodBody.Method.Module.TypeSystem.Byte;  	break;  case ILCode.__Ldind_U2:  	code = ILCode.Ldobj;  	operand = methodBody.Method.Module.TypeSystem.UInt16;  	break;  case ILCode.__Ldind_U4:  	code = ILCode.Ldobj;  	operand = methodBody.Method.Module.TypeSystem.UInt32;  	break;  case ILCode.__Ldind_R4:  	code = ILCode.Ldobj;  	operand = methodBody.Method.Module.TypeSystem.Single;  	break;  case ILCode.__Ldind_R8:  	code = ILCode.Ldobj;  	operand = methodBody.Method.Module.TypeSystem.Double;  	break;  case ILCode.__Stind_I:  	code = ILCode.Stobj;  	operand = methodBody.Method.Module.TypeSystem.IntPtr;  	break;  case ILCode.__Stind_I1:  	code = ILCode.Stobj;  	operand = methodBody.Method.Module.TypeSystem.Byte;  	break;  case ILCode.__Stind_I2:  	code = ILCode.Stobj;  	operand = methodBody.Method.Module.TypeSystem.Int16;  	break;  case ILCode.__Stind_I4:  	code = ILCode.Stobj;  	operand = methodBody.Method.Module.TypeSystem.Int32;  	break;  case ILCode.__Stind_I8:  	code = ILCode.Stobj;  	operand = methodBody.Method.Module.TypeSystem.Int64;  	break;  case ILCode.__Stind_R4:  	code = ILCode.Stobj;  	operand = methodBody.Method.Module.TypeSystem.Single;  	break;  case ILCode.__Stind_R8:  	code = ILCode.Stobj;  	operand = methodBody.Method.Module.TypeSystem.Double;  	break;  }  
Magic Number,Custom.Decompiler.ILAst,ILCodeUtil,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILCodes.cs,ExpandMacro,The following statement contains a magic number: switch (code) {  case ILCode.__Ldarg_0:  	code = ILCode.__Ldarg;  	operand = methodBody.GetParameter (0);  	break;  case ILCode.__Ldarg_1:  	code = ILCode.__Ldarg;  	operand = methodBody.GetParameter (1);  	break;  case ILCode.__Ldarg_2:  	code = ILCode.__Ldarg;  	operand = methodBody.GetParameter (2);  	break;  case ILCode.__Ldarg_3:  	code = ILCode.__Ldarg;  	operand = methodBody.GetParameter (3);  	break;  case ILCode.__Ldloc_0:  	code = ILCode.Ldloc;  	operand = methodBody.Variables [0];  	break;  case ILCode.__Ldloc_1:  	code = ILCode.Ldloc;  	operand = methodBody.Variables [1];  	break;  case ILCode.__Ldloc_2:  	code = ILCode.Ldloc;  	operand = methodBody.Variables [2];  	break;  case ILCode.__Ldloc_3:  	code = ILCode.Ldloc;  	operand = methodBody.Variables [3];  	break;  case ILCode.__Stloc_0:  	code = ILCode.Stloc;  	operand = methodBody.Variables [0];  	break;  case ILCode.__Stloc_1:  	code = ILCode.Stloc;  	operand = methodBody.Variables [1];  	break;  case ILCode.__Stloc_2:  	code = ILCode.Stloc;  	operand = methodBody.Variables [2];  	break;  case ILCode.__Stloc_3:  	code = ILCode.Stloc;  	operand = methodBody.Variables [3];  	break;  case ILCode.__Ldarg_S:  	code = ILCode.__Ldarg;  	break;  case ILCode.__Ldarga_S:  	code = ILCode.__Ldarga;  	break;  case ILCode.__Starg_S:  	code = ILCode.__Starg;  	break;  case ILCode.__Ldloc_S:  	code = ILCode.Ldloc;  	break;  case ILCode.__Ldloca_S:  	code = ILCode.Ldloca;  	break;  case ILCode.__Stloc_S:  	code = ILCode.Stloc;  	break;  case ILCode.__Ldc_I4_M1:  	code = ILCode.Ldc_I4;  	operand = -1;  	break;  case ILCode.__Ldc_I4_0:  	code = ILCode.Ldc_I4;  	operand = 0;  	break;  case ILCode.__Ldc_I4_1:  	code = ILCode.Ldc_I4;  	operand = 1;  	break;  case ILCode.__Ldc_I4_2:  	code = ILCode.Ldc_I4;  	operand = 2;  	break;  case ILCode.__Ldc_I4_3:  	code = ILCode.Ldc_I4;  	operand = 3;  	break;  case ILCode.__Ldc_I4_4:  	code = ILCode.Ldc_I4;  	operand = 4;  	break;  case ILCode.__Ldc_I4_5:  	code = ILCode.Ldc_I4;  	operand = 5;  	break;  case ILCode.__Ldc_I4_6:  	code = ILCode.Ldc_I4;  	operand = 6;  	break;  case ILCode.__Ldc_I4_7:  	code = ILCode.Ldc_I4;  	operand = 7;  	break;  case ILCode.__Ldc_I4_8:  	code = ILCode.Ldc_I4;  	operand = 8;  	break;  case ILCode.__Ldc_I4_S:  	code = ILCode.Ldc_I4;  	operand = (int)(sbyte)operand;  	break;  case ILCode.__Br_S:  	code = ILCode.Br;  	break;  case ILCode.__Brfalse_S:  	code = ILCode.__Brfalse;  	break;  case ILCode.__Brtrue_S:  	code = ILCode.Brtrue;  	break;  case ILCode.__Beq_S:  	code = ILCode.__Beq;  	break;  case ILCode.__Bge_S:  	code = ILCode.__Bge;  	break;  case ILCode.__Bgt_S:  	code = ILCode.__Bgt;  	break;  case ILCode.__Ble_S:  	code = ILCode.__Ble;  	break;  case ILCode.__Blt_S:  	code = ILCode.__Blt;  	break;  case ILCode.__Bne_Un_S:  	code = ILCode.__Bne_Un;  	break;  case ILCode.__Bge_Un_S:  	code = ILCode.__Bge_Un;  	break;  case ILCode.__Bgt_Un_S:  	code = ILCode.__Bgt_Un;  	break;  case ILCode.__Ble_Un_S:  	code = ILCode.__Ble_Un;  	break;  case ILCode.__Blt_Un_S:  	code = ILCode.__Blt_Un;  	break;  case ILCode.__Leave_S:  	code = ILCode.Leave;  	break;  case ILCode.__Ldind_I:  	code = ILCode.Ldobj;  	operand = methodBody.Method.Module.TypeSystem.IntPtr;  	break;  case ILCode.__Ldind_I1:  	code = ILCode.Ldobj;  	operand = methodBody.Method.Module.TypeSystem.SByte;  	break;  case ILCode.__Ldind_I2:  	code = ILCode.Ldobj;  	operand = methodBody.Method.Module.TypeSystem.Int16;  	break;  case ILCode.__Ldind_I4:  	code = ILCode.Ldobj;  	operand = methodBody.Method.Module.TypeSystem.Int32;  	break;  case ILCode.__Ldind_I8:  	code = ILCode.Ldobj;  	operand = methodBody.Method.Module.TypeSystem.Int64;  	break;  case ILCode.__Ldind_U1:  	code = ILCode.Ldobj;  	operand = methodBody.Method.Module.TypeSystem.Byte;  	break;  case ILCode.__Ldind_U2:  	code = ILCode.Ldobj;  	operand = methodBody.Method.Module.TypeSystem.UInt16;  	break;  case ILCode.__Ldind_U4:  	code = ILCode.Ldobj;  	operand = methodBody.Method.Module.TypeSystem.UInt32;  	break;  case ILCode.__Ldind_R4:  	code = ILCode.Ldobj;  	operand = methodBody.Method.Module.TypeSystem.Single;  	break;  case ILCode.__Ldind_R8:  	code = ILCode.Ldobj;  	operand = methodBody.Method.Module.TypeSystem.Double;  	break;  case ILCode.__Stind_I:  	code = ILCode.Stobj;  	operand = methodBody.Method.Module.TypeSystem.IntPtr;  	break;  case ILCode.__Stind_I1:  	code = ILCode.Stobj;  	operand = methodBody.Method.Module.TypeSystem.Byte;  	break;  case ILCode.__Stind_I2:  	code = ILCode.Stobj;  	operand = methodBody.Method.Module.TypeSystem.Int16;  	break;  case ILCode.__Stind_I4:  	code = ILCode.Stobj;  	operand = methodBody.Method.Module.TypeSystem.Int32;  	break;  case ILCode.__Stind_I8:  	code = ILCode.Stobj;  	operand = methodBody.Method.Module.TypeSystem.Int64;  	break;  case ILCode.__Stind_R4:  	code = ILCode.Stobj;  	operand = methodBody.Method.Module.TypeSystem.Single;  	break;  case ILCode.__Stind_R8:  	code = ILCode.Stobj;  	operand = methodBody.Method.Module.TypeSystem.Double;  	break;  }  
Magic Number,Custom.Decompiler.ILAst,ILCodeUtil,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILCodes.cs,ExpandMacro,The following statement contains a magic number: switch (code) {  case ILCode.__Ldarg_0:  	code = ILCode.__Ldarg;  	operand = methodBody.GetParameter (0);  	break;  case ILCode.__Ldarg_1:  	code = ILCode.__Ldarg;  	operand = methodBody.GetParameter (1);  	break;  case ILCode.__Ldarg_2:  	code = ILCode.__Ldarg;  	operand = methodBody.GetParameter (2);  	break;  case ILCode.__Ldarg_3:  	code = ILCode.__Ldarg;  	operand = methodBody.GetParameter (3);  	break;  case ILCode.__Ldloc_0:  	code = ILCode.Ldloc;  	operand = methodBody.Variables [0];  	break;  case ILCode.__Ldloc_1:  	code = ILCode.Ldloc;  	operand = methodBody.Variables [1];  	break;  case ILCode.__Ldloc_2:  	code = ILCode.Ldloc;  	operand = methodBody.Variables [2];  	break;  case ILCode.__Ldloc_3:  	code = ILCode.Ldloc;  	operand = methodBody.Variables [3];  	break;  case ILCode.__Stloc_0:  	code = ILCode.Stloc;  	operand = methodBody.Variables [0];  	break;  case ILCode.__Stloc_1:  	code = ILCode.Stloc;  	operand = methodBody.Variables [1];  	break;  case ILCode.__Stloc_2:  	code = ILCode.Stloc;  	operand = methodBody.Variables [2];  	break;  case ILCode.__Stloc_3:  	code = ILCode.Stloc;  	operand = methodBody.Variables [3];  	break;  case ILCode.__Ldarg_S:  	code = ILCode.__Ldarg;  	break;  case ILCode.__Ldarga_S:  	code = ILCode.__Ldarga;  	break;  case ILCode.__Starg_S:  	code = ILCode.__Starg;  	break;  case ILCode.__Ldloc_S:  	code = ILCode.Ldloc;  	break;  case ILCode.__Ldloca_S:  	code = ILCode.Ldloca;  	break;  case ILCode.__Stloc_S:  	code = ILCode.Stloc;  	break;  case ILCode.__Ldc_I4_M1:  	code = ILCode.Ldc_I4;  	operand = -1;  	break;  case ILCode.__Ldc_I4_0:  	code = ILCode.Ldc_I4;  	operand = 0;  	break;  case ILCode.__Ldc_I4_1:  	code = ILCode.Ldc_I4;  	operand = 1;  	break;  case ILCode.__Ldc_I4_2:  	code = ILCode.Ldc_I4;  	operand = 2;  	break;  case ILCode.__Ldc_I4_3:  	code = ILCode.Ldc_I4;  	operand = 3;  	break;  case ILCode.__Ldc_I4_4:  	code = ILCode.Ldc_I4;  	operand = 4;  	break;  case ILCode.__Ldc_I4_5:  	code = ILCode.Ldc_I4;  	operand = 5;  	break;  case ILCode.__Ldc_I4_6:  	code = ILCode.Ldc_I4;  	operand = 6;  	break;  case ILCode.__Ldc_I4_7:  	code = ILCode.Ldc_I4;  	operand = 7;  	break;  case ILCode.__Ldc_I4_8:  	code = ILCode.Ldc_I4;  	operand = 8;  	break;  case ILCode.__Ldc_I4_S:  	code = ILCode.Ldc_I4;  	operand = (int)(sbyte)operand;  	break;  case ILCode.__Br_S:  	code = ILCode.Br;  	break;  case ILCode.__Brfalse_S:  	code = ILCode.__Brfalse;  	break;  case ILCode.__Brtrue_S:  	code = ILCode.Brtrue;  	break;  case ILCode.__Beq_S:  	code = ILCode.__Beq;  	break;  case ILCode.__Bge_S:  	code = ILCode.__Bge;  	break;  case ILCode.__Bgt_S:  	code = ILCode.__Bgt;  	break;  case ILCode.__Ble_S:  	code = ILCode.__Ble;  	break;  case ILCode.__Blt_S:  	code = ILCode.__Blt;  	break;  case ILCode.__Bne_Un_S:  	code = ILCode.__Bne_Un;  	break;  case ILCode.__Bge_Un_S:  	code = ILCode.__Bge_Un;  	break;  case ILCode.__Bgt_Un_S:  	code = ILCode.__Bgt_Un;  	break;  case ILCode.__Ble_Un_S:  	code = ILCode.__Ble_Un;  	break;  case ILCode.__Blt_Un_S:  	code = ILCode.__Blt_Un;  	break;  case ILCode.__Leave_S:  	code = ILCode.Leave;  	break;  case ILCode.__Ldind_I:  	code = ILCode.Ldobj;  	operand = methodBody.Method.Module.TypeSystem.IntPtr;  	break;  case ILCode.__Ldind_I1:  	code = ILCode.Ldobj;  	operand = methodBody.Method.Module.TypeSystem.SByte;  	break;  case ILCode.__Ldind_I2:  	code = ILCode.Ldobj;  	operand = methodBody.Method.Module.TypeSystem.Int16;  	break;  case ILCode.__Ldind_I4:  	code = ILCode.Ldobj;  	operand = methodBody.Method.Module.TypeSystem.Int32;  	break;  case ILCode.__Ldind_I8:  	code = ILCode.Ldobj;  	operand = methodBody.Method.Module.TypeSystem.Int64;  	break;  case ILCode.__Ldind_U1:  	code = ILCode.Ldobj;  	operand = methodBody.Method.Module.TypeSystem.Byte;  	break;  case ILCode.__Ldind_U2:  	code = ILCode.Ldobj;  	operand = methodBody.Method.Module.TypeSystem.UInt16;  	break;  case ILCode.__Ldind_U4:  	code = ILCode.Ldobj;  	operand = methodBody.Method.Module.TypeSystem.UInt32;  	break;  case ILCode.__Ldind_R4:  	code = ILCode.Ldobj;  	operand = methodBody.Method.Module.TypeSystem.Single;  	break;  case ILCode.__Ldind_R8:  	code = ILCode.Ldobj;  	operand = methodBody.Method.Module.TypeSystem.Double;  	break;  case ILCode.__Stind_I:  	code = ILCode.Stobj;  	operand = methodBody.Method.Module.TypeSystem.IntPtr;  	break;  case ILCode.__Stind_I1:  	code = ILCode.Stobj;  	operand = methodBody.Method.Module.TypeSystem.Byte;  	break;  case ILCode.__Stind_I2:  	code = ILCode.Stobj;  	operand = methodBody.Method.Module.TypeSystem.Int16;  	break;  case ILCode.__Stind_I4:  	code = ILCode.Stobj;  	operand = methodBody.Method.Module.TypeSystem.Int32;  	break;  case ILCode.__Stind_I8:  	code = ILCode.Stobj;  	operand = methodBody.Method.Module.TypeSystem.Int64;  	break;  case ILCode.__Stind_R4:  	code = ILCode.Stobj;  	operand = methodBody.Method.Module.TypeSystem.Single;  	break;  case ILCode.__Stind_R8:  	code = ILCode.Stobj;  	operand = methodBody.Method.Module.TypeSystem.Double;  	break;  }  
Magic Number,Custom.Decompiler.ILAst,ILCodeUtil,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILCodes.cs,ExpandMacro,The following statement contains a magic number: switch (code) {  case ILCode.__Ldarg_0:  	code = ILCode.__Ldarg;  	operand = methodBody.GetParameter (0);  	break;  case ILCode.__Ldarg_1:  	code = ILCode.__Ldarg;  	operand = methodBody.GetParameter (1);  	break;  case ILCode.__Ldarg_2:  	code = ILCode.__Ldarg;  	operand = methodBody.GetParameter (2);  	break;  case ILCode.__Ldarg_3:  	code = ILCode.__Ldarg;  	operand = methodBody.GetParameter (3);  	break;  case ILCode.__Ldloc_0:  	code = ILCode.Ldloc;  	operand = methodBody.Variables [0];  	break;  case ILCode.__Ldloc_1:  	code = ILCode.Ldloc;  	operand = methodBody.Variables [1];  	break;  case ILCode.__Ldloc_2:  	code = ILCode.Ldloc;  	operand = methodBody.Variables [2];  	break;  case ILCode.__Ldloc_3:  	code = ILCode.Ldloc;  	operand = methodBody.Variables [3];  	break;  case ILCode.__Stloc_0:  	code = ILCode.Stloc;  	operand = methodBody.Variables [0];  	break;  case ILCode.__Stloc_1:  	code = ILCode.Stloc;  	operand = methodBody.Variables [1];  	break;  case ILCode.__Stloc_2:  	code = ILCode.Stloc;  	operand = methodBody.Variables [2];  	break;  case ILCode.__Stloc_3:  	code = ILCode.Stloc;  	operand = methodBody.Variables [3];  	break;  case ILCode.__Ldarg_S:  	code = ILCode.__Ldarg;  	break;  case ILCode.__Ldarga_S:  	code = ILCode.__Ldarga;  	break;  case ILCode.__Starg_S:  	code = ILCode.__Starg;  	break;  case ILCode.__Ldloc_S:  	code = ILCode.Ldloc;  	break;  case ILCode.__Ldloca_S:  	code = ILCode.Ldloca;  	break;  case ILCode.__Stloc_S:  	code = ILCode.Stloc;  	break;  case ILCode.__Ldc_I4_M1:  	code = ILCode.Ldc_I4;  	operand = -1;  	break;  case ILCode.__Ldc_I4_0:  	code = ILCode.Ldc_I4;  	operand = 0;  	break;  case ILCode.__Ldc_I4_1:  	code = ILCode.Ldc_I4;  	operand = 1;  	break;  case ILCode.__Ldc_I4_2:  	code = ILCode.Ldc_I4;  	operand = 2;  	break;  case ILCode.__Ldc_I4_3:  	code = ILCode.Ldc_I4;  	operand = 3;  	break;  case ILCode.__Ldc_I4_4:  	code = ILCode.Ldc_I4;  	operand = 4;  	break;  case ILCode.__Ldc_I4_5:  	code = ILCode.Ldc_I4;  	operand = 5;  	break;  case ILCode.__Ldc_I4_6:  	code = ILCode.Ldc_I4;  	operand = 6;  	break;  case ILCode.__Ldc_I4_7:  	code = ILCode.Ldc_I4;  	operand = 7;  	break;  case ILCode.__Ldc_I4_8:  	code = ILCode.Ldc_I4;  	operand = 8;  	break;  case ILCode.__Ldc_I4_S:  	code = ILCode.Ldc_I4;  	operand = (int)(sbyte)operand;  	break;  case ILCode.__Br_S:  	code = ILCode.Br;  	break;  case ILCode.__Brfalse_S:  	code = ILCode.__Brfalse;  	break;  case ILCode.__Brtrue_S:  	code = ILCode.Brtrue;  	break;  case ILCode.__Beq_S:  	code = ILCode.__Beq;  	break;  case ILCode.__Bge_S:  	code = ILCode.__Bge;  	break;  case ILCode.__Bgt_S:  	code = ILCode.__Bgt;  	break;  case ILCode.__Ble_S:  	code = ILCode.__Ble;  	break;  case ILCode.__Blt_S:  	code = ILCode.__Blt;  	break;  case ILCode.__Bne_Un_S:  	code = ILCode.__Bne_Un;  	break;  case ILCode.__Bge_Un_S:  	code = ILCode.__Bge_Un;  	break;  case ILCode.__Bgt_Un_S:  	code = ILCode.__Bgt_Un;  	break;  case ILCode.__Ble_Un_S:  	code = ILCode.__Ble_Un;  	break;  case ILCode.__Blt_Un_S:  	code = ILCode.__Blt_Un;  	break;  case ILCode.__Leave_S:  	code = ILCode.Leave;  	break;  case ILCode.__Ldind_I:  	code = ILCode.Ldobj;  	operand = methodBody.Method.Module.TypeSystem.IntPtr;  	break;  case ILCode.__Ldind_I1:  	code = ILCode.Ldobj;  	operand = methodBody.Method.Module.TypeSystem.SByte;  	break;  case ILCode.__Ldind_I2:  	code = ILCode.Ldobj;  	operand = methodBody.Method.Module.TypeSystem.Int16;  	break;  case ILCode.__Ldind_I4:  	code = ILCode.Ldobj;  	operand = methodBody.Method.Module.TypeSystem.Int32;  	break;  case ILCode.__Ldind_I8:  	code = ILCode.Ldobj;  	operand = methodBody.Method.Module.TypeSystem.Int64;  	break;  case ILCode.__Ldind_U1:  	code = ILCode.Ldobj;  	operand = methodBody.Method.Module.TypeSystem.Byte;  	break;  case ILCode.__Ldind_U2:  	code = ILCode.Ldobj;  	operand = methodBody.Method.Module.TypeSystem.UInt16;  	break;  case ILCode.__Ldind_U4:  	code = ILCode.Ldobj;  	operand = methodBody.Method.Module.TypeSystem.UInt32;  	break;  case ILCode.__Ldind_R4:  	code = ILCode.Ldobj;  	operand = methodBody.Method.Module.TypeSystem.Single;  	break;  case ILCode.__Ldind_R8:  	code = ILCode.Ldobj;  	operand = methodBody.Method.Module.TypeSystem.Double;  	break;  case ILCode.__Stind_I:  	code = ILCode.Stobj;  	operand = methodBody.Method.Module.TypeSystem.IntPtr;  	break;  case ILCode.__Stind_I1:  	code = ILCode.Stobj;  	operand = methodBody.Method.Module.TypeSystem.Byte;  	break;  case ILCode.__Stind_I2:  	code = ILCode.Stobj;  	operand = methodBody.Method.Module.TypeSystem.Int16;  	break;  case ILCode.__Stind_I4:  	code = ILCode.Stobj;  	operand = methodBody.Method.Module.TypeSystem.Int32;  	break;  case ILCode.__Stind_I8:  	code = ILCode.Stobj;  	operand = methodBody.Method.Module.TypeSystem.Int64;  	break;  case ILCode.__Stind_R4:  	code = ILCode.Stobj;  	operand = methodBody.Method.Module.TypeSystem.Single;  	break;  case ILCode.__Stind_R8:  	code = ILCode.Stobj;  	operand = methodBody.Method.Module.TypeSystem.Double;  	break;  }  
Magic Number,Custom.Decompiler.ILAst,ILCodeUtil,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILCodes.cs,ExpandMacro,The following statement contains a magic number: operand = methodBody.GetParameter (2);  
Magic Number,Custom.Decompiler.ILAst,ILCodeUtil,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILCodes.cs,ExpandMacro,The following statement contains a magic number: operand = methodBody.GetParameter (3);  
Magic Number,Custom.Decompiler.ILAst,ILCodeUtil,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILCodes.cs,ExpandMacro,The following statement contains a magic number: operand = methodBody.Variables [2];  
Magic Number,Custom.Decompiler.ILAst,ILCodeUtil,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILCodes.cs,ExpandMacro,The following statement contains a magic number: operand = methodBody.Variables [3];  
Magic Number,Custom.Decompiler.ILAst,ILCodeUtil,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILCodes.cs,ExpandMacro,The following statement contains a magic number: operand = methodBody.Variables [2];  
Magic Number,Custom.Decompiler.ILAst,ILCodeUtil,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILCodes.cs,ExpandMacro,The following statement contains a magic number: operand = methodBody.Variables [3];  
Magic Number,Custom.Decompiler.ILAst,ILCodeUtil,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILCodes.cs,ExpandMacro,The following statement contains a magic number: operand = 2;  
Magic Number,Custom.Decompiler.ILAst,ILCodeUtil,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILCodes.cs,ExpandMacro,The following statement contains a magic number: operand = 3;  
Magic Number,Custom.Decompiler.ILAst,ILCodeUtil,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILCodes.cs,ExpandMacro,The following statement contains a magic number: operand = 4;  
Magic Number,Custom.Decompiler.ILAst,ILCodeUtil,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILCodes.cs,ExpandMacro,The following statement contains a magic number: operand = 5;  
Magic Number,Custom.Decompiler.ILAst,ILCodeUtil,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILCodes.cs,ExpandMacro,The following statement contains a magic number: operand = 6;  
Magic Number,Custom.Decompiler.ILAst,ILCodeUtil,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILCodes.cs,ExpandMacro,The following statement contains a magic number: operand = 7;  
Magic Number,Custom.Decompiler.ILAst,ILCodeUtil,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILCodes.cs,ExpandMacro,The following statement contains a magic number: operand = 8;  
Magic Number,Custom.Decompiler.ILAst,LoopsAndConditions,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\LoopsAndConditions.cs,FindLoops,The following statement contains a magic number: if (block.Body.Count > 0) {  	ControlFlowGraph graph;  	graph = BuildGraph (block.Body' (ILLabel)block.EntryGoto.Operand);  	graph.ComputeDominance (context.CancellationToken);  	graph.ComputeDominanceFrontier ();  	block.Body = FindLoops (new HashSet<ControlFlowNode> (graph.Nodes.Skip (3))' graph.EntryPoint' false);  }  
Magic Number,Custom.Decompiler.ILAst,LoopsAndConditions,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\LoopsAndConditions.cs,FindLoops,The following statement contains a magic number: block.Body = FindLoops (new HashSet<ControlFlowNode> (graph.Nodes.Skip (3))' graph.EntryPoint' false);  
Magic Number,Custom.Decompiler.ILAst,LoopsAndConditions,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\LoopsAndConditions.cs,FindConditions,The following statement contains a magic number: if (block.Body.Count > 0) {  	ControlFlowGraph graph;  	graph = BuildGraph (block.Body' (ILLabel)block.EntryGoto.Operand);  	graph.ComputeDominance (context.CancellationToken);  	graph.ComputeDominanceFrontier ();  	block.Body = FindConditions (new HashSet<ControlFlowNode> (graph.Nodes.Skip (3))' graph.EntryPoint);  }  
Magic Number,Custom.Decompiler.ILAst,LoopsAndConditions,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\LoopsAndConditions.cs,FindConditions,The following statement contains a magic number: block.Body = FindConditions (new HashSet<ControlFlowNode> (graph.Nodes.Skip (3))' graph.EntryPoint);  
Magic Number,Custom.Decompiler.ILAst,PatternMatching,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\PatternMatching.cs,Match,The following statement contains a magic number: if (node.Match (code' out operand' out args) && args.Count == 2) {  	arg1 = args [0];  	arg2 = args [1];  	return true;  }  
Magic Number,Custom.Decompiler.ILAst,PatternMatching,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\PatternMatching.cs,MatchSingle,The following statement contains a magic number: if (bb.Body.Count == 2 && bb.Body [0] is ILLabel && bb.Body [1].Match (code' out operand' out arg)) {  	return true;  }  
Magic Number,Custom.Decompiler.ILAst,PatternMatching,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\PatternMatching.cs,MatchSingleAndBr,The following statement contains a magic number: if (bb.Body.Count == 3 && bb.Body [0] is ILLabel && bb.Body [1].Match (code' out operand' out arg) && bb.Body [2].Match (ILCode.Br' out brLabel)) {  	return true;  }  
Magic Number,Custom.Decompiler.ILAst,PatternMatching,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\PatternMatching.cs,MatchSingleAndBr,The following statement contains a magic number: if (bb.Body.Count == 3 && bb.Body [0] is ILLabel && bb.Body [1].Match (code' out operand' out arg) && bb.Body [2].Match (ILCode.Br' out brLabel)) {  	return true;  }  
Magic Number,Custom.Decompiler.ILAst,PatternMatching,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\PatternMatching.cs,MatchLastAndBr,The following statement contains a magic number: if (bb.Body.ElementAtOrDefault (bb.Body.Count - 2).Match (code' out operand' out arg) && bb.Body.LastOrDefault ().Match (ILCode.Br' out brLabel)) {  	return true;  }  
Magic Number,Custom.Decompiler.ILAst,SimpleControlFlow,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\SimpleControlFlow.cs,SimplifyNullCoalescing,The following statement contains a magic number: if (head.Body.Count >= 3 && head.Body [head.Body.Count - 3].Match (ILCode.Stloc' out v' out leftExpr) && leftExpr.Match (ILCode.Ldloc' out leftVar) && head.MatchLastAndBr (ILCode.Brtrue' out endBBLabel' out leftExpr2' out rightBBLabel) && leftExpr2.MatchLdloc (leftVar) && labelToBasicBlock.TryGetValue (rightBBLabel' out rightBB) && rightBB.MatchSingleAndBr (ILCode.Stloc' out v2' out rightExpr' out endBBLabel2) && v == v2 && endBBLabel == endBBLabel2 && labelGlobalRefCount.GetOrDefault (rightBBLabel) == 1 && body.Contains (rightBB)) {  	head.Body.RemoveTail (ILCode.Stloc' ILCode.Brtrue' ILCode.Br);  	head.Body.Add (new ILExpression (ILCode.Stloc' v' new ILExpression (ILCode.NullCoalescing' null' leftExpr' rightExpr)));  	head.Body.Add (new ILExpression (ILCode.Br' endBBLabel));  	body.RemoveOrThrow (labelToBasicBlock [rightBBLabel]);  	return true;  }  
Magic Number,Custom.Decompiler.ILAst,SimpleControlFlow,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\SimpleControlFlow.cs,SimplifyNullCoalescing,The following statement contains a magic number: if (head.Body.Count >= 3 && head.Body [head.Body.Count - 3].Match (ILCode.Stloc' out v' out leftExpr) && leftExpr.Match (ILCode.Ldloc' out leftVar) && head.MatchLastAndBr (ILCode.Brtrue' out endBBLabel' out leftExpr2' out rightBBLabel) && leftExpr2.MatchLdloc (leftVar) && labelToBasicBlock.TryGetValue (rightBBLabel' out rightBB) && rightBB.MatchSingleAndBr (ILCode.Stloc' out v2' out rightExpr' out endBBLabel2) && v == v2 && endBBLabel == endBBLabel2 && labelGlobalRefCount.GetOrDefault (rightBBLabel) == 1 && body.Contains (rightBB)) {  	head.Body.RemoveTail (ILCode.Stloc' ILCode.Brtrue' ILCode.Br);  	head.Body.Add (new ILExpression (ILCode.Stloc' v' new ILExpression (ILCode.NullCoalescing' null' leftExpr' rightExpr)));  	head.Body.Add (new ILExpression (ILCode.Br' endBBLabel));  	body.RemoveOrThrow (labelToBasicBlock [rightBBLabel]);  	return true;  }  
Magic Number,Custom.Decompiler.ILAst,SimpleControlFlow,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\SimpleControlFlow.cs,SimplifyShortCircuit,The following statement contains a magic number: if (head.MatchLastAndBr (ILCode.Brtrue' out trueLabel' out condExpr' out falseLabel)) {  	for (int pass = 0; pass < 2; pass++) {  		// On the second pass' swap labels and negate expression of the first branch  		// It is slightly ugly' but much better then copy-pasting this whole block  		ILLabel nextLabel = (pass == 0) ? trueLabel : falseLabel;  		ILLabel otherLablel = (pass == 0) ? falseLabel : trueLabel;  		bool negate = (pass == 1);  		ILBasicBlock nextBasicBlock = labelToBasicBlock [nextLabel];  		ILExpression nextCondExpr;  		ILLabel nextTrueLablel;  		ILLabel nextFalseLabel;  		if (body.Contains (nextBasicBlock) && nextBasicBlock != head && labelGlobalRefCount [(ILLabel)nextBasicBlock.Body.First ()] == 1 && nextBasicBlock.MatchSingleAndBr (ILCode.Brtrue' out nextTrueLablel' out nextCondExpr' out nextFalseLabel) && (otherLablel == nextFalseLabel || otherLablel == nextTrueLablel)) {  			// Create short cicuit branch  			ILExpression logicExpr;  			if (otherLablel == nextFalseLabel) {  				logicExpr = MakeLeftAssociativeShortCircuit (ILCode.LogicAnd' negate ? new ILExpression (ILCode.LogicNot' null' condExpr) : condExpr' nextCondExpr);  			} else {  				logicExpr = MakeLeftAssociativeShortCircuit (ILCode.LogicOr' negate ? condExpr : new ILExpression (ILCode.LogicNot' null' condExpr)' nextCondExpr);  			}  			head.Body.RemoveTail (ILCode.Brtrue' ILCode.Br);  			head.Body.Add (new ILExpression (ILCode.Brtrue' nextTrueLablel' logicExpr));  			head.Body.Add (new ILExpression (ILCode.Br' nextFalseLabel));  			// Remove the inlined branch from scope  			body.RemoveOrThrow (nextBasicBlock);  			return true;  		}  	}  }  
Magic Number,Custom.Decompiler.ILAst,SimpleControlFlow,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\SimpleControlFlow.cs,SimplifyShortCircuit,The following statement contains a magic number: for (int pass = 0; pass < 2; pass++) {  	// On the second pass' swap labels and negate expression of the first branch  	// It is slightly ugly' but much better then copy-pasting this whole block  	ILLabel nextLabel = (pass == 0) ? trueLabel : falseLabel;  	ILLabel otherLablel = (pass == 0) ? falseLabel : trueLabel;  	bool negate = (pass == 1);  	ILBasicBlock nextBasicBlock = labelToBasicBlock [nextLabel];  	ILExpression nextCondExpr;  	ILLabel nextTrueLablel;  	ILLabel nextFalseLabel;  	if (body.Contains (nextBasicBlock) && nextBasicBlock != head && labelGlobalRefCount [(ILLabel)nextBasicBlock.Body.First ()] == 1 && nextBasicBlock.MatchSingleAndBr (ILCode.Brtrue' out nextTrueLablel' out nextCondExpr' out nextFalseLabel) && (otherLablel == nextFalseLabel || otherLablel == nextTrueLablel)) {  		// Create short cicuit branch  		ILExpression logicExpr;  		if (otherLablel == nextFalseLabel) {  			logicExpr = MakeLeftAssociativeShortCircuit (ILCode.LogicAnd' negate ? new ILExpression (ILCode.LogicNot' null' condExpr) : condExpr' nextCondExpr);  		} else {  			logicExpr = MakeLeftAssociativeShortCircuit (ILCode.LogicOr' negate ? condExpr : new ILExpression (ILCode.LogicNot' null' condExpr)' nextCondExpr);  		}  		head.Body.RemoveTail (ILCode.Brtrue' ILCode.Br);  		head.Body.Add (new ILExpression (ILCode.Brtrue' nextTrueLablel' logicExpr));  		head.Body.Add (new ILExpression (ILCode.Br' nextFalseLabel));  		// Remove the inlined branch from scope  		body.RemoveOrThrow (nextBasicBlock);  		return true;  	}  }  
Magic Number,Custom.Decompiler.ILAst,SimpleControlFlow,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\SimpleControlFlow.cs,SimplifyCustomShortCircuit,The following statement contains a magic number: if (head.Body.Count < 3)  	return false;  
Magic Number,Custom.Decompiler.ILAst,SimpleControlFlow,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\SimpleControlFlow.cs,SimplifyCustomShortCircuit,The following statement contains a magic number: if (!head.Body [head.Body.Count - 3].Match (ILCode.Stloc' out targetVar' out targetVarInitExpr))  	return false;  
Magic Number,Custom.Decompiler.ILAst,SimpleControlFlow,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\SimpleControlFlow.cs,JoinBasicBlocks,The following statement contains a magic number: if (!head.Body.ElementAtOrDefault (head.Body.Count - 2).IsConditionalControlFlow () && head.Body.Last ().Match (ILCode.Br' out nextLabel) && labelGlobalRefCount [nextLabel] == 1 && labelToBasicBlock.TryGetValue (nextLabel' out nextBB) && body.Contains (nextBB) && nextBB.Body.First () == nextLabel && !nextBB.Body.OfType<ILTryCatchBlock> ().Any ()) {  	head.Body.RemoveTail (ILCode.Br);  	nextBB.Body.RemoveAt (0);  	// Remove label  	head.Body.AddRange (nextBB.Body);  	body.RemoveOrThrow (nextBB);  	return true;  }  
Magic Number,Custom.Decompiler.ILAst,StateRange,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\StateRange.cs,Simplify,The following statement contains a magic number: if (data.Count < 2)  	return;  
Magic Number,Custom.Decompiler.ILAst,TypeAnalysis,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\TypeAnalysis.cs,DoInferTypeForExpression,The following statement contains a magic number: switch (expr.Code) {  #region Logical operators  case ILCode.LogicNot:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments.Single ()' typeSystem.Boolean);  	}  	return typeSystem.Boolean;  case ILCode.LogicAnd:  case ILCode.LogicOr:  	// if Operand is set the logic and/or expression is a custom operator  	// we can deal with it the same as a normal invocation.  	if (expr.Operand != null)  		goto case ILCode.Call;  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' typeSystem.Boolean);  		InferTypeForExpression (expr.Arguments [1]' typeSystem.Boolean);  	}  	return typeSystem.Boolean;  case ILCode.TernaryOp:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' typeSystem.Boolean);  	}  	return InferBinaryArguments (expr.Arguments [1]' expr.Arguments [2]' expectedType' forceInferChildren);  case ILCode.NullCoalescing:  	return InferBinaryArguments (expr.Arguments [0]' expr.Arguments [1]' expectedType' forceInferChildren);  #endregion  #region Variable load/store  case ILCode.Stloc: {  	ILVariable v = (ILVariable)expr.Operand;  	if (forceInferChildren) {  		// do not use 'expectedType' in here!  		InferTypeForExpression (expr.Arguments.Single ()' v.Type);  	}  	return v.Type;  }  case ILCode.Ldloc: {  	ILVariable v = (ILVariable)expr.Operand;  	if (v.Type == null && singleLoadVariables.Contains (v)) {  		v.Type = expectedType;  	}  	return v.Type;  }  case ILCode.Ldloca: {  	ILVariable v = (ILVariable)expr.Operand;  	if (v.Type != null)  		return new ByReferenceType (v.Type);  	else  		return null;  }  #endregion  #region Call / NewObj  case ILCode.Call:  case ILCode.Callvirt:  case ILCode.CallGetter:  case ILCode.CallvirtGetter:  case ILCode.CallSetter:  case ILCode.CallvirtSetter: {  	MethodReference method = (MethodReference)expr.Operand;  	if (forceInferChildren) {  		for (int i = 0; i < expr.Arguments.Count; i++) {  			if (i == 0 && method.HasThis) {  				InferTypeForExpression (expr.Arguments [0]' MakeRefIfValueType (method.DeclaringType' expr.GetPrefix (ILCode.Constrained)));  			} else {  				InferTypeForExpression (expr.Arguments [i]' SubstituteTypeArgs (method.Parameters [method.HasThis ? i - 1 : i].ParameterType' method));  			}  		}  	}  	if (expr.Code == ILCode.CallSetter || expr.Code == ILCode.CallvirtSetter) {  		return SubstituteTypeArgs (method.Parameters.Last ().ParameterType' method);  	} else {  		return SubstituteTypeArgs (method.ReturnType' method);  	}  }  case ILCode.Newobj: {  	MethodReference ctor = (MethodReference)expr.Operand;  	if (forceInferChildren) {  		for (int i = 0; i < ctor.Parameters.Count; i++) {  			InferTypeForExpression (expr.Arguments [i]' SubstituteTypeArgs (ctor.Parameters [i].ParameterType' ctor));  		}  	}  	return ctor.DeclaringType;  }  case ILCode.InitObject:  case ILCode.InitCollection:  	return InferTypeForExpression (expr.Arguments [0]' expectedType);  case ILCode.InitializedObject:  	// expectedType should always be known due to the parent method call / property setter  	Debug.Assert (expectedType != null);  	return expectedType;  #endregion  #region Load/Store Fields  case ILCode.Ldfld:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' MakeRefIfValueType (((FieldReference)expr.Operand).DeclaringType' expr.GetPrefix (ILCode.Constrained)));  	}  	return GetFieldType ((FieldReference)expr.Operand);  case ILCode.Ldsfld:  	return GetFieldType ((FieldReference)expr.Operand);  case ILCode.Ldflda:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' MakeRefIfValueType (((FieldReference)expr.Operand).DeclaringType' expr.GetPrefix (ILCode.Constrained)));  	}  	return new ByReferenceType (GetFieldType ((FieldReference)expr.Operand));  case ILCode.Ldsflda:  	return new ByReferenceType (GetFieldType ((FieldReference)expr.Operand));  case ILCode.Stfld:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' MakeRefIfValueType (((FieldReference)expr.Operand).DeclaringType' expr.GetPrefix (ILCode.Constrained)));  		InferTypeForExpression (expr.Arguments [1]' GetFieldType ((FieldReference)expr.Operand));  	}  	return GetFieldType ((FieldReference)expr.Operand);  case ILCode.Stsfld:  	if (forceInferChildren)  		InferTypeForExpression (expr.Arguments [0]' GetFieldType ((FieldReference)expr.Operand));  	return GetFieldType ((FieldReference)expr.Operand);  #endregion  #region Reference/Pointer instructions  case ILCode.Ldind_Ref:  	return UnpackPointer (InferTypeForExpression (expr.Arguments [0]' null));  case ILCode.Stind_Ref:  	if (forceInferChildren) {  		TypeReference elementType = UnpackPointer (InferTypeForExpression (expr.Arguments [0]' null));  		InferTypeForExpression (expr.Arguments [1]' elementType);  	}  	return null;  case ILCode.Ldobj: {  	TypeReference type = (TypeReference)expr.Operand;  	var argType = InferTypeForExpression (expr.Arguments [0]' null);  	if (argType is PointerType || argType is ByReferenceType) {  		var elementType = ((TypeSpecification)argType).ElementType;  		int infoAmount = GetInformationAmount (elementType);  		if (infoAmount == 1 && GetInformationAmount (type) == 8) {  			// A bool can be loaded from both bytes and sbytes.  			type = elementType;  		}  		if (infoAmount >= 8 && infoAmount <= 64 && infoAmount == GetInformationAmount (type)) {  			// An integer can be loaded as another integer of the same size.  			// For integers smaller than 32 bit' the signs must match (as loading performs sign extension)  			bool? elementTypeIsSigned = IsSigned (elementType);  			bool? typeIsSigned = IsSigned (type);  			if (elementTypeIsSigned != null && typeIsSigned != null) {  				if (infoAmount >= 32 || elementTypeIsSigned == typeIsSigned)  					type = elementType;  			}  		}  	}  	if (argType is PointerType)  		InferTypeForExpression (expr.Arguments [0]' new PointerType (type));  	else  		InferTypeForExpression (expr.Arguments [0]' new ByReferenceType (type));  	return type;  }  case ILCode.Stobj: {  	TypeReference operandType = (TypeReference)expr.Operand;  	TypeReference pointerType = InferTypeForExpression (expr.Arguments [0]' new ByReferenceType (operandType));  	TypeReference elementType;  	if (pointerType is PointerType)  		elementType = ((PointerType)pointerType).ElementType;  	else if (pointerType is ByReferenceType)  		elementType = ((ByReferenceType)pointerType).ElementType;  	else  		elementType = null;  	if (elementType != null) {  		// An integer can be stored in any other integer of the same size.  		int infoAmount = GetInformationAmount (elementType);  		if (infoAmount == 1 && GetInformationAmount (operandType) == 8)  			operandType = elementType;  		else if (infoAmount == GetInformationAmount (operandType) && IsSigned (elementType) != null && IsSigned (operandType) != null)  			operandType = elementType;  	}  	if (forceInferChildren) {  		if (pointerType is PointerType)  			InferTypeForExpression (expr.Arguments [0]' new PointerType (operandType));  		else if (!IsSameType (operandType' expr.Operand as TypeReference))  			InferTypeForExpression (expr.Arguments [0]' new ByReferenceType (operandType));  		InferTypeForExpression (expr.Arguments [1]' operandType);  	}  	return operandType;  }  case ILCode.Initobj:  	return null;  case ILCode.DefaultValue:  	return (TypeReference)expr.Operand;  case ILCode.Localloc:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' typeSystem.Int32);  	}  	if (expectedType is PointerType)  		return expectedType;  	else  		return typeSystem.IntPtr;  case ILCode.Sizeof:  	return typeSystem.Int32;  case ILCode.PostIncrement:  case ILCode.PostIncrement_Ovf:  case ILCode.PostIncrement_Ovf_Un: {  	TypeReference elementType = UnpackPointer (InferTypeForExpression (expr.Arguments [0]' null));  	if (forceInferChildren && elementType != null) {  		// Assign expected type to the child expression  		InferTypeForExpression (expr.Arguments [0]' new ByReferenceType (elementType));  	}  	return elementType;  }  case ILCode.Mkrefany:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' (TypeReference)expr.Operand);  	}  	return typeSystem.TypedReference;  case ILCode.Refanytype:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' typeSystem.TypedReference);  	}  	return new TypeReference ("System"' "RuntimeTypeHandle"' module' module.TypeSystem.CoreLibrary' true);  case ILCode.Refanyval:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' typeSystem.TypedReference);  	}  	return new ByReferenceType ((TypeReference)expr.Operand);  case ILCode.AddressOf: {  	TypeReference t = InferTypeForExpression (expr.Arguments [0]' UnpackPointer (expectedType));  	return t != null ? new ByReferenceType (t) : null;  }  case ILCode.ValueOf:  	return GetNullableTypeArgument (InferTypeForExpression (expr.Arguments [0]' CreateNullableType (expectedType)));  case ILCode.NullableOf:  	return CreateNullableType (InferTypeForExpression (expr.Arguments [0]' GetNullableTypeArgument (expectedType)));  #endregion  #region Arithmetic instructions  case ILCode.Not:  // bitwise complement  case ILCode.Neg:  	return InferTypeForExpression (expr.Arguments.Single ()' expectedType);  case ILCode.Add:  	return InferArgumentsInAddition (expr' null' expectedType);  case ILCode.Sub:  	return InferArgumentsInSubtraction (expr' null' expectedType);  case ILCode.Mul:  case ILCode.Or:  case ILCode.And:  case ILCode.Xor:  	return InferArgumentsInBinaryOperator (expr' null' expectedType);  case ILCode.Add_Ovf:  	return InferArgumentsInAddition (expr' true' expectedType);  case ILCode.Sub_Ovf:  	return InferArgumentsInSubtraction (expr' true' expectedType);  case ILCode.Mul_Ovf:  case ILCode.Div:  case ILCode.Rem:  	return InferArgumentsInBinaryOperator (expr' true' expectedType);  case ILCode.Add_Ovf_Un:  	return InferArgumentsInAddition (expr' false' expectedType);  case ILCode.Sub_Ovf_Un:  	return InferArgumentsInSubtraction (expr' false' expectedType);  case ILCode.Mul_Ovf_Un:  case ILCode.Div_Un:  case ILCode.Rem_Un:  	return InferArgumentsInBinaryOperator (expr' false' expectedType);  case ILCode.Shl:  	if (forceInferChildren)  		InferTypeForExpression (expr.Arguments [1]' typeSystem.Int32);  	if (expectedType != null && (expectedType.MetadataType == MetadataType.Int32 || expectedType.MetadataType == MetadataType.UInt32 || expectedType.MetadataType == MetadataType.Int64 || expectedType.MetadataType == MetadataType.UInt64))  		return NumericPromotion (InferTypeForExpression (expr.Arguments [0]' expectedType));  	else  		return NumericPromotion (InferTypeForExpression (expr.Arguments [0]' null));  case ILCode.Shr:  case ILCode.Shr_Un: {  	if (forceInferChildren)  		InferTypeForExpression (expr.Arguments [1]' typeSystem.Int32);  	TypeReference type = NumericPromotion (InferTypeForExpression (expr.Arguments [0]' null));  	TypeReference expectedInputType = null;  	switch (type.MetadataType) {  	case MetadataType.Int32:  		if (expr.Code == ILCode.Shr_Un)  			expectedInputType = typeSystem.UInt32;  		break;  	case MetadataType.UInt32:  		if (expr.Code == ILCode.Shr)  			expectedInputType = typeSystem.Int32;  		break;  	case MetadataType.Int64:  		if (expr.Code == ILCode.Shr_Un)  			expectedInputType = typeSystem.UInt64;  		break;  	case MetadataType.UInt64:  		if (expr.Code == ILCode.Shr)  			expectedInputType = typeSystem.UInt64;  		break;  	}  	if (expectedInputType != null) {  		InferTypeForExpression (expr.Arguments [0]' expectedInputType);  		return expectedInputType;  	} else {  		return type;  	}  }  case ILCode.CompoundAssignment: {  	var op = expr.Arguments [0];  	if (op.Code == ILCode.NullableOf)  		op = op.Arguments [0].Arguments [0];  	var varType = InferTypeForExpression (op.Arguments [0]' null);  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' varType);  	}  	return varType;  }  #endregion  #region Constant loading instructions  case ILCode.Ldnull:  	return typeSystem.Object;  case ILCode.Ldstr:  	return typeSystem.String;  case ILCode.Ldftn:  case ILCode.Ldvirtftn:  	return typeSystem.IntPtr;  case ILCode.Ldc_I4:  	if (IsBoolean (expectedType) && ((int)expr.Operand == 0 || (int)expr.Operand == 1))  		return typeSystem.Boolean;  	if (expectedType is PointerType && (int)expr.Operand == 0)  		return expectedType;  	if (IsIntegerOrEnum (expectedType) && OperandFitsInType (expectedType' (int)expr.Operand))  		return expectedType;  	else  		return typeSystem.Int32;  case ILCode.Ldc_I8:  	if (expectedType is PointerType && (long)expr.Operand == 0)  		return expectedType;  	if (IsIntegerOrEnum (expectedType) && GetInformationAmount (expectedType) >= NativeInt)  		return expectedType;  	else  		return typeSystem.Int64;  case ILCode.Ldc_R4:  	return typeSystem.Single;  case ILCode.Ldc_R8:  	return typeSystem.Double;  case ILCode.Ldc_Decimal:  	return new TypeReference ("System"' "Decimal"' module' module.TypeSystem.CoreLibrary' true);  case ILCode.Ldtoken:  	if (expr.Operand is TypeReference)  		return new TypeReference ("System"' "RuntimeTypeHandle"' module' module.TypeSystem.CoreLibrary' true);  	else if (expr.Operand is FieldReference)  		return new TypeReference ("System"' "RuntimeFieldHandle"' module' module.TypeSystem.CoreLibrary' true);  	else  		return new TypeReference ("System"' "RuntimeMethodHandle"' module' module.TypeSystem.CoreLibrary' true);  case ILCode.Arglist:  	return new TypeReference ("System"' "RuntimeArgumentHandle"' module' module.TypeSystem.CoreLibrary' true);  #endregion  #region Array instructions  case ILCode.Newarr:  	if (forceInferChildren) {  		var lengthType = InferTypeForExpression (expr.Arguments.Single ()' null);  		if (lengthType == typeSystem.IntPtr) {  			lengthType = typeSystem.Int64;  		} else if (lengthType == typeSystem.UIntPtr) {  			lengthType = typeSystem.UInt64;  		} else if (lengthType != typeSystem.UInt32 && lengthType != typeSystem.Int64 && lengthType != typeSystem.UInt64) {  			lengthType = typeSystem.Int32;  		}  		if (forceInferChildren) {  			InferTypeForExpression (expr.Arguments.Single ()' lengthType);  		}  	}  	return new ArrayType ((TypeReference)expr.Operand);  case ILCode.InitArray:  	var operandAsArrayType = (ArrayType)expr.Operand;  	if (forceInferChildren) {  		foreach (ILExpression arg in expr.Arguments)  			InferTypeForExpression (arg' operandAsArrayType.ElementType);  	}  	return operandAsArrayType;  case ILCode.Ldlen:  	return typeSystem.Int32;  case ILCode.Ldelem_U1:  case ILCode.Ldelem_U2:  case ILCode.Ldelem_U4:  case ILCode.Ldelem_I1:  case ILCode.Ldelem_I2:  case ILCode.Ldelem_I4:  case ILCode.Ldelem_I8:  case ILCode.Ldelem_R4:  case ILCode.Ldelem_R8:  case ILCode.Ldelem_I:  case ILCode.Ldelem_Ref: {  	ArrayType arrayType = InferTypeForExpression (expr.Arguments [0]' null) as ArrayType;  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [1]' typeSystem.Int32);  	}  	return arrayType != null ? arrayType.ElementType : null;  }  case ILCode.Ldelem_Any:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [1]' typeSystem.Int32);  	}  	return (TypeReference)expr.Operand;  case ILCode.Ldelema: {  	ArrayType arrayType = InferTypeForExpression (expr.Arguments [0]' null) as ArrayType;  	if (forceInferChildren)  		InferTypeForExpression (expr.Arguments [1]' typeSystem.Int32);  	return arrayType != null ? new ByReferenceType (arrayType.ElementType) : null;  }  case ILCode.Stelem_I:  case ILCode.Stelem_I1:  case ILCode.Stelem_I2:  case ILCode.Stelem_I4:  case ILCode.Stelem_I8:  case ILCode.Stelem_R4:  case ILCode.Stelem_R8:  case ILCode.Stelem_Ref:  case ILCode.Stelem_Any: {  	ArrayType arrayType = InferTypeForExpression (expr.Arguments [0]' null) as ArrayType;  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [1]' typeSystem.Int32);  		if (arrayType != null) {  			InferTypeForExpression (expr.Arguments [2]' arrayType.ElementType);  		}  	}  	return arrayType != null ? arrayType.ElementType : null;  }  #endregion  #region Conversion instructions  case ILCode.Conv_I1:  case ILCode.Conv_Ovf_I1:  case ILCode.Conv_Ovf_I1_Un:  	return HandleConversion (8' true' expr.Arguments [0]' expectedType' typeSystem.SByte);  case ILCode.Conv_I2:  case ILCode.Conv_Ovf_I2:  case ILCode.Conv_Ovf_I2_Un:  	return HandleConversion (16' true' expr.Arguments [0]' expectedType' typeSystem.Int16);  case ILCode.Conv_I4:  case ILCode.Conv_Ovf_I4:  case ILCode.Conv_Ovf_I4_Un:  	return HandleConversion (32' true' expr.Arguments [0]' expectedType' typeSystem.Int32);  case ILCode.Conv_I8:  case ILCode.Conv_Ovf_I8:  case ILCode.Conv_Ovf_I8_Un:  	return HandleConversion (64' true' expr.Arguments [0]' expectedType' typeSystem.Int64);  case ILCode.Conv_U1:  case ILCode.Conv_Ovf_U1:  case ILCode.Conv_Ovf_U1_Un:  	return HandleConversion (8' false' expr.Arguments [0]' expectedType' typeSystem.Byte);  case ILCode.Conv_U2:  case ILCode.Conv_Ovf_U2:  case ILCode.Conv_Ovf_U2_Un:  	return HandleConversion (16' false' expr.Arguments [0]' expectedType' typeSystem.UInt16);  case ILCode.Conv_U4:  case ILCode.Conv_Ovf_U4:  case ILCode.Conv_Ovf_U4_Un:  	return HandleConversion (32' false' expr.Arguments [0]' expectedType' typeSystem.UInt32);  case ILCode.Conv_U8:  case ILCode.Conv_Ovf_U8:  case ILCode.Conv_Ovf_U8_Un:  	return HandleConversion (64' false' expr.Arguments [0]' expectedType' typeSystem.UInt64);  case ILCode.Conv_I:  case ILCode.Conv_Ovf_I:  case ILCode.Conv_Ovf_I_Un:  	return HandleConversion (NativeInt' true' expr.Arguments [0]' expectedType' typeSystem.IntPtr);  case ILCode.Conv_U:  case ILCode.Conv_Ovf_U:  case ILCode.Conv_Ovf_U_Un:  	return HandleConversion (NativeInt' false' expr.Arguments [0]' expectedType' typeSystem.UIntPtr);  case ILCode.Conv_R4:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' typeSystem.Single);  	}  	return typeSystem.Single;  case ILCode.Conv_R8:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' typeSystem.Double);  	}  	return typeSystem.Double;  case ILCode.Conv_R_Un:  	return (expectedType != null && expectedType.MetadataType == MetadataType.Single) ? typeSystem.Single : typeSystem.Double;  case ILCode.Castclass:  case ILCode.Unbox_Any:  	return (TypeReference)expr.Operand;  case ILCode.Unbox:  	return new ByReferenceType ((TypeReference)expr.Operand);  case ILCode.Isinst: {  	// isinst performs the equivalent of a cast only for reference types;  	// value types still need to be unboxed after an isinst instruction  	TypeReference tr = (TypeReference)expr.Operand;  	return tr.IsValueType ? typeSystem.Object : tr;  }  case ILCode.Box: {  	var tr = (TypeReference)expr.Operand;  	if (forceInferChildren)  		InferTypeForExpression (expr.Arguments.Single ()' tr);  	return tr.IsValueType ? typeSystem.Object : tr;  }  #endregion  #region Comparison instructions  case ILCode.Ceq:  case ILCode.Cne:  	if (forceInferChildren)  		InferArgumentsInBinaryOperator (expr' null' null);  	return typeSystem.Boolean;  case ILCode.Clt:  case ILCode.Cgt:  case ILCode.Cle:  case ILCode.Cge:  	if (forceInferChildren)  		InferArgumentsInBinaryOperator (expr' true' null);  	return typeSystem.Boolean;  case ILCode.Clt_Un:  case ILCode.Cgt_Un:  case ILCode.Cle_Un:  case ILCode.Cge_Un:  	if (forceInferChildren)  		InferArgumentsInBinaryOperator (expr' false' null);  	return typeSystem.Boolean;  #endregion  #region Branch instructions  case ILCode.Brtrue:  	if (forceInferChildren)  		InferTypeForExpression (expr.Arguments.Single ()' typeSystem.Boolean);  	return null;  case ILCode.Br:  case ILCode.Leave:  case ILCode.Endfinally:  case ILCode.Switch:  case ILCode.Throw:  case ILCode.Rethrow:  case ILCode.LoopOrSwitchBreak:  case ILCode.LoopContinue:  case ILCode.YieldBreak:  	return null;  case ILCode.Ret:  	if (forceInferChildren && expr.Arguments.Count == 1) {  		TypeReference returnType = context.CurrentMethod.ReturnType;  		if (context.CurrentMethodIsAsync && returnType != null && returnType.Namespace == "System.Threading.Tasks") {  			if (returnType.Name == "Task") {  				returnType = typeSystem.Void;  			} else if (returnType.Name == "Task`1" && returnType.IsGenericInstance) {  				returnType = ((GenericInstanceType)returnType).GenericArguments [0];  			}  		}  		InferTypeForExpression (expr.Arguments [0]' returnType);  	}  	return null;  case ILCode.YieldReturn:  	if (forceInferChildren) {  		GenericInstanceType genericType = context.CurrentMethod.ReturnType as GenericInstanceType;  		if (genericType != null) {  			// IEnumerable<T> or IEnumerator<T>  			InferTypeForExpression (expr.Arguments [0]' genericType.GenericArguments [0]);  		} else {  			// non-generic IEnumerable or IEnumerator  			InferTypeForExpression (expr.Arguments [0]' typeSystem.Object);  		}  	}  	return null;  case ILCode.Await: {  	TypeReference taskType = InferTypeForExpression (expr.Arguments [0]' null);  	if (taskType.Name == "Task`1" && taskType.IsGenericInstance && taskType.Namespace == "System.Threading.Tasks") {  		return ((GenericInstanceType)taskType).GenericArguments [0];  	}  	return null;  }  #endregion  case ILCode.Pop:  	return null;  case ILCode.Wrap:  case ILCode.Dup: {  	var arg = expr.Arguments.Single ();  	return arg.ExpectedType = InferTypeForExpression (arg' expectedType);  }  default:  	Debug.WriteLine ("Type Inference: Can't handle " + expr.Code.GetName ());  	return null;  }  
Magic Number,Custom.Decompiler.ILAst,TypeAnalysis,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\TypeAnalysis.cs,DoInferTypeForExpression,The following statement contains a magic number: switch (expr.Code) {  #region Logical operators  case ILCode.LogicNot:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments.Single ()' typeSystem.Boolean);  	}  	return typeSystem.Boolean;  case ILCode.LogicAnd:  case ILCode.LogicOr:  	// if Operand is set the logic and/or expression is a custom operator  	// we can deal with it the same as a normal invocation.  	if (expr.Operand != null)  		goto case ILCode.Call;  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' typeSystem.Boolean);  		InferTypeForExpression (expr.Arguments [1]' typeSystem.Boolean);  	}  	return typeSystem.Boolean;  case ILCode.TernaryOp:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' typeSystem.Boolean);  	}  	return InferBinaryArguments (expr.Arguments [1]' expr.Arguments [2]' expectedType' forceInferChildren);  case ILCode.NullCoalescing:  	return InferBinaryArguments (expr.Arguments [0]' expr.Arguments [1]' expectedType' forceInferChildren);  #endregion  #region Variable load/store  case ILCode.Stloc: {  	ILVariable v = (ILVariable)expr.Operand;  	if (forceInferChildren) {  		// do not use 'expectedType' in here!  		InferTypeForExpression (expr.Arguments.Single ()' v.Type);  	}  	return v.Type;  }  case ILCode.Ldloc: {  	ILVariable v = (ILVariable)expr.Operand;  	if (v.Type == null && singleLoadVariables.Contains (v)) {  		v.Type = expectedType;  	}  	return v.Type;  }  case ILCode.Ldloca: {  	ILVariable v = (ILVariable)expr.Operand;  	if (v.Type != null)  		return new ByReferenceType (v.Type);  	else  		return null;  }  #endregion  #region Call / NewObj  case ILCode.Call:  case ILCode.Callvirt:  case ILCode.CallGetter:  case ILCode.CallvirtGetter:  case ILCode.CallSetter:  case ILCode.CallvirtSetter: {  	MethodReference method = (MethodReference)expr.Operand;  	if (forceInferChildren) {  		for (int i = 0; i < expr.Arguments.Count; i++) {  			if (i == 0 && method.HasThis) {  				InferTypeForExpression (expr.Arguments [0]' MakeRefIfValueType (method.DeclaringType' expr.GetPrefix (ILCode.Constrained)));  			} else {  				InferTypeForExpression (expr.Arguments [i]' SubstituteTypeArgs (method.Parameters [method.HasThis ? i - 1 : i].ParameterType' method));  			}  		}  	}  	if (expr.Code == ILCode.CallSetter || expr.Code == ILCode.CallvirtSetter) {  		return SubstituteTypeArgs (method.Parameters.Last ().ParameterType' method);  	} else {  		return SubstituteTypeArgs (method.ReturnType' method);  	}  }  case ILCode.Newobj: {  	MethodReference ctor = (MethodReference)expr.Operand;  	if (forceInferChildren) {  		for (int i = 0; i < ctor.Parameters.Count; i++) {  			InferTypeForExpression (expr.Arguments [i]' SubstituteTypeArgs (ctor.Parameters [i].ParameterType' ctor));  		}  	}  	return ctor.DeclaringType;  }  case ILCode.InitObject:  case ILCode.InitCollection:  	return InferTypeForExpression (expr.Arguments [0]' expectedType);  case ILCode.InitializedObject:  	// expectedType should always be known due to the parent method call / property setter  	Debug.Assert (expectedType != null);  	return expectedType;  #endregion  #region Load/Store Fields  case ILCode.Ldfld:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' MakeRefIfValueType (((FieldReference)expr.Operand).DeclaringType' expr.GetPrefix (ILCode.Constrained)));  	}  	return GetFieldType ((FieldReference)expr.Operand);  case ILCode.Ldsfld:  	return GetFieldType ((FieldReference)expr.Operand);  case ILCode.Ldflda:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' MakeRefIfValueType (((FieldReference)expr.Operand).DeclaringType' expr.GetPrefix (ILCode.Constrained)));  	}  	return new ByReferenceType (GetFieldType ((FieldReference)expr.Operand));  case ILCode.Ldsflda:  	return new ByReferenceType (GetFieldType ((FieldReference)expr.Operand));  case ILCode.Stfld:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' MakeRefIfValueType (((FieldReference)expr.Operand).DeclaringType' expr.GetPrefix (ILCode.Constrained)));  		InferTypeForExpression (expr.Arguments [1]' GetFieldType ((FieldReference)expr.Operand));  	}  	return GetFieldType ((FieldReference)expr.Operand);  case ILCode.Stsfld:  	if (forceInferChildren)  		InferTypeForExpression (expr.Arguments [0]' GetFieldType ((FieldReference)expr.Operand));  	return GetFieldType ((FieldReference)expr.Operand);  #endregion  #region Reference/Pointer instructions  case ILCode.Ldind_Ref:  	return UnpackPointer (InferTypeForExpression (expr.Arguments [0]' null));  case ILCode.Stind_Ref:  	if (forceInferChildren) {  		TypeReference elementType = UnpackPointer (InferTypeForExpression (expr.Arguments [0]' null));  		InferTypeForExpression (expr.Arguments [1]' elementType);  	}  	return null;  case ILCode.Ldobj: {  	TypeReference type = (TypeReference)expr.Operand;  	var argType = InferTypeForExpression (expr.Arguments [0]' null);  	if (argType is PointerType || argType is ByReferenceType) {  		var elementType = ((TypeSpecification)argType).ElementType;  		int infoAmount = GetInformationAmount (elementType);  		if (infoAmount == 1 && GetInformationAmount (type) == 8) {  			// A bool can be loaded from both bytes and sbytes.  			type = elementType;  		}  		if (infoAmount >= 8 && infoAmount <= 64 && infoAmount == GetInformationAmount (type)) {  			// An integer can be loaded as another integer of the same size.  			// For integers smaller than 32 bit' the signs must match (as loading performs sign extension)  			bool? elementTypeIsSigned = IsSigned (elementType);  			bool? typeIsSigned = IsSigned (type);  			if (elementTypeIsSigned != null && typeIsSigned != null) {  				if (infoAmount >= 32 || elementTypeIsSigned == typeIsSigned)  					type = elementType;  			}  		}  	}  	if (argType is PointerType)  		InferTypeForExpression (expr.Arguments [0]' new PointerType (type));  	else  		InferTypeForExpression (expr.Arguments [0]' new ByReferenceType (type));  	return type;  }  case ILCode.Stobj: {  	TypeReference operandType = (TypeReference)expr.Operand;  	TypeReference pointerType = InferTypeForExpression (expr.Arguments [0]' new ByReferenceType (operandType));  	TypeReference elementType;  	if (pointerType is PointerType)  		elementType = ((PointerType)pointerType).ElementType;  	else if (pointerType is ByReferenceType)  		elementType = ((ByReferenceType)pointerType).ElementType;  	else  		elementType = null;  	if (elementType != null) {  		// An integer can be stored in any other integer of the same size.  		int infoAmount = GetInformationAmount (elementType);  		if (infoAmount == 1 && GetInformationAmount (operandType) == 8)  			operandType = elementType;  		else if (infoAmount == GetInformationAmount (operandType) && IsSigned (elementType) != null && IsSigned (operandType) != null)  			operandType = elementType;  	}  	if (forceInferChildren) {  		if (pointerType is PointerType)  			InferTypeForExpression (expr.Arguments [0]' new PointerType (operandType));  		else if (!IsSameType (operandType' expr.Operand as TypeReference))  			InferTypeForExpression (expr.Arguments [0]' new ByReferenceType (operandType));  		InferTypeForExpression (expr.Arguments [1]' operandType);  	}  	return operandType;  }  case ILCode.Initobj:  	return null;  case ILCode.DefaultValue:  	return (TypeReference)expr.Operand;  case ILCode.Localloc:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' typeSystem.Int32);  	}  	if (expectedType is PointerType)  		return expectedType;  	else  		return typeSystem.IntPtr;  case ILCode.Sizeof:  	return typeSystem.Int32;  case ILCode.PostIncrement:  case ILCode.PostIncrement_Ovf:  case ILCode.PostIncrement_Ovf_Un: {  	TypeReference elementType = UnpackPointer (InferTypeForExpression (expr.Arguments [0]' null));  	if (forceInferChildren && elementType != null) {  		// Assign expected type to the child expression  		InferTypeForExpression (expr.Arguments [0]' new ByReferenceType (elementType));  	}  	return elementType;  }  case ILCode.Mkrefany:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' (TypeReference)expr.Operand);  	}  	return typeSystem.TypedReference;  case ILCode.Refanytype:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' typeSystem.TypedReference);  	}  	return new TypeReference ("System"' "RuntimeTypeHandle"' module' module.TypeSystem.CoreLibrary' true);  case ILCode.Refanyval:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' typeSystem.TypedReference);  	}  	return new ByReferenceType ((TypeReference)expr.Operand);  case ILCode.AddressOf: {  	TypeReference t = InferTypeForExpression (expr.Arguments [0]' UnpackPointer (expectedType));  	return t != null ? new ByReferenceType (t) : null;  }  case ILCode.ValueOf:  	return GetNullableTypeArgument (InferTypeForExpression (expr.Arguments [0]' CreateNullableType (expectedType)));  case ILCode.NullableOf:  	return CreateNullableType (InferTypeForExpression (expr.Arguments [0]' GetNullableTypeArgument (expectedType)));  #endregion  #region Arithmetic instructions  case ILCode.Not:  // bitwise complement  case ILCode.Neg:  	return InferTypeForExpression (expr.Arguments.Single ()' expectedType);  case ILCode.Add:  	return InferArgumentsInAddition (expr' null' expectedType);  case ILCode.Sub:  	return InferArgumentsInSubtraction (expr' null' expectedType);  case ILCode.Mul:  case ILCode.Or:  case ILCode.And:  case ILCode.Xor:  	return InferArgumentsInBinaryOperator (expr' null' expectedType);  case ILCode.Add_Ovf:  	return InferArgumentsInAddition (expr' true' expectedType);  case ILCode.Sub_Ovf:  	return InferArgumentsInSubtraction (expr' true' expectedType);  case ILCode.Mul_Ovf:  case ILCode.Div:  case ILCode.Rem:  	return InferArgumentsInBinaryOperator (expr' true' expectedType);  case ILCode.Add_Ovf_Un:  	return InferArgumentsInAddition (expr' false' expectedType);  case ILCode.Sub_Ovf_Un:  	return InferArgumentsInSubtraction (expr' false' expectedType);  case ILCode.Mul_Ovf_Un:  case ILCode.Div_Un:  case ILCode.Rem_Un:  	return InferArgumentsInBinaryOperator (expr' false' expectedType);  case ILCode.Shl:  	if (forceInferChildren)  		InferTypeForExpression (expr.Arguments [1]' typeSystem.Int32);  	if (expectedType != null && (expectedType.MetadataType == MetadataType.Int32 || expectedType.MetadataType == MetadataType.UInt32 || expectedType.MetadataType == MetadataType.Int64 || expectedType.MetadataType == MetadataType.UInt64))  		return NumericPromotion (InferTypeForExpression (expr.Arguments [0]' expectedType));  	else  		return NumericPromotion (InferTypeForExpression (expr.Arguments [0]' null));  case ILCode.Shr:  case ILCode.Shr_Un: {  	if (forceInferChildren)  		InferTypeForExpression (expr.Arguments [1]' typeSystem.Int32);  	TypeReference type = NumericPromotion (InferTypeForExpression (expr.Arguments [0]' null));  	TypeReference expectedInputType = null;  	switch (type.MetadataType) {  	case MetadataType.Int32:  		if (expr.Code == ILCode.Shr_Un)  			expectedInputType = typeSystem.UInt32;  		break;  	case MetadataType.UInt32:  		if (expr.Code == ILCode.Shr)  			expectedInputType = typeSystem.Int32;  		break;  	case MetadataType.Int64:  		if (expr.Code == ILCode.Shr_Un)  			expectedInputType = typeSystem.UInt64;  		break;  	case MetadataType.UInt64:  		if (expr.Code == ILCode.Shr)  			expectedInputType = typeSystem.UInt64;  		break;  	}  	if (expectedInputType != null) {  		InferTypeForExpression (expr.Arguments [0]' expectedInputType);  		return expectedInputType;  	} else {  		return type;  	}  }  case ILCode.CompoundAssignment: {  	var op = expr.Arguments [0];  	if (op.Code == ILCode.NullableOf)  		op = op.Arguments [0].Arguments [0];  	var varType = InferTypeForExpression (op.Arguments [0]' null);  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' varType);  	}  	return varType;  }  #endregion  #region Constant loading instructions  case ILCode.Ldnull:  	return typeSystem.Object;  case ILCode.Ldstr:  	return typeSystem.String;  case ILCode.Ldftn:  case ILCode.Ldvirtftn:  	return typeSystem.IntPtr;  case ILCode.Ldc_I4:  	if (IsBoolean (expectedType) && ((int)expr.Operand == 0 || (int)expr.Operand == 1))  		return typeSystem.Boolean;  	if (expectedType is PointerType && (int)expr.Operand == 0)  		return expectedType;  	if (IsIntegerOrEnum (expectedType) && OperandFitsInType (expectedType' (int)expr.Operand))  		return expectedType;  	else  		return typeSystem.Int32;  case ILCode.Ldc_I8:  	if (expectedType is PointerType && (long)expr.Operand == 0)  		return expectedType;  	if (IsIntegerOrEnum (expectedType) && GetInformationAmount (expectedType) >= NativeInt)  		return expectedType;  	else  		return typeSystem.Int64;  case ILCode.Ldc_R4:  	return typeSystem.Single;  case ILCode.Ldc_R8:  	return typeSystem.Double;  case ILCode.Ldc_Decimal:  	return new TypeReference ("System"' "Decimal"' module' module.TypeSystem.CoreLibrary' true);  case ILCode.Ldtoken:  	if (expr.Operand is TypeReference)  		return new TypeReference ("System"' "RuntimeTypeHandle"' module' module.TypeSystem.CoreLibrary' true);  	else if (expr.Operand is FieldReference)  		return new TypeReference ("System"' "RuntimeFieldHandle"' module' module.TypeSystem.CoreLibrary' true);  	else  		return new TypeReference ("System"' "RuntimeMethodHandle"' module' module.TypeSystem.CoreLibrary' true);  case ILCode.Arglist:  	return new TypeReference ("System"' "RuntimeArgumentHandle"' module' module.TypeSystem.CoreLibrary' true);  #endregion  #region Array instructions  case ILCode.Newarr:  	if (forceInferChildren) {  		var lengthType = InferTypeForExpression (expr.Arguments.Single ()' null);  		if (lengthType == typeSystem.IntPtr) {  			lengthType = typeSystem.Int64;  		} else if (lengthType == typeSystem.UIntPtr) {  			lengthType = typeSystem.UInt64;  		} else if (lengthType != typeSystem.UInt32 && lengthType != typeSystem.Int64 && lengthType != typeSystem.UInt64) {  			lengthType = typeSystem.Int32;  		}  		if (forceInferChildren) {  			InferTypeForExpression (expr.Arguments.Single ()' lengthType);  		}  	}  	return new ArrayType ((TypeReference)expr.Operand);  case ILCode.InitArray:  	var operandAsArrayType = (ArrayType)expr.Operand;  	if (forceInferChildren) {  		foreach (ILExpression arg in expr.Arguments)  			InferTypeForExpression (arg' operandAsArrayType.ElementType);  	}  	return operandAsArrayType;  case ILCode.Ldlen:  	return typeSystem.Int32;  case ILCode.Ldelem_U1:  case ILCode.Ldelem_U2:  case ILCode.Ldelem_U4:  case ILCode.Ldelem_I1:  case ILCode.Ldelem_I2:  case ILCode.Ldelem_I4:  case ILCode.Ldelem_I8:  case ILCode.Ldelem_R4:  case ILCode.Ldelem_R8:  case ILCode.Ldelem_I:  case ILCode.Ldelem_Ref: {  	ArrayType arrayType = InferTypeForExpression (expr.Arguments [0]' null) as ArrayType;  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [1]' typeSystem.Int32);  	}  	return arrayType != null ? arrayType.ElementType : null;  }  case ILCode.Ldelem_Any:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [1]' typeSystem.Int32);  	}  	return (TypeReference)expr.Operand;  case ILCode.Ldelema: {  	ArrayType arrayType = InferTypeForExpression (expr.Arguments [0]' null) as ArrayType;  	if (forceInferChildren)  		InferTypeForExpression (expr.Arguments [1]' typeSystem.Int32);  	return arrayType != null ? new ByReferenceType (arrayType.ElementType) : null;  }  case ILCode.Stelem_I:  case ILCode.Stelem_I1:  case ILCode.Stelem_I2:  case ILCode.Stelem_I4:  case ILCode.Stelem_I8:  case ILCode.Stelem_R4:  case ILCode.Stelem_R8:  case ILCode.Stelem_Ref:  case ILCode.Stelem_Any: {  	ArrayType arrayType = InferTypeForExpression (expr.Arguments [0]' null) as ArrayType;  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [1]' typeSystem.Int32);  		if (arrayType != null) {  			InferTypeForExpression (expr.Arguments [2]' arrayType.ElementType);  		}  	}  	return arrayType != null ? arrayType.ElementType : null;  }  #endregion  #region Conversion instructions  case ILCode.Conv_I1:  case ILCode.Conv_Ovf_I1:  case ILCode.Conv_Ovf_I1_Un:  	return HandleConversion (8' true' expr.Arguments [0]' expectedType' typeSystem.SByte);  case ILCode.Conv_I2:  case ILCode.Conv_Ovf_I2:  case ILCode.Conv_Ovf_I2_Un:  	return HandleConversion (16' true' expr.Arguments [0]' expectedType' typeSystem.Int16);  case ILCode.Conv_I4:  case ILCode.Conv_Ovf_I4:  case ILCode.Conv_Ovf_I4_Un:  	return HandleConversion (32' true' expr.Arguments [0]' expectedType' typeSystem.Int32);  case ILCode.Conv_I8:  case ILCode.Conv_Ovf_I8:  case ILCode.Conv_Ovf_I8_Un:  	return HandleConversion (64' true' expr.Arguments [0]' expectedType' typeSystem.Int64);  case ILCode.Conv_U1:  case ILCode.Conv_Ovf_U1:  case ILCode.Conv_Ovf_U1_Un:  	return HandleConversion (8' false' expr.Arguments [0]' expectedType' typeSystem.Byte);  case ILCode.Conv_U2:  case ILCode.Conv_Ovf_U2:  case ILCode.Conv_Ovf_U2_Un:  	return HandleConversion (16' false' expr.Arguments [0]' expectedType' typeSystem.UInt16);  case ILCode.Conv_U4:  case ILCode.Conv_Ovf_U4:  case ILCode.Conv_Ovf_U4_Un:  	return HandleConversion (32' false' expr.Arguments [0]' expectedType' typeSystem.UInt32);  case ILCode.Conv_U8:  case ILCode.Conv_Ovf_U8:  case ILCode.Conv_Ovf_U8_Un:  	return HandleConversion (64' false' expr.Arguments [0]' expectedType' typeSystem.UInt64);  case ILCode.Conv_I:  case ILCode.Conv_Ovf_I:  case ILCode.Conv_Ovf_I_Un:  	return HandleConversion (NativeInt' true' expr.Arguments [0]' expectedType' typeSystem.IntPtr);  case ILCode.Conv_U:  case ILCode.Conv_Ovf_U:  case ILCode.Conv_Ovf_U_Un:  	return HandleConversion (NativeInt' false' expr.Arguments [0]' expectedType' typeSystem.UIntPtr);  case ILCode.Conv_R4:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' typeSystem.Single);  	}  	return typeSystem.Single;  case ILCode.Conv_R8:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' typeSystem.Double);  	}  	return typeSystem.Double;  case ILCode.Conv_R_Un:  	return (expectedType != null && expectedType.MetadataType == MetadataType.Single) ? typeSystem.Single : typeSystem.Double;  case ILCode.Castclass:  case ILCode.Unbox_Any:  	return (TypeReference)expr.Operand;  case ILCode.Unbox:  	return new ByReferenceType ((TypeReference)expr.Operand);  case ILCode.Isinst: {  	// isinst performs the equivalent of a cast only for reference types;  	// value types still need to be unboxed after an isinst instruction  	TypeReference tr = (TypeReference)expr.Operand;  	return tr.IsValueType ? typeSystem.Object : tr;  }  case ILCode.Box: {  	var tr = (TypeReference)expr.Operand;  	if (forceInferChildren)  		InferTypeForExpression (expr.Arguments.Single ()' tr);  	return tr.IsValueType ? typeSystem.Object : tr;  }  #endregion  #region Comparison instructions  case ILCode.Ceq:  case ILCode.Cne:  	if (forceInferChildren)  		InferArgumentsInBinaryOperator (expr' null' null);  	return typeSystem.Boolean;  case ILCode.Clt:  case ILCode.Cgt:  case ILCode.Cle:  case ILCode.Cge:  	if (forceInferChildren)  		InferArgumentsInBinaryOperator (expr' true' null);  	return typeSystem.Boolean;  case ILCode.Clt_Un:  case ILCode.Cgt_Un:  case ILCode.Cle_Un:  case ILCode.Cge_Un:  	if (forceInferChildren)  		InferArgumentsInBinaryOperator (expr' false' null);  	return typeSystem.Boolean;  #endregion  #region Branch instructions  case ILCode.Brtrue:  	if (forceInferChildren)  		InferTypeForExpression (expr.Arguments.Single ()' typeSystem.Boolean);  	return null;  case ILCode.Br:  case ILCode.Leave:  case ILCode.Endfinally:  case ILCode.Switch:  case ILCode.Throw:  case ILCode.Rethrow:  case ILCode.LoopOrSwitchBreak:  case ILCode.LoopContinue:  case ILCode.YieldBreak:  	return null;  case ILCode.Ret:  	if (forceInferChildren && expr.Arguments.Count == 1) {  		TypeReference returnType = context.CurrentMethod.ReturnType;  		if (context.CurrentMethodIsAsync && returnType != null && returnType.Namespace == "System.Threading.Tasks") {  			if (returnType.Name == "Task") {  				returnType = typeSystem.Void;  			} else if (returnType.Name == "Task`1" && returnType.IsGenericInstance) {  				returnType = ((GenericInstanceType)returnType).GenericArguments [0];  			}  		}  		InferTypeForExpression (expr.Arguments [0]' returnType);  	}  	return null;  case ILCode.YieldReturn:  	if (forceInferChildren) {  		GenericInstanceType genericType = context.CurrentMethod.ReturnType as GenericInstanceType;  		if (genericType != null) {  			// IEnumerable<T> or IEnumerator<T>  			InferTypeForExpression (expr.Arguments [0]' genericType.GenericArguments [0]);  		} else {  			// non-generic IEnumerable or IEnumerator  			InferTypeForExpression (expr.Arguments [0]' typeSystem.Object);  		}  	}  	return null;  case ILCode.Await: {  	TypeReference taskType = InferTypeForExpression (expr.Arguments [0]' null);  	if (taskType.Name == "Task`1" && taskType.IsGenericInstance && taskType.Namespace == "System.Threading.Tasks") {  		return ((GenericInstanceType)taskType).GenericArguments [0];  	}  	return null;  }  #endregion  case ILCode.Pop:  	return null;  case ILCode.Wrap:  case ILCode.Dup: {  	var arg = expr.Arguments.Single ();  	return arg.ExpectedType = InferTypeForExpression (arg' expectedType);  }  default:  	Debug.WriteLine ("Type Inference: Can't handle " + expr.Code.GetName ());  	return null;  }  
Magic Number,Custom.Decompiler.ILAst,TypeAnalysis,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\TypeAnalysis.cs,DoInferTypeForExpression,The following statement contains a magic number: switch (expr.Code) {  #region Logical operators  case ILCode.LogicNot:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments.Single ()' typeSystem.Boolean);  	}  	return typeSystem.Boolean;  case ILCode.LogicAnd:  case ILCode.LogicOr:  	// if Operand is set the logic and/or expression is a custom operator  	// we can deal with it the same as a normal invocation.  	if (expr.Operand != null)  		goto case ILCode.Call;  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' typeSystem.Boolean);  		InferTypeForExpression (expr.Arguments [1]' typeSystem.Boolean);  	}  	return typeSystem.Boolean;  case ILCode.TernaryOp:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' typeSystem.Boolean);  	}  	return InferBinaryArguments (expr.Arguments [1]' expr.Arguments [2]' expectedType' forceInferChildren);  case ILCode.NullCoalescing:  	return InferBinaryArguments (expr.Arguments [0]' expr.Arguments [1]' expectedType' forceInferChildren);  #endregion  #region Variable load/store  case ILCode.Stloc: {  	ILVariable v = (ILVariable)expr.Operand;  	if (forceInferChildren) {  		// do not use 'expectedType' in here!  		InferTypeForExpression (expr.Arguments.Single ()' v.Type);  	}  	return v.Type;  }  case ILCode.Ldloc: {  	ILVariable v = (ILVariable)expr.Operand;  	if (v.Type == null && singleLoadVariables.Contains (v)) {  		v.Type = expectedType;  	}  	return v.Type;  }  case ILCode.Ldloca: {  	ILVariable v = (ILVariable)expr.Operand;  	if (v.Type != null)  		return new ByReferenceType (v.Type);  	else  		return null;  }  #endregion  #region Call / NewObj  case ILCode.Call:  case ILCode.Callvirt:  case ILCode.CallGetter:  case ILCode.CallvirtGetter:  case ILCode.CallSetter:  case ILCode.CallvirtSetter: {  	MethodReference method = (MethodReference)expr.Operand;  	if (forceInferChildren) {  		for (int i = 0; i < expr.Arguments.Count; i++) {  			if (i == 0 && method.HasThis) {  				InferTypeForExpression (expr.Arguments [0]' MakeRefIfValueType (method.DeclaringType' expr.GetPrefix (ILCode.Constrained)));  			} else {  				InferTypeForExpression (expr.Arguments [i]' SubstituteTypeArgs (method.Parameters [method.HasThis ? i - 1 : i].ParameterType' method));  			}  		}  	}  	if (expr.Code == ILCode.CallSetter || expr.Code == ILCode.CallvirtSetter) {  		return SubstituteTypeArgs (method.Parameters.Last ().ParameterType' method);  	} else {  		return SubstituteTypeArgs (method.ReturnType' method);  	}  }  case ILCode.Newobj: {  	MethodReference ctor = (MethodReference)expr.Operand;  	if (forceInferChildren) {  		for (int i = 0; i < ctor.Parameters.Count; i++) {  			InferTypeForExpression (expr.Arguments [i]' SubstituteTypeArgs (ctor.Parameters [i].ParameterType' ctor));  		}  	}  	return ctor.DeclaringType;  }  case ILCode.InitObject:  case ILCode.InitCollection:  	return InferTypeForExpression (expr.Arguments [0]' expectedType);  case ILCode.InitializedObject:  	// expectedType should always be known due to the parent method call / property setter  	Debug.Assert (expectedType != null);  	return expectedType;  #endregion  #region Load/Store Fields  case ILCode.Ldfld:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' MakeRefIfValueType (((FieldReference)expr.Operand).DeclaringType' expr.GetPrefix (ILCode.Constrained)));  	}  	return GetFieldType ((FieldReference)expr.Operand);  case ILCode.Ldsfld:  	return GetFieldType ((FieldReference)expr.Operand);  case ILCode.Ldflda:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' MakeRefIfValueType (((FieldReference)expr.Operand).DeclaringType' expr.GetPrefix (ILCode.Constrained)));  	}  	return new ByReferenceType (GetFieldType ((FieldReference)expr.Operand));  case ILCode.Ldsflda:  	return new ByReferenceType (GetFieldType ((FieldReference)expr.Operand));  case ILCode.Stfld:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' MakeRefIfValueType (((FieldReference)expr.Operand).DeclaringType' expr.GetPrefix (ILCode.Constrained)));  		InferTypeForExpression (expr.Arguments [1]' GetFieldType ((FieldReference)expr.Operand));  	}  	return GetFieldType ((FieldReference)expr.Operand);  case ILCode.Stsfld:  	if (forceInferChildren)  		InferTypeForExpression (expr.Arguments [0]' GetFieldType ((FieldReference)expr.Operand));  	return GetFieldType ((FieldReference)expr.Operand);  #endregion  #region Reference/Pointer instructions  case ILCode.Ldind_Ref:  	return UnpackPointer (InferTypeForExpression (expr.Arguments [0]' null));  case ILCode.Stind_Ref:  	if (forceInferChildren) {  		TypeReference elementType = UnpackPointer (InferTypeForExpression (expr.Arguments [0]' null));  		InferTypeForExpression (expr.Arguments [1]' elementType);  	}  	return null;  case ILCode.Ldobj: {  	TypeReference type = (TypeReference)expr.Operand;  	var argType = InferTypeForExpression (expr.Arguments [0]' null);  	if (argType is PointerType || argType is ByReferenceType) {  		var elementType = ((TypeSpecification)argType).ElementType;  		int infoAmount = GetInformationAmount (elementType);  		if (infoAmount == 1 && GetInformationAmount (type) == 8) {  			// A bool can be loaded from both bytes and sbytes.  			type = elementType;  		}  		if (infoAmount >= 8 && infoAmount <= 64 && infoAmount == GetInformationAmount (type)) {  			// An integer can be loaded as another integer of the same size.  			// For integers smaller than 32 bit' the signs must match (as loading performs sign extension)  			bool? elementTypeIsSigned = IsSigned (elementType);  			bool? typeIsSigned = IsSigned (type);  			if (elementTypeIsSigned != null && typeIsSigned != null) {  				if (infoAmount >= 32 || elementTypeIsSigned == typeIsSigned)  					type = elementType;  			}  		}  	}  	if (argType is PointerType)  		InferTypeForExpression (expr.Arguments [0]' new PointerType (type));  	else  		InferTypeForExpression (expr.Arguments [0]' new ByReferenceType (type));  	return type;  }  case ILCode.Stobj: {  	TypeReference operandType = (TypeReference)expr.Operand;  	TypeReference pointerType = InferTypeForExpression (expr.Arguments [0]' new ByReferenceType (operandType));  	TypeReference elementType;  	if (pointerType is PointerType)  		elementType = ((PointerType)pointerType).ElementType;  	else if (pointerType is ByReferenceType)  		elementType = ((ByReferenceType)pointerType).ElementType;  	else  		elementType = null;  	if (elementType != null) {  		// An integer can be stored in any other integer of the same size.  		int infoAmount = GetInformationAmount (elementType);  		if (infoAmount == 1 && GetInformationAmount (operandType) == 8)  			operandType = elementType;  		else if (infoAmount == GetInformationAmount (operandType) && IsSigned (elementType) != null && IsSigned (operandType) != null)  			operandType = elementType;  	}  	if (forceInferChildren) {  		if (pointerType is PointerType)  			InferTypeForExpression (expr.Arguments [0]' new PointerType (operandType));  		else if (!IsSameType (operandType' expr.Operand as TypeReference))  			InferTypeForExpression (expr.Arguments [0]' new ByReferenceType (operandType));  		InferTypeForExpression (expr.Arguments [1]' operandType);  	}  	return operandType;  }  case ILCode.Initobj:  	return null;  case ILCode.DefaultValue:  	return (TypeReference)expr.Operand;  case ILCode.Localloc:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' typeSystem.Int32);  	}  	if (expectedType is PointerType)  		return expectedType;  	else  		return typeSystem.IntPtr;  case ILCode.Sizeof:  	return typeSystem.Int32;  case ILCode.PostIncrement:  case ILCode.PostIncrement_Ovf:  case ILCode.PostIncrement_Ovf_Un: {  	TypeReference elementType = UnpackPointer (InferTypeForExpression (expr.Arguments [0]' null));  	if (forceInferChildren && elementType != null) {  		// Assign expected type to the child expression  		InferTypeForExpression (expr.Arguments [0]' new ByReferenceType (elementType));  	}  	return elementType;  }  case ILCode.Mkrefany:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' (TypeReference)expr.Operand);  	}  	return typeSystem.TypedReference;  case ILCode.Refanytype:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' typeSystem.TypedReference);  	}  	return new TypeReference ("System"' "RuntimeTypeHandle"' module' module.TypeSystem.CoreLibrary' true);  case ILCode.Refanyval:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' typeSystem.TypedReference);  	}  	return new ByReferenceType ((TypeReference)expr.Operand);  case ILCode.AddressOf: {  	TypeReference t = InferTypeForExpression (expr.Arguments [0]' UnpackPointer (expectedType));  	return t != null ? new ByReferenceType (t) : null;  }  case ILCode.ValueOf:  	return GetNullableTypeArgument (InferTypeForExpression (expr.Arguments [0]' CreateNullableType (expectedType)));  case ILCode.NullableOf:  	return CreateNullableType (InferTypeForExpression (expr.Arguments [0]' GetNullableTypeArgument (expectedType)));  #endregion  #region Arithmetic instructions  case ILCode.Not:  // bitwise complement  case ILCode.Neg:  	return InferTypeForExpression (expr.Arguments.Single ()' expectedType);  case ILCode.Add:  	return InferArgumentsInAddition (expr' null' expectedType);  case ILCode.Sub:  	return InferArgumentsInSubtraction (expr' null' expectedType);  case ILCode.Mul:  case ILCode.Or:  case ILCode.And:  case ILCode.Xor:  	return InferArgumentsInBinaryOperator (expr' null' expectedType);  case ILCode.Add_Ovf:  	return InferArgumentsInAddition (expr' true' expectedType);  case ILCode.Sub_Ovf:  	return InferArgumentsInSubtraction (expr' true' expectedType);  case ILCode.Mul_Ovf:  case ILCode.Div:  case ILCode.Rem:  	return InferArgumentsInBinaryOperator (expr' true' expectedType);  case ILCode.Add_Ovf_Un:  	return InferArgumentsInAddition (expr' false' expectedType);  case ILCode.Sub_Ovf_Un:  	return InferArgumentsInSubtraction (expr' false' expectedType);  case ILCode.Mul_Ovf_Un:  case ILCode.Div_Un:  case ILCode.Rem_Un:  	return InferArgumentsInBinaryOperator (expr' false' expectedType);  case ILCode.Shl:  	if (forceInferChildren)  		InferTypeForExpression (expr.Arguments [1]' typeSystem.Int32);  	if (expectedType != null && (expectedType.MetadataType == MetadataType.Int32 || expectedType.MetadataType == MetadataType.UInt32 || expectedType.MetadataType == MetadataType.Int64 || expectedType.MetadataType == MetadataType.UInt64))  		return NumericPromotion (InferTypeForExpression (expr.Arguments [0]' expectedType));  	else  		return NumericPromotion (InferTypeForExpression (expr.Arguments [0]' null));  case ILCode.Shr:  case ILCode.Shr_Un: {  	if (forceInferChildren)  		InferTypeForExpression (expr.Arguments [1]' typeSystem.Int32);  	TypeReference type = NumericPromotion (InferTypeForExpression (expr.Arguments [0]' null));  	TypeReference expectedInputType = null;  	switch (type.MetadataType) {  	case MetadataType.Int32:  		if (expr.Code == ILCode.Shr_Un)  			expectedInputType = typeSystem.UInt32;  		break;  	case MetadataType.UInt32:  		if (expr.Code == ILCode.Shr)  			expectedInputType = typeSystem.Int32;  		break;  	case MetadataType.Int64:  		if (expr.Code == ILCode.Shr_Un)  			expectedInputType = typeSystem.UInt64;  		break;  	case MetadataType.UInt64:  		if (expr.Code == ILCode.Shr)  			expectedInputType = typeSystem.UInt64;  		break;  	}  	if (expectedInputType != null) {  		InferTypeForExpression (expr.Arguments [0]' expectedInputType);  		return expectedInputType;  	} else {  		return type;  	}  }  case ILCode.CompoundAssignment: {  	var op = expr.Arguments [0];  	if (op.Code == ILCode.NullableOf)  		op = op.Arguments [0].Arguments [0];  	var varType = InferTypeForExpression (op.Arguments [0]' null);  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' varType);  	}  	return varType;  }  #endregion  #region Constant loading instructions  case ILCode.Ldnull:  	return typeSystem.Object;  case ILCode.Ldstr:  	return typeSystem.String;  case ILCode.Ldftn:  case ILCode.Ldvirtftn:  	return typeSystem.IntPtr;  case ILCode.Ldc_I4:  	if (IsBoolean (expectedType) && ((int)expr.Operand == 0 || (int)expr.Operand == 1))  		return typeSystem.Boolean;  	if (expectedType is PointerType && (int)expr.Operand == 0)  		return expectedType;  	if (IsIntegerOrEnum (expectedType) && OperandFitsInType (expectedType' (int)expr.Operand))  		return expectedType;  	else  		return typeSystem.Int32;  case ILCode.Ldc_I8:  	if (expectedType is PointerType && (long)expr.Operand == 0)  		return expectedType;  	if (IsIntegerOrEnum (expectedType) && GetInformationAmount (expectedType) >= NativeInt)  		return expectedType;  	else  		return typeSystem.Int64;  case ILCode.Ldc_R4:  	return typeSystem.Single;  case ILCode.Ldc_R8:  	return typeSystem.Double;  case ILCode.Ldc_Decimal:  	return new TypeReference ("System"' "Decimal"' module' module.TypeSystem.CoreLibrary' true);  case ILCode.Ldtoken:  	if (expr.Operand is TypeReference)  		return new TypeReference ("System"' "RuntimeTypeHandle"' module' module.TypeSystem.CoreLibrary' true);  	else if (expr.Operand is FieldReference)  		return new TypeReference ("System"' "RuntimeFieldHandle"' module' module.TypeSystem.CoreLibrary' true);  	else  		return new TypeReference ("System"' "RuntimeMethodHandle"' module' module.TypeSystem.CoreLibrary' true);  case ILCode.Arglist:  	return new TypeReference ("System"' "RuntimeArgumentHandle"' module' module.TypeSystem.CoreLibrary' true);  #endregion  #region Array instructions  case ILCode.Newarr:  	if (forceInferChildren) {  		var lengthType = InferTypeForExpression (expr.Arguments.Single ()' null);  		if (lengthType == typeSystem.IntPtr) {  			lengthType = typeSystem.Int64;  		} else if (lengthType == typeSystem.UIntPtr) {  			lengthType = typeSystem.UInt64;  		} else if (lengthType != typeSystem.UInt32 && lengthType != typeSystem.Int64 && lengthType != typeSystem.UInt64) {  			lengthType = typeSystem.Int32;  		}  		if (forceInferChildren) {  			InferTypeForExpression (expr.Arguments.Single ()' lengthType);  		}  	}  	return new ArrayType ((TypeReference)expr.Operand);  case ILCode.InitArray:  	var operandAsArrayType = (ArrayType)expr.Operand;  	if (forceInferChildren) {  		foreach (ILExpression arg in expr.Arguments)  			InferTypeForExpression (arg' operandAsArrayType.ElementType);  	}  	return operandAsArrayType;  case ILCode.Ldlen:  	return typeSystem.Int32;  case ILCode.Ldelem_U1:  case ILCode.Ldelem_U2:  case ILCode.Ldelem_U4:  case ILCode.Ldelem_I1:  case ILCode.Ldelem_I2:  case ILCode.Ldelem_I4:  case ILCode.Ldelem_I8:  case ILCode.Ldelem_R4:  case ILCode.Ldelem_R8:  case ILCode.Ldelem_I:  case ILCode.Ldelem_Ref: {  	ArrayType arrayType = InferTypeForExpression (expr.Arguments [0]' null) as ArrayType;  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [1]' typeSystem.Int32);  	}  	return arrayType != null ? arrayType.ElementType : null;  }  case ILCode.Ldelem_Any:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [1]' typeSystem.Int32);  	}  	return (TypeReference)expr.Operand;  case ILCode.Ldelema: {  	ArrayType arrayType = InferTypeForExpression (expr.Arguments [0]' null) as ArrayType;  	if (forceInferChildren)  		InferTypeForExpression (expr.Arguments [1]' typeSystem.Int32);  	return arrayType != null ? new ByReferenceType (arrayType.ElementType) : null;  }  case ILCode.Stelem_I:  case ILCode.Stelem_I1:  case ILCode.Stelem_I2:  case ILCode.Stelem_I4:  case ILCode.Stelem_I8:  case ILCode.Stelem_R4:  case ILCode.Stelem_R8:  case ILCode.Stelem_Ref:  case ILCode.Stelem_Any: {  	ArrayType arrayType = InferTypeForExpression (expr.Arguments [0]' null) as ArrayType;  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [1]' typeSystem.Int32);  		if (arrayType != null) {  			InferTypeForExpression (expr.Arguments [2]' arrayType.ElementType);  		}  	}  	return arrayType != null ? arrayType.ElementType : null;  }  #endregion  #region Conversion instructions  case ILCode.Conv_I1:  case ILCode.Conv_Ovf_I1:  case ILCode.Conv_Ovf_I1_Un:  	return HandleConversion (8' true' expr.Arguments [0]' expectedType' typeSystem.SByte);  case ILCode.Conv_I2:  case ILCode.Conv_Ovf_I2:  case ILCode.Conv_Ovf_I2_Un:  	return HandleConversion (16' true' expr.Arguments [0]' expectedType' typeSystem.Int16);  case ILCode.Conv_I4:  case ILCode.Conv_Ovf_I4:  case ILCode.Conv_Ovf_I4_Un:  	return HandleConversion (32' true' expr.Arguments [0]' expectedType' typeSystem.Int32);  case ILCode.Conv_I8:  case ILCode.Conv_Ovf_I8:  case ILCode.Conv_Ovf_I8_Un:  	return HandleConversion (64' true' expr.Arguments [0]' expectedType' typeSystem.Int64);  case ILCode.Conv_U1:  case ILCode.Conv_Ovf_U1:  case ILCode.Conv_Ovf_U1_Un:  	return HandleConversion (8' false' expr.Arguments [0]' expectedType' typeSystem.Byte);  case ILCode.Conv_U2:  case ILCode.Conv_Ovf_U2:  case ILCode.Conv_Ovf_U2_Un:  	return HandleConversion (16' false' expr.Arguments [0]' expectedType' typeSystem.UInt16);  case ILCode.Conv_U4:  case ILCode.Conv_Ovf_U4:  case ILCode.Conv_Ovf_U4_Un:  	return HandleConversion (32' false' expr.Arguments [0]' expectedType' typeSystem.UInt32);  case ILCode.Conv_U8:  case ILCode.Conv_Ovf_U8:  case ILCode.Conv_Ovf_U8_Un:  	return HandleConversion (64' false' expr.Arguments [0]' expectedType' typeSystem.UInt64);  case ILCode.Conv_I:  case ILCode.Conv_Ovf_I:  case ILCode.Conv_Ovf_I_Un:  	return HandleConversion (NativeInt' true' expr.Arguments [0]' expectedType' typeSystem.IntPtr);  case ILCode.Conv_U:  case ILCode.Conv_Ovf_U:  case ILCode.Conv_Ovf_U_Un:  	return HandleConversion (NativeInt' false' expr.Arguments [0]' expectedType' typeSystem.UIntPtr);  case ILCode.Conv_R4:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' typeSystem.Single);  	}  	return typeSystem.Single;  case ILCode.Conv_R8:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' typeSystem.Double);  	}  	return typeSystem.Double;  case ILCode.Conv_R_Un:  	return (expectedType != null && expectedType.MetadataType == MetadataType.Single) ? typeSystem.Single : typeSystem.Double;  case ILCode.Castclass:  case ILCode.Unbox_Any:  	return (TypeReference)expr.Operand;  case ILCode.Unbox:  	return new ByReferenceType ((TypeReference)expr.Operand);  case ILCode.Isinst: {  	// isinst performs the equivalent of a cast only for reference types;  	// value types still need to be unboxed after an isinst instruction  	TypeReference tr = (TypeReference)expr.Operand;  	return tr.IsValueType ? typeSystem.Object : tr;  }  case ILCode.Box: {  	var tr = (TypeReference)expr.Operand;  	if (forceInferChildren)  		InferTypeForExpression (expr.Arguments.Single ()' tr);  	return tr.IsValueType ? typeSystem.Object : tr;  }  #endregion  #region Comparison instructions  case ILCode.Ceq:  case ILCode.Cne:  	if (forceInferChildren)  		InferArgumentsInBinaryOperator (expr' null' null);  	return typeSystem.Boolean;  case ILCode.Clt:  case ILCode.Cgt:  case ILCode.Cle:  case ILCode.Cge:  	if (forceInferChildren)  		InferArgumentsInBinaryOperator (expr' true' null);  	return typeSystem.Boolean;  case ILCode.Clt_Un:  case ILCode.Cgt_Un:  case ILCode.Cle_Un:  case ILCode.Cge_Un:  	if (forceInferChildren)  		InferArgumentsInBinaryOperator (expr' false' null);  	return typeSystem.Boolean;  #endregion  #region Branch instructions  case ILCode.Brtrue:  	if (forceInferChildren)  		InferTypeForExpression (expr.Arguments.Single ()' typeSystem.Boolean);  	return null;  case ILCode.Br:  case ILCode.Leave:  case ILCode.Endfinally:  case ILCode.Switch:  case ILCode.Throw:  case ILCode.Rethrow:  case ILCode.LoopOrSwitchBreak:  case ILCode.LoopContinue:  case ILCode.YieldBreak:  	return null;  case ILCode.Ret:  	if (forceInferChildren && expr.Arguments.Count == 1) {  		TypeReference returnType = context.CurrentMethod.ReturnType;  		if (context.CurrentMethodIsAsync && returnType != null && returnType.Namespace == "System.Threading.Tasks") {  			if (returnType.Name == "Task") {  				returnType = typeSystem.Void;  			} else if (returnType.Name == "Task`1" && returnType.IsGenericInstance) {  				returnType = ((GenericInstanceType)returnType).GenericArguments [0];  			}  		}  		InferTypeForExpression (expr.Arguments [0]' returnType);  	}  	return null;  case ILCode.YieldReturn:  	if (forceInferChildren) {  		GenericInstanceType genericType = context.CurrentMethod.ReturnType as GenericInstanceType;  		if (genericType != null) {  			// IEnumerable<T> or IEnumerator<T>  			InferTypeForExpression (expr.Arguments [0]' genericType.GenericArguments [0]);  		} else {  			// non-generic IEnumerable or IEnumerator  			InferTypeForExpression (expr.Arguments [0]' typeSystem.Object);  		}  	}  	return null;  case ILCode.Await: {  	TypeReference taskType = InferTypeForExpression (expr.Arguments [0]' null);  	if (taskType.Name == "Task`1" && taskType.IsGenericInstance && taskType.Namespace == "System.Threading.Tasks") {  		return ((GenericInstanceType)taskType).GenericArguments [0];  	}  	return null;  }  #endregion  case ILCode.Pop:  	return null;  case ILCode.Wrap:  case ILCode.Dup: {  	var arg = expr.Arguments.Single ();  	return arg.ExpectedType = InferTypeForExpression (arg' expectedType);  }  default:  	Debug.WriteLine ("Type Inference: Can't handle " + expr.Code.GetName ());  	return null;  }  
Magic Number,Custom.Decompiler.ILAst,TypeAnalysis,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\TypeAnalysis.cs,DoInferTypeForExpression,The following statement contains a magic number: switch (expr.Code) {  #region Logical operators  case ILCode.LogicNot:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments.Single ()' typeSystem.Boolean);  	}  	return typeSystem.Boolean;  case ILCode.LogicAnd:  case ILCode.LogicOr:  	// if Operand is set the logic and/or expression is a custom operator  	// we can deal with it the same as a normal invocation.  	if (expr.Operand != null)  		goto case ILCode.Call;  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' typeSystem.Boolean);  		InferTypeForExpression (expr.Arguments [1]' typeSystem.Boolean);  	}  	return typeSystem.Boolean;  case ILCode.TernaryOp:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' typeSystem.Boolean);  	}  	return InferBinaryArguments (expr.Arguments [1]' expr.Arguments [2]' expectedType' forceInferChildren);  case ILCode.NullCoalescing:  	return InferBinaryArguments (expr.Arguments [0]' expr.Arguments [1]' expectedType' forceInferChildren);  #endregion  #region Variable load/store  case ILCode.Stloc: {  	ILVariable v = (ILVariable)expr.Operand;  	if (forceInferChildren) {  		// do not use 'expectedType' in here!  		InferTypeForExpression (expr.Arguments.Single ()' v.Type);  	}  	return v.Type;  }  case ILCode.Ldloc: {  	ILVariable v = (ILVariable)expr.Operand;  	if (v.Type == null && singleLoadVariables.Contains (v)) {  		v.Type = expectedType;  	}  	return v.Type;  }  case ILCode.Ldloca: {  	ILVariable v = (ILVariable)expr.Operand;  	if (v.Type != null)  		return new ByReferenceType (v.Type);  	else  		return null;  }  #endregion  #region Call / NewObj  case ILCode.Call:  case ILCode.Callvirt:  case ILCode.CallGetter:  case ILCode.CallvirtGetter:  case ILCode.CallSetter:  case ILCode.CallvirtSetter: {  	MethodReference method = (MethodReference)expr.Operand;  	if (forceInferChildren) {  		for (int i = 0; i < expr.Arguments.Count; i++) {  			if (i == 0 && method.HasThis) {  				InferTypeForExpression (expr.Arguments [0]' MakeRefIfValueType (method.DeclaringType' expr.GetPrefix (ILCode.Constrained)));  			} else {  				InferTypeForExpression (expr.Arguments [i]' SubstituteTypeArgs (method.Parameters [method.HasThis ? i - 1 : i].ParameterType' method));  			}  		}  	}  	if (expr.Code == ILCode.CallSetter || expr.Code == ILCode.CallvirtSetter) {  		return SubstituteTypeArgs (method.Parameters.Last ().ParameterType' method);  	} else {  		return SubstituteTypeArgs (method.ReturnType' method);  	}  }  case ILCode.Newobj: {  	MethodReference ctor = (MethodReference)expr.Operand;  	if (forceInferChildren) {  		for (int i = 0; i < ctor.Parameters.Count; i++) {  			InferTypeForExpression (expr.Arguments [i]' SubstituteTypeArgs (ctor.Parameters [i].ParameterType' ctor));  		}  	}  	return ctor.DeclaringType;  }  case ILCode.InitObject:  case ILCode.InitCollection:  	return InferTypeForExpression (expr.Arguments [0]' expectedType);  case ILCode.InitializedObject:  	// expectedType should always be known due to the parent method call / property setter  	Debug.Assert (expectedType != null);  	return expectedType;  #endregion  #region Load/Store Fields  case ILCode.Ldfld:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' MakeRefIfValueType (((FieldReference)expr.Operand).DeclaringType' expr.GetPrefix (ILCode.Constrained)));  	}  	return GetFieldType ((FieldReference)expr.Operand);  case ILCode.Ldsfld:  	return GetFieldType ((FieldReference)expr.Operand);  case ILCode.Ldflda:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' MakeRefIfValueType (((FieldReference)expr.Operand).DeclaringType' expr.GetPrefix (ILCode.Constrained)));  	}  	return new ByReferenceType (GetFieldType ((FieldReference)expr.Operand));  case ILCode.Ldsflda:  	return new ByReferenceType (GetFieldType ((FieldReference)expr.Operand));  case ILCode.Stfld:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' MakeRefIfValueType (((FieldReference)expr.Operand).DeclaringType' expr.GetPrefix (ILCode.Constrained)));  		InferTypeForExpression (expr.Arguments [1]' GetFieldType ((FieldReference)expr.Operand));  	}  	return GetFieldType ((FieldReference)expr.Operand);  case ILCode.Stsfld:  	if (forceInferChildren)  		InferTypeForExpression (expr.Arguments [0]' GetFieldType ((FieldReference)expr.Operand));  	return GetFieldType ((FieldReference)expr.Operand);  #endregion  #region Reference/Pointer instructions  case ILCode.Ldind_Ref:  	return UnpackPointer (InferTypeForExpression (expr.Arguments [0]' null));  case ILCode.Stind_Ref:  	if (forceInferChildren) {  		TypeReference elementType = UnpackPointer (InferTypeForExpression (expr.Arguments [0]' null));  		InferTypeForExpression (expr.Arguments [1]' elementType);  	}  	return null;  case ILCode.Ldobj: {  	TypeReference type = (TypeReference)expr.Operand;  	var argType = InferTypeForExpression (expr.Arguments [0]' null);  	if (argType is PointerType || argType is ByReferenceType) {  		var elementType = ((TypeSpecification)argType).ElementType;  		int infoAmount = GetInformationAmount (elementType);  		if (infoAmount == 1 && GetInformationAmount (type) == 8) {  			// A bool can be loaded from both bytes and sbytes.  			type = elementType;  		}  		if (infoAmount >= 8 && infoAmount <= 64 && infoAmount == GetInformationAmount (type)) {  			// An integer can be loaded as another integer of the same size.  			// For integers smaller than 32 bit' the signs must match (as loading performs sign extension)  			bool? elementTypeIsSigned = IsSigned (elementType);  			bool? typeIsSigned = IsSigned (type);  			if (elementTypeIsSigned != null && typeIsSigned != null) {  				if (infoAmount >= 32 || elementTypeIsSigned == typeIsSigned)  					type = elementType;  			}  		}  	}  	if (argType is PointerType)  		InferTypeForExpression (expr.Arguments [0]' new PointerType (type));  	else  		InferTypeForExpression (expr.Arguments [0]' new ByReferenceType (type));  	return type;  }  case ILCode.Stobj: {  	TypeReference operandType = (TypeReference)expr.Operand;  	TypeReference pointerType = InferTypeForExpression (expr.Arguments [0]' new ByReferenceType (operandType));  	TypeReference elementType;  	if (pointerType is PointerType)  		elementType = ((PointerType)pointerType).ElementType;  	else if (pointerType is ByReferenceType)  		elementType = ((ByReferenceType)pointerType).ElementType;  	else  		elementType = null;  	if (elementType != null) {  		// An integer can be stored in any other integer of the same size.  		int infoAmount = GetInformationAmount (elementType);  		if (infoAmount == 1 && GetInformationAmount (operandType) == 8)  			operandType = elementType;  		else if (infoAmount == GetInformationAmount (operandType) && IsSigned (elementType) != null && IsSigned (operandType) != null)  			operandType = elementType;  	}  	if (forceInferChildren) {  		if (pointerType is PointerType)  			InferTypeForExpression (expr.Arguments [0]' new PointerType (operandType));  		else if (!IsSameType (operandType' expr.Operand as TypeReference))  			InferTypeForExpression (expr.Arguments [0]' new ByReferenceType (operandType));  		InferTypeForExpression (expr.Arguments [1]' operandType);  	}  	return operandType;  }  case ILCode.Initobj:  	return null;  case ILCode.DefaultValue:  	return (TypeReference)expr.Operand;  case ILCode.Localloc:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' typeSystem.Int32);  	}  	if (expectedType is PointerType)  		return expectedType;  	else  		return typeSystem.IntPtr;  case ILCode.Sizeof:  	return typeSystem.Int32;  case ILCode.PostIncrement:  case ILCode.PostIncrement_Ovf:  case ILCode.PostIncrement_Ovf_Un: {  	TypeReference elementType = UnpackPointer (InferTypeForExpression (expr.Arguments [0]' null));  	if (forceInferChildren && elementType != null) {  		// Assign expected type to the child expression  		InferTypeForExpression (expr.Arguments [0]' new ByReferenceType (elementType));  	}  	return elementType;  }  case ILCode.Mkrefany:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' (TypeReference)expr.Operand);  	}  	return typeSystem.TypedReference;  case ILCode.Refanytype:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' typeSystem.TypedReference);  	}  	return new TypeReference ("System"' "RuntimeTypeHandle"' module' module.TypeSystem.CoreLibrary' true);  case ILCode.Refanyval:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' typeSystem.TypedReference);  	}  	return new ByReferenceType ((TypeReference)expr.Operand);  case ILCode.AddressOf: {  	TypeReference t = InferTypeForExpression (expr.Arguments [0]' UnpackPointer (expectedType));  	return t != null ? new ByReferenceType (t) : null;  }  case ILCode.ValueOf:  	return GetNullableTypeArgument (InferTypeForExpression (expr.Arguments [0]' CreateNullableType (expectedType)));  case ILCode.NullableOf:  	return CreateNullableType (InferTypeForExpression (expr.Arguments [0]' GetNullableTypeArgument (expectedType)));  #endregion  #region Arithmetic instructions  case ILCode.Not:  // bitwise complement  case ILCode.Neg:  	return InferTypeForExpression (expr.Arguments.Single ()' expectedType);  case ILCode.Add:  	return InferArgumentsInAddition (expr' null' expectedType);  case ILCode.Sub:  	return InferArgumentsInSubtraction (expr' null' expectedType);  case ILCode.Mul:  case ILCode.Or:  case ILCode.And:  case ILCode.Xor:  	return InferArgumentsInBinaryOperator (expr' null' expectedType);  case ILCode.Add_Ovf:  	return InferArgumentsInAddition (expr' true' expectedType);  case ILCode.Sub_Ovf:  	return InferArgumentsInSubtraction (expr' true' expectedType);  case ILCode.Mul_Ovf:  case ILCode.Div:  case ILCode.Rem:  	return InferArgumentsInBinaryOperator (expr' true' expectedType);  case ILCode.Add_Ovf_Un:  	return InferArgumentsInAddition (expr' false' expectedType);  case ILCode.Sub_Ovf_Un:  	return InferArgumentsInSubtraction (expr' false' expectedType);  case ILCode.Mul_Ovf_Un:  case ILCode.Div_Un:  case ILCode.Rem_Un:  	return InferArgumentsInBinaryOperator (expr' false' expectedType);  case ILCode.Shl:  	if (forceInferChildren)  		InferTypeForExpression (expr.Arguments [1]' typeSystem.Int32);  	if (expectedType != null && (expectedType.MetadataType == MetadataType.Int32 || expectedType.MetadataType == MetadataType.UInt32 || expectedType.MetadataType == MetadataType.Int64 || expectedType.MetadataType == MetadataType.UInt64))  		return NumericPromotion (InferTypeForExpression (expr.Arguments [0]' expectedType));  	else  		return NumericPromotion (InferTypeForExpression (expr.Arguments [0]' null));  case ILCode.Shr:  case ILCode.Shr_Un: {  	if (forceInferChildren)  		InferTypeForExpression (expr.Arguments [1]' typeSystem.Int32);  	TypeReference type = NumericPromotion (InferTypeForExpression (expr.Arguments [0]' null));  	TypeReference expectedInputType = null;  	switch (type.MetadataType) {  	case MetadataType.Int32:  		if (expr.Code == ILCode.Shr_Un)  			expectedInputType = typeSystem.UInt32;  		break;  	case MetadataType.UInt32:  		if (expr.Code == ILCode.Shr)  			expectedInputType = typeSystem.Int32;  		break;  	case MetadataType.Int64:  		if (expr.Code == ILCode.Shr_Un)  			expectedInputType = typeSystem.UInt64;  		break;  	case MetadataType.UInt64:  		if (expr.Code == ILCode.Shr)  			expectedInputType = typeSystem.UInt64;  		break;  	}  	if (expectedInputType != null) {  		InferTypeForExpression (expr.Arguments [0]' expectedInputType);  		return expectedInputType;  	} else {  		return type;  	}  }  case ILCode.CompoundAssignment: {  	var op = expr.Arguments [0];  	if (op.Code == ILCode.NullableOf)  		op = op.Arguments [0].Arguments [0];  	var varType = InferTypeForExpression (op.Arguments [0]' null);  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' varType);  	}  	return varType;  }  #endregion  #region Constant loading instructions  case ILCode.Ldnull:  	return typeSystem.Object;  case ILCode.Ldstr:  	return typeSystem.String;  case ILCode.Ldftn:  case ILCode.Ldvirtftn:  	return typeSystem.IntPtr;  case ILCode.Ldc_I4:  	if (IsBoolean (expectedType) && ((int)expr.Operand == 0 || (int)expr.Operand == 1))  		return typeSystem.Boolean;  	if (expectedType is PointerType && (int)expr.Operand == 0)  		return expectedType;  	if (IsIntegerOrEnum (expectedType) && OperandFitsInType (expectedType' (int)expr.Operand))  		return expectedType;  	else  		return typeSystem.Int32;  case ILCode.Ldc_I8:  	if (expectedType is PointerType && (long)expr.Operand == 0)  		return expectedType;  	if (IsIntegerOrEnum (expectedType) && GetInformationAmount (expectedType) >= NativeInt)  		return expectedType;  	else  		return typeSystem.Int64;  case ILCode.Ldc_R4:  	return typeSystem.Single;  case ILCode.Ldc_R8:  	return typeSystem.Double;  case ILCode.Ldc_Decimal:  	return new TypeReference ("System"' "Decimal"' module' module.TypeSystem.CoreLibrary' true);  case ILCode.Ldtoken:  	if (expr.Operand is TypeReference)  		return new TypeReference ("System"' "RuntimeTypeHandle"' module' module.TypeSystem.CoreLibrary' true);  	else if (expr.Operand is FieldReference)  		return new TypeReference ("System"' "RuntimeFieldHandle"' module' module.TypeSystem.CoreLibrary' true);  	else  		return new TypeReference ("System"' "RuntimeMethodHandle"' module' module.TypeSystem.CoreLibrary' true);  case ILCode.Arglist:  	return new TypeReference ("System"' "RuntimeArgumentHandle"' module' module.TypeSystem.CoreLibrary' true);  #endregion  #region Array instructions  case ILCode.Newarr:  	if (forceInferChildren) {  		var lengthType = InferTypeForExpression (expr.Arguments.Single ()' null);  		if (lengthType == typeSystem.IntPtr) {  			lengthType = typeSystem.Int64;  		} else if (lengthType == typeSystem.UIntPtr) {  			lengthType = typeSystem.UInt64;  		} else if (lengthType != typeSystem.UInt32 && lengthType != typeSystem.Int64 && lengthType != typeSystem.UInt64) {  			lengthType = typeSystem.Int32;  		}  		if (forceInferChildren) {  			InferTypeForExpression (expr.Arguments.Single ()' lengthType);  		}  	}  	return new ArrayType ((TypeReference)expr.Operand);  case ILCode.InitArray:  	var operandAsArrayType = (ArrayType)expr.Operand;  	if (forceInferChildren) {  		foreach (ILExpression arg in expr.Arguments)  			InferTypeForExpression (arg' operandAsArrayType.ElementType);  	}  	return operandAsArrayType;  case ILCode.Ldlen:  	return typeSystem.Int32;  case ILCode.Ldelem_U1:  case ILCode.Ldelem_U2:  case ILCode.Ldelem_U4:  case ILCode.Ldelem_I1:  case ILCode.Ldelem_I2:  case ILCode.Ldelem_I4:  case ILCode.Ldelem_I8:  case ILCode.Ldelem_R4:  case ILCode.Ldelem_R8:  case ILCode.Ldelem_I:  case ILCode.Ldelem_Ref: {  	ArrayType arrayType = InferTypeForExpression (expr.Arguments [0]' null) as ArrayType;  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [1]' typeSystem.Int32);  	}  	return arrayType != null ? arrayType.ElementType : null;  }  case ILCode.Ldelem_Any:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [1]' typeSystem.Int32);  	}  	return (TypeReference)expr.Operand;  case ILCode.Ldelema: {  	ArrayType arrayType = InferTypeForExpression (expr.Arguments [0]' null) as ArrayType;  	if (forceInferChildren)  		InferTypeForExpression (expr.Arguments [1]' typeSystem.Int32);  	return arrayType != null ? new ByReferenceType (arrayType.ElementType) : null;  }  case ILCode.Stelem_I:  case ILCode.Stelem_I1:  case ILCode.Stelem_I2:  case ILCode.Stelem_I4:  case ILCode.Stelem_I8:  case ILCode.Stelem_R4:  case ILCode.Stelem_R8:  case ILCode.Stelem_Ref:  case ILCode.Stelem_Any: {  	ArrayType arrayType = InferTypeForExpression (expr.Arguments [0]' null) as ArrayType;  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [1]' typeSystem.Int32);  		if (arrayType != null) {  			InferTypeForExpression (expr.Arguments [2]' arrayType.ElementType);  		}  	}  	return arrayType != null ? arrayType.ElementType : null;  }  #endregion  #region Conversion instructions  case ILCode.Conv_I1:  case ILCode.Conv_Ovf_I1:  case ILCode.Conv_Ovf_I1_Un:  	return HandleConversion (8' true' expr.Arguments [0]' expectedType' typeSystem.SByte);  case ILCode.Conv_I2:  case ILCode.Conv_Ovf_I2:  case ILCode.Conv_Ovf_I2_Un:  	return HandleConversion (16' true' expr.Arguments [0]' expectedType' typeSystem.Int16);  case ILCode.Conv_I4:  case ILCode.Conv_Ovf_I4:  case ILCode.Conv_Ovf_I4_Un:  	return HandleConversion (32' true' expr.Arguments [0]' expectedType' typeSystem.Int32);  case ILCode.Conv_I8:  case ILCode.Conv_Ovf_I8:  case ILCode.Conv_Ovf_I8_Un:  	return HandleConversion (64' true' expr.Arguments [0]' expectedType' typeSystem.Int64);  case ILCode.Conv_U1:  case ILCode.Conv_Ovf_U1:  case ILCode.Conv_Ovf_U1_Un:  	return HandleConversion (8' false' expr.Arguments [0]' expectedType' typeSystem.Byte);  case ILCode.Conv_U2:  case ILCode.Conv_Ovf_U2:  case ILCode.Conv_Ovf_U2_Un:  	return HandleConversion (16' false' expr.Arguments [0]' expectedType' typeSystem.UInt16);  case ILCode.Conv_U4:  case ILCode.Conv_Ovf_U4:  case ILCode.Conv_Ovf_U4_Un:  	return HandleConversion (32' false' expr.Arguments [0]' expectedType' typeSystem.UInt32);  case ILCode.Conv_U8:  case ILCode.Conv_Ovf_U8:  case ILCode.Conv_Ovf_U8_Un:  	return HandleConversion (64' false' expr.Arguments [0]' expectedType' typeSystem.UInt64);  case ILCode.Conv_I:  case ILCode.Conv_Ovf_I:  case ILCode.Conv_Ovf_I_Un:  	return HandleConversion (NativeInt' true' expr.Arguments [0]' expectedType' typeSystem.IntPtr);  case ILCode.Conv_U:  case ILCode.Conv_Ovf_U:  case ILCode.Conv_Ovf_U_Un:  	return HandleConversion (NativeInt' false' expr.Arguments [0]' expectedType' typeSystem.UIntPtr);  case ILCode.Conv_R4:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' typeSystem.Single);  	}  	return typeSystem.Single;  case ILCode.Conv_R8:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' typeSystem.Double);  	}  	return typeSystem.Double;  case ILCode.Conv_R_Un:  	return (expectedType != null && expectedType.MetadataType == MetadataType.Single) ? typeSystem.Single : typeSystem.Double;  case ILCode.Castclass:  case ILCode.Unbox_Any:  	return (TypeReference)expr.Operand;  case ILCode.Unbox:  	return new ByReferenceType ((TypeReference)expr.Operand);  case ILCode.Isinst: {  	// isinst performs the equivalent of a cast only for reference types;  	// value types still need to be unboxed after an isinst instruction  	TypeReference tr = (TypeReference)expr.Operand;  	return tr.IsValueType ? typeSystem.Object : tr;  }  case ILCode.Box: {  	var tr = (TypeReference)expr.Operand;  	if (forceInferChildren)  		InferTypeForExpression (expr.Arguments.Single ()' tr);  	return tr.IsValueType ? typeSystem.Object : tr;  }  #endregion  #region Comparison instructions  case ILCode.Ceq:  case ILCode.Cne:  	if (forceInferChildren)  		InferArgumentsInBinaryOperator (expr' null' null);  	return typeSystem.Boolean;  case ILCode.Clt:  case ILCode.Cgt:  case ILCode.Cle:  case ILCode.Cge:  	if (forceInferChildren)  		InferArgumentsInBinaryOperator (expr' true' null);  	return typeSystem.Boolean;  case ILCode.Clt_Un:  case ILCode.Cgt_Un:  case ILCode.Cle_Un:  case ILCode.Cge_Un:  	if (forceInferChildren)  		InferArgumentsInBinaryOperator (expr' false' null);  	return typeSystem.Boolean;  #endregion  #region Branch instructions  case ILCode.Brtrue:  	if (forceInferChildren)  		InferTypeForExpression (expr.Arguments.Single ()' typeSystem.Boolean);  	return null;  case ILCode.Br:  case ILCode.Leave:  case ILCode.Endfinally:  case ILCode.Switch:  case ILCode.Throw:  case ILCode.Rethrow:  case ILCode.LoopOrSwitchBreak:  case ILCode.LoopContinue:  case ILCode.YieldBreak:  	return null;  case ILCode.Ret:  	if (forceInferChildren && expr.Arguments.Count == 1) {  		TypeReference returnType = context.CurrentMethod.ReturnType;  		if (context.CurrentMethodIsAsync && returnType != null && returnType.Namespace == "System.Threading.Tasks") {  			if (returnType.Name == "Task") {  				returnType = typeSystem.Void;  			} else if (returnType.Name == "Task`1" && returnType.IsGenericInstance) {  				returnType = ((GenericInstanceType)returnType).GenericArguments [0];  			}  		}  		InferTypeForExpression (expr.Arguments [0]' returnType);  	}  	return null;  case ILCode.YieldReturn:  	if (forceInferChildren) {  		GenericInstanceType genericType = context.CurrentMethod.ReturnType as GenericInstanceType;  		if (genericType != null) {  			// IEnumerable<T> or IEnumerator<T>  			InferTypeForExpression (expr.Arguments [0]' genericType.GenericArguments [0]);  		} else {  			// non-generic IEnumerable or IEnumerator  			InferTypeForExpression (expr.Arguments [0]' typeSystem.Object);  		}  	}  	return null;  case ILCode.Await: {  	TypeReference taskType = InferTypeForExpression (expr.Arguments [0]' null);  	if (taskType.Name == "Task`1" && taskType.IsGenericInstance && taskType.Namespace == "System.Threading.Tasks") {  		return ((GenericInstanceType)taskType).GenericArguments [0];  	}  	return null;  }  #endregion  case ILCode.Pop:  	return null;  case ILCode.Wrap:  case ILCode.Dup: {  	var arg = expr.Arguments.Single ();  	return arg.ExpectedType = InferTypeForExpression (arg' expectedType);  }  default:  	Debug.WriteLine ("Type Inference: Can't handle " + expr.Code.GetName ());  	return null;  }  
Magic Number,Custom.Decompiler.ILAst,TypeAnalysis,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\TypeAnalysis.cs,DoInferTypeForExpression,The following statement contains a magic number: switch (expr.Code) {  #region Logical operators  case ILCode.LogicNot:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments.Single ()' typeSystem.Boolean);  	}  	return typeSystem.Boolean;  case ILCode.LogicAnd:  case ILCode.LogicOr:  	// if Operand is set the logic and/or expression is a custom operator  	// we can deal with it the same as a normal invocation.  	if (expr.Operand != null)  		goto case ILCode.Call;  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' typeSystem.Boolean);  		InferTypeForExpression (expr.Arguments [1]' typeSystem.Boolean);  	}  	return typeSystem.Boolean;  case ILCode.TernaryOp:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' typeSystem.Boolean);  	}  	return InferBinaryArguments (expr.Arguments [1]' expr.Arguments [2]' expectedType' forceInferChildren);  case ILCode.NullCoalescing:  	return InferBinaryArguments (expr.Arguments [0]' expr.Arguments [1]' expectedType' forceInferChildren);  #endregion  #region Variable load/store  case ILCode.Stloc: {  	ILVariable v = (ILVariable)expr.Operand;  	if (forceInferChildren) {  		// do not use 'expectedType' in here!  		InferTypeForExpression (expr.Arguments.Single ()' v.Type);  	}  	return v.Type;  }  case ILCode.Ldloc: {  	ILVariable v = (ILVariable)expr.Operand;  	if (v.Type == null && singleLoadVariables.Contains (v)) {  		v.Type = expectedType;  	}  	return v.Type;  }  case ILCode.Ldloca: {  	ILVariable v = (ILVariable)expr.Operand;  	if (v.Type != null)  		return new ByReferenceType (v.Type);  	else  		return null;  }  #endregion  #region Call / NewObj  case ILCode.Call:  case ILCode.Callvirt:  case ILCode.CallGetter:  case ILCode.CallvirtGetter:  case ILCode.CallSetter:  case ILCode.CallvirtSetter: {  	MethodReference method = (MethodReference)expr.Operand;  	if (forceInferChildren) {  		for (int i = 0; i < expr.Arguments.Count; i++) {  			if (i == 0 && method.HasThis) {  				InferTypeForExpression (expr.Arguments [0]' MakeRefIfValueType (method.DeclaringType' expr.GetPrefix (ILCode.Constrained)));  			} else {  				InferTypeForExpression (expr.Arguments [i]' SubstituteTypeArgs (method.Parameters [method.HasThis ? i - 1 : i].ParameterType' method));  			}  		}  	}  	if (expr.Code == ILCode.CallSetter || expr.Code == ILCode.CallvirtSetter) {  		return SubstituteTypeArgs (method.Parameters.Last ().ParameterType' method);  	} else {  		return SubstituteTypeArgs (method.ReturnType' method);  	}  }  case ILCode.Newobj: {  	MethodReference ctor = (MethodReference)expr.Operand;  	if (forceInferChildren) {  		for (int i = 0; i < ctor.Parameters.Count; i++) {  			InferTypeForExpression (expr.Arguments [i]' SubstituteTypeArgs (ctor.Parameters [i].ParameterType' ctor));  		}  	}  	return ctor.DeclaringType;  }  case ILCode.InitObject:  case ILCode.InitCollection:  	return InferTypeForExpression (expr.Arguments [0]' expectedType);  case ILCode.InitializedObject:  	// expectedType should always be known due to the parent method call / property setter  	Debug.Assert (expectedType != null);  	return expectedType;  #endregion  #region Load/Store Fields  case ILCode.Ldfld:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' MakeRefIfValueType (((FieldReference)expr.Operand).DeclaringType' expr.GetPrefix (ILCode.Constrained)));  	}  	return GetFieldType ((FieldReference)expr.Operand);  case ILCode.Ldsfld:  	return GetFieldType ((FieldReference)expr.Operand);  case ILCode.Ldflda:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' MakeRefIfValueType (((FieldReference)expr.Operand).DeclaringType' expr.GetPrefix (ILCode.Constrained)));  	}  	return new ByReferenceType (GetFieldType ((FieldReference)expr.Operand));  case ILCode.Ldsflda:  	return new ByReferenceType (GetFieldType ((FieldReference)expr.Operand));  case ILCode.Stfld:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' MakeRefIfValueType (((FieldReference)expr.Operand).DeclaringType' expr.GetPrefix (ILCode.Constrained)));  		InferTypeForExpression (expr.Arguments [1]' GetFieldType ((FieldReference)expr.Operand));  	}  	return GetFieldType ((FieldReference)expr.Operand);  case ILCode.Stsfld:  	if (forceInferChildren)  		InferTypeForExpression (expr.Arguments [0]' GetFieldType ((FieldReference)expr.Operand));  	return GetFieldType ((FieldReference)expr.Operand);  #endregion  #region Reference/Pointer instructions  case ILCode.Ldind_Ref:  	return UnpackPointer (InferTypeForExpression (expr.Arguments [0]' null));  case ILCode.Stind_Ref:  	if (forceInferChildren) {  		TypeReference elementType = UnpackPointer (InferTypeForExpression (expr.Arguments [0]' null));  		InferTypeForExpression (expr.Arguments [1]' elementType);  	}  	return null;  case ILCode.Ldobj: {  	TypeReference type = (TypeReference)expr.Operand;  	var argType = InferTypeForExpression (expr.Arguments [0]' null);  	if (argType is PointerType || argType is ByReferenceType) {  		var elementType = ((TypeSpecification)argType).ElementType;  		int infoAmount = GetInformationAmount (elementType);  		if (infoAmount == 1 && GetInformationAmount (type) == 8) {  			// A bool can be loaded from both bytes and sbytes.  			type = elementType;  		}  		if (infoAmount >= 8 && infoAmount <= 64 && infoAmount == GetInformationAmount (type)) {  			// An integer can be loaded as another integer of the same size.  			// For integers smaller than 32 bit' the signs must match (as loading performs sign extension)  			bool? elementTypeIsSigned = IsSigned (elementType);  			bool? typeIsSigned = IsSigned (type);  			if (elementTypeIsSigned != null && typeIsSigned != null) {  				if (infoAmount >= 32 || elementTypeIsSigned == typeIsSigned)  					type = elementType;  			}  		}  	}  	if (argType is PointerType)  		InferTypeForExpression (expr.Arguments [0]' new PointerType (type));  	else  		InferTypeForExpression (expr.Arguments [0]' new ByReferenceType (type));  	return type;  }  case ILCode.Stobj: {  	TypeReference operandType = (TypeReference)expr.Operand;  	TypeReference pointerType = InferTypeForExpression (expr.Arguments [0]' new ByReferenceType (operandType));  	TypeReference elementType;  	if (pointerType is PointerType)  		elementType = ((PointerType)pointerType).ElementType;  	else if (pointerType is ByReferenceType)  		elementType = ((ByReferenceType)pointerType).ElementType;  	else  		elementType = null;  	if (elementType != null) {  		// An integer can be stored in any other integer of the same size.  		int infoAmount = GetInformationAmount (elementType);  		if (infoAmount == 1 && GetInformationAmount (operandType) == 8)  			operandType = elementType;  		else if (infoAmount == GetInformationAmount (operandType) && IsSigned (elementType) != null && IsSigned (operandType) != null)  			operandType = elementType;  	}  	if (forceInferChildren) {  		if (pointerType is PointerType)  			InferTypeForExpression (expr.Arguments [0]' new PointerType (operandType));  		else if (!IsSameType (operandType' expr.Operand as TypeReference))  			InferTypeForExpression (expr.Arguments [0]' new ByReferenceType (operandType));  		InferTypeForExpression (expr.Arguments [1]' operandType);  	}  	return operandType;  }  case ILCode.Initobj:  	return null;  case ILCode.DefaultValue:  	return (TypeReference)expr.Operand;  case ILCode.Localloc:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' typeSystem.Int32);  	}  	if (expectedType is PointerType)  		return expectedType;  	else  		return typeSystem.IntPtr;  case ILCode.Sizeof:  	return typeSystem.Int32;  case ILCode.PostIncrement:  case ILCode.PostIncrement_Ovf:  case ILCode.PostIncrement_Ovf_Un: {  	TypeReference elementType = UnpackPointer (InferTypeForExpression (expr.Arguments [0]' null));  	if (forceInferChildren && elementType != null) {  		// Assign expected type to the child expression  		InferTypeForExpression (expr.Arguments [0]' new ByReferenceType (elementType));  	}  	return elementType;  }  case ILCode.Mkrefany:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' (TypeReference)expr.Operand);  	}  	return typeSystem.TypedReference;  case ILCode.Refanytype:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' typeSystem.TypedReference);  	}  	return new TypeReference ("System"' "RuntimeTypeHandle"' module' module.TypeSystem.CoreLibrary' true);  case ILCode.Refanyval:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' typeSystem.TypedReference);  	}  	return new ByReferenceType ((TypeReference)expr.Operand);  case ILCode.AddressOf: {  	TypeReference t = InferTypeForExpression (expr.Arguments [0]' UnpackPointer (expectedType));  	return t != null ? new ByReferenceType (t) : null;  }  case ILCode.ValueOf:  	return GetNullableTypeArgument (InferTypeForExpression (expr.Arguments [0]' CreateNullableType (expectedType)));  case ILCode.NullableOf:  	return CreateNullableType (InferTypeForExpression (expr.Arguments [0]' GetNullableTypeArgument (expectedType)));  #endregion  #region Arithmetic instructions  case ILCode.Not:  // bitwise complement  case ILCode.Neg:  	return InferTypeForExpression (expr.Arguments.Single ()' expectedType);  case ILCode.Add:  	return InferArgumentsInAddition (expr' null' expectedType);  case ILCode.Sub:  	return InferArgumentsInSubtraction (expr' null' expectedType);  case ILCode.Mul:  case ILCode.Or:  case ILCode.And:  case ILCode.Xor:  	return InferArgumentsInBinaryOperator (expr' null' expectedType);  case ILCode.Add_Ovf:  	return InferArgumentsInAddition (expr' true' expectedType);  case ILCode.Sub_Ovf:  	return InferArgumentsInSubtraction (expr' true' expectedType);  case ILCode.Mul_Ovf:  case ILCode.Div:  case ILCode.Rem:  	return InferArgumentsInBinaryOperator (expr' true' expectedType);  case ILCode.Add_Ovf_Un:  	return InferArgumentsInAddition (expr' false' expectedType);  case ILCode.Sub_Ovf_Un:  	return InferArgumentsInSubtraction (expr' false' expectedType);  case ILCode.Mul_Ovf_Un:  case ILCode.Div_Un:  case ILCode.Rem_Un:  	return InferArgumentsInBinaryOperator (expr' false' expectedType);  case ILCode.Shl:  	if (forceInferChildren)  		InferTypeForExpression (expr.Arguments [1]' typeSystem.Int32);  	if (expectedType != null && (expectedType.MetadataType == MetadataType.Int32 || expectedType.MetadataType == MetadataType.UInt32 || expectedType.MetadataType == MetadataType.Int64 || expectedType.MetadataType == MetadataType.UInt64))  		return NumericPromotion (InferTypeForExpression (expr.Arguments [0]' expectedType));  	else  		return NumericPromotion (InferTypeForExpression (expr.Arguments [0]' null));  case ILCode.Shr:  case ILCode.Shr_Un: {  	if (forceInferChildren)  		InferTypeForExpression (expr.Arguments [1]' typeSystem.Int32);  	TypeReference type = NumericPromotion (InferTypeForExpression (expr.Arguments [0]' null));  	TypeReference expectedInputType = null;  	switch (type.MetadataType) {  	case MetadataType.Int32:  		if (expr.Code == ILCode.Shr_Un)  			expectedInputType = typeSystem.UInt32;  		break;  	case MetadataType.UInt32:  		if (expr.Code == ILCode.Shr)  			expectedInputType = typeSystem.Int32;  		break;  	case MetadataType.Int64:  		if (expr.Code == ILCode.Shr_Un)  			expectedInputType = typeSystem.UInt64;  		break;  	case MetadataType.UInt64:  		if (expr.Code == ILCode.Shr)  			expectedInputType = typeSystem.UInt64;  		break;  	}  	if (expectedInputType != null) {  		InferTypeForExpression (expr.Arguments [0]' expectedInputType);  		return expectedInputType;  	} else {  		return type;  	}  }  case ILCode.CompoundAssignment: {  	var op = expr.Arguments [0];  	if (op.Code == ILCode.NullableOf)  		op = op.Arguments [0].Arguments [0];  	var varType = InferTypeForExpression (op.Arguments [0]' null);  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' varType);  	}  	return varType;  }  #endregion  #region Constant loading instructions  case ILCode.Ldnull:  	return typeSystem.Object;  case ILCode.Ldstr:  	return typeSystem.String;  case ILCode.Ldftn:  case ILCode.Ldvirtftn:  	return typeSystem.IntPtr;  case ILCode.Ldc_I4:  	if (IsBoolean (expectedType) && ((int)expr.Operand == 0 || (int)expr.Operand == 1))  		return typeSystem.Boolean;  	if (expectedType is PointerType && (int)expr.Operand == 0)  		return expectedType;  	if (IsIntegerOrEnum (expectedType) && OperandFitsInType (expectedType' (int)expr.Operand))  		return expectedType;  	else  		return typeSystem.Int32;  case ILCode.Ldc_I8:  	if (expectedType is PointerType && (long)expr.Operand == 0)  		return expectedType;  	if (IsIntegerOrEnum (expectedType) && GetInformationAmount (expectedType) >= NativeInt)  		return expectedType;  	else  		return typeSystem.Int64;  case ILCode.Ldc_R4:  	return typeSystem.Single;  case ILCode.Ldc_R8:  	return typeSystem.Double;  case ILCode.Ldc_Decimal:  	return new TypeReference ("System"' "Decimal"' module' module.TypeSystem.CoreLibrary' true);  case ILCode.Ldtoken:  	if (expr.Operand is TypeReference)  		return new TypeReference ("System"' "RuntimeTypeHandle"' module' module.TypeSystem.CoreLibrary' true);  	else if (expr.Operand is FieldReference)  		return new TypeReference ("System"' "RuntimeFieldHandle"' module' module.TypeSystem.CoreLibrary' true);  	else  		return new TypeReference ("System"' "RuntimeMethodHandle"' module' module.TypeSystem.CoreLibrary' true);  case ILCode.Arglist:  	return new TypeReference ("System"' "RuntimeArgumentHandle"' module' module.TypeSystem.CoreLibrary' true);  #endregion  #region Array instructions  case ILCode.Newarr:  	if (forceInferChildren) {  		var lengthType = InferTypeForExpression (expr.Arguments.Single ()' null);  		if (lengthType == typeSystem.IntPtr) {  			lengthType = typeSystem.Int64;  		} else if (lengthType == typeSystem.UIntPtr) {  			lengthType = typeSystem.UInt64;  		} else if (lengthType != typeSystem.UInt32 && lengthType != typeSystem.Int64 && lengthType != typeSystem.UInt64) {  			lengthType = typeSystem.Int32;  		}  		if (forceInferChildren) {  			InferTypeForExpression (expr.Arguments.Single ()' lengthType);  		}  	}  	return new ArrayType ((TypeReference)expr.Operand);  case ILCode.InitArray:  	var operandAsArrayType = (ArrayType)expr.Operand;  	if (forceInferChildren) {  		foreach (ILExpression arg in expr.Arguments)  			InferTypeForExpression (arg' operandAsArrayType.ElementType);  	}  	return operandAsArrayType;  case ILCode.Ldlen:  	return typeSystem.Int32;  case ILCode.Ldelem_U1:  case ILCode.Ldelem_U2:  case ILCode.Ldelem_U4:  case ILCode.Ldelem_I1:  case ILCode.Ldelem_I2:  case ILCode.Ldelem_I4:  case ILCode.Ldelem_I8:  case ILCode.Ldelem_R4:  case ILCode.Ldelem_R8:  case ILCode.Ldelem_I:  case ILCode.Ldelem_Ref: {  	ArrayType arrayType = InferTypeForExpression (expr.Arguments [0]' null) as ArrayType;  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [1]' typeSystem.Int32);  	}  	return arrayType != null ? arrayType.ElementType : null;  }  case ILCode.Ldelem_Any:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [1]' typeSystem.Int32);  	}  	return (TypeReference)expr.Operand;  case ILCode.Ldelema: {  	ArrayType arrayType = InferTypeForExpression (expr.Arguments [0]' null) as ArrayType;  	if (forceInferChildren)  		InferTypeForExpression (expr.Arguments [1]' typeSystem.Int32);  	return arrayType != null ? new ByReferenceType (arrayType.ElementType) : null;  }  case ILCode.Stelem_I:  case ILCode.Stelem_I1:  case ILCode.Stelem_I2:  case ILCode.Stelem_I4:  case ILCode.Stelem_I8:  case ILCode.Stelem_R4:  case ILCode.Stelem_R8:  case ILCode.Stelem_Ref:  case ILCode.Stelem_Any: {  	ArrayType arrayType = InferTypeForExpression (expr.Arguments [0]' null) as ArrayType;  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [1]' typeSystem.Int32);  		if (arrayType != null) {  			InferTypeForExpression (expr.Arguments [2]' arrayType.ElementType);  		}  	}  	return arrayType != null ? arrayType.ElementType : null;  }  #endregion  #region Conversion instructions  case ILCode.Conv_I1:  case ILCode.Conv_Ovf_I1:  case ILCode.Conv_Ovf_I1_Un:  	return HandleConversion (8' true' expr.Arguments [0]' expectedType' typeSystem.SByte);  case ILCode.Conv_I2:  case ILCode.Conv_Ovf_I2:  case ILCode.Conv_Ovf_I2_Un:  	return HandleConversion (16' true' expr.Arguments [0]' expectedType' typeSystem.Int16);  case ILCode.Conv_I4:  case ILCode.Conv_Ovf_I4:  case ILCode.Conv_Ovf_I4_Un:  	return HandleConversion (32' true' expr.Arguments [0]' expectedType' typeSystem.Int32);  case ILCode.Conv_I8:  case ILCode.Conv_Ovf_I8:  case ILCode.Conv_Ovf_I8_Un:  	return HandleConversion (64' true' expr.Arguments [0]' expectedType' typeSystem.Int64);  case ILCode.Conv_U1:  case ILCode.Conv_Ovf_U1:  case ILCode.Conv_Ovf_U1_Un:  	return HandleConversion (8' false' expr.Arguments [0]' expectedType' typeSystem.Byte);  case ILCode.Conv_U2:  case ILCode.Conv_Ovf_U2:  case ILCode.Conv_Ovf_U2_Un:  	return HandleConversion (16' false' expr.Arguments [0]' expectedType' typeSystem.UInt16);  case ILCode.Conv_U4:  case ILCode.Conv_Ovf_U4:  case ILCode.Conv_Ovf_U4_Un:  	return HandleConversion (32' false' expr.Arguments [0]' expectedType' typeSystem.UInt32);  case ILCode.Conv_U8:  case ILCode.Conv_Ovf_U8:  case ILCode.Conv_Ovf_U8_Un:  	return HandleConversion (64' false' expr.Arguments [0]' expectedType' typeSystem.UInt64);  case ILCode.Conv_I:  case ILCode.Conv_Ovf_I:  case ILCode.Conv_Ovf_I_Un:  	return HandleConversion (NativeInt' true' expr.Arguments [0]' expectedType' typeSystem.IntPtr);  case ILCode.Conv_U:  case ILCode.Conv_Ovf_U:  case ILCode.Conv_Ovf_U_Un:  	return HandleConversion (NativeInt' false' expr.Arguments [0]' expectedType' typeSystem.UIntPtr);  case ILCode.Conv_R4:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' typeSystem.Single);  	}  	return typeSystem.Single;  case ILCode.Conv_R8:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' typeSystem.Double);  	}  	return typeSystem.Double;  case ILCode.Conv_R_Un:  	return (expectedType != null && expectedType.MetadataType == MetadataType.Single) ? typeSystem.Single : typeSystem.Double;  case ILCode.Castclass:  case ILCode.Unbox_Any:  	return (TypeReference)expr.Operand;  case ILCode.Unbox:  	return new ByReferenceType ((TypeReference)expr.Operand);  case ILCode.Isinst: {  	// isinst performs the equivalent of a cast only for reference types;  	// value types still need to be unboxed after an isinst instruction  	TypeReference tr = (TypeReference)expr.Operand;  	return tr.IsValueType ? typeSystem.Object : tr;  }  case ILCode.Box: {  	var tr = (TypeReference)expr.Operand;  	if (forceInferChildren)  		InferTypeForExpression (expr.Arguments.Single ()' tr);  	return tr.IsValueType ? typeSystem.Object : tr;  }  #endregion  #region Comparison instructions  case ILCode.Ceq:  case ILCode.Cne:  	if (forceInferChildren)  		InferArgumentsInBinaryOperator (expr' null' null);  	return typeSystem.Boolean;  case ILCode.Clt:  case ILCode.Cgt:  case ILCode.Cle:  case ILCode.Cge:  	if (forceInferChildren)  		InferArgumentsInBinaryOperator (expr' true' null);  	return typeSystem.Boolean;  case ILCode.Clt_Un:  case ILCode.Cgt_Un:  case ILCode.Cle_Un:  case ILCode.Cge_Un:  	if (forceInferChildren)  		InferArgumentsInBinaryOperator (expr' false' null);  	return typeSystem.Boolean;  #endregion  #region Branch instructions  case ILCode.Brtrue:  	if (forceInferChildren)  		InferTypeForExpression (expr.Arguments.Single ()' typeSystem.Boolean);  	return null;  case ILCode.Br:  case ILCode.Leave:  case ILCode.Endfinally:  case ILCode.Switch:  case ILCode.Throw:  case ILCode.Rethrow:  case ILCode.LoopOrSwitchBreak:  case ILCode.LoopContinue:  case ILCode.YieldBreak:  	return null;  case ILCode.Ret:  	if (forceInferChildren && expr.Arguments.Count == 1) {  		TypeReference returnType = context.CurrentMethod.ReturnType;  		if (context.CurrentMethodIsAsync && returnType != null && returnType.Namespace == "System.Threading.Tasks") {  			if (returnType.Name == "Task") {  				returnType = typeSystem.Void;  			} else if (returnType.Name == "Task`1" && returnType.IsGenericInstance) {  				returnType = ((GenericInstanceType)returnType).GenericArguments [0];  			}  		}  		InferTypeForExpression (expr.Arguments [0]' returnType);  	}  	return null;  case ILCode.YieldReturn:  	if (forceInferChildren) {  		GenericInstanceType genericType = context.CurrentMethod.ReturnType as GenericInstanceType;  		if (genericType != null) {  			// IEnumerable<T> or IEnumerator<T>  			InferTypeForExpression (expr.Arguments [0]' genericType.GenericArguments [0]);  		} else {  			// non-generic IEnumerable or IEnumerator  			InferTypeForExpression (expr.Arguments [0]' typeSystem.Object);  		}  	}  	return null;  case ILCode.Await: {  	TypeReference taskType = InferTypeForExpression (expr.Arguments [0]' null);  	if (taskType.Name == "Task`1" && taskType.IsGenericInstance && taskType.Namespace == "System.Threading.Tasks") {  		return ((GenericInstanceType)taskType).GenericArguments [0];  	}  	return null;  }  #endregion  case ILCode.Pop:  	return null;  case ILCode.Wrap:  case ILCode.Dup: {  	var arg = expr.Arguments.Single ();  	return arg.ExpectedType = InferTypeForExpression (arg' expectedType);  }  default:  	Debug.WriteLine ("Type Inference: Can't handle " + expr.Code.GetName ());  	return null;  }  
Magic Number,Custom.Decompiler.ILAst,TypeAnalysis,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\TypeAnalysis.cs,DoInferTypeForExpression,The following statement contains a magic number: switch (expr.Code) {  #region Logical operators  case ILCode.LogicNot:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments.Single ()' typeSystem.Boolean);  	}  	return typeSystem.Boolean;  case ILCode.LogicAnd:  case ILCode.LogicOr:  	// if Operand is set the logic and/or expression is a custom operator  	// we can deal with it the same as a normal invocation.  	if (expr.Operand != null)  		goto case ILCode.Call;  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' typeSystem.Boolean);  		InferTypeForExpression (expr.Arguments [1]' typeSystem.Boolean);  	}  	return typeSystem.Boolean;  case ILCode.TernaryOp:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' typeSystem.Boolean);  	}  	return InferBinaryArguments (expr.Arguments [1]' expr.Arguments [2]' expectedType' forceInferChildren);  case ILCode.NullCoalescing:  	return InferBinaryArguments (expr.Arguments [0]' expr.Arguments [1]' expectedType' forceInferChildren);  #endregion  #region Variable load/store  case ILCode.Stloc: {  	ILVariable v = (ILVariable)expr.Operand;  	if (forceInferChildren) {  		// do not use 'expectedType' in here!  		InferTypeForExpression (expr.Arguments.Single ()' v.Type);  	}  	return v.Type;  }  case ILCode.Ldloc: {  	ILVariable v = (ILVariable)expr.Operand;  	if (v.Type == null && singleLoadVariables.Contains (v)) {  		v.Type = expectedType;  	}  	return v.Type;  }  case ILCode.Ldloca: {  	ILVariable v = (ILVariable)expr.Operand;  	if (v.Type != null)  		return new ByReferenceType (v.Type);  	else  		return null;  }  #endregion  #region Call / NewObj  case ILCode.Call:  case ILCode.Callvirt:  case ILCode.CallGetter:  case ILCode.CallvirtGetter:  case ILCode.CallSetter:  case ILCode.CallvirtSetter: {  	MethodReference method = (MethodReference)expr.Operand;  	if (forceInferChildren) {  		for (int i = 0; i < expr.Arguments.Count; i++) {  			if (i == 0 && method.HasThis) {  				InferTypeForExpression (expr.Arguments [0]' MakeRefIfValueType (method.DeclaringType' expr.GetPrefix (ILCode.Constrained)));  			} else {  				InferTypeForExpression (expr.Arguments [i]' SubstituteTypeArgs (method.Parameters [method.HasThis ? i - 1 : i].ParameterType' method));  			}  		}  	}  	if (expr.Code == ILCode.CallSetter || expr.Code == ILCode.CallvirtSetter) {  		return SubstituteTypeArgs (method.Parameters.Last ().ParameterType' method);  	} else {  		return SubstituteTypeArgs (method.ReturnType' method);  	}  }  case ILCode.Newobj: {  	MethodReference ctor = (MethodReference)expr.Operand;  	if (forceInferChildren) {  		for (int i = 0; i < ctor.Parameters.Count; i++) {  			InferTypeForExpression (expr.Arguments [i]' SubstituteTypeArgs (ctor.Parameters [i].ParameterType' ctor));  		}  	}  	return ctor.DeclaringType;  }  case ILCode.InitObject:  case ILCode.InitCollection:  	return InferTypeForExpression (expr.Arguments [0]' expectedType);  case ILCode.InitializedObject:  	// expectedType should always be known due to the parent method call / property setter  	Debug.Assert (expectedType != null);  	return expectedType;  #endregion  #region Load/Store Fields  case ILCode.Ldfld:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' MakeRefIfValueType (((FieldReference)expr.Operand).DeclaringType' expr.GetPrefix (ILCode.Constrained)));  	}  	return GetFieldType ((FieldReference)expr.Operand);  case ILCode.Ldsfld:  	return GetFieldType ((FieldReference)expr.Operand);  case ILCode.Ldflda:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' MakeRefIfValueType (((FieldReference)expr.Operand).DeclaringType' expr.GetPrefix (ILCode.Constrained)));  	}  	return new ByReferenceType (GetFieldType ((FieldReference)expr.Operand));  case ILCode.Ldsflda:  	return new ByReferenceType (GetFieldType ((FieldReference)expr.Operand));  case ILCode.Stfld:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' MakeRefIfValueType (((FieldReference)expr.Operand).DeclaringType' expr.GetPrefix (ILCode.Constrained)));  		InferTypeForExpression (expr.Arguments [1]' GetFieldType ((FieldReference)expr.Operand));  	}  	return GetFieldType ((FieldReference)expr.Operand);  case ILCode.Stsfld:  	if (forceInferChildren)  		InferTypeForExpression (expr.Arguments [0]' GetFieldType ((FieldReference)expr.Operand));  	return GetFieldType ((FieldReference)expr.Operand);  #endregion  #region Reference/Pointer instructions  case ILCode.Ldind_Ref:  	return UnpackPointer (InferTypeForExpression (expr.Arguments [0]' null));  case ILCode.Stind_Ref:  	if (forceInferChildren) {  		TypeReference elementType = UnpackPointer (InferTypeForExpression (expr.Arguments [0]' null));  		InferTypeForExpression (expr.Arguments [1]' elementType);  	}  	return null;  case ILCode.Ldobj: {  	TypeReference type = (TypeReference)expr.Operand;  	var argType = InferTypeForExpression (expr.Arguments [0]' null);  	if (argType is PointerType || argType is ByReferenceType) {  		var elementType = ((TypeSpecification)argType).ElementType;  		int infoAmount = GetInformationAmount (elementType);  		if (infoAmount == 1 && GetInformationAmount (type) == 8) {  			// A bool can be loaded from both bytes and sbytes.  			type = elementType;  		}  		if (infoAmount >= 8 && infoAmount <= 64 && infoAmount == GetInformationAmount (type)) {  			// An integer can be loaded as another integer of the same size.  			// For integers smaller than 32 bit' the signs must match (as loading performs sign extension)  			bool? elementTypeIsSigned = IsSigned (elementType);  			bool? typeIsSigned = IsSigned (type);  			if (elementTypeIsSigned != null && typeIsSigned != null) {  				if (infoAmount >= 32 || elementTypeIsSigned == typeIsSigned)  					type = elementType;  			}  		}  	}  	if (argType is PointerType)  		InferTypeForExpression (expr.Arguments [0]' new PointerType (type));  	else  		InferTypeForExpression (expr.Arguments [0]' new ByReferenceType (type));  	return type;  }  case ILCode.Stobj: {  	TypeReference operandType = (TypeReference)expr.Operand;  	TypeReference pointerType = InferTypeForExpression (expr.Arguments [0]' new ByReferenceType (operandType));  	TypeReference elementType;  	if (pointerType is PointerType)  		elementType = ((PointerType)pointerType).ElementType;  	else if (pointerType is ByReferenceType)  		elementType = ((ByReferenceType)pointerType).ElementType;  	else  		elementType = null;  	if (elementType != null) {  		// An integer can be stored in any other integer of the same size.  		int infoAmount = GetInformationAmount (elementType);  		if (infoAmount == 1 && GetInformationAmount (operandType) == 8)  			operandType = elementType;  		else if (infoAmount == GetInformationAmount (operandType) && IsSigned (elementType) != null && IsSigned (operandType) != null)  			operandType = elementType;  	}  	if (forceInferChildren) {  		if (pointerType is PointerType)  			InferTypeForExpression (expr.Arguments [0]' new PointerType (operandType));  		else if (!IsSameType (operandType' expr.Operand as TypeReference))  			InferTypeForExpression (expr.Arguments [0]' new ByReferenceType (operandType));  		InferTypeForExpression (expr.Arguments [1]' operandType);  	}  	return operandType;  }  case ILCode.Initobj:  	return null;  case ILCode.DefaultValue:  	return (TypeReference)expr.Operand;  case ILCode.Localloc:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' typeSystem.Int32);  	}  	if (expectedType is PointerType)  		return expectedType;  	else  		return typeSystem.IntPtr;  case ILCode.Sizeof:  	return typeSystem.Int32;  case ILCode.PostIncrement:  case ILCode.PostIncrement_Ovf:  case ILCode.PostIncrement_Ovf_Un: {  	TypeReference elementType = UnpackPointer (InferTypeForExpression (expr.Arguments [0]' null));  	if (forceInferChildren && elementType != null) {  		// Assign expected type to the child expression  		InferTypeForExpression (expr.Arguments [0]' new ByReferenceType (elementType));  	}  	return elementType;  }  case ILCode.Mkrefany:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' (TypeReference)expr.Operand);  	}  	return typeSystem.TypedReference;  case ILCode.Refanytype:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' typeSystem.TypedReference);  	}  	return new TypeReference ("System"' "RuntimeTypeHandle"' module' module.TypeSystem.CoreLibrary' true);  case ILCode.Refanyval:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' typeSystem.TypedReference);  	}  	return new ByReferenceType ((TypeReference)expr.Operand);  case ILCode.AddressOf: {  	TypeReference t = InferTypeForExpression (expr.Arguments [0]' UnpackPointer (expectedType));  	return t != null ? new ByReferenceType (t) : null;  }  case ILCode.ValueOf:  	return GetNullableTypeArgument (InferTypeForExpression (expr.Arguments [0]' CreateNullableType (expectedType)));  case ILCode.NullableOf:  	return CreateNullableType (InferTypeForExpression (expr.Arguments [0]' GetNullableTypeArgument (expectedType)));  #endregion  #region Arithmetic instructions  case ILCode.Not:  // bitwise complement  case ILCode.Neg:  	return InferTypeForExpression (expr.Arguments.Single ()' expectedType);  case ILCode.Add:  	return InferArgumentsInAddition (expr' null' expectedType);  case ILCode.Sub:  	return InferArgumentsInSubtraction (expr' null' expectedType);  case ILCode.Mul:  case ILCode.Or:  case ILCode.And:  case ILCode.Xor:  	return InferArgumentsInBinaryOperator (expr' null' expectedType);  case ILCode.Add_Ovf:  	return InferArgumentsInAddition (expr' true' expectedType);  case ILCode.Sub_Ovf:  	return InferArgumentsInSubtraction (expr' true' expectedType);  case ILCode.Mul_Ovf:  case ILCode.Div:  case ILCode.Rem:  	return InferArgumentsInBinaryOperator (expr' true' expectedType);  case ILCode.Add_Ovf_Un:  	return InferArgumentsInAddition (expr' false' expectedType);  case ILCode.Sub_Ovf_Un:  	return InferArgumentsInSubtraction (expr' false' expectedType);  case ILCode.Mul_Ovf_Un:  case ILCode.Div_Un:  case ILCode.Rem_Un:  	return InferArgumentsInBinaryOperator (expr' false' expectedType);  case ILCode.Shl:  	if (forceInferChildren)  		InferTypeForExpression (expr.Arguments [1]' typeSystem.Int32);  	if (expectedType != null && (expectedType.MetadataType == MetadataType.Int32 || expectedType.MetadataType == MetadataType.UInt32 || expectedType.MetadataType == MetadataType.Int64 || expectedType.MetadataType == MetadataType.UInt64))  		return NumericPromotion (InferTypeForExpression (expr.Arguments [0]' expectedType));  	else  		return NumericPromotion (InferTypeForExpression (expr.Arguments [0]' null));  case ILCode.Shr:  case ILCode.Shr_Un: {  	if (forceInferChildren)  		InferTypeForExpression (expr.Arguments [1]' typeSystem.Int32);  	TypeReference type = NumericPromotion (InferTypeForExpression (expr.Arguments [0]' null));  	TypeReference expectedInputType = null;  	switch (type.MetadataType) {  	case MetadataType.Int32:  		if (expr.Code == ILCode.Shr_Un)  			expectedInputType = typeSystem.UInt32;  		break;  	case MetadataType.UInt32:  		if (expr.Code == ILCode.Shr)  			expectedInputType = typeSystem.Int32;  		break;  	case MetadataType.Int64:  		if (expr.Code == ILCode.Shr_Un)  			expectedInputType = typeSystem.UInt64;  		break;  	case MetadataType.UInt64:  		if (expr.Code == ILCode.Shr)  			expectedInputType = typeSystem.UInt64;  		break;  	}  	if (expectedInputType != null) {  		InferTypeForExpression (expr.Arguments [0]' expectedInputType);  		return expectedInputType;  	} else {  		return type;  	}  }  case ILCode.CompoundAssignment: {  	var op = expr.Arguments [0];  	if (op.Code == ILCode.NullableOf)  		op = op.Arguments [0].Arguments [0];  	var varType = InferTypeForExpression (op.Arguments [0]' null);  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' varType);  	}  	return varType;  }  #endregion  #region Constant loading instructions  case ILCode.Ldnull:  	return typeSystem.Object;  case ILCode.Ldstr:  	return typeSystem.String;  case ILCode.Ldftn:  case ILCode.Ldvirtftn:  	return typeSystem.IntPtr;  case ILCode.Ldc_I4:  	if (IsBoolean (expectedType) && ((int)expr.Operand == 0 || (int)expr.Operand == 1))  		return typeSystem.Boolean;  	if (expectedType is PointerType && (int)expr.Operand == 0)  		return expectedType;  	if (IsIntegerOrEnum (expectedType) && OperandFitsInType (expectedType' (int)expr.Operand))  		return expectedType;  	else  		return typeSystem.Int32;  case ILCode.Ldc_I8:  	if (expectedType is PointerType && (long)expr.Operand == 0)  		return expectedType;  	if (IsIntegerOrEnum (expectedType) && GetInformationAmount (expectedType) >= NativeInt)  		return expectedType;  	else  		return typeSystem.Int64;  case ILCode.Ldc_R4:  	return typeSystem.Single;  case ILCode.Ldc_R8:  	return typeSystem.Double;  case ILCode.Ldc_Decimal:  	return new TypeReference ("System"' "Decimal"' module' module.TypeSystem.CoreLibrary' true);  case ILCode.Ldtoken:  	if (expr.Operand is TypeReference)  		return new TypeReference ("System"' "RuntimeTypeHandle"' module' module.TypeSystem.CoreLibrary' true);  	else if (expr.Operand is FieldReference)  		return new TypeReference ("System"' "RuntimeFieldHandle"' module' module.TypeSystem.CoreLibrary' true);  	else  		return new TypeReference ("System"' "RuntimeMethodHandle"' module' module.TypeSystem.CoreLibrary' true);  case ILCode.Arglist:  	return new TypeReference ("System"' "RuntimeArgumentHandle"' module' module.TypeSystem.CoreLibrary' true);  #endregion  #region Array instructions  case ILCode.Newarr:  	if (forceInferChildren) {  		var lengthType = InferTypeForExpression (expr.Arguments.Single ()' null);  		if (lengthType == typeSystem.IntPtr) {  			lengthType = typeSystem.Int64;  		} else if (lengthType == typeSystem.UIntPtr) {  			lengthType = typeSystem.UInt64;  		} else if (lengthType != typeSystem.UInt32 && lengthType != typeSystem.Int64 && lengthType != typeSystem.UInt64) {  			lengthType = typeSystem.Int32;  		}  		if (forceInferChildren) {  			InferTypeForExpression (expr.Arguments.Single ()' lengthType);  		}  	}  	return new ArrayType ((TypeReference)expr.Operand);  case ILCode.InitArray:  	var operandAsArrayType = (ArrayType)expr.Operand;  	if (forceInferChildren) {  		foreach (ILExpression arg in expr.Arguments)  			InferTypeForExpression (arg' operandAsArrayType.ElementType);  	}  	return operandAsArrayType;  case ILCode.Ldlen:  	return typeSystem.Int32;  case ILCode.Ldelem_U1:  case ILCode.Ldelem_U2:  case ILCode.Ldelem_U4:  case ILCode.Ldelem_I1:  case ILCode.Ldelem_I2:  case ILCode.Ldelem_I4:  case ILCode.Ldelem_I8:  case ILCode.Ldelem_R4:  case ILCode.Ldelem_R8:  case ILCode.Ldelem_I:  case ILCode.Ldelem_Ref: {  	ArrayType arrayType = InferTypeForExpression (expr.Arguments [0]' null) as ArrayType;  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [1]' typeSystem.Int32);  	}  	return arrayType != null ? arrayType.ElementType : null;  }  case ILCode.Ldelem_Any:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [1]' typeSystem.Int32);  	}  	return (TypeReference)expr.Operand;  case ILCode.Ldelema: {  	ArrayType arrayType = InferTypeForExpression (expr.Arguments [0]' null) as ArrayType;  	if (forceInferChildren)  		InferTypeForExpression (expr.Arguments [1]' typeSystem.Int32);  	return arrayType != null ? new ByReferenceType (arrayType.ElementType) : null;  }  case ILCode.Stelem_I:  case ILCode.Stelem_I1:  case ILCode.Stelem_I2:  case ILCode.Stelem_I4:  case ILCode.Stelem_I8:  case ILCode.Stelem_R4:  case ILCode.Stelem_R8:  case ILCode.Stelem_Ref:  case ILCode.Stelem_Any: {  	ArrayType arrayType = InferTypeForExpression (expr.Arguments [0]' null) as ArrayType;  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [1]' typeSystem.Int32);  		if (arrayType != null) {  			InferTypeForExpression (expr.Arguments [2]' arrayType.ElementType);  		}  	}  	return arrayType != null ? arrayType.ElementType : null;  }  #endregion  #region Conversion instructions  case ILCode.Conv_I1:  case ILCode.Conv_Ovf_I1:  case ILCode.Conv_Ovf_I1_Un:  	return HandleConversion (8' true' expr.Arguments [0]' expectedType' typeSystem.SByte);  case ILCode.Conv_I2:  case ILCode.Conv_Ovf_I2:  case ILCode.Conv_Ovf_I2_Un:  	return HandleConversion (16' true' expr.Arguments [0]' expectedType' typeSystem.Int16);  case ILCode.Conv_I4:  case ILCode.Conv_Ovf_I4:  case ILCode.Conv_Ovf_I4_Un:  	return HandleConversion (32' true' expr.Arguments [0]' expectedType' typeSystem.Int32);  case ILCode.Conv_I8:  case ILCode.Conv_Ovf_I8:  case ILCode.Conv_Ovf_I8_Un:  	return HandleConversion (64' true' expr.Arguments [0]' expectedType' typeSystem.Int64);  case ILCode.Conv_U1:  case ILCode.Conv_Ovf_U1:  case ILCode.Conv_Ovf_U1_Un:  	return HandleConversion (8' false' expr.Arguments [0]' expectedType' typeSystem.Byte);  case ILCode.Conv_U2:  case ILCode.Conv_Ovf_U2:  case ILCode.Conv_Ovf_U2_Un:  	return HandleConversion (16' false' expr.Arguments [0]' expectedType' typeSystem.UInt16);  case ILCode.Conv_U4:  case ILCode.Conv_Ovf_U4:  case ILCode.Conv_Ovf_U4_Un:  	return HandleConversion (32' false' expr.Arguments [0]' expectedType' typeSystem.UInt32);  case ILCode.Conv_U8:  case ILCode.Conv_Ovf_U8:  case ILCode.Conv_Ovf_U8_Un:  	return HandleConversion (64' false' expr.Arguments [0]' expectedType' typeSystem.UInt64);  case ILCode.Conv_I:  case ILCode.Conv_Ovf_I:  case ILCode.Conv_Ovf_I_Un:  	return HandleConversion (NativeInt' true' expr.Arguments [0]' expectedType' typeSystem.IntPtr);  case ILCode.Conv_U:  case ILCode.Conv_Ovf_U:  case ILCode.Conv_Ovf_U_Un:  	return HandleConversion (NativeInt' false' expr.Arguments [0]' expectedType' typeSystem.UIntPtr);  case ILCode.Conv_R4:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' typeSystem.Single);  	}  	return typeSystem.Single;  case ILCode.Conv_R8:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' typeSystem.Double);  	}  	return typeSystem.Double;  case ILCode.Conv_R_Un:  	return (expectedType != null && expectedType.MetadataType == MetadataType.Single) ? typeSystem.Single : typeSystem.Double;  case ILCode.Castclass:  case ILCode.Unbox_Any:  	return (TypeReference)expr.Operand;  case ILCode.Unbox:  	return new ByReferenceType ((TypeReference)expr.Operand);  case ILCode.Isinst: {  	// isinst performs the equivalent of a cast only for reference types;  	// value types still need to be unboxed after an isinst instruction  	TypeReference tr = (TypeReference)expr.Operand;  	return tr.IsValueType ? typeSystem.Object : tr;  }  case ILCode.Box: {  	var tr = (TypeReference)expr.Operand;  	if (forceInferChildren)  		InferTypeForExpression (expr.Arguments.Single ()' tr);  	return tr.IsValueType ? typeSystem.Object : tr;  }  #endregion  #region Comparison instructions  case ILCode.Ceq:  case ILCode.Cne:  	if (forceInferChildren)  		InferArgumentsInBinaryOperator (expr' null' null);  	return typeSystem.Boolean;  case ILCode.Clt:  case ILCode.Cgt:  case ILCode.Cle:  case ILCode.Cge:  	if (forceInferChildren)  		InferArgumentsInBinaryOperator (expr' true' null);  	return typeSystem.Boolean;  case ILCode.Clt_Un:  case ILCode.Cgt_Un:  case ILCode.Cle_Un:  case ILCode.Cge_Un:  	if (forceInferChildren)  		InferArgumentsInBinaryOperator (expr' false' null);  	return typeSystem.Boolean;  #endregion  #region Branch instructions  case ILCode.Brtrue:  	if (forceInferChildren)  		InferTypeForExpression (expr.Arguments.Single ()' typeSystem.Boolean);  	return null;  case ILCode.Br:  case ILCode.Leave:  case ILCode.Endfinally:  case ILCode.Switch:  case ILCode.Throw:  case ILCode.Rethrow:  case ILCode.LoopOrSwitchBreak:  case ILCode.LoopContinue:  case ILCode.YieldBreak:  	return null;  case ILCode.Ret:  	if (forceInferChildren && expr.Arguments.Count == 1) {  		TypeReference returnType = context.CurrentMethod.ReturnType;  		if (context.CurrentMethodIsAsync && returnType != null && returnType.Namespace == "System.Threading.Tasks") {  			if (returnType.Name == "Task") {  				returnType = typeSystem.Void;  			} else if (returnType.Name == "Task`1" && returnType.IsGenericInstance) {  				returnType = ((GenericInstanceType)returnType).GenericArguments [0];  			}  		}  		InferTypeForExpression (expr.Arguments [0]' returnType);  	}  	return null;  case ILCode.YieldReturn:  	if (forceInferChildren) {  		GenericInstanceType genericType = context.CurrentMethod.ReturnType as GenericInstanceType;  		if (genericType != null) {  			// IEnumerable<T> or IEnumerator<T>  			InferTypeForExpression (expr.Arguments [0]' genericType.GenericArguments [0]);  		} else {  			// non-generic IEnumerable or IEnumerator  			InferTypeForExpression (expr.Arguments [0]' typeSystem.Object);  		}  	}  	return null;  case ILCode.Await: {  	TypeReference taskType = InferTypeForExpression (expr.Arguments [0]' null);  	if (taskType.Name == "Task`1" && taskType.IsGenericInstance && taskType.Namespace == "System.Threading.Tasks") {  		return ((GenericInstanceType)taskType).GenericArguments [0];  	}  	return null;  }  #endregion  case ILCode.Pop:  	return null;  case ILCode.Wrap:  case ILCode.Dup: {  	var arg = expr.Arguments.Single ();  	return arg.ExpectedType = InferTypeForExpression (arg' expectedType);  }  default:  	Debug.WriteLine ("Type Inference: Can't handle " + expr.Code.GetName ());  	return null;  }  
Magic Number,Custom.Decompiler.ILAst,TypeAnalysis,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\TypeAnalysis.cs,DoInferTypeForExpression,The following statement contains a magic number: switch (expr.Code) {  #region Logical operators  case ILCode.LogicNot:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments.Single ()' typeSystem.Boolean);  	}  	return typeSystem.Boolean;  case ILCode.LogicAnd:  case ILCode.LogicOr:  	// if Operand is set the logic and/or expression is a custom operator  	// we can deal with it the same as a normal invocation.  	if (expr.Operand != null)  		goto case ILCode.Call;  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' typeSystem.Boolean);  		InferTypeForExpression (expr.Arguments [1]' typeSystem.Boolean);  	}  	return typeSystem.Boolean;  case ILCode.TernaryOp:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' typeSystem.Boolean);  	}  	return InferBinaryArguments (expr.Arguments [1]' expr.Arguments [2]' expectedType' forceInferChildren);  case ILCode.NullCoalescing:  	return InferBinaryArguments (expr.Arguments [0]' expr.Arguments [1]' expectedType' forceInferChildren);  #endregion  #region Variable load/store  case ILCode.Stloc: {  	ILVariable v = (ILVariable)expr.Operand;  	if (forceInferChildren) {  		// do not use 'expectedType' in here!  		InferTypeForExpression (expr.Arguments.Single ()' v.Type);  	}  	return v.Type;  }  case ILCode.Ldloc: {  	ILVariable v = (ILVariable)expr.Operand;  	if (v.Type == null && singleLoadVariables.Contains (v)) {  		v.Type = expectedType;  	}  	return v.Type;  }  case ILCode.Ldloca: {  	ILVariable v = (ILVariable)expr.Operand;  	if (v.Type != null)  		return new ByReferenceType (v.Type);  	else  		return null;  }  #endregion  #region Call / NewObj  case ILCode.Call:  case ILCode.Callvirt:  case ILCode.CallGetter:  case ILCode.CallvirtGetter:  case ILCode.CallSetter:  case ILCode.CallvirtSetter: {  	MethodReference method = (MethodReference)expr.Operand;  	if (forceInferChildren) {  		for (int i = 0; i < expr.Arguments.Count; i++) {  			if (i == 0 && method.HasThis) {  				InferTypeForExpression (expr.Arguments [0]' MakeRefIfValueType (method.DeclaringType' expr.GetPrefix (ILCode.Constrained)));  			} else {  				InferTypeForExpression (expr.Arguments [i]' SubstituteTypeArgs (method.Parameters [method.HasThis ? i - 1 : i].ParameterType' method));  			}  		}  	}  	if (expr.Code == ILCode.CallSetter || expr.Code == ILCode.CallvirtSetter) {  		return SubstituteTypeArgs (method.Parameters.Last ().ParameterType' method);  	} else {  		return SubstituteTypeArgs (method.ReturnType' method);  	}  }  case ILCode.Newobj: {  	MethodReference ctor = (MethodReference)expr.Operand;  	if (forceInferChildren) {  		for (int i = 0; i < ctor.Parameters.Count; i++) {  			InferTypeForExpression (expr.Arguments [i]' SubstituteTypeArgs (ctor.Parameters [i].ParameterType' ctor));  		}  	}  	return ctor.DeclaringType;  }  case ILCode.InitObject:  case ILCode.InitCollection:  	return InferTypeForExpression (expr.Arguments [0]' expectedType);  case ILCode.InitializedObject:  	// expectedType should always be known due to the parent method call / property setter  	Debug.Assert (expectedType != null);  	return expectedType;  #endregion  #region Load/Store Fields  case ILCode.Ldfld:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' MakeRefIfValueType (((FieldReference)expr.Operand).DeclaringType' expr.GetPrefix (ILCode.Constrained)));  	}  	return GetFieldType ((FieldReference)expr.Operand);  case ILCode.Ldsfld:  	return GetFieldType ((FieldReference)expr.Operand);  case ILCode.Ldflda:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' MakeRefIfValueType (((FieldReference)expr.Operand).DeclaringType' expr.GetPrefix (ILCode.Constrained)));  	}  	return new ByReferenceType (GetFieldType ((FieldReference)expr.Operand));  case ILCode.Ldsflda:  	return new ByReferenceType (GetFieldType ((FieldReference)expr.Operand));  case ILCode.Stfld:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' MakeRefIfValueType (((FieldReference)expr.Operand).DeclaringType' expr.GetPrefix (ILCode.Constrained)));  		InferTypeForExpression (expr.Arguments [1]' GetFieldType ((FieldReference)expr.Operand));  	}  	return GetFieldType ((FieldReference)expr.Operand);  case ILCode.Stsfld:  	if (forceInferChildren)  		InferTypeForExpression (expr.Arguments [0]' GetFieldType ((FieldReference)expr.Operand));  	return GetFieldType ((FieldReference)expr.Operand);  #endregion  #region Reference/Pointer instructions  case ILCode.Ldind_Ref:  	return UnpackPointer (InferTypeForExpression (expr.Arguments [0]' null));  case ILCode.Stind_Ref:  	if (forceInferChildren) {  		TypeReference elementType = UnpackPointer (InferTypeForExpression (expr.Arguments [0]' null));  		InferTypeForExpression (expr.Arguments [1]' elementType);  	}  	return null;  case ILCode.Ldobj: {  	TypeReference type = (TypeReference)expr.Operand;  	var argType = InferTypeForExpression (expr.Arguments [0]' null);  	if (argType is PointerType || argType is ByReferenceType) {  		var elementType = ((TypeSpecification)argType).ElementType;  		int infoAmount = GetInformationAmount (elementType);  		if (infoAmount == 1 && GetInformationAmount (type) == 8) {  			// A bool can be loaded from both bytes and sbytes.  			type = elementType;  		}  		if (infoAmount >= 8 && infoAmount <= 64 && infoAmount == GetInformationAmount (type)) {  			// An integer can be loaded as another integer of the same size.  			// For integers smaller than 32 bit' the signs must match (as loading performs sign extension)  			bool? elementTypeIsSigned = IsSigned (elementType);  			bool? typeIsSigned = IsSigned (type);  			if (elementTypeIsSigned != null && typeIsSigned != null) {  				if (infoAmount >= 32 || elementTypeIsSigned == typeIsSigned)  					type = elementType;  			}  		}  	}  	if (argType is PointerType)  		InferTypeForExpression (expr.Arguments [0]' new PointerType (type));  	else  		InferTypeForExpression (expr.Arguments [0]' new ByReferenceType (type));  	return type;  }  case ILCode.Stobj: {  	TypeReference operandType = (TypeReference)expr.Operand;  	TypeReference pointerType = InferTypeForExpression (expr.Arguments [0]' new ByReferenceType (operandType));  	TypeReference elementType;  	if (pointerType is PointerType)  		elementType = ((PointerType)pointerType).ElementType;  	else if (pointerType is ByReferenceType)  		elementType = ((ByReferenceType)pointerType).ElementType;  	else  		elementType = null;  	if (elementType != null) {  		// An integer can be stored in any other integer of the same size.  		int infoAmount = GetInformationAmount (elementType);  		if (infoAmount == 1 && GetInformationAmount (operandType) == 8)  			operandType = elementType;  		else if (infoAmount == GetInformationAmount (operandType) && IsSigned (elementType) != null && IsSigned (operandType) != null)  			operandType = elementType;  	}  	if (forceInferChildren) {  		if (pointerType is PointerType)  			InferTypeForExpression (expr.Arguments [0]' new PointerType (operandType));  		else if (!IsSameType (operandType' expr.Operand as TypeReference))  			InferTypeForExpression (expr.Arguments [0]' new ByReferenceType (operandType));  		InferTypeForExpression (expr.Arguments [1]' operandType);  	}  	return operandType;  }  case ILCode.Initobj:  	return null;  case ILCode.DefaultValue:  	return (TypeReference)expr.Operand;  case ILCode.Localloc:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' typeSystem.Int32);  	}  	if (expectedType is PointerType)  		return expectedType;  	else  		return typeSystem.IntPtr;  case ILCode.Sizeof:  	return typeSystem.Int32;  case ILCode.PostIncrement:  case ILCode.PostIncrement_Ovf:  case ILCode.PostIncrement_Ovf_Un: {  	TypeReference elementType = UnpackPointer (InferTypeForExpression (expr.Arguments [0]' null));  	if (forceInferChildren && elementType != null) {  		// Assign expected type to the child expression  		InferTypeForExpression (expr.Arguments [0]' new ByReferenceType (elementType));  	}  	return elementType;  }  case ILCode.Mkrefany:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' (TypeReference)expr.Operand);  	}  	return typeSystem.TypedReference;  case ILCode.Refanytype:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' typeSystem.TypedReference);  	}  	return new TypeReference ("System"' "RuntimeTypeHandle"' module' module.TypeSystem.CoreLibrary' true);  case ILCode.Refanyval:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' typeSystem.TypedReference);  	}  	return new ByReferenceType ((TypeReference)expr.Operand);  case ILCode.AddressOf: {  	TypeReference t = InferTypeForExpression (expr.Arguments [0]' UnpackPointer (expectedType));  	return t != null ? new ByReferenceType (t) : null;  }  case ILCode.ValueOf:  	return GetNullableTypeArgument (InferTypeForExpression (expr.Arguments [0]' CreateNullableType (expectedType)));  case ILCode.NullableOf:  	return CreateNullableType (InferTypeForExpression (expr.Arguments [0]' GetNullableTypeArgument (expectedType)));  #endregion  #region Arithmetic instructions  case ILCode.Not:  // bitwise complement  case ILCode.Neg:  	return InferTypeForExpression (expr.Arguments.Single ()' expectedType);  case ILCode.Add:  	return InferArgumentsInAddition (expr' null' expectedType);  case ILCode.Sub:  	return InferArgumentsInSubtraction (expr' null' expectedType);  case ILCode.Mul:  case ILCode.Or:  case ILCode.And:  case ILCode.Xor:  	return InferArgumentsInBinaryOperator (expr' null' expectedType);  case ILCode.Add_Ovf:  	return InferArgumentsInAddition (expr' true' expectedType);  case ILCode.Sub_Ovf:  	return InferArgumentsInSubtraction (expr' true' expectedType);  case ILCode.Mul_Ovf:  case ILCode.Div:  case ILCode.Rem:  	return InferArgumentsInBinaryOperator (expr' true' expectedType);  case ILCode.Add_Ovf_Un:  	return InferArgumentsInAddition (expr' false' expectedType);  case ILCode.Sub_Ovf_Un:  	return InferArgumentsInSubtraction (expr' false' expectedType);  case ILCode.Mul_Ovf_Un:  case ILCode.Div_Un:  case ILCode.Rem_Un:  	return InferArgumentsInBinaryOperator (expr' false' expectedType);  case ILCode.Shl:  	if (forceInferChildren)  		InferTypeForExpression (expr.Arguments [1]' typeSystem.Int32);  	if (expectedType != null && (expectedType.MetadataType == MetadataType.Int32 || expectedType.MetadataType == MetadataType.UInt32 || expectedType.MetadataType == MetadataType.Int64 || expectedType.MetadataType == MetadataType.UInt64))  		return NumericPromotion (InferTypeForExpression (expr.Arguments [0]' expectedType));  	else  		return NumericPromotion (InferTypeForExpression (expr.Arguments [0]' null));  case ILCode.Shr:  case ILCode.Shr_Un: {  	if (forceInferChildren)  		InferTypeForExpression (expr.Arguments [1]' typeSystem.Int32);  	TypeReference type = NumericPromotion (InferTypeForExpression (expr.Arguments [0]' null));  	TypeReference expectedInputType = null;  	switch (type.MetadataType) {  	case MetadataType.Int32:  		if (expr.Code == ILCode.Shr_Un)  			expectedInputType = typeSystem.UInt32;  		break;  	case MetadataType.UInt32:  		if (expr.Code == ILCode.Shr)  			expectedInputType = typeSystem.Int32;  		break;  	case MetadataType.Int64:  		if (expr.Code == ILCode.Shr_Un)  			expectedInputType = typeSystem.UInt64;  		break;  	case MetadataType.UInt64:  		if (expr.Code == ILCode.Shr)  			expectedInputType = typeSystem.UInt64;  		break;  	}  	if (expectedInputType != null) {  		InferTypeForExpression (expr.Arguments [0]' expectedInputType);  		return expectedInputType;  	} else {  		return type;  	}  }  case ILCode.CompoundAssignment: {  	var op = expr.Arguments [0];  	if (op.Code == ILCode.NullableOf)  		op = op.Arguments [0].Arguments [0];  	var varType = InferTypeForExpression (op.Arguments [0]' null);  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' varType);  	}  	return varType;  }  #endregion  #region Constant loading instructions  case ILCode.Ldnull:  	return typeSystem.Object;  case ILCode.Ldstr:  	return typeSystem.String;  case ILCode.Ldftn:  case ILCode.Ldvirtftn:  	return typeSystem.IntPtr;  case ILCode.Ldc_I4:  	if (IsBoolean (expectedType) && ((int)expr.Operand == 0 || (int)expr.Operand == 1))  		return typeSystem.Boolean;  	if (expectedType is PointerType && (int)expr.Operand == 0)  		return expectedType;  	if (IsIntegerOrEnum (expectedType) && OperandFitsInType (expectedType' (int)expr.Operand))  		return expectedType;  	else  		return typeSystem.Int32;  case ILCode.Ldc_I8:  	if (expectedType is PointerType && (long)expr.Operand == 0)  		return expectedType;  	if (IsIntegerOrEnum (expectedType) && GetInformationAmount (expectedType) >= NativeInt)  		return expectedType;  	else  		return typeSystem.Int64;  case ILCode.Ldc_R4:  	return typeSystem.Single;  case ILCode.Ldc_R8:  	return typeSystem.Double;  case ILCode.Ldc_Decimal:  	return new TypeReference ("System"' "Decimal"' module' module.TypeSystem.CoreLibrary' true);  case ILCode.Ldtoken:  	if (expr.Operand is TypeReference)  		return new TypeReference ("System"' "RuntimeTypeHandle"' module' module.TypeSystem.CoreLibrary' true);  	else if (expr.Operand is FieldReference)  		return new TypeReference ("System"' "RuntimeFieldHandle"' module' module.TypeSystem.CoreLibrary' true);  	else  		return new TypeReference ("System"' "RuntimeMethodHandle"' module' module.TypeSystem.CoreLibrary' true);  case ILCode.Arglist:  	return new TypeReference ("System"' "RuntimeArgumentHandle"' module' module.TypeSystem.CoreLibrary' true);  #endregion  #region Array instructions  case ILCode.Newarr:  	if (forceInferChildren) {  		var lengthType = InferTypeForExpression (expr.Arguments.Single ()' null);  		if (lengthType == typeSystem.IntPtr) {  			lengthType = typeSystem.Int64;  		} else if (lengthType == typeSystem.UIntPtr) {  			lengthType = typeSystem.UInt64;  		} else if (lengthType != typeSystem.UInt32 && lengthType != typeSystem.Int64 && lengthType != typeSystem.UInt64) {  			lengthType = typeSystem.Int32;  		}  		if (forceInferChildren) {  			InferTypeForExpression (expr.Arguments.Single ()' lengthType);  		}  	}  	return new ArrayType ((TypeReference)expr.Operand);  case ILCode.InitArray:  	var operandAsArrayType = (ArrayType)expr.Operand;  	if (forceInferChildren) {  		foreach (ILExpression arg in expr.Arguments)  			InferTypeForExpression (arg' operandAsArrayType.ElementType);  	}  	return operandAsArrayType;  case ILCode.Ldlen:  	return typeSystem.Int32;  case ILCode.Ldelem_U1:  case ILCode.Ldelem_U2:  case ILCode.Ldelem_U4:  case ILCode.Ldelem_I1:  case ILCode.Ldelem_I2:  case ILCode.Ldelem_I4:  case ILCode.Ldelem_I8:  case ILCode.Ldelem_R4:  case ILCode.Ldelem_R8:  case ILCode.Ldelem_I:  case ILCode.Ldelem_Ref: {  	ArrayType arrayType = InferTypeForExpression (expr.Arguments [0]' null) as ArrayType;  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [1]' typeSystem.Int32);  	}  	return arrayType != null ? arrayType.ElementType : null;  }  case ILCode.Ldelem_Any:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [1]' typeSystem.Int32);  	}  	return (TypeReference)expr.Operand;  case ILCode.Ldelema: {  	ArrayType arrayType = InferTypeForExpression (expr.Arguments [0]' null) as ArrayType;  	if (forceInferChildren)  		InferTypeForExpression (expr.Arguments [1]' typeSystem.Int32);  	return arrayType != null ? new ByReferenceType (arrayType.ElementType) : null;  }  case ILCode.Stelem_I:  case ILCode.Stelem_I1:  case ILCode.Stelem_I2:  case ILCode.Stelem_I4:  case ILCode.Stelem_I8:  case ILCode.Stelem_R4:  case ILCode.Stelem_R8:  case ILCode.Stelem_Ref:  case ILCode.Stelem_Any: {  	ArrayType arrayType = InferTypeForExpression (expr.Arguments [0]' null) as ArrayType;  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [1]' typeSystem.Int32);  		if (arrayType != null) {  			InferTypeForExpression (expr.Arguments [2]' arrayType.ElementType);  		}  	}  	return arrayType != null ? arrayType.ElementType : null;  }  #endregion  #region Conversion instructions  case ILCode.Conv_I1:  case ILCode.Conv_Ovf_I1:  case ILCode.Conv_Ovf_I1_Un:  	return HandleConversion (8' true' expr.Arguments [0]' expectedType' typeSystem.SByte);  case ILCode.Conv_I2:  case ILCode.Conv_Ovf_I2:  case ILCode.Conv_Ovf_I2_Un:  	return HandleConversion (16' true' expr.Arguments [0]' expectedType' typeSystem.Int16);  case ILCode.Conv_I4:  case ILCode.Conv_Ovf_I4:  case ILCode.Conv_Ovf_I4_Un:  	return HandleConversion (32' true' expr.Arguments [0]' expectedType' typeSystem.Int32);  case ILCode.Conv_I8:  case ILCode.Conv_Ovf_I8:  case ILCode.Conv_Ovf_I8_Un:  	return HandleConversion (64' true' expr.Arguments [0]' expectedType' typeSystem.Int64);  case ILCode.Conv_U1:  case ILCode.Conv_Ovf_U1:  case ILCode.Conv_Ovf_U1_Un:  	return HandleConversion (8' false' expr.Arguments [0]' expectedType' typeSystem.Byte);  case ILCode.Conv_U2:  case ILCode.Conv_Ovf_U2:  case ILCode.Conv_Ovf_U2_Un:  	return HandleConversion (16' false' expr.Arguments [0]' expectedType' typeSystem.UInt16);  case ILCode.Conv_U4:  case ILCode.Conv_Ovf_U4:  case ILCode.Conv_Ovf_U4_Un:  	return HandleConversion (32' false' expr.Arguments [0]' expectedType' typeSystem.UInt32);  case ILCode.Conv_U8:  case ILCode.Conv_Ovf_U8:  case ILCode.Conv_Ovf_U8_Un:  	return HandleConversion (64' false' expr.Arguments [0]' expectedType' typeSystem.UInt64);  case ILCode.Conv_I:  case ILCode.Conv_Ovf_I:  case ILCode.Conv_Ovf_I_Un:  	return HandleConversion (NativeInt' true' expr.Arguments [0]' expectedType' typeSystem.IntPtr);  case ILCode.Conv_U:  case ILCode.Conv_Ovf_U:  case ILCode.Conv_Ovf_U_Un:  	return HandleConversion (NativeInt' false' expr.Arguments [0]' expectedType' typeSystem.UIntPtr);  case ILCode.Conv_R4:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' typeSystem.Single);  	}  	return typeSystem.Single;  case ILCode.Conv_R8:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' typeSystem.Double);  	}  	return typeSystem.Double;  case ILCode.Conv_R_Un:  	return (expectedType != null && expectedType.MetadataType == MetadataType.Single) ? typeSystem.Single : typeSystem.Double;  case ILCode.Castclass:  case ILCode.Unbox_Any:  	return (TypeReference)expr.Operand;  case ILCode.Unbox:  	return new ByReferenceType ((TypeReference)expr.Operand);  case ILCode.Isinst: {  	// isinst performs the equivalent of a cast only for reference types;  	// value types still need to be unboxed after an isinst instruction  	TypeReference tr = (TypeReference)expr.Operand;  	return tr.IsValueType ? typeSystem.Object : tr;  }  case ILCode.Box: {  	var tr = (TypeReference)expr.Operand;  	if (forceInferChildren)  		InferTypeForExpression (expr.Arguments.Single ()' tr);  	return tr.IsValueType ? typeSystem.Object : tr;  }  #endregion  #region Comparison instructions  case ILCode.Ceq:  case ILCode.Cne:  	if (forceInferChildren)  		InferArgumentsInBinaryOperator (expr' null' null);  	return typeSystem.Boolean;  case ILCode.Clt:  case ILCode.Cgt:  case ILCode.Cle:  case ILCode.Cge:  	if (forceInferChildren)  		InferArgumentsInBinaryOperator (expr' true' null);  	return typeSystem.Boolean;  case ILCode.Clt_Un:  case ILCode.Cgt_Un:  case ILCode.Cle_Un:  case ILCode.Cge_Un:  	if (forceInferChildren)  		InferArgumentsInBinaryOperator (expr' false' null);  	return typeSystem.Boolean;  #endregion  #region Branch instructions  case ILCode.Brtrue:  	if (forceInferChildren)  		InferTypeForExpression (expr.Arguments.Single ()' typeSystem.Boolean);  	return null;  case ILCode.Br:  case ILCode.Leave:  case ILCode.Endfinally:  case ILCode.Switch:  case ILCode.Throw:  case ILCode.Rethrow:  case ILCode.LoopOrSwitchBreak:  case ILCode.LoopContinue:  case ILCode.YieldBreak:  	return null;  case ILCode.Ret:  	if (forceInferChildren && expr.Arguments.Count == 1) {  		TypeReference returnType = context.CurrentMethod.ReturnType;  		if (context.CurrentMethodIsAsync && returnType != null && returnType.Namespace == "System.Threading.Tasks") {  			if (returnType.Name == "Task") {  				returnType = typeSystem.Void;  			} else if (returnType.Name == "Task`1" && returnType.IsGenericInstance) {  				returnType = ((GenericInstanceType)returnType).GenericArguments [0];  			}  		}  		InferTypeForExpression (expr.Arguments [0]' returnType);  	}  	return null;  case ILCode.YieldReturn:  	if (forceInferChildren) {  		GenericInstanceType genericType = context.CurrentMethod.ReturnType as GenericInstanceType;  		if (genericType != null) {  			// IEnumerable<T> or IEnumerator<T>  			InferTypeForExpression (expr.Arguments [0]' genericType.GenericArguments [0]);  		} else {  			// non-generic IEnumerable or IEnumerator  			InferTypeForExpression (expr.Arguments [0]' typeSystem.Object);  		}  	}  	return null;  case ILCode.Await: {  	TypeReference taskType = InferTypeForExpression (expr.Arguments [0]' null);  	if (taskType.Name == "Task`1" && taskType.IsGenericInstance && taskType.Namespace == "System.Threading.Tasks") {  		return ((GenericInstanceType)taskType).GenericArguments [0];  	}  	return null;  }  #endregion  case ILCode.Pop:  	return null;  case ILCode.Wrap:  case ILCode.Dup: {  	var arg = expr.Arguments.Single ();  	return arg.ExpectedType = InferTypeForExpression (arg' expectedType);  }  default:  	Debug.WriteLine ("Type Inference: Can't handle " + expr.Code.GetName ());  	return null;  }  
Magic Number,Custom.Decompiler.ILAst,TypeAnalysis,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\TypeAnalysis.cs,DoInferTypeForExpression,The following statement contains a magic number: switch (expr.Code) {  #region Logical operators  case ILCode.LogicNot:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments.Single ()' typeSystem.Boolean);  	}  	return typeSystem.Boolean;  case ILCode.LogicAnd:  case ILCode.LogicOr:  	// if Operand is set the logic and/or expression is a custom operator  	// we can deal with it the same as a normal invocation.  	if (expr.Operand != null)  		goto case ILCode.Call;  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' typeSystem.Boolean);  		InferTypeForExpression (expr.Arguments [1]' typeSystem.Boolean);  	}  	return typeSystem.Boolean;  case ILCode.TernaryOp:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' typeSystem.Boolean);  	}  	return InferBinaryArguments (expr.Arguments [1]' expr.Arguments [2]' expectedType' forceInferChildren);  case ILCode.NullCoalescing:  	return InferBinaryArguments (expr.Arguments [0]' expr.Arguments [1]' expectedType' forceInferChildren);  #endregion  #region Variable load/store  case ILCode.Stloc: {  	ILVariable v = (ILVariable)expr.Operand;  	if (forceInferChildren) {  		// do not use 'expectedType' in here!  		InferTypeForExpression (expr.Arguments.Single ()' v.Type);  	}  	return v.Type;  }  case ILCode.Ldloc: {  	ILVariable v = (ILVariable)expr.Operand;  	if (v.Type == null && singleLoadVariables.Contains (v)) {  		v.Type = expectedType;  	}  	return v.Type;  }  case ILCode.Ldloca: {  	ILVariable v = (ILVariable)expr.Operand;  	if (v.Type != null)  		return new ByReferenceType (v.Type);  	else  		return null;  }  #endregion  #region Call / NewObj  case ILCode.Call:  case ILCode.Callvirt:  case ILCode.CallGetter:  case ILCode.CallvirtGetter:  case ILCode.CallSetter:  case ILCode.CallvirtSetter: {  	MethodReference method = (MethodReference)expr.Operand;  	if (forceInferChildren) {  		for (int i = 0; i < expr.Arguments.Count; i++) {  			if (i == 0 && method.HasThis) {  				InferTypeForExpression (expr.Arguments [0]' MakeRefIfValueType (method.DeclaringType' expr.GetPrefix (ILCode.Constrained)));  			} else {  				InferTypeForExpression (expr.Arguments [i]' SubstituteTypeArgs (method.Parameters [method.HasThis ? i - 1 : i].ParameterType' method));  			}  		}  	}  	if (expr.Code == ILCode.CallSetter || expr.Code == ILCode.CallvirtSetter) {  		return SubstituteTypeArgs (method.Parameters.Last ().ParameterType' method);  	} else {  		return SubstituteTypeArgs (method.ReturnType' method);  	}  }  case ILCode.Newobj: {  	MethodReference ctor = (MethodReference)expr.Operand;  	if (forceInferChildren) {  		for (int i = 0; i < ctor.Parameters.Count; i++) {  			InferTypeForExpression (expr.Arguments [i]' SubstituteTypeArgs (ctor.Parameters [i].ParameterType' ctor));  		}  	}  	return ctor.DeclaringType;  }  case ILCode.InitObject:  case ILCode.InitCollection:  	return InferTypeForExpression (expr.Arguments [0]' expectedType);  case ILCode.InitializedObject:  	// expectedType should always be known due to the parent method call / property setter  	Debug.Assert (expectedType != null);  	return expectedType;  #endregion  #region Load/Store Fields  case ILCode.Ldfld:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' MakeRefIfValueType (((FieldReference)expr.Operand).DeclaringType' expr.GetPrefix (ILCode.Constrained)));  	}  	return GetFieldType ((FieldReference)expr.Operand);  case ILCode.Ldsfld:  	return GetFieldType ((FieldReference)expr.Operand);  case ILCode.Ldflda:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' MakeRefIfValueType (((FieldReference)expr.Operand).DeclaringType' expr.GetPrefix (ILCode.Constrained)));  	}  	return new ByReferenceType (GetFieldType ((FieldReference)expr.Operand));  case ILCode.Ldsflda:  	return new ByReferenceType (GetFieldType ((FieldReference)expr.Operand));  case ILCode.Stfld:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' MakeRefIfValueType (((FieldReference)expr.Operand).DeclaringType' expr.GetPrefix (ILCode.Constrained)));  		InferTypeForExpression (expr.Arguments [1]' GetFieldType ((FieldReference)expr.Operand));  	}  	return GetFieldType ((FieldReference)expr.Operand);  case ILCode.Stsfld:  	if (forceInferChildren)  		InferTypeForExpression (expr.Arguments [0]' GetFieldType ((FieldReference)expr.Operand));  	return GetFieldType ((FieldReference)expr.Operand);  #endregion  #region Reference/Pointer instructions  case ILCode.Ldind_Ref:  	return UnpackPointer (InferTypeForExpression (expr.Arguments [0]' null));  case ILCode.Stind_Ref:  	if (forceInferChildren) {  		TypeReference elementType = UnpackPointer (InferTypeForExpression (expr.Arguments [0]' null));  		InferTypeForExpression (expr.Arguments [1]' elementType);  	}  	return null;  case ILCode.Ldobj: {  	TypeReference type = (TypeReference)expr.Operand;  	var argType = InferTypeForExpression (expr.Arguments [0]' null);  	if (argType is PointerType || argType is ByReferenceType) {  		var elementType = ((TypeSpecification)argType).ElementType;  		int infoAmount = GetInformationAmount (elementType);  		if (infoAmount == 1 && GetInformationAmount (type) == 8) {  			// A bool can be loaded from both bytes and sbytes.  			type = elementType;  		}  		if (infoAmount >= 8 && infoAmount <= 64 && infoAmount == GetInformationAmount (type)) {  			// An integer can be loaded as another integer of the same size.  			// For integers smaller than 32 bit' the signs must match (as loading performs sign extension)  			bool? elementTypeIsSigned = IsSigned (elementType);  			bool? typeIsSigned = IsSigned (type);  			if (elementTypeIsSigned != null && typeIsSigned != null) {  				if (infoAmount >= 32 || elementTypeIsSigned == typeIsSigned)  					type = elementType;  			}  		}  	}  	if (argType is PointerType)  		InferTypeForExpression (expr.Arguments [0]' new PointerType (type));  	else  		InferTypeForExpression (expr.Arguments [0]' new ByReferenceType (type));  	return type;  }  case ILCode.Stobj: {  	TypeReference operandType = (TypeReference)expr.Operand;  	TypeReference pointerType = InferTypeForExpression (expr.Arguments [0]' new ByReferenceType (operandType));  	TypeReference elementType;  	if (pointerType is PointerType)  		elementType = ((PointerType)pointerType).ElementType;  	else if (pointerType is ByReferenceType)  		elementType = ((ByReferenceType)pointerType).ElementType;  	else  		elementType = null;  	if (elementType != null) {  		// An integer can be stored in any other integer of the same size.  		int infoAmount = GetInformationAmount (elementType);  		if (infoAmount == 1 && GetInformationAmount (operandType) == 8)  			operandType = elementType;  		else if (infoAmount == GetInformationAmount (operandType) && IsSigned (elementType) != null && IsSigned (operandType) != null)  			operandType = elementType;  	}  	if (forceInferChildren) {  		if (pointerType is PointerType)  			InferTypeForExpression (expr.Arguments [0]' new PointerType (operandType));  		else if (!IsSameType (operandType' expr.Operand as TypeReference))  			InferTypeForExpression (expr.Arguments [0]' new ByReferenceType (operandType));  		InferTypeForExpression (expr.Arguments [1]' operandType);  	}  	return operandType;  }  case ILCode.Initobj:  	return null;  case ILCode.DefaultValue:  	return (TypeReference)expr.Operand;  case ILCode.Localloc:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' typeSystem.Int32);  	}  	if (expectedType is PointerType)  		return expectedType;  	else  		return typeSystem.IntPtr;  case ILCode.Sizeof:  	return typeSystem.Int32;  case ILCode.PostIncrement:  case ILCode.PostIncrement_Ovf:  case ILCode.PostIncrement_Ovf_Un: {  	TypeReference elementType = UnpackPointer (InferTypeForExpression (expr.Arguments [0]' null));  	if (forceInferChildren && elementType != null) {  		// Assign expected type to the child expression  		InferTypeForExpression (expr.Arguments [0]' new ByReferenceType (elementType));  	}  	return elementType;  }  case ILCode.Mkrefany:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' (TypeReference)expr.Operand);  	}  	return typeSystem.TypedReference;  case ILCode.Refanytype:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' typeSystem.TypedReference);  	}  	return new TypeReference ("System"' "RuntimeTypeHandle"' module' module.TypeSystem.CoreLibrary' true);  case ILCode.Refanyval:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' typeSystem.TypedReference);  	}  	return new ByReferenceType ((TypeReference)expr.Operand);  case ILCode.AddressOf: {  	TypeReference t = InferTypeForExpression (expr.Arguments [0]' UnpackPointer (expectedType));  	return t != null ? new ByReferenceType (t) : null;  }  case ILCode.ValueOf:  	return GetNullableTypeArgument (InferTypeForExpression (expr.Arguments [0]' CreateNullableType (expectedType)));  case ILCode.NullableOf:  	return CreateNullableType (InferTypeForExpression (expr.Arguments [0]' GetNullableTypeArgument (expectedType)));  #endregion  #region Arithmetic instructions  case ILCode.Not:  // bitwise complement  case ILCode.Neg:  	return InferTypeForExpression (expr.Arguments.Single ()' expectedType);  case ILCode.Add:  	return InferArgumentsInAddition (expr' null' expectedType);  case ILCode.Sub:  	return InferArgumentsInSubtraction (expr' null' expectedType);  case ILCode.Mul:  case ILCode.Or:  case ILCode.And:  case ILCode.Xor:  	return InferArgumentsInBinaryOperator (expr' null' expectedType);  case ILCode.Add_Ovf:  	return InferArgumentsInAddition (expr' true' expectedType);  case ILCode.Sub_Ovf:  	return InferArgumentsInSubtraction (expr' true' expectedType);  case ILCode.Mul_Ovf:  case ILCode.Div:  case ILCode.Rem:  	return InferArgumentsInBinaryOperator (expr' true' expectedType);  case ILCode.Add_Ovf_Un:  	return InferArgumentsInAddition (expr' false' expectedType);  case ILCode.Sub_Ovf_Un:  	return InferArgumentsInSubtraction (expr' false' expectedType);  case ILCode.Mul_Ovf_Un:  case ILCode.Div_Un:  case ILCode.Rem_Un:  	return InferArgumentsInBinaryOperator (expr' false' expectedType);  case ILCode.Shl:  	if (forceInferChildren)  		InferTypeForExpression (expr.Arguments [1]' typeSystem.Int32);  	if (expectedType != null && (expectedType.MetadataType == MetadataType.Int32 || expectedType.MetadataType == MetadataType.UInt32 || expectedType.MetadataType == MetadataType.Int64 || expectedType.MetadataType == MetadataType.UInt64))  		return NumericPromotion (InferTypeForExpression (expr.Arguments [0]' expectedType));  	else  		return NumericPromotion (InferTypeForExpression (expr.Arguments [0]' null));  case ILCode.Shr:  case ILCode.Shr_Un: {  	if (forceInferChildren)  		InferTypeForExpression (expr.Arguments [1]' typeSystem.Int32);  	TypeReference type = NumericPromotion (InferTypeForExpression (expr.Arguments [0]' null));  	TypeReference expectedInputType = null;  	switch (type.MetadataType) {  	case MetadataType.Int32:  		if (expr.Code == ILCode.Shr_Un)  			expectedInputType = typeSystem.UInt32;  		break;  	case MetadataType.UInt32:  		if (expr.Code == ILCode.Shr)  			expectedInputType = typeSystem.Int32;  		break;  	case MetadataType.Int64:  		if (expr.Code == ILCode.Shr_Un)  			expectedInputType = typeSystem.UInt64;  		break;  	case MetadataType.UInt64:  		if (expr.Code == ILCode.Shr)  			expectedInputType = typeSystem.UInt64;  		break;  	}  	if (expectedInputType != null) {  		InferTypeForExpression (expr.Arguments [0]' expectedInputType);  		return expectedInputType;  	} else {  		return type;  	}  }  case ILCode.CompoundAssignment: {  	var op = expr.Arguments [0];  	if (op.Code == ILCode.NullableOf)  		op = op.Arguments [0].Arguments [0];  	var varType = InferTypeForExpression (op.Arguments [0]' null);  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' varType);  	}  	return varType;  }  #endregion  #region Constant loading instructions  case ILCode.Ldnull:  	return typeSystem.Object;  case ILCode.Ldstr:  	return typeSystem.String;  case ILCode.Ldftn:  case ILCode.Ldvirtftn:  	return typeSystem.IntPtr;  case ILCode.Ldc_I4:  	if (IsBoolean (expectedType) && ((int)expr.Operand == 0 || (int)expr.Operand == 1))  		return typeSystem.Boolean;  	if (expectedType is PointerType && (int)expr.Operand == 0)  		return expectedType;  	if (IsIntegerOrEnum (expectedType) && OperandFitsInType (expectedType' (int)expr.Operand))  		return expectedType;  	else  		return typeSystem.Int32;  case ILCode.Ldc_I8:  	if (expectedType is PointerType && (long)expr.Operand == 0)  		return expectedType;  	if (IsIntegerOrEnum (expectedType) && GetInformationAmount (expectedType) >= NativeInt)  		return expectedType;  	else  		return typeSystem.Int64;  case ILCode.Ldc_R4:  	return typeSystem.Single;  case ILCode.Ldc_R8:  	return typeSystem.Double;  case ILCode.Ldc_Decimal:  	return new TypeReference ("System"' "Decimal"' module' module.TypeSystem.CoreLibrary' true);  case ILCode.Ldtoken:  	if (expr.Operand is TypeReference)  		return new TypeReference ("System"' "RuntimeTypeHandle"' module' module.TypeSystem.CoreLibrary' true);  	else if (expr.Operand is FieldReference)  		return new TypeReference ("System"' "RuntimeFieldHandle"' module' module.TypeSystem.CoreLibrary' true);  	else  		return new TypeReference ("System"' "RuntimeMethodHandle"' module' module.TypeSystem.CoreLibrary' true);  case ILCode.Arglist:  	return new TypeReference ("System"' "RuntimeArgumentHandle"' module' module.TypeSystem.CoreLibrary' true);  #endregion  #region Array instructions  case ILCode.Newarr:  	if (forceInferChildren) {  		var lengthType = InferTypeForExpression (expr.Arguments.Single ()' null);  		if (lengthType == typeSystem.IntPtr) {  			lengthType = typeSystem.Int64;  		} else if (lengthType == typeSystem.UIntPtr) {  			lengthType = typeSystem.UInt64;  		} else if (lengthType != typeSystem.UInt32 && lengthType != typeSystem.Int64 && lengthType != typeSystem.UInt64) {  			lengthType = typeSystem.Int32;  		}  		if (forceInferChildren) {  			InferTypeForExpression (expr.Arguments.Single ()' lengthType);  		}  	}  	return new ArrayType ((TypeReference)expr.Operand);  case ILCode.InitArray:  	var operandAsArrayType = (ArrayType)expr.Operand;  	if (forceInferChildren) {  		foreach (ILExpression arg in expr.Arguments)  			InferTypeForExpression (arg' operandAsArrayType.ElementType);  	}  	return operandAsArrayType;  case ILCode.Ldlen:  	return typeSystem.Int32;  case ILCode.Ldelem_U1:  case ILCode.Ldelem_U2:  case ILCode.Ldelem_U4:  case ILCode.Ldelem_I1:  case ILCode.Ldelem_I2:  case ILCode.Ldelem_I4:  case ILCode.Ldelem_I8:  case ILCode.Ldelem_R4:  case ILCode.Ldelem_R8:  case ILCode.Ldelem_I:  case ILCode.Ldelem_Ref: {  	ArrayType arrayType = InferTypeForExpression (expr.Arguments [0]' null) as ArrayType;  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [1]' typeSystem.Int32);  	}  	return arrayType != null ? arrayType.ElementType : null;  }  case ILCode.Ldelem_Any:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [1]' typeSystem.Int32);  	}  	return (TypeReference)expr.Operand;  case ILCode.Ldelema: {  	ArrayType arrayType = InferTypeForExpression (expr.Arguments [0]' null) as ArrayType;  	if (forceInferChildren)  		InferTypeForExpression (expr.Arguments [1]' typeSystem.Int32);  	return arrayType != null ? new ByReferenceType (arrayType.ElementType) : null;  }  case ILCode.Stelem_I:  case ILCode.Stelem_I1:  case ILCode.Stelem_I2:  case ILCode.Stelem_I4:  case ILCode.Stelem_I8:  case ILCode.Stelem_R4:  case ILCode.Stelem_R8:  case ILCode.Stelem_Ref:  case ILCode.Stelem_Any: {  	ArrayType arrayType = InferTypeForExpression (expr.Arguments [0]' null) as ArrayType;  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [1]' typeSystem.Int32);  		if (arrayType != null) {  			InferTypeForExpression (expr.Arguments [2]' arrayType.ElementType);  		}  	}  	return arrayType != null ? arrayType.ElementType : null;  }  #endregion  #region Conversion instructions  case ILCode.Conv_I1:  case ILCode.Conv_Ovf_I1:  case ILCode.Conv_Ovf_I1_Un:  	return HandleConversion (8' true' expr.Arguments [0]' expectedType' typeSystem.SByte);  case ILCode.Conv_I2:  case ILCode.Conv_Ovf_I2:  case ILCode.Conv_Ovf_I2_Un:  	return HandleConversion (16' true' expr.Arguments [0]' expectedType' typeSystem.Int16);  case ILCode.Conv_I4:  case ILCode.Conv_Ovf_I4:  case ILCode.Conv_Ovf_I4_Un:  	return HandleConversion (32' true' expr.Arguments [0]' expectedType' typeSystem.Int32);  case ILCode.Conv_I8:  case ILCode.Conv_Ovf_I8:  case ILCode.Conv_Ovf_I8_Un:  	return HandleConversion (64' true' expr.Arguments [0]' expectedType' typeSystem.Int64);  case ILCode.Conv_U1:  case ILCode.Conv_Ovf_U1:  case ILCode.Conv_Ovf_U1_Un:  	return HandleConversion (8' false' expr.Arguments [0]' expectedType' typeSystem.Byte);  case ILCode.Conv_U2:  case ILCode.Conv_Ovf_U2:  case ILCode.Conv_Ovf_U2_Un:  	return HandleConversion (16' false' expr.Arguments [0]' expectedType' typeSystem.UInt16);  case ILCode.Conv_U4:  case ILCode.Conv_Ovf_U4:  case ILCode.Conv_Ovf_U4_Un:  	return HandleConversion (32' false' expr.Arguments [0]' expectedType' typeSystem.UInt32);  case ILCode.Conv_U8:  case ILCode.Conv_Ovf_U8:  case ILCode.Conv_Ovf_U8_Un:  	return HandleConversion (64' false' expr.Arguments [0]' expectedType' typeSystem.UInt64);  case ILCode.Conv_I:  case ILCode.Conv_Ovf_I:  case ILCode.Conv_Ovf_I_Un:  	return HandleConversion (NativeInt' true' expr.Arguments [0]' expectedType' typeSystem.IntPtr);  case ILCode.Conv_U:  case ILCode.Conv_Ovf_U:  case ILCode.Conv_Ovf_U_Un:  	return HandleConversion (NativeInt' false' expr.Arguments [0]' expectedType' typeSystem.UIntPtr);  case ILCode.Conv_R4:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' typeSystem.Single);  	}  	return typeSystem.Single;  case ILCode.Conv_R8:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' typeSystem.Double);  	}  	return typeSystem.Double;  case ILCode.Conv_R_Un:  	return (expectedType != null && expectedType.MetadataType == MetadataType.Single) ? typeSystem.Single : typeSystem.Double;  case ILCode.Castclass:  case ILCode.Unbox_Any:  	return (TypeReference)expr.Operand;  case ILCode.Unbox:  	return new ByReferenceType ((TypeReference)expr.Operand);  case ILCode.Isinst: {  	// isinst performs the equivalent of a cast only for reference types;  	// value types still need to be unboxed after an isinst instruction  	TypeReference tr = (TypeReference)expr.Operand;  	return tr.IsValueType ? typeSystem.Object : tr;  }  case ILCode.Box: {  	var tr = (TypeReference)expr.Operand;  	if (forceInferChildren)  		InferTypeForExpression (expr.Arguments.Single ()' tr);  	return tr.IsValueType ? typeSystem.Object : tr;  }  #endregion  #region Comparison instructions  case ILCode.Ceq:  case ILCode.Cne:  	if (forceInferChildren)  		InferArgumentsInBinaryOperator (expr' null' null);  	return typeSystem.Boolean;  case ILCode.Clt:  case ILCode.Cgt:  case ILCode.Cle:  case ILCode.Cge:  	if (forceInferChildren)  		InferArgumentsInBinaryOperator (expr' true' null);  	return typeSystem.Boolean;  case ILCode.Clt_Un:  case ILCode.Cgt_Un:  case ILCode.Cle_Un:  case ILCode.Cge_Un:  	if (forceInferChildren)  		InferArgumentsInBinaryOperator (expr' false' null);  	return typeSystem.Boolean;  #endregion  #region Branch instructions  case ILCode.Brtrue:  	if (forceInferChildren)  		InferTypeForExpression (expr.Arguments.Single ()' typeSystem.Boolean);  	return null;  case ILCode.Br:  case ILCode.Leave:  case ILCode.Endfinally:  case ILCode.Switch:  case ILCode.Throw:  case ILCode.Rethrow:  case ILCode.LoopOrSwitchBreak:  case ILCode.LoopContinue:  case ILCode.YieldBreak:  	return null;  case ILCode.Ret:  	if (forceInferChildren && expr.Arguments.Count == 1) {  		TypeReference returnType = context.CurrentMethod.ReturnType;  		if (context.CurrentMethodIsAsync && returnType != null && returnType.Namespace == "System.Threading.Tasks") {  			if (returnType.Name == "Task") {  				returnType = typeSystem.Void;  			} else if (returnType.Name == "Task`1" && returnType.IsGenericInstance) {  				returnType = ((GenericInstanceType)returnType).GenericArguments [0];  			}  		}  		InferTypeForExpression (expr.Arguments [0]' returnType);  	}  	return null;  case ILCode.YieldReturn:  	if (forceInferChildren) {  		GenericInstanceType genericType = context.CurrentMethod.ReturnType as GenericInstanceType;  		if (genericType != null) {  			// IEnumerable<T> or IEnumerator<T>  			InferTypeForExpression (expr.Arguments [0]' genericType.GenericArguments [0]);  		} else {  			// non-generic IEnumerable or IEnumerator  			InferTypeForExpression (expr.Arguments [0]' typeSystem.Object);  		}  	}  	return null;  case ILCode.Await: {  	TypeReference taskType = InferTypeForExpression (expr.Arguments [0]' null);  	if (taskType.Name == "Task`1" && taskType.IsGenericInstance && taskType.Namespace == "System.Threading.Tasks") {  		return ((GenericInstanceType)taskType).GenericArguments [0];  	}  	return null;  }  #endregion  case ILCode.Pop:  	return null;  case ILCode.Wrap:  case ILCode.Dup: {  	var arg = expr.Arguments.Single ();  	return arg.ExpectedType = InferTypeForExpression (arg' expectedType);  }  default:  	Debug.WriteLine ("Type Inference: Can't handle " + expr.Code.GetName ());  	return null;  }  
Magic Number,Custom.Decompiler.ILAst,TypeAnalysis,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\TypeAnalysis.cs,DoInferTypeForExpression,The following statement contains a magic number: switch (expr.Code) {  #region Logical operators  case ILCode.LogicNot:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments.Single ()' typeSystem.Boolean);  	}  	return typeSystem.Boolean;  case ILCode.LogicAnd:  case ILCode.LogicOr:  	// if Operand is set the logic and/or expression is a custom operator  	// we can deal with it the same as a normal invocation.  	if (expr.Operand != null)  		goto case ILCode.Call;  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' typeSystem.Boolean);  		InferTypeForExpression (expr.Arguments [1]' typeSystem.Boolean);  	}  	return typeSystem.Boolean;  case ILCode.TernaryOp:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' typeSystem.Boolean);  	}  	return InferBinaryArguments (expr.Arguments [1]' expr.Arguments [2]' expectedType' forceInferChildren);  case ILCode.NullCoalescing:  	return InferBinaryArguments (expr.Arguments [0]' expr.Arguments [1]' expectedType' forceInferChildren);  #endregion  #region Variable load/store  case ILCode.Stloc: {  	ILVariable v = (ILVariable)expr.Operand;  	if (forceInferChildren) {  		// do not use 'expectedType' in here!  		InferTypeForExpression (expr.Arguments.Single ()' v.Type);  	}  	return v.Type;  }  case ILCode.Ldloc: {  	ILVariable v = (ILVariable)expr.Operand;  	if (v.Type == null && singleLoadVariables.Contains (v)) {  		v.Type = expectedType;  	}  	return v.Type;  }  case ILCode.Ldloca: {  	ILVariable v = (ILVariable)expr.Operand;  	if (v.Type != null)  		return new ByReferenceType (v.Type);  	else  		return null;  }  #endregion  #region Call / NewObj  case ILCode.Call:  case ILCode.Callvirt:  case ILCode.CallGetter:  case ILCode.CallvirtGetter:  case ILCode.CallSetter:  case ILCode.CallvirtSetter: {  	MethodReference method = (MethodReference)expr.Operand;  	if (forceInferChildren) {  		for (int i = 0; i < expr.Arguments.Count; i++) {  			if (i == 0 && method.HasThis) {  				InferTypeForExpression (expr.Arguments [0]' MakeRefIfValueType (method.DeclaringType' expr.GetPrefix (ILCode.Constrained)));  			} else {  				InferTypeForExpression (expr.Arguments [i]' SubstituteTypeArgs (method.Parameters [method.HasThis ? i - 1 : i].ParameterType' method));  			}  		}  	}  	if (expr.Code == ILCode.CallSetter || expr.Code == ILCode.CallvirtSetter) {  		return SubstituteTypeArgs (method.Parameters.Last ().ParameterType' method);  	} else {  		return SubstituteTypeArgs (method.ReturnType' method);  	}  }  case ILCode.Newobj: {  	MethodReference ctor = (MethodReference)expr.Operand;  	if (forceInferChildren) {  		for (int i = 0; i < ctor.Parameters.Count; i++) {  			InferTypeForExpression (expr.Arguments [i]' SubstituteTypeArgs (ctor.Parameters [i].ParameterType' ctor));  		}  	}  	return ctor.DeclaringType;  }  case ILCode.InitObject:  case ILCode.InitCollection:  	return InferTypeForExpression (expr.Arguments [0]' expectedType);  case ILCode.InitializedObject:  	// expectedType should always be known due to the parent method call / property setter  	Debug.Assert (expectedType != null);  	return expectedType;  #endregion  #region Load/Store Fields  case ILCode.Ldfld:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' MakeRefIfValueType (((FieldReference)expr.Operand).DeclaringType' expr.GetPrefix (ILCode.Constrained)));  	}  	return GetFieldType ((FieldReference)expr.Operand);  case ILCode.Ldsfld:  	return GetFieldType ((FieldReference)expr.Operand);  case ILCode.Ldflda:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' MakeRefIfValueType (((FieldReference)expr.Operand).DeclaringType' expr.GetPrefix (ILCode.Constrained)));  	}  	return new ByReferenceType (GetFieldType ((FieldReference)expr.Operand));  case ILCode.Ldsflda:  	return new ByReferenceType (GetFieldType ((FieldReference)expr.Operand));  case ILCode.Stfld:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' MakeRefIfValueType (((FieldReference)expr.Operand).DeclaringType' expr.GetPrefix (ILCode.Constrained)));  		InferTypeForExpression (expr.Arguments [1]' GetFieldType ((FieldReference)expr.Operand));  	}  	return GetFieldType ((FieldReference)expr.Operand);  case ILCode.Stsfld:  	if (forceInferChildren)  		InferTypeForExpression (expr.Arguments [0]' GetFieldType ((FieldReference)expr.Operand));  	return GetFieldType ((FieldReference)expr.Operand);  #endregion  #region Reference/Pointer instructions  case ILCode.Ldind_Ref:  	return UnpackPointer (InferTypeForExpression (expr.Arguments [0]' null));  case ILCode.Stind_Ref:  	if (forceInferChildren) {  		TypeReference elementType = UnpackPointer (InferTypeForExpression (expr.Arguments [0]' null));  		InferTypeForExpression (expr.Arguments [1]' elementType);  	}  	return null;  case ILCode.Ldobj: {  	TypeReference type = (TypeReference)expr.Operand;  	var argType = InferTypeForExpression (expr.Arguments [0]' null);  	if (argType is PointerType || argType is ByReferenceType) {  		var elementType = ((TypeSpecification)argType).ElementType;  		int infoAmount = GetInformationAmount (elementType);  		if (infoAmount == 1 && GetInformationAmount (type) == 8) {  			// A bool can be loaded from both bytes and sbytes.  			type = elementType;  		}  		if (infoAmount >= 8 && infoAmount <= 64 && infoAmount == GetInformationAmount (type)) {  			// An integer can be loaded as another integer of the same size.  			// For integers smaller than 32 bit' the signs must match (as loading performs sign extension)  			bool? elementTypeIsSigned = IsSigned (elementType);  			bool? typeIsSigned = IsSigned (type);  			if (elementTypeIsSigned != null && typeIsSigned != null) {  				if (infoAmount >= 32 || elementTypeIsSigned == typeIsSigned)  					type = elementType;  			}  		}  	}  	if (argType is PointerType)  		InferTypeForExpression (expr.Arguments [0]' new PointerType (type));  	else  		InferTypeForExpression (expr.Arguments [0]' new ByReferenceType (type));  	return type;  }  case ILCode.Stobj: {  	TypeReference operandType = (TypeReference)expr.Operand;  	TypeReference pointerType = InferTypeForExpression (expr.Arguments [0]' new ByReferenceType (operandType));  	TypeReference elementType;  	if (pointerType is PointerType)  		elementType = ((PointerType)pointerType).ElementType;  	else if (pointerType is ByReferenceType)  		elementType = ((ByReferenceType)pointerType).ElementType;  	else  		elementType = null;  	if (elementType != null) {  		// An integer can be stored in any other integer of the same size.  		int infoAmount = GetInformationAmount (elementType);  		if (infoAmount == 1 && GetInformationAmount (operandType) == 8)  			operandType = elementType;  		else if (infoAmount == GetInformationAmount (operandType) && IsSigned (elementType) != null && IsSigned (operandType) != null)  			operandType = elementType;  	}  	if (forceInferChildren) {  		if (pointerType is PointerType)  			InferTypeForExpression (expr.Arguments [0]' new PointerType (operandType));  		else if (!IsSameType (operandType' expr.Operand as TypeReference))  			InferTypeForExpression (expr.Arguments [0]' new ByReferenceType (operandType));  		InferTypeForExpression (expr.Arguments [1]' operandType);  	}  	return operandType;  }  case ILCode.Initobj:  	return null;  case ILCode.DefaultValue:  	return (TypeReference)expr.Operand;  case ILCode.Localloc:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' typeSystem.Int32);  	}  	if (expectedType is PointerType)  		return expectedType;  	else  		return typeSystem.IntPtr;  case ILCode.Sizeof:  	return typeSystem.Int32;  case ILCode.PostIncrement:  case ILCode.PostIncrement_Ovf:  case ILCode.PostIncrement_Ovf_Un: {  	TypeReference elementType = UnpackPointer (InferTypeForExpression (expr.Arguments [0]' null));  	if (forceInferChildren && elementType != null) {  		// Assign expected type to the child expression  		InferTypeForExpression (expr.Arguments [0]' new ByReferenceType (elementType));  	}  	return elementType;  }  case ILCode.Mkrefany:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' (TypeReference)expr.Operand);  	}  	return typeSystem.TypedReference;  case ILCode.Refanytype:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' typeSystem.TypedReference);  	}  	return new TypeReference ("System"' "RuntimeTypeHandle"' module' module.TypeSystem.CoreLibrary' true);  case ILCode.Refanyval:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' typeSystem.TypedReference);  	}  	return new ByReferenceType ((TypeReference)expr.Operand);  case ILCode.AddressOf: {  	TypeReference t = InferTypeForExpression (expr.Arguments [0]' UnpackPointer (expectedType));  	return t != null ? new ByReferenceType (t) : null;  }  case ILCode.ValueOf:  	return GetNullableTypeArgument (InferTypeForExpression (expr.Arguments [0]' CreateNullableType (expectedType)));  case ILCode.NullableOf:  	return CreateNullableType (InferTypeForExpression (expr.Arguments [0]' GetNullableTypeArgument (expectedType)));  #endregion  #region Arithmetic instructions  case ILCode.Not:  // bitwise complement  case ILCode.Neg:  	return InferTypeForExpression (expr.Arguments.Single ()' expectedType);  case ILCode.Add:  	return InferArgumentsInAddition (expr' null' expectedType);  case ILCode.Sub:  	return InferArgumentsInSubtraction (expr' null' expectedType);  case ILCode.Mul:  case ILCode.Or:  case ILCode.And:  case ILCode.Xor:  	return InferArgumentsInBinaryOperator (expr' null' expectedType);  case ILCode.Add_Ovf:  	return InferArgumentsInAddition (expr' true' expectedType);  case ILCode.Sub_Ovf:  	return InferArgumentsInSubtraction (expr' true' expectedType);  case ILCode.Mul_Ovf:  case ILCode.Div:  case ILCode.Rem:  	return InferArgumentsInBinaryOperator (expr' true' expectedType);  case ILCode.Add_Ovf_Un:  	return InferArgumentsInAddition (expr' false' expectedType);  case ILCode.Sub_Ovf_Un:  	return InferArgumentsInSubtraction (expr' false' expectedType);  case ILCode.Mul_Ovf_Un:  case ILCode.Div_Un:  case ILCode.Rem_Un:  	return InferArgumentsInBinaryOperator (expr' false' expectedType);  case ILCode.Shl:  	if (forceInferChildren)  		InferTypeForExpression (expr.Arguments [1]' typeSystem.Int32);  	if (expectedType != null && (expectedType.MetadataType == MetadataType.Int32 || expectedType.MetadataType == MetadataType.UInt32 || expectedType.MetadataType == MetadataType.Int64 || expectedType.MetadataType == MetadataType.UInt64))  		return NumericPromotion (InferTypeForExpression (expr.Arguments [0]' expectedType));  	else  		return NumericPromotion (InferTypeForExpression (expr.Arguments [0]' null));  case ILCode.Shr:  case ILCode.Shr_Un: {  	if (forceInferChildren)  		InferTypeForExpression (expr.Arguments [1]' typeSystem.Int32);  	TypeReference type = NumericPromotion (InferTypeForExpression (expr.Arguments [0]' null));  	TypeReference expectedInputType = null;  	switch (type.MetadataType) {  	case MetadataType.Int32:  		if (expr.Code == ILCode.Shr_Un)  			expectedInputType = typeSystem.UInt32;  		break;  	case MetadataType.UInt32:  		if (expr.Code == ILCode.Shr)  			expectedInputType = typeSystem.Int32;  		break;  	case MetadataType.Int64:  		if (expr.Code == ILCode.Shr_Un)  			expectedInputType = typeSystem.UInt64;  		break;  	case MetadataType.UInt64:  		if (expr.Code == ILCode.Shr)  			expectedInputType = typeSystem.UInt64;  		break;  	}  	if (expectedInputType != null) {  		InferTypeForExpression (expr.Arguments [0]' expectedInputType);  		return expectedInputType;  	} else {  		return type;  	}  }  case ILCode.CompoundAssignment: {  	var op = expr.Arguments [0];  	if (op.Code == ILCode.NullableOf)  		op = op.Arguments [0].Arguments [0];  	var varType = InferTypeForExpression (op.Arguments [0]' null);  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' varType);  	}  	return varType;  }  #endregion  #region Constant loading instructions  case ILCode.Ldnull:  	return typeSystem.Object;  case ILCode.Ldstr:  	return typeSystem.String;  case ILCode.Ldftn:  case ILCode.Ldvirtftn:  	return typeSystem.IntPtr;  case ILCode.Ldc_I4:  	if (IsBoolean (expectedType) && ((int)expr.Operand == 0 || (int)expr.Operand == 1))  		return typeSystem.Boolean;  	if (expectedType is PointerType && (int)expr.Operand == 0)  		return expectedType;  	if (IsIntegerOrEnum (expectedType) && OperandFitsInType (expectedType' (int)expr.Operand))  		return expectedType;  	else  		return typeSystem.Int32;  case ILCode.Ldc_I8:  	if (expectedType is PointerType && (long)expr.Operand == 0)  		return expectedType;  	if (IsIntegerOrEnum (expectedType) && GetInformationAmount (expectedType) >= NativeInt)  		return expectedType;  	else  		return typeSystem.Int64;  case ILCode.Ldc_R4:  	return typeSystem.Single;  case ILCode.Ldc_R8:  	return typeSystem.Double;  case ILCode.Ldc_Decimal:  	return new TypeReference ("System"' "Decimal"' module' module.TypeSystem.CoreLibrary' true);  case ILCode.Ldtoken:  	if (expr.Operand is TypeReference)  		return new TypeReference ("System"' "RuntimeTypeHandle"' module' module.TypeSystem.CoreLibrary' true);  	else if (expr.Operand is FieldReference)  		return new TypeReference ("System"' "RuntimeFieldHandle"' module' module.TypeSystem.CoreLibrary' true);  	else  		return new TypeReference ("System"' "RuntimeMethodHandle"' module' module.TypeSystem.CoreLibrary' true);  case ILCode.Arglist:  	return new TypeReference ("System"' "RuntimeArgumentHandle"' module' module.TypeSystem.CoreLibrary' true);  #endregion  #region Array instructions  case ILCode.Newarr:  	if (forceInferChildren) {  		var lengthType = InferTypeForExpression (expr.Arguments.Single ()' null);  		if (lengthType == typeSystem.IntPtr) {  			lengthType = typeSystem.Int64;  		} else if (lengthType == typeSystem.UIntPtr) {  			lengthType = typeSystem.UInt64;  		} else if (lengthType != typeSystem.UInt32 && lengthType != typeSystem.Int64 && lengthType != typeSystem.UInt64) {  			lengthType = typeSystem.Int32;  		}  		if (forceInferChildren) {  			InferTypeForExpression (expr.Arguments.Single ()' lengthType);  		}  	}  	return new ArrayType ((TypeReference)expr.Operand);  case ILCode.InitArray:  	var operandAsArrayType = (ArrayType)expr.Operand;  	if (forceInferChildren) {  		foreach (ILExpression arg in expr.Arguments)  			InferTypeForExpression (arg' operandAsArrayType.ElementType);  	}  	return operandAsArrayType;  case ILCode.Ldlen:  	return typeSystem.Int32;  case ILCode.Ldelem_U1:  case ILCode.Ldelem_U2:  case ILCode.Ldelem_U4:  case ILCode.Ldelem_I1:  case ILCode.Ldelem_I2:  case ILCode.Ldelem_I4:  case ILCode.Ldelem_I8:  case ILCode.Ldelem_R4:  case ILCode.Ldelem_R8:  case ILCode.Ldelem_I:  case ILCode.Ldelem_Ref: {  	ArrayType arrayType = InferTypeForExpression (expr.Arguments [0]' null) as ArrayType;  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [1]' typeSystem.Int32);  	}  	return arrayType != null ? arrayType.ElementType : null;  }  case ILCode.Ldelem_Any:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [1]' typeSystem.Int32);  	}  	return (TypeReference)expr.Operand;  case ILCode.Ldelema: {  	ArrayType arrayType = InferTypeForExpression (expr.Arguments [0]' null) as ArrayType;  	if (forceInferChildren)  		InferTypeForExpression (expr.Arguments [1]' typeSystem.Int32);  	return arrayType != null ? new ByReferenceType (arrayType.ElementType) : null;  }  case ILCode.Stelem_I:  case ILCode.Stelem_I1:  case ILCode.Stelem_I2:  case ILCode.Stelem_I4:  case ILCode.Stelem_I8:  case ILCode.Stelem_R4:  case ILCode.Stelem_R8:  case ILCode.Stelem_Ref:  case ILCode.Stelem_Any: {  	ArrayType arrayType = InferTypeForExpression (expr.Arguments [0]' null) as ArrayType;  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [1]' typeSystem.Int32);  		if (arrayType != null) {  			InferTypeForExpression (expr.Arguments [2]' arrayType.ElementType);  		}  	}  	return arrayType != null ? arrayType.ElementType : null;  }  #endregion  #region Conversion instructions  case ILCode.Conv_I1:  case ILCode.Conv_Ovf_I1:  case ILCode.Conv_Ovf_I1_Un:  	return HandleConversion (8' true' expr.Arguments [0]' expectedType' typeSystem.SByte);  case ILCode.Conv_I2:  case ILCode.Conv_Ovf_I2:  case ILCode.Conv_Ovf_I2_Un:  	return HandleConversion (16' true' expr.Arguments [0]' expectedType' typeSystem.Int16);  case ILCode.Conv_I4:  case ILCode.Conv_Ovf_I4:  case ILCode.Conv_Ovf_I4_Un:  	return HandleConversion (32' true' expr.Arguments [0]' expectedType' typeSystem.Int32);  case ILCode.Conv_I8:  case ILCode.Conv_Ovf_I8:  case ILCode.Conv_Ovf_I8_Un:  	return HandleConversion (64' true' expr.Arguments [0]' expectedType' typeSystem.Int64);  case ILCode.Conv_U1:  case ILCode.Conv_Ovf_U1:  case ILCode.Conv_Ovf_U1_Un:  	return HandleConversion (8' false' expr.Arguments [0]' expectedType' typeSystem.Byte);  case ILCode.Conv_U2:  case ILCode.Conv_Ovf_U2:  case ILCode.Conv_Ovf_U2_Un:  	return HandleConversion (16' false' expr.Arguments [0]' expectedType' typeSystem.UInt16);  case ILCode.Conv_U4:  case ILCode.Conv_Ovf_U4:  case ILCode.Conv_Ovf_U4_Un:  	return HandleConversion (32' false' expr.Arguments [0]' expectedType' typeSystem.UInt32);  case ILCode.Conv_U8:  case ILCode.Conv_Ovf_U8:  case ILCode.Conv_Ovf_U8_Un:  	return HandleConversion (64' false' expr.Arguments [0]' expectedType' typeSystem.UInt64);  case ILCode.Conv_I:  case ILCode.Conv_Ovf_I:  case ILCode.Conv_Ovf_I_Un:  	return HandleConversion (NativeInt' true' expr.Arguments [0]' expectedType' typeSystem.IntPtr);  case ILCode.Conv_U:  case ILCode.Conv_Ovf_U:  case ILCode.Conv_Ovf_U_Un:  	return HandleConversion (NativeInt' false' expr.Arguments [0]' expectedType' typeSystem.UIntPtr);  case ILCode.Conv_R4:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' typeSystem.Single);  	}  	return typeSystem.Single;  case ILCode.Conv_R8:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' typeSystem.Double);  	}  	return typeSystem.Double;  case ILCode.Conv_R_Un:  	return (expectedType != null && expectedType.MetadataType == MetadataType.Single) ? typeSystem.Single : typeSystem.Double;  case ILCode.Castclass:  case ILCode.Unbox_Any:  	return (TypeReference)expr.Operand;  case ILCode.Unbox:  	return new ByReferenceType ((TypeReference)expr.Operand);  case ILCode.Isinst: {  	// isinst performs the equivalent of a cast only for reference types;  	// value types still need to be unboxed after an isinst instruction  	TypeReference tr = (TypeReference)expr.Operand;  	return tr.IsValueType ? typeSystem.Object : tr;  }  case ILCode.Box: {  	var tr = (TypeReference)expr.Operand;  	if (forceInferChildren)  		InferTypeForExpression (expr.Arguments.Single ()' tr);  	return tr.IsValueType ? typeSystem.Object : tr;  }  #endregion  #region Comparison instructions  case ILCode.Ceq:  case ILCode.Cne:  	if (forceInferChildren)  		InferArgumentsInBinaryOperator (expr' null' null);  	return typeSystem.Boolean;  case ILCode.Clt:  case ILCode.Cgt:  case ILCode.Cle:  case ILCode.Cge:  	if (forceInferChildren)  		InferArgumentsInBinaryOperator (expr' true' null);  	return typeSystem.Boolean;  case ILCode.Clt_Un:  case ILCode.Cgt_Un:  case ILCode.Cle_Un:  case ILCode.Cge_Un:  	if (forceInferChildren)  		InferArgumentsInBinaryOperator (expr' false' null);  	return typeSystem.Boolean;  #endregion  #region Branch instructions  case ILCode.Brtrue:  	if (forceInferChildren)  		InferTypeForExpression (expr.Arguments.Single ()' typeSystem.Boolean);  	return null;  case ILCode.Br:  case ILCode.Leave:  case ILCode.Endfinally:  case ILCode.Switch:  case ILCode.Throw:  case ILCode.Rethrow:  case ILCode.LoopOrSwitchBreak:  case ILCode.LoopContinue:  case ILCode.YieldBreak:  	return null;  case ILCode.Ret:  	if (forceInferChildren && expr.Arguments.Count == 1) {  		TypeReference returnType = context.CurrentMethod.ReturnType;  		if (context.CurrentMethodIsAsync && returnType != null && returnType.Namespace == "System.Threading.Tasks") {  			if (returnType.Name == "Task") {  				returnType = typeSystem.Void;  			} else if (returnType.Name == "Task`1" && returnType.IsGenericInstance) {  				returnType = ((GenericInstanceType)returnType).GenericArguments [0];  			}  		}  		InferTypeForExpression (expr.Arguments [0]' returnType);  	}  	return null;  case ILCode.YieldReturn:  	if (forceInferChildren) {  		GenericInstanceType genericType = context.CurrentMethod.ReturnType as GenericInstanceType;  		if (genericType != null) {  			// IEnumerable<T> or IEnumerator<T>  			InferTypeForExpression (expr.Arguments [0]' genericType.GenericArguments [0]);  		} else {  			// non-generic IEnumerable or IEnumerator  			InferTypeForExpression (expr.Arguments [0]' typeSystem.Object);  		}  	}  	return null;  case ILCode.Await: {  	TypeReference taskType = InferTypeForExpression (expr.Arguments [0]' null);  	if (taskType.Name == "Task`1" && taskType.IsGenericInstance && taskType.Namespace == "System.Threading.Tasks") {  		return ((GenericInstanceType)taskType).GenericArguments [0];  	}  	return null;  }  #endregion  case ILCode.Pop:  	return null;  case ILCode.Wrap:  case ILCode.Dup: {  	var arg = expr.Arguments.Single ();  	return arg.ExpectedType = InferTypeForExpression (arg' expectedType);  }  default:  	Debug.WriteLine ("Type Inference: Can't handle " + expr.Code.GetName ());  	return null;  }  
Magic Number,Custom.Decompiler.ILAst,TypeAnalysis,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\TypeAnalysis.cs,DoInferTypeForExpression,The following statement contains a magic number: switch (expr.Code) {  #region Logical operators  case ILCode.LogicNot:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments.Single ()' typeSystem.Boolean);  	}  	return typeSystem.Boolean;  case ILCode.LogicAnd:  case ILCode.LogicOr:  	// if Operand is set the logic and/or expression is a custom operator  	// we can deal with it the same as a normal invocation.  	if (expr.Operand != null)  		goto case ILCode.Call;  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' typeSystem.Boolean);  		InferTypeForExpression (expr.Arguments [1]' typeSystem.Boolean);  	}  	return typeSystem.Boolean;  case ILCode.TernaryOp:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' typeSystem.Boolean);  	}  	return InferBinaryArguments (expr.Arguments [1]' expr.Arguments [2]' expectedType' forceInferChildren);  case ILCode.NullCoalescing:  	return InferBinaryArguments (expr.Arguments [0]' expr.Arguments [1]' expectedType' forceInferChildren);  #endregion  #region Variable load/store  case ILCode.Stloc: {  	ILVariable v = (ILVariable)expr.Operand;  	if (forceInferChildren) {  		// do not use 'expectedType' in here!  		InferTypeForExpression (expr.Arguments.Single ()' v.Type);  	}  	return v.Type;  }  case ILCode.Ldloc: {  	ILVariable v = (ILVariable)expr.Operand;  	if (v.Type == null && singleLoadVariables.Contains (v)) {  		v.Type = expectedType;  	}  	return v.Type;  }  case ILCode.Ldloca: {  	ILVariable v = (ILVariable)expr.Operand;  	if (v.Type != null)  		return new ByReferenceType (v.Type);  	else  		return null;  }  #endregion  #region Call / NewObj  case ILCode.Call:  case ILCode.Callvirt:  case ILCode.CallGetter:  case ILCode.CallvirtGetter:  case ILCode.CallSetter:  case ILCode.CallvirtSetter: {  	MethodReference method = (MethodReference)expr.Operand;  	if (forceInferChildren) {  		for (int i = 0; i < expr.Arguments.Count; i++) {  			if (i == 0 && method.HasThis) {  				InferTypeForExpression (expr.Arguments [0]' MakeRefIfValueType (method.DeclaringType' expr.GetPrefix (ILCode.Constrained)));  			} else {  				InferTypeForExpression (expr.Arguments [i]' SubstituteTypeArgs (method.Parameters [method.HasThis ? i - 1 : i].ParameterType' method));  			}  		}  	}  	if (expr.Code == ILCode.CallSetter || expr.Code == ILCode.CallvirtSetter) {  		return SubstituteTypeArgs (method.Parameters.Last ().ParameterType' method);  	} else {  		return SubstituteTypeArgs (method.ReturnType' method);  	}  }  case ILCode.Newobj: {  	MethodReference ctor = (MethodReference)expr.Operand;  	if (forceInferChildren) {  		for (int i = 0; i < ctor.Parameters.Count; i++) {  			InferTypeForExpression (expr.Arguments [i]' SubstituteTypeArgs (ctor.Parameters [i].ParameterType' ctor));  		}  	}  	return ctor.DeclaringType;  }  case ILCode.InitObject:  case ILCode.InitCollection:  	return InferTypeForExpression (expr.Arguments [0]' expectedType);  case ILCode.InitializedObject:  	// expectedType should always be known due to the parent method call / property setter  	Debug.Assert (expectedType != null);  	return expectedType;  #endregion  #region Load/Store Fields  case ILCode.Ldfld:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' MakeRefIfValueType (((FieldReference)expr.Operand).DeclaringType' expr.GetPrefix (ILCode.Constrained)));  	}  	return GetFieldType ((FieldReference)expr.Operand);  case ILCode.Ldsfld:  	return GetFieldType ((FieldReference)expr.Operand);  case ILCode.Ldflda:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' MakeRefIfValueType (((FieldReference)expr.Operand).DeclaringType' expr.GetPrefix (ILCode.Constrained)));  	}  	return new ByReferenceType (GetFieldType ((FieldReference)expr.Operand));  case ILCode.Ldsflda:  	return new ByReferenceType (GetFieldType ((FieldReference)expr.Operand));  case ILCode.Stfld:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' MakeRefIfValueType (((FieldReference)expr.Operand).DeclaringType' expr.GetPrefix (ILCode.Constrained)));  		InferTypeForExpression (expr.Arguments [1]' GetFieldType ((FieldReference)expr.Operand));  	}  	return GetFieldType ((FieldReference)expr.Operand);  case ILCode.Stsfld:  	if (forceInferChildren)  		InferTypeForExpression (expr.Arguments [0]' GetFieldType ((FieldReference)expr.Operand));  	return GetFieldType ((FieldReference)expr.Operand);  #endregion  #region Reference/Pointer instructions  case ILCode.Ldind_Ref:  	return UnpackPointer (InferTypeForExpression (expr.Arguments [0]' null));  case ILCode.Stind_Ref:  	if (forceInferChildren) {  		TypeReference elementType = UnpackPointer (InferTypeForExpression (expr.Arguments [0]' null));  		InferTypeForExpression (expr.Arguments [1]' elementType);  	}  	return null;  case ILCode.Ldobj: {  	TypeReference type = (TypeReference)expr.Operand;  	var argType = InferTypeForExpression (expr.Arguments [0]' null);  	if (argType is PointerType || argType is ByReferenceType) {  		var elementType = ((TypeSpecification)argType).ElementType;  		int infoAmount = GetInformationAmount (elementType);  		if (infoAmount == 1 && GetInformationAmount (type) == 8) {  			// A bool can be loaded from both bytes and sbytes.  			type = elementType;  		}  		if (infoAmount >= 8 && infoAmount <= 64 && infoAmount == GetInformationAmount (type)) {  			// An integer can be loaded as another integer of the same size.  			// For integers smaller than 32 bit' the signs must match (as loading performs sign extension)  			bool? elementTypeIsSigned = IsSigned (elementType);  			bool? typeIsSigned = IsSigned (type);  			if (elementTypeIsSigned != null && typeIsSigned != null) {  				if (infoAmount >= 32 || elementTypeIsSigned == typeIsSigned)  					type = elementType;  			}  		}  	}  	if (argType is PointerType)  		InferTypeForExpression (expr.Arguments [0]' new PointerType (type));  	else  		InferTypeForExpression (expr.Arguments [0]' new ByReferenceType (type));  	return type;  }  case ILCode.Stobj: {  	TypeReference operandType = (TypeReference)expr.Operand;  	TypeReference pointerType = InferTypeForExpression (expr.Arguments [0]' new ByReferenceType (operandType));  	TypeReference elementType;  	if (pointerType is PointerType)  		elementType = ((PointerType)pointerType).ElementType;  	else if (pointerType is ByReferenceType)  		elementType = ((ByReferenceType)pointerType).ElementType;  	else  		elementType = null;  	if (elementType != null) {  		// An integer can be stored in any other integer of the same size.  		int infoAmount = GetInformationAmount (elementType);  		if (infoAmount == 1 && GetInformationAmount (operandType) == 8)  			operandType = elementType;  		else if (infoAmount == GetInformationAmount (operandType) && IsSigned (elementType) != null && IsSigned (operandType) != null)  			operandType = elementType;  	}  	if (forceInferChildren) {  		if (pointerType is PointerType)  			InferTypeForExpression (expr.Arguments [0]' new PointerType (operandType));  		else if (!IsSameType (operandType' expr.Operand as TypeReference))  			InferTypeForExpression (expr.Arguments [0]' new ByReferenceType (operandType));  		InferTypeForExpression (expr.Arguments [1]' operandType);  	}  	return operandType;  }  case ILCode.Initobj:  	return null;  case ILCode.DefaultValue:  	return (TypeReference)expr.Operand;  case ILCode.Localloc:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' typeSystem.Int32);  	}  	if (expectedType is PointerType)  		return expectedType;  	else  		return typeSystem.IntPtr;  case ILCode.Sizeof:  	return typeSystem.Int32;  case ILCode.PostIncrement:  case ILCode.PostIncrement_Ovf:  case ILCode.PostIncrement_Ovf_Un: {  	TypeReference elementType = UnpackPointer (InferTypeForExpression (expr.Arguments [0]' null));  	if (forceInferChildren && elementType != null) {  		// Assign expected type to the child expression  		InferTypeForExpression (expr.Arguments [0]' new ByReferenceType (elementType));  	}  	return elementType;  }  case ILCode.Mkrefany:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' (TypeReference)expr.Operand);  	}  	return typeSystem.TypedReference;  case ILCode.Refanytype:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' typeSystem.TypedReference);  	}  	return new TypeReference ("System"' "RuntimeTypeHandle"' module' module.TypeSystem.CoreLibrary' true);  case ILCode.Refanyval:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' typeSystem.TypedReference);  	}  	return new ByReferenceType ((TypeReference)expr.Operand);  case ILCode.AddressOf: {  	TypeReference t = InferTypeForExpression (expr.Arguments [0]' UnpackPointer (expectedType));  	return t != null ? new ByReferenceType (t) : null;  }  case ILCode.ValueOf:  	return GetNullableTypeArgument (InferTypeForExpression (expr.Arguments [0]' CreateNullableType (expectedType)));  case ILCode.NullableOf:  	return CreateNullableType (InferTypeForExpression (expr.Arguments [0]' GetNullableTypeArgument (expectedType)));  #endregion  #region Arithmetic instructions  case ILCode.Not:  // bitwise complement  case ILCode.Neg:  	return InferTypeForExpression (expr.Arguments.Single ()' expectedType);  case ILCode.Add:  	return InferArgumentsInAddition (expr' null' expectedType);  case ILCode.Sub:  	return InferArgumentsInSubtraction (expr' null' expectedType);  case ILCode.Mul:  case ILCode.Or:  case ILCode.And:  case ILCode.Xor:  	return InferArgumentsInBinaryOperator (expr' null' expectedType);  case ILCode.Add_Ovf:  	return InferArgumentsInAddition (expr' true' expectedType);  case ILCode.Sub_Ovf:  	return InferArgumentsInSubtraction (expr' true' expectedType);  case ILCode.Mul_Ovf:  case ILCode.Div:  case ILCode.Rem:  	return InferArgumentsInBinaryOperator (expr' true' expectedType);  case ILCode.Add_Ovf_Un:  	return InferArgumentsInAddition (expr' false' expectedType);  case ILCode.Sub_Ovf_Un:  	return InferArgumentsInSubtraction (expr' false' expectedType);  case ILCode.Mul_Ovf_Un:  case ILCode.Div_Un:  case ILCode.Rem_Un:  	return InferArgumentsInBinaryOperator (expr' false' expectedType);  case ILCode.Shl:  	if (forceInferChildren)  		InferTypeForExpression (expr.Arguments [1]' typeSystem.Int32);  	if (expectedType != null && (expectedType.MetadataType == MetadataType.Int32 || expectedType.MetadataType == MetadataType.UInt32 || expectedType.MetadataType == MetadataType.Int64 || expectedType.MetadataType == MetadataType.UInt64))  		return NumericPromotion (InferTypeForExpression (expr.Arguments [0]' expectedType));  	else  		return NumericPromotion (InferTypeForExpression (expr.Arguments [0]' null));  case ILCode.Shr:  case ILCode.Shr_Un: {  	if (forceInferChildren)  		InferTypeForExpression (expr.Arguments [1]' typeSystem.Int32);  	TypeReference type = NumericPromotion (InferTypeForExpression (expr.Arguments [0]' null));  	TypeReference expectedInputType = null;  	switch (type.MetadataType) {  	case MetadataType.Int32:  		if (expr.Code == ILCode.Shr_Un)  			expectedInputType = typeSystem.UInt32;  		break;  	case MetadataType.UInt32:  		if (expr.Code == ILCode.Shr)  			expectedInputType = typeSystem.Int32;  		break;  	case MetadataType.Int64:  		if (expr.Code == ILCode.Shr_Un)  			expectedInputType = typeSystem.UInt64;  		break;  	case MetadataType.UInt64:  		if (expr.Code == ILCode.Shr)  			expectedInputType = typeSystem.UInt64;  		break;  	}  	if (expectedInputType != null) {  		InferTypeForExpression (expr.Arguments [0]' expectedInputType);  		return expectedInputType;  	} else {  		return type;  	}  }  case ILCode.CompoundAssignment: {  	var op = expr.Arguments [0];  	if (op.Code == ILCode.NullableOf)  		op = op.Arguments [0].Arguments [0];  	var varType = InferTypeForExpression (op.Arguments [0]' null);  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' varType);  	}  	return varType;  }  #endregion  #region Constant loading instructions  case ILCode.Ldnull:  	return typeSystem.Object;  case ILCode.Ldstr:  	return typeSystem.String;  case ILCode.Ldftn:  case ILCode.Ldvirtftn:  	return typeSystem.IntPtr;  case ILCode.Ldc_I4:  	if (IsBoolean (expectedType) && ((int)expr.Operand == 0 || (int)expr.Operand == 1))  		return typeSystem.Boolean;  	if (expectedType is PointerType && (int)expr.Operand == 0)  		return expectedType;  	if (IsIntegerOrEnum (expectedType) && OperandFitsInType (expectedType' (int)expr.Operand))  		return expectedType;  	else  		return typeSystem.Int32;  case ILCode.Ldc_I8:  	if (expectedType is PointerType && (long)expr.Operand == 0)  		return expectedType;  	if (IsIntegerOrEnum (expectedType) && GetInformationAmount (expectedType) >= NativeInt)  		return expectedType;  	else  		return typeSystem.Int64;  case ILCode.Ldc_R4:  	return typeSystem.Single;  case ILCode.Ldc_R8:  	return typeSystem.Double;  case ILCode.Ldc_Decimal:  	return new TypeReference ("System"' "Decimal"' module' module.TypeSystem.CoreLibrary' true);  case ILCode.Ldtoken:  	if (expr.Operand is TypeReference)  		return new TypeReference ("System"' "RuntimeTypeHandle"' module' module.TypeSystem.CoreLibrary' true);  	else if (expr.Operand is FieldReference)  		return new TypeReference ("System"' "RuntimeFieldHandle"' module' module.TypeSystem.CoreLibrary' true);  	else  		return new TypeReference ("System"' "RuntimeMethodHandle"' module' module.TypeSystem.CoreLibrary' true);  case ILCode.Arglist:  	return new TypeReference ("System"' "RuntimeArgumentHandle"' module' module.TypeSystem.CoreLibrary' true);  #endregion  #region Array instructions  case ILCode.Newarr:  	if (forceInferChildren) {  		var lengthType = InferTypeForExpression (expr.Arguments.Single ()' null);  		if (lengthType == typeSystem.IntPtr) {  			lengthType = typeSystem.Int64;  		} else if (lengthType == typeSystem.UIntPtr) {  			lengthType = typeSystem.UInt64;  		} else if (lengthType != typeSystem.UInt32 && lengthType != typeSystem.Int64 && lengthType != typeSystem.UInt64) {  			lengthType = typeSystem.Int32;  		}  		if (forceInferChildren) {  			InferTypeForExpression (expr.Arguments.Single ()' lengthType);  		}  	}  	return new ArrayType ((TypeReference)expr.Operand);  case ILCode.InitArray:  	var operandAsArrayType = (ArrayType)expr.Operand;  	if (forceInferChildren) {  		foreach (ILExpression arg in expr.Arguments)  			InferTypeForExpression (arg' operandAsArrayType.ElementType);  	}  	return operandAsArrayType;  case ILCode.Ldlen:  	return typeSystem.Int32;  case ILCode.Ldelem_U1:  case ILCode.Ldelem_U2:  case ILCode.Ldelem_U4:  case ILCode.Ldelem_I1:  case ILCode.Ldelem_I2:  case ILCode.Ldelem_I4:  case ILCode.Ldelem_I8:  case ILCode.Ldelem_R4:  case ILCode.Ldelem_R8:  case ILCode.Ldelem_I:  case ILCode.Ldelem_Ref: {  	ArrayType arrayType = InferTypeForExpression (expr.Arguments [0]' null) as ArrayType;  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [1]' typeSystem.Int32);  	}  	return arrayType != null ? arrayType.ElementType : null;  }  case ILCode.Ldelem_Any:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [1]' typeSystem.Int32);  	}  	return (TypeReference)expr.Operand;  case ILCode.Ldelema: {  	ArrayType arrayType = InferTypeForExpression (expr.Arguments [0]' null) as ArrayType;  	if (forceInferChildren)  		InferTypeForExpression (expr.Arguments [1]' typeSystem.Int32);  	return arrayType != null ? new ByReferenceType (arrayType.ElementType) : null;  }  case ILCode.Stelem_I:  case ILCode.Stelem_I1:  case ILCode.Stelem_I2:  case ILCode.Stelem_I4:  case ILCode.Stelem_I8:  case ILCode.Stelem_R4:  case ILCode.Stelem_R8:  case ILCode.Stelem_Ref:  case ILCode.Stelem_Any: {  	ArrayType arrayType = InferTypeForExpression (expr.Arguments [0]' null) as ArrayType;  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [1]' typeSystem.Int32);  		if (arrayType != null) {  			InferTypeForExpression (expr.Arguments [2]' arrayType.ElementType);  		}  	}  	return arrayType != null ? arrayType.ElementType : null;  }  #endregion  #region Conversion instructions  case ILCode.Conv_I1:  case ILCode.Conv_Ovf_I1:  case ILCode.Conv_Ovf_I1_Un:  	return HandleConversion (8' true' expr.Arguments [0]' expectedType' typeSystem.SByte);  case ILCode.Conv_I2:  case ILCode.Conv_Ovf_I2:  case ILCode.Conv_Ovf_I2_Un:  	return HandleConversion (16' true' expr.Arguments [0]' expectedType' typeSystem.Int16);  case ILCode.Conv_I4:  case ILCode.Conv_Ovf_I4:  case ILCode.Conv_Ovf_I4_Un:  	return HandleConversion (32' true' expr.Arguments [0]' expectedType' typeSystem.Int32);  case ILCode.Conv_I8:  case ILCode.Conv_Ovf_I8:  case ILCode.Conv_Ovf_I8_Un:  	return HandleConversion (64' true' expr.Arguments [0]' expectedType' typeSystem.Int64);  case ILCode.Conv_U1:  case ILCode.Conv_Ovf_U1:  case ILCode.Conv_Ovf_U1_Un:  	return HandleConversion (8' false' expr.Arguments [0]' expectedType' typeSystem.Byte);  case ILCode.Conv_U2:  case ILCode.Conv_Ovf_U2:  case ILCode.Conv_Ovf_U2_Un:  	return HandleConversion (16' false' expr.Arguments [0]' expectedType' typeSystem.UInt16);  case ILCode.Conv_U4:  case ILCode.Conv_Ovf_U4:  case ILCode.Conv_Ovf_U4_Un:  	return HandleConversion (32' false' expr.Arguments [0]' expectedType' typeSystem.UInt32);  case ILCode.Conv_U8:  case ILCode.Conv_Ovf_U8:  case ILCode.Conv_Ovf_U8_Un:  	return HandleConversion (64' false' expr.Arguments [0]' expectedType' typeSystem.UInt64);  case ILCode.Conv_I:  case ILCode.Conv_Ovf_I:  case ILCode.Conv_Ovf_I_Un:  	return HandleConversion (NativeInt' true' expr.Arguments [0]' expectedType' typeSystem.IntPtr);  case ILCode.Conv_U:  case ILCode.Conv_Ovf_U:  case ILCode.Conv_Ovf_U_Un:  	return HandleConversion (NativeInt' false' expr.Arguments [0]' expectedType' typeSystem.UIntPtr);  case ILCode.Conv_R4:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' typeSystem.Single);  	}  	return typeSystem.Single;  case ILCode.Conv_R8:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' typeSystem.Double);  	}  	return typeSystem.Double;  case ILCode.Conv_R_Un:  	return (expectedType != null && expectedType.MetadataType == MetadataType.Single) ? typeSystem.Single : typeSystem.Double;  case ILCode.Castclass:  case ILCode.Unbox_Any:  	return (TypeReference)expr.Operand;  case ILCode.Unbox:  	return new ByReferenceType ((TypeReference)expr.Operand);  case ILCode.Isinst: {  	// isinst performs the equivalent of a cast only for reference types;  	// value types still need to be unboxed after an isinst instruction  	TypeReference tr = (TypeReference)expr.Operand;  	return tr.IsValueType ? typeSystem.Object : tr;  }  case ILCode.Box: {  	var tr = (TypeReference)expr.Operand;  	if (forceInferChildren)  		InferTypeForExpression (expr.Arguments.Single ()' tr);  	return tr.IsValueType ? typeSystem.Object : tr;  }  #endregion  #region Comparison instructions  case ILCode.Ceq:  case ILCode.Cne:  	if (forceInferChildren)  		InferArgumentsInBinaryOperator (expr' null' null);  	return typeSystem.Boolean;  case ILCode.Clt:  case ILCode.Cgt:  case ILCode.Cle:  case ILCode.Cge:  	if (forceInferChildren)  		InferArgumentsInBinaryOperator (expr' true' null);  	return typeSystem.Boolean;  case ILCode.Clt_Un:  case ILCode.Cgt_Un:  case ILCode.Cle_Un:  case ILCode.Cge_Un:  	if (forceInferChildren)  		InferArgumentsInBinaryOperator (expr' false' null);  	return typeSystem.Boolean;  #endregion  #region Branch instructions  case ILCode.Brtrue:  	if (forceInferChildren)  		InferTypeForExpression (expr.Arguments.Single ()' typeSystem.Boolean);  	return null;  case ILCode.Br:  case ILCode.Leave:  case ILCode.Endfinally:  case ILCode.Switch:  case ILCode.Throw:  case ILCode.Rethrow:  case ILCode.LoopOrSwitchBreak:  case ILCode.LoopContinue:  case ILCode.YieldBreak:  	return null;  case ILCode.Ret:  	if (forceInferChildren && expr.Arguments.Count == 1) {  		TypeReference returnType = context.CurrentMethod.ReturnType;  		if (context.CurrentMethodIsAsync && returnType != null && returnType.Namespace == "System.Threading.Tasks") {  			if (returnType.Name == "Task") {  				returnType = typeSystem.Void;  			} else if (returnType.Name == "Task`1" && returnType.IsGenericInstance) {  				returnType = ((GenericInstanceType)returnType).GenericArguments [0];  			}  		}  		InferTypeForExpression (expr.Arguments [0]' returnType);  	}  	return null;  case ILCode.YieldReturn:  	if (forceInferChildren) {  		GenericInstanceType genericType = context.CurrentMethod.ReturnType as GenericInstanceType;  		if (genericType != null) {  			// IEnumerable<T> or IEnumerator<T>  			InferTypeForExpression (expr.Arguments [0]' genericType.GenericArguments [0]);  		} else {  			// non-generic IEnumerable or IEnumerator  			InferTypeForExpression (expr.Arguments [0]' typeSystem.Object);  		}  	}  	return null;  case ILCode.Await: {  	TypeReference taskType = InferTypeForExpression (expr.Arguments [0]' null);  	if (taskType.Name == "Task`1" && taskType.IsGenericInstance && taskType.Namespace == "System.Threading.Tasks") {  		return ((GenericInstanceType)taskType).GenericArguments [0];  	}  	return null;  }  #endregion  case ILCode.Pop:  	return null;  case ILCode.Wrap:  case ILCode.Dup: {  	var arg = expr.Arguments.Single ();  	return arg.ExpectedType = InferTypeForExpression (arg' expectedType);  }  default:  	Debug.WriteLine ("Type Inference: Can't handle " + expr.Code.GetName ());  	return null;  }  
Magic Number,Custom.Decompiler.ILAst,TypeAnalysis,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\TypeAnalysis.cs,DoInferTypeForExpression,The following statement contains a magic number: switch (expr.Code) {  #region Logical operators  case ILCode.LogicNot:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments.Single ()' typeSystem.Boolean);  	}  	return typeSystem.Boolean;  case ILCode.LogicAnd:  case ILCode.LogicOr:  	// if Operand is set the logic and/or expression is a custom operator  	// we can deal with it the same as a normal invocation.  	if (expr.Operand != null)  		goto case ILCode.Call;  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' typeSystem.Boolean);  		InferTypeForExpression (expr.Arguments [1]' typeSystem.Boolean);  	}  	return typeSystem.Boolean;  case ILCode.TernaryOp:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' typeSystem.Boolean);  	}  	return InferBinaryArguments (expr.Arguments [1]' expr.Arguments [2]' expectedType' forceInferChildren);  case ILCode.NullCoalescing:  	return InferBinaryArguments (expr.Arguments [0]' expr.Arguments [1]' expectedType' forceInferChildren);  #endregion  #region Variable load/store  case ILCode.Stloc: {  	ILVariable v = (ILVariable)expr.Operand;  	if (forceInferChildren) {  		// do not use 'expectedType' in here!  		InferTypeForExpression (expr.Arguments.Single ()' v.Type);  	}  	return v.Type;  }  case ILCode.Ldloc: {  	ILVariable v = (ILVariable)expr.Operand;  	if (v.Type == null && singleLoadVariables.Contains (v)) {  		v.Type = expectedType;  	}  	return v.Type;  }  case ILCode.Ldloca: {  	ILVariable v = (ILVariable)expr.Operand;  	if (v.Type != null)  		return new ByReferenceType (v.Type);  	else  		return null;  }  #endregion  #region Call / NewObj  case ILCode.Call:  case ILCode.Callvirt:  case ILCode.CallGetter:  case ILCode.CallvirtGetter:  case ILCode.CallSetter:  case ILCode.CallvirtSetter: {  	MethodReference method = (MethodReference)expr.Operand;  	if (forceInferChildren) {  		for (int i = 0; i < expr.Arguments.Count; i++) {  			if (i == 0 && method.HasThis) {  				InferTypeForExpression (expr.Arguments [0]' MakeRefIfValueType (method.DeclaringType' expr.GetPrefix (ILCode.Constrained)));  			} else {  				InferTypeForExpression (expr.Arguments [i]' SubstituteTypeArgs (method.Parameters [method.HasThis ? i - 1 : i].ParameterType' method));  			}  		}  	}  	if (expr.Code == ILCode.CallSetter || expr.Code == ILCode.CallvirtSetter) {  		return SubstituteTypeArgs (method.Parameters.Last ().ParameterType' method);  	} else {  		return SubstituteTypeArgs (method.ReturnType' method);  	}  }  case ILCode.Newobj: {  	MethodReference ctor = (MethodReference)expr.Operand;  	if (forceInferChildren) {  		for (int i = 0; i < ctor.Parameters.Count; i++) {  			InferTypeForExpression (expr.Arguments [i]' SubstituteTypeArgs (ctor.Parameters [i].ParameterType' ctor));  		}  	}  	return ctor.DeclaringType;  }  case ILCode.InitObject:  case ILCode.InitCollection:  	return InferTypeForExpression (expr.Arguments [0]' expectedType);  case ILCode.InitializedObject:  	// expectedType should always be known due to the parent method call / property setter  	Debug.Assert (expectedType != null);  	return expectedType;  #endregion  #region Load/Store Fields  case ILCode.Ldfld:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' MakeRefIfValueType (((FieldReference)expr.Operand).DeclaringType' expr.GetPrefix (ILCode.Constrained)));  	}  	return GetFieldType ((FieldReference)expr.Operand);  case ILCode.Ldsfld:  	return GetFieldType ((FieldReference)expr.Operand);  case ILCode.Ldflda:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' MakeRefIfValueType (((FieldReference)expr.Operand).DeclaringType' expr.GetPrefix (ILCode.Constrained)));  	}  	return new ByReferenceType (GetFieldType ((FieldReference)expr.Operand));  case ILCode.Ldsflda:  	return new ByReferenceType (GetFieldType ((FieldReference)expr.Operand));  case ILCode.Stfld:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' MakeRefIfValueType (((FieldReference)expr.Operand).DeclaringType' expr.GetPrefix (ILCode.Constrained)));  		InferTypeForExpression (expr.Arguments [1]' GetFieldType ((FieldReference)expr.Operand));  	}  	return GetFieldType ((FieldReference)expr.Operand);  case ILCode.Stsfld:  	if (forceInferChildren)  		InferTypeForExpression (expr.Arguments [0]' GetFieldType ((FieldReference)expr.Operand));  	return GetFieldType ((FieldReference)expr.Operand);  #endregion  #region Reference/Pointer instructions  case ILCode.Ldind_Ref:  	return UnpackPointer (InferTypeForExpression (expr.Arguments [0]' null));  case ILCode.Stind_Ref:  	if (forceInferChildren) {  		TypeReference elementType = UnpackPointer (InferTypeForExpression (expr.Arguments [0]' null));  		InferTypeForExpression (expr.Arguments [1]' elementType);  	}  	return null;  case ILCode.Ldobj: {  	TypeReference type = (TypeReference)expr.Operand;  	var argType = InferTypeForExpression (expr.Arguments [0]' null);  	if (argType is PointerType || argType is ByReferenceType) {  		var elementType = ((TypeSpecification)argType).ElementType;  		int infoAmount = GetInformationAmount (elementType);  		if (infoAmount == 1 && GetInformationAmount (type) == 8) {  			// A bool can be loaded from both bytes and sbytes.  			type = elementType;  		}  		if (infoAmount >= 8 && infoAmount <= 64 && infoAmount == GetInformationAmount (type)) {  			// An integer can be loaded as another integer of the same size.  			// For integers smaller than 32 bit' the signs must match (as loading performs sign extension)  			bool? elementTypeIsSigned = IsSigned (elementType);  			bool? typeIsSigned = IsSigned (type);  			if (elementTypeIsSigned != null && typeIsSigned != null) {  				if (infoAmount >= 32 || elementTypeIsSigned == typeIsSigned)  					type = elementType;  			}  		}  	}  	if (argType is PointerType)  		InferTypeForExpression (expr.Arguments [0]' new PointerType (type));  	else  		InferTypeForExpression (expr.Arguments [0]' new ByReferenceType (type));  	return type;  }  case ILCode.Stobj: {  	TypeReference operandType = (TypeReference)expr.Operand;  	TypeReference pointerType = InferTypeForExpression (expr.Arguments [0]' new ByReferenceType (operandType));  	TypeReference elementType;  	if (pointerType is PointerType)  		elementType = ((PointerType)pointerType).ElementType;  	else if (pointerType is ByReferenceType)  		elementType = ((ByReferenceType)pointerType).ElementType;  	else  		elementType = null;  	if (elementType != null) {  		// An integer can be stored in any other integer of the same size.  		int infoAmount = GetInformationAmount (elementType);  		if (infoAmount == 1 && GetInformationAmount (operandType) == 8)  			operandType = elementType;  		else if (infoAmount == GetInformationAmount (operandType) && IsSigned (elementType) != null && IsSigned (operandType) != null)  			operandType = elementType;  	}  	if (forceInferChildren) {  		if (pointerType is PointerType)  			InferTypeForExpression (expr.Arguments [0]' new PointerType (operandType));  		else if (!IsSameType (operandType' expr.Operand as TypeReference))  			InferTypeForExpression (expr.Arguments [0]' new ByReferenceType (operandType));  		InferTypeForExpression (expr.Arguments [1]' operandType);  	}  	return operandType;  }  case ILCode.Initobj:  	return null;  case ILCode.DefaultValue:  	return (TypeReference)expr.Operand;  case ILCode.Localloc:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' typeSystem.Int32);  	}  	if (expectedType is PointerType)  		return expectedType;  	else  		return typeSystem.IntPtr;  case ILCode.Sizeof:  	return typeSystem.Int32;  case ILCode.PostIncrement:  case ILCode.PostIncrement_Ovf:  case ILCode.PostIncrement_Ovf_Un: {  	TypeReference elementType = UnpackPointer (InferTypeForExpression (expr.Arguments [0]' null));  	if (forceInferChildren && elementType != null) {  		// Assign expected type to the child expression  		InferTypeForExpression (expr.Arguments [0]' new ByReferenceType (elementType));  	}  	return elementType;  }  case ILCode.Mkrefany:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' (TypeReference)expr.Operand);  	}  	return typeSystem.TypedReference;  case ILCode.Refanytype:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' typeSystem.TypedReference);  	}  	return new TypeReference ("System"' "RuntimeTypeHandle"' module' module.TypeSystem.CoreLibrary' true);  case ILCode.Refanyval:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' typeSystem.TypedReference);  	}  	return new ByReferenceType ((TypeReference)expr.Operand);  case ILCode.AddressOf: {  	TypeReference t = InferTypeForExpression (expr.Arguments [0]' UnpackPointer (expectedType));  	return t != null ? new ByReferenceType (t) : null;  }  case ILCode.ValueOf:  	return GetNullableTypeArgument (InferTypeForExpression (expr.Arguments [0]' CreateNullableType (expectedType)));  case ILCode.NullableOf:  	return CreateNullableType (InferTypeForExpression (expr.Arguments [0]' GetNullableTypeArgument (expectedType)));  #endregion  #region Arithmetic instructions  case ILCode.Not:  // bitwise complement  case ILCode.Neg:  	return InferTypeForExpression (expr.Arguments.Single ()' expectedType);  case ILCode.Add:  	return InferArgumentsInAddition (expr' null' expectedType);  case ILCode.Sub:  	return InferArgumentsInSubtraction (expr' null' expectedType);  case ILCode.Mul:  case ILCode.Or:  case ILCode.And:  case ILCode.Xor:  	return InferArgumentsInBinaryOperator (expr' null' expectedType);  case ILCode.Add_Ovf:  	return InferArgumentsInAddition (expr' true' expectedType);  case ILCode.Sub_Ovf:  	return InferArgumentsInSubtraction (expr' true' expectedType);  case ILCode.Mul_Ovf:  case ILCode.Div:  case ILCode.Rem:  	return InferArgumentsInBinaryOperator (expr' true' expectedType);  case ILCode.Add_Ovf_Un:  	return InferArgumentsInAddition (expr' false' expectedType);  case ILCode.Sub_Ovf_Un:  	return InferArgumentsInSubtraction (expr' false' expectedType);  case ILCode.Mul_Ovf_Un:  case ILCode.Div_Un:  case ILCode.Rem_Un:  	return InferArgumentsInBinaryOperator (expr' false' expectedType);  case ILCode.Shl:  	if (forceInferChildren)  		InferTypeForExpression (expr.Arguments [1]' typeSystem.Int32);  	if (expectedType != null && (expectedType.MetadataType == MetadataType.Int32 || expectedType.MetadataType == MetadataType.UInt32 || expectedType.MetadataType == MetadataType.Int64 || expectedType.MetadataType == MetadataType.UInt64))  		return NumericPromotion (InferTypeForExpression (expr.Arguments [0]' expectedType));  	else  		return NumericPromotion (InferTypeForExpression (expr.Arguments [0]' null));  case ILCode.Shr:  case ILCode.Shr_Un: {  	if (forceInferChildren)  		InferTypeForExpression (expr.Arguments [1]' typeSystem.Int32);  	TypeReference type = NumericPromotion (InferTypeForExpression (expr.Arguments [0]' null));  	TypeReference expectedInputType = null;  	switch (type.MetadataType) {  	case MetadataType.Int32:  		if (expr.Code == ILCode.Shr_Un)  			expectedInputType = typeSystem.UInt32;  		break;  	case MetadataType.UInt32:  		if (expr.Code == ILCode.Shr)  			expectedInputType = typeSystem.Int32;  		break;  	case MetadataType.Int64:  		if (expr.Code == ILCode.Shr_Un)  			expectedInputType = typeSystem.UInt64;  		break;  	case MetadataType.UInt64:  		if (expr.Code == ILCode.Shr)  			expectedInputType = typeSystem.UInt64;  		break;  	}  	if (expectedInputType != null) {  		InferTypeForExpression (expr.Arguments [0]' expectedInputType);  		return expectedInputType;  	} else {  		return type;  	}  }  case ILCode.CompoundAssignment: {  	var op = expr.Arguments [0];  	if (op.Code == ILCode.NullableOf)  		op = op.Arguments [0].Arguments [0];  	var varType = InferTypeForExpression (op.Arguments [0]' null);  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' varType);  	}  	return varType;  }  #endregion  #region Constant loading instructions  case ILCode.Ldnull:  	return typeSystem.Object;  case ILCode.Ldstr:  	return typeSystem.String;  case ILCode.Ldftn:  case ILCode.Ldvirtftn:  	return typeSystem.IntPtr;  case ILCode.Ldc_I4:  	if (IsBoolean (expectedType) && ((int)expr.Operand == 0 || (int)expr.Operand == 1))  		return typeSystem.Boolean;  	if (expectedType is PointerType && (int)expr.Operand == 0)  		return expectedType;  	if (IsIntegerOrEnum (expectedType) && OperandFitsInType (expectedType' (int)expr.Operand))  		return expectedType;  	else  		return typeSystem.Int32;  case ILCode.Ldc_I8:  	if (expectedType is PointerType && (long)expr.Operand == 0)  		return expectedType;  	if (IsIntegerOrEnum (expectedType) && GetInformationAmount (expectedType) >= NativeInt)  		return expectedType;  	else  		return typeSystem.Int64;  case ILCode.Ldc_R4:  	return typeSystem.Single;  case ILCode.Ldc_R8:  	return typeSystem.Double;  case ILCode.Ldc_Decimal:  	return new TypeReference ("System"' "Decimal"' module' module.TypeSystem.CoreLibrary' true);  case ILCode.Ldtoken:  	if (expr.Operand is TypeReference)  		return new TypeReference ("System"' "RuntimeTypeHandle"' module' module.TypeSystem.CoreLibrary' true);  	else if (expr.Operand is FieldReference)  		return new TypeReference ("System"' "RuntimeFieldHandle"' module' module.TypeSystem.CoreLibrary' true);  	else  		return new TypeReference ("System"' "RuntimeMethodHandle"' module' module.TypeSystem.CoreLibrary' true);  case ILCode.Arglist:  	return new TypeReference ("System"' "RuntimeArgumentHandle"' module' module.TypeSystem.CoreLibrary' true);  #endregion  #region Array instructions  case ILCode.Newarr:  	if (forceInferChildren) {  		var lengthType = InferTypeForExpression (expr.Arguments.Single ()' null);  		if (lengthType == typeSystem.IntPtr) {  			lengthType = typeSystem.Int64;  		} else if (lengthType == typeSystem.UIntPtr) {  			lengthType = typeSystem.UInt64;  		} else if (lengthType != typeSystem.UInt32 && lengthType != typeSystem.Int64 && lengthType != typeSystem.UInt64) {  			lengthType = typeSystem.Int32;  		}  		if (forceInferChildren) {  			InferTypeForExpression (expr.Arguments.Single ()' lengthType);  		}  	}  	return new ArrayType ((TypeReference)expr.Operand);  case ILCode.InitArray:  	var operandAsArrayType = (ArrayType)expr.Operand;  	if (forceInferChildren) {  		foreach (ILExpression arg in expr.Arguments)  			InferTypeForExpression (arg' operandAsArrayType.ElementType);  	}  	return operandAsArrayType;  case ILCode.Ldlen:  	return typeSystem.Int32;  case ILCode.Ldelem_U1:  case ILCode.Ldelem_U2:  case ILCode.Ldelem_U4:  case ILCode.Ldelem_I1:  case ILCode.Ldelem_I2:  case ILCode.Ldelem_I4:  case ILCode.Ldelem_I8:  case ILCode.Ldelem_R4:  case ILCode.Ldelem_R8:  case ILCode.Ldelem_I:  case ILCode.Ldelem_Ref: {  	ArrayType arrayType = InferTypeForExpression (expr.Arguments [0]' null) as ArrayType;  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [1]' typeSystem.Int32);  	}  	return arrayType != null ? arrayType.ElementType : null;  }  case ILCode.Ldelem_Any:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [1]' typeSystem.Int32);  	}  	return (TypeReference)expr.Operand;  case ILCode.Ldelema: {  	ArrayType arrayType = InferTypeForExpression (expr.Arguments [0]' null) as ArrayType;  	if (forceInferChildren)  		InferTypeForExpression (expr.Arguments [1]' typeSystem.Int32);  	return arrayType != null ? new ByReferenceType (arrayType.ElementType) : null;  }  case ILCode.Stelem_I:  case ILCode.Stelem_I1:  case ILCode.Stelem_I2:  case ILCode.Stelem_I4:  case ILCode.Stelem_I8:  case ILCode.Stelem_R4:  case ILCode.Stelem_R8:  case ILCode.Stelem_Ref:  case ILCode.Stelem_Any: {  	ArrayType arrayType = InferTypeForExpression (expr.Arguments [0]' null) as ArrayType;  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [1]' typeSystem.Int32);  		if (arrayType != null) {  			InferTypeForExpression (expr.Arguments [2]' arrayType.ElementType);  		}  	}  	return arrayType != null ? arrayType.ElementType : null;  }  #endregion  #region Conversion instructions  case ILCode.Conv_I1:  case ILCode.Conv_Ovf_I1:  case ILCode.Conv_Ovf_I1_Un:  	return HandleConversion (8' true' expr.Arguments [0]' expectedType' typeSystem.SByte);  case ILCode.Conv_I2:  case ILCode.Conv_Ovf_I2:  case ILCode.Conv_Ovf_I2_Un:  	return HandleConversion (16' true' expr.Arguments [0]' expectedType' typeSystem.Int16);  case ILCode.Conv_I4:  case ILCode.Conv_Ovf_I4:  case ILCode.Conv_Ovf_I4_Un:  	return HandleConversion (32' true' expr.Arguments [0]' expectedType' typeSystem.Int32);  case ILCode.Conv_I8:  case ILCode.Conv_Ovf_I8:  case ILCode.Conv_Ovf_I8_Un:  	return HandleConversion (64' true' expr.Arguments [0]' expectedType' typeSystem.Int64);  case ILCode.Conv_U1:  case ILCode.Conv_Ovf_U1:  case ILCode.Conv_Ovf_U1_Un:  	return HandleConversion (8' false' expr.Arguments [0]' expectedType' typeSystem.Byte);  case ILCode.Conv_U2:  case ILCode.Conv_Ovf_U2:  case ILCode.Conv_Ovf_U2_Un:  	return HandleConversion (16' false' expr.Arguments [0]' expectedType' typeSystem.UInt16);  case ILCode.Conv_U4:  case ILCode.Conv_Ovf_U4:  case ILCode.Conv_Ovf_U4_Un:  	return HandleConversion (32' false' expr.Arguments [0]' expectedType' typeSystem.UInt32);  case ILCode.Conv_U8:  case ILCode.Conv_Ovf_U8:  case ILCode.Conv_Ovf_U8_Un:  	return HandleConversion (64' false' expr.Arguments [0]' expectedType' typeSystem.UInt64);  case ILCode.Conv_I:  case ILCode.Conv_Ovf_I:  case ILCode.Conv_Ovf_I_Un:  	return HandleConversion (NativeInt' true' expr.Arguments [0]' expectedType' typeSystem.IntPtr);  case ILCode.Conv_U:  case ILCode.Conv_Ovf_U:  case ILCode.Conv_Ovf_U_Un:  	return HandleConversion (NativeInt' false' expr.Arguments [0]' expectedType' typeSystem.UIntPtr);  case ILCode.Conv_R4:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' typeSystem.Single);  	}  	return typeSystem.Single;  case ILCode.Conv_R8:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' typeSystem.Double);  	}  	return typeSystem.Double;  case ILCode.Conv_R_Un:  	return (expectedType != null && expectedType.MetadataType == MetadataType.Single) ? typeSystem.Single : typeSystem.Double;  case ILCode.Castclass:  case ILCode.Unbox_Any:  	return (TypeReference)expr.Operand;  case ILCode.Unbox:  	return new ByReferenceType ((TypeReference)expr.Operand);  case ILCode.Isinst: {  	// isinst performs the equivalent of a cast only for reference types;  	// value types still need to be unboxed after an isinst instruction  	TypeReference tr = (TypeReference)expr.Operand;  	return tr.IsValueType ? typeSystem.Object : tr;  }  case ILCode.Box: {  	var tr = (TypeReference)expr.Operand;  	if (forceInferChildren)  		InferTypeForExpression (expr.Arguments.Single ()' tr);  	return tr.IsValueType ? typeSystem.Object : tr;  }  #endregion  #region Comparison instructions  case ILCode.Ceq:  case ILCode.Cne:  	if (forceInferChildren)  		InferArgumentsInBinaryOperator (expr' null' null);  	return typeSystem.Boolean;  case ILCode.Clt:  case ILCode.Cgt:  case ILCode.Cle:  case ILCode.Cge:  	if (forceInferChildren)  		InferArgumentsInBinaryOperator (expr' true' null);  	return typeSystem.Boolean;  case ILCode.Clt_Un:  case ILCode.Cgt_Un:  case ILCode.Cle_Un:  case ILCode.Cge_Un:  	if (forceInferChildren)  		InferArgumentsInBinaryOperator (expr' false' null);  	return typeSystem.Boolean;  #endregion  #region Branch instructions  case ILCode.Brtrue:  	if (forceInferChildren)  		InferTypeForExpression (expr.Arguments.Single ()' typeSystem.Boolean);  	return null;  case ILCode.Br:  case ILCode.Leave:  case ILCode.Endfinally:  case ILCode.Switch:  case ILCode.Throw:  case ILCode.Rethrow:  case ILCode.LoopOrSwitchBreak:  case ILCode.LoopContinue:  case ILCode.YieldBreak:  	return null;  case ILCode.Ret:  	if (forceInferChildren && expr.Arguments.Count == 1) {  		TypeReference returnType = context.CurrentMethod.ReturnType;  		if (context.CurrentMethodIsAsync && returnType != null && returnType.Namespace == "System.Threading.Tasks") {  			if (returnType.Name == "Task") {  				returnType = typeSystem.Void;  			} else if (returnType.Name == "Task`1" && returnType.IsGenericInstance) {  				returnType = ((GenericInstanceType)returnType).GenericArguments [0];  			}  		}  		InferTypeForExpression (expr.Arguments [0]' returnType);  	}  	return null;  case ILCode.YieldReturn:  	if (forceInferChildren) {  		GenericInstanceType genericType = context.CurrentMethod.ReturnType as GenericInstanceType;  		if (genericType != null) {  			// IEnumerable<T> or IEnumerator<T>  			InferTypeForExpression (expr.Arguments [0]' genericType.GenericArguments [0]);  		} else {  			// non-generic IEnumerable or IEnumerator  			InferTypeForExpression (expr.Arguments [0]' typeSystem.Object);  		}  	}  	return null;  case ILCode.Await: {  	TypeReference taskType = InferTypeForExpression (expr.Arguments [0]' null);  	if (taskType.Name == "Task`1" && taskType.IsGenericInstance && taskType.Namespace == "System.Threading.Tasks") {  		return ((GenericInstanceType)taskType).GenericArguments [0];  	}  	return null;  }  #endregion  case ILCode.Pop:  	return null;  case ILCode.Wrap:  case ILCode.Dup: {  	var arg = expr.Arguments.Single ();  	return arg.ExpectedType = InferTypeForExpression (arg' expectedType);  }  default:  	Debug.WriteLine ("Type Inference: Can't handle " + expr.Code.GetName ());  	return null;  }  
Magic Number,Custom.Decompiler.ILAst,TypeAnalysis,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\TypeAnalysis.cs,DoInferTypeForExpression,The following statement contains a magic number: switch (expr.Code) {  #region Logical operators  case ILCode.LogicNot:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments.Single ()' typeSystem.Boolean);  	}  	return typeSystem.Boolean;  case ILCode.LogicAnd:  case ILCode.LogicOr:  	// if Operand is set the logic and/or expression is a custom operator  	// we can deal with it the same as a normal invocation.  	if (expr.Operand != null)  		goto case ILCode.Call;  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' typeSystem.Boolean);  		InferTypeForExpression (expr.Arguments [1]' typeSystem.Boolean);  	}  	return typeSystem.Boolean;  case ILCode.TernaryOp:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' typeSystem.Boolean);  	}  	return InferBinaryArguments (expr.Arguments [1]' expr.Arguments [2]' expectedType' forceInferChildren);  case ILCode.NullCoalescing:  	return InferBinaryArguments (expr.Arguments [0]' expr.Arguments [1]' expectedType' forceInferChildren);  #endregion  #region Variable load/store  case ILCode.Stloc: {  	ILVariable v = (ILVariable)expr.Operand;  	if (forceInferChildren) {  		// do not use 'expectedType' in here!  		InferTypeForExpression (expr.Arguments.Single ()' v.Type);  	}  	return v.Type;  }  case ILCode.Ldloc: {  	ILVariable v = (ILVariable)expr.Operand;  	if (v.Type == null && singleLoadVariables.Contains (v)) {  		v.Type = expectedType;  	}  	return v.Type;  }  case ILCode.Ldloca: {  	ILVariable v = (ILVariable)expr.Operand;  	if (v.Type != null)  		return new ByReferenceType (v.Type);  	else  		return null;  }  #endregion  #region Call / NewObj  case ILCode.Call:  case ILCode.Callvirt:  case ILCode.CallGetter:  case ILCode.CallvirtGetter:  case ILCode.CallSetter:  case ILCode.CallvirtSetter: {  	MethodReference method = (MethodReference)expr.Operand;  	if (forceInferChildren) {  		for (int i = 0; i < expr.Arguments.Count; i++) {  			if (i == 0 && method.HasThis) {  				InferTypeForExpression (expr.Arguments [0]' MakeRefIfValueType (method.DeclaringType' expr.GetPrefix (ILCode.Constrained)));  			} else {  				InferTypeForExpression (expr.Arguments [i]' SubstituteTypeArgs (method.Parameters [method.HasThis ? i - 1 : i].ParameterType' method));  			}  		}  	}  	if (expr.Code == ILCode.CallSetter || expr.Code == ILCode.CallvirtSetter) {  		return SubstituteTypeArgs (method.Parameters.Last ().ParameterType' method);  	} else {  		return SubstituteTypeArgs (method.ReturnType' method);  	}  }  case ILCode.Newobj: {  	MethodReference ctor = (MethodReference)expr.Operand;  	if (forceInferChildren) {  		for (int i = 0; i < ctor.Parameters.Count; i++) {  			InferTypeForExpression (expr.Arguments [i]' SubstituteTypeArgs (ctor.Parameters [i].ParameterType' ctor));  		}  	}  	return ctor.DeclaringType;  }  case ILCode.InitObject:  case ILCode.InitCollection:  	return InferTypeForExpression (expr.Arguments [0]' expectedType);  case ILCode.InitializedObject:  	// expectedType should always be known due to the parent method call / property setter  	Debug.Assert (expectedType != null);  	return expectedType;  #endregion  #region Load/Store Fields  case ILCode.Ldfld:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' MakeRefIfValueType (((FieldReference)expr.Operand).DeclaringType' expr.GetPrefix (ILCode.Constrained)));  	}  	return GetFieldType ((FieldReference)expr.Operand);  case ILCode.Ldsfld:  	return GetFieldType ((FieldReference)expr.Operand);  case ILCode.Ldflda:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' MakeRefIfValueType (((FieldReference)expr.Operand).DeclaringType' expr.GetPrefix (ILCode.Constrained)));  	}  	return new ByReferenceType (GetFieldType ((FieldReference)expr.Operand));  case ILCode.Ldsflda:  	return new ByReferenceType (GetFieldType ((FieldReference)expr.Operand));  case ILCode.Stfld:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' MakeRefIfValueType (((FieldReference)expr.Operand).DeclaringType' expr.GetPrefix (ILCode.Constrained)));  		InferTypeForExpression (expr.Arguments [1]' GetFieldType ((FieldReference)expr.Operand));  	}  	return GetFieldType ((FieldReference)expr.Operand);  case ILCode.Stsfld:  	if (forceInferChildren)  		InferTypeForExpression (expr.Arguments [0]' GetFieldType ((FieldReference)expr.Operand));  	return GetFieldType ((FieldReference)expr.Operand);  #endregion  #region Reference/Pointer instructions  case ILCode.Ldind_Ref:  	return UnpackPointer (InferTypeForExpression (expr.Arguments [0]' null));  case ILCode.Stind_Ref:  	if (forceInferChildren) {  		TypeReference elementType = UnpackPointer (InferTypeForExpression (expr.Arguments [0]' null));  		InferTypeForExpression (expr.Arguments [1]' elementType);  	}  	return null;  case ILCode.Ldobj: {  	TypeReference type = (TypeReference)expr.Operand;  	var argType = InferTypeForExpression (expr.Arguments [0]' null);  	if (argType is PointerType || argType is ByReferenceType) {  		var elementType = ((TypeSpecification)argType).ElementType;  		int infoAmount = GetInformationAmount (elementType);  		if (infoAmount == 1 && GetInformationAmount (type) == 8) {  			// A bool can be loaded from both bytes and sbytes.  			type = elementType;  		}  		if (infoAmount >= 8 && infoAmount <= 64 && infoAmount == GetInformationAmount (type)) {  			// An integer can be loaded as another integer of the same size.  			// For integers smaller than 32 bit' the signs must match (as loading performs sign extension)  			bool? elementTypeIsSigned = IsSigned (elementType);  			bool? typeIsSigned = IsSigned (type);  			if (elementTypeIsSigned != null && typeIsSigned != null) {  				if (infoAmount >= 32 || elementTypeIsSigned == typeIsSigned)  					type = elementType;  			}  		}  	}  	if (argType is PointerType)  		InferTypeForExpression (expr.Arguments [0]' new PointerType (type));  	else  		InferTypeForExpression (expr.Arguments [0]' new ByReferenceType (type));  	return type;  }  case ILCode.Stobj: {  	TypeReference operandType = (TypeReference)expr.Operand;  	TypeReference pointerType = InferTypeForExpression (expr.Arguments [0]' new ByReferenceType (operandType));  	TypeReference elementType;  	if (pointerType is PointerType)  		elementType = ((PointerType)pointerType).ElementType;  	else if (pointerType is ByReferenceType)  		elementType = ((ByReferenceType)pointerType).ElementType;  	else  		elementType = null;  	if (elementType != null) {  		// An integer can be stored in any other integer of the same size.  		int infoAmount = GetInformationAmount (elementType);  		if (infoAmount == 1 && GetInformationAmount (operandType) == 8)  			operandType = elementType;  		else if (infoAmount == GetInformationAmount (operandType) && IsSigned (elementType) != null && IsSigned (operandType) != null)  			operandType = elementType;  	}  	if (forceInferChildren) {  		if (pointerType is PointerType)  			InferTypeForExpression (expr.Arguments [0]' new PointerType (operandType));  		else if (!IsSameType (operandType' expr.Operand as TypeReference))  			InferTypeForExpression (expr.Arguments [0]' new ByReferenceType (operandType));  		InferTypeForExpression (expr.Arguments [1]' operandType);  	}  	return operandType;  }  case ILCode.Initobj:  	return null;  case ILCode.DefaultValue:  	return (TypeReference)expr.Operand;  case ILCode.Localloc:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' typeSystem.Int32);  	}  	if (expectedType is PointerType)  		return expectedType;  	else  		return typeSystem.IntPtr;  case ILCode.Sizeof:  	return typeSystem.Int32;  case ILCode.PostIncrement:  case ILCode.PostIncrement_Ovf:  case ILCode.PostIncrement_Ovf_Un: {  	TypeReference elementType = UnpackPointer (InferTypeForExpression (expr.Arguments [0]' null));  	if (forceInferChildren && elementType != null) {  		// Assign expected type to the child expression  		InferTypeForExpression (expr.Arguments [0]' new ByReferenceType (elementType));  	}  	return elementType;  }  case ILCode.Mkrefany:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' (TypeReference)expr.Operand);  	}  	return typeSystem.TypedReference;  case ILCode.Refanytype:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' typeSystem.TypedReference);  	}  	return new TypeReference ("System"' "RuntimeTypeHandle"' module' module.TypeSystem.CoreLibrary' true);  case ILCode.Refanyval:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' typeSystem.TypedReference);  	}  	return new ByReferenceType ((TypeReference)expr.Operand);  case ILCode.AddressOf: {  	TypeReference t = InferTypeForExpression (expr.Arguments [0]' UnpackPointer (expectedType));  	return t != null ? new ByReferenceType (t) : null;  }  case ILCode.ValueOf:  	return GetNullableTypeArgument (InferTypeForExpression (expr.Arguments [0]' CreateNullableType (expectedType)));  case ILCode.NullableOf:  	return CreateNullableType (InferTypeForExpression (expr.Arguments [0]' GetNullableTypeArgument (expectedType)));  #endregion  #region Arithmetic instructions  case ILCode.Not:  // bitwise complement  case ILCode.Neg:  	return InferTypeForExpression (expr.Arguments.Single ()' expectedType);  case ILCode.Add:  	return InferArgumentsInAddition (expr' null' expectedType);  case ILCode.Sub:  	return InferArgumentsInSubtraction (expr' null' expectedType);  case ILCode.Mul:  case ILCode.Or:  case ILCode.And:  case ILCode.Xor:  	return InferArgumentsInBinaryOperator (expr' null' expectedType);  case ILCode.Add_Ovf:  	return InferArgumentsInAddition (expr' true' expectedType);  case ILCode.Sub_Ovf:  	return InferArgumentsInSubtraction (expr' true' expectedType);  case ILCode.Mul_Ovf:  case ILCode.Div:  case ILCode.Rem:  	return InferArgumentsInBinaryOperator (expr' true' expectedType);  case ILCode.Add_Ovf_Un:  	return InferArgumentsInAddition (expr' false' expectedType);  case ILCode.Sub_Ovf_Un:  	return InferArgumentsInSubtraction (expr' false' expectedType);  case ILCode.Mul_Ovf_Un:  case ILCode.Div_Un:  case ILCode.Rem_Un:  	return InferArgumentsInBinaryOperator (expr' false' expectedType);  case ILCode.Shl:  	if (forceInferChildren)  		InferTypeForExpression (expr.Arguments [1]' typeSystem.Int32);  	if (expectedType != null && (expectedType.MetadataType == MetadataType.Int32 || expectedType.MetadataType == MetadataType.UInt32 || expectedType.MetadataType == MetadataType.Int64 || expectedType.MetadataType == MetadataType.UInt64))  		return NumericPromotion (InferTypeForExpression (expr.Arguments [0]' expectedType));  	else  		return NumericPromotion (InferTypeForExpression (expr.Arguments [0]' null));  case ILCode.Shr:  case ILCode.Shr_Un: {  	if (forceInferChildren)  		InferTypeForExpression (expr.Arguments [1]' typeSystem.Int32);  	TypeReference type = NumericPromotion (InferTypeForExpression (expr.Arguments [0]' null));  	TypeReference expectedInputType = null;  	switch (type.MetadataType) {  	case MetadataType.Int32:  		if (expr.Code == ILCode.Shr_Un)  			expectedInputType = typeSystem.UInt32;  		break;  	case MetadataType.UInt32:  		if (expr.Code == ILCode.Shr)  			expectedInputType = typeSystem.Int32;  		break;  	case MetadataType.Int64:  		if (expr.Code == ILCode.Shr_Un)  			expectedInputType = typeSystem.UInt64;  		break;  	case MetadataType.UInt64:  		if (expr.Code == ILCode.Shr)  			expectedInputType = typeSystem.UInt64;  		break;  	}  	if (expectedInputType != null) {  		InferTypeForExpression (expr.Arguments [0]' expectedInputType);  		return expectedInputType;  	} else {  		return type;  	}  }  case ILCode.CompoundAssignment: {  	var op = expr.Arguments [0];  	if (op.Code == ILCode.NullableOf)  		op = op.Arguments [0].Arguments [0];  	var varType = InferTypeForExpression (op.Arguments [0]' null);  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' varType);  	}  	return varType;  }  #endregion  #region Constant loading instructions  case ILCode.Ldnull:  	return typeSystem.Object;  case ILCode.Ldstr:  	return typeSystem.String;  case ILCode.Ldftn:  case ILCode.Ldvirtftn:  	return typeSystem.IntPtr;  case ILCode.Ldc_I4:  	if (IsBoolean (expectedType) && ((int)expr.Operand == 0 || (int)expr.Operand == 1))  		return typeSystem.Boolean;  	if (expectedType is PointerType && (int)expr.Operand == 0)  		return expectedType;  	if (IsIntegerOrEnum (expectedType) && OperandFitsInType (expectedType' (int)expr.Operand))  		return expectedType;  	else  		return typeSystem.Int32;  case ILCode.Ldc_I8:  	if (expectedType is PointerType && (long)expr.Operand == 0)  		return expectedType;  	if (IsIntegerOrEnum (expectedType) && GetInformationAmount (expectedType) >= NativeInt)  		return expectedType;  	else  		return typeSystem.Int64;  case ILCode.Ldc_R4:  	return typeSystem.Single;  case ILCode.Ldc_R8:  	return typeSystem.Double;  case ILCode.Ldc_Decimal:  	return new TypeReference ("System"' "Decimal"' module' module.TypeSystem.CoreLibrary' true);  case ILCode.Ldtoken:  	if (expr.Operand is TypeReference)  		return new TypeReference ("System"' "RuntimeTypeHandle"' module' module.TypeSystem.CoreLibrary' true);  	else if (expr.Operand is FieldReference)  		return new TypeReference ("System"' "RuntimeFieldHandle"' module' module.TypeSystem.CoreLibrary' true);  	else  		return new TypeReference ("System"' "RuntimeMethodHandle"' module' module.TypeSystem.CoreLibrary' true);  case ILCode.Arglist:  	return new TypeReference ("System"' "RuntimeArgumentHandle"' module' module.TypeSystem.CoreLibrary' true);  #endregion  #region Array instructions  case ILCode.Newarr:  	if (forceInferChildren) {  		var lengthType = InferTypeForExpression (expr.Arguments.Single ()' null);  		if (lengthType == typeSystem.IntPtr) {  			lengthType = typeSystem.Int64;  		} else if (lengthType == typeSystem.UIntPtr) {  			lengthType = typeSystem.UInt64;  		} else if (lengthType != typeSystem.UInt32 && lengthType != typeSystem.Int64 && lengthType != typeSystem.UInt64) {  			lengthType = typeSystem.Int32;  		}  		if (forceInferChildren) {  			InferTypeForExpression (expr.Arguments.Single ()' lengthType);  		}  	}  	return new ArrayType ((TypeReference)expr.Operand);  case ILCode.InitArray:  	var operandAsArrayType = (ArrayType)expr.Operand;  	if (forceInferChildren) {  		foreach (ILExpression arg in expr.Arguments)  			InferTypeForExpression (arg' operandAsArrayType.ElementType);  	}  	return operandAsArrayType;  case ILCode.Ldlen:  	return typeSystem.Int32;  case ILCode.Ldelem_U1:  case ILCode.Ldelem_U2:  case ILCode.Ldelem_U4:  case ILCode.Ldelem_I1:  case ILCode.Ldelem_I2:  case ILCode.Ldelem_I4:  case ILCode.Ldelem_I8:  case ILCode.Ldelem_R4:  case ILCode.Ldelem_R8:  case ILCode.Ldelem_I:  case ILCode.Ldelem_Ref: {  	ArrayType arrayType = InferTypeForExpression (expr.Arguments [0]' null) as ArrayType;  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [1]' typeSystem.Int32);  	}  	return arrayType != null ? arrayType.ElementType : null;  }  case ILCode.Ldelem_Any:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [1]' typeSystem.Int32);  	}  	return (TypeReference)expr.Operand;  case ILCode.Ldelema: {  	ArrayType arrayType = InferTypeForExpression (expr.Arguments [0]' null) as ArrayType;  	if (forceInferChildren)  		InferTypeForExpression (expr.Arguments [1]' typeSystem.Int32);  	return arrayType != null ? new ByReferenceType (arrayType.ElementType) : null;  }  case ILCode.Stelem_I:  case ILCode.Stelem_I1:  case ILCode.Stelem_I2:  case ILCode.Stelem_I4:  case ILCode.Stelem_I8:  case ILCode.Stelem_R4:  case ILCode.Stelem_R8:  case ILCode.Stelem_Ref:  case ILCode.Stelem_Any: {  	ArrayType arrayType = InferTypeForExpression (expr.Arguments [0]' null) as ArrayType;  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [1]' typeSystem.Int32);  		if (arrayType != null) {  			InferTypeForExpression (expr.Arguments [2]' arrayType.ElementType);  		}  	}  	return arrayType != null ? arrayType.ElementType : null;  }  #endregion  #region Conversion instructions  case ILCode.Conv_I1:  case ILCode.Conv_Ovf_I1:  case ILCode.Conv_Ovf_I1_Un:  	return HandleConversion (8' true' expr.Arguments [0]' expectedType' typeSystem.SByte);  case ILCode.Conv_I2:  case ILCode.Conv_Ovf_I2:  case ILCode.Conv_Ovf_I2_Un:  	return HandleConversion (16' true' expr.Arguments [0]' expectedType' typeSystem.Int16);  case ILCode.Conv_I4:  case ILCode.Conv_Ovf_I4:  case ILCode.Conv_Ovf_I4_Un:  	return HandleConversion (32' true' expr.Arguments [0]' expectedType' typeSystem.Int32);  case ILCode.Conv_I8:  case ILCode.Conv_Ovf_I8:  case ILCode.Conv_Ovf_I8_Un:  	return HandleConversion (64' true' expr.Arguments [0]' expectedType' typeSystem.Int64);  case ILCode.Conv_U1:  case ILCode.Conv_Ovf_U1:  case ILCode.Conv_Ovf_U1_Un:  	return HandleConversion (8' false' expr.Arguments [0]' expectedType' typeSystem.Byte);  case ILCode.Conv_U2:  case ILCode.Conv_Ovf_U2:  case ILCode.Conv_Ovf_U2_Un:  	return HandleConversion (16' false' expr.Arguments [0]' expectedType' typeSystem.UInt16);  case ILCode.Conv_U4:  case ILCode.Conv_Ovf_U4:  case ILCode.Conv_Ovf_U4_Un:  	return HandleConversion (32' false' expr.Arguments [0]' expectedType' typeSystem.UInt32);  case ILCode.Conv_U8:  case ILCode.Conv_Ovf_U8:  case ILCode.Conv_Ovf_U8_Un:  	return HandleConversion (64' false' expr.Arguments [0]' expectedType' typeSystem.UInt64);  case ILCode.Conv_I:  case ILCode.Conv_Ovf_I:  case ILCode.Conv_Ovf_I_Un:  	return HandleConversion (NativeInt' true' expr.Arguments [0]' expectedType' typeSystem.IntPtr);  case ILCode.Conv_U:  case ILCode.Conv_Ovf_U:  case ILCode.Conv_Ovf_U_Un:  	return HandleConversion (NativeInt' false' expr.Arguments [0]' expectedType' typeSystem.UIntPtr);  case ILCode.Conv_R4:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' typeSystem.Single);  	}  	return typeSystem.Single;  case ILCode.Conv_R8:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' typeSystem.Double);  	}  	return typeSystem.Double;  case ILCode.Conv_R_Un:  	return (expectedType != null && expectedType.MetadataType == MetadataType.Single) ? typeSystem.Single : typeSystem.Double;  case ILCode.Castclass:  case ILCode.Unbox_Any:  	return (TypeReference)expr.Operand;  case ILCode.Unbox:  	return new ByReferenceType ((TypeReference)expr.Operand);  case ILCode.Isinst: {  	// isinst performs the equivalent of a cast only for reference types;  	// value types still need to be unboxed after an isinst instruction  	TypeReference tr = (TypeReference)expr.Operand;  	return tr.IsValueType ? typeSystem.Object : tr;  }  case ILCode.Box: {  	var tr = (TypeReference)expr.Operand;  	if (forceInferChildren)  		InferTypeForExpression (expr.Arguments.Single ()' tr);  	return tr.IsValueType ? typeSystem.Object : tr;  }  #endregion  #region Comparison instructions  case ILCode.Ceq:  case ILCode.Cne:  	if (forceInferChildren)  		InferArgumentsInBinaryOperator (expr' null' null);  	return typeSystem.Boolean;  case ILCode.Clt:  case ILCode.Cgt:  case ILCode.Cle:  case ILCode.Cge:  	if (forceInferChildren)  		InferArgumentsInBinaryOperator (expr' true' null);  	return typeSystem.Boolean;  case ILCode.Clt_Un:  case ILCode.Cgt_Un:  case ILCode.Cle_Un:  case ILCode.Cge_Un:  	if (forceInferChildren)  		InferArgumentsInBinaryOperator (expr' false' null);  	return typeSystem.Boolean;  #endregion  #region Branch instructions  case ILCode.Brtrue:  	if (forceInferChildren)  		InferTypeForExpression (expr.Arguments.Single ()' typeSystem.Boolean);  	return null;  case ILCode.Br:  case ILCode.Leave:  case ILCode.Endfinally:  case ILCode.Switch:  case ILCode.Throw:  case ILCode.Rethrow:  case ILCode.LoopOrSwitchBreak:  case ILCode.LoopContinue:  case ILCode.YieldBreak:  	return null;  case ILCode.Ret:  	if (forceInferChildren && expr.Arguments.Count == 1) {  		TypeReference returnType = context.CurrentMethod.ReturnType;  		if (context.CurrentMethodIsAsync && returnType != null && returnType.Namespace == "System.Threading.Tasks") {  			if (returnType.Name == "Task") {  				returnType = typeSystem.Void;  			} else if (returnType.Name == "Task`1" && returnType.IsGenericInstance) {  				returnType = ((GenericInstanceType)returnType).GenericArguments [0];  			}  		}  		InferTypeForExpression (expr.Arguments [0]' returnType);  	}  	return null;  case ILCode.YieldReturn:  	if (forceInferChildren) {  		GenericInstanceType genericType = context.CurrentMethod.ReturnType as GenericInstanceType;  		if (genericType != null) {  			// IEnumerable<T> or IEnumerator<T>  			InferTypeForExpression (expr.Arguments [0]' genericType.GenericArguments [0]);  		} else {  			// non-generic IEnumerable or IEnumerator  			InferTypeForExpression (expr.Arguments [0]' typeSystem.Object);  		}  	}  	return null;  case ILCode.Await: {  	TypeReference taskType = InferTypeForExpression (expr.Arguments [0]' null);  	if (taskType.Name == "Task`1" && taskType.IsGenericInstance && taskType.Namespace == "System.Threading.Tasks") {  		return ((GenericInstanceType)taskType).GenericArguments [0];  	}  	return null;  }  #endregion  case ILCode.Pop:  	return null;  case ILCode.Wrap:  case ILCode.Dup: {  	var arg = expr.Arguments.Single ();  	return arg.ExpectedType = InferTypeForExpression (arg' expectedType);  }  default:  	Debug.WriteLine ("Type Inference: Can't handle " + expr.Code.GetName ());  	return null;  }  
Magic Number,Custom.Decompiler.ILAst,TypeAnalysis,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\TypeAnalysis.cs,DoInferTypeForExpression,The following statement contains a magic number: switch (expr.Code) {  #region Logical operators  case ILCode.LogicNot:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments.Single ()' typeSystem.Boolean);  	}  	return typeSystem.Boolean;  case ILCode.LogicAnd:  case ILCode.LogicOr:  	// if Operand is set the logic and/or expression is a custom operator  	// we can deal with it the same as a normal invocation.  	if (expr.Operand != null)  		goto case ILCode.Call;  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' typeSystem.Boolean);  		InferTypeForExpression (expr.Arguments [1]' typeSystem.Boolean);  	}  	return typeSystem.Boolean;  case ILCode.TernaryOp:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' typeSystem.Boolean);  	}  	return InferBinaryArguments (expr.Arguments [1]' expr.Arguments [2]' expectedType' forceInferChildren);  case ILCode.NullCoalescing:  	return InferBinaryArguments (expr.Arguments [0]' expr.Arguments [1]' expectedType' forceInferChildren);  #endregion  #region Variable load/store  case ILCode.Stloc: {  	ILVariable v = (ILVariable)expr.Operand;  	if (forceInferChildren) {  		// do not use 'expectedType' in here!  		InferTypeForExpression (expr.Arguments.Single ()' v.Type);  	}  	return v.Type;  }  case ILCode.Ldloc: {  	ILVariable v = (ILVariable)expr.Operand;  	if (v.Type == null && singleLoadVariables.Contains (v)) {  		v.Type = expectedType;  	}  	return v.Type;  }  case ILCode.Ldloca: {  	ILVariable v = (ILVariable)expr.Operand;  	if (v.Type != null)  		return new ByReferenceType (v.Type);  	else  		return null;  }  #endregion  #region Call / NewObj  case ILCode.Call:  case ILCode.Callvirt:  case ILCode.CallGetter:  case ILCode.CallvirtGetter:  case ILCode.CallSetter:  case ILCode.CallvirtSetter: {  	MethodReference method = (MethodReference)expr.Operand;  	if (forceInferChildren) {  		for (int i = 0; i < expr.Arguments.Count; i++) {  			if (i == 0 && method.HasThis) {  				InferTypeForExpression (expr.Arguments [0]' MakeRefIfValueType (method.DeclaringType' expr.GetPrefix (ILCode.Constrained)));  			} else {  				InferTypeForExpression (expr.Arguments [i]' SubstituteTypeArgs (method.Parameters [method.HasThis ? i - 1 : i].ParameterType' method));  			}  		}  	}  	if (expr.Code == ILCode.CallSetter || expr.Code == ILCode.CallvirtSetter) {  		return SubstituteTypeArgs (method.Parameters.Last ().ParameterType' method);  	} else {  		return SubstituteTypeArgs (method.ReturnType' method);  	}  }  case ILCode.Newobj: {  	MethodReference ctor = (MethodReference)expr.Operand;  	if (forceInferChildren) {  		for (int i = 0; i < ctor.Parameters.Count; i++) {  			InferTypeForExpression (expr.Arguments [i]' SubstituteTypeArgs (ctor.Parameters [i].ParameterType' ctor));  		}  	}  	return ctor.DeclaringType;  }  case ILCode.InitObject:  case ILCode.InitCollection:  	return InferTypeForExpression (expr.Arguments [0]' expectedType);  case ILCode.InitializedObject:  	// expectedType should always be known due to the parent method call / property setter  	Debug.Assert (expectedType != null);  	return expectedType;  #endregion  #region Load/Store Fields  case ILCode.Ldfld:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' MakeRefIfValueType (((FieldReference)expr.Operand).DeclaringType' expr.GetPrefix (ILCode.Constrained)));  	}  	return GetFieldType ((FieldReference)expr.Operand);  case ILCode.Ldsfld:  	return GetFieldType ((FieldReference)expr.Operand);  case ILCode.Ldflda:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' MakeRefIfValueType (((FieldReference)expr.Operand).DeclaringType' expr.GetPrefix (ILCode.Constrained)));  	}  	return new ByReferenceType (GetFieldType ((FieldReference)expr.Operand));  case ILCode.Ldsflda:  	return new ByReferenceType (GetFieldType ((FieldReference)expr.Operand));  case ILCode.Stfld:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' MakeRefIfValueType (((FieldReference)expr.Operand).DeclaringType' expr.GetPrefix (ILCode.Constrained)));  		InferTypeForExpression (expr.Arguments [1]' GetFieldType ((FieldReference)expr.Operand));  	}  	return GetFieldType ((FieldReference)expr.Operand);  case ILCode.Stsfld:  	if (forceInferChildren)  		InferTypeForExpression (expr.Arguments [0]' GetFieldType ((FieldReference)expr.Operand));  	return GetFieldType ((FieldReference)expr.Operand);  #endregion  #region Reference/Pointer instructions  case ILCode.Ldind_Ref:  	return UnpackPointer (InferTypeForExpression (expr.Arguments [0]' null));  case ILCode.Stind_Ref:  	if (forceInferChildren) {  		TypeReference elementType = UnpackPointer (InferTypeForExpression (expr.Arguments [0]' null));  		InferTypeForExpression (expr.Arguments [1]' elementType);  	}  	return null;  case ILCode.Ldobj: {  	TypeReference type = (TypeReference)expr.Operand;  	var argType = InferTypeForExpression (expr.Arguments [0]' null);  	if (argType is PointerType || argType is ByReferenceType) {  		var elementType = ((TypeSpecification)argType).ElementType;  		int infoAmount = GetInformationAmount (elementType);  		if (infoAmount == 1 && GetInformationAmount (type) == 8) {  			// A bool can be loaded from both bytes and sbytes.  			type = elementType;  		}  		if (infoAmount >= 8 && infoAmount <= 64 && infoAmount == GetInformationAmount (type)) {  			// An integer can be loaded as another integer of the same size.  			// For integers smaller than 32 bit' the signs must match (as loading performs sign extension)  			bool? elementTypeIsSigned = IsSigned (elementType);  			bool? typeIsSigned = IsSigned (type);  			if (elementTypeIsSigned != null && typeIsSigned != null) {  				if (infoAmount >= 32 || elementTypeIsSigned == typeIsSigned)  					type = elementType;  			}  		}  	}  	if (argType is PointerType)  		InferTypeForExpression (expr.Arguments [0]' new PointerType (type));  	else  		InferTypeForExpression (expr.Arguments [0]' new ByReferenceType (type));  	return type;  }  case ILCode.Stobj: {  	TypeReference operandType = (TypeReference)expr.Operand;  	TypeReference pointerType = InferTypeForExpression (expr.Arguments [0]' new ByReferenceType (operandType));  	TypeReference elementType;  	if (pointerType is PointerType)  		elementType = ((PointerType)pointerType).ElementType;  	else if (pointerType is ByReferenceType)  		elementType = ((ByReferenceType)pointerType).ElementType;  	else  		elementType = null;  	if (elementType != null) {  		// An integer can be stored in any other integer of the same size.  		int infoAmount = GetInformationAmount (elementType);  		if (infoAmount == 1 && GetInformationAmount (operandType) == 8)  			operandType = elementType;  		else if (infoAmount == GetInformationAmount (operandType) && IsSigned (elementType) != null && IsSigned (operandType) != null)  			operandType = elementType;  	}  	if (forceInferChildren) {  		if (pointerType is PointerType)  			InferTypeForExpression (expr.Arguments [0]' new PointerType (operandType));  		else if (!IsSameType (operandType' expr.Operand as TypeReference))  			InferTypeForExpression (expr.Arguments [0]' new ByReferenceType (operandType));  		InferTypeForExpression (expr.Arguments [1]' operandType);  	}  	return operandType;  }  case ILCode.Initobj:  	return null;  case ILCode.DefaultValue:  	return (TypeReference)expr.Operand;  case ILCode.Localloc:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' typeSystem.Int32);  	}  	if (expectedType is PointerType)  		return expectedType;  	else  		return typeSystem.IntPtr;  case ILCode.Sizeof:  	return typeSystem.Int32;  case ILCode.PostIncrement:  case ILCode.PostIncrement_Ovf:  case ILCode.PostIncrement_Ovf_Un: {  	TypeReference elementType = UnpackPointer (InferTypeForExpression (expr.Arguments [0]' null));  	if (forceInferChildren && elementType != null) {  		// Assign expected type to the child expression  		InferTypeForExpression (expr.Arguments [0]' new ByReferenceType (elementType));  	}  	return elementType;  }  case ILCode.Mkrefany:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' (TypeReference)expr.Operand);  	}  	return typeSystem.TypedReference;  case ILCode.Refanytype:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' typeSystem.TypedReference);  	}  	return new TypeReference ("System"' "RuntimeTypeHandle"' module' module.TypeSystem.CoreLibrary' true);  case ILCode.Refanyval:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' typeSystem.TypedReference);  	}  	return new ByReferenceType ((TypeReference)expr.Operand);  case ILCode.AddressOf: {  	TypeReference t = InferTypeForExpression (expr.Arguments [0]' UnpackPointer (expectedType));  	return t != null ? new ByReferenceType (t) : null;  }  case ILCode.ValueOf:  	return GetNullableTypeArgument (InferTypeForExpression (expr.Arguments [0]' CreateNullableType (expectedType)));  case ILCode.NullableOf:  	return CreateNullableType (InferTypeForExpression (expr.Arguments [0]' GetNullableTypeArgument (expectedType)));  #endregion  #region Arithmetic instructions  case ILCode.Not:  // bitwise complement  case ILCode.Neg:  	return InferTypeForExpression (expr.Arguments.Single ()' expectedType);  case ILCode.Add:  	return InferArgumentsInAddition (expr' null' expectedType);  case ILCode.Sub:  	return InferArgumentsInSubtraction (expr' null' expectedType);  case ILCode.Mul:  case ILCode.Or:  case ILCode.And:  case ILCode.Xor:  	return InferArgumentsInBinaryOperator (expr' null' expectedType);  case ILCode.Add_Ovf:  	return InferArgumentsInAddition (expr' true' expectedType);  case ILCode.Sub_Ovf:  	return InferArgumentsInSubtraction (expr' true' expectedType);  case ILCode.Mul_Ovf:  case ILCode.Div:  case ILCode.Rem:  	return InferArgumentsInBinaryOperator (expr' true' expectedType);  case ILCode.Add_Ovf_Un:  	return InferArgumentsInAddition (expr' false' expectedType);  case ILCode.Sub_Ovf_Un:  	return InferArgumentsInSubtraction (expr' false' expectedType);  case ILCode.Mul_Ovf_Un:  case ILCode.Div_Un:  case ILCode.Rem_Un:  	return InferArgumentsInBinaryOperator (expr' false' expectedType);  case ILCode.Shl:  	if (forceInferChildren)  		InferTypeForExpression (expr.Arguments [1]' typeSystem.Int32);  	if (expectedType != null && (expectedType.MetadataType == MetadataType.Int32 || expectedType.MetadataType == MetadataType.UInt32 || expectedType.MetadataType == MetadataType.Int64 || expectedType.MetadataType == MetadataType.UInt64))  		return NumericPromotion (InferTypeForExpression (expr.Arguments [0]' expectedType));  	else  		return NumericPromotion (InferTypeForExpression (expr.Arguments [0]' null));  case ILCode.Shr:  case ILCode.Shr_Un: {  	if (forceInferChildren)  		InferTypeForExpression (expr.Arguments [1]' typeSystem.Int32);  	TypeReference type = NumericPromotion (InferTypeForExpression (expr.Arguments [0]' null));  	TypeReference expectedInputType = null;  	switch (type.MetadataType) {  	case MetadataType.Int32:  		if (expr.Code == ILCode.Shr_Un)  			expectedInputType = typeSystem.UInt32;  		break;  	case MetadataType.UInt32:  		if (expr.Code == ILCode.Shr)  			expectedInputType = typeSystem.Int32;  		break;  	case MetadataType.Int64:  		if (expr.Code == ILCode.Shr_Un)  			expectedInputType = typeSystem.UInt64;  		break;  	case MetadataType.UInt64:  		if (expr.Code == ILCode.Shr)  			expectedInputType = typeSystem.UInt64;  		break;  	}  	if (expectedInputType != null) {  		InferTypeForExpression (expr.Arguments [0]' expectedInputType);  		return expectedInputType;  	} else {  		return type;  	}  }  case ILCode.CompoundAssignment: {  	var op = expr.Arguments [0];  	if (op.Code == ILCode.NullableOf)  		op = op.Arguments [0].Arguments [0];  	var varType = InferTypeForExpression (op.Arguments [0]' null);  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' varType);  	}  	return varType;  }  #endregion  #region Constant loading instructions  case ILCode.Ldnull:  	return typeSystem.Object;  case ILCode.Ldstr:  	return typeSystem.String;  case ILCode.Ldftn:  case ILCode.Ldvirtftn:  	return typeSystem.IntPtr;  case ILCode.Ldc_I4:  	if (IsBoolean (expectedType) && ((int)expr.Operand == 0 || (int)expr.Operand == 1))  		return typeSystem.Boolean;  	if (expectedType is PointerType && (int)expr.Operand == 0)  		return expectedType;  	if (IsIntegerOrEnum (expectedType) && OperandFitsInType (expectedType' (int)expr.Operand))  		return expectedType;  	else  		return typeSystem.Int32;  case ILCode.Ldc_I8:  	if (expectedType is PointerType && (long)expr.Operand == 0)  		return expectedType;  	if (IsIntegerOrEnum (expectedType) && GetInformationAmount (expectedType) >= NativeInt)  		return expectedType;  	else  		return typeSystem.Int64;  case ILCode.Ldc_R4:  	return typeSystem.Single;  case ILCode.Ldc_R8:  	return typeSystem.Double;  case ILCode.Ldc_Decimal:  	return new TypeReference ("System"' "Decimal"' module' module.TypeSystem.CoreLibrary' true);  case ILCode.Ldtoken:  	if (expr.Operand is TypeReference)  		return new TypeReference ("System"' "RuntimeTypeHandle"' module' module.TypeSystem.CoreLibrary' true);  	else if (expr.Operand is FieldReference)  		return new TypeReference ("System"' "RuntimeFieldHandle"' module' module.TypeSystem.CoreLibrary' true);  	else  		return new TypeReference ("System"' "RuntimeMethodHandle"' module' module.TypeSystem.CoreLibrary' true);  case ILCode.Arglist:  	return new TypeReference ("System"' "RuntimeArgumentHandle"' module' module.TypeSystem.CoreLibrary' true);  #endregion  #region Array instructions  case ILCode.Newarr:  	if (forceInferChildren) {  		var lengthType = InferTypeForExpression (expr.Arguments.Single ()' null);  		if (lengthType == typeSystem.IntPtr) {  			lengthType = typeSystem.Int64;  		} else if (lengthType == typeSystem.UIntPtr) {  			lengthType = typeSystem.UInt64;  		} else if (lengthType != typeSystem.UInt32 && lengthType != typeSystem.Int64 && lengthType != typeSystem.UInt64) {  			lengthType = typeSystem.Int32;  		}  		if (forceInferChildren) {  			InferTypeForExpression (expr.Arguments.Single ()' lengthType);  		}  	}  	return new ArrayType ((TypeReference)expr.Operand);  case ILCode.InitArray:  	var operandAsArrayType = (ArrayType)expr.Operand;  	if (forceInferChildren) {  		foreach (ILExpression arg in expr.Arguments)  			InferTypeForExpression (arg' operandAsArrayType.ElementType);  	}  	return operandAsArrayType;  case ILCode.Ldlen:  	return typeSystem.Int32;  case ILCode.Ldelem_U1:  case ILCode.Ldelem_U2:  case ILCode.Ldelem_U4:  case ILCode.Ldelem_I1:  case ILCode.Ldelem_I2:  case ILCode.Ldelem_I4:  case ILCode.Ldelem_I8:  case ILCode.Ldelem_R4:  case ILCode.Ldelem_R8:  case ILCode.Ldelem_I:  case ILCode.Ldelem_Ref: {  	ArrayType arrayType = InferTypeForExpression (expr.Arguments [0]' null) as ArrayType;  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [1]' typeSystem.Int32);  	}  	return arrayType != null ? arrayType.ElementType : null;  }  case ILCode.Ldelem_Any:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [1]' typeSystem.Int32);  	}  	return (TypeReference)expr.Operand;  case ILCode.Ldelema: {  	ArrayType arrayType = InferTypeForExpression (expr.Arguments [0]' null) as ArrayType;  	if (forceInferChildren)  		InferTypeForExpression (expr.Arguments [1]' typeSystem.Int32);  	return arrayType != null ? new ByReferenceType (arrayType.ElementType) : null;  }  case ILCode.Stelem_I:  case ILCode.Stelem_I1:  case ILCode.Stelem_I2:  case ILCode.Stelem_I4:  case ILCode.Stelem_I8:  case ILCode.Stelem_R4:  case ILCode.Stelem_R8:  case ILCode.Stelem_Ref:  case ILCode.Stelem_Any: {  	ArrayType arrayType = InferTypeForExpression (expr.Arguments [0]' null) as ArrayType;  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [1]' typeSystem.Int32);  		if (arrayType != null) {  			InferTypeForExpression (expr.Arguments [2]' arrayType.ElementType);  		}  	}  	return arrayType != null ? arrayType.ElementType : null;  }  #endregion  #region Conversion instructions  case ILCode.Conv_I1:  case ILCode.Conv_Ovf_I1:  case ILCode.Conv_Ovf_I1_Un:  	return HandleConversion (8' true' expr.Arguments [0]' expectedType' typeSystem.SByte);  case ILCode.Conv_I2:  case ILCode.Conv_Ovf_I2:  case ILCode.Conv_Ovf_I2_Un:  	return HandleConversion (16' true' expr.Arguments [0]' expectedType' typeSystem.Int16);  case ILCode.Conv_I4:  case ILCode.Conv_Ovf_I4:  case ILCode.Conv_Ovf_I4_Un:  	return HandleConversion (32' true' expr.Arguments [0]' expectedType' typeSystem.Int32);  case ILCode.Conv_I8:  case ILCode.Conv_Ovf_I8:  case ILCode.Conv_Ovf_I8_Un:  	return HandleConversion (64' true' expr.Arguments [0]' expectedType' typeSystem.Int64);  case ILCode.Conv_U1:  case ILCode.Conv_Ovf_U1:  case ILCode.Conv_Ovf_U1_Un:  	return HandleConversion (8' false' expr.Arguments [0]' expectedType' typeSystem.Byte);  case ILCode.Conv_U2:  case ILCode.Conv_Ovf_U2:  case ILCode.Conv_Ovf_U2_Un:  	return HandleConversion (16' false' expr.Arguments [0]' expectedType' typeSystem.UInt16);  case ILCode.Conv_U4:  case ILCode.Conv_Ovf_U4:  case ILCode.Conv_Ovf_U4_Un:  	return HandleConversion (32' false' expr.Arguments [0]' expectedType' typeSystem.UInt32);  case ILCode.Conv_U8:  case ILCode.Conv_Ovf_U8:  case ILCode.Conv_Ovf_U8_Un:  	return HandleConversion (64' false' expr.Arguments [0]' expectedType' typeSystem.UInt64);  case ILCode.Conv_I:  case ILCode.Conv_Ovf_I:  case ILCode.Conv_Ovf_I_Un:  	return HandleConversion (NativeInt' true' expr.Arguments [0]' expectedType' typeSystem.IntPtr);  case ILCode.Conv_U:  case ILCode.Conv_Ovf_U:  case ILCode.Conv_Ovf_U_Un:  	return HandleConversion (NativeInt' false' expr.Arguments [0]' expectedType' typeSystem.UIntPtr);  case ILCode.Conv_R4:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' typeSystem.Single);  	}  	return typeSystem.Single;  case ILCode.Conv_R8:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' typeSystem.Double);  	}  	return typeSystem.Double;  case ILCode.Conv_R_Un:  	return (expectedType != null && expectedType.MetadataType == MetadataType.Single) ? typeSystem.Single : typeSystem.Double;  case ILCode.Castclass:  case ILCode.Unbox_Any:  	return (TypeReference)expr.Operand;  case ILCode.Unbox:  	return new ByReferenceType ((TypeReference)expr.Operand);  case ILCode.Isinst: {  	// isinst performs the equivalent of a cast only for reference types;  	// value types still need to be unboxed after an isinst instruction  	TypeReference tr = (TypeReference)expr.Operand;  	return tr.IsValueType ? typeSystem.Object : tr;  }  case ILCode.Box: {  	var tr = (TypeReference)expr.Operand;  	if (forceInferChildren)  		InferTypeForExpression (expr.Arguments.Single ()' tr);  	return tr.IsValueType ? typeSystem.Object : tr;  }  #endregion  #region Comparison instructions  case ILCode.Ceq:  case ILCode.Cne:  	if (forceInferChildren)  		InferArgumentsInBinaryOperator (expr' null' null);  	return typeSystem.Boolean;  case ILCode.Clt:  case ILCode.Cgt:  case ILCode.Cle:  case ILCode.Cge:  	if (forceInferChildren)  		InferArgumentsInBinaryOperator (expr' true' null);  	return typeSystem.Boolean;  case ILCode.Clt_Un:  case ILCode.Cgt_Un:  case ILCode.Cle_Un:  case ILCode.Cge_Un:  	if (forceInferChildren)  		InferArgumentsInBinaryOperator (expr' false' null);  	return typeSystem.Boolean;  #endregion  #region Branch instructions  case ILCode.Brtrue:  	if (forceInferChildren)  		InferTypeForExpression (expr.Arguments.Single ()' typeSystem.Boolean);  	return null;  case ILCode.Br:  case ILCode.Leave:  case ILCode.Endfinally:  case ILCode.Switch:  case ILCode.Throw:  case ILCode.Rethrow:  case ILCode.LoopOrSwitchBreak:  case ILCode.LoopContinue:  case ILCode.YieldBreak:  	return null;  case ILCode.Ret:  	if (forceInferChildren && expr.Arguments.Count == 1) {  		TypeReference returnType = context.CurrentMethod.ReturnType;  		if (context.CurrentMethodIsAsync && returnType != null && returnType.Namespace == "System.Threading.Tasks") {  			if (returnType.Name == "Task") {  				returnType = typeSystem.Void;  			} else if (returnType.Name == "Task`1" && returnType.IsGenericInstance) {  				returnType = ((GenericInstanceType)returnType).GenericArguments [0];  			}  		}  		InferTypeForExpression (expr.Arguments [0]' returnType);  	}  	return null;  case ILCode.YieldReturn:  	if (forceInferChildren) {  		GenericInstanceType genericType = context.CurrentMethod.ReturnType as GenericInstanceType;  		if (genericType != null) {  			// IEnumerable<T> or IEnumerator<T>  			InferTypeForExpression (expr.Arguments [0]' genericType.GenericArguments [0]);  		} else {  			// non-generic IEnumerable or IEnumerator  			InferTypeForExpression (expr.Arguments [0]' typeSystem.Object);  		}  	}  	return null;  case ILCode.Await: {  	TypeReference taskType = InferTypeForExpression (expr.Arguments [0]' null);  	if (taskType.Name == "Task`1" && taskType.IsGenericInstance && taskType.Namespace == "System.Threading.Tasks") {  		return ((GenericInstanceType)taskType).GenericArguments [0];  	}  	return null;  }  #endregion  case ILCode.Pop:  	return null;  case ILCode.Wrap:  case ILCode.Dup: {  	var arg = expr.Arguments.Single ();  	return arg.ExpectedType = InferTypeForExpression (arg' expectedType);  }  default:  	Debug.WriteLine ("Type Inference: Can't handle " + expr.Code.GetName ());  	return null;  }  
Magic Number,Custom.Decompiler.ILAst,TypeAnalysis,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\TypeAnalysis.cs,DoInferTypeForExpression,The following statement contains a magic number: switch (expr.Code) {  #region Logical operators  case ILCode.LogicNot:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments.Single ()' typeSystem.Boolean);  	}  	return typeSystem.Boolean;  case ILCode.LogicAnd:  case ILCode.LogicOr:  	// if Operand is set the logic and/or expression is a custom operator  	// we can deal with it the same as a normal invocation.  	if (expr.Operand != null)  		goto case ILCode.Call;  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' typeSystem.Boolean);  		InferTypeForExpression (expr.Arguments [1]' typeSystem.Boolean);  	}  	return typeSystem.Boolean;  case ILCode.TernaryOp:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' typeSystem.Boolean);  	}  	return InferBinaryArguments (expr.Arguments [1]' expr.Arguments [2]' expectedType' forceInferChildren);  case ILCode.NullCoalescing:  	return InferBinaryArguments (expr.Arguments [0]' expr.Arguments [1]' expectedType' forceInferChildren);  #endregion  #region Variable load/store  case ILCode.Stloc: {  	ILVariable v = (ILVariable)expr.Operand;  	if (forceInferChildren) {  		// do not use 'expectedType' in here!  		InferTypeForExpression (expr.Arguments.Single ()' v.Type);  	}  	return v.Type;  }  case ILCode.Ldloc: {  	ILVariable v = (ILVariable)expr.Operand;  	if (v.Type == null && singleLoadVariables.Contains (v)) {  		v.Type = expectedType;  	}  	return v.Type;  }  case ILCode.Ldloca: {  	ILVariable v = (ILVariable)expr.Operand;  	if (v.Type != null)  		return new ByReferenceType (v.Type);  	else  		return null;  }  #endregion  #region Call / NewObj  case ILCode.Call:  case ILCode.Callvirt:  case ILCode.CallGetter:  case ILCode.CallvirtGetter:  case ILCode.CallSetter:  case ILCode.CallvirtSetter: {  	MethodReference method = (MethodReference)expr.Operand;  	if (forceInferChildren) {  		for (int i = 0; i < expr.Arguments.Count; i++) {  			if (i == 0 && method.HasThis) {  				InferTypeForExpression (expr.Arguments [0]' MakeRefIfValueType (method.DeclaringType' expr.GetPrefix (ILCode.Constrained)));  			} else {  				InferTypeForExpression (expr.Arguments [i]' SubstituteTypeArgs (method.Parameters [method.HasThis ? i - 1 : i].ParameterType' method));  			}  		}  	}  	if (expr.Code == ILCode.CallSetter || expr.Code == ILCode.CallvirtSetter) {  		return SubstituteTypeArgs (method.Parameters.Last ().ParameterType' method);  	} else {  		return SubstituteTypeArgs (method.ReturnType' method);  	}  }  case ILCode.Newobj: {  	MethodReference ctor = (MethodReference)expr.Operand;  	if (forceInferChildren) {  		for (int i = 0; i < ctor.Parameters.Count; i++) {  			InferTypeForExpression (expr.Arguments [i]' SubstituteTypeArgs (ctor.Parameters [i].ParameterType' ctor));  		}  	}  	return ctor.DeclaringType;  }  case ILCode.InitObject:  case ILCode.InitCollection:  	return InferTypeForExpression (expr.Arguments [0]' expectedType);  case ILCode.InitializedObject:  	// expectedType should always be known due to the parent method call / property setter  	Debug.Assert (expectedType != null);  	return expectedType;  #endregion  #region Load/Store Fields  case ILCode.Ldfld:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' MakeRefIfValueType (((FieldReference)expr.Operand).DeclaringType' expr.GetPrefix (ILCode.Constrained)));  	}  	return GetFieldType ((FieldReference)expr.Operand);  case ILCode.Ldsfld:  	return GetFieldType ((FieldReference)expr.Operand);  case ILCode.Ldflda:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' MakeRefIfValueType (((FieldReference)expr.Operand).DeclaringType' expr.GetPrefix (ILCode.Constrained)));  	}  	return new ByReferenceType (GetFieldType ((FieldReference)expr.Operand));  case ILCode.Ldsflda:  	return new ByReferenceType (GetFieldType ((FieldReference)expr.Operand));  case ILCode.Stfld:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' MakeRefIfValueType (((FieldReference)expr.Operand).DeclaringType' expr.GetPrefix (ILCode.Constrained)));  		InferTypeForExpression (expr.Arguments [1]' GetFieldType ((FieldReference)expr.Operand));  	}  	return GetFieldType ((FieldReference)expr.Operand);  case ILCode.Stsfld:  	if (forceInferChildren)  		InferTypeForExpression (expr.Arguments [0]' GetFieldType ((FieldReference)expr.Operand));  	return GetFieldType ((FieldReference)expr.Operand);  #endregion  #region Reference/Pointer instructions  case ILCode.Ldind_Ref:  	return UnpackPointer (InferTypeForExpression (expr.Arguments [0]' null));  case ILCode.Stind_Ref:  	if (forceInferChildren) {  		TypeReference elementType = UnpackPointer (InferTypeForExpression (expr.Arguments [0]' null));  		InferTypeForExpression (expr.Arguments [1]' elementType);  	}  	return null;  case ILCode.Ldobj: {  	TypeReference type = (TypeReference)expr.Operand;  	var argType = InferTypeForExpression (expr.Arguments [0]' null);  	if (argType is PointerType || argType is ByReferenceType) {  		var elementType = ((TypeSpecification)argType).ElementType;  		int infoAmount = GetInformationAmount (elementType);  		if (infoAmount == 1 && GetInformationAmount (type) == 8) {  			// A bool can be loaded from both bytes and sbytes.  			type = elementType;  		}  		if (infoAmount >= 8 && infoAmount <= 64 && infoAmount == GetInformationAmount (type)) {  			// An integer can be loaded as another integer of the same size.  			// For integers smaller than 32 bit' the signs must match (as loading performs sign extension)  			bool? elementTypeIsSigned = IsSigned (elementType);  			bool? typeIsSigned = IsSigned (type);  			if (elementTypeIsSigned != null && typeIsSigned != null) {  				if (infoAmount >= 32 || elementTypeIsSigned == typeIsSigned)  					type = elementType;  			}  		}  	}  	if (argType is PointerType)  		InferTypeForExpression (expr.Arguments [0]' new PointerType (type));  	else  		InferTypeForExpression (expr.Arguments [0]' new ByReferenceType (type));  	return type;  }  case ILCode.Stobj: {  	TypeReference operandType = (TypeReference)expr.Operand;  	TypeReference pointerType = InferTypeForExpression (expr.Arguments [0]' new ByReferenceType (operandType));  	TypeReference elementType;  	if (pointerType is PointerType)  		elementType = ((PointerType)pointerType).ElementType;  	else if (pointerType is ByReferenceType)  		elementType = ((ByReferenceType)pointerType).ElementType;  	else  		elementType = null;  	if (elementType != null) {  		// An integer can be stored in any other integer of the same size.  		int infoAmount = GetInformationAmount (elementType);  		if (infoAmount == 1 && GetInformationAmount (operandType) == 8)  			operandType = elementType;  		else if (infoAmount == GetInformationAmount (operandType) && IsSigned (elementType) != null && IsSigned (operandType) != null)  			operandType = elementType;  	}  	if (forceInferChildren) {  		if (pointerType is PointerType)  			InferTypeForExpression (expr.Arguments [0]' new PointerType (operandType));  		else if (!IsSameType (operandType' expr.Operand as TypeReference))  			InferTypeForExpression (expr.Arguments [0]' new ByReferenceType (operandType));  		InferTypeForExpression (expr.Arguments [1]' operandType);  	}  	return operandType;  }  case ILCode.Initobj:  	return null;  case ILCode.DefaultValue:  	return (TypeReference)expr.Operand;  case ILCode.Localloc:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' typeSystem.Int32);  	}  	if (expectedType is PointerType)  		return expectedType;  	else  		return typeSystem.IntPtr;  case ILCode.Sizeof:  	return typeSystem.Int32;  case ILCode.PostIncrement:  case ILCode.PostIncrement_Ovf:  case ILCode.PostIncrement_Ovf_Un: {  	TypeReference elementType = UnpackPointer (InferTypeForExpression (expr.Arguments [0]' null));  	if (forceInferChildren && elementType != null) {  		// Assign expected type to the child expression  		InferTypeForExpression (expr.Arguments [0]' new ByReferenceType (elementType));  	}  	return elementType;  }  case ILCode.Mkrefany:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' (TypeReference)expr.Operand);  	}  	return typeSystem.TypedReference;  case ILCode.Refanytype:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' typeSystem.TypedReference);  	}  	return new TypeReference ("System"' "RuntimeTypeHandle"' module' module.TypeSystem.CoreLibrary' true);  case ILCode.Refanyval:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' typeSystem.TypedReference);  	}  	return new ByReferenceType ((TypeReference)expr.Operand);  case ILCode.AddressOf: {  	TypeReference t = InferTypeForExpression (expr.Arguments [0]' UnpackPointer (expectedType));  	return t != null ? new ByReferenceType (t) : null;  }  case ILCode.ValueOf:  	return GetNullableTypeArgument (InferTypeForExpression (expr.Arguments [0]' CreateNullableType (expectedType)));  case ILCode.NullableOf:  	return CreateNullableType (InferTypeForExpression (expr.Arguments [0]' GetNullableTypeArgument (expectedType)));  #endregion  #region Arithmetic instructions  case ILCode.Not:  // bitwise complement  case ILCode.Neg:  	return InferTypeForExpression (expr.Arguments.Single ()' expectedType);  case ILCode.Add:  	return InferArgumentsInAddition (expr' null' expectedType);  case ILCode.Sub:  	return InferArgumentsInSubtraction (expr' null' expectedType);  case ILCode.Mul:  case ILCode.Or:  case ILCode.And:  case ILCode.Xor:  	return InferArgumentsInBinaryOperator (expr' null' expectedType);  case ILCode.Add_Ovf:  	return InferArgumentsInAddition (expr' true' expectedType);  case ILCode.Sub_Ovf:  	return InferArgumentsInSubtraction (expr' true' expectedType);  case ILCode.Mul_Ovf:  case ILCode.Div:  case ILCode.Rem:  	return InferArgumentsInBinaryOperator (expr' true' expectedType);  case ILCode.Add_Ovf_Un:  	return InferArgumentsInAddition (expr' false' expectedType);  case ILCode.Sub_Ovf_Un:  	return InferArgumentsInSubtraction (expr' false' expectedType);  case ILCode.Mul_Ovf_Un:  case ILCode.Div_Un:  case ILCode.Rem_Un:  	return InferArgumentsInBinaryOperator (expr' false' expectedType);  case ILCode.Shl:  	if (forceInferChildren)  		InferTypeForExpression (expr.Arguments [1]' typeSystem.Int32);  	if (expectedType != null && (expectedType.MetadataType == MetadataType.Int32 || expectedType.MetadataType == MetadataType.UInt32 || expectedType.MetadataType == MetadataType.Int64 || expectedType.MetadataType == MetadataType.UInt64))  		return NumericPromotion (InferTypeForExpression (expr.Arguments [0]' expectedType));  	else  		return NumericPromotion (InferTypeForExpression (expr.Arguments [0]' null));  case ILCode.Shr:  case ILCode.Shr_Un: {  	if (forceInferChildren)  		InferTypeForExpression (expr.Arguments [1]' typeSystem.Int32);  	TypeReference type = NumericPromotion (InferTypeForExpression (expr.Arguments [0]' null));  	TypeReference expectedInputType = null;  	switch (type.MetadataType) {  	case MetadataType.Int32:  		if (expr.Code == ILCode.Shr_Un)  			expectedInputType = typeSystem.UInt32;  		break;  	case MetadataType.UInt32:  		if (expr.Code == ILCode.Shr)  			expectedInputType = typeSystem.Int32;  		break;  	case MetadataType.Int64:  		if (expr.Code == ILCode.Shr_Un)  			expectedInputType = typeSystem.UInt64;  		break;  	case MetadataType.UInt64:  		if (expr.Code == ILCode.Shr)  			expectedInputType = typeSystem.UInt64;  		break;  	}  	if (expectedInputType != null) {  		InferTypeForExpression (expr.Arguments [0]' expectedInputType);  		return expectedInputType;  	} else {  		return type;  	}  }  case ILCode.CompoundAssignment: {  	var op = expr.Arguments [0];  	if (op.Code == ILCode.NullableOf)  		op = op.Arguments [0].Arguments [0];  	var varType = InferTypeForExpression (op.Arguments [0]' null);  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' varType);  	}  	return varType;  }  #endregion  #region Constant loading instructions  case ILCode.Ldnull:  	return typeSystem.Object;  case ILCode.Ldstr:  	return typeSystem.String;  case ILCode.Ldftn:  case ILCode.Ldvirtftn:  	return typeSystem.IntPtr;  case ILCode.Ldc_I4:  	if (IsBoolean (expectedType) && ((int)expr.Operand == 0 || (int)expr.Operand == 1))  		return typeSystem.Boolean;  	if (expectedType is PointerType && (int)expr.Operand == 0)  		return expectedType;  	if (IsIntegerOrEnum (expectedType) && OperandFitsInType (expectedType' (int)expr.Operand))  		return expectedType;  	else  		return typeSystem.Int32;  case ILCode.Ldc_I8:  	if (expectedType is PointerType && (long)expr.Operand == 0)  		return expectedType;  	if (IsIntegerOrEnum (expectedType) && GetInformationAmount (expectedType) >= NativeInt)  		return expectedType;  	else  		return typeSystem.Int64;  case ILCode.Ldc_R4:  	return typeSystem.Single;  case ILCode.Ldc_R8:  	return typeSystem.Double;  case ILCode.Ldc_Decimal:  	return new TypeReference ("System"' "Decimal"' module' module.TypeSystem.CoreLibrary' true);  case ILCode.Ldtoken:  	if (expr.Operand is TypeReference)  		return new TypeReference ("System"' "RuntimeTypeHandle"' module' module.TypeSystem.CoreLibrary' true);  	else if (expr.Operand is FieldReference)  		return new TypeReference ("System"' "RuntimeFieldHandle"' module' module.TypeSystem.CoreLibrary' true);  	else  		return new TypeReference ("System"' "RuntimeMethodHandle"' module' module.TypeSystem.CoreLibrary' true);  case ILCode.Arglist:  	return new TypeReference ("System"' "RuntimeArgumentHandle"' module' module.TypeSystem.CoreLibrary' true);  #endregion  #region Array instructions  case ILCode.Newarr:  	if (forceInferChildren) {  		var lengthType = InferTypeForExpression (expr.Arguments.Single ()' null);  		if (lengthType == typeSystem.IntPtr) {  			lengthType = typeSystem.Int64;  		} else if (lengthType == typeSystem.UIntPtr) {  			lengthType = typeSystem.UInt64;  		} else if (lengthType != typeSystem.UInt32 && lengthType != typeSystem.Int64 && lengthType != typeSystem.UInt64) {  			lengthType = typeSystem.Int32;  		}  		if (forceInferChildren) {  			InferTypeForExpression (expr.Arguments.Single ()' lengthType);  		}  	}  	return new ArrayType ((TypeReference)expr.Operand);  case ILCode.InitArray:  	var operandAsArrayType = (ArrayType)expr.Operand;  	if (forceInferChildren) {  		foreach (ILExpression arg in expr.Arguments)  			InferTypeForExpression (arg' operandAsArrayType.ElementType);  	}  	return operandAsArrayType;  case ILCode.Ldlen:  	return typeSystem.Int32;  case ILCode.Ldelem_U1:  case ILCode.Ldelem_U2:  case ILCode.Ldelem_U4:  case ILCode.Ldelem_I1:  case ILCode.Ldelem_I2:  case ILCode.Ldelem_I4:  case ILCode.Ldelem_I8:  case ILCode.Ldelem_R4:  case ILCode.Ldelem_R8:  case ILCode.Ldelem_I:  case ILCode.Ldelem_Ref: {  	ArrayType arrayType = InferTypeForExpression (expr.Arguments [0]' null) as ArrayType;  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [1]' typeSystem.Int32);  	}  	return arrayType != null ? arrayType.ElementType : null;  }  case ILCode.Ldelem_Any:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [1]' typeSystem.Int32);  	}  	return (TypeReference)expr.Operand;  case ILCode.Ldelema: {  	ArrayType arrayType = InferTypeForExpression (expr.Arguments [0]' null) as ArrayType;  	if (forceInferChildren)  		InferTypeForExpression (expr.Arguments [1]' typeSystem.Int32);  	return arrayType != null ? new ByReferenceType (arrayType.ElementType) : null;  }  case ILCode.Stelem_I:  case ILCode.Stelem_I1:  case ILCode.Stelem_I2:  case ILCode.Stelem_I4:  case ILCode.Stelem_I8:  case ILCode.Stelem_R4:  case ILCode.Stelem_R8:  case ILCode.Stelem_Ref:  case ILCode.Stelem_Any: {  	ArrayType arrayType = InferTypeForExpression (expr.Arguments [0]' null) as ArrayType;  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [1]' typeSystem.Int32);  		if (arrayType != null) {  			InferTypeForExpression (expr.Arguments [2]' arrayType.ElementType);  		}  	}  	return arrayType != null ? arrayType.ElementType : null;  }  #endregion  #region Conversion instructions  case ILCode.Conv_I1:  case ILCode.Conv_Ovf_I1:  case ILCode.Conv_Ovf_I1_Un:  	return HandleConversion (8' true' expr.Arguments [0]' expectedType' typeSystem.SByte);  case ILCode.Conv_I2:  case ILCode.Conv_Ovf_I2:  case ILCode.Conv_Ovf_I2_Un:  	return HandleConversion (16' true' expr.Arguments [0]' expectedType' typeSystem.Int16);  case ILCode.Conv_I4:  case ILCode.Conv_Ovf_I4:  case ILCode.Conv_Ovf_I4_Un:  	return HandleConversion (32' true' expr.Arguments [0]' expectedType' typeSystem.Int32);  case ILCode.Conv_I8:  case ILCode.Conv_Ovf_I8:  case ILCode.Conv_Ovf_I8_Un:  	return HandleConversion (64' true' expr.Arguments [0]' expectedType' typeSystem.Int64);  case ILCode.Conv_U1:  case ILCode.Conv_Ovf_U1:  case ILCode.Conv_Ovf_U1_Un:  	return HandleConversion (8' false' expr.Arguments [0]' expectedType' typeSystem.Byte);  case ILCode.Conv_U2:  case ILCode.Conv_Ovf_U2:  case ILCode.Conv_Ovf_U2_Un:  	return HandleConversion (16' false' expr.Arguments [0]' expectedType' typeSystem.UInt16);  case ILCode.Conv_U4:  case ILCode.Conv_Ovf_U4:  case ILCode.Conv_Ovf_U4_Un:  	return HandleConversion (32' false' expr.Arguments [0]' expectedType' typeSystem.UInt32);  case ILCode.Conv_U8:  case ILCode.Conv_Ovf_U8:  case ILCode.Conv_Ovf_U8_Un:  	return HandleConversion (64' false' expr.Arguments [0]' expectedType' typeSystem.UInt64);  case ILCode.Conv_I:  case ILCode.Conv_Ovf_I:  case ILCode.Conv_Ovf_I_Un:  	return HandleConversion (NativeInt' true' expr.Arguments [0]' expectedType' typeSystem.IntPtr);  case ILCode.Conv_U:  case ILCode.Conv_Ovf_U:  case ILCode.Conv_Ovf_U_Un:  	return HandleConversion (NativeInt' false' expr.Arguments [0]' expectedType' typeSystem.UIntPtr);  case ILCode.Conv_R4:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' typeSystem.Single);  	}  	return typeSystem.Single;  case ILCode.Conv_R8:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' typeSystem.Double);  	}  	return typeSystem.Double;  case ILCode.Conv_R_Un:  	return (expectedType != null && expectedType.MetadataType == MetadataType.Single) ? typeSystem.Single : typeSystem.Double;  case ILCode.Castclass:  case ILCode.Unbox_Any:  	return (TypeReference)expr.Operand;  case ILCode.Unbox:  	return new ByReferenceType ((TypeReference)expr.Operand);  case ILCode.Isinst: {  	// isinst performs the equivalent of a cast only for reference types;  	// value types still need to be unboxed after an isinst instruction  	TypeReference tr = (TypeReference)expr.Operand;  	return tr.IsValueType ? typeSystem.Object : tr;  }  case ILCode.Box: {  	var tr = (TypeReference)expr.Operand;  	if (forceInferChildren)  		InferTypeForExpression (expr.Arguments.Single ()' tr);  	return tr.IsValueType ? typeSystem.Object : tr;  }  #endregion  #region Comparison instructions  case ILCode.Ceq:  case ILCode.Cne:  	if (forceInferChildren)  		InferArgumentsInBinaryOperator (expr' null' null);  	return typeSystem.Boolean;  case ILCode.Clt:  case ILCode.Cgt:  case ILCode.Cle:  case ILCode.Cge:  	if (forceInferChildren)  		InferArgumentsInBinaryOperator (expr' true' null);  	return typeSystem.Boolean;  case ILCode.Clt_Un:  case ILCode.Cgt_Un:  case ILCode.Cle_Un:  case ILCode.Cge_Un:  	if (forceInferChildren)  		InferArgumentsInBinaryOperator (expr' false' null);  	return typeSystem.Boolean;  #endregion  #region Branch instructions  case ILCode.Brtrue:  	if (forceInferChildren)  		InferTypeForExpression (expr.Arguments.Single ()' typeSystem.Boolean);  	return null;  case ILCode.Br:  case ILCode.Leave:  case ILCode.Endfinally:  case ILCode.Switch:  case ILCode.Throw:  case ILCode.Rethrow:  case ILCode.LoopOrSwitchBreak:  case ILCode.LoopContinue:  case ILCode.YieldBreak:  	return null;  case ILCode.Ret:  	if (forceInferChildren && expr.Arguments.Count == 1) {  		TypeReference returnType = context.CurrentMethod.ReturnType;  		if (context.CurrentMethodIsAsync && returnType != null && returnType.Namespace == "System.Threading.Tasks") {  			if (returnType.Name == "Task") {  				returnType = typeSystem.Void;  			} else if (returnType.Name == "Task`1" && returnType.IsGenericInstance) {  				returnType = ((GenericInstanceType)returnType).GenericArguments [0];  			}  		}  		InferTypeForExpression (expr.Arguments [0]' returnType);  	}  	return null;  case ILCode.YieldReturn:  	if (forceInferChildren) {  		GenericInstanceType genericType = context.CurrentMethod.ReturnType as GenericInstanceType;  		if (genericType != null) {  			// IEnumerable<T> or IEnumerator<T>  			InferTypeForExpression (expr.Arguments [0]' genericType.GenericArguments [0]);  		} else {  			// non-generic IEnumerable or IEnumerator  			InferTypeForExpression (expr.Arguments [0]' typeSystem.Object);  		}  	}  	return null;  case ILCode.Await: {  	TypeReference taskType = InferTypeForExpression (expr.Arguments [0]' null);  	if (taskType.Name == "Task`1" && taskType.IsGenericInstance && taskType.Namespace == "System.Threading.Tasks") {  		return ((GenericInstanceType)taskType).GenericArguments [0];  	}  	return null;  }  #endregion  case ILCode.Pop:  	return null;  case ILCode.Wrap:  case ILCode.Dup: {  	var arg = expr.Arguments.Single ();  	return arg.ExpectedType = InferTypeForExpression (arg' expectedType);  }  default:  	Debug.WriteLine ("Type Inference: Can't handle " + expr.Code.GetName ());  	return null;  }  
Magic Number,Custom.Decompiler.ILAst,TypeAnalysis,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\TypeAnalysis.cs,DoInferTypeForExpression,The following statement contains a magic number: switch (expr.Code) {  #region Logical operators  case ILCode.LogicNot:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments.Single ()' typeSystem.Boolean);  	}  	return typeSystem.Boolean;  case ILCode.LogicAnd:  case ILCode.LogicOr:  	// if Operand is set the logic and/or expression is a custom operator  	// we can deal with it the same as a normal invocation.  	if (expr.Operand != null)  		goto case ILCode.Call;  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' typeSystem.Boolean);  		InferTypeForExpression (expr.Arguments [1]' typeSystem.Boolean);  	}  	return typeSystem.Boolean;  case ILCode.TernaryOp:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' typeSystem.Boolean);  	}  	return InferBinaryArguments (expr.Arguments [1]' expr.Arguments [2]' expectedType' forceInferChildren);  case ILCode.NullCoalescing:  	return InferBinaryArguments (expr.Arguments [0]' expr.Arguments [1]' expectedType' forceInferChildren);  #endregion  #region Variable load/store  case ILCode.Stloc: {  	ILVariable v = (ILVariable)expr.Operand;  	if (forceInferChildren) {  		// do not use 'expectedType' in here!  		InferTypeForExpression (expr.Arguments.Single ()' v.Type);  	}  	return v.Type;  }  case ILCode.Ldloc: {  	ILVariable v = (ILVariable)expr.Operand;  	if (v.Type == null && singleLoadVariables.Contains (v)) {  		v.Type = expectedType;  	}  	return v.Type;  }  case ILCode.Ldloca: {  	ILVariable v = (ILVariable)expr.Operand;  	if (v.Type != null)  		return new ByReferenceType (v.Type);  	else  		return null;  }  #endregion  #region Call / NewObj  case ILCode.Call:  case ILCode.Callvirt:  case ILCode.CallGetter:  case ILCode.CallvirtGetter:  case ILCode.CallSetter:  case ILCode.CallvirtSetter: {  	MethodReference method = (MethodReference)expr.Operand;  	if (forceInferChildren) {  		for (int i = 0; i < expr.Arguments.Count; i++) {  			if (i == 0 && method.HasThis) {  				InferTypeForExpression (expr.Arguments [0]' MakeRefIfValueType (method.DeclaringType' expr.GetPrefix (ILCode.Constrained)));  			} else {  				InferTypeForExpression (expr.Arguments [i]' SubstituteTypeArgs (method.Parameters [method.HasThis ? i - 1 : i].ParameterType' method));  			}  		}  	}  	if (expr.Code == ILCode.CallSetter || expr.Code == ILCode.CallvirtSetter) {  		return SubstituteTypeArgs (method.Parameters.Last ().ParameterType' method);  	} else {  		return SubstituteTypeArgs (method.ReturnType' method);  	}  }  case ILCode.Newobj: {  	MethodReference ctor = (MethodReference)expr.Operand;  	if (forceInferChildren) {  		for (int i = 0; i < ctor.Parameters.Count; i++) {  			InferTypeForExpression (expr.Arguments [i]' SubstituteTypeArgs (ctor.Parameters [i].ParameterType' ctor));  		}  	}  	return ctor.DeclaringType;  }  case ILCode.InitObject:  case ILCode.InitCollection:  	return InferTypeForExpression (expr.Arguments [0]' expectedType);  case ILCode.InitializedObject:  	// expectedType should always be known due to the parent method call / property setter  	Debug.Assert (expectedType != null);  	return expectedType;  #endregion  #region Load/Store Fields  case ILCode.Ldfld:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' MakeRefIfValueType (((FieldReference)expr.Operand).DeclaringType' expr.GetPrefix (ILCode.Constrained)));  	}  	return GetFieldType ((FieldReference)expr.Operand);  case ILCode.Ldsfld:  	return GetFieldType ((FieldReference)expr.Operand);  case ILCode.Ldflda:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' MakeRefIfValueType (((FieldReference)expr.Operand).DeclaringType' expr.GetPrefix (ILCode.Constrained)));  	}  	return new ByReferenceType (GetFieldType ((FieldReference)expr.Operand));  case ILCode.Ldsflda:  	return new ByReferenceType (GetFieldType ((FieldReference)expr.Operand));  case ILCode.Stfld:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' MakeRefIfValueType (((FieldReference)expr.Operand).DeclaringType' expr.GetPrefix (ILCode.Constrained)));  		InferTypeForExpression (expr.Arguments [1]' GetFieldType ((FieldReference)expr.Operand));  	}  	return GetFieldType ((FieldReference)expr.Operand);  case ILCode.Stsfld:  	if (forceInferChildren)  		InferTypeForExpression (expr.Arguments [0]' GetFieldType ((FieldReference)expr.Operand));  	return GetFieldType ((FieldReference)expr.Operand);  #endregion  #region Reference/Pointer instructions  case ILCode.Ldind_Ref:  	return UnpackPointer (InferTypeForExpression (expr.Arguments [0]' null));  case ILCode.Stind_Ref:  	if (forceInferChildren) {  		TypeReference elementType = UnpackPointer (InferTypeForExpression (expr.Arguments [0]' null));  		InferTypeForExpression (expr.Arguments [1]' elementType);  	}  	return null;  case ILCode.Ldobj: {  	TypeReference type = (TypeReference)expr.Operand;  	var argType = InferTypeForExpression (expr.Arguments [0]' null);  	if (argType is PointerType || argType is ByReferenceType) {  		var elementType = ((TypeSpecification)argType).ElementType;  		int infoAmount = GetInformationAmount (elementType);  		if (infoAmount == 1 && GetInformationAmount (type) == 8) {  			// A bool can be loaded from both bytes and sbytes.  			type = elementType;  		}  		if (infoAmount >= 8 && infoAmount <= 64 && infoAmount == GetInformationAmount (type)) {  			// An integer can be loaded as another integer of the same size.  			// For integers smaller than 32 bit' the signs must match (as loading performs sign extension)  			bool? elementTypeIsSigned = IsSigned (elementType);  			bool? typeIsSigned = IsSigned (type);  			if (elementTypeIsSigned != null && typeIsSigned != null) {  				if (infoAmount >= 32 || elementTypeIsSigned == typeIsSigned)  					type = elementType;  			}  		}  	}  	if (argType is PointerType)  		InferTypeForExpression (expr.Arguments [0]' new PointerType (type));  	else  		InferTypeForExpression (expr.Arguments [0]' new ByReferenceType (type));  	return type;  }  case ILCode.Stobj: {  	TypeReference operandType = (TypeReference)expr.Operand;  	TypeReference pointerType = InferTypeForExpression (expr.Arguments [0]' new ByReferenceType (operandType));  	TypeReference elementType;  	if (pointerType is PointerType)  		elementType = ((PointerType)pointerType).ElementType;  	else if (pointerType is ByReferenceType)  		elementType = ((ByReferenceType)pointerType).ElementType;  	else  		elementType = null;  	if (elementType != null) {  		// An integer can be stored in any other integer of the same size.  		int infoAmount = GetInformationAmount (elementType);  		if (infoAmount == 1 && GetInformationAmount (operandType) == 8)  			operandType = elementType;  		else if (infoAmount == GetInformationAmount (operandType) && IsSigned (elementType) != null && IsSigned (operandType) != null)  			operandType = elementType;  	}  	if (forceInferChildren) {  		if (pointerType is PointerType)  			InferTypeForExpression (expr.Arguments [0]' new PointerType (operandType));  		else if (!IsSameType (operandType' expr.Operand as TypeReference))  			InferTypeForExpression (expr.Arguments [0]' new ByReferenceType (operandType));  		InferTypeForExpression (expr.Arguments [1]' operandType);  	}  	return operandType;  }  case ILCode.Initobj:  	return null;  case ILCode.DefaultValue:  	return (TypeReference)expr.Operand;  case ILCode.Localloc:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' typeSystem.Int32);  	}  	if (expectedType is PointerType)  		return expectedType;  	else  		return typeSystem.IntPtr;  case ILCode.Sizeof:  	return typeSystem.Int32;  case ILCode.PostIncrement:  case ILCode.PostIncrement_Ovf:  case ILCode.PostIncrement_Ovf_Un: {  	TypeReference elementType = UnpackPointer (InferTypeForExpression (expr.Arguments [0]' null));  	if (forceInferChildren && elementType != null) {  		// Assign expected type to the child expression  		InferTypeForExpression (expr.Arguments [0]' new ByReferenceType (elementType));  	}  	return elementType;  }  case ILCode.Mkrefany:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' (TypeReference)expr.Operand);  	}  	return typeSystem.TypedReference;  case ILCode.Refanytype:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' typeSystem.TypedReference);  	}  	return new TypeReference ("System"' "RuntimeTypeHandle"' module' module.TypeSystem.CoreLibrary' true);  case ILCode.Refanyval:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' typeSystem.TypedReference);  	}  	return new ByReferenceType ((TypeReference)expr.Operand);  case ILCode.AddressOf: {  	TypeReference t = InferTypeForExpression (expr.Arguments [0]' UnpackPointer (expectedType));  	return t != null ? new ByReferenceType (t) : null;  }  case ILCode.ValueOf:  	return GetNullableTypeArgument (InferTypeForExpression (expr.Arguments [0]' CreateNullableType (expectedType)));  case ILCode.NullableOf:  	return CreateNullableType (InferTypeForExpression (expr.Arguments [0]' GetNullableTypeArgument (expectedType)));  #endregion  #region Arithmetic instructions  case ILCode.Not:  // bitwise complement  case ILCode.Neg:  	return InferTypeForExpression (expr.Arguments.Single ()' expectedType);  case ILCode.Add:  	return InferArgumentsInAddition (expr' null' expectedType);  case ILCode.Sub:  	return InferArgumentsInSubtraction (expr' null' expectedType);  case ILCode.Mul:  case ILCode.Or:  case ILCode.And:  case ILCode.Xor:  	return InferArgumentsInBinaryOperator (expr' null' expectedType);  case ILCode.Add_Ovf:  	return InferArgumentsInAddition (expr' true' expectedType);  case ILCode.Sub_Ovf:  	return InferArgumentsInSubtraction (expr' true' expectedType);  case ILCode.Mul_Ovf:  case ILCode.Div:  case ILCode.Rem:  	return InferArgumentsInBinaryOperator (expr' true' expectedType);  case ILCode.Add_Ovf_Un:  	return InferArgumentsInAddition (expr' false' expectedType);  case ILCode.Sub_Ovf_Un:  	return InferArgumentsInSubtraction (expr' false' expectedType);  case ILCode.Mul_Ovf_Un:  case ILCode.Div_Un:  case ILCode.Rem_Un:  	return InferArgumentsInBinaryOperator (expr' false' expectedType);  case ILCode.Shl:  	if (forceInferChildren)  		InferTypeForExpression (expr.Arguments [1]' typeSystem.Int32);  	if (expectedType != null && (expectedType.MetadataType == MetadataType.Int32 || expectedType.MetadataType == MetadataType.UInt32 || expectedType.MetadataType == MetadataType.Int64 || expectedType.MetadataType == MetadataType.UInt64))  		return NumericPromotion (InferTypeForExpression (expr.Arguments [0]' expectedType));  	else  		return NumericPromotion (InferTypeForExpression (expr.Arguments [0]' null));  case ILCode.Shr:  case ILCode.Shr_Un: {  	if (forceInferChildren)  		InferTypeForExpression (expr.Arguments [1]' typeSystem.Int32);  	TypeReference type = NumericPromotion (InferTypeForExpression (expr.Arguments [0]' null));  	TypeReference expectedInputType = null;  	switch (type.MetadataType) {  	case MetadataType.Int32:  		if (expr.Code == ILCode.Shr_Un)  			expectedInputType = typeSystem.UInt32;  		break;  	case MetadataType.UInt32:  		if (expr.Code == ILCode.Shr)  			expectedInputType = typeSystem.Int32;  		break;  	case MetadataType.Int64:  		if (expr.Code == ILCode.Shr_Un)  			expectedInputType = typeSystem.UInt64;  		break;  	case MetadataType.UInt64:  		if (expr.Code == ILCode.Shr)  			expectedInputType = typeSystem.UInt64;  		break;  	}  	if (expectedInputType != null) {  		InferTypeForExpression (expr.Arguments [0]' expectedInputType);  		return expectedInputType;  	} else {  		return type;  	}  }  case ILCode.CompoundAssignment: {  	var op = expr.Arguments [0];  	if (op.Code == ILCode.NullableOf)  		op = op.Arguments [0].Arguments [0];  	var varType = InferTypeForExpression (op.Arguments [0]' null);  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' varType);  	}  	return varType;  }  #endregion  #region Constant loading instructions  case ILCode.Ldnull:  	return typeSystem.Object;  case ILCode.Ldstr:  	return typeSystem.String;  case ILCode.Ldftn:  case ILCode.Ldvirtftn:  	return typeSystem.IntPtr;  case ILCode.Ldc_I4:  	if (IsBoolean (expectedType) && ((int)expr.Operand == 0 || (int)expr.Operand == 1))  		return typeSystem.Boolean;  	if (expectedType is PointerType && (int)expr.Operand == 0)  		return expectedType;  	if (IsIntegerOrEnum (expectedType) && OperandFitsInType (expectedType' (int)expr.Operand))  		return expectedType;  	else  		return typeSystem.Int32;  case ILCode.Ldc_I8:  	if (expectedType is PointerType && (long)expr.Operand == 0)  		return expectedType;  	if (IsIntegerOrEnum (expectedType) && GetInformationAmount (expectedType) >= NativeInt)  		return expectedType;  	else  		return typeSystem.Int64;  case ILCode.Ldc_R4:  	return typeSystem.Single;  case ILCode.Ldc_R8:  	return typeSystem.Double;  case ILCode.Ldc_Decimal:  	return new TypeReference ("System"' "Decimal"' module' module.TypeSystem.CoreLibrary' true);  case ILCode.Ldtoken:  	if (expr.Operand is TypeReference)  		return new TypeReference ("System"' "RuntimeTypeHandle"' module' module.TypeSystem.CoreLibrary' true);  	else if (expr.Operand is FieldReference)  		return new TypeReference ("System"' "RuntimeFieldHandle"' module' module.TypeSystem.CoreLibrary' true);  	else  		return new TypeReference ("System"' "RuntimeMethodHandle"' module' module.TypeSystem.CoreLibrary' true);  case ILCode.Arglist:  	return new TypeReference ("System"' "RuntimeArgumentHandle"' module' module.TypeSystem.CoreLibrary' true);  #endregion  #region Array instructions  case ILCode.Newarr:  	if (forceInferChildren) {  		var lengthType = InferTypeForExpression (expr.Arguments.Single ()' null);  		if (lengthType == typeSystem.IntPtr) {  			lengthType = typeSystem.Int64;  		} else if (lengthType == typeSystem.UIntPtr) {  			lengthType = typeSystem.UInt64;  		} else if (lengthType != typeSystem.UInt32 && lengthType != typeSystem.Int64 && lengthType != typeSystem.UInt64) {  			lengthType = typeSystem.Int32;  		}  		if (forceInferChildren) {  			InferTypeForExpression (expr.Arguments.Single ()' lengthType);  		}  	}  	return new ArrayType ((TypeReference)expr.Operand);  case ILCode.InitArray:  	var operandAsArrayType = (ArrayType)expr.Operand;  	if (forceInferChildren) {  		foreach (ILExpression arg in expr.Arguments)  			InferTypeForExpression (arg' operandAsArrayType.ElementType);  	}  	return operandAsArrayType;  case ILCode.Ldlen:  	return typeSystem.Int32;  case ILCode.Ldelem_U1:  case ILCode.Ldelem_U2:  case ILCode.Ldelem_U4:  case ILCode.Ldelem_I1:  case ILCode.Ldelem_I2:  case ILCode.Ldelem_I4:  case ILCode.Ldelem_I8:  case ILCode.Ldelem_R4:  case ILCode.Ldelem_R8:  case ILCode.Ldelem_I:  case ILCode.Ldelem_Ref: {  	ArrayType arrayType = InferTypeForExpression (expr.Arguments [0]' null) as ArrayType;  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [1]' typeSystem.Int32);  	}  	return arrayType != null ? arrayType.ElementType : null;  }  case ILCode.Ldelem_Any:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [1]' typeSystem.Int32);  	}  	return (TypeReference)expr.Operand;  case ILCode.Ldelema: {  	ArrayType arrayType = InferTypeForExpression (expr.Arguments [0]' null) as ArrayType;  	if (forceInferChildren)  		InferTypeForExpression (expr.Arguments [1]' typeSystem.Int32);  	return arrayType != null ? new ByReferenceType (arrayType.ElementType) : null;  }  case ILCode.Stelem_I:  case ILCode.Stelem_I1:  case ILCode.Stelem_I2:  case ILCode.Stelem_I4:  case ILCode.Stelem_I8:  case ILCode.Stelem_R4:  case ILCode.Stelem_R8:  case ILCode.Stelem_Ref:  case ILCode.Stelem_Any: {  	ArrayType arrayType = InferTypeForExpression (expr.Arguments [0]' null) as ArrayType;  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [1]' typeSystem.Int32);  		if (arrayType != null) {  			InferTypeForExpression (expr.Arguments [2]' arrayType.ElementType);  		}  	}  	return arrayType != null ? arrayType.ElementType : null;  }  #endregion  #region Conversion instructions  case ILCode.Conv_I1:  case ILCode.Conv_Ovf_I1:  case ILCode.Conv_Ovf_I1_Un:  	return HandleConversion (8' true' expr.Arguments [0]' expectedType' typeSystem.SByte);  case ILCode.Conv_I2:  case ILCode.Conv_Ovf_I2:  case ILCode.Conv_Ovf_I2_Un:  	return HandleConversion (16' true' expr.Arguments [0]' expectedType' typeSystem.Int16);  case ILCode.Conv_I4:  case ILCode.Conv_Ovf_I4:  case ILCode.Conv_Ovf_I4_Un:  	return HandleConversion (32' true' expr.Arguments [0]' expectedType' typeSystem.Int32);  case ILCode.Conv_I8:  case ILCode.Conv_Ovf_I8:  case ILCode.Conv_Ovf_I8_Un:  	return HandleConversion (64' true' expr.Arguments [0]' expectedType' typeSystem.Int64);  case ILCode.Conv_U1:  case ILCode.Conv_Ovf_U1:  case ILCode.Conv_Ovf_U1_Un:  	return HandleConversion (8' false' expr.Arguments [0]' expectedType' typeSystem.Byte);  case ILCode.Conv_U2:  case ILCode.Conv_Ovf_U2:  case ILCode.Conv_Ovf_U2_Un:  	return HandleConversion (16' false' expr.Arguments [0]' expectedType' typeSystem.UInt16);  case ILCode.Conv_U4:  case ILCode.Conv_Ovf_U4:  case ILCode.Conv_Ovf_U4_Un:  	return HandleConversion (32' false' expr.Arguments [0]' expectedType' typeSystem.UInt32);  case ILCode.Conv_U8:  case ILCode.Conv_Ovf_U8:  case ILCode.Conv_Ovf_U8_Un:  	return HandleConversion (64' false' expr.Arguments [0]' expectedType' typeSystem.UInt64);  case ILCode.Conv_I:  case ILCode.Conv_Ovf_I:  case ILCode.Conv_Ovf_I_Un:  	return HandleConversion (NativeInt' true' expr.Arguments [0]' expectedType' typeSystem.IntPtr);  case ILCode.Conv_U:  case ILCode.Conv_Ovf_U:  case ILCode.Conv_Ovf_U_Un:  	return HandleConversion (NativeInt' false' expr.Arguments [0]' expectedType' typeSystem.UIntPtr);  case ILCode.Conv_R4:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' typeSystem.Single);  	}  	return typeSystem.Single;  case ILCode.Conv_R8:  	if (forceInferChildren) {  		InferTypeForExpression (expr.Arguments [0]' typeSystem.Double);  	}  	return typeSystem.Double;  case ILCode.Conv_R_Un:  	return (expectedType != null && expectedType.MetadataType == MetadataType.Single) ? typeSystem.Single : typeSystem.Double;  case ILCode.Castclass:  case ILCode.Unbox_Any:  	return (TypeReference)expr.Operand;  case ILCode.Unbox:  	return new ByReferenceType ((TypeReference)expr.Operand);  case ILCode.Isinst: {  	// isinst performs the equivalent of a cast only for reference types;  	// value types still need to be unboxed after an isinst instruction  	TypeReference tr = (TypeReference)expr.Operand;  	return tr.IsValueType ? typeSystem.Object : tr;  }  case ILCode.Box: {  	var tr = (TypeReference)expr.Operand;  	if (forceInferChildren)  		InferTypeForExpression (expr.Arguments.Single ()' tr);  	return tr.IsValueType ? typeSystem.Object : tr;  }  #endregion  #region Comparison instructions  case ILCode.Ceq:  case ILCode.Cne:  	if (forceInferChildren)  		InferArgumentsInBinaryOperator (expr' null' null);  	return typeSystem.Boolean;  case ILCode.Clt:  case ILCode.Cgt:  case ILCode.Cle:  case ILCode.Cge:  	if (forceInferChildren)  		InferArgumentsInBinaryOperator (expr' true' null);  	return typeSystem.Boolean;  case ILCode.Clt_Un:  case ILCode.Cgt_Un:  case ILCode.Cle_Un:  case ILCode.Cge_Un:  	if (forceInferChildren)  		InferArgumentsInBinaryOperator (expr' false' null);  	return typeSystem.Boolean;  #endregion  #region Branch instructions  case ILCode.Brtrue:  	if (forceInferChildren)  		InferTypeForExpression (expr.Arguments.Single ()' typeSystem.Boolean);  	return null;  case ILCode.Br:  case ILCode.Leave:  case ILCode.Endfinally:  case ILCode.Switch:  case ILCode.Throw:  case ILCode.Rethrow:  case ILCode.LoopOrSwitchBreak:  case ILCode.LoopContinue:  case ILCode.YieldBreak:  	return null;  case ILCode.Ret:  	if (forceInferChildren && expr.Arguments.Count == 1) {  		TypeReference returnType = context.CurrentMethod.ReturnType;  		if (context.CurrentMethodIsAsync && returnType != null && returnType.Namespace == "System.Threading.Tasks") {  			if (returnType.Name == "Task") {  				returnType = typeSystem.Void;  			} else if (returnType.Name == "Task`1" && returnType.IsGenericInstance) {  				returnType = ((GenericInstanceType)returnType).GenericArguments [0];  			}  		}  		InferTypeForExpression (expr.Arguments [0]' returnType);  	}  	return null;  case ILCode.YieldReturn:  	if (forceInferChildren) {  		GenericInstanceType genericType = context.CurrentMethod.ReturnType as GenericInstanceType;  		if (genericType != null) {  			// IEnumerable<T> or IEnumerator<T>  			InferTypeForExpression (expr.Arguments [0]' genericType.GenericArguments [0]);  		} else {  			// non-generic IEnumerable or IEnumerator  			InferTypeForExpression (expr.Arguments [0]' typeSystem.Object);  		}  	}  	return null;  case ILCode.Await: {  	TypeReference taskType = InferTypeForExpression (expr.Arguments [0]' null);  	if (taskType.Name == "Task`1" && taskType.IsGenericInstance && taskType.Namespace == "System.Threading.Tasks") {  		return ((GenericInstanceType)taskType).GenericArguments [0];  	}  	return null;  }  #endregion  case ILCode.Pop:  	return null;  case ILCode.Wrap:  case ILCode.Dup: {  	var arg = expr.Arguments.Single ();  	return arg.ExpectedType = InferTypeForExpression (arg' expectedType);  }  default:  	Debug.WriteLine ("Type Inference: Can't handle " + expr.Code.GetName ());  	return null;  }  
Magic Number,Custom.Decompiler.ILAst,TypeAnalysis,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\TypeAnalysis.cs,DoInferTypeForExpression,The following statement contains a magic number: return InferBinaryArguments (expr.Arguments [1]' expr.Arguments [2]' expectedType' forceInferChildren);  
Magic Number,Custom.Decompiler.ILAst,TypeAnalysis,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\TypeAnalysis.cs,DoInferTypeForExpression,The following statement contains a magic number: if (argType is PointerType || argType is ByReferenceType) {  	var elementType = ((TypeSpecification)argType).ElementType;  	int infoAmount = GetInformationAmount (elementType);  	if (infoAmount == 1 && GetInformationAmount (type) == 8) {  		// A bool can be loaded from both bytes and sbytes.  		type = elementType;  	}  	if (infoAmount >= 8 && infoAmount <= 64 && infoAmount == GetInformationAmount (type)) {  		// An integer can be loaded as another integer of the same size.  		// For integers smaller than 32 bit' the signs must match (as loading performs sign extension)  		bool? elementTypeIsSigned = IsSigned (elementType);  		bool? typeIsSigned = IsSigned (type);  		if (elementTypeIsSigned != null && typeIsSigned != null) {  			if (infoAmount >= 32 || elementTypeIsSigned == typeIsSigned)  				type = elementType;  		}  	}  }  
Magic Number,Custom.Decompiler.ILAst,TypeAnalysis,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\TypeAnalysis.cs,DoInferTypeForExpression,The following statement contains a magic number: if (argType is PointerType || argType is ByReferenceType) {  	var elementType = ((TypeSpecification)argType).ElementType;  	int infoAmount = GetInformationAmount (elementType);  	if (infoAmount == 1 && GetInformationAmount (type) == 8) {  		// A bool can be loaded from both bytes and sbytes.  		type = elementType;  	}  	if (infoAmount >= 8 && infoAmount <= 64 && infoAmount == GetInformationAmount (type)) {  		// An integer can be loaded as another integer of the same size.  		// For integers smaller than 32 bit' the signs must match (as loading performs sign extension)  		bool? elementTypeIsSigned = IsSigned (elementType);  		bool? typeIsSigned = IsSigned (type);  		if (elementTypeIsSigned != null && typeIsSigned != null) {  			if (infoAmount >= 32 || elementTypeIsSigned == typeIsSigned)  				type = elementType;  		}  	}  }  
Magic Number,Custom.Decompiler.ILAst,TypeAnalysis,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\TypeAnalysis.cs,DoInferTypeForExpression,The following statement contains a magic number: if (argType is PointerType || argType is ByReferenceType) {  	var elementType = ((TypeSpecification)argType).ElementType;  	int infoAmount = GetInformationAmount (elementType);  	if (infoAmount == 1 && GetInformationAmount (type) == 8) {  		// A bool can be loaded from both bytes and sbytes.  		type = elementType;  	}  	if (infoAmount >= 8 && infoAmount <= 64 && infoAmount == GetInformationAmount (type)) {  		// An integer can be loaded as another integer of the same size.  		// For integers smaller than 32 bit' the signs must match (as loading performs sign extension)  		bool? elementTypeIsSigned = IsSigned (elementType);  		bool? typeIsSigned = IsSigned (type);  		if (elementTypeIsSigned != null && typeIsSigned != null) {  			if (infoAmount >= 32 || elementTypeIsSigned == typeIsSigned)  				type = elementType;  		}  	}  }  
Magic Number,Custom.Decompiler.ILAst,TypeAnalysis,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\TypeAnalysis.cs,DoInferTypeForExpression,The following statement contains a magic number: if (argType is PointerType || argType is ByReferenceType) {  	var elementType = ((TypeSpecification)argType).ElementType;  	int infoAmount = GetInformationAmount (elementType);  	if (infoAmount == 1 && GetInformationAmount (type) == 8) {  		// A bool can be loaded from both bytes and sbytes.  		type = elementType;  	}  	if (infoAmount >= 8 && infoAmount <= 64 && infoAmount == GetInformationAmount (type)) {  		// An integer can be loaded as another integer of the same size.  		// For integers smaller than 32 bit' the signs must match (as loading performs sign extension)  		bool? elementTypeIsSigned = IsSigned (elementType);  		bool? typeIsSigned = IsSigned (type);  		if (elementTypeIsSigned != null && typeIsSigned != null) {  			if (infoAmount >= 32 || elementTypeIsSigned == typeIsSigned)  				type = elementType;  		}  	}  }  
Magic Number,Custom.Decompiler.ILAst,TypeAnalysis,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\TypeAnalysis.cs,DoInferTypeForExpression,The following statement contains a magic number: if (infoAmount == 1 && GetInformationAmount (type) == 8) {  	// A bool can be loaded from both bytes and sbytes.  	type = elementType;  }  
Magic Number,Custom.Decompiler.ILAst,TypeAnalysis,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\TypeAnalysis.cs,DoInferTypeForExpression,The following statement contains a magic number: if (infoAmount >= 8 && infoAmount <= 64 && infoAmount == GetInformationAmount (type)) {  	// An integer can be loaded as another integer of the same size.  	// For integers smaller than 32 bit' the signs must match (as loading performs sign extension)  	bool? elementTypeIsSigned = IsSigned (elementType);  	bool? typeIsSigned = IsSigned (type);  	if (elementTypeIsSigned != null && typeIsSigned != null) {  		if (infoAmount >= 32 || elementTypeIsSigned == typeIsSigned)  			type = elementType;  	}  }  
Magic Number,Custom.Decompiler.ILAst,TypeAnalysis,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\TypeAnalysis.cs,DoInferTypeForExpression,The following statement contains a magic number: if (infoAmount >= 8 && infoAmount <= 64 && infoAmount == GetInformationAmount (type)) {  	// An integer can be loaded as another integer of the same size.  	// For integers smaller than 32 bit' the signs must match (as loading performs sign extension)  	bool? elementTypeIsSigned = IsSigned (elementType);  	bool? typeIsSigned = IsSigned (type);  	if (elementTypeIsSigned != null && typeIsSigned != null) {  		if (infoAmount >= 32 || elementTypeIsSigned == typeIsSigned)  			type = elementType;  	}  }  
Magic Number,Custom.Decompiler.ILAst,TypeAnalysis,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\TypeAnalysis.cs,DoInferTypeForExpression,The following statement contains a magic number: if (infoAmount >= 8 && infoAmount <= 64 && infoAmount == GetInformationAmount (type)) {  	// An integer can be loaded as another integer of the same size.  	// For integers smaller than 32 bit' the signs must match (as loading performs sign extension)  	bool? elementTypeIsSigned = IsSigned (elementType);  	bool? typeIsSigned = IsSigned (type);  	if (elementTypeIsSigned != null && typeIsSigned != null) {  		if (infoAmount >= 32 || elementTypeIsSigned == typeIsSigned)  			type = elementType;  	}  }  
Magic Number,Custom.Decompiler.ILAst,TypeAnalysis,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\TypeAnalysis.cs,DoInferTypeForExpression,The following statement contains a magic number: if (elementTypeIsSigned != null && typeIsSigned != null) {  	if (infoAmount >= 32 || elementTypeIsSigned == typeIsSigned)  		type = elementType;  }  
Magic Number,Custom.Decompiler.ILAst,TypeAnalysis,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\TypeAnalysis.cs,DoInferTypeForExpression,The following statement contains a magic number: if (infoAmount >= 32 || elementTypeIsSigned == typeIsSigned)  	type = elementType;  
Magic Number,Custom.Decompiler.ILAst,TypeAnalysis,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\TypeAnalysis.cs,DoInferTypeForExpression,The following statement contains a magic number: if (elementType != null) {  	// An integer can be stored in any other integer of the same size.  	int infoAmount = GetInformationAmount (elementType);  	if (infoAmount == 1 && GetInformationAmount (operandType) == 8)  		operandType = elementType;  	else if (infoAmount == GetInformationAmount (operandType) && IsSigned (elementType) != null && IsSigned (operandType) != null)  		operandType = elementType;  }  
Magic Number,Custom.Decompiler.ILAst,TypeAnalysis,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\TypeAnalysis.cs,DoInferTypeForExpression,The following statement contains a magic number: if (infoAmount == 1 && GetInformationAmount (operandType) == 8)  	operandType = elementType;  else if (infoAmount == GetInformationAmount (operandType) && IsSigned (elementType) != null && IsSigned (operandType) != null)  	operandType = elementType;  
Magic Number,Custom.Decompiler.ILAst,TypeAnalysis,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\TypeAnalysis.cs,DoInferTypeForExpression,The following statement contains a magic number: if (forceInferChildren) {  	InferTypeForExpression (expr.Arguments [1]' typeSystem.Int32);  	if (arrayType != null) {  		InferTypeForExpression (expr.Arguments [2]' arrayType.ElementType);  	}  }  
Magic Number,Custom.Decompiler.ILAst,TypeAnalysis,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\TypeAnalysis.cs,DoInferTypeForExpression,The following statement contains a magic number: if (arrayType != null) {  	InferTypeForExpression (expr.Arguments [2]' arrayType.ElementType);  }  
Magic Number,Custom.Decompiler.ILAst,TypeAnalysis,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\TypeAnalysis.cs,DoInferTypeForExpression,The following statement contains a magic number: InferTypeForExpression (expr.Arguments [2]' arrayType.ElementType);  
Magic Number,Custom.Decompiler.ILAst,TypeAnalysis,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\TypeAnalysis.cs,DoInferTypeForExpression,The following statement contains a magic number: return HandleConversion (8' true' expr.Arguments [0]' expectedType' typeSystem.SByte);  
Magic Number,Custom.Decompiler.ILAst,TypeAnalysis,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\TypeAnalysis.cs,DoInferTypeForExpression,The following statement contains a magic number: return HandleConversion (16' true' expr.Arguments [0]' expectedType' typeSystem.Int16);  
Magic Number,Custom.Decompiler.ILAst,TypeAnalysis,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\TypeAnalysis.cs,DoInferTypeForExpression,The following statement contains a magic number: return HandleConversion (32' true' expr.Arguments [0]' expectedType' typeSystem.Int32);  
Magic Number,Custom.Decompiler.ILAst,TypeAnalysis,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\TypeAnalysis.cs,DoInferTypeForExpression,The following statement contains a magic number: return HandleConversion (64' true' expr.Arguments [0]' expectedType' typeSystem.Int64);  
Magic Number,Custom.Decompiler.ILAst,TypeAnalysis,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\TypeAnalysis.cs,DoInferTypeForExpression,The following statement contains a magic number: return HandleConversion (8' false' expr.Arguments [0]' expectedType' typeSystem.Byte);  
Magic Number,Custom.Decompiler.ILAst,TypeAnalysis,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\TypeAnalysis.cs,DoInferTypeForExpression,The following statement contains a magic number: return HandleConversion (16' false' expr.Arguments [0]' expectedType' typeSystem.UInt16);  
Magic Number,Custom.Decompiler.ILAst,TypeAnalysis,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\TypeAnalysis.cs,DoInferTypeForExpression,The following statement contains a magic number: return HandleConversion (32' false' expr.Arguments [0]' expectedType' typeSystem.UInt32);  
Magic Number,Custom.Decompiler.ILAst,TypeAnalysis,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\TypeAnalysis.cs,DoInferTypeForExpression,The following statement contains a magic number: return HandleConversion (64' false' expr.Arguments [0]' expectedType' typeSystem.UInt64);  
Magic Number,Custom.Decompiler.ILAst,TypeAnalysis,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\TypeAnalysis.cs,GetInformationAmount,The following statement contains a magic number: switch (type.MetadataType) {  case MetadataType.Void:  	return 0;  case MetadataType.Boolean:  	return 1;  case MetadataType.SByte:  case MetadataType.Byte:  	return 8;  case MetadataType.Char:  case MetadataType.Int16:  case MetadataType.UInt16:  	return 16;  case MetadataType.Int32:  case MetadataType.UInt32:  case MetadataType.Single:  	return 32;  case MetadataType.Int64:  case MetadataType.UInt64:  case MetadataType.Double:  	return 64;  case MetadataType.IntPtr:  case MetadataType.UIntPtr:  	return NativeInt;  default:  	return 100;  // we consider structs/objects to have more information than any primitives  }  
Magic Number,Custom.Decompiler.ILAst,TypeAnalysis,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\TypeAnalysis.cs,GetInformationAmount,The following statement contains a magic number: switch (type.MetadataType) {  case MetadataType.Void:  	return 0;  case MetadataType.Boolean:  	return 1;  case MetadataType.SByte:  case MetadataType.Byte:  	return 8;  case MetadataType.Char:  case MetadataType.Int16:  case MetadataType.UInt16:  	return 16;  case MetadataType.Int32:  case MetadataType.UInt32:  case MetadataType.Single:  	return 32;  case MetadataType.Int64:  case MetadataType.UInt64:  case MetadataType.Double:  	return 64;  case MetadataType.IntPtr:  case MetadataType.UIntPtr:  	return NativeInt;  default:  	return 100;  // we consider structs/objects to have more information than any primitives  }  
Magic Number,Custom.Decompiler.ILAst,TypeAnalysis,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\TypeAnalysis.cs,GetInformationAmount,The following statement contains a magic number: switch (type.MetadataType) {  case MetadataType.Void:  	return 0;  case MetadataType.Boolean:  	return 1;  case MetadataType.SByte:  case MetadataType.Byte:  	return 8;  case MetadataType.Char:  case MetadataType.Int16:  case MetadataType.UInt16:  	return 16;  case MetadataType.Int32:  case MetadataType.UInt32:  case MetadataType.Single:  	return 32;  case MetadataType.Int64:  case MetadataType.UInt64:  case MetadataType.Double:  	return 64;  case MetadataType.IntPtr:  case MetadataType.UIntPtr:  	return NativeInt;  default:  	return 100;  // we consider structs/objects to have more information than any primitives  }  
Magic Number,Custom.Decompiler.ILAst,TypeAnalysis,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\TypeAnalysis.cs,GetInformationAmount,The following statement contains a magic number: switch (type.MetadataType) {  case MetadataType.Void:  	return 0;  case MetadataType.Boolean:  	return 1;  case MetadataType.SByte:  case MetadataType.Byte:  	return 8;  case MetadataType.Char:  case MetadataType.Int16:  case MetadataType.UInt16:  	return 16;  case MetadataType.Int32:  case MetadataType.UInt32:  case MetadataType.Single:  	return 32;  case MetadataType.Int64:  case MetadataType.UInt64:  case MetadataType.Double:  	return 64;  case MetadataType.IntPtr:  case MetadataType.UIntPtr:  	return NativeInt;  default:  	return 100;  // we consider structs/objects to have more information than any primitives  }  
Magic Number,Custom.Decompiler.ILAst,TypeAnalysis,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\TypeAnalysis.cs,GetInformationAmount,The following statement contains a magic number: switch (type.MetadataType) {  case MetadataType.Void:  	return 0;  case MetadataType.Boolean:  	return 1;  case MetadataType.SByte:  case MetadataType.Byte:  	return 8;  case MetadataType.Char:  case MetadataType.Int16:  case MetadataType.UInt16:  	return 16;  case MetadataType.Int32:  case MetadataType.UInt32:  case MetadataType.Single:  	return 32;  case MetadataType.Int64:  case MetadataType.UInt64:  case MetadataType.Double:  	return 64;  case MetadataType.IntPtr:  case MetadataType.UIntPtr:  	return NativeInt;  default:  	return 100;  // we consider structs/objects to have more information than any primitives  }  
Magic Number,Custom.Decompiler.ILAst,TypeAnalysis,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\TypeAnalysis.cs,GetInformationAmount,The following statement contains a magic number: return 8;  
Magic Number,Custom.Decompiler.ILAst,TypeAnalysis,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\TypeAnalysis.cs,GetInformationAmount,The following statement contains a magic number: return 16;  
Magic Number,Custom.Decompiler.ILAst,TypeAnalysis,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\TypeAnalysis.cs,GetInformationAmount,The following statement contains a magic number: return 32;  
Magic Number,Custom.Decompiler.ILAst,TypeAnalysis,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\TypeAnalysis.cs,GetInformationAmount,The following statement contains a magic number: return 64;  
Magic Number,Custom.Decompiler.ILAst,TypeAnalysis,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\TypeAnalysis.cs,GetInformationAmount,The following statement contains a magic number: return 100;  
Magic Number,Custom.Decompiler.ILAst,YieldReturnDecompiler,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\YieldReturnDecompiler.cs,MatchEnumeratorCreationNewObj,The following statement contains a magic number: if (!(initialState == -2 || initialState == 0))  	return false;  
Magic Number,Custom.Decompiler.ILAst,YieldReturnDecompiler,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\YieldReturnDecompiler.cs,AnalyzeCurrentProperty,The following statement contains a magic number: if (method.Body.Count == 1) {  	// release builds directly return the current field  	ILExpression retExpr;  	FieldReference field;  	ILExpression ldFromObj;  	if (method.Body [0].Match (ILCode.Ret' out retExpr) && retExpr.Match (ILCode.Ldfld' out field' out ldFromObj) && ldFromObj.MatchThis ()) {  		currentField = GetFieldDefinition (field);  	}  } else if (method.Body.Count == 2) {  	ILVariable v' v2;  	ILExpression stExpr;  	FieldReference field;  	ILExpression ldFromObj;  	ILExpression retExpr;  	if (method.Body [0].Match (ILCode.Stloc' out v' out stExpr) && stExpr.Match (ILCode.Ldfld' out field' out ldFromObj) && ldFromObj.MatchThis () && method.Body [1].Match (ILCode.Ret' out retExpr) && retExpr.Match (ILCode.Ldloc' out v2) && v == v2) {  		currentField = GetFieldDefinition (field);  	}  }  
Magic Number,Custom.Decompiler.ILAst,YieldReturnDecompiler,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\YieldReturnDecompiler.cs,AnalyzeCurrentProperty,The following statement contains a magic number: if (method.Body.Count == 2) {  	ILVariable v' v2;  	ILExpression stExpr;  	FieldReference field;  	ILExpression ldFromObj;  	ILExpression retExpr;  	if (method.Body [0].Match (ILCode.Stloc' out v' out stExpr) && stExpr.Match (ILCode.Ldfld' out field' out ldFromObj) && ldFromObj.MatchThis () && method.Body [1].Match (ILCode.Ret' out retExpr) && retExpr.Match (ILCode.Ldloc' out v2) && v == v2) {  		currentField = GetFieldDefinition (field);  	}  }  
Magic Number,Custom.Decompiler.ILAst,YieldReturnDecompiler,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\YieldReturnDecompiler.cs,ConstructExceptionTable,The following statement contains a magic number: foreach (var tryFinally in ilMethod.GetSelfAndChildrenRecursive<ILTryCatchBlock> ()) {  	Interval interval = rangeAnalysis.ranges [tryFinally.TryBlock.Body [0]].ToEnclosingInterval ();  	var finallyBody = tryFinally.FinallyBlock.Body;  	if (finallyBody.Count != 2)  		throw new SymbolicAnalysisFailedException ();  	ILExpression call = finallyBody [0] as ILExpression;  	if (call == null || call.Code != ILCode.Call || call.Arguments.Count != 1)  		throw new SymbolicAnalysisFailedException ();  	if (!call.Arguments [0].MatchThis ())  		throw new SymbolicAnalysisFailedException ();  	if (!finallyBody [1].Match (ILCode.Endfinally))  		throw new SymbolicAnalysisFailedException ();  	MethodDefinition mdef = GetMethodDefinition (call.Operand as MethodReference);  	if (mdef == null || finallyMethodToStateInterval.ContainsKey (mdef))  		throw new SymbolicAnalysisFailedException ();  	finallyMethodToStateInterval.Add (mdef' interval);  }  
Magic Number,Custom.Decompiler.ILAst,YieldReturnDecompiler,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\YieldReturnDecompiler.cs,ConstructExceptionTable,The following statement contains a magic number: if (finallyBody.Count != 2)  	throw new SymbolicAnalysisFailedException ();  
Magic Number,Custom.Decompiler.ILAst,YieldReturnDecompiler,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\YieldReturnDecompiler.cs,AnalyzeMoveNext,The following statement contains a magic number: if (lastReturnArg.Code == ILCode.Ldloc) {  	// a) the compiler uses a variable for returns (in debug builds' or when there are try-finally blocks)  	returnVariable = (ILVariable)lastReturnArg.Operand;  	returnLabel = ilMethod.Body.ElementAtOrDefault (ilMethod.Body.Count - 2) as ILLabel;  	if (returnLabel == null)  		throw new SymbolicAnalysisFailedException ();  } else {  	// b) the compiler directly returns constants  	returnVariable = null;  	returnLabel = null;  	// In this case' the last return must return false.  	if (lastReturnArg.Code != ILCode.Ldc_I4 || (int)lastReturnArg.Operand != 0)  		throw new SymbolicAnalysisFailedException ();  }  
Magic Number,Custom.Decompiler.ILAst,YieldReturnDecompiler,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\YieldReturnDecompiler.cs,AnalyzeMoveNext,The following statement contains a magic number: returnLabel = ilMethod.Body.ElementAtOrDefault (ilMethod.Body.Count - 2) as ILLabel;  
Magic Number,Custom.Decompiler.ILAst,YieldReturnDecompiler,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\YieldReturnDecompiler.cs,AnalyzeMoveNext,The following statement contains a magic number: if (tryFaultBlock != null) {  	// there are try-finally blocks  	if (returnVariable == null)  		// in this case' we must use a return variable  		throw new SymbolicAnalysisFailedException ();  	// must be a try-fault block:  	if (tryFaultBlock.CatchBlocks.Count != 0 || tryFaultBlock.FinallyBlock != null || tryFaultBlock.FaultBlock == null)  		throw new SymbolicAnalysisFailedException ();  	ILBlock faultBlock = tryFaultBlock.FaultBlock;  	// Ensure the fault block contains the call to Dispose().  	if (faultBlock.Body.Count != 2)  		throw new SymbolicAnalysisFailedException ();  	MethodReference disposeMethodRef;  	ILExpression disposeArg;  	if (!faultBlock.Body [0].Match (ILCode.Call' out disposeMethodRef' out disposeArg))  		throw new SymbolicAnalysisFailedException ();  	if (GetMethodDefinition (disposeMethodRef) != disposeMethod || !disposeArg.MatchThis ())  		throw new SymbolicAnalysisFailedException ();  	if (!faultBlock.Body [1].Match (ILCode.Endfinally))  		throw new SymbolicAnalysisFailedException ();  	body = tryFaultBlock.TryBlock.Body;  	bodyLength = body.Count;  } else {  	// no try-finally blocks  	body = ilMethod.Body;  	if (returnVariable == null)  		bodyLength = body.Count - 1;  	// all except for the return statement  	else  		bodyLength = body.Count - 2;  	// all except for the return label and statement  }  
Magic Number,Custom.Decompiler.ILAst,YieldReturnDecompiler,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\YieldReturnDecompiler.cs,AnalyzeMoveNext,The following statement contains a magic number: if (tryFaultBlock != null) {  	// there are try-finally blocks  	if (returnVariable == null)  		// in this case' we must use a return variable  		throw new SymbolicAnalysisFailedException ();  	// must be a try-fault block:  	if (tryFaultBlock.CatchBlocks.Count != 0 || tryFaultBlock.FinallyBlock != null || tryFaultBlock.FaultBlock == null)  		throw new SymbolicAnalysisFailedException ();  	ILBlock faultBlock = tryFaultBlock.FaultBlock;  	// Ensure the fault block contains the call to Dispose().  	if (faultBlock.Body.Count != 2)  		throw new SymbolicAnalysisFailedException ();  	MethodReference disposeMethodRef;  	ILExpression disposeArg;  	if (!faultBlock.Body [0].Match (ILCode.Call' out disposeMethodRef' out disposeArg))  		throw new SymbolicAnalysisFailedException ();  	if (GetMethodDefinition (disposeMethodRef) != disposeMethod || !disposeArg.MatchThis ())  		throw new SymbolicAnalysisFailedException ();  	if (!faultBlock.Body [1].Match (ILCode.Endfinally))  		throw new SymbolicAnalysisFailedException ();  	body = tryFaultBlock.TryBlock.Body;  	bodyLength = body.Count;  } else {  	// no try-finally blocks  	body = ilMethod.Body;  	if (returnVariable == null)  		bodyLength = body.Count - 1;  	// all except for the return statement  	else  		bodyLength = body.Count - 2;  	// all except for the return label and statement  }  
Magic Number,Custom.Decompiler.ILAst,YieldReturnDecompiler,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\YieldReturnDecompiler.cs,AnalyzeMoveNext,The following statement contains a magic number: if (faultBlock.Body.Count != 2)  	throw new SymbolicAnalysisFailedException ();  
Magic Number,Custom.Decompiler.ILAst,YieldReturnDecompiler,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\YieldReturnDecompiler.cs,AnalyzeMoveNext,The following statement contains a magic number: if (returnVariable == null)  	bodyLength = body.Count - 1;  // all except for the return statement  else  	bodyLength = body.Count - 2;  
Magic Number,Custom.Decompiler.ILAst,YieldReturnDecompiler,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\YieldReturnDecompiler.cs,AnalyzeMoveNext,The following statement contains a magic number: bodyLength = body.Count - 2;  
Missing Default,Custom.Decompiler.Ast,AstBuilder,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\AstBuilder.cs,ConvertType,The following switch statement is missing a default case: switch (name) {  case "SByte":  	return new PrimitiveType ("sbyte");  case "Int16":  	return new PrimitiveType ("short");  case "Int32":  	return new PrimitiveType ("int");  case "Int64":  	return new PrimitiveType ("long");  case "Byte":  	return new PrimitiveType ("byte");  case "UInt16":  	return new PrimitiveType ("ushort");  case "UInt32":  	return new PrimitiveType ("uint");  case "UInt64":  	return new PrimitiveType ("ulong");  case "String":  	return new PrimitiveType ("string");  case "Single":  	return new PrimitiveType ("float");  case "Double":  	return new PrimitiveType ("double");  case "Decimal":  	return new PrimitiveType ("decimal");  case "Char":  	return new PrimitiveType ("char");  case "Boolean":  	return new PrimitiveType ("bool");  case "Void":  	return new PrimitiveType ("void");  case "Object":  	return new PrimitiveType ("object");  }  
Missing Default,Custom.Decompiler.Ast,AstBuilder,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\AstBuilder.cs,ConvertAttributes,The following switch statement is missing a default case: switch (typeDefinition.Attributes & TypeAttributes.LayoutMask) {  case TypeAttributes.SequentialLayout:  	layoutKind = LayoutKind.Sequential;  	break;  case TypeAttributes.ExplicitLayout:  	layoutKind = LayoutKind.Explicit;  	break;  }  
Missing Default,Custom.Decompiler.Ast,AstBuilder,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\AstBuilder.cs,ConvertAttributes,The following switch statement is missing a default case: switch (typeDefinition.Attributes & TypeAttributes.StringFormatMask) {  case TypeAttributes.AnsiClass:  	charSet = CharSet.Ansi;  	break;  case TypeAttributes.AutoClass:  	charSet = CharSet.Auto;  	break;  case TypeAttributes.UnicodeClass:  	charSet = CharSet.Unicode;  	break;  }  
Missing Default,Custom.Decompiler.Ast,AstBuilder,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\AstBuilder.cs,ConvertAttributes,The following switch statement is missing a default case: switch (info.Attributes & PInvokeAttributes.CharSetMask) {  case PInvokeAttributes.CharSetAnsi:  	charSet = CharSet.Ansi;  	break;  case PInvokeAttributes.CharSetAuto:  	charSet = CharSet.Auto;  	break;  case PInvokeAttributes.CharSetUnicode:  	charSet = CharSet.Unicode;  	break;  }  
Missing Default,Custom.Decompiler.Ast,AstBuilder,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\AstBuilder.cs,MakePrimitive,The following switch statement is missing a default case: switch (enumBaseTypeCode) {  case TypeCode.Byte:  case TypeCode.SByte:  	negatedEnumValue &= byte.MaxValue;  	break;  case TypeCode.Int16:  case TypeCode.UInt16:  	negatedEnumValue &= ushort.MaxValue;  	break;  case TypeCode.Int32:  case TypeCode.UInt32:  	negatedEnumValue &= uint.MaxValue;  	break;  }  
Missing Default,Custom.Decompiler.Ast,AstMethodBodyBuilder,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\AstMethodBodyBuilder.cs,MakeDefaultValue,The following switch statement is missing a default case: switch (typeDef.FullName) {  case "System.Nullable`1":  	return new NullReferenceExpression ();  case "System.Single":  	return new PrimitiveExpression (0f);  case "System.Double":  	return new PrimitiveExpression (0.0);  case "System.Decimal":  	return new PrimitiveExpression (0m);  }  
Missing Default,Custom.Decompiler.Ast,NameVariables,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\NameVariables.cs,GenerateNameForVariable,The following switch statement is missing a default case: switch (expr.Code) {  case ILCode.Clt:  case ILCode.Clt_Un:  case ILCode.Cgt:  case ILCode.Cgt_Un:  case ILCode.Cle:  case ILCode.Cle_Un:  case ILCode.Cge:  case ILCode.Cge_Un:  	ILVariable loadVar;  	if (expr.Arguments [0].Match (ILCode.Ldloc' out loadVar) && loadVar == variable) {  		isLoopCounter = true;  	}  	break;  }  
Missing Default,Custom.Decompiler.Ast,NameVariables,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\NameVariables.cs,GetNameFromExpression,The following switch statement is missing a default case: switch (expr.Code) {  case ILCode.Ldfld:  case ILCode.Ldsfld:  	return CleanUpVariableName (((FieldReference)expr.Operand).Name);  case ILCode.Call:  case ILCode.Callvirt:  case ILCode.CallGetter:  case ILCode.CallvirtGetter:  	MethodReference mr = (MethodReference)expr.Operand;  	if (mr.Name.StartsWith ("get_"' StringComparison.OrdinalIgnoreCase) && mr.Parameters.Count == 0) {  		// use name from properties' but not from indexers  		return CleanUpVariableName (mr.Name.Substring (4));  	} else if (mr.Name.StartsWith ("Get"' StringComparison.OrdinalIgnoreCase) && mr.Name.Length >= 4 && char.IsUpper (mr.Name [3])) {  		// use name from Get-methods  		return CleanUpVariableName (mr.Name.Substring (3));  	}  	break;  }  
Missing Default,Custom.Decompiler.Ast,NameVariables,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\NameVariables.cs,GetNameForArgument,The following switch statement is missing a default case: switch (parent.Code) {  case ILCode.Stfld:  case ILCode.Stsfld:  	if (i == parent.Arguments.Count - 1)  		// last argument is stored value  		return CleanUpVariableName (((FieldReference)parent.Operand).Name);  	else  		break;  case ILCode.Call:  case ILCode.Callvirt:  case ILCode.Newobj:  case ILCode.CallGetter:  case ILCode.CallvirtGetter:  case ILCode.CallSetter:  case ILCode.CallvirtSetter:  	MethodReference methodRef = (MethodReference)parent.Operand;  	if (methodRef.Parameters.Count == 1 && i == parent.Arguments.Count - 1) {  		// argument might be value of a setter  		if (methodRef.Name.StartsWith ("set_"' StringComparison.OrdinalIgnoreCase)) {  			return CleanUpVariableName (methodRef.Name.Substring (4));  		} else if (methodRef.Name.StartsWith ("Set"' StringComparison.OrdinalIgnoreCase) && methodRef.Name.Length >= 4 && char.IsUpper (methodRef.Name [3])) {  			return CleanUpVariableName (methodRef.Name.Substring (3));  		}  	}  	MethodDefinition methodDef = methodRef.Resolve ();  	if (methodDef != null) {  		var p = methodDef.Parameters.ElementAtOrDefault ((parent.Code != ILCode.Newobj && methodDef.HasThis) ? i - 1 : i);  		if (p != null && !string.IsNullOrEmpty (p.Name))  			return CleanUpVariableName (p.Name);  	}  	break;  case ILCode.Ret:  	return "result";  }  
Missing Default,Custom.Decompiler,CecilExtensions,F:\newReposMay17\Fody_Usable\Fody\Decompiler\CecilExtensions.cs,GetPushDelta,The following switch statement is missing a default case: switch (code.StackBehaviourPush) {  case StackBehaviour.Push0:  	return 0;  case StackBehaviour.Push1:  case StackBehaviour.Pushi:  case StackBehaviour.Pushi8:  case StackBehaviour.Pushr4:  case StackBehaviour.Pushr8:  case StackBehaviour.Pushref:  	return 1;  case StackBehaviour.Push1_push1:  	return 2;  case StackBehaviour.Varpush:  	if (code.FlowControl != FlowControl.Call)  		break;  	IMethodSignature method = (IMethodSignature)instruction.Operand;  	return IsVoid (method.ReturnType) ? 0 : 1;  }  
Missing Default,Custom.Decompiler,CecilExtensions,F:\newReposMay17\Fody_Usable\Fody\Decompiler\CecilExtensions.cs,GetPopDelta,The following switch statement is missing a default case: switch (code.StackBehaviourPop) {  case StackBehaviour.Pop0:  	return 0;  case StackBehaviour.Popi:  case StackBehaviour.Popref:  case StackBehaviour.Pop1:  	return 1;  case StackBehaviour.Pop1_pop1:  case StackBehaviour.Popi_pop1:  case StackBehaviour.Popi_popi:  case StackBehaviour.Popi_popi8:  case StackBehaviour.Popi_popr4:  case StackBehaviour.Popi_popr8:  case StackBehaviour.Popref_pop1:  case StackBehaviour.Popref_popi:  	return 2;  case StackBehaviour.Popi_popi_popi:  case StackBehaviour.Popref_popi_popi:  case StackBehaviour.Popref_popi_popi8:  case StackBehaviour.Popref_popi_popr4:  case StackBehaviour.Popref_popi_popr8:  case StackBehaviour.Popref_popi_popref:  	return 3;  case StackBehaviour.PopAll:  	return null;  case StackBehaviour.Varpop:  	if (code == OpCodes.Ret)  		return methodDef.ReturnType.IsVoid () ? 0 : 1;  	if (code.FlowControl != FlowControl.Call)  		break;  	IMethodSignature method = (IMethodSignature)instruction.Operand;  	int count = method.HasParameters ? method.Parameters.Count : 0;  	if (method.HasThis && code != OpCodes.Newobj)  		++count;  	if (code == OpCodes.Calli)  		++count;  	// calli takes a function pointer in additional to the normal args  	return count;  }  
Missing Default,Custom.Decompiler.Ast.Transforms,ExpressionTreeConverter,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\Transforms\ExpressionTreeConverter.cs,Convert,The following switch statement is missing a default case: switch (mr.Name) {  case "Add":  	return ConvertBinaryOperator (invocation' BinaryOperatorType.Add' false);  case "AddChecked":  	return ConvertBinaryOperator (invocation' BinaryOperatorType.Add' true);  case "AddAssign":  	return ConvertAssignmentOperator (invocation' AssignmentOperatorType.Add' false);  case "AddAssignChecked":  	return ConvertAssignmentOperator (invocation' AssignmentOperatorType.Add' true);  case "And":  	return ConvertBinaryOperator (invocation' BinaryOperatorType.BitwiseAnd);  case "AndAlso":  	return ConvertBinaryOperator (invocation' BinaryOperatorType.ConditionalAnd);  case "AndAssign":  	return ConvertAssignmentOperator (invocation' AssignmentOperatorType.BitwiseAnd);  case "ArrayAccess":  case "ArrayIndex":  	return ConvertArrayIndex (invocation);  case "ArrayLength":  	return ConvertArrayLength (invocation);  case "Assign":  	return ConvertAssignmentOperator (invocation' AssignmentOperatorType.Assign);  case "Call":  	return ConvertCall (invocation);  case "Coalesce":  	return ConvertBinaryOperator (invocation' BinaryOperatorType.NullCoalescing);  case "Condition":  	return ConvertCondition (invocation);  case "Constant":  	if (invocation.Arguments.Count >= 1)  		return invocation.Arguments.First ().Clone ();  	else  		return NotSupported (expr);  case "Convert":  	return ConvertCast (invocation' false);  case "ConvertChecked":  	return ConvertCast (invocation' true);  case "Divide":  	return ConvertBinaryOperator (invocation' BinaryOperatorType.Divide);  case "DivideAssign":  	return ConvertAssignmentOperator (invocation' AssignmentOperatorType.Divide);  case "Equal":  	return ConvertBinaryOperator (invocation' BinaryOperatorType.Equality);  case "ExclusiveOr":  	return ConvertBinaryOperator (invocation' BinaryOperatorType.ExclusiveOr);  case "ExclusiveOrAssign":  	return ConvertAssignmentOperator (invocation' AssignmentOperatorType.ExclusiveOr);  case "Field":  	return ConvertField (invocation);  case "GreaterThan":  	return ConvertBinaryOperator (invocation' BinaryOperatorType.GreaterThan);  case "GreaterThanOrEqual":  	return ConvertBinaryOperator (invocation' BinaryOperatorType.GreaterThanOrEqual);  case "Invoke":  	return ConvertInvoke (invocation);  case "Lambda":  	return ConvertLambda (invocation);  case "LeftShift":  	return ConvertBinaryOperator (invocation' BinaryOperatorType.ShiftLeft);  case "LeftShiftAssign":  	return ConvertAssignmentOperator (invocation' AssignmentOperatorType.ShiftLeft);  case "LessThan":  	return ConvertBinaryOperator (invocation' BinaryOperatorType.LessThan);  case "LessThanOrEqual":  	return ConvertBinaryOperator (invocation' BinaryOperatorType.LessThanOrEqual);  case "ListInit":  	return ConvertListInit (invocation);  case "MemberInit":  	return ConvertMemberInit (invocation);  case "Modulo":  	return ConvertBinaryOperator (invocation' BinaryOperatorType.Modulus);  case "ModuloAssign":  	return ConvertAssignmentOperator (invocation' AssignmentOperatorType.Modulus);  case "Multiply":  	return ConvertBinaryOperator (invocation' BinaryOperatorType.Multiply' false);  case "MultiplyChecked":  	return ConvertBinaryOperator (invocation' BinaryOperatorType.Multiply' true);  case "MultiplyAssign":  	return ConvertAssignmentOperator (invocation' AssignmentOperatorType.Multiply' false);  case "MultiplyAssignChecked":  	return ConvertAssignmentOperator (invocation' AssignmentOperatorType.Multiply' true);  case "Negate":  	return ConvertUnaryOperator (invocation' UnaryOperatorType.Minus' false);  case "NegateChecked":  	return ConvertUnaryOperator (invocation' UnaryOperatorType.Minus' true);  case "New":  	return ConvertNewObject (invocation);  case "NewArrayBounds":  	return ConvertNewArrayBounds (invocation);  case "NewArrayInit":  	return ConvertNewArrayInit (invocation);  case "Not":  	return ConvertUnaryOperator (invocation' UnaryOperatorType.Not);  case "NotEqual":  	return ConvertBinaryOperator (invocation' BinaryOperatorType.InEquality);  case "OnesComplement":  	return ConvertUnaryOperator (invocation' UnaryOperatorType.BitNot);  case "Or":  	return ConvertBinaryOperator (invocation' BinaryOperatorType.BitwiseOr);  case "OrAssign":  	return ConvertAssignmentOperator (invocation' AssignmentOperatorType.BitwiseOr);  case "OrElse":  	return ConvertBinaryOperator (invocation' BinaryOperatorType.ConditionalOr);  case "Property":  	return ConvertProperty (invocation);  case "Quote":  	if (invocation.Arguments.Count == 1)  		return Convert (invocation.Arguments.Single ());  	else  		return NotSupported (invocation);  case "RightShift":  	return ConvertBinaryOperator (invocation' BinaryOperatorType.ShiftRight);  case "RightShiftAssign":  	return ConvertAssignmentOperator (invocation' AssignmentOperatorType.ShiftRight);  case "Subtract":  	return ConvertBinaryOperator (invocation' BinaryOperatorType.Subtract' false);  case "SubtractChecked":  	return ConvertBinaryOperator (invocation' BinaryOperatorType.Subtract' true);  case "SubtractAssign":  	return ConvertAssignmentOperator (invocation' AssignmentOperatorType.Subtract' false);  case "SubtractAssignChecked":  	return ConvertAssignmentOperator (invocation' AssignmentOperatorType.Subtract' true);  case "TypeAs":  	return ConvertTypeAs (invocation);  case "TypeIs":  	return ConvertTypeIs (invocation);  }  
Missing Default,Custom.Decompiler.Ast.Transforms,ExpressionTreeConverter,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\Transforms\ExpressionTreeConverter.cs,ConvertCast,The following switch statement is missing a default case: switch (invocation.Arguments.Count) {  case 2:  	return cast;  case 3:  	Match m = getMethodFromHandlePattern.Match (invocation.Arguments.ElementAt (2));  	if (m.Success)  		return cast.WithAnnotation (m.Get<AstNode> ("method").Single ().Annotation<MethodReference> ());  	else  		return null;  }  
Missing Default,Custom.Decompiler.Ast.Transforms,ReplaceMethodCallsWithOperators,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Ast\Transforms\ReplaceMethodCallsWithOperators.cs,ProcessInvocationExpression,The following switch statement is missing a default case: switch (methodRef.FullName) {  case "System.Type System.Type::GetTypeFromHandle(System.RuntimeTypeHandle)":  	if (arguments.Length == 1) {  		if (typeHandleOnTypeOfPattern.IsMatch (arguments [0])) {  			invocationExpression.ReplaceWith (((MemberReferenceExpression)arguments [0]).Target);  			return;  		}  	}  	break;  case "System.Reflection.FieldInfo System.Reflection.FieldInfo::GetFieldFromHandle(System.RuntimeFieldHandle)":  	if (arguments.Length == 1) {  		MemberReferenceExpression mre = arguments [0] as MemberReferenceExpression;  		if (mre != null && mre.MemberName == "FieldHandle" && mre.Target.Annotation<LdTokenAnnotation> () != null) {  			invocationExpression.ReplaceWith (mre.Target);  			return;  		}  	}  	break;  case "System.Reflection.FieldInfo System.Reflection.FieldInfo::GetFieldFromHandle(System.RuntimeFieldHandle'System.RuntimeTypeHandle)":  	if (arguments.Length == 2) {  		MemberReferenceExpression mre1 = arguments [0] as MemberReferenceExpression;  		MemberReferenceExpression mre2 = arguments [1] as MemberReferenceExpression;  		if (mre1 != null && mre1.MemberName == "FieldHandle" && mre1.Target.Annotation<LdTokenAnnotation> () != null) {  			if (mre2 != null && mre2.MemberName == "TypeHandle" && mre2.Target is TypeOfExpression) {  				Expression oldArg = ((InvocationExpression)mre1.Target).Arguments.Single ();  				FieldReference field = oldArg.Annotation<FieldReference> ();  				if (field != null) {  					AstType declaringType = ((TypeOfExpression)mre2.Target).Type.Detach ();  					oldArg.ReplaceWith (declaringType.Member (field.Name).WithAnnotation (field));  					invocationExpression.ReplaceWith (mre1.Target);  					return;  				}  			}  		}  	}  	break;  }  
Missing Default,Custom.Decompiler.Disassembler,ILStructure,F:\newReposMay17\Fody_Usable\Fody\Decompiler\Disassembler\ILStructure.cs,FindAllBranches,The following switch statement is missing a default case: switch (inst.OpCode.OperandType) {  case OperandType.InlineBrTarget:  case OperandType.ShortInlineBrTarget:  	result.Add (new KeyValuePair<Instruction' Instruction> (inst' (Instruction)inst.Operand));  	break;  case OperandType.InlineSwitch:  	foreach (Instruction target in (Instruction[])inst.Operand)  		result.Add (new KeyValuePair<Instruction' Instruction> (inst' target));  	break;  }  
Missing Default,Custom.Decompiler.FlowAnalysis,SimplifyByRefCalls,F:\newReposMay17\Fody_Usable\Fody\Decompiler\FlowAnalysis\SimplifyByRefCalls.cs,MakeByRefCallsSimple,The following switch statement is missing a default case: switch (inst.Instruction.OpCode.Code) {  case Code.Call:  case Code.Callvirt:  	instance.MakeByRefCallSimple (block' ref i' (IMethodSignature)inst.Instruction.Operand);  	break;  case Code.Initobj:  	instance.MakeInitObjCallSimple (block' ref i);  	break;  case Code.Ldfld:  	instance.MakeLoadFieldCallSimple (block' ref i);  	break;  }  
Missing Default,Custom.Decompiler.ILAst,ILAstBuilder,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstBuilder.cs,IsDeterministicLdloca,The following switch statement is missing a default case: switch (b.Code) {  case ILCode.Ldloc:  case ILCode.Ldloca:  case ILCode.Stloc:  	if (b.Operand == v)  		return false;  	break;  }  
Missing Default,Custom.Decompiler.ILAst,ILAstBuilder,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstBuilder.cs,ConvertParameters,The following switch statement is missing a default case: switch (byteCode.Code) {  case ILCode.__Ldarg:  	p = (ParameterDefinition)byteCode.Operand;  	byteCode.Code = ILCode.Ldloc;  	byteCode.Operand = p.Index < 0 ? thisParameter : this.Parameters [p.Index];  	break;  case ILCode.__Starg:  	p = (ParameterDefinition)byteCode.Operand;  	byteCode.Code = ILCode.Stloc;  	byteCode.Operand = p.Index < 0 ? thisParameter : this.Parameters [p.Index];  	break;  case ILCode.__Ldarga:  	p = (ParameterDefinition)byteCode.Operand;  	byteCode.Code = ILCode.Ldloca;  	byteCode.Operand = p.Index < 0 ? thisParameter : this.Parameters [p.Index];  	break;  }  
Missing Default,Custom.Decompiler.ILAst,ILAstOptimizer,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,IntroducePropertyAccessInstructions,The following switch statement is missing a default case: switch (cecilMethod.Name) {  case "Get":  	expr.Code = ILCode.CallGetter;  	break;  case "Set":  	expr.Code = ILCode.CallSetter;  	break;  case "Address":  	ByReferenceType brt = cecilMethod.ReturnType as ByReferenceType;  	if (brt != null) {  		MethodReference getMethod = new MethodReference ("Get"' brt.ElementType' cecilMethod.DeclaringType);  		foreach (var p in cecilMethod.Parameters)  			getMethod.Parameters.Add (p);  		getMethod.HasThis = cecilMethod.HasThis;  		expr.Operand = getMethod;  	}  	expr.Code = ILCode.CallGetter;  	if (parentExpr != null) {  		parentExpr.Arguments [posInParent] = new ILExpression (ILCode.AddressOf' null' expr);  	}  	break;  }  
Missing Default,Custom.Decompiler.ILAst,ILAstOptimizer,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,SimplifyLdObjAndStObj,The following switch statement is missing a default case: switch (arg.Code) {  case ILCode.Ldelema:  	newCode = ILCode.Stelem_Any;  	break;  case ILCode.Ldloca:  	newCode = ILCode.Stloc;  	break;  case ILCode.Ldflda:  	newCode = ILCode.Stfld;  	break;  case ILCode.Ldsflda:  	newCode = ILCode.Stsfld;  	break;  }  
Missing Default,Custom.Decompiler.ILAst,ILAstOptimizer,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,SimplifyLdObjAndStObj,The following switch statement is missing a default case: switch (arg.Code) {  case ILCode.Ldelema:  	newCode = ILCode.Ldelem_Any;  	break;  case ILCode.Ldloca:  	newCode = ILCode.Ldloc;  	break;  case ILCode.Ldflda:  	newCode = ILCode.Ldfld;  	break;  case ILCode.Ldsflda:  	newCode = ILCode.Ldsfld;  	break;  }  
Missing Default,Custom.Decompiler.ILAst,ILAstOptimizer,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,IntroducePostIncrementForVariables,The following switch statement is missing a default case: switch (loadInstruction) {  case ILCode.Ldloc:  	exprInit.Code = ILCode.Ldloca;  	break;  case ILCode.Ldsfld:  	exprInit.Code = ILCode.Ldsflda;  	break;  case ILCode.CallGetter:  	exprInit = new ILExpression (ILCode.AddressOf' null' exprInit);  	break;  }  
Missing Default,Custom.Decompiler.ILAst,ILCodeUtil,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILCodes.cs,ExpandMacro,The following switch statement is missing a default case: switch (code) {  case ILCode.__Ldarg_0:  	code = ILCode.__Ldarg;  	operand = methodBody.GetParameter (0);  	break;  case ILCode.__Ldarg_1:  	code = ILCode.__Ldarg;  	operand = methodBody.GetParameter (1);  	break;  case ILCode.__Ldarg_2:  	code = ILCode.__Ldarg;  	operand = methodBody.GetParameter (2);  	break;  case ILCode.__Ldarg_3:  	code = ILCode.__Ldarg;  	operand = methodBody.GetParameter (3);  	break;  case ILCode.__Ldloc_0:  	code = ILCode.Ldloc;  	operand = methodBody.Variables [0];  	break;  case ILCode.__Ldloc_1:  	code = ILCode.Ldloc;  	operand = methodBody.Variables [1];  	break;  case ILCode.__Ldloc_2:  	code = ILCode.Ldloc;  	operand = methodBody.Variables [2];  	break;  case ILCode.__Ldloc_3:  	code = ILCode.Ldloc;  	operand = methodBody.Variables [3];  	break;  case ILCode.__Stloc_0:  	code = ILCode.Stloc;  	operand = methodBody.Variables [0];  	break;  case ILCode.__Stloc_1:  	code = ILCode.Stloc;  	operand = methodBody.Variables [1];  	break;  case ILCode.__Stloc_2:  	code = ILCode.Stloc;  	operand = methodBody.Variables [2];  	break;  case ILCode.__Stloc_3:  	code = ILCode.Stloc;  	operand = methodBody.Variables [3];  	break;  case ILCode.__Ldarg_S:  	code = ILCode.__Ldarg;  	break;  case ILCode.__Ldarga_S:  	code = ILCode.__Ldarga;  	break;  case ILCode.__Starg_S:  	code = ILCode.__Starg;  	break;  case ILCode.__Ldloc_S:  	code = ILCode.Ldloc;  	break;  case ILCode.__Ldloca_S:  	code = ILCode.Ldloca;  	break;  case ILCode.__Stloc_S:  	code = ILCode.Stloc;  	break;  case ILCode.__Ldc_I4_M1:  	code = ILCode.Ldc_I4;  	operand = -1;  	break;  case ILCode.__Ldc_I4_0:  	code = ILCode.Ldc_I4;  	operand = 0;  	break;  case ILCode.__Ldc_I4_1:  	code = ILCode.Ldc_I4;  	operand = 1;  	break;  case ILCode.__Ldc_I4_2:  	code = ILCode.Ldc_I4;  	operand = 2;  	break;  case ILCode.__Ldc_I4_3:  	code = ILCode.Ldc_I4;  	operand = 3;  	break;  case ILCode.__Ldc_I4_4:  	code = ILCode.Ldc_I4;  	operand = 4;  	break;  case ILCode.__Ldc_I4_5:  	code = ILCode.Ldc_I4;  	operand = 5;  	break;  case ILCode.__Ldc_I4_6:  	code = ILCode.Ldc_I4;  	operand = 6;  	break;  case ILCode.__Ldc_I4_7:  	code = ILCode.Ldc_I4;  	operand = 7;  	break;  case ILCode.__Ldc_I4_8:  	code = ILCode.Ldc_I4;  	operand = 8;  	break;  case ILCode.__Ldc_I4_S:  	code = ILCode.Ldc_I4;  	operand = (int)(sbyte)operand;  	break;  case ILCode.__Br_S:  	code = ILCode.Br;  	break;  case ILCode.__Brfalse_S:  	code = ILCode.__Brfalse;  	break;  case ILCode.__Brtrue_S:  	code = ILCode.Brtrue;  	break;  case ILCode.__Beq_S:  	code = ILCode.__Beq;  	break;  case ILCode.__Bge_S:  	code = ILCode.__Bge;  	break;  case ILCode.__Bgt_S:  	code = ILCode.__Bgt;  	break;  case ILCode.__Ble_S:  	code = ILCode.__Ble;  	break;  case ILCode.__Blt_S:  	code = ILCode.__Blt;  	break;  case ILCode.__Bne_Un_S:  	code = ILCode.__Bne_Un;  	break;  case ILCode.__Bge_Un_S:  	code = ILCode.__Bge_Un;  	break;  case ILCode.__Bgt_Un_S:  	code = ILCode.__Bgt_Un;  	break;  case ILCode.__Ble_Un_S:  	code = ILCode.__Ble_Un;  	break;  case ILCode.__Blt_Un_S:  	code = ILCode.__Blt_Un;  	break;  case ILCode.__Leave_S:  	code = ILCode.Leave;  	break;  case ILCode.__Ldind_I:  	code = ILCode.Ldobj;  	operand = methodBody.Method.Module.TypeSystem.IntPtr;  	break;  case ILCode.__Ldind_I1:  	code = ILCode.Ldobj;  	operand = methodBody.Method.Module.TypeSystem.SByte;  	break;  case ILCode.__Ldind_I2:  	code = ILCode.Ldobj;  	operand = methodBody.Method.Module.TypeSystem.Int16;  	break;  case ILCode.__Ldind_I4:  	code = ILCode.Ldobj;  	operand = methodBody.Method.Module.TypeSystem.Int32;  	break;  case ILCode.__Ldind_I8:  	code = ILCode.Ldobj;  	operand = methodBody.Method.Module.TypeSystem.Int64;  	break;  case ILCode.__Ldind_U1:  	code = ILCode.Ldobj;  	operand = methodBody.Method.Module.TypeSystem.Byte;  	break;  case ILCode.__Ldind_U2:  	code = ILCode.Ldobj;  	operand = methodBody.Method.Module.TypeSystem.UInt16;  	break;  case ILCode.__Ldind_U4:  	code = ILCode.Ldobj;  	operand = methodBody.Method.Module.TypeSystem.UInt32;  	break;  case ILCode.__Ldind_R4:  	code = ILCode.Ldobj;  	operand = methodBody.Method.Module.TypeSystem.Single;  	break;  case ILCode.__Ldind_R8:  	code = ILCode.Ldobj;  	operand = methodBody.Method.Module.TypeSystem.Double;  	break;  case ILCode.__Stind_I:  	code = ILCode.Stobj;  	operand = methodBody.Method.Module.TypeSystem.IntPtr;  	break;  case ILCode.__Stind_I1:  	code = ILCode.Stobj;  	operand = methodBody.Method.Module.TypeSystem.Byte;  	break;  case ILCode.__Stind_I2:  	code = ILCode.Stobj;  	operand = methodBody.Method.Module.TypeSystem.Int16;  	break;  case ILCode.__Stind_I4:  	code = ILCode.Stobj;  	operand = methodBody.Method.Module.TypeSystem.Int32;  	break;  case ILCode.__Stind_I8:  	code = ILCode.Stobj;  	operand = methodBody.Method.Module.TypeSystem.Int64;  	break;  case ILCode.__Stind_R4:  	code = ILCode.Stobj;  	operand = methodBody.Method.Module.TypeSystem.Single;  	break;  case ILCode.__Stind_R8:  	code = ILCode.Stobj;  	operand = methodBody.Method.Module.TypeSystem.Double;  	break;  }  
Missing Default,Custom.Decompiler.ILAst,ILInlining,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILInlining.cs,IsGeneratedValueTypeTemporary,The following switch statement is missing a default case: switch (inlinedExpression.Code) {  case ILCode.Ldloc:  case ILCode.Stloc:  case ILCode.CompoundAssignment:  case ILCode.Ldelem_Any:  case ILCode.Ldelem_I:  case ILCode.Ldelem_I1:  case ILCode.Ldelem_I2:  case ILCode.Ldelem_I4:  case ILCode.Ldelem_I8:  case ILCode.Ldelem_R4:  case ILCode.Ldelem_R8:  case ILCode.Ldelem_Ref:  case ILCode.Ldelem_U1:  case ILCode.Ldelem_U2:  case ILCode.Ldelem_U4:  case ILCode.Ldobj:  case ILCode.Ldind_Ref:  	return false;  case ILCode.Ldfld:  case ILCode.Stfld:  case ILCode.Ldsfld:  case ILCode.Stsfld:  	// allow inlining field access only if it's a readonly field  	FieldDefinition f = ((FieldReference)inlinedExpression.Operand).Resolve ();  	if (!(f != null && f.IsInitOnly))  		return false;  	break;  case ILCode.Call:  case ILCode.CallGetter:  	// inlining runs both before and after IntroducePropertyAccessInstructions'  	// so we have to handle both 'call' and 'callgetter'  	MethodReference mr = (MethodReference)inlinedExpression.Operand;  	// ensure that it's not an multi-dimensional array getter  	if (mr.DeclaringType is ArrayType)  		return false;  	goto case ILCode.Callvirt;  case ILCode.Callvirt:  case ILCode.CallvirtGetter:  	// don't inline foreach loop variables:  	mr = (MethodReference)inlinedExpression.Operand;  	if (mr.Name == "get_Current" && mr.HasThis)  		return false;  	break;  case ILCode.Castclass:  case ILCode.Unbox_Any:  	// These are valid' but might occur as part of a foreach loop variable.  	ILExpression arg = inlinedExpression.Arguments [0];  	if (arg.Code == ILCode.CallGetter || arg.Code == ILCode.CallvirtGetter || arg.Code == ILCode.Call || arg.Code == ILCode.Callvirt) {  		mr = (MethodReference)arg.Operand;  		if (mr.Name == "get_Current" && mr.HasThis)  			return false;  		// looks like a foreach loop variable' so don't inline it  	}  	break;  }  
Missing Default,Custom.Decompiler.ILAst,ILInlining,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\ILInlining.cs,IsGeneratedValueTypeTemporary,The following switch statement is missing a default case: switch (parent.Code) {  case ILCode.Call:  case ILCode.CallGetter:  case ILCode.CallSetter:  case ILCode.Callvirt:  case ILCode.CallvirtGetter:  case ILCode.CallvirtSetter:  	MethodReference mr = (MethodReference)parent.Operand;  	return mr.HasThis;  case ILCode.Stfld:  case ILCode.Ldfld:  case ILCode.Ldflda:  case ILCode.Await:  	return true;  }  
Missing Default,Custom.Decompiler.ILAst,TypeAnalysis,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\TypeAnalysis.cs,DoInferTypeForExpression,The following switch statement is missing a default case: switch (type.MetadataType) {  case MetadataType.Int32:  	if (expr.Code == ILCode.Shr_Un)  		expectedInputType = typeSystem.UInt32;  	break;  case MetadataType.UInt32:  	if (expr.Code == ILCode.Shr)  		expectedInputType = typeSystem.Int32;  	break;  case MetadataType.Int64:  	if (expr.Code == ILCode.Shr_Un)  		expectedInputType = typeSystem.UInt64;  	break;  case MetadataType.UInt64:  	if (expr.Code == ILCode.Shr)  		expectedInputType = typeSystem.UInt64;  	break;  }  
Missing Default,Custom.Decompiler.ILAst,YieldReturnDecompiler,F:\newReposMay17\Fody_Usable\Fody\Decompiler\ILAst\YieldReturnDecompiler.cs,TranslateFieldsToLocalAccess,The following switch statement is missing a default case: switch (expr.Code) {  case ILCode.Ldfld:  	if (expr.Arguments [0].MatchThis ()) {  		expr.Code = ILCode.Ldloc;  		if (fieldToParameterMap.ContainsKey (field)) {  			expr.Operand = fieldToParameterMap [field];  		} else {  			expr.Operand = fieldToLocalMap [field];  		}  		expr.Arguments.Clear ();  	}  	break;  case ILCode.Stfld:  	if (expr.Arguments [0].MatchThis ()) {  		expr.Code = ILCode.Stloc;  		if (fieldToParameterMap.ContainsKey (field)) {  			expr.Operand = fieldToParameterMap [field];  		} else {  			expr.Operand = fieldToLocalMap [field];  		}  		expr.Arguments.RemoveAt (0);  	}  	break;  case ILCode.Ldflda:  	if (expr.Arguments [0].MatchThis ()) {  		expr.Code = ILCode.Ldloca;  		if (fieldToParameterMap.ContainsKey (field)) {  			expr.Operand = fieldToParameterMap [field];  		} else {  			expr.Operand = fieldToLocalMap [field];  		}  		expr.Arguments.Clear ();  	}  	break;  }  
