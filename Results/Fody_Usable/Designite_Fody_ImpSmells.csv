Implementation smell,Namespace,Class,File,Method,Description
Long Method,Custom.Decompiler.Ast,AstBuilder,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\AstBuilder.cs,ConvertType,The method has 120 lines of code.
Long Method,Custom.Decompiler.Ast,AstMethodBodyBuilder,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\AstMethodBodyBuilder.cs,TransformNode,The method has 103 lines of code.
Long Method,Custom.Decompiler.Ast,AstMethodBodyBuilder,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\AstMethodBodyBuilder.cs,TransformByteCode,The method has 585 lines of code.
Long Method,Custom.Decompiler.Ast,AstMethodBodyBuilder,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\AstMethodBodyBuilder.cs,TransformCall,The method has 110 lines of code.
Long Method,Custom.Decompiler.Ast.Transforms,DelegateConstruction,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\Transforms\DelegateConstruction.cs,VisitBlockStatement,The method has 146 lines of code.
Long Method,Custom.Decompiler.Ast.Transforms,ExpressionTreeConverter,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\Transforms\ExpressionTreeConverter.cs,Convert,The method has 148 lines of code.
Long Method,Custom.Decompiler.Ast.Transforms,IntroduceQueryExpressions,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\Transforms\IntroduceQueryExpressions.cs,DecompileQuery,The method has 162 lines of code.
Long Method,Custom.Decompiler.Disassembler,DisassemblerHelpers,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Disassembler\DisassemblerHelpers.cs,WriteOperand,The method has 104 lines of code.
Long Method,Custom.Decompiler.Disassembler,ReflectionDisassembler,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Disassembler\ReflectionDisassembler.cs,DisassembleMethodInternal,The method has 115 lines of code.
Long Method,Custom.Decompiler.Disassembler,ReflectionDisassembler,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Disassembler\ReflectionDisassembler.cs,WriteNativeType,The method has 211 lines of code.
Long Method,Custom.Decompiler.ILAst,AsyncDecompiler,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\AsyncDecompiler.cs,MatchTaskCreationPattern,The method has 108 lines of code.
Long Method,Custom.Decompiler.ILAst,ILAstBuilder,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\ILAstBuilder.cs,StackAnalysis,The method has 256 lines of code.
Long Method,Custom.Decompiler.ILAst,ILAstOptimizer,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,Optimize,The method has 173 lines of code.
Long Method,Custom.Decompiler.ILAst,LoopsAndConditions,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\LoopsAndConditions.cs,FindLoops,The method has 104 lines of code.
Long Method,Custom.Decompiler.ILAst,LoopsAndConditions,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\LoopsAndConditions.cs,FindConditions,The method has 168 lines of code.
Long Method,Custom.Decompiler.ILAst,StateRangeAnalysis,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\StateRange.cs,AssignStateRanges,The method has 109 lines of code.
Long Method,Custom.Decompiler.ILAst,TypeAnalysis,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\TypeAnalysis.cs,DoInferTypeForExpression,The method has 589 lines of code.
Complex Method,Custom.Decompiler.Ast,AstBuilder,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\AstBuilder.cs,MemberIsHidden,Cyclomatic complexity of the method is 18
Complex Method,Custom.Decompiler.Ast,AstBuilder,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\AstBuilder.cs,CreateType,Cyclomatic complexity of the method is 20
Complex Method,Custom.Decompiler.Ast,AstBuilder,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\AstBuilder.cs,ConvertType,Cyclomatic complexity of the method is 34
Complex Method,Custom.Decompiler.Ast,AstBuilder,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\AstBuilder.cs,ConvertModifiers,Cyclomatic complexity of the method is 9
Complex Method,Custom.Decompiler.Ast,AstBuilder,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\AstBuilder.cs,ConvertModifiers,Cyclomatic complexity of the method is 10
Complex Method,Custom.Decompiler.Ast,AstBuilder,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\AstBuilder.cs,ConvertModifiers,Cyclomatic complexity of the method is 15
Complex Method,Custom.Decompiler.Ast,AstBuilder,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\AstBuilder.cs,AddTypeMembers,Cyclomatic complexity of the method is 10
Complex Method,Custom.Decompiler.Ast,AstBuilder,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\AstBuilder.cs,CreateMethod,Cyclomatic complexity of the method is 11
Complex Method,Custom.Decompiler.Ast,AstBuilder,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\AstBuilder.cs,MakeConstraints,Cyclomatic complexity of the method is 8
Complex Method,Custom.Decompiler.Ast,AstBuilder,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\AstBuilder.cs,CreateProperty,Cyclomatic complexity of the method is 16
Complex Method,Custom.Decompiler.Ast,AstBuilder,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\AstBuilder.cs,MakeParameters,Cyclomatic complexity of the method is 13
Complex Method,Custom.Decompiler.Ast,AstBuilder,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\AstBuilder.cs,ConvertAttributes,Cyclomatic complexity of the method is 10
Complex Method,Custom.Decompiler.Ast,AstBuilder,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\AstBuilder.cs,ConvertAttributes,Cyclomatic complexity of the method is 21
Complex Method,Custom.Decompiler.Ast,AstBuilder,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\AstBuilder.cs,ConvertMarshalInfo,Cyclomatic complexity of the method is 11
Complex Method,Custom.Decompiler.Ast,AstBuilder,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\AstBuilder.cs,ConvertCustomAttributes,Cyclomatic complexity of the method is 18
Complex Method,Custom.Decompiler.Ast,AstBuilder,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\AstBuilder.cs,ConvertSecurityAttributes,Cyclomatic complexity of the method is 12
Complex Method,Custom.Decompiler.Ast,AstBuilder,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\AstBuilder.cs,MakePrimitive,Cyclomatic complexity of the method is 22
Complex Method,Custom.Decompiler.Ast,AstBuilder,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\AstBuilder.cs,HidesByName,Cyclomatic complexity of the method is 8
Complex Method,Custom.Decompiler.Ast,AstMethodBodyBuilder,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\AstMethodBodyBuilder.cs,TransformNode,Cyclomatic complexity of the method is 20
Complex Method,Custom.Decompiler.Ast,AstMethodBodyBuilder,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\AstMethodBodyBuilder.cs,TransformByteCode,Cyclomatic complexity of the method is 162
Complex Method,Custom.Decompiler.Ast,AstMethodBodyBuilder,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\AstMethodBodyBuilder.cs,DivideBySize,Cyclomatic complexity of the method is 8
Complex Method,Custom.Decompiler.Ast,AstMethodBodyBuilder,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\AstMethodBodyBuilder.cs,TransformCall,Cyclomatic complexity of the method is 30
Complex Method,Custom.Decompiler.Ast,AstMethodBodyBuilder,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\AstMethodBodyBuilder.cs,FormatByteCodeOperand,Cyclomatic complexity of the method is 9
Complex Method,Custom.Decompiler.Ast,AstMethodBodyBuilder,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\AstMethodBodyBuilder.cs,Convert,Cyclomatic complexity of the method is 12
Complex Method,Custom.Decompiler.Ast,NameVariables,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\NameVariables.cs,AssignNamesToVariables,Cyclomatic complexity of the method is 11
Complex Method,Custom.Decompiler.Ast,NameVariables,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\NameVariables.cs,GenerateNameForVariable,Cyclomatic complexity of the method is 16
Complex Method,Custom.Decompiler.Ast,NameVariables,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\NameVariables.cs,GetNameForArgument,Cyclomatic complexity of the method is 9
Complex Method,Custom.Decompiler.Ast,TextOutputFormatter,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\TextOutputFormatter.cs,GetCurrentLocalDefinition,Cyclomatic complexity of the method is 8
Complex Method,Custom.Decompiler.Ast,TypesHierarchyHelpers,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\TypesHierarchyHelpers.cs,FindBaseProperties,Cyclomatic complexity of the method is 8
Complex Method,Custom.Decompiler.Ast,TypesHierarchyHelpers,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\TypesHierarchyHelpers.cs,GetAccessAttributes,Cyclomatic complexity of the method is 8
Complex Method,Custom.Decompiler.Ast,TypesHierarchyHelpers,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\TypesHierarchyHelpers.cs,MatchMethod,Cyclomatic complexity of the method is 10
Complex Method,Custom.Decompiler,CecilExtensions,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\CecilExtensions.cs,GetPopDelta,Cyclomatic complexity of the method is 10
Complex Method,Custom.Decompiler.Ast.Transforms,AddCheckedBlocks,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\Transforms\AddCheckedBlocks.cs,GetResult,Cyclomatic complexity of the method is 13
Complex Method,Custom.Decompiler.Ast.Transforms,CombineQueryExpressions,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\Transforms\CombineQueryExpressions.cs,TryRemoveTransparentIdentifier,Cyclomatic complexity of the method is 10
Complex Method,Custom.Decompiler.Ast.Transforms,ConvertConstructorCallIntoInitializer,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\Transforms\ConvertConstructorCallIntoInitializer.cs,HandleStaticFieldInitializers,Cyclomatic complexity of the method is 9
Complex Method,Custom.Decompiler.Ast.Transforms,DeclareVariables,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\Transforms\DeclareVariables.cs,DeclareVariableInBlock,Cyclomatic complexity of the method is 13
Complex Method,Custom.Decompiler.Ast.Transforms,DeclareVariables,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\Transforms\DeclareVariables.cs,CanMoveVariableUseIntoSubBlock,Cyclomatic complexity of the method is 14
Complex Method,Custom.Decompiler.Ast.Transforms,DeclareVariables,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\Transforms\DeclareVariables.cs,UsesVariable,Cyclomatic complexity of the method is 14
Complex Method,Custom.Decompiler.Ast.Transforms,DelegateConstruction,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\Transforms\DelegateConstruction.cs,VisitObjectCreateExpression,Cyclomatic complexity of the method is 12
Complex Method,Custom.Decompiler.Ast.Transforms,DelegateConstruction,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\Transforms\DelegateConstruction.cs,HandleAnonymousMethod,Cyclomatic complexity of the method is 11
Complex Method,Custom.Decompiler.Ast.Transforms,DelegateConstruction,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\Transforms\DelegateConstruction.cs,VisitBlockStatement,Cyclomatic complexity of the method is 26
Complex Method,Custom.Decompiler.Ast.Transforms,DelegateConstruction,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\Transforms\DelegateConstruction.cs,EnsureVariableNameIsAvailable,Cyclomatic complexity of the method is 11
Complex Method,Custom.Decompiler.Ast.Transforms,ExpressionTreeConverter,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\Transforms\ExpressionTreeConverter.cs,Convert,Cyclomatic complexity of the method is 68
Complex Method,Custom.Decompiler.Ast.Transforms,ExpressionTreeConverter,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\Transforms\ExpressionTreeConverter.cs,ConvertCall,Cyclomatic complexity of the method is 16
Complex Method,Custom.Decompiler.Ast.Transforms,ExpressionTreeConverter,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\Transforms\ExpressionTreeConverter.cs,ConvertBinaryOperator,Cyclomatic complexity of the method is 11
Complex Method,Custom.Decompiler.Ast.Transforms,ExpressionTreeConverter,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\Transforms\ExpressionTreeConverter.cs,ConvertNewObject,Cyclomatic complexity of the method is 12
Complex Method,Custom.Decompiler.Ast.Transforms,ExpressionTreeConverter,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\Transforms\ExpressionTreeConverter.cs,ConvertMemberBindings,Cyclomatic complexity of the method is 11
Complex Method,Custom.Decompiler.Ast.Transforms,IntroduceExtensionMethods,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\Transforms\IntroduceExtensionMethods.cs,Run,Cyclomatic complexity of the method is 8
Complex Method,Custom.Decompiler.Ast.Transforms,IntroduceQueryExpressions,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\Transforms\IntroduceQueryExpressions.cs,DecompileQuery,Cyclomatic complexity of the method is 31
Complex Method,Custom.Decompiler.Ast.Transforms,FullyQualifyAmbiguousTypeNamesVisitor,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\Transforms\IntroduceUsingDeclarations.cs,VisitTypeDeclaration,Cyclomatic complexity of the method is 17
Complex Method,Custom.Decompiler.Ast.Transforms,PatternStatementTransform,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\Transforms\PatternStatementTransform.cs,TransformUsings,Cyclomatic complexity of the method is 10
Complex Method,Custom.Decompiler.Ast.Transforms,PatternStatementTransform,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\Transforms\PatternStatementTransform.cs,TransformForeach,Cyclomatic complexity of the method is 9
Complex Method,Custom.Decompiler.Ast.Transforms,PatternStatementTransform,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\Transforms\PatternStatementTransform.cs,TransformNonGenericForEach,Cyclomatic complexity of the method is 9
Complex Method,Custom.Decompiler.Ast.Transforms,PatternStatementTransform,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\Transforms\PatternStatementTransform.cs,TransformSwitchOnString,Cyclomatic complexity of the method is 13
Complex Method,Custom.Decompiler.Ast.Transforms,PushNegation,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\Transforms\PushNegation.cs,VisitUnaryOperatorExpression,Cyclomatic complexity of the method is 14
Complex Method,Custom.Decompiler.Ast.Transforms,PushNegation,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\Transforms\PushNegation.cs,VisitBinaryOperatorExpression,Cyclomatic complexity of the method is 8
Complex Method,Custom.Decompiler.Ast.Transforms,ReplaceMethodCallsWithOperators,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\Transforms\ReplaceMethodCallsWithOperators.cs,ProcessInvocationExpression,Cyclomatic complexity of the method is 19
Complex Method,Custom.Decompiler.Ast.Transforms,ReplaceMethodCallsWithOperators,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\Transforms\ReplaceMethodCallsWithOperators.cs,GetBinaryOperatorTypeFromMetadataName,Cyclomatic complexity of the method is 17
Complex Method,Custom.Decompiler.Ast.Transforms,ReplaceMethodCallsWithOperators,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\Transforms\ReplaceMethodCallsWithOperators.cs,VisitAssignmentExpression,Cyclomatic complexity of the method is 8
Complex Method,Custom.Decompiler.Ast.Transforms,ReplaceMethodCallsWithOperators,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\Transforms\ReplaceMethodCallsWithOperators.cs,GetAssignmentOperatorForBinaryOperator,Cyclomatic complexity of the method is 11
Complex Method,Custom.Decompiler.Disassembler,DisassemblerHelpers,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Disassembler\DisassemblerHelpers.cs,WriteTo,Cyclomatic complexity of the method is 10
Complex Method,Custom.Decompiler.Disassembler,DisassemblerHelpers,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Disassembler\DisassemblerHelpers.cs,WriteTo,Cyclomatic complexity of the method is 19
Complex Method,Custom.Decompiler.Disassembler,DisassemblerHelpers,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Disassembler\DisassemblerHelpers.cs,WriteOperand,Cyclomatic complexity of the method is 26
Complex Method,Custom.Decompiler.Disassembler,DisassemblerHelpers,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Disassembler\DisassemblerHelpers.cs,PrimitiveTypeName,Cyclomatic complexity of the method is 17
Complex Method,Custom.Decompiler.Disassembler,ILStructure,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Disassembler\ILStructure.cs,ILStructure,Cyclomatic complexity of the method is 13
Complex Method,Custom.Decompiler.Disassembler,ILStructure,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Disassembler\ILStructure.cs,AddNestedStructure,Cyclomatic complexity of the method is 8
Complex Method,Custom.Decompiler.Disassembler,MethodBodyDisassembler,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Disassembler\MethodBodyDisassembler.cs,Disassemble,Cyclomatic complexity of the method is 12
Complex Method,Custom.Decompiler.Disassembler,MethodBodyDisassembler,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Disassembler\MethodBodyDisassembler.cs,WriteStructureHeader,Cyclomatic complexity of the method is 10
Complex Method,Custom.Decompiler.Disassembler,ReflectionDisassembler,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Disassembler\ReflectionDisassembler.cs,DisassembleMethodInternal,Cyclomatic complexity of the method is 25
Complex Method,Custom.Decompiler.Disassembler,ReflectionDisassembler,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Disassembler\ReflectionDisassembler.cs,WriteSecurityDeclarations,Cyclomatic complexity of the method is 24
Complex Method,Custom.Decompiler.Disassembler,ReflectionDisassembler,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Disassembler\ReflectionDisassembler.cs,WriteNativeType,Cyclomatic complexity of the method is 66
Complex Method,Custom.Decompiler.Disassembler,ReflectionDisassembler,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Disassembler\ReflectionDisassembler.cs,DisassembleType,Cyclomatic complexity of the method is 18
Complex Method,Custom.Decompiler.Disassembler,ReflectionDisassembler,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Disassembler\ReflectionDisassembler.cs,WriteTypeParameters,Cyclomatic complexity of the method is 12
Complex Method,Custom.Decompiler.FlowAnalysis,ControlFlowGraphBuilder,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\FlowAnalysis\ControlFlowGraphBuilder.cs,CreateNodes,Cyclomatic complexity of the method is 10
Complex Method,Custom.Decompiler.FlowAnalysis,ControlFlowGraphBuilder,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\FlowAnalysis\ControlFlowGraphBuilder.cs,CreateRegularControlFlow,Cyclomatic complexity of the method is 13
Complex Method,Custom.Decompiler.FlowAnalysis,ControlFlowNode,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\FlowAnalysis\ControlFlowNode.cs,ToString,Cyclomatic complexity of the method is 8
Complex Method,Custom.Decompiler.FlowAnalysis,ControlStructureDetector,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\FlowAnalysis\ControlStructureDetector.cs,FindLoops,Cyclomatic complexity of the method is 9
Complex Method,Custom.Decompiler.FlowAnalysis,SsaForm,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\FlowAnalysis\SsaForm.cs,ExportVariableGraph,Cyclomatic complexity of the method is 8
Complex Method,Custom.Decompiler.FlowAnalysis,SsaForm,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\FlowAnalysis\SsaForm.cs,ComputeVariableUsage,Cyclomatic complexity of the method is 11
Complex Method,Custom.Decompiler.FlowAnalysis,SsaFormBuilder,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\FlowAnalysis\SsaFormBuilder.cs,CreateInstructions,Cyclomatic complexity of the method is 15
Complex Method,Custom.Decompiler.FlowAnalysis,SsaFormBuilder,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\FlowAnalysis\SsaFormBuilder.cs,DetermineOperands,Cyclomatic complexity of the method is 9
Complex Method,Custom.Decompiler.FlowAnalysis,SsaInstruction,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\FlowAnalysis\SsaInstruction.cs,WriteTo,Cyclomatic complexity of the method is 12
Complex Method,Custom.Decompiler.FlowAnalysis,SsaOptimization,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\FlowAnalysis\SsaOptimization.cs,RemoveDeadAssignments,Cyclomatic complexity of the method is 11
Complex Method,Custom.Decompiler.FlowAnalysis,TransformToSsa,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\FlowAnalysis\TransformToSsa.cs,CollectInformationAboutOriginalVariableUse,Cyclomatic complexity of the method is 10
Complex Method,Custom.Decompiler.FlowAnalysis,TransformToSsa,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\FlowAnalysis\TransformToSsa.cs,PlacePhiFunctions,Cyclomatic complexity of the method is 8
Complex Method,Custom.Decompiler.FlowAnalysis,VariableRenamer,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\FlowAnalysis\TransformToSsa.cs,Visit,Cyclomatic complexity of the method is 16
Complex Method,Custom.Decompiler.ILAst,AsyncDecompiler,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\AsyncDecompiler.cs,MatchTaskCreationPattern,Cyclomatic complexity of the method is 31
Complex Method,Custom.Decompiler.ILAst,AsyncDecompiler,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\AsyncDecompiler.cs,AnalyzeMoveNext,Cyclomatic complexity of the method is 11
Complex Method,Custom.Decompiler.ILAst,AsyncDecompiler,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\AsyncDecompiler.cs,HandleAwait,Cyclomatic complexity of the method is 11
Complex Method,Custom.Decompiler.ILAst,AsyncDecompiler,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\AsyncDecompiler.cs,Step2,Cyclomatic complexity of the method is 17
Complex Method,Custom.Decompiler.ILAst,GotoRemoval,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\GotoRemoval.cs,RemoveRedundantCode,Cyclomatic complexity of the method is 14
Complex Method,Custom.Decompiler.ILAst,GotoRemoval,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\GotoRemoval.cs,Enter,Cyclomatic complexity of the method is 25
Complex Method,Custom.Decompiler.ILAst,GotoRemoval,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\GotoRemoval.cs,Exit,Cyclomatic complexity of the method is 9
Complex Method,Custom.Decompiler.ILAst,ILAstBuilder,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\ILAstBuilder.cs,StackAnalysis,Cyclomatic complexity of the method is 45
Complex Method,Custom.Decompiler.ILAst,ILAstBuilder,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\ILAstBuilder.cs,IsDeterministicLdloca,Cyclomatic complexity of the method is 10
Complex Method,Custom.Decompiler.ILAst,ILAstBuilder,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\ILAstBuilder.cs,ConvertLocalVariables,Cyclomatic complexity of the method is 8
Complex Method,Custom.Decompiler.ILAst,ILAstBuilder,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\ILAstBuilder.cs,ConvertParameters,Cyclomatic complexity of the method is 8
Complex Method,Custom.Decompiler.ILAst,ILAstBuilder,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\ILAstBuilder.cs,ConvertToAst,Cyclomatic complexity of the method is 15
Complex Method,Custom.Decompiler.ILAst,ILAstBuilder,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\ILAstBuilder.cs,ConvertToAst,Cyclomatic complexity of the method is 10
Complex Method,Custom.Decompiler.ILAst,ByteCode,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\ILAstBuilder.cs,ToString,Cyclomatic complexity of the method is 25
Complex Method,Custom.Decompiler.ILAst,ILAstOptimizer,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,Optimize,Cyclomatic complexity of the method is 36
Complex Method,Custom.Decompiler.ILAst,ILAstOptimizer,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,RemoveRedundantCode,Cyclomatic complexity of the method is 17
Complex Method,Custom.Decompiler.ILAst,ILAstOptimizer,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,ReduceBranchInstructionSet,Cyclomatic complexity of the method is 15
Complex Method,Custom.Decompiler.ILAst,ILAstOptimizer,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,IntroducePropertyAccessInstructions,Cyclomatic complexity of the method is 13
Complex Method,Custom.Decompiler.ILAst,ILAstOptimizer,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,DuplicateReturnStatements,Cyclomatic complexity of the method is 14
Complex Method,Custom.Decompiler.ILAst,ILAstOptimizer,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,FlattenBasicBlocks,Cyclomatic complexity of the method is 9
Complex Method,Custom.Decompiler.ILAst,ILAstOptimizer,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,ReduceIfNesting,Cyclomatic complexity of the method is 9
Complex Method,Custom.Decompiler.ILAst,ILAstOptimizer,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,DecodeArrayInitializer,Cyclomatic complexity of the method is 11
Complex Method,Custom.Decompiler.ILAst,ILAstOptimizer,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,TransformObjectInitializers,Cyclomatic complexity of the method is 19
Complex Method,Custom.Decompiler.ILAst,ILAstOptimizer,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,AdjustInitializerStack,Cyclomatic complexity of the method is 15
Complex Method,Custom.Decompiler.ILAst,ILAstOptimizer,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,SimplifyLdObjAndStObj,Cyclomatic complexity of the method is 13
Complex Method,Custom.Decompiler.ILAst,ILAstOptimizer,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,CachedDelegateInitializationWithField,Cyclomatic complexity of the method is 15
Complex Method,Custom.Decompiler.ILAst,ILAstOptimizer,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,CachedDelegateInitializationWithLocal,Cyclomatic complexity of the method is 16
Complex Method,Custom.Decompiler.ILAst,ILAstOptimizer,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,MakeCompoundAssignment,Cyclomatic complexity of the method is 16
Complex Method,Custom.Decompiler.ILAst,ILAstOptimizer,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,IntroducePostIncrementForVariables,Cyclomatic complexity of the method is 18
Complex Method,Custom.Decompiler.ILAst,ILAstOptimizer,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,IntroducePostIncrementForInstanceFields,Cyclomatic complexity of the method is 19
Complex Method,Custom.Decompiler.ILAst,ILAstOptimizer,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,GetIncrementCode,Cyclomatic complexity of the method is 10
Complex Method,Custom.Decompiler.ILAst,ILAstOptimizer,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,IntroduceFixedStatements,Cyclomatic complexity of the method is 9
Complex Method,Custom.Decompiler.ILAst,ILAstOptimizer,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,MatchFixedInitializer,Cyclomatic complexity of the method is 9
Complex Method,Custom.Decompiler.ILAst,ILAstOptimizer,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,HandleStringFixing,Cyclomatic complexity of the method is 13
Complex Method,Custom.Decompiler.ILAst,ILAstOptimizer,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,SimplifyLogicNotArgument,Cyclomatic complexity of the method is 11
Complex Method,Custom.Decompiler.ILAst,ILAstOptimizer,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,InlineExpressionTreeParameterDeclarations,Cyclomatic complexity of the method is 9
Complex Method,Custom.Decompiler.ILAst,ILAstOptimizer,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,MatchParameterVariableAssignment,Cyclomatic complexity of the method is 8
Complex Method,Custom.Decompiler.ILAst,ILExpression,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\ILAstTypes.cs,WriteTo,Cyclomatic complexity of the method is 21
Complex Method,Custom.Decompiler.ILAst,ILCodeUtil,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\ILCodes.cs,ExpandMacro,Cyclomatic complexity of the method is 60
Complex Method,Custom.Decompiler.ILAst,ILInlining,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\ILInlining.cs,AnalyzeNode,Cyclomatic complexity of the method is 9
Complex Method,Custom.Decompiler.ILAst,ILInlining,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\ILInlining.cs,InlineAllInBlock,Cyclomatic complexity of the method is 8
Complex Method,Custom.Decompiler.ILAst,ILInlining,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\ILInlining.cs,InlineIfPossible,Cyclomatic complexity of the method is 10
Complex Method,Custom.Decompiler.ILAst,ILInlining,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\ILInlining.cs,IsGeneratedValueTypeTemporary,Cyclomatic complexity of the method is 12
Complex Method,Custom.Decompiler.ILAst,ILInlining,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\ILInlining.cs,IsSafeForInlineOver,Cyclomatic complexity of the method is 8
Complex Method,Custom.Decompiler.ILAst,ILInlining,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\ILInlining.cs,CopyPropagation,Cyclomatic complexity of the method is 9
Complex Method,Custom.Decompiler.ILAst,PatternMatcher,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\LiftedOperators.cs,Simplify,Cyclomatic complexity of the method is 10
Complex Method,Custom.Decompiler.ILAst,OperatorPattern,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\LiftedOperators.cs,Match,Cyclomatic complexity of the method is 16
Complex Method,Custom.Decompiler.ILAst,OperatorPattern,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\LiftedOperators.cs,IsCustomOperator,Cyclomatic complexity of the method is 8
Complex Method,Custom.Decompiler.ILAst,LoopsAndConditions,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\LoopsAndConditions.cs,FindLoops,Cyclomatic complexity of the method is 10
Complex Method,Custom.Decompiler.ILAst,LoopsAndConditions,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\LoopsAndConditions.cs,FindConditions,Cyclomatic complexity of the method is 19
Complex Method,Custom.Decompiler.ILAst,SimpleControlFlow,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\SimpleControlFlow.cs,SimplifyTernaryOperator,Cyclomatic complexity of the method is 11
Complex Method,Custom.Decompiler.ILAst,SimpleControlFlow,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\SimpleControlFlow.cs,SimplifyCustomShortCircuit,Cyclomatic complexity of the method is 16
Complex Method,Custom.Decompiler.ILAst,StateRangeAnalysis,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\StateRange.cs,AssignStateRanges,Cyclomatic complexity of the method is 25
Complex Method,Custom.Decompiler.ILAst,SymbolicEvaluationContext,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\SymbolicExecution.cs,Eval,Cyclomatic complexity of the method is 16
Complex Method,Custom.Decompiler.ILAst,TypeAnalysis,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\TypeAnalysis.cs,RunInference,Cyclomatic complexity of the method is 14
Complex Method,Custom.Decompiler.ILAst,TypeAnalysis,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\TypeAnalysis.cs,DoInferTypeForExpression,Cyclomatic complexity of the method is 174
Complex Method,Custom.Decompiler.ILAst,TypeAnalysis,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\TypeAnalysis.cs,SubstituteTypeArgs,Cyclomatic complexity of the method is 14
Complex Method,Custom.Decompiler.ILAst,TypeAnalysis,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\TypeAnalysis.cs,GetInformationAmount,Cyclomatic complexity of the method is 9
Complex Method,Custom.Decompiler.ILAst,TypeAnalysis,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\TypeAnalysis.cs,GetTypeCode,Cyclomatic complexity of the method is 15
Complex Method,Custom.Decompiler.ILAst,YieldReturnDecompiler,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\YieldReturnDecompiler.cs,MatchEnumeratorCreationPattern,Cyclomatic complexity of the method is 14
Complex Method,Custom.Decompiler.ILAst,YieldReturnDecompiler,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\YieldReturnDecompiler.cs,AnalyzeMoveNext,Cyclomatic complexity of the method is 19
Complex Method,Custom.Decompiler.ILAst,YieldReturnDecompiler,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\YieldReturnDecompiler.cs,ConvertBody,Cyclomatic complexity of the method is 20
Complex Method,Custom.Decompiler.ILAst,YieldReturnDecompiler,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\YieldReturnDecompiler.cs,TranslateFieldsToLocalAccess,Cyclomatic complexity of the method is 12
Long Parameter List,Custom.Decompiler.Ast.Transforms,DeclareVariables,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\Transforms\DeclareVariables.cs,DeclareVariableInBlock,The method has 6 parameters. Parameters: daa' block' type' variableName' v' allowPassIntoLoops
Long Parameter List,Custom.Decompiler.Ast.Transforms,DeclareVariables,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\Transforms\DeclareVariables.cs,FindDeclarationPoint,The method has 5 parameters. Parameters: daa' variableName' allowPassIntoLoops' block' declarationPoint
Long Parameter List,Custom.Decompiler.Disassembler,MethodBodyDisassembler,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Disassembler\MethodBodyDisassembler.cs,WriteStructureBody,The method has 5 parameters. Parameters: s' branchTargets' inst' currentMethodMapping' codeSize
Long Parameter List,Custom.Decompiler.FlowAnalysis,SsaForm,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\FlowAnalysis\SsaForm.cs,SsaForm,The method has 5 parameters. Parameters: blocks' parameters' locals' stackLocations' methodHasThis
Long Parameter List,Custom.Decompiler.FlowAnalysis,SsaFormBuilder,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\FlowAnalysis\SsaFormBuilder.cs,DetermineOperands,The method has 6 parameters. Parameters: stackSize' inst' popCount' pushCount' target' operands
Long Parameter List,Custom.Decompiler.FlowAnalysis,SsaInstruction,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\FlowAnalysis\SsaInstruction.cs,SsaInstruction,The method has 7 parameters. Parameters: parentBlock' instruction' target' operands' prefixes' specialOpCode' typeOperand
Long Parameter List,Custom.Decompiler.ILAst,ILAstOptimizer,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,ForwardScanInitializeArrayRuntimeHelper,The method has 7 parameters. Parameters: body' pos' array' arrayType' arrayLength' values' foundPos
Long Parameter List,Custom.Decompiler.ILAst,ILAstOptimizer,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,ParseObjectInitializer,The method has 6 parameters. Parameters: body' pos' v' newObjExpr' isCollection' isValueType
Long Parameter List,Custom.Decompiler.ILAst,ILAstOptimizer,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,AdjustInitializerStack,The method has 5 parameters. Parameters: initializerStack' argument' v' isCollection' isValueType
Long Parameter List,Custom.Decompiler.ILAst,ILAstOptimizer,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,MatchFixedInitializer,The method has 5 parameters. Parameters: body' i' pinnedVar' initValue' nextPos
Long Parameter List,Custom.Decompiler.ILAst,ILInlining,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\ILInlining.cs,IsGeneratedValueTypeTemporary,The method has 5 parameters. Parameters: next' parent' pos' v' inlinedExpression
Long Parameter List,Custom.Decompiler.ILAst,ILInlining,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\ILInlining.cs,FindLoadInNext,The method has 5 parameters. Parameters: expr' v' expressionBeingMoved' parent' pos
Long Parameter List,Custom.Decompiler.ILAst,PatternMatching,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\PatternMatching.cs,Match,The method has 5 parameters. Parameters: node' code' operand' arg1' arg2
Long Parameter List,Custom.Decompiler.ILAst,PatternMatching,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\PatternMatching.cs,MatchSingleAndBr,The method has 5 parameters. Parameters: bb' code' operand' arg' brLabel
Long Parameter List,Custom.Decompiler.ILAst,PatternMatching,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\PatternMatching.cs,MatchLastAndBr,The method has 5 parameters. Parameters: bb' code' operand' arg' brLabel
Long Parameter List,Custom.Decompiler.ILAst,StateRangeAnalysis,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\StateRange.cs,CreateLabelRangeMapping,The method has 5 parameters. Parameters: body' pos' bodyLength' result' onlyInitialLabels
Long Parameter List,Custom.Decompiler.ILAst,TypeAnalysis,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\TypeAnalysis.cs,HandleConversion,The method has 5 parameters. Parameters: targetBitSize' targetSigned' arg' expectedType' targetType
Long Parameter List,Custom.Decompiler.ILAst,TypeAnalysis,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\TypeAnalysis.cs,InferBinaryArguments,The method has 6 parameters. Parameters: left' right' expectedType' forceInferChildren' leftPreferred' rightPreferred
Long Identifier,Custom.Decompiler.Ast,GenericContext,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\TypesHierarchyHelpers.cs,,The length of the parameter UnresolvedGenericTypeParameter is 30.
Long Identifier,Custom.Decompiler.Ast,GenericContext,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\TypesHierarchyHelpers.cs,,The length of the parameter UnresolvedGenericMethodParameter is 32.
Long Identifier,Custom.Decompiler,DecompilerSettings,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\DecompilerSettings.cs,,The length of the parameter fullyQualifyAmbiguousTypeNames is 30.
Long Identifier,Custom.Decompiler,DecompilerSettings,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\DecompilerSettings.cs,,The length of the parameter introduceIncrementAndDecrement is 30.
Long Identifier,Custom.Decompiler,DecompilerSettings,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\DecompilerSettings.cs,,The length of the parameter alwaysGenerateExceptionVariableForCatchBlocks is 45.
Long Identifier,Custom.Decompiler.Ast.Transforms,AddCheckedBlocks,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\Transforms\AddCheckedBlocks.cs,GetResultFromBlock,The length of the parameter costCheckedContextUncheckedBlockOpen is 36.
Long Identifier,Custom.Decompiler.Ast.Transforms,AddCheckedBlocks,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\Transforms\AddCheckedBlocks.cs,GetResultFromBlock,The length of the parameter nodesCheckedContextUncheckedBlockOpen is 37.
Long Identifier,Custom.Decompiler.Ast.Transforms,AddCheckedBlocks,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\Transforms\AddCheckedBlocks.cs,GetResultFromBlock,The length of the parameter costUncheckedContextCheckedBlockOpen is 36.
Long Identifier,Custom.Decompiler.Ast.Transforms,AddCheckedBlocks,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\Transforms\AddCheckedBlocks.cs,GetResultFromBlock,The length of the parameter nodesUncheckedContextCheckedBlockOpen is 37.
Long Identifier,Custom.Decompiler.Ast.Transforms,Result,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\Transforms\AddCheckedBlocks.cs,,The length of the parameter NodesToInsertInUncheckedContext is 31.
Long Identifier,Custom.Decompiler.Ast.Transforms,CombineQueryExpressions,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\Transforms\CombineQueryExpressions.cs,,The length of the parameter selectTransparentIdentifierPattern is 34.
Long Identifier,Custom.Decompiler.Ast.Transforms,ConvertConstructorCallIntoInitializer,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\Transforms\ConvertConstructorCallIntoInitializer.cs,HandleInstanceFieldInitializers,The length of the parameter instanceCtorsNotChainingWithThis is 32.
Long Identifier,Custom.Decompiler.Ast.Transforms,DelegateConstruction,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\Transforms\DelegateConstruction.cs,HandleAnonymousMethod,The length of the parameter parameterReferencingIdentifiers is 31.
Long Identifier,Custom.Decompiler.Ast.Transforms,DelegateConstruction,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\Transforms\DelegateConstruction.cs,VisitBlockStatement,The length of the parameter isDisplayClassParentPointerAssignment is 37.
Long Identifier,Custom.Decompiler.Ast.Transforms,FullyQualifyAmbiguousTypeNamesVisitor,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\Transforms\IntroduceUsingDeclarations.cs,VisitTypeDeclaration,The length of the parameter internalMembersVisibleInModule is 30.
Long Identifier,Custom.Decompiler.Ast.Transforms,FullyQualifyAmbiguousTypeNamesVisitor,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\Transforms\IntroduceUsingDeclarations.cs,IsVisible,The length of the parameter internalMembersVisibleInModule is 30.
Long Identifier,Custom.Decompiler.Ast.Transforms,FullyQualifyAmbiguousTypeNamesVisitor,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\Transforms\IntroduceUsingDeclarations.cs,IsVisible,The length of the parameter internalMembersVisibleInModule is 30.
Long Identifier,Custom.Decompiler.Ast.Transforms,FullyQualifyAmbiguousTypeNamesVisitor,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\Transforms\IntroduceUsingDeclarations.cs,IsVisible,The length of the parameter internalMembersVisibleInModule is 30.
Long Identifier,Custom.Decompiler.Ast.Transforms,FullyQualifyAmbiguousTypeNamesVisitor,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\Transforms\IntroduceUsingDeclarations.cs,,The length of the parameter isWithinTypeReferenceExpression is 31.
Long Identifier,Custom.Decompiler.Ast.Transforms,ReplaceMethodCallsWithOperators,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\Transforms\ReplaceMethodCallsWithOperators.cs,,The length of the parameter getMethodOrConstructorFromHandlePattern is 39.
Long Identifier,Custom.Decompiler.FlowAnalysis,SimplifyByRefCalls,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\FlowAnalysis\SimplifyByRefCalls.cs,,The length of the parameter redundantLoadAddressInstructions is 32.
Long Identifier,Custom.Decompiler.ILAst,AsyncDecompiler,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\AsyncDecompiler.cs,MatchTaskCreationPattern,The length of the parameter loadStateMachineForBuilderExpr is 30.
Long Identifier,Custom.Decompiler.ILAst,AsyncDecompiler,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\AsyncDecompiler.cs,MatchTaskCreationPattern,The length of the parameter loadStateMachineForBuilderExpr2 is 31.
Long Identifier,Custom.Decompiler.ILAst,AsyncDecompiler,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\AsyncDecompiler.cs,,The length of the parameter smallestGeneratedVariableIndex is 30.
Long Identifier,Custom.Decompiler.ILAst,ILAstOptimizer,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,TransformArrayInitializers,The length of the parameter maxConsecutiveDefaultValueExpressions is 37.
Long Identifier,Custom.Decompiler.ILAst,TypeAnalysis,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\TypeAnalysis.cs,RunInference,The length of the parameter numberOfExpressionsAlreadyInferred is 34.
Long Identifier,Custom.Decompiler.ILAst,TypeAnalysis,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\TypeAnalysis.cs,RunInference,The length of the parameter assignVariableTypesBasedOnPartialInformation is 44.
Long Identifier,Custom.Decompiler.ILAst,TypeAnalysis,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\TypeAnalysis.cs,RunInference,The length of the parameter anyArgumentIsMissingExpectedType is 32.
Long Statement,Custom.Decompiler.Ast,AstBuilder,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\AstBuilder.cs,IsAnonymousMethodCacheField,The length of the statement  "			return field.Name.StartsWith("CS$<>"' StringComparison.Ordinal) || field.Name.StartsWith("<>f__am"' StringComparison.Ordinal); " is 126.
Long Statement,Custom.Decompiler.Ast,AstBuilder,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\AstBuilder.cs,IsClosureType,The length of the statement  "			return type.HasGeneratedName() && type.IsCompilerGenerated() && (type.Name.Contains("DisplayClass") || type.Name.Contains("AnonStorey")); " is 137.
Long Statement,Custom.Decompiler.Ast,AstBuilder,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\AstBuilder.cs,ConvertType,The length of the statement  "				if (gType.ElementType.Namespace == "System" && gType.ElementType.Name == "Nullable`1" && gType.GenericArguments.Count == 1) { " is 125.
Long Statement,Custom.Decompiler.Ast,AstBuilder,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\AstBuilder.cs,ConvertType,The length of the statement  "				AstType baseType = ConvertType(gType.ElementType' typeAttributes' ref typeIndex' options & ~ConvertTypeOptions.IncludeTypeParameterDefinitions); " is 144.
Long Statement,Custom.Decompiler.Ast,AstBuilder,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\AstBuilder.cs,ConvertType,The length of the statement  "				AstType typeRef = ConvertType(type.DeclaringType' typeAttributes' ref typeIndex' options & ~ConvertTypeOptions.IncludeTypeParameterDefinitions); " is 144.
Long Statement,Custom.Decompiler.Ast,AstBuilder,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\AstBuilder.cs,ConvertType,The length of the statement  "				string namepart = ICSharpCode.NRefactory.TypeSystem.ReflectionHelper.SplitTypeParameterCountFromReflectionName(type.Name); " is 122.
Long Statement,Custom.Decompiler.Ast,AstBuilder,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\AstBuilder.cs,ConvertType,The length of the statement  "				if ((options & ConvertTypeOptions.IncludeTypeParameterDefinitions) == ConvertTypeOptions.IncludeTypeParameterDefinitions) { " is 123.
Long Statement,Custom.Decompiler.Ast,AstBuilder,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\AstBuilder.cs,ConvertType,The length of the statement  "					if ((options & ConvertTypeOptions.IncludeTypeParameterDefinitions) == ConvertTypeOptions.IncludeTypeParameterDefinitions) { " is 123.
Long Statement,Custom.Decompiler.Ast,AstBuilder,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\AstBuilder.cs,ApplyTypeArgumentsTo,The length of the statement  "					ICSharpCode.NRefactory.TypeSystem.ReflectionHelper.SplitTypeParameterCountFromReflectionName(type.Name' out typeParameterCount); " is 128.
Long Statement,Custom.Decompiler.Ast,AstBuilder,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\AstBuilder.cs,CreateMethod,The length of the statement  "			// constraints for override and explicit interface implementation methods are inherited from the base method' so they cannot be specified directly " is 146.
Long Statement,Custom.Decompiler.Ast,AstBuilder,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\AstBuilder.cs,CreateMethod,The length of the statement  "			if (!methodDef.IsVirtual || (methodDef.IsNewSlot && !methodDef.IsPrivate)) astMethod.Constraints.AddRange(MakeConstraints(methodDef.GenericParameters)); " is 152.
Long Statement,Custom.Decompiler.Ast,AstBuilder,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\AstBuilder.cs,CreateProperty,The length of the statement  "								astProp.Modifiers = FixUpVisibility((astProp.Modifiers & ~Modifiers.VisibilityMask) | (propVisibilityModifiers & Modifiers.VisibilityMask)); " is 140.
Long Statement,Custom.Decompiler.Ast,AstBuilder,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\AstBuilder.cs,CreateProperty,The length of the statement  "					// TODO: add some kind of notification (a comment?) about possible problems with decompiled code due to unresolved references. " is 126.
Long Statement,Custom.Decompiler.Ast,AstBuilder,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\AstBuilder.cs,CreateProperty,The length of the statement  "						astProp.Setter.Attributes.Add(new AttributeSection(ConvertMarshalInfo(lastParam' propDef.Module)) { AttributeTarget = "param" }); " is 129.
Long Statement,Custom.Decompiler.Ast,AstBuilder,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\AstBuilder.cs,CreateField,The length of the statement  "				initializer.Initializer = CreateExpressionForConstant(fieldDef.Constant' fieldDef.FieldType' fieldDef.DeclaringType.IsEnum); " is 124.
Long Statement,Custom.Decompiler.Ast,AstBuilder,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\AstBuilder.cs,ConvertAttributes,The length of the statement  "			LayoutKind defaultLayoutKind = (typeDefinition.IsValueType && !typeDefinition.IsEnum) ? LayoutKind.Sequential: LayoutKind.Auto; " is 127.
Long Statement,Custom.Decompiler.Ast,AstBuilder,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\AstBuilder.cs,ConvertAttributes,The length of the statement  "			if (layoutKind != defaultLayoutKind || charSet != CharSet.Ansi || typeDefinition.PackingSize > 0 || typeDefinition.ClassSize > 0) { " is 131.
Long Statement,Custom.Decompiler.Ast,AstBuilder,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\AstBuilder.cs,ConvertAttributes,The length of the statement  "					dllImport.AddNamedArgument("CallingConvention"' new IdentifierExpression("CallingConvention").Member(callingConvention.ToString())); " is 132.
Long Statement,Custom.Decompiler.Ast,AstBuilder,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\AstBuilder.cs,ConvertAttributes,The length of the statement  "				attributedNode.Attributes.Add(new AttributeSection(ConvertMarshalInfo(fieldDefinition' fieldDefinition.Module))  { AttributeTarget = attributeTarget }); " is 152.
Long Statement,Custom.Decompiler.Ast,AstBuilder,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\AstBuilder.cs,ConvertMarshalInfo,The length of the statement  "            var unmanagedType = new TypeReference("System.Runtime.InteropServices"' "UnmanagedType"' module' module.TypeSystem.CoreLibrary); " is 128.
Long Statement,Custom.Decompiler.Ast,AstBuilder,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\AstBuilder.cs,CreateNonCustomAttribute,The length of the statement  "                attr.Type.AddAnnotation(new TypeReference(attributeType.Namespace' attributeType.Name' module' module.TypeSystem.CoreLibrary)); " is 127.
Long Statement,Custom.Decompiler.Ast,AstBuilder,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\AstBuilder.cs,ConvertCustomAttributes,The length of the statement  "					if (customAttribute.AttributeType.Name == "ExtensionAttribute" && customAttribute.AttributeType.Namespace == "System.Runtime.CompilerServices") { " is 145.
Long Statement,Custom.Decompiler.Ast,AstBuilder,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\AstBuilder.cs,ConvertCustomAttributes,The length of the statement  "					if (customAttribute.AttributeType.Name == "ParamArrayAttribute" && customAttribute.AttributeType.Namespace == "System") { " is 121.
Long Statement,Custom.Decompiler.Ast,AstBuilder,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\AstBuilder.cs,ConvertCustomAttributes,The length of the statement  "						if (customAttribute.AttributeType.Name == "DebuggerStepThroughAttribute" && customAttribute.AttributeType.Namespace == "System.Diagnostics") { " is 142.
Long Statement,Custom.Decompiler.Ast,AstBuilder,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\AstBuilder.cs,ConvertCustomAttributes,The length of the statement  "						if (customAttribute.AttributeType.Name == "AsyncStateMachineAttribute" && customAttribute.AttributeType.Namespace == "System.Runtime.CompilerServices") { " is 153.
Long Statement,Custom.Decompiler.Ast,AstBuilder,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\AstBuilder.cs,ConvertCustomAttributes,The length of the statement  "							var propertyReference = resolvedAttributeType != null ? resolvedAttributeType.Properties.FirstOrDefault(pr => pr.Name == propertyNamedArg.Name) : null; " is 151.
Long Statement,Custom.Decompiler.Ast,AstBuilder,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\AstBuilder.cs,ConvertCustomAttributes,The length of the statement  "							var fieldReference = resolvedAttributeType != null ? resolvedAttributeType.Fields.FirstOrDefault(f => f.Name == fieldNamedArg.Name) : null; " is 139.
Long Statement,Custom.Decompiler.Ast,AstBuilder,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\AstBuilder.cs,ConvertSecurityAttributes,The length of the statement  "                    var securityActionType = new TypeReference("System.Security.Permissions"' "SecurityAction"' module' module.TypeSystem.CoreLibrary); " is 131.
Long Statement,Custom.Decompiler.Ast,AstBuilder,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\AstBuilder.cs,ConvertSecurityAttributes,The length of the statement  "							var propertyReference = resolvedAttributeType != null ? resolvedAttributeType.Properties.FirstOrDefault(pr => pr.Name == propertyNamedArg.Name) : null; " is 151.
Long Statement,Custom.Decompiler.Ast,AstBuilder,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\AstBuilder.cs,ConvertSecurityAttributes,The length of the statement  "							var fieldReference = resolvedAttributeType != null ? resolvedAttributeType.Fields.FirstOrDefault(f => f.Name == fieldNamedArg.Name) : null; " is 139.
Long Statement,Custom.Decompiler.Ast,AstBuilder,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\AstBuilder.cs,SetNewModifier,The length of the statement  "				// TODO: add some kind of notification (a comment?) about possible problems with decompiled code due to unresolved references. " is 126.
Long Statement,Custom.Decompiler.Ast,AstMethodBodyBuilder,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\AstMethodBodyBuilder.cs,TransformNode,The length of the statement  "				List<ILRange> ilRanges = ILRange.OrderAndJoint(node.GetSelfAndChildrenRecursive<ILExpression>().SelectMany(e => e.ILRanges)); " is 125.
Long Statement,Custom.Decompiler.Ast,AstMethodBodyBuilder,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\AstMethodBodyBuilder.cs,TransformNode,The length of the statement  "					Condition = ilLoop.Condition != null ? (Expression)TransformExpression(ilLoop.Condition) : new PrimitiveExpression(true)' " is 121.
Long Statement,Custom.Decompiler.Ast,AstMethodBodyBuilder,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\AstMethodBodyBuilder.cs,TransformNode,The length of the statement  "				SwitchStatement switchStmt = new SwitchStatement() { Expression = (Expression)TransformExpression(ilSwitch.Condition) }; " is 120.
Long Statement,Custom.Decompiler.Ast,AstMethodBodyBuilder,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\AstMethodBodyBuilder.cs,TransformNode,The length of the statement  "						section.CaseLabels.AddRange(caseBlock.Values.Select(i => new CaseLabel() { Expression = AstBuilder.MakePrimitive(i' ilSwitch.Condition.ExpectedType ?? ilSwitch.Condition.InferredType) })); " is 188.
Long Statement,Custom.Decompiler.Ast,AstMethodBodyBuilder,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\AstMethodBodyBuilder.cs,TransformExpression,The length of the statement  "			List<ILRange> ilRanges = ILRange.OrderAndJoint(expr.GetSelfAndChildrenRecursive<ILExpression>().SelectMany(e => e.ILRanges)); " is 125.
Long Statement,Custom.Decompiler.Ast,AstMethodBodyBuilder,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\AstMethodBodyBuilder.cs,TransformByteCode,The length of the statement  "						boe.AddAnnotation(byteCode.Code == ILCode.Add ? AddCheckedBlocks.UncheckedAnnotation : AddCheckedBlocks.CheckedAnnotation); " is 123.
Long Statement,Custom.Decompiler.Ast,AstMethodBodyBuilder,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\AstMethodBodyBuilder.cs,TransformByteCode,The length of the statement  "						boe.AddAnnotation(byteCode.Code == ILCode.Sub ? AddCheckedBlocks.UncheckedAnnotation : AddCheckedBlocks.CheckedAnnotation); " is 123.
Long Statement,Custom.Decompiler.Ast,AstMethodBodyBuilder,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\AstMethodBodyBuilder.cs,TransformByteCode,The length of the statement  "					case ILCode.Mul:        return new Ast.BinaryOperatorExpression(arg1' BinaryOperatorType.Multiply' arg2).WithAnnotation(AddCheckedBlocks.UncheckedAnnotation); " is 158.
Long Statement,Custom.Decompiler.Ast,AstMethodBodyBuilder,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\AstMethodBodyBuilder.cs,TransformByteCode,The length of the statement  "					case ILCode.Mul_Ovf:    return new Ast.BinaryOperatorExpression(arg1' BinaryOperatorType.Multiply' arg2).WithAnnotation(AddCheckedBlocks.CheckedAnnotation); " is 156.
Long Statement,Custom.Decompiler.Ast,AstMethodBodyBuilder,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\AstMethodBodyBuilder.cs,TransformByteCode,The length of the statement  "					case ILCode.Mul_Ovf_Un: return new Ast.BinaryOperatorExpression(arg1' BinaryOperatorType.Multiply' arg2).WithAnnotation(AddCheckedBlocks.CheckedAnnotation); " is 156.
Long Statement,Custom.Decompiler.Ast,AstMethodBodyBuilder,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\AstMethodBodyBuilder.cs,TransformByteCode,The length of the statement  "					case ILCode.Neg:        return new Ast.UnaryOperatorExpression(UnaryOperatorType.Minus' arg1).WithAnnotation(AddCheckedBlocks.UncheckedAnnotation); " is 147.
Long Statement,Custom.Decompiler.Ast,AstMethodBodyBuilder,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\AstMethodBodyBuilder.cs,TransformByteCode,The length of the statement  "						uoe.AddAnnotation((byteCode.Code == ILCode.PostIncrement) ? AddCheckedBlocks.UncheckedAnnotation : AddCheckedBlocks.CheckedAnnotation); " is 135.
Long Statement,Custom.Decompiler.Ast,AstMethodBodyBuilder,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\AstMethodBodyBuilder.cs,TransformByteCode,The length of the statement  "					case ILCode.TernaryOp:  return new Ast.ConditionalExpression() { Condition = arg1' TrueExpression = arg2' FalseExpression = arg3 }; " is 131.
Long Statement,Custom.Decompiler.Ast,AstMethodBodyBuilder,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\AstMethodBodyBuilder.cs,TransformByteCode,The length of the statement  "					if (arg1 is AsExpression && byteCode.Arguments[0].Code == ILCode.Isinst && TypeAnalysis.IsSameType(operand as TypeReference' byteCode.Arguments[0].Operand as TypeReference)) " is 173.
Long Statement,Custom.Decompiler.Ast,AstMethodBodyBuilder,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\AstMethodBodyBuilder.cs,TransformByteCode,The length of the statement  "					if ((byteCode.Arguments[0].InferredType != null && byteCode.Arguments[0].InferredType.IsGenericParameter) || ((Cecil.TypeReference)operand).IsGenericParameter) " is 159.
Long Statement,Custom.Decompiler.Ast,AstMethodBodyBuilder,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\AstMethodBodyBuilder.cs,TransformByteCode,The length of the statement  "						return new IdentifierExpression(loadName).Invoke(referencedEntity).WithAnnotation(new LdTokenAnnotation()).Member(handleName); " is 126.
Long Statement,Custom.Decompiler.Ast,AstMethodBodyBuilder,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\AstMethodBodyBuilder.cs,TransformCall,The length of the statement  "							return new Ast.AssignmentExpression(target.Member(prop.Name).WithAnnotation(prop).WithAnnotation(cecilMethod)' methodArgs[0]); " is 126.
Long Statement,Custom.Decompiler.Ast,AstMethodBodyBuilder,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\AstMethodBodyBuilder.cs,TransformCall,The length of the statement  "				} else if (cecilMethodDef.Name == "Invoke" && cecilMethodDef.DeclaringType.BaseType != null && cecilMethodDef.DeclaringType.BaseType.FullName == "System.MulticastDelegate") { " is 174.
Long Statement,Custom.Decompiler.Ast,NameVariables,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\NameVariables.cs,GetNameFromExpression,The length of the statement  "					} else if (mr.Name.StartsWith("Get"' StringComparison.OrdinalIgnoreCase) && mr.Name.Length >= 4 && char.IsUpper(mr.Name[3])) { " is 126.
Long Statement,Custom.Decompiler.Ast,NameVariables,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\NameVariables.cs,GetNameForArgument,The length of the statement  "						} else if (methodRef.Name.StartsWith("Set"' StringComparison.OrdinalIgnoreCase) && methodRef.Name.Length >= 4 && char.IsUpper(methodRef.Name[3])) { " is 147.
Long Statement,Custom.Decompiler.Ast,TextOutputFormatter,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\TextOutputFormatter.cs,GetCurrentMemberReference,The length of the statement  "				(memberRef == null && node.Role == Roles.TargetExpression && (node.Parent is InvocationExpression || node.Parent is ObjectCreateExpression))) " is 141.
Long Statement,Custom.Decompiler.Ast,TextOutputFormatter,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\TextOutputFormatter.cs,StartNode,The length of the statement  "			if (node is EntityDeclaration && node.Annotation<MemberReference>() != null && node.GetChildByRole(Roles.Identifier).IsNull) " is 124.
Long Statement,Custom.Decompiler.Ast,TypesHierarchyHelpers,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\TypesHierarchyHelpers.cs,IsBaseMethod,The length of the statement  "				if (!parentMethod.HasParameters || !childMethod.HasParameters || parentMethod.Parameters.Count != childMethod.Parameters.Count) " is 127.
Long Statement,Custom.Decompiler.Ast,TypesHierarchyHelpers,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\TypesHierarchyHelpers.cs,IsBaseProperty,The length of the statement  "				if (!parentProperty.HasParameters || !childProperty.HasParameters || parentProperty.Parameters.Count != childProperty.Parameters.Count) " is 135.
Long Statement,Custom.Decompiler.Ast,TypesHierarchyHelpers,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\TypesHierarchyHelpers.cs,MatchMethod,The length of the statement  "				if (!mCandidate.HasGenericParameters || !mMethod.HasGenericParameters || mCandidate.GenericParameters.Count != mMethod.GenericParameters.Count) " is 143.
Long Statement,Custom.Decompiler.Ast,TypesHierarchyHelpers,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\TypesHierarchyHelpers.cs,MatchInterfaceMethod,The length of the statement  "				var methodContext = new GenericContext<TypeDefinition>(interfaceContextType.Resolve()' ((GenericInstanceType)interfaceContextType).GenericArguments); " is 149.
Long Statement,Custom.Decompiler,CecilExtensions,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\CecilExtensions.cs,IsAnonymousType,The length of the statement  "			if (string.IsNullOrEmpty(type.Namespace) && type.HasGeneratedName() && (type.Name.Contains("AnonType") || type.Name.Contains("AnonymousType"))) { " is 145.
Long Statement,Custom.Decompiler,CecilExtensions,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\CecilExtensions.cs,GetDefaultMemberName,The length of the statement  "					if (ca.Constructor.DeclaringType.Name == "DefaultMemberAttribute" && ca.Constructor.DeclaringType.Namespace == "System.Reflection" " is 130.
Long Statement,Custom.Decompiler,CodeMappings,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\CodeMappings.cs,GetInstructionByTokenAndOffset,The length of the statement  "			var map = codeMapping.MemberCodeMappings.Find(m => m.ILInstructionOffset.From <= ilOffset && ilOffset < m.ILInstructionOffset.To); " is 130.
Long Statement,Custom.Decompiler.Ast.Transforms,AddCheckedBlocks,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\Transforms\AddCheckedBlocks.cs,GetResult,The length of the statement  "							result.NodesToInsertInUncheckedContext = result.NodesToInsertInCheckedContext + new ConvertCompoundAssignment(expr' true); " is 122.
Long Statement,Custom.Decompiler.Ast.Transforms,AddCheckedBlocks,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\Transforms\AddCheckedBlocks.cs,GetResult,The length of the statement  "							result.NodesToInsertInCheckedContext = result.NodesToInsertInUncheckedContext + new ConvertCompoundAssignment(expr' false); " is 123.
Long Statement,Custom.Decompiler.Ast.Transforms,ConvertCompoundAssignment,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\Transforms\AddCheckedBlocks.cs,Insert,The length of the statement  "				AssignmentExpression assign = expression.Annotation<ReplaceMethodCallsWithOperators.RestoreOriginalAssignOperatorAnnotation>().Restore(expression); " is 147.
Long Statement,Custom.Decompiler.Ast.Transforms,ConvertConstructorCallIntoInitializer,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\Transforms\ConvertConstructorCallIntoInitializer.cs,HandleInstanceFieldInitializers,The length of the statement  "			var instanceCtors = members.OfType<ConstructorDeclaration>().Where(c => (c.Modifiers & Modifiers.Static) == 0).ToArray(); " is 121.
Long Statement,Custom.Decompiler.Ast.Transforms,ConvertConstructorCallIntoInitializer,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\Transforms\ConvertConstructorCallIntoInitializer.cs,HandleInstanceFieldInitializers,The length of the statement  "			var instanceCtorsNotChainingWithThis = instanceCtors.Where(ctor => !thisCallPattern.IsMatch(ctor.Body.Statements.FirstOrDefault())).ToArray(); " is 142.
Long Statement,Custom.Decompiler.Ast.Transforms,ConvertConstructorCallIntoInitializer,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\Transforms\ConvertConstructorCallIntoInitializer.cs,HandleInstanceFieldInitializers,The length of the statement  "					FieldDefinition fieldDef = m.Get<AstNode>("fieldAccess").Single().Annotation<FieldReference>().ResolveWithinSameModule(); " is 121.
Long Statement,Custom.Decompiler.Ast.Transforms,ConvertConstructorCallIntoInitializer,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\Transforms\ConvertConstructorCallIntoInitializer.cs,RemoveSingleEmptyConstructor,The length of the statement  "			var instanceCtors = typeDeclaration.Members.OfType<ConstructorDeclaration>().Where(c => (c.Modifiers & Modifiers.Static) == 0).ToArray(); " is 137.
Long Statement,Custom.Decompiler.Ast.Transforms,ConvertConstructorCallIntoInitializer,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\Transforms\ConvertConstructorCallIntoInitializer.cs,RemoveSingleEmptyConstructor,The length of the statement  "				emptyCtor.Modifiers = ((typeDeclaration.Modifiers & Modifiers.Abstract) == Modifiers.Abstract ? Modifiers.Protected : Modifiers.Public); " is 136.
Long Statement,Custom.Decompiler.Ast.Transforms,ConvertConstructorCallIntoInitializer,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\Transforms\ConvertConstructorCallIntoInitializer.cs,HandleStaticFieldInitializers,The length of the statement  "			var staticCtor = members.OfType<ConstructorDeclaration>().FirstOrDefault(c => (c.Modifiers & Modifiers.Static) == Modifiers.Static); " is 132.
Long Statement,Custom.Decompiler.Ast.Transforms,ConvertConstructorCallIntoInitializer,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\Transforms\ConvertConstructorCallIntoInitializer.cs,HandleStaticFieldInitializers,The length of the statement  "						FieldDeclaration fieldDecl = members.OfType<FieldDeclaration>().FirstOrDefault(f => f.Annotation<FieldDefinition>() == fieldDef); " is 129.
Long Statement,Custom.Decompiler.Ast.Transforms,DecimalConstantTransform,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\Transforms\DecimalConstantTransform.cs,VisitFieldDeclaration,The length of the statement  "			if ((fieldDeclaration.Modifiers & staticReadOnly) == staticReadOnly && decimalType.IsMatch(fieldDeclaration.ReturnType)) { " is 122.
Long Statement,Custom.Decompiler.Ast.Transforms,DeclareVariables,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\Transforms\DeclareVariables.cs,Run,The length of the statement  "			// First do all the insertions' then do all the replacements. This is necessary because a replacement might remove our reference point from the AST. " is 148.
Long Statement,Custom.Decompiler.Ast.Transforms,DeclareVariables,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\Transforms\DeclareVariables.cs,Run,The length of the statement  "					VariableInitializer initializer = new VariableInitializer(v.Name' v.ReplacedAssignment.Right.Detach()).CopyAnnotationsFrom(v.ReplacedAssignment).WithAnnotation(v.ILVariable); " is 174.
Long Statement,Custom.Decompiler.Ast.Transforms,DeclareVariables,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\Transforms\DeclareVariables.cs,DeclareVariableInBlock,The length of the statement  "			bool canMoveVariableIntoSubBlocks = FindDeclarationPoint(daa' variableName' allowPassIntoLoops' block' out declarationPoint); " is 125.
Long Statement,Custom.Decompiler.Ast.Transforms,DeclareVariables,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\Transforms\DeclareVariables.cs,DeclareVariableInBlock,The length of the statement  "						if (TryConvertAssignmentExpressionIntoVariableDeclaration((Expression)usingStmt.ResourceAcquisition' type' variableName)) " is 121.
Long Statement,Custom.Decompiler.Ast.Transforms,DeclareVariables,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\Transforms\DeclareVariables.cs,DeclareVariableInBlock,The length of the statement  "					variablesToDeclare.Add(new VariableToDeclare { Type = type' Name = variableName' ILVariable = v' InsertionPoint = declarationPoint }); " is 134.
Long Statement,Custom.Decompiler.Ast.Transforms,DeclareVariables,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\Transforms\DeclareVariables.cs,TryConvertAssignmentExpressionIntoVariableDeclaration,The length of the statement  "					variablesToDeclare.Add(new VariableToDeclare { Type = type' Name = variableName' ILVariable = ident.Annotation<ILVariable>()' ReplacedAssignment = ae }); " is 153.
Long Statement,Custom.Decompiler.Ast.Transforms,DeclareVariables,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\Transforms\DeclareVariables.cs,FindDeclarationPoint,The length of the statement  "			bool allowPassIntoLoops = varDecl.Variables.Single().Annotation<DelegateConstruction.CapturedVariableAnnotation>() == null; " is 123.
Long Statement,Custom.Decompiler.Ast.Transforms,DeclareVariables,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\Transforms\DeclareVariables.cs,CanMoveVariableUseIntoSubBlock,The length of the statement  "			if (!allowPassIntoLoops && (stmt is ForStatement || stmt is ForeachStatement || stmt is DoWhileStatement || stmt is WhileStatement)) " is 132.
Long Statement,Custom.Decompiler.Ast.Transforms,DeclareVariables,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\Transforms\DeclareVariables.cs,CanMoveVariableUseIntoSubBlock,The length of the statement  "			// We can move the variable into a sub-block only if the variable is used in only that sub-block (and not in expressions such as the loop condition) " is 148.
Long Statement,Custom.Decompiler.Ast.Transforms,DelegateConstruction,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\Transforms\DelegateConstruction.cs,HandleAnonymousMethod,The length of the statement  "			if (target != null && !(target is IdentifierExpression || target is ThisReferenceExpression || target is NullReferenceExpression)) " is 130.
Long Statement,Custom.Decompiler.Ast.Transforms,DelegateConstruction,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\Transforms\DelegateConstruction.cs,VisitBlockStatement,The length of the statement  "				if (displayClassAssignmentMatch.Get<AstType>("type").Single().Annotation<TypeReference>().ResolveWithinSameModule() != type) " is 124.
Long Statement,Custom.Decompiler.Ast.Transforms,DelegateConstruction,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\Transforms\DelegateConstruction.cs,VisitBlockStatement,The length of the statement  "				VariableDeclarationStatement displayClassVarDecl = PatternStatementTransform.FindVariableDeclaration(stmt' variable.Name); " is 122.
Long Statement,Custom.Decompiler.Ast.Transforms,DelegateConstruction,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\Transforms\DelegateConstruction.cs,VisitBlockStatement,The length of the statement  "						FieldDefinition fieldDef = m.Get<MemberReferenceExpression>("left").Single().Annotation<FieldReference>().ResolveWithinSameModule(); " is 132.
Long Statement,Custom.Decompiler.Ast.Transforms,DelegateConstruction,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\Transforms\DelegateConstruction.cs,VisitBlockStatement,The length of the statement  "			currentlyUsedVariableNames.RemoveRange(numberOfVariablesOutsideBlock' currentlyUsedVariableNames.Count - numberOfVariablesOutsideBlock); " is 136.
Long Statement,Custom.Decompiler.Ast.Transforms,IntroduceExtensionMethods,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\Transforms\IntroduceExtensionMethods.cs,Run,The length of the statement  "									firstArgument = firstArgument.ReplaceWith(expr => expr.CastTo(AstBuilder.ConvertType(d.Parameters.First().ParameterType))); " is 123.
Long Statement,Custom.Decompiler.Ast.Transforms,IntroduceQueryExpressions,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\Transforms\IntroduceQueryExpressions.cs,Run,The length of the statement  "			// After all queries were decompiled' detect degenerate queries (queries not property terminated with 'select' or 'group') " is 122.
Long Statement,Custom.Decompiler.Ast.Transforms,IntroduceQueryExpressions,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\Transforms\IntroduceQueryExpressions.cs,DecompileQuery,The length of the statement  "								query.Clauses.Add(new QueryGroupClause { Projection = new IdentifierExpression(parameterName)' Key = keySelector.Detach() }); " is 125.
Long Statement,Custom.Decompiler.Ast.Transforms,FullyQualifyAmbiguousTypeNamesVisitor,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\Transforms\IntroduceUsingDeclarations.cs,VisitTypeDeclaration,The length of the statement  "						if (privateMembersVisible || IsVisible(property.GetMethod' internalMembersVisibleInModule) || IsVisible(property.SetMethod' internalMembersVisibleInModule)) " is 156.
Long Statement,Custom.Decompiler.Ast.Transforms,FullyQualifyAmbiguousTypeNamesVisitor,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\Transforms\IntroduceUsingDeclarations.cs,VisitTypeDeclaration,The length of the statement  "						if (privateMembersVisible || IsVisible(ev.AddMethod' internalMembersVisibleInModule) || IsVisible(ev.RemoveMethod' internalMembersVisibleInModule)) " is 147.
Long Statement,Custom.Decompiler.Ast.Transforms,PatternStatementTransform,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\Transforms\PatternStatementTransform.cs,TransformUsings,The length of the statement  "			if (usingStatement.EmbeddedStatement.Descendants.OfType<IdentifierExpression>().Any(ident => ident.Identifier == variableName)) { " is 129.
Long Statement,Custom.Decompiler.Ast.Transforms,PatternStatementTransform,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\Transforms\PatternStatementTransform.cs,CanMoveVariableDeclarationIntoStatement,The length of the statement  "			List<BlockStatement> blocks = targetStatement.Ancestors.TakeWhile(block => block != varDecl.Parent).OfType<BlockStatement>().ToList(); " is 134.
Long Statement,Custom.Decompiler.Ast.Transforms,PatternStatementTransform,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\Transforms\PatternStatementTransform.cs,TransformForeach,The length of the statement  "				// if there are variables outside the loop' we need to put those into the parent block' and that won't work if the direct parent isn't a block " is 142.
Long Statement,Custom.Decompiler.Ast.Transforms,PatternStatementTransform,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\Transforms\PatternStatementTransform.cs,TransformForeach,The length of the statement  "			// Because we look only outside the loop' we won't make the mistake of moving a captured variable across the loop boundary " is 122.
Long Statement,Custom.Decompiler.Ast.Transforms,PatternStatementTransform,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\Transforms\PatternStatementTransform.cs,TransformNonGenericForEach,The length of the statement  "			// Because we look only outside the loop' we won't make the mistake of moving a captured variable across the loop boundary " is 122.
Long Statement,Custom.Decompiler.Ast.Transforms,PatternStatementTransform,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\Transforms\PatternStatementTransform.cs,TransformFor,The length of the statement  "			if (m1.Get<IdentifierExpression>("variable").Single().Identifier != m2.Get<IdentifierExpression>("ident").Single().Identifier) " is 126.
Long Statement,Custom.Decompiler.Ast.Transforms,PatternStatementTransform,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\Transforms\PatternStatementTransform.cs,TransformDoWhile,The length of the statement  "				doLoop.Condition = new UnaryOperatorExpression(UnaryOperatorType.Not' m.Get<Expression>("condition").Single().Detach()); " is 120.
Long Statement,Custom.Decompiler.Ast.Transforms,PatternStatementTransform,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\Transforms\PatternStatementTransform.cs,TransformLock,The length of the statement  "			if (m1.Get<IdentifierExpression>("variable").Single().Identifier == m2.Get<IdentifierExpression>("flag").Single().Identifier) { " is 127.
Long Statement,Custom.Decompiler.Ast.Transforms,PatternStatementTransform,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\Transforms\PatternStatementTransform.cs,TransformSwitchOnString,The length of the statement  "			// switchVar must be the same as switchExpr; or switchExpr must be an assignment and switchVar the left side of that assignment " is 127.
Long Statement,Custom.Decompiler.Ast.Transforms,PatternStatementTransform,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\Transforms\PatternStatementTransform.cs,TransformAutomaticProperties,The length of the statement  "				FieldDefinition field = m.Get<AstNode>("fieldReference").Single().Annotation<FieldReference>().ResolveWithinSameModule(); " is 121.
Long Statement,Custom.Decompiler.Ast.Transforms,PushNegation,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\Transforms\PushNegation.cs,VisitBinaryOperatorExpression,The length of the statement  "			if (op == BinaryOperatorType.Equality && rightOperand == true || op == BinaryOperatorType.InEquality && rightOperand == false) { " is 128.
Long Statement,Custom.Decompiler.Ast.Transforms,PushNegation,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\Transforms\PushNegation.cs,VisitBinaryOperatorExpression,The length of the statement  "			} else if (op == BinaryOperatorType.Equality && rightOperand == false || op == BinaryOperatorType.InEquality && rightOperand == true) { " is 135.
Long Statement,Custom.Decompiler.Ast.Transforms,ReplaceMethodCallsWithOperators,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\Transforms\ReplaceMethodCallsWithOperators.cs,ProcessInvocationExpression,The length of the statement  "				case "System.Reflection.FieldInfo System.Reflection.FieldInfo::GetFieldFromHandle(System.RuntimeFieldHandle'System.RuntimeTypeHandle)": " is 135.
Long Statement,Custom.Decompiler.Ast.Transforms,ReplaceMethodCallsWithOperators,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\Transforms\ReplaceMethodCallsWithOperators.cs,VisitAssignmentExpression,The length of the statement  "			if (context.Settings.IntroduceIncrementAndDecrement && (assignment.Operator == AssignmentOperatorType.Add || assignment.Operator == AssignmentOperatorType.Subtract)) { " is 167.
Long Statement,Custom.Decompiler.Ast.Transforms,ReplaceMethodCallsWithOperators,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\Transforms\ReplaceMethodCallsWithOperators.cs,VisitAssignmentExpression,The length of the statement  "							type = (assignment.Operator == AssignmentOperatorType.Add) ? UnaryOperatorType.PostIncrement : UnaryOperatorType.PostDecrement; " is 127.
Long Statement,Custom.Decompiler.Ast.Transforms,ReplaceMethodCallsWithOperators,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\Transforms\ReplaceMethodCallsWithOperators.cs,IsWithoutSideEffects,The length of the statement  "			return left is ThisReferenceExpression || left is IdentifierExpression || left is TypeReferenceExpression || left is BaseReferenceExpression; " is 141.
Long Statement,Custom.Decompiler.Ast.Transforms,ReplaceMethodCallsWithOperators,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\Transforms\ReplaceMethodCallsWithOperators.cs,VisitCastExpression,The length of the statement  "					newNode = newNode.Invoke(method.Parameters.Select(p => new TypeReferenceExpression(AstBuilder.ConvertType(p.ParameterType' p)))); " is 129.
Long Statement,Custom.Decompiler.Disassembler,DisassemblerHelpers,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Disassembler\DisassemblerHelpers.cs,WriteTo,The length of the statement  "			ILNameSyntax syntaxForElementTypes = syntax == ILNameSyntax.SignatureNoNamedTypeParameters ? syntax : ILNameSyntax.Signature; " is 125.
Long Statement,Custom.Decompiler.Disassembler,DisassemblerHelpers,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Disassembler\DisassemblerHelpers.cs,WriteTo,The length of the statement  "				} else if ((syntax == ILNameSyntax.Signature || syntax == ILNameSyntax.SignatureNoNamedTypeParameters) && name != null) { " is 121.
Long Statement,Custom.Decompiler.Disassembler,ILStructure,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Disassembler\ILStructure.cs,AddNestedStructure,The length of the statement  "			if (this.Type == ILStructureType.Loop && newStructure.Type == ILStructureType.Loop && newStructure.StartOffset == this.StartOffset) " is 131.
Long Statement,Custom.Decompiler.Disassembler,MethodBodyDisassembler,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Disassembler\MethodBodyDisassembler.cs,Disassemble,The length of the statement  "								ILInstructionOffset = new ILRange { From = inst.Offset' To = inst.Next == null ? method.Body.CodeSize : inst.Next.Offset }' " is 123.
Long Statement,Custom.Decompiler.Disassembler,MethodBodyDisassembler,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Disassembler\MethodBodyDisassembler.cs,WriteStructureBody,The length of the statement  "				if (childIndex < s.Children.Count && s.Children[childIndex].StartOffset <= offset && offset < s.Children[childIndex].EndOffset) { " is 129.
Long Statement,Custom.Decompiler.Disassembler,ReflectionDisassembler,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Disassembler\ReflectionDisassembler.cs,DisassembleMethodInternal,The length of the statement  "			WriteFlags(method.ImplAttributes & ~(MethodImplAttributes.CodeTypeMask | MethodImplAttributes.ManagedMask)' methodImpl); " is 120.
Long Statement,Custom.Decompiler.Disassembler,ReflectionDisassembler,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Disassembler\ReflectionDisassembler.cs,DisassembleMethodInternal,The length of the statement  "			CloseBlock("end of method " + DisassemblerHelpers.Escape(method.DeclaringType.Name) + "::" + DisassemblerHelpers.Escape(method.Name)); " is 134.
Long Statement,Custom.Decompiler.Disassembler,ReflectionDisassembler,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Disassembler\ReflectionDisassembler.cs,WriteSecurityDeclarationArgument,The length of the statement  "				output.Write("string('{0}')"' ICSharpCode.NRefactory.CSharp.CSharpOutputVisitor.ConvertString((string)na.Argument.Value).Replace("'"' "\'")); " is 141.
Long Statement,Custom.Decompiler.Disassembler,ReflectionDisassembler,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Disassembler\ReflectionDisassembler.cs,WriteNativeType,The length of the statement  "						output.Write("' \"{0}\"' \"{1}\""' cmi.Guid.ToString()' ICSharpCode.NRefactory.CSharp.CSharpOutputVisitor.ConvertString(cmi.UnmanagedType)); " is 140.
Long Statement,Custom.Decompiler.Disassembler,ReflectionDisassembler,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Disassembler\ReflectionDisassembler.cs,DisassembleField,The length of the statement  "			const FieldAttributes hasXAttributes = FieldAttributes.HasDefault | FieldAttributes.HasFieldMarshal | FieldAttributes.HasFieldRVA; " is 130.
Long Statement,Custom.Decompiler.Disassembler,ReflectionDisassembler,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Disassembler\ReflectionDisassembler.cs,DisassembleType,The length of the statement  "			const TypeAttributes masks = TypeAttributes.ClassSemanticMask | TypeAttributes.VisibilityMask | TypeAttributes.LayoutMask | TypeAttributes.StringFormatMask; " is 156.
Long Statement,Custom.Decompiler.Disassembler,ReflectionDisassembler,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Disassembler\ReflectionDisassembler.cs,WriteAssemblyReferences,The length of the statement  "					output.WriteLine(".ver {0}:{1}:{2}:{3}"' aref.Version.Major' aref.Version.Minor' aref.Version.Build' aref.Version.Revision); " is 124.
Long Statement,Custom.Decompiler.FlowAnalysis,ControlFlowGraph,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\FlowAnalysis\ControlFlowGraph.cs,ExportGraph,The length of the statement  "					graph.AddEdge(new GraphVizEdge(node.ImmediateDominator.BlockIndex' node.BlockIndex) { color = "green"' constraint = false }); " is 125.
Long Statement,Custom.Decompiler.FlowAnalysis,ControlFlowGraphBuilder,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\FlowAnalysis\ControlFlowGraphBuilder.cs,CalculateHasIncomingJumps,The length of the statement  "				if (inst.OpCode.OperandType == OperandType.InlineBrTarget || inst.OpCode.OperandType == OperandType.ShortInlineBrTarget) { " is 122.
Long Statement,Custom.Decompiler.FlowAnalysis,ControlFlowGraphBuilder,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\FlowAnalysis\ControlFlowGraphBuilder.cs,CreateNodes,The length of the statement  "					endFinallyOrFaultNode = new ControlFlowNode(nodes.Count' handler.HandlerEnd.Offset' ControlFlowNodeType.EndFinallyOrFault); " is 123.
Long Statement,Custom.Decompiler.FlowAnalysis,ControlFlowGraphBuilder,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\FlowAnalysis\ControlFlowGraphBuilder.cs,CreateRegularControlFlow,The length of the statement  "					if (node.End.OpCode.OperandType == OperandType.InlineBrTarget || node.End.OpCode.OperandType == OperandType.ShortInlineBrTarget) { " is 130.
Long Statement,Custom.Decompiler.FlowAnalysis,ControlFlowNode,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\FlowAnalysis\ControlFlowNode.cs,ToString,The length of the statement  "				writer.Write("DominanceFrontier: " + string.Join("'"' DominanceFrontier.OrderBy(d => d.BlockIndex).Select(d => d.BlockIndex.ToString()))); " is 138.
Long Statement,Custom.Decompiler.FlowAnalysis,ControlStructureDetector,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\FlowAnalysis\ControlStructureDetector.cs,DetectStructure,The length of the statement  "			ControlStructure root = new ControlStructure(new HashSet<ControlFlowNode>(g.Nodes)' g.EntryPoint' ControlStructureType.Root); " is 125.
Long Statement,Custom.Decompiler.FlowAnalysis,ControlStructureDetector,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\FlowAnalysis\ControlStructureDetector.cs,DetectExceptionHandling,The length of the statement  "			// For each exception handler' we determine the nodes and substructures inside that handler' and move them into a new substructure. " is 131.
Long Statement,Custom.Decompiler.FlowAnalysis,ControlStructureDetector,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\FlowAnalysis\ControlStructureDetector.cs,DetectExceptionHandling,The length of the statement  "			// This is always possible because exception handlers are guaranteed (by the CLR spec) to be properly nested and non-overlapping; " is 129.
Long Statement,Custom.Decompiler.FlowAnalysis,SimplifyByRefCalls,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\FlowAnalysis\SimplifyByRefCalls.cs,IsLoadAddress,The length of the statement  "			return inst.Instruction != null && (inst.Instruction.OpCode == OpCodes.Ldloca || inst.Instruction.OpCode == OpCodes.Ldarga); " is 124.
Long Statement,Custom.Decompiler.FlowAnalysis,SsaFormBuilder,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\FlowAnalysis\SsaFormBuilder.cs,CreateSpecialInstructions,The length of the statement  "				ssaForm.EntryPoint.Instructions.Add(new SsaInstruction(ssaForm.EntryPoint' null' v' null' specialOpCode: SpecialOpCode.Parameter)); " is 131.
Long Statement,Custom.Decompiler.FlowAnalysis,SsaFormBuilder,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\FlowAnalysis\SsaFormBuilder.cs,CreateSpecialInstructions,The length of the statement  "				ssaForm.EntryPoint.Instructions.Add(new SsaInstruction(ssaForm.EntryPoint' null' v' null' specialOpCode: SpecialOpCode.Uninitialized)); " is 135.
Long Statement,Custom.Decompiler.FlowAnalysis,SsaFormBuilder,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\FlowAnalysis\SsaFormBuilder.cs,CreateSpecialInstructions,The length of the statement  "				ssaForm.EntryPoint.Instructions.Add(new SsaInstruction(ssaForm.EntryPoint' null' v' null' specialOpCode: SpecialOpCode.Uninitialized)); " is 135.
Long Statement,Custom.Decompiler.FlowAnalysis,SsaOptimization,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\FlowAnalysis\SsaOptimization.cs,DirectlyStoreToVariables,The length of the statement  "						if (inst.Instruction != null && (inst.Instruction.OpCode == OpCodes.Stloc || inst.Instruction.OpCode == OpCodes.Starg)) { " is 121.
Long Statement,Custom.Decompiler.ILAst,AsyncDecompiler,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\AsyncDecompiler.cs,MatchTaskCreationPattern,The length of the statement  "			if (!method.Body[method.Body.Count - 2].Match(ILCode.Call' out startMethod' out loadStartTarget' out loadStartArgument)) " is 120.
Long Statement,Custom.Decompiler.ILAst,AsyncDecompiler,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\AsyncDecompiler.cs,MatchTaskCreationPattern,The length of the statement  "			if (startMethod.Name != "Start" || startMethod.DeclaringType == null || startMethod.DeclaringType.Namespace != "System.Runtime.CompilerServices") " is 145.
Long Statement,Custom.Decompiler.ILAst,AsyncDecompiler,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\AsyncDecompiler.cs,MatchTaskCreationPattern,The length of the statement  "				if (builderField2.ResolveWithinSameModule() != builderField || !loadStateMachineForBuilderExpr2.MatchLdloca(stateMachineVar)) " is 125.
Long Statement,Custom.Decompiler.ILAst,AsyncDecompiler,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\AsyncDecompiler.cs,ValidateCatchBlock,The length of the statement  "			if (!(setExceptionMethod.Name == "SetException" && IsBuilderFieldOnThis(builderExpr) && exceptionExpr.MatchLdloc(catchBlock.ExceptionVariable))) " is 144.
Long Statement,Custom.Decompiler.ILAst,AsyncDecompiler,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\AsyncDecompiler.cs,ConvertBody,The length of the statement  "					StateRangeAnalysis rangeAnalysis = new StateRangeAnalysis(tryBody[0]' StateRangeAnalysisMode.AsyncMoveNext' stateField); " is 120.
Long Statement,Custom.Decompiler.ILAst,AsyncDecompiler,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\AsyncDecompiler.cs,HandleAwait,The length of the statement  "			// call(AsyncTaskMethodBuilder::AwaitUnsafeOnCompleted' ldflda(StateMachine::<>t__builder' ldloc(this))' ldloca(CS$0$0001)' ldloc(this)) " is 136.
Long Statement,Custom.Decompiler.ILAst,AsyncDecompiler,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\AsyncDecompiler.cs,Step2,The length of the statement  "			// brtrue(IL_7C' call(valuetype [mscorlib]System.Runtime.CompilerServices.TaskAwaiter`1<bool>::get_IsCompleted' ldloca(CS$0$0001))) " is 131.
Long Statement,Custom.Decompiler.ILAst,AsyncDecompiler,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\AsyncDecompiler.cs,Step2,The length of the statement  "			// arg_8B_0 = call(valuetype [mscorlib]System.Runtime.CompilerServices.TaskAwaiter`1<bool>::GetResult' ldloca(CS$0$0001)) " is 121.
Long Statement,Custom.Decompiler.ILAst,AsyncDecompiler,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\AsyncDecompiler.cs,Step2,The length of the statement  "			if (!(getAwaiterCall.Match(ILCode.Call' out getAwaiterMethod' out awaitedExpr) || getAwaiterCall.Match(ILCode.Callvirt' out getAwaiterMethod' out awaitedExpr))) " is 160.
Long Statement,Custom.Decompiler.ILAst,AsyncDecompiler,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\AsyncDecompiler.cs,Step2,The length of the statement  "			// brtrue(IL_7C' call(valuetype [mscorlib]System.Runtime.CompilerServices.TaskAwaiter`1<bool>::get_IsCompleted' ldloca(CS$0$0001))) " is 131.
Long Statement,Custom.Decompiler.ILAst,GotoRemoval,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\GotoRemoval.cs,RemoveGotos,The length of the statement  "				foreach (ILExpression gotoExpr in method.GetSelfAndChildrenRecursive<ILExpression>(e => e.Code == ILCode.Br || e.Code == ILCode.Leave)) { " is 137.
Long Statement,Custom.Decompiler.ILAst,GotoRemoval,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\GotoRemoval.cs,RemoveRedundantCode,The length of the statement  "			HashSet<ILLabel> liveLabels = new HashSet<ILLabel>(method.GetSelfAndChildrenRecursive<ILExpression>(e => e.IsBranch()).SelectMany(e => e.GetBranchTargets())); " is 158.
Long Statement,Custom.Decompiler.ILAst,GotoRemoval,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\GotoRemoval.cs,RemoveRedundantCode,The length of the statement  "				block.Body = block.Body.Where(n => !n.Match(ILCode.Nop) && !(n is ILLabel && !liveLabels.Contains((ILLabel)n))).ToList(); " is 121.
Long Statement,Custom.Decompiler.ILAst,GotoRemoval,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\GotoRemoval.cs,RemoveRedundantCode,The length of the statement  "				if (defaultCase == null || (defaultCase.Body.Count == 1 && defaultCase.Body.Single().Match(ILCode.LoopOrSwitchBreak))) { " is 120.
Long Statement,Custom.Decompiler.ILAst,GotoRemoval,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\GotoRemoval.cs,RemoveRedundantCode,The length of the statement  "			if (method.Body.Count > 0 && method.Body.Last().Match(ILCode.Ret) && ((ILExpression)method.Body.Last()).Arguments.Count == 0) { " is 127.
Long Statement,Custom.Decompiler.ILAst,GotoRemoval,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\GotoRemoval.cs,Enter,The length of the statement  "					if (GetParents(expr).OfType<ILTryCatchBlock>().FirstOrDefault() == GetParents(target).OfType<ILTryCatchBlock>().FirstOrDefault()) " is 129.
Long Statement,Custom.Decompiler.ILAst,ILAstBuilder,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\ILAstBuilder.cs,StackAnalysis,The length of the statement  "			var exceptionHandlerStarts = new HashSet<ByteCode>(methodDef.Body.ExceptionHandlers.Select(eh => instrToByteCode[eh.HandlerStart])); " is 132.
Long Statement,Custom.Decompiler.ILAst,ILAstBuilder,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\ILAstBuilder.cs,StackAnalysis,The length of the statement  "				StackSlot[] newStack = StackSlot.ModifyStack(byteCode.StackBefore' byteCode.PopCount ?? byteCode.StackBefore.Length' byteCode.PushCount' byteCode); " is 147.
Long Statement,Custom.Decompiler.ILAst,ILAstBuilder,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\ILAstBuilder.cs,StackAnalysis,The length of the statement  "					ILVariable tmpVar = new ILVariable() { Name = string.Format("arg_{0:X2}_{1}"' byteCode.Offset' argIdx)' IsGenerated = true }; " is 125.
Long Statement,Custom.Decompiler.ILAst,ILAstBuilder,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\ILAstBuilder.cs,StackAnalysis,The length of the statement  "					var loadedBy = locVars.Select(locVar => body.SelectMany(bc => bc.StackBefore).Single(s => s.LoadFrom == locVar)).ToList(); " is 122.
Long Statement,Custom.Decompiler.ILAst,ILAstBuilder,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\ILAstBuilder.cs,ConvertLocalVariables,The length of the statement  "				if (!optimize || varDef.IsPinned || uses.Any(b => b.VariablesBefore[varDef.Index].UnknownDefinition || (b.Code == ILCode.Ldloca && !IsDeterministicLdloca(b)))) {				 " is 161.
Long Statement,Custom.Decompiler.ILAst,ILAstBuilder,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\ILAstBuilder.cs,ConvertToAst,The length of the statement  "				var handlers = ehs.Where(eh => eh.TryStart.Offset == tryStart && eh.TryEnd.Offset == tryEnd).OrderBy(eh => eh.TryStart.Offset).ToList(); " is 136.
Long Statement,Custom.Decompiler.ILAst,ILAstBuilder,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\ILAstBuilder.cs,ConvertToAst,The length of the statement  "					HashSet<ExceptionHandler> nestedEHs = new HashSet<ExceptionHandler>(ehs.Where(eh => (tryStart <= eh.TryStart.Offset && eh.TryEnd.Offset < tryEnd) || (tryStart < eh.TryStart.Offset && eh.TryEnd.Offset <= tryEnd))); " is 213.
Long Statement,Custom.Decompiler.ILAst,ILAstBuilder,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\ILAstBuilder.cs,ConvertToAst,The length of the statement  "					HashSet<ExceptionHandler> nestedEHs = new HashSet<ExceptionHandler>(ehs.Where(e => (eh.HandlerStart.Offset <= e.TryStart.Offset && e.TryEnd.Offset < handlerEndOffset) || (eh.HandlerStart.Offset < e.TryStart.Offset && e.TryEnd.Offset <= handlerEndOffset))); " is 256.
Long Statement,Custom.Decompiler.ILAst,ILAstBuilder,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\ILAstBuilder.cs,ConvertToAst,The length of the statement  "									catchBlock.ExceptionVariable = new ILVariable() { Name = "ex_" + eh.HandlerStart.Offset.ToString("X2")' IsGenerated = true }; " is 125.
Long Statement,Custom.Decompiler.ILAst,ILAstOptimizer,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,RemoveRedundantCode,The length of the statement  "			foreach (ILLabel target in method.GetSelfAndChildrenRecursive<ILExpression>(e => e.IsBranch()).SelectMany(e => e.GetBranchTargets())) { " is 135.
Long Statement,Custom.Decompiler.ILAst,ILAstOptimizer,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,DuplicateReturnStatements,The length of the statement  "                                    block.Body[i] = new ILExpression(ILCode.Ret' null) { Original = new List<ILExpression> { (ILExpression)block.Body[i] } }; " is 121.
Long Statement,Custom.Decompiler.ILAst,ILAstOptimizer,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,DuplicateReturnStatements,The length of the statement  "                                    block.Body[i] = new ILExpression(ILCode.Ret' null' new ILExpression(ILCode.Ldloc' locVar)) { Original = new List<ILExpression> { (ILExpression)block.Body[i] } }; " is 161.
Long Statement,Custom.Decompiler.ILAst,ILAstOptimizer,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,DuplicateReturnStatements,The length of the statement  "                                    block.Body[i] = new ILExpression(ILCode.Ret' null' new ILExpression(ILCode.Ldc_I4' constValue)) { Original = new List<ILExpression> { (ILExpression)block.Body[i] } }; " is 166.
Long Statement,Custom.Decompiler.ILAst,ILAstOptimizer,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,RecombineVariables,The length of the statement  "			// The DeclareVariables transformation might then split up the C# variable again if it is used indendently in two separate scopes. " is 130.
Long Statement,Custom.Decompiler.ILAst,ILAstOptimizer,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,ReportUnassignedILRanges,The length of the statement  "			var unassigned = ILRange.Invert(method.GetSelfAndChildrenRecursive<ILExpression>().SelectMany(e => e.ILRanges)' context.CurrentMethod.Body.CodeSize).ToList(); " is 158.
Long Statement,Custom.Decompiler.ILAst,ILAstOptimizer,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,ReportUnassignedILRanges,The length of the statement  "				Debug.WriteLine(string.Format("Unassigned ILRanges for {0}.{1}: {2}"' this.context.CurrentMethod.DeclaringType.Name' this.context.CurrentMethod.Name' string.Join("' "' unassigned.Select(r => r.ToString())))); " is 208.
Long Statement,Custom.Decompiler.ILAst,ILAstOptimizer,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,TransformArrayInitializers,The length of the statement  "				if (ForwardScanInitializeArrayRuntimeHelper(body' pos + 1' v' elementType' arrayLength' out newArr' out initArrayPos)) { " is 120.
Long Statement,Custom.Decompiler.ILAst,ILAstOptimizer,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,TransformMultidimensionalArrayInitializers,The length of the statement  "				if (ForwardScanInitializeArrayRuntimeHelper(body' pos + 1' v' arrayType' totalElements' out newArr' out initArrayPos)) { " is 120.
Long Statement,Custom.Decompiler.ILAst,ILAstOptimizer,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,TransformObjectInitializers,The length of the statement  "			ILExpression initializer = ParseObjectInitializer(body' ref pos' v' newObjExpr' IsCollectionType(newObjType)' isValueType); " is 123.
Long Statement,Custom.Decompiler.ILAst,ILAstOptimizer,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,ParseObjectInitializer,The length of the statement  "			ILExpression objectInitializer = new ILExpression(isCollection ? ILCode.InitCollection : ILCode.InitObject' null' newObjExpr); " is 126.
Long Statement,Custom.Decompiler.ILAst,ILAstOptimizer,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,CachedDelegateInitializationWithField,The length of the statement  "			FieldDefinition field = ((FieldReference)condition.Operand).ResolveWithinSameModule(); // field is defined in current assembly " is 126.
Long Statement,Custom.Decompiler.ILAst,ILAstOptimizer,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,CachedDelegateInitializationWithField,The length of the statement  "			if (!(stsfld != null && stsfld.Code == ILCode.Stsfld && ((FieldReference)stsfld.Operand).ResolveWithinSameModule() == field)) " is 125.
Long Statement,Custom.Decompiler.ILAst,ILAstOptimizer,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,CachedDelegateInitializationWithField,The length of the statement  "			MethodDefinition anonymousMethod = ((MethodReference)newObj.Arguments[1].Operand).ResolveWithinSameModule(); // method is defined in current assembly " is 149.
Long Statement,Custom.Decompiler.ILAst,ILAstOptimizer,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,CachedDelegateInitializationWithField,The length of the statement  "						if (parent.Arguments[j].Code == ILCode.Ldsfld && ((FieldReference)parent.Arguments[j].Operand).ResolveWithinSameModule() == field) { " is 132.
Long Statement,Custom.Decompiler.ILAst,ILAstOptimizer,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,CachedDelegateInitializationWithLocal,The length of the statement  "			MethodDefinition anonymousMethod = ((MethodReference)newObj.Arguments[1].Operand).ResolveWithinSameModule(); // method is defined in current assembly " is 149.
Long Statement,Custom.Decompiler.ILAst,ILAstOptimizer,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,CachedDelegateInitializationWithLocal,The length of the statement  "				if (!(inlining.numLdloc.GetOrDefault(v) == 2 && inlining.numStloc.GetOrDefault(v) == 2 && inlining.numLdloca.GetOrDefault(v) == 0)) " is 131.
Long Statement,Custom.Decompiler.ILAst,ILAstOptimizer,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,CachedDelegateInitializationWithLocal,The length of the statement  "						if (storeBlock.Body[j].Match(ILCode.Stloc' out storedVar' out storedExpr) && storedVar == v && storedExpr.Match(ILCode.Ldnull)) { " is 129.
Long Statement,Custom.Decompiler.ILAst,ILAstOptimizer,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,MakeAssignmentExpression,The length of the statement  "			} else if ((nextExpr.Code == ILCode.Stsfld || nextExpr.Code == ILCode.CallSetter || nextExpr.Code == ILCode.CallvirtSetter) && nextExpr.Arguments.Count == 1) { " is 159.
Long Statement,Custom.Decompiler.ILAst,ILAstOptimizer,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,MakeCompoundAssignments,The length of the statement  "			// (which does a reversible transform to the short operator form' as the introduction of checked/unchecked might have to revert to the long form). " is 146.
Long Statement,Custom.Decompiler.ILAst,ILAstOptimizer,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,MakeCompoundAssignment,The length of the statement  "			// in case of compound assignments with a lifted operator the result is inside NullableOf and the operand is inside ValueOf " is 123.
Long Statement,Custom.Decompiler.ILAst,ILAstOptimizer,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,IntroducePostIncrementForInstanceFields,The length of the statement  "			// stelem.any(T' ldloc(instance)' ldloc(pos)' add(stloc(helperVar' ldelem.any(T' ldloc(instance)' ldloc(pos)))' ldc.i4(1))) " is 123.
Long Statement,Custom.Decompiler.ILAst,ILAstOptimizer,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,IntroducePostIncrementForInstanceFields,The length of the statement  "			if (!(expr.Code == ILCode.Stfld || expr.Code.IsStoreToArray() || expr.Code == ILCode.Stobj || expr.Code == ILCode.CallSetter || expr.Code == ILCode.CallvirtSetter)) " is 164.
Long Statement,Custom.Decompiler.ILAst,ILAstOptimizer,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,HandleStringFixing,The length of the statement  "			if (!(body[pos].Match(ILCode.Stloc' out var1' out varAssignment) && varAssignment.Match(ILCode.Stloc' out var2' out ptrInitialization))) " is 136.
Long Statement,Custom.Decompiler.ILAst,ILAstOptimizer,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,HandleStringFixing,The length of the statement  "			if (!(ifStmt != null && ifStmt.TrueBlock != null && ifStmt.TrueBlock.Body.Count == 1 && (ifStmt.FalseBlock == null || ifStmt.FalseBlock.Body.Count == 0))) " is 154.
Long Statement,Custom.Decompiler.ILAst,ILAstOptimizer,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,HandleStringFixing,The length of the statement  "			if (!(ifStmt.TrueBlock.Body[0].Match(ILCode.Stloc' out assignedVar' out assignedExpr) && assignedVar == var2 && assignedExpr.Code == ILCode.Add)) " is 145.
Long Statement,Custom.Decompiler.ILAst,ILAstOptimizer,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,HandleStringFixing,The length of the statement  "			if (!(assignedExpr.Arguments[1].Match(ILCode.Call' out calledMethod) || assignedExpr.Arguments[1].Match(ILCode.CallGetter' out calledMethod))) " is 142.
Long Statement,Custom.Decompiler.ILAst,ILAstOptimizer,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,HandleStringFixing,The length of the statement  "			if (!(calledMethod.Name == "get_OffsetToStringData" && calledMethod.DeclaringType.FullName == "System.Runtime.CompilerServices.RuntimeHelpers")) " is 144.
Long Statement,Custom.Decompiler.ILAst,ILAstOptimizer,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,SimplifyLogicNot,The length of the statement  "			if (expr.Code == ILCode.Ceq && TypeAnalysis.IsBoolean(expr.Arguments[0].InferredType) && (a = expr.Arguments[1]).Code == ILCode.Ldc_I4 && (int)a.Operand == 0) { " is 160.
Long Statement,Custom.Decompiler.ILAst,ILAstOptimizer,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,MatchParameterVariableAssignment,The length of the statement  "			if (!(parameterMethod.Name == "Parameter" && parameterMethod.DeclaringType.FullName == "System.Linq.Expressions.Expression")) " is 125.
Long Statement,Custom.Decompiler.ILAst,ILInlining,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\ILInlining.cs,IsGeneratedValueTypeTemporary,The length of the statement  "						if (arg.Code == ILCode.CallGetter || arg.Code == ILCode.CallvirtGetter || arg.Code == ILCode.Call || arg.Code == ILCode.Callvirt) { " is 131.
Long Statement,Custom.Decompiler.ILAst,ILInlining,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\ILInlining.cs,FindLoadInNext,The length of the statement  "				if (i == 1 && (expr.Code == ILCode.LogicAnd || expr.Code == ILCode.LogicOr || expr.Code == ILCode.TernaryOp || expr.Code == ILCode.NullCoalescing)) " is 147.
Long Statement,Custom.Decompiler.ILAst,PatternMatcher,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\LiftedOperators.cs,SetResult,The length of the statement  "				var removednodes = expr.GetSelfAndChildrenRecursive<ILExpression>().Except(n.GetSelfAndChildrenRecursive<ILExpression>()); " is 122.
Long Statement,Custom.Decompiler.ILAst,LoopsAndConditions,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\LoopsAndConditions.cs,BuildGraph,The length of the statement  "				foreach(ILLabel target in node.GetSelfAndChildrenRecursive<ILExpression>(e => e.IsBranch()).SelectMany(e => e.GetBranchTargets())) { " is 132.
Long Statement,Custom.Decompiler.ILAst,LoopsAndConditions,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\LoopsAndConditions.cs,BuildGraph,The length of the statement  "					if (labelToCfNode.TryGetValue(target' out destination) && (destination != source || target == node.Body.FirstOrDefault())) { " is 124.
Long Statement,Custom.Decompiler.ILAst,SimpleControlFlow,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\SimpleControlFlow.cs,SimplifyTernaryOperator,The length of the statement  "				} else if ((retTypeIsBoolean || TypeAnalysis.IsBoolean(falseExpr.InferredType)) && trueExpr.Match(ILCode.Ldc_I4' out leftBoolVal) && (leftBoolVal == 0 || leftBoolVal == 1)) { " is 174.
Long Statement,Custom.Decompiler.ILAst,SimpleControlFlow,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\SimpleControlFlow.cs,SimplifyTernaryOperator,The length of the statement  "						newExpr = MakeLeftAssociativeShortCircuit(ILCode.LogicAnd' new ILExpression(ILCode.LogicNot' null' condExpr)' falseExpr); " is 121.
Long Statement,Custom.Decompiler.ILAst,SimpleControlFlow,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\SimpleControlFlow.cs,SimplifyTernaryOperator,The length of the statement  "				} else if ((retTypeIsBoolean || TypeAnalysis.IsBoolean(trueExpr.InferredType)) && falseExpr.Match(ILCode.Ldc_I4' out rightBoolVal) && (rightBoolVal == 0 || rightBoolVal == 1)) { " is 177.
Long Statement,Custom.Decompiler.ILAst,SimpleControlFlow,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\SimpleControlFlow.cs,SimplifyShortCircuit,The length of the statement  "							logicExpr = MakeLeftAssociativeShortCircuit(ILCode.LogicAnd' negate ? new ILExpression(ILCode.LogicNot' null' condExpr) : condExpr' nextCondExpr); " is 146.
Long Statement,Custom.Decompiler.ILAst,SimpleControlFlow,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\SimpleControlFlow.cs,SimplifyShortCircuit,The length of the statement  "							logicExpr = MakeLeftAssociativeShortCircuit(ILCode.LogicOr' negate ? condExpr : new ILExpression(ILCode.LogicNot' null' condExpr)' nextCondExpr); " is 145.
Long Statement,Custom.Decompiler.ILAst,SymbolicEvaluationContext,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\SymbolicExecution.cs,Eval,The length of the statement  "					return new SymbolicValue(expr.Code == ILCode.Ceq ? SymbolicValueType.StateEquals : SymbolicValueType.StateInEquals' unchecked(right.Constant - left.Constant)); " is 159.
Long Statement,Custom.Decompiler.ILAst,TypeAnalysis,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\TypeAnalysis.cs,CreateDependencyGraph,The length of the statement  "			if (catchBlock != null && catchBlock.ExceptionVariable != null && catchBlock.ExceptionType != null && catchBlock.ExceptionVariable.Type == null) { " is 146.
Long Statement,Custom.Decompiler.ILAst,TypeAnalysis,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\TypeAnalysis.cs,IdentifySingleLoadVariables,The length of the statement  "				if (g.Count() == 1 && g.Single().Expression.GetSelfAndChildrenRecursive<ILExpression>().Count(e => e.Operand == v) == 1) { " is 122.
Long Statement,Custom.Decompiler.ILAst,TypeAnalysis,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\TypeAnalysis.cs,RunInference,The length of the statement  "					if (v.Type == null && (assignVariableTypesBasedOnPartialInformation ? pair.Value.Any(e => e.Done) : pair.Value.All(e => e.Done))) { " is 131.
Long Statement,Custom.Decompiler.ILAst,TypeAnalysis,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\TypeAnalysis.cs,DoInferTypeForExpression,The length of the statement  "									InferTypeForExpression(expr.Arguments[0]' MakeRefIfValueType(method.DeclaringType' expr.GetPrefix(ILCode.Constrained))); " is 120.
Long Statement,Custom.Decompiler.ILAst,TypeAnalysis,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\TypeAnalysis.cs,DoInferTypeForExpression,The length of the statement  "									InferTypeForExpression(expr.Arguments[i]' SubstituteTypeArgs(method.Parameters[method.HasThis ? i - 1 : i].ParameterType' method)); " is 131.
Long Statement,Custom.Decompiler.ILAst,TypeAnalysis,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\TypeAnalysis.cs,DoInferTypeForExpression,The length of the statement  "						InferTypeForExpression(expr.Arguments[0]' MakeRefIfValueType(((FieldReference)expr.Operand).DeclaringType' expr.GetPrefix(ILCode.Constrained))); " is 144.
Long Statement,Custom.Decompiler.ILAst,TypeAnalysis,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\TypeAnalysis.cs,DoInferTypeForExpression,The length of the statement  "						InferTypeForExpression(expr.Arguments[0]' MakeRefIfValueType(((FieldReference)expr.Operand).DeclaringType' expr.GetPrefix(ILCode.Constrained))); " is 144.
Long Statement,Custom.Decompiler.ILAst,TypeAnalysis,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\TypeAnalysis.cs,DoInferTypeForExpression,The length of the statement  "						InferTypeForExpression(expr.Arguments[0]' MakeRefIfValueType(((FieldReference)expr.Operand).DeclaringType' expr.GetPrefix(ILCode.Constrained))); " is 144.
Long Statement,Custom.Decompiler.ILAst,TypeAnalysis,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\TypeAnalysis.cs,DoInferTypeForExpression,The length of the statement  "							else if (infoAmount == GetInformationAmount(operandType) && IsSigned(elementType) != null && IsSigned(operandType) != null) " is 123.
Long Statement,Custom.Decompiler.ILAst,TypeAnalysis,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\TypeAnalysis.cs,DoInferTypeForExpression,The length of the statement  "					return (expectedType != null  && expectedType.MetadataType == MetadataType.Single) ? typeSystem.Single : typeSystem.Double; " is 123.
Long Statement,Custom.Decompiler.ILAst,TypeAnalysis,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\TypeAnalysis.cs,HandleConversion,The length of the statement  "			TypeReference resultType = (GetInformationAmount(expectedType) == targetBitSize && IsSigned(expectedType) == targetSigned) ? expectedType : targetType; " is 151.
Long Statement,Custom.Decompiler.ILAst,TypeAnalysis,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\TypeAnalysis.cs,HandleConversion,The length of the statement  "			arg.ExpectedType = resultType; // store the expected type in the argument so that AstMethodBodyBuilder will insert a cast " is 121.
Long Statement,Custom.Decompiler.ILAst,TypeAnalysis,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\TypeAnalysis.cs,CreateNullableType,The length of the statement  "            var t = new GenericInstanceType(new TypeReference("System"' "Nullable`1"' module' module.TypeSystem.CoreLibrary' true)); " is 120.
Long Statement,Custom.Decompiler.ILAst,TypeAnalysis,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\TypeAnalysis.cs,GetEnumUnderlyingType,The length of the statement  "			// unfortunately we cannot rely on enumType.IsValueType here - it's not set when the instruction operand is a typeref (as opposed to a typespec) " is 144.
Long Statement,Custom.Decompiler.ILAst,TypeAnalysis,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\TypeAnalysis.cs,IsEnum,The length of the statement  "			// unfortunately we cannot rely on type.IsValueType here - it's not set when the instruction operand is a typeref (as opposed to a typespec) " is 140.
Long Statement,Custom.Decompiler.ILAst,YieldReturnDecompiler,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\YieldReturnDecompiler.cs,ConvertBody,The length of the statement  "					if (br == null || !(br.Code == ILCode.Br || br.Code == ILCode.Leave) || br.Operand != returnLabel || expr.Arguments[0].Code != ILCode.Ldc_I4) " is 141.
Long Statement,Custom.Decompiler.ILAst,YieldReturnDecompiler,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\YieldReturnDecompiler.cs,ConvertBody,The length of the statement  "						newBody.RemoveRange(stateChange.NewBodyPos' newBody.Count - stateChange.NewBodyPos); // remove all nodes that we just moved into the try block " is 142.
Long Statement,Custom.Decompiler.ILAst,YieldReturnDecompiler,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\YieldReturnDecompiler.cs,TranslateFieldsToLocalAccess,The length of the statement  "			var fieldToLocalMap = new DefaultDictionary<FieldDefinition' ILVariable>(f => new ILVariable { Name = f.Name' Type = f.FieldType }); " is 132.
Complex Conditional,Custom.Decompiler.Ast,AstBuilder,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\AstBuilder.cs,MemberIsHidden,The conditional expression  "method.IsGetter || method.IsSetter || method.IsAddOn || method.IsRemoveOn"  is complex.
Complex Conditional,Custom.Decompiler.Ast,AstBuilder,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\AstBuilder.cs,CreateProperty,The conditional expression  "accessor.IsVirtual && !accessor.IsNewSlot && (propDef.GetMethod == null || propDef.SetMethod == null)"  is complex.
Complex Conditional,Custom.Decompiler.Ast,AstBuilder,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\AstBuilder.cs,ConvertAttributes,The conditional expression  "layoutKind != defaultLayoutKind || charSet != CharSet.Ansi || typeDefinition.PackingSize > 0 || typeDefinition.ClassSize > 0"  is complex.
Complex Conditional,Custom.Decompiler.Ast,NameVariables,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\NameVariables.cs,GetNameByType,The conditional expression  "name.Length >= 3 && name[0] == 'I' && char.IsUpper(name[1]) && char.IsLower(name[2])"  is complex.
Complex Conditional,Custom.Decompiler.Ast,TextOutputFormatter,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\TextOutputFormatter.cs,GetCurrentMemberReference,The conditional expression  "(node.Role == Roles.Type && node.Parent is ObjectCreateExpression) ||  				(memberRef == null && node.Role == Roles.TargetExpression && (node.Parent is InvocationExpression || node.Parent is ObjectCreateExpression))"  is complex.
Complex Conditional,Custom.Decompiler,CecilExtensions,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\CecilExtensions.cs,IsAnonymousType,The conditional expression  "string.IsNullOrEmpty(type.Namespace) && type.HasGeneratedName() && (type.Name.Contains("AnonType") || type.Name.Contains("AnonymousType"))"  is complex.
Complex Conditional,Custom.Decompiler.Ast.Transforms,TypePattern,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\Transforms\CustomPatterns.cs,DoMatch,The conditional expression  "ct != null && !ct.HasNullableSpecifier && ct.PointerRank == 0 && !ct.ArraySpecifiers.Any()"  is complex.
Complex Conditional,Custom.Decompiler.Ast.Transforms,DeclareVariables,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\Transforms\DeclareVariables.cs,CanMoveVariableUseIntoSubBlock,The conditional expression  "!allowPassIntoLoops && (stmt is ForStatement || stmt is ForeachStatement || stmt is DoWhileStatement || stmt is WhileStatement)"  is complex.
Complex Conditional,Custom.Decompiler.Ast.Transforms,DelegateConstruction,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\Transforms\DelegateConstruction.cs,HandleAnonymousMethod,The conditional expression  "target != null && !(target is IdentifierExpression || target is ThisReferenceExpression || target is NullReferenceExpression)"  is complex.
Complex Conditional,Custom.Decompiler.Ast.Transforms,IntroduceExtensionMethods,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\Transforms\IntroduceExtensionMethods.cs,Run,The conditional expression  "mre != null && mre.Target is TypeReferenceExpression && methodReference != null && invocation.Arguments.Any()"  is complex.
Complex Conditional,Custom.Decompiler.Ast.Transforms,FullyQualifyAmbiguousTypeNamesVisitor,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\Transforms\IntroduceUsingDeclarations.cs,IsAmbiguous,The conditional expression  "!(prop != null && prop.PropertyType.Namespace == ns && prop.PropertyType.Name == name)  						    && !(field != null && field.FieldType.Namespace == ns && field.FieldType.Name == name)"  is complex.
Complex Conditional,Custom.Decompiler.Ast.Transforms,PatternStatementTransform,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\Transforms\PatternStatementTransform.cs,TryGetPairFrom,The conditional expression  "arg1 != null && arg2 != null && arg1.Value is string && arg2.Value is int"  is complex.
Complex Conditional,Custom.Decompiler.Ast.Transforms,PushNegation,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\Transforms\PushNegation.cs,VisitBinaryOperatorExpression,The conditional expression  "op == BinaryOperatorType.Equality && rightOperand == true || op == BinaryOperatorType.InEquality && rightOperand == false"  is complex.
Complex Conditional,Custom.Decompiler.Ast.Transforms,PushNegation,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\Transforms\PushNegation.cs,VisitBinaryOperatorExpression,The conditional expression  "op == BinaryOperatorType.Equality && rightOperand == false || op == BinaryOperatorType.InEquality && rightOperand == true"  is complex.
Complex Conditional,Custom.Decompiler.FlowAnalysis,ControlFlowGraphBuilder,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\FlowAnalysis\ControlFlowGraphBuilder.cs,FindInnermostHandlerBlock,The conditional expression  "h.TryStart.Offset <= instructionOffset && instructionOffset < h.TryEnd.Offset  				    || h.HandlerStart.Offset <= instructionOffset && instructionOffset < h.HandlerEnd.Offset"  is complex.
Complex Conditional,Custom.Decompiler.FlowAnalysis,ControlStructureDetector,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\FlowAnalysis\ControlStructureDetector.cs,FindLoops,The conditional expression  "current.Nodes.Contains(node)  			    && node.DominanceFrontier.Contains(node)  			    && !(node == current.EntryPoint && current.Type == ControlStructureType.Loop)"  is complex.
Complex Conditional,Custom.Decompiler.FlowAnalysis,SsaOptimization,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\FlowAnalysis\SsaOptimization.cs,DirectlyStoreToVariables,The conditional expression  "target.IsSingleAssignment && temp.IsSingleAssignment && temp.Usage.Count == 1 && temp.IsStackLocation"  is complex.
Complex Conditional,Custom.Decompiler.ILAst,ILAstBuilder,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\ILAstBuilder.cs,ConvertLocalVariables,The conditional expression  "!optimize || varDef.IsPinned || uses.Any(b => b.VariablesBefore[varDef.Index].UnknownDefinition || (b.Code == ILCode.Ldloca && !IsDeterministicLdloca(b)))"  is complex.
Complex Conditional,Custom.Decompiler.ILAst,ILAstBuilder,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\ILAstBuilder.cs,ConvertParameters,The conditional expression  "this.Parameters.Count > 0 && (methodDef.IsSetter || methodDef.IsAddOn || methodDef.IsRemoveOn)"  is complex.
Complex Conditional,Custom.Decompiler.ILAst,ILAstBuilder,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\ILAstBuilder.cs,ConvertToAst,The conditional expression  "first != null &&  							    first.Code == ILCode.Pop &&  							    first.Arguments[0].Code == ILCode.Ldloc &&  							    first.Arguments[0].Operand == ldexception.StoreTo[0]"  is complex.
Complex Conditional,Custom.Decompiler.ILAst,ILAstOptimizer,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,IntroducePropertyAccessInstructions,The conditional expression  "expr.Arguments[0].Match(ILCode.Ldloc' out target)  				    && expr.Arguments[1].Code == ILCode.Ldvirtftn  				    && expr.Arguments[1].Arguments.Count == 1  				    && expr.Arguments[1].Arguments[0].MatchLdloc(target)"  is complex.
Complex Conditional,Custom.Decompiler.ILAst,ILAstOptimizer,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,SplitToBasicBlocks,The conditional expression  "currNode is ILLabel ||  					    currNode is ILTryCatchBlock || // Counts as label  					    lastNode.IsConditionalControlFlow() ||  					    lastNode.IsUnconditionalControlFlow()"  is complex.
Complex Conditional,Custom.Decompiler.ILAst,ILAstOptimizer,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,TransformArrayInitializers,The conditional expression  "expr.Match(ILCode.Stloc' out v' out newarrExpr) &&  			    newarrExpr.Match(ILCode.Newarr' out elementType' out lengthExpr) &&  			    lengthExpr.Match(ILCode.Ldc_I4' out arrayLength) &&  			    arrayLength > 0"  is complex.
Complex Conditional,Custom.Decompiler.ILAst,ILAstOptimizer,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,TransformArrayInitializers,The conditional expression  "nextExpr != null &&  					    nextExpr.Code.IsStoreToArray() &&  					    nextExpr.Arguments[0].Match(ILCode.Ldloc' out v3) &&  					    v == v3 &&  					    nextExpr.Arguments[1].Match(ILCode.Ldc_I4' out arrayPos) &&  					    arrayPos >= operands.Count &&  					    arrayPos <= operands.Count + maxConsecutiveDefaultValueExpressions &&  					    !nextExpr.Arguments[2].ContainsReferenceTo(v3)"  is complex.
Complex Conditional,Custom.Decompiler.ILAst,ILAstOptimizer,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,TransformMultidimensionalArrayInitializers,The conditional expression  "expr.Match(ILCode.Stloc' out v' out newarrExpr) &&  			    newarrExpr.Match(ILCode.Newobj' out ctor' out ctorArgs) &&  			    (arrayType = (ctor.DeclaringType as ArrayType)) != null &&  			    arrayType.Rank == ctorArgs.Count"  is complex.
Complex Conditional,Custom.Decompiler.ILAst,ILAstOptimizer,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,ForwardScanInitializeArrayRuntimeHelper,The conditional expression  "body.ElementAtOrDefault(pos).Match(ILCode.Call' out methodRef' out methodArg1' out methodArg2) &&  			    methodRef.DeclaringType.FullName == "System.Runtime.CompilerServices.RuntimeHelpers" &&  			    methodRef.Name == "InitializeArray" &&  			    methodArg1.Match(ILCode.Ldloc' out v2) &&  			    array == v2 &&  			    methodArg2.Match(ILCode.Ldtoken' out fieldRef)"  is complex.
Complex Conditional,Custom.Decompiler.ILAst,ILAstOptimizer,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,TransformDecimalCtorToConstant,The conditional expression  "expr.Arguments[0].Match(ILCode.Ldc_I4' out lo) &&  					    expr.Arguments[1].Match(ILCode.Ldc_I4' out mid) &&  					    expr.Arguments[2].Match(ILCode.Ldc_I4' out hi) &&  					    expr.Arguments[3].Match(ILCode.Ldc_I4' out isNegative) &&  					    expr.Arguments[4].Match(ILCode.Ldc_I4' out scale)"  is complex.
Complex Conditional,Custom.Decompiler.ILAst,ILAstOptimizer,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,RemoveConvIFromArrayCreation,The conditional expression  "length.Match(ILCode.Conv_Ovf_I' out input) || length.Match(ILCode.Conv_I' out input)  				    || length.Match(ILCode.Conv_Ovf_I_Un' out input) || length.Match(ILCode.Conv_U' out input)"  is complex.
Complex Conditional,Custom.Decompiler.ILAst,ILAstOptimizer,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,CachedDelegateInitializationWithField,The conditional expression  "c == null || c.Condition == null && c.TrueBlock == null || c.FalseBlock == null"  is complex.
Complex Conditional,Custom.Decompiler.ILAst,ILAstOptimizer,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,CachedDelegateInitializationWithLocal,The conditional expression  "c == null || c.Condition == null && c.TrueBlock == null || c.FalseBlock == null"  is complex.
Complex Conditional,Custom.Decompiler.ILAst,ILAstOptimizer,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,MakeAssignmentExpression,The conditional expression  "(nextExpr.Code == ILCode.Stsfld || nextExpr.Code == ILCode.CallSetter || nextExpr.Code == ILCode.CallvirtSetter) && nextExpr.Arguments.Count == 1"  is complex.
Complex Conditional,Custom.Decompiler.ILAst,ILAstOptimizer,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,IntroducePostIncrementForInstanceFields,The conditional expression  "!(expr.Code == ILCode.Stfld || expr.Code.IsStoreToArray() || expr.Code == ILCode.Stobj || expr.Code == ILCode.CallSetter || expr.Code == ILCode.CallvirtSetter)"  is complex.
Complex Conditional,Custom.Decompiler.ILAst,ILAstOptimizer,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,IntroduceFixedStatements,The conditional expression  "expr != null && expr.Code == ILCode.Stloc && expr.Operand == pinnedVar && IsNullOrZero(expr.Arguments[0])"  is complex.
Complex Conditional,Custom.Decompiler.ILAst,ILAstOptimizer,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,MatchFixedInitializer,The conditional expression  "ifStmt.TrueBlock != null && ifStmt.TrueBlock.Body.Count == 1  				    && ifStmt.TrueBlock.Body[0].Match(ILCode.Stloc' out pinnedVar' out trueValue)  				    && pinnedVar.IsPinned && IsNullOrZero(trueValue)"  is complex.
Complex Conditional,Custom.Decompiler.ILAst,ILAstOptimizer,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,MatchFixedInitializer,The conditional expression  "fixedStmt.Initializers.Count == 1 && fixedStmt.BodyBlock.Body.Count == 0  						    && fixedStmt.Initializers[0].Match(ILCode.Stloc' out stlocVar' out falseValue) && stlocVar == pinnedVar"  is complex.
Complex Conditional,Custom.Decompiler.ILAst,ILAstOptimizer,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,MatchFixedInitializer,The conditional expression  "falseValue.Code == ILCode.Ldelema  							    && falseValue.Arguments[0].Match(ILCode.Ldloc' out loadedVariable) && loadedVariable == arrayVariable  							    && IsNullOrZero(falseValue.Arguments[1])"  is complex.
Complex Conditional,Custom.Decompiler.ILAst,ILAstOptimizer,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,HandleStringFixing,The conditional expression  "!(ifStmt != null && ifStmt.TrueBlock != null && ifStmt.TrueBlock.Body.Count == 1 && (ifStmt.FalseBlock == null || ifStmt.FalseBlock.Body.Count == 0))"  is complex.
Complex Conditional,Custom.Decompiler.ILAst,ILAstOptimizer,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,SimplifyLogicNot,The conditional expression  "expr.Code == ILCode.Ceq && TypeAnalysis.IsBoolean(expr.Arguments[0].InferredType) && (a = expr.Arguments[1]).Code == ILCode.Ldc_I4 && (int)a.Operand == 0"  is complex.
Complex Conditional,Custom.Decompiler.ILAst,ILInlining,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\ILInlining.cs,IsGeneratedValueTypeTemporary,The conditional expression  "arg.Code == ILCode.CallGetter || arg.Code == ILCode.CallvirtGetter || arg.Code == ILCode.Call || arg.Code == ILCode.Callvirt"  is complex.
Complex Conditional,Custom.Decompiler.ILAst,ILInlining,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\ILInlining.cs,FindLoadInNext,The conditional expression  "i == 1 && (expr.Code == ILCode.LogicAnd || expr.Code == ILCode.LogicOr || expr.Code == ILCode.TernaryOp || expr.Code == ILCode.NullCoalescing)"  is complex.
Complex Conditional,Custom.Decompiler.ILAst,ILInlining,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\ILInlining.cs,CopyPropagation,The conditional expression  "block.Body[i].Match(ILCode.Stloc' out v' out copiedExpr)  					    && !v.IsParameter && numStloc.GetOrDefault(v) == 1 && numLdloca.GetOrDefault(v) == 0  					    && CanPerformCopyPropagation(copiedExpr' v)"  is complex.
Complex Conditional,Custom.Decompiler.ILAst,OperatorPattern,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\LiftedOperators.cs,Match,The conditional expression  "m == null || m.HasThis || !m.HasParameters || e.Arguments.Count > 2 || !IsCustomOperator(m.Name)"  is complex.
Complex Conditional,Custom.Decompiler.ILAst,LoopsAndConditions,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\LoopsAndConditions.cs,FindLoops,The conditional expression  "scope.Contains(node)  				    && node.DominanceFrontier.Contains(node)  				    && (node != entryPoint || !excludeEntryPoint)"  is complex.
Complex Conditional,Custom.Decompiler.ILAst,LoopsAndConditions,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\LoopsAndConditions.cs,FindLoops,The conditional expression  "(!loopContents.Contains(trueTarget) && loopContents.Contains(falseTarget)) ||  						    (loopContents.Contains(trueTarget) && !loopContents.Contains(falseTarget))"  is complex.
Complex Conditional,Custom.Decompiler.ILAst,PatternMatching,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\PatternMatching.cs,Match,The conditional expression  "expr != null && expr.Prefixes == null && expr.Code == code && expr.Arguments.Count == 0"  is complex.
Complex Conditional,Custom.Decompiler.ILAst,PatternMatching,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\PatternMatching.cs,MatchSingleAndBr,The conditional expression  "bb.Body.Count == 3 &&  			    bb.Body[0] is ILLabel &&  			    bb.Body[1].Match(code' out operand' out arg) &&  			    bb.Body[2].Match(ILCode.Br' out brLabel)"  is complex.
Complex Conditional,Custom.Decompiler.ILAst,SimpleControlFlow,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\SimpleControlFlow.cs,SimplifyTernaryOperator,The conditional expression  "head.MatchLastAndBr(ILCode.Brtrue' out trueLabel' out condExpr' out falseLabel) &&  			    labelGlobalRefCount[trueLabel] == 1 &&  			    labelGlobalRefCount[falseLabel] == 1 &&  			    ((labelToBasicBlock[trueLabel].MatchSingleAndBr(ILCode.Stloc' out trueLocVar' out trueExpr' out trueFall) &&  			      labelToBasicBlock[falseLabel].MatchSingleAndBr(ILCode.Stloc' out falseLocVar' out falseExpr' out falseFall) &&  			      trueLocVar == falseLocVar && trueFall == falseFall) ||  			     (labelToBasicBlock[trueLabel].MatchSingle(ILCode.Ret' out unused' out trueExpr) &&  			      labelToBasicBlock[falseLabel].MatchSingle(ILCode.Ret' out unused' out falseExpr))) &&  			    body.Contains(labelToBasicBlock[trueLabel]) &&  			    body.Contains(labelToBasicBlock[falseLabel])"  is complex.
Complex Conditional,Custom.Decompiler.ILAst,SimpleControlFlow,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\SimpleControlFlow.cs,SimplifyTernaryOperator,The conditional expression  "retTypeIsBoolean &&  				    trueExpr.Match(ILCode.Ldc_I4' out leftBoolVal) &&  				    falseExpr.Match(ILCode.Ldc_I4' out rightBoolVal) &&  				    ((leftBoolVal != 0 && rightBoolVal == 0) || (leftBoolVal == 0 && rightBoolVal != 0))"  is complex.
Complex Conditional,Custom.Decompiler.ILAst,SimpleControlFlow,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\SimpleControlFlow.cs,SimplifyTernaryOperator,The conditional expression  "(retTypeIsBoolean || TypeAnalysis.IsBoolean(falseExpr.InferredType)) && trueExpr.Match(ILCode.Ldc_I4' out leftBoolVal) && (leftBoolVal == 0 || leftBoolVal == 1)"  is complex.
Complex Conditional,Custom.Decompiler.ILAst,SimpleControlFlow,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\SimpleControlFlow.cs,SimplifyTernaryOperator,The conditional expression  "(retTypeIsBoolean || TypeAnalysis.IsBoolean(trueExpr.InferredType)) && falseExpr.Match(ILCode.Ldc_I4' out rightBoolVal) && (rightBoolVal == 0 || rightBoolVal == 1)"  is complex.
Complex Conditional,Custom.Decompiler.ILAst,SimpleControlFlow,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\SimpleControlFlow.cs,SimplifyNullCoalescing,The conditional expression  "head.Body.Count >= 3 &&  			    head.Body[head.Body.Count - 3].Match(ILCode.Stloc' out v' out leftExpr) &&  			    leftExpr.Match(ILCode.Ldloc' out leftVar) &&  			    head.MatchLastAndBr(ILCode.Brtrue' out endBBLabel' out leftExpr2' out rightBBLabel) &&  			    leftExpr2.MatchLdloc(leftVar) &&  			    labelToBasicBlock.TryGetValue(rightBBLabel' out rightBB) &&  			    rightBB.MatchSingleAndBr(ILCode.Stloc' out v2' out rightExpr' out endBBLabel2) &&  			    v == v2 &&  			    endBBLabel == endBBLabel2 &&  			    labelGlobalRefCount.GetOrDefault(rightBBLabel) == 1 &&  			    body.Contains(rightBB)"  is complex.
Complex Conditional,Custom.Decompiler.ILAst,SimpleControlFlow,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\SimpleControlFlow.cs,SimplifyShortCircuit,The conditional expression  "body.Contains(nextBasicBlock) &&  					    nextBasicBlock != head &&  					    labelGlobalRefCount[(ILLabel)nextBasicBlock.Body.First()] == 1 &&  					    nextBasicBlock.MatchSingleAndBr(ILCode.Brtrue' out nextTrueLablel' out nextCondExpr' out nextFalseLabel) &&  					    (otherLablel == nextFalseLabel || otherLablel == nextTrueLablel)"  is complex.
Complex Conditional,Custom.Decompiler.ILAst,SimpleControlFlow,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\SimpleControlFlow.cs,JoinBasicBlocks,The conditional expression  "!head.Body.ElementAtOrDefault(head.Body.Count - 2).IsConditionalControlFlow() &&  			    head.Body.Last().Match(ILCode.Br' out nextLabel) &&  			    labelGlobalRefCount[nextLabel] == 1 &&  			    labelToBasicBlock.TryGetValue(nextLabel' out nextBB) &&  			    body.Contains(nextBB) &&  			    nextBB.Body.First() == nextLabel &&  			    !nextBB.Body.OfType<ILTryCatchBlock>().Any()"  is complex.
Complex Conditional,Custom.Decompiler.ILAst,TypeAnalysis,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\TypeAnalysis.cs,CreateDependencyGraph,The conditional expression  "catchBlock != null && catchBlock.ExceptionVariable != null && catchBlock.ExceptionType != null && catchBlock.ExceptionVariable.Type == null"  is complex.
Complex Conditional,Custom.Decompiler.ILAst,TypeAnalysis,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\TypeAnalysis.cs,RunInference,The conditional expression  "!expr.Done && expr.Dependencies.TrueForAll(v => v.Type != null || singleLoadVariables.Contains(v))  					    && (expr.DependsOnSingleLoad == null || expr.DependsOnSingleLoad.Type != null || ignoreSingleLoadDependencies)"  is complex.
Complex Conditional,Custom.Decompiler.ILAst,TypeAnalysis,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\TypeAnalysis.cs,DoInferTypeForExpression,The conditional expression  "expectedType != null && (  						expectedType.MetadataType == MetadataType.Int32 || expectedType.MetadataType == MetadataType.UInt32 ||  						expectedType.MetadataType == MetadataType.Int64 || expectedType.MetadataType == MetadataType.UInt64)"  is complex.
Complex Conditional,Custom.Decompiler.ILAst,YieldReturnDecompiler,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\YieldReturnDecompiler.cs,AnalyzeCtor,The conditional expression  "node.Match(ILCode.Stfld' out field' out instExpr' out stExpr) &&  				    instExpr.MatchThis() &&  				    stExpr.Match(ILCode.Ldloc' out arg) &&  				    arg.IsParameter && arg.OriginalParameter.Index == 0"  is complex.
Complex Conditional,Custom.Decompiler.ILAst,YieldReturnDecompiler,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\YieldReturnDecompiler.cs,AnalyzeCurrentProperty,The conditional expression  "method.Body[0].Match(ILCode.Stloc' out v' out stExpr) &&  				    stExpr.Match(ILCode.Ldfld' out field' out ldFromObj) &&  				    ldFromObj.MatchThis() &&  				    method.Body[1].Match(ILCode.Ret' out retExpr) &&  				    retExpr.Match(ILCode.Ldloc' out v2) &&  				    v == v2"  is complex.
Complex Conditional,Custom.Decompiler.ILAst,YieldReturnDecompiler,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\YieldReturnDecompiler.cs,AnalyzeMoveNext,The conditional expression  "leave != null && (leave.Code == ILCode.Br || leave.Code == ILCode.Leave) && leave.Operand == returnLabel"  is complex.
Complex Conditional,Custom.Decompiler.ILAst,YieldReturnDecompiler,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\YieldReturnDecompiler.cs,ConvertBody,The conditional expression  "returnVariable != null && expr != null && expr.Code == ILCode.Stloc && expr.Operand == returnVariable"  is complex.
Complex Conditional,Custom.Decompiler.ILAst,YieldReturnDecompiler,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\YieldReturnDecompiler.cs,ConvertBody,The conditional expression  "br == null || !(br.Code == ILCode.Br || br.Code == ILCode.Leave) || br.Operand != returnLabel || expr.Arguments[0].Code != ILCode.Ldc_I4"  is complex.
Complex Conditional,Custom.Decompiler.ILAst,YieldReturnDecompiler,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\YieldReturnDecompiler.cs,ConvertBody,The conditional expression  "expr != null && expr.Code == ILCode.Call && expr.Arguments.Count == 1 && expr.Arguments[0].MatchThis()"  is complex.
Complex Conditional,Custom.Decompiler.ILAst,YieldReturnDecompiler,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\YieldReturnDecompiler.cs,ConvertBody,The conditional expression  "br == null || !(br.Code == ILCode.Br || br.Code == ILCode.Leave) || br.Operand != returnFalseLabel"  is complex.
Empty Catch Block,Custom.Decompiler.Ast,AstBuilder,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\AstBuilder.cs,CreateProperty,The method has an empty catch block.
Empty Catch Block,Custom.Decompiler.Ast,AstBuilder,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\AstBuilder.cs,SetNewModifier,The method has an empty catch block.
Magic Number,Custom.Decompiler.Ast,AstMethodBodyBuilder,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\AstMethodBodyBuilder.cs,TransformByteCode,The following statement contains a magic number: Ast.Expression arg2 = args.Count >= 2 ? args[1] : null;
Magic Number,Custom.Decompiler.Ast,AstMethodBodyBuilder,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\AstMethodBodyBuilder.cs,TransformByteCode,The following statement contains a magic number: Ast.Expression arg3 = args.Count >= 3 ? args[2] : null;
Magic Number,Custom.Decompiler.Ast,AstMethodBodyBuilder,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\AstMethodBodyBuilder.cs,TransformByteCode,The following statement contains a magic number: Ast.Expression arg3 = args.Count >= 3 ? args[2] : null;
Magic Number,Custom.Decompiler.Ast,AstMethodBodyBuilder,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\AstMethodBodyBuilder.cs,DivideBySize,The following statement contains a magic number: switch (TypeAnalysis.GetInformationAmount(type)) {  				case 1:  				case 8:  					sizeOfExpression = new PrimitiveExpression(1);  					break;  				case 16:  					sizeOfExpression = new PrimitiveExpression(2);  					break;  				case 32:  					sizeOfExpression = new PrimitiveExpression(4);  					break;  				case 64:  					sizeOfExpression = new PrimitiveExpression(8);  					break;  				default:  					sizeOfExpression = new SizeOfExpression { Type = AstBuilder.ConvertType(type) };  					break;  			}
Magic Number,Custom.Decompiler.Ast,AstMethodBodyBuilder,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\AstMethodBodyBuilder.cs,DivideBySize,The following statement contains a magic number: switch (TypeAnalysis.GetInformationAmount(type)) {  				case 1:  				case 8:  					sizeOfExpression = new PrimitiveExpression(1);  					break;  				case 16:  					sizeOfExpression = new PrimitiveExpression(2);  					break;  				case 32:  					sizeOfExpression = new PrimitiveExpression(4);  					break;  				case 64:  					sizeOfExpression = new PrimitiveExpression(8);  					break;  				default:  					sizeOfExpression = new SizeOfExpression { Type = AstBuilder.ConvertType(type) };  					break;  			}
Magic Number,Custom.Decompiler.Ast,AstMethodBodyBuilder,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\AstMethodBodyBuilder.cs,DivideBySize,The following statement contains a magic number: switch (TypeAnalysis.GetInformationAmount(type)) {  				case 1:  				case 8:  					sizeOfExpression = new PrimitiveExpression(1);  					break;  				case 16:  					sizeOfExpression = new PrimitiveExpression(2);  					break;  				case 32:  					sizeOfExpression = new PrimitiveExpression(4);  					break;  				case 64:  					sizeOfExpression = new PrimitiveExpression(8);  					break;  				default:  					sizeOfExpression = new SizeOfExpression { Type = AstBuilder.ConvertType(type) };  					break;  			}
Magic Number,Custom.Decompiler.Ast,AstMethodBodyBuilder,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\AstMethodBodyBuilder.cs,DivideBySize,The following statement contains a magic number: switch (TypeAnalysis.GetInformationAmount(type)) {  				case 1:  				case 8:  					sizeOfExpression = new PrimitiveExpression(1);  					break;  				case 16:  					sizeOfExpression = new PrimitiveExpression(2);  					break;  				case 32:  					sizeOfExpression = new PrimitiveExpression(4);  					break;  				case 64:  					sizeOfExpression = new PrimitiveExpression(8);  					break;  				default:  					sizeOfExpression = new SizeOfExpression { Type = AstBuilder.ConvertType(type) };  					break;  			}
Magic Number,Custom.Decompiler.Ast,AstMethodBodyBuilder,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\AstMethodBodyBuilder.cs,DivideBySize,The following statement contains a magic number: switch (TypeAnalysis.GetInformationAmount(type)) {  				case 1:  				case 8:  					sizeOfExpression = new PrimitiveExpression(1);  					break;  				case 16:  					sizeOfExpression = new PrimitiveExpression(2);  					break;  				case 32:  					sizeOfExpression = new PrimitiveExpression(4);  					break;  				case 64:  					sizeOfExpression = new PrimitiveExpression(8);  					break;  				default:  					sizeOfExpression = new SizeOfExpression { Type = AstBuilder.ConvertType(type) };  					break;  			}
Magic Number,Custom.Decompiler.Ast,AstMethodBodyBuilder,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\AstMethodBodyBuilder.cs,DivideBySize,The following statement contains a magic number: switch (TypeAnalysis.GetInformationAmount(type)) {  				case 1:  				case 8:  					sizeOfExpression = new PrimitiveExpression(1);  					break;  				case 16:  					sizeOfExpression = new PrimitiveExpression(2);  					break;  				case 32:  					sizeOfExpression = new PrimitiveExpression(4);  					break;  				case 64:  					sizeOfExpression = new PrimitiveExpression(8);  					break;  				default:  					sizeOfExpression = new SizeOfExpression { Type = AstBuilder.ConvertType(type) };  					break;  			}
Magic Number,Custom.Decompiler.Ast,AstMethodBodyBuilder,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\AstMethodBodyBuilder.cs,DivideBySize,The following statement contains a magic number: switch (TypeAnalysis.GetInformationAmount(type)) {  				case 1:  				case 8:  					sizeOfExpression = new PrimitiveExpression(1);  					break;  				case 16:  					sizeOfExpression = new PrimitiveExpression(2);  					break;  				case 32:  					sizeOfExpression = new PrimitiveExpression(4);  					break;  				case 64:  					sizeOfExpression = new PrimitiveExpression(8);  					break;  				default:  					sizeOfExpression = new SizeOfExpression { Type = AstBuilder.ConvertType(type) };  					break;  			}
Magic Number,Custom.Decompiler.Ast,NameVariables,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\NameVariables.cs,GetNameFromExpression,The following statement contains a magic number: switch (expr.Code) {  				case ILCode.Ldfld:  				case ILCode.Ldsfld:  					return CleanUpVariableName(((FieldReference)expr.Operand).Name);  				case ILCode.Call:  				case ILCode.Callvirt:  				case ILCode.CallGetter:  				case ILCode.CallvirtGetter:  					MethodReference mr = (MethodReference)expr.Operand;  					if (mr.Name.StartsWith("get_"' StringComparison.OrdinalIgnoreCase) && mr.Parameters.Count == 0) {  						// use name from properties' but not from indexers  						return CleanUpVariableName(mr.Name.Substring(4));  					} else if (mr.Name.StartsWith("Get"' StringComparison.OrdinalIgnoreCase) && mr.Name.Length >= 4 && char.IsUpper(mr.Name[3])) {  						// use name from Get-methods  						return CleanUpVariableName(mr.Name.Substring(3));  					}  					break;  			}
Magic Number,Custom.Decompiler.Ast,NameVariables,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\NameVariables.cs,GetNameFromExpression,The following statement contains a magic number: switch (expr.Code) {  				case ILCode.Ldfld:  				case ILCode.Ldsfld:  					return CleanUpVariableName(((FieldReference)expr.Operand).Name);  				case ILCode.Call:  				case ILCode.Callvirt:  				case ILCode.CallGetter:  				case ILCode.CallvirtGetter:  					MethodReference mr = (MethodReference)expr.Operand;  					if (mr.Name.StartsWith("get_"' StringComparison.OrdinalIgnoreCase) && mr.Parameters.Count == 0) {  						// use name from properties' but not from indexers  						return CleanUpVariableName(mr.Name.Substring(4));  					} else if (mr.Name.StartsWith("Get"' StringComparison.OrdinalIgnoreCase) && mr.Name.Length >= 4 && char.IsUpper(mr.Name[3])) {  						// use name from Get-methods  						return CleanUpVariableName(mr.Name.Substring(3));  					}  					break;  			}
Magic Number,Custom.Decompiler.Ast,NameVariables,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\NameVariables.cs,GetNameFromExpression,The following statement contains a magic number: switch (expr.Code) {  				case ILCode.Ldfld:  				case ILCode.Ldsfld:  					return CleanUpVariableName(((FieldReference)expr.Operand).Name);  				case ILCode.Call:  				case ILCode.Callvirt:  				case ILCode.CallGetter:  				case ILCode.CallvirtGetter:  					MethodReference mr = (MethodReference)expr.Operand;  					if (mr.Name.StartsWith("get_"' StringComparison.OrdinalIgnoreCase) && mr.Parameters.Count == 0) {  						// use name from properties' but not from indexers  						return CleanUpVariableName(mr.Name.Substring(4));  					} else if (mr.Name.StartsWith("Get"' StringComparison.OrdinalIgnoreCase) && mr.Name.Length >= 4 && char.IsUpper(mr.Name[3])) {  						// use name from Get-methods  						return CleanUpVariableName(mr.Name.Substring(3));  					}  					break;  			}
Magic Number,Custom.Decompiler.Ast,NameVariables,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\NameVariables.cs,GetNameFromExpression,The following statement contains a magic number: switch (expr.Code) {  				case ILCode.Ldfld:  				case ILCode.Ldsfld:  					return CleanUpVariableName(((FieldReference)expr.Operand).Name);  				case ILCode.Call:  				case ILCode.Callvirt:  				case ILCode.CallGetter:  				case ILCode.CallvirtGetter:  					MethodReference mr = (MethodReference)expr.Operand;  					if (mr.Name.StartsWith("get_"' StringComparison.OrdinalIgnoreCase) && mr.Parameters.Count == 0) {  						// use name from properties' but not from indexers  						return CleanUpVariableName(mr.Name.Substring(4));  					} else if (mr.Name.StartsWith("Get"' StringComparison.OrdinalIgnoreCase) && mr.Name.Length >= 4 && char.IsUpper(mr.Name[3])) {  						// use name from Get-methods  						return CleanUpVariableName(mr.Name.Substring(3));  					}  					break;  			}
Magic Number,Custom.Decompiler.Ast,NameVariables,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\NameVariables.cs,GetNameForArgument,The following statement contains a magic number: switch (parent.Code) {  				case ILCode.Stfld:  				case ILCode.Stsfld:  					if (i == parent.Arguments.Count - 1) // last argument is stored value  						return CleanUpVariableName(((FieldReference)parent.Operand).Name);  					else  						break;  				case ILCode.Call:  				case ILCode.Callvirt:  				case ILCode.Newobj:  				case ILCode.CallGetter:  				case ILCode.CallvirtGetter:  				case ILCode.CallSetter:  				case ILCode.CallvirtSetter:  					MethodReference methodRef = (MethodReference)parent.Operand;  					if (methodRef.Parameters.Count == 1 && i == parent.Arguments.Count - 1) {  						// argument might be value of a setter  						if (methodRef.Name.StartsWith("set_"' StringComparison.OrdinalIgnoreCase)) {  							return CleanUpVariableName(methodRef.Name.Substring(4));  						} else if (methodRef.Name.StartsWith("Set"' StringComparison.OrdinalIgnoreCase) && methodRef.Name.Length >= 4 && char.IsUpper(methodRef.Name[3])) {  							return CleanUpVariableName(methodRef.Name.Substring(3));  						}  					}  					MethodDefinition methodDef = methodRef.Resolve();  					if (methodDef != null) {  						var p = methodDef.Parameters.ElementAtOrDefault((parent.Code != ILCode.Newobj && methodDef.HasThis) ? i - 1 : i);  						if (p != null && !string.IsNullOrEmpty(p.Name))  							return CleanUpVariableName(p.Name);  					}  					break;  				case ILCode.Ret:  					return "result";  			}
Magic Number,Custom.Decompiler.Ast,NameVariables,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\NameVariables.cs,GetNameForArgument,The following statement contains a magic number: switch (parent.Code) {  				case ILCode.Stfld:  				case ILCode.Stsfld:  					if (i == parent.Arguments.Count - 1) // last argument is stored value  						return CleanUpVariableName(((FieldReference)parent.Operand).Name);  					else  						break;  				case ILCode.Call:  				case ILCode.Callvirt:  				case ILCode.Newobj:  				case ILCode.CallGetter:  				case ILCode.CallvirtGetter:  				case ILCode.CallSetter:  				case ILCode.CallvirtSetter:  					MethodReference methodRef = (MethodReference)parent.Operand;  					if (methodRef.Parameters.Count == 1 && i == parent.Arguments.Count - 1) {  						// argument might be value of a setter  						if (methodRef.Name.StartsWith("set_"' StringComparison.OrdinalIgnoreCase)) {  							return CleanUpVariableName(methodRef.Name.Substring(4));  						} else if (methodRef.Name.StartsWith("Set"' StringComparison.OrdinalIgnoreCase) && methodRef.Name.Length >= 4 && char.IsUpper(methodRef.Name[3])) {  							return CleanUpVariableName(methodRef.Name.Substring(3));  						}  					}  					MethodDefinition methodDef = methodRef.Resolve();  					if (methodDef != null) {  						var p = methodDef.Parameters.ElementAtOrDefault((parent.Code != ILCode.Newobj && methodDef.HasThis) ? i - 1 : i);  						if (p != null && !string.IsNullOrEmpty(p.Name))  							return CleanUpVariableName(p.Name);  					}  					break;  				case ILCode.Ret:  					return "result";  			}
Magic Number,Custom.Decompiler.Ast,NameVariables,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\NameVariables.cs,GetNameForArgument,The following statement contains a magic number: switch (parent.Code) {  				case ILCode.Stfld:  				case ILCode.Stsfld:  					if (i == parent.Arguments.Count - 1) // last argument is stored value  						return CleanUpVariableName(((FieldReference)parent.Operand).Name);  					else  						break;  				case ILCode.Call:  				case ILCode.Callvirt:  				case ILCode.Newobj:  				case ILCode.CallGetter:  				case ILCode.CallvirtGetter:  				case ILCode.CallSetter:  				case ILCode.CallvirtSetter:  					MethodReference methodRef = (MethodReference)parent.Operand;  					if (methodRef.Parameters.Count == 1 && i == parent.Arguments.Count - 1) {  						// argument might be value of a setter  						if (methodRef.Name.StartsWith("set_"' StringComparison.OrdinalIgnoreCase)) {  							return CleanUpVariableName(methodRef.Name.Substring(4));  						} else if (methodRef.Name.StartsWith("Set"' StringComparison.OrdinalIgnoreCase) && methodRef.Name.Length >= 4 && char.IsUpper(methodRef.Name[3])) {  							return CleanUpVariableName(methodRef.Name.Substring(3));  						}  					}  					MethodDefinition methodDef = methodRef.Resolve();  					if (methodDef != null) {  						var p = methodDef.Parameters.ElementAtOrDefault((parent.Code != ILCode.Newobj && methodDef.HasThis) ? i - 1 : i);  						if (p != null && !string.IsNullOrEmpty(p.Name))  							return CleanUpVariableName(p.Name);  					}  					break;  				case ILCode.Ret:  					return "result";  			}
Magic Number,Custom.Decompiler.Ast,NameVariables,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\NameVariables.cs,GetNameForArgument,The following statement contains a magic number: switch (parent.Code) {  				case ILCode.Stfld:  				case ILCode.Stsfld:  					if (i == parent.Arguments.Count - 1) // last argument is stored value  						return CleanUpVariableName(((FieldReference)parent.Operand).Name);  					else  						break;  				case ILCode.Call:  				case ILCode.Callvirt:  				case ILCode.Newobj:  				case ILCode.CallGetter:  				case ILCode.CallvirtGetter:  				case ILCode.CallSetter:  				case ILCode.CallvirtSetter:  					MethodReference methodRef = (MethodReference)parent.Operand;  					if (methodRef.Parameters.Count == 1 && i == parent.Arguments.Count - 1) {  						// argument might be value of a setter  						if (methodRef.Name.StartsWith("set_"' StringComparison.OrdinalIgnoreCase)) {  							return CleanUpVariableName(methodRef.Name.Substring(4));  						} else if (methodRef.Name.StartsWith("Set"' StringComparison.OrdinalIgnoreCase) && methodRef.Name.Length >= 4 && char.IsUpper(methodRef.Name[3])) {  							return CleanUpVariableName(methodRef.Name.Substring(3));  						}  					}  					MethodDefinition methodDef = methodRef.Resolve();  					if (methodDef != null) {  						var p = methodDef.Parameters.ElementAtOrDefault((parent.Code != ILCode.Newobj && methodDef.HasThis) ? i - 1 : i);  						if (p != null && !string.IsNullOrEmpty(p.Name))  							return CleanUpVariableName(p.Name);  					}  					break;  				case ILCode.Ret:  					return "result";  			}
Magic Number,Custom.Decompiler.Ast,NameVariables,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\NameVariables.cs,CleanUpVariableName,The following statement contains a magic number: name = name.Substring(2);
Magic Number,Custom.Decompiler.Ast,NameVariables,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\NameVariables.cs,CleanUpVariableName,The following statement contains a magic number: name.Length > 2 && name.StartsWith("m_"' StringComparison.Ordinal)
Magic Number,Custom.Decompiler,CecilExtensions,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\CecilExtensions.cs,GetPushDelta,The following statement contains a magic number: switch (code.StackBehaviourPush) {  				case StackBehaviour.Push0:  					return 0;    				case StackBehaviour.Push1:  				case StackBehaviour.Pushi:  				case StackBehaviour.Pushi8:  				case StackBehaviour.Pushr4:  				case StackBehaviour.Pushr8:  				case StackBehaviour.Pushref:  					return 1;    				case StackBehaviour.Push1_push1:  					return 2;    				case StackBehaviour.Varpush:  					if (code.FlowControl != FlowControl.Call)  						break;    					IMethodSignature method = (IMethodSignature) instruction.Operand;  					return IsVoid (method.ReturnType) ? 0 : 1;  			}
Magic Number,Custom.Decompiler,CecilExtensions,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\CecilExtensions.cs,GetPopDelta,The following statement contains a magic number: switch (code.StackBehaviourPop) {  				case StackBehaviour.Pop0:  					return 0;  				case StackBehaviour.Popi:  				case StackBehaviour.Popref:  				case StackBehaviour.Pop1:  					return 1;    				case StackBehaviour.Pop1_pop1:  				case StackBehaviour.Popi_pop1:  				case StackBehaviour.Popi_popi:  				case StackBehaviour.Popi_popi8:  				case StackBehaviour.Popi_popr4:  				case StackBehaviour.Popi_popr8:  				case StackBehaviour.Popref_pop1:  				case StackBehaviour.Popref_popi:  					return 2;    				case StackBehaviour.Popi_popi_popi:  				case StackBehaviour.Popref_popi_popi:  				case StackBehaviour.Popref_popi_popi8:  				case StackBehaviour.Popref_popi_popr4:  				case StackBehaviour.Popref_popi_popr8:  				case StackBehaviour.Popref_popi_popref:  					return 3;    				case StackBehaviour.PopAll:  					return null;    				case StackBehaviour.Varpop:  					if (code == OpCodes.Ret)  						return methodDef.ReturnType.IsVoid() ? 0 : 1;    					if (code.FlowControl != FlowControl.Call)  						break;    					IMethodSignature method = (IMethodSignature) instruction.Operand;  					int count = method.HasParameters ? method.Parameters.Count : 0;  					if (method.HasThis && code != OpCodes.Newobj)  						++count;  					if (code == OpCodes.Calli)  						++count; // calli takes a function pointer in additional to the normal args    					return count;  			}
Magic Number,Custom.Decompiler,CecilExtensions,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\CecilExtensions.cs,GetPopDelta,The following statement contains a magic number: switch (code.StackBehaviourPop) {  				case StackBehaviour.Pop0:  					return 0;  				case StackBehaviour.Popi:  				case StackBehaviour.Popref:  				case StackBehaviour.Pop1:  					return 1;    				case StackBehaviour.Pop1_pop1:  				case StackBehaviour.Popi_pop1:  				case StackBehaviour.Popi_popi:  				case StackBehaviour.Popi_popi8:  				case StackBehaviour.Popi_popr4:  				case StackBehaviour.Popi_popr8:  				case StackBehaviour.Popref_pop1:  				case StackBehaviour.Popref_popi:  					return 2;    				case StackBehaviour.Popi_popi_popi:  				case StackBehaviour.Popref_popi_popi:  				case StackBehaviour.Popref_popi_popi8:  				case StackBehaviour.Popref_popi_popr4:  				case StackBehaviour.Popref_popi_popr8:  				case StackBehaviour.Popref_popi_popref:  					return 3;    				case StackBehaviour.PopAll:  					return null;    				case StackBehaviour.Varpop:  					if (code == OpCodes.Ret)  						return methodDef.ReturnType.IsVoid() ? 0 : 1;    					if (code.FlowControl != FlowControl.Call)  						break;    					IMethodSignature method = (IMethodSignature) instruction.Operand;  					int count = method.HasParameters ? method.Parameters.Count : 0;  					if (method.HasThis && code != OpCodes.Newobj)  						++count;  					if (code == OpCodes.Calli)  						++count; // calli takes a function pointer in additional to the normal args    					return count;  			}
Magic Number,Custom.Decompiler.Ast.Transforms,AddCheckedBlocks,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\Transforms\AddCheckedBlocks.cs,GetResult,The following statement contains a magic number: result.CostInUncheckedContext += new Cost(10000' 0);
Magic Number,Custom.Decompiler.Ast.Transforms,DelegateConstruction,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\Transforms\DelegateConstruction.cs,VisitObjectCreateExpression,The following statement contains a magic number: objectCreateExpression.Arguments.Count == 2
Magic Number,Custom.Decompiler.Ast.Transforms,DelegateConstruction,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\Transforms\DelegateConstruction.cs,VisitBlockStatement,The following statement contains a magic number: capturedVariableName = capturedVariableName.Substring(10);
Magic Number,Custom.Decompiler.Ast.Transforms,DelegateConstruction,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\Transforms\DelegateConstruction.cs,VisitBlockStatement,The following statement contains a magic number: capturedVariableName.StartsWith("$VB$Local_"' StringComparison.Ordinal) && capturedVariableName.Length > 10
Magic Number,Custom.Decompiler.Ast.Transforms,ExpressionTreeConverter,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\Transforms\ExpressionTreeConverter.cs,CouldBeExpressionTree,The following statement contains a magic number: expr != null && expr.Arguments.Count == 2
Magic Number,Custom.Decompiler.Ast.Transforms,ExpressionTreeConverter,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\Transforms\ExpressionTreeConverter.cs,ConvertLambda,The following statement contains a magic number: invocation.Arguments.Count != 2
Magic Number,Custom.Decompiler.Ast.Transforms,ExpressionTreeConverter,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\Transforms\ExpressionTreeConverter.cs,ConvertField,The following statement contains a magic number: invocation.Arguments.Count != 2
Magic Number,Custom.Decompiler.Ast.Transforms,ExpressionTreeConverter,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\Transforms\ExpressionTreeConverter.cs,ConvertProperty,The following statement contains a magic number: invocation.Arguments.Count != 2
Magic Number,Custom.Decompiler.Ast.Transforms,ExpressionTreeConverter,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\Transforms\ExpressionTreeConverter.cs,GetPropertyName,The following statement contains a magic number: name = name.Substring(4);
Magic Number,Custom.Decompiler.Ast.Transforms,ExpressionTreeConverter,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\Transforms\ExpressionTreeConverter.cs,ConvertCall,The following statement contains a magic number: invocation.Arguments.Count < 2
Magic Number,Custom.Decompiler.Ast.Transforms,ExpressionTreeConverter,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\Transforms\ExpressionTreeConverter.cs,ConvertInvoke,The following statement contains a magic number: invocation.Arguments.Count != 2
Magic Number,Custom.Decompiler.Ast.Transforms,ExpressionTreeConverter,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\Transforms\ExpressionTreeConverter.cs,ConvertBinaryOperator,The following statement contains a magic number: invocation.Arguments.Count < 2
Magic Number,Custom.Decompiler.Ast.Transforms,ExpressionTreeConverter,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\Transforms\ExpressionTreeConverter.cs,ConvertBinaryOperator,The following statement contains a magic number: switch (invocation.Arguments.Count) {  				case 2:  					return boe;  				case 3:  					Match m = getMethodFromHandlePattern.Match(invocation.Arguments.ElementAt(2));  					if (m.Success)  						return boe.WithAnnotation(m.Get<AstNode>("method").Single().Annotation<MethodReference>());  					else  						return null;  				case 4:  					if (!trueOrFalse.IsMatch(invocation.Arguments.ElementAt(2)))  						return null;  					m = getMethodFromHandlePattern.Match(invocation.Arguments.ElementAt(3));  					if (m.Success)  						return boe.WithAnnotation(m.Get<AstNode>("method").Single().Annotation<MethodReference>());  					else  						return null;  				default:  					return NotSupported(invocation);  			}
Magic Number,Custom.Decompiler.Ast.Transforms,ExpressionTreeConverter,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\Transforms\ExpressionTreeConverter.cs,ConvertBinaryOperator,The following statement contains a magic number: switch (invocation.Arguments.Count) {  				case 2:  					return boe;  				case 3:  					Match m = getMethodFromHandlePattern.Match(invocation.Arguments.ElementAt(2));  					if (m.Success)  						return boe.WithAnnotation(m.Get<AstNode>("method").Single().Annotation<MethodReference>());  					else  						return null;  				case 4:  					if (!trueOrFalse.IsMatch(invocation.Arguments.ElementAt(2)))  						return null;  					m = getMethodFromHandlePattern.Match(invocation.Arguments.ElementAt(3));  					if (m.Success)  						return boe.WithAnnotation(m.Get<AstNode>("method").Single().Annotation<MethodReference>());  					else  						return null;  				default:  					return NotSupported(invocation);  			}
Magic Number,Custom.Decompiler.Ast.Transforms,ExpressionTreeConverter,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\Transforms\ExpressionTreeConverter.cs,ConvertBinaryOperator,The following statement contains a magic number: switch (invocation.Arguments.Count) {  				case 2:  					return boe;  				case 3:  					Match m = getMethodFromHandlePattern.Match(invocation.Arguments.ElementAt(2));  					if (m.Success)  						return boe.WithAnnotation(m.Get<AstNode>("method").Single().Annotation<MethodReference>());  					else  						return null;  				case 4:  					if (!trueOrFalse.IsMatch(invocation.Arguments.ElementAt(2)))  						return null;  					m = getMethodFromHandlePattern.Match(invocation.Arguments.ElementAt(3));  					if (m.Success)  						return boe.WithAnnotation(m.Get<AstNode>("method").Single().Annotation<MethodReference>());  					else  						return null;  				default:  					return NotSupported(invocation);  			}
Magic Number,Custom.Decompiler.Ast.Transforms,ExpressionTreeConverter,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\Transforms\ExpressionTreeConverter.cs,ConvertBinaryOperator,The following statement contains a magic number: switch (invocation.Arguments.Count) {  				case 2:  					return boe;  				case 3:  					Match m = getMethodFromHandlePattern.Match(invocation.Arguments.ElementAt(2));  					if (m.Success)  						return boe.WithAnnotation(m.Get<AstNode>("method").Single().Annotation<MethodReference>());  					else  						return null;  				case 4:  					if (!trueOrFalse.IsMatch(invocation.Arguments.ElementAt(2)))  						return null;  					m = getMethodFromHandlePattern.Match(invocation.Arguments.ElementAt(3));  					if (m.Success)  						return boe.WithAnnotation(m.Get<AstNode>("method").Single().Annotation<MethodReference>());  					else  						return null;  				default:  					return NotSupported(invocation);  			}
Magic Number,Custom.Decompiler.Ast.Transforms,ExpressionTreeConverter,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\Transforms\ExpressionTreeConverter.cs,ConvertBinaryOperator,The following statement contains a magic number: switch (invocation.Arguments.Count) {  				case 2:  					return boe;  				case 3:  					Match m = getMethodFromHandlePattern.Match(invocation.Arguments.ElementAt(2));  					if (m.Success)  						return boe.WithAnnotation(m.Get<AstNode>("method").Single().Annotation<MethodReference>());  					else  						return null;  				case 4:  					if (!trueOrFalse.IsMatch(invocation.Arguments.ElementAt(2)))  						return null;  					m = getMethodFromHandlePattern.Match(invocation.Arguments.ElementAt(3));  					if (m.Success)  						return boe.WithAnnotation(m.Get<AstNode>("method").Single().Annotation<MethodReference>());  					else  						return null;  				default:  					return NotSupported(invocation);  			}
Magic Number,Custom.Decompiler.Ast.Transforms,ExpressionTreeConverter,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\Transforms\ExpressionTreeConverter.cs,ConvertBinaryOperator,The following statement contains a magic number: switch (invocation.Arguments.Count) {  				case 2:  					return boe;  				case 3:  					Match m = getMethodFromHandlePattern.Match(invocation.Arguments.ElementAt(2));  					if (m.Success)  						return boe.WithAnnotation(m.Get<AstNode>("method").Single().Annotation<MethodReference>());  					else  						return null;  				case 4:  					if (!trueOrFalse.IsMatch(invocation.Arguments.ElementAt(2)))  						return null;  					m = getMethodFromHandlePattern.Match(invocation.Arguments.ElementAt(3));  					if (m.Success)  						return boe.WithAnnotation(m.Get<AstNode>("method").Single().Annotation<MethodReference>());  					else  						return null;  				default:  					return NotSupported(invocation);  			}
Magic Number,Custom.Decompiler.Ast.Transforms,ExpressionTreeConverter,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\Transforms\ExpressionTreeConverter.cs,ConvertUnaryOperator,The following statement contains a magic number: switch (invocation.Arguments.Count) {  				case 1:  					return uoe;  				case 2:  					Match m = getMethodFromHandlePattern.Match(invocation.Arguments.ElementAt(1));  					if (m.Success)  						return uoe.WithAnnotation(m.Get<AstNode>("method").Single().Annotation<MethodReference>());  					else  						return null;  				default:  					return NotSupported(invocation);  			}
Magic Number,Custom.Decompiler.Ast.Transforms,ExpressionTreeConverter,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\Transforms\ExpressionTreeConverter.cs,ConvertCondition,The following statement contains a magic number: invocation.Arguments.Count != 3
Magic Number,Custom.Decompiler.Ast.Transforms,ExpressionTreeConverter,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\Transforms\ExpressionTreeConverter.cs,ConvertCondition,The following statement contains a magic number: Expression falseExpr = Convert(invocation.Arguments.ElementAt(2));
Magic Number,Custom.Decompiler.Ast.Transforms,ExpressionTreeConverter,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\Transforms\ExpressionTreeConverter.cs,ConvertNewObject,The following statement contains a magic number: invocation.Arguments.Count < 1 || invocation.Arguments.Count > 3
Magic Number,Custom.Decompiler.Ast.Transforms,ExpressionTreeConverter,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\Transforms\ExpressionTreeConverter.cs,ConvertNewObject,The following statement contains a magic number: invocation.Arguments.Count >= 2
Magic Number,Custom.Decompiler.Ast.Transforms,ExpressionTreeConverter,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\Transforms\ExpressionTreeConverter.cs,ConvertNewObject,The following statement contains a magic number: invocation.Arguments.Count >= 3 && declaringType.IsAnonymousType()
Magic Number,Custom.Decompiler.Ast.Transforms,ExpressionTreeConverter,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\Transforms\ExpressionTreeConverter.cs,ConvertListInit,The following statement contains a magic number: invocation.Arguments.Count != 2
Magic Number,Custom.Decompiler.Ast.Transforms,ExpressionTreeConverter,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\Transforms\ExpressionTreeConverter.cs,ConvertMemberInit,The following statement contains a magic number: invocation.Arguments.Count != 2
Magic Number,Custom.Decompiler.Ast.Transforms,ExpressionTreeConverter,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\Transforms\ExpressionTreeConverter.cs,ConvertMemberBindings,The following statement contains a magic number: bindingInvocation == null || bindingInvocation.Arguments.Count != 2
Magic Number,Custom.Decompiler.Ast.Transforms,ExpressionTreeConverter,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\Transforms\ExpressionTreeConverter.cs,ConvertCast,The following statement contains a magic number: invocation.Arguments.Count < 2
Magic Number,Custom.Decompiler.Ast.Transforms,ExpressionTreeConverter,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\Transforms\ExpressionTreeConverter.cs,ConvertCast,The following statement contains a magic number: switch (invocation.Arguments.Count) {  					case 2:  						return cast;  					case 3:  						Match m = getMethodFromHandlePattern.Match(invocation.Arguments.ElementAt(2));  						if (m.Success)  							return cast.WithAnnotation(m.Get<AstNode>("method").Single().Annotation<MethodReference>());  						else  							return null;  				}
Magic Number,Custom.Decompiler.Ast.Transforms,ExpressionTreeConverter,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\Transforms\ExpressionTreeConverter.cs,ConvertCast,The following statement contains a magic number: switch (invocation.Arguments.Count) {  					case 2:  						return cast;  					case 3:  						Match m = getMethodFromHandlePattern.Match(invocation.Arguments.ElementAt(2));  						if (m.Success)  							return cast.WithAnnotation(m.Get<AstNode>("method").Single().Annotation<MethodReference>());  						else  							return null;  				}
Magic Number,Custom.Decompiler.Ast.Transforms,ExpressionTreeConverter,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\Transforms\ExpressionTreeConverter.cs,ConvertCast,The following statement contains a magic number: switch (invocation.Arguments.Count) {  					case 2:  						return cast;  					case 3:  						Match m = getMethodFromHandlePattern.Match(invocation.Arguments.ElementAt(2));  						if (m.Success)  							return cast.WithAnnotation(m.Get<AstNode>("method").Single().Annotation<MethodReference>());  						else  							return null;  				}
Magic Number,Custom.Decompiler.Ast.Transforms,ExpressionTreeConverter,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\Transforms\ExpressionTreeConverter.cs,ConvertTypeAs,The following statement contains a magic number: invocation.Arguments.Count != 2
Magic Number,Custom.Decompiler.Ast.Transforms,ExpressionTreeConverter,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\Transforms\ExpressionTreeConverter.cs,ConvertTypeIs,The following statement contains a magic number: invocation.Arguments.Count != 2
Magic Number,Custom.Decompiler.Ast.Transforms,ExpressionTreeConverter,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\Transforms\ExpressionTreeConverter.cs,ConvertArrayIndex,The following statement contains a magic number: invocation.Arguments.Count != 2
Magic Number,Custom.Decompiler.Ast.Transforms,ExpressionTreeConverter,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\Transforms\ExpressionTreeConverter.cs,ConvertNewArrayInit,The following statement contains a magic number: invocation.Arguments.Count != 2
Magic Number,Custom.Decompiler.Ast.Transforms,ExpressionTreeConverter,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\Transforms\ExpressionTreeConverter.cs,ConvertNewArrayBounds,The following statement contains a magic number: invocation.Arguments.Count != 2
Magic Number,Custom.Decompiler.Ast.Transforms,IntroduceQueryExpressions,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\Transforms\IntroduceQueryExpressions.cs,DecompileQuery,The following statement contains a magic number: switch (mre.MemberName) {  				case "Select":  					{  						if (invocation.Arguments.Count != 1)  							return null;  						string parameterName;  						Expression body;  						if (MatchSimpleLambda(invocation.Arguments.Single()' out parameterName' out body)) {  							QueryExpression query = new QueryExpression();  							query.Clauses.Add(new QueryFromClause { Identifier = parameterName' Expression = mre.Target.Detach() });  							query.Clauses.Add(new QuerySelectClause { Expression = body.Detach() });  							return query;  						}  						return null;  					}  				case "GroupBy":  					{  						if (invocation.Arguments.Count == 2) {  							string parameterName1' parameterName2;  							Expression keySelector' elementSelector;  							if (MatchSimpleLambda(invocation.Arguments.ElementAt(0)' out parameterName1' out keySelector)  							    && MatchSimpleLambda(invocation.Arguments.ElementAt(1)' out parameterName2' out elementSelector)  							    && parameterName1 == parameterName2)  							{  								QueryExpression query = new QueryExpression();  								query.Clauses.Add(new QueryFromClause { Identifier = parameterName1' Expression = mre.Target.Detach() });  								query.Clauses.Add(new QueryGroupClause { Projection = elementSelector.Detach()' Key = keySelector.Detach() });  								return query;  							}  						} else if (invocation.Arguments.Count == 1) {  							string parameterName;  							Expression keySelector;  							if (MatchSimpleLambda(invocation.Arguments.Single()' out parameterName' out keySelector)) {  								QueryExpression query = new QueryExpression();  								query.Clauses.Add(new QueryFromClause { Identifier = parameterName' Expression = mre.Target.Detach() });  								query.Clauses.Add(new QueryGroupClause { Projection = new IdentifierExpression(parameterName)' Key = keySelector.Detach() });  								return query;  							}  						}  						return null;  					}  				case "SelectMany":  					{  						if (invocation.Arguments.Count != 2)  							return null;  						string parameterName;  						Expression collectionSelector;  						if (!MatchSimpleLambda(invocation.Arguments.ElementAt(0)' out parameterName' out collectionSelector))  							return null;  						LambdaExpression lambda = invocation.Arguments.ElementAt(1) as LambdaExpression;  						if (lambda != null && lambda.Parameters.Count == 2 && lambda.Body is Expression) {  							ParameterDeclaration p1 = lambda.Parameters.ElementAt(0);  							ParameterDeclaration p2 = lambda.Parameters.ElementAt(1);  							if (p1.Name == parameterName) {  								QueryExpression query = new QueryExpression();  								query.Clauses.Add(new QueryFromClause { Identifier = p1.Name' Expression = mre.Target.Detach() });  								query.Clauses.Add(new QueryFromClause { Identifier = p2.Name' Expression = collectionSelector.Detach() });  								query.Clauses.Add(new QuerySelectClause { Expression = ((Expression)lambda.Body).Detach() });  								return query;  							}  						}  						return null;  					}  				case "Where":  					{  						if (invocation.Arguments.Count != 1)  							return null;  						string parameterName;  						Expression body;  						if (MatchSimpleLambda(invocation.Arguments.Single()' out parameterName' out body)) {  							QueryExpression query = new QueryExpression();  							query.Clauses.Add(new QueryFromClause { Identifier = parameterName' Expression = mre.Target.Detach() });  							query.Clauses.Add(new QueryWhereClause { Condition = body.Detach() });  							return query;  						}  						return null;  					}  				case "OrderBy":  				case "OrderByDescending":  				case "ThenBy":  				case "ThenByDescending":  					{  						if (invocation.Arguments.Count != 1)  							return null;  						string parameterName;  						Expression orderExpression;  						if (MatchSimpleLambda(invocation.Arguments.Single()' out parameterName' out orderExpression)) {  							if (ValidateThenByChain(invocation' parameterName)) {  								QueryOrderClause orderClause = new QueryOrderClause();  								InvocationExpression tmp = invocation;  								while (mre.MemberName == "ThenBy" || mre.MemberName == "ThenByDescending") {  									// insert new ordering at beginning  									orderClause.Orderings.InsertAfter(  										null' new QueryOrdering {  											Expression = orderExpression.Detach()'  											Direction = (mre.MemberName == "ThenBy" ? QueryOrderingDirection.None : QueryOrderingDirection.Descending)  										});  									  									tmp = (InvocationExpression)mre.Target;  									mre = (MemberReferenceExpression)tmp.Target;  									MatchSimpleLambda(tmp.Arguments.Single()' out parameterName' out orderExpression);  								}  								// insert new ordering at beginning  								orderClause.Orderings.InsertAfter(  									null' new QueryOrdering {  										Expression = orderExpression.Detach()'  										Direction = (mre.MemberName == "OrderBy" ? QueryOrderingDirection.None : QueryOrderingDirection.Descending)  									});  								  								QueryExpression query = new QueryExpression();  								query.Clauses.Add(new QueryFromClause { Identifier = parameterName' Expression = mre.Target.Detach() });  								query.Clauses.Add(orderClause);  								return query;  							}  						}  						return null;  					}  				case "Join":  				case "GroupJoin":  					{  						if (invocation.Arguments.Count != 4)  							return null;  						Expression source1 = mre.Target;  						Expression source2 = invocation.Arguments.ElementAt(0);  						string elementName1' elementName2;  						Expression key1' key2;  						if (!MatchSimpleLambda(invocation.Arguments.ElementAt(1)' out elementName1' out key1))  							return null;  						if (!MatchSimpleLambda(invocation.Arguments.ElementAt(2)' out elementName2' out key2))  							return null;  						LambdaExpression lambda = invocation.Arguments.ElementAt(3) as LambdaExpression;  						if (lambda != null && lambda.Parameters.Count == 2 && lambda.Body is Expression) {  							ParameterDeclaration p1 = lambda.Parameters.ElementAt(0);  							ParameterDeclaration p2 = lambda.Parameters.ElementAt(1);  							if (p1.Name == elementName1 && (p2.Name == elementName2 || mre.MemberName == "GroupJoin")) {  								QueryExpression query = new QueryExpression();  								query.Clauses.Add(new QueryFromClause { Identifier = elementName1' Expression = source1.Detach() });  								QueryJoinClause joinClause = new QueryJoinClause();  								joinClause.JoinIdentifier = elementName2;    // join elementName2  								joinClause.InExpression = source2.Detach();  // in source2  								joinClause.OnExpression = key1.Detach();     // on key1  								joinClause.EqualsExpression = key2.Detach(); // equals key2  								if (mre.MemberName == "GroupJoin") {  									joinClause.IntoIdentifier = p2.Name; // into p2.Name  								}  								query.Clauses.Add(joinClause);  								query.Clauses.Add(new QuerySelectClause { Expression = ((Expression)lambda.Body).Detach() });  								return query;  							}  						}  						return null;  					}  				default:  					return null;  			}
Magic Number,Custom.Decompiler.Ast.Transforms,IntroduceQueryExpressions,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\Transforms\IntroduceQueryExpressions.cs,DecompileQuery,The following statement contains a magic number: switch (mre.MemberName) {  				case "Select":  					{  						if (invocation.Arguments.Count != 1)  							return null;  						string parameterName;  						Expression body;  						if (MatchSimpleLambda(invocation.Arguments.Single()' out parameterName' out body)) {  							QueryExpression query = new QueryExpression();  							query.Clauses.Add(new QueryFromClause { Identifier = parameterName' Expression = mre.Target.Detach() });  							query.Clauses.Add(new QuerySelectClause { Expression = body.Detach() });  							return query;  						}  						return null;  					}  				case "GroupBy":  					{  						if (invocation.Arguments.Count == 2) {  							string parameterName1' parameterName2;  							Expression keySelector' elementSelector;  							if (MatchSimpleLambda(invocation.Arguments.ElementAt(0)' out parameterName1' out keySelector)  							    && MatchSimpleLambda(invocation.Arguments.ElementAt(1)' out parameterName2' out elementSelector)  							    && parameterName1 == parameterName2)  							{  								QueryExpression query = new QueryExpression();  								query.Clauses.Add(new QueryFromClause { Identifier = parameterName1' Expression = mre.Target.Detach() });  								query.Clauses.Add(new QueryGroupClause { Projection = elementSelector.Detach()' Key = keySelector.Detach() });  								return query;  							}  						} else if (invocation.Arguments.Count == 1) {  							string parameterName;  							Expression keySelector;  							if (MatchSimpleLambda(invocation.Arguments.Single()' out parameterName' out keySelector)) {  								QueryExpression query = new QueryExpression();  								query.Clauses.Add(new QueryFromClause { Identifier = parameterName' Expression = mre.Target.Detach() });  								query.Clauses.Add(new QueryGroupClause { Projection = new IdentifierExpression(parameterName)' Key = keySelector.Detach() });  								return query;  							}  						}  						return null;  					}  				case "SelectMany":  					{  						if (invocation.Arguments.Count != 2)  							return null;  						string parameterName;  						Expression collectionSelector;  						if (!MatchSimpleLambda(invocation.Arguments.ElementAt(0)' out parameterName' out collectionSelector))  							return null;  						LambdaExpression lambda = invocation.Arguments.ElementAt(1) as LambdaExpression;  						if (lambda != null && lambda.Parameters.Count == 2 && lambda.Body is Expression) {  							ParameterDeclaration p1 = lambda.Parameters.ElementAt(0);  							ParameterDeclaration p2 = lambda.Parameters.ElementAt(1);  							if (p1.Name == parameterName) {  								QueryExpression query = new QueryExpression();  								query.Clauses.Add(new QueryFromClause { Identifier = p1.Name' Expression = mre.Target.Detach() });  								query.Clauses.Add(new QueryFromClause { Identifier = p2.Name' Expression = collectionSelector.Detach() });  								query.Clauses.Add(new QuerySelectClause { Expression = ((Expression)lambda.Body).Detach() });  								return query;  							}  						}  						return null;  					}  				case "Where":  					{  						if (invocation.Arguments.Count != 1)  							return null;  						string parameterName;  						Expression body;  						if (MatchSimpleLambda(invocation.Arguments.Single()' out parameterName' out body)) {  							QueryExpression query = new QueryExpression();  							query.Clauses.Add(new QueryFromClause { Identifier = parameterName' Expression = mre.Target.Detach() });  							query.Clauses.Add(new QueryWhereClause { Condition = body.Detach() });  							return query;  						}  						return null;  					}  				case "OrderBy":  				case "OrderByDescending":  				case "ThenBy":  				case "ThenByDescending":  					{  						if (invocation.Arguments.Count != 1)  							return null;  						string parameterName;  						Expression orderExpression;  						if (MatchSimpleLambda(invocation.Arguments.Single()' out parameterName' out orderExpression)) {  							if (ValidateThenByChain(invocation' parameterName)) {  								QueryOrderClause orderClause = new QueryOrderClause();  								InvocationExpression tmp = invocation;  								while (mre.MemberName == "ThenBy" || mre.MemberName == "ThenByDescending") {  									// insert new ordering at beginning  									orderClause.Orderings.InsertAfter(  										null' new QueryOrdering {  											Expression = orderExpression.Detach()'  											Direction = (mre.MemberName == "ThenBy" ? QueryOrderingDirection.None : QueryOrderingDirection.Descending)  										});  									  									tmp = (InvocationExpression)mre.Target;  									mre = (MemberReferenceExpression)tmp.Target;  									MatchSimpleLambda(tmp.Arguments.Single()' out parameterName' out orderExpression);  								}  								// insert new ordering at beginning  								orderClause.Orderings.InsertAfter(  									null' new QueryOrdering {  										Expression = orderExpression.Detach()'  										Direction = (mre.MemberName == "OrderBy" ? QueryOrderingDirection.None : QueryOrderingDirection.Descending)  									});  								  								QueryExpression query = new QueryExpression();  								query.Clauses.Add(new QueryFromClause { Identifier = parameterName' Expression = mre.Target.Detach() });  								query.Clauses.Add(orderClause);  								return query;  							}  						}  						return null;  					}  				case "Join":  				case "GroupJoin":  					{  						if (invocation.Arguments.Count != 4)  							return null;  						Expression source1 = mre.Target;  						Expression source2 = invocation.Arguments.ElementAt(0);  						string elementName1' elementName2;  						Expression key1' key2;  						if (!MatchSimpleLambda(invocation.Arguments.ElementAt(1)' out elementName1' out key1))  							return null;  						if (!MatchSimpleLambda(invocation.Arguments.ElementAt(2)' out elementName2' out key2))  							return null;  						LambdaExpression lambda = invocation.Arguments.ElementAt(3) as LambdaExpression;  						if (lambda != null && lambda.Parameters.Count == 2 && lambda.Body is Expression) {  							ParameterDeclaration p1 = lambda.Parameters.ElementAt(0);  							ParameterDeclaration p2 = lambda.Parameters.ElementAt(1);  							if (p1.Name == elementName1 && (p2.Name == elementName2 || mre.MemberName == "GroupJoin")) {  								QueryExpression query = new QueryExpression();  								query.Clauses.Add(new QueryFromClause { Identifier = elementName1' Expression = source1.Detach() });  								QueryJoinClause joinClause = new QueryJoinClause();  								joinClause.JoinIdentifier = elementName2;    // join elementName2  								joinClause.InExpression = source2.Detach();  // in source2  								joinClause.OnExpression = key1.Detach();     // on key1  								joinClause.EqualsExpression = key2.Detach(); // equals key2  								if (mre.MemberName == "GroupJoin") {  									joinClause.IntoIdentifier = p2.Name; // into p2.Name  								}  								query.Clauses.Add(joinClause);  								query.Clauses.Add(new QuerySelectClause { Expression = ((Expression)lambda.Body).Detach() });  								return query;  							}  						}  						return null;  					}  				default:  					return null;  			}
Magic Number,Custom.Decompiler.Ast.Transforms,IntroduceQueryExpressions,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\Transforms\IntroduceQueryExpressions.cs,DecompileQuery,The following statement contains a magic number: switch (mre.MemberName) {  				case "Select":  					{  						if (invocation.Arguments.Count != 1)  							return null;  						string parameterName;  						Expression body;  						if (MatchSimpleLambda(invocation.Arguments.Single()' out parameterName' out body)) {  							QueryExpression query = new QueryExpression();  							query.Clauses.Add(new QueryFromClause { Identifier = parameterName' Expression = mre.Target.Detach() });  							query.Clauses.Add(new QuerySelectClause { Expression = body.Detach() });  							return query;  						}  						return null;  					}  				case "GroupBy":  					{  						if (invocation.Arguments.Count == 2) {  							string parameterName1' parameterName2;  							Expression keySelector' elementSelector;  							if (MatchSimpleLambda(invocation.Arguments.ElementAt(0)' out parameterName1' out keySelector)  							    && MatchSimpleLambda(invocation.Arguments.ElementAt(1)' out parameterName2' out elementSelector)  							    && parameterName1 == parameterName2)  							{  								QueryExpression query = new QueryExpression();  								query.Clauses.Add(new QueryFromClause { Identifier = parameterName1' Expression = mre.Target.Detach() });  								query.Clauses.Add(new QueryGroupClause { Projection = elementSelector.Detach()' Key = keySelector.Detach() });  								return query;  							}  						} else if (invocation.Arguments.Count == 1) {  							string parameterName;  							Expression keySelector;  							if (MatchSimpleLambda(invocation.Arguments.Single()' out parameterName' out keySelector)) {  								QueryExpression query = new QueryExpression();  								query.Clauses.Add(new QueryFromClause { Identifier = parameterName' Expression = mre.Target.Detach() });  								query.Clauses.Add(new QueryGroupClause { Projection = new IdentifierExpression(parameterName)' Key = keySelector.Detach() });  								return query;  							}  						}  						return null;  					}  				case "SelectMany":  					{  						if (invocation.Arguments.Count != 2)  							return null;  						string parameterName;  						Expression collectionSelector;  						if (!MatchSimpleLambda(invocation.Arguments.ElementAt(0)' out parameterName' out collectionSelector))  							return null;  						LambdaExpression lambda = invocation.Arguments.ElementAt(1) as LambdaExpression;  						if (lambda != null && lambda.Parameters.Count == 2 && lambda.Body is Expression) {  							ParameterDeclaration p1 = lambda.Parameters.ElementAt(0);  							ParameterDeclaration p2 = lambda.Parameters.ElementAt(1);  							if (p1.Name == parameterName) {  								QueryExpression query = new QueryExpression();  								query.Clauses.Add(new QueryFromClause { Identifier = p1.Name' Expression = mre.Target.Detach() });  								query.Clauses.Add(new QueryFromClause { Identifier = p2.Name' Expression = collectionSelector.Detach() });  								query.Clauses.Add(new QuerySelectClause { Expression = ((Expression)lambda.Body).Detach() });  								return query;  							}  						}  						return null;  					}  				case "Where":  					{  						if (invocation.Arguments.Count != 1)  							return null;  						string parameterName;  						Expression body;  						if (MatchSimpleLambda(invocation.Arguments.Single()' out parameterName' out body)) {  							QueryExpression query = new QueryExpression();  							query.Clauses.Add(new QueryFromClause { Identifier = parameterName' Expression = mre.Target.Detach() });  							query.Clauses.Add(new QueryWhereClause { Condition = body.Detach() });  							return query;  						}  						return null;  					}  				case "OrderBy":  				case "OrderByDescending":  				case "ThenBy":  				case "ThenByDescending":  					{  						if (invocation.Arguments.Count != 1)  							return null;  						string parameterName;  						Expression orderExpression;  						if (MatchSimpleLambda(invocation.Arguments.Single()' out parameterName' out orderExpression)) {  							if (ValidateThenByChain(invocation' parameterName)) {  								QueryOrderClause orderClause = new QueryOrderClause();  								InvocationExpression tmp = invocation;  								while (mre.MemberName == "ThenBy" || mre.MemberName == "ThenByDescending") {  									// insert new ordering at beginning  									orderClause.Orderings.InsertAfter(  										null' new QueryOrdering {  											Expression = orderExpression.Detach()'  											Direction = (mre.MemberName == "ThenBy" ? QueryOrderingDirection.None : QueryOrderingDirection.Descending)  										});  									  									tmp = (InvocationExpression)mre.Target;  									mre = (MemberReferenceExpression)tmp.Target;  									MatchSimpleLambda(tmp.Arguments.Single()' out parameterName' out orderExpression);  								}  								// insert new ordering at beginning  								orderClause.Orderings.InsertAfter(  									null' new QueryOrdering {  										Expression = orderExpression.Detach()'  										Direction = (mre.MemberName == "OrderBy" ? QueryOrderingDirection.None : QueryOrderingDirection.Descending)  									});  								  								QueryExpression query = new QueryExpression();  								query.Clauses.Add(new QueryFromClause { Identifier = parameterName' Expression = mre.Target.Detach() });  								query.Clauses.Add(orderClause);  								return query;  							}  						}  						return null;  					}  				case "Join":  				case "GroupJoin":  					{  						if (invocation.Arguments.Count != 4)  							return null;  						Expression source1 = mre.Target;  						Expression source2 = invocation.Arguments.ElementAt(0);  						string elementName1' elementName2;  						Expression key1' key2;  						if (!MatchSimpleLambda(invocation.Arguments.ElementAt(1)' out elementName1' out key1))  							return null;  						if (!MatchSimpleLambda(invocation.Arguments.ElementAt(2)' out elementName2' out key2))  							return null;  						LambdaExpression lambda = invocation.Arguments.ElementAt(3) as LambdaExpression;  						if (lambda != null && lambda.Parameters.Count == 2 && lambda.Body is Expression) {  							ParameterDeclaration p1 = lambda.Parameters.ElementAt(0);  							ParameterDeclaration p2 = lambda.Parameters.ElementAt(1);  							if (p1.Name == elementName1 && (p2.Name == elementName2 || mre.MemberName == "GroupJoin")) {  								QueryExpression query = new QueryExpression();  								query.Clauses.Add(new QueryFromClause { Identifier = elementName1' Expression = source1.Detach() });  								QueryJoinClause joinClause = new QueryJoinClause();  								joinClause.JoinIdentifier = elementName2;    // join elementName2  								joinClause.InExpression = source2.Detach();  // in source2  								joinClause.OnExpression = key1.Detach();     // on key1  								joinClause.EqualsExpression = key2.Detach(); // equals key2  								if (mre.MemberName == "GroupJoin") {  									joinClause.IntoIdentifier = p2.Name; // into p2.Name  								}  								query.Clauses.Add(joinClause);  								query.Clauses.Add(new QuerySelectClause { Expression = ((Expression)lambda.Body).Detach() });  								return query;  							}  						}  						return null;  					}  				default:  					return null;  			}
Magic Number,Custom.Decompiler.Ast.Transforms,IntroduceQueryExpressions,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\Transforms\IntroduceQueryExpressions.cs,DecompileQuery,The following statement contains a magic number: switch (mre.MemberName) {  				case "Select":  					{  						if (invocation.Arguments.Count != 1)  							return null;  						string parameterName;  						Expression body;  						if (MatchSimpleLambda(invocation.Arguments.Single()' out parameterName' out body)) {  							QueryExpression query = new QueryExpression();  							query.Clauses.Add(new QueryFromClause { Identifier = parameterName' Expression = mre.Target.Detach() });  							query.Clauses.Add(new QuerySelectClause { Expression = body.Detach() });  							return query;  						}  						return null;  					}  				case "GroupBy":  					{  						if (invocation.Arguments.Count == 2) {  							string parameterName1' parameterName2;  							Expression keySelector' elementSelector;  							if (MatchSimpleLambda(invocation.Arguments.ElementAt(0)' out parameterName1' out keySelector)  							    && MatchSimpleLambda(invocation.Arguments.ElementAt(1)' out parameterName2' out elementSelector)  							    && parameterName1 == parameterName2)  							{  								QueryExpression query = new QueryExpression();  								query.Clauses.Add(new QueryFromClause { Identifier = parameterName1' Expression = mre.Target.Detach() });  								query.Clauses.Add(new QueryGroupClause { Projection = elementSelector.Detach()' Key = keySelector.Detach() });  								return query;  							}  						} else if (invocation.Arguments.Count == 1) {  							string parameterName;  							Expression keySelector;  							if (MatchSimpleLambda(invocation.Arguments.Single()' out parameterName' out keySelector)) {  								QueryExpression query = new QueryExpression();  								query.Clauses.Add(new QueryFromClause { Identifier = parameterName' Expression = mre.Target.Detach() });  								query.Clauses.Add(new QueryGroupClause { Projection = new IdentifierExpression(parameterName)' Key = keySelector.Detach() });  								return query;  							}  						}  						return null;  					}  				case "SelectMany":  					{  						if (invocation.Arguments.Count != 2)  							return null;  						string parameterName;  						Expression collectionSelector;  						if (!MatchSimpleLambda(invocation.Arguments.ElementAt(0)' out parameterName' out collectionSelector))  							return null;  						LambdaExpression lambda = invocation.Arguments.ElementAt(1) as LambdaExpression;  						if (lambda != null && lambda.Parameters.Count == 2 && lambda.Body is Expression) {  							ParameterDeclaration p1 = lambda.Parameters.ElementAt(0);  							ParameterDeclaration p2 = lambda.Parameters.ElementAt(1);  							if (p1.Name == parameterName) {  								QueryExpression query = new QueryExpression();  								query.Clauses.Add(new QueryFromClause { Identifier = p1.Name' Expression = mre.Target.Detach() });  								query.Clauses.Add(new QueryFromClause { Identifier = p2.Name' Expression = collectionSelector.Detach() });  								query.Clauses.Add(new QuerySelectClause { Expression = ((Expression)lambda.Body).Detach() });  								return query;  							}  						}  						return null;  					}  				case "Where":  					{  						if (invocation.Arguments.Count != 1)  							return null;  						string parameterName;  						Expression body;  						if (MatchSimpleLambda(invocation.Arguments.Single()' out parameterName' out body)) {  							QueryExpression query = new QueryExpression();  							query.Clauses.Add(new QueryFromClause { Identifier = parameterName' Expression = mre.Target.Detach() });  							query.Clauses.Add(new QueryWhereClause { Condition = body.Detach() });  							return query;  						}  						return null;  					}  				case "OrderBy":  				case "OrderByDescending":  				case "ThenBy":  				case "ThenByDescending":  					{  						if (invocation.Arguments.Count != 1)  							return null;  						string parameterName;  						Expression orderExpression;  						if (MatchSimpleLambda(invocation.Arguments.Single()' out parameterName' out orderExpression)) {  							if (ValidateThenByChain(invocation' parameterName)) {  								QueryOrderClause orderClause = new QueryOrderClause();  								InvocationExpression tmp = invocation;  								while (mre.MemberName == "ThenBy" || mre.MemberName == "ThenByDescending") {  									// insert new ordering at beginning  									orderClause.Orderings.InsertAfter(  										null' new QueryOrdering {  											Expression = orderExpression.Detach()'  											Direction = (mre.MemberName == "ThenBy" ? QueryOrderingDirection.None : QueryOrderingDirection.Descending)  										});  									  									tmp = (InvocationExpression)mre.Target;  									mre = (MemberReferenceExpression)tmp.Target;  									MatchSimpleLambda(tmp.Arguments.Single()' out parameterName' out orderExpression);  								}  								// insert new ordering at beginning  								orderClause.Orderings.InsertAfter(  									null' new QueryOrdering {  										Expression = orderExpression.Detach()'  										Direction = (mre.MemberName == "OrderBy" ? QueryOrderingDirection.None : QueryOrderingDirection.Descending)  									});  								  								QueryExpression query = new QueryExpression();  								query.Clauses.Add(new QueryFromClause { Identifier = parameterName' Expression = mre.Target.Detach() });  								query.Clauses.Add(orderClause);  								return query;  							}  						}  						return null;  					}  				case "Join":  				case "GroupJoin":  					{  						if (invocation.Arguments.Count != 4)  							return null;  						Expression source1 = mre.Target;  						Expression source2 = invocation.Arguments.ElementAt(0);  						string elementName1' elementName2;  						Expression key1' key2;  						if (!MatchSimpleLambda(invocation.Arguments.ElementAt(1)' out elementName1' out key1))  							return null;  						if (!MatchSimpleLambda(invocation.Arguments.ElementAt(2)' out elementName2' out key2))  							return null;  						LambdaExpression lambda = invocation.Arguments.ElementAt(3) as LambdaExpression;  						if (lambda != null && lambda.Parameters.Count == 2 && lambda.Body is Expression) {  							ParameterDeclaration p1 = lambda.Parameters.ElementAt(0);  							ParameterDeclaration p2 = lambda.Parameters.ElementAt(1);  							if (p1.Name == elementName1 && (p2.Name == elementName2 || mre.MemberName == "GroupJoin")) {  								QueryExpression query = new QueryExpression();  								query.Clauses.Add(new QueryFromClause { Identifier = elementName1' Expression = source1.Detach() });  								QueryJoinClause joinClause = new QueryJoinClause();  								joinClause.JoinIdentifier = elementName2;    // join elementName2  								joinClause.InExpression = source2.Detach();  // in source2  								joinClause.OnExpression = key1.Detach();     // on key1  								joinClause.EqualsExpression = key2.Detach(); // equals key2  								if (mre.MemberName == "GroupJoin") {  									joinClause.IntoIdentifier = p2.Name; // into p2.Name  								}  								query.Clauses.Add(joinClause);  								query.Clauses.Add(new QuerySelectClause { Expression = ((Expression)lambda.Body).Detach() });  								return query;  							}  						}  						return null;  					}  				default:  					return null;  			}
Magic Number,Custom.Decompiler.Ast.Transforms,IntroduceQueryExpressions,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\Transforms\IntroduceQueryExpressions.cs,DecompileQuery,The following statement contains a magic number: switch (mre.MemberName) {  				case "Select":  					{  						if (invocation.Arguments.Count != 1)  							return null;  						string parameterName;  						Expression body;  						if (MatchSimpleLambda(invocation.Arguments.Single()' out parameterName' out body)) {  							QueryExpression query = new QueryExpression();  							query.Clauses.Add(new QueryFromClause { Identifier = parameterName' Expression = mre.Target.Detach() });  							query.Clauses.Add(new QuerySelectClause { Expression = body.Detach() });  							return query;  						}  						return null;  					}  				case "GroupBy":  					{  						if (invocation.Arguments.Count == 2) {  							string parameterName1' parameterName2;  							Expression keySelector' elementSelector;  							if (MatchSimpleLambda(invocation.Arguments.ElementAt(0)' out parameterName1' out keySelector)  							    && MatchSimpleLambda(invocation.Arguments.ElementAt(1)' out parameterName2' out elementSelector)  							    && parameterName1 == parameterName2)  							{  								QueryExpression query = new QueryExpression();  								query.Clauses.Add(new QueryFromClause { Identifier = parameterName1' Expression = mre.Target.Detach() });  								query.Clauses.Add(new QueryGroupClause { Projection = elementSelector.Detach()' Key = keySelector.Detach() });  								return query;  							}  						} else if (invocation.Arguments.Count == 1) {  							string parameterName;  							Expression keySelector;  							if (MatchSimpleLambda(invocation.Arguments.Single()' out parameterName' out keySelector)) {  								QueryExpression query = new QueryExpression();  								query.Clauses.Add(new QueryFromClause { Identifier = parameterName' Expression = mre.Target.Detach() });  								query.Clauses.Add(new QueryGroupClause { Projection = new IdentifierExpression(parameterName)' Key = keySelector.Detach() });  								return query;  							}  						}  						return null;  					}  				case "SelectMany":  					{  						if (invocation.Arguments.Count != 2)  							return null;  						string parameterName;  						Expression collectionSelector;  						if (!MatchSimpleLambda(invocation.Arguments.ElementAt(0)' out parameterName' out collectionSelector))  							return null;  						LambdaExpression lambda = invocation.Arguments.ElementAt(1) as LambdaExpression;  						if (lambda != null && lambda.Parameters.Count == 2 && lambda.Body is Expression) {  							ParameterDeclaration p1 = lambda.Parameters.ElementAt(0);  							ParameterDeclaration p2 = lambda.Parameters.ElementAt(1);  							if (p1.Name == parameterName) {  								QueryExpression query = new QueryExpression();  								query.Clauses.Add(new QueryFromClause { Identifier = p1.Name' Expression = mre.Target.Detach() });  								query.Clauses.Add(new QueryFromClause { Identifier = p2.Name' Expression = collectionSelector.Detach() });  								query.Clauses.Add(new QuerySelectClause { Expression = ((Expression)lambda.Body).Detach() });  								return query;  							}  						}  						return null;  					}  				case "Where":  					{  						if (invocation.Arguments.Count != 1)  							return null;  						string parameterName;  						Expression body;  						if (MatchSimpleLambda(invocation.Arguments.Single()' out parameterName' out body)) {  							QueryExpression query = new QueryExpression();  							query.Clauses.Add(new QueryFromClause { Identifier = parameterName' Expression = mre.Target.Detach() });  							query.Clauses.Add(new QueryWhereClause { Condition = body.Detach() });  							return query;  						}  						return null;  					}  				case "OrderBy":  				case "OrderByDescending":  				case "ThenBy":  				case "ThenByDescending":  					{  						if (invocation.Arguments.Count != 1)  							return null;  						string parameterName;  						Expression orderExpression;  						if (MatchSimpleLambda(invocation.Arguments.Single()' out parameterName' out orderExpression)) {  							if (ValidateThenByChain(invocation' parameterName)) {  								QueryOrderClause orderClause = new QueryOrderClause();  								InvocationExpression tmp = invocation;  								while (mre.MemberName == "ThenBy" || mre.MemberName == "ThenByDescending") {  									// insert new ordering at beginning  									orderClause.Orderings.InsertAfter(  										null' new QueryOrdering {  											Expression = orderExpression.Detach()'  											Direction = (mre.MemberName == "ThenBy" ? QueryOrderingDirection.None : QueryOrderingDirection.Descending)  										});  									  									tmp = (InvocationExpression)mre.Target;  									mre = (MemberReferenceExpression)tmp.Target;  									MatchSimpleLambda(tmp.Arguments.Single()' out parameterName' out orderExpression);  								}  								// insert new ordering at beginning  								orderClause.Orderings.InsertAfter(  									null' new QueryOrdering {  										Expression = orderExpression.Detach()'  										Direction = (mre.MemberName == "OrderBy" ? QueryOrderingDirection.None : QueryOrderingDirection.Descending)  									});  								  								QueryExpression query = new QueryExpression();  								query.Clauses.Add(new QueryFromClause { Identifier = parameterName' Expression = mre.Target.Detach() });  								query.Clauses.Add(orderClause);  								return query;  							}  						}  						return null;  					}  				case "Join":  				case "GroupJoin":  					{  						if (invocation.Arguments.Count != 4)  							return null;  						Expression source1 = mre.Target;  						Expression source2 = invocation.Arguments.ElementAt(0);  						string elementName1' elementName2;  						Expression key1' key2;  						if (!MatchSimpleLambda(invocation.Arguments.ElementAt(1)' out elementName1' out key1))  							return null;  						if (!MatchSimpleLambda(invocation.Arguments.ElementAt(2)' out elementName2' out key2))  							return null;  						LambdaExpression lambda = invocation.Arguments.ElementAt(3) as LambdaExpression;  						if (lambda != null && lambda.Parameters.Count == 2 && lambda.Body is Expression) {  							ParameterDeclaration p1 = lambda.Parameters.ElementAt(0);  							ParameterDeclaration p2 = lambda.Parameters.ElementAt(1);  							if (p1.Name == elementName1 && (p2.Name == elementName2 || mre.MemberName == "GroupJoin")) {  								QueryExpression query = new QueryExpression();  								query.Clauses.Add(new QueryFromClause { Identifier = elementName1' Expression = source1.Detach() });  								QueryJoinClause joinClause = new QueryJoinClause();  								joinClause.JoinIdentifier = elementName2;    // join elementName2  								joinClause.InExpression = source2.Detach();  // in source2  								joinClause.OnExpression = key1.Detach();     // on key1  								joinClause.EqualsExpression = key2.Detach(); // equals key2  								if (mre.MemberName == "GroupJoin") {  									joinClause.IntoIdentifier = p2.Name; // into p2.Name  								}  								query.Clauses.Add(joinClause);  								query.Clauses.Add(new QuerySelectClause { Expression = ((Expression)lambda.Body).Detach() });  								return query;  							}  						}  						return null;  					}  				default:  					return null;  			}
Magic Number,Custom.Decompiler.Ast.Transforms,IntroduceQueryExpressions,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\Transforms\IntroduceQueryExpressions.cs,DecompileQuery,The following statement contains a magic number: switch (mre.MemberName) {  				case "Select":  					{  						if (invocation.Arguments.Count != 1)  							return null;  						string parameterName;  						Expression body;  						if (MatchSimpleLambda(invocation.Arguments.Single()' out parameterName' out body)) {  							QueryExpression query = new QueryExpression();  							query.Clauses.Add(new QueryFromClause { Identifier = parameterName' Expression = mre.Target.Detach() });  							query.Clauses.Add(new QuerySelectClause { Expression = body.Detach() });  							return query;  						}  						return null;  					}  				case "GroupBy":  					{  						if (invocation.Arguments.Count == 2) {  							string parameterName1' parameterName2;  							Expression keySelector' elementSelector;  							if (MatchSimpleLambda(invocation.Arguments.ElementAt(0)' out parameterName1' out keySelector)  							    && MatchSimpleLambda(invocation.Arguments.ElementAt(1)' out parameterName2' out elementSelector)  							    && parameterName1 == parameterName2)  							{  								QueryExpression query = new QueryExpression();  								query.Clauses.Add(new QueryFromClause { Identifier = parameterName1' Expression = mre.Target.Detach() });  								query.Clauses.Add(new QueryGroupClause { Projection = elementSelector.Detach()' Key = keySelector.Detach() });  								return query;  							}  						} else if (invocation.Arguments.Count == 1) {  							string parameterName;  							Expression keySelector;  							if (MatchSimpleLambda(invocation.Arguments.Single()' out parameterName' out keySelector)) {  								QueryExpression query = new QueryExpression();  								query.Clauses.Add(new QueryFromClause { Identifier = parameterName' Expression = mre.Target.Detach() });  								query.Clauses.Add(new QueryGroupClause { Projection = new IdentifierExpression(parameterName)' Key = keySelector.Detach() });  								return query;  							}  						}  						return null;  					}  				case "SelectMany":  					{  						if (invocation.Arguments.Count != 2)  							return null;  						string parameterName;  						Expression collectionSelector;  						if (!MatchSimpleLambda(invocation.Arguments.ElementAt(0)' out parameterName' out collectionSelector))  							return null;  						LambdaExpression lambda = invocation.Arguments.ElementAt(1) as LambdaExpression;  						if (lambda != null && lambda.Parameters.Count == 2 && lambda.Body is Expression) {  							ParameterDeclaration p1 = lambda.Parameters.ElementAt(0);  							ParameterDeclaration p2 = lambda.Parameters.ElementAt(1);  							if (p1.Name == parameterName) {  								QueryExpression query = new QueryExpression();  								query.Clauses.Add(new QueryFromClause { Identifier = p1.Name' Expression = mre.Target.Detach() });  								query.Clauses.Add(new QueryFromClause { Identifier = p2.Name' Expression = collectionSelector.Detach() });  								query.Clauses.Add(new QuerySelectClause { Expression = ((Expression)lambda.Body).Detach() });  								return query;  							}  						}  						return null;  					}  				case "Where":  					{  						if (invocation.Arguments.Count != 1)  							return null;  						string parameterName;  						Expression body;  						if (MatchSimpleLambda(invocation.Arguments.Single()' out parameterName' out body)) {  							QueryExpression query = new QueryExpression();  							query.Clauses.Add(new QueryFromClause { Identifier = parameterName' Expression = mre.Target.Detach() });  							query.Clauses.Add(new QueryWhereClause { Condition = body.Detach() });  							return query;  						}  						return null;  					}  				case "OrderBy":  				case "OrderByDescending":  				case "ThenBy":  				case "ThenByDescending":  					{  						if (invocation.Arguments.Count != 1)  							return null;  						string parameterName;  						Expression orderExpression;  						if (MatchSimpleLambda(invocation.Arguments.Single()' out parameterName' out orderExpression)) {  							if (ValidateThenByChain(invocation' parameterName)) {  								QueryOrderClause orderClause = new QueryOrderClause();  								InvocationExpression tmp = invocation;  								while (mre.MemberName == "ThenBy" || mre.MemberName == "ThenByDescending") {  									// insert new ordering at beginning  									orderClause.Orderings.InsertAfter(  										null' new QueryOrdering {  											Expression = orderExpression.Detach()'  											Direction = (mre.MemberName == "ThenBy" ? QueryOrderingDirection.None : QueryOrderingDirection.Descending)  										});  									  									tmp = (InvocationExpression)mre.Target;  									mre = (MemberReferenceExpression)tmp.Target;  									MatchSimpleLambda(tmp.Arguments.Single()' out parameterName' out orderExpression);  								}  								// insert new ordering at beginning  								orderClause.Orderings.InsertAfter(  									null' new QueryOrdering {  										Expression = orderExpression.Detach()'  										Direction = (mre.MemberName == "OrderBy" ? QueryOrderingDirection.None : QueryOrderingDirection.Descending)  									});  								  								QueryExpression query = new QueryExpression();  								query.Clauses.Add(new QueryFromClause { Identifier = parameterName' Expression = mre.Target.Detach() });  								query.Clauses.Add(orderClause);  								return query;  							}  						}  						return null;  					}  				case "Join":  				case "GroupJoin":  					{  						if (invocation.Arguments.Count != 4)  							return null;  						Expression source1 = mre.Target;  						Expression source2 = invocation.Arguments.ElementAt(0);  						string elementName1' elementName2;  						Expression key1' key2;  						if (!MatchSimpleLambda(invocation.Arguments.ElementAt(1)' out elementName1' out key1))  							return null;  						if (!MatchSimpleLambda(invocation.Arguments.ElementAt(2)' out elementName2' out key2))  							return null;  						LambdaExpression lambda = invocation.Arguments.ElementAt(3) as LambdaExpression;  						if (lambda != null && lambda.Parameters.Count == 2 && lambda.Body is Expression) {  							ParameterDeclaration p1 = lambda.Parameters.ElementAt(0);  							ParameterDeclaration p2 = lambda.Parameters.ElementAt(1);  							if (p1.Name == elementName1 && (p2.Name == elementName2 || mre.MemberName == "GroupJoin")) {  								QueryExpression query = new QueryExpression();  								query.Clauses.Add(new QueryFromClause { Identifier = elementName1' Expression = source1.Detach() });  								QueryJoinClause joinClause = new QueryJoinClause();  								joinClause.JoinIdentifier = elementName2;    // join elementName2  								joinClause.InExpression = source2.Detach();  // in source2  								joinClause.OnExpression = key1.Detach();     // on key1  								joinClause.EqualsExpression = key2.Detach(); // equals key2  								if (mre.MemberName == "GroupJoin") {  									joinClause.IntoIdentifier = p2.Name; // into p2.Name  								}  								query.Clauses.Add(joinClause);  								query.Clauses.Add(new QuerySelectClause { Expression = ((Expression)lambda.Body).Detach() });  								return query;  							}  						}  						return null;  					}  				default:  					return null;  			}
Magic Number,Custom.Decompiler.Ast.Transforms,IntroduceQueryExpressions,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\Transforms\IntroduceQueryExpressions.cs,DecompileQuery,The following statement contains a magic number: switch (mre.MemberName) {  				case "Select":  					{  						if (invocation.Arguments.Count != 1)  							return null;  						string parameterName;  						Expression body;  						if (MatchSimpleLambda(invocation.Arguments.Single()' out parameterName' out body)) {  							QueryExpression query = new QueryExpression();  							query.Clauses.Add(new QueryFromClause { Identifier = parameterName' Expression = mre.Target.Detach() });  							query.Clauses.Add(new QuerySelectClause { Expression = body.Detach() });  							return query;  						}  						return null;  					}  				case "GroupBy":  					{  						if (invocation.Arguments.Count == 2) {  							string parameterName1' parameterName2;  							Expression keySelector' elementSelector;  							if (MatchSimpleLambda(invocation.Arguments.ElementAt(0)' out parameterName1' out keySelector)  							    && MatchSimpleLambda(invocation.Arguments.ElementAt(1)' out parameterName2' out elementSelector)  							    && parameterName1 == parameterName2)  							{  								QueryExpression query = new QueryExpression();  								query.Clauses.Add(new QueryFromClause { Identifier = parameterName1' Expression = mre.Target.Detach() });  								query.Clauses.Add(new QueryGroupClause { Projection = elementSelector.Detach()' Key = keySelector.Detach() });  								return query;  							}  						} else if (invocation.Arguments.Count == 1) {  							string parameterName;  							Expression keySelector;  							if (MatchSimpleLambda(invocation.Arguments.Single()' out parameterName' out keySelector)) {  								QueryExpression query = new QueryExpression();  								query.Clauses.Add(new QueryFromClause { Identifier = parameterName' Expression = mre.Target.Detach() });  								query.Clauses.Add(new QueryGroupClause { Projection = new IdentifierExpression(parameterName)' Key = keySelector.Detach() });  								return query;  							}  						}  						return null;  					}  				case "SelectMany":  					{  						if (invocation.Arguments.Count != 2)  							return null;  						string parameterName;  						Expression collectionSelector;  						if (!MatchSimpleLambda(invocation.Arguments.ElementAt(0)' out parameterName' out collectionSelector))  							return null;  						LambdaExpression lambda = invocation.Arguments.ElementAt(1) as LambdaExpression;  						if (lambda != null && lambda.Parameters.Count == 2 && lambda.Body is Expression) {  							ParameterDeclaration p1 = lambda.Parameters.ElementAt(0);  							ParameterDeclaration p2 = lambda.Parameters.ElementAt(1);  							if (p1.Name == parameterName) {  								QueryExpression query = new QueryExpression();  								query.Clauses.Add(new QueryFromClause { Identifier = p1.Name' Expression = mre.Target.Detach() });  								query.Clauses.Add(new QueryFromClause { Identifier = p2.Name' Expression = collectionSelector.Detach() });  								query.Clauses.Add(new QuerySelectClause { Expression = ((Expression)lambda.Body).Detach() });  								return query;  							}  						}  						return null;  					}  				case "Where":  					{  						if (invocation.Arguments.Count != 1)  							return null;  						string parameterName;  						Expression body;  						if (MatchSimpleLambda(invocation.Arguments.Single()' out parameterName' out body)) {  							QueryExpression query = new QueryExpression();  							query.Clauses.Add(new QueryFromClause { Identifier = parameterName' Expression = mre.Target.Detach() });  							query.Clauses.Add(new QueryWhereClause { Condition = body.Detach() });  							return query;  						}  						return null;  					}  				case "OrderBy":  				case "OrderByDescending":  				case "ThenBy":  				case "ThenByDescending":  					{  						if (invocation.Arguments.Count != 1)  							return null;  						string parameterName;  						Expression orderExpression;  						if (MatchSimpleLambda(invocation.Arguments.Single()' out parameterName' out orderExpression)) {  							if (ValidateThenByChain(invocation' parameterName)) {  								QueryOrderClause orderClause = new QueryOrderClause();  								InvocationExpression tmp = invocation;  								while (mre.MemberName == "ThenBy" || mre.MemberName == "ThenByDescending") {  									// insert new ordering at beginning  									orderClause.Orderings.InsertAfter(  										null' new QueryOrdering {  											Expression = orderExpression.Detach()'  											Direction = (mre.MemberName == "ThenBy" ? QueryOrderingDirection.None : QueryOrderingDirection.Descending)  										});  									  									tmp = (InvocationExpression)mre.Target;  									mre = (MemberReferenceExpression)tmp.Target;  									MatchSimpleLambda(tmp.Arguments.Single()' out parameterName' out orderExpression);  								}  								// insert new ordering at beginning  								orderClause.Orderings.InsertAfter(  									null' new QueryOrdering {  										Expression = orderExpression.Detach()'  										Direction = (mre.MemberName == "OrderBy" ? QueryOrderingDirection.None : QueryOrderingDirection.Descending)  									});  								  								QueryExpression query = new QueryExpression();  								query.Clauses.Add(new QueryFromClause { Identifier = parameterName' Expression = mre.Target.Detach() });  								query.Clauses.Add(orderClause);  								return query;  							}  						}  						return null;  					}  				case "Join":  				case "GroupJoin":  					{  						if (invocation.Arguments.Count != 4)  							return null;  						Expression source1 = mre.Target;  						Expression source2 = invocation.Arguments.ElementAt(0);  						string elementName1' elementName2;  						Expression key1' key2;  						if (!MatchSimpleLambda(invocation.Arguments.ElementAt(1)' out elementName1' out key1))  							return null;  						if (!MatchSimpleLambda(invocation.Arguments.ElementAt(2)' out elementName2' out key2))  							return null;  						LambdaExpression lambda = invocation.Arguments.ElementAt(3) as LambdaExpression;  						if (lambda != null && lambda.Parameters.Count == 2 && lambda.Body is Expression) {  							ParameterDeclaration p1 = lambda.Parameters.ElementAt(0);  							ParameterDeclaration p2 = lambda.Parameters.ElementAt(1);  							if (p1.Name == elementName1 && (p2.Name == elementName2 || mre.MemberName == "GroupJoin")) {  								QueryExpression query = new QueryExpression();  								query.Clauses.Add(new QueryFromClause { Identifier = elementName1' Expression = source1.Detach() });  								QueryJoinClause joinClause = new QueryJoinClause();  								joinClause.JoinIdentifier = elementName2;    // join elementName2  								joinClause.InExpression = source2.Detach();  // in source2  								joinClause.OnExpression = key1.Detach();     // on key1  								joinClause.EqualsExpression = key2.Detach(); // equals key2  								if (mre.MemberName == "GroupJoin") {  									joinClause.IntoIdentifier = p2.Name; // into p2.Name  								}  								query.Clauses.Add(joinClause);  								query.Clauses.Add(new QuerySelectClause { Expression = ((Expression)lambda.Body).Detach() });  								return query;  							}  						}  						return null;  					}  				default:  					return null;  			}
Magic Number,Custom.Decompiler.Ast.Transforms,ReplaceMethodCallsWithOperators,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\Transforms\ReplaceMethodCallsWithOperators.cs,ProcessInvocationExpression,The following statement contains a magic number: methodRef.Name == "Concat" && methodRef.DeclaringType.FullName == "System.String" && arguments.Length >= 2
Magic Number,Custom.Decompiler.Ast.Transforms,ReplaceMethodCallsWithOperators,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\Transforms\ReplaceMethodCallsWithOperators.cs,ProcessInvocationExpression,The following statement contains a magic number: switch (methodRef.FullName) {  				case "System.Type System.Type::GetTypeFromHandle(System.RuntimeTypeHandle)":  					if (arguments.Length == 1) {  						if (typeHandleOnTypeOfPattern.IsMatch(arguments[0])) {  							invocationExpression.ReplaceWith(((MemberReferenceExpression)arguments[0]).Target);  							return;  						}  					}  					break;  				case "System.Reflection.FieldInfo System.Reflection.FieldInfo::GetFieldFromHandle(System.RuntimeFieldHandle)":  					if (arguments.Length == 1) {  						MemberReferenceExpression mre = arguments[0] as MemberReferenceExpression;  						if (mre != null && mre.MemberName == "FieldHandle" && mre.Target.Annotation<LdTokenAnnotation>() != null) {  							invocationExpression.ReplaceWith(mre.Target);  							return;  						}  					}  					break;  				case "System.Reflection.FieldInfo System.Reflection.FieldInfo::GetFieldFromHandle(System.RuntimeFieldHandle'System.RuntimeTypeHandle)":  					if (arguments.Length == 2) {  						MemberReferenceExpression mre1 = arguments[0] as MemberReferenceExpression;  						MemberReferenceExpression mre2 = arguments[1] as MemberReferenceExpression;  						if (mre1 != null && mre1.MemberName == "FieldHandle" && mre1.Target.Annotation<LdTokenAnnotation>() != null) {  							if (mre2 != null && mre2.MemberName == "TypeHandle" && mre2.Target is TypeOfExpression) {  								Expression oldArg = ((InvocationExpression)mre1.Target).Arguments.Single();  								FieldReference field = oldArg.Annotation<FieldReference>();  								if (field != null) {  									AstType declaringType = ((TypeOfExpression)mre2.Target).Type.Detach();  									oldArg.ReplaceWith(declaringType.Member(field.Name).WithAnnotation(field));  									invocationExpression.ReplaceWith(mre1.Target);  									return;  								}  							}  						}  					}  					break;  			}
Magic Number,Custom.Decompiler.Ast.Transforms,ReplaceMethodCallsWithOperators,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\Transforms\ReplaceMethodCallsWithOperators.cs,ProcessInvocationExpression,The following statement contains a magic number: bop != null && arguments.Length == 2
Magic Number,Custom.Decompiler.Disassembler,ReflectionDisassembler,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Disassembler\ReflectionDisassembler.cs,WriteBlob,The following statement contains a magic number: i % 16 == 0 && i < blob.Length - 1
Magic Number,Custom.Decompiler.FlowAnalysis,ControlFlowGraphBuilder,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\FlowAnalysis\ControlFlowGraphBuilder.cs,ControlFlowGraphBuilder,The following statement contains a magic number: exceptionalExit = new ControlFlowNode(2' -1' ControlFlowNodeType.ExceptionalExit);
Magic Number,Custom.Decompiler.FlowAnalysis,ControlFlowGraphBuilder,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\FlowAnalysis\ControlFlowGraphBuilder.cs,ControlFlowGraphBuilder,The following statement contains a magic number: Debug.Assert(nodes.Count == 3);
Magic Number,Custom.Decompiler.ILAst,AsyncDecompiler,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\AsyncDecompiler.cs,MatchTaskCreationPattern,The following statement contains a magic number: method.Body.Count < 5
Magic Number,Custom.Decompiler.ILAst,AsyncDecompiler,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\AsyncDecompiler.cs,MatchTaskCreationPattern,The following statement contains a magic number: !method.Body[method.Body.Count - 2].Match(ILCode.Call' out startMethod' out loadStartTarget' out loadStartArgument)
Magic Number,Custom.Decompiler.ILAst,AsyncDecompiler,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\AsyncDecompiler.cs,MatchTaskCreationPattern,The following statement contains a magic number: !method.Body[method.Body.Count - 3].MatchStloc(builderVar' out loadBuilderExpr)
Magic Number,Custom.Decompiler.ILAst,AsyncDecompiler,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\AsyncDecompiler.cs,MatchTaskCreationPattern,The following statement contains a magic number: !MatchStFld(method.Body[method.Body.Count - 4]' stateMachineVar' out stateField' out initialStateExpr)
Magic Number,Custom.Decompiler.ILAst,AsyncDecompiler,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\AsyncDecompiler.cs,MatchTaskCreationPattern,The following statement contains a magic number: !MatchStFld(method.Body[method.Body.Count - 5]' stateMachineVar' out builderField3' out builderInitialization)
Magic Number,Custom.Decompiler.ILAst,AsyncDecompiler,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\AsyncDecompiler.cs,MatchTaskCreationPattern,The following statement contains a magic number: i < method.Body.Count - 5
Magic Number,Custom.Decompiler.ILAst,AsyncDecompiler,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\AsyncDecompiler.cs,AnalyzeMoveNext,The following statement contains a magic number: ilMethod.Body.Count != 6
Magic Number,Custom.Decompiler.ILAst,AsyncDecompiler,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\AsyncDecompiler.cs,AnalyzeMoveNext,The following statement contains a magic number: !MatchStateAssignment(ilMethod.Body[2]' out finalState)
Magic Number,Custom.Decompiler.ILAst,AsyncDecompiler,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\AsyncDecompiler.cs,AnalyzeMoveNext,The following statement contains a magic number: !ilMethod.Body[3].Match(ILCode.Call' out setResultMethod' out builderExpr' out resultExpr)
Magic Number,Custom.Decompiler.ILAst,AsyncDecompiler,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\AsyncDecompiler.cs,AnalyzeMoveNext,The following statement contains a magic number: exitLabel = ilMethod.Body[4] as ILLabel;
Magic Number,Custom.Decompiler.ILAst,AsyncDecompiler,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\AsyncDecompiler.cs,ValidateCatchBlock,The following statement contains a magic number: catchBlock.Body.Count != 3
Magic Number,Custom.Decompiler.ILAst,AsyncDecompiler,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\AsyncDecompiler.cs,ValidateCatchBlock,The following statement contains a magic number: !(catchBlock.Body[2].Match(ILCode.Leave' out label) && label == exitLabel)
Magic Number,Custom.Decompiler.ILAst,AsyncDecompiler,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\AsyncDecompiler.cs,HandleAwait,The following statement contains a magic number: callAwaitUnsafeOnCompleted.Arguments.Count != 3
Magic Number,Custom.Decompiler.ILAst,AsyncDecompiler,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\AsyncDecompiler.cs,Step2,The following statement contains a magic number: !(pos >= 2 && body[pos - 2].MatchStloc(awaiterVar' out getAwaiterCall))
Magic Number,Custom.Decompiler.ILAst,AsyncDecompiler,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\AsyncDecompiler.cs,Step2,The following statement contains a magic number: !(pos >= 2 && body[pos - 2].MatchStloc(awaiterVar' out getAwaiterCall))
Magic Number,Custom.Decompiler.ILAst,AsyncDecompiler,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\AsyncDecompiler.cs,Step2,The following statement contains a magic number: pos -= 2;
Magic Number,Custom.Decompiler.ILAst,GotoRemoval,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\GotoRemoval.cs,RemoveRedundantCode,The following statement contains a magic number: ilCase.Body[count - 2].IsUnconditionalControlFlow() &&  						    ilCase.Body[count - 1].Match(ILCode.LoopOrSwitchBreak)
Magic Number,Custom.Decompiler.ILAst,GotoRemoval,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\GotoRemoval.cs,RemoveRedundantCode,The following statement contains a magic number: count >= 2
Magic Number,Custom.Decompiler.ILAst,ILAstOptimizer,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,TransformArrayInitializers,The following statement contains a magic number: const int maxConsecutiveDefaultValueExpressions = 300;
Magic Number,Custom.Decompiler.ILAst,ILAstOptimizer,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,TransformArrayInitializers,The following statement contains a magic number: operands.Add(nextExpr.Arguments[2]);
Magic Number,Custom.Decompiler.ILAst,ILAstOptimizer,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,TransformArrayInitializers,The following statement contains a magic number: nextExpr != null &&  					    nextExpr.Code.IsStoreToArray() &&  					    nextExpr.Arguments[0].Match(ILCode.Ldloc' out v3) &&  					    v == v3 &&  					    nextExpr.Arguments[1].Match(ILCode.Ldc_I4' out arrayPos) &&  					    arrayPos >= operands.Count &&  					    arrayPos <= operands.Count + maxConsecutiveDefaultValueExpressions &&  					    !nextExpr.Arguments[2].ContainsReferenceTo(v3)
Magic Number,Custom.Decompiler.ILAst,ILAstOptimizer,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,ElementSizeOf,The following statement contains a magic number: switch (elementType) {  				case TypeCode.Boolean:  				case TypeCode.Byte:  				case TypeCode.SByte:  					return 1;  				case TypeCode.Char:  				case TypeCode.Int16:  				case TypeCode.UInt16:  					return 2;  				case TypeCode.Int32:  				case TypeCode.UInt32:  				case TypeCode.Single:  					return 4;  				case TypeCode.Int64:  				case TypeCode.UInt64:  				case TypeCode.Double:  					return 8;  				default:  					throw new ArgumentOutOfRangeException("elementType");  			}
Magic Number,Custom.Decompiler.ILAst,ILAstOptimizer,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,ElementSizeOf,The following statement contains a magic number: switch (elementType) {  				case TypeCode.Boolean:  				case TypeCode.Byte:  				case TypeCode.SByte:  					return 1;  				case TypeCode.Char:  				case TypeCode.Int16:  				case TypeCode.UInt16:  					return 2;  				case TypeCode.Int32:  				case TypeCode.UInt32:  				case TypeCode.Single:  					return 4;  				case TypeCode.Int64:  				case TypeCode.UInt64:  				case TypeCode.Double:  					return 8;  				default:  					throw new ArgumentOutOfRangeException("elementType");  			}
Magic Number,Custom.Decompiler.ILAst,ILAstOptimizer,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,ElementSizeOf,The following statement contains a magic number: switch (elementType) {  				case TypeCode.Boolean:  				case TypeCode.Byte:  				case TypeCode.SByte:  					return 1;  				case TypeCode.Char:  				case TypeCode.Int16:  				case TypeCode.UInt16:  					return 2;  				case TypeCode.Int32:  				case TypeCode.UInt32:  				case TypeCode.Single:  					return 4;  				case TypeCode.Int64:  				case TypeCode.UInt64:  				case TypeCode.Double:  					return 8;  				default:  					throw new ArgumentOutOfRangeException("elementType");  			}
Magic Number,Custom.Decompiler.ILAst,ILAstOptimizer,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,IsSetterInObjectInitializer,The following statement contains a magic number: return expr.Arguments.Count == 2;
Magic Number,Custom.Decompiler.ILAst,ILAstOptimizer,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,IsAddMethodCall,The following statement contains a magic number: return args.Count >= 2;
Magic Number,Custom.Decompiler.ILAst,ILAstOptimizer,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,CleanupInitializerStackAfterFailedAdjustment,The following statement contains a magic number: ILExpression parent = initializerStack[initializerStack.Count - 2];
Magic Number,Custom.Decompiler.ILAst,ILAstOptimizer,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,CachedDelegateInitializationWithField,The following statement contains a magic number: !(newObj.Code == ILCode.Newobj && newObj.Arguments.Count == 2)
Magic Number,Custom.Decompiler.ILAst,ILAstOptimizer,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,CachedDelegateInitializationWithLocal,The following statement contains a magic number: !(newObj.Code == ILCode.Newobj && newObj.Arguments.Count == 2)
Magic Number,Custom.Decompiler.ILAst,ILAstOptimizer,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,CachedDelegateInitializationWithLocal,The following statement contains a magic number: !(inlining.numLdloc.GetOrDefault(v) == 2 && inlining.numStloc.GetOrDefault(v) == 2 && inlining.numLdloca.GetOrDefault(v) == 0)
Magic Number,Custom.Decompiler.ILAst,ILAstOptimizer,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,CachedDelegateInitializationWithLocal,The following statement contains a magic number: !(inlining.numLdloc.GetOrDefault(v) == 2 && inlining.numStloc.GetOrDefault(v) == 2 && inlining.numLdloca.GetOrDefault(v) == 0)
Magic Number,Custom.Decompiler.ILAst,ILAstOptimizer,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,MakeAssignmentExpression,The following statement contains a magic number: ILExpression store2 = body.ElementAtOrDefault(pos + 2) as ILExpression;
Magic Number,Custom.Decompiler.ILAst,ILAstOptimizer,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,MakeAssignmentExpression,The following statement contains a magic number: body.RemoveAt(pos + 2);
Magic Number,Custom.Decompiler.ILAst,ILAstOptimizer,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,MakeAssignmentExpression,The following statement contains a magic number: inlining.numLdloc.GetOrDefault(exprVar) == 2 && inlining.numStloc.GetOrDefault(exprVar) == 1
Magic Number,Custom.Decompiler.ILAst,ILAstOptimizer,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,CanBeRepresentedAsCompoundAssignment,The following statement contains a magic number: switch (expr.Code) {  				case ILCode.Add:  				case ILCode.Add_Ovf:  				case ILCode.Add_Ovf_Un:  				case ILCode.Sub:  				case ILCode.Sub_Ovf:  				case ILCode.Sub_Ovf_Un:  				case ILCode.Mul:  				case ILCode.Mul_Ovf:  				case ILCode.Mul_Ovf_Un:  				case ILCode.Div:  				case ILCode.Div_Un:  				case ILCode.Rem:  				case ILCode.Rem_Un:  				case ILCode.And:  				case ILCode.Or:  				case ILCode.Xor:  				case ILCode.Shl:  				case ILCode.Shr:  				case ILCode.Shr_Un:  					return true;  				case ILCode.Call:  					var m = expr.Operand as MethodReference;  					if (m == null || m.HasThis || expr.Arguments.Count != 2) return false;  					switch (m.Name) {  						case "op_Addition":  						case "op_Subtraction":  						case "op_Multiply":  						case "op_Division":  						case "op_Modulus":  						case "op_BitwiseAnd":  						case "op_BitwiseOr":  						case "op_ExclusiveOr":  						case "op_LeftShift":  						case "op_RightShift":  							return true;  						default:  							return false;  					}  				default:  					return false;  			}
Magic Number,Custom.Decompiler.ILAst,ILAstOptimizer,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,MatchFixedInitializer,The following statement contains a magic number: inlining.numLdloc.GetOrDefault(arrayVariable) == 2 &&  									    inlining.numStloc.GetOrDefault(arrayVariable) == 1 && inlining.numLdloca.GetOrDefault(arrayVariable) == 0
Magic Number,Custom.Decompiler.ILAst,ILAstOptimizer,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,HandleStringFixing,The following statement contains a magic number: pos += 3;
Magic Number,Custom.Decompiler.ILAst,ILAstOptimizer,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,HandleStringFixing,The following statement contains a magic number: body[pos + 2].Match(ILCode.Stloc' out pointerVar' out assignedExpr) && assignedExpr.MatchLdloc(var2)
Magic Number,Custom.Decompiler.ILAst,ILAstOptimizer,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,SimplifyShiftOperators,The following statement contains a magic number: switch (expr.InferredType.MetadataType) {  				case MetadataType.Int32:  					case MetadataType.UInt32: mask = 31; break;  				case MetadataType.Int64:  					case MetadataType.UInt64: mask = 63; break;  					default: return;  			}
Magic Number,Custom.Decompiler.ILAst,ILAstOptimizer,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,SimplifyShiftOperators,The following statement contains a magic number: switch (expr.InferredType.MetadataType) {  				case MetadataType.Int32:  					case MetadataType.UInt32: mask = 31; break;  				case MetadataType.Int64:  					case MetadataType.UInt64: mask = 63; break;  					default: return;  			}
Magic Number,Custom.Decompiler.ILAst,ILNode,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\ILAstTypes.cs,GetSelfAndChildrenRecursive,The following statement contains a magic number: List<T> result = new List<T>(16);
Magic Number,Custom.Decompiler.ILAst,ILCodeUtil,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\ILCodes.cs,ExpandMacro,The following statement contains a magic number: switch (code) {  					case ILCode.__Ldarg_0:   code = ILCode.__Ldarg; operand = methodBody.GetParameter(0); break;  					case ILCode.__Ldarg_1:   code = ILCode.__Ldarg; operand = methodBody.GetParameter(1); break;  					case ILCode.__Ldarg_2:   code = ILCode.__Ldarg; operand = methodBody.GetParameter(2); break;  					case ILCode.__Ldarg_3:   code = ILCode.__Ldarg; operand = methodBody.GetParameter(3); break;  					case ILCode.__Ldloc_0:   code = ILCode.Ldloc; operand = methodBody.Variables[0]; break;  					case ILCode.__Ldloc_1:   code = ILCode.Ldloc; operand = methodBody.Variables[1]; break;  					case ILCode.__Ldloc_2:   code = ILCode.Ldloc; operand = methodBody.Variables[2]; break;  					case ILCode.__Ldloc_3:   code = ILCode.Ldloc; operand = methodBody.Variables[3]; break;  					case ILCode.__Stloc_0:   code = ILCode.Stloc; operand = methodBody.Variables[0]; break;  					case ILCode.__Stloc_1:   code = ILCode.Stloc; operand = methodBody.Variables[1]; break;  					case ILCode.__Stloc_2:   code = ILCode.Stloc; operand = methodBody.Variables[2]; break;  					case ILCode.__Stloc_3:   code = ILCode.Stloc; operand = methodBody.Variables[3]; break;  					case ILCode.__Ldarg_S:   code = ILCode.__Ldarg; break;  					case ILCode.__Ldarga_S:  code = ILCode.__Ldarga; break;  					case ILCode.__Starg_S:   code = ILCode.__Starg; break;  					case ILCode.__Ldloc_S:   code = ILCode.Ldloc; break;  					case ILCode.__Ldloca_S:  code = ILCode.Ldloca; break;  					case ILCode.__Stloc_S:   code = ILCode.Stloc; break;  					case ILCode.__Ldc_I4_M1: code = ILCode.Ldc_I4; operand = -1; break;  					case ILCode.__Ldc_I4_0:  code = ILCode.Ldc_I4; operand = 0; break;  					case ILCode.__Ldc_I4_1:  code = ILCode.Ldc_I4; operand = 1; break;  					case ILCode.__Ldc_I4_2:  code = ILCode.Ldc_I4; operand = 2; break;  					case ILCode.__Ldc_I4_3:  code = ILCode.Ldc_I4; operand = 3; break;  					case ILCode.__Ldc_I4_4:  code = ILCode.Ldc_I4; operand = 4; break;  					case ILCode.__Ldc_I4_5:  code = ILCode.Ldc_I4; operand = 5; break;  					case ILCode.__Ldc_I4_6:  code = ILCode.Ldc_I4; operand = 6; break;  					case ILCode.__Ldc_I4_7:  code = ILCode.Ldc_I4; operand = 7; break;  					case ILCode.__Ldc_I4_8:  code = ILCode.Ldc_I4; operand = 8; break;  					case ILCode.__Ldc_I4_S:  code = ILCode.Ldc_I4; operand = (int) (sbyte) operand; break;  					case ILCode.__Br_S:      code = ILCode.Br; break;  					case ILCode.__Brfalse_S: code = ILCode.__Brfalse; break;  					case ILCode.__Brtrue_S:  code = ILCode.Brtrue; break;  					case ILCode.__Beq_S:     code = ILCode.__Beq; break;  					case ILCode.__Bge_S:     code = ILCode.__Bge; break;  					case ILCode.__Bgt_S:     code = ILCode.__Bgt; break;  					case ILCode.__Ble_S:     code = ILCode.__Ble; break;  					case ILCode.__Blt_S:     code = ILCode.__Blt; break;  					case ILCode.__Bne_Un_S:  code = ILCode.__Bne_Un; break;  					case ILCode.__Bge_Un_S:  code = ILCode.__Bge_Un; break;  					case ILCode.__Bgt_Un_S:  code = ILCode.__Bgt_Un; break;  					case ILCode.__Ble_Un_S:  code = ILCode.__Ble_Un; break;  					case ILCode.__Blt_Un_S:  code = ILCode.__Blt_Un; break;  					case ILCode.__Leave_S:   code = ILCode.Leave; break;  					case ILCode.__Ldind_I:   code = ILCode.Ldobj; operand = methodBody.Method.Module.TypeSystem.IntPtr; break;  					case ILCode.__Ldind_I1:  code = ILCode.Ldobj; operand = methodBody.Method.Module.TypeSystem.SByte; break;  					case ILCode.__Ldind_I2:  code = ILCode.Ldobj; operand = methodBody.Method.Module.TypeSystem.Int16; break;  					case ILCode.__Ldind_I4:  code = ILCode.Ldobj; operand = methodBody.Method.Module.TypeSystem.Int32; break;  					case ILCode.__Ldind_I8:  code = ILCode.Ldobj; operand = methodBody.Method.Module.TypeSystem.Int64; break;  					case ILCode.__Ldind_U1:  code = ILCode.Ldobj; operand = methodBody.Method.Module.TypeSystem.Byte; break;  					case ILCode.__Ldind_U2:  code = ILCode.Ldobj; operand = methodBody.Method.Module.TypeSystem.UInt16; break;  					case ILCode.__Ldind_U4:  code = ILCode.Ldobj; operand = methodBody.Method.Module.TypeSystem.UInt32; break;  					case ILCode.__Ldind_R4:  code = ILCode.Ldobj; operand = methodBody.Method.Module.TypeSystem.Single; break;  					case ILCode.__Ldind_R8:  code = ILCode.Ldobj; operand = methodBody.Method.Module.TypeSystem.Double; break;  					case ILCode.__Stind_I:   code = ILCode.Stobj; operand = methodBody.Method.Module.TypeSystem.IntPtr; break;  					case ILCode.__Stind_I1:  code = ILCode.Stobj; operand = methodBody.Method.Module.TypeSystem.Byte; break;  					case ILCode.__Stind_I2:  code = ILCode.Stobj; operand = methodBody.Method.Module.TypeSystem.Int16; break;  					case ILCode.__Stind_I4:  code = ILCode.Stobj; operand = methodBody.Method.Module.TypeSystem.Int32; break;  					case ILCode.__Stind_I8:  code = ILCode.Stobj; operand = methodBody.Method.Module.TypeSystem.Int64; break;  					case ILCode.__Stind_R4:  code = ILCode.Stobj; operand = methodBody.Method.Module.TypeSystem.Single; break;  					case ILCode.__Stind_R8:  code = ILCode.Stobj; operand = methodBody.Method.Module.TypeSystem.Double; break;  			}
Magic Number,Custom.Decompiler.ILAst,ILCodeUtil,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\ILCodes.cs,ExpandMacro,The following statement contains a magic number: switch (code) {  					case ILCode.__Ldarg_0:   code = ILCode.__Ldarg; operand = methodBody.GetParameter(0); break;  					case ILCode.__Ldarg_1:   code = ILCode.__Ldarg; operand = methodBody.GetParameter(1); break;  					case ILCode.__Ldarg_2:   code = ILCode.__Ldarg; operand = methodBody.GetParameter(2); break;  					case ILCode.__Ldarg_3:   code = ILCode.__Ldarg; operand = methodBody.GetParameter(3); break;  					case ILCode.__Ldloc_0:   code = ILCode.Ldloc; operand = methodBody.Variables[0]; break;  					case ILCode.__Ldloc_1:   code = ILCode.Ldloc; operand = methodBody.Variables[1]; break;  					case ILCode.__Ldloc_2:   code = ILCode.Ldloc; operand = methodBody.Variables[2]; break;  					case ILCode.__Ldloc_3:   code = ILCode.Ldloc; operand = methodBody.Variables[3]; break;  					case ILCode.__Stloc_0:   code = ILCode.Stloc; operand = methodBody.Variables[0]; break;  					case ILCode.__Stloc_1:   code = ILCode.Stloc; operand = methodBody.Variables[1]; break;  					case ILCode.__Stloc_2:   code = ILCode.Stloc; operand = methodBody.Variables[2]; break;  					case ILCode.__Stloc_3:   code = ILCode.Stloc; operand = methodBody.Variables[3]; break;  					case ILCode.__Ldarg_S:   code = ILCode.__Ldarg; break;  					case ILCode.__Ldarga_S:  code = ILCode.__Ldarga; break;  					case ILCode.__Starg_S:   code = ILCode.__Starg; break;  					case ILCode.__Ldloc_S:   code = ILCode.Ldloc; break;  					case ILCode.__Ldloca_S:  code = ILCode.Ldloca; break;  					case ILCode.__Stloc_S:   code = ILCode.Stloc; break;  					case ILCode.__Ldc_I4_M1: code = ILCode.Ldc_I4; operand = -1; break;  					case ILCode.__Ldc_I4_0:  code = ILCode.Ldc_I4; operand = 0; break;  					case ILCode.__Ldc_I4_1:  code = ILCode.Ldc_I4; operand = 1; break;  					case ILCode.__Ldc_I4_2:  code = ILCode.Ldc_I4; operand = 2; break;  					case ILCode.__Ldc_I4_3:  code = ILCode.Ldc_I4; operand = 3; break;  					case ILCode.__Ldc_I4_4:  code = ILCode.Ldc_I4; operand = 4; break;  					case ILCode.__Ldc_I4_5:  code = ILCode.Ldc_I4; operand = 5; break;  					case ILCode.__Ldc_I4_6:  code = ILCode.Ldc_I4; operand = 6; break;  					case ILCode.__Ldc_I4_7:  code = ILCode.Ldc_I4; operand = 7; break;  					case ILCode.__Ldc_I4_8:  code = ILCode.Ldc_I4; operand = 8; break;  					case ILCode.__Ldc_I4_S:  code = ILCode.Ldc_I4; operand = (int) (sbyte) operand; break;  					case ILCode.__Br_S:      code = ILCode.Br; break;  					case ILCode.__Brfalse_S: code = ILCode.__Brfalse; break;  					case ILCode.__Brtrue_S:  code = ILCode.Brtrue; break;  					case ILCode.__Beq_S:     code = ILCode.__Beq; break;  					case ILCode.__Bge_S:     code = ILCode.__Bge; break;  					case ILCode.__Bgt_S:     code = ILCode.__Bgt; break;  					case ILCode.__Ble_S:     code = ILCode.__Ble; break;  					case ILCode.__Blt_S:     code = ILCode.__Blt; break;  					case ILCode.__Bne_Un_S:  code = ILCode.__Bne_Un; break;  					case ILCode.__Bge_Un_S:  code = ILCode.__Bge_Un; break;  					case ILCode.__Bgt_Un_S:  code = ILCode.__Bgt_Un; break;  					case ILCode.__Ble_Un_S:  code = ILCode.__Ble_Un; break;  					case ILCode.__Blt_Un_S:  code = ILCode.__Blt_Un; break;  					case ILCode.__Leave_S:   code = ILCode.Leave; break;  					case ILCode.__Ldind_I:   code = ILCode.Ldobj; operand = methodBody.Method.Module.TypeSystem.IntPtr; break;  					case ILCode.__Ldind_I1:  code = ILCode.Ldobj; operand = methodBody.Method.Module.TypeSystem.SByte; break;  					case ILCode.__Ldind_I2:  code = ILCode.Ldobj; operand = methodBody.Method.Module.TypeSystem.Int16; break;  					case ILCode.__Ldind_I4:  code = ILCode.Ldobj; operand = methodBody.Method.Module.TypeSystem.Int32; break;  					case ILCode.__Ldind_I8:  code = ILCode.Ldobj; operand = methodBody.Method.Module.TypeSystem.Int64; break;  					case ILCode.__Ldind_U1:  code = ILCode.Ldobj; operand = methodBody.Method.Module.TypeSystem.Byte; break;  					case ILCode.__Ldind_U2:  code = ILCode.Ldobj; operand = methodBody.Method.Module.TypeSystem.UInt16; break;  					case ILCode.__Ldind_U4:  code = ILCode.Ldobj; operand = methodBody.Method.Module.TypeSystem.UInt32; break;  					case ILCode.__Ldind_R4:  code = ILCode.Ldobj; operand = methodBody.Method.Module.TypeSystem.Single; break;  					case ILCode.__Ldind_R8:  code = ILCode.Ldobj; operand = methodBody.Method.Module.TypeSystem.Double; break;  					case ILCode.__Stind_I:   code = ILCode.Stobj; operand = methodBody.Method.Module.TypeSystem.IntPtr; break;  					case ILCode.__Stind_I1:  code = ILCode.Stobj; operand = methodBody.Method.Module.TypeSystem.Byte; break;  					case ILCode.__Stind_I2:  code = ILCode.Stobj; operand = methodBody.Method.Module.TypeSystem.Int16; break;  					case ILCode.__Stind_I4:  code = ILCode.Stobj; operand = methodBody.Method.Module.TypeSystem.Int32; break;  					case ILCode.__Stind_I8:  code = ILCode.Stobj; operand = methodBody.Method.Module.TypeSystem.Int64; break;  					case ILCode.__Stind_R4:  code = ILCode.Stobj; operand = methodBody.Method.Module.TypeSystem.Single; break;  					case ILCode.__Stind_R8:  code = ILCode.Stobj; operand = methodBody.Method.Module.TypeSystem.Double; break;  			}
Magic Number,Custom.Decompiler.ILAst,ILCodeUtil,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\ILCodes.cs,ExpandMacro,The following statement contains a magic number: switch (code) {  					case ILCode.__Ldarg_0:   code = ILCode.__Ldarg; operand = methodBody.GetParameter(0); break;  					case ILCode.__Ldarg_1:   code = ILCode.__Ldarg; operand = methodBody.GetParameter(1); break;  					case ILCode.__Ldarg_2:   code = ILCode.__Ldarg; operand = methodBody.GetParameter(2); break;  					case ILCode.__Ldarg_3:   code = ILCode.__Ldarg; operand = methodBody.GetParameter(3); break;  					case ILCode.__Ldloc_0:   code = ILCode.Ldloc; operand = methodBody.Variables[0]; break;  					case ILCode.__Ldloc_1:   code = ILCode.Ldloc; operand = methodBody.Variables[1]; break;  					case ILCode.__Ldloc_2:   code = ILCode.Ldloc; operand = methodBody.Variables[2]; break;  					case ILCode.__Ldloc_3:   code = ILCode.Ldloc; operand = methodBody.Variables[3]; break;  					case ILCode.__Stloc_0:   code = ILCode.Stloc; operand = methodBody.Variables[0]; break;  					case ILCode.__Stloc_1:   code = ILCode.Stloc; operand = methodBody.Variables[1]; break;  					case ILCode.__Stloc_2:   code = ILCode.Stloc; operand = methodBody.Variables[2]; break;  					case ILCode.__Stloc_3:   code = ILCode.Stloc; operand = methodBody.Variables[3]; break;  					case ILCode.__Ldarg_S:   code = ILCode.__Ldarg; break;  					case ILCode.__Ldarga_S:  code = ILCode.__Ldarga; break;  					case ILCode.__Starg_S:   code = ILCode.__Starg; break;  					case ILCode.__Ldloc_S:   code = ILCode.Ldloc; break;  					case ILCode.__Ldloca_S:  code = ILCode.Ldloca; break;  					case ILCode.__Stloc_S:   code = ILCode.Stloc; break;  					case ILCode.__Ldc_I4_M1: code = ILCode.Ldc_I4; operand = -1; break;  					case ILCode.__Ldc_I4_0:  code = ILCode.Ldc_I4; operand = 0; break;  					case ILCode.__Ldc_I4_1:  code = ILCode.Ldc_I4; operand = 1; break;  					case ILCode.__Ldc_I4_2:  code = ILCode.Ldc_I4; operand = 2; break;  					case ILCode.__Ldc_I4_3:  code = ILCode.Ldc_I4; operand = 3; break;  					case ILCode.__Ldc_I4_4:  code = ILCode.Ldc_I4; operand = 4; break;  					case ILCode.__Ldc_I4_5:  code = ILCode.Ldc_I4; operand = 5; break;  					case ILCode.__Ldc_I4_6:  code = ILCode.Ldc_I4; operand = 6; break;  					case ILCode.__Ldc_I4_7:  code = ILCode.Ldc_I4; operand = 7; break;  					case ILCode.__Ldc_I4_8:  code = ILCode.Ldc_I4; operand = 8; break;  					case ILCode.__Ldc_I4_S:  code = ILCode.Ldc_I4; operand = (int) (sbyte) operand; break;  					case ILCode.__Br_S:      code = ILCode.Br; break;  					case ILCode.__Brfalse_S: code = ILCode.__Brfalse; break;  					case ILCode.__Brtrue_S:  code = ILCode.Brtrue; break;  					case ILCode.__Beq_S:     code = ILCode.__Beq; break;  					case ILCode.__Bge_S:     code = ILCode.__Bge; break;  					case ILCode.__Bgt_S:     code = ILCode.__Bgt; break;  					case ILCode.__Ble_S:     code = ILCode.__Ble; break;  					case ILCode.__Blt_S:     code = ILCode.__Blt; break;  					case ILCode.__Bne_Un_S:  code = ILCode.__Bne_Un; break;  					case ILCode.__Bge_Un_S:  code = ILCode.__Bge_Un; break;  					case ILCode.__Bgt_Un_S:  code = ILCode.__Bgt_Un; break;  					case ILCode.__Ble_Un_S:  code = ILCode.__Ble_Un; break;  					case ILCode.__Blt_Un_S:  code = ILCode.__Blt_Un; break;  					case ILCode.__Leave_S:   code = ILCode.Leave; break;  					case ILCode.__Ldind_I:   code = ILCode.Ldobj; operand = methodBody.Method.Module.TypeSystem.IntPtr; break;  					case ILCode.__Ldind_I1:  code = ILCode.Ldobj; operand = methodBody.Method.Module.TypeSystem.SByte; break;  					case ILCode.__Ldind_I2:  code = ILCode.Ldobj; operand = methodBody.Method.Module.TypeSystem.Int16; break;  					case ILCode.__Ldind_I4:  code = ILCode.Ldobj; operand = methodBody.Method.Module.TypeSystem.Int32; break;  					case ILCode.__Ldind_I8:  code = ILCode.Ldobj; operand = methodBody.Method.Module.TypeSystem.Int64; break;  					case ILCode.__Ldind_U1:  code = ILCode.Ldobj; operand = methodBody.Method.Module.TypeSystem.Byte; break;  					case ILCode.__Ldind_U2:  code = ILCode.Ldobj; operand = methodBody.Method.Module.TypeSystem.UInt16; break;  					case ILCode.__Ldind_U4:  code = ILCode.Ldobj; operand = methodBody.Method.Module.TypeSystem.UInt32; break;  					case ILCode.__Ldind_R4:  code = ILCode.Ldobj; operand = methodBody.Method.Module.TypeSystem.Single; break;  					case ILCode.__Ldind_R8:  code = ILCode.Ldobj; operand = methodBody.Method.Module.TypeSystem.Double; break;  					case ILCode.__Stind_I:   code = ILCode.Stobj; operand = methodBody.Method.Module.TypeSystem.IntPtr; break;  					case ILCode.__Stind_I1:  code = ILCode.Stobj; operand = methodBody.Method.Module.TypeSystem.Byte; break;  					case ILCode.__Stind_I2:  code = ILCode.Stobj; operand = methodBody.Method.Module.TypeSystem.Int16; break;  					case ILCode.__Stind_I4:  code = ILCode.Stobj; operand = methodBody.Method.Module.TypeSystem.Int32; break;  					case ILCode.__Stind_I8:  code = ILCode.Stobj; operand = methodBody.Method.Module.TypeSystem.Int64; break;  					case ILCode.__Stind_R4:  code = ILCode.Stobj; operand = methodBody.Method.Module.TypeSystem.Single; break;  					case ILCode.__Stind_R8:  code = ILCode.Stobj; operand = methodBody.Method.Module.TypeSystem.Double; break;  			}
Magic Number,Custom.Decompiler.ILAst,ILCodeUtil,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\ILCodes.cs,ExpandMacro,The following statement contains a magic number: switch (code) {  					case ILCode.__Ldarg_0:   code = ILCode.__Ldarg; operand = methodBody.GetParameter(0); break;  					case ILCode.__Ldarg_1:   code = ILCode.__Ldarg; operand = methodBody.GetParameter(1); break;  					case ILCode.__Ldarg_2:   code = ILCode.__Ldarg; operand = methodBody.GetParameter(2); break;  					case ILCode.__Ldarg_3:   code = ILCode.__Ldarg; operand = methodBody.GetParameter(3); break;  					case ILCode.__Ldloc_0:   code = ILCode.Ldloc; operand = methodBody.Variables[0]; break;  					case ILCode.__Ldloc_1:   code = ILCode.Ldloc; operand = methodBody.Variables[1]; break;  					case ILCode.__Ldloc_2:   code = ILCode.Ldloc; operand = methodBody.Variables[2]; break;  					case ILCode.__Ldloc_3:   code = ILCode.Ldloc; operand = methodBody.Variables[3]; break;  					case ILCode.__Stloc_0:   code = ILCode.Stloc; operand = methodBody.Variables[0]; break;  					case ILCode.__Stloc_1:   code = ILCode.Stloc; operand = methodBody.Variables[1]; break;  					case ILCode.__Stloc_2:   code = ILCode.Stloc; operand = methodBody.Variables[2]; break;  					case ILCode.__Stloc_3:   code = ILCode.Stloc; operand = methodBody.Variables[3]; break;  					case ILCode.__Ldarg_S:   code = ILCode.__Ldarg; break;  					case ILCode.__Ldarga_S:  code = ILCode.__Ldarga; break;  					case ILCode.__Starg_S:   code = ILCode.__Starg; break;  					case ILCode.__Ldloc_S:   code = ILCode.Ldloc; break;  					case ILCode.__Ldloca_S:  code = ILCode.Ldloca; break;  					case ILCode.__Stloc_S:   code = ILCode.Stloc; break;  					case ILCode.__Ldc_I4_M1: code = ILCode.Ldc_I4; operand = -1; break;  					case ILCode.__Ldc_I4_0:  code = ILCode.Ldc_I4; operand = 0; break;  					case ILCode.__Ldc_I4_1:  code = ILCode.Ldc_I4; operand = 1; break;  					case ILCode.__Ldc_I4_2:  code = ILCode.Ldc_I4; operand = 2; break;  					case ILCode.__Ldc_I4_3:  code = ILCode.Ldc_I4; operand = 3; break;  					case ILCode.__Ldc_I4_4:  code = ILCode.Ldc_I4; operand = 4; break;  					case ILCode.__Ldc_I4_5:  code = ILCode.Ldc_I4; operand = 5; break;  					case ILCode.__Ldc_I4_6:  code = ILCode.Ldc_I4; operand = 6; break;  					case ILCode.__Ldc_I4_7:  code = ILCode.Ldc_I4; operand = 7; break;  					case ILCode.__Ldc_I4_8:  code = ILCode.Ldc_I4; operand = 8; break;  					case ILCode.__Ldc_I4_S:  code = ILCode.Ldc_I4; operand = (int) (sbyte) operand; break;  					case ILCode.__Br_S:      code = ILCode.Br; break;  					case ILCode.__Brfalse_S: code = ILCode.__Brfalse; break;  					case ILCode.__Brtrue_S:  code = ILCode.Brtrue; break;  					case ILCode.__Beq_S:     code = ILCode.__Beq; break;  					case ILCode.__Bge_S:     code = ILCode.__Bge; break;  					case ILCode.__Bgt_S:     code = ILCode.__Bgt; break;  					case ILCode.__Ble_S:     code = ILCode.__Ble; break;  					case ILCode.__Blt_S:     code = ILCode.__Blt; break;  					case ILCode.__Bne_Un_S:  code = ILCode.__Bne_Un; break;  					case ILCode.__Bge_Un_S:  code = ILCode.__Bge_Un; break;  					case ILCode.__Bgt_Un_S:  code = ILCode.__Bgt_Un; break;  					case ILCode.__Ble_Un_S:  code = ILCode.__Ble_Un; break;  					case ILCode.__Blt_Un_S:  code = ILCode.__Blt_Un; break;  					case ILCode.__Leave_S:   code = ILCode.Leave; break;  					case ILCode.__Ldind_I:   code = ILCode.Ldobj; operand = methodBody.Method.Module.TypeSystem.IntPtr; break;  					case ILCode.__Ldind_I1:  code = ILCode.Ldobj; operand = methodBody.Method.Module.TypeSystem.SByte; break;  					case ILCode.__Ldind_I2:  code = ILCode.Ldobj; operand = methodBody.Method.Module.TypeSystem.Int16; break;  					case ILCode.__Ldind_I4:  code = ILCode.Ldobj; operand = methodBody.Method.Module.TypeSystem.Int32; break;  					case ILCode.__Ldind_I8:  code = ILCode.Ldobj; operand = methodBody.Method.Module.TypeSystem.Int64; break;  					case ILCode.__Ldind_U1:  code = ILCode.Ldobj; operand = methodBody.Method.Module.TypeSystem.Byte; break;  					case ILCode.__Ldind_U2:  code = ILCode.Ldobj; operand = methodBody.Method.Module.TypeSystem.UInt16; break;  					case ILCode.__Ldind_U4:  code = ILCode.Ldobj; operand = methodBody.Method.Module.TypeSystem.UInt32; break;  					case ILCode.__Ldind_R4:  code = ILCode.Ldobj; operand = methodBody.Method.Module.TypeSystem.Single; break;  					case ILCode.__Ldind_R8:  code = ILCode.Ldobj; operand = methodBody.Method.Module.TypeSystem.Double; break;  					case ILCode.__Stind_I:   code = ILCode.Stobj; operand = methodBody.Method.Module.TypeSystem.IntPtr; break;  					case ILCode.__Stind_I1:  code = ILCode.Stobj; operand = methodBody.Method.Module.TypeSystem.Byte; break;  					case ILCode.__Stind_I2:  code = ILCode.Stobj; operand = methodBody.Method.Module.TypeSystem.Int16; break;  					case ILCode.__Stind_I4:  code = ILCode.Stobj; operand = methodBody.Method.Module.TypeSystem.Int32; break;  					case ILCode.__Stind_I8:  code = ILCode.Stobj; operand = methodBody.Method.Module.TypeSystem.Int64; break;  					case ILCode.__Stind_R4:  code = ILCode.Stobj; operand = methodBody.Method.Module.TypeSystem.Single; break;  					case ILCode.__Stind_R8:  code = ILCode.Stobj; operand = methodBody.Method.Module.TypeSystem.Double; break;  			}
Magic Number,Custom.Decompiler.ILAst,ILCodeUtil,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\ILCodes.cs,ExpandMacro,The following statement contains a magic number: switch (code) {  					case ILCode.__Ldarg_0:   code = ILCode.__Ldarg; operand = methodBody.GetParameter(0); break;  					case ILCode.__Ldarg_1:   code = ILCode.__Ldarg; operand = methodBody.GetParameter(1); break;  					case ILCode.__Ldarg_2:   code = ILCode.__Ldarg; operand = methodBody.GetParameter(2); break;  					case ILCode.__Ldarg_3:   code = ILCode.__Ldarg; operand = methodBody.GetParameter(3); break;  					case ILCode.__Ldloc_0:   code = ILCode.Ldloc; operand = methodBody.Variables[0]; break;  					case ILCode.__Ldloc_1:   code = ILCode.Ldloc; operand = methodBody.Variables[1]; break;  					case ILCode.__Ldloc_2:   code = ILCode.Ldloc; operand = methodBody.Variables[2]; break;  					case ILCode.__Ldloc_3:   code = ILCode.Ldloc; operand = methodBody.Variables[3]; break;  					case ILCode.__Stloc_0:   code = ILCode.Stloc; operand = methodBody.Variables[0]; break;  					case ILCode.__Stloc_1:   code = ILCode.Stloc; operand = methodBody.Variables[1]; break;  					case ILCode.__Stloc_2:   code = ILCode.Stloc; operand = methodBody.Variables[2]; break;  					case ILCode.__Stloc_3:   code = ILCode.Stloc; operand = methodBody.Variables[3]; break;  					case ILCode.__Ldarg_S:   code = ILCode.__Ldarg; break;  					case ILCode.__Ldarga_S:  code = ILCode.__Ldarga; break;  					case ILCode.__Starg_S:   code = ILCode.__Starg; break;  					case ILCode.__Ldloc_S:   code = ILCode.Ldloc; break;  					case ILCode.__Ldloca_S:  code = ILCode.Ldloca; break;  					case ILCode.__Stloc_S:   code = ILCode.Stloc; break;  					case ILCode.__Ldc_I4_M1: code = ILCode.Ldc_I4; operand = -1; break;  					case ILCode.__Ldc_I4_0:  code = ILCode.Ldc_I4; operand = 0; break;  					case ILCode.__Ldc_I4_1:  code = ILCode.Ldc_I4; operand = 1; break;  					case ILCode.__Ldc_I4_2:  code = ILCode.Ldc_I4; operand = 2; break;  					case ILCode.__Ldc_I4_3:  code = ILCode.Ldc_I4; operand = 3; break;  					case ILCode.__Ldc_I4_4:  code = ILCode.Ldc_I4; operand = 4; break;  					case ILCode.__Ldc_I4_5:  code = ILCode.Ldc_I4; operand = 5; break;  					case ILCode.__Ldc_I4_6:  code = ILCode.Ldc_I4; operand = 6; break;  					case ILCode.__Ldc_I4_7:  code = ILCode.Ldc_I4; operand = 7; break;  					case ILCode.__Ldc_I4_8:  code = ILCode.Ldc_I4; operand = 8; break;  					case ILCode.__Ldc_I4_S:  code = ILCode.Ldc_I4; operand = (int) (sbyte) operand; break;  					case ILCode.__Br_S:      code = ILCode.Br; break;  					case ILCode.__Brfalse_S: code = ILCode.__Brfalse; break;  					case ILCode.__Brtrue_S:  code = ILCode.Brtrue; break;  					case ILCode.__Beq_S:     code = ILCode.__Beq; break;  					case ILCode.__Bge_S:     code = ILCode.__Bge; break;  					case ILCode.__Bgt_S:     code = ILCode.__Bgt; break;  					case ILCode.__Ble_S:     code = ILCode.__Ble; break;  					case ILCode.__Blt_S:     code = ILCode.__Blt; break;  					case ILCode.__Bne_Un_S:  code = ILCode.__Bne_Un; break;  					case ILCode.__Bge_Un_S:  code = ILCode.__Bge_Un; break;  					case ILCode.__Bgt_Un_S:  code = ILCode.__Bgt_Un; break;  					case ILCode.__Ble_Un_S:  code = ILCode.__Ble_Un; break;  					case ILCode.__Blt_Un_S:  code = ILCode.__Blt_Un; break;  					case ILCode.__Leave_S:   code = ILCode.Leave; break;  					case ILCode.__Ldind_I:   code = ILCode.Ldobj; operand = methodBody.Method.Module.TypeSystem.IntPtr; break;  					case ILCode.__Ldind_I1:  code = ILCode.Ldobj; operand = methodBody.Method.Module.TypeSystem.SByte; break;  					case ILCode.__Ldind_I2:  code = ILCode.Ldobj; operand = methodBody.Method.Module.TypeSystem.Int16; break;  					case ILCode.__Ldind_I4:  code = ILCode.Ldobj; operand = methodBody.Method.Module.TypeSystem.Int32; break;  					case ILCode.__Ldind_I8:  code = ILCode.Ldobj; operand = methodBody.Method.Module.TypeSystem.Int64; break;  					case ILCode.__Ldind_U1:  code = ILCode.Ldobj; operand = methodBody.Method.Module.TypeSystem.Byte; break;  					case ILCode.__Ldind_U2:  code = ILCode.Ldobj; operand = methodBody.Method.Module.TypeSystem.UInt16; break;  					case ILCode.__Ldind_U4:  code = ILCode.Ldobj; operand = methodBody.Method.Module.TypeSystem.UInt32; break;  					case ILCode.__Ldind_R4:  code = ILCode.Ldobj; operand = methodBody.Method.Module.TypeSystem.Single; break;  					case ILCode.__Ldind_R8:  code = ILCode.Ldobj; operand = methodBody.Method.Module.TypeSystem.Double; break;  					case ILCode.__Stind_I:   code = ILCode.Stobj; operand = methodBody.Method.Module.TypeSystem.IntPtr; break;  					case ILCode.__Stind_I1:  code = ILCode.Stobj; operand = methodBody.Method.Module.TypeSystem.Byte; break;  					case ILCode.__Stind_I2:  code = ILCode.Stobj; operand = methodBody.Method.Module.TypeSystem.Int16; break;  					case ILCode.__Stind_I4:  code = ILCode.Stobj; operand = methodBody.Method.Module.TypeSystem.Int32; break;  					case ILCode.__Stind_I8:  code = ILCode.Stobj; operand = methodBody.Method.Module.TypeSystem.Int64; break;  					case ILCode.__Stind_R4:  code = ILCode.Stobj; operand = methodBody.Method.Module.TypeSystem.Single; break;  					case ILCode.__Stind_R8:  code = ILCode.Stobj; operand = methodBody.Method.Module.TypeSystem.Double; break;  			}
Magic Number,Custom.Decompiler.ILAst,ILCodeUtil,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\ILCodes.cs,ExpandMacro,The following statement contains a magic number: switch (code) {  					case ILCode.__Ldarg_0:   code = ILCode.__Ldarg; operand = methodBody.GetParameter(0); break;  					case ILCode.__Ldarg_1:   code = ILCode.__Ldarg; operand = methodBody.GetParameter(1); break;  					case ILCode.__Ldarg_2:   code = ILCode.__Ldarg; operand = methodBody.GetParameter(2); break;  					case ILCode.__Ldarg_3:   code = ILCode.__Ldarg; operand = methodBody.GetParameter(3); break;  					case ILCode.__Ldloc_0:   code = ILCode.Ldloc; operand = methodBody.Variables[0]; break;  					case ILCode.__Ldloc_1:   code = ILCode.Ldloc; operand = methodBody.Variables[1]; break;  					case ILCode.__Ldloc_2:   code = ILCode.Ldloc; operand = methodBody.Variables[2]; break;  					case ILCode.__Ldloc_3:   code = ILCode.Ldloc; operand = methodBody.Variables[3]; break;  					case ILCode.__Stloc_0:   code = ILCode.Stloc; operand = methodBody.Variables[0]; break;  					case ILCode.__Stloc_1:   code = ILCode.Stloc; operand = methodBody.Variables[1]; break;  					case ILCode.__Stloc_2:   code = ILCode.Stloc; operand = methodBody.Variables[2]; break;  					case ILCode.__Stloc_3:   code = ILCode.Stloc; operand = methodBody.Variables[3]; break;  					case ILCode.__Ldarg_S:   code = ILCode.__Ldarg; break;  					case ILCode.__Ldarga_S:  code = ILCode.__Ldarga; break;  					case ILCode.__Starg_S:   code = ILCode.__Starg; break;  					case ILCode.__Ldloc_S:   code = ILCode.Ldloc; break;  					case ILCode.__Ldloca_S:  code = ILCode.Ldloca; break;  					case ILCode.__Stloc_S:   code = ILCode.Stloc; break;  					case ILCode.__Ldc_I4_M1: code = ILCode.Ldc_I4; operand = -1; break;  					case ILCode.__Ldc_I4_0:  code = ILCode.Ldc_I4; operand = 0; break;  					case ILCode.__Ldc_I4_1:  code = ILCode.Ldc_I4; operand = 1; break;  					case ILCode.__Ldc_I4_2:  code = ILCode.Ldc_I4; operand = 2; break;  					case ILCode.__Ldc_I4_3:  code = ILCode.Ldc_I4; operand = 3; break;  					case ILCode.__Ldc_I4_4:  code = ILCode.Ldc_I4; operand = 4; break;  					case ILCode.__Ldc_I4_5:  code = ILCode.Ldc_I4; operand = 5; break;  					case ILCode.__Ldc_I4_6:  code = ILCode.Ldc_I4; operand = 6; break;  					case ILCode.__Ldc_I4_7:  code = ILCode.Ldc_I4; operand = 7; break;  					case ILCode.__Ldc_I4_8:  code = ILCode.Ldc_I4; operand = 8; break;  					case ILCode.__Ldc_I4_S:  code = ILCode.Ldc_I4; operand = (int) (sbyte) operand; break;  					case ILCode.__Br_S:      code = ILCode.Br; break;  					case ILCode.__Brfalse_S: code = ILCode.__Brfalse; break;  					case ILCode.__Brtrue_S:  code = ILCode.Brtrue; break;  					case ILCode.__Beq_S:     code = ILCode.__Beq; break;  					case ILCode.__Bge_S:     code = ILCode.__Bge; break;  					case ILCode.__Bgt_S:     code = ILCode.__Bgt; break;  					case ILCode.__Ble_S:     code = ILCode.__Ble; break;  					case ILCode.__Blt_S:     code = ILCode.__Blt; break;  					case ILCode.__Bne_Un_S:  code = ILCode.__Bne_Un; break;  					case ILCode.__Bge_Un_S:  code = ILCode.__Bge_Un; break;  					case ILCode.__Bgt_Un_S:  code = ILCode.__Bgt_Un; break;  					case ILCode.__Ble_Un_S:  code = ILCode.__Ble_Un; break;  					case ILCode.__Blt_Un_S:  code = ILCode.__Blt_Un; break;  					case ILCode.__Leave_S:   code = ILCode.Leave; break;  					case ILCode.__Ldind_I:   code = ILCode.Ldobj; operand = methodBody.Method.Module.TypeSystem.IntPtr; break;  					case ILCode.__Ldind_I1:  code = ILCode.Ldobj; operand = methodBody.Method.Module.TypeSystem.SByte; break;  					case ILCode.__Ldind_I2:  code = ILCode.Ldobj; operand = methodBody.Method.Module.TypeSystem.Int16; break;  					case ILCode.__Ldind_I4:  code = ILCode.Ldobj; operand = methodBody.Method.Module.TypeSystem.Int32; break;  					case ILCode.__Ldind_I8:  code = ILCode.Ldobj; operand = methodBody.Method.Module.TypeSystem.Int64; break;  					case ILCode.__Ldind_U1:  code = ILCode.Ldobj; operand = methodBody.Method.Module.TypeSystem.Byte; break;  					case ILCode.__Ldind_U2:  code = ILCode.Ldobj; operand = methodBody.Method.Module.TypeSystem.UInt16; break;  					case ILCode.__Ldind_U4:  code = ILCode.Ldobj; operand = methodBody.Method.Module.TypeSystem.UInt32; break;  					case ILCode.__Ldind_R4:  code = ILCode.Ldobj; operand = methodBody.Method.Module.TypeSystem.Single; break;  					case ILCode.__Ldind_R8:  code = ILCode.Ldobj; operand = methodBody.Method.Module.TypeSystem.Double; break;  					case ILCode.__Stind_I:   code = ILCode.Stobj; operand = methodBody.Method.Module.TypeSystem.IntPtr; break;  					case ILCode.__Stind_I1:  code = ILCode.Stobj; operand = methodBody.Method.Module.TypeSystem.Byte; break;  					case ILCode.__Stind_I2:  code = ILCode.Stobj; operand = methodBody.Method.Module.TypeSystem.Int16; break;  					case ILCode.__Stind_I4:  code = ILCode.Stobj; operand = methodBody.Method.Module.TypeSystem.Int32; break;  					case ILCode.__Stind_I8:  code = ILCode.Stobj; operand = methodBody.Method.Module.TypeSystem.Int64; break;  					case ILCode.__Stind_R4:  code = ILCode.Stobj; operand = methodBody.Method.Module.TypeSystem.Single; break;  					case ILCode.__Stind_R8:  code = ILCode.Stobj; operand = methodBody.Method.Module.TypeSystem.Double; break;  			}
Magic Number,Custom.Decompiler.ILAst,ILCodeUtil,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\ILCodes.cs,ExpandMacro,The following statement contains a magic number: switch (code) {  					case ILCode.__Ldarg_0:   code = ILCode.__Ldarg; operand = methodBody.GetParameter(0); break;  					case ILCode.__Ldarg_1:   code = ILCode.__Ldarg; operand = methodBody.GetParameter(1); break;  					case ILCode.__Ldarg_2:   code = ILCode.__Ldarg; operand = methodBody.GetParameter(2); break;  					case ILCode.__Ldarg_3:   code = ILCode.__Ldarg; operand = methodBody.GetParameter(3); break;  					case ILCode.__Ldloc_0:   code = ILCode.Ldloc; operand = methodBody.Variables[0]; break;  					case ILCode.__Ldloc_1:   code = ILCode.Ldloc; operand = methodBody.Variables[1]; break;  					case ILCode.__Ldloc_2:   code = ILCode.Ldloc; operand = methodBody.Variables[2]; break;  					case ILCode.__Ldloc_3:   code = ILCode.Ldloc; operand = methodBody.Variables[3]; break;  					case ILCode.__Stloc_0:   code = ILCode.Stloc; operand = methodBody.Variables[0]; break;  					case ILCode.__Stloc_1:   code = ILCode.Stloc; operand = methodBody.Variables[1]; break;  					case ILCode.__Stloc_2:   code = ILCode.Stloc; operand = methodBody.Variables[2]; break;  					case ILCode.__Stloc_3:   code = ILCode.Stloc; operand = methodBody.Variables[3]; break;  					case ILCode.__Ldarg_S:   code = ILCode.__Ldarg; break;  					case ILCode.__Ldarga_S:  code = ILCode.__Ldarga; break;  					case ILCode.__Starg_S:   code = ILCode.__Starg; break;  					case ILCode.__Ldloc_S:   code = ILCode.Ldloc; break;  					case ILCode.__Ldloca_S:  code = ILCode.Ldloca; break;  					case ILCode.__Stloc_S:   code = ILCode.Stloc; break;  					case ILCode.__Ldc_I4_M1: code = ILCode.Ldc_I4; operand = -1; break;  					case ILCode.__Ldc_I4_0:  code = ILCode.Ldc_I4; operand = 0; break;  					case ILCode.__Ldc_I4_1:  code = ILCode.Ldc_I4; operand = 1; break;  					case ILCode.__Ldc_I4_2:  code = ILCode.Ldc_I4; operand = 2; break;  					case ILCode.__Ldc_I4_3:  code = ILCode.Ldc_I4; operand = 3; break;  					case ILCode.__Ldc_I4_4:  code = ILCode.Ldc_I4; operand = 4; break;  					case ILCode.__Ldc_I4_5:  code = ILCode.Ldc_I4; operand = 5; break;  					case ILCode.__Ldc_I4_6:  code = ILCode.Ldc_I4; operand = 6; break;  					case ILCode.__Ldc_I4_7:  code = ILCode.Ldc_I4; operand = 7; break;  					case ILCode.__Ldc_I4_8:  code = ILCode.Ldc_I4; operand = 8; break;  					case ILCode.__Ldc_I4_S:  code = ILCode.Ldc_I4; operand = (int) (sbyte) operand; break;  					case ILCode.__Br_S:      code = ILCode.Br; break;  					case ILCode.__Brfalse_S: code = ILCode.__Brfalse; break;  					case ILCode.__Brtrue_S:  code = ILCode.Brtrue; break;  					case ILCode.__Beq_S:     code = ILCode.__Beq; break;  					case ILCode.__Bge_S:     code = ILCode.__Bge; break;  					case ILCode.__Bgt_S:     code = ILCode.__Bgt; break;  					case ILCode.__Ble_S:     code = ILCode.__Ble; break;  					case ILCode.__Blt_S:     code = ILCode.__Blt; break;  					case ILCode.__Bne_Un_S:  code = ILCode.__Bne_Un; break;  					case ILCode.__Bge_Un_S:  code = ILCode.__Bge_Un; break;  					case ILCode.__Bgt_Un_S:  code = ILCode.__Bgt_Un; break;  					case ILCode.__Ble_Un_S:  code = ILCode.__Ble_Un; break;  					case ILCode.__Blt_Un_S:  code = ILCode.__Blt_Un; break;  					case ILCode.__Leave_S:   code = ILCode.Leave; break;  					case ILCode.__Ldind_I:   code = ILCode.Ldobj; operand = methodBody.Method.Module.TypeSystem.IntPtr; break;  					case ILCode.__Ldind_I1:  code = ILCode.Ldobj; operand = methodBody.Method.Module.TypeSystem.SByte; break;  					case ILCode.__Ldind_I2:  code = ILCode.Ldobj; operand = methodBody.Method.Module.TypeSystem.Int16; break;  					case ILCode.__Ldind_I4:  code = ILCode.Ldobj; operand = methodBody.Method.Module.TypeSystem.Int32; break;  					case ILCode.__Ldind_I8:  code = ILCode.Ldobj; operand = methodBody.Method.Module.TypeSystem.Int64; break;  					case ILCode.__Ldind_U1:  code = ILCode.Ldobj; operand = methodBody.Method.Module.TypeSystem.Byte; break;  					case ILCode.__Ldind_U2:  code = ILCode.Ldobj; operand = methodBody.Method.Module.TypeSystem.UInt16; break;  					case ILCode.__Ldind_U4:  code = ILCode.Ldobj; operand = methodBody.Method.Module.TypeSystem.UInt32; break;  					case ILCode.__Ldind_R4:  code = ILCode.Ldobj; operand = methodBody.Method.Module.TypeSystem.Single; break;  					case ILCode.__Ldind_R8:  code = ILCode.Ldobj; operand = methodBody.Method.Module.TypeSystem.Double; break;  					case ILCode.__Stind_I:   code = ILCode.Stobj; operand = methodBody.Method.Module.TypeSystem.IntPtr; break;  					case ILCode.__Stind_I1:  code = ILCode.Stobj; operand = methodBody.Method.Module.TypeSystem.Byte; break;  					case ILCode.__Stind_I2:  code = ILCode.Stobj; operand = methodBody.Method.Module.TypeSystem.Int16; break;  					case ILCode.__Stind_I4:  code = ILCode.Stobj; operand = methodBody.Method.Module.TypeSystem.Int32; break;  					case ILCode.__Stind_I8:  code = ILCode.Stobj; operand = methodBody.Method.Module.TypeSystem.Int64; break;  					case ILCode.__Stind_R4:  code = ILCode.Stobj; operand = methodBody.Method.Module.TypeSystem.Single; break;  					case ILCode.__Stind_R8:  code = ILCode.Stobj; operand = methodBody.Method.Module.TypeSystem.Double; break;  			}
Magic Number,Custom.Decompiler.ILAst,ILCodeUtil,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\ILCodes.cs,ExpandMacro,The following statement contains a magic number: switch (code) {  					case ILCode.__Ldarg_0:   code = ILCode.__Ldarg; operand = methodBody.GetParameter(0); break;  					case ILCode.__Ldarg_1:   code = ILCode.__Ldarg; operand = methodBody.GetParameter(1); break;  					case ILCode.__Ldarg_2:   code = ILCode.__Ldarg; operand = methodBody.GetParameter(2); break;  					case ILCode.__Ldarg_3:   code = ILCode.__Ldarg; operand = methodBody.GetParameter(3); break;  					case ILCode.__Ldloc_0:   code = ILCode.Ldloc; operand = methodBody.Variables[0]; break;  					case ILCode.__Ldloc_1:   code = ILCode.Ldloc; operand = methodBody.Variables[1]; break;  					case ILCode.__Ldloc_2:   code = ILCode.Ldloc; operand = methodBody.Variables[2]; break;  					case ILCode.__Ldloc_3:   code = ILCode.Ldloc; operand = methodBody.Variables[3]; break;  					case ILCode.__Stloc_0:   code = ILCode.Stloc; operand = methodBody.Variables[0]; break;  					case ILCode.__Stloc_1:   code = ILCode.Stloc; operand = methodBody.Variables[1]; break;  					case ILCode.__Stloc_2:   code = ILCode.Stloc; operand = methodBody.Variables[2]; break;  					case ILCode.__Stloc_3:   code = ILCode.Stloc; operand = methodBody.Variables[3]; break;  					case ILCode.__Ldarg_S:   code = ILCode.__Ldarg; break;  					case ILCode.__Ldarga_S:  code = ILCode.__Ldarga; break;  					case ILCode.__Starg_S:   code = ILCode.__Starg; break;  					case ILCode.__Ldloc_S:   code = ILCode.Ldloc; break;  					case ILCode.__Ldloca_S:  code = ILCode.Ldloca; break;  					case ILCode.__Stloc_S:   code = ILCode.Stloc; break;  					case ILCode.__Ldc_I4_M1: code = ILCode.Ldc_I4; operand = -1; break;  					case ILCode.__Ldc_I4_0:  code = ILCode.Ldc_I4; operand = 0; break;  					case ILCode.__Ldc_I4_1:  code = ILCode.Ldc_I4; operand = 1; break;  					case ILCode.__Ldc_I4_2:  code = ILCode.Ldc_I4; operand = 2; break;  					case ILCode.__Ldc_I4_3:  code = ILCode.Ldc_I4; operand = 3; break;  					case ILCode.__Ldc_I4_4:  code = ILCode.Ldc_I4; operand = 4; break;  					case ILCode.__Ldc_I4_5:  code = ILCode.Ldc_I4; operand = 5; break;  					case ILCode.__Ldc_I4_6:  code = ILCode.Ldc_I4; operand = 6; break;  					case ILCode.__Ldc_I4_7:  code = ILCode.Ldc_I4; operand = 7; break;  					case ILCode.__Ldc_I4_8:  code = ILCode.Ldc_I4; operand = 8; break;  					case ILCode.__Ldc_I4_S:  code = ILCode.Ldc_I4; operand = (int) (sbyte) operand; break;  					case ILCode.__Br_S:      code = ILCode.Br; break;  					case ILCode.__Brfalse_S: code = ILCode.__Brfalse; break;  					case ILCode.__Brtrue_S:  code = ILCode.Brtrue; break;  					case ILCode.__Beq_S:     code = ILCode.__Beq; break;  					case ILCode.__Bge_S:     code = ILCode.__Bge; break;  					case ILCode.__Bgt_S:     code = ILCode.__Bgt; break;  					case ILCode.__Ble_S:     code = ILCode.__Ble; break;  					case ILCode.__Blt_S:     code = ILCode.__Blt; break;  					case ILCode.__Bne_Un_S:  code = ILCode.__Bne_Un; break;  					case ILCode.__Bge_Un_S:  code = ILCode.__Bge_Un; break;  					case ILCode.__Bgt_Un_S:  code = ILCode.__Bgt_Un; break;  					case ILCode.__Ble_Un_S:  code = ILCode.__Ble_Un; break;  					case ILCode.__Blt_Un_S:  code = ILCode.__Blt_Un; break;  					case ILCode.__Leave_S:   code = ILCode.Leave; break;  					case ILCode.__Ldind_I:   code = ILCode.Ldobj; operand = methodBody.Method.Module.TypeSystem.IntPtr; break;  					case ILCode.__Ldind_I1:  code = ILCode.Ldobj; operand = methodBody.Method.Module.TypeSystem.SByte; break;  					case ILCode.__Ldind_I2:  code = ILCode.Ldobj; operand = methodBody.Method.Module.TypeSystem.Int16; break;  					case ILCode.__Ldind_I4:  code = ILCode.Ldobj; operand = methodBody.Method.Module.TypeSystem.Int32; break;  					case ILCode.__Ldind_I8:  code = ILCode.Ldobj; operand = methodBody.Method.Module.TypeSystem.Int64; break;  					case ILCode.__Ldind_U1:  code = ILCode.Ldobj; operand = methodBody.Method.Module.TypeSystem.Byte; break;  					case ILCode.__Ldind_U2:  code = ILCode.Ldobj; operand = methodBody.Method.Module.TypeSystem.UInt16; break;  					case ILCode.__Ldind_U4:  code = ILCode.Ldobj; operand = methodBody.Method.Module.TypeSystem.UInt32; break;  					case ILCode.__Ldind_R4:  code = ILCode.Ldobj; operand = methodBody.Method.Module.TypeSystem.Single; break;  					case ILCode.__Ldind_R8:  code = ILCode.Ldobj; operand = methodBody.Method.Module.TypeSystem.Double; break;  					case ILCode.__Stind_I:   code = ILCode.Stobj; operand = methodBody.Method.Module.TypeSystem.IntPtr; break;  					case ILCode.__Stind_I1:  code = ILCode.Stobj; operand = methodBody.Method.Module.TypeSystem.Byte; break;  					case ILCode.__Stind_I2:  code = ILCode.Stobj; operand = methodBody.Method.Module.TypeSystem.Int16; break;  					case ILCode.__Stind_I4:  code = ILCode.Stobj; operand = methodBody.Method.Module.TypeSystem.Int32; break;  					case ILCode.__Stind_I8:  code = ILCode.Stobj; operand = methodBody.Method.Module.TypeSystem.Int64; break;  					case ILCode.__Stind_R4:  code = ILCode.Stobj; operand = methodBody.Method.Module.TypeSystem.Single; break;  					case ILCode.__Stind_R8:  code = ILCode.Stobj; operand = methodBody.Method.Module.TypeSystem.Double; break;  			}
Magic Number,Custom.Decompiler.ILAst,ILCodeUtil,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\ILCodes.cs,ExpandMacro,The following statement contains a magic number: switch (code) {  					case ILCode.__Ldarg_0:   code = ILCode.__Ldarg; operand = methodBody.GetParameter(0); break;  					case ILCode.__Ldarg_1:   code = ILCode.__Ldarg; operand = methodBody.GetParameter(1); break;  					case ILCode.__Ldarg_2:   code = ILCode.__Ldarg; operand = methodBody.GetParameter(2); break;  					case ILCode.__Ldarg_3:   code = ILCode.__Ldarg; operand = methodBody.GetParameter(3); break;  					case ILCode.__Ldloc_0:   code = ILCode.Ldloc; operand = methodBody.Variables[0]; break;  					case ILCode.__Ldloc_1:   code = ILCode.Ldloc; operand = methodBody.Variables[1]; break;  					case ILCode.__Ldloc_2:   code = ILCode.Ldloc; operand = methodBody.Variables[2]; break;  					case ILCode.__Ldloc_3:   code = ILCode.Ldloc; operand = methodBody.Variables[3]; break;  					case ILCode.__Stloc_0:   code = ILCode.Stloc; operand = methodBody.Variables[0]; break;  					case ILCode.__Stloc_1:   code = ILCode.Stloc; operand = methodBody.Variables[1]; break;  					case ILCode.__Stloc_2:   code = ILCode.Stloc; operand = methodBody.Variables[2]; break;  					case ILCode.__Stloc_3:   code = ILCode.Stloc; operand = methodBody.Variables[3]; break;  					case ILCode.__Ldarg_S:   code = ILCode.__Ldarg; break;  					case ILCode.__Ldarga_S:  code = ILCode.__Ldarga; break;  					case ILCode.__Starg_S:   code = ILCode.__Starg; break;  					case ILCode.__Ldloc_S:   code = ILCode.Ldloc; break;  					case ILCode.__Ldloca_S:  code = ILCode.Ldloca; break;  					case ILCode.__Stloc_S:   code = ILCode.Stloc; break;  					case ILCode.__Ldc_I4_M1: code = ILCode.Ldc_I4; operand = -1; break;  					case ILCode.__Ldc_I4_0:  code = ILCode.Ldc_I4; operand = 0; break;  					case ILCode.__Ldc_I4_1:  code = ILCode.Ldc_I4; operand = 1; break;  					case ILCode.__Ldc_I4_2:  code = ILCode.Ldc_I4; operand = 2; break;  					case ILCode.__Ldc_I4_3:  code = ILCode.Ldc_I4; operand = 3; break;  					case ILCode.__Ldc_I4_4:  code = ILCode.Ldc_I4; operand = 4; break;  					case ILCode.__Ldc_I4_5:  code = ILCode.Ldc_I4; operand = 5; break;  					case ILCode.__Ldc_I4_6:  code = ILCode.Ldc_I4; operand = 6; break;  					case ILCode.__Ldc_I4_7:  code = ILCode.Ldc_I4; operand = 7; break;  					case ILCode.__Ldc_I4_8:  code = ILCode.Ldc_I4; operand = 8; break;  					case ILCode.__Ldc_I4_S:  code = ILCode.Ldc_I4; operand = (int) (sbyte) operand; break;  					case ILCode.__Br_S:      code = ILCode.Br; break;  					case ILCode.__Brfalse_S: code = ILCode.__Brfalse; break;  					case ILCode.__Brtrue_S:  code = ILCode.Brtrue; break;  					case ILCode.__Beq_S:     code = ILCode.__Beq; break;  					case ILCode.__Bge_S:     code = ILCode.__Bge; break;  					case ILCode.__Bgt_S:     code = ILCode.__Bgt; break;  					case ILCode.__Ble_S:     code = ILCode.__Ble; break;  					case ILCode.__Blt_S:     code = ILCode.__Blt; break;  					case ILCode.__Bne_Un_S:  code = ILCode.__Bne_Un; break;  					case ILCode.__Bge_Un_S:  code = ILCode.__Bge_Un; break;  					case ILCode.__Bgt_Un_S:  code = ILCode.__Bgt_Un; break;  					case ILCode.__Ble_Un_S:  code = ILCode.__Ble_Un; break;  					case ILCode.__Blt_Un_S:  code = ILCode.__Blt_Un; break;  					case ILCode.__Leave_S:   code = ILCode.Leave; break;  					case ILCode.__Ldind_I:   code = ILCode.Ldobj; operand = methodBody.Method.Module.TypeSystem.IntPtr; break;  					case ILCode.__Ldind_I1:  code = ILCode.Ldobj; operand = methodBody.Method.Module.TypeSystem.SByte; break;  					case ILCode.__Ldind_I2:  code = ILCode.Ldobj; operand = methodBody.Method.Module.TypeSystem.Int16; break;  					case ILCode.__Ldind_I4:  code = ILCode.Ldobj; operand = methodBody.Method.Module.TypeSystem.Int32; break;  					case ILCode.__Ldind_I8:  code = ILCode.Ldobj; operand = methodBody.Method.Module.TypeSystem.Int64; break;  					case ILCode.__Ldind_U1:  code = ILCode.Ldobj; operand = methodBody.Method.Module.TypeSystem.Byte; break;  					case ILCode.__Ldind_U2:  code = ILCode.Ldobj; operand = methodBody.Method.Module.TypeSystem.UInt16; break;  					case ILCode.__Ldind_U4:  code = ILCode.Ldobj; operand = methodBody.Method.Module.TypeSystem.UInt32; break;  					case ILCode.__Ldind_R4:  code = ILCode.Ldobj; operand = methodBody.Method.Module.TypeSystem.Single; break;  					case ILCode.__Ldind_R8:  code = ILCode.Ldobj; operand = methodBody.Method.Module.TypeSystem.Double; break;  					case ILCode.__Stind_I:   code = ILCode.Stobj; operand = methodBody.Method.Module.TypeSystem.IntPtr; break;  					case ILCode.__Stind_I1:  code = ILCode.Stobj; operand = methodBody.Method.Module.TypeSystem.Byte; break;  					case ILCode.__Stind_I2:  code = ILCode.Stobj; operand = methodBody.Method.Module.TypeSystem.Int16; break;  					case ILCode.__Stind_I4:  code = ILCode.Stobj; operand = methodBody.Method.Module.TypeSystem.Int32; break;  					case ILCode.__Stind_I8:  code = ILCode.Stobj; operand = methodBody.Method.Module.TypeSystem.Int64; break;  					case ILCode.__Stind_R4:  code = ILCode.Stobj; operand = methodBody.Method.Module.TypeSystem.Single; break;  					case ILCode.__Stind_R8:  code = ILCode.Stobj; operand = methodBody.Method.Module.TypeSystem.Double; break;  			}
Magic Number,Custom.Decompiler.ILAst,ILCodeUtil,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\ILCodes.cs,ExpandMacro,The following statement contains a magic number: switch (code) {  					case ILCode.__Ldarg_0:   code = ILCode.__Ldarg; operand = methodBody.GetParameter(0); break;  					case ILCode.__Ldarg_1:   code = ILCode.__Ldarg; operand = methodBody.GetParameter(1); break;  					case ILCode.__Ldarg_2:   code = ILCode.__Ldarg; operand = methodBody.GetParameter(2); break;  					case ILCode.__Ldarg_3:   code = ILCode.__Ldarg; operand = methodBody.GetParameter(3); break;  					case ILCode.__Ldloc_0:   code = ILCode.Ldloc; operand = methodBody.Variables[0]; break;  					case ILCode.__Ldloc_1:   code = ILCode.Ldloc; operand = methodBody.Variables[1]; break;  					case ILCode.__Ldloc_2:   code = ILCode.Ldloc; operand = methodBody.Variables[2]; break;  					case ILCode.__Ldloc_3:   code = ILCode.Ldloc; operand = methodBody.Variables[3]; break;  					case ILCode.__Stloc_0:   code = ILCode.Stloc; operand = methodBody.Variables[0]; break;  					case ILCode.__Stloc_1:   code = ILCode.Stloc; operand = methodBody.Variables[1]; break;  					case ILCode.__Stloc_2:   code = ILCode.Stloc; operand = methodBody.Variables[2]; break;  					case ILCode.__Stloc_3:   code = ILCode.Stloc; operand = methodBody.Variables[3]; break;  					case ILCode.__Ldarg_S:   code = ILCode.__Ldarg; break;  					case ILCode.__Ldarga_S:  code = ILCode.__Ldarga; break;  					case ILCode.__Starg_S:   code = ILCode.__Starg; break;  					case ILCode.__Ldloc_S:   code = ILCode.Ldloc; break;  					case ILCode.__Ldloca_S:  code = ILCode.Ldloca; break;  					case ILCode.__Stloc_S:   code = ILCode.Stloc; break;  					case ILCode.__Ldc_I4_M1: code = ILCode.Ldc_I4; operand = -1; break;  					case ILCode.__Ldc_I4_0:  code = ILCode.Ldc_I4; operand = 0; break;  					case ILCode.__Ldc_I4_1:  code = ILCode.Ldc_I4; operand = 1; break;  					case ILCode.__Ldc_I4_2:  code = ILCode.Ldc_I4; operand = 2; break;  					case ILCode.__Ldc_I4_3:  code = ILCode.Ldc_I4; operand = 3; break;  					case ILCode.__Ldc_I4_4:  code = ILCode.Ldc_I4; operand = 4; break;  					case ILCode.__Ldc_I4_5:  code = ILCode.Ldc_I4; operand = 5; break;  					case ILCode.__Ldc_I4_6:  code = ILCode.Ldc_I4; operand = 6; break;  					case ILCode.__Ldc_I4_7:  code = ILCode.Ldc_I4; operand = 7; break;  					case ILCode.__Ldc_I4_8:  code = ILCode.Ldc_I4; operand = 8; break;  					case ILCode.__Ldc_I4_S:  code = ILCode.Ldc_I4; operand = (int) (sbyte) operand; break;  					case ILCode.__Br_S:      code = ILCode.Br; break;  					case ILCode.__Brfalse_S: code = ILCode.__Brfalse; break;  					case ILCode.__Brtrue_S:  code = ILCode.Brtrue; break;  					case ILCode.__Beq_S:     code = ILCode.__Beq; break;  					case ILCode.__Bge_S:     code = ILCode.__Bge; break;  					case ILCode.__Bgt_S:     code = ILCode.__Bgt; break;  					case ILCode.__Ble_S:     code = ILCode.__Ble; break;  					case ILCode.__Blt_S:     code = ILCode.__Blt; break;  					case ILCode.__Bne_Un_S:  code = ILCode.__Bne_Un; break;  					case ILCode.__Bge_Un_S:  code = ILCode.__Bge_Un; break;  					case ILCode.__Bgt_Un_S:  code = ILCode.__Bgt_Un; break;  					case ILCode.__Ble_Un_S:  code = ILCode.__Ble_Un; break;  					case ILCode.__Blt_Un_S:  code = ILCode.__Blt_Un; break;  					case ILCode.__Leave_S:   code = ILCode.Leave; break;  					case ILCode.__Ldind_I:   code = ILCode.Ldobj; operand = methodBody.Method.Module.TypeSystem.IntPtr; break;  					case ILCode.__Ldind_I1:  code = ILCode.Ldobj; operand = methodBody.Method.Module.TypeSystem.SByte; break;  					case ILCode.__Ldind_I2:  code = ILCode.Ldobj; operand = methodBody.Method.Module.TypeSystem.Int16; break;  					case ILCode.__Ldind_I4:  code = ILCode.Ldobj; operand = methodBody.Method.Module.TypeSystem.Int32; break;  					case ILCode.__Ldind_I8:  code = ILCode.Ldobj; operand = methodBody.Method.Module.TypeSystem.Int64; break;  					case ILCode.__Ldind_U1:  code = ILCode.Ldobj; operand = methodBody.Method.Module.TypeSystem.Byte; break;  					case ILCode.__Ldind_U2:  code = ILCode.Ldobj; operand = methodBody.Method.Module.TypeSystem.UInt16; break;  					case ILCode.__Ldind_U4:  code = ILCode.Ldobj; operand = methodBody.Method.Module.TypeSystem.UInt32; break;  					case ILCode.__Ldind_R4:  code = ILCode.Ldobj; operand = methodBody.Method.Module.TypeSystem.Single; break;  					case ILCode.__Ldind_R8:  code = ILCode.Ldobj; operand = methodBody.Method.Module.TypeSystem.Double; break;  					case ILCode.__Stind_I:   code = ILCode.Stobj; operand = methodBody.Method.Module.TypeSystem.IntPtr; break;  					case ILCode.__Stind_I1:  code = ILCode.Stobj; operand = methodBody.Method.Module.TypeSystem.Byte; break;  					case ILCode.__Stind_I2:  code = ILCode.Stobj; operand = methodBody.Method.Module.TypeSystem.Int16; break;  					case ILCode.__Stind_I4:  code = ILCode.Stobj; operand = methodBody.Method.Module.TypeSystem.Int32; break;  					case ILCode.__Stind_I8:  code = ILCode.Stobj; operand = methodBody.Method.Module.TypeSystem.Int64; break;  					case ILCode.__Stind_R4:  code = ILCode.Stobj; operand = methodBody.Method.Module.TypeSystem.Single; break;  					case ILCode.__Stind_R8:  code = ILCode.Stobj; operand = methodBody.Method.Module.TypeSystem.Double; break;  			}
Magic Number,Custom.Decompiler.ILAst,ILCodeUtil,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\ILCodes.cs,ExpandMacro,The following statement contains a magic number: switch (code) {  					case ILCode.__Ldarg_0:   code = ILCode.__Ldarg; operand = methodBody.GetParameter(0); break;  					case ILCode.__Ldarg_1:   code = ILCode.__Ldarg; operand = methodBody.GetParameter(1); break;  					case ILCode.__Ldarg_2:   code = ILCode.__Ldarg; operand = methodBody.GetParameter(2); break;  					case ILCode.__Ldarg_3:   code = ILCode.__Ldarg; operand = methodBody.GetParameter(3); break;  					case ILCode.__Ldloc_0:   code = ILCode.Ldloc; operand = methodBody.Variables[0]; break;  					case ILCode.__Ldloc_1:   code = ILCode.Ldloc; operand = methodBody.Variables[1]; break;  					case ILCode.__Ldloc_2:   code = ILCode.Ldloc; operand = methodBody.Variables[2]; break;  					case ILCode.__Ldloc_3:   code = ILCode.Ldloc; operand = methodBody.Variables[3]; break;  					case ILCode.__Stloc_0:   code = ILCode.Stloc; operand = methodBody.Variables[0]; break;  					case ILCode.__Stloc_1:   code = ILCode.Stloc; operand = methodBody.Variables[1]; break;  					case ILCode.__Stloc_2:   code = ILCode.Stloc; operand = methodBody.Variables[2]; break;  					case ILCode.__Stloc_3:   code = ILCode.Stloc; operand = methodBody.Variables[3]; break;  					case ILCode.__Ldarg_S:   code = ILCode.__Ldarg; break;  					case ILCode.__Ldarga_S:  code = ILCode.__Ldarga; break;  					case ILCode.__Starg_S:   code = ILCode.__Starg; break;  					case ILCode.__Ldloc_S:   code = ILCode.Ldloc; break;  					case ILCode.__Ldloca_S:  code = ILCode.Ldloca; break;  					case ILCode.__Stloc_S:   code = ILCode.Stloc; break;  					case ILCode.__Ldc_I4_M1: code = ILCode.Ldc_I4; operand = -1; break;  					case ILCode.__Ldc_I4_0:  code = ILCode.Ldc_I4; operand = 0; break;  					case ILCode.__Ldc_I4_1:  code = ILCode.Ldc_I4; operand = 1; break;  					case ILCode.__Ldc_I4_2:  code = ILCode.Ldc_I4; operand = 2; break;  					case ILCode.__Ldc_I4_3:  code = ILCode.Ldc_I4; operand = 3; break;  					case ILCode.__Ldc_I4_4:  code = ILCode.Ldc_I4; operand = 4; break;  					case ILCode.__Ldc_I4_5:  code = ILCode.Ldc_I4; operand = 5; break;  					case ILCode.__Ldc_I4_6:  code = ILCode.Ldc_I4; operand = 6; break;  					case ILCode.__Ldc_I4_7:  code = ILCode.Ldc_I4; operand = 7; break;  					case ILCode.__Ldc_I4_8:  code = ILCode.Ldc_I4; operand = 8; break;  					case ILCode.__Ldc_I4_S:  code = ILCode.Ldc_I4; operand = (int) (sbyte) operand; break;  					case ILCode.__Br_S:      code = ILCode.Br; break;  					case ILCode.__Brfalse_S: code = ILCode.__Brfalse; break;  					case ILCode.__Brtrue_S:  code = ILCode.Brtrue; break;  					case ILCode.__Beq_S:     code = ILCode.__Beq; break;  					case ILCode.__Bge_S:     code = ILCode.__Bge; break;  					case ILCode.__Bgt_S:     code = ILCode.__Bgt; break;  					case ILCode.__Ble_S:     code = ILCode.__Ble; break;  					case ILCode.__Blt_S:     code = ILCode.__Blt; break;  					case ILCode.__Bne_Un_S:  code = ILCode.__Bne_Un; break;  					case ILCode.__Bge_Un_S:  code = ILCode.__Bge_Un; break;  					case ILCode.__Bgt_Un_S:  code = ILCode.__Bgt_Un; break;  					case ILCode.__Ble_Un_S:  code = ILCode.__Ble_Un; break;  					case ILCode.__Blt_Un_S:  code = ILCode.__Blt_Un; break;  					case ILCode.__Leave_S:   code = ILCode.Leave; break;  					case ILCode.__Ldind_I:   code = ILCode.Ldobj; operand = methodBody.Method.Module.TypeSystem.IntPtr; break;  					case ILCode.__Ldind_I1:  code = ILCode.Ldobj; operand = methodBody.Method.Module.TypeSystem.SByte; break;  					case ILCode.__Ldind_I2:  code = ILCode.Ldobj; operand = methodBody.Method.Module.TypeSystem.Int16; break;  					case ILCode.__Ldind_I4:  code = ILCode.Ldobj; operand = methodBody.Method.Module.TypeSystem.Int32; break;  					case ILCode.__Ldind_I8:  code = ILCode.Ldobj; operand = methodBody.Method.Module.TypeSystem.Int64; break;  					case ILCode.__Ldind_U1:  code = ILCode.Ldobj; operand = methodBody.Method.Module.TypeSystem.Byte; break;  					case ILCode.__Ldind_U2:  code = ILCode.Ldobj; operand = methodBody.Method.Module.TypeSystem.UInt16; break;  					case ILCode.__Ldind_U4:  code = ILCode.Ldobj; operand = methodBody.Method.Module.TypeSystem.UInt32; break;  					case ILCode.__Ldind_R4:  code = ILCode.Ldobj; operand = methodBody.Method.Module.TypeSystem.Single; break;  					case ILCode.__Ldind_R8:  code = ILCode.Ldobj; operand = methodBody.Method.Module.TypeSystem.Double; break;  					case ILCode.__Stind_I:   code = ILCode.Stobj; operand = methodBody.Method.Module.TypeSystem.IntPtr; break;  					case ILCode.__Stind_I1:  code = ILCode.Stobj; operand = methodBody.Method.Module.TypeSystem.Byte; break;  					case ILCode.__Stind_I2:  code = ILCode.Stobj; operand = methodBody.Method.Module.TypeSystem.Int16; break;  					case ILCode.__Stind_I4:  code = ILCode.Stobj; operand = methodBody.Method.Module.TypeSystem.Int32; break;  					case ILCode.__Stind_I8:  code = ILCode.Stobj; operand = methodBody.Method.Module.TypeSystem.Int64; break;  					case ILCode.__Stind_R4:  code = ILCode.Stobj; operand = methodBody.Method.Module.TypeSystem.Single; break;  					case ILCode.__Stind_R8:  code = ILCode.Stobj; operand = methodBody.Method.Module.TypeSystem.Double; break;  			}
Magic Number,Custom.Decompiler.ILAst,ILCodeUtil,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\ILCodes.cs,ExpandMacro,The following statement contains a magic number: switch (code) {  					case ILCode.__Ldarg_0:   code = ILCode.__Ldarg; operand = methodBody.GetParameter(0); break;  					case ILCode.__Ldarg_1:   code = ILCode.__Ldarg; operand = methodBody.GetParameter(1); break;  					case ILCode.__Ldarg_2:   code = ILCode.__Ldarg; operand = methodBody.GetParameter(2); break;  					case ILCode.__Ldarg_3:   code = ILCode.__Ldarg; operand = methodBody.GetParameter(3); break;  					case ILCode.__Ldloc_0:   code = ILCode.Ldloc; operand = methodBody.Variables[0]; break;  					case ILCode.__Ldloc_1:   code = ILCode.Ldloc; operand = methodBody.Variables[1]; break;  					case ILCode.__Ldloc_2:   code = ILCode.Ldloc; operand = methodBody.Variables[2]; break;  					case ILCode.__Ldloc_3:   code = ILCode.Ldloc; operand = methodBody.Variables[3]; break;  					case ILCode.__Stloc_0:   code = ILCode.Stloc; operand = methodBody.Variables[0]; break;  					case ILCode.__Stloc_1:   code = ILCode.Stloc; operand = methodBody.Variables[1]; break;  					case ILCode.__Stloc_2:   code = ILCode.Stloc; operand = methodBody.Variables[2]; break;  					case ILCode.__Stloc_3:   code = ILCode.Stloc; operand = methodBody.Variables[3]; break;  					case ILCode.__Ldarg_S:   code = ILCode.__Ldarg; break;  					case ILCode.__Ldarga_S:  code = ILCode.__Ldarga; break;  					case ILCode.__Starg_S:   code = ILCode.__Starg; break;  					case ILCode.__Ldloc_S:   code = ILCode.Ldloc; break;  					case ILCode.__Ldloca_S:  code = ILCode.Ldloca; break;  					case ILCode.__Stloc_S:   code = ILCode.Stloc; break;  					case ILCode.__Ldc_I4_M1: code = ILCode.Ldc_I4; operand = -1; break;  					case ILCode.__Ldc_I4_0:  code = ILCode.Ldc_I4; operand = 0; break;  					case ILCode.__Ldc_I4_1:  code = ILCode.Ldc_I4; operand = 1; break;  					case ILCode.__Ldc_I4_2:  code = ILCode.Ldc_I4; operand = 2; break;  					case ILCode.__Ldc_I4_3:  code = ILCode.Ldc_I4; operand = 3; break;  					case ILCode.__Ldc_I4_4:  code = ILCode.Ldc_I4; operand = 4; break;  					case ILCode.__Ldc_I4_5:  code = ILCode.Ldc_I4; operand = 5; break;  					case ILCode.__Ldc_I4_6:  code = ILCode.Ldc_I4; operand = 6; break;  					case ILCode.__Ldc_I4_7:  code = ILCode.Ldc_I4; operand = 7; break;  					case ILCode.__Ldc_I4_8:  code = ILCode.Ldc_I4; operand = 8; break;  					case ILCode.__Ldc_I4_S:  code = ILCode.Ldc_I4; operand = (int) (sbyte) operand; break;  					case ILCode.__Br_S:      code = ILCode.Br; break;  					case ILCode.__Brfalse_S: code = ILCode.__Brfalse; break;  					case ILCode.__Brtrue_S:  code = ILCode.Brtrue; break;  					case ILCode.__Beq_S:     code = ILCode.__Beq; break;  					case ILCode.__Bge_S:     code = ILCode.__Bge; break;  					case ILCode.__Bgt_S:     code = ILCode.__Bgt; break;  					case ILCode.__Ble_S:     code = ILCode.__Ble; break;  					case ILCode.__Blt_S:     code = ILCode.__Blt; break;  					case ILCode.__Bne_Un_S:  code = ILCode.__Bne_Un; break;  					case ILCode.__Bge_Un_S:  code = ILCode.__Bge_Un; break;  					case ILCode.__Bgt_Un_S:  code = ILCode.__Bgt_Un; break;  					case ILCode.__Ble_Un_S:  code = ILCode.__Ble_Un; break;  					case ILCode.__Blt_Un_S:  code = ILCode.__Blt_Un; break;  					case ILCode.__Leave_S:   code = ILCode.Leave; break;  					case ILCode.__Ldind_I:   code = ILCode.Ldobj; operand = methodBody.Method.Module.TypeSystem.IntPtr; break;  					case ILCode.__Ldind_I1:  code = ILCode.Ldobj; operand = methodBody.Method.Module.TypeSystem.SByte; break;  					case ILCode.__Ldind_I2:  code = ILCode.Ldobj; operand = methodBody.Method.Module.TypeSystem.Int16; break;  					case ILCode.__Ldind_I4:  code = ILCode.Ldobj; operand = methodBody.Method.Module.TypeSystem.Int32; break;  					case ILCode.__Ldind_I8:  code = ILCode.Ldobj; operand = methodBody.Method.Module.TypeSystem.Int64; break;  					case ILCode.__Ldind_U1:  code = ILCode.Ldobj; operand = methodBody.Method.Module.TypeSystem.Byte; break;  					case ILCode.__Ldind_U2:  code = ILCode.Ldobj; operand = methodBody.Method.Module.TypeSystem.UInt16; break;  					case ILCode.__Ldind_U4:  code = ILCode.Ldobj; operand = methodBody.Method.Module.TypeSystem.UInt32; break;  					case ILCode.__Ldind_R4:  code = ILCode.Ldobj; operand = methodBody.Method.Module.TypeSystem.Single; break;  					case ILCode.__Ldind_R8:  code = ILCode.Ldobj; operand = methodBody.Method.Module.TypeSystem.Double; break;  					case ILCode.__Stind_I:   code = ILCode.Stobj; operand = methodBody.Method.Module.TypeSystem.IntPtr; break;  					case ILCode.__Stind_I1:  code = ILCode.Stobj; operand = methodBody.Method.Module.TypeSystem.Byte; break;  					case ILCode.__Stind_I2:  code = ILCode.Stobj; operand = methodBody.Method.Module.TypeSystem.Int16; break;  					case ILCode.__Stind_I4:  code = ILCode.Stobj; operand = methodBody.Method.Module.TypeSystem.Int32; break;  					case ILCode.__Stind_I8:  code = ILCode.Stobj; operand = methodBody.Method.Module.TypeSystem.Int64; break;  					case ILCode.__Stind_R4:  code = ILCode.Stobj; operand = methodBody.Method.Module.TypeSystem.Single; break;  					case ILCode.__Stind_R8:  code = ILCode.Stobj; operand = methodBody.Method.Module.TypeSystem.Double; break;  			}
Magic Number,Custom.Decompiler.ILAst,ILCodeUtil,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\ILCodes.cs,ExpandMacro,The following statement contains a magic number: switch (code) {  					case ILCode.__Ldarg_0:   code = ILCode.__Ldarg; operand = methodBody.GetParameter(0); break;  					case ILCode.__Ldarg_1:   code = ILCode.__Ldarg; operand = methodBody.GetParameter(1); break;  					case ILCode.__Ldarg_2:   code = ILCode.__Ldarg; operand = methodBody.GetParameter(2); break;  					case ILCode.__Ldarg_3:   code = ILCode.__Ldarg; operand = methodBody.GetParameter(3); break;  					case ILCode.__Ldloc_0:   code = ILCode.Ldloc; operand = methodBody.Variables[0]; break;  					case ILCode.__Ldloc_1:   code = ILCode.Ldloc; operand = methodBody.Variables[1]; break;  					case ILCode.__Ldloc_2:   code = ILCode.Ldloc; operand = methodBody.Variables[2]; break;  					case ILCode.__Ldloc_3:   code = ILCode.Ldloc; operand = methodBody.Variables[3]; break;  					case ILCode.__Stloc_0:   code = ILCode.Stloc; operand = methodBody.Variables[0]; break;  					case ILCode.__Stloc_1:   code = ILCode.Stloc; operand = methodBody.Variables[1]; break;  					case ILCode.__Stloc_2:   code = ILCode.Stloc; operand = methodBody.Variables[2]; break;  					case ILCode.__Stloc_3:   code = ILCode.Stloc; operand = methodBody.Variables[3]; break;  					case ILCode.__Ldarg_S:   code = ILCode.__Ldarg; break;  					case ILCode.__Ldarga_S:  code = ILCode.__Ldarga; break;  					case ILCode.__Starg_S:   code = ILCode.__Starg; break;  					case ILCode.__Ldloc_S:   code = ILCode.Ldloc; break;  					case ILCode.__Ldloca_S:  code = ILCode.Ldloca; break;  					case ILCode.__Stloc_S:   code = ILCode.Stloc; break;  					case ILCode.__Ldc_I4_M1: code = ILCode.Ldc_I4; operand = -1; break;  					case ILCode.__Ldc_I4_0:  code = ILCode.Ldc_I4; operand = 0; break;  					case ILCode.__Ldc_I4_1:  code = ILCode.Ldc_I4; operand = 1; break;  					case ILCode.__Ldc_I4_2:  code = ILCode.Ldc_I4; operand = 2; break;  					case ILCode.__Ldc_I4_3:  code = ILCode.Ldc_I4; operand = 3; break;  					case ILCode.__Ldc_I4_4:  code = ILCode.Ldc_I4; operand = 4; break;  					case ILCode.__Ldc_I4_5:  code = ILCode.Ldc_I4; operand = 5; break;  					case ILCode.__Ldc_I4_6:  code = ILCode.Ldc_I4; operand = 6; break;  					case ILCode.__Ldc_I4_7:  code = ILCode.Ldc_I4; operand = 7; break;  					case ILCode.__Ldc_I4_8:  code = ILCode.Ldc_I4; operand = 8; break;  					case ILCode.__Ldc_I4_S:  code = ILCode.Ldc_I4; operand = (int) (sbyte) operand; break;  					case ILCode.__Br_S:      code = ILCode.Br; break;  					case ILCode.__Brfalse_S: code = ILCode.__Brfalse; break;  					case ILCode.__Brtrue_S:  code = ILCode.Brtrue; break;  					case ILCode.__Beq_S:     code = ILCode.__Beq; break;  					case ILCode.__Bge_S:     code = ILCode.__Bge; break;  					case ILCode.__Bgt_S:     code = ILCode.__Bgt; break;  					case ILCode.__Ble_S:     code = ILCode.__Ble; break;  					case ILCode.__Blt_S:     code = ILCode.__Blt; break;  					case ILCode.__Bne_Un_S:  code = ILCode.__Bne_Un; break;  					case ILCode.__Bge_Un_S:  code = ILCode.__Bge_Un; break;  					case ILCode.__Bgt_Un_S:  code = ILCode.__Bgt_Un; break;  					case ILCode.__Ble_Un_S:  code = ILCode.__Ble_Un; break;  					case ILCode.__Blt_Un_S:  code = ILCode.__Blt_Un; break;  					case ILCode.__Leave_S:   code = ILCode.Leave; break;  					case ILCode.__Ldind_I:   code = ILCode.Ldobj; operand = methodBody.Method.Module.TypeSystem.IntPtr; break;  					case ILCode.__Ldind_I1:  code = ILCode.Ldobj; operand = methodBody.Method.Module.TypeSystem.SByte; break;  					case ILCode.__Ldind_I2:  code = ILCode.Ldobj; operand = methodBody.Method.Module.TypeSystem.Int16; break;  					case ILCode.__Ldind_I4:  code = ILCode.Ldobj; operand = methodBody.Method.Module.TypeSystem.Int32; break;  					case ILCode.__Ldind_I8:  code = ILCode.Ldobj; operand = methodBody.Method.Module.TypeSystem.Int64; break;  					case ILCode.__Ldind_U1:  code = ILCode.Ldobj; operand = methodBody.Method.Module.TypeSystem.Byte; break;  					case ILCode.__Ldind_U2:  code = ILCode.Ldobj; operand = methodBody.Method.Module.TypeSystem.UInt16; break;  					case ILCode.__Ldind_U4:  code = ILCode.Ldobj; operand = methodBody.Method.Module.TypeSystem.UInt32; break;  					case ILCode.__Ldind_R4:  code = ILCode.Ldobj; operand = methodBody.Method.Module.TypeSystem.Single; break;  					case ILCode.__Ldind_R8:  code = ILCode.Ldobj; operand = methodBody.Method.Module.TypeSystem.Double; break;  					case ILCode.__Stind_I:   code = ILCode.Stobj; operand = methodBody.Method.Module.TypeSystem.IntPtr; break;  					case ILCode.__Stind_I1:  code = ILCode.Stobj; operand = methodBody.Method.Module.TypeSystem.Byte; break;  					case ILCode.__Stind_I2:  code = ILCode.Stobj; operand = methodBody.Method.Module.TypeSystem.Int16; break;  					case ILCode.__Stind_I4:  code = ILCode.Stobj; operand = methodBody.Method.Module.TypeSystem.Int32; break;  					case ILCode.__Stind_I8:  code = ILCode.Stobj; operand = methodBody.Method.Module.TypeSystem.Int64; break;  					case ILCode.__Stind_R4:  code = ILCode.Stobj; operand = methodBody.Method.Module.TypeSystem.Single; break;  					case ILCode.__Stind_R8:  code = ILCode.Stobj; operand = methodBody.Method.Module.TypeSystem.Double; break;  			}
Magic Number,Custom.Decompiler.ILAst,OperatorPattern,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\LiftedOperators.cs,Match,The following statement contains a magic number: switch (e.Code) {  						case ILCode.Ceq:  							if (type != OperatorType.Equality) return false;  							break;  						case ILCode.Cne:  							if (type != OperatorType.InEquality) return false;  							break;  						case ILCode.Cgt:  						case ILCode.Cgt_Un:  						case ILCode.Cge:  						case ILCode.Cge_Un:  						case ILCode.Clt:  						case ILCode.Clt_Un:  						case ILCode.Cle:  						case ILCode.Cle_Un:  							if (type != OperatorType.Comparison) return false;  							break;  						case ILCode.Add:  						case ILCode.Add_Ovf:  						case ILCode.Add_Ovf_Un:  						case ILCode.Sub:  						case ILCode.Sub_Ovf:  						case ILCode.Sub_Ovf_Un:  						case ILCode.Mul:  						case ILCode.Mul_Ovf:  						case ILCode.Mul_Ovf_Un:  						case ILCode.Div:  						case ILCode.Div_Un:  						case ILCode.Rem:  						case ILCode.Rem_Un:  						case ILCode.And:  						case ILCode.Or:  						case ILCode.Xor:  						case ILCode.Shl:  						case ILCode.Shr:  						case ILCode.Shr_Un:  						case ILCode.Not:  						case ILCode.Neg:  						case ILCode.LogicNot:  							if (type != OperatorType.Other) return false;  							break;  						case ILCode.Call:  							var m = e.Operand as MethodReference;  							if (m == null || m.HasThis || !m.HasParameters || e.Arguments.Count > 2 || !IsCustomOperator(m.Name)) return false;  							break;  						default: return false;  					}
Magic Number,Custom.Decompiler.ILAst,OperatorPattern,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\LiftedOperators.cs,IsCustomOperator,The following statement contains a magic number: switch (type) {  						case OperatorType.Equality: return s == "op_Equality";  						case OperatorType.InEquality: return s == "op_Inequality";  						case OperatorType.Comparison:  							if (s.Length < 11 || !s.StartsWith("op_"' StringComparison.Ordinal)) return false;  							switch (s) {  								case "op_GreaterThan":  								case "op_GreaterThanOrEqual":  								case "op_LessThan":  								case "op_LessThanOrEqual": return true;  								default: return false;  							}  						default:  							if (s.Length < 10 || !s.StartsWith("op_"' StringComparison.Ordinal)) return false;  							switch (s) {  								case "op_Addition":  								case "op_Subtraction":  								case "op_Multiply":  								case "op_Division":  								case "op_Modulus":  								case "op_BitwiseAnd":  								case "op_BitwiseOr":  								case "op_ExclusiveOr":  								case "op_LeftShift":  								case "op_RightShift":  								case "op_UnaryNegation":  								case "op_UnaryPlus":  								case "op_LogicalNot":  								case "op_OnesComplement":  								case "op_Increment":  								case "op_Decrement": return true;  								default: return false;  							}  					}
Magic Number,Custom.Decompiler.ILAst,OperatorPattern,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\LiftedOperators.cs,IsCustomOperator,The following statement contains a magic number: switch (type) {  						case OperatorType.Equality: return s == "op_Equality";  						case OperatorType.InEquality: return s == "op_Inequality";  						case OperatorType.Comparison:  							if (s.Length < 11 || !s.StartsWith("op_"' StringComparison.Ordinal)) return false;  							switch (s) {  								case "op_GreaterThan":  								case "op_GreaterThanOrEqual":  								case "op_LessThan":  								case "op_LessThanOrEqual": return true;  								default: return false;  							}  						default:  							if (s.Length < 10 || !s.StartsWith("op_"' StringComparison.Ordinal)) return false;  							switch (s) {  								case "op_Addition":  								case "op_Subtraction":  								case "op_Multiply":  								case "op_Division":  								case "op_Modulus":  								case "op_BitwiseAnd":  								case "op_BitwiseOr":  								case "op_ExclusiveOr":  								case "op_LeftShift":  								case "op_RightShift":  								case "op_UnaryNegation":  								case "op_UnaryPlus":  								case "op_LogicalNot":  								case "op_OnesComplement":  								case "op_Increment":  								case "op_Decrement": return true;  								default: return false;  							}  					}
Magic Number,Custom.Decompiler.ILAst,LoopsAndConditions,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\LoopsAndConditions.cs,FindLoops,The following statement contains a magic number: block.Body = FindLoops(new HashSet<ControlFlowNode>(graph.Nodes.Skip(3))' graph.EntryPoint' false);
Magic Number,Custom.Decompiler.ILAst,LoopsAndConditions,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\LoopsAndConditions.cs,FindConditions,The following statement contains a magic number: block.Body = FindConditions(new HashSet<ControlFlowNode>(graph.Nodes.Skip(3))' graph.EntryPoint);
Magic Number,Custom.Decompiler.ILAst,PatternMatching,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\PatternMatching.cs,Match,The following statement contains a magic number: node.Match(code' out operand' out args) && args.Count == 2
Magic Number,Custom.Decompiler.ILAst,PatternMatching,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\PatternMatching.cs,MatchSingle,The following statement contains a magic number: bb.Body.Count == 2 &&  			    bb.Body[0] is ILLabel &&  			    bb.Body[1].Match(code' out operand' out arg)
Magic Number,Custom.Decompiler.ILAst,PatternMatching,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\PatternMatching.cs,MatchSingleAndBr,The following statement contains a magic number: bb.Body.Count == 3 &&  			    bb.Body[0] is ILLabel &&  			    bb.Body[1].Match(code' out operand' out arg) &&  			    bb.Body[2].Match(ILCode.Br' out brLabel)
Magic Number,Custom.Decompiler.ILAst,PatternMatching,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\PatternMatching.cs,MatchSingleAndBr,The following statement contains a magic number: bb.Body.Count == 3 &&  			    bb.Body[0] is ILLabel &&  			    bb.Body[1].Match(code' out operand' out arg) &&  			    bb.Body[2].Match(ILCode.Br' out brLabel)
Magic Number,Custom.Decompiler.ILAst,PatternMatching,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\PatternMatching.cs,MatchLastAndBr,The following statement contains a magic number: bb.Body.ElementAtOrDefault(bb.Body.Count - 2).Match(code' out operand' out arg) &&  			    bb.Body.LastOrDefault().Match(ILCode.Br' out brLabel)
Magic Number,Custom.Decompiler.ILAst,SimpleControlFlow,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\SimpleControlFlow.cs,SimplifyNullCoalescing,The following statement contains a magic number: head.Body.Count >= 3 &&  			    head.Body[head.Body.Count - 3].Match(ILCode.Stloc' out v' out leftExpr) &&  			    leftExpr.Match(ILCode.Ldloc' out leftVar) &&  			    head.MatchLastAndBr(ILCode.Brtrue' out endBBLabel' out leftExpr2' out rightBBLabel) &&  			    leftExpr2.MatchLdloc(leftVar) &&  			    labelToBasicBlock.TryGetValue(rightBBLabel' out rightBB) &&  			    rightBB.MatchSingleAndBr(ILCode.Stloc' out v2' out rightExpr' out endBBLabel2) &&  			    v == v2 &&  			    endBBLabel == endBBLabel2 &&  			    labelGlobalRefCount.GetOrDefault(rightBBLabel) == 1 &&  			    body.Contains(rightBB)
Magic Number,Custom.Decompiler.ILAst,SimpleControlFlow,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\SimpleControlFlow.cs,SimplifyNullCoalescing,The following statement contains a magic number: head.Body.Count >= 3 &&  			    head.Body[head.Body.Count - 3].Match(ILCode.Stloc' out v' out leftExpr) &&  			    leftExpr.Match(ILCode.Ldloc' out leftVar) &&  			    head.MatchLastAndBr(ILCode.Brtrue' out endBBLabel' out leftExpr2' out rightBBLabel) &&  			    leftExpr2.MatchLdloc(leftVar) &&  			    labelToBasicBlock.TryGetValue(rightBBLabel' out rightBB) &&  			    rightBB.MatchSingleAndBr(ILCode.Stloc' out v2' out rightExpr' out endBBLabel2) &&  			    v == v2 &&  			    endBBLabel == endBBLabel2 &&  			    labelGlobalRefCount.GetOrDefault(rightBBLabel) == 1 &&  			    body.Contains(rightBB)
Magic Number,Custom.Decompiler.ILAst,SimpleControlFlow,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\SimpleControlFlow.cs,SimplifyShortCircuit,The following statement contains a magic number: pass < 2
Magic Number,Custom.Decompiler.ILAst,SimpleControlFlow,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\SimpleControlFlow.cs,SimplifyCustomShortCircuit,The following statement contains a magic number: head.Body.Count < 3
Magic Number,Custom.Decompiler.ILAst,SimpleControlFlow,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\SimpleControlFlow.cs,SimplifyCustomShortCircuit,The following statement contains a magic number: !head.Body[head.Body.Count - 3].Match(ILCode.Stloc' out targetVar' out targetVarInitExpr)
Magic Number,Custom.Decompiler.ILAst,SimpleControlFlow,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\SimpleControlFlow.cs,JoinBasicBlocks,The following statement contains a magic number: !head.Body.ElementAtOrDefault(head.Body.Count - 2).IsConditionalControlFlow() &&  			    head.Body.Last().Match(ILCode.Br' out nextLabel) &&  			    labelGlobalRefCount[nextLabel] == 1 &&  			    labelToBasicBlock.TryGetValue(nextLabel' out nextBB) &&  			    body.Contains(nextBB) &&  			    nextBB.Body.First() == nextLabel &&  			    !nextBB.Body.OfType<ILTryCatchBlock>().Any()
Magic Number,Custom.Decompiler.ILAst,StateRange,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\StateRange.cs,Simplify,The following statement contains a magic number: data.Count < 2
Magic Number,Custom.Decompiler.ILAst,TypeAnalysis,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\TypeAnalysis.cs,DoInferTypeForExpression,The following statement contains a magic number: switch (expr.Code) {  					#region Logical operators  				case ILCode.LogicNot:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments.Single()' typeSystem.Boolean);  					}  					return typeSystem.Boolean;  				case ILCode.LogicAnd:  				case ILCode.LogicOr:  					// if Operand is set the logic and/or expression is a custom operator  					// we can deal with it the same as a normal invocation.  					if (expr.Operand != null)  						goto case ILCode.Call;  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[0]' typeSystem.Boolean);  						InferTypeForExpression(expr.Arguments[1]' typeSystem.Boolean);  					}  					return typeSystem.Boolean;  				case ILCode.TernaryOp:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[0]' typeSystem.Boolean);  					}  					return InferBinaryArguments(expr.Arguments[1]' expr.Arguments[2]' expectedType' forceInferChildren);  				case ILCode.NullCoalescing:  					return InferBinaryArguments(expr.Arguments[0]' expr.Arguments[1]' expectedType' forceInferChildren);  					#endregion  					#region Variable load/store  				case ILCode.Stloc:  					{  						ILVariable v = (ILVariable)expr.Operand;  						if (forceInferChildren) {  							// do not use 'expectedType' in here!  							InferTypeForExpression(expr.Arguments.Single()' v.Type);  						}  						return v.Type;  					}  				case ILCode.Ldloc:  					{  						ILVariable v = (ILVariable)expr.Operand;  						if (v.Type == null && singleLoadVariables.Contains(v)) {  							v.Type = expectedType;  						}  						return v.Type;  					}  				case ILCode.Ldloca:  					{  						ILVariable v = (ILVariable)expr.Operand;  						if (v.Type != null)  							return new ByReferenceType(v.Type);  						else  							return null;  					}  					#endregion  					#region Call / NewObj  				case ILCode.Call:  				case ILCode.Callvirt:  				case ILCode.CallGetter:  				case ILCode.CallvirtGetter:  				case ILCode.CallSetter:  				case ILCode.CallvirtSetter:  					{  						MethodReference method = (MethodReference)expr.Operand;  						if (forceInferChildren) {  							for (int i = 0; i < expr.Arguments.Count; i++) {  								if (i == 0 && method.HasThis) {  									InferTypeForExpression(expr.Arguments[0]' MakeRefIfValueType(method.DeclaringType' expr.GetPrefix(ILCode.Constrained)));  								} else {  									InferTypeForExpression(expr.Arguments[i]' SubstituteTypeArgs(method.Parameters[method.HasThis ? i - 1 : i].ParameterType' method));  								}  							}  						}  						if (expr.Code == ILCode.CallSetter || expr.Code == ILCode.CallvirtSetter) {  							return SubstituteTypeArgs(method.Parameters.Last().ParameterType' method);  						} else {  							return SubstituteTypeArgs(method.ReturnType' method);  						}  					}  				case ILCode.Newobj:  					{  						MethodReference ctor = (MethodReference)expr.Operand;  						if (forceInferChildren) {  							for (int i = 0; i < ctor.Parameters.Count; i++) {  								InferTypeForExpression(expr.Arguments[i]' SubstituteTypeArgs(ctor.Parameters[i].ParameterType' ctor));  							}  						}  						return ctor.DeclaringType;  					}  				case ILCode.InitObject:  				case ILCode.InitCollection:  					return InferTypeForExpression(expr.Arguments[0]' expectedType);  				case ILCode.InitializedObject:  					// expectedType should always be known due to the parent method call / property setter  					Debug.Assert(expectedType != null);  					return expectedType;  					#endregion  					#region Load/Store Fields  				case ILCode.Ldfld:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[0]' MakeRefIfValueType(((FieldReference)expr.Operand).DeclaringType' expr.GetPrefix(ILCode.Constrained)));  					}  					return GetFieldType((FieldReference)expr.Operand);  				case ILCode.Ldsfld:  					return GetFieldType((FieldReference)expr.Operand);  				case ILCode.Ldflda:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[0]' MakeRefIfValueType(((FieldReference)expr.Operand).DeclaringType' expr.GetPrefix(ILCode.Constrained)));  					}  					return new ByReferenceType(GetFieldType((FieldReference)expr.Operand));  				case ILCode.Ldsflda:  					return new ByReferenceType(GetFieldType((FieldReference)expr.Operand));  				case ILCode.Stfld:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[0]' MakeRefIfValueType(((FieldReference)expr.Operand).DeclaringType' expr.GetPrefix(ILCode.Constrained)));  						InferTypeForExpression(expr.Arguments[1]' GetFieldType((FieldReference)expr.Operand));  					}  					return GetFieldType((FieldReference)expr.Operand);  				case ILCode.Stsfld:  					if (forceInferChildren)  						InferTypeForExpression(expr.Arguments[0]' GetFieldType((FieldReference)expr.Operand));  					return GetFieldType((FieldReference)expr.Operand);  					#endregion  					#region Reference/Pointer instructions  				case ILCode.Ldind_Ref:  					return UnpackPointer(InferTypeForExpression(expr.Arguments[0]' null));  				case ILCode.Stind_Ref:  					if (forceInferChildren) {  						TypeReference elementType = UnpackPointer(InferTypeForExpression(expr.Arguments[0]' null));  						InferTypeForExpression(expr.Arguments[1]' elementType);  					}  					return null;  				case ILCode.Ldobj:  					{  						TypeReference type = (TypeReference)expr.Operand;  						var argType = InferTypeForExpression(expr.Arguments[0]' null);  						if (argType is PointerType || argType is ByReferenceType) {  							var elementType = ((TypeSpecification)argType).ElementType;  							int infoAmount = GetInformationAmount(elementType);  							if (infoAmount == 1 && GetInformationAmount(type) == 8) {  								// A bool can be loaded from both bytes and sbytes.  								type = elementType;  							}  							if (infoAmount >= 8 && infoAmount <= 64 && infoAmount == GetInformationAmount(type)) {  								// An integer can be loaded as another integer of the same size.  								// For integers smaller than 32 bit' the signs must match (as loading performs sign extension)  								bool? elementTypeIsSigned = IsSigned(elementType);  								bool? typeIsSigned = IsSigned(type);  								if (elementTypeIsSigned != null && typeIsSigned != null) {  									if (infoAmount >= 32 || elementTypeIsSigned == typeIsSigned)  										type = elementType;  								}  							}  						}  						if (argType is PointerType)  							InferTypeForExpression(expr.Arguments[0]' new PointerType(type));  						else  							InferTypeForExpression(expr.Arguments[0]' new ByReferenceType(type));  						return type;  					}  				case ILCode.Stobj:  					{  						TypeReference operandType = (TypeReference)expr.Operand;  						TypeReference pointerType = InferTypeForExpression(expr.Arguments[0]' new ByReferenceType(operandType));  						TypeReference elementType;  						if (pointerType is PointerType)  							elementType = ((PointerType)pointerType).ElementType;  						else if (pointerType is ByReferenceType)  							elementType = ((ByReferenceType)pointerType).ElementType;  						else  							elementType = null;  						if (elementType != null) {  							// An integer can be stored in any other integer of the same size.  							int infoAmount = GetInformationAmount(elementType);  							if (infoAmount == 1 && GetInformationAmount(operandType) == 8)  								operandType = elementType;  							else if (infoAmount == GetInformationAmount(operandType) && IsSigned(elementType) != null && IsSigned(operandType) != null)  								operandType = elementType;  						}  						if (forceInferChildren) {  							if (pointerType is PointerType)  								InferTypeForExpression(expr.Arguments[0]' new PointerType(operandType));  							else if (!IsSameType(operandType' expr.Operand as TypeReference))  								InferTypeForExpression(expr.Arguments[0]' new ByReferenceType(operandType));  							InferTypeForExpression(expr.Arguments[1]' operandType);  						}  						return operandType;  					}  				case ILCode.Initobj:  					return null;  				case ILCode.DefaultValue:  					return (TypeReference)expr.Operand;  				case ILCode.Localloc:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[0]' typeSystem.Int32);  					}  					if (expectedType is PointerType)  						return expectedType;  					else  						return typeSystem.IntPtr;  				case ILCode.Sizeof:  					return typeSystem.Int32;  				case ILCode.PostIncrement:  				case ILCode.PostIncrement_Ovf:  				case ILCode.PostIncrement_Ovf_Un:  					{  						TypeReference elementType = UnpackPointer(InferTypeForExpression(expr.Arguments[0]' null));  						if (forceInferChildren && elementType != null) {  							// Assign expected type to the child expression  							InferTypeForExpression(expr.Arguments[0]' new ByReferenceType(elementType));  						}  						return elementType;  					}  				case ILCode.Mkrefany:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[0]' (TypeReference)expr.Operand);  					}  					return typeSystem.TypedReference;  				case ILCode.Refanytype:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[0]' typeSystem.TypedReference);  					}                      return new TypeReference("System"' "RuntimeTypeHandle"' module' module.TypeSystem.CoreLibrary' true);  				case ILCode.Refanyval:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[0]' typeSystem.TypedReference);  					}  					return new ByReferenceType((TypeReference)expr.Operand);  				case ILCode.AddressOf:  					{  						TypeReference t = InferTypeForExpression(expr.Arguments[0]' UnpackPointer(expectedType));  						return t != null ? new ByReferenceType(t) : null;  					}  				case ILCode.ValueOf:  					return GetNullableTypeArgument(InferTypeForExpression(expr.Arguments[0]' CreateNullableType(expectedType)));  				case ILCode.NullableOf:  					return CreateNullableType(InferTypeForExpression(expr.Arguments[0]' GetNullableTypeArgument(expectedType)));  					#endregion  					#region Arithmetic instructions  				case ILCode.Not: // bitwise complement  				case ILCode.Neg:  					return InferTypeForExpression(expr.Arguments.Single()' expectedType);  				case ILCode.Add:  					return InferArgumentsInAddition(expr' null' expectedType);  				case ILCode.Sub:  					return InferArgumentsInSubtraction(expr' null' expectedType);  				case ILCode.Mul:  				case ILCode.Or:  				case ILCode.And:  				case ILCode.Xor:  					return InferArgumentsInBinaryOperator(expr' null' expectedType);  				case ILCode.Add_Ovf:  					return InferArgumentsInAddition(expr' true' expectedType);  				case ILCode.Sub_Ovf:  					return InferArgumentsInSubtraction(expr' true' expectedType);  				case ILCode.Mul_Ovf:  				case ILCode.Div:  				case ILCode.Rem:  					return InferArgumentsInBinaryOperator(expr' true' expectedType);  				case ILCode.Add_Ovf_Un:  					return InferArgumentsInAddition(expr' false' expectedType);  				case ILCode.Sub_Ovf_Un:  					return InferArgumentsInSubtraction(expr' false' expectedType);  				case ILCode.Mul_Ovf_Un:  				case ILCode.Div_Un:  				case ILCode.Rem_Un:  					return InferArgumentsInBinaryOperator(expr' false' expectedType);  				case ILCode.Shl:  					if (forceInferChildren)  						InferTypeForExpression(expr.Arguments[1]' typeSystem.Int32);  					if (expectedType != null && (  						expectedType.MetadataType == MetadataType.Int32 || expectedType.MetadataType == MetadataType.UInt32 ||  						expectedType.MetadataType == MetadataType.Int64 || expectedType.MetadataType == MetadataType.UInt64)  					   )  						return NumericPromotion(InferTypeForExpression(expr.Arguments[0]' expectedType));  					else  						return NumericPromotion(InferTypeForExpression(expr.Arguments[0]' null));  				case ILCode.Shr:  				case ILCode.Shr_Un:  					{  						if (forceInferChildren)  							InferTypeForExpression(expr.Arguments[1]' typeSystem.Int32);  						TypeReference type = NumericPromotion(InferTypeForExpression(expr.Arguments[0]' null));  						TypeReference expectedInputType = null;  						switch (type.MetadataType) {  							case MetadataType.Int32:  								if (expr.Code == ILCode.Shr_Un)  									expectedInputType = typeSystem.UInt32;  								break;  							case MetadataType.UInt32:  								if (expr.Code == ILCode.Shr)  									expectedInputType = typeSystem.Int32;  								break;  							case MetadataType.Int64:  								if (expr.Code == ILCode.Shr_Un)  									expectedInputType = typeSystem.UInt64;  								break;  							case MetadataType.UInt64:  								if (expr.Code == ILCode.Shr)  									expectedInputType = typeSystem.UInt64;  								break;  						}  						if (expectedInputType != null) {  							InferTypeForExpression(expr.Arguments[0]' expectedInputType);  							return expectedInputType;  						} else {  							return type;  						}  					}  				case ILCode.CompoundAssignment:  					{  						var op = expr.Arguments[0];  						if (op.Code == ILCode.NullableOf) op = op.Arguments[0].Arguments[0];  						var varType = InferTypeForExpression(op.Arguments[0]' null);  						if (forceInferChildren) {  							InferTypeForExpression(expr.Arguments[0]' varType);  						}  						return varType;  					}  					#endregion  					#region Constant loading instructions  				case ILCode.Ldnull:  					return typeSystem.Object;  				case ILCode.Ldstr:  					return typeSystem.String;  				case ILCode.Ldftn:  				case ILCode.Ldvirtftn:  					return typeSystem.IntPtr;  				case ILCode.Ldc_I4:  					if (IsBoolean(expectedType) && ((int)expr.Operand == 0 || (int)expr.Operand == 1))  						return typeSystem.Boolean;  					if (expectedType is PointerType && (int)expr.Operand == 0)  						return expectedType;  					if (IsIntegerOrEnum(expectedType) && OperandFitsInType(expectedType' (int)expr.Operand))  						return expectedType;  					else  						return typeSystem.Int32;  				case ILCode.Ldc_I8:  					if (expectedType is PointerType && (long)expr.Operand == 0)  						return expectedType;  					if (IsIntegerOrEnum(expectedType) && GetInformationAmount(expectedType) >= NativeInt)  						return expectedType;  					else  						return typeSystem.Int64;  				case ILCode.Ldc_R4:  					return typeSystem.Single;  				case ILCode.Ldc_R8:  					return typeSystem.Double;  				case ILCode.Ldc_Decimal:                      return new TypeReference("System"' "Decimal"' module' module.TypeSystem.CoreLibrary' true);  				case ILCode.Ldtoken:  					if (expr.Operand is TypeReference)  						return new TypeReference("System"' "RuntimeTypeHandle"' module' module.TypeSystem.CoreLibrary' true);  					else if (expr.Operand is FieldReference)                          return new TypeReference("System"' "RuntimeFieldHandle"' module' module.TypeSystem.CoreLibrary' true);  					else                          return new TypeReference("System"' "RuntimeMethodHandle"' module' module.TypeSystem.CoreLibrary' true);  				case ILCode.Arglist:                      return new TypeReference("System"' "RuntimeArgumentHandle"' module' module.TypeSystem.CoreLibrary' true);  					#endregion  					#region Array instructions  				case ILCode.Newarr:  					if (forceInferChildren) {  						var lengthType = InferTypeForExpression(expr.Arguments.Single()' null);  						if (lengthType == typeSystem.IntPtr) {  							lengthType = typeSystem.Int64;  						} else if (lengthType == typeSystem.UIntPtr) {  							lengthType = typeSystem.UInt64;  						} else if (lengthType != typeSystem.UInt32 && lengthType != typeSystem.Int64 && lengthType != typeSystem.UInt64) {  							lengthType = typeSystem.Int32;  						}  						if (forceInferChildren) {  							InferTypeForExpression(expr.Arguments.Single()' lengthType);  						}  					}  					return new ArrayType((TypeReference)expr.Operand);  				case ILCode.InitArray:  					var operandAsArrayType = (ArrayType)expr.Operand;  					if (forceInferChildren)  					{  						foreach (ILExpression arg in expr.Arguments)  							InferTypeForExpression(arg' operandAsArrayType.ElementType);  					}  					return operandAsArrayType;  				case ILCode.Ldlen:  					return typeSystem.Int32;  				case ILCode.Ldelem_U1:  				case ILCode.Ldelem_U2:  				case ILCode.Ldelem_U4:  				case ILCode.Ldelem_I1:  				case ILCode.Ldelem_I2:  				case ILCode.Ldelem_I4:  				case ILCode.Ldelem_I8:  				case ILCode.Ldelem_R4:  				case ILCode.Ldelem_R8:  				case ILCode.Ldelem_I:  				case ILCode.Ldelem_Ref:  					{  						ArrayType arrayType = InferTypeForExpression(expr.Arguments[0]' null) as ArrayType;  						if (forceInferChildren) {  							InferTypeForExpression(expr.Arguments[1]' typeSystem.Int32);  						}  						return arrayType != null ? arrayType.ElementType : null;  					}  				case ILCode.Ldelem_Any:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[1]' typeSystem.Int32);  					}  					return (TypeReference)expr.Operand;  				case ILCode.Ldelema:  					{  						ArrayType arrayType = InferTypeForExpression(expr.Arguments[0]' null) as ArrayType;  						if (forceInferChildren)  							InferTypeForExpression(expr.Arguments[1]' typeSystem.Int32);  						return arrayType != null ? new ByReferenceType(arrayType.ElementType) : null;  					}  				case ILCode.Stelem_I:  				case ILCode.Stelem_I1:  				case ILCode.Stelem_I2:  				case ILCode.Stelem_I4:  				case ILCode.Stelem_I8:  				case ILCode.Stelem_R4:  				case ILCode.Stelem_R8:  				case ILCode.Stelem_Ref:  				case ILCode.Stelem_Any:  					{  						ArrayType arrayType = InferTypeForExpression(expr.Arguments[0]' null) as ArrayType;  						if (forceInferChildren) {  							InferTypeForExpression(expr.Arguments[1]' typeSystem.Int32);  							if (arrayType != null) {  								InferTypeForExpression(expr.Arguments[2]' arrayType.ElementType);  							}  						}  						return arrayType != null ? arrayType.ElementType : null;  					}  					#endregion  					#region Conversion instructions  				case ILCode.Conv_I1:  				case ILCode.Conv_Ovf_I1:  				case ILCode.Conv_Ovf_I1_Un:  					return HandleConversion(8' true' expr.Arguments[0]' expectedType' typeSystem.SByte);  				case ILCode.Conv_I2:  				case ILCode.Conv_Ovf_I2:  				case ILCode.Conv_Ovf_I2_Un:  					return HandleConversion(16' true' expr.Arguments[0]' expectedType' typeSystem.Int16);  				case ILCode.Conv_I4:  				case ILCode.Conv_Ovf_I4:  				case ILCode.Conv_Ovf_I4_Un:  					return HandleConversion(32' true' expr.Arguments[0]' expectedType' typeSystem.Int32);  				case ILCode.Conv_I8:  				case ILCode.Conv_Ovf_I8:  				case ILCode.Conv_Ovf_I8_Un:  					return HandleConversion(64' true' expr.Arguments[0]' expectedType' typeSystem.Int64);  				case ILCode.Conv_U1:  				case ILCode.Conv_Ovf_U1:  				case ILCode.Conv_Ovf_U1_Un:  					return HandleConversion(8' false' expr.Arguments[0]' expectedType' typeSystem.Byte);  				case ILCode.Conv_U2:  				case ILCode.Conv_Ovf_U2:  				case ILCode.Conv_Ovf_U2_Un:  					return HandleConversion(16' false' expr.Arguments[0]' expectedType' typeSystem.UInt16);  				case ILCode.Conv_U4:  				case ILCode.Conv_Ovf_U4:  				case ILCode.Conv_Ovf_U4_Un:  					return HandleConversion(32' false' expr.Arguments[0]' expectedType' typeSystem.UInt32);  				case ILCode.Conv_U8:  				case ILCode.Conv_Ovf_U8:  				case ILCode.Conv_Ovf_U8_Un:  					return HandleConversion(64' false' expr.Arguments[0]' expectedType' typeSystem.UInt64);  				case ILCode.Conv_I:  				case ILCode.Conv_Ovf_I:  				case ILCode.Conv_Ovf_I_Un:  					return HandleConversion(NativeInt' true' expr.Arguments[0]' expectedType' typeSystem.IntPtr);  				case ILCode.Conv_U:  				case ILCode.Conv_Ovf_U:  				case ILCode.Conv_Ovf_U_Un:  					return HandleConversion(NativeInt' false' expr.Arguments[0]' expectedType' typeSystem.UIntPtr);  				case ILCode.Conv_R4:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[0]' typeSystem.Single);  					}  					return typeSystem.Single;  				case ILCode.Conv_R8:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[0]' typeSystem.Double);  					}  					return typeSystem.Double;  				case ILCode.Conv_R_Un:  					return (expectedType != null  && expectedType.MetadataType == MetadataType.Single) ? typeSystem.Single : typeSystem.Double;  				case ILCode.Castclass:  				case ILCode.Unbox_Any:  					return (TypeReference)expr.Operand;  				case ILCode.Unbox:  					return new ByReferenceType((TypeReference)expr.Operand);  				case ILCode.Isinst:  					{  						// isinst performs the equivalent of a cast only for reference types;  						// value types still need to be unboxed after an isinst instruction  						TypeReference tr = (TypeReference)expr.Operand;  						return tr.IsValueType ? typeSystem.Object : tr;  					}  				case ILCode.Box:  					{  						var tr = (TypeReference)expr.Operand;  						if (forceInferChildren)  							InferTypeForExpression(expr.Arguments.Single()' tr);  						return tr.IsValueType ? typeSystem.Object : tr;  					}  					#endregion  					#region Comparison instructions  				case ILCode.Ceq:  				case ILCode.Cne:  					if (forceInferChildren)  						InferArgumentsInBinaryOperator(expr' null' null);  					return typeSystem.Boolean;  				case ILCode.Clt:  				case ILCode.Cgt:  				case ILCode.Cle:  				case ILCode.Cge:  					if (forceInferChildren)  						InferArgumentsInBinaryOperator(expr' true' null);  					return typeSystem.Boolean;  				case ILCode.Clt_Un:  				case ILCode.Cgt_Un:  				case ILCode.Cle_Un:  				case ILCode.Cge_Un:  					if (forceInferChildren)  						InferArgumentsInBinaryOperator(expr' false' null);  					return typeSystem.Boolean;  					#endregion  					#region Branch instructions  				case ILCode.Brtrue:  					if (forceInferChildren)  						InferTypeForExpression(expr.Arguments.Single()' typeSystem.Boolean);  					return null;  				case ILCode.Br:  				case ILCode.Leave:  				case ILCode.Endfinally:  				case ILCode.Switch:  				case ILCode.Throw:  				case ILCode.Rethrow:  				case ILCode.LoopOrSwitchBreak:  				case ILCode.LoopContinue:  				case ILCode.YieldBreak:  					return null;  				case ILCode.Ret:  					if (forceInferChildren && expr.Arguments.Count == 1) {  						TypeReference returnType = context.CurrentMethod.ReturnType;  						if (context.CurrentMethodIsAsync && returnType != null && returnType.Namespace == "System.Threading.Tasks") {  							if (returnType.Name == "Task") {  								returnType = typeSystem.Void;  							} else if (returnType.Name == "Task`1" && returnType.IsGenericInstance) {  								returnType = ((GenericInstanceType)returnType).GenericArguments[0];  							}  						}  						InferTypeForExpression(expr.Arguments[0]' returnType);  					}  					return null;  				case ILCode.YieldReturn:  					if (forceInferChildren) {  						GenericInstanceType genericType = context.CurrentMethod.ReturnType as GenericInstanceType;  						if (genericType != null) { // IEnumerable<T> or IEnumerator<T>  							InferTypeForExpression(expr.Arguments[0]' genericType.GenericArguments[0]);  						} else { // non-generic IEnumerable or IEnumerator  							InferTypeForExpression(expr.Arguments[0]' typeSystem.Object);  						}  					}  					return null;  				case ILCode.Await:  					{  						TypeReference taskType = InferTypeForExpression(expr.Arguments[0]' null);  						if (taskType.Name == "Task`1" && taskType.IsGenericInstance && taskType.Namespace == "System.Threading.Tasks") {  							return ((GenericInstanceType)taskType).GenericArguments[0];  						}  						return null;  					}  					#endregion  				case ILCode.Pop:  					return null;  				case ILCode.Wrap:  				case ILCode.Dup:  					{  						var arg = expr.Arguments.Single();  						return arg.ExpectedType = InferTypeForExpression(arg' expectedType);  					}  				default:  					Debug.WriteLine("Type Inference: Can't handle " + expr.Code.GetName());  					return null;  			}
Magic Number,Custom.Decompiler.ILAst,TypeAnalysis,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\TypeAnalysis.cs,DoInferTypeForExpression,The following statement contains a magic number: switch (expr.Code) {  					#region Logical operators  				case ILCode.LogicNot:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments.Single()' typeSystem.Boolean);  					}  					return typeSystem.Boolean;  				case ILCode.LogicAnd:  				case ILCode.LogicOr:  					// if Operand is set the logic and/or expression is a custom operator  					// we can deal with it the same as a normal invocation.  					if (expr.Operand != null)  						goto case ILCode.Call;  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[0]' typeSystem.Boolean);  						InferTypeForExpression(expr.Arguments[1]' typeSystem.Boolean);  					}  					return typeSystem.Boolean;  				case ILCode.TernaryOp:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[0]' typeSystem.Boolean);  					}  					return InferBinaryArguments(expr.Arguments[1]' expr.Arguments[2]' expectedType' forceInferChildren);  				case ILCode.NullCoalescing:  					return InferBinaryArguments(expr.Arguments[0]' expr.Arguments[1]' expectedType' forceInferChildren);  					#endregion  					#region Variable load/store  				case ILCode.Stloc:  					{  						ILVariable v = (ILVariable)expr.Operand;  						if (forceInferChildren) {  							// do not use 'expectedType' in here!  							InferTypeForExpression(expr.Arguments.Single()' v.Type);  						}  						return v.Type;  					}  				case ILCode.Ldloc:  					{  						ILVariable v = (ILVariable)expr.Operand;  						if (v.Type == null && singleLoadVariables.Contains(v)) {  							v.Type = expectedType;  						}  						return v.Type;  					}  				case ILCode.Ldloca:  					{  						ILVariable v = (ILVariable)expr.Operand;  						if (v.Type != null)  							return new ByReferenceType(v.Type);  						else  							return null;  					}  					#endregion  					#region Call / NewObj  				case ILCode.Call:  				case ILCode.Callvirt:  				case ILCode.CallGetter:  				case ILCode.CallvirtGetter:  				case ILCode.CallSetter:  				case ILCode.CallvirtSetter:  					{  						MethodReference method = (MethodReference)expr.Operand;  						if (forceInferChildren) {  							for (int i = 0; i < expr.Arguments.Count; i++) {  								if (i == 0 && method.HasThis) {  									InferTypeForExpression(expr.Arguments[0]' MakeRefIfValueType(method.DeclaringType' expr.GetPrefix(ILCode.Constrained)));  								} else {  									InferTypeForExpression(expr.Arguments[i]' SubstituteTypeArgs(method.Parameters[method.HasThis ? i - 1 : i].ParameterType' method));  								}  							}  						}  						if (expr.Code == ILCode.CallSetter || expr.Code == ILCode.CallvirtSetter) {  							return SubstituteTypeArgs(method.Parameters.Last().ParameterType' method);  						} else {  							return SubstituteTypeArgs(method.ReturnType' method);  						}  					}  				case ILCode.Newobj:  					{  						MethodReference ctor = (MethodReference)expr.Operand;  						if (forceInferChildren) {  							for (int i = 0; i < ctor.Parameters.Count; i++) {  								InferTypeForExpression(expr.Arguments[i]' SubstituteTypeArgs(ctor.Parameters[i].ParameterType' ctor));  							}  						}  						return ctor.DeclaringType;  					}  				case ILCode.InitObject:  				case ILCode.InitCollection:  					return InferTypeForExpression(expr.Arguments[0]' expectedType);  				case ILCode.InitializedObject:  					// expectedType should always be known due to the parent method call / property setter  					Debug.Assert(expectedType != null);  					return expectedType;  					#endregion  					#region Load/Store Fields  				case ILCode.Ldfld:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[0]' MakeRefIfValueType(((FieldReference)expr.Operand).DeclaringType' expr.GetPrefix(ILCode.Constrained)));  					}  					return GetFieldType((FieldReference)expr.Operand);  				case ILCode.Ldsfld:  					return GetFieldType((FieldReference)expr.Operand);  				case ILCode.Ldflda:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[0]' MakeRefIfValueType(((FieldReference)expr.Operand).DeclaringType' expr.GetPrefix(ILCode.Constrained)));  					}  					return new ByReferenceType(GetFieldType((FieldReference)expr.Operand));  				case ILCode.Ldsflda:  					return new ByReferenceType(GetFieldType((FieldReference)expr.Operand));  				case ILCode.Stfld:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[0]' MakeRefIfValueType(((FieldReference)expr.Operand).DeclaringType' expr.GetPrefix(ILCode.Constrained)));  						InferTypeForExpression(expr.Arguments[1]' GetFieldType((FieldReference)expr.Operand));  					}  					return GetFieldType((FieldReference)expr.Operand);  				case ILCode.Stsfld:  					if (forceInferChildren)  						InferTypeForExpression(expr.Arguments[0]' GetFieldType((FieldReference)expr.Operand));  					return GetFieldType((FieldReference)expr.Operand);  					#endregion  					#region Reference/Pointer instructions  				case ILCode.Ldind_Ref:  					return UnpackPointer(InferTypeForExpression(expr.Arguments[0]' null));  				case ILCode.Stind_Ref:  					if (forceInferChildren) {  						TypeReference elementType = UnpackPointer(InferTypeForExpression(expr.Arguments[0]' null));  						InferTypeForExpression(expr.Arguments[1]' elementType);  					}  					return null;  				case ILCode.Ldobj:  					{  						TypeReference type = (TypeReference)expr.Operand;  						var argType = InferTypeForExpression(expr.Arguments[0]' null);  						if (argType is PointerType || argType is ByReferenceType) {  							var elementType = ((TypeSpecification)argType).ElementType;  							int infoAmount = GetInformationAmount(elementType);  							if (infoAmount == 1 && GetInformationAmount(type) == 8) {  								// A bool can be loaded from both bytes and sbytes.  								type = elementType;  							}  							if (infoAmount >= 8 && infoAmount <= 64 && infoAmount == GetInformationAmount(type)) {  								// An integer can be loaded as another integer of the same size.  								// For integers smaller than 32 bit' the signs must match (as loading performs sign extension)  								bool? elementTypeIsSigned = IsSigned(elementType);  								bool? typeIsSigned = IsSigned(type);  								if (elementTypeIsSigned != null && typeIsSigned != null) {  									if (infoAmount >= 32 || elementTypeIsSigned == typeIsSigned)  										type = elementType;  								}  							}  						}  						if (argType is PointerType)  							InferTypeForExpression(expr.Arguments[0]' new PointerType(type));  						else  							InferTypeForExpression(expr.Arguments[0]' new ByReferenceType(type));  						return type;  					}  				case ILCode.Stobj:  					{  						TypeReference operandType = (TypeReference)expr.Operand;  						TypeReference pointerType = InferTypeForExpression(expr.Arguments[0]' new ByReferenceType(operandType));  						TypeReference elementType;  						if (pointerType is PointerType)  							elementType = ((PointerType)pointerType).ElementType;  						else if (pointerType is ByReferenceType)  							elementType = ((ByReferenceType)pointerType).ElementType;  						else  							elementType = null;  						if (elementType != null) {  							// An integer can be stored in any other integer of the same size.  							int infoAmount = GetInformationAmount(elementType);  							if (infoAmount == 1 && GetInformationAmount(operandType) == 8)  								operandType = elementType;  							else if (infoAmount == GetInformationAmount(operandType) && IsSigned(elementType) != null && IsSigned(operandType) != null)  								operandType = elementType;  						}  						if (forceInferChildren) {  							if (pointerType is PointerType)  								InferTypeForExpression(expr.Arguments[0]' new PointerType(operandType));  							else if (!IsSameType(operandType' expr.Operand as TypeReference))  								InferTypeForExpression(expr.Arguments[0]' new ByReferenceType(operandType));  							InferTypeForExpression(expr.Arguments[1]' operandType);  						}  						return operandType;  					}  				case ILCode.Initobj:  					return null;  				case ILCode.DefaultValue:  					return (TypeReference)expr.Operand;  				case ILCode.Localloc:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[0]' typeSystem.Int32);  					}  					if (expectedType is PointerType)  						return expectedType;  					else  						return typeSystem.IntPtr;  				case ILCode.Sizeof:  					return typeSystem.Int32;  				case ILCode.PostIncrement:  				case ILCode.PostIncrement_Ovf:  				case ILCode.PostIncrement_Ovf_Un:  					{  						TypeReference elementType = UnpackPointer(InferTypeForExpression(expr.Arguments[0]' null));  						if (forceInferChildren && elementType != null) {  							// Assign expected type to the child expression  							InferTypeForExpression(expr.Arguments[0]' new ByReferenceType(elementType));  						}  						return elementType;  					}  				case ILCode.Mkrefany:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[0]' (TypeReference)expr.Operand);  					}  					return typeSystem.TypedReference;  				case ILCode.Refanytype:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[0]' typeSystem.TypedReference);  					}                      return new TypeReference("System"' "RuntimeTypeHandle"' module' module.TypeSystem.CoreLibrary' true);  				case ILCode.Refanyval:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[0]' typeSystem.TypedReference);  					}  					return new ByReferenceType((TypeReference)expr.Operand);  				case ILCode.AddressOf:  					{  						TypeReference t = InferTypeForExpression(expr.Arguments[0]' UnpackPointer(expectedType));  						return t != null ? new ByReferenceType(t) : null;  					}  				case ILCode.ValueOf:  					return GetNullableTypeArgument(InferTypeForExpression(expr.Arguments[0]' CreateNullableType(expectedType)));  				case ILCode.NullableOf:  					return CreateNullableType(InferTypeForExpression(expr.Arguments[0]' GetNullableTypeArgument(expectedType)));  					#endregion  					#region Arithmetic instructions  				case ILCode.Not: // bitwise complement  				case ILCode.Neg:  					return InferTypeForExpression(expr.Arguments.Single()' expectedType);  				case ILCode.Add:  					return InferArgumentsInAddition(expr' null' expectedType);  				case ILCode.Sub:  					return InferArgumentsInSubtraction(expr' null' expectedType);  				case ILCode.Mul:  				case ILCode.Or:  				case ILCode.And:  				case ILCode.Xor:  					return InferArgumentsInBinaryOperator(expr' null' expectedType);  				case ILCode.Add_Ovf:  					return InferArgumentsInAddition(expr' true' expectedType);  				case ILCode.Sub_Ovf:  					return InferArgumentsInSubtraction(expr' true' expectedType);  				case ILCode.Mul_Ovf:  				case ILCode.Div:  				case ILCode.Rem:  					return InferArgumentsInBinaryOperator(expr' true' expectedType);  				case ILCode.Add_Ovf_Un:  					return InferArgumentsInAddition(expr' false' expectedType);  				case ILCode.Sub_Ovf_Un:  					return InferArgumentsInSubtraction(expr' false' expectedType);  				case ILCode.Mul_Ovf_Un:  				case ILCode.Div_Un:  				case ILCode.Rem_Un:  					return InferArgumentsInBinaryOperator(expr' false' expectedType);  				case ILCode.Shl:  					if (forceInferChildren)  						InferTypeForExpression(expr.Arguments[1]' typeSystem.Int32);  					if (expectedType != null && (  						expectedType.MetadataType == MetadataType.Int32 || expectedType.MetadataType == MetadataType.UInt32 ||  						expectedType.MetadataType == MetadataType.Int64 || expectedType.MetadataType == MetadataType.UInt64)  					   )  						return NumericPromotion(InferTypeForExpression(expr.Arguments[0]' expectedType));  					else  						return NumericPromotion(InferTypeForExpression(expr.Arguments[0]' null));  				case ILCode.Shr:  				case ILCode.Shr_Un:  					{  						if (forceInferChildren)  							InferTypeForExpression(expr.Arguments[1]' typeSystem.Int32);  						TypeReference type = NumericPromotion(InferTypeForExpression(expr.Arguments[0]' null));  						TypeReference expectedInputType = null;  						switch (type.MetadataType) {  							case MetadataType.Int32:  								if (expr.Code == ILCode.Shr_Un)  									expectedInputType = typeSystem.UInt32;  								break;  							case MetadataType.UInt32:  								if (expr.Code == ILCode.Shr)  									expectedInputType = typeSystem.Int32;  								break;  							case MetadataType.Int64:  								if (expr.Code == ILCode.Shr_Un)  									expectedInputType = typeSystem.UInt64;  								break;  							case MetadataType.UInt64:  								if (expr.Code == ILCode.Shr)  									expectedInputType = typeSystem.UInt64;  								break;  						}  						if (expectedInputType != null) {  							InferTypeForExpression(expr.Arguments[0]' expectedInputType);  							return expectedInputType;  						} else {  							return type;  						}  					}  				case ILCode.CompoundAssignment:  					{  						var op = expr.Arguments[0];  						if (op.Code == ILCode.NullableOf) op = op.Arguments[0].Arguments[0];  						var varType = InferTypeForExpression(op.Arguments[0]' null);  						if (forceInferChildren) {  							InferTypeForExpression(expr.Arguments[0]' varType);  						}  						return varType;  					}  					#endregion  					#region Constant loading instructions  				case ILCode.Ldnull:  					return typeSystem.Object;  				case ILCode.Ldstr:  					return typeSystem.String;  				case ILCode.Ldftn:  				case ILCode.Ldvirtftn:  					return typeSystem.IntPtr;  				case ILCode.Ldc_I4:  					if (IsBoolean(expectedType) && ((int)expr.Operand == 0 || (int)expr.Operand == 1))  						return typeSystem.Boolean;  					if (expectedType is PointerType && (int)expr.Operand == 0)  						return expectedType;  					if (IsIntegerOrEnum(expectedType) && OperandFitsInType(expectedType' (int)expr.Operand))  						return expectedType;  					else  						return typeSystem.Int32;  				case ILCode.Ldc_I8:  					if (expectedType is PointerType && (long)expr.Operand == 0)  						return expectedType;  					if (IsIntegerOrEnum(expectedType) && GetInformationAmount(expectedType) >= NativeInt)  						return expectedType;  					else  						return typeSystem.Int64;  				case ILCode.Ldc_R4:  					return typeSystem.Single;  				case ILCode.Ldc_R8:  					return typeSystem.Double;  				case ILCode.Ldc_Decimal:                      return new TypeReference("System"' "Decimal"' module' module.TypeSystem.CoreLibrary' true);  				case ILCode.Ldtoken:  					if (expr.Operand is TypeReference)  						return new TypeReference("System"' "RuntimeTypeHandle"' module' module.TypeSystem.CoreLibrary' true);  					else if (expr.Operand is FieldReference)                          return new TypeReference("System"' "RuntimeFieldHandle"' module' module.TypeSystem.CoreLibrary' true);  					else                          return new TypeReference("System"' "RuntimeMethodHandle"' module' module.TypeSystem.CoreLibrary' true);  				case ILCode.Arglist:                      return new TypeReference("System"' "RuntimeArgumentHandle"' module' module.TypeSystem.CoreLibrary' true);  					#endregion  					#region Array instructions  				case ILCode.Newarr:  					if (forceInferChildren) {  						var lengthType = InferTypeForExpression(expr.Arguments.Single()' null);  						if (lengthType == typeSystem.IntPtr) {  							lengthType = typeSystem.Int64;  						} else if (lengthType == typeSystem.UIntPtr) {  							lengthType = typeSystem.UInt64;  						} else if (lengthType != typeSystem.UInt32 && lengthType != typeSystem.Int64 && lengthType != typeSystem.UInt64) {  							lengthType = typeSystem.Int32;  						}  						if (forceInferChildren) {  							InferTypeForExpression(expr.Arguments.Single()' lengthType);  						}  					}  					return new ArrayType((TypeReference)expr.Operand);  				case ILCode.InitArray:  					var operandAsArrayType = (ArrayType)expr.Operand;  					if (forceInferChildren)  					{  						foreach (ILExpression arg in expr.Arguments)  							InferTypeForExpression(arg' operandAsArrayType.ElementType);  					}  					return operandAsArrayType;  				case ILCode.Ldlen:  					return typeSystem.Int32;  				case ILCode.Ldelem_U1:  				case ILCode.Ldelem_U2:  				case ILCode.Ldelem_U4:  				case ILCode.Ldelem_I1:  				case ILCode.Ldelem_I2:  				case ILCode.Ldelem_I4:  				case ILCode.Ldelem_I8:  				case ILCode.Ldelem_R4:  				case ILCode.Ldelem_R8:  				case ILCode.Ldelem_I:  				case ILCode.Ldelem_Ref:  					{  						ArrayType arrayType = InferTypeForExpression(expr.Arguments[0]' null) as ArrayType;  						if (forceInferChildren) {  							InferTypeForExpression(expr.Arguments[1]' typeSystem.Int32);  						}  						return arrayType != null ? arrayType.ElementType : null;  					}  				case ILCode.Ldelem_Any:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[1]' typeSystem.Int32);  					}  					return (TypeReference)expr.Operand;  				case ILCode.Ldelema:  					{  						ArrayType arrayType = InferTypeForExpression(expr.Arguments[0]' null) as ArrayType;  						if (forceInferChildren)  							InferTypeForExpression(expr.Arguments[1]' typeSystem.Int32);  						return arrayType != null ? new ByReferenceType(arrayType.ElementType) : null;  					}  				case ILCode.Stelem_I:  				case ILCode.Stelem_I1:  				case ILCode.Stelem_I2:  				case ILCode.Stelem_I4:  				case ILCode.Stelem_I8:  				case ILCode.Stelem_R4:  				case ILCode.Stelem_R8:  				case ILCode.Stelem_Ref:  				case ILCode.Stelem_Any:  					{  						ArrayType arrayType = InferTypeForExpression(expr.Arguments[0]' null) as ArrayType;  						if (forceInferChildren) {  							InferTypeForExpression(expr.Arguments[1]' typeSystem.Int32);  							if (arrayType != null) {  								InferTypeForExpression(expr.Arguments[2]' arrayType.ElementType);  							}  						}  						return arrayType != null ? arrayType.ElementType : null;  					}  					#endregion  					#region Conversion instructions  				case ILCode.Conv_I1:  				case ILCode.Conv_Ovf_I1:  				case ILCode.Conv_Ovf_I1_Un:  					return HandleConversion(8' true' expr.Arguments[0]' expectedType' typeSystem.SByte);  				case ILCode.Conv_I2:  				case ILCode.Conv_Ovf_I2:  				case ILCode.Conv_Ovf_I2_Un:  					return HandleConversion(16' true' expr.Arguments[0]' expectedType' typeSystem.Int16);  				case ILCode.Conv_I4:  				case ILCode.Conv_Ovf_I4:  				case ILCode.Conv_Ovf_I4_Un:  					return HandleConversion(32' true' expr.Arguments[0]' expectedType' typeSystem.Int32);  				case ILCode.Conv_I8:  				case ILCode.Conv_Ovf_I8:  				case ILCode.Conv_Ovf_I8_Un:  					return HandleConversion(64' true' expr.Arguments[0]' expectedType' typeSystem.Int64);  				case ILCode.Conv_U1:  				case ILCode.Conv_Ovf_U1:  				case ILCode.Conv_Ovf_U1_Un:  					return HandleConversion(8' false' expr.Arguments[0]' expectedType' typeSystem.Byte);  				case ILCode.Conv_U2:  				case ILCode.Conv_Ovf_U2:  				case ILCode.Conv_Ovf_U2_Un:  					return HandleConversion(16' false' expr.Arguments[0]' expectedType' typeSystem.UInt16);  				case ILCode.Conv_U4:  				case ILCode.Conv_Ovf_U4:  				case ILCode.Conv_Ovf_U4_Un:  					return HandleConversion(32' false' expr.Arguments[0]' expectedType' typeSystem.UInt32);  				case ILCode.Conv_U8:  				case ILCode.Conv_Ovf_U8:  				case ILCode.Conv_Ovf_U8_Un:  					return HandleConversion(64' false' expr.Arguments[0]' expectedType' typeSystem.UInt64);  				case ILCode.Conv_I:  				case ILCode.Conv_Ovf_I:  				case ILCode.Conv_Ovf_I_Un:  					return HandleConversion(NativeInt' true' expr.Arguments[0]' expectedType' typeSystem.IntPtr);  				case ILCode.Conv_U:  				case ILCode.Conv_Ovf_U:  				case ILCode.Conv_Ovf_U_Un:  					return HandleConversion(NativeInt' false' expr.Arguments[0]' expectedType' typeSystem.UIntPtr);  				case ILCode.Conv_R4:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[0]' typeSystem.Single);  					}  					return typeSystem.Single;  				case ILCode.Conv_R8:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[0]' typeSystem.Double);  					}  					return typeSystem.Double;  				case ILCode.Conv_R_Un:  					return (expectedType != null  && expectedType.MetadataType == MetadataType.Single) ? typeSystem.Single : typeSystem.Double;  				case ILCode.Castclass:  				case ILCode.Unbox_Any:  					return (TypeReference)expr.Operand;  				case ILCode.Unbox:  					return new ByReferenceType((TypeReference)expr.Operand);  				case ILCode.Isinst:  					{  						// isinst performs the equivalent of a cast only for reference types;  						// value types still need to be unboxed after an isinst instruction  						TypeReference tr = (TypeReference)expr.Operand;  						return tr.IsValueType ? typeSystem.Object : tr;  					}  				case ILCode.Box:  					{  						var tr = (TypeReference)expr.Operand;  						if (forceInferChildren)  							InferTypeForExpression(expr.Arguments.Single()' tr);  						return tr.IsValueType ? typeSystem.Object : tr;  					}  					#endregion  					#region Comparison instructions  				case ILCode.Ceq:  				case ILCode.Cne:  					if (forceInferChildren)  						InferArgumentsInBinaryOperator(expr' null' null);  					return typeSystem.Boolean;  				case ILCode.Clt:  				case ILCode.Cgt:  				case ILCode.Cle:  				case ILCode.Cge:  					if (forceInferChildren)  						InferArgumentsInBinaryOperator(expr' true' null);  					return typeSystem.Boolean;  				case ILCode.Clt_Un:  				case ILCode.Cgt_Un:  				case ILCode.Cle_Un:  				case ILCode.Cge_Un:  					if (forceInferChildren)  						InferArgumentsInBinaryOperator(expr' false' null);  					return typeSystem.Boolean;  					#endregion  					#region Branch instructions  				case ILCode.Brtrue:  					if (forceInferChildren)  						InferTypeForExpression(expr.Arguments.Single()' typeSystem.Boolean);  					return null;  				case ILCode.Br:  				case ILCode.Leave:  				case ILCode.Endfinally:  				case ILCode.Switch:  				case ILCode.Throw:  				case ILCode.Rethrow:  				case ILCode.LoopOrSwitchBreak:  				case ILCode.LoopContinue:  				case ILCode.YieldBreak:  					return null;  				case ILCode.Ret:  					if (forceInferChildren && expr.Arguments.Count == 1) {  						TypeReference returnType = context.CurrentMethod.ReturnType;  						if (context.CurrentMethodIsAsync && returnType != null && returnType.Namespace == "System.Threading.Tasks") {  							if (returnType.Name == "Task") {  								returnType = typeSystem.Void;  							} else if (returnType.Name == "Task`1" && returnType.IsGenericInstance) {  								returnType = ((GenericInstanceType)returnType).GenericArguments[0];  							}  						}  						InferTypeForExpression(expr.Arguments[0]' returnType);  					}  					return null;  				case ILCode.YieldReturn:  					if (forceInferChildren) {  						GenericInstanceType genericType = context.CurrentMethod.ReturnType as GenericInstanceType;  						if (genericType != null) { // IEnumerable<T> or IEnumerator<T>  							InferTypeForExpression(expr.Arguments[0]' genericType.GenericArguments[0]);  						} else { // non-generic IEnumerable or IEnumerator  							InferTypeForExpression(expr.Arguments[0]' typeSystem.Object);  						}  					}  					return null;  				case ILCode.Await:  					{  						TypeReference taskType = InferTypeForExpression(expr.Arguments[0]' null);  						if (taskType.Name == "Task`1" && taskType.IsGenericInstance && taskType.Namespace == "System.Threading.Tasks") {  							return ((GenericInstanceType)taskType).GenericArguments[0];  						}  						return null;  					}  					#endregion  				case ILCode.Pop:  					return null;  				case ILCode.Wrap:  				case ILCode.Dup:  					{  						var arg = expr.Arguments.Single();  						return arg.ExpectedType = InferTypeForExpression(arg' expectedType);  					}  				default:  					Debug.WriteLine("Type Inference: Can't handle " + expr.Code.GetName());  					return null;  			}
Magic Number,Custom.Decompiler.ILAst,TypeAnalysis,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\TypeAnalysis.cs,DoInferTypeForExpression,The following statement contains a magic number: switch (expr.Code) {  					#region Logical operators  				case ILCode.LogicNot:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments.Single()' typeSystem.Boolean);  					}  					return typeSystem.Boolean;  				case ILCode.LogicAnd:  				case ILCode.LogicOr:  					// if Operand is set the logic and/or expression is a custom operator  					// we can deal with it the same as a normal invocation.  					if (expr.Operand != null)  						goto case ILCode.Call;  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[0]' typeSystem.Boolean);  						InferTypeForExpression(expr.Arguments[1]' typeSystem.Boolean);  					}  					return typeSystem.Boolean;  				case ILCode.TernaryOp:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[0]' typeSystem.Boolean);  					}  					return InferBinaryArguments(expr.Arguments[1]' expr.Arguments[2]' expectedType' forceInferChildren);  				case ILCode.NullCoalescing:  					return InferBinaryArguments(expr.Arguments[0]' expr.Arguments[1]' expectedType' forceInferChildren);  					#endregion  					#region Variable load/store  				case ILCode.Stloc:  					{  						ILVariable v = (ILVariable)expr.Operand;  						if (forceInferChildren) {  							// do not use 'expectedType' in here!  							InferTypeForExpression(expr.Arguments.Single()' v.Type);  						}  						return v.Type;  					}  				case ILCode.Ldloc:  					{  						ILVariable v = (ILVariable)expr.Operand;  						if (v.Type == null && singleLoadVariables.Contains(v)) {  							v.Type = expectedType;  						}  						return v.Type;  					}  				case ILCode.Ldloca:  					{  						ILVariable v = (ILVariable)expr.Operand;  						if (v.Type != null)  							return new ByReferenceType(v.Type);  						else  							return null;  					}  					#endregion  					#region Call / NewObj  				case ILCode.Call:  				case ILCode.Callvirt:  				case ILCode.CallGetter:  				case ILCode.CallvirtGetter:  				case ILCode.CallSetter:  				case ILCode.CallvirtSetter:  					{  						MethodReference method = (MethodReference)expr.Operand;  						if (forceInferChildren) {  							for (int i = 0; i < expr.Arguments.Count; i++) {  								if (i == 0 && method.HasThis) {  									InferTypeForExpression(expr.Arguments[0]' MakeRefIfValueType(method.DeclaringType' expr.GetPrefix(ILCode.Constrained)));  								} else {  									InferTypeForExpression(expr.Arguments[i]' SubstituteTypeArgs(method.Parameters[method.HasThis ? i - 1 : i].ParameterType' method));  								}  							}  						}  						if (expr.Code == ILCode.CallSetter || expr.Code == ILCode.CallvirtSetter) {  							return SubstituteTypeArgs(method.Parameters.Last().ParameterType' method);  						} else {  							return SubstituteTypeArgs(method.ReturnType' method);  						}  					}  				case ILCode.Newobj:  					{  						MethodReference ctor = (MethodReference)expr.Operand;  						if (forceInferChildren) {  							for (int i = 0; i < ctor.Parameters.Count; i++) {  								InferTypeForExpression(expr.Arguments[i]' SubstituteTypeArgs(ctor.Parameters[i].ParameterType' ctor));  							}  						}  						return ctor.DeclaringType;  					}  				case ILCode.InitObject:  				case ILCode.InitCollection:  					return InferTypeForExpression(expr.Arguments[0]' expectedType);  				case ILCode.InitializedObject:  					// expectedType should always be known due to the parent method call / property setter  					Debug.Assert(expectedType != null);  					return expectedType;  					#endregion  					#region Load/Store Fields  				case ILCode.Ldfld:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[0]' MakeRefIfValueType(((FieldReference)expr.Operand).DeclaringType' expr.GetPrefix(ILCode.Constrained)));  					}  					return GetFieldType((FieldReference)expr.Operand);  				case ILCode.Ldsfld:  					return GetFieldType((FieldReference)expr.Operand);  				case ILCode.Ldflda:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[0]' MakeRefIfValueType(((FieldReference)expr.Operand).DeclaringType' expr.GetPrefix(ILCode.Constrained)));  					}  					return new ByReferenceType(GetFieldType((FieldReference)expr.Operand));  				case ILCode.Ldsflda:  					return new ByReferenceType(GetFieldType((FieldReference)expr.Operand));  				case ILCode.Stfld:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[0]' MakeRefIfValueType(((FieldReference)expr.Operand).DeclaringType' expr.GetPrefix(ILCode.Constrained)));  						InferTypeForExpression(expr.Arguments[1]' GetFieldType((FieldReference)expr.Operand));  					}  					return GetFieldType((FieldReference)expr.Operand);  				case ILCode.Stsfld:  					if (forceInferChildren)  						InferTypeForExpression(expr.Arguments[0]' GetFieldType((FieldReference)expr.Operand));  					return GetFieldType((FieldReference)expr.Operand);  					#endregion  					#region Reference/Pointer instructions  				case ILCode.Ldind_Ref:  					return UnpackPointer(InferTypeForExpression(expr.Arguments[0]' null));  				case ILCode.Stind_Ref:  					if (forceInferChildren) {  						TypeReference elementType = UnpackPointer(InferTypeForExpression(expr.Arguments[0]' null));  						InferTypeForExpression(expr.Arguments[1]' elementType);  					}  					return null;  				case ILCode.Ldobj:  					{  						TypeReference type = (TypeReference)expr.Operand;  						var argType = InferTypeForExpression(expr.Arguments[0]' null);  						if (argType is PointerType || argType is ByReferenceType) {  							var elementType = ((TypeSpecification)argType).ElementType;  							int infoAmount = GetInformationAmount(elementType);  							if (infoAmount == 1 && GetInformationAmount(type) == 8) {  								// A bool can be loaded from both bytes and sbytes.  								type = elementType;  							}  							if (infoAmount >= 8 && infoAmount <= 64 && infoAmount == GetInformationAmount(type)) {  								// An integer can be loaded as another integer of the same size.  								// For integers smaller than 32 bit' the signs must match (as loading performs sign extension)  								bool? elementTypeIsSigned = IsSigned(elementType);  								bool? typeIsSigned = IsSigned(type);  								if (elementTypeIsSigned != null && typeIsSigned != null) {  									if (infoAmount >= 32 || elementTypeIsSigned == typeIsSigned)  										type = elementType;  								}  							}  						}  						if (argType is PointerType)  							InferTypeForExpression(expr.Arguments[0]' new PointerType(type));  						else  							InferTypeForExpression(expr.Arguments[0]' new ByReferenceType(type));  						return type;  					}  				case ILCode.Stobj:  					{  						TypeReference operandType = (TypeReference)expr.Operand;  						TypeReference pointerType = InferTypeForExpression(expr.Arguments[0]' new ByReferenceType(operandType));  						TypeReference elementType;  						if (pointerType is PointerType)  							elementType = ((PointerType)pointerType).ElementType;  						else if (pointerType is ByReferenceType)  							elementType = ((ByReferenceType)pointerType).ElementType;  						else  							elementType = null;  						if (elementType != null) {  							// An integer can be stored in any other integer of the same size.  							int infoAmount = GetInformationAmount(elementType);  							if (infoAmount == 1 && GetInformationAmount(operandType) == 8)  								operandType = elementType;  							else if (infoAmount == GetInformationAmount(operandType) && IsSigned(elementType) != null && IsSigned(operandType) != null)  								operandType = elementType;  						}  						if (forceInferChildren) {  							if (pointerType is PointerType)  								InferTypeForExpression(expr.Arguments[0]' new PointerType(operandType));  							else if (!IsSameType(operandType' expr.Operand as TypeReference))  								InferTypeForExpression(expr.Arguments[0]' new ByReferenceType(operandType));  							InferTypeForExpression(expr.Arguments[1]' operandType);  						}  						return operandType;  					}  				case ILCode.Initobj:  					return null;  				case ILCode.DefaultValue:  					return (TypeReference)expr.Operand;  				case ILCode.Localloc:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[0]' typeSystem.Int32);  					}  					if (expectedType is PointerType)  						return expectedType;  					else  						return typeSystem.IntPtr;  				case ILCode.Sizeof:  					return typeSystem.Int32;  				case ILCode.PostIncrement:  				case ILCode.PostIncrement_Ovf:  				case ILCode.PostIncrement_Ovf_Un:  					{  						TypeReference elementType = UnpackPointer(InferTypeForExpression(expr.Arguments[0]' null));  						if (forceInferChildren && elementType != null) {  							// Assign expected type to the child expression  							InferTypeForExpression(expr.Arguments[0]' new ByReferenceType(elementType));  						}  						return elementType;  					}  				case ILCode.Mkrefany:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[0]' (TypeReference)expr.Operand);  					}  					return typeSystem.TypedReference;  				case ILCode.Refanytype:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[0]' typeSystem.TypedReference);  					}                      return new TypeReference("System"' "RuntimeTypeHandle"' module' module.TypeSystem.CoreLibrary' true);  				case ILCode.Refanyval:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[0]' typeSystem.TypedReference);  					}  					return new ByReferenceType((TypeReference)expr.Operand);  				case ILCode.AddressOf:  					{  						TypeReference t = InferTypeForExpression(expr.Arguments[0]' UnpackPointer(expectedType));  						return t != null ? new ByReferenceType(t) : null;  					}  				case ILCode.ValueOf:  					return GetNullableTypeArgument(InferTypeForExpression(expr.Arguments[0]' CreateNullableType(expectedType)));  				case ILCode.NullableOf:  					return CreateNullableType(InferTypeForExpression(expr.Arguments[0]' GetNullableTypeArgument(expectedType)));  					#endregion  					#region Arithmetic instructions  				case ILCode.Not: // bitwise complement  				case ILCode.Neg:  					return InferTypeForExpression(expr.Arguments.Single()' expectedType);  				case ILCode.Add:  					return InferArgumentsInAddition(expr' null' expectedType);  				case ILCode.Sub:  					return InferArgumentsInSubtraction(expr' null' expectedType);  				case ILCode.Mul:  				case ILCode.Or:  				case ILCode.And:  				case ILCode.Xor:  					return InferArgumentsInBinaryOperator(expr' null' expectedType);  				case ILCode.Add_Ovf:  					return InferArgumentsInAddition(expr' true' expectedType);  				case ILCode.Sub_Ovf:  					return InferArgumentsInSubtraction(expr' true' expectedType);  				case ILCode.Mul_Ovf:  				case ILCode.Div:  				case ILCode.Rem:  					return InferArgumentsInBinaryOperator(expr' true' expectedType);  				case ILCode.Add_Ovf_Un:  					return InferArgumentsInAddition(expr' false' expectedType);  				case ILCode.Sub_Ovf_Un:  					return InferArgumentsInSubtraction(expr' false' expectedType);  				case ILCode.Mul_Ovf_Un:  				case ILCode.Div_Un:  				case ILCode.Rem_Un:  					return InferArgumentsInBinaryOperator(expr' false' expectedType);  				case ILCode.Shl:  					if (forceInferChildren)  						InferTypeForExpression(expr.Arguments[1]' typeSystem.Int32);  					if (expectedType != null && (  						expectedType.MetadataType == MetadataType.Int32 || expectedType.MetadataType == MetadataType.UInt32 ||  						expectedType.MetadataType == MetadataType.Int64 || expectedType.MetadataType == MetadataType.UInt64)  					   )  						return NumericPromotion(InferTypeForExpression(expr.Arguments[0]' expectedType));  					else  						return NumericPromotion(InferTypeForExpression(expr.Arguments[0]' null));  				case ILCode.Shr:  				case ILCode.Shr_Un:  					{  						if (forceInferChildren)  							InferTypeForExpression(expr.Arguments[1]' typeSystem.Int32);  						TypeReference type = NumericPromotion(InferTypeForExpression(expr.Arguments[0]' null));  						TypeReference expectedInputType = null;  						switch (type.MetadataType) {  							case MetadataType.Int32:  								if (expr.Code == ILCode.Shr_Un)  									expectedInputType = typeSystem.UInt32;  								break;  							case MetadataType.UInt32:  								if (expr.Code == ILCode.Shr)  									expectedInputType = typeSystem.Int32;  								break;  							case MetadataType.Int64:  								if (expr.Code == ILCode.Shr_Un)  									expectedInputType = typeSystem.UInt64;  								break;  							case MetadataType.UInt64:  								if (expr.Code == ILCode.Shr)  									expectedInputType = typeSystem.UInt64;  								break;  						}  						if (expectedInputType != null) {  							InferTypeForExpression(expr.Arguments[0]' expectedInputType);  							return expectedInputType;  						} else {  							return type;  						}  					}  				case ILCode.CompoundAssignment:  					{  						var op = expr.Arguments[0];  						if (op.Code == ILCode.NullableOf) op = op.Arguments[0].Arguments[0];  						var varType = InferTypeForExpression(op.Arguments[0]' null);  						if (forceInferChildren) {  							InferTypeForExpression(expr.Arguments[0]' varType);  						}  						return varType;  					}  					#endregion  					#region Constant loading instructions  				case ILCode.Ldnull:  					return typeSystem.Object;  				case ILCode.Ldstr:  					return typeSystem.String;  				case ILCode.Ldftn:  				case ILCode.Ldvirtftn:  					return typeSystem.IntPtr;  				case ILCode.Ldc_I4:  					if (IsBoolean(expectedType) && ((int)expr.Operand == 0 || (int)expr.Operand == 1))  						return typeSystem.Boolean;  					if (expectedType is PointerType && (int)expr.Operand == 0)  						return expectedType;  					if (IsIntegerOrEnum(expectedType) && OperandFitsInType(expectedType' (int)expr.Operand))  						return expectedType;  					else  						return typeSystem.Int32;  				case ILCode.Ldc_I8:  					if (expectedType is PointerType && (long)expr.Operand == 0)  						return expectedType;  					if (IsIntegerOrEnum(expectedType) && GetInformationAmount(expectedType) >= NativeInt)  						return expectedType;  					else  						return typeSystem.Int64;  				case ILCode.Ldc_R4:  					return typeSystem.Single;  				case ILCode.Ldc_R8:  					return typeSystem.Double;  				case ILCode.Ldc_Decimal:                      return new TypeReference("System"' "Decimal"' module' module.TypeSystem.CoreLibrary' true);  				case ILCode.Ldtoken:  					if (expr.Operand is TypeReference)  						return new TypeReference("System"' "RuntimeTypeHandle"' module' module.TypeSystem.CoreLibrary' true);  					else if (expr.Operand is FieldReference)                          return new TypeReference("System"' "RuntimeFieldHandle"' module' module.TypeSystem.CoreLibrary' true);  					else                          return new TypeReference("System"' "RuntimeMethodHandle"' module' module.TypeSystem.CoreLibrary' true);  				case ILCode.Arglist:                      return new TypeReference("System"' "RuntimeArgumentHandle"' module' module.TypeSystem.CoreLibrary' true);  					#endregion  					#region Array instructions  				case ILCode.Newarr:  					if (forceInferChildren) {  						var lengthType = InferTypeForExpression(expr.Arguments.Single()' null);  						if (lengthType == typeSystem.IntPtr) {  							lengthType = typeSystem.Int64;  						} else if (lengthType == typeSystem.UIntPtr) {  							lengthType = typeSystem.UInt64;  						} else if (lengthType != typeSystem.UInt32 && lengthType != typeSystem.Int64 && lengthType != typeSystem.UInt64) {  							lengthType = typeSystem.Int32;  						}  						if (forceInferChildren) {  							InferTypeForExpression(expr.Arguments.Single()' lengthType);  						}  					}  					return new ArrayType((TypeReference)expr.Operand);  				case ILCode.InitArray:  					var operandAsArrayType = (ArrayType)expr.Operand;  					if (forceInferChildren)  					{  						foreach (ILExpression arg in expr.Arguments)  							InferTypeForExpression(arg' operandAsArrayType.ElementType);  					}  					return operandAsArrayType;  				case ILCode.Ldlen:  					return typeSystem.Int32;  				case ILCode.Ldelem_U1:  				case ILCode.Ldelem_U2:  				case ILCode.Ldelem_U4:  				case ILCode.Ldelem_I1:  				case ILCode.Ldelem_I2:  				case ILCode.Ldelem_I4:  				case ILCode.Ldelem_I8:  				case ILCode.Ldelem_R4:  				case ILCode.Ldelem_R8:  				case ILCode.Ldelem_I:  				case ILCode.Ldelem_Ref:  					{  						ArrayType arrayType = InferTypeForExpression(expr.Arguments[0]' null) as ArrayType;  						if (forceInferChildren) {  							InferTypeForExpression(expr.Arguments[1]' typeSystem.Int32);  						}  						return arrayType != null ? arrayType.ElementType : null;  					}  				case ILCode.Ldelem_Any:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[1]' typeSystem.Int32);  					}  					return (TypeReference)expr.Operand;  				case ILCode.Ldelema:  					{  						ArrayType arrayType = InferTypeForExpression(expr.Arguments[0]' null) as ArrayType;  						if (forceInferChildren)  							InferTypeForExpression(expr.Arguments[1]' typeSystem.Int32);  						return arrayType != null ? new ByReferenceType(arrayType.ElementType) : null;  					}  				case ILCode.Stelem_I:  				case ILCode.Stelem_I1:  				case ILCode.Stelem_I2:  				case ILCode.Stelem_I4:  				case ILCode.Stelem_I8:  				case ILCode.Stelem_R4:  				case ILCode.Stelem_R8:  				case ILCode.Stelem_Ref:  				case ILCode.Stelem_Any:  					{  						ArrayType arrayType = InferTypeForExpression(expr.Arguments[0]' null) as ArrayType;  						if (forceInferChildren) {  							InferTypeForExpression(expr.Arguments[1]' typeSystem.Int32);  							if (arrayType != null) {  								InferTypeForExpression(expr.Arguments[2]' arrayType.ElementType);  							}  						}  						return arrayType != null ? arrayType.ElementType : null;  					}  					#endregion  					#region Conversion instructions  				case ILCode.Conv_I1:  				case ILCode.Conv_Ovf_I1:  				case ILCode.Conv_Ovf_I1_Un:  					return HandleConversion(8' true' expr.Arguments[0]' expectedType' typeSystem.SByte);  				case ILCode.Conv_I2:  				case ILCode.Conv_Ovf_I2:  				case ILCode.Conv_Ovf_I2_Un:  					return HandleConversion(16' true' expr.Arguments[0]' expectedType' typeSystem.Int16);  				case ILCode.Conv_I4:  				case ILCode.Conv_Ovf_I4:  				case ILCode.Conv_Ovf_I4_Un:  					return HandleConversion(32' true' expr.Arguments[0]' expectedType' typeSystem.Int32);  				case ILCode.Conv_I8:  				case ILCode.Conv_Ovf_I8:  				case ILCode.Conv_Ovf_I8_Un:  					return HandleConversion(64' true' expr.Arguments[0]' expectedType' typeSystem.Int64);  				case ILCode.Conv_U1:  				case ILCode.Conv_Ovf_U1:  				case ILCode.Conv_Ovf_U1_Un:  					return HandleConversion(8' false' expr.Arguments[0]' expectedType' typeSystem.Byte);  				case ILCode.Conv_U2:  				case ILCode.Conv_Ovf_U2:  				case ILCode.Conv_Ovf_U2_Un:  					return HandleConversion(16' false' expr.Arguments[0]' expectedType' typeSystem.UInt16);  				case ILCode.Conv_U4:  				case ILCode.Conv_Ovf_U4:  				case ILCode.Conv_Ovf_U4_Un:  					return HandleConversion(32' false' expr.Arguments[0]' expectedType' typeSystem.UInt32);  				case ILCode.Conv_U8:  				case ILCode.Conv_Ovf_U8:  				case ILCode.Conv_Ovf_U8_Un:  					return HandleConversion(64' false' expr.Arguments[0]' expectedType' typeSystem.UInt64);  				case ILCode.Conv_I:  				case ILCode.Conv_Ovf_I:  				case ILCode.Conv_Ovf_I_Un:  					return HandleConversion(NativeInt' true' expr.Arguments[0]' expectedType' typeSystem.IntPtr);  				case ILCode.Conv_U:  				case ILCode.Conv_Ovf_U:  				case ILCode.Conv_Ovf_U_Un:  					return HandleConversion(NativeInt' false' expr.Arguments[0]' expectedType' typeSystem.UIntPtr);  				case ILCode.Conv_R4:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[0]' typeSystem.Single);  					}  					return typeSystem.Single;  				case ILCode.Conv_R8:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[0]' typeSystem.Double);  					}  					return typeSystem.Double;  				case ILCode.Conv_R_Un:  					return (expectedType != null  && expectedType.MetadataType == MetadataType.Single) ? typeSystem.Single : typeSystem.Double;  				case ILCode.Castclass:  				case ILCode.Unbox_Any:  					return (TypeReference)expr.Operand;  				case ILCode.Unbox:  					return new ByReferenceType((TypeReference)expr.Operand);  				case ILCode.Isinst:  					{  						// isinst performs the equivalent of a cast only for reference types;  						// value types still need to be unboxed after an isinst instruction  						TypeReference tr = (TypeReference)expr.Operand;  						return tr.IsValueType ? typeSystem.Object : tr;  					}  				case ILCode.Box:  					{  						var tr = (TypeReference)expr.Operand;  						if (forceInferChildren)  							InferTypeForExpression(expr.Arguments.Single()' tr);  						return tr.IsValueType ? typeSystem.Object : tr;  					}  					#endregion  					#region Comparison instructions  				case ILCode.Ceq:  				case ILCode.Cne:  					if (forceInferChildren)  						InferArgumentsInBinaryOperator(expr' null' null);  					return typeSystem.Boolean;  				case ILCode.Clt:  				case ILCode.Cgt:  				case ILCode.Cle:  				case ILCode.Cge:  					if (forceInferChildren)  						InferArgumentsInBinaryOperator(expr' true' null);  					return typeSystem.Boolean;  				case ILCode.Clt_Un:  				case ILCode.Cgt_Un:  				case ILCode.Cle_Un:  				case ILCode.Cge_Un:  					if (forceInferChildren)  						InferArgumentsInBinaryOperator(expr' false' null);  					return typeSystem.Boolean;  					#endregion  					#region Branch instructions  				case ILCode.Brtrue:  					if (forceInferChildren)  						InferTypeForExpression(expr.Arguments.Single()' typeSystem.Boolean);  					return null;  				case ILCode.Br:  				case ILCode.Leave:  				case ILCode.Endfinally:  				case ILCode.Switch:  				case ILCode.Throw:  				case ILCode.Rethrow:  				case ILCode.LoopOrSwitchBreak:  				case ILCode.LoopContinue:  				case ILCode.YieldBreak:  					return null;  				case ILCode.Ret:  					if (forceInferChildren && expr.Arguments.Count == 1) {  						TypeReference returnType = context.CurrentMethod.ReturnType;  						if (context.CurrentMethodIsAsync && returnType != null && returnType.Namespace == "System.Threading.Tasks") {  							if (returnType.Name == "Task") {  								returnType = typeSystem.Void;  							} else if (returnType.Name == "Task`1" && returnType.IsGenericInstance) {  								returnType = ((GenericInstanceType)returnType).GenericArguments[0];  							}  						}  						InferTypeForExpression(expr.Arguments[0]' returnType);  					}  					return null;  				case ILCode.YieldReturn:  					if (forceInferChildren) {  						GenericInstanceType genericType = context.CurrentMethod.ReturnType as GenericInstanceType;  						if (genericType != null) { // IEnumerable<T> or IEnumerator<T>  							InferTypeForExpression(expr.Arguments[0]' genericType.GenericArguments[0]);  						} else { // non-generic IEnumerable or IEnumerator  							InferTypeForExpression(expr.Arguments[0]' typeSystem.Object);  						}  					}  					return null;  				case ILCode.Await:  					{  						TypeReference taskType = InferTypeForExpression(expr.Arguments[0]' null);  						if (taskType.Name == "Task`1" && taskType.IsGenericInstance && taskType.Namespace == "System.Threading.Tasks") {  							return ((GenericInstanceType)taskType).GenericArguments[0];  						}  						return null;  					}  					#endregion  				case ILCode.Pop:  					return null;  				case ILCode.Wrap:  				case ILCode.Dup:  					{  						var arg = expr.Arguments.Single();  						return arg.ExpectedType = InferTypeForExpression(arg' expectedType);  					}  				default:  					Debug.WriteLine("Type Inference: Can't handle " + expr.Code.GetName());  					return null;  			}
Magic Number,Custom.Decompiler.ILAst,TypeAnalysis,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\TypeAnalysis.cs,DoInferTypeForExpression,The following statement contains a magic number: switch (expr.Code) {  					#region Logical operators  				case ILCode.LogicNot:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments.Single()' typeSystem.Boolean);  					}  					return typeSystem.Boolean;  				case ILCode.LogicAnd:  				case ILCode.LogicOr:  					// if Operand is set the logic and/or expression is a custom operator  					// we can deal with it the same as a normal invocation.  					if (expr.Operand != null)  						goto case ILCode.Call;  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[0]' typeSystem.Boolean);  						InferTypeForExpression(expr.Arguments[1]' typeSystem.Boolean);  					}  					return typeSystem.Boolean;  				case ILCode.TernaryOp:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[0]' typeSystem.Boolean);  					}  					return InferBinaryArguments(expr.Arguments[1]' expr.Arguments[2]' expectedType' forceInferChildren);  				case ILCode.NullCoalescing:  					return InferBinaryArguments(expr.Arguments[0]' expr.Arguments[1]' expectedType' forceInferChildren);  					#endregion  					#region Variable load/store  				case ILCode.Stloc:  					{  						ILVariable v = (ILVariable)expr.Operand;  						if (forceInferChildren) {  							// do not use 'expectedType' in here!  							InferTypeForExpression(expr.Arguments.Single()' v.Type);  						}  						return v.Type;  					}  				case ILCode.Ldloc:  					{  						ILVariable v = (ILVariable)expr.Operand;  						if (v.Type == null && singleLoadVariables.Contains(v)) {  							v.Type = expectedType;  						}  						return v.Type;  					}  				case ILCode.Ldloca:  					{  						ILVariable v = (ILVariable)expr.Operand;  						if (v.Type != null)  							return new ByReferenceType(v.Type);  						else  							return null;  					}  					#endregion  					#region Call / NewObj  				case ILCode.Call:  				case ILCode.Callvirt:  				case ILCode.CallGetter:  				case ILCode.CallvirtGetter:  				case ILCode.CallSetter:  				case ILCode.CallvirtSetter:  					{  						MethodReference method = (MethodReference)expr.Operand;  						if (forceInferChildren) {  							for (int i = 0; i < expr.Arguments.Count; i++) {  								if (i == 0 && method.HasThis) {  									InferTypeForExpression(expr.Arguments[0]' MakeRefIfValueType(method.DeclaringType' expr.GetPrefix(ILCode.Constrained)));  								} else {  									InferTypeForExpression(expr.Arguments[i]' SubstituteTypeArgs(method.Parameters[method.HasThis ? i - 1 : i].ParameterType' method));  								}  							}  						}  						if (expr.Code == ILCode.CallSetter || expr.Code == ILCode.CallvirtSetter) {  							return SubstituteTypeArgs(method.Parameters.Last().ParameterType' method);  						} else {  							return SubstituteTypeArgs(method.ReturnType' method);  						}  					}  				case ILCode.Newobj:  					{  						MethodReference ctor = (MethodReference)expr.Operand;  						if (forceInferChildren) {  							for (int i = 0; i < ctor.Parameters.Count; i++) {  								InferTypeForExpression(expr.Arguments[i]' SubstituteTypeArgs(ctor.Parameters[i].ParameterType' ctor));  							}  						}  						return ctor.DeclaringType;  					}  				case ILCode.InitObject:  				case ILCode.InitCollection:  					return InferTypeForExpression(expr.Arguments[0]' expectedType);  				case ILCode.InitializedObject:  					// expectedType should always be known due to the parent method call / property setter  					Debug.Assert(expectedType != null);  					return expectedType;  					#endregion  					#region Load/Store Fields  				case ILCode.Ldfld:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[0]' MakeRefIfValueType(((FieldReference)expr.Operand).DeclaringType' expr.GetPrefix(ILCode.Constrained)));  					}  					return GetFieldType((FieldReference)expr.Operand);  				case ILCode.Ldsfld:  					return GetFieldType((FieldReference)expr.Operand);  				case ILCode.Ldflda:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[0]' MakeRefIfValueType(((FieldReference)expr.Operand).DeclaringType' expr.GetPrefix(ILCode.Constrained)));  					}  					return new ByReferenceType(GetFieldType((FieldReference)expr.Operand));  				case ILCode.Ldsflda:  					return new ByReferenceType(GetFieldType((FieldReference)expr.Operand));  				case ILCode.Stfld:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[0]' MakeRefIfValueType(((FieldReference)expr.Operand).DeclaringType' expr.GetPrefix(ILCode.Constrained)));  						InferTypeForExpression(expr.Arguments[1]' GetFieldType((FieldReference)expr.Operand));  					}  					return GetFieldType((FieldReference)expr.Operand);  				case ILCode.Stsfld:  					if (forceInferChildren)  						InferTypeForExpression(expr.Arguments[0]' GetFieldType((FieldReference)expr.Operand));  					return GetFieldType((FieldReference)expr.Operand);  					#endregion  					#region Reference/Pointer instructions  				case ILCode.Ldind_Ref:  					return UnpackPointer(InferTypeForExpression(expr.Arguments[0]' null));  				case ILCode.Stind_Ref:  					if (forceInferChildren) {  						TypeReference elementType = UnpackPointer(InferTypeForExpression(expr.Arguments[0]' null));  						InferTypeForExpression(expr.Arguments[1]' elementType);  					}  					return null;  				case ILCode.Ldobj:  					{  						TypeReference type = (TypeReference)expr.Operand;  						var argType = InferTypeForExpression(expr.Arguments[0]' null);  						if (argType is PointerType || argType is ByReferenceType) {  							var elementType = ((TypeSpecification)argType).ElementType;  							int infoAmount = GetInformationAmount(elementType);  							if (infoAmount == 1 && GetInformationAmount(type) == 8) {  								// A bool can be loaded from both bytes and sbytes.  								type = elementType;  							}  							if (infoAmount >= 8 && infoAmount <= 64 && infoAmount == GetInformationAmount(type)) {  								// An integer can be loaded as another integer of the same size.  								// For integers smaller than 32 bit' the signs must match (as loading performs sign extension)  								bool? elementTypeIsSigned = IsSigned(elementType);  								bool? typeIsSigned = IsSigned(type);  								if (elementTypeIsSigned != null && typeIsSigned != null) {  									if (infoAmount >= 32 || elementTypeIsSigned == typeIsSigned)  										type = elementType;  								}  							}  						}  						if (argType is PointerType)  							InferTypeForExpression(expr.Arguments[0]' new PointerType(type));  						else  							InferTypeForExpression(expr.Arguments[0]' new ByReferenceType(type));  						return type;  					}  				case ILCode.Stobj:  					{  						TypeReference operandType = (TypeReference)expr.Operand;  						TypeReference pointerType = InferTypeForExpression(expr.Arguments[0]' new ByReferenceType(operandType));  						TypeReference elementType;  						if (pointerType is PointerType)  							elementType = ((PointerType)pointerType).ElementType;  						else if (pointerType is ByReferenceType)  							elementType = ((ByReferenceType)pointerType).ElementType;  						else  							elementType = null;  						if (elementType != null) {  							// An integer can be stored in any other integer of the same size.  							int infoAmount = GetInformationAmount(elementType);  							if (infoAmount == 1 && GetInformationAmount(operandType) == 8)  								operandType = elementType;  							else if (infoAmount == GetInformationAmount(operandType) && IsSigned(elementType) != null && IsSigned(operandType) != null)  								operandType = elementType;  						}  						if (forceInferChildren) {  							if (pointerType is PointerType)  								InferTypeForExpression(expr.Arguments[0]' new PointerType(operandType));  							else if (!IsSameType(operandType' expr.Operand as TypeReference))  								InferTypeForExpression(expr.Arguments[0]' new ByReferenceType(operandType));  							InferTypeForExpression(expr.Arguments[1]' operandType);  						}  						return operandType;  					}  				case ILCode.Initobj:  					return null;  				case ILCode.DefaultValue:  					return (TypeReference)expr.Operand;  				case ILCode.Localloc:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[0]' typeSystem.Int32);  					}  					if (expectedType is PointerType)  						return expectedType;  					else  						return typeSystem.IntPtr;  				case ILCode.Sizeof:  					return typeSystem.Int32;  				case ILCode.PostIncrement:  				case ILCode.PostIncrement_Ovf:  				case ILCode.PostIncrement_Ovf_Un:  					{  						TypeReference elementType = UnpackPointer(InferTypeForExpression(expr.Arguments[0]' null));  						if (forceInferChildren && elementType != null) {  							// Assign expected type to the child expression  							InferTypeForExpression(expr.Arguments[0]' new ByReferenceType(elementType));  						}  						return elementType;  					}  				case ILCode.Mkrefany:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[0]' (TypeReference)expr.Operand);  					}  					return typeSystem.TypedReference;  				case ILCode.Refanytype:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[0]' typeSystem.TypedReference);  					}                      return new TypeReference("System"' "RuntimeTypeHandle"' module' module.TypeSystem.CoreLibrary' true);  				case ILCode.Refanyval:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[0]' typeSystem.TypedReference);  					}  					return new ByReferenceType((TypeReference)expr.Operand);  				case ILCode.AddressOf:  					{  						TypeReference t = InferTypeForExpression(expr.Arguments[0]' UnpackPointer(expectedType));  						return t != null ? new ByReferenceType(t) : null;  					}  				case ILCode.ValueOf:  					return GetNullableTypeArgument(InferTypeForExpression(expr.Arguments[0]' CreateNullableType(expectedType)));  				case ILCode.NullableOf:  					return CreateNullableType(InferTypeForExpression(expr.Arguments[0]' GetNullableTypeArgument(expectedType)));  					#endregion  					#region Arithmetic instructions  				case ILCode.Not: // bitwise complement  				case ILCode.Neg:  					return InferTypeForExpression(expr.Arguments.Single()' expectedType);  				case ILCode.Add:  					return InferArgumentsInAddition(expr' null' expectedType);  				case ILCode.Sub:  					return InferArgumentsInSubtraction(expr' null' expectedType);  				case ILCode.Mul:  				case ILCode.Or:  				case ILCode.And:  				case ILCode.Xor:  					return InferArgumentsInBinaryOperator(expr' null' expectedType);  				case ILCode.Add_Ovf:  					return InferArgumentsInAddition(expr' true' expectedType);  				case ILCode.Sub_Ovf:  					return InferArgumentsInSubtraction(expr' true' expectedType);  				case ILCode.Mul_Ovf:  				case ILCode.Div:  				case ILCode.Rem:  					return InferArgumentsInBinaryOperator(expr' true' expectedType);  				case ILCode.Add_Ovf_Un:  					return InferArgumentsInAddition(expr' false' expectedType);  				case ILCode.Sub_Ovf_Un:  					return InferArgumentsInSubtraction(expr' false' expectedType);  				case ILCode.Mul_Ovf_Un:  				case ILCode.Div_Un:  				case ILCode.Rem_Un:  					return InferArgumentsInBinaryOperator(expr' false' expectedType);  				case ILCode.Shl:  					if (forceInferChildren)  						InferTypeForExpression(expr.Arguments[1]' typeSystem.Int32);  					if (expectedType != null && (  						expectedType.MetadataType == MetadataType.Int32 || expectedType.MetadataType == MetadataType.UInt32 ||  						expectedType.MetadataType == MetadataType.Int64 || expectedType.MetadataType == MetadataType.UInt64)  					   )  						return NumericPromotion(InferTypeForExpression(expr.Arguments[0]' expectedType));  					else  						return NumericPromotion(InferTypeForExpression(expr.Arguments[0]' null));  				case ILCode.Shr:  				case ILCode.Shr_Un:  					{  						if (forceInferChildren)  							InferTypeForExpression(expr.Arguments[1]' typeSystem.Int32);  						TypeReference type = NumericPromotion(InferTypeForExpression(expr.Arguments[0]' null));  						TypeReference expectedInputType = null;  						switch (type.MetadataType) {  							case MetadataType.Int32:  								if (expr.Code == ILCode.Shr_Un)  									expectedInputType = typeSystem.UInt32;  								break;  							case MetadataType.UInt32:  								if (expr.Code == ILCode.Shr)  									expectedInputType = typeSystem.Int32;  								break;  							case MetadataType.Int64:  								if (expr.Code == ILCode.Shr_Un)  									expectedInputType = typeSystem.UInt64;  								break;  							case MetadataType.UInt64:  								if (expr.Code == ILCode.Shr)  									expectedInputType = typeSystem.UInt64;  								break;  						}  						if (expectedInputType != null) {  							InferTypeForExpression(expr.Arguments[0]' expectedInputType);  							return expectedInputType;  						} else {  							return type;  						}  					}  				case ILCode.CompoundAssignment:  					{  						var op = expr.Arguments[0];  						if (op.Code == ILCode.NullableOf) op = op.Arguments[0].Arguments[0];  						var varType = InferTypeForExpression(op.Arguments[0]' null);  						if (forceInferChildren) {  							InferTypeForExpression(expr.Arguments[0]' varType);  						}  						return varType;  					}  					#endregion  					#region Constant loading instructions  				case ILCode.Ldnull:  					return typeSystem.Object;  				case ILCode.Ldstr:  					return typeSystem.String;  				case ILCode.Ldftn:  				case ILCode.Ldvirtftn:  					return typeSystem.IntPtr;  				case ILCode.Ldc_I4:  					if (IsBoolean(expectedType) && ((int)expr.Operand == 0 || (int)expr.Operand == 1))  						return typeSystem.Boolean;  					if (expectedType is PointerType && (int)expr.Operand == 0)  						return expectedType;  					if (IsIntegerOrEnum(expectedType) && OperandFitsInType(expectedType' (int)expr.Operand))  						return expectedType;  					else  						return typeSystem.Int32;  				case ILCode.Ldc_I8:  					if (expectedType is PointerType && (long)expr.Operand == 0)  						return expectedType;  					if (IsIntegerOrEnum(expectedType) && GetInformationAmount(expectedType) >= NativeInt)  						return expectedType;  					else  						return typeSystem.Int64;  				case ILCode.Ldc_R4:  					return typeSystem.Single;  				case ILCode.Ldc_R8:  					return typeSystem.Double;  				case ILCode.Ldc_Decimal:                      return new TypeReference("System"' "Decimal"' module' module.TypeSystem.CoreLibrary' true);  				case ILCode.Ldtoken:  					if (expr.Operand is TypeReference)  						return new TypeReference("System"' "RuntimeTypeHandle"' module' module.TypeSystem.CoreLibrary' true);  					else if (expr.Operand is FieldReference)                          return new TypeReference("System"' "RuntimeFieldHandle"' module' module.TypeSystem.CoreLibrary' true);  					else                          return new TypeReference("System"' "RuntimeMethodHandle"' module' module.TypeSystem.CoreLibrary' true);  				case ILCode.Arglist:                      return new TypeReference("System"' "RuntimeArgumentHandle"' module' module.TypeSystem.CoreLibrary' true);  					#endregion  					#region Array instructions  				case ILCode.Newarr:  					if (forceInferChildren) {  						var lengthType = InferTypeForExpression(expr.Arguments.Single()' null);  						if (lengthType == typeSystem.IntPtr) {  							lengthType = typeSystem.Int64;  						} else if (lengthType == typeSystem.UIntPtr) {  							lengthType = typeSystem.UInt64;  						} else if (lengthType != typeSystem.UInt32 && lengthType != typeSystem.Int64 && lengthType != typeSystem.UInt64) {  							lengthType = typeSystem.Int32;  						}  						if (forceInferChildren) {  							InferTypeForExpression(expr.Arguments.Single()' lengthType);  						}  					}  					return new ArrayType((TypeReference)expr.Operand);  				case ILCode.InitArray:  					var operandAsArrayType = (ArrayType)expr.Operand;  					if (forceInferChildren)  					{  						foreach (ILExpression arg in expr.Arguments)  							InferTypeForExpression(arg' operandAsArrayType.ElementType);  					}  					return operandAsArrayType;  				case ILCode.Ldlen:  					return typeSystem.Int32;  				case ILCode.Ldelem_U1:  				case ILCode.Ldelem_U2:  				case ILCode.Ldelem_U4:  				case ILCode.Ldelem_I1:  				case ILCode.Ldelem_I2:  				case ILCode.Ldelem_I4:  				case ILCode.Ldelem_I8:  				case ILCode.Ldelem_R4:  				case ILCode.Ldelem_R8:  				case ILCode.Ldelem_I:  				case ILCode.Ldelem_Ref:  					{  						ArrayType arrayType = InferTypeForExpression(expr.Arguments[0]' null) as ArrayType;  						if (forceInferChildren) {  							InferTypeForExpression(expr.Arguments[1]' typeSystem.Int32);  						}  						return arrayType != null ? arrayType.ElementType : null;  					}  				case ILCode.Ldelem_Any:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[1]' typeSystem.Int32);  					}  					return (TypeReference)expr.Operand;  				case ILCode.Ldelema:  					{  						ArrayType arrayType = InferTypeForExpression(expr.Arguments[0]' null) as ArrayType;  						if (forceInferChildren)  							InferTypeForExpression(expr.Arguments[1]' typeSystem.Int32);  						return arrayType != null ? new ByReferenceType(arrayType.ElementType) : null;  					}  				case ILCode.Stelem_I:  				case ILCode.Stelem_I1:  				case ILCode.Stelem_I2:  				case ILCode.Stelem_I4:  				case ILCode.Stelem_I8:  				case ILCode.Stelem_R4:  				case ILCode.Stelem_R8:  				case ILCode.Stelem_Ref:  				case ILCode.Stelem_Any:  					{  						ArrayType arrayType = InferTypeForExpression(expr.Arguments[0]' null) as ArrayType;  						if (forceInferChildren) {  							InferTypeForExpression(expr.Arguments[1]' typeSystem.Int32);  							if (arrayType != null) {  								InferTypeForExpression(expr.Arguments[2]' arrayType.ElementType);  							}  						}  						return arrayType != null ? arrayType.ElementType : null;  					}  					#endregion  					#region Conversion instructions  				case ILCode.Conv_I1:  				case ILCode.Conv_Ovf_I1:  				case ILCode.Conv_Ovf_I1_Un:  					return HandleConversion(8' true' expr.Arguments[0]' expectedType' typeSystem.SByte);  				case ILCode.Conv_I2:  				case ILCode.Conv_Ovf_I2:  				case ILCode.Conv_Ovf_I2_Un:  					return HandleConversion(16' true' expr.Arguments[0]' expectedType' typeSystem.Int16);  				case ILCode.Conv_I4:  				case ILCode.Conv_Ovf_I4:  				case ILCode.Conv_Ovf_I4_Un:  					return HandleConversion(32' true' expr.Arguments[0]' expectedType' typeSystem.Int32);  				case ILCode.Conv_I8:  				case ILCode.Conv_Ovf_I8:  				case ILCode.Conv_Ovf_I8_Un:  					return HandleConversion(64' true' expr.Arguments[0]' expectedType' typeSystem.Int64);  				case ILCode.Conv_U1:  				case ILCode.Conv_Ovf_U1:  				case ILCode.Conv_Ovf_U1_Un:  					return HandleConversion(8' false' expr.Arguments[0]' expectedType' typeSystem.Byte);  				case ILCode.Conv_U2:  				case ILCode.Conv_Ovf_U2:  				case ILCode.Conv_Ovf_U2_Un:  					return HandleConversion(16' false' expr.Arguments[0]' expectedType' typeSystem.UInt16);  				case ILCode.Conv_U4:  				case ILCode.Conv_Ovf_U4:  				case ILCode.Conv_Ovf_U4_Un:  					return HandleConversion(32' false' expr.Arguments[0]' expectedType' typeSystem.UInt32);  				case ILCode.Conv_U8:  				case ILCode.Conv_Ovf_U8:  				case ILCode.Conv_Ovf_U8_Un:  					return HandleConversion(64' false' expr.Arguments[0]' expectedType' typeSystem.UInt64);  				case ILCode.Conv_I:  				case ILCode.Conv_Ovf_I:  				case ILCode.Conv_Ovf_I_Un:  					return HandleConversion(NativeInt' true' expr.Arguments[0]' expectedType' typeSystem.IntPtr);  				case ILCode.Conv_U:  				case ILCode.Conv_Ovf_U:  				case ILCode.Conv_Ovf_U_Un:  					return HandleConversion(NativeInt' false' expr.Arguments[0]' expectedType' typeSystem.UIntPtr);  				case ILCode.Conv_R4:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[0]' typeSystem.Single);  					}  					return typeSystem.Single;  				case ILCode.Conv_R8:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[0]' typeSystem.Double);  					}  					return typeSystem.Double;  				case ILCode.Conv_R_Un:  					return (expectedType != null  && expectedType.MetadataType == MetadataType.Single) ? typeSystem.Single : typeSystem.Double;  				case ILCode.Castclass:  				case ILCode.Unbox_Any:  					return (TypeReference)expr.Operand;  				case ILCode.Unbox:  					return new ByReferenceType((TypeReference)expr.Operand);  				case ILCode.Isinst:  					{  						// isinst performs the equivalent of a cast only for reference types;  						// value types still need to be unboxed after an isinst instruction  						TypeReference tr = (TypeReference)expr.Operand;  						return tr.IsValueType ? typeSystem.Object : tr;  					}  				case ILCode.Box:  					{  						var tr = (TypeReference)expr.Operand;  						if (forceInferChildren)  							InferTypeForExpression(expr.Arguments.Single()' tr);  						return tr.IsValueType ? typeSystem.Object : tr;  					}  					#endregion  					#region Comparison instructions  				case ILCode.Ceq:  				case ILCode.Cne:  					if (forceInferChildren)  						InferArgumentsInBinaryOperator(expr' null' null);  					return typeSystem.Boolean;  				case ILCode.Clt:  				case ILCode.Cgt:  				case ILCode.Cle:  				case ILCode.Cge:  					if (forceInferChildren)  						InferArgumentsInBinaryOperator(expr' true' null);  					return typeSystem.Boolean;  				case ILCode.Clt_Un:  				case ILCode.Cgt_Un:  				case ILCode.Cle_Un:  				case ILCode.Cge_Un:  					if (forceInferChildren)  						InferArgumentsInBinaryOperator(expr' false' null);  					return typeSystem.Boolean;  					#endregion  					#region Branch instructions  				case ILCode.Brtrue:  					if (forceInferChildren)  						InferTypeForExpression(expr.Arguments.Single()' typeSystem.Boolean);  					return null;  				case ILCode.Br:  				case ILCode.Leave:  				case ILCode.Endfinally:  				case ILCode.Switch:  				case ILCode.Throw:  				case ILCode.Rethrow:  				case ILCode.LoopOrSwitchBreak:  				case ILCode.LoopContinue:  				case ILCode.YieldBreak:  					return null;  				case ILCode.Ret:  					if (forceInferChildren && expr.Arguments.Count == 1) {  						TypeReference returnType = context.CurrentMethod.ReturnType;  						if (context.CurrentMethodIsAsync && returnType != null && returnType.Namespace == "System.Threading.Tasks") {  							if (returnType.Name == "Task") {  								returnType = typeSystem.Void;  							} else if (returnType.Name == "Task`1" && returnType.IsGenericInstance) {  								returnType = ((GenericInstanceType)returnType).GenericArguments[0];  							}  						}  						InferTypeForExpression(expr.Arguments[0]' returnType);  					}  					return null;  				case ILCode.YieldReturn:  					if (forceInferChildren) {  						GenericInstanceType genericType = context.CurrentMethod.ReturnType as GenericInstanceType;  						if (genericType != null) { // IEnumerable<T> or IEnumerator<T>  							InferTypeForExpression(expr.Arguments[0]' genericType.GenericArguments[0]);  						} else { // non-generic IEnumerable or IEnumerator  							InferTypeForExpression(expr.Arguments[0]' typeSystem.Object);  						}  					}  					return null;  				case ILCode.Await:  					{  						TypeReference taskType = InferTypeForExpression(expr.Arguments[0]' null);  						if (taskType.Name == "Task`1" && taskType.IsGenericInstance && taskType.Namespace == "System.Threading.Tasks") {  							return ((GenericInstanceType)taskType).GenericArguments[0];  						}  						return null;  					}  					#endregion  				case ILCode.Pop:  					return null;  				case ILCode.Wrap:  				case ILCode.Dup:  					{  						var arg = expr.Arguments.Single();  						return arg.ExpectedType = InferTypeForExpression(arg' expectedType);  					}  				default:  					Debug.WriteLine("Type Inference: Can't handle " + expr.Code.GetName());  					return null;  			}
Magic Number,Custom.Decompiler.ILAst,TypeAnalysis,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\TypeAnalysis.cs,DoInferTypeForExpression,The following statement contains a magic number: switch (expr.Code) {  					#region Logical operators  				case ILCode.LogicNot:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments.Single()' typeSystem.Boolean);  					}  					return typeSystem.Boolean;  				case ILCode.LogicAnd:  				case ILCode.LogicOr:  					// if Operand is set the logic and/or expression is a custom operator  					// we can deal with it the same as a normal invocation.  					if (expr.Operand != null)  						goto case ILCode.Call;  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[0]' typeSystem.Boolean);  						InferTypeForExpression(expr.Arguments[1]' typeSystem.Boolean);  					}  					return typeSystem.Boolean;  				case ILCode.TernaryOp:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[0]' typeSystem.Boolean);  					}  					return InferBinaryArguments(expr.Arguments[1]' expr.Arguments[2]' expectedType' forceInferChildren);  				case ILCode.NullCoalescing:  					return InferBinaryArguments(expr.Arguments[0]' expr.Arguments[1]' expectedType' forceInferChildren);  					#endregion  					#region Variable load/store  				case ILCode.Stloc:  					{  						ILVariable v = (ILVariable)expr.Operand;  						if (forceInferChildren) {  							// do not use 'expectedType' in here!  							InferTypeForExpression(expr.Arguments.Single()' v.Type);  						}  						return v.Type;  					}  				case ILCode.Ldloc:  					{  						ILVariable v = (ILVariable)expr.Operand;  						if (v.Type == null && singleLoadVariables.Contains(v)) {  							v.Type = expectedType;  						}  						return v.Type;  					}  				case ILCode.Ldloca:  					{  						ILVariable v = (ILVariable)expr.Operand;  						if (v.Type != null)  							return new ByReferenceType(v.Type);  						else  							return null;  					}  					#endregion  					#region Call / NewObj  				case ILCode.Call:  				case ILCode.Callvirt:  				case ILCode.CallGetter:  				case ILCode.CallvirtGetter:  				case ILCode.CallSetter:  				case ILCode.CallvirtSetter:  					{  						MethodReference method = (MethodReference)expr.Operand;  						if (forceInferChildren) {  							for (int i = 0; i < expr.Arguments.Count; i++) {  								if (i == 0 && method.HasThis) {  									InferTypeForExpression(expr.Arguments[0]' MakeRefIfValueType(method.DeclaringType' expr.GetPrefix(ILCode.Constrained)));  								} else {  									InferTypeForExpression(expr.Arguments[i]' SubstituteTypeArgs(method.Parameters[method.HasThis ? i - 1 : i].ParameterType' method));  								}  							}  						}  						if (expr.Code == ILCode.CallSetter || expr.Code == ILCode.CallvirtSetter) {  							return SubstituteTypeArgs(method.Parameters.Last().ParameterType' method);  						} else {  							return SubstituteTypeArgs(method.ReturnType' method);  						}  					}  				case ILCode.Newobj:  					{  						MethodReference ctor = (MethodReference)expr.Operand;  						if (forceInferChildren) {  							for (int i = 0; i < ctor.Parameters.Count; i++) {  								InferTypeForExpression(expr.Arguments[i]' SubstituteTypeArgs(ctor.Parameters[i].ParameterType' ctor));  							}  						}  						return ctor.DeclaringType;  					}  				case ILCode.InitObject:  				case ILCode.InitCollection:  					return InferTypeForExpression(expr.Arguments[0]' expectedType);  				case ILCode.InitializedObject:  					// expectedType should always be known due to the parent method call / property setter  					Debug.Assert(expectedType != null);  					return expectedType;  					#endregion  					#region Load/Store Fields  				case ILCode.Ldfld:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[0]' MakeRefIfValueType(((FieldReference)expr.Operand).DeclaringType' expr.GetPrefix(ILCode.Constrained)));  					}  					return GetFieldType((FieldReference)expr.Operand);  				case ILCode.Ldsfld:  					return GetFieldType((FieldReference)expr.Operand);  				case ILCode.Ldflda:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[0]' MakeRefIfValueType(((FieldReference)expr.Operand).DeclaringType' expr.GetPrefix(ILCode.Constrained)));  					}  					return new ByReferenceType(GetFieldType((FieldReference)expr.Operand));  				case ILCode.Ldsflda:  					return new ByReferenceType(GetFieldType((FieldReference)expr.Operand));  				case ILCode.Stfld:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[0]' MakeRefIfValueType(((FieldReference)expr.Operand).DeclaringType' expr.GetPrefix(ILCode.Constrained)));  						InferTypeForExpression(expr.Arguments[1]' GetFieldType((FieldReference)expr.Operand));  					}  					return GetFieldType((FieldReference)expr.Operand);  				case ILCode.Stsfld:  					if (forceInferChildren)  						InferTypeForExpression(expr.Arguments[0]' GetFieldType((FieldReference)expr.Operand));  					return GetFieldType((FieldReference)expr.Operand);  					#endregion  					#region Reference/Pointer instructions  				case ILCode.Ldind_Ref:  					return UnpackPointer(InferTypeForExpression(expr.Arguments[0]' null));  				case ILCode.Stind_Ref:  					if (forceInferChildren) {  						TypeReference elementType = UnpackPointer(InferTypeForExpression(expr.Arguments[0]' null));  						InferTypeForExpression(expr.Arguments[1]' elementType);  					}  					return null;  				case ILCode.Ldobj:  					{  						TypeReference type = (TypeReference)expr.Operand;  						var argType = InferTypeForExpression(expr.Arguments[0]' null);  						if (argType is PointerType || argType is ByReferenceType) {  							var elementType = ((TypeSpecification)argType).ElementType;  							int infoAmount = GetInformationAmount(elementType);  							if (infoAmount == 1 && GetInformationAmount(type) == 8) {  								// A bool can be loaded from both bytes and sbytes.  								type = elementType;  							}  							if (infoAmount >= 8 && infoAmount <= 64 && infoAmount == GetInformationAmount(type)) {  								// An integer can be loaded as another integer of the same size.  								// For integers smaller than 32 bit' the signs must match (as loading performs sign extension)  								bool? elementTypeIsSigned = IsSigned(elementType);  								bool? typeIsSigned = IsSigned(type);  								if (elementTypeIsSigned != null && typeIsSigned != null) {  									if (infoAmount >= 32 || elementTypeIsSigned == typeIsSigned)  										type = elementType;  								}  							}  						}  						if (argType is PointerType)  							InferTypeForExpression(expr.Arguments[0]' new PointerType(type));  						else  							InferTypeForExpression(expr.Arguments[0]' new ByReferenceType(type));  						return type;  					}  				case ILCode.Stobj:  					{  						TypeReference operandType = (TypeReference)expr.Operand;  						TypeReference pointerType = InferTypeForExpression(expr.Arguments[0]' new ByReferenceType(operandType));  						TypeReference elementType;  						if (pointerType is PointerType)  							elementType = ((PointerType)pointerType).ElementType;  						else if (pointerType is ByReferenceType)  							elementType = ((ByReferenceType)pointerType).ElementType;  						else  							elementType = null;  						if (elementType != null) {  							// An integer can be stored in any other integer of the same size.  							int infoAmount = GetInformationAmount(elementType);  							if (infoAmount == 1 && GetInformationAmount(operandType) == 8)  								operandType = elementType;  							else if (infoAmount == GetInformationAmount(operandType) && IsSigned(elementType) != null && IsSigned(operandType) != null)  								operandType = elementType;  						}  						if (forceInferChildren) {  							if (pointerType is PointerType)  								InferTypeForExpression(expr.Arguments[0]' new PointerType(operandType));  							else if (!IsSameType(operandType' expr.Operand as TypeReference))  								InferTypeForExpression(expr.Arguments[0]' new ByReferenceType(operandType));  							InferTypeForExpression(expr.Arguments[1]' operandType);  						}  						return operandType;  					}  				case ILCode.Initobj:  					return null;  				case ILCode.DefaultValue:  					return (TypeReference)expr.Operand;  				case ILCode.Localloc:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[0]' typeSystem.Int32);  					}  					if (expectedType is PointerType)  						return expectedType;  					else  						return typeSystem.IntPtr;  				case ILCode.Sizeof:  					return typeSystem.Int32;  				case ILCode.PostIncrement:  				case ILCode.PostIncrement_Ovf:  				case ILCode.PostIncrement_Ovf_Un:  					{  						TypeReference elementType = UnpackPointer(InferTypeForExpression(expr.Arguments[0]' null));  						if (forceInferChildren && elementType != null) {  							// Assign expected type to the child expression  							InferTypeForExpression(expr.Arguments[0]' new ByReferenceType(elementType));  						}  						return elementType;  					}  				case ILCode.Mkrefany:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[0]' (TypeReference)expr.Operand);  					}  					return typeSystem.TypedReference;  				case ILCode.Refanytype:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[0]' typeSystem.TypedReference);  					}                      return new TypeReference("System"' "RuntimeTypeHandle"' module' module.TypeSystem.CoreLibrary' true);  				case ILCode.Refanyval:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[0]' typeSystem.TypedReference);  					}  					return new ByReferenceType((TypeReference)expr.Operand);  				case ILCode.AddressOf:  					{  						TypeReference t = InferTypeForExpression(expr.Arguments[0]' UnpackPointer(expectedType));  						return t != null ? new ByReferenceType(t) : null;  					}  				case ILCode.ValueOf:  					return GetNullableTypeArgument(InferTypeForExpression(expr.Arguments[0]' CreateNullableType(expectedType)));  				case ILCode.NullableOf:  					return CreateNullableType(InferTypeForExpression(expr.Arguments[0]' GetNullableTypeArgument(expectedType)));  					#endregion  					#region Arithmetic instructions  				case ILCode.Not: // bitwise complement  				case ILCode.Neg:  					return InferTypeForExpression(expr.Arguments.Single()' expectedType);  				case ILCode.Add:  					return InferArgumentsInAddition(expr' null' expectedType);  				case ILCode.Sub:  					return InferArgumentsInSubtraction(expr' null' expectedType);  				case ILCode.Mul:  				case ILCode.Or:  				case ILCode.And:  				case ILCode.Xor:  					return InferArgumentsInBinaryOperator(expr' null' expectedType);  				case ILCode.Add_Ovf:  					return InferArgumentsInAddition(expr' true' expectedType);  				case ILCode.Sub_Ovf:  					return InferArgumentsInSubtraction(expr' true' expectedType);  				case ILCode.Mul_Ovf:  				case ILCode.Div:  				case ILCode.Rem:  					return InferArgumentsInBinaryOperator(expr' true' expectedType);  				case ILCode.Add_Ovf_Un:  					return InferArgumentsInAddition(expr' false' expectedType);  				case ILCode.Sub_Ovf_Un:  					return InferArgumentsInSubtraction(expr' false' expectedType);  				case ILCode.Mul_Ovf_Un:  				case ILCode.Div_Un:  				case ILCode.Rem_Un:  					return InferArgumentsInBinaryOperator(expr' false' expectedType);  				case ILCode.Shl:  					if (forceInferChildren)  						InferTypeForExpression(expr.Arguments[1]' typeSystem.Int32);  					if (expectedType != null && (  						expectedType.MetadataType == MetadataType.Int32 || expectedType.MetadataType == MetadataType.UInt32 ||  						expectedType.MetadataType == MetadataType.Int64 || expectedType.MetadataType == MetadataType.UInt64)  					   )  						return NumericPromotion(InferTypeForExpression(expr.Arguments[0]' expectedType));  					else  						return NumericPromotion(InferTypeForExpression(expr.Arguments[0]' null));  				case ILCode.Shr:  				case ILCode.Shr_Un:  					{  						if (forceInferChildren)  							InferTypeForExpression(expr.Arguments[1]' typeSystem.Int32);  						TypeReference type = NumericPromotion(InferTypeForExpression(expr.Arguments[0]' null));  						TypeReference expectedInputType = null;  						switch (type.MetadataType) {  							case MetadataType.Int32:  								if (expr.Code == ILCode.Shr_Un)  									expectedInputType = typeSystem.UInt32;  								break;  							case MetadataType.UInt32:  								if (expr.Code == ILCode.Shr)  									expectedInputType = typeSystem.Int32;  								break;  							case MetadataType.Int64:  								if (expr.Code == ILCode.Shr_Un)  									expectedInputType = typeSystem.UInt64;  								break;  							case MetadataType.UInt64:  								if (expr.Code == ILCode.Shr)  									expectedInputType = typeSystem.UInt64;  								break;  						}  						if (expectedInputType != null) {  							InferTypeForExpression(expr.Arguments[0]' expectedInputType);  							return expectedInputType;  						} else {  							return type;  						}  					}  				case ILCode.CompoundAssignment:  					{  						var op = expr.Arguments[0];  						if (op.Code == ILCode.NullableOf) op = op.Arguments[0].Arguments[0];  						var varType = InferTypeForExpression(op.Arguments[0]' null);  						if (forceInferChildren) {  							InferTypeForExpression(expr.Arguments[0]' varType);  						}  						return varType;  					}  					#endregion  					#region Constant loading instructions  				case ILCode.Ldnull:  					return typeSystem.Object;  				case ILCode.Ldstr:  					return typeSystem.String;  				case ILCode.Ldftn:  				case ILCode.Ldvirtftn:  					return typeSystem.IntPtr;  				case ILCode.Ldc_I4:  					if (IsBoolean(expectedType) && ((int)expr.Operand == 0 || (int)expr.Operand == 1))  						return typeSystem.Boolean;  					if (expectedType is PointerType && (int)expr.Operand == 0)  						return expectedType;  					if (IsIntegerOrEnum(expectedType) && OperandFitsInType(expectedType' (int)expr.Operand))  						return expectedType;  					else  						return typeSystem.Int32;  				case ILCode.Ldc_I8:  					if (expectedType is PointerType && (long)expr.Operand == 0)  						return expectedType;  					if (IsIntegerOrEnum(expectedType) && GetInformationAmount(expectedType) >= NativeInt)  						return expectedType;  					else  						return typeSystem.Int64;  				case ILCode.Ldc_R4:  					return typeSystem.Single;  				case ILCode.Ldc_R8:  					return typeSystem.Double;  				case ILCode.Ldc_Decimal:                      return new TypeReference("System"' "Decimal"' module' module.TypeSystem.CoreLibrary' true);  				case ILCode.Ldtoken:  					if (expr.Operand is TypeReference)  						return new TypeReference("System"' "RuntimeTypeHandle"' module' module.TypeSystem.CoreLibrary' true);  					else if (expr.Operand is FieldReference)                          return new TypeReference("System"' "RuntimeFieldHandle"' module' module.TypeSystem.CoreLibrary' true);  					else                          return new TypeReference("System"' "RuntimeMethodHandle"' module' module.TypeSystem.CoreLibrary' true);  				case ILCode.Arglist:                      return new TypeReference("System"' "RuntimeArgumentHandle"' module' module.TypeSystem.CoreLibrary' true);  					#endregion  					#region Array instructions  				case ILCode.Newarr:  					if (forceInferChildren) {  						var lengthType = InferTypeForExpression(expr.Arguments.Single()' null);  						if (lengthType == typeSystem.IntPtr) {  							lengthType = typeSystem.Int64;  						} else if (lengthType == typeSystem.UIntPtr) {  							lengthType = typeSystem.UInt64;  						} else if (lengthType != typeSystem.UInt32 && lengthType != typeSystem.Int64 && lengthType != typeSystem.UInt64) {  							lengthType = typeSystem.Int32;  						}  						if (forceInferChildren) {  							InferTypeForExpression(expr.Arguments.Single()' lengthType);  						}  					}  					return new ArrayType((TypeReference)expr.Operand);  				case ILCode.InitArray:  					var operandAsArrayType = (ArrayType)expr.Operand;  					if (forceInferChildren)  					{  						foreach (ILExpression arg in expr.Arguments)  							InferTypeForExpression(arg' operandAsArrayType.ElementType);  					}  					return operandAsArrayType;  				case ILCode.Ldlen:  					return typeSystem.Int32;  				case ILCode.Ldelem_U1:  				case ILCode.Ldelem_U2:  				case ILCode.Ldelem_U4:  				case ILCode.Ldelem_I1:  				case ILCode.Ldelem_I2:  				case ILCode.Ldelem_I4:  				case ILCode.Ldelem_I8:  				case ILCode.Ldelem_R4:  				case ILCode.Ldelem_R8:  				case ILCode.Ldelem_I:  				case ILCode.Ldelem_Ref:  					{  						ArrayType arrayType = InferTypeForExpression(expr.Arguments[0]' null) as ArrayType;  						if (forceInferChildren) {  							InferTypeForExpression(expr.Arguments[1]' typeSystem.Int32);  						}  						return arrayType != null ? arrayType.ElementType : null;  					}  				case ILCode.Ldelem_Any:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[1]' typeSystem.Int32);  					}  					return (TypeReference)expr.Operand;  				case ILCode.Ldelema:  					{  						ArrayType arrayType = InferTypeForExpression(expr.Arguments[0]' null) as ArrayType;  						if (forceInferChildren)  							InferTypeForExpression(expr.Arguments[1]' typeSystem.Int32);  						return arrayType != null ? new ByReferenceType(arrayType.ElementType) : null;  					}  				case ILCode.Stelem_I:  				case ILCode.Stelem_I1:  				case ILCode.Stelem_I2:  				case ILCode.Stelem_I4:  				case ILCode.Stelem_I8:  				case ILCode.Stelem_R4:  				case ILCode.Stelem_R8:  				case ILCode.Stelem_Ref:  				case ILCode.Stelem_Any:  					{  						ArrayType arrayType = InferTypeForExpression(expr.Arguments[0]' null) as ArrayType;  						if (forceInferChildren) {  							InferTypeForExpression(expr.Arguments[1]' typeSystem.Int32);  							if (arrayType != null) {  								InferTypeForExpression(expr.Arguments[2]' arrayType.ElementType);  							}  						}  						return arrayType != null ? arrayType.ElementType : null;  					}  					#endregion  					#region Conversion instructions  				case ILCode.Conv_I1:  				case ILCode.Conv_Ovf_I1:  				case ILCode.Conv_Ovf_I1_Un:  					return HandleConversion(8' true' expr.Arguments[0]' expectedType' typeSystem.SByte);  				case ILCode.Conv_I2:  				case ILCode.Conv_Ovf_I2:  				case ILCode.Conv_Ovf_I2_Un:  					return HandleConversion(16' true' expr.Arguments[0]' expectedType' typeSystem.Int16);  				case ILCode.Conv_I4:  				case ILCode.Conv_Ovf_I4:  				case ILCode.Conv_Ovf_I4_Un:  					return HandleConversion(32' true' expr.Arguments[0]' expectedType' typeSystem.Int32);  				case ILCode.Conv_I8:  				case ILCode.Conv_Ovf_I8:  				case ILCode.Conv_Ovf_I8_Un:  					return HandleConversion(64' true' expr.Arguments[0]' expectedType' typeSystem.Int64);  				case ILCode.Conv_U1:  				case ILCode.Conv_Ovf_U1:  				case ILCode.Conv_Ovf_U1_Un:  					return HandleConversion(8' false' expr.Arguments[0]' expectedType' typeSystem.Byte);  				case ILCode.Conv_U2:  				case ILCode.Conv_Ovf_U2:  				case ILCode.Conv_Ovf_U2_Un:  					return HandleConversion(16' false' expr.Arguments[0]' expectedType' typeSystem.UInt16);  				case ILCode.Conv_U4:  				case ILCode.Conv_Ovf_U4:  				case ILCode.Conv_Ovf_U4_Un:  					return HandleConversion(32' false' expr.Arguments[0]' expectedType' typeSystem.UInt32);  				case ILCode.Conv_U8:  				case ILCode.Conv_Ovf_U8:  				case ILCode.Conv_Ovf_U8_Un:  					return HandleConversion(64' false' expr.Arguments[0]' expectedType' typeSystem.UInt64);  				case ILCode.Conv_I:  				case ILCode.Conv_Ovf_I:  				case ILCode.Conv_Ovf_I_Un:  					return HandleConversion(NativeInt' true' expr.Arguments[0]' expectedType' typeSystem.IntPtr);  				case ILCode.Conv_U:  				case ILCode.Conv_Ovf_U:  				case ILCode.Conv_Ovf_U_Un:  					return HandleConversion(NativeInt' false' expr.Arguments[0]' expectedType' typeSystem.UIntPtr);  				case ILCode.Conv_R4:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[0]' typeSystem.Single);  					}  					return typeSystem.Single;  				case ILCode.Conv_R8:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[0]' typeSystem.Double);  					}  					return typeSystem.Double;  				case ILCode.Conv_R_Un:  					return (expectedType != null  && expectedType.MetadataType == MetadataType.Single) ? typeSystem.Single : typeSystem.Double;  				case ILCode.Castclass:  				case ILCode.Unbox_Any:  					return (TypeReference)expr.Operand;  				case ILCode.Unbox:  					return new ByReferenceType((TypeReference)expr.Operand);  				case ILCode.Isinst:  					{  						// isinst performs the equivalent of a cast only for reference types;  						// value types still need to be unboxed after an isinst instruction  						TypeReference tr = (TypeReference)expr.Operand;  						return tr.IsValueType ? typeSystem.Object : tr;  					}  				case ILCode.Box:  					{  						var tr = (TypeReference)expr.Operand;  						if (forceInferChildren)  							InferTypeForExpression(expr.Arguments.Single()' tr);  						return tr.IsValueType ? typeSystem.Object : tr;  					}  					#endregion  					#region Comparison instructions  				case ILCode.Ceq:  				case ILCode.Cne:  					if (forceInferChildren)  						InferArgumentsInBinaryOperator(expr' null' null);  					return typeSystem.Boolean;  				case ILCode.Clt:  				case ILCode.Cgt:  				case ILCode.Cle:  				case ILCode.Cge:  					if (forceInferChildren)  						InferArgumentsInBinaryOperator(expr' true' null);  					return typeSystem.Boolean;  				case ILCode.Clt_Un:  				case ILCode.Cgt_Un:  				case ILCode.Cle_Un:  				case ILCode.Cge_Un:  					if (forceInferChildren)  						InferArgumentsInBinaryOperator(expr' false' null);  					return typeSystem.Boolean;  					#endregion  					#region Branch instructions  				case ILCode.Brtrue:  					if (forceInferChildren)  						InferTypeForExpression(expr.Arguments.Single()' typeSystem.Boolean);  					return null;  				case ILCode.Br:  				case ILCode.Leave:  				case ILCode.Endfinally:  				case ILCode.Switch:  				case ILCode.Throw:  				case ILCode.Rethrow:  				case ILCode.LoopOrSwitchBreak:  				case ILCode.LoopContinue:  				case ILCode.YieldBreak:  					return null;  				case ILCode.Ret:  					if (forceInferChildren && expr.Arguments.Count == 1) {  						TypeReference returnType = context.CurrentMethod.ReturnType;  						if (context.CurrentMethodIsAsync && returnType != null && returnType.Namespace == "System.Threading.Tasks") {  							if (returnType.Name == "Task") {  								returnType = typeSystem.Void;  							} else if (returnType.Name == "Task`1" && returnType.IsGenericInstance) {  								returnType = ((GenericInstanceType)returnType).GenericArguments[0];  							}  						}  						InferTypeForExpression(expr.Arguments[0]' returnType);  					}  					return null;  				case ILCode.YieldReturn:  					if (forceInferChildren) {  						GenericInstanceType genericType = context.CurrentMethod.ReturnType as GenericInstanceType;  						if (genericType != null) { // IEnumerable<T> or IEnumerator<T>  							InferTypeForExpression(expr.Arguments[0]' genericType.GenericArguments[0]);  						} else { // non-generic IEnumerable or IEnumerator  							InferTypeForExpression(expr.Arguments[0]' typeSystem.Object);  						}  					}  					return null;  				case ILCode.Await:  					{  						TypeReference taskType = InferTypeForExpression(expr.Arguments[0]' null);  						if (taskType.Name == "Task`1" && taskType.IsGenericInstance && taskType.Namespace == "System.Threading.Tasks") {  							return ((GenericInstanceType)taskType).GenericArguments[0];  						}  						return null;  					}  					#endregion  				case ILCode.Pop:  					return null;  				case ILCode.Wrap:  				case ILCode.Dup:  					{  						var arg = expr.Arguments.Single();  						return arg.ExpectedType = InferTypeForExpression(arg' expectedType);  					}  				default:  					Debug.WriteLine("Type Inference: Can't handle " + expr.Code.GetName());  					return null;  			}
Magic Number,Custom.Decompiler.ILAst,TypeAnalysis,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\TypeAnalysis.cs,DoInferTypeForExpression,The following statement contains a magic number: switch (expr.Code) {  					#region Logical operators  				case ILCode.LogicNot:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments.Single()' typeSystem.Boolean);  					}  					return typeSystem.Boolean;  				case ILCode.LogicAnd:  				case ILCode.LogicOr:  					// if Operand is set the logic and/or expression is a custom operator  					// we can deal with it the same as a normal invocation.  					if (expr.Operand != null)  						goto case ILCode.Call;  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[0]' typeSystem.Boolean);  						InferTypeForExpression(expr.Arguments[1]' typeSystem.Boolean);  					}  					return typeSystem.Boolean;  				case ILCode.TernaryOp:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[0]' typeSystem.Boolean);  					}  					return InferBinaryArguments(expr.Arguments[1]' expr.Arguments[2]' expectedType' forceInferChildren);  				case ILCode.NullCoalescing:  					return InferBinaryArguments(expr.Arguments[0]' expr.Arguments[1]' expectedType' forceInferChildren);  					#endregion  					#region Variable load/store  				case ILCode.Stloc:  					{  						ILVariable v = (ILVariable)expr.Operand;  						if (forceInferChildren) {  							// do not use 'expectedType' in here!  							InferTypeForExpression(expr.Arguments.Single()' v.Type);  						}  						return v.Type;  					}  				case ILCode.Ldloc:  					{  						ILVariable v = (ILVariable)expr.Operand;  						if (v.Type == null && singleLoadVariables.Contains(v)) {  							v.Type = expectedType;  						}  						return v.Type;  					}  				case ILCode.Ldloca:  					{  						ILVariable v = (ILVariable)expr.Operand;  						if (v.Type != null)  							return new ByReferenceType(v.Type);  						else  							return null;  					}  					#endregion  					#region Call / NewObj  				case ILCode.Call:  				case ILCode.Callvirt:  				case ILCode.CallGetter:  				case ILCode.CallvirtGetter:  				case ILCode.CallSetter:  				case ILCode.CallvirtSetter:  					{  						MethodReference method = (MethodReference)expr.Operand;  						if (forceInferChildren) {  							for (int i = 0; i < expr.Arguments.Count; i++) {  								if (i == 0 && method.HasThis) {  									InferTypeForExpression(expr.Arguments[0]' MakeRefIfValueType(method.DeclaringType' expr.GetPrefix(ILCode.Constrained)));  								} else {  									InferTypeForExpression(expr.Arguments[i]' SubstituteTypeArgs(method.Parameters[method.HasThis ? i - 1 : i].ParameterType' method));  								}  							}  						}  						if (expr.Code == ILCode.CallSetter || expr.Code == ILCode.CallvirtSetter) {  							return SubstituteTypeArgs(method.Parameters.Last().ParameterType' method);  						} else {  							return SubstituteTypeArgs(method.ReturnType' method);  						}  					}  				case ILCode.Newobj:  					{  						MethodReference ctor = (MethodReference)expr.Operand;  						if (forceInferChildren) {  							for (int i = 0; i < ctor.Parameters.Count; i++) {  								InferTypeForExpression(expr.Arguments[i]' SubstituteTypeArgs(ctor.Parameters[i].ParameterType' ctor));  							}  						}  						return ctor.DeclaringType;  					}  				case ILCode.InitObject:  				case ILCode.InitCollection:  					return InferTypeForExpression(expr.Arguments[0]' expectedType);  				case ILCode.InitializedObject:  					// expectedType should always be known due to the parent method call / property setter  					Debug.Assert(expectedType != null);  					return expectedType;  					#endregion  					#region Load/Store Fields  				case ILCode.Ldfld:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[0]' MakeRefIfValueType(((FieldReference)expr.Operand).DeclaringType' expr.GetPrefix(ILCode.Constrained)));  					}  					return GetFieldType((FieldReference)expr.Operand);  				case ILCode.Ldsfld:  					return GetFieldType((FieldReference)expr.Operand);  				case ILCode.Ldflda:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[0]' MakeRefIfValueType(((FieldReference)expr.Operand).DeclaringType' expr.GetPrefix(ILCode.Constrained)));  					}  					return new ByReferenceType(GetFieldType((FieldReference)expr.Operand));  				case ILCode.Ldsflda:  					return new ByReferenceType(GetFieldType((FieldReference)expr.Operand));  				case ILCode.Stfld:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[0]' MakeRefIfValueType(((FieldReference)expr.Operand).DeclaringType' expr.GetPrefix(ILCode.Constrained)));  						InferTypeForExpression(expr.Arguments[1]' GetFieldType((FieldReference)expr.Operand));  					}  					return GetFieldType((FieldReference)expr.Operand);  				case ILCode.Stsfld:  					if (forceInferChildren)  						InferTypeForExpression(expr.Arguments[0]' GetFieldType((FieldReference)expr.Operand));  					return GetFieldType((FieldReference)expr.Operand);  					#endregion  					#region Reference/Pointer instructions  				case ILCode.Ldind_Ref:  					return UnpackPointer(InferTypeForExpression(expr.Arguments[0]' null));  				case ILCode.Stind_Ref:  					if (forceInferChildren) {  						TypeReference elementType = UnpackPointer(InferTypeForExpression(expr.Arguments[0]' null));  						InferTypeForExpression(expr.Arguments[1]' elementType);  					}  					return null;  				case ILCode.Ldobj:  					{  						TypeReference type = (TypeReference)expr.Operand;  						var argType = InferTypeForExpression(expr.Arguments[0]' null);  						if (argType is PointerType || argType is ByReferenceType) {  							var elementType = ((TypeSpecification)argType).ElementType;  							int infoAmount = GetInformationAmount(elementType);  							if (infoAmount == 1 && GetInformationAmount(type) == 8) {  								// A bool can be loaded from both bytes and sbytes.  								type = elementType;  							}  							if (infoAmount >= 8 && infoAmount <= 64 && infoAmount == GetInformationAmount(type)) {  								// An integer can be loaded as another integer of the same size.  								// For integers smaller than 32 bit' the signs must match (as loading performs sign extension)  								bool? elementTypeIsSigned = IsSigned(elementType);  								bool? typeIsSigned = IsSigned(type);  								if (elementTypeIsSigned != null && typeIsSigned != null) {  									if (infoAmount >= 32 || elementTypeIsSigned == typeIsSigned)  										type = elementType;  								}  							}  						}  						if (argType is PointerType)  							InferTypeForExpression(expr.Arguments[0]' new PointerType(type));  						else  							InferTypeForExpression(expr.Arguments[0]' new ByReferenceType(type));  						return type;  					}  				case ILCode.Stobj:  					{  						TypeReference operandType = (TypeReference)expr.Operand;  						TypeReference pointerType = InferTypeForExpression(expr.Arguments[0]' new ByReferenceType(operandType));  						TypeReference elementType;  						if (pointerType is PointerType)  							elementType = ((PointerType)pointerType).ElementType;  						else if (pointerType is ByReferenceType)  							elementType = ((ByReferenceType)pointerType).ElementType;  						else  							elementType = null;  						if (elementType != null) {  							// An integer can be stored in any other integer of the same size.  							int infoAmount = GetInformationAmount(elementType);  							if (infoAmount == 1 && GetInformationAmount(operandType) == 8)  								operandType = elementType;  							else if (infoAmount == GetInformationAmount(operandType) && IsSigned(elementType) != null && IsSigned(operandType) != null)  								operandType = elementType;  						}  						if (forceInferChildren) {  							if (pointerType is PointerType)  								InferTypeForExpression(expr.Arguments[0]' new PointerType(operandType));  							else if (!IsSameType(operandType' expr.Operand as TypeReference))  								InferTypeForExpression(expr.Arguments[0]' new ByReferenceType(operandType));  							InferTypeForExpression(expr.Arguments[1]' operandType);  						}  						return operandType;  					}  				case ILCode.Initobj:  					return null;  				case ILCode.DefaultValue:  					return (TypeReference)expr.Operand;  				case ILCode.Localloc:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[0]' typeSystem.Int32);  					}  					if (expectedType is PointerType)  						return expectedType;  					else  						return typeSystem.IntPtr;  				case ILCode.Sizeof:  					return typeSystem.Int32;  				case ILCode.PostIncrement:  				case ILCode.PostIncrement_Ovf:  				case ILCode.PostIncrement_Ovf_Un:  					{  						TypeReference elementType = UnpackPointer(InferTypeForExpression(expr.Arguments[0]' null));  						if (forceInferChildren && elementType != null) {  							// Assign expected type to the child expression  							InferTypeForExpression(expr.Arguments[0]' new ByReferenceType(elementType));  						}  						return elementType;  					}  				case ILCode.Mkrefany:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[0]' (TypeReference)expr.Operand);  					}  					return typeSystem.TypedReference;  				case ILCode.Refanytype:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[0]' typeSystem.TypedReference);  					}                      return new TypeReference("System"' "RuntimeTypeHandle"' module' module.TypeSystem.CoreLibrary' true);  				case ILCode.Refanyval:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[0]' typeSystem.TypedReference);  					}  					return new ByReferenceType((TypeReference)expr.Operand);  				case ILCode.AddressOf:  					{  						TypeReference t = InferTypeForExpression(expr.Arguments[0]' UnpackPointer(expectedType));  						return t != null ? new ByReferenceType(t) : null;  					}  				case ILCode.ValueOf:  					return GetNullableTypeArgument(InferTypeForExpression(expr.Arguments[0]' CreateNullableType(expectedType)));  				case ILCode.NullableOf:  					return CreateNullableType(InferTypeForExpression(expr.Arguments[0]' GetNullableTypeArgument(expectedType)));  					#endregion  					#region Arithmetic instructions  				case ILCode.Not: // bitwise complement  				case ILCode.Neg:  					return InferTypeForExpression(expr.Arguments.Single()' expectedType);  				case ILCode.Add:  					return InferArgumentsInAddition(expr' null' expectedType);  				case ILCode.Sub:  					return InferArgumentsInSubtraction(expr' null' expectedType);  				case ILCode.Mul:  				case ILCode.Or:  				case ILCode.And:  				case ILCode.Xor:  					return InferArgumentsInBinaryOperator(expr' null' expectedType);  				case ILCode.Add_Ovf:  					return InferArgumentsInAddition(expr' true' expectedType);  				case ILCode.Sub_Ovf:  					return InferArgumentsInSubtraction(expr' true' expectedType);  				case ILCode.Mul_Ovf:  				case ILCode.Div:  				case ILCode.Rem:  					return InferArgumentsInBinaryOperator(expr' true' expectedType);  				case ILCode.Add_Ovf_Un:  					return InferArgumentsInAddition(expr' false' expectedType);  				case ILCode.Sub_Ovf_Un:  					return InferArgumentsInSubtraction(expr' false' expectedType);  				case ILCode.Mul_Ovf_Un:  				case ILCode.Div_Un:  				case ILCode.Rem_Un:  					return InferArgumentsInBinaryOperator(expr' false' expectedType);  				case ILCode.Shl:  					if (forceInferChildren)  						InferTypeForExpression(expr.Arguments[1]' typeSystem.Int32);  					if (expectedType != null && (  						expectedType.MetadataType == MetadataType.Int32 || expectedType.MetadataType == MetadataType.UInt32 ||  						expectedType.MetadataType == MetadataType.Int64 || expectedType.MetadataType == MetadataType.UInt64)  					   )  						return NumericPromotion(InferTypeForExpression(expr.Arguments[0]' expectedType));  					else  						return NumericPromotion(InferTypeForExpression(expr.Arguments[0]' null));  				case ILCode.Shr:  				case ILCode.Shr_Un:  					{  						if (forceInferChildren)  							InferTypeForExpression(expr.Arguments[1]' typeSystem.Int32);  						TypeReference type = NumericPromotion(InferTypeForExpression(expr.Arguments[0]' null));  						TypeReference expectedInputType = null;  						switch (type.MetadataType) {  							case MetadataType.Int32:  								if (expr.Code == ILCode.Shr_Un)  									expectedInputType = typeSystem.UInt32;  								break;  							case MetadataType.UInt32:  								if (expr.Code == ILCode.Shr)  									expectedInputType = typeSystem.Int32;  								break;  							case MetadataType.Int64:  								if (expr.Code == ILCode.Shr_Un)  									expectedInputType = typeSystem.UInt64;  								break;  							case MetadataType.UInt64:  								if (expr.Code == ILCode.Shr)  									expectedInputType = typeSystem.UInt64;  								break;  						}  						if (expectedInputType != null) {  							InferTypeForExpression(expr.Arguments[0]' expectedInputType);  							return expectedInputType;  						} else {  							return type;  						}  					}  				case ILCode.CompoundAssignment:  					{  						var op = expr.Arguments[0];  						if (op.Code == ILCode.NullableOf) op = op.Arguments[0].Arguments[0];  						var varType = InferTypeForExpression(op.Arguments[0]' null);  						if (forceInferChildren) {  							InferTypeForExpression(expr.Arguments[0]' varType);  						}  						return varType;  					}  					#endregion  					#region Constant loading instructions  				case ILCode.Ldnull:  					return typeSystem.Object;  				case ILCode.Ldstr:  					return typeSystem.String;  				case ILCode.Ldftn:  				case ILCode.Ldvirtftn:  					return typeSystem.IntPtr;  				case ILCode.Ldc_I4:  					if (IsBoolean(expectedType) && ((int)expr.Operand == 0 || (int)expr.Operand == 1))  						return typeSystem.Boolean;  					if (expectedType is PointerType && (int)expr.Operand == 0)  						return expectedType;  					if (IsIntegerOrEnum(expectedType) && OperandFitsInType(expectedType' (int)expr.Operand))  						return expectedType;  					else  						return typeSystem.Int32;  				case ILCode.Ldc_I8:  					if (expectedType is PointerType && (long)expr.Operand == 0)  						return expectedType;  					if (IsIntegerOrEnum(expectedType) && GetInformationAmount(expectedType) >= NativeInt)  						return expectedType;  					else  						return typeSystem.Int64;  				case ILCode.Ldc_R4:  					return typeSystem.Single;  				case ILCode.Ldc_R8:  					return typeSystem.Double;  				case ILCode.Ldc_Decimal:                      return new TypeReference("System"' "Decimal"' module' module.TypeSystem.CoreLibrary' true);  				case ILCode.Ldtoken:  					if (expr.Operand is TypeReference)  						return new TypeReference("System"' "RuntimeTypeHandle"' module' module.TypeSystem.CoreLibrary' true);  					else if (expr.Operand is FieldReference)                          return new TypeReference("System"' "RuntimeFieldHandle"' module' module.TypeSystem.CoreLibrary' true);  					else                          return new TypeReference("System"' "RuntimeMethodHandle"' module' module.TypeSystem.CoreLibrary' true);  				case ILCode.Arglist:                      return new TypeReference("System"' "RuntimeArgumentHandle"' module' module.TypeSystem.CoreLibrary' true);  					#endregion  					#region Array instructions  				case ILCode.Newarr:  					if (forceInferChildren) {  						var lengthType = InferTypeForExpression(expr.Arguments.Single()' null);  						if (lengthType == typeSystem.IntPtr) {  							lengthType = typeSystem.Int64;  						} else if (lengthType == typeSystem.UIntPtr) {  							lengthType = typeSystem.UInt64;  						} else if (lengthType != typeSystem.UInt32 && lengthType != typeSystem.Int64 && lengthType != typeSystem.UInt64) {  							lengthType = typeSystem.Int32;  						}  						if (forceInferChildren) {  							InferTypeForExpression(expr.Arguments.Single()' lengthType);  						}  					}  					return new ArrayType((TypeReference)expr.Operand);  				case ILCode.InitArray:  					var operandAsArrayType = (ArrayType)expr.Operand;  					if (forceInferChildren)  					{  						foreach (ILExpression arg in expr.Arguments)  							InferTypeForExpression(arg' operandAsArrayType.ElementType);  					}  					return operandAsArrayType;  				case ILCode.Ldlen:  					return typeSystem.Int32;  				case ILCode.Ldelem_U1:  				case ILCode.Ldelem_U2:  				case ILCode.Ldelem_U4:  				case ILCode.Ldelem_I1:  				case ILCode.Ldelem_I2:  				case ILCode.Ldelem_I4:  				case ILCode.Ldelem_I8:  				case ILCode.Ldelem_R4:  				case ILCode.Ldelem_R8:  				case ILCode.Ldelem_I:  				case ILCode.Ldelem_Ref:  					{  						ArrayType arrayType = InferTypeForExpression(expr.Arguments[0]' null) as ArrayType;  						if (forceInferChildren) {  							InferTypeForExpression(expr.Arguments[1]' typeSystem.Int32);  						}  						return arrayType != null ? arrayType.ElementType : null;  					}  				case ILCode.Ldelem_Any:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[1]' typeSystem.Int32);  					}  					return (TypeReference)expr.Operand;  				case ILCode.Ldelema:  					{  						ArrayType arrayType = InferTypeForExpression(expr.Arguments[0]' null) as ArrayType;  						if (forceInferChildren)  							InferTypeForExpression(expr.Arguments[1]' typeSystem.Int32);  						return arrayType != null ? new ByReferenceType(arrayType.ElementType) : null;  					}  				case ILCode.Stelem_I:  				case ILCode.Stelem_I1:  				case ILCode.Stelem_I2:  				case ILCode.Stelem_I4:  				case ILCode.Stelem_I8:  				case ILCode.Stelem_R4:  				case ILCode.Stelem_R8:  				case ILCode.Stelem_Ref:  				case ILCode.Stelem_Any:  					{  						ArrayType arrayType = InferTypeForExpression(expr.Arguments[0]' null) as ArrayType;  						if (forceInferChildren) {  							InferTypeForExpression(expr.Arguments[1]' typeSystem.Int32);  							if (arrayType != null) {  								InferTypeForExpression(expr.Arguments[2]' arrayType.ElementType);  							}  						}  						return arrayType != null ? arrayType.ElementType : null;  					}  					#endregion  					#region Conversion instructions  				case ILCode.Conv_I1:  				case ILCode.Conv_Ovf_I1:  				case ILCode.Conv_Ovf_I1_Un:  					return HandleConversion(8' true' expr.Arguments[0]' expectedType' typeSystem.SByte);  				case ILCode.Conv_I2:  				case ILCode.Conv_Ovf_I2:  				case ILCode.Conv_Ovf_I2_Un:  					return HandleConversion(16' true' expr.Arguments[0]' expectedType' typeSystem.Int16);  				case ILCode.Conv_I4:  				case ILCode.Conv_Ovf_I4:  				case ILCode.Conv_Ovf_I4_Un:  					return HandleConversion(32' true' expr.Arguments[0]' expectedType' typeSystem.Int32);  				case ILCode.Conv_I8:  				case ILCode.Conv_Ovf_I8:  				case ILCode.Conv_Ovf_I8_Un:  					return HandleConversion(64' true' expr.Arguments[0]' expectedType' typeSystem.Int64);  				case ILCode.Conv_U1:  				case ILCode.Conv_Ovf_U1:  				case ILCode.Conv_Ovf_U1_Un:  					return HandleConversion(8' false' expr.Arguments[0]' expectedType' typeSystem.Byte);  				case ILCode.Conv_U2:  				case ILCode.Conv_Ovf_U2:  				case ILCode.Conv_Ovf_U2_Un:  					return HandleConversion(16' false' expr.Arguments[0]' expectedType' typeSystem.UInt16);  				case ILCode.Conv_U4:  				case ILCode.Conv_Ovf_U4:  				case ILCode.Conv_Ovf_U4_Un:  					return HandleConversion(32' false' expr.Arguments[0]' expectedType' typeSystem.UInt32);  				case ILCode.Conv_U8:  				case ILCode.Conv_Ovf_U8:  				case ILCode.Conv_Ovf_U8_Un:  					return HandleConversion(64' false' expr.Arguments[0]' expectedType' typeSystem.UInt64);  				case ILCode.Conv_I:  				case ILCode.Conv_Ovf_I:  				case ILCode.Conv_Ovf_I_Un:  					return HandleConversion(NativeInt' true' expr.Arguments[0]' expectedType' typeSystem.IntPtr);  				case ILCode.Conv_U:  				case ILCode.Conv_Ovf_U:  				case ILCode.Conv_Ovf_U_Un:  					return HandleConversion(NativeInt' false' expr.Arguments[0]' expectedType' typeSystem.UIntPtr);  				case ILCode.Conv_R4:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[0]' typeSystem.Single);  					}  					return typeSystem.Single;  				case ILCode.Conv_R8:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[0]' typeSystem.Double);  					}  					return typeSystem.Double;  				case ILCode.Conv_R_Un:  					return (expectedType != null  && expectedType.MetadataType == MetadataType.Single) ? typeSystem.Single : typeSystem.Double;  				case ILCode.Castclass:  				case ILCode.Unbox_Any:  					return (TypeReference)expr.Operand;  				case ILCode.Unbox:  					return new ByReferenceType((TypeReference)expr.Operand);  				case ILCode.Isinst:  					{  						// isinst performs the equivalent of a cast only for reference types;  						// value types still need to be unboxed after an isinst instruction  						TypeReference tr = (TypeReference)expr.Operand;  						return tr.IsValueType ? typeSystem.Object : tr;  					}  				case ILCode.Box:  					{  						var tr = (TypeReference)expr.Operand;  						if (forceInferChildren)  							InferTypeForExpression(expr.Arguments.Single()' tr);  						return tr.IsValueType ? typeSystem.Object : tr;  					}  					#endregion  					#region Comparison instructions  				case ILCode.Ceq:  				case ILCode.Cne:  					if (forceInferChildren)  						InferArgumentsInBinaryOperator(expr' null' null);  					return typeSystem.Boolean;  				case ILCode.Clt:  				case ILCode.Cgt:  				case ILCode.Cle:  				case ILCode.Cge:  					if (forceInferChildren)  						InferArgumentsInBinaryOperator(expr' true' null);  					return typeSystem.Boolean;  				case ILCode.Clt_Un:  				case ILCode.Cgt_Un:  				case ILCode.Cle_Un:  				case ILCode.Cge_Un:  					if (forceInferChildren)  						InferArgumentsInBinaryOperator(expr' false' null);  					return typeSystem.Boolean;  					#endregion  					#region Branch instructions  				case ILCode.Brtrue:  					if (forceInferChildren)  						InferTypeForExpression(expr.Arguments.Single()' typeSystem.Boolean);  					return null;  				case ILCode.Br:  				case ILCode.Leave:  				case ILCode.Endfinally:  				case ILCode.Switch:  				case ILCode.Throw:  				case ILCode.Rethrow:  				case ILCode.LoopOrSwitchBreak:  				case ILCode.LoopContinue:  				case ILCode.YieldBreak:  					return null;  				case ILCode.Ret:  					if (forceInferChildren && expr.Arguments.Count == 1) {  						TypeReference returnType = context.CurrentMethod.ReturnType;  						if (context.CurrentMethodIsAsync && returnType != null && returnType.Namespace == "System.Threading.Tasks") {  							if (returnType.Name == "Task") {  								returnType = typeSystem.Void;  							} else if (returnType.Name == "Task`1" && returnType.IsGenericInstance) {  								returnType = ((GenericInstanceType)returnType).GenericArguments[0];  							}  						}  						InferTypeForExpression(expr.Arguments[0]' returnType);  					}  					return null;  				case ILCode.YieldReturn:  					if (forceInferChildren) {  						GenericInstanceType genericType = context.CurrentMethod.ReturnType as GenericInstanceType;  						if (genericType != null) { // IEnumerable<T> or IEnumerator<T>  							InferTypeForExpression(expr.Arguments[0]' genericType.GenericArguments[0]);  						} else { // non-generic IEnumerable or IEnumerator  							InferTypeForExpression(expr.Arguments[0]' typeSystem.Object);  						}  					}  					return null;  				case ILCode.Await:  					{  						TypeReference taskType = InferTypeForExpression(expr.Arguments[0]' null);  						if (taskType.Name == "Task`1" && taskType.IsGenericInstance && taskType.Namespace == "System.Threading.Tasks") {  							return ((GenericInstanceType)taskType).GenericArguments[0];  						}  						return null;  					}  					#endregion  				case ILCode.Pop:  					return null;  				case ILCode.Wrap:  				case ILCode.Dup:  					{  						var arg = expr.Arguments.Single();  						return arg.ExpectedType = InferTypeForExpression(arg' expectedType);  					}  				default:  					Debug.WriteLine("Type Inference: Can't handle " + expr.Code.GetName());  					return null;  			}
Magic Number,Custom.Decompiler.ILAst,TypeAnalysis,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\TypeAnalysis.cs,DoInferTypeForExpression,The following statement contains a magic number: switch (expr.Code) {  					#region Logical operators  				case ILCode.LogicNot:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments.Single()' typeSystem.Boolean);  					}  					return typeSystem.Boolean;  				case ILCode.LogicAnd:  				case ILCode.LogicOr:  					// if Operand is set the logic and/or expression is a custom operator  					// we can deal with it the same as a normal invocation.  					if (expr.Operand != null)  						goto case ILCode.Call;  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[0]' typeSystem.Boolean);  						InferTypeForExpression(expr.Arguments[1]' typeSystem.Boolean);  					}  					return typeSystem.Boolean;  				case ILCode.TernaryOp:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[0]' typeSystem.Boolean);  					}  					return InferBinaryArguments(expr.Arguments[1]' expr.Arguments[2]' expectedType' forceInferChildren);  				case ILCode.NullCoalescing:  					return InferBinaryArguments(expr.Arguments[0]' expr.Arguments[1]' expectedType' forceInferChildren);  					#endregion  					#region Variable load/store  				case ILCode.Stloc:  					{  						ILVariable v = (ILVariable)expr.Operand;  						if (forceInferChildren) {  							// do not use 'expectedType' in here!  							InferTypeForExpression(expr.Arguments.Single()' v.Type);  						}  						return v.Type;  					}  				case ILCode.Ldloc:  					{  						ILVariable v = (ILVariable)expr.Operand;  						if (v.Type == null && singleLoadVariables.Contains(v)) {  							v.Type = expectedType;  						}  						return v.Type;  					}  				case ILCode.Ldloca:  					{  						ILVariable v = (ILVariable)expr.Operand;  						if (v.Type != null)  							return new ByReferenceType(v.Type);  						else  							return null;  					}  					#endregion  					#region Call / NewObj  				case ILCode.Call:  				case ILCode.Callvirt:  				case ILCode.CallGetter:  				case ILCode.CallvirtGetter:  				case ILCode.CallSetter:  				case ILCode.CallvirtSetter:  					{  						MethodReference method = (MethodReference)expr.Operand;  						if (forceInferChildren) {  							for (int i = 0; i < expr.Arguments.Count; i++) {  								if (i == 0 && method.HasThis) {  									InferTypeForExpression(expr.Arguments[0]' MakeRefIfValueType(method.DeclaringType' expr.GetPrefix(ILCode.Constrained)));  								} else {  									InferTypeForExpression(expr.Arguments[i]' SubstituteTypeArgs(method.Parameters[method.HasThis ? i - 1 : i].ParameterType' method));  								}  							}  						}  						if (expr.Code == ILCode.CallSetter || expr.Code == ILCode.CallvirtSetter) {  							return SubstituteTypeArgs(method.Parameters.Last().ParameterType' method);  						} else {  							return SubstituteTypeArgs(method.ReturnType' method);  						}  					}  				case ILCode.Newobj:  					{  						MethodReference ctor = (MethodReference)expr.Operand;  						if (forceInferChildren) {  							for (int i = 0; i < ctor.Parameters.Count; i++) {  								InferTypeForExpression(expr.Arguments[i]' SubstituteTypeArgs(ctor.Parameters[i].ParameterType' ctor));  							}  						}  						return ctor.DeclaringType;  					}  				case ILCode.InitObject:  				case ILCode.InitCollection:  					return InferTypeForExpression(expr.Arguments[0]' expectedType);  				case ILCode.InitializedObject:  					// expectedType should always be known due to the parent method call / property setter  					Debug.Assert(expectedType != null);  					return expectedType;  					#endregion  					#region Load/Store Fields  				case ILCode.Ldfld:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[0]' MakeRefIfValueType(((FieldReference)expr.Operand).DeclaringType' expr.GetPrefix(ILCode.Constrained)));  					}  					return GetFieldType((FieldReference)expr.Operand);  				case ILCode.Ldsfld:  					return GetFieldType((FieldReference)expr.Operand);  				case ILCode.Ldflda:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[0]' MakeRefIfValueType(((FieldReference)expr.Operand).DeclaringType' expr.GetPrefix(ILCode.Constrained)));  					}  					return new ByReferenceType(GetFieldType((FieldReference)expr.Operand));  				case ILCode.Ldsflda:  					return new ByReferenceType(GetFieldType((FieldReference)expr.Operand));  				case ILCode.Stfld:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[0]' MakeRefIfValueType(((FieldReference)expr.Operand).DeclaringType' expr.GetPrefix(ILCode.Constrained)));  						InferTypeForExpression(expr.Arguments[1]' GetFieldType((FieldReference)expr.Operand));  					}  					return GetFieldType((FieldReference)expr.Operand);  				case ILCode.Stsfld:  					if (forceInferChildren)  						InferTypeForExpression(expr.Arguments[0]' GetFieldType((FieldReference)expr.Operand));  					return GetFieldType((FieldReference)expr.Operand);  					#endregion  					#region Reference/Pointer instructions  				case ILCode.Ldind_Ref:  					return UnpackPointer(InferTypeForExpression(expr.Arguments[0]' null));  				case ILCode.Stind_Ref:  					if (forceInferChildren) {  						TypeReference elementType = UnpackPointer(InferTypeForExpression(expr.Arguments[0]' null));  						InferTypeForExpression(expr.Arguments[1]' elementType);  					}  					return null;  				case ILCode.Ldobj:  					{  						TypeReference type = (TypeReference)expr.Operand;  						var argType = InferTypeForExpression(expr.Arguments[0]' null);  						if (argType is PointerType || argType is ByReferenceType) {  							var elementType = ((TypeSpecification)argType).ElementType;  							int infoAmount = GetInformationAmount(elementType);  							if (infoAmount == 1 && GetInformationAmount(type) == 8) {  								// A bool can be loaded from both bytes and sbytes.  								type = elementType;  							}  							if (infoAmount >= 8 && infoAmount <= 64 && infoAmount == GetInformationAmount(type)) {  								// An integer can be loaded as another integer of the same size.  								// For integers smaller than 32 bit' the signs must match (as loading performs sign extension)  								bool? elementTypeIsSigned = IsSigned(elementType);  								bool? typeIsSigned = IsSigned(type);  								if (elementTypeIsSigned != null && typeIsSigned != null) {  									if (infoAmount >= 32 || elementTypeIsSigned == typeIsSigned)  										type = elementType;  								}  							}  						}  						if (argType is PointerType)  							InferTypeForExpression(expr.Arguments[0]' new PointerType(type));  						else  							InferTypeForExpression(expr.Arguments[0]' new ByReferenceType(type));  						return type;  					}  				case ILCode.Stobj:  					{  						TypeReference operandType = (TypeReference)expr.Operand;  						TypeReference pointerType = InferTypeForExpression(expr.Arguments[0]' new ByReferenceType(operandType));  						TypeReference elementType;  						if (pointerType is PointerType)  							elementType = ((PointerType)pointerType).ElementType;  						else if (pointerType is ByReferenceType)  							elementType = ((ByReferenceType)pointerType).ElementType;  						else  							elementType = null;  						if (elementType != null) {  							// An integer can be stored in any other integer of the same size.  							int infoAmount = GetInformationAmount(elementType);  							if (infoAmount == 1 && GetInformationAmount(operandType) == 8)  								operandType = elementType;  							else if (infoAmount == GetInformationAmount(operandType) && IsSigned(elementType) != null && IsSigned(operandType) != null)  								operandType = elementType;  						}  						if (forceInferChildren) {  							if (pointerType is PointerType)  								InferTypeForExpression(expr.Arguments[0]' new PointerType(operandType));  							else if (!IsSameType(operandType' expr.Operand as TypeReference))  								InferTypeForExpression(expr.Arguments[0]' new ByReferenceType(operandType));  							InferTypeForExpression(expr.Arguments[1]' operandType);  						}  						return operandType;  					}  				case ILCode.Initobj:  					return null;  				case ILCode.DefaultValue:  					return (TypeReference)expr.Operand;  				case ILCode.Localloc:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[0]' typeSystem.Int32);  					}  					if (expectedType is PointerType)  						return expectedType;  					else  						return typeSystem.IntPtr;  				case ILCode.Sizeof:  					return typeSystem.Int32;  				case ILCode.PostIncrement:  				case ILCode.PostIncrement_Ovf:  				case ILCode.PostIncrement_Ovf_Un:  					{  						TypeReference elementType = UnpackPointer(InferTypeForExpression(expr.Arguments[0]' null));  						if (forceInferChildren && elementType != null) {  							// Assign expected type to the child expression  							InferTypeForExpression(expr.Arguments[0]' new ByReferenceType(elementType));  						}  						return elementType;  					}  				case ILCode.Mkrefany:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[0]' (TypeReference)expr.Operand);  					}  					return typeSystem.TypedReference;  				case ILCode.Refanytype:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[0]' typeSystem.TypedReference);  					}                      return new TypeReference("System"' "RuntimeTypeHandle"' module' module.TypeSystem.CoreLibrary' true);  				case ILCode.Refanyval:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[0]' typeSystem.TypedReference);  					}  					return new ByReferenceType((TypeReference)expr.Operand);  				case ILCode.AddressOf:  					{  						TypeReference t = InferTypeForExpression(expr.Arguments[0]' UnpackPointer(expectedType));  						return t != null ? new ByReferenceType(t) : null;  					}  				case ILCode.ValueOf:  					return GetNullableTypeArgument(InferTypeForExpression(expr.Arguments[0]' CreateNullableType(expectedType)));  				case ILCode.NullableOf:  					return CreateNullableType(InferTypeForExpression(expr.Arguments[0]' GetNullableTypeArgument(expectedType)));  					#endregion  					#region Arithmetic instructions  				case ILCode.Not: // bitwise complement  				case ILCode.Neg:  					return InferTypeForExpression(expr.Arguments.Single()' expectedType);  				case ILCode.Add:  					return InferArgumentsInAddition(expr' null' expectedType);  				case ILCode.Sub:  					return InferArgumentsInSubtraction(expr' null' expectedType);  				case ILCode.Mul:  				case ILCode.Or:  				case ILCode.And:  				case ILCode.Xor:  					return InferArgumentsInBinaryOperator(expr' null' expectedType);  				case ILCode.Add_Ovf:  					return InferArgumentsInAddition(expr' true' expectedType);  				case ILCode.Sub_Ovf:  					return InferArgumentsInSubtraction(expr' true' expectedType);  				case ILCode.Mul_Ovf:  				case ILCode.Div:  				case ILCode.Rem:  					return InferArgumentsInBinaryOperator(expr' true' expectedType);  				case ILCode.Add_Ovf_Un:  					return InferArgumentsInAddition(expr' false' expectedType);  				case ILCode.Sub_Ovf_Un:  					return InferArgumentsInSubtraction(expr' false' expectedType);  				case ILCode.Mul_Ovf_Un:  				case ILCode.Div_Un:  				case ILCode.Rem_Un:  					return InferArgumentsInBinaryOperator(expr' false' expectedType);  				case ILCode.Shl:  					if (forceInferChildren)  						InferTypeForExpression(expr.Arguments[1]' typeSystem.Int32);  					if (expectedType != null && (  						expectedType.MetadataType == MetadataType.Int32 || expectedType.MetadataType == MetadataType.UInt32 ||  						expectedType.MetadataType == MetadataType.Int64 || expectedType.MetadataType == MetadataType.UInt64)  					   )  						return NumericPromotion(InferTypeForExpression(expr.Arguments[0]' expectedType));  					else  						return NumericPromotion(InferTypeForExpression(expr.Arguments[0]' null));  				case ILCode.Shr:  				case ILCode.Shr_Un:  					{  						if (forceInferChildren)  							InferTypeForExpression(expr.Arguments[1]' typeSystem.Int32);  						TypeReference type = NumericPromotion(InferTypeForExpression(expr.Arguments[0]' null));  						TypeReference expectedInputType = null;  						switch (type.MetadataType) {  							case MetadataType.Int32:  								if (expr.Code == ILCode.Shr_Un)  									expectedInputType = typeSystem.UInt32;  								break;  							case MetadataType.UInt32:  								if (expr.Code == ILCode.Shr)  									expectedInputType = typeSystem.Int32;  								break;  							case MetadataType.Int64:  								if (expr.Code == ILCode.Shr_Un)  									expectedInputType = typeSystem.UInt64;  								break;  							case MetadataType.UInt64:  								if (expr.Code == ILCode.Shr)  									expectedInputType = typeSystem.UInt64;  								break;  						}  						if (expectedInputType != null) {  							InferTypeForExpression(expr.Arguments[0]' expectedInputType);  							return expectedInputType;  						} else {  							return type;  						}  					}  				case ILCode.CompoundAssignment:  					{  						var op = expr.Arguments[0];  						if (op.Code == ILCode.NullableOf) op = op.Arguments[0].Arguments[0];  						var varType = InferTypeForExpression(op.Arguments[0]' null);  						if (forceInferChildren) {  							InferTypeForExpression(expr.Arguments[0]' varType);  						}  						return varType;  					}  					#endregion  					#region Constant loading instructions  				case ILCode.Ldnull:  					return typeSystem.Object;  				case ILCode.Ldstr:  					return typeSystem.String;  				case ILCode.Ldftn:  				case ILCode.Ldvirtftn:  					return typeSystem.IntPtr;  				case ILCode.Ldc_I4:  					if (IsBoolean(expectedType) && ((int)expr.Operand == 0 || (int)expr.Operand == 1))  						return typeSystem.Boolean;  					if (expectedType is PointerType && (int)expr.Operand == 0)  						return expectedType;  					if (IsIntegerOrEnum(expectedType) && OperandFitsInType(expectedType' (int)expr.Operand))  						return expectedType;  					else  						return typeSystem.Int32;  				case ILCode.Ldc_I8:  					if (expectedType is PointerType && (long)expr.Operand == 0)  						return expectedType;  					if (IsIntegerOrEnum(expectedType) && GetInformationAmount(expectedType) >= NativeInt)  						return expectedType;  					else  						return typeSystem.Int64;  				case ILCode.Ldc_R4:  					return typeSystem.Single;  				case ILCode.Ldc_R8:  					return typeSystem.Double;  				case ILCode.Ldc_Decimal:                      return new TypeReference("System"' "Decimal"' module' module.TypeSystem.CoreLibrary' true);  				case ILCode.Ldtoken:  					if (expr.Operand is TypeReference)  						return new TypeReference("System"' "RuntimeTypeHandle"' module' module.TypeSystem.CoreLibrary' true);  					else if (expr.Operand is FieldReference)                          return new TypeReference("System"' "RuntimeFieldHandle"' module' module.TypeSystem.CoreLibrary' true);  					else                          return new TypeReference("System"' "RuntimeMethodHandle"' module' module.TypeSystem.CoreLibrary' true);  				case ILCode.Arglist:                      return new TypeReference("System"' "RuntimeArgumentHandle"' module' module.TypeSystem.CoreLibrary' true);  					#endregion  					#region Array instructions  				case ILCode.Newarr:  					if (forceInferChildren) {  						var lengthType = InferTypeForExpression(expr.Arguments.Single()' null);  						if (lengthType == typeSystem.IntPtr) {  							lengthType = typeSystem.Int64;  						} else if (lengthType == typeSystem.UIntPtr) {  							lengthType = typeSystem.UInt64;  						} else if (lengthType != typeSystem.UInt32 && lengthType != typeSystem.Int64 && lengthType != typeSystem.UInt64) {  							lengthType = typeSystem.Int32;  						}  						if (forceInferChildren) {  							InferTypeForExpression(expr.Arguments.Single()' lengthType);  						}  					}  					return new ArrayType((TypeReference)expr.Operand);  				case ILCode.InitArray:  					var operandAsArrayType = (ArrayType)expr.Operand;  					if (forceInferChildren)  					{  						foreach (ILExpression arg in expr.Arguments)  							InferTypeForExpression(arg' operandAsArrayType.ElementType);  					}  					return operandAsArrayType;  				case ILCode.Ldlen:  					return typeSystem.Int32;  				case ILCode.Ldelem_U1:  				case ILCode.Ldelem_U2:  				case ILCode.Ldelem_U4:  				case ILCode.Ldelem_I1:  				case ILCode.Ldelem_I2:  				case ILCode.Ldelem_I4:  				case ILCode.Ldelem_I8:  				case ILCode.Ldelem_R4:  				case ILCode.Ldelem_R8:  				case ILCode.Ldelem_I:  				case ILCode.Ldelem_Ref:  					{  						ArrayType arrayType = InferTypeForExpression(expr.Arguments[0]' null) as ArrayType;  						if (forceInferChildren) {  							InferTypeForExpression(expr.Arguments[1]' typeSystem.Int32);  						}  						return arrayType != null ? arrayType.ElementType : null;  					}  				case ILCode.Ldelem_Any:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[1]' typeSystem.Int32);  					}  					return (TypeReference)expr.Operand;  				case ILCode.Ldelema:  					{  						ArrayType arrayType = InferTypeForExpression(expr.Arguments[0]' null) as ArrayType;  						if (forceInferChildren)  							InferTypeForExpression(expr.Arguments[1]' typeSystem.Int32);  						return arrayType != null ? new ByReferenceType(arrayType.ElementType) : null;  					}  				case ILCode.Stelem_I:  				case ILCode.Stelem_I1:  				case ILCode.Stelem_I2:  				case ILCode.Stelem_I4:  				case ILCode.Stelem_I8:  				case ILCode.Stelem_R4:  				case ILCode.Stelem_R8:  				case ILCode.Stelem_Ref:  				case ILCode.Stelem_Any:  					{  						ArrayType arrayType = InferTypeForExpression(expr.Arguments[0]' null) as ArrayType;  						if (forceInferChildren) {  							InferTypeForExpression(expr.Arguments[1]' typeSystem.Int32);  							if (arrayType != null) {  								InferTypeForExpression(expr.Arguments[2]' arrayType.ElementType);  							}  						}  						return arrayType != null ? arrayType.ElementType : null;  					}  					#endregion  					#region Conversion instructions  				case ILCode.Conv_I1:  				case ILCode.Conv_Ovf_I1:  				case ILCode.Conv_Ovf_I1_Un:  					return HandleConversion(8' true' expr.Arguments[0]' expectedType' typeSystem.SByte);  				case ILCode.Conv_I2:  				case ILCode.Conv_Ovf_I2:  				case ILCode.Conv_Ovf_I2_Un:  					return HandleConversion(16' true' expr.Arguments[0]' expectedType' typeSystem.Int16);  				case ILCode.Conv_I4:  				case ILCode.Conv_Ovf_I4:  				case ILCode.Conv_Ovf_I4_Un:  					return HandleConversion(32' true' expr.Arguments[0]' expectedType' typeSystem.Int32);  				case ILCode.Conv_I8:  				case ILCode.Conv_Ovf_I8:  				case ILCode.Conv_Ovf_I8_Un:  					return HandleConversion(64' true' expr.Arguments[0]' expectedType' typeSystem.Int64);  				case ILCode.Conv_U1:  				case ILCode.Conv_Ovf_U1:  				case ILCode.Conv_Ovf_U1_Un:  					return HandleConversion(8' false' expr.Arguments[0]' expectedType' typeSystem.Byte);  				case ILCode.Conv_U2:  				case ILCode.Conv_Ovf_U2:  				case ILCode.Conv_Ovf_U2_Un:  					return HandleConversion(16' false' expr.Arguments[0]' expectedType' typeSystem.UInt16);  				case ILCode.Conv_U4:  				case ILCode.Conv_Ovf_U4:  				case ILCode.Conv_Ovf_U4_Un:  					return HandleConversion(32' false' expr.Arguments[0]' expectedType' typeSystem.UInt32);  				case ILCode.Conv_U8:  				case ILCode.Conv_Ovf_U8:  				case ILCode.Conv_Ovf_U8_Un:  					return HandleConversion(64' false' expr.Arguments[0]' expectedType' typeSystem.UInt64);  				case ILCode.Conv_I:  				case ILCode.Conv_Ovf_I:  				case ILCode.Conv_Ovf_I_Un:  					return HandleConversion(NativeInt' true' expr.Arguments[0]' expectedType' typeSystem.IntPtr);  				case ILCode.Conv_U:  				case ILCode.Conv_Ovf_U:  				case ILCode.Conv_Ovf_U_Un:  					return HandleConversion(NativeInt' false' expr.Arguments[0]' expectedType' typeSystem.UIntPtr);  				case ILCode.Conv_R4:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[0]' typeSystem.Single);  					}  					return typeSystem.Single;  				case ILCode.Conv_R8:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[0]' typeSystem.Double);  					}  					return typeSystem.Double;  				case ILCode.Conv_R_Un:  					return (expectedType != null  && expectedType.MetadataType == MetadataType.Single) ? typeSystem.Single : typeSystem.Double;  				case ILCode.Castclass:  				case ILCode.Unbox_Any:  					return (TypeReference)expr.Operand;  				case ILCode.Unbox:  					return new ByReferenceType((TypeReference)expr.Operand);  				case ILCode.Isinst:  					{  						// isinst performs the equivalent of a cast only for reference types;  						// value types still need to be unboxed after an isinst instruction  						TypeReference tr = (TypeReference)expr.Operand;  						return tr.IsValueType ? typeSystem.Object : tr;  					}  				case ILCode.Box:  					{  						var tr = (TypeReference)expr.Operand;  						if (forceInferChildren)  							InferTypeForExpression(expr.Arguments.Single()' tr);  						return tr.IsValueType ? typeSystem.Object : tr;  					}  					#endregion  					#region Comparison instructions  				case ILCode.Ceq:  				case ILCode.Cne:  					if (forceInferChildren)  						InferArgumentsInBinaryOperator(expr' null' null);  					return typeSystem.Boolean;  				case ILCode.Clt:  				case ILCode.Cgt:  				case ILCode.Cle:  				case ILCode.Cge:  					if (forceInferChildren)  						InferArgumentsInBinaryOperator(expr' true' null);  					return typeSystem.Boolean;  				case ILCode.Clt_Un:  				case ILCode.Cgt_Un:  				case ILCode.Cle_Un:  				case ILCode.Cge_Un:  					if (forceInferChildren)  						InferArgumentsInBinaryOperator(expr' false' null);  					return typeSystem.Boolean;  					#endregion  					#region Branch instructions  				case ILCode.Brtrue:  					if (forceInferChildren)  						InferTypeForExpression(expr.Arguments.Single()' typeSystem.Boolean);  					return null;  				case ILCode.Br:  				case ILCode.Leave:  				case ILCode.Endfinally:  				case ILCode.Switch:  				case ILCode.Throw:  				case ILCode.Rethrow:  				case ILCode.LoopOrSwitchBreak:  				case ILCode.LoopContinue:  				case ILCode.YieldBreak:  					return null;  				case ILCode.Ret:  					if (forceInferChildren && expr.Arguments.Count == 1) {  						TypeReference returnType = context.CurrentMethod.ReturnType;  						if (context.CurrentMethodIsAsync && returnType != null && returnType.Namespace == "System.Threading.Tasks") {  							if (returnType.Name == "Task") {  								returnType = typeSystem.Void;  							} else if (returnType.Name == "Task`1" && returnType.IsGenericInstance) {  								returnType = ((GenericInstanceType)returnType).GenericArguments[0];  							}  						}  						InferTypeForExpression(expr.Arguments[0]' returnType);  					}  					return null;  				case ILCode.YieldReturn:  					if (forceInferChildren) {  						GenericInstanceType genericType = context.CurrentMethod.ReturnType as GenericInstanceType;  						if (genericType != null) { // IEnumerable<T> or IEnumerator<T>  							InferTypeForExpression(expr.Arguments[0]' genericType.GenericArguments[0]);  						} else { // non-generic IEnumerable or IEnumerator  							InferTypeForExpression(expr.Arguments[0]' typeSystem.Object);  						}  					}  					return null;  				case ILCode.Await:  					{  						TypeReference taskType = InferTypeForExpression(expr.Arguments[0]' null);  						if (taskType.Name == "Task`1" && taskType.IsGenericInstance && taskType.Namespace == "System.Threading.Tasks") {  							return ((GenericInstanceType)taskType).GenericArguments[0];  						}  						return null;  					}  					#endregion  				case ILCode.Pop:  					return null;  				case ILCode.Wrap:  				case ILCode.Dup:  					{  						var arg = expr.Arguments.Single();  						return arg.ExpectedType = InferTypeForExpression(arg' expectedType);  					}  				default:  					Debug.WriteLine("Type Inference: Can't handle " + expr.Code.GetName());  					return null;  			}
Magic Number,Custom.Decompiler.ILAst,TypeAnalysis,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\TypeAnalysis.cs,DoInferTypeForExpression,The following statement contains a magic number: switch (expr.Code) {  					#region Logical operators  				case ILCode.LogicNot:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments.Single()' typeSystem.Boolean);  					}  					return typeSystem.Boolean;  				case ILCode.LogicAnd:  				case ILCode.LogicOr:  					// if Operand is set the logic and/or expression is a custom operator  					// we can deal with it the same as a normal invocation.  					if (expr.Operand != null)  						goto case ILCode.Call;  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[0]' typeSystem.Boolean);  						InferTypeForExpression(expr.Arguments[1]' typeSystem.Boolean);  					}  					return typeSystem.Boolean;  				case ILCode.TernaryOp:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[0]' typeSystem.Boolean);  					}  					return InferBinaryArguments(expr.Arguments[1]' expr.Arguments[2]' expectedType' forceInferChildren);  				case ILCode.NullCoalescing:  					return InferBinaryArguments(expr.Arguments[0]' expr.Arguments[1]' expectedType' forceInferChildren);  					#endregion  					#region Variable load/store  				case ILCode.Stloc:  					{  						ILVariable v = (ILVariable)expr.Operand;  						if (forceInferChildren) {  							// do not use 'expectedType' in here!  							InferTypeForExpression(expr.Arguments.Single()' v.Type);  						}  						return v.Type;  					}  				case ILCode.Ldloc:  					{  						ILVariable v = (ILVariable)expr.Operand;  						if (v.Type == null && singleLoadVariables.Contains(v)) {  							v.Type = expectedType;  						}  						return v.Type;  					}  				case ILCode.Ldloca:  					{  						ILVariable v = (ILVariable)expr.Operand;  						if (v.Type != null)  							return new ByReferenceType(v.Type);  						else  							return null;  					}  					#endregion  					#region Call / NewObj  				case ILCode.Call:  				case ILCode.Callvirt:  				case ILCode.CallGetter:  				case ILCode.CallvirtGetter:  				case ILCode.CallSetter:  				case ILCode.CallvirtSetter:  					{  						MethodReference method = (MethodReference)expr.Operand;  						if (forceInferChildren) {  							for (int i = 0; i < expr.Arguments.Count; i++) {  								if (i == 0 && method.HasThis) {  									InferTypeForExpression(expr.Arguments[0]' MakeRefIfValueType(method.DeclaringType' expr.GetPrefix(ILCode.Constrained)));  								} else {  									InferTypeForExpression(expr.Arguments[i]' SubstituteTypeArgs(method.Parameters[method.HasThis ? i - 1 : i].ParameterType' method));  								}  							}  						}  						if (expr.Code == ILCode.CallSetter || expr.Code == ILCode.CallvirtSetter) {  							return SubstituteTypeArgs(method.Parameters.Last().ParameterType' method);  						} else {  							return SubstituteTypeArgs(method.ReturnType' method);  						}  					}  				case ILCode.Newobj:  					{  						MethodReference ctor = (MethodReference)expr.Operand;  						if (forceInferChildren) {  							for (int i = 0; i < ctor.Parameters.Count; i++) {  								InferTypeForExpression(expr.Arguments[i]' SubstituteTypeArgs(ctor.Parameters[i].ParameterType' ctor));  							}  						}  						return ctor.DeclaringType;  					}  				case ILCode.InitObject:  				case ILCode.InitCollection:  					return InferTypeForExpression(expr.Arguments[0]' expectedType);  				case ILCode.InitializedObject:  					// expectedType should always be known due to the parent method call / property setter  					Debug.Assert(expectedType != null);  					return expectedType;  					#endregion  					#region Load/Store Fields  				case ILCode.Ldfld:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[0]' MakeRefIfValueType(((FieldReference)expr.Operand).DeclaringType' expr.GetPrefix(ILCode.Constrained)));  					}  					return GetFieldType((FieldReference)expr.Operand);  				case ILCode.Ldsfld:  					return GetFieldType((FieldReference)expr.Operand);  				case ILCode.Ldflda:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[0]' MakeRefIfValueType(((FieldReference)expr.Operand).DeclaringType' expr.GetPrefix(ILCode.Constrained)));  					}  					return new ByReferenceType(GetFieldType((FieldReference)expr.Operand));  				case ILCode.Ldsflda:  					return new ByReferenceType(GetFieldType((FieldReference)expr.Operand));  				case ILCode.Stfld:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[0]' MakeRefIfValueType(((FieldReference)expr.Operand).DeclaringType' expr.GetPrefix(ILCode.Constrained)));  						InferTypeForExpression(expr.Arguments[1]' GetFieldType((FieldReference)expr.Operand));  					}  					return GetFieldType((FieldReference)expr.Operand);  				case ILCode.Stsfld:  					if (forceInferChildren)  						InferTypeForExpression(expr.Arguments[0]' GetFieldType((FieldReference)expr.Operand));  					return GetFieldType((FieldReference)expr.Operand);  					#endregion  					#region Reference/Pointer instructions  				case ILCode.Ldind_Ref:  					return UnpackPointer(InferTypeForExpression(expr.Arguments[0]' null));  				case ILCode.Stind_Ref:  					if (forceInferChildren) {  						TypeReference elementType = UnpackPointer(InferTypeForExpression(expr.Arguments[0]' null));  						InferTypeForExpression(expr.Arguments[1]' elementType);  					}  					return null;  				case ILCode.Ldobj:  					{  						TypeReference type = (TypeReference)expr.Operand;  						var argType = InferTypeForExpression(expr.Arguments[0]' null);  						if (argType is PointerType || argType is ByReferenceType) {  							var elementType = ((TypeSpecification)argType).ElementType;  							int infoAmount = GetInformationAmount(elementType);  							if (infoAmount == 1 && GetInformationAmount(type) == 8) {  								// A bool can be loaded from both bytes and sbytes.  								type = elementType;  							}  							if (infoAmount >= 8 && infoAmount <= 64 && infoAmount == GetInformationAmount(type)) {  								// An integer can be loaded as another integer of the same size.  								// For integers smaller than 32 bit' the signs must match (as loading performs sign extension)  								bool? elementTypeIsSigned = IsSigned(elementType);  								bool? typeIsSigned = IsSigned(type);  								if (elementTypeIsSigned != null && typeIsSigned != null) {  									if (infoAmount >= 32 || elementTypeIsSigned == typeIsSigned)  										type = elementType;  								}  							}  						}  						if (argType is PointerType)  							InferTypeForExpression(expr.Arguments[0]' new PointerType(type));  						else  							InferTypeForExpression(expr.Arguments[0]' new ByReferenceType(type));  						return type;  					}  				case ILCode.Stobj:  					{  						TypeReference operandType = (TypeReference)expr.Operand;  						TypeReference pointerType = InferTypeForExpression(expr.Arguments[0]' new ByReferenceType(operandType));  						TypeReference elementType;  						if (pointerType is PointerType)  							elementType = ((PointerType)pointerType).ElementType;  						else if (pointerType is ByReferenceType)  							elementType = ((ByReferenceType)pointerType).ElementType;  						else  							elementType = null;  						if (elementType != null) {  							// An integer can be stored in any other integer of the same size.  							int infoAmount = GetInformationAmount(elementType);  							if (infoAmount == 1 && GetInformationAmount(operandType) == 8)  								operandType = elementType;  							else if (infoAmount == GetInformationAmount(operandType) && IsSigned(elementType) != null && IsSigned(operandType) != null)  								operandType = elementType;  						}  						if (forceInferChildren) {  							if (pointerType is PointerType)  								InferTypeForExpression(expr.Arguments[0]' new PointerType(operandType));  							else if (!IsSameType(operandType' expr.Operand as TypeReference))  								InferTypeForExpression(expr.Arguments[0]' new ByReferenceType(operandType));  							InferTypeForExpression(expr.Arguments[1]' operandType);  						}  						return operandType;  					}  				case ILCode.Initobj:  					return null;  				case ILCode.DefaultValue:  					return (TypeReference)expr.Operand;  				case ILCode.Localloc:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[0]' typeSystem.Int32);  					}  					if (expectedType is PointerType)  						return expectedType;  					else  						return typeSystem.IntPtr;  				case ILCode.Sizeof:  					return typeSystem.Int32;  				case ILCode.PostIncrement:  				case ILCode.PostIncrement_Ovf:  				case ILCode.PostIncrement_Ovf_Un:  					{  						TypeReference elementType = UnpackPointer(InferTypeForExpression(expr.Arguments[0]' null));  						if (forceInferChildren && elementType != null) {  							// Assign expected type to the child expression  							InferTypeForExpression(expr.Arguments[0]' new ByReferenceType(elementType));  						}  						return elementType;  					}  				case ILCode.Mkrefany:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[0]' (TypeReference)expr.Operand);  					}  					return typeSystem.TypedReference;  				case ILCode.Refanytype:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[0]' typeSystem.TypedReference);  					}                      return new TypeReference("System"' "RuntimeTypeHandle"' module' module.TypeSystem.CoreLibrary' true);  				case ILCode.Refanyval:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[0]' typeSystem.TypedReference);  					}  					return new ByReferenceType((TypeReference)expr.Operand);  				case ILCode.AddressOf:  					{  						TypeReference t = InferTypeForExpression(expr.Arguments[0]' UnpackPointer(expectedType));  						return t != null ? new ByReferenceType(t) : null;  					}  				case ILCode.ValueOf:  					return GetNullableTypeArgument(InferTypeForExpression(expr.Arguments[0]' CreateNullableType(expectedType)));  				case ILCode.NullableOf:  					return CreateNullableType(InferTypeForExpression(expr.Arguments[0]' GetNullableTypeArgument(expectedType)));  					#endregion  					#region Arithmetic instructions  				case ILCode.Not: // bitwise complement  				case ILCode.Neg:  					return InferTypeForExpression(expr.Arguments.Single()' expectedType);  				case ILCode.Add:  					return InferArgumentsInAddition(expr' null' expectedType);  				case ILCode.Sub:  					return InferArgumentsInSubtraction(expr' null' expectedType);  				case ILCode.Mul:  				case ILCode.Or:  				case ILCode.And:  				case ILCode.Xor:  					return InferArgumentsInBinaryOperator(expr' null' expectedType);  				case ILCode.Add_Ovf:  					return InferArgumentsInAddition(expr' true' expectedType);  				case ILCode.Sub_Ovf:  					return InferArgumentsInSubtraction(expr' true' expectedType);  				case ILCode.Mul_Ovf:  				case ILCode.Div:  				case ILCode.Rem:  					return InferArgumentsInBinaryOperator(expr' true' expectedType);  				case ILCode.Add_Ovf_Un:  					return InferArgumentsInAddition(expr' false' expectedType);  				case ILCode.Sub_Ovf_Un:  					return InferArgumentsInSubtraction(expr' false' expectedType);  				case ILCode.Mul_Ovf_Un:  				case ILCode.Div_Un:  				case ILCode.Rem_Un:  					return InferArgumentsInBinaryOperator(expr' false' expectedType);  				case ILCode.Shl:  					if (forceInferChildren)  						InferTypeForExpression(expr.Arguments[1]' typeSystem.Int32);  					if (expectedType != null && (  						expectedType.MetadataType == MetadataType.Int32 || expectedType.MetadataType == MetadataType.UInt32 ||  						expectedType.MetadataType == MetadataType.Int64 || expectedType.MetadataType == MetadataType.UInt64)  					   )  						return NumericPromotion(InferTypeForExpression(expr.Arguments[0]' expectedType));  					else  						return NumericPromotion(InferTypeForExpression(expr.Arguments[0]' null));  				case ILCode.Shr:  				case ILCode.Shr_Un:  					{  						if (forceInferChildren)  							InferTypeForExpression(expr.Arguments[1]' typeSystem.Int32);  						TypeReference type = NumericPromotion(InferTypeForExpression(expr.Arguments[0]' null));  						TypeReference expectedInputType = null;  						switch (type.MetadataType) {  							case MetadataType.Int32:  								if (expr.Code == ILCode.Shr_Un)  									expectedInputType = typeSystem.UInt32;  								break;  							case MetadataType.UInt32:  								if (expr.Code == ILCode.Shr)  									expectedInputType = typeSystem.Int32;  								break;  							case MetadataType.Int64:  								if (expr.Code == ILCode.Shr_Un)  									expectedInputType = typeSystem.UInt64;  								break;  							case MetadataType.UInt64:  								if (expr.Code == ILCode.Shr)  									expectedInputType = typeSystem.UInt64;  								break;  						}  						if (expectedInputType != null) {  							InferTypeForExpression(expr.Arguments[0]' expectedInputType);  							return expectedInputType;  						} else {  							return type;  						}  					}  				case ILCode.CompoundAssignment:  					{  						var op = expr.Arguments[0];  						if (op.Code == ILCode.NullableOf) op = op.Arguments[0].Arguments[0];  						var varType = InferTypeForExpression(op.Arguments[0]' null);  						if (forceInferChildren) {  							InferTypeForExpression(expr.Arguments[0]' varType);  						}  						return varType;  					}  					#endregion  					#region Constant loading instructions  				case ILCode.Ldnull:  					return typeSystem.Object;  				case ILCode.Ldstr:  					return typeSystem.String;  				case ILCode.Ldftn:  				case ILCode.Ldvirtftn:  					return typeSystem.IntPtr;  				case ILCode.Ldc_I4:  					if (IsBoolean(expectedType) && ((int)expr.Operand == 0 || (int)expr.Operand == 1))  						return typeSystem.Boolean;  					if (expectedType is PointerType && (int)expr.Operand == 0)  						return expectedType;  					if (IsIntegerOrEnum(expectedType) && OperandFitsInType(expectedType' (int)expr.Operand))  						return expectedType;  					else  						return typeSystem.Int32;  				case ILCode.Ldc_I8:  					if (expectedType is PointerType && (long)expr.Operand == 0)  						return expectedType;  					if (IsIntegerOrEnum(expectedType) && GetInformationAmount(expectedType) >= NativeInt)  						return expectedType;  					else  						return typeSystem.Int64;  				case ILCode.Ldc_R4:  					return typeSystem.Single;  				case ILCode.Ldc_R8:  					return typeSystem.Double;  				case ILCode.Ldc_Decimal:                      return new TypeReference("System"' "Decimal"' module' module.TypeSystem.CoreLibrary' true);  				case ILCode.Ldtoken:  					if (expr.Operand is TypeReference)  						return new TypeReference("System"' "RuntimeTypeHandle"' module' module.TypeSystem.CoreLibrary' true);  					else if (expr.Operand is FieldReference)                          return new TypeReference("System"' "RuntimeFieldHandle"' module' module.TypeSystem.CoreLibrary' true);  					else                          return new TypeReference("System"' "RuntimeMethodHandle"' module' module.TypeSystem.CoreLibrary' true);  				case ILCode.Arglist:                      return new TypeReference("System"' "RuntimeArgumentHandle"' module' module.TypeSystem.CoreLibrary' true);  					#endregion  					#region Array instructions  				case ILCode.Newarr:  					if (forceInferChildren) {  						var lengthType = InferTypeForExpression(expr.Arguments.Single()' null);  						if (lengthType == typeSystem.IntPtr) {  							lengthType = typeSystem.Int64;  						} else if (lengthType == typeSystem.UIntPtr) {  							lengthType = typeSystem.UInt64;  						} else if (lengthType != typeSystem.UInt32 && lengthType != typeSystem.Int64 && lengthType != typeSystem.UInt64) {  							lengthType = typeSystem.Int32;  						}  						if (forceInferChildren) {  							InferTypeForExpression(expr.Arguments.Single()' lengthType);  						}  					}  					return new ArrayType((TypeReference)expr.Operand);  				case ILCode.InitArray:  					var operandAsArrayType = (ArrayType)expr.Operand;  					if (forceInferChildren)  					{  						foreach (ILExpression arg in expr.Arguments)  							InferTypeForExpression(arg' operandAsArrayType.ElementType);  					}  					return operandAsArrayType;  				case ILCode.Ldlen:  					return typeSystem.Int32;  				case ILCode.Ldelem_U1:  				case ILCode.Ldelem_U2:  				case ILCode.Ldelem_U4:  				case ILCode.Ldelem_I1:  				case ILCode.Ldelem_I2:  				case ILCode.Ldelem_I4:  				case ILCode.Ldelem_I8:  				case ILCode.Ldelem_R4:  				case ILCode.Ldelem_R8:  				case ILCode.Ldelem_I:  				case ILCode.Ldelem_Ref:  					{  						ArrayType arrayType = InferTypeForExpression(expr.Arguments[0]' null) as ArrayType;  						if (forceInferChildren) {  							InferTypeForExpression(expr.Arguments[1]' typeSystem.Int32);  						}  						return arrayType != null ? arrayType.ElementType : null;  					}  				case ILCode.Ldelem_Any:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[1]' typeSystem.Int32);  					}  					return (TypeReference)expr.Operand;  				case ILCode.Ldelema:  					{  						ArrayType arrayType = InferTypeForExpression(expr.Arguments[0]' null) as ArrayType;  						if (forceInferChildren)  							InferTypeForExpression(expr.Arguments[1]' typeSystem.Int32);  						return arrayType != null ? new ByReferenceType(arrayType.ElementType) : null;  					}  				case ILCode.Stelem_I:  				case ILCode.Stelem_I1:  				case ILCode.Stelem_I2:  				case ILCode.Stelem_I4:  				case ILCode.Stelem_I8:  				case ILCode.Stelem_R4:  				case ILCode.Stelem_R8:  				case ILCode.Stelem_Ref:  				case ILCode.Stelem_Any:  					{  						ArrayType arrayType = InferTypeForExpression(expr.Arguments[0]' null) as ArrayType;  						if (forceInferChildren) {  							InferTypeForExpression(expr.Arguments[1]' typeSystem.Int32);  							if (arrayType != null) {  								InferTypeForExpression(expr.Arguments[2]' arrayType.ElementType);  							}  						}  						return arrayType != null ? arrayType.ElementType : null;  					}  					#endregion  					#region Conversion instructions  				case ILCode.Conv_I1:  				case ILCode.Conv_Ovf_I1:  				case ILCode.Conv_Ovf_I1_Un:  					return HandleConversion(8' true' expr.Arguments[0]' expectedType' typeSystem.SByte);  				case ILCode.Conv_I2:  				case ILCode.Conv_Ovf_I2:  				case ILCode.Conv_Ovf_I2_Un:  					return HandleConversion(16' true' expr.Arguments[0]' expectedType' typeSystem.Int16);  				case ILCode.Conv_I4:  				case ILCode.Conv_Ovf_I4:  				case ILCode.Conv_Ovf_I4_Un:  					return HandleConversion(32' true' expr.Arguments[0]' expectedType' typeSystem.Int32);  				case ILCode.Conv_I8:  				case ILCode.Conv_Ovf_I8:  				case ILCode.Conv_Ovf_I8_Un:  					return HandleConversion(64' true' expr.Arguments[0]' expectedType' typeSystem.Int64);  				case ILCode.Conv_U1:  				case ILCode.Conv_Ovf_U1:  				case ILCode.Conv_Ovf_U1_Un:  					return HandleConversion(8' false' expr.Arguments[0]' expectedType' typeSystem.Byte);  				case ILCode.Conv_U2:  				case ILCode.Conv_Ovf_U2:  				case ILCode.Conv_Ovf_U2_Un:  					return HandleConversion(16' false' expr.Arguments[0]' expectedType' typeSystem.UInt16);  				case ILCode.Conv_U4:  				case ILCode.Conv_Ovf_U4:  				case ILCode.Conv_Ovf_U4_Un:  					return HandleConversion(32' false' expr.Arguments[0]' expectedType' typeSystem.UInt32);  				case ILCode.Conv_U8:  				case ILCode.Conv_Ovf_U8:  				case ILCode.Conv_Ovf_U8_Un:  					return HandleConversion(64' false' expr.Arguments[0]' expectedType' typeSystem.UInt64);  				case ILCode.Conv_I:  				case ILCode.Conv_Ovf_I:  				case ILCode.Conv_Ovf_I_Un:  					return HandleConversion(NativeInt' true' expr.Arguments[0]' expectedType' typeSystem.IntPtr);  				case ILCode.Conv_U:  				case ILCode.Conv_Ovf_U:  				case ILCode.Conv_Ovf_U_Un:  					return HandleConversion(NativeInt' false' expr.Arguments[0]' expectedType' typeSystem.UIntPtr);  				case ILCode.Conv_R4:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[0]' typeSystem.Single);  					}  					return typeSystem.Single;  				case ILCode.Conv_R8:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[0]' typeSystem.Double);  					}  					return typeSystem.Double;  				case ILCode.Conv_R_Un:  					return (expectedType != null  && expectedType.MetadataType == MetadataType.Single) ? typeSystem.Single : typeSystem.Double;  				case ILCode.Castclass:  				case ILCode.Unbox_Any:  					return (TypeReference)expr.Operand;  				case ILCode.Unbox:  					return new ByReferenceType((TypeReference)expr.Operand);  				case ILCode.Isinst:  					{  						// isinst performs the equivalent of a cast only for reference types;  						// value types still need to be unboxed after an isinst instruction  						TypeReference tr = (TypeReference)expr.Operand;  						return tr.IsValueType ? typeSystem.Object : tr;  					}  				case ILCode.Box:  					{  						var tr = (TypeReference)expr.Operand;  						if (forceInferChildren)  							InferTypeForExpression(expr.Arguments.Single()' tr);  						return tr.IsValueType ? typeSystem.Object : tr;  					}  					#endregion  					#region Comparison instructions  				case ILCode.Ceq:  				case ILCode.Cne:  					if (forceInferChildren)  						InferArgumentsInBinaryOperator(expr' null' null);  					return typeSystem.Boolean;  				case ILCode.Clt:  				case ILCode.Cgt:  				case ILCode.Cle:  				case ILCode.Cge:  					if (forceInferChildren)  						InferArgumentsInBinaryOperator(expr' true' null);  					return typeSystem.Boolean;  				case ILCode.Clt_Un:  				case ILCode.Cgt_Un:  				case ILCode.Cle_Un:  				case ILCode.Cge_Un:  					if (forceInferChildren)  						InferArgumentsInBinaryOperator(expr' false' null);  					return typeSystem.Boolean;  					#endregion  					#region Branch instructions  				case ILCode.Brtrue:  					if (forceInferChildren)  						InferTypeForExpression(expr.Arguments.Single()' typeSystem.Boolean);  					return null;  				case ILCode.Br:  				case ILCode.Leave:  				case ILCode.Endfinally:  				case ILCode.Switch:  				case ILCode.Throw:  				case ILCode.Rethrow:  				case ILCode.LoopOrSwitchBreak:  				case ILCode.LoopContinue:  				case ILCode.YieldBreak:  					return null;  				case ILCode.Ret:  					if (forceInferChildren && expr.Arguments.Count == 1) {  						TypeReference returnType = context.CurrentMethod.ReturnType;  						if (context.CurrentMethodIsAsync && returnType != null && returnType.Namespace == "System.Threading.Tasks") {  							if (returnType.Name == "Task") {  								returnType = typeSystem.Void;  							} else if (returnType.Name == "Task`1" && returnType.IsGenericInstance) {  								returnType = ((GenericInstanceType)returnType).GenericArguments[0];  							}  						}  						InferTypeForExpression(expr.Arguments[0]' returnType);  					}  					return null;  				case ILCode.YieldReturn:  					if (forceInferChildren) {  						GenericInstanceType genericType = context.CurrentMethod.ReturnType as GenericInstanceType;  						if (genericType != null) { // IEnumerable<T> or IEnumerator<T>  							InferTypeForExpression(expr.Arguments[0]' genericType.GenericArguments[0]);  						} else { // non-generic IEnumerable or IEnumerator  							InferTypeForExpression(expr.Arguments[0]' typeSystem.Object);  						}  					}  					return null;  				case ILCode.Await:  					{  						TypeReference taskType = InferTypeForExpression(expr.Arguments[0]' null);  						if (taskType.Name == "Task`1" && taskType.IsGenericInstance && taskType.Namespace == "System.Threading.Tasks") {  							return ((GenericInstanceType)taskType).GenericArguments[0];  						}  						return null;  					}  					#endregion  				case ILCode.Pop:  					return null;  				case ILCode.Wrap:  				case ILCode.Dup:  					{  						var arg = expr.Arguments.Single();  						return arg.ExpectedType = InferTypeForExpression(arg' expectedType);  					}  				default:  					Debug.WriteLine("Type Inference: Can't handle " + expr.Code.GetName());  					return null;  			}
Magic Number,Custom.Decompiler.ILAst,TypeAnalysis,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\TypeAnalysis.cs,DoInferTypeForExpression,The following statement contains a magic number: switch (expr.Code) {  					#region Logical operators  				case ILCode.LogicNot:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments.Single()' typeSystem.Boolean);  					}  					return typeSystem.Boolean;  				case ILCode.LogicAnd:  				case ILCode.LogicOr:  					// if Operand is set the logic and/or expression is a custom operator  					// we can deal with it the same as a normal invocation.  					if (expr.Operand != null)  						goto case ILCode.Call;  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[0]' typeSystem.Boolean);  						InferTypeForExpression(expr.Arguments[1]' typeSystem.Boolean);  					}  					return typeSystem.Boolean;  				case ILCode.TernaryOp:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[0]' typeSystem.Boolean);  					}  					return InferBinaryArguments(expr.Arguments[1]' expr.Arguments[2]' expectedType' forceInferChildren);  				case ILCode.NullCoalescing:  					return InferBinaryArguments(expr.Arguments[0]' expr.Arguments[1]' expectedType' forceInferChildren);  					#endregion  					#region Variable load/store  				case ILCode.Stloc:  					{  						ILVariable v = (ILVariable)expr.Operand;  						if (forceInferChildren) {  							// do not use 'expectedType' in here!  							InferTypeForExpression(expr.Arguments.Single()' v.Type);  						}  						return v.Type;  					}  				case ILCode.Ldloc:  					{  						ILVariable v = (ILVariable)expr.Operand;  						if (v.Type == null && singleLoadVariables.Contains(v)) {  							v.Type = expectedType;  						}  						return v.Type;  					}  				case ILCode.Ldloca:  					{  						ILVariable v = (ILVariable)expr.Operand;  						if (v.Type != null)  							return new ByReferenceType(v.Type);  						else  							return null;  					}  					#endregion  					#region Call / NewObj  				case ILCode.Call:  				case ILCode.Callvirt:  				case ILCode.CallGetter:  				case ILCode.CallvirtGetter:  				case ILCode.CallSetter:  				case ILCode.CallvirtSetter:  					{  						MethodReference method = (MethodReference)expr.Operand;  						if (forceInferChildren) {  							for (int i = 0; i < expr.Arguments.Count; i++) {  								if (i == 0 && method.HasThis) {  									InferTypeForExpression(expr.Arguments[0]' MakeRefIfValueType(method.DeclaringType' expr.GetPrefix(ILCode.Constrained)));  								} else {  									InferTypeForExpression(expr.Arguments[i]' SubstituteTypeArgs(method.Parameters[method.HasThis ? i - 1 : i].ParameterType' method));  								}  							}  						}  						if (expr.Code == ILCode.CallSetter || expr.Code == ILCode.CallvirtSetter) {  							return SubstituteTypeArgs(method.Parameters.Last().ParameterType' method);  						} else {  							return SubstituteTypeArgs(method.ReturnType' method);  						}  					}  				case ILCode.Newobj:  					{  						MethodReference ctor = (MethodReference)expr.Operand;  						if (forceInferChildren) {  							for (int i = 0; i < ctor.Parameters.Count; i++) {  								InferTypeForExpression(expr.Arguments[i]' SubstituteTypeArgs(ctor.Parameters[i].ParameterType' ctor));  							}  						}  						return ctor.DeclaringType;  					}  				case ILCode.InitObject:  				case ILCode.InitCollection:  					return InferTypeForExpression(expr.Arguments[0]' expectedType);  				case ILCode.InitializedObject:  					// expectedType should always be known due to the parent method call / property setter  					Debug.Assert(expectedType != null);  					return expectedType;  					#endregion  					#region Load/Store Fields  				case ILCode.Ldfld:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[0]' MakeRefIfValueType(((FieldReference)expr.Operand).DeclaringType' expr.GetPrefix(ILCode.Constrained)));  					}  					return GetFieldType((FieldReference)expr.Operand);  				case ILCode.Ldsfld:  					return GetFieldType((FieldReference)expr.Operand);  				case ILCode.Ldflda:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[0]' MakeRefIfValueType(((FieldReference)expr.Operand).DeclaringType' expr.GetPrefix(ILCode.Constrained)));  					}  					return new ByReferenceType(GetFieldType((FieldReference)expr.Operand));  				case ILCode.Ldsflda:  					return new ByReferenceType(GetFieldType((FieldReference)expr.Operand));  				case ILCode.Stfld:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[0]' MakeRefIfValueType(((FieldReference)expr.Operand).DeclaringType' expr.GetPrefix(ILCode.Constrained)));  						InferTypeForExpression(expr.Arguments[1]' GetFieldType((FieldReference)expr.Operand));  					}  					return GetFieldType((FieldReference)expr.Operand);  				case ILCode.Stsfld:  					if (forceInferChildren)  						InferTypeForExpression(expr.Arguments[0]' GetFieldType((FieldReference)expr.Operand));  					return GetFieldType((FieldReference)expr.Operand);  					#endregion  					#region Reference/Pointer instructions  				case ILCode.Ldind_Ref:  					return UnpackPointer(InferTypeForExpression(expr.Arguments[0]' null));  				case ILCode.Stind_Ref:  					if (forceInferChildren) {  						TypeReference elementType = UnpackPointer(InferTypeForExpression(expr.Arguments[0]' null));  						InferTypeForExpression(expr.Arguments[1]' elementType);  					}  					return null;  				case ILCode.Ldobj:  					{  						TypeReference type = (TypeReference)expr.Operand;  						var argType = InferTypeForExpression(expr.Arguments[0]' null);  						if (argType is PointerType || argType is ByReferenceType) {  							var elementType = ((TypeSpecification)argType).ElementType;  							int infoAmount = GetInformationAmount(elementType);  							if (infoAmount == 1 && GetInformationAmount(type) == 8) {  								// A bool can be loaded from both bytes and sbytes.  								type = elementType;  							}  							if (infoAmount >= 8 && infoAmount <= 64 && infoAmount == GetInformationAmount(type)) {  								// An integer can be loaded as another integer of the same size.  								// For integers smaller than 32 bit' the signs must match (as loading performs sign extension)  								bool? elementTypeIsSigned = IsSigned(elementType);  								bool? typeIsSigned = IsSigned(type);  								if (elementTypeIsSigned != null && typeIsSigned != null) {  									if (infoAmount >= 32 || elementTypeIsSigned == typeIsSigned)  										type = elementType;  								}  							}  						}  						if (argType is PointerType)  							InferTypeForExpression(expr.Arguments[0]' new PointerType(type));  						else  							InferTypeForExpression(expr.Arguments[0]' new ByReferenceType(type));  						return type;  					}  				case ILCode.Stobj:  					{  						TypeReference operandType = (TypeReference)expr.Operand;  						TypeReference pointerType = InferTypeForExpression(expr.Arguments[0]' new ByReferenceType(operandType));  						TypeReference elementType;  						if (pointerType is PointerType)  							elementType = ((PointerType)pointerType).ElementType;  						else if (pointerType is ByReferenceType)  							elementType = ((ByReferenceType)pointerType).ElementType;  						else  							elementType = null;  						if (elementType != null) {  							// An integer can be stored in any other integer of the same size.  							int infoAmount = GetInformationAmount(elementType);  							if (infoAmount == 1 && GetInformationAmount(operandType) == 8)  								operandType = elementType;  							else if (infoAmount == GetInformationAmount(operandType) && IsSigned(elementType) != null && IsSigned(operandType) != null)  								operandType = elementType;  						}  						if (forceInferChildren) {  							if (pointerType is PointerType)  								InferTypeForExpression(expr.Arguments[0]' new PointerType(operandType));  							else if (!IsSameType(operandType' expr.Operand as TypeReference))  								InferTypeForExpression(expr.Arguments[0]' new ByReferenceType(operandType));  							InferTypeForExpression(expr.Arguments[1]' operandType);  						}  						return operandType;  					}  				case ILCode.Initobj:  					return null;  				case ILCode.DefaultValue:  					return (TypeReference)expr.Operand;  				case ILCode.Localloc:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[0]' typeSystem.Int32);  					}  					if (expectedType is PointerType)  						return expectedType;  					else  						return typeSystem.IntPtr;  				case ILCode.Sizeof:  					return typeSystem.Int32;  				case ILCode.PostIncrement:  				case ILCode.PostIncrement_Ovf:  				case ILCode.PostIncrement_Ovf_Un:  					{  						TypeReference elementType = UnpackPointer(InferTypeForExpression(expr.Arguments[0]' null));  						if (forceInferChildren && elementType != null) {  							// Assign expected type to the child expression  							InferTypeForExpression(expr.Arguments[0]' new ByReferenceType(elementType));  						}  						return elementType;  					}  				case ILCode.Mkrefany:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[0]' (TypeReference)expr.Operand);  					}  					return typeSystem.TypedReference;  				case ILCode.Refanytype:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[0]' typeSystem.TypedReference);  					}                      return new TypeReference("System"' "RuntimeTypeHandle"' module' module.TypeSystem.CoreLibrary' true);  				case ILCode.Refanyval:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[0]' typeSystem.TypedReference);  					}  					return new ByReferenceType((TypeReference)expr.Operand);  				case ILCode.AddressOf:  					{  						TypeReference t = InferTypeForExpression(expr.Arguments[0]' UnpackPointer(expectedType));  						return t != null ? new ByReferenceType(t) : null;  					}  				case ILCode.ValueOf:  					return GetNullableTypeArgument(InferTypeForExpression(expr.Arguments[0]' CreateNullableType(expectedType)));  				case ILCode.NullableOf:  					return CreateNullableType(InferTypeForExpression(expr.Arguments[0]' GetNullableTypeArgument(expectedType)));  					#endregion  					#region Arithmetic instructions  				case ILCode.Not: // bitwise complement  				case ILCode.Neg:  					return InferTypeForExpression(expr.Arguments.Single()' expectedType);  				case ILCode.Add:  					return InferArgumentsInAddition(expr' null' expectedType);  				case ILCode.Sub:  					return InferArgumentsInSubtraction(expr' null' expectedType);  				case ILCode.Mul:  				case ILCode.Or:  				case ILCode.And:  				case ILCode.Xor:  					return InferArgumentsInBinaryOperator(expr' null' expectedType);  				case ILCode.Add_Ovf:  					return InferArgumentsInAddition(expr' true' expectedType);  				case ILCode.Sub_Ovf:  					return InferArgumentsInSubtraction(expr' true' expectedType);  				case ILCode.Mul_Ovf:  				case ILCode.Div:  				case ILCode.Rem:  					return InferArgumentsInBinaryOperator(expr' true' expectedType);  				case ILCode.Add_Ovf_Un:  					return InferArgumentsInAddition(expr' false' expectedType);  				case ILCode.Sub_Ovf_Un:  					return InferArgumentsInSubtraction(expr' false' expectedType);  				case ILCode.Mul_Ovf_Un:  				case ILCode.Div_Un:  				case ILCode.Rem_Un:  					return InferArgumentsInBinaryOperator(expr' false' expectedType);  				case ILCode.Shl:  					if (forceInferChildren)  						InferTypeForExpression(expr.Arguments[1]' typeSystem.Int32);  					if (expectedType != null && (  						expectedType.MetadataType == MetadataType.Int32 || expectedType.MetadataType == MetadataType.UInt32 ||  						expectedType.MetadataType == MetadataType.Int64 || expectedType.MetadataType == MetadataType.UInt64)  					   )  						return NumericPromotion(InferTypeForExpression(expr.Arguments[0]' expectedType));  					else  						return NumericPromotion(InferTypeForExpression(expr.Arguments[0]' null));  				case ILCode.Shr:  				case ILCode.Shr_Un:  					{  						if (forceInferChildren)  							InferTypeForExpression(expr.Arguments[1]' typeSystem.Int32);  						TypeReference type = NumericPromotion(InferTypeForExpression(expr.Arguments[0]' null));  						TypeReference expectedInputType = null;  						switch (type.MetadataType) {  							case MetadataType.Int32:  								if (expr.Code == ILCode.Shr_Un)  									expectedInputType = typeSystem.UInt32;  								break;  							case MetadataType.UInt32:  								if (expr.Code == ILCode.Shr)  									expectedInputType = typeSystem.Int32;  								break;  							case MetadataType.Int64:  								if (expr.Code == ILCode.Shr_Un)  									expectedInputType = typeSystem.UInt64;  								break;  							case MetadataType.UInt64:  								if (expr.Code == ILCode.Shr)  									expectedInputType = typeSystem.UInt64;  								break;  						}  						if (expectedInputType != null) {  							InferTypeForExpression(expr.Arguments[0]' expectedInputType);  							return expectedInputType;  						} else {  							return type;  						}  					}  				case ILCode.CompoundAssignment:  					{  						var op = expr.Arguments[0];  						if (op.Code == ILCode.NullableOf) op = op.Arguments[0].Arguments[0];  						var varType = InferTypeForExpression(op.Arguments[0]' null);  						if (forceInferChildren) {  							InferTypeForExpression(expr.Arguments[0]' varType);  						}  						return varType;  					}  					#endregion  					#region Constant loading instructions  				case ILCode.Ldnull:  					return typeSystem.Object;  				case ILCode.Ldstr:  					return typeSystem.String;  				case ILCode.Ldftn:  				case ILCode.Ldvirtftn:  					return typeSystem.IntPtr;  				case ILCode.Ldc_I4:  					if (IsBoolean(expectedType) && ((int)expr.Operand == 0 || (int)expr.Operand == 1))  						return typeSystem.Boolean;  					if (expectedType is PointerType && (int)expr.Operand == 0)  						return expectedType;  					if (IsIntegerOrEnum(expectedType) && OperandFitsInType(expectedType' (int)expr.Operand))  						return expectedType;  					else  						return typeSystem.Int32;  				case ILCode.Ldc_I8:  					if (expectedType is PointerType && (long)expr.Operand == 0)  						return expectedType;  					if (IsIntegerOrEnum(expectedType) && GetInformationAmount(expectedType) >= NativeInt)  						return expectedType;  					else  						return typeSystem.Int64;  				case ILCode.Ldc_R4:  					return typeSystem.Single;  				case ILCode.Ldc_R8:  					return typeSystem.Double;  				case ILCode.Ldc_Decimal:                      return new TypeReference("System"' "Decimal"' module' module.TypeSystem.CoreLibrary' true);  				case ILCode.Ldtoken:  					if (expr.Operand is TypeReference)  						return new TypeReference("System"' "RuntimeTypeHandle"' module' module.TypeSystem.CoreLibrary' true);  					else if (expr.Operand is FieldReference)                          return new TypeReference("System"' "RuntimeFieldHandle"' module' module.TypeSystem.CoreLibrary' true);  					else                          return new TypeReference("System"' "RuntimeMethodHandle"' module' module.TypeSystem.CoreLibrary' true);  				case ILCode.Arglist:                      return new TypeReference("System"' "RuntimeArgumentHandle"' module' module.TypeSystem.CoreLibrary' true);  					#endregion  					#region Array instructions  				case ILCode.Newarr:  					if (forceInferChildren) {  						var lengthType = InferTypeForExpression(expr.Arguments.Single()' null);  						if (lengthType == typeSystem.IntPtr) {  							lengthType = typeSystem.Int64;  						} else if (lengthType == typeSystem.UIntPtr) {  							lengthType = typeSystem.UInt64;  						} else if (lengthType != typeSystem.UInt32 && lengthType != typeSystem.Int64 && lengthType != typeSystem.UInt64) {  							lengthType = typeSystem.Int32;  						}  						if (forceInferChildren) {  							InferTypeForExpression(expr.Arguments.Single()' lengthType);  						}  					}  					return new ArrayType((TypeReference)expr.Operand);  				case ILCode.InitArray:  					var operandAsArrayType = (ArrayType)expr.Operand;  					if (forceInferChildren)  					{  						foreach (ILExpression arg in expr.Arguments)  							InferTypeForExpression(arg' operandAsArrayType.ElementType);  					}  					return operandAsArrayType;  				case ILCode.Ldlen:  					return typeSystem.Int32;  				case ILCode.Ldelem_U1:  				case ILCode.Ldelem_U2:  				case ILCode.Ldelem_U4:  				case ILCode.Ldelem_I1:  				case ILCode.Ldelem_I2:  				case ILCode.Ldelem_I4:  				case ILCode.Ldelem_I8:  				case ILCode.Ldelem_R4:  				case ILCode.Ldelem_R8:  				case ILCode.Ldelem_I:  				case ILCode.Ldelem_Ref:  					{  						ArrayType arrayType = InferTypeForExpression(expr.Arguments[0]' null) as ArrayType;  						if (forceInferChildren) {  							InferTypeForExpression(expr.Arguments[1]' typeSystem.Int32);  						}  						return arrayType != null ? arrayType.ElementType : null;  					}  				case ILCode.Ldelem_Any:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[1]' typeSystem.Int32);  					}  					return (TypeReference)expr.Operand;  				case ILCode.Ldelema:  					{  						ArrayType arrayType = InferTypeForExpression(expr.Arguments[0]' null) as ArrayType;  						if (forceInferChildren)  							InferTypeForExpression(expr.Arguments[1]' typeSystem.Int32);  						return arrayType != null ? new ByReferenceType(arrayType.ElementType) : null;  					}  				case ILCode.Stelem_I:  				case ILCode.Stelem_I1:  				case ILCode.Stelem_I2:  				case ILCode.Stelem_I4:  				case ILCode.Stelem_I8:  				case ILCode.Stelem_R4:  				case ILCode.Stelem_R8:  				case ILCode.Stelem_Ref:  				case ILCode.Stelem_Any:  					{  						ArrayType arrayType = InferTypeForExpression(expr.Arguments[0]' null) as ArrayType;  						if (forceInferChildren) {  							InferTypeForExpression(expr.Arguments[1]' typeSystem.Int32);  							if (arrayType != null) {  								InferTypeForExpression(expr.Arguments[2]' arrayType.ElementType);  							}  						}  						return arrayType != null ? arrayType.ElementType : null;  					}  					#endregion  					#region Conversion instructions  				case ILCode.Conv_I1:  				case ILCode.Conv_Ovf_I1:  				case ILCode.Conv_Ovf_I1_Un:  					return HandleConversion(8' true' expr.Arguments[0]' expectedType' typeSystem.SByte);  				case ILCode.Conv_I2:  				case ILCode.Conv_Ovf_I2:  				case ILCode.Conv_Ovf_I2_Un:  					return HandleConversion(16' true' expr.Arguments[0]' expectedType' typeSystem.Int16);  				case ILCode.Conv_I4:  				case ILCode.Conv_Ovf_I4:  				case ILCode.Conv_Ovf_I4_Un:  					return HandleConversion(32' true' expr.Arguments[0]' expectedType' typeSystem.Int32);  				case ILCode.Conv_I8:  				case ILCode.Conv_Ovf_I8:  				case ILCode.Conv_Ovf_I8_Un:  					return HandleConversion(64' true' expr.Arguments[0]' expectedType' typeSystem.Int64);  				case ILCode.Conv_U1:  				case ILCode.Conv_Ovf_U1:  				case ILCode.Conv_Ovf_U1_Un:  					return HandleConversion(8' false' expr.Arguments[0]' expectedType' typeSystem.Byte);  				case ILCode.Conv_U2:  				case ILCode.Conv_Ovf_U2:  				case ILCode.Conv_Ovf_U2_Un:  					return HandleConversion(16' false' expr.Arguments[0]' expectedType' typeSystem.UInt16);  				case ILCode.Conv_U4:  				case ILCode.Conv_Ovf_U4:  				case ILCode.Conv_Ovf_U4_Un:  					return HandleConversion(32' false' expr.Arguments[0]' expectedType' typeSystem.UInt32);  				case ILCode.Conv_U8:  				case ILCode.Conv_Ovf_U8:  				case ILCode.Conv_Ovf_U8_Un:  					return HandleConversion(64' false' expr.Arguments[0]' expectedType' typeSystem.UInt64);  				case ILCode.Conv_I:  				case ILCode.Conv_Ovf_I:  				case ILCode.Conv_Ovf_I_Un:  					return HandleConversion(NativeInt' true' expr.Arguments[0]' expectedType' typeSystem.IntPtr);  				case ILCode.Conv_U:  				case ILCode.Conv_Ovf_U:  				case ILCode.Conv_Ovf_U_Un:  					return HandleConversion(NativeInt' false' expr.Arguments[0]' expectedType' typeSystem.UIntPtr);  				case ILCode.Conv_R4:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[0]' typeSystem.Single);  					}  					return typeSystem.Single;  				case ILCode.Conv_R8:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[0]' typeSystem.Double);  					}  					return typeSystem.Double;  				case ILCode.Conv_R_Un:  					return (expectedType != null  && expectedType.MetadataType == MetadataType.Single) ? typeSystem.Single : typeSystem.Double;  				case ILCode.Castclass:  				case ILCode.Unbox_Any:  					return (TypeReference)expr.Operand;  				case ILCode.Unbox:  					return new ByReferenceType((TypeReference)expr.Operand);  				case ILCode.Isinst:  					{  						// isinst performs the equivalent of a cast only for reference types;  						// value types still need to be unboxed after an isinst instruction  						TypeReference tr = (TypeReference)expr.Operand;  						return tr.IsValueType ? typeSystem.Object : tr;  					}  				case ILCode.Box:  					{  						var tr = (TypeReference)expr.Operand;  						if (forceInferChildren)  							InferTypeForExpression(expr.Arguments.Single()' tr);  						return tr.IsValueType ? typeSystem.Object : tr;  					}  					#endregion  					#region Comparison instructions  				case ILCode.Ceq:  				case ILCode.Cne:  					if (forceInferChildren)  						InferArgumentsInBinaryOperator(expr' null' null);  					return typeSystem.Boolean;  				case ILCode.Clt:  				case ILCode.Cgt:  				case ILCode.Cle:  				case ILCode.Cge:  					if (forceInferChildren)  						InferArgumentsInBinaryOperator(expr' true' null);  					return typeSystem.Boolean;  				case ILCode.Clt_Un:  				case ILCode.Cgt_Un:  				case ILCode.Cle_Un:  				case ILCode.Cge_Un:  					if (forceInferChildren)  						InferArgumentsInBinaryOperator(expr' false' null);  					return typeSystem.Boolean;  					#endregion  					#region Branch instructions  				case ILCode.Brtrue:  					if (forceInferChildren)  						InferTypeForExpression(expr.Arguments.Single()' typeSystem.Boolean);  					return null;  				case ILCode.Br:  				case ILCode.Leave:  				case ILCode.Endfinally:  				case ILCode.Switch:  				case ILCode.Throw:  				case ILCode.Rethrow:  				case ILCode.LoopOrSwitchBreak:  				case ILCode.LoopContinue:  				case ILCode.YieldBreak:  					return null;  				case ILCode.Ret:  					if (forceInferChildren && expr.Arguments.Count == 1) {  						TypeReference returnType = context.CurrentMethod.ReturnType;  						if (context.CurrentMethodIsAsync && returnType != null && returnType.Namespace == "System.Threading.Tasks") {  							if (returnType.Name == "Task") {  								returnType = typeSystem.Void;  							} else if (returnType.Name == "Task`1" && returnType.IsGenericInstance) {  								returnType = ((GenericInstanceType)returnType).GenericArguments[0];  							}  						}  						InferTypeForExpression(expr.Arguments[0]' returnType);  					}  					return null;  				case ILCode.YieldReturn:  					if (forceInferChildren) {  						GenericInstanceType genericType = context.CurrentMethod.ReturnType as GenericInstanceType;  						if (genericType != null) { // IEnumerable<T> or IEnumerator<T>  							InferTypeForExpression(expr.Arguments[0]' genericType.GenericArguments[0]);  						} else { // non-generic IEnumerable or IEnumerator  							InferTypeForExpression(expr.Arguments[0]' typeSystem.Object);  						}  					}  					return null;  				case ILCode.Await:  					{  						TypeReference taskType = InferTypeForExpression(expr.Arguments[0]' null);  						if (taskType.Name == "Task`1" && taskType.IsGenericInstance && taskType.Namespace == "System.Threading.Tasks") {  							return ((GenericInstanceType)taskType).GenericArguments[0];  						}  						return null;  					}  					#endregion  				case ILCode.Pop:  					return null;  				case ILCode.Wrap:  				case ILCode.Dup:  					{  						var arg = expr.Arguments.Single();  						return arg.ExpectedType = InferTypeForExpression(arg' expectedType);  					}  				default:  					Debug.WriteLine("Type Inference: Can't handle " + expr.Code.GetName());  					return null;  			}
Magic Number,Custom.Decompiler.ILAst,TypeAnalysis,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\TypeAnalysis.cs,DoInferTypeForExpression,The following statement contains a magic number: switch (expr.Code) {  					#region Logical operators  				case ILCode.LogicNot:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments.Single()' typeSystem.Boolean);  					}  					return typeSystem.Boolean;  				case ILCode.LogicAnd:  				case ILCode.LogicOr:  					// if Operand is set the logic and/or expression is a custom operator  					// we can deal with it the same as a normal invocation.  					if (expr.Operand != null)  						goto case ILCode.Call;  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[0]' typeSystem.Boolean);  						InferTypeForExpression(expr.Arguments[1]' typeSystem.Boolean);  					}  					return typeSystem.Boolean;  				case ILCode.TernaryOp:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[0]' typeSystem.Boolean);  					}  					return InferBinaryArguments(expr.Arguments[1]' expr.Arguments[2]' expectedType' forceInferChildren);  				case ILCode.NullCoalescing:  					return InferBinaryArguments(expr.Arguments[0]' expr.Arguments[1]' expectedType' forceInferChildren);  					#endregion  					#region Variable load/store  				case ILCode.Stloc:  					{  						ILVariable v = (ILVariable)expr.Operand;  						if (forceInferChildren) {  							// do not use 'expectedType' in here!  							InferTypeForExpression(expr.Arguments.Single()' v.Type);  						}  						return v.Type;  					}  				case ILCode.Ldloc:  					{  						ILVariable v = (ILVariable)expr.Operand;  						if (v.Type == null && singleLoadVariables.Contains(v)) {  							v.Type = expectedType;  						}  						return v.Type;  					}  				case ILCode.Ldloca:  					{  						ILVariable v = (ILVariable)expr.Operand;  						if (v.Type != null)  							return new ByReferenceType(v.Type);  						else  							return null;  					}  					#endregion  					#region Call / NewObj  				case ILCode.Call:  				case ILCode.Callvirt:  				case ILCode.CallGetter:  				case ILCode.CallvirtGetter:  				case ILCode.CallSetter:  				case ILCode.CallvirtSetter:  					{  						MethodReference method = (MethodReference)expr.Operand;  						if (forceInferChildren) {  							for (int i = 0; i < expr.Arguments.Count; i++) {  								if (i == 0 && method.HasThis) {  									InferTypeForExpression(expr.Arguments[0]' MakeRefIfValueType(method.DeclaringType' expr.GetPrefix(ILCode.Constrained)));  								} else {  									InferTypeForExpression(expr.Arguments[i]' SubstituteTypeArgs(method.Parameters[method.HasThis ? i - 1 : i].ParameterType' method));  								}  							}  						}  						if (expr.Code == ILCode.CallSetter || expr.Code == ILCode.CallvirtSetter) {  							return SubstituteTypeArgs(method.Parameters.Last().ParameterType' method);  						} else {  							return SubstituteTypeArgs(method.ReturnType' method);  						}  					}  				case ILCode.Newobj:  					{  						MethodReference ctor = (MethodReference)expr.Operand;  						if (forceInferChildren) {  							for (int i = 0; i < ctor.Parameters.Count; i++) {  								InferTypeForExpression(expr.Arguments[i]' SubstituteTypeArgs(ctor.Parameters[i].ParameterType' ctor));  							}  						}  						return ctor.DeclaringType;  					}  				case ILCode.InitObject:  				case ILCode.InitCollection:  					return InferTypeForExpression(expr.Arguments[0]' expectedType);  				case ILCode.InitializedObject:  					// expectedType should always be known due to the parent method call / property setter  					Debug.Assert(expectedType != null);  					return expectedType;  					#endregion  					#region Load/Store Fields  				case ILCode.Ldfld:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[0]' MakeRefIfValueType(((FieldReference)expr.Operand).DeclaringType' expr.GetPrefix(ILCode.Constrained)));  					}  					return GetFieldType((FieldReference)expr.Operand);  				case ILCode.Ldsfld:  					return GetFieldType((FieldReference)expr.Operand);  				case ILCode.Ldflda:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[0]' MakeRefIfValueType(((FieldReference)expr.Operand).DeclaringType' expr.GetPrefix(ILCode.Constrained)));  					}  					return new ByReferenceType(GetFieldType((FieldReference)expr.Operand));  				case ILCode.Ldsflda:  					return new ByReferenceType(GetFieldType((FieldReference)expr.Operand));  				case ILCode.Stfld:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[0]' MakeRefIfValueType(((FieldReference)expr.Operand).DeclaringType' expr.GetPrefix(ILCode.Constrained)));  						InferTypeForExpression(expr.Arguments[1]' GetFieldType((FieldReference)expr.Operand));  					}  					return GetFieldType((FieldReference)expr.Operand);  				case ILCode.Stsfld:  					if (forceInferChildren)  						InferTypeForExpression(expr.Arguments[0]' GetFieldType((FieldReference)expr.Operand));  					return GetFieldType((FieldReference)expr.Operand);  					#endregion  					#region Reference/Pointer instructions  				case ILCode.Ldind_Ref:  					return UnpackPointer(InferTypeForExpression(expr.Arguments[0]' null));  				case ILCode.Stind_Ref:  					if (forceInferChildren) {  						TypeReference elementType = UnpackPointer(InferTypeForExpression(expr.Arguments[0]' null));  						InferTypeForExpression(expr.Arguments[1]' elementType);  					}  					return null;  				case ILCode.Ldobj:  					{  						TypeReference type = (TypeReference)expr.Operand;  						var argType = InferTypeForExpression(expr.Arguments[0]' null);  						if (argType is PointerType || argType is ByReferenceType) {  							var elementType = ((TypeSpecification)argType).ElementType;  							int infoAmount = GetInformationAmount(elementType);  							if (infoAmount == 1 && GetInformationAmount(type) == 8) {  								// A bool can be loaded from both bytes and sbytes.  								type = elementType;  							}  							if (infoAmount >= 8 && infoAmount <= 64 && infoAmount == GetInformationAmount(type)) {  								// An integer can be loaded as another integer of the same size.  								// For integers smaller than 32 bit' the signs must match (as loading performs sign extension)  								bool? elementTypeIsSigned = IsSigned(elementType);  								bool? typeIsSigned = IsSigned(type);  								if (elementTypeIsSigned != null && typeIsSigned != null) {  									if (infoAmount >= 32 || elementTypeIsSigned == typeIsSigned)  										type = elementType;  								}  							}  						}  						if (argType is PointerType)  							InferTypeForExpression(expr.Arguments[0]' new PointerType(type));  						else  							InferTypeForExpression(expr.Arguments[0]' new ByReferenceType(type));  						return type;  					}  				case ILCode.Stobj:  					{  						TypeReference operandType = (TypeReference)expr.Operand;  						TypeReference pointerType = InferTypeForExpression(expr.Arguments[0]' new ByReferenceType(operandType));  						TypeReference elementType;  						if (pointerType is PointerType)  							elementType = ((PointerType)pointerType).ElementType;  						else if (pointerType is ByReferenceType)  							elementType = ((ByReferenceType)pointerType).ElementType;  						else  							elementType = null;  						if (elementType != null) {  							// An integer can be stored in any other integer of the same size.  							int infoAmount = GetInformationAmount(elementType);  							if (infoAmount == 1 && GetInformationAmount(operandType) == 8)  								operandType = elementType;  							else if (infoAmount == GetInformationAmount(operandType) && IsSigned(elementType) != null && IsSigned(operandType) != null)  								operandType = elementType;  						}  						if (forceInferChildren) {  							if (pointerType is PointerType)  								InferTypeForExpression(expr.Arguments[0]' new PointerType(operandType));  							else if (!IsSameType(operandType' expr.Operand as TypeReference))  								InferTypeForExpression(expr.Arguments[0]' new ByReferenceType(operandType));  							InferTypeForExpression(expr.Arguments[1]' operandType);  						}  						return operandType;  					}  				case ILCode.Initobj:  					return null;  				case ILCode.DefaultValue:  					return (TypeReference)expr.Operand;  				case ILCode.Localloc:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[0]' typeSystem.Int32);  					}  					if (expectedType is PointerType)  						return expectedType;  					else  						return typeSystem.IntPtr;  				case ILCode.Sizeof:  					return typeSystem.Int32;  				case ILCode.PostIncrement:  				case ILCode.PostIncrement_Ovf:  				case ILCode.PostIncrement_Ovf_Un:  					{  						TypeReference elementType = UnpackPointer(InferTypeForExpression(expr.Arguments[0]' null));  						if (forceInferChildren && elementType != null) {  							// Assign expected type to the child expression  							InferTypeForExpression(expr.Arguments[0]' new ByReferenceType(elementType));  						}  						return elementType;  					}  				case ILCode.Mkrefany:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[0]' (TypeReference)expr.Operand);  					}  					return typeSystem.TypedReference;  				case ILCode.Refanytype:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[0]' typeSystem.TypedReference);  					}                      return new TypeReference("System"' "RuntimeTypeHandle"' module' module.TypeSystem.CoreLibrary' true);  				case ILCode.Refanyval:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[0]' typeSystem.TypedReference);  					}  					return new ByReferenceType((TypeReference)expr.Operand);  				case ILCode.AddressOf:  					{  						TypeReference t = InferTypeForExpression(expr.Arguments[0]' UnpackPointer(expectedType));  						return t != null ? new ByReferenceType(t) : null;  					}  				case ILCode.ValueOf:  					return GetNullableTypeArgument(InferTypeForExpression(expr.Arguments[0]' CreateNullableType(expectedType)));  				case ILCode.NullableOf:  					return CreateNullableType(InferTypeForExpression(expr.Arguments[0]' GetNullableTypeArgument(expectedType)));  					#endregion  					#region Arithmetic instructions  				case ILCode.Not: // bitwise complement  				case ILCode.Neg:  					return InferTypeForExpression(expr.Arguments.Single()' expectedType);  				case ILCode.Add:  					return InferArgumentsInAddition(expr' null' expectedType);  				case ILCode.Sub:  					return InferArgumentsInSubtraction(expr' null' expectedType);  				case ILCode.Mul:  				case ILCode.Or:  				case ILCode.And:  				case ILCode.Xor:  					return InferArgumentsInBinaryOperator(expr' null' expectedType);  				case ILCode.Add_Ovf:  					return InferArgumentsInAddition(expr' true' expectedType);  				case ILCode.Sub_Ovf:  					return InferArgumentsInSubtraction(expr' true' expectedType);  				case ILCode.Mul_Ovf:  				case ILCode.Div:  				case ILCode.Rem:  					return InferArgumentsInBinaryOperator(expr' true' expectedType);  				case ILCode.Add_Ovf_Un:  					return InferArgumentsInAddition(expr' false' expectedType);  				case ILCode.Sub_Ovf_Un:  					return InferArgumentsInSubtraction(expr' false' expectedType);  				case ILCode.Mul_Ovf_Un:  				case ILCode.Div_Un:  				case ILCode.Rem_Un:  					return InferArgumentsInBinaryOperator(expr' false' expectedType);  				case ILCode.Shl:  					if (forceInferChildren)  						InferTypeForExpression(expr.Arguments[1]' typeSystem.Int32);  					if (expectedType != null && (  						expectedType.MetadataType == MetadataType.Int32 || expectedType.MetadataType == MetadataType.UInt32 ||  						expectedType.MetadataType == MetadataType.Int64 || expectedType.MetadataType == MetadataType.UInt64)  					   )  						return NumericPromotion(InferTypeForExpression(expr.Arguments[0]' expectedType));  					else  						return NumericPromotion(InferTypeForExpression(expr.Arguments[0]' null));  				case ILCode.Shr:  				case ILCode.Shr_Un:  					{  						if (forceInferChildren)  							InferTypeForExpression(expr.Arguments[1]' typeSystem.Int32);  						TypeReference type = NumericPromotion(InferTypeForExpression(expr.Arguments[0]' null));  						TypeReference expectedInputType = null;  						switch (type.MetadataType) {  							case MetadataType.Int32:  								if (expr.Code == ILCode.Shr_Un)  									expectedInputType = typeSystem.UInt32;  								break;  							case MetadataType.UInt32:  								if (expr.Code == ILCode.Shr)  									expectedInputType = typeSystem.Int32;  								break;  							case MetadataType.Int64:  								if (expr.Code == ILCode.Shr_Un)  									expectedInputType = typeSystem.UInt64;  								break;  							case MetadataType.UInt64:  								if (expr.Code == ILCode.Shr)  									expectedInputType = typeSystem.UInt64;  								break;  						}  						if (expectedInputType != null) {  							InferTypeForExpression(expr.Arguments[0]' expectedInputType);  							return expectedInputType;  						} else {  							return type;  						}  					}  				case ILCode.CompoundAssignment:  					{  						var op = expr.Arguments[0];  						if (op.Code == ILCode.NullableOf) op = op.Arguments[0].Arguments[0];  						var varType = InferTypeForExpression(op.Arguments[0]' null);  						if (forceInferChildren) {  							InferTypeForExpression(expr.Arguments[0]' varType);  						}  						return varType;  					}  					#endregion  					#region Constant loading instructions  				case ILCode.Ldnull:  					return typeSystem.Object;  				case ILCode.Ldstr:  					return typeSystem.String;  				case ILCode.Ldftn:  				case ILCode.Ldvirtftn:  					return typeSystem.IntPtr;  				case ILCode.Ldc_I4:  					if (IsBoolean(expectedType) && ((int)expr.Operand == 0 || (int)expr.Operand == 1))  						return typeSystem.Boolean;  					if (expectedType is PointerType && (int)expr.Operand == 0)  						return expectedType;  					if (IsIntegerOrEnum(expectedType) && OperandFitsInType(expectedType' (int)expr.Operand))  						return expectedType;  					else  						return typeSystem.Int32;  				case ILCode.Ldc_I8:  					if (expectedType is PointerType && (long)expr.Operand == 0)  						return expectedType;  					if (IsIntegerOrEnum(expectedType) && GetInformationAmount(expectedType) >= NativeInt)  						return expectedType;  					else  						return typeSystem.Int64;  				case ILCode.Ldc_R4:  					return typeSystem.Single;  				case ILCode.Ldc_R8:  					return typeSystem.Double;  				case ILCode.Ldc_Decimal:                      return new TypeReference("System"' "Decimal"' module' module.TypeSystem.CoreLibrary' true);  				case ILCode.Ldtoken:  					if (expr.Operand is TypeReference)  						return new TypeReference("System"' "RuntimeTypeHandle"' module' module.TypeSystem.CoreLibrary' true);  					else if (expr.Operand is FieldReference)                          return new TypeReference("System"' "RuntimeFieldHandle"' module' module.TypeSystem.CoreLibrary' true);  					else                          return new TypeReference("System"' "RuntimeMethodHandle"' module' module.TypeSystem.CoreLibrary' true);  				case ILCode.Arglist:                      return new TypeReference("System"' "RuntimeArgumentHandle"' module' module.TypeSystem.CoreLibrary' true);  					#endregion  					#region Array instructions  				case ILCode.Newarr:  					if (forceInferChildren) {  						var lengthType = InferTypeForExpression(expr.Arguments.Single()' null);  						if (lengthType == typeSystem.IntPtr) {  							lengthType = typeSystem.Int64;  						} else if (lengthType == typeSystem.UIntPtr) {  							lengthType = typeSystem.UInt64;  						} else if (lengthType != typeSystem.UInt32 && lengthType != typeSystem.Int64 && lengthType != typeSystem.UInt64) {  							lengthType = typeSystem.Int32;  						}  						if (forceInferChildren) {  							InferTypeForExpression(expr.Arguments.Single()' lengthType);  						}  					}  					return new ArrayType((TypeReference)expr.Operand);  				case ILCode.InitArray:  					var operandAsArrayType = (ArrayType)expr.Operand;  					if (forceInferChildren)  					{  						foreach (ILExpression arg in expr.Arguments)  							InferTypeForExpression(arg' operandAsArrayType.ElementType);  					}  					return operandAsArrayType;  				case ILCode.Ldlen:  					return typeSystem.Int32;  				case ILCode.Ldelem_U1:  				case ILCode.Ldelem_U2:  				case ILCode.Ldelem_U4:  				case ILCode.Ldelem_I1:  				case ILCode.Ldelem_I2:  				case ILCode.Ldelem_I4:  				case ILCode.Ldelem_I8:  				case ILCode.Ldelem_R4:  				case ILCode.Ldelem_R8:  				case ILCode.Ldelem_I:  				case ILCode.Ldelem_Ref:  					{  						ArrayType arrayType = InferTypeForExpression(expr.Arguments[0]' null) as ArrayType;  						if (forceInferChildren) {  							InferTypeForExpression(expr.Arguments[1]' typeSystem.Int32);  						}  						return arrayType != null ? arrayType.ElementType : null;  					}  				case ILCode.Ldelem_Any:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[1]' typeSystem.Int32);  					}  					return (TypeReference)expr.Operand;  				case ILCode.Ldelema:  					{  						ArrayType arrayType = InferTypeForExpression(expr.Arguments[0]' null) as ArrayType;  						if (forceInferChildren)  							InferTypeForExpression(expr.Arguments[1]' typeSystem.Int32);  						return arrayType != null ? new ByReferenceType(arrayType.ElementType) : null;  					}  				case ILCode.Stelem_I:  				case ILCode.Stelem_I1:  				case ILCode.Stelem_I2:  				case ILCode.Stelem_I4:  				case ILCode.Stelem_I8:  				case ILCode.Stelem_R4:  				case ILCode.Stelem_R8:  				case ILCode.Stelem_Ref:  				case ILCode.Stelem_Any:  					{  						ArrayType arrayType = InferTypeForExpression(expr.Arguments[0]' null) as ArrayType;  						if (forceInferChildren) {  							InferTypeForExpression(expr.Arguments[1]' typeSystem.Int32);  							if (arrayType != null) {  								InferTypeForExpression(expr.Arguments[2]' arrayType.ElementType);  							}  						}  						return arrayType != null ? arrayType.ElementType : null;  					}  					#endregion  					#region Conversion instructions  				case ILCode.Conv_I1:  				case ILCode.Conv_Ovf_I1:  				case ILCode.Conv_Ovf_I1_Un:  					return HandleConversion(8' true' expr.Arguments[0]' expectedType' typeSystem.SByte);  				case ILCode.Conv_I2:  				case ILCode.Conv_Ovf_I2:  				case ILCode.Conv_Ovf_I2_Un:  					return HandleConversion(16' true' expr.Arguments[0]' expectedType' typeSystem.Int16);  				case ILCode.Conv_I4:  				case ILCode.Conv_Ovf_I4:  				case ILCode.Conv_Ovf_I4_Un:  					return HandleConversion(32' true' expr.Arguments[0]' expectedType' typeSystem.Int32);  				case ILCode.Conv_I8:  				case ILCode.Conv_Ovf_I8:  				case ILCode.Conv_Ovf_I8_Un:  					return HandleConversion(64' true' expr.Arguments[0]' expectedType' typeSystem.Int64);  				case ILCode.Conv_U1:  				case ILCode.Conv_Ovf_U1:  				case ILCode.Conv_Ovf_U1_Un:  					return HandleConversion(8' false' expr.Arguments[0]' expectedType' typeSystem.Byte);  				case ILCode.Conv_U2:  				case ILCode.Conv_Ovf_U2:  				case ILCode.Conv_Ovf_U2_Un:  					return HandleConversion(16' false' expr.Arguments[0]' expectedType' typeSystem.UInt16);  				case ILCode.Conv_U4:  				case ILCode.Conv_Ovf_U4:  				case ILCode.Conv_Ovf_U4_Un:  					return HandleConversion(32' false' expr.Arguments[0]' expectedType' typeSystem.UInt32);  				case ILCode.Conv_U8:  				case ILCode.Conv_Ovf_U8:  				case ILCode.Conv_Ovf_U8_Un:  					return HandleConversion(64' false' expr.Arguments[0]' expectedType' typeSystem.UInt64);  				case ILCode.Conv_I:  				case ILCode.Conv_Ovf_I:  				case ILCode.Conv_Ovf_I_Un:  					return HandleConversion(NativeInt' true' expr.Arguments[0]' expectedType' typeSystem.IntPtr);  				case ILCode.Conv_U:  				case ILCode.Conv_Ovf_U:  				case ILCode.Conv_Ovf_U_Un:  					return HandleConversion(NativeInt' false' expr.Arguments[0]' expectedType' typeSystem.UIntPtr);  				case ILCode.Conv_R4:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[0]' typeSystem.Single);  					}  					return typeSystem.Single;  				case ILCode.Conv_R8:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[0]' typeSystem.Double);  					}  					return typeSystem.Double;  				case ILCode.Conv_R_Un:  					return (expectedType != null  && expectedType.MetadataType == MetadataType.Single) ? typeSystem.Single : typeSystem.Double;  				case ILCode.Castclass:  				case ILCode.Unbox_Any:  					return (TypeReference)expr.Operand;  				case ILCode.Unbox:  					return new ByReferenceType((TypeReference)expr.Operand);  				case ILCode.Isinst:  					{  						// isinst performs the equivalent of a cast only for reference types;  						// value types still need to be unboxed after an isinst instruction  						TypeReference tr = (TypeReference)expr.Operand;  						return tr.IsValueType ? typeSystem.Object : tr;  					}  				case ILCode.Box:  					{  						var tr = (TypeReference)expr.Operand;  						if (forceInferChildren)  							InferTypeForExpression(expr.Arguments.Single()' tr);  						return tr.IsValueType ? typeSystem.Object : tr;  					}  					#endregion  					#region Comparison instructions  				case ILCode.Ceq:  				case ILCode.Cne:  					if (forceInferChildren)  						InferArgumentsInBinaryOperator(expr' null' null);  					return typeSystem.Boolean;  				case ILCode.Clt:  				case ILCode.Cgt:  				case ILCode.Cle:  				case ILCode.Cge:  					if (forceInferChildren)  						InferArgumentsInBinaryOperator(expr' true' null);  					return typeSystem.Boolean;  				case ILCode.Clt_Un:  				case ILCode.Cgt_Un:  				case ILCode.Cle_Un:  				case ILCode.Cge_Un:  					if (forceInferChildren)  						InferArgumentsInBinaryOperator(expr' false' null);  					return typeSystem.Boolean;  					#endregion  					#region Branch instructions  				case ILCode.Brtrue:  					if (forceInferChildren)  						InferTypeForExpression(expr.Arguments.Single()' typeSystem.Boolean);  					return null;  				case ILCode.Br:  				case ILCode.Leave:  				case ILCode.Endfinally:  				case ILCode.Switch:  				case ILCode.Throw:  				case ILCode.Rethrow:  				case ILCode.LoopOrSwitchBreak:  				case ILCode.LoopContinue:  				case ILCode.YieldBreak:  					return null;  				case ILCode.Ret:  					if (forceInferChildren && expr.Arguments.Count == 1) {  						TypeReference returnType = context.CurrentMethod.ReturnType;  						if (context.CurrentMethodIsAsync && returnType != null && returnType.Namespace == "System.Threading.Tasks") {  							if (returnType.Name == "Task") {  								returnType = typeSystem.Void;  							} else if (returnType.Name == "Task`1" && returnType.IsGenericInstance) {  								returnType = ((GenericInstanceType)returnType).GenericArguments[0];  							}  						}  						InferTypeForExpression(expr.Arguments[0]' returnType);  					}  					return null;  				case ILCode.YieldReturn:  					if (forceInferChildren) {  						GenericInstanceType genericType = context.CurrentMethod.ReturnType as GenericInstanceType;  						if (genericType != null) { // IEnumerable<T> or IEnumerator<T>  							InferTypeForExpression(expr.Arguments[0]' genericType.GenericArguments[0]);  						} else { // non-generic IEnumerable or IEnumerator  							InferTypeForExpression(expr.Arguments[0]' typeSystem.Object);  						}  					}  					return null;  				case ILCode.Await:  					{  						TypeReference taskType = InferTypeForExpression(expr.Arguments[0]' null);  						if (taskType.Name == "Task`1" && taskType.IsGenericInstance && taskType.Namespace == "System.Threading.Tasks") {  							return ((GenericInstanceType)taskType).GenericArguments[0];  						}  						return null;  					}  					#endregion  				case ILCode.Pop:  					return null;  				case ILCode.Wrap:  				case ILCode.Dup:  					{  						var arg = expr.Arguments.Single();  						return arg.ExpectedType = InferTypeForExpression(arg' expectedType);  					}  				default:  					Debug.WriteLine("Type Inference: Can't handle " + expr.Code.GetName());  					return null;  			}
Magic Number,Custom.Decompiler.ILAst,TypeAnalysis,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\TypeAnalysis.cs,DoInferTypeForExpression,The following statement contains a magic number: switch (expr.Code) {  					#region Logical operators  				case ILCode.LogicNot:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments.Single()' typeSystem.Boolean);  					}  					return typeSystem.Boolean;  				case ILCode.LogicAnd:  				case ILCode.LogicOr:  					// if Operand is set the logic and/or expression is a custom operator  					// we can deal with it the same as a normal invocation.  					if (expr.Operand != null)  						goto case ILCode.Call;  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[0]' typeSystem.Boolean);  						InferTypeForExpression(expr.Arguments[1]' typeSystem.Boolean);  					}  					return typeSystem.Boolean;  				case ILCode.TernaryOp:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[0]' typeSystem.Boolean);  					}  					return InferBinaryArguments(expr.Arguments[1]' expr.Arguments[2]' expectedType' forceInferChildren);  				case ILCode.NullCoalescing:  					return InferBinaryArguments(expr.Arguments[0]' expr.Arguments[1]' expectedType' forceInferChildren);  					#endregion  					#region Variable load/store  				case ILCode.Stloc:  					{  						ILVariable v = (ILVariable)expr.Operand;  						if (forceInferChildren) {  							// do not use 'expectedType' in here!  							InferTypeForExpression(expr.Arguments.Single()' v.Type);  						}  						return v.Type;  					}  				case ILCode.Ldloc:  					{  						ILVariable v = (ILVariable)expr.Operand;  						if (v.Type == null && singleLoadVariables.Contains(v)) {  							v.Type = expectedType;  						}  						return v.Type;  					}  				case ILCode.Ldloca:  					{  						ILVariable v = (ILVariable)expr.Operand;  						if (v.Type != null)  							return new ByReferenceType(v.Type);  						else  							return null;  					}  					#endregion  					#region Call / NewObj  				case ILCode.Call:  				case ILCode.Callvirt:  				case ILCode.CallGetter:  				case ILCode.CallvirtGetter:  				case ILCode.CallSetter:  				case ILCode.CallvirtSetter:  					{  						MethodReference method = (MethodReference)expr.Operand;  						if (forceInferChildren) {  							for (int i = 0; i < expr.Arguments.Count; i++) {  								if (i == 0 && method.HasThis) {  									InferTypeForExpression(expr.Arguments[0]' MakeRefIfValueType(method.DeclaringType' expr.GetPrefix(ILCode.Constrained)));  								} else {  									InferTypeForExpression(expr.Arguments[i]' SubstituteTypeArgs(method.Parameters[method.HasThis ? i - 1 : i].ParameterType' method));  								}  							}  						}  						if (expr.Code == ILCode.CallSetter || expr.Code == ILCode.CallvirtSetter) {  							return SubstituteTypeArgs(method.Parameters.Last().ParameterType' method);  						} else {  							return SubstituteTypeArgs(method.ReturnType' method);  						}  					}  				case ILCode.Newobj:  					{  						MethodReference ctor = (MethodReference)expr.Operand;  						if (forceInferChildren) {  							for (int i = 0; i < ctor.Parameters.Count; i++) {  								InferTypeForExpression(expr.Arguments[i]' SubstituteTypeArgs(ctor.Parameters[i].ParameterType' ctor));  							}  						}  						return ctor.DeclaringType;  					}  				case ILCode.InitObject:  				case ILCode.InitCollection:  					return InferTypeForExpression(expr.Arguments[0]' expectedType);  				case ILCode.InitializedObject:  					// expectedType should always be known due to the parent method call / property setter  					Debug.Assert(expectedType != null);  					return expectedType;  					#endregion  					#region Load/Store Fields  				case ILCode.Ldfld:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[0]' MakeRefIfValueType(((FieldReference)expr.Operand).DeclaringType' expr.GetPrefix(ILCode.Constrained)));  					}  					return GetFieldType((FieldReference)expr.Operand);  				case ILCode.Ldsfld:  					return GetFieldType((FieldReference)expr.Operand);  				case ILCode.Ldflda:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[0]' MakeRefIfValueType(((FieldReference)expr.Operand).DeclaringType' expr.GetPrefix(ILCode.Constrained)));  					}  					return new ByReferenceType(GetFieldType((FieldReference)expr.Operand));  				case ILCode.Ldsflda:  					return new ByReferenceType(GetFieldType((FieldReference)expr.Operand));  				case ILCode.Stfld:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[0]' MakeRefIfValueType(((FieldReference)expr.Operand).DeclaringType' expr.GetPrefix(ILCode.Constrained)));  						InferTypeForExpression(expr.Arguments[1]' GetFieldType((FieldReference)expr.Operand));  					}  					return GetFieldType((FieldReference)expr.Operand);  				case ILCode.Stsfld:  					if (forceInferChildren)  						InferTypeForExpression(expr.Arguments[0]' GetFieldType((FieldReference)expr.Operand));  					return GetFieldType((FieldReference)expr.Operand);  					#endregion  					#region Reference/Pointer instructions  				case ILCode.Ldind_Ref:  					return UnpackPointer(InferTypeForExpression(expr.Arguments[0]' null));  				case ILCode.Stind_Ref:  					if (forceInferChildren) {  						TypeReference elementType = UnpackPointer(InferTypeForExpression(expr.Arguments[0]' null));  						InferTypeForExpression(expr.Arguments[1]' elementType);  					}  					return null;  				case ILCode.Ldobj:  					{  						TypeReference type = (TypeReference)expr.Operand;  						var argType = InferTypeForExpression(expr.Arguments[0]' null);  						if (argType is PointerType || argType is ByReferenceType) {  							var elementType = ((TypeSpecification)argType).ElementType;  							int infoAmount = GetInformationAmount(elementType);  							if (infoAmount == 1 && GetInformationAmount(type) == 8) {  								// A bool can be loaded from both bytes and sbytes.  								type = elementType;  							}  							if (infoAmount >= 8 && infoAmount <= 64 && infoAmount == GetInformationAmount(type)) {  								// An integer can be loaded as another integer of the same size.  								// For integers smaller than 32 bit' the signs must match (as loading performs sign extension)  								bool? elementTypeIsSigned = IsSigned(elementType);  								bool? typeIsSigned = IsSigned(type);  								if (elementTypeIsSigned != null && typeIsSigned != null) {  									if (infoAmount >= 32 || elementTypeIsSigned == typeIsSigned)  										type = elementType;  								}  							}  						}  						if (argType is PointerType)  							InferTypeForExpression(expr.Arguments[0]' new PointerType(type));  						else  							InferTypeForExpression(expr.Arguments[0]' new ByReferenceType(type));  						return type;  					}  				case ILCode.Stobj:  					{  						TypeReference operandType = (TypeReference)expr.Operand;  						TypeReference pointerType = InferTypeForExpression(expr.Arguments[0]' new ByReferenceType(operandType));  						TypeReference elementType;  						if (pointerType is PointerType)  							elementType = ((PointerType)pointerType).ElementType;  						else if (pointerType is ByReferenceType)  							elementType = ((ByReferenceType)pointerType).ElementType;  						else  							elementType = null;  						if (elementType != null) {  							// An integer can be stored in any other integer of the same size.  							int infoAmount = GetInformationAmount(elementType);  							if (infoAmount == 1 && GetInformationAmount(operandType) == 8)  								operandType = elementType;  							else if (infoAmount == GetInformationAmount(operandType) && IsSigned(elementType) != null && IsSigned(operandType) != null)  								operandType = elementType;  						}  						if (forceInferChildren) {  							if (pointerType is PointerType)  								InferTypeForExpression(expr.Arguments[0]' new PointerType(operandType));  							else if (!IsSameType(operandType' expr.Operand as TypeReference))  								InferTypeForExpression(expr.Arguments[0]' new ByReferenceType(operandType));  							InferTypeForExpression(expr.Arguments[1]' operandType);  						}  						return operandType;  					}  				case ILCode.Initobj:  					return null;  				case ILCode.DefaultValue:  					return (TypeReference)expr.Operand;  				case ILCode.Localloc:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[0]' typeSystem.Int32);  					}  					if (expectedType is PointerType)  						return expectedType;  					else  						return typeSystem.IntPtr;  				case ILCode.Sizeof:  					return typeSystem.Int32;  				case ILCode.PostIncrement:  				case ILCode.PostIncrement_Ovf:  				case ILCode.PostIncrement_Ovf_Un:  					{  						TypeReference elementType = UnpackPointer(InferTypeForExpression(expr.Arguments[0]' null));  						if (forceInferChildren && elementType != null) {  							// Assign expected type to the child expression  							InferTypeForExpression(expr.Arguments[0]' new ByReferenceType(elementType));  						}  						return elementType;  					}  				case ILCode.Mkrefany:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[0]' (TypeReference)expr.Operand);  					}  					return typeSystem.TypedReference;  				case ILCode.Refanytype:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[0]' typeSystem.TypedReference);  					}                      return new TypeReference("System"' "RuntimeTypeHandle"' module' module.TypeSystem.CoreLibrary' true);  				case ILCode.Refanyval:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[0]' typeSystem.TypedReference);  					}  					return new ByReferenceType((TypeReference)expr.Operand);  				case ILCode.AddressOf:  					{  						TypeReference t = InferTypeForExpression(expr.Arguments[0]' UnpackPointer(expectedType));  						return t != null ? new ByReferenceType(t) : null;  					}  				case ILCode.ValueOf:  					return GetNullableTypeArgument(InferTypeForExpression(expr.Arguments[0]' CreateNullableType(expectedType)));  				case ILCode.NullableOf:  					return CreateNullableType(InferTypeForExpression(expr.Arguments[0]' GetNullableTypeArgument(expectedType)));  					#endregion  					#region Arithmetic instructions  				case ILCode.Not: // bitwise complement  				case ILCode.Neg:  					return InferTypeForExpression(expr.Arguments.Single()' expectedType);  				case ILCode.Add:  					return InferArgumentsInAddition(expr' null' expectedType);  				case ILCode.Sub:  					return InferArgumentsInSubtraction(expr' null' expectedType);  				case ILCode.Mul:  				case ILCode.Or:  				case ILCode.And:  				case ILCode.Xor:  					return InferArgumentsInBinaryOperator(expr' null' expectedType);  				case ILCode.Add_Ovf:  					return InferArgumentsInAddition(expr' true' expectedType);  				case ILCode.Sub_Ovf:  					return InferArgumentsInSubtraction(expr' true' expectedType);  				case ILCode.Mul_Ovf:  				case ILCode.Div:  				case ILCode.Rem:  					return InferArgumentsInBinaryOperator(expr' true' expectedType);  				case ILCode.Add_Ovf_Un:  					return InferArgumentsInAddition(expr' false' expectedType);  				case ILCode.Sub_Ovf_Un:  					return InferArgumentsInSubtraction(expr' false' expectedType);  				case ILCode.Mul_Ovf_Un:  				case ILCode.Div_Un:  				case ILCode.Rem_Un:  					return InferArgumentsInBinaryOperator(expr' false' expectedType);  				case ILCode.Shl:  					if (forceInferChildren)  						InferTypeForExpression(expr.Arguments[1]' typeSystem.Int32);  					if (expectedType != null && (  						expectedType.MetadataType == MetadataType.Int32 || expectedType.MetadataType == MetadataType.UInt32 ||  						expectedType.MetadataType == MetadataType.Int64 || expectedType.MetadataType == MetadataType.UInt64)  					   )  						return NumericPromotion(InferTypeForExpression(expr.Arguments[0]' expectedType));  					else  						return NumericPromotion(InferTypeForExpression(expr.Arguments[0]' null));  				case ILCode.Shr:  				case ILCode.Shr_Un:  					{  						if (forceInferChildren)  							InferTypeForExpression(expr.Arguments[1]' typeSystem.Int32);  						TypeReference type = NumericPromotion(InferTypeForExpression(expr.Arguments[0]' null));  						TypeReference expectedInputType = null;  						switch (type.MetadataType) {  							case MetadataType.Int32:  								if (expr.Code == ILCode.Shr_Un)  									expectedInputType = typeSystem.UInt32;  								break;  							case MetadataType.UInt32:  								if (expr.Code == ILCode.Shr)  									expectedInputType = typeSystem.Int32;  								break;  							case MetadataType.Int64:  								if (expr.Code == ILCode.Shr_Un)  									expectedInputType = typeSystem.UInt64;  								break;  							case MetadataType.UInt64:  								if (expr.Code == ILCode.Shr)  									expectedInputType = typeSystem.UInt64;  								break;  						}  						if (expectedInputType != null) {  							InferTypeForExpression(expr.Arguments[0]' expectedInputType);  							return expectedInputType;  						} else {  							return type;  						}  					}  				case ILCode.CompoundAssignment:  					{  						var op = expr.Arguments[0];  						if (op.Code == ILCode.NullableOf) op = op.Arguments[0].Arguments[0];  						var varType = InferTypeForExpression(op.Arguments[0]' null);  						if (forceInferChildren) {  							InferTypeForExpression(expr.Arguments[0]' varType);  						}  						return varType;  					}  					#endregion  					#region Constant loading instructions  				case ILCode.Ldnull:  					return typeSystem.Object;  				case ILCode.Ldstr:  					return typeSystem.String;  				case ILCode.Ldftn:  				case ILCode.Ldvirtftn:  					return typeSystem.IntPtr;  				case ILCode.Ldc_I4:  					if (IsBoolean(expectedType) && ((int)expr.Operand == 0 || (int)expr.Operand == 1))  						return typeSystem.Boolean;  					if (expectedType is PointerType && (int)expr.Operand == 0)  						return expectedType;  					if (IsIntegerOrEnum(expectedType) && OperandFitsInType(expectedType' (int)expr.Operand))  						return expectedType;  					else  						return typeSystem.Int32;  				case ILCode.Ldc_I8:  					if (expectedType is PointerType && (long)expr.Operand == 0)  						return expectedType;  					if (IsIntegerOrEnum(expectedType) && GetInformationAmount(expectedType) >= NativeInt)  						return expectedType;  					else  						return typeSystem.Int64;  				case ILCode.Ldc_R4:  					return typeSystem.Single;  				case ILCode.Ldc_R8:  					return typeSystem.Double;  				case ILCode.Ldc_Decimal:                      return new TypeReference("System"' "Decimal"' module' module.TypeSystem.CoreLibrary' true);  				case ILCode.Ldtoken:  					if (expr.Operand is TypeReference)  						return new TypeReference("System"' "RuntimeTypeHandle"' module' module.TypeSystem.CoreLibrary' true);  					else if (expr.Operand is FieldReference)                          return new TypeReference("System"' "RuntimeFieldHandle"' module' module.TypeSystem.CoreLibrary' true);  					else                          return new TypeReference("System"' "RuntimeMethodHandle"' module' module.TypeSystem.CoreLibrary' true);  				case ILCode.Arglist:                      return new TypeReference("System"' "RuntimeArgumentHandle"' module' module.TypeSystem.CoreLibrary' true);  					#endregion  					#region Array instructions  				case ILCode.Newarr:  					if (forceInferChildren) {  						var lengthType = InferTypeForExpression(expr.Arguments.Single()' null);  						if (lengthType == typeSystem.IntPtr) {  							lengthType = typeSystem.Int64;  						} else if (lengthType == typeSystem.UIntPtr) {  							lengthType = typeSystem.UInt64;  						} else if (lengthType != typeSystem.UInt32 && lengthType != typeSystem.Int64 && lengthType != typeSystem.UInt64) {  							lengthType = typeSystem.Int32;  						}  						if (forceInferChildren) {  							InferTypeForExpression(expr.Arguments.Single()' lengthType);  						}  					}  					return new ArrayType((TypeReference)expr.Operand);  				case ILCode.InitArray:  					var operandAsArrayType = (ArrayType)expr.Operand;  					if (forceInferChildren)  					{  						foreach (ILExpression arg in expr.Arguments)  							InferTypeForExpression(arg' operandAsArrayType.ElementType);  					}  					return operandAsArrayType;  				case ILCode.Ldlen:  					return typeSystem.Int32;  				case ILCode.Ldelem_U1:  				case ILCode.Ldelem_U2:  				case ILCode.Ldelem_U4:  				case ILCode.Ldelem_I1:  				case ILCode.Ldelem_I2:  				case ILCode.Ldelem_I4:  				case ILCode.Ldelem_I8:  				case ILCode.Ldelem_R4:  				case ILCode.Ldelem_R8:  				case ILCode.Ldelem_I:  				case ILCode.Ldelem_Ref:  					{  						ArrayType arrayType = InferTypeForExpression(expr.Arguments[0]' null) as ArrayType;  						if (forceInferChildren) {  							InferTypeForExpression(expr.Arguments[1]' typeSystem.Int32);  						}  						return arrayType != null ? arrayType.ElementType : null;  					}  				case ILCode.Ldelem_Any:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[1]' typeSystem.Int32);  					}  					return (TypeReference)expr.Operand;  				case ILCode.Ldelema:  					{  						ArrayType arrayType = InferTypeForExpression(expr.Arguments[0]' null) as ArrayType;  						if (forceInferChildren)  							InferTypeForExpression(expr.Arguments[1]' typeSystem.Int32);  						return arrayType != null ? new ByReferenceType(arrayType.ElementType) : null;  					}  				case ILCode.Stelem_I:  				case ILCode.Stelem_I1:  				case ILCode.Stelem_I2:  				case ILCode.Stelem_I4:  				case ILCode.Stelem_I8:  				case ILCode.Stelem_R4:  				case ILCode.Stelem_R8:  				case ILCode.Stelem_Ref:  				case ILCode.Stelem_Any:  					{  						ArrayType arrayType = InferTypeForExpression(expr.Arguments[0]' null) as ArrayType;  						if (forceInferChildren) {  							InferTypeForExpression(expr.Arguments[1]' typeSystem.Int32);  							if (arrayType != null) {  								InferTypeForExpression(expr.Arguments[2]' arrayType.ElementType);  							}  						}  						return arrayType != null ? arrayType.ElementType : null;  					}  					#endregion  					#region Conversion instructions  				case ILCode.Conv_I1:  				case ILCode.Conv_Ovf_I1:  				case ILCode.Conv_Ovf_I1_Un:  					return HandleConversion(8' true' expr.Arguments[0]' expectedType' typeSystem.SByte);  				case ILCode.Conv_I2:  				case ILCode.Conv_Ovf_I2:  				case ILCode.Conv_Ovf_I2_Un:  					return HandleConversion(16' true' expr.Arguments[0]' expectedType' typeSystem.Int16);  				case ILCode.Conv_I4:  				case ILCode.Conv_Ovf_I4:  				case ILCode.Conv_Ovf_I4_Un:  					return HandleConversion(32' true' expr.Arguments[0]' expectedType' typeSystem.Int32);  				case ILCode.Conv_I8:  				case ILCode.Conv_Ovf_I8:  				case ILCode.Conv_Ovf_I8_Un:  					return HandleConversion(64' true' expr.Arguments[0]' expectedType' typeSystem.Int64);  				case ILCode.Conv_U1:  				case ILCode.Conv_Ovf_U1:  				case ILCode.Conv_Ovf_U1_Un:  					return HandleConversion(8' false' expr.Arguments[0]' expectedType' typeSystem.Byte);  				case ILCode.Conv_U2:  				case ILCode.Conv_Ovf_U2:  				case ILCode.Conv_Ovf_U2_Un:  					return HandleConversion(16' false' expr.Arguments[0]' expectedType' typeSystem.UInt16);  				case ILCode.Conv_U4:  				case ILCode.Conv_Ovf_U4:  				case ILCode.Conv_Ovf_U4_Un:  					return HandleConversion(32' false' expr.Arguments[0]' expectedType' typeSystem.UInt32);  				case ILCode.Conv_U8:  				case ILCode.Conv_Ovf_U8:  				case ILCode.Conv_Ovf_U8_Un:  					return HandleConversion(64' false' expr.Arguments[0]' expectedType' typeSystem.UInt64);  				case ILCode.Conv_I:  				case ILCode.Conv_Ovf_I:  				case ILCode.Conv_Ovf_I_Un:  					return HandleConversion(NativeInt' true' expr.Arguments[0]' expectedType' typeSystem.IntPtr);  				case ILCode.Conv_U:  				case ILCode.Conv_Ovf_U:  				case ILCode.Conv_Ovf_U_Un:  					return HandleConversion(NativeInt' false' expr.Arguments[0]' expectedType' typeSystem.UIntPtr);  				case ILCode.Conv_R4:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[0]' typeSystem.Single);  					}  					return typeSystem.Single;  				case ILCode.Conv_R8:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[0]' typeSystem.Double);  					}  					return typeSystem.Double;  				case ILCode.Conv_R_Un:  					return (expectedType != null  && expectedType.MetadataType == MetadataType.Single) ? typeSystem.Single : typeSystem.Double;  				case ILCode.Castclass:  				case ILCode.Unbox_Any:  					return (TypeReference)expr.Operand;  				case ILCode.Unbox:  					return new ByReferenceType((TypeReference)expr.Operand);  				case ILCode.Isinst:  					{  						// isinst performs the equivalent of a cast only for reference types;  						// value types still need to be unboxed after an isinst instruction  						TypeReference tr = (TypeReference)expr.Operand;  						return tr.IsValueType ? typeSystem.Object : tr;  					}  				case ILCode.Box:  					{  						var tr = (TypeReference)expr.Operand;  						if (forceInferChildren)  							InferTypeForExpression(expr.Arguments.Single()' tr);  						return tr.IsValueType ? typeSystem.Object : tr;  					}  					#endregion  					#region Comparison instructions  				case ILCode.Ceq:  				case ILCode.Cne:  					if (forceInferChildren)  						InferArgumentsInBinaryOperator(expr' null' null);  					return typeSystem.Boolean;  				case ILCode.Clt:  				case ILCode.Cgt:  				case ILCode.Cle:  				case ILCode.Cge:  					if (forceInferChildren)  						InferArgumentsInBinaryOperator(expr' true' null);  					return typeSystem.Boolean;  				case ILCode.Clt_Un:  				case ILCode.Cgt_Un:  				case ILCode.Cle_Un:  				case ILCode.Cge_Un:  					if (forceInferChildren)  						InferArgumentsInBinaryOperator(expr' false' null);  					return typeSystem.Boolean;  					#endregion  					#region Branch instructions  				case ILCode.Brtrue:  					if (forceInferChildren)  						InferTypeForExpression(expr.Arguments.Single()' typeSystem.Boolean);  					return null;  				case ILCode.Br:  				case ILCode.Leave:  				case ILCode.Endfinally:  				case ILCode.Switch:  				case ILCode.Throw:  				case ILCode.Rethrow:  				case ILCode.LoopOrSwitchBreak:  				case ILCode.LoopContinue:  				case ILCode.YieldBreak:  					return null;  				case ILCode.Ret:  					if (forceInferChildren && expr.Arguments.Count == 1) {  						TypeReference returnType = context.CurrentMethod.ReturnType;  						if (context.CurrentMethodIsAsync && returnType != null && returnType.Namespace == "System.Threading.Tasks") {  							if (returnType.Name == "Task") {  								returnType = typeSystem.Void;  							} else if (returnType.Name == "Task`1" && returnType.IsGenericInstance) {  								returnType = ((GenericInstanceType)returnType).GenericArguments[0];  							}  						}  						InferTypeForExpression(expr.Arguments[0]' returnType);  					}  					return null;  				case ILCode.YieldReturn:  					if (forceInferChildren) {  						GenericInstanceType genericType = context.CurrentMethod.ReturnType as GenericInstanceType;  						if (genericType != null) { // IEnumerable<T> or IEnumerator<T>  							InferTypeForExpression(expr.Arguments[0]' genericType.GenericArguments[0]);  						} else { // non-generic IEnumerable or IEnumerator  							InferTypeForExpression(expr.Arguments[0]' typeSystem.Object);  						}  					}  					return null;  				case ILCode.Await:  					{  						TypeReference taskType = InferTypeForExpression(expr.Arguments[0]' null);  						if (taskType.Name == "Task`1" && taskType.IsGenericInstance && taskType.Namespace == "System.Threading.Tasks") {  							return ((GenericInstanceType)taskType).GenericArguments[0];  						}  						return null;  					}  					#endregion  				case ILCode.Pop:  					return null;  				case ILCode.Wrap:  				case ILCode.Dup:  					{  						var arg = expr.Arguments.Single();  						return arg.ExpectedType = InferTypeForExpression(arg' expectedType);  					}  				default:  					Debug.WriteLine("Type Inference: Can't handle " + expr.Code.GetName());  					return null;  			}
Magic Number,Custom.Decompiler.ILAst,TypeAnalysis,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\TypeAnalysis.cs,DoInferTypeForExpression,The following statement contains a magic number: switch (expr.Code) {  					#region Logical operators  				case ILCode.LogicNot:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments.Single()' typeSystem.Boolean);  					}  					return typeSystem.Boolean;  				case ILCode.LogicAnd:  				case ILCode.LogicOr:  					// if Operand is set the logic and/or expression is a custom operator  					// we can deal with it the same as a normal invocation.  					if (expr.Operand != null)  						goto case ILCode.Call;  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[0]' typeSystem.Boolean);  						InferTypeForExpression(expr.Arguments[1]' typeSystem.Boolean);  					}  					return typeSystem.Boolean;  				case ILCode.TernaryOp:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[0]' typeSystem.Boolean);  					}  					return InferBinaryArguments(expr.Arguments[1]' expr.Arguments[2]' expectedType' forceInferChildren);  				case ILCode.NullCoalescing:  					return InferBinaryArguments(expr.Arguments[0]' expr.Arguments[1]' expectedType' forceInferChildren);  					#endregion  					#region Variable load/store  				case ILCode.Stloc:  					{  						ILVariable v = (ILVariable)expr.Operand;  						if (forceInferChildren) {  							// do not use 'expectedType' in here!  							InferTypeForExpression(expr.Arguments.Single()' v.Type);  						}  						return v.Type;  					}  				case ILCode.Ldloc:  					{  						ILVariable v = (ILVariable)expr.Operand;  						if (v.Type == null && singleLoadVariables.Contains(v)) {  							v.Type = expectedType;  						}  						return v.Type;  					}  				case ILCode.Ldloca:  					{  						ILVariable v = (ILVariable)expr.Operand;  						if (v.Type != null)  							return new ByReferenceType(v.Type);  						else  							return null;  					}  					#endregion  					#region Call / NewObj  				case ILCode.Call:  				case ILCode.Callvirt:  				case ILCode.CallGetter:  				case ILCode.CallvirtGetter:  				case ILCode.CallSetter:  				case ILCode.CallvirtSetter:  					{  						MethodReference method = (MethodReference)expr.Operand;  						if (forceInferChildren) {  							for (int i = 0; i < expr.Arguments.Count; i++) {  								if (i == 0 && method.HasThis) {  									InferTypeForExpression(expr.Arguments[0]' MakeRefIfValueType(method.DeclaringType' expr.GetPrefix(ILCode.Constrained)));  								} else {  									InferTypeForExpression(expr.Arguments[i]' SubstituteTypeArgs(method.Parameters[method.HasThis ? i - 1 : i].ParameterType' method));  								}  							}  						}  						if (expr.Code == ILCode.CallSetter || expr.Code == ILCode.CallvirtSetter) {  							return SubstituteTypeArgs(method.Parameters.Last().ParameterType' method);  						} else {  							return SubstituteTypeArgs(method.ReturnType' method);  						}  					}  				case ILCode.Newobj:  					{  						MethodReference ctor = (MethodReference)expr.Operand;  						if (forceInferChildren) {  							for (int i = 0; i < ctor.Parameters.Count; i++) {  								InferTypeForExpression(expr.Arguments[i]' SubstituteTypeArgs(ctor.Parameters[i].ParameterType' ctor));  							}  						}  						return ctor.DeclaringType;  					}  				case ILCode.InitObject:  				case ILCode.InitCollection:  					return InferTypeForExpression(expr.Arguments[0]' expectedType);  				case ILCode.InitializedObject:  					// expectedType should always be known due to the parent method call / property setter  					Debug.Assert(expectedType != null);  					return expectedType;  					#endregion  					#region Load/Store Fields  				case ILCode.Ldfld:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[0]' MakeRefIfValueType(((FieldReference)expr.Operand).DeclaringType' expr.GetPrefix(ILCode.Constrained)));  					}  					return GetFieldType((FieldReference)expr.Operand);  				case ILCode.Ldsfld:  					return GetFieldType((FieldReference)expr.Operand);  				case ILCode.Ldflda:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[0]' MakeRefIfValueType(((FieldReference)expr.Operand).DeclaringType' expr.GetPrefix(ILCode.Constrained)));  					}  					return new ByReferenceType(GetFieldType((FieldReference)expr.Operand));  				case ILCode.Ldsflda:  					return new ByReferenceType(GetFieldType((FieldReference)expr.Operand));  				case ILCode.Stfld:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[0]' MakeRefIfValueType(((FieldReference)expr.Operand).DeclaringType' expr.GetPrefix(ILCode.Constrained)));  						InferTypeForExpression(expr.Arguments[1]' GetFieldType((FieldReference)expr.Operand));  					}  					return GetFieldType((FieldReference)expr.Operand);  				case ILCode.Stsfld:  					if (forceInferChildren)  						InferTypeForExpression(expr.Arguments[0]' GetFieldType((FieldReference)expr.Operand));  					return GetFieldType((FieldReference)expr.Operand);  					#endregion  					#region Reference/Pointer instructions  				case ILCode.Ldind_Ref:  					return UnpackPointer(InferTypeForExpression(expr.Arguments[0]' null));  				case ILCode.Stind_Ref:  					if (forceInferChildren) {  						TypeReference elementType = UnpackPointer(InferTypeForExpression(expr.Arguments[0]' null));  						InferTypeForExpression(expr.Arguments[1]' elementType);  					}  					return null;  				case ILCode.Ldobj:  					{  						TypeReference type = (TypeReference)expr.Operand;  						var argType = InferTypeForExpression(expr.Arguments[0]' null);  						if (argType is PointerType || argType is ByReferenceType) {  							var elementType = ((TypeSpecification)argType).ElementType;  							int infoAmount = GetInformationAmount(elementType);  							if (infoAmount == 1 && GetInformationAmount(type) == 8) {  								// A bool can be loaded from both bytes and sbytes.  								type = elementType;  							}  							if (infoAmount >= 8 && infoAmount <= 64 && infoAmount == GetInformationAmount(type)) {  								// An integer can be loaded as another integer of the same size.  								// For integers smaller than 32 bit' the signs must match (as loading performs sign extension)  								bool? elementTypeIsSigned = IsSigned(elementType);  								bool? typeIsSigned = IsSigned(type);  								if (elementTypeIsSigned != null && typeIsSigned != null) {  									if (infoAmount >= 32 || elementTypeIsSigned == typeIsSigned)  										type = elementType;  								}  							}  						}  						if (argType is PointerType)  							InferTypeForExpression(expr.Arguments[0]' new PointerType(type));  						else  							InferTypeForExpression(expr.Arguments[0]' new ByReferenceType(type));  						return type;  					}  				case ILCode.Stobj:  					{  						TypeReference operandType = (TypeReference)expr.Operand;  						TypeReference pointerType = InferTypeForExpression(expr.Arguments[0]' new ByReferenceType(operandType));  						TypeReference elementType;  						if (pointerType is PointerType)  							elementType = ((PointerType)pointerType).ElementType;  						else if (pointerType is ByReferenceType)  							elementType = ((ByReferenceType)pointerType).ElementType;  						else  							elementType = null;  						if (elementType != null) {  							// An integer can be stored in any other integer of the same size.  							int infoAmount = GetInformationAmount(elementType);  							if (infoAmount == 1 && GetInformationAmount(operandType) == 8)  								operandType = elementType;  							else if (infoAmount == GetInformationAmount(operandType) && IsSigned(elementType) != null && IsSigned(operandType) != null)  								operandType = elementType;  						}  						if (forceInferChildren) {  							if (pointerType is PointerType)  								InferTypeForExpression(expr.Arguments[0]' new PointerType(operandType));  							else if (!IsSameType(operandType' expr.Operand as TypeReference))  								InferTypeForExpression(expr.Arguments[0]' new ByReferenceType(operandType));  							InferTypeForExpression(expr.Arguments[1]' operandType);  						}  						return operandType;  					}  				case ILCode.Initobj:  					return null;  				case ILCode.DefaultValue:  					return (TypeReference)expr.Operand;  				case ILCode.Localloc:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[0]' typeSystem.Int32);  					}  					if (expectedType is PointerType)  						return expectedType;  					else  						return typeSystem.IntPtr;  				case ILCode.Sizeof:  					return typeSystem.Int32;  				case ILCode.PostIncrement:  				case ILCode.PostIncrement_Ovf:  				case ILCode.PostIncrement_Ovf_Un:  					{  						TypeReference elementType = UnpackPointer(InferTypeForExpression(expr.Arguments[0]' null));  						if (forceInferChildren && elementType != null) {  							// Assign expected type to the child expression  							InferTypeForExpression(expr.Arguments[0]' new ByReferenceType(elementType));  						}  						return elementType;  					}  				case ILCode.Mkrefany:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[0]' (TypeReference)expr.Operand);  					}  					return typeSystem.TypedReference;  				case ILCode.Refanytype:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[0]' typeSystem.TypedReference);  					}                      return new TypeReference("System"' "RuntimeTypeHandle"' module' module.TypeSystem.CoreLibrary' true);  				case ILCode.Refanyval:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[0]' typeSystem.TypedReference);  					}  					return new ByReferenceType((TypeReference)expr.Operand);  				case ILCode.AddressOf:  					{  						TypeReference t = InferTypeForExpression(expr.Arguments[0]' UnpackPointer(expectedType));  						return t != null ? new ByReferenceType(t) : null;  					}  				case ILCode.ValueOf:  					return GetNullableTypeArgument(InferTypeForExpression(expr.Arguments[0]' CreateNullableType(expectedType)));  				case ILCode.NullableOf:  					return CreateNullableType(InferTypeForExpression(expr.Arguments[0]' GetNullableTypeArgument(expectedType)));  					#endregion  					#region Arithmetic instructions  				case ILCode.Not: // bitwise complement  				case ILCode.Neg:  					return InferTypeForExpression(expr.Arguments.Single()' expectedType);  				case ILCode.Add:  					return InferArgumentsInAddition(expr' null' expectedType);  				case ILCode.Sub:  					return InferArgumentsInSubtraction(expr' null' expectedType);  				case ILCode.Mul:  				case ILCode.Or:  				case ILCode.And:  				case ILCode.Xor:  					return InferArgumentsInBinaryOperator(expr' null' expectedType);  				case ILCode.Add_Ovf:  					return InferArgumentsInAddition(expr' true' expectedType);  				case ILCode.Sub_Ovf:  					return InferArgumentsInSubtraction(expr' true' expectedType);  				case ILCode.Mul_Ovf:  				case ILCode.Div:  				case ILCode.Rem:  					return InferArgumentsInBinaryOperator(expr' true' expectedType);  				case ILCode.Add_Ovf_Un:  					return InferArgumentsInAddition(expr' false' expectedType);  				case ILCode.Sub_Ovf_Un:  					return InferArgumentsInSubtraction(expr' false' expectedType);  				case ILCode.Mul_Ovf_Un:  				case ILCode.Div_Un:  				case ILCode.Rem_Un:  					return InferArgumentsInBinaryOperator(expr' false' expectedType);  				case ILCode.Shl:  					if (forceInferChildren)  						InferTypeForExpression(expr.Arguments[1]' typeSystem.Int32);  					if (expectedType != null && (  						expectedType.MetadataType == MetadataType.Int32 || expectedType.MetadataType == MetadataType.UInt32 ||  						expectedType.MetadataType == MetadataType.Int64 || expectedType.MetadataType == MetadataType.UInt64)  					   )  						return NumericPromotion(InferTypeForExpression(expr.Arguments[0]' expectedType));  					else  						return NumericPromotion(InferTypeForExpression(expr.Arguments[0]' null));  				case ILCode.Shr:  				case ILCode.Shr_Un:  					{  						if (forceInferChildren)  							InferTypeForExpression(expr.Arguments[1]' typeSystem.Int32);  						TypeReference type = NumericPromotion(InferTypeForExpression(expr.Arguments[0]' null));  						TypeReference expectedInputType = null;  						switch (type.MetadataType) {  							case MetadataType.Int32:  								if (expr.Code == ILCode.Shr_Un)  									expectedInputType = typeSystem.UInt32;  								break;  							case MetadataType.UInt32:  								if (expr.Code == ILCode.Shr)  									expectedInputType = typeSystem.Int32;  								break;  							case MetadataType.Int64:  								if (expr.Code == ILCode.Shr_Un)  									expectedInputType = typeSystem.UInt64;  								break;  							case MetadataType.UInt64:  								if (expr.Code == ILCode.Shr)  									expectedInputType = typeSystem.UInt64;  								break;  						}  						if (expectedInputType != null) {  							InferTypeForExpression(expr.Arguments[0]' expectedInputType);  							return expectedInputType;  						} else {  							return type;  						}  					}  				case ILCode.CompoundAssignment:  					{  						var op = expr.Arguments[0];  						if (op.Code == ILCode.NullableOf) op = op.Arguments[0].Arguments[0];  						var varType = InferTypeForExpression(op.Arguments[0]' null);  						if (forceInferChildren) {  							InferTypeForExpression(expr.Arguments[0]' varType);  						}  						return varType;  					}  					#endregion  					#region Constant loading instructions  				case ILCode.Ldnull:  					return typeSystem.Object;  				case ILCode.Ldstr:  					return typeSystem.String;  				case ILCode.Ldftn:  				case ILCode.Ldvirtftn:  					return typeSystem.IntPtr;  				case ILCode.Ldc_I4:  					if (IsBoolean(expectedType) && ((int)expr.Operand == 0 || (int)expr.Operand == 1))  						return typeSystem.Boolean;  					if (expectedType is PointerType && (int)expr.Operand == 0)  						return expectedType;  					if (IsIntegerOrEnum(expectedType) && OperandFitsInType(expectedType' (int)expr.Operand))  						return expectedType;  					else  						return typeSystem.Int32;  				case ILCode.Ldc_I8:  					if (expectedType is PointerType && (long)expr.Operand == 0)  						return expectedType;  					if (IsIntegerOrEnum(expectedType) && GetInformationAmount(expectedType) >= NativeInt)  						return expectedType;  					else  						return typeSystem.Int64;  				case ILCode.Ldc_R4:  					return typeSystem.Single;  				case ILCode.Ldc_R8:  					return typeSystem.Double;  				case ILCode.Ldc_Decimal:                      return new TypeReference("System"' "Decimal"' module' module.TypeSystem.CoreLibrary' true);  				case ILCode.Ldtoken:  					if (expr.Operand is TypeReference)  						return new TypeReference("System"' "RuntimeTypeHandle"' module' module.TypeSystem.CoreLibrary' true);  					else if (expr.Operand is FieldReference)                          return new TypeReference("System"' "RuntimeFieldHandle"' module' module.TypeSystem.CoreLibrary' true);  					else                          return new TypeReference("System"' "RuntimeMethodHandle"' module' module.TypeSystem.CoreLibrary' true);  				case ILCode.Arglist:                      return new TypeReference("System"' "RuntimeArgumentHandle"' module' module.TypeSystem.CoreLibrary' true);  					#endregion  					#region Array instructions  				case ILCode.Newarr:  					if (forceInferChildren) {  						var lengthType = InferTypeForExpression(expr.Arguments.Single()' null);  						if (lengthType == typeSystem.IntPtr) {  							lengthType = typeSystem.Int64;  						} else if (lengthType == typeSystem.UIntPtr) {  							lengthType = typeSystem.UInt64;  						} else if (lengthType != typeSystem.UInt32 && lengthType != typeSystem.Int64 && lengthType != typeSystem.UInt64) {  							lengthType = typeSystem.Int32;  						}  						if (forceInferChildren) {  							InferTypeForExpression(expr.Arguments.Single()' lengthType);  						}  					}  					return new ArrayType((TypeReference)expr.Operand);  				case ILCode.InitArray:  					var operandAsArrayType = (ArrayType)expr.Operand;  					if (forceInferChildren)  					{  						foreach (ILExpression arg in expr.Arguments)  							InferTypeForExpression(arg' operandAsArrayType.ElementType);  					}  					return operandAsArrayType;  				case ILCode.Ldlen:  					return typeSystem.Int32;  				case ILCode.Ldelem_U1:  				case ILCode.Ldelem_U2:  				case ILCode.Ldelem_U4:  				case ILCode.Ldelem_I1:  				case ILCode.Ldelem_I2:  				case ILCode.Ldelem_I4:  				case ILCode.Ldelem_I8:  				case ILCode.Ldelem_R4:  				case ILCode.Ldelem_R8:  				case ILCode.Ldelem_I:  				case ILCode.Ldelem_Ref:  					{  						ArrayType arrayType = InferTypeForExpression(expr.Arguments[0]' null) as ArrayType;  						if (forceInferChildren) {  							InferTypeForExpression(expr.Arguments[1]' typeSystem.Int32);  						}  						return arrayType != null ? arrayType.ElementType : null;  					}  				case ILCode.Ldelem_Any:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[1]' typeSystem.Int32);  					}  					return (TypeReference)expr.Operand;  				case ILCode.Ldelema:  					{  						ArrayType arrayType = InferTypeForExpression(expr.Arguments[0]' null) as ArrayType;  						if (forceInferChildren)  							InferTypeForExpression(expr.Arguments[1]' typeSystem.Int32);  						return arrayType != null ? new ByReferenceType(arrayType.ElementType) : null;  					}  				case ILCode.Stelem_I:  				case ILCode.Stelem_I1:  				case ILCode.Stelem_I2:  				case ILCode.Stelem_I4:  				case ILCode.Stelem_I8:  				case ILCode.Stelem_R4:  				case ILCode.Stelem_R8:  				case ILCode.Stelem_Ref:  				case ILCode.Stelem_Any:  					{  						ArrayType arrayType = InferTypeForExpression(expr.Arguments[0]' null) as ArrayType;  						if (forceInferChildren) {  							InferTypeForExpression(expr.Arguments[1]' typeSystem.Int32);  							if (arrayType != null) {  								InferTypeForExpression(expr.Arguments[2]' arrayType.ElementType);  							}  						}  						return arrayType != null ? arrayType.ElementType : null;  					}  					#endregion  					#region Conversion instructions  				case ILCode.Conv_I1:  				case ILCode.Conv_Ovf_I1:  				case ILCode.Conv_Ovf_I1_Un:  					return HandleConversion(8' true' expr.Arguments[0]' expectedType' typeSystem.SByte);  				case ILCode.Conv_I2:  				case ILCode.Conv_Ovf_I2:  				case ILCode.Conv_Ovf_I2_Un:  					return HandleConversion(16' true' expr.Arguments[0]' expectedType' typeSystem.Int16);  				case ILCode.Conv_I4:  				case ILCode.Conv_Ovf_I4:  				case ILCode.Conv_Ovf_I4_Un:  					return HandleConversion(32' true' expr.Arguments[0]' expectedType' typeSystem.Int32);  				case ILCode.Conv_I8:  				case ILCode.Conv_Ovf_I8:  				case ILCode.Conv_Ovf_I8_Un:  					return HandleConversion(64' true' expr.Arguments[0]' expectedType' typeSystem.Int64);  				case ILCode.Conv_U1:  				case ILCode.Conv_Ovf_U1:  				case ILCode.Conv_Ovf_U1_Un:  					return HandleConversion(8' false' expr.Arguments[0]' expectedType' typeSystem.Byte);  				case ILCode.Conv_U2:  				case ILCode.Conv_Ovf_U2:  				case ILCode.Conv_Ovf_U2_Un:  					return HandleConversion(16' false' expr.Arguments[0]' expectedType' typeSystem.UInt16);  				case ILCode.Conv_U4:  				case ILCode.Conv_Ovf_U4:  				case ILCode.Conv_Ovf_U4_Un:  					return HandleConversion(32' false' expr.Arguments[0]' expectedType' typeSystem.UInt32);  				case ILCode.Conv_U8:  				case ILCode.Conv_Ovf_U8:  				case ILCode.Conv_Ovf_U8_Un:  					return HandleConversion(64' false' expr.Arguments[0]' expectedType' typeSystem.UInt64);  				case ILCode.Conv_I:  				case ILCode.Conv_Ovf_I:  				case ILCode.Conv_Ovf_I_Un:  					return HandleConversion(NativeInt' true' expr.Arguments[0]' expectedType' typeSystem.IntPtr);  				case ILCode.Conv_U:  				case ILCode.Conv_Ovf_U:  				case ILCode.Conv_Ovf_U_Un:  					return HandleConversion(NativeInt' false' expr.Arguments[0]' expectedType' typeSystem.UIntPtr);  				case ILCode.Conv_R4:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[0]' typeSystem.Single);  					}  					return typeSystem.Single;  				case ILCode.Conv_R8:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[0]' typeSystem.Double);  					}  					return typeSystem.Double;  				case ILCode.Conv_R_Un:  					return (expectedType != null  && expectedType.MetadataType == MetadataType.Single) ? typeSystem.Single : typeSystem.Double;  				case ILCode.Castclass:  				case ILCode.Unbox_Any:  					return (TypeReference)expr.Operand;  				case ILCode.Unbox:  					return new ByReferenceType((TypeReference)expr.Operand);  				case ILCode.Isinst:  					{  						// isinst performs the equivalent of a cast only for reference types;  						// value types still need to be unboxed after an isinst instruction  						TypeReference tr = (TypeReference)expr.Operand;  						return tr.IsValueType ? typeSystem.Object : tr;  					}  				case ILCode.Box:  					{  						var tr = (TypeReference)expr.Operand;  						if (forceInferChildren)  							InferTypeForExpression(expr.Arguments.Single()' tr);  						return tr.IsValueType ? typeSystem.Object : tr;  					}  					#endregion  					#region Comparison instructions  				case ILCode.Ceq:  				case ILCode.Cne:  					if (forceInferChildren)  						InferArgumentsInBinaryOperator(expr' null' null);  					return typeSystem.Boolean;  				case ILCode.Clt:  				case ILCode.Cgt:  				case ILCode.Cle:  				case ILCode.Cge:  					if (forceInferChildren)  						InferArgumentsInBinaryOperator(expr' true' null);  					return typeSystem.Boolean;  				case ILCode.Clt_Un:  				case ILCode.Cgt_Un:  				case ILCode.Cle_Un:  				case ILCode.Cge_Un:  					if (forceInferChildren)  						InferArgumentsInBinaryOperator(expr' false' null);  					return typeSystem.Boolean;  					#endregion  					#region Branch instructions  				case ILCode.Brtrue:  					if (forceInferChildren)  						InferTypeForExpression(expr.Arguments.Single()' typeSystem.Boolean);  					return null;  				case ILCode.Br:  				case ILCode.Leave:  				case ILCode.Endfinally:  				case ILCode.Switch:  				case ILCode.Throw:  				case ILCode.Rethrow:  				case ILCode.LoopOrSwitchBreak:  				case ILCode.LoopContinue:  				case ILCode.YieldBreak:  					return null;  				case ILCode.Ret:  					if (forceInferChildren && expr.Arguments.Count == 1) {  						TypeReference returnType = context.CurrentMethod.ReturnType;  						if (context.CurrentMethodIsAsync && returnType != null && returnType.Namespace == "System.Threading.Tasks") {  							if (returnType.Name == "Task") {  								returnType = typeSystem.Void;  							} else if (returnType.Name == "Task`1" && returnType.IsGenericInstance) {  								returnType = ((GenericInstanceType)returnType).GenericArguments[0];  							}  						}  						InferTypeForExpression(expr.Arguments[0]' returnType);  					}  					return null;  				case ILCode.YieldReturn:  					if (forceInferChildren) {  						GenericInstanceType genericType = context.CurrentMethod.ReturnType as GenericInstanceType;  						if (genericType != null) { // IEnumerable<T> or IEnumerator<T>  							InferTypeForExpression(expr.Arguments[0]' genericType.GenericArguments[0]);  						} else { // non-generic IEnumerable or IEnumerator  							InferTypeForExpression(expr.Arguments[0]' typeSystem.Object);  						}  					}  					return null;  				case ILCode.Await:  					{  						TypeReference taskType = InferTypeForExpression(expr.Arguments[0]' null);  						if (taskType.Name == "Task`1" && taskType.IsGenericInstance && taskType.Namespace == "System.Threading.Tasks") {  							return ((GenericInstanceType)taskType).GenericArguments[0];  						}  						return null;  					}  					#endregion  				case ILCode.Pop:  					return null;  				case ILCode.Wrap:  				case ILCode.Dup:  					{  						var arg = expr.Arguments.Single();  						return arg.ExpectedType = InferTypeForExpression(arg' expectedType);  					}  				default:  					Debug.WriteLine("Type Inference: Can't handle " + expr.Code.GetName());  					return null;  			}
Magic Number,Custom.Decompiler.ILAst,TypeAnalysis,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\TypeAnalysis.cs,DoInferTypeForExpression,The following statement contains a magic number: switch (expr.Code) {  					#region Logical operators  				case ILCode.LogicNot:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments.Single()' typeSystem.Boolean);  					}  					return typeSystem.Boolean;  				case ILCode.LogicAnd:  				case ILCode.LogicOr:  					// if Operand is set the logic and/or expression is a custom operator  					// we can deal with it the same as a normal invocation.  					if (expr.Operand != null)  						goto case ILCode.Call;  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[0]' typeSystem.Boolean);  						InferTypeForExpression(expr.Arguments[1]' typeSystem.Boolean);  					}  					return typeSystem.Boolean;  				case ILCode.TernaryOp:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[0]' typeSystem.Boolean);  					}  					return InferBinaryArguments(expr.Arguments[1]' expr.Arguments[2]' expectedType' forceInferChildren);  				case ILCode.NullCoalescing:  					return InferBinaryArguments(expr.Arguments[0]' expr.Arguments[1]' expectedType' forceInferChildren);  					#endregion  					#region Variable load/store  				case ILCode.Stloc:  					{  						ILVariable v = (ILVariable)expr.Operand;  						if (forceInferChildren) {  							// do not use 'expectedType' in here!  							InferTypeForExpression(expr.Arguments.Single()' v.Type);  						}  						return v.Type;  					}  				case ILCode.Ldloc:  					{  						ILVariable v = (ILVariable)expr.Operand;  						if (v.Type == null && singleLoadVariables.Contains(v)) {  							v.Type = expectedType;  						}  						return v.Type;  					}  				case ILCode.Ldloca:  					{  						ILVariable v = (ILVariable)expr.Operand;  						if (v.Type != null)  							return new ByReferenceType(v.Type);  						else  							return null;  					}  					#endregion  					#region Call / NewObj  				case ILCode.Call:  				case ILCode.Callvirt:  				case ILCode.CallGetter:  				case ILCode.CallvirtGetter:  				case ILCode.CallSetter:  				case ILCode.CallvirtSetter:  					{  						MethodReference method = (MethodReference)expr.Operand;  						if (forceInferChildren) {  							for (int i = 0; i < expr.Arguments.Count; i++) {  								if (i == 0 && method.HasThis) {  									InferTypeForExpression(expr.Arguments[0]' MakeRefIfValueType(method.DeclaringType' expr.GetPrefix(ILCode.Constrained)));  								} else {  									InferTypeForExpression(expr.Arguments[i]' SubstituteTypeArgs(method.Parameters[method.HasThis ? i - 1 : i].ParameterType' method));  								}  							}  						}  						if (expr.Code == ILCode.CallSetter || expr.Code == ILCode.CallvirtSetter) {  							return SubstituteTypeArgs(method.Parameters.Last().ParameterType' method);  						} else {  							return SubstituteTypeArgs(method.ReturnType' method);  						}  					}  				case ILCode.Newobj:  					{  						MethodReference ctor = (MethodReference)expr.Operand;  						if (forceInferChildren) {  							for (int i = 0; i < ctor.Parameters.Count; i++) {  								InferTypeForExpression(expr.Arguments[i]' SubstituteTypeArgs(ctor.Parameters[i].ParameterType' ctor));  							}  						}  						return ctor.DeclaringType;  					}  				case ILCode.InitObject:  				case ILCode.InitCollection:  					return InferTypeForExpression(expr.Arguments[0]' expectedType);  				case ILCode.InitializedObject:  					// expectedType should always be known due to the parent method call / property setter  					Debug.Assert(expectedType != null);  					return expectedType;  					#endregion  					#region Load/Store Fields  				case ILCode.Ldfld:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[0]' MakeRefIfValueType(((FieldReference)expr.Operand).DeclaringType' expr.GetPrefix(ILCode.Constrained)));  					}  					return GetFieldType((FieldReference)expr.Operand);  				case ILCode.Ldsfld:  					return GetFieldType((FieldReference)expr.Operand);  				case ILCode.Ldflda:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[0]' MakeRefIfValueType(((FieldReference)expr.Operand).DeclaringType' expr.GetPrefix(ILCode.Constrained)));  					}  					return new ByReferenceType(GetFieldType((FieldReference)expr.Operand));  				case ILCode.Ldsflda:  					return new ByReferenceType(GetFieldType((FieldReference)expr.Operand));  				case ILCode.Stfld:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[0]' MakeRefIfValueType(((FieldReference)expr.Operand).DeclaringType' expr.GetPrefix(ILCode.Constrained)));  						InferTypeForExpression(expr.Arguments[1]' GetFieldType((FieldReference)expr.Operand));  					}  					return GetFieldType((FieldReference)expr.Operand);  				case ILCode.Stsfld:  					if (forceInferChildren)  						InferTypeForExpression(expr.Arguments[0]' GetFieldType((FieldReference)expr.Operand));  					return GetFieldType((FieldReference)expr.Operand);  					#endregion  					#region Reference/Pointer instructions  				case ILCode.Ldind_Ref:  					return UnpackPointer(InferTypeForExpression(expr.Arguments[0]' null));  				case ILCode.Stind_Ref:  					if (forceInferChildren) {  						TypeReference elementType = UnpackPointer(InferTypeForExpression(expr.Arguments[0]' null));  						InferTypeForExpression(expr.Arguments[1]' elementType);  					}  					return null;  				case ILCode.Ldobj:  					{  						TypeReference type = (TypeReference)expr.Operand;  						var argType = InferTypeForExpression(expr.Arguments[0]' null);  						if (argType is PointerType || argType is ByReferenceType) {  							var elementType = ((TypeSpecification)argType).ElementType;  							int infoAmount = GetInformationAmount(elementType);  							if (infoAmount == 1 && GetInformationAmount(type) == 8) {  								// A bool can be loaded from both bytes and sbytes.  								type = elementType;  							}  							if (infoAmount >= 8 && infoAmount <= 64 && infoAmount == GetInformationAmount(type)) {  								// An integer can be loaded as another integer of the same size.  								// For integers smaller than 32 bit' the signs must match (as loading performs sign extension)  								bool? elementTypeIsSigned = IsSigned(elementType);  								bool? typeIsSigned = IsSigned(type);  								if (elementTypeIsSigned != null && typeIsSigned != null) {  									if (infoAmount >= 32 || elementTypeIsSigned == typeIsSigned)  										type = elementType;  								}  							}  						}  						if (argType is PointerType)  							InferTypeForExpression(expr.Arguments[0]' new PointerType(type));  						else  							InferTypeForExpression(expr.Arguments[0]' new ByReferenceType(type));  						return type;  					}  				case ILCode.Stobj:  					{  						TypeReference operandType = (TypeReference)expr.Operand;  						TypeReference pointerType = InferTypeForExpression(expr.Arguments[0]' new ByReferenceType(operandType));  						TypeReference elementType;  						if (pointerType is PointerType)  							elementType = ((PointerType)pointerType).ElementType;  						else if (pointerType is ByReferenceType)  							elementType = ((ByReferenceType)pointerType).ElementType;  						else  							elementType = null;  						if (elementType != null) {  							// An integer can be stored in any other integer of the same size.  							int infoAmount = GetInformationAmount(elementType);  							if (infoAmount == 1 && GetInformationAmount(operandType) == 8)  								operandType = elementType;  							else if (infoAmount == GetInformationAmount(operandType) && IsSigned(elementType) != null && IsSigned(operandType) != null)  								operandType = elementType;  						}  						if (forceInferChildren) {  							if (pointerType is PointerType)  								InferTypeForExpression(expr.Arguments[0]' new PointerType(operandType));  							else if (!IsSameType(operandType' expr.Operand as TypeReference))  								InferTypeForExpression(expr.Arguments[0]' new ByReferenceType(operandType));  							InferTypeForExpression(expr.Arguments[1]' operandType);  						}  						return operandType;  					}  				case ILCode.Initobj:  					return null;  				case ILCode.DefaultValue:  					return (TypeReference)expr.Operand;  				case ILCode.Localloc:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[0]' typeSystem.Int32);  					}  					if (expectedType is PointerType)  						return expectedType;  					else  						return typeSystem.IntPtr;  				case ILCode.Sizeof:  					return typeSystem.Int32;  				case ILCode.PostIncrement:  				case ILCode.PostIncrement_Ovf:  				case ILCode.PostIncrement_Ovf_Un:  					{  						TypeReference elementType = UnpackPointer(InferTypeForExpression(expr.Arguments[0]' null));  						if (forceInferChildren && elementType != null) {  							// Assign expected type to the child expression  							InferTypeForExpression(expr.Arguments[0]' new ByReferenceType(elementType));  						}  						return elementType;  					}  				case ILCode.Mkrefany:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[0]' (TypeReference)expr.Operand);  					}  					return typeSystem.TypedReference;  				case ILCode.Refanytype:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[0]' typeSystem.TypedReference);  					}                      return new TypeReference("System"' "RuntimeTypeHandle"' module' module.TypeSystem.CoreLibrary' true);  				case ILCode.Refanyval:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[0]' typeSystem.TypedReference);  					}  					return new ByReferenceType((TypeReference)expr.Operand);  				case ILCode.AddressOf:  					{  						TypeReference t = InferTypeForExpression(expr.Arguments[0]' UnpackPointer(expectedType));  						return t != null ? new ByReferenceType(t) : null;  					}  				case ILCode.ValueOf:  					return GetNullableTypeArgument(InferTypeForExpression(expr.Arguments[0]' CreateNullableType(expectedType)));  				case ILCode.NullableOf:  					return CreateNullableType(InferTypeForExpression(expr.Arguments[0]' GetNullableTypeArgument(expectedType)));  					#endregion  					#region Arithmetic instructions  				case ILCode.Not: // bitwise complement  				case ILCode.Neg:  					return InferTypeForExpression(expr.Arguments.Single()' expectedType);  				case ILCode.Add:  					return InferArgumentsInAddition(expr' null' expectedType);  				case ILCode.Sub:  					return InferArgumentsInSubtraction(expr' null' expectedType);  				case ILCode.Mul:  				case ILCode.Or:  				case ILCode.And:  				case ILCode.Xor:  					return InferArgumentsInBinaryOperator(expr' null' expectedType);  				case ILCode.Add_Ovf:  					return InferArgumentsInAddition(expr' true' expectedType);  				case ILCode.Sub_Ovf:  					return InferArgumentsInSubtraction(expr' true' expectedType);  				case ILCode.Mul_Ovf:  				case ILCode.Div:  				case ILCode.Rem:  					return InferArgumentsInBinaryOperator(expr' true' expectedType);  				case ILCode.Add_Ovf_Un:  					return InferArgumentsInAddition(expr' false' expectedType);  				case ILCode.Sub_Ovf_Un:  					return InferArgumentsInSubtraction(expr' false' expectedType);  				case ILCode.Mul_Ovf_Un:  				case ILCode.Div_Un:  				case ILCode.Rem_Un:  					return InferArgumentsInBinaryOperator(expr' false' expectedType);  				case ILCode.Shl:  					if (forceInferChildren)  						InferTypeForExpression(expr.Arguments[1]' typeSystem.Int32);  					if (expectedType != null && (  						expectedType.MetadataType == MetadataType.Int32 || expectedType.MetadataType == MetadataType.UInt32 ||  						expectedType.MetadataType == MetadataType.Int64 || expectedType.MetadataType == MetadataType.UInt64)  					   )  						return NumericPromotion(InferTypeForExpression(expr.Arguments[0]' expectedType));  					else  						return NumericPromotion(InferTypeForExpression(expr.Arguments[0]' null));  				case ILCode.Shr:  				case ILCode.Shr_Un:  					{  						if (forceInferChildren)  							InferTypeForExpression(expr.Arguments[1]' typeSystem.Int32);  						TypeReference type = NumericPromotion(InferTypeForExpression(expr.Arguments[0]' null));  						TypeReference expectedInputType = null;  						switch (type.MetadataType) {  							case MetadataType.Int32:  								if (expr.Code == ILCode.Shr_Un)  									expectedInputType = typeSystem.UInt32;  								break;  							case MetadataType.UInt32:  								if (expr.Code == ILCode.Shr)  									expectedInputType = typeSystem.Int32;  								break;  							case MetadataType.Int64:  								if (expr.Code == ILCode.Shr_Un)  									expectedInputType = typeSystem.UInt64;  								break;  							case MetadataType.UInt64:  								if (expr.Code == ILCode.Shr)  									expectedInputType = typeSystem.UInt64;  								break;  						}  						if (expectedInputType != null) {  							InferTypeForExpression(expr.Arguments[0]' expectedInputType);  							return expectedInputType;  						} else {  							return type;  						}  					}  				case ILCode.CompoundAssignment:  					{  						var op = expr.Arguments[0];  						if (op.Code == ILCode.NullableOf) op = op.Arguments[0].Arguments[0];  						var varType = InferTypeForExpression(op.Arguments[0]' null);  						if (forceInferChildren) {  							InferTypeForExpression(expr.Arguments[0]' varType);  						}  						return varType;  					}  					#endregion  					#region Constant loading instructions  				case ILCode.Ldnull:  					return typeSystem.Object;  				case ILCode.Ldstr:  					return typeSystem.String;  				case ILCode.Ldftn:  				case ILCode.Ldvirtftn:  					return typeSystem.IntPtr;  				case ILCode.Ldc_I4:  					if (IsBoolean(expectedType) && ((int)expr.Operand == 0 || (int)expr.Operand == 1))  						return typeSystem.Boolean;  					if (expectedType is PointerType && (int)expr.Operand == 0)  						return expectedType;  					if (IsIntegerOrEnum(expectedType) && OperandFitsInType(expectedType' (int)expr.Operand))  						return expectedType;  					else  						return typeSystem.Int32;  				case ILCode.Ldc_I8:  					if (expectedType is PointerType && (long)expr.Operand == 0)  						return expectedType;  					if (IsIntegerOrEnum(expectedType) && GetInformationAmount(expectedType) >= NativeInt)  						return expectedType;  					else  						return typeSystem.Int64;  				case ILCode.Ldc_R4:  					return typeSystem.Single;  				case ILCode.Ldc_R8:  					return typeSystem.Double;  				case ILCode.Ldc_Decimal:                      return new TypeReference("System"' "Decimal"' module' module.TypeSystem.CoreLibrary' true);  				case ILCode.Ldtoken:  					if (expr.Operand is TypeReference)  						return new TypeReference("System"' "RuntimeTypeHandle"' module' module.TypeSystem.CoreLibrary' true);  					else if (expr.Operand is FieldReference)                          return new TypeReference("System"' "RuntimeFieldHandle"' module' module.TypeSystem.CoreLibrary' true);  					else                          return new TypeReference("System"' "RuntimeMethodHandle"' module' module.TypeSystem.CoreLibrary' true);  				case ILCode.Arglist:                      return new TypeReference("System"' "RuntimeArgumentHandle"' module' module.TypeSystem.CoreLibrary' true);  					#endregion  					#region Array instructions  				case ILCode.Newarr:  					if (forceInferChildren) {  						var lengthType = InferTypeForExpression(expr.Arguments.Single()' null);  						if (lengthType == typeSystem.IntPtr) {  							lengthType = typeSystem.Int64;  						} else if (lengthType == typeSystem.UIntPtr) {  							lengthType = typeSystem.UInt64;  						} else if (lengthType != typeSystem.UInt32 && lengthType != typeSystem.Int64 && lengthType != typeSystem.UInt64) {  							lengthType = typeSystem.Int32;  						}  						if (forceInferChildren) {  							InferTypeForExpression(expr.Arguments.Single()' lengthType);  						}  					}  					return new ArrayType((TypeReference)expr.Operand);  				case ILCode.InitArray:  					var operandAsArrayType = (ArrayType)expr.Operand;  					if (forceInferChildren)  					{  						foreach (ILExpression arg in expr.Arguments)  							InferTypeForExpression(arg' operandAsArrayType.ElementType);  					}  					return operandAsArrayType;  				case ILCode.Ldlen:  					return typeSystem.Int32;  				case ILCode.Ldelem_U1:  				case ILCode.Ldelem_U2:  				case ILCode.Ldelem_U4:  				case ILCode.Ldelem_I1:  				case ILCode.Ldelem_I2:  				case ILCode.Ldelem_I4:  				case ILCode.Ldelem_I8:  				case ILCode.Ldelem_R4:  				case ILCode.Ldelem_R8:  				case ILCode.Ldelem_I:  				case ILCode.Ldelem_Ref:  					{  						ArrayType arrayType = InferTypeForExpression(expr.Arguments[0]' null) as ArrayType;  						if (forceInferChildren) {  							InferTypeForExpression(expr.Arguments[1]' typeSystem.Int32);  						}  						return arrayType != null ? arrayType.ElementType : null;  					}  				case ILCode.Ldelem_Any:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[1]' typeSystem.Int32);  					}  					return (TypeReference)expr.Operand;  				case ILCode.Ldelema:  					{  						ArrayType arrayType = InferTypeForExpression(expr.Arguments[0]' null) as ArrayType;  						if (forceInferChildren)  							InferTypeForExpression(expr.Arguments[1]' typeSystem.Int32);  						return arrayType != null ? new ByReferenceType(arrayType.ElementType) : null;  					}  				case ILCode.Stelem_I:  				case ILCode.Stelem_I1:  				case ILCode.Stelem_I2:  				case ILCode.Stelem_I4:  				case ILCode.Stelem_I8:  				case ILCode.Stelem_R4:  				case ILCode.Stelem_R8:  				case ILCode.Stelem_Ref:  				case ILCode.Stelem_Any:  					{  						ArrayType arrayType = InferTypeForExpression(expr.Arguments[0]' null) as ArrayType;  						if (forceInferChildren) {  							InferTypeForExpression(expr.Arguments[1]' typeSystem.Int32);  							if (arrayType != null) {  								InferTypeForExpression(expr.Arguments[2]' arrayType.ElementType);  							}  						}  						return arrayType != null ? arrayType.ElementType : null;  					}  					#endregion  					#region Conversion instructions  				case ILCode.Conv_I1:  				case ILCode.Conv_Ovf_I1:  				case ILCode.Conv_Ovf_I1_Un:  					return HandleConversion(8' true' expr.Arguments[0]' expectedType' typeSystem.SByte);  				case ILCode.Conv_I2:  				case ILCode.Conv_Ovf_I2:  				case ILCode.Conv_Ovf_I2_Un:  					return HandleConversion(16' true' expr.Arguments[0]' expectedType' typeSystem.Int16);  				case ILCode.Conv_I4:  				case ILCode.Conv_Ovf_I4:  				case ILCode.Conv_Ovf_I4_Un:  					return HandleConversion(32' true' expr.Arguments[0]' expectedType' typeSystem.Int32);  				case ILCode.Conv_I8:  				case ILCode.Conv_Ovf_I8:  				case ILCode.Conv_Ovf_I8_Un:  					return HandleConversion(64' true' expr.Arguments[0]' expectedType' typeSystem.Int64);  				case ILCode.Conv_U1:  				case ILCode.Conv_Ovf_U1:  				case ILCode.Conv_Ovf_U1_Un:  					return HandleConversion(8' false' expr.Arguments[0]' expectedType' typeSystem.Byte);  				case ILCode.Conv_U2:  				case ILCode.Conv_Ovf_U2:  				case ILCode.Conv_Ovf_U2_Un:  					return HandleConversion(16' false' expr.Arguments[0]' expectedType' typeSystem.UInt16);  				case ILCode.Conv_U4:  				case ILCode.Conv_Ovf_U4:  				case ILCode.Conv_Ovf_U4_Un:  					return HandleConversion(32' false' expr.Arguments[0]' expectedType' typeSystem.UInt32);  				case ILCode.Conv_U8:  				case ILCode.Conv_Ovf_U8:  				case ILCode.Conv_Ovf_U8_Un:  					return HandleConversion(64' false' expr.Arguments[0]' expectedType' typeSystem.UInt64);  				case ILCode.Conv_I:  				case ILCode.Conv_Ovf_I:  				case ILCode.Conv_Ovf_I_Un:  					return HandleConversion(NativeInt' true' expr.Arguments[0]' expectedType' typeSystem.IntPtr);  				case ILCode.Conv_U:  				case ILCode.Conv_Ovf_U:  				case ILCode.Conv_Ovf_U_Un:  					return HandleConversion(NativeInt' false' expr.Arguments[0]' expectedType' typeSystem.UIntPtr);  				case ILCode.Conv_R4:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[0]' typeSystem.Single);  					}  					return typeSystem.Single;  				case ILCode.Conv_R8:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[0]' typeSystem.Double);  					}  					return typeSystem.Double;  				case ILCode.Conv_R_Un:  					return (expectedType != null  && expectedType.MetadataType == MetadataType.Single) ? typeSystem.Single : typeSystem.Double;  				case ILCode.Castclass:  				case ILCode.Unbox_Any:  					return (TypeReference)expr.Operand;  				case ILCode.Unbox:  					return new ByReferenceType((TypeReference)expr.Operand);  				case ILCode.Isinst:  					{  						// isinst performs the equivalent of a cast only for reference types;  						// value types still need to be unboxed after an isinst instruction  						TypeReference tr = (TypeReference)expr.Operand;  						return tr.IsValueType ? typeSystem.Object : tr;  					}  				case ILCode.Box:  					{  						var tr = (TypeReference)expr.Operand;  						if (forceInferChildren)  							InferTypeForExpression(expr.Arguments.Single()' tr);  						return tr.IsValueType ? typeSystem.Object : tr;  					}  					#endregion  					#region Comparison instructions  				case ILCode.Ceq:  				case ILCode.Cne:  					if (forceInferChildren)  						InferArgumentsInBinaryOperator(expr' null' null);  					return typeSystem.Boolean;  				case ILCode.Clt:  				case ILCode.Cgt:  				case ILCode.Cle:  				case ILCode.Cge:  					if (forceInferChildren)  						InferArgumentsInBinaryOperator(expr' true' null);  					return typeSystem.Boolean;  				case ILCode.Clt_Un:  				case ILCode.Cgt_Un:  				case ILCode.Cle_Un:  				case ILCode.Cge_Un:  					if (forceInferChildren)  						InferArgumentsInBinaryOperator(expr' false' null);  					return typeSystem.Boolean;  					#endregion  					#region Branch instructions  				case ILCode.Brtrue:  					if (forceInferChildren)  						InferTypeForExpression(expr.Arguments.Single()' typeSystem.Boolean);  					return null;  				case ILCode.Br:  				case ILCode.Leave:  				case ILCode.Endfinally:  				case ILCode.Switch:  				case ILCode.Throw:  				case ILCode.Rethrow:  				case ILCode.LoopOrSwitchBreak:  				case ILCode.LoopContinue:  				case ILCode.YieldBreak:  					return null;  				case ILCode.Ret:  					if (forceInferChildren && expr.Arguments.Count == 1) {  						TypeReference returnType = context.CurrentMethod.ReturnType;  						if (context.CurrentMethodIsAsync && returnType != null && returnType.Namespace == "System.Threading.Tasks") {  							if (returnType.Name == "Task") {  								returnType = typeSystem.Void;  							} else if (returnType.Name == "Task`1" && returnType.IsGenericInstance) {  								returnType = ((GenericInstanceType)returnType).GenericArguments[0];  							}  						}  						InferTypeForExpression(expr.Arguments[0]' returnType);  					}  					return null;  				case ILCode.YieldReturn:  					if (forceInferChildren) {  						GenericInstanceType genericType = context.CurrentMethod.ReturnType as GenericInstanceType;  						if (genericType != null) { // IEnumerable<T> or IEnumerator<T>  							InferTypeForExpression(expr.Arguments[0]' genericType.GenericArguments[0]);  						} else { // non-generic IEnumerable or IEnumerator  							InferTypeForExpression(expr.Arguments[0]' typeSystem.Object);  						}  					}  					return null;  				case ILCode.Await:  					{  						TypeReference taskType = InferTypeForExpression(expr.Arguments[0]' null);  						if (taskType.Name == "Task`1" && taskType.IsGenericInstance && taskType.Namespace == "System.Threading.Tasks") {  							return ((GenericInstanceType)taskType).GenericArguments[0];  						}  						return null;  					}  					#endregion  				case ILCode.Pop:  					return null;  				case ILCode.Wrap:  				case ILCode.Dup:  					{  						var arg = expr.Arguments.Single();  						return arg.ExpectedType = InferTypeForExpression(arg' expectedType);  					}  				default:  					Debug.WriteLine("Type Inference: Can't handle " + expr.Code.GetName());  					return null;  			}
Magic Number,Custom.Decompiler.ILAst,TypeAnalysis,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\TypeAnalysis.cs,DoInferTypeForExpression,The following statement contains a magic number: switch (expr.Code) {  					#region Logical operators  				case ILCode.LogicNot:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments.Single()' typeSystem.Boolean);  					}  					return typeSystem.Boolean;  				case ILCode.LogicAnd:  				case ILCode.LogicOr:  					// if Operand is set the logic and/or expression is a custom operator  					// we can deal with it the same as a normal invocation.  					if (expr.Operand != null)  						goto case ILCode.Call;  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[0]' typeSystem.Boolean);  						InferTypeForExpression(expr.Arguments[1]' typeSystem.Boolean);  					}  					return typeSystem.Boolean;  				case ILCode.TernaryOp:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[0]' typeSystem.Boolean);  					}  					return InferBinaryArguments(expr.Arguments[1]' expr.Arguments[2]' expectedType' forceInferChildren);  				case ILCode.NullCoalescing:  					return InferBinaryArguments(expr.Arguments[0]' expr.Arguments[1]' expectedType' forceInferChildren);  					#endregion  					#region Variable load/store  				case ILCode.Stloc:  					{  						ILVariable v = (ILVariable)expr.Operand;  						if (forceInferChildren) {  							// do not use 'expectedType' in here!  							InferTypeForExpression(expr.Arguments.Single()' v.Type);  						}  						return v.Type;  					}  				case ILCode.Ldloc:  					{  						ILVariable v = (ILVariable)expr.Operand;  						if (v.Type == null && singleLoadVariables.Contains(v)) {  							v.Type = expectedType;  						}  						return v.Type;  					}  				case ILCode.Ldloca:  					{  						ILVariable v = (ILVariable)expr.Operand;  						if (v.Type != null)  							return new ByReferenceType(v.Type);  						else  							return null;  					}  					#endregion  					#region Call / NewObj  				case ILCode.Call:  				case ILCode.Callvirt:  				case ILCode.CallGetter:  				case ILCode.CallvirtGetter:  				case ILCode.CallSetter:  				case ILCode.CallvirtSetter:  					{  						MethodReference method = (MethodReference)expr.Operand;  						if (forceInferChildren) {  							for (int i = 0; i < expr.Arguments.Count; i++) {  								if (i == 0 && method.HasThis) {  									InferTypeForExpression(expr.Arguments[0]' MakeRefIfValueType(method.DeclaringType' expr.GetPrefix(ILCode.Constrained)));  								} else {  									InferTypeForExpression(expr.Arguments[i]' SubstituteTypeArgs(method.Parameters[method.HasThis ? i - 1 : i].ParameterType' method));  								}  							}  						}  						if (expr.Code == ILCode.CallSetter || expr.Code == ILCode.CallvirtSetter) {  							return SubstituteTypeArgs(method.Parameters.Last().ParameterType' method);  						} else {  							return SubstituteTypeArgs(method.ReturnType' method);  						}  					}  				case ILCode.Newobj:  					{  						MethodReference ctor = (MethodReference)expr.Operand;  						if (forceInferChildren) {  							for (int i = 0; i < ctor.Parameters.Count; i++) {  								InferTypeForExpression(expr.Arguments[i]' SubstituteTypeArgs(ctor.Parameters[i].ParameterType' ctor));  							}  						}  						return ctor.DeclaringType;  					}  				case ILCode.InitObject:  				case ILCode.InitCollection:  					return InferTypeForExpression(expr.Arguments[0]' expectedType);  				case ILCode.InitializedObject:  					// expectedType should always be known due to the parent method call / property setter  					Debug.Assert(expectedType != null);  					return expectedType;  					#endregion  					#region Load/Store Fields  				case ILCode.Ldfld:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[0]' MakeRefIfValueType(((FieldReference)expr.Operand).DeclaringType' expr.GetPrefix(ILCode.Constrained)));  					}  					return GetFieldType((FieldReference)expr.Operand);  				case ILCode.Ldsfld:  					return GetFieldType((FieldReference)expr.Operand);  				case ILCode.Ldflda:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[0]' MakeRefIfValueType(((FieldReference)expr.Operand).DeclaringType' expr.GetPrefix(ILCode.Constrained)));  					}  					return new ByReferenceType(GetFieldType((FieldReference)expr.Operand));  				case ILCode.Ldsflda:  					return new ByReferenceType(GetFieldType((FieldReference)expr.Operand));  				case ILCode.Stfld:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[0]' MakeRefIfValueType(((FieldReference)expr.Operand).DeclaringType' expr.GetPrefix(ILCode.Constrained)));  						InferTypeForExpression(expr.Arguments[1]' GetFieldType((FieldReference)expr.Operand));  					}  					return GetFieldType((FieldReference)expr.Operand);  				case ILCode.Stsfld:  					if (forceInferChildren)  						InferTypeForExpression(expr.Arguments[0]' GetFieldType((FieldReference)expr.Operand));  					return GetFieldType((FieldReference)expr.Operand);  					#endregion  					#region Reference/Pointer instructions  				case ILCode.Ldind_Ref:  					return UnpackPointer(InferTypeForExpression(expr.Arguments[0]' null));  				case ILCode.Stind_Ref:  					if (forceInferChildren) {  						TypeReference elementType = UnpackPointer(InferTypeForExpression(expr.Arguments[0]' null));  						InferTypeForExpression(expr.Arguments[1]' elementType);  					}  					return null;  				case ILCode.Ldobj:  					{  						TypeReference type = (TypeReference)expr.Operand;  						var argType = InferTypeForExpression(expr.Arguments[0]' null);  						if (argType is PointerType || argType is ByReferenceType) {  							var elementType = ((TypeSpecification)argType).ElementType;  							int infoAmount = GetInformationAmount(elementType);  							if (infoAmount == 1 && GetInformationAmount(type) == 8) {  								// A bool can be loaded from both bytes and sbytes.  								type = elementType;  							}  							if (infoAmount >= 8 && infoAmount <= 64 && infoAmount == GetInformationAmount(type)) {  								// An integer can be loaded as another integer of the same size.  								// For integers smaller than 32 bit' the signs must match (as loading performs sign extension)  								bool? elementTypeIsSigned = IsSigned(elementType);  								bool? typeIsSigned = IsSigned(type);  								if (elementTypeIsSigned != null && typeIsSigned != null) {  									if (infoAmount >= 32 || elementTypeIsSigned == typeIsSigned)  										type = elementType;  								}  							}  						}  						if (argType is PointerType)  							InferTypeForExpression(expr.Arguments[0]' new PointerType(type));  						else  							InferTypeForExpression(expr.Arguments[0]' new ByReferenceType(type));  						return type;  					}  				case ILCode.Stobj:  					{  						TypeReference operandType = (TypeReference)expr.Operand;  						TypeReference pointerType = InferTypeForExpression(expr.Arguments[0]' new ByReferenceType(operandType));  						TypeReference elementType;  						if (pointerType is PointerType)  							elementType = ((PointerType)pointerType).ElementType;  						else if (pointerType is ByReferenceType)  							elementType = ((ByReferenceType)pointerType).ElementType;  						else  							elementType = null;  						if (elementType != null) {  							// An integer can be stored in any other integer of the same size.  							int infoAmount = GetInformationAmount(elementType);  							if (infoAmount == 1 && GetInformationAmount(operandType) == 8)  								operandType = elementType;  							else if (infoAmount == GetInformationAmount(operandType) && IsSigned(elementType) != null && IsSigned(operandType) != null)  								operandType = elementType;  						}  						if (forceInferChildren) {  							if (pointerType is PointerType)  								InferTypeForExpression(expr.Arguments[0]' new PointerType(operandType));  							else if (!IsSameType(operandType' expr.Operand as TypeReference))  								InferTypeForExpression(expr.Arguments[0]' new ByReferenceType(operandType));  							InferTypeForExpression(expr.Arguments[1]' operandType);  						}  						return operandType;  					}  				case ILCode.Initobj:  					return null;  				case ILCode.DefaultValue:  					return (TypeReference)expr.Operand;  				case ILCode.Localloc:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[0]' typeSystem.Int32);  					}  					if (expectedType is PointerType)  						return expectedType;  					else  						return typeSystem.IntPtr;  				case ILCode.Sizeof:  					return typeSystem.Int32;  				case ILCode.PostIncrement:  				case ILCode.PostIncrement_Ovf:  				case ILCode.PostIncrement_Ovf_Un:  					{  						TypeReference elementType = UnpackPointer(InferTypeForExpression(expr.Arguments[0]' null));  						if (forceInferChildren && elementType != null) {  							// Assign expected type to the child expression  							InferTypeForExpression(expr.Arguments[0]' new ByReferenceType(elementType));  						}  						return elementType;  					}  				case ILCode.Mkrefany:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[0]' (TypeReference)expr.Operand);  					}  					return typeSystem.TypedReference;  				case ILCode.Refanytype:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[0]' typeSystem.TypedReference);  					}                      return new TypeReference("System"' "RuntimeTypeHandle"' module' module.TypeSystem.CoreLibrary' true);  				case ILCode.Refanyval:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[0]' typeSystem.TypedReference);  					}  					return new ByReferenceType((TypeReference)expr.Operand);  				case ILCode.AddressOf:  					{  						TypeReference t = InferTypeForExpression(expr.Arguments[0]' UnpackPointer(expectedType));  						return t != null ? new ByReferenceType(t) : null;  					}  				case ILCode.ValueOf:  					return GetNullableTypeArgument(InferTypeForExpression(expr.Arguments[0]' CreateNullableType(expectedType)));  				case ILCode.NullableOf:  					return CreateNullableType(InferTypeForExpression(expr.Arguments[0]' GetNullableTypeArgument(expectedType)));  					#endregion  					#region Arithmetic instructions  				case ILCode.Not: // bitwise complement  				case ILCode.Neg:  					return InferTypeForExpression(expr.Arguments.Single()' expectedType);  				case ILCode.Add:  					return InferArgumentsInAddition(expr' null' expectedType);  				case ILCode.Sub:  					return InferArgumentsInSubtraction(expr' null' expectedType);  				case ILCode.Mul:  				case ILCode.Or:  				case ILCode.And:  				case ILCode.Xor:  					return InferArgumentsInBinaryOperator(expr' null' expectedType);  				case ILCode.Add_Ovf:  					return InferArgumentsInAddition(expr' true' expectedType);  				case ILCode.Sub_Ovf:  					return InferArgumentsInSubtraction(expr' true' expectedType);  				case ILCode.Mul_Ovf:  				case ILCode.Div:  				case ILCode.Rem:  					return InferArgumentsInBinaryOperator(expr' true' expectedType);  				case ILCode.Add_Ovf_Un:  					return InferArgumentsInAddition(expr' false' expectedType);  				case ILCode.Sub_Ovf_Un:  					return InferArgumentsInSubtraction(expr' false' expectedType);  				case ILCode.Mul_Ovf_Un:  				case ILCode.Div_Un:  				case ILCode.Rem_Un:  					return InferArgumentsInBinaryOperator(expr' false' expectedType);  				case ILCode.Shl:  					if (forceInferChildren)  						InferTypeForExpression(expr.Arguments[1]' typeSystem.Int32);  					if (expectedType != null && (  						expectedType.MetadataType == MetadataType.Int32 || expectedType.MetadataType == MetadataType.UInt32 ||  						expectedType.MetadataType == MetadataType.Int64 || expectedType.MetadataType == MetadataType.UInt64)  					   )  						return NumericPromotion(InferTypeForExpression(expr.Arguments[0]' expectedType));  					else  						return NumericPromotion(InferTypeForExpression(expr.Arguments[0]' null));  				case ILCode.Shr:  				case ILCode.Shr_Un:  					{  						if (forceInferChildren)  							InferTypeForExpression(expr.Arguments[1]' typeSystem.Int32);  						TypeReference type = NumericPromotion(InferTypeForExpression(expr.Arguments[0]' null));  						TypeReference expectedInputType = null;  						switch (type.MetadataType) {  							case MetadataType.Int32:  								if (expr.Code == ILCode.Shr_Un)  									expectedInputType = typeSystem.UInt32;  								break;  							case MetadataType.UInt32:  								if (expr.Code == ILCode.Shr)  									expectedInputType = typeSystem.Int32;  								break;  							case MetadataType.Int64:  								if (expr.Code == ILCode.Shr_Un)  									expectedInputType = typeSystem.UInt64;  								break;  							case MetadataType.UInt64:  								if (expr.Code == ILCode.Shr)  									expectedInputType = typeSystem.UInt64;  								break;  						}  						if (expectedInputType != null) {  							InferTypeForExpression(expr.Arguments[0]' expectedInputType);  							return expectedInputType;  						} else {  							return type;  						}  					}  				case ILCode.CompoundAssignment:  					{  						var op = expr.Arguments[0];  						if (op.Code == ILCode.NullableOf) op = op.Arguments[0].Arguments[0];  						var varType = InferTypeForExpression(op.Arguments[0]' null);  						if (forceInferChildren) {  							InferTypeForExpression(expr.Arguments[0]' varType);  						}  						return varType;  					}  					#endregion  					#region Constant loading instructions  				case ILCode.Ldnull:  					return typeSystem.Object;  				case ILCode.Ldstr:  					return typeSystem.String;  				case ILCode.Ldftn:  				case ILCode.Ldvirtftn:  					return typeSystem.IntPtr;  				case ILCode.Ldc_I4:  					if (IsBoolean(expectedType) && ((int)expr.Operand == 0 || (int)expr.Operand == 1))  						return typeSystem.Boolean;  					if (expectedType is PointerType && (int)expr.Operand == 0)  						return expectedType;  					if (IsIntegerOrEnum(expectedType) && OperandFitsInType(expectedType' (int)expr.Operand))  						return expectedType;  					else  						return typeSystem.Int32;  				case ILCode.Ldc_I8:  					if (expectedType is PointerType && (long)expr.Operand == 0)  						return expectedType;  					if (IsIntegerOrEnum(expectedType) && GetInformationAmount(expectedType) >= NativeInt)  						return expectedType;  					else  						return typeSystem.Int64;  				case ILCode.Ldc_R4:  					return typeSystem.Single;  				case ILCode.Ldc_R8:  					return typeSystem.Double;  				case ILCode.Ldc_Decimal:                      return new TypeReference("System"' "Decimal"' module' module.TypeSystem.CoreLibrary' true);  				case ILCode.Ldtoken:  					if (expr.Operand is TypeReference)  						return new TypeReference("System"' "RuntimeTypeHandle"' module' module.TypeSystem.CoreLibrary' true);  					else if (expr.Operand is FieldReference)                          return new TypeReference("System"' "RuntimeFieldHandle"' module' module.TypeSystem.CoreLibrary' true);  					else                          return new TypeReference("System"' "RuntimeMethodHandle"' module' module.TypeSystem.CoreLibrary' true);  				case ILCode.Arglist:                      return new TypeReference("System"' "RuntimeArgumentHandle"' module' module.TypeSystem.CoreLibrary' true);  					#endregion  					#region Array instructions  				case ILCode.Newarr:  					if (forceInferChildren) {  						var lengthType = InferTypeForExpression(expr.Arguments.Single()' null);  						if (lengthType == typeSystem.IntPtr) {  							lengthType = typeSystem.Int64;  						} else if (lengthType == typeSystem.UIntPtr) {  							lengthType = typeSystem.UInt64;  						} else if (lengthType != typeSystem.UInt32 && lengthType != typeSystem.Int64 && lengthType != typeSystem.UInt64) {  							lengthType = typeSystem.Int32;  						}  						if (forceInferChildren) {  							InferTypeForExpression(expr.Arguments.Single()' lengthType);  						}  					}  					return new ArrayType((TypeReference)expr.Operand);  				case ILCode.InitArray:  					var operandAsArrayType = (ArrayType)expr.Operand;  					if (forceInferChildren)  					{  						foreach (ILExpression arg in expr.Arguments)  							InferTypeForExpression(arg' operandAsArrayType.ElementType);  					}  					return operandAsArrayType;  				case ILCode.Ldlen:  					return typeSystem.Int32;  				case ILCode.Ldelem_U1:  				case ILCode.Ldelem_U2:  				case ILCode.Ldelem_U4:  				case ILCode.Ldelem_I1:  				case ILCode.Ldelem_I2:  				case ILCode.Ldelem_I4:  				case ILCode.Ldelem_I8:  				case ILCode.Ldelem_R4:  				case ILCode.Ldelem_R8:  				case ILCode.Ldelem_I:  				case ILCode.Ldelem_Ref:  					{  						ArrayType arrayType = InferTypeForExpression(expr.Arguments[0]' null) as ArrayType;  						if (forceInferChildren) {  							InferTypeForExpression(expr.Arguments[1]' typeSystem.Int32);  						}  						return arrayType != null ? arrayType.ElementType : null;  					}  				case ILCode.Ldelem_Any:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[1]' typeSystem.Int32);  					}  					return (TypeReference)expr.Operand;  				case ILCode.Ldelema:  					{  						ArrayType arrayType = InferTypeForExpression(expr.Arguments[0]' null) as ArrayType;  						if (forceInferChildren)  							InferTypeForExpression(expr.Arguments[1]' typeSystem.Int32);  						return arrayType != null ? new ByReferenceType(arrayType.ElementType) : null;  					}  				case ILCode.Stelem_I:  				case ILCode.Stelem_I1:  				case ILCode.Stelem_I2:  				case ILCode.Stelem_I4:  				case ILCode.Stelem_I8:  				case ILCode.Stelem_R4:  				case ILCode.Stelem_R8:  				case ILCode.Stelem_Ref:  				case ILCode.Stelem_Any:  					{  						ArrayType arrayType = InferTypeForExpression(expr.Arguments[0]' null) as ArrayType;  						if (forceInferChildren) {  							InferTypeForExpression(expr.Arguments[1]' typeSystem.Int32);  							if (arrayType != null) {  								InferTypeForExpression(expr.Arguments[2]' arrayType.ElementType);  							}  						}  						return arrayType != null ? arrayType.ElementType : null;  					}  					#endregion  					#region Conversion instructions  				case ILCode.Conv_I1:  				case ILCode.Conv_Ovf_I1:  				case ILCode.Conv_Ovf_I1_Un:  					return HandleConversion(8' true' expr.Arguments[0]' expectedType' typeSystem.SByte);  				case ILCode.Conv_I2:  				case ILCode.Conv_Ovf_I2:  				case ILCode.Conv_Ovf_I2_Un:  					return HandleConversion(16' true' expr.Arguments[0]' expectedType' typeSystem.Int16);  				case ILCode.Conv_I4:  				case ILCode.Conv_Ovf_I4:  				case ILCode.Conv_Ovf_I4_Un:  					return HandleConversion(32' true' expr.Arguments[0]' expectedType' typeSystem.Int32);  				case ILCode.Conv_I8:  				case ILCode.Conv_Ovf_I8:  				case ILCode.Conv_Ovf_I8_Un:  					return HandleConversion(64' true' expr.Arguments[0]' expectedType' typeSystem.Int64);  				case ILCode.Conv_U1:  				case ILCode.Conv_Ovf_U1:  				case ILCode.Conv_Ovf_U1_Un:  					return HandleConversion(8' false' expr.Arguments[0]' expectedType' typeSystem.Byte);  				case ILCode.Conv_U2:  				case ILCode.Conv_Ovf_U2:  				case ILCode.Conv_Ovf_U2_Un:  					return HandleConversion(16' false' expr.Arguments[0]' expectedType' typeSystem.UInt16);  				case ILCode.Conv_U4:  				case ILCode.Conv_Ovf_U4:  				case ILCode.Conv_Ovf_U4_Un:  					return HandleConversion(32' false' expr.Arguments[0]' expectedType' typeSystem.UInt32);  				case ILCode.Conv_U8:  				case ILCode.Conv_Ovf_U8:  				case ILCode.Conv_Ovf_U8_Un:  					return HandleConversion(64' false' expr.Arguments[0]' expectedType' typeSystem.UInt64);  				case ILCode.Conv_I:  				case ILCode.Conv_Ovf_I:  				case ILCode.Conv_Ovf_I_Un:  					return HandleConversion(NativeInt' true' expr.Arguments[0]' expectedType' typeSystem.IntPtr);  				case ILCode.Conv_U:  				case ILCode.Conv_Ovf_U:  				case ILCode.Conv_Ovf_U_Un:  					return HandleConversion(NativeInt' false' expr.Arguments[0]' expectedType' typeSystem.UIntPtr);  				case ILCode.Conv_R4:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[0]' typeSystem.Single);  					}  					return typeSystem.Single;  				case ILCode.Conv_R8:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[0]' typeSystem.Double);  					}  					return typeSystem.Double;  				case ILCode.Conv_R_Un:  					return (expectedType != null  && expectedType.MetadataType == MetadataType.Single) ? typeSystem.Single : typeSystem.Double;  				case ILCode.Castclass:  				case ILCode.Unbox_Any:  					return (TypeReference)expr.Operand;  				case ILCode.Unbox:  					return new ByReferenceType((TypeReference)expr.Operand);  				case ILCode.Isinst:  					{  						// isinst performs the equivalent of a cast only for reference types;  						// value types still need to be unboxed after an isinst instruction  						TypeReference tr = (TypeReference)expr.Operand;  						return tr.IsValueType ? typeSystem.Object : tr;  					}  				case ILCode.Box:  					{  						var tr = (TypeReference)expr.Operand;  						if (forceInferChildren)  							InferTypeForExpression(expr.Arguments.Single()' tr);  						return tr.IsValueType ? typeSystem.Object : tr;  					}  					#endregion  					#region Comparison instructions  				case ILCode.Ceq:  				case ILCode.Cne:  					if (forceInferChildren)  						InferArgumentsInBinaryOperator(expr' null' null);  					return typeSystem.Boolean;  				case ILCode.Clt:  				case ILCode.Cgt:  				case ILCode.Cle:  				case ILCode.Cge:  					if (forceInferChildren)  						InferArgumentsInBinaryOperator(expr' true' null);  					return typeSystem.Boolean;  				case ILCode.Clt_Un:  				case ILCode.Cgt_Un:  				case ILCode.Cle_Un:  				case ILCode.Cge_Un:  					if (forceInferChildren)  						InferArgumentsInBinaryOperator(expr' false' null);  					return typeSystem.Boolean;  					#endregion  					#region Branch instructions  				case ILCode.Brtrue:  					if (forceInferChildren)  						InferTypeForExpression(expr.Arguments.Single()' typeSystem.Boolean);  					return null;  				case ILCode.Br:  				case ILCode.Leave:  				case ILCode.Endfinally:  				case ILCode.Switch:  				case ILCode.Throw:  				case ILCode.Rethrow:  				case ILCode.LoopOrSwitchBreak:  				case ILCode.LoopContinue:  				case ILCode.YieldBreak:  					return null;  				case ILCode.Ret:  					if (forceInferChildren && expr.Arguments.Count == 1) {  						TypeReference returnType = context.CurrentMethod.ReturnType;  						if (context.CurrentMethodIsAsync && returnType != null && returnType.Namespace == "System.Threading.Tasks") {  							if (returnType.Name == "Task") {  								returnType = typeSystem.Void;  							} else if (returnType.Name == "Task`1" && returnType.IsGenericInstance) {  								returnType = ((GenericInstanceType)returnType).GenericArguments[0];  							}  						}  						InferTypeForExpression(expr.Arguments[0]' returnType);  					}  					return null;  				case ILCode.YieldReturn:  					if (forceInferChildren) {  						GenericInstanceType genericType = context.CurrentMethod.ReturnType as GenericInstanceType;  						if (genericType != null) { // IEnumerable<T> or IEnumerator<T>  							InferTypeForExpression(expr.Arguments[0]' genericType.GenericArguments[0]);  						} else { // non-generic IEnumerable or IEnumerator  							InferTypeForExpression(expr.Arguments[0]' typeSystem.Object);  						}  					}  					return null;  				case ILCode.Await:  					{  						TypeReference taskType = InferTypeForExpression(expr.Arguments[0]' null);  						if (taskType.Name == "Task`1" && taskType.IsGenericInstance && taskType.Namespace == "System.Threading.Tasks") {  							return ((GenericInstanceType)taskType).GenericArguments[0];  						}  						return null;  					}  					#endregion  				case ILCode.Pop:  					return null;  				case ILCode.Wrap:  				case ILCode.Dup:  					{  						var arg = expr.Arguments.Single();  						return arg.ExpectedType = InferTypeForExpression(arg' expectedType);  					}  				default:  					Debug.WriteLine("Type Inference: Can't handle " + expr.Code.GetName());  					return null;  			}
Magic Number,Custom.Decompiler.ILAst,TypeAnalysis,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\TypeAnalysis.cs,DoInferTypeForExpression,The following statement contains a magic number: switch (expr.Code) {  					#region Logical operators  				case ILCode.LogicNot:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments.Single()' typeSystem.Boolean);  					}  					return typeSystem.Boolean;  				case ILCode.LogicAnd:  				case ILCode.LogicOr:  					// if Operand is set the logic and/or expression is a custom operator  					// we can deal with it the same as a normal invocation.  					if (expr.Operand != null)  						goto case ILCode.Call;  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[0]' typeSystem.Boolean);  						InferTypeForExpression(expr.Arguments[1]' typeSystem.Boolean);  					}  					return typeSystem.Boolean;  				case ILCode.TernaryOp:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[0]' typeSystem.Boolean);  					}  					return InferBinaryArguments(expr.Arguments[1]' expr.Arguments[2]' expectedType' forceInferChildren);  				case ILCode.NullCoalescing:  					return InferBinaryArguments(expr.Arguments[0]' expr.Arguments[1]' expectedType' forceInferChildren);  					#endregion  					#region Variable load/store  				case ILCode.Stloc:  					{  						ILVariable v = (ILVariable)expr.Operand;  						if (forceInferChildren) {  							// do not use 'expectedType' in here!  							InferTypeForExpression(expr.Arguments.Single()' v.Type);  						}  						return v.Type;  					}  				case ILCode.Ldloc:  					{  						ILVariable v = (ILVariable)expr.Operand;  						if (v.Type == null && singleLoadVariables.Contains(v)) {  							v.Type = expectedType;  						}  						return v.Type;  					}  				case ILCode.Ldloca:  					{  						ILVariable v = (ILVariable)expr.Operand;  						if (v.Type != null)  							return new ByReferenceType(v.Type);  						else  							return null;  					}  					#endregion  					#region Call / NewObj  				case ILCode.Call:  				case ILCode.Callvirt:  				case ILCode.CallGetter:  				case ILCode.CallvirtGetter:  				case ILCode.CallSetter:  				case ILCode.CallvirtSetter:  					{  						MethodReference method = (MethodReference)expr.Operand;  						if (forceInferChildren) {  							for (int i = 0; i < expr.Arguments.Count; i++) {  								if (i == 0 && method.HasThis) {  									InferTypeForExpression(expr.Arguments[0]' MakeRefIfValueType(method.DeclaringType' expr.GetPrefix(ILCode.Constrained)));  								} else {  									InferTypeForExpression(expr.Arguments[i]' SubstituteTypeArgs(method.Parameters[method.HasThis ? i - 1 : i].ParameterType' method));  								}  							}  						}  						if (expr.Code == ILCode.CallSetter || expr.Code == ILCode.CallvirtSetter) {  							return SubstituteTypeArgs(method.Parameters.Last().ParameterType' method);  						} else {  							return SubstituteTypeArgs(method.ReturnType' method);  						}  					}  				case ILCode.Newobj:  					{  						MethodReference ctor = (MethodReference)expr.Operand;  						if (forceInferChildren) {  							for (int i = 0; i < ctor.Parameters.Count; i++) {  								InferTypeForExpression(expr.Arguments[i]' SubstituteTypeArgs(ctor.Parameters[i].ParameterType' ctor));  							}  						}  						return ctor.DeclaringType;  					}  				case ILCode.InitObject:  				case ILCode.InitCollection:  					return InferTypeForExpression(expr.Arguments[0]' expectedType);  				case ILCode.InitializedObject:  					// expectedType should always be known due to the parent method call / property setter  					Debug.Assert(expectedType != null);  					return expectedType;  					#endregion  					#region Load/Store Fields  				case ILCode.Ldfld:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[0]' MakeRefIfValueType(((FieldReference)expr.Operand).DeclaringType' expr.GetPrefix(ILCode.Constrained)));  					}  					return GetFieldType((FieldReference)expr.Operand);  				case ILCode.Ldsfld:  					return GetFieldType((FieldReference)expr.Operand);  				case ILCode.Ldflda:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[0]' MakeRefIfValueType(((FieldReference)expr.Operand).DeclaringType' expr.GetPrefix(ILCode.Constrained)));  					}  					return new ByReferenceType(GetFieldType((FieldReference)expr.Operand));  				case ILCode.Ldsflda:  					return new ByReferenceType(GetFieldType((FieldReference)expr.Operand));  				case ILCode.Stfld:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[0]' MakeRefIfValueType(((FieldReference)expr.Operand).DeclaringType' expr.GetPrefix(ILCode.Constrained)));  						InferTypeForExpression(expr.Arguments[1]' GetFieldType((FieldReference)expr.Operand));  					}  					return GetFieldType((FieldReference)expr.Operand);  				case ILCode.Stsfld:  					if (forceInferChildren)  						InferTypeForExpression(expr.Arguments[0]' GetFieldType((FieldReference)expr.Operand));  					return GetFieldType((FieldReference)expr.Operand);  					#endregion  					#region Reference/Pointer instructions  				case ILCode.Ldind_Ref:  					return UnpackPointer(InferTypeForExpression(expr.Arguments[0]' null));  				case ILCode.Stind_Ref:  					if (forceInferChildren) {  						TypeReference elementType = UnpackPointer(InferTypeForExpression(expr.Arguments[0]' null));  						InferTypeForExpression(expr.Arguments[1]' elementType);  					}  					return null;  				case ILCode.Ldobj:  					{  						TypeReference type = (TypeReference)expr.Operand;  						var argType = InferTypeForExpression(expr.Arguments[0]' null);  						if (argType is PointerType || argType is ByReferenceType) {  							var elementType = ((TypeSpecification)argType).ElementType;  							int infoAmount = GetInformationAmount(elementType);  							if (infoAmount == 1 && GetInformationAmount(type) == 8) {  								// A bool can be loaded from both bytes and sbytes.  								type = elementType;  							}  							if (infoAmount >= 8 && infoAmount <= 64 && infoAmount == GetInformationAmount(type)) {  								// An integer can be loaded as another integer of the same size.  								// For integers smaller than 32 bit' the signs must match (as loading performs sign extension)  								bool? elementTypeIsSigned = IsSigned(elementType);  								bool? typeIsSigned = IsSigned(type);  								if (elementTypeIsSigned != null && typeIsSigned != null) {  									if (infoAmount >= 32 || elementTypeIsSigned == typeIsSigned)  										type = elementType;  								}  							}  						}  						if (argType is PointerType)  							InferTypeForExpression(expr.Arguments[0]' new PointerType(type));  						else  							InferTypeForExpression(expr.Arguments[0]' new ByReferenceType(type));  						return type;  					}  				case ILCode.Stobj:  					{  						TypeReference operandType = (TypeReference)expr.Operand;  						TypeReference pointerType = InferTypeForExpression(expr.Arguments[0]' new ByReferenceType(operandType));  						TypeReference elementType;  						if (pointerType is PointerType)  							elementType = ((PointerType)pointerType).ElementType;  						else if (pointerType is ByReferenceType)  							elementType = ((ByReferenceType)pointerType).ElementType;  						else  							elementType = null;  						if (elementType != null) {  							// An integer can be stored in any other integer of the same size.  							int infoAmount = GetInformationAmount(elementType);  							if (infoAmount == 1 && GetInformationAmount(operandType) == 8)  								operandType = elementType;  							else if (infoAmount == GetInformationAmount(operandType) && IsSigned(elementType) != null && IsSigned(operandType) != null)  								operandType = elementType;  						}  						if (forceInferChildren) {  							if (pointerType is PointerType)  								InferTypeForExpression(expr.Arguments[0]' new PointerType(operandType));  							else if (!IsSameType(operandType' expr.Operand as TypeReference))  								InferTypeForExpression(expr.Arguments[0]' new ByReferenceType(operandType));  							InferTypeForExpression(expr.Arguments[1]' operandType);  						}  						return operandType;  					}  				case ILCode.Initobj:  					return null;  				case ILCode.DefaultValue:  					return (TypeReference)expr.Operand;  				case ILCode.Localloc:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[0]' typeSystem.Int32);  					}  					if (expectedType is PointerType)  						return expectedType;  					else  						return typeSystem.IntPtr;  				case ILCode.Sizeof:  					return typeSystem.Int32;  				case ILCode.PostIncrement:  				case ILCode.PostIncrement_Ovf:  				case ILCode.PostIncrement_Ovf_Un:  					{  						TypeReference elementType = UnpackPointer(InferTypeForExpression(expr.Arguments[0]' null));  						if (forceInferChildren && elementType != null) {  							// Assign expected type to the child expression  							InferTypeForExpression(expr.Arguments[0]' new ByReferenceType(elementType));  						}  						return elementType;  					}  				case ILCode.Mkrefany:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[0]' (TypeReference)expr.Operand);  					}  					return typeSystem.TypedReference;  				case ILCode.Refanytype:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[0]' typeSystem.TypedReference);  					}                      return new TypeReference("System"' "RuntimeTypeHandle"' module' module.TypeSystem.CoreLibrary' true);  				case ILCode.Refanyval:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[0]' typeSystem.TypedReference);  					}  					return new ByReferenceType((TypeReference)expr.Operand);  				case ILCode.AddressOf:  					{  						TypeReference t = InferTypeForExpression(expr.Arguments[0]' UnpackPointer(expectedType));  						return t != null ? new ByReferenceType(t) : null;  					}  				case ILCode.ValueOf:  					return GetNullableTypeArgument(InferTypeForExpression(expr.Arguments[0]' CreateNullableType(expectedType)));  				case ILCode.NullableOf:  					return CreateNullableType(InferTypeForExpression(expr.Arguments[0]' GetNullableTypeArgument(expectedType)));  					#endregion  					#region Arithmetic instructions  				case ILCode.Not: // bitwise complement  				case ILCode.Neg:  					return InferTypeForExpression(expr.Arguments.Single()' expectedType);  				case ILCode.Add:  					return InferArgumentsInAddition(expr' null' expectedType);  				case ILCode.Sub:  					return InferArgumentsInSubtraction(expr' null' expectedType);  				case ILCode.Mul:  				case ILCode.Or:  				case ILCode.And:  				case ILCode.Xor:  					return InferArgumentsInBinaryOperator(expr' null' expectedType);  				case ILCode.Add_Ovf:  					return InferArgumentsInAddition(expr' true' expectedType);  				case ILCode.Sub_Ovf:  					return InferArgumentsInSubtraction(expr' true' expectedType);  				case ILCode.Mul_Ovf:  				case ILCode.Div:  				case ILCode.Rem:  					return InferArgumentsInBinaryOperator(expr' true' expectedType);  				case ILCode.Add_Ovf_Un:  					return InferArgumentsInAddition(expr' false' expectedType);  				case ILCode.Sub_Ovf_Un:  					return InferArgumentsInSubtraction(expr' false' expectedType);  				case ILCode.Mul_Ovf_Un:  				case ILCode.Div_Un:  				case ILCode.Rem_Un:  					return InferArgumentsInBinaryOperator(expr' false' expectedType);  				case ILCode.Shl:  					if (forceInferChildren)  						InferTypeForExpression(expr.Arguments[1]' typeSystem.Int32);  					if (expectedType != null && (  						expectedType.MetadataType == MetadataType.Int32 || expectedType.MetadataType == MetadataType.UInt32 ||  						expectedType.MetadataType == MetadataType.Int64 || expectedType.MetadataType == MetadataType.UInt64)  					   )  						return NumericPromotion(InferTypeForExpression(expr.Arguments[0]' expectedType));  					else  						return NumericPromotion(InferTypeForExpression(expr.Arguments[0]' null));  				case ILCode.Shr:  				case ILCode.Shr_Un:  					{  						if (forceInferChildren)  							InferTypeForExpression(expr.Arguments[1]' typeSystem.Int32);  						TypeReference type = NumericPromotion(InferTypeForExpression(expr.Arguments[0]' null));  						TypeReference expectedInputType = null;  						switch (type.MetadataType) {  							case MetadataType.Int32:  								if (expr.Code == ILCode.Shr_Un)  									expectedInputType = typeSystem.UInt32;  								break;  							case MetadataType.UInt32:  								if (expr.Code == ILCode.Shr)  									expectedInputType = typeSystem.Int32;  								break;  							case MetadataType.Int64:  								if (expr.Code == ILCode.Shr_Un)  									expectedInputType = typeSystem.UInt64;  								break;  							case MetadataType.UInt64:  								if (expr.Code == ILCode.Shr)  									expectedInputType = typeSystem.UInt64;  								break;  						}  						if (expectedInputType != null) {  							InferTypeForExpression(expr.Arguments[0]' expectedInputType);  							return expectedInputType;  						} else {  							return type;  						}  					}  				case ILCode.CompoundAssignment:  					{  						var op = expr.Arguments[0];  						if (op.Code == ILCode.NullableOf) op = op.Arguments[0].Arguments[0];  						var varType = InferTypeForExpression(op.Arguments[0]' null);  						if (forceInferChildren) {  							InferTypeForExpression(expr.Arguments[0]' varType);  						}  						return varType;  					}  					#endregion  					#region Constant loading instructions  				case ILCode.Ldnull:  					return typeSystem.Object;  				case ILCode.Ldstr:  					return typeSystem.String;  				case ILCode.Ldftn:  				case ILCode.Ldvirtftn:  					return typeSystem.IntPtr;  				case ILCode.Ldc_I4:  					if (IsBoolean(expectedType) && ((int)expr.Operand == 0 || (int)expr.Operand == 1))  						return typeSystem.Boolean;  					if (expectedType is PointerType && (int)expr.Operand == 0)  						return expectedType;  					if (IsIntegerOrEnum(expectedType) && OperandFitsInType(expectedType' (int)expr.Operand))  						return expectedType;  					else  						return typeSystem.Int32;  				case ILCode.Ldc_I8:  					if (expectedType is PointerType && (long)expr.Operand == 0)  						return expectedType;  					if (IsIntegerOrEnum(expectedType) && GetInformationAmount(expectedType) >= NativeInt)  						return expectedType;  					else  						return typeSystem.Int64;  				case ILCode.Ldc_R4:  					return typeSystem.Single;  				case ILCode.Ldc_R8:  					return typeSystem.Double;  				case ILCode.Ldc_Decimal:                      return new TypeReference("System"' "Decimal"' module' module.TypeSystem.CoreLibrary' true);  				case ILCode.Ldtoken:  					if (expr.Operand is TypeReference)  						return new TypeReference("System"' "RuntimeTypeHandle"' module' module.TypeSystem.CoreLibrary' true);  					else if (expr.Operand is FieldReference)                          return new TypeReference("System"' "RuntimeFieldHandle"' module' module.TypeSystem.CoreLibrary' true);  					else                          return new TypeReference("System"' "RuntimeMethodHandle"' module' module.TypeSystem.CoreLibrary' true);  				case ILCode.Arglist:                      return new TypeReference("System"' "RuntimeArgumentHandle"' module' module.TypeSystem.CoreLibrary' true);  					#endregion  					#region Array instructions  				case ILCode.Newarr:  					if (forceInferChildren) {  						var lengthType = InferTypeForExpression(expr.Arguments.Single()' null);  						if (lengthType == typeSystem.IntPtr) {  							lengthType = typeSystem.Int64;  						} else if (lengthType == typeSystem.UIntPtr) {  							lengthType = typeSystem.UInt64;  						} else if (lengthType != typeSystem.UInt32 && lengthType != typeSystem.Int64 && lengthType != typeSystem.UInt64) {  							lengthType = typeSystem.Int32;  						}  						if (forceInferChildren) {  							InferTypeForExpression(expr.Arguments.Single()' lengthType);  						}  					}  					return new ArrayType((TypeReference)expr.Operand);  				case ILCode.InitArray:  					var operandAsArrayType = (ArrayType)expr.Operand;  					if (forceInferChildren)  					{  						foreach (ILExpression arg in expr.Arguments)  							InferTypeForExpression(arg' operandAsArrayType.ElementType);  					}  					return operandAsArrayType;  				case ILCode.Ldlen:  					return typeSystem.Int32;  				case ILCode.Ldelem_U1:  				case ILCode.Ldelem_U2:  				case ILCode.Ldelem_U4:  				case ILCode.Ldelem_I1:  				case ILCode.Ldelem_I2:  				case ILCode.Ldelem_I4:  				case ILCode.Ldelem_I8:  				case ILCode.Ldelem_R4:  				case ILCode.Ldelem_R8:  				case ILCode.Ldelem_I:  				case ILCode.Ldelem_Ref:  					{  						ArrayType arrayType = InferTypeForExpression(expr.Arguments[0]' null) as ArrayType;  						if (forceInferChildren) {  							InferTypeForExpression(expr.Arguments[1]' typeSystem.Int32);  						}  						return arrayType != null ? arrayType.ElementType : null;  					}  				case ILCode.Ldelem_Any:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[1]' typeSystem.Int32);  					}  					return (TypeReference)expr.Operand;  				case ILCode.Ldelema:  					{  						ArrayType arrayType = InferTypeForExpression(expr.Arguments[0]' null) as ArrayType;  						if (forceInferChildren)  							InferTypeForExpression(expr.Arguments[1]' typeSystem.Int32);  						return arrayType != null ? new ByReferenceType(arrayType.ElementType) : null;  					}  				case ILCode.Stelem_I:  				case ILCode.Stelem_I1:  				case ILCode.Stelem_I2:  				case ILCode.Stelem_I4:  				case ILCode.Stelem_I8:  				case ILCode.Stelem_R4:  				case ILCode.Stelem_R8:  				case ILCode.Stelem_Ref:  				case ILCode.Stelem_Any:  					{  						ArrayType arrayType = InferTypeForExpression(expr.Arguments[0]' null) as ArrayType;  						if (forceInferChildren) {  							InferTypeForExpression(expr.Arguments[1]' typeSystem.Int32);  							if (arrayType != null) {  								InferTypeForExpression(expr.Arguments[2]' arrayType.ElementType);  							}  						}  						return arrayType != null ? arrayType.ElementType : null;  					}  					#endregion  					#region Conversion instructions  				case ILCode.Conv_I1:  				case ILCode.Conv_Ovf_I1:  				case ILCode.Conv_Ovf_I1_Un:  					return HandleConversion(8' true' expr.Arguments[0]' expectedType' typeSystem.SByte);  				case ILCode.Conv_I2:  				case ILCode.Conv_Ovf_I2:  				case ILCode.Conv_Ovf_I2_Un:  					return HandleConversion(16' true' expr.Arguments[0]' expectedType' typeSystem.Int16);  				case ILCode.Conv_I4:  				case ILCode.Conv_Ovf_I4:  				case ILCode.Conv_Ovf_I4_Un:  					return HandleConversion(32' true' expr.Arguments[0]' expectedType' typeSystem.Int32);  				case ILCode.Conv_I8:  				case ILCode.Conv_Ovf_I8:  				case ILCode.Conv_Ovf_I8_Un:  					return HandleConversion(64' true' expr.Arguments[0]' expectedType' typeSystem.Int64);  				case ILCode.Conv_U1:  				case ILCode.Conv_Ovf_U1:  				case ILCode.Conv_Ovf_U1_Un:  					return HandleConversion(8' false' expr.Arguments[0]' expectedType' typeSystem.Byte);  				case ILCode.Conv_U2:  				case ILCode.Conv_Ovf_U2:  				case ILCode.Conv_Ovf_U2_Un:  					return HandleConversion(16' false' expr.Arguments[0]' expectedType' typeSystem.UInt16);  				case ILCode.Conv_U4:  				case ILCode.Conv_Ovf_U4:  				case ILCode.Conv_Ovf_U4_Un:  					return HandleConversion(32' false' expr.Arguments[0]' expectedType' typeSystem.UInt32);  				case ILCode.Conv_U8:  				case ILCode.Conv_Ovf_U8:  				case ILCode.Conv_Ovf_U8_Un:  					return HandleConversion(64' false' expr.Arguments[0]' expectedType' typeSystem.UInt64);  				case ILCode.Conv_I:  				case ILCode.Conv_Ovf_I:  				case ILCode.Conv_Ovf_I_Un:  					return HandleConversion(NativeInt' true' expr.Arguments[0]' expectedType' typeSystem.IntPtr);  				case ILCode.Conv_U:  				case ILCode.Conv_Ovf_U:  				case ILCode.Conv_Ovf_U_Un:  					return HandleConversion(NativeInt' false' expr.Arguments[0]' expectedType' typeSystem.UIntPtr);  				case ILCode.Conv_R4:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[0]' typeSystem.Single);  					}  					return typeSystem.Single;  				case ILCode.Conv_R8:  					if (forceInferChildren) {  						InferTypeForExpression(expr.Arguments[0]' typeSystem.Double);  					}  					return typeSystem.Double;  				case ILCode.Conv_R_Un:  					return (expectedType != null  && expectedType.MetadataType == MetadataType.Single) ? typeSystem.Single : typeSystem.Double;  				case ILCode.Castclass:  				case ILCode.Unbox_Any:  					return (TypeReference)expr.Operand;  				case ILCode.Unbox:  					return new ByReferenceType((TypeReference)expr.Operand);  				case ILCode.Isinst:  					{  						// isinst performs the equivalent of a cast only for reference types;  						// value types still need to be unboxed after an isinst instruction  						TypeReference tr = (TypeReference)expr.Operand;  						return tr.IsValueType ? typeSystem.Object : tr;  					}  				case ILCode.Box:  					{  						var tr = (TypeReference)expr.Operand;  						if (forceInferChildren)  							InferTypeForExpression(expr.Arguments.Single()' tr);  						return tr.IsValueType ? typeSystem.Object : tr;  					}  					#endregion  					#region Comparison instructions  				case ILCode.Ceq:  				case ILCode.Cne:  					if (forceInferChildren)  						InferArgumentsInBinaryOperator(expr' null' null);  					return typeSystem.Boolean;  				case ILCode.Clt:  				case ILCode.Cgt:  				case ILCode.Cle:  				case ILCode.Cge:  					if (forceInferChildren)  						InferArgumentsInBinaryOperator(expr' true' null);  					return typeSystem.Boolean;  				case ILCode.Clt_Un:  				case ILCode.Cgt_Un:  				case ILCode.Cle_Un:  				case ILCode.Cge_Un:  					if (forceInferChildren)  						InferArgumentsInBinaryOperator(expr' false' null);  					return typeSystem.Boolean;  					#endregion  					#region Branch instructions  				case ILCode.Brtrue:  					if (forceInferChildren)  						InferTypeForExpression(expr.Arguments.Single()' typeSystem.Boolean);  					return null;  				case ILCode.Br:  				case ILCode.Leave:  				case ILCode.Endfinally:  				case ILCode.Switch:  				case ILCode.Throw:  				case ILCode.Rethrow:  				case ILCode.LoopOrSwitchBreak:  				case ILCode.LoopContinue:  				case ILCode.YieldBreak:  					return null;  				case ILCode.Ret:  					if (forceInferChildren && expr.Arguments.Count == 1) {  						TypeReference returnType = context.CurrentMethod.ReturnType;  						if (context.CurrentMethodIsAsync && returnType != null && returnType.Namespace == "System.Threading.Tasks") {  							if (returnType.Name == "Task") {  								returnType = typeSystem.Void;  							} else if (returnType.Name == "Task`1" && returnType.IsGenericInstance) {  								returnType = ((GenericInstanceType)returnType).GenericArguments[0];  							}  						}  						InferTypeForExpression(expr.Arguments[0]' returnType);  					}  					return null;  				case ILCode.YieldReturn:  					if (forceInferChildren) {  						GenericInstanceType genericType = context.CurrentMethod.ReturnType as GenericInstanceType;  						if (genericType != null) { // IEnumerable<T> or IEnumerator<T>  							InferTypeForExpression(expr.Arguments[0]' genericType.GenericArguments[0]);  						} else { // non-generic IEnumerable or IEnumerator  							InferTypeForExpression(expr.Arguments[0]' typeSystem.Object);  						}  					}  					return null;  				case ILCode.Await:  					{  						TypeReference taskType = InferTypeForExpression(expr.Arguments[0]' null);  						if (taskType.Name == "Task`1" && taskType.IsGenericInstance && taskType.Namespace == "System.Threading.Tasks") {  							return ((GenericInstanceType)taskType).GenericArguments[0];  						}  						return null;  					}  					#endregion  				case ILCode.Pop:  					return null;  				case ILCode.Wrap:  				case ILCode.Dup:  					{  						var arg = expr.Arguments.Single();  						return arg.ExpectedType = InferTypeForExpression(arg' expectedType);  					}  				default:  					Debug.WriteLine("Type Inference: Can't handle " + expr.Code.GetName());  					return null;  			}
Magic Number,Custom.Decompiler.ILAst,TypeAnalysis,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\TypeAnalysis.cs,GetInformationAmount,The following statement contains a magic number: switch (type.MetadataType) {  				case MetadataType.Void:  					return 0;  				case MetadataType.Boolean:  					return 1;  				case MetadataType.SByte:  				case MetadataType.Byte:  					return 8;  				case MetadataType.Char:  				case MetadataType.Int16:  				case MetadataType.UInt16:  					return 16;  				case MetadataType.Int32:  				case MetadataType.UInt32:  				case MetadataType.Single:  					return 32;  				case MetadataType.Int64:  				case MetadataType.UInt64:  				case MetadataType.Double:  					return 64;  				case MetadataType.IntPtr:  				case MetadataType.UIntPtr:  					return NativeInt;  				default:  					return 100; // we consider structs/objects to have more information than any primitives  			}
Magic Number,Custom.Decompiler.ILAst,TypeAnalysis,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\TypeAnalysis.cs,GetInformationAmount,The following statement contains a magic number: switch (type.MetadataType) {  				case MetadataType.Void:  					return 0;  				case MetadataType.Boolean:  					return 1;  				case MetadataType.SByte:  				case MetadataType.Byte:  					return 8;  				case MetadataType.Char:  				case MetadataType.Int16:  				case MetadataType.UInt16:  					return 16;  				case MetadataType.Int32:  				case MetadataType.UInt32:  				case MetadataType.Single:  					return 32;  				case MetadataType.Int64:  				case MetadataType.UInt64:  				case MetadataType.Double:  					return 64;  				case MetadataType.IntPtr:  				case MetadataType.UIntPtr:  					return NativeInt;  				default:  					return 100; // we consider structs/objects to have more information than any primitives  			}
Magic Number,Custom.Decompiler.ILAst,TypeAnalysis,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\TypeAnalysis.cs,GetInformationAmount,The following statement contains a magic number: switch (type.MetadataType) {  				case MetadataType.Void:  					return 0;  				case MetadataType.Boolean:  					return 1;  				case MetadataType.SByte:  				case MetadataType.Byte:  					return 8;  				case MetadataType.Char:  				case MetadataType.Int16:  				case MetadataType.UInt16:  					return 16;  				case MetadataType.Int32:  				case MetadataType.UInt32:  				case MetadataType.Single:  					return 32;  				case MetadataType.Int64:  				case MetadataType.UInt64:  				case MetadataType.Double:  					return 64;  				case MetadataType.IntPtr:  				case MetadataType.UIntPtr:  					return NativeInt;  				default:  					return 100; // we consider structs/objects to have more information than any primitives  			}
Magic Number,Custom.Decompiler.ILAst,TypeAnalysis,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\TypeAnalysis.cs,GetInformationAmount,The following statement contains a magic number: switch (type.MetadataType) {  				case MetadataType.Void:  					return 0;  				case MetadataType.Boolean:  					return 1;  				case MetadataType.SByte:  				case MetadataType.Byte:  					return 8;  				case MetadataType.Char:  				case MetadataType.Int16:  				case MetadataType.UInt16:  					return 16;  				case MetadataType.Int32:  				case MetadataType.UInt32:  				case MetadataType.Single:  					return 32;  				case MetadataType.Int64:  				case MetadataType.UInt64:  				case MetadataType.Double:  					return 64;  				case MetadataType.IntPtr:  				case MetadataType.UIntPtr:  					return NativeInt;  				default:  					return 100; // we consider structs/objects to have more information than any primitives  			}
Magic Number,Custom.Decompiler.ILAst,TypeAnalysis,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\TypeAnalysis.cs,GetInformationAmount,The following statement contains a magic number: switch (type.MetadataType) {  				case MetadataType.Void:  					return 0;  				case MetadataType.Boolean:  					return 1;  				case MetadataType.SByte:  				case MetadataType.Byte:  					return 8;  				case MetadataType.Char:  				case MetadataType.Int16:  				case MetadataType.UInt16:  					return 16;  				case MetadataType.Int32:  				case MetadataType.UInt32:  				case MetadataType.Single:  					return 32;  				case MetadataType.Int64:  				case MetadataType.UInt64:  				case MetadataType.Double:  					return 64;  				case MetadataType.IntPtr:  				case MetadataType.UIntPtr:  					return NativeInt;  				default:  					return 100; // we consider structs/objects to have more information than any primitives  			}
Magic Number,Custom.Decompiler.ILAst,YieldReturnDecompiler,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\YieldReturnDecompiler.cs,MatchEnumeratorCreationNewObj,The following statement contains a magic number: !(initialState == -2 || initialState == 0)
Magic Number,Custom.Decompiler.ILAst,YieldReturnDecompiler,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\YieldReturnDecompiler.cs,ConstructExceptionTable,The following statement contains a magic number: finallyBody.Count != 2
Magic Number,Custom.Decompiler.ILAst,YieldReturnDecompiler,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\YieldReturnDecompiler.cs,AnalyzeMoveNext,The following statement contains a magic number: returnLabel = ilMethod.Body.ElementAtOrDefault(ilMethod.Body.Count - 2) as ILLabel;
Magic Number,Custom.Decompiler.ILAst,YieldReturnDecompiler,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\YieldReturnDecompiler.cs,AnalyzeMoveNext,The following statement contains a magic number: faultBlock.Body.Count != 2
Missing Default,Custom.Decompiler.Ast,AstBuilder,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\AstBuilder.cs,ConvertType,The following switch statement is missing a default case: switch (name) {  								case "SByte":  									return new PrimitiveType("sbyte");  								case "Int16":  									return new PrimitiveType("short");  								case "Int32":  									return new PrimitiveType("int");  								case "Int64":  									return new PrimitiveType("long");  								case "Byte":  									return new PrimitiveType("byte");  								case "UInt16":  									return new PrimitiveType("ushort");  								case "UInt32":  									return new PrimitiveType("uint");  								case "UInt64":  									return new PrimitiveType("ulong");  								case "String":  									return new PrimitiveType("string");  								case "Single":  									return new PrimitiveType("float");  								case "Double":  									return new PrimitiveType("double");  								case "Decimal":  									return new PrimitiveType("decimal");  								case "Char":  									return new PrimitiveType("char");  								case "Boolean":  									return new PrimitiveType("bool");  								case "Void":  									return new PrimitiveType("void");  								case "Object":  									return new PrimitiveType("object");  							}
Missing Default,Custom.Decompiler.Ast,AstBuilder,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\AstBuilder.cs,ConvertAttributes,The following switch statement is missing a default case: switch (typeDefinition.Attributes & TypeAttributes.LayoutMask) {  				case TypeAttributes.SequentialLayout:  					layoutKind = LayoutKind.Sequential;  					break;  				case TypeAttributes.ExplicitLayout:  					layoutKind = LayoutKind.Explicit;  					break;  			}
Missing Default,Custom.Decompiler.Ast,AstBuilder,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\AstBuilder.cs,ConvertAttributes,The following switch statement is missing a default case: switch (typeDefinition.Attributes & TypeAttributes.StringFormatMask) {  				case TypeAttributes.AnsiClass:  					charSet = CharSet.Ansi;  					break;  				case TypeAttributes.AutoClass:  					charSet = CharSet.Auto;  					break;  				case TypeAttributes.UnicodeClass:  					charSet = CharSet.Unicode;  					break;  			}
Missing Default,Custom.Decompiler.Ast,AstBuilder,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\AstBuilder.cs,ConvertAttributes,The following switch statement is missing a default case: switch (info.Attributes & PInvokeAttributes.CharSetMask) {  					case PInvokeAttributes.CharSetAnsi:  						charSet = CharSet.Ansi;  						break;  					case PInvokeAttributes.CharSetAuto:  						charSet = CharSet.Auto;  						break;  					case PInvokeAttributes.CharSetUnicode:  						charSet = CharSet.Unicode;  						break;  				}
Missing Default,Custom.Decompiler.Ast,AstBuilder,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\AstBuilder.cs,MakePrimitive,The following switch statement is missing a default case: switch (enumBaseTypeCode) {  							case TypeCode.Byte:  							case TypeCode.SByte:  								negatedEnumValue &= byte.MaxValue;  								break;  							case TypeCode.Int16:  							case TypeCode.UInt16:  								negatedEnumValue &= ushort.MaxValue;  								break;  							case TypeCode.Int32:  							case TypeCode.UInt32:  								negatedEnumValue &= uint.MaxValue;  								break;  						}
Missing Default,Custom.Decompiler.Ast,AstMethodBodyBuilder,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\AstMethodBodyBuilder.cs,MakeDefaultValue,The following switch statement is missing a default case: switch (typeDef.FullName) {  					case "System.Nullable`1":  						return new NullReferenceExpression();  					case "System.Single":  						return new PrimitiveExpression(0f);  					case "System.Double":  						return new PrimitiveExpression(0.0);  					case "System.Decimal":  						return new PrimitiveExpression(0m);  				}
Missing Default,Custom.Decompiler.Ast,NameVariables,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\NameVariables.cs,GenerateNameForVariable,The following switch statement is missing a default case: switch (expr.Code) {  							case ILCode.Clt:  							case ILCode.Clt_Un:  							case ILCode.Cgt:  							case ILCode.Cgt_Un:  							case ILCode.Cle:  							case ILCode.Cle_Un:  							case ILCode.Cge:  							case ILCode.Cge_Un:  								ILVariable loadVar;  								if (expr.Arguments[0].Match(ILCode.Ldloc' out loadVar) && loadVar == variable) {  									isLoopCounter = true;  								}  								break;  						}
Missing Default,Custom.Decompiler.Ast,NameVariables,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\NameVariables.cs,GetNameFromExpression,The following switch statement is missing a default case: switch (expr.Code) {  				case ILCode.Ldfld:  				case ILCode.Ldsfld:  					return CleanUpVariableName(((FieldReference)expr.Operand).Name);  				case ILCode.Call:  				case ILCode.Callvirt:  				case ILCode.CallGetter:  				case ILCode.CallvirtGetter:  					MethodReference mr = (MethodReference)expr.Operand;  					if (mr.Name.StartsWith("get_"' StringComparison.OrdinalIgnoreCase) && mr.Parameters.Count == 0) {  						// use name from properties' but not from indexers  						return CleanUpVariableName(mr.Name.Substring(4));  					} else if (mr.Name.StartsWith("Get"' StringComparison.OrdinalIgnoreCase) && mr.Name.Length >= 4 && char.IsUpper(mr.Name[3])) {  						// use name from Get-methods  						return CleanUpVariableName(mr.Name.Substring(3));  					}  					break;  			}
Missing Default,Custom.Decompiler.Ast,NameVariables,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\NameVariables.cs,GetNameForArgument,The following switch statement is missing a default case: switch (parent.Code) {  				case ILCode.Stfld:  				case ILCode.Stsfld:  					if (i == parent.Arguments.Count - 1) // last argument is stored value  						return CleanUpVariableName(((FieldReference)parent.Operand).Name);  					else  						break;  				case ILCode.Call:  				case ILCode.Callvirt:  				case ILCode.Newobj:  				case ILCode.CallGetter:  				case ILCode.CallvirtGetter:  				case ILCode.CallSetter:  				case ILCode.CallvirtSetter:  					MethodReference methodRef = (MethodReference)parent.Operand;  					if (methodRef.Parameters.Count == 1 && i == parent.Arguments.Count - 1) {  						// argument might be value of a setter  						if (methodRef.Name.StartsWith("set_"' StringComparison.OrdinalIgnoreCase)) {  							return CleanUpVariableName(methodRef.Name.Substring(4));  						} else if (methodRef.Name.StartsWith("Set"' StringComparison.OrdinalIgnoreCase) && methodRef.Name.Length >= 4 && char.IsUpper(methodRef.Name[3])) {  							return CleanUpVariableName(methodRef.Name.Substring(3));  						}  					}  					MethodDefinition methodDef = methodRef.Resolve();  					if (methodDef != null) {  						var p = methodDef.Parameters.ElementAtOrDefault((parent.Code != ILCode.Newobj && methodDef.HasThis) ? i - 1 : i);  						if (p != null && !string.IsNullOrEmpty(p.Name))  							return CleanUpVariableName(p.Name);  					}  					break;  				case ILCode.Ret:  					return "result";  			}
Missing Default,Custom.Decompiler,CecilExtensions,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\CecilExtensions.cs,GetPushDelta,The following switch statement is missing a default case: switch (code.StackBehaviourPush) {  				case StackBehaviour.Push0:  					return 0;    				case StackBehaviour.Push1:  				case StackBehaviour.Pushi:  				case StackBehaviour.Pushi8:  				case StackBehaviour.Pushr4:  				case StackBehaviour.Pushr8:  				case StackBehaviour.Pushref:  					return 1;    				case StackBehaviour.Push1_push1:  					return 2;    				case StackBehaviour.Varpush:  					if (code.FlowControl != FlowControl.Call)  						break;    					IMethodSignature method = (IMethodSignature) instruction.Operand;  					return IsVoid (method.ReturnType) ? 0 : 1;  			}
Missing Default,Custom.Decompiler,CecilExtensions,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\CecilExtensions.cs,GetPopDelta,The following switch statement is missing a default case: switch (code.StackBehaviourPop) {  				case StackBehaviour.Pop0:  					return 0;  				case StackBehaviour.Popi:  				case StackBehaviour.Popref:  				case StackBehaviour.Pop1:  					return 1;    				case StackBehaviour.Pop1_pop1:  				case StackBehaviour.Popi_pop1:  				case StackBehaviour.Popi_popi:  				case StackBehaviour.Popi_popi8:  				case StackBehaviour.Popi_popr4:  				case StackBehaviour.Popi_popr8:  				case StackBehaviour.Popref_pop1:  				case StackBehaviour.Popref_popi:  					return 2;    				case StackBehaviour.Popi_popi_popi:  				case StackBehaviour.Popref_popi_popi:  				case StackBehaviour.Popref_popi_popi8:  				case StackBehaviour.Popref_popi_popr4:  				case StackBehaviour.Popref_popi_popr8:  				case StackBehaviour.Popref_popi_popref:  					return 3;    				case StackBehaviour.PopAll:  					return null;    				case StackBehaviour.Varpop:  					if (code == OpCodes.Ret)  						return methodDef.ReturnType.IsVoid() ? 0 : 1;    					if (code.FlowControl != FlowControl.Call)  						break;    					IMethodSignature method = (IMethodSignature) instruction.Operand;  					int count = method.HasParameters ? method.Parameters.Count : 0;  					if (method.HasThis && code != OpCodes.Newobj)  						++count;  					if (code == OpCodes.Calli)  						++count; // calli takes a function pointer in additional to the normal args    					return count;  			}
Missing Default,Custom.Decompiler.Ast.Transforms,ExpressionTreeConverter,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\Transforms\ExpressionTreeConverter.cs,Convert,The following switch statement is missing a default case: switch (mr.Name) {  						case "Add":  							return ConvertBinaryOperator(invocation' BinaryOperatorType.Add' false);  						case "AddChecked":  							return ConvertBinaryOperator(invocation' BinaryOperatorType.Add' true);  						case "AddAssign":  							return ConvertAssignmentOperator(invocation' AssignmentOperatorType.Add' false);  						case "AddAssignChecked":  							return ConvertAssignmentOperator(invocation' AssignmentOperatorType.Add' true);  						case "And":  							return ConvertBinaryOperator(invocation' BinaryOperatorType.BitwiseAnd);  						case "AndAlso":  							return ConvertBinaryOperator(invocation' BinaryOperatorType.ConditionalAnd);  						case "AndAssign":  							return ConvertAssignmentOperator(invocation' AssignmentOperatorType.BitwiseAnd);  						case "ArrayAccess":  						case "ArrayIndex":  							return ConvertArrayIndex(invocation);  						case "ArrayLength":  							return ConvertArrayLength(invocation);  						case "Assign":  							return ConvertAssignmentOperator(invocation' AssignmentOperatorType.Assign);  						case "Call":  							return ConvertCall(invocation);  						case "Coalesce":  							return ConvertBinaryOperator(invocation' BinaryOperatorType.NullCoalescing);  						case "Condition":  							return ConvertCondition(invocation);  						case "Constant":  							if (invocation.Arguments.Count >= 1)  								return invocation.Arguments.First().Clone();  							else  								return NotSupported(expr);  						case "Convert":  							return ConvertCast(invocation' false);  						case "ConvertChecked":  							return ConvertCast(invocation' true);  						case "Divide":  							return ConvertBinaryOperator(invocation' BinaryOperatorType.Divide);  						case "DivideAssign":  							return ConvertAssignmentOperator(invocation' AssignmentOperatorType.Divide);  						case "Equal":  							return ConvertBinaryOperator(invocation' BinaryOperatorType.Equality);  						case "ExclusiveOr":  							return ConvertBinaryOperator(invocation' BinaryOperatorType.ExclusiveOr);  						case "ExclusiveOrAssign":  							return ConvertAssignmentOperator(invocation' AssignmentOperatorType.ExclusiveOr);  						case "Field":  							return ConvertField(invocation);  						case "GreaterThan":  							return ConvertBinaryOperator(invocation' BinaryOperatorType.GreaterThan);  						case "GreaterThanOrEqual":  							return ConvertBinaryOperator(invocation' BinaryOperatorType.GreaterThanOrEqual);  						case "Invoke":  							return ConvertInvoke(invocation);  						case "Lambda":  							return ConvertLambda(invocation);  						case "LeftShift":  							return ConvertBinaryOperator(invocation' BinaryOperatorType.ShiftLeft);  						case "LeftShiftAssign":  							return ConvertAssignmentOperator(invocation' AssignmentOperatorType.ShiftLeft);  						case "LessThan":  							return ConvertBinaryOperator(invocation' BinaryOperatorType.LessThan);  						case "LessThanOrEqual":  							return ConvertBinaryOperator(invocation' BinaryOperatorType.LessThanOrEqual);  						case "ListInit":  							return ConvertListInit(invocation);  						case "MemberInit":  							return ConvertMemberInit(invocation);  						case "Modulo":  							return ConvertBinaryOperator(invocation' BinaryOperatorType.Modulus);  						case "ModuloAssign":  							return ConvertAssignmentOperator(invocation' AssignmentOperatorType.Modulus);  						case "Multiply":  							return ConvertBinaryOperator(invocation' BinaryOperatorType.Multiply' false);  						case "MultiplyChecked":  							return ConvertBinaryOperator(invocation' BinaryOperatorType.Multiply' true);  						case "MultiplyAssign":  							return ConvertAssignmentOperator(invocation' AssignmentOperatorType.Multiply' false);  						case "MultiplyAssignChecked":  							return ConvertAssignmentOperator(invocation' AssignmentOperatorType.Multiply' true);  						case "Negate":  							return ConvertUnaryOperator(invocation' UnaryOperatorType.Minus' false);  						case "NegateChecked":  							return ConvertUnaryOperator(invocation' UnaryOperatorType.Minus' true);  						case "New":  							return ConvertNewObject(invocation);  						case "NewArrayBounds":  							return ConvertNewArrayBounds(invocation);  						case "NewArrayInit":  							return ConvertNewArrayInit(invocation);  						case "Not":  							return ConvertUnaryOperator(invocation' UnaryOperatorType.Not);  						case "NotEqual":  							return ConvertBinaryOperator(invocation' BinaryOperatorType.InEquality);  						case "OnesComplement":  							return ConvertUnaryOperator(invocation' UnaryOperatorType.BitNot);  						case "Or":  							return ConvertBinaryOperator(invocation' BinaryOperatorType.BitwiseOr);  						case "OrAssign":  							return ConvertAssignmentOperator(invocation' AssignmentOperatorType.BitwiseOr);  						case "OrElse":  							return ConvertBinaryOperator(invocation' BinaryOperatorType.ConditionalOr);  						case "Property":  							return ConvertProperty(invocation);  						case "Quote":  							if (invocation.Arguments.Count == 1)  								return Convert(invocation.Arguments.Single());  							else  								return NotSupported(invocation);  						case "RightShift":  							return ConvertBinaryOperator(invocation' BinaryOperatorType.ShiftRight);  						case "RightShiftAssign":  							return ConvertAssignmentOperator(invocation' AssignmentOperatorType.ShiftRight);  						case "Subtract":  							return ConvertBinaryOperator(invocation' BinaryOperatorType.Subtract' false);  						case "SubtractChecked":  							return ConvertBinaryOperator(invocation' BinaryOperatorType.Subtract' true);  						case "SubtractAssign":  							return ConvertAssignmentOperator(invocation' AssignmentOperatorType.Subtract' false);  						case "SubtractAssignChecked":  							return ConvertAssignmentOperator(invocation' AssignmentOperatorType.Subtract' true);  						case "TypeAs":  							return ConvertTypeAs(invocation);  						case "TypeIs":  							return ConvertTypeIs(invocation);  					}
Missing Default,Custom.Decompiler.Ast.Transforms,ExpressionTreeConverter,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\Transforms\ExpressionTreeConverter.cs,ConvertCast,The following switch statement is missing a default case: switch (invocation.Arguments.Count) {  					case 2:  						return cast;  					case 3:  						Match m = getMethodFromHandlePattern.Match(invocation.Arguments.ElementAt(2));  						if (m.Success)  							return cast.WithAnnotation(m.Get<AstNode>("method").Single().Annotation<MethodReference>());  						else  							return null;  				}
Missing Default,Custom.Decompiler.Ast.Transforms,ReplaceMethodCallsWithOperators,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Ast\Transforms\ReplaceMethodCallsWithOperators.cs,ProcessInvocationExpression,The following switch statement is missing a default case: switch (methodRef.FullName) {  				case "System.Type System.Type::GetTypeFromHandle(System.RuntimeTypeHandle)":  					if (arguments.Length == 1) {  						if (typeHandleOnTypeOfPattern.IsMatch(arguments[0])) {  							invocationExpression.ReplaceWith(((MemberReferenceExpression)arguments[0]).Target);  							return;  						}  					}  					break;  				case "System.Reflection.FieldInfo System.Reflection.FieldInfo::GetFieldFromHandle(System.RuntimeFieldHandle)":  					if (arguments.Length == 1) {  						MemberReferenceExpression mre = arguments[0] as MemberReferenceExpression;  						if (mre != null && mre.MemberName == "FieldHandle" && mre.Target.Annotation<LdTokenAnnotation>() != null) {  							invocationExpression.ReplaceWith(mre.Target);  							return;  						}  					}  					break;  				case "System.Reflection.FieldInfo System.Reflection.FieldInfo::GetFieldFromHandle(System.RuntimeFieldHandle'System.RuntimeTypeHandle)":  					if (arguments.Length == 2) {  						MemberReferenceExpression mre1 = arguments[0] as MemberReferenceExpression;  						MemberReferenceExpression mre2 = arguments[1] as MemberReferenceExpression;  						if (mre1 != null && mre1.MemberName == "FieldHandle" && mre1.Target.Annotation<LdTokenAnnotation>() != null) {  							if (mre2 != null && mre2.MemberName == "TypeHandle" && mre2.Target is TypeOfExpression) {  								Expression oldArg = ((InvocationExpression)mre1.Target).Arguments.Single();  								FieldReference field = oldArg.Annotation<FieldReference>();  								if (field != null) {  									AstType declaringType = ((TypeOfExpression)mre2.Target).Type.Detach();  									oldArg.ReplaceWith(declaringType.Member(field.Name).WithAnnotation(field));  									invocationExpression.ReplaceWith(mre1.Target);  									return;  								}  							}  						}  					}  					break;  			}
Missing Default,Custom.Decompiler.Disassembler,ILStructure,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\Disassembler\ILStructure.cs,FindAllBranches,The following switch statement is missing a default case: switch (inst.OpCode.OperandType) {  					case OperandType.InlineBrTarget:  					case OperandType.ShortInlineBrTarget:  						result.Add(new KeyValuePair<Instruction' Instruction>(inst' (Instruction)inst.Operand));  						break;  					case OperandType.InlineSwitch:  						foreach (Instruction target in (Instruction[])inst.Operand)  							result.Add(new KeyValuePair<Instruction' Instruction>(inst' target));  						break;  				}
Missing Default,Custom.Decompiler.FlowAnalysis,SimplifyByRefCalls,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\FlowAnalysis\SimplifyByRefCalls.cs,MakeByRefCallsSimple,The following switch statement is missing a default case: switch (inst.Instruction.OpCode.Code) {  							case Code.Call:  							case Code.Callvirt:  								instance.MakeByRefCallSimple(block' ref i' (IMethodSignature)inst.Instruction.Operand);  								break;  							case Code.Initobj:  								instance.MakeInitObjCallSimple(block' ref i);  								break;  							case Code.Ldfld:  								instance.MakeLoadFieldCallSimple(block' ref i);  								break;  						}
Missing Default,Custom.Decompiler.ILAst,ILAstBuilder,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\ILAstBuilder.cs,IsDeterministicLdloca,The following switch statement is missing a default case: switch (b.Code) {  					case ILCode.Ldloc:  					case ILCode.Ldloca:  					case ILCode.Stloc:  						if (b.Operand == v) return false;  						break;  				}
Missing Default,Custom.Decompiler.ILAst,ILAstBuilder,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\ILAstBuilder.cs,ConvertParameters,The following switch statement is missing a default case: switch (byteCode.Code) {  					case ILCode.__Ldarg:  						p = (ParameterDefinition)byteCode.Operand;  						byteCode.Code = ILCode.Ldloc;  						byteCode.Operand = p.Index < 0 ? thisParameter : this.Parameters[p.Index];  						break;  					case ILCode.__Starg:  						p = (ParameterDefinition)byteCode.Operand;  						byteCode.Code = ILCode.Stloc;  						byteCode.Operand = p.Index < 0 ? thisParameter : this.Parameters[p.Index];  						break;  					case ILCode.__Ldarga:  						p = (ParameterDefinition)byteCode.Operand;  						byteCode.Code = ILCode.Ldloca;  						byteCode.Operand = p.Index < 0 ? thisParameter : this.Parameters[p.Index];  						break;  				}
Missing Default,Custom.Decompiler.ILAst,ILAstOptimizer,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,IntroducePropertyAccessInstructions,The following switch statement is missing a default case: switch (cecilMethod.Name) {  						case "Get":  							expr.Code = ILCode.CallGetter;  							break;  						case "Set":  							expr.Code = ILCode.CallSetter;  							break;  						case "Address":  							ByReferenceType brt = cecilMethod.ReturnType as ByReferenceType;  							if (brt != null) {  								MethodReference getMethod = new MethodReference("Get"' brt.ElementType' cecilMethod.DeclaringType);  								foreach (var p in cecilMethod.Parameters)  									getMethod.Parameters.Add(p);  								getMethod.HasThis = cecilMethod.HasThis;  								expr.Operand = getMethod;  							}  							expr.Code = ILCode.CallGetter;  							if (parentExpr != null) {  								parentExpr.Arguments[posInParent] = new ILExpression(ILCode.AddressOf' null' expr);  							}  							break;  					}
Missing Default,Custom.Decompiler.ILAst,ILAstOptimizer,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,SimplifyLdObjAndStObj,The following switch statement is missing a default case: switch (arg.Code) {  						case ILCode.Ldelema: newCode = ILCode.Stelem_Any; break;  						case ILCode.Ldloca:  newCode = ILCode.Stloc; break;  						case ILCode.Ldflda:  newCode = ILCode.Stfld; break;  						case ILCode.Ldsflda: newCode = ILCode.Stsfld; break;  				}
Missing Default,Custom.Decompiler.ILAst,ILAstOptimizer,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,SimplifyLdObjAndStObj,The following switch statement is missing a default case: switch (arg.Code) {  						case ILCode.Ldelema: newCode = ILCode.Ldelem_Any; break;  						case ILCode.Ldloca:  newCode = ILCode.Ldloc; break;  						case ILCode.Ldflda:  newCode = ILCode.Ldfld; break;  						case ILCode.Ldsflda: newCode = ILCode.Ldsfld; break;  				}
Missing Default,Custom.Decompiler.ILAst,ILAstOptimizer,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\ILAstOptimizer.cs,IntroducePostIncrementForVariables,The following switch statement is missing a default case: switch (loadInstruction) {  				case ILCode.Ldloc:  					exprInit.Code = ILCode.Ldloca;  					break;  				case ILCode.Ldsfld:  					exprInit.Code = ILCode.Ldsflda;  					break;  				case ILCode.CallGetter:  					exprInit = new ILExpression(ILCode.AddressOf' null' exprInit);  					break;  			}
Missing Default,Custom.Decompiler.ILAst,ILCodeUtil,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\ILCodes.cs,ExpandMacro,The following switch statement is missing a default case: switch (code) {  					case ILCode.__Ldarg_0:   code = ILCode.__Ldarg; operand = methodBody.GetParameter(0); break;  					case ILCode.__Ldarg_1:   code = ILCode.__Ldarg; operand = methodBody.GetParameter(1); break;  					case ILCode.__Ldarg_2:   code = ILCode.__Ldarg; operand = methodBody.GetParameter(2); break;  					case ILCode.__Ldarg_3:   code = ILCode.__Ldarg; operand = methodBody.GetParameter(3); break;  					case ILCode.__Ldloc_0:   code = ILCode.Ldloc; operand = methodBody.Variables[0]; break;  					case ILCode.__Ldloc_1:   code = ILCode.Ldloc; operand = methodBody.Variables[1]; break;  					case ILCode.__Ldloc_2:   code = ILCode.Ldloc; operand = methodBody.Variables[2]; break;  					case ILCode.__Ldloc_3:   code = ILCode.Ldloc; operand = methodBody.Variables[3]; break;  					case ILCode.__Stloc_0:   code = ILCode.Stloc; operand = methodBody.Variables[0]; break;  					case ILCode.__Stloc_1:   code = ILCode.Stloc; operand = methodBody.Variables[1]; break;  					case ILCode.__Stloc_2:   code = ILCode.Stloc; operand = methodBody.Variables[2]; break;  					case ILCode.__Stloc_3:   code = ILCode.Stloc; operand = methodBody.Variables[3]; break;  					case ILCode.__Ldarg_S:   code = ILCode.__Ldarg; break;  					case ILCode.__Ldarga_S:  code = ILCode.__Ldarga; break;  					case ILCode.__Starg_S:   code = ILCode.__Starg; break;  					case ILCode.__Ldloc_S:   code = ILCode.Ldloc; break;  					case ILCode.__Ldloca_S:  code = ILCode.Ldloca; break;  					case ILCode.__Stloc_S:   code = ILCode.Stloc; break;  					case ILCode.__Ldc_I4_M1: code = ILCode.Ldc_I4; operand = -1; break;  					case ILCode.__Ldc_I4_0:  code = ILCode.Ldc_I4; operand = 0; break;  					case ILCode.__Ldc_I4_1:  code = ILCode.Ldc_I4; operand = 1; break;  					case ILCode.__Ldc_I4_2:  code = ILCode.Ldc_I4; operand = 2; break;  					case ILCode.__Ldc_I4_3:  code = ILCode.Ldc_I4; operand = 3; break;  					case ILCode.__Ldc_I4_4:  code = ILCode.Ldc_I4; operand = 4; break;  					case ILCode.__Ldc_I4_5:  code = ILCode.Ldc_I4; operand = 5; break;  					case ILCode.__Ldc_I4_6:  code = ILCode.Ldc_I4; operand = 6; break;  					case ILCode.__Ldc_I4_7:  code = ILCode.Ldc_I4; operand = 7; break;  					case ILCode.__Ldc_I4_8:  code = ILCode.Ldc_I4; operand = 8; break;  					case ILCode.__Ldc_I4_S:  code = ILCode.Ldc_I4; operand = (int) (sbyte) operand; break;  					case ILCode.__Br_S:      code = ILCode.Br; break;  					case ILCode.__Brfalse_S: code = ILCode.__Brfalse; break;  					case ILCode.__Brtrue_S:  code = ILCode.Brtrue; break;  					case ILCode.__Beq_S:     code = ILCode.__Beq; break;  					case ILCode.__Bge_S:     code = ILCode.__Bge; break;  					case ILCode.__Bgt_S:     code = ILCode.__Bgt; break;  					case ILCode.__Ble_S:     code = ILCode.__Ble; break;  					case ILCode.__Blt_S:     code = ILCode.__Blt; break;  					case ILCode.__Bne_Un_S:  code = ILCode.__Bne_Un; break;  					case ILCode.__Bge_Un_S:  code = ILCode.__Bge_Un; break;  					case ILCode.__Bgt_Un_S:  code = ILCode.__Bgt_Un; break;  					case ILCode.__Ble_Un_S:  code = ILCode.__Ble_Un; break;  					case ILCode.__Blt_Un_S:  code = ILCode.__Blt_Un; break;  					case ILCode.__Leave_S:   code = ILCode.Leave; break;  					case ILCode.__Ldind_I:   code = ILCode.Ldobj; operand = methodBody.Method.Module.TypeSystem.IntPtr; break;  					case ILCode.__Ldind_I1:  code = ILCode.Ldobj; operand = methodBody.Method.Module.TypeSystem.SByte; break;  					case ILCode.__Ldind_I2:  code = ILCode.Ldobj; operand = methodBody.Method.Module.TypeSystem.Int16; break;  					case ILCode.__Ldind_I4:  code = ILCode.Ldobj; operand = methodBody.Method.Module.TypeSystem.Int32; break;  					case ILCode.__Ldind_I8:  code = ILCode.Ldobj; operand = methodBody.Method.Module.TypeSystem.Int64; break;  					case ILCode.__Ldind_U1:  code = ILCode.Ldobj; operand = methodBody.Method.Module.TypeSystem.Byte; break;  					case ILCode.__Ldind_U2:  code = ILCode.Ldobj; operand = methodBody.Method.Module.TypeSystem.UInt16; break;  					case ILCode.__Ldind_U4:  code = ILCode.Ldobj; operand = methodBody.Method.Module.TypeSystem.UInt32; break;  					case ILCode.__Ldind_R4:  code = ILCode.Ldobj; operand = methodBody.Method.Module.TypeSystem.Single; break;  					case ILCode.__Ldind_R8:  code = ILCode.Ldobj; operand = methodBody.Method.Module.TypeSystem.Double; break;  					case ILCode.__Stind_I:   code = ILCode.Stobj; operand = methodBody.Method.Module.TypeSystem.IntPtr; break;  					case ILCode.__Stind_I1:  code = ILCode.Stobj; operand = methodBody.Method.Module.TypeSystem.Byte; break;  					case ILCode.__Stind_I2:  code = ILCode.Stobj; operand = methodBody.Method.Module.TypeSystem.Int16; break;  					case ILCode.__Stind_I4:  code = ILCode.Stobj; operand = methodBody.Method.Module.TypeSystem.Int32; break;  					case ILCode.__Stind_I8:  code = ILCode.Stobj; operand = methodBody.Method.Module.TypeSystem.Int64; break;  					case ILCode.__Stind_R4:  code = ILCode.Stobj; operand = methodBody.Method.Module.TypeSystem.Single; break;  					case ILCode.__Stind_R8:  code = ILCode.Stobj; operand = methodBody.Method.Module.TypeSystem.Double; break;  			}
Missing Default,Custom.Decompiler.ILAst,ILInlining,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\ILInlining.cs,IsGeneratedValueTypeTemporary,The following switch statement is missing a default case: switch (inlinedExpression.Code) {  					case ILCode.Ldloc:  					case ILCode.Stloc:  					case ILCode.CompoundAssignment:  					case ILCode.Ldelem_Any:  					case ILCode.Ldelem_I:  					case ILCode.Ldelem_I1:  					case ILCode.Ldelem_I2:  					case ILCode.Ldelem_I4:  					case ILCode.Ldelem_I8:  					case ILCode.Ldelem_R4:  					case ILCode.Ldelem_R8:  					case ILCode.Ldelem_Ref:  					case ILCode.Ldelem_U1:  					case ILCode.Ldelem_U2:  					case ILCode.Ldelem_U4:  					case ILCode.Ldobj:  					case ILCode.Ldind_Ref:  						return false;  					case ILCode.Ldfld:  					case ILCode.Stfld:  					case ILCode.Ldsfld:  					case ILCode.Stsfld:  						// allow inlining field access only if it's a readonly field  						FieldDefinition f = ((FieldReference)inlinedExpression.Operand).Resolve();  						if (!(f != null && f.IsInitOnly))  							return false;  						break;  					case ILCode.Call:  					case ILCode.CallGetter:  						// inlining runs both before and after IntroducePropertyAccessInstructions'  						// so we have to handle both 'call' and 'callgetter'  						MethodReference mr = (MethodReference)inlinedExpression.Operand;  						// ensure that it's not an multi-dimensional array getter  						if (mr.DeclaringType is ArrayType)  							return false;  						goto case ILCode.Callvirt;  					case ILCode.Callvirt:  					case ILCode.CallvirtGetter:  						// don't inline foreach loop variables:  						mr = (MethodReference)inlinedExpression.Operand;  						if (mr.Name == "get_Current" && mr.HasThis)  							return false;  						break;  					case ILCode.Castclass:  					case ILCode.Unbox_Any:  						// These are valid' but might occur as part of a foreach loop variable.  						ILExpression arg = inlinedExpression.Arguments[0];  						if (arg.Code == ILCode.CallGetter || arg.Code == ILCode.CallvirtGetter || arg.Code == ILCode.Call || arg.Code == ILCode.Callvirt) {  							mr = (MethodReference)arg.Operand;  							if (mr.Name == "get_Current" && mr.HasThis)  								return false; // looks like a foreach loop variable' so don't inline it  						}  						break;  				}
Missing Default,Custom.Decompiler.ILAst,ILInlining,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\ILInlining.cs,IsGeneratedValueTypeTemporary,The following switch statement is missing a default case: switch (parent.Code) {  					case ILCode.Call:  					case ILCode.CallGetter:  					case ILCode.CallSetter:  					case ILCode.Callvirt:  					case ILCode.CallvirtGetter:  					case ILCode.CallvirtSetter:  						MethodReference mr = (MethodReference)parent.Operand;  						return mr.HasThis;  					case ILCode.Stfld:  					case ILCode.Ldfld:  					case ILCode.Ldflda:  					case ILCode.Await:  						return true;  				}
Missing Default,Custom.Decompiler.ILAst,ILPattern,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\LiftedOperators.cs,BuildNew,The following switch statement is missing a default case: switch (code) {  						case ILCode.Ceq:  						case ILCode.Cne:  							t = pm.typeSystem.Boolean;  							break;  						case ILCode.NullCoalescing:  							t = args[1].InferredType;  							break;  					}
Missing Default,Custom.Decompiler.ILAst,TypeAnalysis,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\TypeAnalysis.cs,DoInferTypeForExpression,The following switch statement is missing a default case: switch (type.MetadataType) {  							case MetadataType.Int32:  								if (expr.Code == ILCode.Shr_Un)  									expectedInputType = typeSystem.UInt32;  								break;  							case MetadataType.UInt32:  								if (expr.Code == ILCode.Shr)  									expectedInputType = typeSystem.Int32;  								break;  							case MetadataType.Int64:  								if (expr.Code == ILCode.Shr_Un)  									expectedInputType = typeSystem.UInt64;  								break;  							case MetadataType.UInt64:  								if (expr.Code == ILCode.Shr)  									expectedInputType = typeSystem.UInt64;  								break;  						}
Missing Default,Custom.Decompiler.ILAst,YieldReturnDecompiler,D:\research\architectureSmells\repos\Fody_Usable\Fody\Decompiler\ILAst\YieldReturnDecompiler.cs,TranslateFieldsToLocalAccess,The following switch statement is missing a default case: switch (expr.Code) {  							case ILCode.Ldfld:  								if (expr.Arguments[0].MatchThis()) {  									expr.Code = ILCode.Ldloc;  									if (fieldToParameterMap.ContainsKey(field)) {  										expr.Operand = fieldToParameterMap[field];  									} else {  										expr.Operand = fieldToLocalMap[field];  									}  									expr.Arguments.Clear();  								}  								break;  							case ILCode.Stfld:  								if (expr.Arguments[0].MatchThis()) {  									expr.Code = ILCode.Stloc;  									if (fieldToParameterMap.ContainsKey(field)) {  										expr.Operand = fieldToParameterMap[field];  									} else {  										expr.Operand = fieldToLocalMap[field];  									}  									expr.Arguments.RemoveAt(0);  								}  								break;  							case ILCode.Ldflda:  								if (expr.Arguments[0].MatchThis()) {  									expr.Code = ILCode.Ldloca;  									if (fieldToParameterMap.ContainsKey(field)) {  										expr.Operand = fieldToParameterMap[field];  									} else {  										expr.Operand = fieldToLocalMap[field];  									}  									expr.Arguments.Clear();  								}  								break;  						}
