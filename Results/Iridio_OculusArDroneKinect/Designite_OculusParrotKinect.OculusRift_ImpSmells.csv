Implementation smell,Namespace,Class,File,Method,Description
Complex Method,OculusParrotKinect.Oculus,EmbeddedDllClass,C:\repos\Iridio_OculusArDroneKinect\OculusParrotKinect.OculusRift\EmbeddedDllClass.cs,ExtractEmbeddedDlls,Cyclomatic complexity of the method is 8
Long Parameter List,OculusParrotKinect.Oculus,OculusRiftDevice,C:\repos\Iridio_OculusArDroneKinect\OculusParrotKinect.OculusRift\OculusRiftDevice.cs,OVR_GetSensorOrientation,The method has 5 parameters. Parameters: sensorID' w' x' y' z
Long Parameter List,OculusParrotKinect.Oculus,OculusRiftDevice,C:\repos\Iridio_OculusArDroneKinect\OculusParrotKinect.OculusRift\OculusRiftDevice.cs,OVR_GetSensorPredictedOrientation,The method has 5 parameters. Parameters: sensorID' w' x' y' z
Magic Number,OculusParrotKinect.Oculus,Helpers,C:\repos\Iridio_OculusArDroneKinect\OculusParrotKinect.OculusRift\OculusClient.cs,ToEulerAngles,The following statement contains a magic number: if (test > 0.499 * unit)        { // singularity at north pole          euler.X = (float)(2 * Math.Atan2(q.X' q.W));          euler.Y = (float)Math.PI / 2;          euler.Z = 0;        }        else if (test < -0.499 * unit)        { // singularity at south pole          euler.X = (float)(-2 * Math.Atan2(q.X' q.W));          euler.Y = (float)-Math.PI / 2;          euler.Z = 0;        }        else        {          euler.X = (float)Math.Atan2(2 * q.Y * q.W - 2 * q.X * q.Z' sqx - sqy - sqz + sqw);          euler.Y = -(float)Math.Asin(2 * test / unit);          euler.Z = -(float)Math.Atan2(2 * q.X * q.W - 2 * q.Y * q.Z' -sqx + sqy - sqz + sqw);        }
Magic Number,OculusParrotKinect.Oculus,Helpers,C:\repos\Iridio_OculusArDroneKinect\OculusParrotKinect.OculusRift\OculusClient.cs,ToEulerAngles,The following statement contains a magic number: if (test > 0.499 * unit)        { // singularity at north pole          euler.X = (float)(2 * Math.Atan2(q.X' q.W));          euler.Y = (float)Math.PI / 2;          euler.Z = 0;        }        else if (test < -0.499 * unit)        { // singularity at south pole          euler.X = (float)(-2 * Math.Atan2(q.X' q.W));          euler.Y = (float)-Math.PI / 2;          euler.Z = 0;        }        else        {          euler.X = (float)Math.Atan2(2 * q.Y * q.W - 2 * q.X * q.Z' sqx - sqy - sqz + sqw);          euler.Y = -(float)Math.Asin(2 * test / unit);          euler.Z = -(float)Math.Atan2(2 * q.X * q.W - 2 * q.Y * q.Z' -sqx + sqy - sqz + sqw);        }
Magic Number,OculusParrotKinect.Oculus,Helpers,C:\repos\Iridio_OculusArDroneKinect\OculusParrotKinect.OculusRift\OculusClient.cs,ToEulerAngles,The following statement contains a magic number: if (test > 0.499 * unit)        { // singularity at north pole          euler.X = (float)(2 * Math.Atan2(q.X' q.W));          euler.Y = (float)Math.PI / 2;          euler.Z = 0;        }        else if (test < -0.499 * unit)        { // singularity at south pole          euler.X = (float)(-2 * Math.Atan2(q.X' q.W));          euler.Y = (float)-Math.PI / 2;          euler.Z = 0;        }        else        {          euler.X = (float)Math.Atan2(2 * q.Y * q.W - 2 * q.X * q.Z' sqx - sqy - sqz + sqw);          euler.Y = -(float)Math.Asin(2 * test / unit);          euler.Z = -(float)Math.Atan2(2 * q.X * q.W - 2 * q.Y * q.Z' -sqx + sqy - sqz + sqw);        }
Magic Number,OculusParrotKinect.Oculus,Helpers,C:\repos\Iridio_OculusArDroneKinect\OculusParrotKinect.OculusRift\OculusClient.cs,ToEulerAngles,The following statement contains a magic number: if (test > 0.499 * unit)        { // singularity at north pole          euler.X = (float)(2 * Math.Atan2(q.X' q.W));          euler.Y = (float)Math.PI / 2;          euler.Z = 0;        }        else if (test < -0.499 * unit)        { // singularity at south pole          euler.X = (float)(-2 * Math.Atan2(q.X' q.W));          euler.Y = (float)-Math.PI / 2;          euler.Z = 0;        }        else        {          euler.X = (float)Math.Atan2(2 * q.Y * q.W - 2 * q.X * q.Z' sqx - sqy - sqz + sqw);          euler.Y = -(float)Math.Asin(2 * test / unit);          euler.Z = -(float)Math.Atan2(2 * q.X * q.W - 2 * q.Y * q.Z' -sqx + sqy - sqz + sqw);        }
Magic Number,OculusParrotKinect.Oculus,Helpers,C:\repos\Iridio_OculusArDroneKinect\OculusParrotKinect.OculusRift\OculusClient.cs,ToEulerAngles,The following statement contains a magic number: if (test > 0.499 * unit)        { // singularity at north pole          euler.X = (float)(2 * Math.Atan2(q.X' q.W));          euler.Y = (float)Math.PI / 2;          euler.Z = 0;        }        else if (test < -0.499 * unit)        { // singularity at south pole          euler.X = (float)(-2 * Math.Atan2(q.X' q.W));          euler.Y = (float)-Math.PI / 2;          euler.Z = 0;        }        else        {          euler.X = (float)Math.Atan2(2 * q.Y * q.W - 2 * q.X * q.Z' sqx - sqy - sqz + sqw);          euler.Y = -(float)Math.Asin(2 * test / unit);          euler.Z = -(float)Math.Atan2(2 * q.X * q.W - 2 * q.Y * q.Z' -sqx + sqy - sqz + sqw);        }
Magic Number,OculusParrotKinect.Oculus,Helpers,C:\repos\Iridio_OculusArDroneKinect\OculusParrotKinect.OculusRift\OculusClient.cs,ToEulerAngles,The following statement contains a magic number: if (test > 0.499 * unit)        { // singularity at north pole          euler.X = (float)(2 * Math.Atan2(q.X' q.W));          euler.Y = (float)Math.PI / 2;          euler.Z = 0;        }        else if (test < -0.499 * unit)        { // singularity at south pole          euler.X = (float)(-2 * Math.Atan2(q.X' q.W));          euler.Y = (float)-Math.PI / 2;          euler.Z = 0;        }        else        {          euler.X = (float)Math.Atan2(2 * q.Y * q.W - 2 * q.X * q.Z' sqx - sqy - sqz + sqw);          euler.Y = -(float)Math.Asin(2 * test / unit);          euler.Z = -(float)Math.Atan2(2 * q.X * q.W - 2 * q.Y * q.Z' -sqx + sqy - sqz + sqw);        }
Magic Number,OculusParrotKinect.Oculus,Helpers,C:\repos\Iridio_OculusArDroneKinect\OculusParrotKinect.OculusRift\OculusClient.cs,ToEulerAngles,The following statement contains a magic number: if (test > 0.499 * unit)        { // singularity at north pole          euler.X = (float)(2 * Math.Atan2(q.X' q.W));          euler.Y = (float)Math.PI / 2;          euler.Z = 0;        }        else if (test < -0.499 * unit)        { // singularity at south pole          euler.X = (float)(-2 * Math.Atan2(q.X' q.W));          euler.Y = (float)-Math.PI / 2;          euler.Z = 0;        }        else        {          euler.X = (float)Math.Atan2(2 * q.Y * q.W - 2 * q.X * q.Z' sqx - sqy - sqz + sqw);          euler.Y = -(float)Math.Asin(2 * test / unit);          euler.Z = -(float)Math.Atan2(2 * q.X * q.W - 2 * q.Y * q.Z' -sqx + sqy - sqz + sqw);        }
Magic Number,OculusParrotKinect.Oculus,Helpers,C:\repos\Iridio_OculusArDroneKinect\OculusParrotKinect.OculusRift\OculusClient.cs,ToEulerAngles,The following statement contains a magic number: if (test > 0.499 * unit)        { // singularity at north pole          euler.X = (float)(2 * Math.Atan2(q.X' q.W));          euler.Y = (float)Math.PI / 2;          euler.Z = 0;        }        else if (test < -0.499 * unit)        { // singularity at south pole          euler.X = (float)(-2 * Math.Atan2(q.X' q.W));          euler.Y = (float)-Math.PI / 2;          euler.Z = 0;        }        else        {          euler.X = (float)Math.Atan2(2 * q.Y * q.W - 2 * q.X * q.Z' sqx - sqy - sqz + sqw);          euler.Y = -(float)Math.Asin(2 * test / unit);          euler.Z = -(float)Math.Atan2(2 * q.X * q.W - 2 * q.Y * q.Z' -sqx + sqy - sqz + sqw);        }
Magic Number,OculusParrotKinect.Oculus,Helpers,C:\repos\Iridio_OculusArDroneKinect\OculusParrotKinect.OculusRift\OculusClient.cs,ToEulerAngles,The following statement contains a magic number: if (test > 0.499 * unit)        { // singularity at north pole          euler.X = (float)(2 * Math.Atan2(q.X' q.W));          euler.Y = (float)Math.PI / 2;          euler.Z = 0;        }        else if (test < -0.499 * unit)        { // singularity at south pole          euler.X = (float)(-2 * Math.Atan2(q.X' q.W));          euler.Y = (float)-Math.PI / 2;          euler.Z = 0;        }        else        {          euler.X = (float)Math.Atan2(2 * q.Y * q.W - 2 * q.X * q.Z' sqx - sqy - sqz + sqw);          euler.Y = -(float)Math.Asin(2 * test / unit);          euler.Z = -(float)Math.Atan2(2 * q.X * q.W - 2 * q.Y * q.Z' -sqx + sqy - sqz + sqw);        }
Magic Number,OculusParrotKinect.Oculus,Helpers,C:\repos\Iridio_OculusArDroneKinect\OculusParrotKinect.OculusRift\OculusClient.cs,ToEulerAngles,The following statement contains a magic number: if (test > 0.499 * unit)        { // singularity at north pole          euler.X = (float)(2 * Math.Atan2(q.X' q.W));          euler.Y = (float)Math.PI / 2;          euler.Z = 0;        }        else if (test < -0.499 * unit)        { // singularity at south pole          euler.X = (float)(-2 * Math.Atan2(q.X' q.W));          euler.Y = (float)-Math.PI / 2;          euler.Z = 0;        }        else        {          euler.X = (float)Math.Atan2(2 * q.Y * q.W - 2 * q.X * q.Z' sqx - sqy - sqz + sqw);          euler.Y = -(float)Math.Asin(2 * test / unit);          euler.Z = -(float)Math.Atan2(2 * q.X * q.W - 2 * q.Y * q.Z' -sqx + sqy - sqz + sqw);        }
Magic Number,OculusParrotKinect.Oculus,Helpers,C:\repos\Iridio_OculusArDroneKinect\OculusParrotKinect.OculusRift\OculusClient.cs,ToEulerAngles,The following statement contains a magic number: if (test > 0.499 * unit)        { // singularity at north pole          euler.X = (float)(2 * Math.Atan2(q.X' q.W));          euler.Y = (float)Math.PI / 2;          euler.Z = 0;        }        else if (test < -0.499 * unit)        { // singularity at south pole          euler.X = (float)(-2 * Math.Atan2(q.X' q.W));          euler.Y = (float)-Math.PI / 2;          euler.Z = 0;        }        else        {          euler.X = (float)Math.Atan2(2 * q.Y * q.W - 2 * q.X * q.Z' sqx - sqy - sqz + sqw);          euler.Y = -(float)Math.Asin(2 * test / unit);          euler.Z = -(float)Math.Atan2(2 * q.X * q.W - 2 * q.Y * q.Z' -sqx + sqy - sqz + sqw);        }
