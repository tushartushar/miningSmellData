Implementation smell,Namespace,Class,File,Method,Description
Complex Method,SimpleHelpers,FlexibleOptions,C:\repos\khalidsalomao_SimpleHelpers.Net\SimpleHelpers.Arguments\FlexibleOptions.cs,Get,Cyclomatic complexity of the method is 8
Long Statement,SimpleHelpers,Arguments,C:\repos\khalidsalomao_SimpleHelpers.Net\SimpleHelpers.Arguments\Arguments.cs,ParseCommandLineArguments,The length of the statement  "                    bool hasStartingMarker = arg.StartsWith ("-"' StringComparison.Ordinal) || arg.StartsWith ("/"' StringComparison.Ordinal); " is 122.
Long Statement,SimpleHelpers,Arguments,C:\repos\khalidsalomao_SimpleHelpers.Net\SimpleHelpers.Arguments\Arguments.cs,LoadWebConfigurationFile,The length of the statement  "            // NOTE: in MONO (linux) this can happen with ssl certificates and dozens of instances of the app starting at the same time... " is 126.
Long Statement,SimpleHelpers,FlexibleOptions,C:\repos\khalidsalomao_SimpleHelpers.Net\SimpleHelpers.Arguments\FlexibleOptions.cs,ChangeStringComparer,The length of the statement  "                Options = new Dictionary<string' string> (Options' _caseInsensitive ? StringComparer.OrdinalIgnoreCase : StringComparer.Ordinal); " is 129.
Long Statement,SimpleHelpers,FlexibleOptions,C:\repos\khalidsalomao_SimpleHelpers.Net\SimpleHelpers.Arguments\FlexibleOptions.cs,Get,The length of the statement  "                    if (DateTime.TryParse (vDt' System.Globalization.CultureInfo.InvariantCulture' System.Globalization.DateTimeStyles.None' out dt)) " is 129.
Long Statement,SimpleHelpers,FlexibleOptions,C:\repos\khalidsalomao_SimpleHelpers.Net\SimpleHelpers.Arguments\FlexibleOptions.cs,Get,The length of the statement  "                    if (vDt.Length == 8 && DateTime.TryParseExact (vDt' "yyyyMMdd"' System.Globalization.CultureInfo.InvariantCulture' System.Globalization.DateTimeStyles.None' out dt)) " is 165.
Empty Catch Block,SimpleHelpers,FlexibleOptions,C:\repos\khalidsalomao_SimpleHelpers.Net\SimpleHelpers.Arguments\FlexibleOptions.cs,Get,The method has an empty catch block.
Magic Number,SimpleHelpers,Arguments,C:\repos\khalidsalomao_SimpleHelpers.Net\SimpleHelpers.Arguments\Arguments.cs,LoadWebConfigurationFile,The following statement contains a magic number: for (var i = 0; i < count; i++)              {                  try                  {                      using (WebClient client = new WebClient ())                      {                          return client.DownloadString (filePath);                      }                  }                  catch (Exception ex)                  {                      if (i >= 2)                      {                          if (ThrownOnError)                              throw;                          RaiseErrorEvent (ex);                      }                      else                      {                          System.Threading.Tasks.Task.Delay (100).Wait ();                      }                  }              }
Magic Number,SimpleHelpers,Arguments,C:\repos\khalidsalomao_SimpleHelpers.Net\SimpleHelpers.Arguments\Arguments.cs,LoadWebConfigurationFile,The following statement contains a magic number: for (var i = 0; i < count; i++)              {                  try                  {                      using (WebClient client = new WebClient ())                      {                          return client.DownloadString (filePath);                      }                  }                  catch (Exception ex)                  {                      if (i >= 2)                      {                          if (ThrownOnError)                              throw;                          RaiseErrorEvent (ex);                      }                      else                      {                          System.Threading.Tasks.Task.Delay (100).Wait ();                      }                  }              }
Magic Number,SimpleHelpers,FlexibleOptions,C:\repos\khalidsalomao_SimpleHelpers.Net\SimpleHelpers.Arguments\FlexibleOptions.cs,Get,The following statement contains a magic number: try              {                  if (v == null || v.Length == 0)                      return defaultValue;                    bool missingQuotes = v.Length < 2 || (!(v[0] == '\"' && v[v.Length - 1] == '\"'));                  var desiredType = typeof (T);                    if (desiredType == typeof (string))                  {                      if (missingQuotes || preserveQuotes)                          return (T)(object)v;                      // let's deserialize to also unscape the string                      return Newtonsoft.Json.JsonConvert.DeserializeObject<T> (v);                  }                  // more comprehensive datetime parser' except formats like "\"\\/Date(1335205592410-0500)\\/\""                  // DateTime is tested prior to IConvertible' since it also implements IConvertible                  else if (desiredType == typeof (DateTime) || desiredType == typeof (DateTime?))                  {                      DateTime dt;                      var vDt = missingQuotes ? v : v.Substring (1' v.Length - 2);                      if (DateTime.TryParse (vDt' System.Globalization.CultureInfo.InvariantCulture' System.Globalization.DateTimeStyles.None' out dt))                          return (T)(object)dt;                      if (vDt.Length == 8 && DateTime.TryParseExact (vDt' "yyyyMMdd"' System.Globalization.CultureInfo.InvariantCulture' System.Globalization.DateTimeStyles.None' out dt))                          return (T)(object)dt;                      // if previous convertion attempts didn't work' fallback to json deserialization                  }                  // let's deal with enums                  else if (desiredType.IsEnum)                  {                      return (T)Enum.Parse (desiredType' v' true);                  }                  // all primitive types are IConvertible'                   // and if the type implements this interface lets use it!                  else if (typeof (IConvertible).IsAssignableFrom (desiredType))                  {                      if (!missingQuotes)                          v = v.Substring (1' v.Length - 2);                      // type convertion with InvariantCulture (faster)                      return (T)Convert.ChangeType (v' desiredType' System.Globalization.CultureInfo.InvariantCulture);                  }                  // Guid doesn't implement IConvertible                  else if (desiredType == typeof (Guid) || desiredType == typeof (Guid?))                  {                      Guid guid;                      if (Guid.TryParse (v' out guid))                          return (T)(object)guid;                  }                  // TimeSpan doesn't implement IConvertible                  else if (desiredType == typeof (TimeSpan) || desiredType == typeof (TimeSpan?))                  {                      TimeSpan timespan;                      if (TimeSpan.TryParse (v' out timespan))                          return (T)(object)timespan;                  }                    // finally' deserialize it!                                     return Newtonsoft.Json.JsonConvert.DeserializeObject<T> (v);              }              catch { /* ignore and return default value */ }
Magic Number,SimpleHelpers,FlexibleOptions,C:\repos\khalidsalomao_SimpleHelpers.Net\SimpleHelpers.Arguments\FlexibleOptions.cs,Get,The following statement contains a magic number: try              {                  if (v == null || v.Length == 0)                      return defaultValue;                    bool missingQuotes = v.Length < 2 || (!(v[0] == '\"' && v[v.Length - 1] == '\"'));                  var desiredType = typeof (T);                    if (desiredType == typeof (string))                  {                      if (missingQuotes || preserveQuotes)                          return (T)(object)v;                      // let's deserialize to also unscape the string                      return Newtonsoft.Json.JsonConvert.DeserializeObject<T> (v);                  }                  // more comprehensive datetime parser' except formats like "\"\\/Date(1335205592410-0500)\\/\""                  // DateTime is tested prior to IConvertible' since it also implements IConvertible                  else if (desiredType == typeof (DateTime) || desiredType == typeof (DateTime?))                  {                      DateTime dt;                      var vDt = missingQuotes ? v : v.Substring (1' v.Length - 2);                      if (DateTime.TryParse (vDt' System.Globalization.CultureInfo.InvariantCulture' System.Globalization.DateTimeStyles.None' out dt))                          return (T)(object)dt;                      if (vDt.Length == 8 && DateTime.TryParseExact (vDt' "yyyyMMdd"' System.Globalization.CultureInfo.InvariantCulture' System.Globalization.DateTimeStyles.None' out dt))                          return (T)(object)dt;                      // if previous convertion attempts didn't work' fallback to json deserialization                  }                  // let's deal with enums                  else if (desiredType.IsEnum)                  {                      return (T)Enum.Parse (desiredType' v' true);                  }                  // all primitive types are IConvertible'                   // and if the type implements this interface lets use it!                  else if (typeof (IConvertible).IsAssignableFrom (desiredType))                  {                      if (!missingQuotes)                          v = v.Substring (1' v.Length - 2);                      // type convertion with InvariantCulture (faster)                      return (T)Convert.ChangeType (v' desiredType' System.Globalization.CultureInfo.InvariantCulture);                  }                  // Guid doesn't implement IConvertible                  else if (desiredType == typeof (Guid) || desiredType == typeof (Guid?))                  {                      Guid guid;                      if (Guid.TryParse (v' out guid))                          return (T)(object)guid;                  }                  // TimeSpan doesn't implement IConvertible                  else if (desiredType == typeof (TimeSpan) || desiredType == typeof (TimeSpan?))                  {                      TimeSpan timespan;                      if (TimeSpan.TryParse (v' out timespan))                          return (T)(object)timespan;                  }                    // finally' deserialize it!                                     return Newtonsoft.Json.JsonConvert.DeserializeObject<T> (v);              }              catch { /* ignore and return default value */ }
Magic Number,SimpleHelpers,FlexibleOptions,C:\repos\khalidsalomao_SimpleHelpers.Net\SimpleHelpers.Arguments\FlexibleOptions.cs,Get,The following statement contains a magic number: try              {                  if (v == null || v.Length == 0)                      return defaultValue;                    bool missingQuotes = v.Length < 2 || (!(v[0] == '\"' && v[v.Length - 1] == '\"'));                  var desiredType = typeof (T);                    if (desiredType == typeof (string))                  {                      if (missingQuotes || preserveQuotes)                          return (T)(object)v;                      // let's deserialize to also unscape the string                      return Newtonsoft.Json.JsonConvert.DeserializeObject<T> (v);                  }                  // more comprehensive datetime parser' except formats like "\"\\/Date(1335205592410-0500)\\/\""                  // DateTime is tested prior to IConvertible' since it also implements IConvertible                  else if (desiredType == typeof (DateTime) || desiredType == typeof (DateTime?))                  {                      DateTime dt;                      var vDt = missingQuotes ? v : v.Substring (1' v.Length - 2);                      if (DateTime.TryParse (vDt' System.Globalization.CultureInfo.InvariantCulture' System.Globalization.DateTimeStyles.None' out dt))                          return (T)(object)dt;                      if (vDt.Length == 8 && DateTime.TryParseExact (vDt' "yyyyMMdd"' System.Globalization.CultureInfo.InvariantCulture' System.Globalization.DateTimeStyles.None' out dt))                          return (T)(object)dt;                      // if previous convertion attempts didn't work' fallback to json deserialization                  }                  // let's deal with enums                  else if (desiredType.IsEnum)                  {                      return (T)Enum.Parse (desiredType' v' true);                  }                  // all primitive types are IConvertible'                   // and if the type implements this interface lets use it!                  else if (typeof (IConvertible).IsAssignableFrom (desiredType))                  {                      if (!missingQuotes)                          v = v.Substring (1' v.Length - 2);                      // type convertion with InvariantCulture (faster)                      return (T)Convert.ChangeType (v' desiredType' System.Globalization.CultureInfo.InvariantCulture);                  }                  // Guid doesn't implement IConvertible                  else if (desiredType == typeof (Guid) || desiredType == typeof (Guid?))                  {                      Guid guid;                      if (Guid.TryParse (v' out guid))                          return (T)(object)guid;                  }                  // TimeSpan doesn't implement IConvertible                  else if (desiredType == typeof (TimeSpan) || desiredType == typeof (TimeSpan?))                  {                      TimeSpan timespan;                      if (TimeSpan.TryParse (v' out timespan))                          return (T)(object)timespan;                  }                    // finally' deserialize it!                                     return Newtonsoft.Json.JsonConvert.DeserializeObject<T> (v);              }              catch { /* ignore and return default value */ }
Magic Number,SimpleHelpers,FlexibleOptions,C:\repos\khalidsalomao_SimpleHelpers.Net\SimpleHelpers.Arguments\FlexibleOptions.cs,Get,The following statement contains a magic number: try              {                  if (v == null || v.Length == 0)                      return defaultValue;                    bool missingQuotes = v.Length < 2 || (!(v[0] == '\"' && v[v.Length - 1] == '\"'));                  var desiredType = typeof (T);                    if (desiredType == typeof (string))                  {                      if (missingQuotes || preserveQuotes)                          return (T)(object)v;                      // let's deserialize to also unscape the string                      return Newtonsoft.Json.JsonConvert.DeserializeObject<T> (v);                  }                  // more comprehensive datetime parser' except formats like "\"\\/Date(1335205592410-0500)\\/\""                  // DateTime is tested prior to IConvertible' since it also implements IConvertible                  else if (desiredType == typeof (DateTime) || desiredType == typeof (DateTime?))                  {                      DateTime dt;                      var vDt = missingQuotes ? v : v.Substring (1' v.Length - 2);                      if (DateTime.TryParse (vDt' System.Globalization.CultureInfo.InvariantCulture' System.Globalization.DateTimeStyles.None' out dt))                          return (T)(object)dt;                      if (vDt.Length == 8 && DateTime.TryParseExact (vDt' "yyyyMMdd"' System.Globalization.CultureInfo.InvariantCulture' System.Globalization.DateTimeStyles.None' out dt))                          return (T)(object)dt;                      // if previous convertion attempts didn't work' fallback to json deserialization                  }                  // let's deal with enums                  else if (desiredType.IsEnum)                  {                      return (T)Enum.Parse (desiredType' v' true);                  }                  // all primitive types are IConvertible'                   // and if the type implements this interface lets use it!                  else if (typeof (IConvertible).IsAssignableFrom (desiredType))                  {                      if (!missingQuotes)                          v = v.Substring (1' v.Length - 2);                      // type convertion with InvariantCulture (faster)                      return (T)Convert.ChangeType (v' desiredType' System.Globalization.CultureInfo.InvariantCulture);                  }                  // Guid doesn't implement IConvertible                  else if (desiredType == typeof (Guid) || desiredType == typeof (Guid?))                  {                      Guid guid;                      if (Guid.TryParse (v' out guid))                          return (T)(object)guid;                  }                  // TimeSpan doesn't implement IConvertible                  else if (desiredType == typeof (TimeSpan) || desiredType == typeof (TimeSpan?))                  {                      TimeSpan timespan;                      if (TimeSpan.TryParse (v' out timespan))                          return (T)(object)timespan;                  }                    // finally' deserialize it!                                     return Newtonsoft.Json.JsonConvert.DeserializeObject<T> (v);              }              catch { /* ignore and return default value */ }
