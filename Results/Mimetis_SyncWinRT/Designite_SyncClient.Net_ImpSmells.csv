Implementation smell,Namespace,Class,File,Method,Description
Long Method,Microsoft.Synchronization.ClientServices,HttpCacheRequestHandler,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\ClientCommon\HttpCacheRequestHandlerAsync.cs,ProcessRequest,The method has 108 lines of code.
Long Method,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,Read,The method has 205 lines of code.
Long Method,Microsoft.Synchronization.ClientServices.SQLite,SQLiteHelper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteHelper.cs,MergeEntities,The method has 129 lines of code.
Complex Method,Microsoft.Synchronization.ClientServices,CacheController,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\ClientCommon\CacheControllerAsync.cs,SynchronizeAsync,Cyclomatic complexity of the method is 11
Complex Method,Microsoft.Synchronization.ClientServices,CacheController,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\ClientCommon\CacheControllerAsync.cs,EnqueueDownloadRequest,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Synchronization.ClientServices,CacheController,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\ClientCommon\CacheControllerAsync.cs,ProcessCacheRequestResults,Cyclomatic complexity of the method is 12
Complex Method,Microsoft.Synchronization.ClientServices,HttpCacheRequestHandler,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\ClientCommon\HttpCacheRequestHandlerAsync.cs,ProcessRequest,Cyclomatic complexity of the method is 17
Complex Method,Microsoft.Synchronization.ClientServices,HttpCacheRequestHandler,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\ClientCommon\HttpCacheRequestHandlerAsync.cs,ReadUploadResponse,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Synchronization.ClientServices,StringHandle,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\StringHandle.cs,GetString,Cyclomatic complexity of the method is 11
Complex Method,Microsoft.Synchronization.ClientServices,ValueHandle,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\ValueHandle.cs,IsWhitespace,Cyclomatic complexity of the method is 17
Complex Method,Microsoft.Synchronization.ClientServices,ValueHandle,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\ValueHandle.cs,ToType,Cyclomatic complexity of the method is 28
Complex Method,Microsoft.Synchronization.ClientServices,ValueHandle,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\ValueHandle.cs,ToDouble,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.Synchronization.ClientServices,ValueHandle,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\ValueHandle.cs,GetString,Cyclomatic complexity of the method is 28
Complex Method,Microsoft.Synchronization.ClientServices,ValueHandle,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\ValueHandle.cs,ToObject,Cyclomatic complexity of the method is 28
Complex Method,Microsoft.Synchronization.ClientServices,ValueHandle,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\ValueHandle.cs,TryReadChars,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Synchronization.ClientServices,XmlBufferReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlBufferReader.cs,GetEscapedChars,Cyclomatic complexity of the method is 18
Complex Method,Microsoft.Synchronization.ClientServices,XmlBufferReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlBufferReader.cs,GetCharEntity,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,TryParseSingle,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,TryParseDateTime,Cyclomatic complexity of the method is 15
Complex Method,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,ToChars,Cyclomatic complexity of the method is 16
Complex Method,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,MoveToContent,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,BufferElement,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,ReadValueChunk,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,Read,Cyclomatic complexity of the method is 20
Complex Method,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,ReadAttributes,Cyclomatic complexity of the method is 27
Complex Method,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,ReadEscapedCharacter,Cyclomatic complexity of the method is 29
Complex Method,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,UnescapeJsonString,Cyclomatic complexity of the method is 31
Complex Method,Microsoft.Synchronization.ClientServices,XmlJsonWriter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonWriter.cs,WriteEndAttribute,Cyclomatic complexity of the method is 30
Complex Method,Microsoft.Synchronization.ClientServices,XmlJsonWriter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonWriter.cs,WriteEndElement,Cyclomatic complexity of the method is 14
Complex Method,Microsoft.Synchronization.ClientServices,XmlJsonWriter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonWriter.cs,WriteStartAttribute,Cyclomatic complexity of the method is 13
Complex Method,Microsoft.Synchronization.ClientServices,XmlJsonWriter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonWriter.cs,WriteStartElement,Cyclomatic complexity of the method is 32
Complex Method,Microsoft.Synchronization.ClientServices,XmlJsonWriter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonWriter.cs,WriteEscapedJsonString,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Synchronization.ClientServices,XmlJsonWriter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonWriter.cs,StartText,Cyclomatic complexity of the method is 15
Complex Method,Microsoft.Synchronization.ClientServices,XmlJsonWriter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonWriter.cs,WriteDataTypeServerType,Cyclomatic complexity of the method is 11
Complex Method,Microsoft.Synchronization.ClientServices,XmlJsonWriter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonWriter.cs,WritePrimitiveValue,Cyclomatic complexity of the method is 17
Complex Method,Microsoft.Synchronization.Services.Formatters,AtomEntryInfoWrapper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\AtomEntryInfoWrapper.cs,LoadEntryProperties,Cyclomatic complexity of the method is 18
Complex Method,Microsoft.Synchronization.Services.Formatters,FormatterUtilities,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\FormatterUtilities.cs,GetEdmType,Cyclomatic complexity of the method is 20
Complex Method,Microsoft.Synchronization.Services.Formatters,JsonEntryInfoWrapper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonEntryInfoWrapper.cs,LoadTypeName,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.Synchronization.Services.Formatters,ODataJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\ODataJsonReader.cs,Next,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Synchronization.Services.Formatters,ODataJsonWriter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\ODataJsonWriter.cs,WriteEntityContentsToElement,Cyclomatic complexity of the method is 11
Complex Method,Microsoft.Synchronization.ClientServices.SQLite,SQLiteHelper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteHelper.cs,CreateTable,Cyclomatic complexity of the method is 18
Complex Method,Microsoft.Synchronization.ClientServices.SQLite,SQLiteHelper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteHelper.cs,DisableTriggers,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Synchronization.ClientServices.SQLite,SQLiteHelper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteHelper.cs,CreateTriggers,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Synchronization.ClientServices.SQLite,SQLiteHelper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteHelper.cs,DeleteTombstoneTrackingEntities,Cyclomatic complexity of the method is 11
Complex Method,Microsoft.Synchronization.ClientServices.SQLite,SQLiteHelper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteHelper.cs,UpdateDirtyTrackingEntities,Cyclomatic complexity of the method is 12
Complex Method,Microsoft.Synchronization.ClientServices.SQLite,SQLiteHelper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteHelper.cs,MergeEntities,Cyclomatic complexity of the method is 26
Complex Method,Microsoft.Synchronization.ClientServices.SQLite,SQLiteHelper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteHelper.cs,GetChanges,Cyclomatic complexity of the method is 16
Complex Method,Microsoft.Synchronization.ClientServices.SQLite,SQLiteHelper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteHelper.cs,BindParameter,Cyclomatic complexity of the method is 14
Complex Method,Microsoft.Synchronization.ClientServices.SQLite,SQLiteManager,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteManager.cs,ScopeTableExist,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Synchronization.ClientServices.SQLite,SQLiteManager,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteManager.cs,ReadConfiguration,Cyclomatic complexity of the method is 11
Complex Method,Microsoft.Synchronization.ClientServices.SQLite,SQLiteManager,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteManager.cs,SaveConfiguration,Cyclomatic complexity of the method is 14
Complex Method,Microsoft.Synchronization.ClientServices.SQLite,Orm,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteManager.cs,SqlType,Cyclomatic complexity of the method is 11
Long Parameter List,Microsoft.Synchronization.ClientServices,CacheRequestResult,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\ClientCommon\CacheRequestResult.cs,CacheRequestResult,The method has 6 parameters.
Long Parameter List,Microsoft.Synchronization.ClientServices,CacheRequestResult,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\ClientCommon\CacheRequestResult.cs,CacheRequestResult,The method has 5 parameters.
Long Parameter List,Microsoft.Synchronization.ClientServices,SyncProgressEvent,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\ClientCommon\SyncProgressEventArgs.cs,SyncProgressEvent,The method has 6 parameters.
Long Parameter List,Microsoft.Synchronization.ClientServices,XmlBufferReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlBufferReader.cs,Equals2,The method has 5 parameters.
Long Parameter List,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,ToChars,The method has 5 parameters.
Long Parameter List,Microsoft.Synchronization.ClientServices,XmlNode,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlNode.cs,XmlNode,The method has 7 parameters.
Long Parameter List,Microsoft.Synchronization.ClientServices,XmlTextNode,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlNode.cs,XmlTextNode,The method has 7 parameters.
Long Parameter List,Microsoft.Synchronization.Services.Formatters,ODataAtomWriter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\ODataAtomWriter.cs,WriteItemInternal,The method has 7 parameters.
Long Parameter List,Microsoft.Synchronization.Services.Formatters,ODataJsonWriter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\ODataJsonWriter.cs,WriteItemInternal,The method has 7 parameters.
Long Parameter List,Microsoft.Synchronization.Services.Formatters,SyncWriter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\SyncWriter.cs,WriteItemInternal,The method has 7 parameters.
Long Parameter List,Microsoft.Synchronization.ClientServices.SQLite,SQLiteContext,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteContext.cs,SQLiteContext,The method has 5 parameters.
Long Parameter List,Microsoft.Synchronization.ClientServices.SQLite,SQLiteContext,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteContext.cs,CheckSchemaAndUriAsync,The method has 12 parameters.
Long Parameter List,Microsoft.Synchronization.ClientServices.SQLite,SQLiteHelper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteHelper.cs,CreateTriggers,The method has 5 parameters.
Long Parameter List,Microsoft.Synchronization.ClientServices.SQLite,SQLiteHelper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteHelper.cs,MergeEntities,The method has 5 parameters.
Long Identifier,Microsoft.Synchronization.ClientServices.SQLite,SQLiteHelper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteHelper.cs,MergeEntities,The length of the parameter querySelectItemPrimaryKeyFromTrackingChangesWithOemID is 53.
Long Statement,Microsoft.Synchronization.ClientServices,CacheController,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\ClientCommon\CacheControllerAsync.cs,EnqueueUploadRequest,The length of the statement  "			progress.Report (new SyncProgressEvent (SyncStage.GetChanges' DateTime.Now.Subtract (durationStartDate)' true' (changeSet != null ? changeSet.Data : null))); " is 157.
Long Statement,Microsoft.Synchronization.ClientServices,CacheController,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\ClientCommon\CacheControllerAsync.cs,EnqueueUploadRequest,The length of the statement  "		var requestResult = await this.cacheRequestHandler.ProcessCacheRequestAsync (request' changeSet.IsLastBatch' cancellationToken); " is 128.
Long Statement,Microsoft.Synchronization.ClientServices,CacheController,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\ClientCommon\CacheControllerAsync.cs,EnqueueUploadRequest,The length of the statement  "			progress.Report (new SyncProgressEvent (SyncStage.UploadingChanges' DateTime.Now.Subtract (durationStartDate)' true' changeSet.Data' requestResult.ChangeSetResponse.Conflicts' requestResult.ChangeSetResponse.UpdatedItems)); " is 223.
Long Statement,Microsoft.Synchronization.ClientServices,CacheController,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\ClientCommon\CacheControllerAsync.cs,EnqueueDownloadRequest,The length of the statement  "				progress.Report (new SyncProgressEvent (SyncStage.DownloadingChanges' DateTime.Now.Subtract (durationStartDate)' true' (requestResult.ChangeSet != null ? requestResult.ChangeSet.Data : null))); " is 193.
Long Statement,Microsoft.Synchronization.ClientServices,CacheController,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\ClientCommon\CacheControllerAsync.cs,ProcessCacheRequestResults,The length of the statement  "		if (cacheRequestResult.ChangeSet != null && cacheRequestResult.ChangeSet.Data != null && cacheRequestResult.ChangeSet.Data.Count > 0) { " is 135.
Long Statement,Microsoft.Synchronization.ClientServices,HttpCacheRequestHandler,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\ClientCommon\HttpCacheRequestHandlerAsync.cs,ProcessCacheRequestAsync,The length of the statement  "		cacheRequestResult = new CacheRequestResult (wrapper.CacheRequest.RequestId' wrapper.UploadResponse' wrapper.CacheRequest.Changes.Count' wrapper.Error' wrapper.Step' wrapper.UserPassedState); " is 191.
Long Statement,Microsoft.Synchronization.ClientServices,HttpCacheRequestHandler,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\ClientCommon\HttpCacheRequestHandlerAsync.cs,ProcessCacheRequestAsync,The length of the statement  "		cacheRequestResult = new CacheRequestResult (wrapper.CacheRequest.RequestId' wrapper.DownloadResponse' wrapper.Error' wrapper.Step' wrapper.UserPassedState); " is 157.
Long Statement,Microsoft.Synchronization.ClientServices,HttpCacheRequestHandler,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\ClientCommon\HttpCacheRequestHandlerAsync.cs,ProcessRequest,The length of the statement  "		requestUri.AppendFormat ("{0}{1}{2}/{3}"' BaseUri' (BaseUri.ToString ().EndsWith ("/")) ? string.Empty : "/"' Uri.EscapeUriString (ScopeName)' wrapper.CacheRequest.RequestType.ToString ()); " is 189.
Long Statement,Microsoft.Synchronization.ClientServices,HttpCacheRequestHandler,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\ClientCommon\HttpCacheRequestHandlerAsync.cs,ProcessRequest,The length of the statement  "		webRequest.Accept = (SerializationFormat == SerializationFormat.ODataAtom) ? "application/atom+xml" : "application/json"; " is 121.
Long Statement,Microsoft.Synchronization.ClientServices,HttpCacheRequestHandler,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\ClientCommon\HttpCacheRequestHandlerAsync.cs,ProcessRequest,The length of the statement  "		webRequest.ContentType = (SerializationFormat == SerializationFormat.ODataAtom) ? "application/atom+xml" : "application/json"; " is 126.
Long Statement,Microsoft.Synchronization.ClientServices,HttpCacheRequestHandler,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\ClientCommon\HttpCacheRequestHandlerAsync.cs,ProcessRequest,The length of the statement  "		using (Stream stream = await Task.Factory.FromAsync<Stream> (webRequest.BeginGetRequestStream' webRequest.EndGetRequestStream' null)) " is 133.
Long Statement,Microsoft.Synchronization.ClientServices,HttpCacheRequestHandler,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\ClientCommon\HttpCacheRequestHandlerAsync.cs,ProcessRequest,The length of the statement  "		webResponse = (HttpWebResponse)(await Task.Factory.FromAsync<WebResponse> (webRequest.BeginGetResponse' webRequest.EndGetResponse' null)); " is 138.
Long Statement,Microsoft.Synchronization.ClientServices,HttpCacheRequestHandler,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\ClientCommon\HttpCacheRequestHandlerAsync.cs,ProcessRequest,The length of the statement  "				using (var reader = SerializationFormat == SerializationFormat.ODataAtom ? XmlReader.Create (stream) : new XmlJsonReader (stream' XmlDictionaryReaderQuotas.Max)) { " is 163.
Long Statement,Microsoft.Synchronization.ClientServices,HttpCacheRequestHandler,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\ClientCommon\HttpCacheRequestHandlerAsync.cs,WriteUploadRequestStream,The length of the statement  "		var syncWriter = (SerializationFormat == SerializationFormat.ODataAtom) ? new ODataAtomWriter (BaseUri) : (SyncWriter)new ODataJsonWriter (BaseUri); " is 148.
Long Statement,Microsoft.Synchronization.ClientServices,HttpCacheRequestHandler,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\ClientCommon\HttpCacheRequestHandlerAsync.cs,WriteDownloadRequestStream,The length of the statement  "		var syncWriter = (SerializationFormat == SerializationFormat.ODataAtom) ? new ODataAtomWriter (BaseUri) : (SyncWriter)new ODataJsonWriter (BaseUri); " is 148.
Long Statement,Microsoft.Synchronization.ClientServices,HttpCacheRequestHandler,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\ClientCommon\HttpCacheRequestHandlerAsync.cs,ReadUploadResponse,The length of the statement  "				using (var syncReader = (SerializationFormat == SerializationFormat.ODataAtom) ? new ODataAtomReader (responseStream' this.knownTypes) : (SyncReader)new ODataJsonReader (responseStream' this.knownTypes)) { " is 205.
Long Statement,Microsoft.Synchronization.ClientServices,HttpCacheRequestHandler,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\ClientCommon\HttpCacheRequestHandlerAsync.cs,ReadUploadResponse,The length of the statement  "									throw new CacheControllerException (string.Format ("Service returned a TempId '{0}' in both live and conflicting entities."' syncReader.GetTempId ())); " is 151.
Long Statement,Microsoft.Synchronization.ClientServices,HttpCacheRequestHandler,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\ClientCommon\HttpCacheRequestHandlerAsync.cs,ReadUploadResponse,The length of the statement  "									IOfflineEntity conflictEntity = (conflict is SyncConflict) ? ((SyncConflict)conflict).LosingEntity : ((SyncError)conflict).ErrorEntity; " is 135.
Long Statement,Microsoft.Synchronization.ClientServices,HttpCacheRequestHandler,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\ClientCommon\HttpCacheRequestHandlerAsync.cs,ReadUploadResponse,The length of the statement  "			wrapper.UploadResponse.Error = new CacheControllerException (string.Format ("Remote service returned error status. Status: {0}' Description: {1}"' response.StatusCode' response.StatusDescription)); " is 197.
Long Statement,Microsoft.Synchronization.ClientServices,HttpCacheRequestHandler,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\ClientCommon\HttpCacheRequestHandlerAsync.cs,CheckEntityServiceMetadataAndTempIds,The length of the statement  "		throw new CacheControllerException ("Service returned a response for a tempId which was not uploaded by the client. TempId: " + tempId); " is 136.
Long Statement,Microsoft.Synchronization.ClientServices,HttpCacheRequestHandler,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\ClientCommon\HttpCacheRequestHandlerAsync.cs,ReadDownloadResponse,The length of the statement  "				using (var syncReader = (SerializationFormat == SerializationFormat.ODataAtom) ? new ODataAtomReader (responseStream' this.knownTypes) : (SyncReader)new ODataJsonReader (responseStream' this.knownTypes)) { " is 205.
Long Statement,Microsoft.Synchronization.ClientServices,HttpCacheRequestHandler,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\ClientCommon\HttpCacheRequestHandlerAsync.cs,ReadDownloadResponse,The length of the statement  "			wrapper.Error = new CacheControllerException (string.Format ("Remote service returned error status. Status: {0}' Description: {1}"' response.StatusCode' response.StatusDescription)); " is 182.
Long Statement,Microsoft.Synchronization.ClientServices,ValueHandle,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\ValueHandle.cs,ToByteArray,The length of the statement  "	//            int bytes2 = ValueHandle.Base64Encoding.GetBytes(this.bufferReader.Buffer' this.offset' this.length' bytes1' 0); " is 126.
Long Statement,Microsoft.Synchronization.ClientServices,ValueHandle,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\ValueHandle.cs,ToByteArray,The length of the statement  "	//    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError((Exception)new XmlException(ex.Message' ex.InnerException)); " is 124.
Long Statement,Microsoft.Synchronization.ClientServices,ValueHandle,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\ValueHandle.cs,TryReadBase64,The length of the statement  "	//            actual = ValueHandle.Base64Encoding.GetBytes(this.bufferReader.Buffer' this.offset' charCount' buffer' offset); " is 125.
Long Statement,Microsoft.Synchronization.ClientServices,ValueHandle,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\ValueHandle.cs,TryReadChars,The length of the statement  "		// If we're asking for more than are possibly available' or more than are truly available then we can return the entire thing " is 125.
Long Statement,Microsoft.Synchronization.ClientServices,ValueHandle,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\ValueHandle.cs,TryReadChars,The length of the statement  "		if (charCount >= encoding.GetMaxCharCount (byteCount) || charCount >= encoding.GetCharCount (bytes' byteOffset' byteCount)) { " is 125.
Long Statement,Microsoft.Synchronization.ClientServices,XmlBufferReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlBufferReader.cs,TryEnsureBytes,The length of the statement  "		throw new Exception ("XmlExceptionHelper.ThrowMaxBytesPerReadExceeded(this.reader' this.windowOffsetMax - this.windowOffset);"); " is 128.
Long Statement,Microsoft.Synchronization.ClientServices,XmlBufferReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlBufferReader.cs,TryEnsureBytes,The length of the statement  "		throw new Exception ("XmlExceptionHelper.ThrowMaxBytesPerReadExceeded(this.reader' this.windowOffsetMax - this.windowOffset);"); " is 128.
Long Statement,Microsoft.Synchronization.ClientServices,XmlBufferReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlBufferReader.cs,GetChars,The length of the statement  "			return charOffset + XmlConverter.ToChars (currentBuffer' iOffset + charOffset' iLength - charOffset' iChars' charOffset); " is 121.
Long Statement,Microsoft.Synchronization.ClientServices,XmlBufferReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlBufferReader.cs,GetQuoteCharEntity,The length of the statement  "	if (length != 6 || iBuffer [offset + 1] != (byte)'q' || iBuffer [offset + 2] != (byte)'u' || iBuffer [offset + 3] != (byte)'o' || iBuffer [offset + 4] != (byte)'t') " is 164.
Long Statement,Microsoft.Synchronization.ClientServices,XmlBufferReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlBufferReader.cs,GetAmpersandCharEntity,The length of the statement  "	if (length != 5 || iBuffer [offset + 1] != (byte)'a' || iBuffer [offset + 2] != (byte)'m' || iBuffer [offset + 3] != (byte)'p') " is 127.
Long Statement,Microsoft.Synchronization.ClientServices,XmlBufferReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlBufferReader.cs,GetApostropheCharEntity,The length of the statement  "	if (length != 6 || iBuffer [offset + 1] != (byte)'a' || iBuffer [offset + 2] != (byte)'p' || iBuffer [offset + 3] != (byte)'o' || iBuffer [offset + 4] != (byte)'s') " is 164.
Long Statement,Microsoft.Synchronization.ClientServices,XmlBufferReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlBufferReader.cs,GetDecimal,The length of the statement  "	var int1 = numArray [0 + iOffset] | numArray [1 + iOffset] << 8 | numArray [2 + iOffset] << 16 | numArray [3 + iOffset] << 24; " is 126.
Long Statement,Microsoft.Synchronization.ClientServices,XmlBufferReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlBufferReader.cs,GetDecimal,The length of the statement  "	var int2 = numArray [4 + iOffset] | numArray [5 + iOffset] << 8 | numArray [6 + iOffset] << 16 | numArray [7 + iOffset] << 24; " is 126.
Long Statement,Microsoft.Synchronization.ClientServices,XmlBufferReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlBufferReader.cs,GetDecimal,The length of the statement  "	var int3 = numArray [8 + iOffset] | numArray [9 + iOffset] << 8 | numArray [10 + iOffset] << 16 | numArray [11 + iOffset] << 24; " is 128.
Long Statement,Microsoft.Synchronization.ClientServices,XmlBufferReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlBufferReader.cs,GetDecimal,The length of the statement  "	var int4 = numArray [12 + iOffset] | numArray [13 + iOffset] << 8 | numArray [14 + iOffset] << 16 | numArray [15 + iOffset] << 24; " is 130.
Long Statement,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,TryParseDateTime,The length of the statement  "	if (chars [offset + 4] != '-' || chars [offset + 7] != '-' || chars [offset + 10] != 'T' || chars [offset + 13] != ':' || chars [offset + 16] != ':') " is 149.
Long Statement,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,IsStartElement,The length of the statement  "	if (slocalName == null || namespaceUri == null || this.Node.NodeType != XmlNodeType.Element && !this.IsStartElement () || !(this.Node.LocalName == slocalName)) " is 159.
Long Statement,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,Read,The length of the statement  "				if (buffer [offset + 1] != Keys.LowerA || buffer [offset + 2] != Keys.LowerL || buffer [offset + 3] != Keys.LowerS || buffer [offset + 4] != Keys.LowerE) " is 153.
Long Statement,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,Read,The length of the statement  "				if (TryGetByte (out ch) && !IsWhitespace (ch) && (ch != Keys.Comma && ch != Keys.RightClosingBrace) && ch != Keys.RightClosingBracket) " is 134.
Long Statement,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,Read,The length of the statement  "				if (TryGetByte (out ch) && !IsWhitespace (ch) && (ch != Keys.Comma && ch != Keys.RightClosingBrace) && ch != Keys.RightClosingBracket) " is 134.
Long Statement,Microsoft.Synchronization.Services.Formatters,AtomEntryInfoWrapper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\AtomEntryInfoWrapper.cs,LoadConflictEntry,The length of the statement  "	XElement conflictElement = entry.Element (FormatterConstants.SyncNamespace + FormatterConstants.SyncConlflictElementName); " is 122.
Long Statement,Microsoft.Synchronization.Services.Formatters,AtomEntryInfoWrapper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\AtomEntryInfoWrapper.cs,LoadConflictEntry,The length of the statement  "		XElement resolutionType = conflictElement.Element (FormatterConstants.SyncNamespace + FormatterConstants.ConflictResolutionElementName); " is 136.
Long Statement,Microsoft.Synchronization.Services.Formatters,AtomEntryInfoWrapper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\AtomEntryInfoWrapper.cs,LoadConflictEntry,The length of the statement  "		XElement conflictingChangeElement = conflictElement.Element (FormatterConstants.SyncNamespace + FormatterConstants.ConflictEntryElementName); " is 141.
Long Statement,Microsoft.Synchronization.Services.Formatters,AtomEntryInfoWrapper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\AtomEntryInfoWrapper.cs,LoadConflictEntry,The length of the statement  "		XElement errorDesc = errorElement.Element (FormatterConstants.SyncNamespace + FormatterConstants.ErrorDescriptionElementName); " is 126.
Long Statement,Microsoft.Synchronization.Services.Formatters,AtomEntryInfoWrapper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\AtomEntryInfoWrapper.cs,LoadConflictEntry,The length of the statement  "		XElement errorChangeElement = errorElement.Element (FormatterConstants.SyncNamespace + FormatterConstants.ErrorEntryElementName); " is 129.
Long Statement,Microsoft.Synchronization.Services.Formatters,AtomEntryInfoWrapper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\AtomEntryInfoWrapper.cs,GetSubElement,The length of the statement  "	XElement element = entryElement.Element (FormatterConstants.AtomNamespaceUri + FormatterConstants.AtomPubEntryElementName); " is 123.
Long Statement,Microsoft.Synchronization.Services.Formatters,AtomEntryInfoWrapper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\AtomEntryInfoWrapper.cs,GetSubElement,The length of the statement  "		element = entryElement.Element (FormatterConstants.AtomDeletedEntryNamespace + FormatterConstants.AtomDeletedEntryElementName); " is 127.
Long Statement,Microsoft.Synchronization.Services.Formatters,AtomEntryInfoWrapper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\AtomEntryInfoWrapper.cs,LoadEntryProperties,The length of the statement  "			throw new InvalidOperationException ("A atom:ref element must be present for a tombstone entry. Entity in error: " + entry.ToString (SaveOptions.None)); " is 152.
Long Statement,Microsoft.Synchronization.Services.Formatters,AtomEntryInfoWrapper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\AtomEntryInfoWrapper.cs,LoadEntryProperties,The length of the statement  "			throw new InvalidOperationException ("A atom:id or a sync:tempId element must be present. Entity in error: " + entry.ToString (SaveOptions.None)); " is 146.
Long Statement,Microsoft.Synchronization.Services.Formatters,AtomEntryInfoWrapper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\AtomEntryInfoWrapper.cs,LoadEntryProperties,The length of the statement  "		foreach (XElement linkElement in entry.Elements (FormatterConstants.AtomXmlNamespace + FormatterConstants.AtomPubLinkElementName)) { " is 132.
Long Statement,Microsoft.Synchronization.Services.Formatters,AtomEntryInfoWrapper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\AtomEntryInfoWrapper.cs,LoadEntryProperties,The length of the statement  "						throw new InvalidOperationException (string.Format (CultureInfo.InvariantCulture' "Multiple Edit Url's found for atom with {0}: '{1}'"' (this.Id == null) ? "TempId" : "Id"' (this.Id == null) ? this.TempId : this.Id)); " is 217.
Long Statement,Microsoft.Synchronization.Services.Formatters,AtomEntryInfoWrapper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\AtomEntryInfoWrapper.cs,LoadEntryProperties,The length of the statement  "						throw new InvalidOperationException (string.Format ("No href attribute found in the edit link for atom with  {0}: '{1}'"' (this.Id == null) ? "TempId" : "Id"' this.Id ?? this.TempId)); " is 184.
Long Statement,Microsoft.Synchronization.Services.Formatters,AtomEntryInfoWrapper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\AtomEntryInfoWrapper.cs,LoadEntryProperties,The length of the statement  "					XAttribute nullableAttr = property.Attribute (FormatterConstants.ODataMetadataNamespace + FormatterConstants.AtomPubIsNullElementName); " is 135.
Long Statement,Microsoft.Synchronization.Services.Formatters,AtomEntryInfoWrapper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\AtomEntryInfoWrapper.cs,LoadTypeName,The length of the statement  "	var categories = (isTombstone) ? entry.Elements (FormatterConstants.SyncNamespace + FormatterConstants.AtomPubCategoryElementName) : entry.Elements (FormatterConstants.AtomNamespaceUri + FormatterConstants.AtomPubCategoryElementName); " is 234.
Long Statement,Microsoft.Synchronization.Services.Formatters,AtomEntryInfoWrapper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\AtomEntryInfoWrapper.cs,LoadTypeName,The length of the statement  "		throw new InvalidOperationException (string.Format (CultureInfo.InvariantCulture' "Category element not found in {0} element."' (isTombstone) ? FormatterConstants.AtomDeletedEntryElementName : FormatterConstants.AtomPubEntryElementName)); " is 238.
Long Statement,Microsoft.Synchronization.Services.Formatters,AtomHelper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\AtomHelper.cs,IsAtomElement,The length of the statement  "	return reader.NodeType == XmlNodeType.Element && reader.LocalName == name && reader.NamespaceURI == FormatterConstants.AtomNamespaceUri; " is 136.
Long Statement,Microsoft.Synchronization.Services.Formatters,AtomHelper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\AtomHelper.cs,IsAtomTombstone,The length of the statement  "	return reader.NodeType == XmlNodeType.Element && reader.LocalName == name && reader.NamespaceURI == FormatterConstants.AtomDeletedEntryNamespace; " is 145.
Long Statement,Microsoft.Synchronization.Services.Formatters,AtomHelper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\AtomHelper.cs,IsSyncElement,The length of the statement  "	return reader.NodeType == XmlNodeType.Element && reader.LocalName == name && reader.NamespaceURI == FormatterConstants.SyncNamespace.NamespaceName; " is 147.
Long Statement,Microsoft.Synchronization.Services.Formatters,FormatterUtilities,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\FormatterUtilities.cs,ConvertDateTimeToJson,The length of the statement  "	return string.Format (USCultureInfo' FormatterConstants.JsonDateTimeFormat' (date.Ticks - FormatterConstants.JsonDateTimeStartTime.Ticks) / FormatterConstants.JsonNanoToMilliSecondsFactor); " is 189.
Long Statement,Microsoft.Synchronization.Services.Formatters,FormatterUtilities,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\FormatterUtilities.cs,ConvertDateTimeOffsetToJson,The length of the statement  "	return string.Format (USCultureInfo' FormatterConstants.JsonDateTimeOffsetFormat' dto.ToString (FormatterConstants.JsonDateTimeOffsetLexicalRepresentation' USCultureInfo)); " is 172.
Long Statement,Microsoft.Synchronization.Services.Formatters,FormatterUtilities,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\FormatterUtilities.cs,ParseDateTimeFromString,The length of the statement  "		throw new InvalidOperationException (string.Format (USCultureInfo' "Invalid Date/Time value received. Unable to parse value {0} to type {1}."' value' type.Name)); " is 162.
Long Statement,Microsoft.Synchronization.Services.Formatters,FormatterUtilities,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\FormatterUtilities.cs,ParseJsonString,The length of the statement  "			long ticks = long.Parse (ticksStr' USCultureInfo) * FormatterConstants.JsonNanoToMilliSecondsFactor + FormatterConstants.JsonDateTimeStartTime.Ticks; " is 149.
Long Statement,Microsoft.Synchronization.Services.Formatters,FormatterUtilities,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\FormatterUtilities.cs,ParseJsonString,The length of the statement  "				throw new InvalidOperationException (string.Format ("Invalid JSON DateTime value received. Value '{0}' is not a valid DateTime"' ticks)); " is 137.
Long Statement,Microsoft.Synchronization.Services.Formatters,FormatterUtilities,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\FormatterUtilities.cs,ParseJsonString,The length of the statement  "			throw new InvalidOperationException (string.Format (USCultureInfo' @"Invalid Json DateTime value received. Value {0} is not in format '\/Date(ticks)\/'."' value)); " is 163.
Long Statement,Microsoft.Synchronization.Services.Formatters,FormatterUtilities,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\FormatterUtilities.cs,ParseJsonString,The length of the statement  "			throw new InvalidOperationException (string.Format (USCultureInfo' @"Invalid Json DateTimeOffset value received. Value {0} is not in format 'datetimeoffset'yyyy-MM-ddTHH:mm:ss.fffffffzzz''."' value)); " is 200.
Long Statement,Microsoft.Synchronization.Services.Formatters,FormatterUtilities,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\FormatterUtilities.cs,ParseJsonString,The length of the statement  "		throw new InvalidOperationException (string.Format (USCultureInfo' @"Invalid Json TimeSpan value received. Value {0} is not in format 'time'HH:mm:ss''."' value)); " is 162.
Long Statement,Microsoft.Synchronization.Services.Formatters,JsonEntryInfoWrapper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonEntryInfoWrapper.cs,LoadEntryProperties,The length of the statement  "		if (!keyValuePair.Name.LocalName.Equals (FormatterConstants.JsonSyncEntryMetadataElementName' StringComparison.CurrentCultureIgnoreCase) && !keyValuePair.Name.LocalName.Equals (FormatterConstants.IsDeletedElementName' StringComparison.CurrentCultureIgnoreCase)) { " is 263.
Long Statement,Microsoft.Synchronization.Services.Formatters,JsonEntryInfoWrapper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonEntryInfoWrapper.cs,LoadTypeName,The length of the statement  "			throw new InvalidOperationException ("A uri or a tempId key must be present in the __metadata object. Entity in error: " + entry.ToString (SaveOptions.None)); " is 158.
Long Statement,Microsoft.Synchronization.Services.Formatters,ODataAtomReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\ODataAtomReader.cs,Next,The length of the statement  "		if (AtomHelper.IsAtomElement (reader' FormatterConstants.AtomPubEntryElementName) || AtomHelper.IsAtomTombstone (reader' FormatterConstants.AtomDeletedEntryElementName)) { " is 171.
Long Statement,Microsoft.Synchronization.Services.Formatters,ODataAtomWriter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\ODataAtomWriter.cs,StartFeed,The length of the statement  "	root = new XElement (FormatterConstants.AtomXmlNamespace + FormatterConstants.AtomPubFeedElementName' new XAttribute (XNamespace.Xmlns + "base"' baseNs)' new XAttribute (FormatterConstants.AtomPubXmlNsPrefix' FormatterConstants.AtomXmlNamespace)' new XAttribute (XNamespace.Xmlns + FormatterConstants.ODataDataNsPrefix' FormatterConstants.ODataDataNamespace)' new XAttribute (XNamespace.Xmlns + FormatterConstants.ODataMetadataNsPrefix' FormatterConstants.ODataMetadataNamespace)' new XAttribute (XNamespace.Xmlns + FormatterConstants.AtomDeletedEntryPrefix' FormatterConstants.AtomDeletedEntryNamespace)' new XAttribute (XNamespace.Xmlns + FormatterConstants.SyncNsPrefix' FormatterConstants.SyncNamespace)); " is 709.
Long Statement,Microsoft.Synchronization.Services.Formatters,ODataAtomWriter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\ODataAtomWriter.cs,StartFeed,The length of the statement  "	root.Add (new XElement (atom + FormatterConstants.AtomPubLinkElementName' new XAttribute (FormatterConstants.AtomPubRelAttrName' "self")' new XAttribute (FormatterConstants.AtomPubHrefAttrName' string.Empty))); " is 210.
Long Statement,Microsoft.Synchronization.Services.Formatters,ODataAtomWriter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\ODataAtomWriter.cs,StartFeed,The length of the statement  "	root.Add (new XElement (FormatterConstants.SyncNamespace + FormatterConstants.ServerBlobText' (serverBlob != null) ? Convert.ToBase64String (serverBlob) : "null")); " is 164.
Long Statement,Microsoft.Synchronization.Services.Formatters,ODataAtomWriter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\ODataAtomWriter.cs,WriteItemInternal,The length of the statement  "		XElement conflictElement = new XElement (FormatterConstants.SyncNamespace + ((isConflict) ? FormatterConstants.SyncConlflictElementName : FormatterConstants.SyncErrorElementName)); " is 180.
Long Statement,Microsoft.Synchronization.Services.Formatters,ODataAtomWriter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\ODataAtomWriter.cs,WriteItemInternal,The length of the statement  "		conflictElement.Add (new XElement (FormatterConstants.SyncNamespace + ((isConflict) ? FormatterConstants.ConflictResolutionElementName : FormatterConstants.ErrorDescriptionElementName)' desc)); " is 193.
Long Statement,Microsoft.Synchronization.Services.Formatters,ODataAtomWriter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\ODataAtomWriter.cs,WriteItemInternal,The length of the statement  "		XElement conflictingEntryElement = new XElement (FormatterConstants.SyncNamespace + ((isConflict) ? FormatterConstants.ConflictEntryElementName : FormatterConstants.ErrorEntryElementName)); " is 189.
Long Statement,Microsoft.Synchronization.Services.Formatters,ODataAtomWriter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\ODataAtomWriter.cs,WriteEntry,The length of the statement  "		XElement entryElement = new XElement (FormatterConstants.AtomXmlNamespace + FormatterConstants.AtomPubEntryElementName); " is 120.
Long Statement,Microsoft.Synchronization.Services.Formatters,ODataAtomWriter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\ODataAtomWriter.cs,WriteEntry,The length of the statement  "			entryElement.Add (new XAttribute (FormatterConstants.ODataMetadataNamespace + FormatterConstants.EtagElementName' live.GetServiceMetadata ().ETag)); " is 148.
Long Statement,Microsoft.Synchronization.Services.Formatters,ODataAtomWriter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\ODataAtomWriter.cs,WriteEntry,The length of the statement  "		entryElement.Add (new XElement (FormatterConstants.AtomXmlNamespace + FormatterConstants.AtomPubIdElementName' string.IsNullOrEmpty (live.GetServiceMetadata ().Id) ? string.Empty : live.GetServiceMetadata ().Id)); " is 213.
Long Statement,Microsoft.Synchronization.Services.Formatters,ODataAtomWriter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\ODataAtomWriter.cs,WriteEntry,The length of the statement  "		entryElement.Add (new XElement (FormatterConstants.AtomXmlNamespace + FormatterConstants.AtomPubTitleElementName' new XAttribute (FormatterConstants.AtomPubTypeElementName' "text"))); " is 183.
Long Statement,Microsoft.Synchronization.Services.Formatters,ODataAtomWriter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\ODataAtomWriter.cs,WriteEntry,The length of the statement  "		entryElement.Add (new XElement (FormatterConstants.AtomXmlNamespace + FormatterConstants.AtomPubUpdatedElementName' XmlConvert.ToString (DateTime.Now))); " is 153.
Long Statement,Microsoft.Synchronization.Services.Formatters,ODataAtomWriter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\ODataAtomWriter.cs,WriteEntry,The length of the statement  "		entryElement.Add (new XElement (FormatterConstants.AtomXmlNamespace + FormatterConstants.AtomPubAuthorElementName' new XElement (FormatterConstants.AtomXmlNamespace + FormatterConstants.AtomPubNameElementName))); " is 212.
Long Statement,Microsoft.Synchronization.Services.Formatters,ODataAtomWriter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\ODataAtomWriter.cs,WriteEntry,The length of the statement  "		entryElement.Add (new XElement (FormatterConstants.AtomXmlNamespace + FormatterConstants.AtomPubLinkElementName' new XAttribute (FormatterConstants.AtomPubRelAttrName' FormatterConstants.AtomPubEditLinkAttributeName)' new XAttribute (FormatterConstants.AtomPubTitleElementName' typeName)' new XAttribute (FormatterConstants.AtomPubHrefAttrName' (live.GetServiceMetadata ().EditUri != null) ? live.GetServiceMetadata ().EditUri.ToString () : string.Empty))); " is 457.
Long Statement,Microsoft.Synchronization.Services.Formatters,ODataAtomWriter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\ODataAtomWriter.cs,WriteEntry,The length of the statement  "		entryElement.Add (new XElement (FormatterConstants.AtomXmlNamespace + FormatterConstants.AtomPubCategoryElementName' new XAttribute (FormatterConstants.AtomPubTermAttrName' live.GetType ().FullName)' new XAttribute (FormatterConstants.AtomPubSchemaAttrName' FormatterConstants.ODataSchemaNamespace))); " is 301.
Long Statement,Microsoft.Synchronization.Services.Formatters,ODataAtomWriter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\ODataAtomWriter.cs,WriteEntry,The length of the statement  "		XElement contentElement = new XElement (FormatterConstants.AtomXmlNamespace + FormatterConstants.AtomPubContentElementName); " is 124.
Long Statement,Microsoft.Synchronization.Services.Formatters,ODataAtomWriter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\ODataAtomWriter.cs,WriteEntry,The length of the statement  "	XElement tombstoneElement = new XElement (FormatterConstants.AtomDeletedEntryNamespace + FormatterConstants.AtomDeletedEntryElementName); " is 137.
Long Statement,Microsoft.Synchronization.Services.Formatters,ODataAtomWriter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\ODataAtomWriter.cs,WriteEntry,The length of the statement  "	tombstoneElement.Add (new XElement (FormatterConstants.AtomNamespaceUri + FormatterConstants.AtomReferenceElementName' live.GetServiceMetadata ().Id)); " is 151.
Long Statement,Microsoft.Synchronization.Services.Formatters,ODataAtomWriter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\ODataAtomWriter.cs,WriteEntry,The length of the statement  "	tombstoneElement.Add (new XElement (FormatterConstants.SyncNamespace + FormatterConstants.AtomPubCategoryElementName' typeName)); " is 129.
Long Statement,Microsoft.Synchronization.Services.Formatters,ODataAtomWriter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\ODataAtomWriter.cs,WriteEntityContents,The length of the statement  "	XElement contentElement = new XElement (FormatterConstants.ODataMetadataNamespace + FormatterConstants.PropertiesElementName); " is 126.
Long Statement,Microsoft.Synchronization.Services.Formatters,ODataAtomWriter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\ODataAtomWriter.cs,WriteEntityContents,The length of the statement  "		if (fi.PropertyType.IsGenericType () && fi.PropertyType.Name.Equals (FormatterConstants.NullableTypeName' StringComparison.CurrentCultureIgnoreCase)) { " is 151.
Long Statement,Microsoft.Synchronization.Services.Formatters,ODataAtomWriter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\ODataAtomWriter.cs,WriteEntityContents,The length of the statement  "			contentElement.Add (new XElement (FormatterConstants.ODataDataNamespace + fi.Name' new XAttribute (FormatterConstants.ODataMetadataNamespace + FormatterConstants.AtomPubTypeElementName' edmType)' new XAttribute (FormatterConstants.ODataMetadataNamespace + FormatterConstants.AtomPubIsNullElementName' true))); " is 309.
Long Statement,Microsoft.Synchronization.Services.Formatters,ODataAtomWriter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\ODataAtomWriter.cs,WriteEntityContents,The length of the statement  "		else if (propType == FormatterConstants.DateTimeType || propType == FormatterConstants.TimeSpanType || propType == FormatterConstants.DateTimeOffsetType) { " is 155.
Long Statement,Microsoft.Synchronization.Services.Formatters,ODataAtomWriter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\ODataAtomWriter.cs,WriteEntityContents,The length of the statement  "			contentElement.Add (new XElement (FormatterConstants.ODataDataNamespace + fi.Name' new XAttribute (FormatterConstants.ODataMetadataNamespace + FormatterConstants.AtomPubTypeElementName' edmType)' FormatterUtilities.ConvertDateTimeForType_Atom (value' propType))); " is 263.
Long Statement,Microsoft.Synchronization.Services.Formatters,ODataAtomWriter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\ODataAtomWriter.cs,WriteEntityContents,The length of the statement  "			contentElement.Add (new XElement (FormatterConstants.ODataDataNamespace + fi.Name' new XAttribute (FormatterConstants.ODataMetadataNamespace + FormatterConstants.AtomPubTypeElementName' edmType)' value)); " is 204.
Long Statement,Microsoft.Synchronization.Services.Formatters,ODataAtomWriter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\ODataAtomWriter.cs,WriteEntityContents,The length of the statement  "			contentElement.Add (new XElement (FormatterConstants.ODataDataNamespace + fi.Name' new XAttribute (FormatterConstants.ODataMetadataNamespace + FormatterConstants.AtomPubTypeElementName' edmType)' Convert.ToBase64String (bytes))); " is 229.
Long Statement,Microsoft.Synchronization.Services.Formatters,ODataJsonWriter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\ODataJsonWriter.cs,StartFeed,The length of the statement  "	XElement nRoot = new XElement (FormatterConstants.JsonDocumentElementName' new XAttribute (FormatterConstants.JsonTypeAttributeName' JsonElementTypes.Object)); " is 159.
Long Statement,Microsoft.Synchronization.Services.Formatters,ODataJsonWriter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\ODataJsonWriter.cs,StartFeed,The length of the statement  "	this.root = new XElement (FormatterConstants.JsonRootElementName' new XAttribute (FormatterConstants.JsonTypeAttributeName' JsonElementTypes.Object)); " is 150.
Long Statement,Microsoft.Synchronization.Services.Formatters,ODataJsonWriter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\ODataJsonWriter.cs,StartFeed,The length of the statement  "	XElement syncElement = new XElement (FormatterConstants.JsonSyncMetadataElementName' new XAttribute (FormatterConstants.JsonTypeAttributeName' JsonElementTypes.Object)); " is 169.
Long Statement,Microsoft.Synchronization.Services.Formatters,ODataJsonWriter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\ODataJsonWriter.cs,StartFeed,The length of the statement  "	syncElement.Add (new XElement (FormatterConstants.MoreChangesAvailableText' new XAttribute (FormatterConstants.JsonTypeAttributeName' JsonElementTypes.Boolean)' !isLastBatch)); " is 176.
Long Statement,Microsoft.Synchronization.Services.Formatters,ODataJsonWriter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\ODataJsonWriter.cs,StartFeed,The length of the statement  "	syncElement.Add (new XElement (FormatterConstants.ServerBlobText' new XAttribute (FormatterConstants.JsonTypeAttributeName' (serverBlob != null) ? JsonElementTypes.String : JsonElementTypes.Object)' (serverBlob != null) ? Convert.ToBase64String (serverBlob) : "null")); " is 269.
Long Statement,Microsoft.Synchronization.Services.Formatters,ODataJsonWriter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\ODataJsonWriter.cs,StartFeed,The length of the statement  "	results = new XElement (FormatterConstants.JsonSyncResultsElementName' new XAttribute (FormatterConstants.JsonTypeAttributeName' JsonElementTypes.Array)); " is 154.
Long Statement,Microsoft.Synchronization.Services.Formatters,ODataJsonWriter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\ODataJsonWriter.cs,WriteItemInternal,The length of the statement  "		XElement conflictElement = new XElement (((isConflict) ? FormatterConstants.JsonSyncConflictElementName : FormatterConstants.JsonSyncErrorElementName)' new XAttribute (FormatterConstants.JsonTypeAttributeName' JsonElementTypes.Object)); " is 236.
Long Statement,Microsoft.Synchronization.Services.Formatters,ODataJsonWriter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\ODataJsonWriter.cs,WriteItemInternal,The length of the statement  "		conflictElement.Add (new XElement (((isConflict) ? FormatterConstants.ConflictResolutionElementName : FormatterConstants.ErrorDescriptionElementName)' new XAttribute (FormatterConstants.JsonTypeAttributeName' JsonElementTypes.String)' desc)); " is 242.
Long Statement,Microsoft.Synchronization.Services.Formatters,ODataJsonWriter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\ODataJsonWriter.cs,WriteItemInternal,The length of the statement  "		XElement conflictingEntryElement = new XElement (((isConflict) ? FormatterConstants.ConflictEntryElementName : FormatterConstants.ErrorEntryElementName)' new XAttribute (FormatterConstants.JsonTypeAttributeName' JsonElementTypes.Object)); " is 238.
Long Statement,Microsoft.Synchronization.Services.Formatters,ODataJsonWriter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\ODataJsonWriter.cs,WriteEntry,The length of the statement  "		entryElement = new XElement ("item"' new XAttribute (FormatterConstants.JsonTypeAttributeName' JsonElementTypes.Object)); " is 121.
Long Statement,Microsoft.Synchronization.Services.Formatters,ODataJsonWriter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\ODataJsonWriter.cs,WriteEntry,The length of the statement  "	XElement entryMetadata = new XElement (FormatterConstants.JsonSyncEntryMetadataElementName' new XAttribute (FormatterConstants.JsonTypeAttributeName' JsonElementTypes.Object)); " is 176.
Long Statement,Microsoft.Synchronization.Services.Formatters,ODataJsonWriter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\ODataJsonWriter.cs,WriteEntry,The length of the statement  "		entryMetadata.Add (new XElement (FormatterConstants.TempIdElementName' new XAttribute (FormatterConstants.JsonTypeAttributeName' JsonElementTypes.String)' tempId)); " is 164.
Long Statement,Microsoft.Synchronization.Services.Formatters,ODataJsonWriter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\ODataJsonWriter.cs,WriteEntry,The length of the statement  "	entryMetadata.Add (new XElement (FormatterConstants.JsonSyncEntryUriElementName' new XAttribute (FormatterConstants.JsonTypeAttributeName' JsonElementTypes.String)' string.IsNullOrEmpty (live.GetServiceMetadata ().Id) ? string.Empty : live.GetServiceMetadata ().Id)); " is 267.
Long Statement,Microsoft.Synchronization.Services.Formatters,ODataJsonWriter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\ODataJsonWriter.cs,WriteEntry,The length of the statement  "		entryMetadata.Add (new XElement (FormatterConstants.EtagElementName' new XAttribute (FormatterConstants.JsonTypeAttributeName' JsonElementTypes.String)' live.GetServiceMetadata ().ETag)); " is 187.
Long Statement,Microsoft.Synchronization.Services.Formatters,ODataJsonWriter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\ODataJsonWriter.cs,WriteEntry,The length of the statement  "		entryMetadata.Add (new XElement (FormatterConstants.EditUriElementName' new XAttribute (FormatterConstants.JsonTypeAttributeName' JsonElementTypes.String)' live.GetServiceMetadata ().EditUri)); " is 193.
Long Statement,Microsoft.Synchronization.Services.Formatters,ODataJsonWriter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\ODataJsonWriter.cs,WriteEntry,The length of the statement  "	entryMetadata.Add (new XElement (FormatterConstants.JsonSyncEntryTypeElementName' new XAttribute (FormatterConstants.JsonTypeAttributeName' JsonElementTypes.String)' typeName)); " is 177.
Long Statement,Microsoft.Synchronization.Services.Formatters,ODataJsonWriter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\ODataJsonWriter.cs,WriteEntry,The length of the statement  "		entryMetadata.Add (new XElement (FormatterConstants.IsDeletedElementName' new XAttribute (FormatterConstants.JsonTypeAttributeName' JsonElementTypes.Boolean)' true)); " is 166.
Long Statement,Microsoft.Synchronization.Services.Formatters,ODataJsonWriter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\ODataJsonWriter.cs,WriteEntityContentsToElement,The length of the statement  "			contentElement.Add (new XElement (fi.Name' new XAttribute (FormatterConstants.JsonTypeAttributeName' JsonElementTypes.Null)' null)); " is 132.
Long Statement,Microsoft.Synchronization.Services.Formatters,ODataJsonWriter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\ODataJsonWriter.cs,WriteEntityContentsToElement,The length of the statement  "		else if (fi.PropertyType == FormatterConstants.CharType || fi.PropertyType == FormatterConstants.StringType || fi.PropertyType == FormatterConstants.GuidType) { " is 160.
Long Statement,Microsoft.Synchronization.Services.Formatters,ODataJsonWriter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\ODataJsonWriter.cs,WriteEntityContentsToElement,The length of the statement  "			contentElement.Add (new XElement (fi.Name' new XAttribute (FormatterConstants.JsonTypeAttributeName' JsonElementTypes.String)' objValue)); " is 138.
Long Statement,Microsoft.Synchronization.Services.Formatters,ODataJsonWriter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\ODataJsonWriter.cs,WriteEntityContentsToElement,The length of the statement  "		else if (fi.PropertyType == FormatterConstants.DateTimeType || fi.PropertyType == FormatterConstants.TimeSpanType || fi.PropertyType == FormatterConstants.DateTimeOffsetType) { " is 176.
Long Statement,Microsoft.Synchronization.Services.Formatters,ODataJsonWriter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\ODataJsonWriter.cs,WriteEntityContentsToElement,The length of the statement  "			contentElement.Add (new XElement (fi.Name' new XAttribute (FormatterConstants.JsonTypeAttributeName' JsonElementTypes.String)' FormatterUtilities.ConvertDateTimeForType_Json (objValue' fi.PropertyType))); " is 204.
Long Statement,Microsoft.Synchronization.Services.Formatters,ODataJsonWriter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\ODataJsonWriter.cs,WriteEntityContentsToElement,The length of the statement  "			contentElement.Add (new XElement (fi.Name' new XAttribute (FormatterConstants.JsonTypeAttributeName' JsonElementTypes.Boolean)' objValue)); " is 139.
Long Statement,Microsoft.Synchronization.Services.Formatters,ODataJsonWriter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\ODataJsonWriter.cs,WriteEntityContentsToElement,The length of the statement  "			contentElement.Add (new XElement (fi.Name' new XAttribute (FormatterConstants.JsonTypeAttributeName' JsonElementTypes.String)' Convert.ToBase64String (bytes))); " is 160.
Long Statement,Microsoft.Synchronization.Services.Formatters,ODataJsonWriter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\ODataJsonWriter.cs,WriteEntityContentsToElement,The length of the statement  "		else if (fi.PropertyType.IsGenericType () && fi.PropertyType.Name.Equals (FormatterConstants.NullableTypeName' StringComparison.CurrentCultureIgnoreCase)) { " is 156.
Long Statement,Microsoft.Synchronization.Services.Formatters,ODataJsonWriter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\ODataJsonWriter.cs,WriteEntityContentsToElement,The length of the statement  "			else if (genericParamType == FormatterConstants.DateTimeType || genericParamType == FormatterConstants.TimeSpanType || genericParamType == FormatterConstants.DateTimeOffsetType) { " is 179.
Long Statement,Microsoft.Synchronization.Services.Formatters,ODataJsonWriter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\ODataJsonWriter.cs,WriteEntityContentsToElement,The length of the statement  "				contentElement.Add (new XElement (fi.Name' new XAttribute (FormatterConstants.JsonTypeAttributeName' JsonElementTypes.String)' FormatterUtilities.ConvertDateTimeForType_Json (objValue' genericParamType))); " is 205.
Long Statement,Microsoft.Synchronization.Services.Formatters,ODataJsonWriter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\ODataJsonWriter.cs,WriteEntityContentsToElement,The length of the statement  "			contentElement.Add (new XElement (fi.Name' new XAttribute (FormatterConstants.JsonTypeAttributeName' elementType)' objValue)); " is 126.
Long Statement,Microsoft.Synchronization.Services.Formatters,ODataJsonWriter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\ODataJsonWriter.cs,WriteEntityContentsToElement,The length of the statement  "			contentElement.Add (new XElement (fi.Name' new XAttribute (FormatterConstants.JsonTypeAttributeName' JsonElementTypes.Number)' objValue)); " is 138.
Long Statement,Microsoft.Synchronization.Services.Formatters,ReflectionUtility,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\ReflectionUtility.cs,GetPropertyInfoMapping,The length of the statement  "				props = props.Where (e => (!e.Name.Equals ("ServiceMetadata"' StringComparison.Ordinal) && e.GetMethod != null && e.SetMethod != null && e.DeclaringType == type)).ToArray (); " is 174.
Long Statement,Microsoft.Synchronization.Services.Formatters,ReflectionUtility,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\ReflectionUtility.cs,GetPropertyInfoMapping,The length of the statement  "				PropertyInfo[] keyFields = props.Where (e => e.GetCustomAttributes (typeof(PrimaryKeyAttribute)' true).Any ()).ToArray (); " is 122.
Long Statement,Microsoft.Synchronization.Services.Formatters,ReflectionUtility,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\ReflectionUtility.cs,GetPropertyInfoMapping,The length of the statement  "					throw new InvalidOperationException (string.Format ("Entity {0} does not have the any property marked with the [DataAnnotations.KeyAttribute]. or [SQLite.PrimaryKeyAttribute]"' type.Name)); " is 189.
Long Statement,Microsoft.Synchronization.Services.Formatters,ReflectionUtility,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\ReflectionUtility.cs,GetPropertyInfoMapping,The length of the statement  "					throw new InvalidOperationException (string.Format ("Type {0} does not have a public parameterless constructor."' type.FullName)); " is 130.
Long Statement,Microsoft.Synchronization.Services.Formatters,ReflectionUtility,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\ReflectionUtility.cs,GetObjectForType,The length of the statement  "			entityType = knownTypes.FirstOrDefault (e => e.FullName.Equals (wrapper.TypeName' StringComparison.CurrentCultureIgnoreCase)); " is 126.
Long Statement,Microsoft.Synchronization.Services.Formatters,ReflectionUtility,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\ReflectionUtility.cs,GetObjectForType,The length of the statement  "				throw new InvalidOperationException (string.Format (CultureInfo.InvariantCulture' "Unable to find a matching type for entry '{0}' in list of KnownTypes."' wrapper.TypeName)); " is 174.
Long Statement,Microsoft.Synchronization.Services.Formatters,ReflectionUtility,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\ReflectionUtility.cs,GetObjectForType,The length of the statement  "			throw new InvalidOperationException (string.Format ("Unable to find a matching type for entry '{0}' in the loaded assemblies. Specify the type name in the KnownTypes argument to the SyncReader instance."' wrapper.TypeName)); " is 224.
Long Statement,Microsoft.Synchronization.Services.Formatters,ReflectionUtility,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\ReflectionUtility.cs,GetValueFromType,The length of the statement  "	if (FormatterConstants.DateTimeType.IsAssignableFrom (type) || FormatterConstants.DateTimeOffsetType.IsAssignableFrom (type) || FormatterConstants.TimeSpanType.IsAssignableFrom (type)) " is 184.
Long Statement,Microsoft.Synchronization.Services.Formatters,ReflectionUtility,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\ReflectionUtility.cs,GetValueFromType,The length of the statement  "	if (type.IsPrimitive () || FormatterConstants.DecimalType.IsAssignableFrom (type) || FormatterConstants.FloatType.IsAssignableFrom (type)) " is 138.
Long Statement,Microsoft.Synchronization.Services.Formatters,SyncReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\SyncReader.cs,GetConflict,The length of the statement  "			Resolution = (SyncConflictResolution)Enum.Parse (FormatterConstants.SyncConflictResolutionType' currentEntryWrapper.ConflictDesc' true) " is 135.
Long Statement,Microsoft.Synchronization.Services.Formatters,SyncReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\SyncReader.cs,CheckItemType,The length of the statement  "		throw new InvalidOperationException (string.Format (CultureInfo.InvariantCulture' "{0} is not a valid {1} element."' reader.Name' type)); " is 137.
Long Statement,Microsoft.Synchronization.Services.Formatters,SyncWriter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\SyncWriter.cs,AddItem,The length of the statement  "	WriteItemInternal (entry' tempId' null/*conflicting*/' null/*conflictingTempId*/' null/*desc*/' false/*isconflict*/' emitMetadataOnly); " is 135.
Long Statement,Microsoft.Synchronization.ClientServices.SQLite,SQLiteContext,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteContext.cs,OnChangeSetUploaded,The length of the statement  "				// This approach assumes that there are not duplicates between the conflicts and the updated entities (there shouldn't be) " is 122.
Long Statement,Microsoft.Synchronization.ClientServices.SQLite,SQLiteContext,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteContext.cs,CheckSchemaAndUriAsync,The length of the statement  "				throw new ArgumentException ("Specified offlineSchema does not match database Offline schema previously used for cache path"); " is 126.
Long Statement,Microsoft.Synchronization.ClientServices.SQLite,SQLiteContext,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteContext.cs,CheckSchemaAndUriAsync,The length of the statement  "				throw new ArgumentException ("Specified offlineSchema does not match database Offline schema previously used for cache path"); " is 126.
Long Statement,Microsoft.Synchronization.ClientServices.SQLite,SQLiteHelper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteHelper.cs,CreateTriggers,The length of the statement  "		var declWhere = map.PrimaryKeys.Select (primaryKey => String.Format ("\"{0}\" = old.\"{0}\" "' primaryKey.Name)).ToList (); " is 123.
Long Statement,Microsoft.Synchronization.ClientServices.SQLite,SQLiteHelper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteHelper.cs,CreateTriggers,The length of the statement  "		String triggerInsertQuery = String.Format (SQLiteConstants.CreateTriggerAfterInsert' map.TableName' pkeysNames' pkeysNewNames); " is 127.
Long Statement,Microsoft.Synchronization.ClientServices.SQLite,SQLiteHelper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteHelper.cs,CreateTriggers,The length of the statement  "		String triggerUpdateQuery = String.Format (SQLiteConstants.CreateTriggerAfterUpdate' map.TableName' updateOrWherePkeysName); " is 124.
Long Statement,Microsoft.Synchronization.ClientServices.SQLite,SQLiteHelper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteHelper.cs,CreateTriggers,The length of the statement  "		String triggerDeleteQuery = String.Format (SQLiteConstants.CreateTriggerAfterDelete' map.TableName' updateOrWherePkeysName); " is 124.
Long Statement,Microsoft.Synchronization.ClientServices.SQLite,SQLiteHelper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteHelper.cs,DeleteTombstoneTrackingEntities,The length of the statement  "		var queryDeleteTracking = String.Format (SQLiteConstants.DeleteTrackingFromChanges' map.TableName' updateOrWherePkeysName); " is 123.
Long Statement,Microsoft.Synchronization.ClientServices.SQLite,SQLiteHelper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteHelper.cs,MergeEntities,The length of the statement  "		var queryUpdate = String.Format (SQLiteConstants.UpdateOrIgnoreFromChanges' map.TableName' declValuePairsStr' map.GetPrimaryKeysWhereClause); " is 141.
Long Statement,Microsoft.Synchronization.ClientServices.SQLite,SQLiteHelper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteHelper.cs,MergeEntities,The length of the statement  "		var queryUpdateTracking = String.Format (SQLiteConstants.InsertOrReplaceTrackingFromChanges' map.TableName' declTracking' declValuesTracking); " is 142.
Long Statement,Microsoft.Synchronization.ClientServices.SQLite,SQLiteHelper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteHelper.cs,MergeEntities,The length of the statement  "		var queryDeleteTracking = String.Format (SQLiteConstants.DeleteTrackingFromChanges' map.TableName' map.GetPrimaryKeysWhereClause); " is 130.
Long Statement,Microsoft.Synchronization.ClientServices.SQLite,SQLiteHelper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteHelper.cs,MergeEntities,The length of the statement  "		var querySelectItemPrimaryKeyFromTrackingChangesWithOemID = String.Format (SQLiteConstants.SelectItemPrimaryKeyFromTrackingChangesWithOemID' map.TableName' pkeysNames); " is 168.
Long Statement,Microsoft.Synchronization.ClientServices.SQLite,SQLiteManager,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteManager.cs,SaveConfiguration,The length of the statement  "					string stmtText = exist ? "Update ScopeInfoTable Set ServiceUri = ?' LastSyncDate = ?' Configuration = ?' AnchorBlob = ? Where ScopeName = ?;" : "Insert into ScopeInfoTable (ServiceUri' LastSyncDate' Configuration' AnchorBlob' ScopeName) Values (?' ?' ?' ?' ?);"; " is 263.
Long Statement,Microsoft.Synchronization.ClientServices.SQLite,Orm,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteManager.cs,SqlType,The length of the statement  "	if (clrType == typeof(Boolean) || clrType == typeof(Byte) || clrType == typeof(UInt16) || clrType == typeof(SByte) || clrType == typeof(Int16) || clrType == typeof(Int32)) { " is 173.
Complex Conditional,Microsoft.Synchronization.ClientServices,ValueHandle,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\ValueHandle.cs,ToSingle,The conditional expression  "(value >= Single.MinValue && value <= Single.MaxValue) || double.IsInfinity (value) || double.IsNaN (value)"  is complex.
Complex Conditional,Microsoft.Synchronization.ClientServices,XmlBufferReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlBufferReader.cs,GetQuoteCharEntity,The conditional expression  "length != 6 || iBuffer [offset + 1] != (byte)'q' || iBuffer [offset + 2] != (byte)'u' || iBuffer [offset + 3] != (byte)'o' || iBuffer [offset + 4] != (byte)'t'"  is complex.
Complex Conditional,Microsoft.Synchronization.ClientServices,XmlBufferReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlBufferReader.cs,GetAmpersandCharEntity,The conditional expression  "length != 5 || iBuffer [offset + 1] != (byte)'a' || iBuffer [offset + 2] != (byte)'m' || iBuffer [offset + 3] != (byte)'p'"  is complex.
Complex Conditional,Microsoft.Synchronization.ClientServices,XmlBufferReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlBufferReader.cs,GetApostropheCharEntity,The conditional expression  "length != 6 || iBuffer [offset + 1] != (byte)'a' || iBuffer [offset + 2] != (byte)'p' || iBuffer [offset + 3] != (byte)'o' || iBuffer [offset + 4] != (byte)'s'"  is complex.
Complex Conditional,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,TryParseDateTime,The conditional expression  "chars [offset + 4] != '-' || chars [offset + 7] != '-' || chars [offset + 10] != 'T' || chars [offset + 13] != ':' || chars [offset + 16] != ':'"  is complex.
Complex Conditional,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,TryParseDateTime,The conditional expression  "hourDelta >= 0 && (value < DateTime.MaxValue - ts) || hourDelta < 0 && (value > DateTime.MinValue - ts)"  is complex.
Complex Conditional,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,ComputeNumericalTextLength,The conditional expression  "ch == Keys.Comma || ch == Keys.RightClosingBrace || ch == Keys.RightClosingBracket || IsWhitespace (ch)"  is complex.
Complex Conditional,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,IsStartElement,The conditional expression  "slocalName == null || namespaceUri == null || this.Node.NodeType != XmlNodeType.Element && !this.IsStartElement () || !(this.Node.LocalName == slocalName)"  is complex.
Complex Conditional,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,Read,The conditional expression  "buffer [offset + 1] != Keys.LowerA || buffer [offset + 2] != Keys.LowerL || buffer [offset + 3] != Keys.LowerS || buffer [offset + 4] != Keys.LowerE"  is complex.
Complex Conditional,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,Read,The conditional expression  "TryGetByte (out ch) && !IsWhitespace (ch) && (ch != Keys.Comma && ch != Keys.RightClosingBrace) && ch != Keys.RightClosingBracket"  is complex.
Complex Conditional,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,Read,The conditional expression  "TryGetByte (out ch) && !IsWhitespace (ch) && (ch != Keys.Comma && ch != Keys.RightClosingBrace) && ch != Keys.RightClosingBracket"  is complex.
Complex Conditional,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,Read,The conditional expression  "(ch == (byte)'-') || (((byte)'0' <= ch) && (ch <= (byte)'9')) || (ch == (byte)'I') || (ch == (byte)'N')"  is complex.
Complex Conditional,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,ReadAttributes,The conditional expression  "nextByte == '-' || (nextByte <= '9' && nextByte >= '0') || nextByte == 'N' || nextByte == 'I'"  is complex.
Complex Conditional,Microsoft.Synchronization.ClientServices,XmlJsonWriter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonWriter.cs,CharacterNeedsEscaping,The conditional expression  "ch == Keys.SlashForward || ch == Keys.DoubleQuote || ch < Keys.Space || ch == Keys.BackSlash"  is complex.
Complex Conditional,Microsoft.Synchronization.ClientServices.SQLite,SQLiteHelper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteHelper.cs,BindParameter,The conditional expression  "value is Byte || value is UInt16 || value is SByte || value is Int16"  is complex.
Complex Conditional,Microsoft.Synchronization.ClientServices.SQLite,Orm,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteManager.cs,SqlType,The conditional expression  "clrType == typeof(Boolean) || clrType == typeof(Byte) || clrType == typeof(UInt16) || clrType == typeof(SByte) || clrType == typeof(Int16) || clrType == typeof(Int32)"  is complex.
Virtual Method Call from Constructor,Microsoft.Synchronization.Services.Formatters,EntryInfoWrapper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\EntryInfoWrapper.cs,EntryInfoWrapper,The constructor "EntryInfoWrapper" calls a virtual method "LoadTypeName".
Virtual Method Call from Constructor,Microsoft.Synchronization.Services.Formatters,EntryInfoWrapper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\EntryInfoWrapper.cs,EntryInfoWrapper,The constructor "EntryInfoWrapper" calls a virtual method "LoadEntryProperties".
Virtual Method Call from Constructor,Microsoft.Synchronization.Services.Formatters,EntryInfoWrapper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\EntryInfoWrapper.cs,EntryInfoWrapper,The constructor "EntryInfoWrapper" calls a virtual method "LoadConflictEntry".
Magic Number,Microsoft.Synchronization.ClientServices,ValueHandle,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\ValueHandle.cs,TryReadUnicodeChars,The following statement contains a magic number: for (int index = 0; index < charCount; ++index)  	chars [iOffset + index] = (char)this.bufferReader.GetInt16 (this.offset + index * 2);  
Magic Number,Microsoft.Synchronization.ClientServices,ValueHandle,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\ValueHandle.cs,TryReadUnicodeChars,The following statement contains a magic number: chars [iOffset + index] = (char)this.bufferReader.GetInt16 (this.offset + index * 2);  
Magic Number,Microsoft.Synchronization.ClientServices,ValueHandle,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\ValueHandle.cs,TryReadUnicodeChars,The following statement contains a magic number: this.offset += charCount * 2;  
Magic Number,Microsoft.Synchronization.ClientServices,ValueHandle,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\ValueHandle.cs,TryReadUnicodeChars,The following statement contains a magic number: this.length -= charCount * 2;  
Magic Number,Microsoft.Synchronization.ClientServices,XmlBufferReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlBufferReader.cs,Close,The following statement contains a magic number: if (streamBuffer != null && streamBuffer.Length > 4096)  	streamBuffer = null;  
Magic Number,Microsoft.Synchronization.ClientServices,XmlBufferReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlBufferReader.cs,TryEnsureBytes,The following statement contains a magic number: if (newOffsetMax > buffer.Length) {  	var numBuffer = new byte[Math.Max (newOffsetMax' buffer.Length * 2)];  	System.Buffer.BlockCopy (buffer' 0' numBuffer' 0' offsetMax);  	buffer = numBuffer;  	streamBuffer = numBuffer;  }  
Magic Number,Microsoft.Synchronization.ClientServices,XmlBufferReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlBufferReader.cs,ReadMultiByteUInt31,The following statement contains a magic number: if ((m & 248) != 0)  	throw new Exception ("XmlExceptionHelper.ThrowInvalidBinaryFormat(this.reader);");  
Magic Number,Microsoft.Synchronization.ClientServices,XmlBufferReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlBufferReader.cs,ReadUInt16,The following statement contains a magic number: Advance (2);  
Magic Number,Microsoft.Synchronization.ClientServices,XmlBufferReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlBufferReader.cs,ReadInt32,The following statement contains a magic number: Advance (4);  
Magic Number,Microsoft.Synchronization.ClientServices,XmlBufferReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlBufferReader.cs,ReadInt32,The following statement contains a magic number: return (((b4 << 8) + b3 << 8) + b2 << 8) + b1;  
Magic Number,Microsoft.Synchronization.ClientServices,XmlBufferReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlBufferReader.cs,ReadInt32,The following statement contains a magic number: return (((b4 << 8) + b3 << 8) + b2 << 8) + b1;  
Magic Number,Microsoft.Synchronization.ClientServices,XmlBufferReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlBufferReader.cs,ReadInt32,The following statement contains a magic number: return (((b4 << 8) + b3 << 8) + b2 << 8) + b1;  
Magic Number,Microsoft.Synchronization.ClientServices,XmlBufferReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlBufferReader.cs,ReadInt64,The following statement contains a magic number: return (hi << 32) + lo;  
Magic Number,Microsoft.Synchronization.ClientServices,XmlBufferReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlBufferReader.cs,ReadUniqueId,The following statement contains a magic number: Advance (16);  
Magic Number,Microsoft.Synchronization.ClientServices,XmlBufferReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlBufferReader.cs,ReadGuid,The following statement contains a magic number: GetBuffer (16' out currentOffset);  
Magic Number,Microsoft.Synchronization.ClientServices,XmlBufferReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlBufferReader.cs,ReadGuid,The following statement contains a magic number: Advance (16);  
Magic Number,Microsoft.Synchronization.ClientServices,XmlBufferReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlBufferReader.cs,GetCharBuffer,The following statement contains a magic number: if (count > 1024)  	return new char[count];  
Magic Number,Microsoft.Synchronization.ClientServices,XmlBufferReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlBufferReader.cs,GetCharEntity,The following statement contains a magic number: if (length < 3)  	throw new Exception (" XmlExceptionHelper.ThrowInvalidCharRef(this.reader);");  
Magic Number,Microsoft.Synchronization.ClientServices,XmlBufferReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlBufferReader.cs,GetCharEntity,The following statement contains a magic number: switch (buffer [offset + 1]) {  case Keys.LowerA:  	// if it's an "&amp;"  	if (numArray [iOffset + 2] == Keys.LowerM)  		return GetAmpersandCharEntity (iOffset' length);  	return GetApostropheCharEntity (iOffset' length);  case Keys.Diese:  	if (numArray [iOffset + 2] == Keys.LowerX)  		return GetHexCharEntity (iOffset' length);  	return GetDecimalCharEntity (iOffset' length);  case Keys.LowerG:  	return GetGreaterThanCharEntity (length);  case Keys.LowerL:  	return GetLessThanCharEntity (iOffset' length);  case Keys.LowerQ:  	return GetQuoteCharEntity (iOffset' length);  default:  	throw new Exception ("XmlExceptionHelper.ThrowInvalidCharRef(this.reader);");  }  
Magic Number,Microsoft.Synchronization.ClientServices,XmlBufferReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlBufferReader.cs,GetCharEntity,The following statement contains a magic number: switch (buffer [offset + 1]) {  case Keys.LowerA:  	// if it's an "&amp;"  	if (numArray [iOffset + 2] == Keys.LowerM)  		return GetAmpersandCharEntity (iOffset' length);  	return GetApostropheCharEntity (iOffset' length);  case Keys.Diese:  	if (numArray [iOffset + 2] == Keys.LowerX)  		return GetHexCharEntity (iOffset' length);  	return GetDecimalCharEntity (iOffset' length);  case Keys.LowerG:  	return GetGreaterThanCharEntity (length);  case Keys.LowerL:  	return GetLessThanCharEntity (iOffset' length);  case Keys.LowerQ:  	return GetQuoteCharEntity (iOffset' length);  default:  	throw new Exception ("XmlExceptionHelper.ThrowInvalidCharRef(this.reader);");  }  
Magic Number,Microsoft.Synchronization.ClientServices,XmlBufferReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlBufferReader.cs,GetCharEntity,The following statement contains a magic number: if (numArray [iOffset + 2] == Keys.LowerM)  	return GetAmpersandCharEntity (iOffset' length);  
Magic Number,Microsoft.Synchronization.ClientServices,XmlBufferReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlBufferReader.cs,GetCharEntity,The following statement contains a magic number: if (numArray [iOffset + 2] == Keys.LowerX)  	return GetHexCharEntity (iOffset' length);  
Magic Number,Microsoft.Synchronization.ClientServices,XmlBufferReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlBufferReader.cs,GetLessThanCharEntity,The following statement contains a magic number: if (length != 4 || iBuffer [offset + 1] != (byte)'l' || iBuffer [offset + 2] != (byte)'t')  	throw new Exception ("XmlExceptionHelper.ThrowInvalidCharRef(this.reader);");  
Magic Number,Microsoft.Synchronization.ClientServices,XmlBufferReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlBufferReader.cs,GetLessThanCharEntity,The following statement contains a magic number: if (length != 4 || iBuffer [offset + 1] != (byte)'l' || iBuffer [offset + 2] != (byte)'t')  	throw new Exception ("XmlExceptionHelper.ThrowInvalidCharRef(this.reader);");  
Magic Number,Microsoft.Synchronization.ClientServices,XmlBufferReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlBufferReader.cs,GetGreaterThanCharEntity,The following statement contains a magic number: if (length != 4 || iBuffer [offset + 1] != (byte)'g' || iBuffer [offset + 2] != (byte)'t')  	throw new Exception ("XmlExceptionHelper.ThrowInvalidCharRef(this.reader);");  
Magic Number,Microsoft.Synchronization.ClientServices,XmlBufferReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlBufferReader.cs,GetGreaterThanCharEntity,The following statement contains a magic number: if (length != 4 || iBuffer [offset + 1] != (byte)'g' || iBuffer [offset + 2] != (byte)'t')  	throw new Exception ("XmlExceptionHelper.ThrowInvalidCharRef(this.reader);");  
Magic Number,Microsoft.Synchronization.ClientServices,XmlBufferReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlBufferReader.cs,GetQuoteCharEntity,The following statement contains a magic number: if (length != 6 || iBuffer [offset + 1] != (byte)'q' || iBuffer [offset + 2] != (byte)'u' || iBuffer [offset + 3] != (byte)'o' || iBuffer [offset + 4] != (byte)'t')  	throw new Exception ("XmlExceptionHelper.ThrowInvalidCharRef(this.reader);");  
Magic Number,Microsoft.Synchronization.ClientServices,XmlBufferReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlBufferReader.cs,GetQuoteCharEntity,The following statement contains a magic number: if (length != 6 || iBuffer [offset + 1] != (byte)'q' || iBuffer [offset + 2] != (byte)'u' || iBuffer [offset + 3] != (byte)'o' || iBuffer [offset + 4] != (byte)'t')  	throw new Exception ("XmlExceptionHelper.ThrowInvalidCharRef(this.reader);");  
Magic Number,Microsoft.Synchronization.ClientServices,XmlBufferReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlBufferReader.cs,GetQuoteCharEntity,The following statement contains a magic number: if (length != 6 || iBuffer [offset + 1] != (byte)'q' || iBuffer [offset + 2] != (byte)'u' || iBuffer [offset + 3] != (byte)'o' || iBuffer [offset + 4] != (byte)'t')  	throw new Exception ("XmlExceptionHelper.ThrowInvalidCharRef(this.reader);");  
Magic Number,Microsoft.Synchronization.ClientServices,XmlBufferReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlBufferReader.cs,GetQuoteCharEntity,The following statement contains a magic number: if (length != 6 || iBuffer [offset + 1] != (byte)'q' || iBuffer [offset + 2] != (byte)'u' || iBuffer [offset + 3] != (byte)'o' || iBuffer [offset + 4] != (byte)'t')  	throw new Exception ("XmlExceptionHelper.ThrowInvalidCharRef(this.reader);");  
Magic Number,Microsoft.Synchronization.ClientServices,XmlBufferReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlBufferReader.cs,GetAmpersandCharEntity,The following statement contains a magic number: if (length != 5 || iBuffer [offset + 1] != (byte)'a' || iBuffer [offset + 2] != (byte)'m' || iBuffer [offset + 3] != (byte)'p')  	throw new Exception ("XmlExceptionHelper.ThrowInvalidCharRef(this.reader);");  
Magic Number,Microsoft.Synchronization.ClientServices,XmlBufferReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlBufferReader.cs,GetAmpersandCharEntity,The following statement contains a magic number: if (length != 5 || iBuffer [offset + 1] != (byte)'a' || iBuffer [offset + 2] != (byte)'m' || iBuffer [offset + 3] != (byte)'p')  	throw new Exception ("XmlExceptionHelper.ThrowInvalidCharRef(this.reader);");  
Magic Number,Microsoft.Synchronization.ClientServices,XmlBufferReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlBufferReader.cs,GetAmpersandCharEntity,The following statement contains a magic number: if (length != 5 || iBuffer [offset + 1] != (byte)'a' || iBuffer [offset + 2] != (byte)'m' || iBuffer [offset + 3] != (byte)'p')  	throw new Exception ("XmlExceptionHelper.ThrowInvalidCharRef(this.reader);");  
Magic Number,Microsoft.Synchronization.ClientServices,XmlBufferReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlBufferReader.cs,GetApostropheCharEntity,The following statement contains a magic number: if (length != 6 || iBuffer [offset + 1] != (byte)'a' || iBuffer [offset + 2] != (byte)'p' || iBuffer [offset + 3] != (byte)'o' || iBuffer [offset + 4] != (byte)'s')  	throw new Exception ("XmlExceptionHelper.ThrowInvalidCharRef(this.reader);");  
Magic Number,Microsoft.Synchronization.ClientServices,XmlBufferReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlBufferReader.cs,GetApostropheCharEntity,The following statement contains a magic number: if (length != 6 || iBuffer [offset + 1] != (byte)'a' || iBuffer [offset + 2] != (byte)'p' || iBuffer [offset + 3] != (byte)'o' || iBuffer [offset + 4] != (byte)'s')  	throw new Exception ("XmlExceptionHelper.ThrowInvalidCharRef(this.reader);");  
Magic Number,Microsoft.Synchronization.ClientServices,XmlBufferReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlBufferReader.cs,GetApostropheCharEntity,The following statement contains a magic number: if (length != 6 || iBuffer [offset + 1] != (byte)'a' || iBuffer [offset + 2] != (byte)'p' || iBuffer [offset + 3] != (byte)'o' || iBuffer [offset + 4] != (byte)'s')  	throw new Exception ("XmlExceptionHelper.ThrowInvalidCharRef(this.reader);");  
Magic Number,Microsoft.Synchronization.ClientServices,XmlBufferReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlBufferReader.cs,GetApostropheCharEntity,The following statement contains a magic number: if (length != 6 || iBuffer [offset + 1] != (byte)'a' || iBuffer [offset + 2] != (byte)'p' || iBuffer [offset + 3] != (byte)'o' || iBuffer [offset + 4] != (byte)'s')  	throw new Exception ("XmlExceptionHelper.ThrowInvalidCharRef(this.reader);");  
Magic Number,Microsoft.Synchronization.ClientServices,XmlBufferReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlBufferReader.cs,GetDecimalCharEntity,The following statement contains a magic number: for (int i = 2; i < length - 1; i++) {  	byte ch = iBuffer [offset + i];  	if (ch < (byte)'0' || ch > (byte)'9')  		throw new Exception ("XmlExceptionHelper.ThrowInvalidCharRef(this.reader);");  	value = value * 10 + (ch - '0');  	if (value > 1114111)  		throw new Exception ("XmlExceptionHelper.ThrowInvalidCharRef(this.reader);");  }  
Magic Number,Microsoft.Synchronization.ClientServices,XmlBufferReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlBufferReader.cs,GetDecimalCharEntity,The following statement contains a magic number: for (int i = 2; i < length - 1; i++) {  	byte ch = iBuffer [offset + i];  	if (ch < (byte)'0' || ch > (byte)'9')  		throw new Exception ("XmlExceptionHelper.ThrowInvalidCharRef(this.reader);");  	value = value * 10 + (ch - '0');  	if (value > 1114111)  		throw new Exception ("XmlExceptionHelper.ThrowInvalidCharRef(this.reader);");  }  
Magic Number,Microsoft.Synchronization.ClientServices,XmlBufferReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlBufferReader.cs,GetDecimalCharEntity,The following statement contains a magic number: for (int i = 2; i < length - 1; i++) {  	byte ch = iBuffer [offset + i];  	if (ch < (byte)'0' || ch > (byte)'9')  		throw new Exception ("XmlExceptionHelper.ThrowInvalidCharRef(this.reader);");  	value = value * 10 + (ch - '0');  	if (value > 1114111)  		throw new Exception ("XmlExceptionHelper.ThrowInvalidCharRef(this.reader);");  }  
Magic Number,Microsoft.Synchronization.ClientServices,XmlBufferReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlBufferReader.cs,GetDecimalCharEntity,The following statement contains a magic number: value = value * 10 + (ch - '0');  
Magic Number,Microsoft.Synchronization.ClientServices,XmlBufferReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlBufferReader.cs,GetDecimalCharEntity,The following statement contains a magic number: if (value > 1114111)  	throw new Exception ("XmlExceptionHelper.ThrowInvalidCharRef(this.reader);");  
Magic Number,Microsoft.Synchronization.ClientServices,XmlBufferReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlBufferReader.cs,GetHexCharEntity,The following statement contains a magic number: for (int i = 3; i < length - 1; i++) {  	byte ch = iBuffer [offset + i];  	int digit;  	if (ch >= '0' && ch <= '9')  		digit = (ch - '0');  	else if (ch >= 'a' && ch <= 'f')  		digit = 10 + (ch - 'a');  	else if (ch >= 'A' && ch <= 'F')  		digit = 10 + (ch - 'A');  	else  		throw new Exception (" XmlExceptionHelper.ThrowInvalidCharRef(this.reader);");  	value = value * 16 + digit;  	if (value > 1114111)  		throw new Exception (" XmlExceptionHelper.ThrowInvalidCharRef(this.reader);");  }  
Magic Number,Microsoft.Synchronization.ClientServices,XmlBufferReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlBufferReader.cs,GetHexCharEntity,The following statement contains a magic number: for (int i = 3; i < length - 1; i++) {  	byte ch = iBuffer [offset + i];  	int digit;  	if (ch >= '0' && ch <= '9')  		digit = (ch - '0');  	else if (ch >= 'a' && ch <= 'f')  		digit = 10 + (ch - 'a');  	else if (ch >= 'A' && ch <= 'F')  		digit = 10 + (ch - 'A');  	else  		throw new Exception (" XmlExceptionHelper.ThrowInvalidCharRef(this.reader);");  	value = value * 16 + digit;  	if (value > 1114111)  		throw new Exception (" XmlExceptionHelper.ThrowInvalidCharRef(this.reader);");  }  
Magic Number,Microsoft.Synchronization.ClientServices,XmlBufferReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlBufferReader.cs,GetHexCharEntity,The following statement contains a magic number: for (int i = 3; i < length - 1; i++) {  	byte ch = iBuffer [offset + i];  	int digit;  	if (ch >= '0' && ch <= '9')  		digit = (ch - '0');  	else if (ch >= 'a' && ch <= 'f')  		digit = 10 + (ch - 'a');  	else if (ch >= 'A' && ch <= 'F')  		digit = 10 + (ch - 'A');  	else  		throw new Exception (" XmlExceptionHelper.ThrowInvalidCharRef(this.reader);");  	value = value * 16 + digit;  	if (value > 1114111)  		throw new Exception (" XmlExceptionHelper.ThrowInvalidCharRef(this.reader);");  }  
Magic Number,Microsoft.Synchronization.ClientServices,XmlBufferReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlBufferReader.cs,GetHexCharEntity,The following statement contains a magic number: for (int i = 3; i < length - 1; i++) {  	byte ch = iBuffer [offset + i];  	int digit;  	if (ch >= '0' && ch <= '9')  		digit = (ch - '0');  	else if (ch >= 'a' && ch <= 'f')  		digit = 10 + (ch - 'a');  	else if (ch >= 'A' && ch <= 'F')  		digit = 10 + (ch - 'A');  	else  		throw new Exception (" XmlExceptionHelper.ThrowInvalidCharRef(this.reader);");  	value = value * 16 + digit;  	if (value > 1114111)  		throw new Exception (" XmlExceptionHelper.ThrowInvalidCharRef(this.reader);");  }  
Magic Number,Microsoft.Synchronization.ClientServices,XmlBufferReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlBufferReader.cs,GetHexCharEntity,The following statement contains a magic number: for (int i = 3; i < length - 1; i++) {  	byte ch = iBuffer [offset + i];  	int digit;  	if (ch >= '0' && ch <= '9')  		digit = (ch - '0');  	else if (ch >= 'a' && ch <= 'f')  		digit = 10 + (ch - 'a');  	else if (ch >= 'A' && ch <= 'F')  		digit = 10 + (ch - 'A');  	else  		throw new Exception (" XmlExceptionHelper.ThrowInvalidCharRef(this.reader);");  	value = value * 16 + digit;  	if (value > 1114111)  		throw new Exception (" XmlExceptionHelper.ThrowInvalidCharRef(this.reader);");  }  
Magic Number,Microsoft.Synchronization.ClientServices,XmlBufferReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlBufferReader.cs,GetHexCharEntity,The following statement contains a magic number: if (ch >= '0' && ch <= '9')  	digit = (ch - '0');  else if (ch >= 'a' && ch <= 'f')  	digit = 10 + (ch - 'a');  else if (ch >= 'A' && ch <= 'F')  	digit = 10 + (ch - 'A');  else  	throw new Exception (" XmlExceptionHelper.ThrowInvalidCharRef(this.reader);");  
Magic Number,Microsoft.Synchronization.ClientServices,XmlBufferReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlBufferReader.cs,GetHexCharEntity,The following statement contains a magic number: if (ch >= '0' && ch <= '9')  	digit = (ch - '0');  else if (ch >= 'a' && ch <= 'f')  	digit = 10 + (ch - 'a');  else if (ch >= 'A' && ch <= 'F')  	digit = 10 + (ch - 'A');  else  	throw new Exception (" XmlExceptionHelper.ThrowInvalidCharRef(this.reader);");  
Magic Number,Microsoft.Synchronization.ClientServices,XmlBufferReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlBufferReader.cs,GetHexCharEntity,The following statement contains a magic number: if (ch >= 'a' && ch <= 'f')  	digit = 10 + (ch - 'a');  else if (ch >= 'A' && ch <= 'F')  	digit = 10 + (ch - 'A');  else  	throw new Exception (" XmlExceptionHelper.ThrowInvalidCharRef(this.reader);");  
Magic Number,Microsoft.Synchronization.ClientServices,XmlBufferReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlBufferReader.cs,GetHexCharEntity,The following statement contains a magic number: if (ch >= 'a' && ch <= 'f')  	digit = 10 + (ch - 'a');  else if (ch >= 'A' && ch <= 'F')  	digit = 10 + (ch - 'A');  else  	throw new Exception (" XmlExceptionHelper.ThrowInvalidCharRef(this.reader);");  
Magic Number,Microsoft.Synchronization.ClientServices,XmlBufferReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlBufferReader.cs,GetHexCharEntity,The following statement contains a magic number: digit = 10 + (ch - 'a');  
Magic Number,Microsoft.Synchronization.ClientServices,XmlBufferReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlBufferReader.cs,GetHexCharEntity,The following statement contains a magic number: if (ch >= 'A' && ch <= 'F')  	digit = 10 + (ch - 'A');  else  	throw new Exception (" XmlExceptionHelper.ThrowInvalidCharRef(this.reader);");  
Magic Number,Microsoft.Synchronization.ClientServices,XmlBufferReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlBufferReader.cs,GetHexCharEntity,The following statement contains a magic number: digit = 10 + (ch - 'A');  
Magic Number,Microsoft.Synchronization.ClientServices,XmlBufferReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlBufferReader.cs,GetHexCharEntity,The following statement contains a magic number: value = value * 16 + digit;  
Magic Number,Microsoft.Synchronization.ClientServices,XmlBufferReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlBufferReader.cs,GetHexCharEntity,The following statement contains a magic number: if (value > 1114111)  	throw new Exception (" XmlExceptionHelper.ThrowInvalidCharRef(this.reader);");  
Magic Number,Microsoft.Synchronization.ClientServices,XmlBufferReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlBufferReader.cs,GetInt16,The following statement contains a magic number: return (short)(numArray [iOffset] + (numArray [iOffset + 1] << 8));  
Magic Number,Microsoft.Synchronization.ClientServices,XmlBufferReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlBufferReader.cs,GetGuid,The following statement contains a magic number: if (guid == null)  	guid = new byte[16];  
Magic Number,Microsoft.Synchronization.ClientServices,XmlBufferReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlBufferReader.cs,GetGuid,The following statement contains a magic number: guid = new byte[16];  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,TryParseInt32,The following statement contains a magic number: if (chars [offset] == '-') {  	if (count == 1)  		return false;  	for (int i = offset + 1; i < offsetMax; i++) {  		int digit = (chars [i] - '0');  		if ((uint)digit > 9)  			return false;  		if (value < int.MinValue / 10)  			return false;  		value *= 10;  		if (value < int.MinValue + digit)  			return false;  		value -= digit;  	}  }  else {  	for (int i = offset; i < offsetMax; i++) {  		int digit = (chars [i] - '0');  		if ((uint)digit > 9)  			return false;  		if (value > int.MaxValue / 10)  			return false;  		value *= 10;  		if (value > int.MaxValue - digit)  			return false;  		value += digit;  	}  }  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,TryParseInt32,The following statement contains a magic number: if (chars [offset] == '-') {  	if (count == 1)  		return false;  	for (int i = offset + 1; i < offsetMax; i++) {  		int digit = (chars [i] - '0');  		if ((uint)digit > 9)  			return false;  		if (value < int.MinValue / 10)  			return false;  		value *= 10;  		if (value < int.MinValue + digit)  			return false;  		value -= digit;  	}  }  else {  	for (int i = offset; i < offsetMax; i++) {  		int digit = (chars [i] - '0');  		if ((uint)digit > 9)  			return false;  		if (value > int.MaxValue / 10)  			return false;  		value *= 10;  		if (value > int.MaxValue - digit)  			return false;  		value += digit;  	}  }  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,TryParseInt32,The following statement contains a magic number: if (chars [offset] == '-') {  	if (count == 1)  		return false;  	for (int i = offset + 1; i < offsetMax; i++) {  		int digit = (chars [i] - '0');  		if ((uint)digit > 9)  			return false;  		if (value < int.MinValue / 10)  			return false;  		value *= 10;  		if (value < int.MinValue + digit)  			return false;  		value -= digit;  	}  }  else {  	for (int i = offset; i < offsetMax; i++) {  		int digit = (chars [i] - '0');  		if ((uint)digit > 9)  			return false;  		if (value > int.MaxValue / 10)  			return false;  		value *= 10;  		if (value > int.MaxValue - digit)  			return false;  		value += digit;  	}  }  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,TryParseInt32,The following statement contains a magic number: if (chars [offset] == '-') {  	if (count == 1)  		return false;  	for (int i = offset + 1; i < offsetMax; i++) {  		int digit = (chars [i] - '0');  		if ((uint)digit > 9)  			return false;  		if (value < int.MinValue / 10)  			return false;  		value *= 10;  		if (value < int.MinValue + digit)  			return false;  		value -= digit;  	}  }  else {  	for (int i = offset; i < offsetMax; i++) {  		int digit = (chars [i] - '0');  		if ((uint)digit > 9)  			return false;  		if (value > int.MaxValue / 10)  			return false;  		value *= 10;  		if (value > int.MaxValue - digit)  			return false;  		value += digit;  	}  }  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,TryParseInt32,The following statement contains a magic number: if (chars [offset] == '-') {  	if (count == 1)  		return false;  	for (int i = offset + 1; i < offsetMax; i++) {  		int digit = (chars [i] - '0');  		if ((uint)digit > 9)  			return false;  		if (value < int.MinValue / 10)  			return false;  		value *= 10;  		if (value < int.MinValue + digit)  			return false;  		value -= digit;  	}  }  else {  	for (int i = offset; i < offsetMax; i++) {  		int digit = (chars [i] - '0');  		if ((uint)digit > 9)  			return false;  		if (value > int.MaxValue / 10)  			return false;  		value *= 10;  		if (value > int.MaxValue - digit)  			return false;  		value += digit;  	}  }  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,TryParseInt32,The following statement contains a magic number: if (chars [offset] == '-') {  	if (count == 1)  		return false;  	for (int i = offset + 1; i < offsetMax; i++) {  		int digit = (chars [i] - '0');  		if ((uint)digit > 9)  			return false;  		if (value < int.MinValue / 10)  			return false;  		value *= 10;  		if (value < int.MinValue + digit)  			return false;  		value -= digit;  	}  }  else {  	for (int i = offset; i < offsetMax; i++) {  		int digit = (chars [i] - '0');  		if ((uint)digit > 9)  			return false;  		if (value > int.MaxValue / 10)  			return false;  		value *= 10;  		if (value > int.MaxValue - digit)  			return false;  		value += digit;  	}  }  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,TryParseInt32,The following statement contains a magic number: for (int i = offset + 1; i < offsetMax; i++) {  	int digit = (chars [i] - '0');  	if ((uint)digit > 9)  		return false;  	if (value < int.MinValue / 10)  		return false;  	value *= 10;  	if (value < int.MinValue + digit)  		return false;  	value -= digit;  }  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,TryParseInt32,The following statement contains a magic number: for (int i = offset + 1; i < offsetMax; i++) {  	int digit = (chars [i] - '0');  	if ((uint)digit > 9)  		return false;  	if (value < int.MinValue / 10)  		return false;  	value *= 10;  	if (value < int.MinValue + digit)  		return false;  	value -= digit;  }  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,TryParseInt32,The following statement contains a magic number: for (int i = offset + 1; i < offsetMax; i++) {  	int digit = (chars [i] - '0');  	if ((uint)digit > 9)  		return false;  	if (value < int.MinValue / 10)  		return false;  	value *= 10;  	if (value < int.MinValue + digit)  		return false;  	value -= digit;  }  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,TryParseInt32,The following statement contains a magic number: if ((uint)digit > 9)  	return false;  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,TryParseInt32,The following statement contains a magic number: if (value < int.MinValue / 10)  	return false;  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,TryParseInt32,The following statement contains a magic number: value *= 10;  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,TryParseInt32,The following statement contains a magic number: for (int i = offset; i < offsetMax; i++) {  	int digit = (chars [i] - '0');  	if ((uint)digit > 9)  		return false;  	if (value > int.MaxValue / 10)  		return false;  	value *= 10;  	if (value > int.MaxValue - digit)  		return false;  	value += digit;  }  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,TryParseInt32,The following statement contains a magic number: for (int i = offset; i < offsetMax; i++) {  	int digit = (chars [i] - '0');  	if ((uint)digit > 9)  		return false;  	if (value > int.MaxValue / 10)  		return false;  	value *= 10;  	if (value > int.MaxValue - digit)  		return false;  	value += digit;  }  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,TryParseInt32,The following statement contains a magic number: for (int i = offset; i < offsetMax; i++) {  	int digit = (chars [i] - '0');  	if ((uint)digit > 9)  		return false;  	if (value > int.MaxValue / 10)  		return false;  	value *= 10;  	if (value > int.MaxValue - digit)  		return false;  	value += digit;  }  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,TryParseInt32,The following statement contains a magic number: if ((uint)digit > 9)  	return false;  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,TryParseInt32,The following statement contains a magic number: if (value > int.MaxValue / 10)  	return false;  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,TryParseInt32,The following statement contains a magic number: value *= 10;  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,TryParseInt64,The following statement contains a magic number: if (count < 11) {  	int value;  	if (!TryParseInt32 (chars' offset' count' out value))  		return false;  	result = value;  	return true;  }  else {  	long value = 0;  	int offsetMax = offset + count;  	if (chars [offset] == '-') {  		if (count == 1)  			return false;  		for (int i = offset + 1; i < offsetMax; i++) {  			int digit = (chars [i] - '0');  			if ((uint)digit > 9)  				return false;  			if (value < long.MinValue / 10)  				return false;  			value *= 10;  			if (value < long.MinValue + digit)  				return false;  			value -= digit;  		}  	}  	else {  		for (int i = offset; i < offsetMax; i++) {  			int digit = (chars [i] - '0');  			if ((uint)digit > 9)  				return false;  			if (value > long.MaxValue / 10)  				return false;  			value *= 10;  			if (value > long.MaxValue - digit)  				return false;  			value += digit;  		}  	}  	result = value;  	return true;  }  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,TryParseInt64,The following statement contains a magic number: if (count < 11) {  	int value;  	if (!TryParseInt32 (chars' offset' count' out value))  		return false;  	result = value;  	return true;  }  else {  	long value = 0;  	int offsetMax = offset + count;  	if (chars [offset] == '-') {  		if (count == 1)  			return false;  		for (int i = offset + 1; i < offsetMax; i++) {  			int digit = (chars [i] - '0');  			if ((uint)digit > 9)  				return false;  			if (value < long.MinValue / 10)  				return false;  			value *= 10;  			if (value < long.MinValue + digit)  				return false;  			value -= digit;  		}  	}  	else {  		for (int i = offset; i < offsetMax; i++) {  			int digit = (chars [i] - '0');  			if ((uint)digit > 9)  				return false;  			if (value > long.MaxValue / 10)  				return false;  			value *= 10;  			if (value > long.MaxValue - digit)  				return false;  			value += digit;  		}  	}  	result = value;  	return true;  }  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,TryParseInt64,The following statement contains a magic number: if (count < 11) {  	int value;  	if (!TryParseInt32 (chars' offset' count' out value))  		return false;  	result = value;  	return true;  }  else {  	long value = 0;  	int offsetMax = offset + count;  	if (chars [offset] == '-') {  		if (count == 1)  			return false;  		for (int i = offset + 1; i < offsetMax; i++) {  			int digit = (chars [i] - '0');  			if ((uint)digit > 9)  				return false;  			if (value < long.MinValue / 10)  				return false;  			value *= 10;  			if (value < long.MinValue + digit)  				return false;  			value -= digit;  		}  	}  	else {  		for (int i = offset; i < offsetMax; i++) {  			int digit = (chars [i] - '0');  			if ((uint)digit > 9)  				return false;  			if (value > long.MaxValue / 10)  				return false;  			value *= 10;  			if (value > long.MaxValue - digit)  				return false;  			value += digit;  		}  	}  	result = value;  	return true;  }  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,TryParseInt64,The following statement contains a magic number: if (count < 11) {  	int value;  	if (!TryParseInt32 (chars' offset' count' out value))  		return false;  	result = value;  	return true;  }  else {  	long value = 0;  	int offsetMax = offset + count;  	if (chars [offset] == '-') {  		if (count == 1)  			return false;  		for (int i = offset + 1; i < offsetMax; i++) {  			int digit = (chars [i] - '0');  			if ((uint)digit > 9)  				return false;  			if (value < long.MinValue / 10)  				return false;  			value *= 10;  			if (value < long.MinValue + digit)  				return false;  			value -= digit;  		}  	}  	else {  		for (int i = offset; i < offsetMax; i++) {  			int digit = (chars [i] - '0');  			if ((uint)digit > 9)  				return false;  			if (value > long.MaxValue / 10)  				return false;  			value *= 10;  			if (value > long.MaxValue - digit)  				return false;  			value += digit;  		}  	}  	result = value;  	return true;  }  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,TryParseInt64,The following statement contains a magic number: if (count < 11) {  	int value;  	if (!TryParseInt32 (chars' offset' count' out value))  		return false;  	result = value;  	return true;  }  else {  	long value = 0;  	int offsetMax = offset + count;  	if (chars [offset] == '-') {  		if (count == 1)  			return false;  		for (int i = offset + 1; i < offsetMax; i++) {  			int digit = (chars [i] - '0');  			if ((uint)digit > 9)  				return false;  			if (value < long.MinValue / 10)  				return false;  			value *= 10;  			if (value < long.MinValue + digit)  				return false;  			value -= digit;  		}  	}  	else {  		for (int i = offset; i < offsetMax; i++) {  			int digit = (chars [i] - '0');  			if ((uint)digit > 9)  				return false;  			if (value > long.MaxValue / 10)  				return false;  			value *= 10;  			if (value > long.MaxValue - digit)  				return false;  			value += digit;  		}  	}  	result = value;  	return true;  }  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,TryParseInt64,The following statement contains a magic number: if (count < 11) {  	int value;  	if (!TryParseInt32 (chars' offset' count' out value))  		return false;  	result = value;  	return true;  }  else {  	long value = 0;  	int offsetMax = offset + count;  	if (chars [offset] == '-') {  		if (count == 1)  			return false;  		for (int i = offset + 1; i < offsetMax; i++) {  			int digit = (chars [i] - '0');  			if ((uint)digit > 9)  				return false;  			if (value < long.MinValue / 10)  				return false;  			value *= 10;  			if (value < long.MinValue + digit)  				return false;  			value -= digit;  		}  	}  	else {  		for (int i = offset; i < offsetMax; i++) {  			int digit = (chars [i] - '0');  			if ((uint)digit > 9)  				return false;  			if (value > long.MaxValue / 10)  				return false;  			value *= 10;  			if (value > long.MaxValue - digit)  				return false;  			value += digit;  		}  	}  	result = value;  	return true;  }  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,TryParseInt64,The following statement contains a magic number: if (count < 11) {  	int value;  	if (!TryParseInt32 (chars' offset' count' out value))  		return false;  	result = value;  	return true;  }  else {  	long value = 0;  	int offsetMax = offset + count;  	if (chars [offset] == '-') {  		if (count == 1)  			return false;  		for (int i = offset + 1; i < offsetMax; i++) {  			int digit = (chars [i] - '0');  			if ((uint)digit > 9)  				return false;  			if (value < long.MinValue / 10)  				return false;  			value *= 10;  			if (value < long.MinValue + digit)  				return false;  			value -= digit;  		}  	}  	else {  		for (int i = offset; i < offsetMax; i++) {  			int digit = (chars [i] - '0');  			if ((uint)digit > 9)  				return false;  			if (value > long.MaxValue / 10)  				return false;  			value *= 10;  			if (value > long.MaxValue - digit)  				return false;  			value += digit;  		}  	}  	result = value;  	return true;  }  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,TryParseInt64,The following statement contains a magic number: if (chars [offset] == '-') {  	if (count == 1)  		return false;  	for (int i = offset + 1; i < offsetMax; i++) {  		int digit = (chars [i] - '0');  		if ((uint)digit > 9)  			return false;  		if (value < long.MinValue / 10)  			return false;  		value *= 10;  		if (value < long.MinValue + digit)  			return false;  		value -= digit;  	}  }  else {  	for (int i = offset; i < offsetMax; i++) {  		int digit = (chars [i] - '0');  		if ((uint)digit > 9)  			return false;  		if (value > long.MaxValue / 10)  			return false;  		value *= 10;  		if (value > long.MaxValue - digit)  			return false;  		value += digit;  	}  }  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,TryParseInt64,The following statement contains a magic number: if (chars [offset] == '-') {  	if (count == 1)  		return false;  	for (int i = offset + 1; i < offsetMax; i++) {  		int digit = (chars [i] - '0');  		if ((uint)digit > 9)  			return false;  		if (value < long.MinValue / 10)  			return false;  		value *= 10;  		if (value < long.MinValue + digit)  			return false;  		value -= digit;  	}  }  else {  	for (int i = offset; i < offsetMax; i++) {  		int digit = (chars [i] - '0');  		if ((uint)digit > 9)  			return false;  		if (value > long.MaxValue / 10)  			return false;  		value *= 10;  		if (value > long.MaxValue - digit)  			return false;  		value += digit;  	}  }  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,TryParseInt64,The following statement contains a magic number: if (chars [offset] == '-') {  	if (count == 1)  		return false;  	for (int i = offset + 1; i < offsetMax; i++) {  		int digit = (chars [i] - '0');  		if ((uint)digit > 9)  			return false;  		if (value < long.MinValue / 10)  			return false;  		value *= 10;  		if (value < long.MinValue + digit)  			return false;  		value -= digit;  	}  }  else {  	for (int i = offset; i < offsetMax; i++) {  		int digit = (chars [i] - '0');  		if ((uint)digit > 9)  			return false;  		if (value > long.MaxValue / 10)  			return false;  		value *= 10;  		if (value > long.MaxValue - digit)  			return false;  		value += digit;  	}  }  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,TryParseInt64,The following statement contains a magic number: if (chars [offset] == '-') {  	if (count == 1)  		return false;  	for (int i = offset + 1; i < offsetMax; i++) {  		int digit = (chars [i] - '0');  		if ((uint)digit > 9)  			return false;  		if (value < long.MinValue / 10)  			return false;  		value *= 10;  		if (value < long.MinValue + digit)  			return false;  		value -= digit;  	}  }  else {  	for (int i = offset; i < offsetMax; i++) {  		int digit = (chars [i] - '0');  		if ((uint)digit > 9)  			return false;  		if (value > long.MaxValue / 10)  			return false;  		value *= 10;  		if (value > long.MaxValue - digit)  			return false;  		value += digit;  	}  }  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,TryParseInt64,The following statement contains a magic number: if (chars [offset] == '-') {  	if (count == 1)  		return false;  	for (int i = offset + 1; i < offsetMax; i++) {  		int digit = (chars [i] - '0');  		if ((uint)digit > 9)  			return false;  		if (value < long.MinValue / 10)  			return false;  		value *= 10;  		if (value < long.MinValue + digit)  			return false;  		value -= digit;  	}  }  else {  	for (int i = offset; i < offsetMax; i++) {  		int digit = (chars [i] - '0');  		if ((uint)digit > 9)  			return false;  		if (value > long.MaxValue / 10)  			return false;  		value *= 10;  		if (value > long.MaxValue - digit)  			return false;  		value += digit;  	}  }  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,TryParseInt64,The following statement contains a magic number: if (chars [offset] == '-') {  	if (count == 1)  		return false;  	for (int i = offset + 1; i < offsetMax; i++) {  		int digit = (chars [i] - '0');  		if ((uint)digit > 9)  			return false;  		if (value < long.MinValue / 10)  			return false;  		value *= 10;  		if (value < long.MinValue + digit)  			return false;  		value -= digit;  	}  }  else {  	for (int i = offset; i < offsetMax; i++) {  		int digit = (chars [i] - '0');  		if ((uint)digit > 9)  			return false;  		if (value > long.MaxValue / 10)  			return false;  		value *= 10;  		if (value > long.MaxValue - digit)  			return false;  		value += digit;  	}  }  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,TryParseInt64,The following statement contains a magic number: for (int i = offset + 1; i < offsetMax; i++) {  	int digit = (chars [i] - '0');  	if ((uint)digit > 9)  		return false;  	if (value < long.MinValue / 10)  		return false;  	value *= 10;  	if (value < long.MinValue + digit)  		return false;  	value -= digit;  }  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,TryParseInt64,The following statement contains a magic number: for (int i = offset + 1; i < offsetMax; i++) {  	int digit = (chars [i] - '0');  	if ((uint)digit > 9)  		return false;  	if (value < long.MinValue / 10)  		return false;  	value *= 10;  	if (value < long.MinValue + digit)  		return false;  	value -= digit;  }  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,TryParseInt64,The following statement contains a magic number: for (int i = offset + 1; i < offsetMax; i++) {  	int digit = (chars [i] - '0');  	if ((uint)digit > 9)  		return false;  	if (value < long.MinValue / 10)  		return false;  	value *= 10;  	if (value < long.MinValue + digit)  		return false;  	value -= digit;  }  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,TryParseInt64,The following statement contains a magic number: if ((uint)digit > 9)  	return false;  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,TryParseInt64,The following statement contains a magic number: if (value < long.MinValue / 10)  	return false;  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,TryParseInt64,The following statement contains a magic number: value *= 10;  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,TryParseInt64,The following statement contains a magic number: for (int i = offset; i < offsetMax; i++) {  	int digit = (chars [i] - '0');  	if ((uint)digit > 9)  		return false;  	if (value > long.MaxValue / 10)  		return false;  	value *= 10;  	if (value > long.MaxValue - digit)  		return false;  	value += digit;  }  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,TryParseInt64,The following statement contains a magic number: for (int i = offset; i < offsetMax; i++) {  	int digit = (chars [i] - '0');  	if ((uint)digit > 9)  		return false;  	if (value > long.MaxValue / 10)  		return false;  	value *= 10;  	if (value > long.MaxValue - digit)  		return false;  	value += digit;  }  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,TryParseInt64,The following statement contains a magic number: for (int i = offset; i < offsetMax; i++) {  	int digit = (chars [i] - '0');  	if ((uint)digit > 9)  		return false;  	if (value > long.MaxValue / 10)  		return false;  	value *= 10;  	if (value > long.MaxValue - digit)  		return false;  	value += digit;  }  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,TryParseInt64,The following statement contains a magic number: if ((uint)digit > 9)  	return false;  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,TryParseInt64,The following statement contains a magic number: if (value > long.MaxValue / 10)  	return false;  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,TryParseInt64,The following statement contains a magic number: value *= 10;  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,TryParseSingle,The following statement contains a magic number: if (count < 1 || count > 10)  	return false;  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,TryParseSingle,The following statement contains a magic number: while (offset < offsetMax) {  	int ch = (chars [offset] - '0');  	if (ch == ('.' - '0')) {  		offset++;  		int pow10 = 1;  		while (offset < offsetMax) {  			ch = chars [offset] - '0';  			if (((uint)ch) >= 10)  				return false;  			pow10 *= 10;  			value = value * 10 + ch;  			offset++;  		}  		// More than 8 characters (7 sig figs and a decimal) and int -> float conversion is lossy' so use double   		if (count > 8)  			result = (float)(value / (double)pow10);  		else  			result = (float)value / pow10;  		if (negative)  			result = -result;  		return true;  	}  	if (((uint)ch) >= 10)  		return false;  	value = value * 10 + ch;  	offset++;  }  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,TryParseSingle,The following statement contains a magic number: while (offset < offsetMax) {  	int ch = (chars [offset] - '0');  	if (ch == ('.' - '0')) {  		offset++;  		int pow10 = 1;  		while (offset < offsetMax) {  			ch = chars [offset] - '0';  			if (((uint)ch) >= 10)  				return false;  			pow10 *= 10;  			value = value * 10 + ch;  			offset++;  		}  		// More than 8 characters (7 sig figs and a decimal) and int -> float conversion is lossy' so use double   		if (count > 8)  			result = (float)(value / (double)pow10);  		else  			result = (float)value / pow10;  		if (negative)  			result = -result;  		return true;  	}  	if (((uint)ch) >= 10)  		return false;  	value = value * 10 + ch;  	offset++;  }  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,TryParseSingle,The following statement contains a magic number: while (offset < offsetMax) {  	int ch = (chars [offset] - '0');  	if (ch == ('.' - '0')) {  		offset++;  		int pow10 = 1;  		while (offset < offsetMax) {  			ch = chars [offset] - '0';  			if (((uint)ch) >= 10)  				return false;  			pow10 *= 10;  			value = value * 10 + ch;  			offset++;  		}  		// More than 8 characters (7 sig figs and a decimal) and int -> float conversion is lossy' so use double   		if (count > 8)  			result = (float)(value / (double)pow10);  		else  			result = (float)value / pow10;  		if (negative)  			result = -result;  		return true;  	}  	if (((uint)ch) >= 10)  		return false;  	value = value * 10 + ch;  	offset++;  }  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,TryParseSingle,The following statement contains a magic number: while (offset < offsetMax) {  	int ch = (chars [offset] - '0');  	if (ch == ('.' - '0')) {  		offset++;  		int pow10 = 1;  		while (offset < offsetMax) {  			ch = chars [offset] - '0';  			if (((uint)ch) >= 10)  				return false;  			pow10 *= 10;  			value = value * 10 + ch;  			offset++;  		}  		// More than 8 characters (7 sig figs and a decimal) and int -> float conversion is lossy' so use double   		if (count > 8)  			result = (float)(value / (double)pow10);  		else  			result = (float)value / pow10;  		if (negative)  			result = -result;  		return true;  	}  	if (((uint)ch) >= 10)  		return false;  	value = value * 10 + ch;  	offset++;  }  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,TryParseSingle,The following statement contains a magic number: while (offset < offsetMax) {  	int ch = (chars [offset] - '0');  	if (ch == ('.' - '0')) {  		offset++;  		int pow10 = 1;  		while (offset < offsetMax) {  			ch = chars [offset] - '0';  			if (((uint)ch) >= 10)  				return false;  			pow10 *= 10;  			value = value * 10 + ch;  			offset++;  		}  		// More than 8 characters (7 sig figs and a decimal) and int -> float conversion is lossy' so use double   		if (count > 8)  			result = (float)(value / (double)pow10);  		else  			result = (float)value / pow10;  		if (negative)  			result = -result;  		return true;  	}  	if (((uint)ch) >= 10)  		return false;  	value = value * 10 + ch;  	offset++;  }  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,TryParseSingle,The following statement contains a magic number: while (offset < offsetMax) {  	int ch = (chars [offset] - '0');  	if (ch == ('.' - '0')) {  		offset++;  		int pow10 = 1;  		while (offset < offsetMax) {  			ch = chars [offset] - '0';  			if (((uint)ch) >= 10)  				return false;  			pow10 *= 10;  			value = value * 10 + ch;  			offset++;  		}  		// More than 8 characters (7 sig figs and a decimal) and int -> float conversion is lossy' so use double   		if (count > 8)  			result = (float)(value / (double)pow10);  		else  			result = (float)value / pow10;  		if (negative)  			result = -result;  		return true;  	}  	if (((uint)ch) >= 10)  		return false;  	value = value * 10 + ch;  	offset++;  }  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,TryParseSingle,The following statement contains a magic number: if (ch == ('.' - '0')) {  	offset++;  	int pow10 = 1;  	while (offset < offsetMax) {  		ch = chars [offset] - '0';  		if (((uint)ch) >= 10)  			return false;  		pow10 *= 10;  		value = value * 10 + ch;  		offset++;  	}  	// More than 8 characters (7 sig figs and a decimal) and int -> float conversion is lossy' so use double   	if (count > 8)  		result = (float)(value / (double)pow10);  	else  		result = (float)value / pow10;  	if (negative)  		result = -result;  	return true;  }  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,TryParseSingle,The following statement contains a magic number: if (ch == ('.' - '0')) {  	offset++;  	int pow10 = 1;  	while (offset < offsetMax) {  		ch = chars [offset] - '0';  		if (((uint)ch) >= 10)  			return false;  		pow10 *= 10;  		value = value * 10 + ch;  		offset++;  	}  	// More than 8 characters (7 sig figs and a decimal) and int -> float conversion is lossy' so use double   	if (count > 8)  		result = (float)(value / (double)pow10);  	else  		result = (float)value / pow10;  	if (negative)  		result = -result;  	return true;  }  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,TryParseSingle,The following statement contains a magic number: if (ch == ('.' - '0')) {  	offset++;  	int pow10 = 1;  	while (offset < offsetMax) {  		ch = chars [offset] - '0';  		if (((uint)ch) >= 10)  			return false;  		pow10 *= 10;  		value = value * 10 + ch;  		offset++;  	}  	// More than 8 characters (7 sig figs and a decimal) and int -> float conversion is lossy' so use double   	if (count > 8)  		result = (float)(value / (double)pow10);  	else  		result = (float)value / pow10;  	if (negative)  		result = -result;  	return true;  }  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,TryParseSingle,The following statement contains a magic number: if (ch == ('.' - '0')) {  	offset++;  	int pow10 = 1;  	while (offset < offsetMax) {  		ch = chars [offset] - '0';  		if (((uint)ch) >= 10)  			return false;  		pow10 *= 10;  		value = value * 10 + ch;  		offset++;  	}  	// More than 8 characters (7 sig figs and a decimal) and int -> float conversion is lossy' so use double   	if (count > 8)  		result = (float)(value / (double)pow10);  	else  		result = (float)value / pow10;  	if (negative)  		result = -result;  	return true;  }  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,TryParseSingle,The following statement contains a magic number: while (offset < offsetMax) {  	ch = chars [offset] - '0';  	if (((uint)ch) >= 10)  		return false;  	pow10 *= 10;  	value = value * 10 + ch;  	offset++;  }  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,TryParseSingle,The following statement contains a magic number: while (offset < offsetMax) {  	ch = chars [offset] - '0';  	if (((uint)ch) >= 10)  		return false;  	pow10 *= 10;  	value = value * 10 + ch;  	offset++;  }  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,TryParseSingle,The following statement contains a magic number: while (offset < offsetMax) {  	ch = chars [offset] - '0';  	if (((uint)ch) >= 10)  		return false;  	pow10 *= 10;  	value = value * 10 + ch;  	offset++;  }  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,TryParseSingle,The following statement contains a magic number: if (((uint)ch) >= 10)  	return false;  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,TryParseSingle,The following statement contains a magic number: pow10 *= 10;  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,TryParseSingle,The following statement contains a magic number: value = value * 10 + ch;  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,TryParseSingle,The following statement contains a magic number: if (count > 8)  	result = (float)(value / (double)pow10);  else  	result = (float)value / pow10;  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,TryParseSingle,The following statement contains a magic number: if (((uint)ch) >= 10)  	return false;  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,TryParseSingle,The following statement contains a magic number: value = value * 10 + ch;  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,TryParseSingle,The following statement contains a magic number: if (count == 10)  	return false;  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,TryParseDouble,The following statement contains a magic number: if (count < 1 || count > 10)  	return false;  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,TryParseDouble,The following statement contains a magic number: while (offset < offsetMax) {  	int ch = (chars [offset] - '0');  	if (ch == ('.' - '0')) {  		offset++;  		int pow10 = 1;  		while (offset < offsetMax) {  			ch = chars [offset] - '0';  			if (((uint)ch) >= 10)  				return false;  			pow10 *= 10;  			value = value * 10 + ch;  			offset++;  		}  		if (negative)  			result = -(double)value / pow10;  		else  			result = (double)value / pow10;  		return true;  	}  	if (((uint)ch) >= 10)  		return false;  	value = value * 10 + ch;  	offset++;  }  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,TryParseDouble,The following statement contains a magic number: while (offset < offsetMax) {  	int ch = (chars [offset] - '0');  	if (ch == ('.' - '0')) {  		offset++;  		int pow10 = 1;  		while (offset < offsetMax) {  			ch = chars [offset] - '0';  			if (((uint)ch) >= 10)  				return false;  			pow10 *= 10;  			value = value * 10 + ch;  			offset++;  		}  		if (negative)  			result = -(double)value / pow10;  		else  			result = (double)value / pow10;  		return true;  	}  	if (((uint)ch) >= 10)  		return false;  	value = value * 10 + ch;  	offset++;  }  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,TryParseDouble,The following statement contains a magic number: while (offset < offsetMax) {  	int ch = (chars [offset] - '0');  	if (ch == ('.' - '0')) {  		offset++;  		int pow10 = 1;  		while (offset < offsetMax) {  			ch = chars [offset] - '0';  			if (((uint)ch) >= 10)  				return false;  			pow10 *= 10;  			value = value * 10 + ch;  			offset++;  		}  		if (negative)  			result = -(double)value / pow10;  		else  			result = (double)value / pow10;  		return true;  	}  	if (((uint)ch) >= 10)  		return false;  	value = value * 10 + ch;  	offset++;  }  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,TryParseDouble,The following statement contains a magic number: while (offset < offsetMax) {  	int ch = (chars [offset] - '0');  	if (ch == ('.' - '0')) {  		offset++;  		int pow10 = 1;  		while (offset < offsetMax) {  			ch = chars [offset] - '0';  			if (((uint)ch) >= 10)  				return false;  			pow10 *= 10;  			value = value * 10 + ch;  			offset++;  		}  		if (negative)  			result = -(double)value / pow10;  		else  			result = (double)value / pow10;  		return true;  	}  	if (((uint)ch) >= 10)  		return false;  	value = value * 10 + ch;  	offset++;  }  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,TryParseDouble,The following statement contains a magic number: while (offset < offsetMax) {  	int ch = (chars [offset] - '0');  	if (ch == ('.' - '0')) {  		offset++;  		int pow10 = 1;  		while (offset < offsetMax) {  			ch = chars [offset] - '0';  			if (((uint)ch) >= 10)  				return false;  			pow10 *= 10;  			value = value * 10 + ch;  			offset++;  		}  		if (negative)  			result = -(double)value / pow10;  		else  			result = (double)value / pow10;  		return true;  	}  	if (((uint)ch) >= 10)  		return false;  	value = value * 10 + ch;  	offset++;  }  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,TryParseDouble,The following statement contains a magic number: if (ch == ('.' - '0')) {  	offset++;  	int pow10 = 1;  	while (offset < offsetMax) {  		ch = chars [offset] - '0';  		if (((uint)ch) >= 10)  			return false;  		pow10 *= 10;  		value = value * 10 + ch;  		offset++;  	}  	if (negative)  		result = -(double)value / pow10;  	else  		result = (double)value / pow10;  	return true;  }  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,TryParseDouble,The following statement contains a magic number: if (ch == ('.' - '0')) {  	offset++;  	int pow10 = 1;  	while (offset < offsetMax) {  		ch = chars [offset] - '0';  		if (((uint)ch) >= 10)  			return false;  		pow10 *= 10;  		value = value * 10 + ch;  		offset++;  	}  	if (negative)  		result = -(double)value / pow10;  	else  		result = (double)value / pow10;  	return true;  }  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,TryParseDouble,The following statement contains a magic number: if (ch == ('.' - '0')) {  	offset++;  	int pow10 = 1;  	while (offset < offsetMax) {  		ch = chars [offset] - '0';  		if (((uint)ch) >= 10)  			return false;  		pow10 *= 10;  		value = value * 10 + ch;  		offset++;  	}  	if (negative)  		result = -(double)value / pow10;  	else  		result = (double)value / pow10;  	return true;  }  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,TryParseDouble,The following statement contains a magic number: while (offset < offsetMax) {  	ch = chars [offset] - '0';  	if (((uint)ch) >= 10)  		return false;  	pow10 *= 10;  	value = value * 10 + ch;  	offset++;  }  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,TryParseDouble,The following statement contains a magic number: while (offset < offsetMax) {  	ch = chars [offset] - '0';  	if (((uint)ch) >= 10)  		return false;  	pow10 *= 10;  	value = value * 10 + ch;  	offset++;  }  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,TryParseDouble,The following statement contains a magic number: while (offset < offsetMax) {  	ch = chars [offset] - '0';  	if (((uint)ch) >= 10)  		return false;  	pow10 *= 10;  	value = value * 10 + ch;  	offset++;  }  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,TryParseDouble,The following statement contains a magic number: if (((uint)ch) >= 10)  	return false;  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,TryParseDouble,The following statement contains a magic number: pow10 *= 10;  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,TryParseDouble,The following statement contains a magic number: value = value * 10 + ch;  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,TryParseDouble,The following statement contains a magic number: if (((uint)ch) >= 10)  	return false;  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,TryParseDouble,The following statement contains a magic number: value = value * 10 + ch;  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,TryParseDouble,The following statement contains a magic number: if (count == 10)  	return false;  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,ToInt32D2,The following statement contains a magic number: if (ch1 > 9 || ch2 > 9)  	return -1;  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,ToInt32D2,The following statement contains a magic number: if (ch1 > 9 || ch2 > 9)  	return -1;  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,ToInt32D2,The following statement contains a magic number: return 10 * ch1 + ch2;  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,ToInt32D7,The following statement contains a magic number: for (int i = 0; i < count; i++) {  	byte ch = (byte)(chars [offset + i] - '0');  	if (ch > 9)  		return -1;  	value = value * 10 + ch;  }  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,ToInt32D7,The following statement contains a magic number: for (int i = 0; i < count; i++) {  	byte ch = (byte)(chars [offset + i] - '0');  	if (ch > 9)  		return -1;  	value = value * 10 + ch;  }  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,ToInt32D7,The following statement contains a magic number: if (ch > 9)  	return -1;  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,ToInt32D7,The following statement contains a magic number: value = value * 10 + ch;  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,TryParseDateTime,The following statement contains a magic number: if (count < 19)  	return false;  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,TryParseDateTime,The following statement contains a magic number: if (chars [offset + 4] != '-' || chars [offset + 7] != '-' || chars [offset + 10] != 'T' || chars [offset + 13] != ':' || chars [offset + 16] != ':')  	return false;  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,TryParseDateTime,The following statement contains a magic number: if (chars [offset + 4] != '-' || chars [offset + 7] != '-' || chars [offset + 10] != 'T' || chars [offset + 13] != ':' || chars [offset + 16] != ':')  	return false;  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,TryParseDateTime,The following statement contains a magic number: if (chars [offset + 4] != '-' || chars [offset + 7] != '-' || chars [offset + 10] != 'T' || chars [offset + 13] != ':' || chars [offset + 16] != ':')  	return false;  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,TryParseDateTime,The following statement contains a magic number: if (chars [offset + 4] != '-' || chars [offset + 7] != '-' || chars [offset + 10] != 'T' || chars [offset + 13] != ':' || chars [offset + 16] != ':')  	return false;  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,TryParseDateTime,The following statement contains a magic number: if (chars [offset + 4] != '-' || chars [offset + 7] != '-' || chars [offset + 10] != 'T' || chars [offset + 13] != ':' || chars [offset + 16] != ':')  	return false;  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,TryParseDateTime,The following statement contains a magic number: offset += 19;  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,TryParseDateTime,The following statement contains a magic number: if (offset < offsetMax && chars [offset] == '.') {  	offset++;  	int digitOffset = offset;  	while (offset < offsetMax) {  		byte ch = chars [offset];  		if (ch < '0' || ch > '9')  			break;  		offset++;  	}  	int digitCount = offset - digitOffset;  	if (digitCount < 1 || digitCount > 7)  		return false;  	ticks = ToInt32D7 (chars' digitOffset' digitCount);  	if (ticks < 0)  		return false;  	for (int i = digitCount; i < 7; ++i)  		ticks *= 10;  }  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,TryParseDateTime,The following statement contains a magic number: if (offset < offsetMax && chars [offset] == '.') {  	offset++;  	int digitOffset = offset;  	while (offset < offsetMax) {  		byte ch = chars [offset];  		if (ch < '0' || ch > '9')  			break;  		offset++;  	}  	int digitCount = offset - digitOffset;  	if (digitCount < 1 || digitCount > 7)  		return false;  	ticks = ToInt32D7 (chars' digitOffset' digitCount);  	if (ticks < 0)  		return false;  	for (int i = digitCount; i < 7; ++i)  		ticks *= 10;  }  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,TryParseDateTime,The following statement contains a magic number: if (offset < offsetMax && chars [offset] == '.') {  	offset++;  	int digitOffset = offset;  	while (offset < offsetMax) {  		byte ch = chars [offset];  		if (ch < '0' || ch > '9')  			break;  		offset++;  	}  	int digitCount = offset - digitOffset;  	if (digitCount < 1 || digitCount > 7)  		return false;  	ticks = ToInt32D7 (chars' digitOffset' digitCount);  	if (ticks < 0)  		return false;  	for (int i = digitCount; i < 7; ++i)  		ticks *= 10;  }  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,TryParseDateTime,The following statement contains a magic number: if (digitCount < 1 || digitCount > 7)  	return false;  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,TryParseDateTime,The following statement contains a magic number: for (int i = digitCount; i < 7; ++i)  	ticks *= 10;  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,TryParseDateTime,The following statement contains a magic number: for (int i = digitCount; i < 7; ++i)  	ticks *= 10;  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,TryParseDateTime,The following statement contains a magic number: ticks *= 10;  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,TryParseDateTime,The following statement contains a magic number: if (offset < offsetMax) {  	byte ch = chars [offset];  	if (ch == 'Z') {  		offset++;  		kind = DateTimeKind.Utc;  	}  	else if (ch == '+' || ch == '-') {  		offset++;  		if (offset + 5 > offsetMax || chars [offset + 2] != ':')  			return false;  		kind = DateTimeKind.Utc;  		isLocal = true;  		hourDelta = ToInt32D2 (chars' offset);  		minuteDelta = ToInt32D2 (chars' offset + 3);  		if ((hourDelta | minuteDelta) < 0)  			return false;  		if (ch == '+') {  			hourDelta = -hourDelta;  			minuteDelta = -minuteDelta;  		}  		offset += 5;  	}  }  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,TryParseDateTime,The following statement contains a magic number: if (offset < offsetMax) {  	byte ch = chars [offset];  	if (ch == 'Z') {  		offset++;  		kind = DateTimeKind.Utc;  	}  	else if (ch == '+' || ch == '-') {  		offset++;  		if (offset + 5 > offsetMax || chars [offset + 2] != ':')  			return false;  		kind = DateTimeKind.Utc;  		isLocal = true;  		hourDelta = ToInt32D2 (chars' offset);  		minuteDelta = ToInt32D2 (chars' offset + 3);  		if ((hourDelta | minuteDelta) < 0)  			return false;  		if (ch == '+') {  			hourDelta = -hourDelta;  			minuteDelta = -minuteDelta;  		}  		offset += 5;  	}  }  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,TryParseDateTime,The following statement contains a magic number: if (offset < offsetMax) {  	byte ch = chars [offset];  	if (ch == 'Z') {  		offset++;  		kind = DateTimeKind.Utc;  	}  	else if (ch == '+' || ch == '-') {  		offset++;  		if (offset + 5 > offsetMax || chars [offset + 2] != ':')  			return false;  		kind = DateTimeKind.Utc;  		isLocal = true;  		hourDelta = ToInt32D2 (chars' offset);  		minuteDelta = ToInt32D2 (chars' offset + 3);  		if ((hourDelta | minuteDelta) < 0)  			return false;  		if (ch == '+') {  			hourDelta = -hourDelta;  			minuteDelta = -minuteDelta;  		}  		offset += 5;  	}  }  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,TryParseDateTime,The following statement contains a magic number: if (offset < offsetMax) {  	byte ch = chars [offset];  	if (ch == 'Z') {  		offset++;  		kind = DateTimeKind.Utc;  	}  	else if (ch == '+' || ch == '-') {  		offset++;  		if (offset + 5 > offsetMax || chars [offset + 2] != ':')  			return false;  		kind = DateTimeKind.Utc;  		isLocal = true;  		hourDelta = ToInt32D2 (chars' offset);  		minuteDelta = ToInt32D2 (chars' offset + 3);  		if ((hourDelta | minuteDelta) < 0)  			return false;  		if (ch == '+') {  			hourDelta = -hourDelta;  			minuteDelta = -minuteDelta;  		}  		offset += 5;  	}  }  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,TryParseDateTime,The following statement contains a magic number: if (ch == 'Z') {  	offset++;  	kind = DateTimeKind.Utc;  }  else if (ch == '+' || ch == '-') {  	offset++;  	if (offset + 5 > offsetMax || chars [offset + 2] != ':')  		return false;  	kind = DateTimeKind.Utc;  	isLocal = true;  	hourDelta = ToInt32D2 (chars' offset);  	minuteDelta = ToInt32D2 (chars' offset + 3);  	if ((hourDelta | minuteDelta) < 0)  		return false;  	if (ch == '+') {  		hourDelta = -hourDelta;  		minuteDelta = -minuteDelta;  	}  	offset += 5;  }  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,TryParseDateTime,The following statement contains a magic number: if (ch == 'Z') {  	offset++;  	kind = DateTimeKind.Utc;  }  else if (ch == '+' || ch == '-') {  	offset++;  	if (offset + 5 > offsetMax || chars [offset + 2] != ':')  		return false;  	kind = DateTimeKind.Utc;  	isLocal = true;  	hourDelta = ToInt32D2 (chars' offset);  	minuteDelta = ToInt32D2 (chars' offset + 3);  	if ((hourDelta | minuteDelta) < 0)  		return false;  	if (ch == '+') {  		hourDelta = -hourDelta;  		minuteDelta = -minuteDelta;  	}  	offset += 5;  }  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,TryParseDateTime,The following statement contains a magic number: if (ch == 'Z') {  	offset++;  	kind = DateTimeKind.Utc;  }  else if (ch == '+' || ch == '-') {  	offset++;  	if (offset + 5 > offsetMax || chars [offset + 2] != ':')  		return false;  	kind = DateTimeKind.Utc;  	isLocal = true;  	hourDelta = ToInt32D2 (chars' offset);  	minuteDelta = ToInt32D2 (chars' offset + 3);  	if ((hourDelta | minuteDelta) < 0)  		return false;  	if (ch == '+') {  		hourDelta = -hourDelta;  		minuteDelta = -minuteDelta;  	}  	offset += 5;  }  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,TryParseDateTime,The following statement contains a magic number: if (ch == 'Z') {  	offset++;  	kind = DateTimeKind.Utc;  }  else if (ch == '+' || ch == '-') {  	offset++;  	if (offset + 5 > offsetMax || chars [offset + 2] != ':')  		return false;  	kind = DateTimeKind.Utc;  	isLocal = true;  	hourDelta = ToInt32D2 (chars' offset);  	minuteDelta = ToInt32D2 (chars' offset + 3);  	if ((hourDelta | minuteDelta) < 0)  		return false;  	if (ch == '+') {  		hourDelta = -hourDelta;  		minuteDelta = -minuteDelta;  	}  	offset += 5;  }  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,TryParseDateTime,The following statement contains a magic number: if (ch == '+' || ch == '-') {  	offset++;  	if (offset + 5 > offsetMax || chars [offset + 2] != ':')  		return false;  	kind = DateTimeKind.Utc;  	isLocal = true;  	hourDelta = ToInt32D2 (chars' offset);  	minuteDelta = ToInt32D2 (chars' offset + 3);  	if ((hourDelta | minuteDelta) < 0)  		return false;  	if (ch == '+') {  		hourDelta = -hourDelta;  		minuteDelta = -minuteDelta;  	}  	offset += 5;  }  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,TryParseDateTime,The following statement contains a magic number: if (ch == '+' || ch == '-') {  	offset++;  	if (offset + 5 > offsetMax || chars [offset + 2] != ':')  		return false;  	kind = DateTimeKind.Utc;  	isLocal = true;  	hourDelta = ToInt32D2 (chars' offset);  	minuteDelta = ToInt32D2 (chars' offset + 3);  	if ((hourDelta | minuteDelta) < 0)  		return false;  	if (ch == '+') {  		hourDelta = -hourDelta;  		minuteDelta = -minuteDelta;  	}  	offset += 5;  }  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,TryParseDateTime,The following statement contains a magic number: if (ch == '+' || ch == '-') {  	offset++;  	if (offset + 5 > offsetMax || chars [offset + 2] != ':')  		return false;  	kind = DateTimeKind.Utc;  	isLocal = true;  	hourDelta = ToInt32D2 (chars' offset);  	minuteDelta = ToInt32D2 (chars' offset + 3);  	if ((hourDelta | minuteDelta) < 0)  		return false;  	if (ch == '+') {  		hourDelta = -hourDelta;  		minuteDelta = -minuteDelta;  	}  	offset += 5;  }  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,TryParseDateTime,The following statement contains a magic number: if (ch == '+' || ch == '-') {  	offset++;  	if (offset + 5 > offsetMax || chars [offset + 2] != ':')  		return false;  	kind = DateTimeKind.Utc;  	isLocal = true;  	hourDelta = ToInt32D2 (chars' offset);  	minuteDelta = ToInt32D2 (chars' offset + 3);  	if ((hourDelta | minuteDelta) < 0)  		return false;  	if (ch == '+') {  		hourDelta = -hourDelta;  		minuteDelta = -minuteDelta;  	}  	offset += 5;  }  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,TryParseDateTime,The following statement contains a magic number: if (offset + 5 > offsetMax || chars [offset + 2] != ':')  	return false;  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,TryParseDateTime,The following statement contains a magic number: if (offset + 5 > offsetMax || chars [offset + 2] != ':')  	return false;  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,TryParseDateTime,The following statement contains a magic number: minuteDelta = ToInt32D2 (chars' offset + 3);  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,TryParseDateTime,The following statement contains a magic number: offset += 5;  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,ToChars,The following statement contains a magic number: if (value) {  	buffer [offset + 0] = (byte)'t';  	buffer [offset + 1] = (byte)'r';  	buffer [offset + 2] = (byte)'u';  	buffer [offset + 3] = (byte)'e';  	return 4;  }  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,ToChars,The following statement contains a magic number: if (value) {  	buffer [offset + 0] = (byte)'t';  	buffer [offset + 1] = (byte)'r';  	buffer [offset + 2] = (byte)'u';  	buffer [offset + 3] = (byte)'e';  	return 4;  }  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,ToChars,The following statement contains a magic number: if (value) {  	buffer [offset + 0] = (byte)'t';  	buffer [offset + 1] = (byte)'r';  	buffer [offset + 2] = (byte)'u';  	buffer [offset + 3] = (byte)'e';  	return 4;  }  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,ToChars,The following statement contains a magic number: buffer [offset + 2] = (byte)'u';  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,ToChars,The following statement contains a magic number: buffer [offset + 3] = (byte)'e';  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,ToChars,The following statement contains a magic number: return 4;  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,ToChars,The following statement contains a magic number: buffer [offset + 2] = (byte)'l';  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,ToChars,The following statement contains a magic number: buffer [offset + 3] = (byte)'s';  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,ToChars,The following statement contains a magic number: buffer [offset + 4] = (byte)'e';  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,ToChars,The following statement contains a magic number: return 5;  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,ToCharsR,The following statement contains a magic number: if (value >= 0) {  	while (value >= 10) {  		int valueDiv10 = value / 10;  		count++;  		chars [--offset] = (byte)('0' + (value - valueDiv10 * 10));  		value = valueDiv10;  	}  	chars [--offset] = (byte)('0' + value);  	count++;  }  else {  	while (value <= -10) {  		int valueDiv10 = value / 10;  		count++;  		chars [--offset] = (byte)('0' - (value - valueDiv10 * 10));  		value = valueDiv10;  	}  	chars [--offset] = (byte)('0' - value);  	chars [--offset] = (byte)'-';  	count += 2;  }  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,ToCharsR,The following statement contains a magic number: if (value >= 0) {  	while (value >= 10) {  		int valueDiv10 = value / 10;  		count++;  		chars [--offset] = (byte)('0' + (value - valueDiv10 * 10));  		value = valueDiv10;  	}  	chars [--offset] = (byte)('0' + value);  	count++;  }  else {  	while (value <= -10) {  		int valueDiv10 = value / 10;  		count++;  		chars [--offset] = (byte)('0' - (value - valueDiv10 * 10));  		value = valueDiv10;  	}  	chars [--offset] = (byte)('0' - value);  	chars [--offset] = (byte)'-';  	count += 2;  }  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,ToCharsR,The following statement contains a magic number: if (value >= 0) {  	while (value >= 10) {  		int valueDiv10 = value / 10;  		count++;  		chars [--offset] = (byte)('0' + (value - valueDiv10 * 10));  		value = valueDiv10;  	}  	chars [--offset] = (byte)('0' + value);  	count++;  }  else {  	while (value <= -10) {  		int valueDiv10 = value / 10;  		count++;  		chars [--offset] = (byte)('0' - (value - valueDiv10 * 10));  		value = valueDiv10;  	}  	chars [--offset] = (byte)('0' - value);  	chars [--offset] = (byte)'-';  	count += 2;  }  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,ToCharsR,The following statement contains a magic number: if (value >= 0) {  	while (value >= 10) {  		int valueDiv10 = value / 10;  		count++;  		chars [--offset] = (byte)('0' + (value - valueDiv10 * 10));  		value = valueDiv10;  	}  	chars [--offset] = (byte)('0' + value);  	count++;  }  else {  	while (value <= -10) {  		int valueDiv10 = value / 10;  		count++;  		chars [--offset] = (byte)('0' - (value - valueDiv10 * 10));  		value = valueDiv10;  	}  	chars [--offset] = (byte)('0' - value);  	chars [--offset] = (byte)'-';  	count += 2;  }  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,ToCharsR,The following statement contains a magic number: if (value >= 0) {  	while (value >= 10) {  		int valueDiv10 = value / 10;  		count++;  		chars [--offset] = (byte)('0' + (value - valueDiv10 * 10));  		value = valueDiv10;  	}  	chars [--offset] = (byte)('0' + value);  	count++;  }  else {  	while (value <= -10) {  		int valueDiv10 = value / 10;  		count++;  		chars [--offset] = (byte)('0' - (value - valueDiv10 * 10));  		value = valueDiv10;  	}  	chars [--offset] = (byte)('0' - value);  	chars [--offset] = (byte)'-';  	count += 2;  }  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,ToCharsR,The following statement contains a magic number: if (value >= 0) {  	while (value >= 10) {  		int valueDiv10 = value / 10;  		count++;  		chars [--offset] = (byte)('0' + (value - valueDiv10 * 10));  		value = valueDiv10;  	}  	chars [--offset] = (byte)('0' + value);  	count++;  }  else {  	while (value <= -10) {  		int valueDiv10 = value / 10;  		count++;  		chars [--offset] = (byte)('0' - (value - valueDiv10 * 10));  		value = valueDiv10;  	}  	chars [--offset] = (byte)('0' - value);  	chars [--offset] = (byte)'-';  	count += 2;  }  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,ToCharsR,The following statement contains a magic number: if (value >= 0) {  	while (value >= 10) {  		int valueDiv10 = value / 10;  		count++;  		chars [--offset] = (byte)('0' + (value - valueDiv10 * 10));  		value = valueDiv10;  	}  	chars [--offset] = (byte)('0' + value);  	count++;  }  else {  	while (value <= -10) {  		int valueDiv10 = value / 10;  		count++;  		chars [--offset] = (byte)('0' - (value - valueDiv10 * 10));  		value = valueDiv10;  	}  	chars [--offset] = (byte)('0' - value);  	chars [--offset] = (byte)'-';  	count += 2;  }  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,ToCharsR,The following statement contains a magic number: while (value >= 10) {  	int valueDiv10 = value / 10;  	count++;  	chars [--offset] = (byte)('0' + (value - valueDiv10 * 10));  	value = valueDiv10;  }  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,ToCharsR,The following statement contains a magic number: while (value >= 10) {  	int valueDiv10 = value / 10;  	count++;  	chars [--offset] = (byte)('0' + (value - valueDiv10 * 10));  	value = valueDiv10;  }  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,ToCharsR,The following statement contains a magic number: while (value >= 10) {  	int valueDiv10 = value / 10;  	count++;  	chars [--offset] = (byte)('0' + (value - valueDiv10 * 10));  	value = valueDiv10;  }  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,ToCharsR,The following statement contains a magic number: chars [--offset] = (byte)('0' + (value - valueDiv10 * 10));  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,ToCharsR,The following statement contains a magic number: while (value <= -10) {  	int valueDiv10 = value / 10;  	count++;  	chars [--offset] = (byte)('0' - (value - valueDiv10 * 10));  	value = valueDiv10;  }  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,ToCharsR,The following statement contains a magic number: while (value <= -10) {  	int valueDiv10 = value / 10;  	count++;  	chars [--offset] = (byte)('0' - (value - valueDiv10 * 10));  	value = valueDiv10;  }  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,ToCharsR,The following statement contains a magic number: while (value <= -10) {  	int valueDiv10 = value / 10;  	count++;  	chars [--offset] = (byte)('0' - (value - valueDiv10 * 10));  	value = valueDiv10;  }  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,ToCharsR,The following statement contains a magic number: chars [--offset] = (byte)('0' - (value - valueDiv10 * 10));  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,ToCharsR,The following statement contains a magic number: count += 2;  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,ToChars,The following statement contains a magic number: Buffer.BlockCopy (chars' offset + 16 - count' chars' offset' count);  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,ToCharsR,The following statement contains a magic number: if (value >= 0) {  	while (value > int.MaxValue) {  		long valueDiv10 = value / 10;  		count++;  		chars [--offset] = (byte)('0' + (int)(value - valueDiv10 * 10));  		value = valueDiv10;  	}  }  else {  	while (value < int.MinValue) {  		long valueDiv10 = value / 10;  		count++;  		chars [--offset] = (byte)('0' - (int)(value - valueDiv10 * 10));  		value = valueDiv10;  	}  }  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,ToCharsR,The following statement contains a magic number: if (value >= 0) {  	while (value > int.MaxValue) {  		long valueDiv10 = value / 10;  		count++;  		chars [--offset] = (byte)('0' + (int)(value - valueDiv10 * 10));  		value = valueDiv10;  	}  }  else {  	while (value < int.MinValue) {  		long valueDiv10 = value / 10;  		count++;  		chars [--offset] = (byte)('0' - (int)(value - valueDiv10 * 10));  		value = valueDiv10;  	}  }  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,ToCharsR,The following statement contains a magic number: if (value >= 0) {  	while (value > int.MaxValue) {  		long valueDiv10 = value / 10;  		count++;  		chars [--offset] = (byte)('0' + (int)(value - valueDiv10 * 10));  		value = valueDiv10;  	}  }  else {  	while (value < int.MinValue) {  		long valueDiv10 = value / 10;  		count++;  		chars [--offset] = (byte)('0' - (int)(value - valueDiv10 * 10));  		value = valueDiv10;  	}  }  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,ToCharsR,The following statement contains a magic number: if (value >= 0) {  	while (value > int.MaxValue) {  		long valueDiv10 = value / 10;  		count++;  		chars [--offset] = (byte)('0' + (int)(value - valueDiv10 * 10));  		value = valueDiv10;  	}  }  else {  	while (value < int.MinValue) {  		long valueDiv10 = value / 10;  		count++;  		chars [--offset] = (byte)('0' - (int)(value - valueDiv10 * 10));  		value = valueDiv10;  	}  }  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,ToCharsR,The following statement contains a magic number: while (value > int.MaxValue) {  	long valueDiv10 = value / 10;  	count++;  	chars [--offset] = (byte)('0' + (int)(value - valueDiv10 * 10));  	value = valueDiv10;  }  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,ToCharsR,The following statement contains a magic number: while (value > int.MaxValue) {  	long valueDiv10 = value / 10;  	count++;  	chars [--offset] = (byte)('0' + (int)(value - valueDiv10 * 10));  	value = valueDiv10;  }  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,ToCharsR,The following statement contains a magic number: chars [--offset] = (byte)('0' + (int)(value - valueDiv10 * 10));  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,ToCharsR,The following statement contains a magic number: while (value < int.MinValue) {  	long valueDiv10 = value / 10;  	count++;  	chars [--offset] = (byte)('0' - (int)(value - valueDiv10 * 10));  	value = valueDiv10;  }  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,ToCharsR,The following statement contains a magic number: while (value < int.MinValue) {  	long valueDiv10 = value / 10;  	count++;  	chars [--offset] = (byte)('0' - (int)(value - valueDiv10 * 10));  	value = valueDiv10;  }  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,ToCharsR,The following statement contains a magic number: chars [--offset] = (byte)('0' - (int)(value - valueDiv10 * 10));  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,ToChars,The following statement contains a magic number: Buffer.BlockCopy (chars' offset + 32 - count' chars' offset' count);  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,ToInfinity,The following statement contains a magic number: if (isNegative) {  	buffer [offset + 0] = (byte)'-';  	buffer [offset + 1] = (byte)'I';  	buffer [offset + 2] = (byte)'N';  	buffer [offset + 3] = (byte)'F';  	return 4;  }  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,ToInfinity,The following statement contains a magic number: if (isNegative) {  	buffer [offset + 0] = (byte)'-';  	buffer [offset + 1] = (byte)'I';  	buffer [offset + 2] = (byte)'N';  	buffer [offset + 3] = (byte)'F';  	return 4;  }  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,ToInfinity,The following statement contains a magic number: if (isNegative) {  	buffer [offset + 0] = (byte)'-';  	buffer [offset + 1] = (byte)'I';  	buffer [offset + 2] = (byte)'N';  	buffer [offset + 3] = (byte)'F';  	return 4;  }  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,ToInfinity,The following statement contains a magic number: buffer [offset + 2] = (byte)'N';  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,ToInfinity,The following statement contains a magic number: buffer [offset + 3] = (byte)'F';  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,ToInfinity,The following statement contains a magic number: return 4;  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,ToInfinity,The following statement contains a magic number: buffer [offset + 2] = (byte)'F';  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,ToInfinity,The following statement contains a magic number: return 3;  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,ToZero,The following statement contains a magic number: if (isNegative) {  	buffer [offset + 0] = (byte)'-';  	buffer [offset + 1] = (byte)'0';  	return 2;  }  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,ToZero,The following statement contains a magic number: return 2;  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,ToCharsD2,The following statement contains a magic number: if (value < 10) {  	chars [offset + 0] = (byte)'0';  	chars [offset + 1] = (byte)('0' + value);  }  else {  	int valueDiv10 = value / 10;  	chars [offset + 0] = (byte)('0' + valueDiv10);  	chars [offset + 1] = (byte)('0' + value - valueDiv10 * 10);  }  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,ToCharsD2,The following statement contains a magic number: if (value < 10) {  	chars [offset + 0] = (byte)'0';  	chars [offset + 1] = (byte)('0' + value);  }  else {  	int valueDiv10 = value / 10;  	chars [offset + 0] = (byte)('0' + valueDiv10);  	chars [offset + 1] = (byte)('0' + value - valueDiv10 * 10);  }  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,ToCharsD2,The following statement contains a magic number: if (value < 10) {  	chars [offset + 0] = (byte)'0';  	chars [offset + 1] = (byte)('0' + value);  }  else {  	int valueDiv10 = value / 10;  	chars [offset + 0] = (byte)('0' + valueDiv10);  	chars [offset + 1] = (byte)('0' + value - valueDiv10 * 10);  }  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,ToCharsD2,The following statement contains a magic number: chars [offset + 1] = (byte)('0' + value - valueDiv10 * 10);  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,ToCharsD2,The following statement contains a magic number: return 2;  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,ToCharsD4,The following statement contains a magic number: ToCharsD2 (value / 100' chars' offset);  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,ToCharsD4,The following statement contains a magic number: ToCharsD2 (value % 100' chars' offset + 2);  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,ToCharsD4,The following statement contains a magic number: ToCharsD2 (value % 100' chars' offset + 2);  
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,ToCharsD4,The following statement contains a magic number: return 4;  
Magic Number,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,ResetState,The following statement contains a magic number: charactersToSkipOnNextRead = new byte[2];  
Magic Number,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,BreakText,The following statement contains a magic number: if (length > 0 && (buffer [offset + length - 1] & BufferAllocation) == BufferAllocation) {  	// Find the lead char of the utf8 sequence (0x11xxxxxx)   	int originalLength = length;  	do {  		--length;  	}  	while (length > 0 && (buffer [offset + length] & 192) != 192);  	// Couldn't find the lead char  	if (length == 0)  		return originalLength;  	// Count how many bytes follow the lead char   	byte b = (byte)(buffer [offset + length] << 2);  	int byteCount = 2;  	while ((b & BufferAllocation) == BufferAllocation) {  		b <<= 1;  		++byteCount;  		// There shouldn't be more than 3 bytes following the lead char   		if (byteCount > 4)  			return originalLength;  		// Invalid utf8 sequence - can't break   	}  	if (length + byteCount == originalLength)  		return originalLength;  	// sequence fits exactly  	if (length == 0)  		return originalLength;  	// Quota too small to read a char   }  
Magic Number,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,BreakText,The following statement contains a magic number: if (length > 0 && (buffer [offset + length - 1] & BufferAllocation) == BufferAllocation) {  	// Find the lead char of the utf8 sequence (0x11xxxxxx)   	int originalLength = length;  	do {  		--length;  	}  	while (length > 0 && (buffer [offset + length] & 192) != 192);  	// Couldn't find the lead char  	if (length == 0)  		return originalLength;  	// Count how many bytes follow the lead char   	byte b = (byte)(buffer [offset + length] << 2);  	int byteCount = 2;  	while ((b & BufferAllocation) == BufferAllocation) {  		b <<= 1;  		++byteCount;  		// There shouldn't be more than 3 bytes following the lead char   		if (byteCount > 4)  			return originalLength;  		// Invalid utf8 sequence - can't break   	}  	if (length + byteCount == originalLength)  		return originalLength;  	// sequence fits exactly  	if (length == 0)  		return originalLength;  	// Quota too small to read a char   }  
Magic Number,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,BreakText,The following statement contains a magic number: if (length > 0 && (buffer [offset + length - 1] & BufferAllocation) == BufferAllocation) {  	// Find the lead char of the utf8 sequence (0x11xxxxxx)   	int originalLength = length;  	do {  		--length;  	}  	while (length > 0 && (buffer [offset + length] & 192) != 192);  	// Couldn't find the lead char  	if (length == 0)  		return originalLength;  	// Count how many bytes follow the lead char   	byte b = (byte)(buffer [offset + length] << 2);  	int byteCount = 2;  	while ((b & BufferAllocation) == BufferAllocation) {  		b <<= 1;  		++byteCount;  		// There shouldn't be more than 3 bytes following the lead char   		if (byteCount > 4)  			return originalLength;  		// Invalid utf8 sequence - can't break   	}  	if (length + byteCount == originalLength)  		return originalLength;  	// sequence fits exactly  	if (length == 0)  		return originalLength;  	// Quota too small to read a char   }  
Magic Number,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,BreakText,The following statement contains a magic number: if (length > 0 && (buffer [offset + length - 1] & BufferAllocation) == BufferAllocation) {  	// Find the lead char of the utf8 sequence (0x11xxxxxx)   	int originalLength = length;  	do {  		--length;  	}  	while (length > 0 && (buffer [offset + length] & 192) != 192);  	// Couldn't find the lead char  	if (length == 0)  		return originalLength;  	// Count how many bytes follow the lead char   	byte b = (byte)(buffer [offset + length] << 2);  	int byteCount = 2;  	while ((b & BufferAllocation) == BufferAllocation) {  		b <<= 1;  		++byteCount;  		// There shouldn't be more than 3 bytes following the lead char   		if (byteCount > 4)  			return originalLength;  		// Invalid utf8 sequence - can't break   	}  	if (length + byteCount == originalLength)  		return originalLength;  	// sequence fits exactly  	if (length == 0)  		return originalLength;  	// Quota too small to read a char   }  
Magic Number,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,BreakText,The following statement contains a magic number: if (length > 0 && (buffer [offset + length - 1] & BufferAllocation) == BufferAllocation) {  	// Find the lead char of the utf8 sequence (0x11xxxxxx)   	int originalLength = length;  	do {  		--length;  	}  	while (length > 0 && (buffer [offset + length] & 192) != 192);  	// Couldn't find the lead char  	if (length == 0)  		return originalLength;  	// Count how many bytes follow the lead char   	byte b = (byte)(buffer [offset + length] << 2);  	int byteCount = 2;  	while ((b & BufferAllocation) == BufferAllocation) {  		b <<= 1;  		++byteCount;  		// There shouldn't be more than 3 bytes following the lead char   		if (byteCount > 4)  			return originalLength;  		// Invalid utf8 sequence - can't break   	}  	if (length + byteCount == originalLength)  		return originalLength;  	// sequence fits exactly  	if (length == 0)  		return originalLength;  	// Quota too small to read a char   }  
Magic Number,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,BreakText,The following statement contains a magic number: do {  	--length;  }  while (length > 0 && (buffer [offset + length] & 192) != 192);  
Magic Number,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,BreakText,The following statement contains a magic number: do {  	--length;  }  while (length > 0 && (buffer [offset + length] & 192) != 192);  
Magic Number,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,BreakText,The following statement contains a magic number: while ((b & BufferAllocation) == BufferAllocation) {  	b <<= 1;  	++byteCount;  	// There shouldn't be more than 3 bytes following the lead char   	if (byteCount > 4)  		return originalLength;  	// Invalid utf8 sequence - can't break   }  
Magic Number,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,BreakText,The following statement contains a magic number: if (byteCount > 4)  	return originalLength;  
Magic Number,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,Read,The following statement contains a magic number: if (scopeDepth == 0) {  	ReadNonExistentElementName (StringHandleConstStringType.Root);  }  else if (IsReadingComplexText) {  	switch (complexTextMode) {  	case JsonComplexTextMode.QuotedText:  		if (ch == Keys.BackSlash) {  			ReadEscapedCharacter (true);  			break;  		}  		ReadQuotedText (true);  		break;  	case JsonComplexTextMode.NumericalText:  		ReadNumericalText ();  		break;  	case JsonComplexTextMode.None:  		throw new XmlException ("JsonEncounteredUnexpectedCharacter");  	}  }  else if (IsReadingCollection)  	ReadNonExistentElementName (StringHandleConstStringType.Item);  else  	switch (ch) {  	case Keys.RightClosingBracket:  		this.BufferReader.SkipByte ();  		MoveToEndElement ();  		ExitJsonScope ();  		break;  	case Keys.LeftOpeningBrace:  		this.BufferReader.SkipByte ();  		SkipWhitespaceInBufferReader ();  		ch = this.BufferReader.GetByte ();  		if (ch == Keys.RightClosingBrace) {  			// Skip this byte  			this.BufferReader.SkipByte ();  			// Skip white spaces  			SkipWhitespaceInBufferReader ();  			// try get next char  			if (TryGetByte (out ch)) {  				if (ch == Keys.Comma)  					this.BufferReader.SkipByte ();  			}  			else {  				// We are at end of buffer' just mark Comma to be skipped next time  				charactersToSkipOnNextRead [0] = Keys.Comma;  			}  			// We set to End Element  			MoveToEndElement ();  		}  		else {  			// Enter a new scope  			EnterJsonScope (JsonNodeType.Object);  			// Parse start element  			ParseStartElement ();  		}  		break;  	case Keys.RightClosingBrace:  		this.BufferReader.SkipByte ();  		if (expectingFirstElementInNonPrimitiveChild) {  			SkipWhitespaceInBufferReader ();  			ch = this.BufferReader.GetByte ();  			switch (ch) {  			case Keys.Comma:  			case Keys.RightClosingBrace:  				this.BufferReader.SkipByte ();  				break;  			default:  				throw new XmlException ("JsonEncounteredUnexpectedCharacter");  			}  			expectingFirstElementInNonPrimitiveChild = false;  		}  		MoveToEndElement ();  		break;  	case Keys.Comma:  		this.BufferReader.SkipByte ();  		MoveToEndElement ();  		break;  	case Keys.DoubleQuote:  		if (this.Node.NodeType == XmlNodeType.Element) {  			if (expectingFirstElementInNonPrimitiveChild) {  				EnterJsonScope (JsonNodeType.Object);  				ParseStartElement ();  			}  			else {  				this.BufferReader.SkipByte ();  				ReadQuotedText (true);  			}  		}  		else if (this.Node.NodeType == XmlNodeType.EndElement) {  			EnterJsonScope (JsonNodeType.Element);  			ParseStartElement ();  		}  		else  			throw new XmlException ("JsonEncounteredUnexpectedCharacter");  		break;  	case Keys.LowerF:  		{  			int offset;  			byte[] buffer = this.BufferReader.GetBuffer (5' out offset);  			// Check if it's "false"  			if (buffer [offset + 1] != Keys.LowerA || buffer [offset + 2] != Keys.LowerL || buffer [offset + 3] != Keys.LowerS || buffer [offset + 4] != Keys.LowerE)  				throw new Exception ("Expected False");  			// Advance of 5 byte  			this.BufferReader.Advance (5);  			// Check if char after is a closing one  			if (TryGetByte (out ch) && !IsWhitespace (ch) && (ch != Keys.Comma && ch != Keys.RightClosingBrace) && ch != Keys.RightClosingBracket)  				throw new Exception ("TokenExpected");  			// Move  			this.MoveToAtomicText ().Value.SetValue (ValueHandleType.UTF8' offset' 5);  		}  		break;  	case Keys.LowerT:  		{  			int offset;  			// check if it's "true"  			byte[] buffer = this.BufferReader.GetBuffer (4' out offset);  			if (buffer [offset + 1] != Keys.LowerR || buffer [offset + 2] != Keys.LowerU || buffer [offset + 3] != Keys.LowerE)  				throw new Exception ("expected true");  			this.BufferReader.Advance (4);  			// Check if char after is a closing one  			if (TryGetByte (out ch) && !IsWhitespace (ch) && (ch != Keys.Comma && ch != Keys.RightClosingBrace) && ch != Keys.RightClosingBracket)  				throw new Exception ("TokenExpected");  			// move atomic  			this.MoveToAtomicText ().Value.SetValue (ValueHandleType.UTF8' offset' 4);  		}  		break;  	case Keys.LowerN:  		{  			int offset;  			// check if it's "null"  			byte[] buffer = this.BufferReader.GetBuffer (4' out offset);  			if (buffer [offset + 1] != Keys.LowerU || buffer [offset + 2] != Keys.LowerL || buffer [offset + 3] != Keys.LowerL)  				throw new Exception ("Expected null");  			// advance of 4 chars  			this.BufferReader.Advance (4);  			SkipWhitespaceInBufferReader ();  			if (TryGetByte (out ch)) {  				if (ch == Keys.Comma || ch == Keys.RightClosingBrace)  					this.BufferReader.SkipByte ();  				else if (ch != Keys.RightClosingBracket)  					throw new Exception ("TokenExpected");  			}  			else {  				charactersToSkipOnNextRead [0] = Keys.Comma;  				charactersToSkipOnNextRead [1] = Keys.RightClosingBrace;  			}  			MoveToEndElement ();  		}  		break;  	default:  		if ((ch == (byte)'-') || (((byte)'0' <= ch) && (ch <= (byte)'9')) || (ch == (byte)'I') || (ch == (byte)'N'))  			ReadNumericalText ();  		else  			throw new XmlException ("JsonEncounteredUnexpectedCharacter");  		break;  	}  
Magic Number,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,Read,The following statement contains a magic number: if (scopeDepth == 0) {  	ReadNonExistentElementName (StringHandleConstStringType.Root);  }  else if (IsReadingComplexText) {  	switch (complexTextMode) {  	case JsonComplexTextMode.QuotedText:  		if (ch == Keys.BackSlash) {  			ReadEscapedCharacter (true);  			break;  		}  		ReadQuotedText (true);  		break;  	case JsonComplexTextMode.NumericalText:  		ReadNumericalText ();  		break;  	case JsonComplexTextMode.None:  		throw new XmlException ("JsonEncounteredUnexpectedCharacter");  	}  }  else if (IsReadingCollection)  	ReadNonExistentElementName (StringHandleConstStringType.Item);  else  	switch (ch) {  	case Keys.RightClosingBracket:  		this.BufferReader.SkipByte ();  		MoveToEndElement ();  		ExitJsonScope ();  		break;  	case Keys.LeftOpeningBrace:  		this.BufferReader.SkipByte ();  		SkipWhitespaceInBufferReader ();  		ch = this.BufferReader.GetByte ();  		if (ch == Keys.RightClosingBrace) {  			// Skip this byte  			this.BufferReader.SkipByte ();  			// Skip white spaces  			SkipWhitespaceInBufferReader ();  			// try get next char  			if (TryGetByte (out ch)) {  				if (ch == Keys.Comma)  					this.BufferReader.SkipByte ();  			}  			else {  				// We are at end of buffer' just mark Comma to be skipped next time  				charactersToSkipOnNextRead [0] = Keys.Comma;  			}  			// We set to End Element  			MoveToEndElement ();  		}  		else {  			// Enter a new scope  			EnterJsonScope (JsonNodeType.Object);  			// Parse start element  			ParseStartElement ();  		}  		break;  	case Keys.RightClosingBrace:  		this.BufferReader.SkipByte ();  		if (expectingFirstElementInNonPrimitiveChild) {  			SkipWhitespaceInBufferReader ();  			ch = this.BufferReader.GetByte ();  			switch (ch) {  			case Keys.Comma:  			case Keys.RightClosingBrace:  				this.BufferReader.SkipByte ();  				break;  			default:  				throw new XmlException ("JsonEncounteredUnexpectedCharacter");  			}  			expectingFirstElementInNonPrimitiveChild = false;  		}  		MoveToEndElement ();  		break;  	case Keys.Comma:  		this.BufferReader.SkipByte ();  		MoveToEndElement ();  		break;  	case Keys.DoubleQuote:  		if (this.Node.NodeType == XmlNodeType.Element) {  			if (expectingFirstElementInNonPrimitiveChild) {  				EnterJsonScope (JsonNodeType.Object);  				ParseStartElement ();  			}  			else {  				this.BufferReader.SkipByte ();  				ReadQuotedText (true);  			}  		}  		else if (this.Node.NodeType == XmlNodeType.EndElement) {  			EnterJsonScope (JsonNodeType.Element);  			ParseStartElement ();  		}  		else  			throw new XmlException ("JsonEncounteredUnexpectedCharacter");  		break;  	case Keys.LowerF:  		{  			int offset;  			byte[] buffer = this.BufferReader.GetBuffer (5' out offset);  			// Check if it's "false"  			if (buffer [offset + 1] != Keys.LowerA || buffer [offset + 2] != Keys.LowerL || buffer [offset + 3] != Keys.LowerS || buffer [offset + 4] != Keys.LowerE)  				throw new Exception ("Expected False");  			// Advance of 5 byte  			this.BufferReader.Advance (5);  			// Check if char after is a closing one  			if (TryGetByte (out ch) && !IsWhitespace (ch) && (ch != Keys.Comma && ch != Keys.RightClosingBrace) && ch != Keys.RightClosingBracket)  				throw new Exception ("TokenExpected");  			// Move  			this.MoveToAtomicText ().Value.SetValue (ValueHandleType.UTF8' offset' 5);  		}  		break;  	case Keys.LowerT:  		{  			int offset;  			// check if it's "true"  			byte[] buffer = this.BufferReader.GetBuffer (4' out offset);  			if (buffer [offset + 1] != Keys.LowerR || buffer [offset + 2] != Keys.LowerU || buffer [offset + 3] != Keys.LowerE)  				throw new Exception ("expected true");  			this.BufferReader.Advance (4);  			// Check if char after is a closing one  			if (TryGetByte (out ch) && !IsWhitespace (ch) && (ch != Keys.Comma && ch != Keys.RightClosingBrace) && ch != Keys.RightClosingBracket)  				throw new Exception ("TokenExpected");  			// move atomic  			this.MoveToAtomicText ().Value.SetValue (ValueHandleType.UTF8' offset' 4);  		}  		break;  	case Keys.LowerN:  		{  			int offset;  			// check if it's "null"  			byte[] buffer = this.BufferReader.GetBuffer (4' out offset);  			if (buffer [offset + 1] != Keys.LowerU || buffer [offset + 2] != Keys.LowerL || buffer [offset + 3] != Keys.LowerL)  				throw new Exception ("Expected null");  			// advance of 4 chars  			this.BufferReader.Advance (4);  			SkipWhitespaceInBufferReader ();  			if (TryGetByte (out ch)) {  				if (ch == Keys.Comma || ch == Keys.RightClosingBrace)  					this.BufferReader.SkipByte ();  				else if (ch != Keys.RightClosingBracket)  					throw new Exception ("TokenExpected");  			}  			else {  				charactersToSkipOnNextRead [0] = Keys.Comma;  				charactersToSkipOnNextRead [1] = Keys.RightClosingBrace;  			}  			MoveToEndElement ();  		}  		break;  	default:  		if ((ch == (byte)'-') || (((byte)'0' <= ch) && (ch <= (byte)'9')) || (ch == (byte)'I') || (ch == (byte)'N'))  			ReadNumericalText ();  		else  			throw new XmlException ("JsonEncounteredUnexpectedCharacter");  		break;  	}  
Magic Number,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,Read,The following statement contains a magic number: if (scopeDepth == 0) {  	ReadNonExistentElementName (StringHandleConstStringType.Root);  }  else if (IsReadingComplexText) {  	switch (complexTextMode) {  	case JsonComplexTextMode.QuotedText:  		if (ch == Keys.BackSlash) {  			ReadEscapedCharacter (true);  			break;  		}  		ReadQuotedText (true);  		break;  	case JsonComplexTextMode.NumericalText:  		ReadNumericalText ();  		break;  	case JsonComplexTextMode.None:  		throw new XmlException ("JsonEncounteredUnexpectedCharacter");  	}  }  else if (IsReadingCollection)  	ReadNonExistentElementName (StringHandleConstStringType.Item);  else  	switch (ch) {  	case Keys.RightClosingBracket:  		this.BufferReader.SkipByte ();  		MoveToEndElement ();  		ExitJsonScope ();  		break;  	case Keys.LeftOpeningBrace:  		this.BufferReader.SkipByte ();  		SkipWhitespaceInBufferReader ();  		ch = this.BufferReader.GetByte ();  		if (ch == Keys.RightClosingBrace) {  			// Skip this byte  			this.BufferReader.SkipByte ();  			// Skip white spaces  			SkipWhitespaceInBufferReader ();  			// try get next char  			if (TryGetByte (out ch)) {  				if (ch == Keys.Comma)  					this.BufferReader.SkipByte ();  			}  			else {  				// We are at end of buffer' just mark Comma to be skipped next time  				charactersToSkipOnNextRead [0] = Keys.Comma;  			}  			// We set to End Element  			MoveToEndElement ();  		}  		else {  			// Enter a new scope  			EnterJsonScope (JsonNodeType.Object);  			// Parse start element  			ParseStartElement ();  		}  		break;  	case Keys.RightClosingBrace:  		this.BufferReader.SkipByte ();  		if (expectingFirstElementInNonPrimitiveChild) {  			SkipWhitespaceInBufferReader ();  			ch = this.BufferReader.GetByte ();  			switch (ch) {  			case Keys.Comma:  			case Keys.RightClosingBrace:  				this.BufferReader.SkipByte ();  				break;  			default:  				throw new XmlException ("JsonEncounteredUnexpectedCharacter");  			}  			expectingFirstElementInNonPrimitiveChild = false;  		}  		MoveToEndElement ();  		break;  	case Keys.Comma:  		this.BufferReader.SkipByte ();  		MoveToEndElement ();  		break;  	case Keys.DoubleQuote:  		if (this.Node.NodeType == XmlNodeType.Element) {  			if (expectingFirstElementInNonPrimitiveChild) {  				EnterJsonScope (JsonNodeType.Object);  				ParseStartElement ();  			}  			else {  				this.BufferReader.SkipByte ();  				ReadQuotedText (true);  			}  		}  		else if (this.Node.NodeType == XmlNodeType.EndElement) {  			EnterJsonScope (JsonNodeType.Element);  			ParseStartElement ();  		}  		else  			throw new XmlException ("JsonEncounteredUnexpectedCharacter");  		break;  	case Keys.LowerF:  		{  			int offset;  			byte[] buffer = this.BufferReader.GetBuffer (5' out offset);  			// Check if it's "false"  			if (buffer [offset + 1] != Keys.LowerA || buffer [offset + 2] != Keys.LowerL || buffer [offset + 3] != Keys.LowerS || buffer [offset + 4] != Keys.LowerE)  				throw new Exception ("Expected False");  			// Advance of 5 byte  			this.BufferReader.Advance (5);  			// Check if char after is a closing one  			if (TryGetByte (out ch) && !IsWhitespace (ch) && (ch != Keys.Comma && ch != Keys.RightClosingBrace) && ch != Keys.RightClosingBracket)  				throw new Exception ("TokenExpected");  			// Move  			this.MoveToAtomicText ().Value.SetValue (ValueHandleType.UTF8' offset' 5);  		}  		break;  	case Keys.LowerT:  		{  			int offset;  			// check if it's "true"  			byte[] buffer = this.BufferReader.GetBuffer (4' out offset);  			if (buffer [offset + 1] != Keys.LowerR || buffer [offset + 2] != Keys.LowerU || buffer [offset + 3] != Keys.LowerE)  				throw new Exception ("expected true");  			this.BufferReader.Advance (4);  			// Check if char after is a closing one  			if (TryGetByte (out ch) && !IsWhitespace (ch) && (ch != Keys.Comma && ch != Keys.RightClosingBrace) && ch != Keys.RightClosingBracket)  				throw new Exception ("TokenExpected");  			// move atomic  			this.MoveToAtomicText ().Value.SetValue (ValueHandleType.UTF8' offset' 4);  		}  		break;  	case Keys.LowerN:  		{  			int offset;  			// check if it's "null"  			byte[] buffer = this.BufferReader.GetBuffer (4' out offset);  			if (buffer [offset + 1] != Keys.LowerU || buffer [offset + 2] != Keys.LowerL || buffer [offset + 3] != Keys.LowerL)  				throw new Exception ("Expected null");  			// advance of 4 chars  			this.BufferReader.Advance (4);  			SkipWhitespaceInBufferReader ();  			if (TryGetByte (out ch)) {  				if (ch == Keys.Comma || ch == Keys.RightClosingBrace)  					this.BufferReader.SkipByte ();  				else if (ch != Keys.RightClosingBracket)  					throw new Exception ("TokenExpected");  			}  			else {  				charactersToSkipOnNextRead [0] = Keys.Comma;  				charactersToSkipOnNextRead [1] = Keys.RightClosingBrace;  			}  			MoveToEndElement ();  		}  		break;  	default:  		if ((ch == (byte)'-') || (((byte)'0' <= ch) && (ch <= (byte)'9')) || (ch == (byte)'I') || (ch == (byte)'N'))  			ReadNumericalText ();  		else  			throw new XmlException ("JsonEncounteredUnexpectedCharacter");  		break;  	}  
Magic Number,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,Read,The following statement contains a magic number: if (scopeDepth == 0) {  	ReadNonExistentElementName (StringHandleConstStringType.Root);  }  else if (IsReadingComplexText) {  	switch (complexTextMode) {  	case JsonComplexTextMode.QuotedText:  		if (ch == Keys.BackSlash) {  			ReadEscapedCharacter (true);  			break;  		}  		ReadQuotedText (true);  		break;  	case JsonComplexTextMode.NumericalText:  		ReadNumericalText ();  		break;  	case JsonComplexTextMode.None:  		throw new XmlException ("JsonEncounteredUnexpectedCharacter");  	}  }  else if (IsReadingCollection)  	ReadNonExistentElementName (StringHandleConstStringType.Item);  else  	switch (ch) {  	case Keys.RightClosingBracket:  		this.BufferReader.SkipByte ();  		MoveToEndElement ();  		ExitJsonScope ();  		break;  	case Keys.LeftOpeningBrace:  		this.BufferReader.SkipByte ();  		SkipWhitespaceInBufferReader ();  		ch = this.BufferReader.GetByte ();  		if (ch == Keys.RightClosingBrace) {  			// Skip this byte  			this.BufferReader.SkipByte ();  			// Skip white spaces  			SkipWhitespaceInBufferReader ();  			// try get next char  			if (TryGetByte (out ch)) {  				if (ch == Keys.Comma)  					this.BufferReader.SkipByte ();  			}  			else {  				// We are at end of buffer' just mark Comma to be skipped next time  				charactersToSkipOnNextRead [0] = Keys.Comma;  			}  			// We set to End Element  			MoveToEndElement ();  		}  		else {  			// Enter a new scope  			EnterJsonScope (JsonNodeType.Object);  			// Parse start element  			ParseStartElement ();  		}  		break;  	case Keys.RightClosingBrace:  		this.BufferReader.SkipByte ();  		if (expectingFirstElementInNonPrimitiveChild) {  			SkipWhitespaceInBufferReader ();  			ch = this.BufferReader.GetByte ();  			switch (ch) {  			case Keys.Comma:  			case Keys.RightClosingBrace:  				this.BufferReader.SkipByte ();  				break;  			default:  				throw new XmlException ("JsonEncounteredUnexpectedCharacter");  			}  			expectingFirstElementInNonPrimitiveChild = false;  		}  		MoveToEndElement ();  		break;  	case Keys.Comma:  		this.BufferReader.SkipByte ();  		MoveToEndElement ();  		break;  	case Keys.DoubleQuote:  		if (this.Node.NodeType == XmlNodeType.Element) {  			if (expectingFirstElementInNonPrimitiveChild) {  				EnterJsonScope (JsonNodeType.Object);  				ParseStartElement ();  			}  			else {  				this.BufferReader.SkipByte ();  				ReadQuotedText (true);  			}  		}  		else if (this.Node.NodeType == XmlNodeType.EndElement) {  			EnterJsonScope (JsonNodeType.Element);  			ParseStartElement ();  		}  		else  			throw new XmlException ("JsonEncounteredUnexpectedCharacter");  		break;  	case Keys.LowerF:  		{  			int offset;  			byte[] buffer = this.BufferReader.GetBuffer (5' out offset);  			// Check if it's "false"  			if (buffer [offset + 1] != Keys.LowerA || buffer [offset + 2] != Keys.LowerL || buffer [offset + 3] != Keys.LowerS || buffer [offset + 4] != Keys.LowerE)  				throw new Exception ("Expected False");  			// Advance of 5 byte  			this.BufferReader.Advance (5);  			// Check if char after is a closing one  			if (TryGetByte (out ch) && !IsWhitespace (ch) && (ch != Keys.Comma && ch != Keys.RightClosingBrace) && ch != Keys.RightClosingBracket)  				throw new Exception ("TokenExpected");  			// Move  			this.MoveToAtomicText ().Value.SetValue (ValueHandleType.UTF8' offset' 5);  		}  		break;  	case Keys.LowerT:  		{  			int offset;  			// check if it's "true"  			byte[] buffer = this.BufferReader.GetBuffer (4' out offset);  			if (buffer [offset + 1] != Keys.LowerR || buffer [offset + 2] != Keys.LowerU || buffer [offset + 3] != Keys.LowerE)  				throw new Exception ("expected true");  			this.BufferReader.Advance (4);  			// Check if char after is a closing one  			if (TryGetByte (out ch) && !IsWhitespace (ch) && (ch != Keys.Comma && ch != Keys.RightClosingBrace) && ch != Keys.RightClosingBracket)  				throw new Exception ("TokenExpected");  			// move atomic  			this.MoveToAtomicText ().Value.SetValue (ValueHandleType.UTF8' offset' 4);  		}  		break;  	case Keys.LowerN:  		{  			int offset;  			// check if it's "null"  			byte[] buffer = this.BufferReader.GetBuffer (4' out offset);  			if (buffer [offset + 1] != Keys.LowerU || buffer [offset + 2] != Keys.LowerL || buffer [offset + 3] != Keys.LowerL)  				throw new Exception ("Expected null");  			// advance of 4 chars  			this.BufferReader.Advance (4);  			SkipWhitespaceInBufferReader ();  			if (TryGetByte (out ch)) {  				if (ch == Keys.Comma || ch == Keys.RightClosingBrace)  					this.BufferReader.SkipByte ();  				else if (ch != Keys.RightClosingBracket)  					throw new Exception ("TokenExpected");  			}  			else {  				charactersToSkipOnNextRead [0] = Keys.Comma;  				charactersToSkipOnNextRead [1] = Keys.RightClosingBrace;  			}  			MoveToEndElement ();  		}  		break;  	default:  		if ((ch == (byte)'-') || (((byte)'0' <= ch) && (ch <= (byte)'9')) || (ch == (byte)'I') || (ch == (byte)'N'))  			ReadNumericalText ();  		else  			throw new XmlException ("JsonEncounteredUnexpectedCharacter");  		break;  	}  
Magic Number,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,Read,The following statement contains a magic number: if (scopeDepth == 0) {  	ReadNonExistentElementName (StringHandleConstStringType.Root);  }  else if (IsReadingComplexText) {  	switch (complexTextMode) {  	case JsonComplexTextMode.QuotedText:  		if (ch == Keys.BackSlash) {  			ReadEscapedCharacter (true);  			break;  		}  		ReadQuotedText (true);  		break;  	case JsonComplexTextMode.NumericalText:  		ReadNumericalText ();  		break;  	case JsonComplexTextMode.None:  		throw new XmlException ("JsonEncounteredUnexpectedCharacter");  	}  }  else if (IsReadingCollection)  	ReadNonExistentElementName (StringHandleConstStringType.Item);  else  	switch (ch) {  	case Keys.RightClosingBracket:  		this.BufferReader.SkipByte ();  		MoveToEndElement ();  		ExitJsonScope ();  		break;  	case Keys.LeftOpeningBrace:  		this.BufferReader.SkipByte ();  		SkipWhitespaceInBufferReader ();  		ch = this.BufferReader.GetByte ();  		if (ch == Keys.RightClosingBrace) {  			// Skip this byte  			this.BufferReader.SkipByte ();  			// Skip white spaces  			SkipWhitespaceInBufferReader ();  			// try get next char  			if (TryGetByte (out ch)) {  				if (ch == Keys.Comma)  					this.BufferReader.SkipByte ();  			}  			else {  				// We are at end of buffer' just mark Comma to be skipped next time  				charactersToSkipOnNextRead [0] = Keys.Comma;  			}  			// We set to End Element  			MoveToEndElement ();  		}  		else {  			// Enter a new scope  			EnterJsonScope (JsonNodeType.Object);  			// Parse start element  			ParseStartElement ();  		}  		break;  	case Keys.RightClosingBrace:  		this.BufferReader.SkipByte ();  		if (expectingFirstElementInNonPrimitiveChild) {  			SkipWhitespaceInBufferReader ();  			ch = this.BufferReader.GetByte ();  			switch (ch) {  			case Keys.Comma:  			case Keys.RightClosingBrace:  				this.BufferReader.SkipByte ();  				break;  			default:  				throw new XmlException ("JsonEncounteredUnexpectedCharacter");  			}  			expectingFirstElementInNonPrimitiveChild = false;  		}  		MoveToEndElement ();  		break;  	case Keys.Comma:  		this.BufferReader.SkipByte ();  		MoveToEndElement ();  		break;  	case Keys.DoubleQuote:  		if (this.Node.NodeType == XmlNodeType.Element) {  			if (expectingFirstElementInNonPrimitiveChild) {  				EnterJsonScope (JsonNodeType.Object);  				ParseStartElement ();  			}  			else {  				this.BufferReader.SkipByte ();  				ReadQuotedText (true);  			}  		}  		else if (this.Node.NodeType == XmlNodeType.EndElement) {  			EnterJsonScope (JsonNodeType.Element);  			ParseStartElement ();  		}  		else  			throw new XmlException ("JsonEncounteredUnexpectedCharacter");  		break;  	case Keys.LowerF:  		{  			int offset;  			byte[] buffer = this.BufferReader.GetBuffer (5' out offset);  			// Check if it's "false"  			if (buffer [offset + 1] != Keys.LowerA || buffer [offset + 2] != Keys.LowerL || buffer [offset + 3] != Keys.LowerS || buffer [offset + 4] != Keys.LowerE)  				throw new Exception ("Expected False");  			// Advance of 5 byte  			this.BufferReader.Advance (5);  			// Check if char after is a closing one  			if (TryGetByte (out ch) && !IsWhitespace (ch) && (ch != Keys.Comma && ch != Keys.RightClosingBrace) && ch != Keys.RightClosingBracket)  				throw new Exception ("TokenExpected");  			// Move  			this.MoveToAtomicText ().Value.SetValue (ValueHandleType.UTF8' offset' 5);  		}  		break;  	case Keys.LowerT:  		{  			int offset;  			// check if it's "true"  			byte[] buffer = this.BufferReader.GetBuffer (4' out offset);  			if (buffer [offset + 1] != Keys.LowerR || buffer [offset + 2] != Keys.LowerU || buffer [offset + 3] != Keys.LowerE)  				throw new Exception ("expected true");  			this.BufferReader.Advance (4);  			// Check if char after is a closing one  			if (TryGetByte (out ch) && !IsWhitespace (ch) && (ch != Keys.Comma && ch != Keys.RightClosingBrace) && ch != Keys.RightClosingBracket)  				throw new Exception ("TokenExpected");  			// move atomic  			this.MoveToAtomicText ().Value.SetValue (ValueHandleType.UTF8' offset' 4);  		}  		break;  	case Keys.LowerN:  		{  			int offset;  			// check if it's "null"  			byte[] buffer = this.BufferReader.GetBuffer (4' out offset);  			if (buffer [offset + 1] != Keys.LowerU || buffer [offset + 2] != Keys.LowerL || buffer [offset + 3] != Keys.LowerL)  				throw new Exception ("Expected null");  			// advance of 4 chars  			this.BufferReader.Advance (4);  			SkipWhitespaceInBufferReader ();  			if (TryGetByte (out ch)) {  				if (ch == Keys.Comma || ch == Keys.RightClosingBrace)  					this.BufferReader.SkipByte ();  				else if (ch != Keys.RightClosingBracket)  					throw new Exception ("TokenExpected");  			}  			else {  				charactersToSkipOnNextRead [0] = Keys.Comma;  				charactersToSkipOnNextRead [1] = Keys.RightClosingBrace;  			}  			MoveToEndElement ();  		}  		break;  	default:  		if ((ch == (byte)'-') || (((byte)'0' <= ch) && (ch <= (byte)'9')) || (ch == (byte)'I') || (ch == (byte)'N'))  			ReadNumericalText ();  		else  			throw new XmlException ("JsonEncounteredUnexpectedCharacter");  		break;  	}  
Magic Number,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,Read,The following statement contains a magic number: if (scopeDepth == 0) {  	ReadNonExistentElementName (StringHandleConstStringType.Root);  }  else if (IsReadingComplexText) {  	switch (complexTextMode) {  	case JsonComplexTextMode.QuotedText:  		if (ch == Keys.BackSlash) {  			ReadEscapedCharacter (true);  			break;  		}  		ReadQuotedText (true);  		break;  	case JsonComplexTextMode.NumericalText:  		ReadNumericalText ();  		break;  	case JsonComplexTextMode.None:  		throw new XmlException ("JsonEncounteredUnexpectedCharacter");  	}  }  else if (IsReadingCollection)  	ReadNonExistentElementName (StringHandleConstStringType.Item);  else  	switch (ch) {  	case Keys.RightClosingBracket:  		this.BufferReader.SkipByte ();  		MoveToEndElement ();  		ExitJsonScope ();  		break;  	case Keys.LeftOpeningBrace:  		this.BufferReader.SkipByte ();  		SkipWhitespaceInBufferReader ();  		ch = this.BufferReader.GetByte ();  		if (ch == Keys.RightClosingBrace) {  			// Skip this byte  			this.BufferReader.SkipByte ();  			// Skip white spaces  			SkipWhitespaceInBufferReader ();  			// try get next char  			if (TryGetByte (out ch)) {  				if (ch == Keys.Comma)  					this.BufferReader.SkipByte ();  			}  			else {  				// We are at end of buffer' just mark Comma to be skipped next time  				charactersToSkipOnNextRead [0] = Keys.Comma;  			}  			// We set to End Element  			MoveToEndElement ();  		}  		else {  			// Enter a new scope  			EnterJsonScope (JsonNodeType.Object);  			// Parse start element  			ParseStartElement ();  		}  		break;  	case Keys.RightClosingBrace:  		this.BufferReader.SkipByte ();  		if (expectingFirstElementInNonPrimitiveChild) {  			SkipWhitespaceInBufferReader ();  			ch = this.BufferReader.GetByte ();  			switch (ch) {  			case Keys.Comma:  			case Keys.RightClosingBrace:  				this.BufferReader.SkipByte ();  				break;  			default:  				throw new XmlException ("JsonEncounteredUnexpectedCharacter");  			}  			expectingFirstElementInNonPrimitiveChild = false;  		}  		MoveToEndElement ();  		break;  	case Keys.Comma:  		this.BufferReader.SkipByte ();  		MoveToEndElement ();  		break;  	case Keys.DoubleQuote:  		if (this.Node.NodeType == XmlNodeType.Element) {  			if (expectingFirstElementInNonPrimitiveChild) {  				EnterJsonScope (JsonNodeType.Object);  				ParseStartElement ();  			}  			else {  				this.BufferReader.SkipByte ();  				ReadQuotedText (true);  			}  		}  		else if (this.Node.NodeType == XmlNodeType.EndElement) {  			EnterJsonScope (JsonNodeType.Element);  			ParseStartElement ();  		}  		else  			throw new XmlException ("JsonEncounteredUnexpectedCharacter");  		break;  	case Keys.LowerF:  		{  			int offset;  			byte[] buffer = this.BufferReader.GetBuffer (5' out offset);  			// Check if it's "false"  			if (buffer [offset + 1] != Keys.LowerA || buffer [offset + 2] != Keys.LowerL || buffer [offset + 3] != Keys.LowerS || buffer [offset + 4] != Keys.LowerE)  				throw new Exception ("Expected False");  			// Advance of 5 byte  			this.BufferReader.Advance (5);  			// Check if char after is a closing one  			if (TryGetByte (out ch) && !IsWhitespace (ch) && (ch != Keys.Comma && ch != Keys.RightClosingBrace) && ch != Keys.RightClosingBracket)  				throw new Exception ("TokenExpected");  			// Move  			this.MoveToAtomicText ().Value.SetValue (ValueHandleType.UTF8' offset' 5);  		}  		break;  	case Keys.LowerT:  		{  			int offset;  			// check if it's "true"  			byte[] buffer = this.BufferReader.GetBuffer (4' out offset);  			if (buffer [offset + 1] != Keys.LowerR || buffer [offset + 2] != Keys.LowerU || buffer [offset + 3] != Keys.LowerE)  				throw new Exception ("expected true");  			this.BufferReader.Advance (4);  			// Check if char after is a closing one  			if (TryGetByte (out ch) && !IsWhitespace (ch) && (ch != Keys.Comma && ch != Keys.RightClosingBrace) && ch != Keys.RightClosingBracket)  				throw new Exception ("TokenExpected");  			// move atomic  			this.MoveToAtomicText ().Value.SetValue (ValueHandleType.UTF8' offset' 4);  		}  		break;  	case Keys.LowerN:  		{  			int offset;  			// check if it's "null"  			byte[] buffer = this.BufferReader.GetBuffer (4' out offset);  			if (buffer [offset + 1] != Keys.LowerU || buffer [offset + 2] != Keys.LowerL || buffer [offset + 3] != Keys.LowerL)  				throw new Exception ("Expected null");  			// advance of 4 chars  			this.BufferReader.Advance (4);  			SkipWhitespaceInBufferReader ();  			if (TryGetByte (out ch)) {  				if (ch == Keys.Comma || ch == Keys.RightClosingBrace)  					this.BufferReader.SkipByte ();  				else if (ch != Keys.RightClosingBracket)  					throw new Exception ("TokenExpected");  			}  			else {  				charactersToSkipOnNextRead [0] = Keys.Comma;  				charactersToSkipOnNextRead [1] = Keys.RightClosingBrace;  			}  			MoveToEndElement ();  		}  		break;  	default:  		if ((ch == (byte)'-') || (((byte)'0' <= ch) && (ch <= (byte)'9')) || (ch == (byte)'I') || (ch == (byte)'N'))  			ReadNumericalText ();  		else  			throw new XmlException ("JsonEncounteredUnexpectedCharacter");  		break;  	}  
Magic Number,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,Read,The following statement contains a magic number: if (scopeDepth == 0) {  	ReadNonExistentElementName (StringHandleConstStringType.Root);  }  else if (IsReadingComplexText) {  	switch (complexTextMode) {  	case JsonComplexTextMode.QuotedText:  		if (ch == Keys.BackSlash) {  			ReadEscapedCharacter (true);  			break;  		}  		ReadQuotedText (true);  		break;  	case JsonComplexTextMode.NumericalText:  		ReadNumericalText ();  		break;  	case JsonComplexTextMode.None:  		throw new XmlException ("JsonEncounteredUnexpectedCharacter");  	}  }  else if (IsReadingCollection)  	ReadNonExistentElementName (StringHandleConstStringType.Item);  else  	switch (ch) {  	case Keys.RightClosingBracket:  		this.BufferReader.SkipByte ();  		MoveToEndElement ();  		ExitJsonScope ();  		break;  	case Keys.LeftOpeningBrace:  		this.BufferReader.SkipByte ();  		SkipWhitespaceInBufferReader ();  		ch = this.BufferReader.GetByte ();  		if (ch == Keys.RightClosingBrace) {  			// Skip this byte  			this.BufferReader.SkipByte ();  			// Skip white spaces  			SkipWhitespaceInBufferReader ();  			// try get next char  			if (TryGetByte (out ch)) {  				if (ch == Keys.Comma)  					this.BufferReader.SkipByte ();  			}  			else {  				// We are at end of buffer' just mark Comma to be skipped next time  				charactersToSkipOnNextRead [0] = Keys.Comma;  			}  			// We set to End Element  			MoveToEndElement ();  		}  		else {  			// Enter a new scope  			EnterJsonScope (JsonNodeType.Object);  			// Parse start element  			ParseStartElement ();  		}  		break;  	case Keys.RightClosingBrace:  		this.BufferReader.SkipByte ();  		if (expectingFirstElementInNonPrimitiveChild) {  			SkipWhitespaceInBufferReader ();  			ch = this.BufferReader.GetByte ();  			switch (ch) {  			case Keys.Comma:  			case Keys.RightClosingBrace:  				this.BufferReader.SkipByte ();  				break;  			default:  				throw new XmlException ("JsonEncounteredUnexpectedCharacter");  			}  			expectingFirstElementInNonPrimitiveChild = false;  		}  		MoveToEndElement ();  		break;  	case Keys.Comma:  		this.BufferReader.SkipByte ();  		MoveToEndElement ();  		break;  	case Keys.DoubleQuote:  		if (this.Node.NodeType == XmlNodeType.Element) {  			if (expectingFirstElementInNonPrimitiveChild) {  				EnterJsonScope (JsonNodeType.Object);  				ParseStartElement ();  			}  			else {  				this.BufferReader.SkipByte ();  				ReadQuotedText (true);  			}  		}  		else if (this.Node.NodeType == XmlNodeType.EndElement) {  			EnterJsonScope (JsonNodeType.Element);  			ParseStartElement ();  		}  		else  			throw new XmlException ("JsonEncounteredUnexpectedCharacter");  		break;  	case Keys.LowerF:  		{  			int offset;  			byte[] buffer = this.BufferReader.GetBuffer (5' out offset);  			// Check if it's "false"  			if (buffer [offset + 1] != Keys.LowerA || buffer [offset + 2] != Keys.LowerL || buffer [offset + 3] != Keys.LowerS || buffer [offset + 4] != Keys.LowerE)  				throw new Exception ("Expected False");  			// Advance of 5 byte  			this.BufferReader.Advance (5);  			// Check if char after is a closing one  			if (TryGetByte (out ch) && !IsWhitespace (ch) && (ch != Keys.Comma && ch != Keys.RightClosingBrace) && ch != Keys.RightClosingBracket)  				throw new Exception ("TokenExpected");  			// Move  			this.MoveToAtomicText ().Value.SetValue (ValueHandleType.UTF8' offset' 5);  		}  		break;  	case Keys.LowerT:  		{  			int offset;  			// check if it's "true"  			byte[] buffer = this.BufferReader.GetBuffer (4' out offset);  			if (buffer [offset + 1] != Keys.LowerR || buffer [offset + 2] != Keys.LowerU || buffer [offset + 3] != Keys.LowerE)  				throw new Exception ("expected true");  			this.BufferReader.Advance (4);  			// Check if char after is a closing one  			if (TryGetByte (out ch) && !IsWhitespace (ch) && (ch != Keys.Comma && ch != Keys.RightClosingBrace) && ch != Keys.RightClosingBracket)  				throw new Exception ("TokenExpected");  			// move atomic  			this.MoveToAtomicText ().Value.SetValue (ValueHandleType.UTF8' offset' 4);  		}  		break;  	case Keys.LowerN:  		{  			int offset;  			// check if it's "null"  			byte[] buffer = this.BufferReader.GetBuffer (4' out offset);  			if (buffer [offset + 1] != Keys.LowerU || buffer [offset + 2] != Keys.LowerL || buffer [offset + 3] != Keys.LowerL)  				throw new Exception ("Expected null");  			// advance of 4 chars  			this.BufferReader.Advance (4);  			SkipWhitespaceInBufferReader ();  			if (TryGetByte (out ch)) {  				if (ch == Keys.Comma || ch == Keys.RightClosingBrace)  					this.BufferReader.SkipByte ();  				else if (ch != Keys.RightClosingBracket)  					throw new Exception ("TokenExpected");  			}  			else {  				charactersToSkipOnNextRead [0] = Keys.Comma;  				charactersToSkipOnNextRead [1] = Keys.RightClosingBrace;  			}  			MoveToEndElement ();  		}  		break;  	default:  		if ((ch == (byte)'-') || (((byte)'0' <= ch) && (ch <= (byte)'9')) || (ch == (byte)'I') || (ch == (byte)'N'))  			ReadNumericalText ();  		else  			throw new XmlException ("JsonEncounteredUnexpectedCharacter");  		break;  	}  
Magic Number,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,Read,The following statement contains a magic number: if (scopeDepth == 0) {  	ReadNonExistentElementName (StringHandleConstStringType.Root);  }  else if (IsReadingComplexText) {  	switch (complexTextMode) {  	case JsonComplexTextMode.QuotedText:  		if (ch == Keys.BackSlash) {  			ReadEscapedCharacter (true);  			break;  		}  		ReadQuotedText (true);  		break;  	case JsonComplexTextMode.NumericalText:  		ReadNumericalText ();  		break;  	case JsonComplexTextMode.None:  		throw new XmlException ("JsonEncounteredUnexpectedCharacter");  	}  }  else if (IsReadingCollection)  	ReadNonExistentElementName (StringHandleConstStringType.Item);  else  	switch (ch) {  	case Keys.RightClosingBracket:  		this.BufferReader.SkipByte ();  		MoveToEndElement ();  		ExitJsonScope ();  		break;  	case Keys.LeftOpeningBrace:  		this.BufferReader.SkipByte ();  		SkipWhitespaceInBufferReader ();  		ch = this.BufferReader.GetByte ();  		if (ch == Keys.RightClosingBrace) {  			// Skip this byte  			this.BufferReader.SkipByte ();  			// Skip white spaces  			SkipWhitespaceInBufferReader ();  			// try get next char  			if (TryGetByte (out ch)) {  				if (ch == Keys.Comma)  					this.BufferReader.SkipByte ();  			}  			else {  				// We are at end of buffer' just mark Comma to be skipped next time  				charactersToSkipOnNextRead [0] = Keys.Comma;  			}  			// We set to End Element  			MoveToEndElement ();  		}  		else {  			// Enter a new scope  			EnterJsonScope (JsonNodeType.Object);  			// Parse start element  			ParseStartElement ();  		}  		break;  	case Keys.RightClosingBrace:  		this.BufferReader.SkipByte ();  		if (expectingFirstElementInNonPrimitiveChild) {  			SkipWhitespaceInBufferReader ();  			ch = this.BufferReader.GetByte ();  			switch (ch) {  			case Keys.Comma:  			case Keys.RightClosingBrace:  				this.BufferReader.SkipByte ();  				break;  			default:  				throw new XmlException ("JsonEncounteredUnexpectedCharacter");  			}  			expectingFirstElementInNonPrimitiveChild = false;  		}  		MoveToEndElement ();  		break;  	case Keys.Comma:  		this.BufferReader.SkipByte ();  		MoveToEndElement ();  		break;  	case Keys.DoubleQuote:  		if (this.Node.NodeType == XmlNodeType.Element) {  			if (expectingFirstElementInNonPrimitiveChild) {  				EnterJsonScope (JsonNodeType.Object);  				ParseStartElement ();  			}  			else {  				this.BufferReader.SkipByte ();  				ReadQuotedText (true);  			}  		}  		else if (this.Node.NodeType == XmlNodeType.EndElement) {  			EnterJsonScope (JsonNodeType.Element);  			ParseStartElement ();  		}  		else  			throw new XmlException ("JsonEncounteredUnexpectedCharacter");  		break;  	case Keys.LowerF:  		{  			int offset;  			byte[] buffer = this.BufferReader.GetBuffer (5' out offset);  			// Check if it's "false"  			if (buffer [offset + 1] != Keys.LowerA || buffer [offset + 2] != Keys.LowerL || buffer [offset + 3] != Keys.LowerS || buffer [offset + 4] != Keys.LowerE)  				throw new Exception ("Expected False");  			// Advance of 5 byte  			this.BufferReader.Advance (5);  			// Check if char after is a closing one  			if (TryGetByte (out ch) && !IsWhitespace (ch) && (ch != Keys.Comma && ch != Keys.RightClosingBrace) && ch != Keys.RightClosingBracket)  				throw new Exception ("TokenExpected");  			// Move  			this.MoveToAtomicText ().Value.SetValue (ValueHandleType.UTF8' offset' 5);  		}  		break;  	case Keys.LowerT:  		{  			int offset;  			// check if it's "true"  			byte[] buffer = this.BufferReader.GetBuffer (4' out offset);  			if (buffer [offset + 1] != Keys.LowerR || buffer [offset + 2] != Keys.LowerU || buffer [offset + 3] != Keys.LowerE)  				throw new Exception ("expected true");  			this.BufferReader.Advance (4);  			// Check if char after is a closing one  			if (TryGetByte (out ch) && !IsWhitespace (ch) && (ch != Keys.Comma && ch != Keys.RightClosingBrace) && ch != Keys.RightClosingBracket)  				throw new Exception ("TokenExpected");  			// move atomic  			this.MoveToAtomicText ().Value.SetValue (ValueHandleType.UTF8' offset' 4);  		}  		break;  	case Keys.LowerN:  		{  			int offset;  			// check if it's "null"  			byte[] buffer = this.BufferReader.GetBuffer (4' out offset);  			if (buffer [offset + 1] != Keys.LowerU || buffer [offset + 2] != Keys.LowerL || buffer [offset + 3] != Keys.LowerL)  				throw new Exception ("Expected null");  			// advance of 4 chars  			this.BufferReader.Advance (4);  			SkipWhitespaceInBufferReader ();  			if (TryGetByte (out ch)) {  				if (ch == Keys.Comma || ch == Keys.RightClosingBrace)  					this.BufferReader.SkipByte ();  				else if (ch != Keys.RightClosingBracket)  					throw new Exception ("TokenExpected");  			}  			else {  				charactersToSkipOnNextRead [0] = Keys.Comma;  				charactersToSkipOnNextRead [1] = Keys.RightClosingBrace;  			}  			MoveToEndElement ();  		}  		break;  	default:  		if ((ch == (byte)'-') || (((byte)'0' <= ch) && (ch <= (byte)'9')) || (ch == (byte)'I') || (ch == (byte)'N'))  			ReadNumericalText ();  		else  			throw new XmlException ("JsonEncounteredUnexpectedCharacter");  		break;  	}  
Magic Number,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,Read,The following statement contains a magic number: if (scopeDepth == 0) {  	ReadNonExistentElementName (StringHandleConstStringType.Root);  }  else if (IsReadingComplexText) {  	switch (complexTextMode) {  	case JsonComplexTextMode.QuotedText:  		if (ch == Keys.BackSlash) {  			ReadEscapedCharacter (true);  			break;  		}  		ReadQuotedText (true);  		break;  	case JsonComplexTextMode.NumericalText:  		ReadNumericalText ();  		break;  	case JsonComplexTextMode.None:  		throw new XmlException ("JsonEncounteredUnexpectedCharacter");  	}  }  else if (IsReadingCollection)  	ReadNonExistentElementName (StringHandleConstStringType.Item);  else  	switch (ch) {  	case Keys.RightClosingBracket:  		this.BufferReader.SkipByte ();  		MoveToEndElement ();  		ExitJsonScope ();  		break;  	case Keys.LeftOpeningBrace:  		this.BufferReader.SkipByte ();  		SkipWhitespaceInBufferReader ();  		ch = this.BufferReader.GetByte ();  		if (ch == Keys.RightClosingBrace) {  			// Skip this byte  			this.BufferReader.SkipByte ();  			// Skip white spaces  			SkipWhitespaceInBufferReader ();  			// try get next char  			if (TryGetByte (out ch)) {  				if (ch == Keys.Comma)  					this.BufferReader.SkipByte ();  			}  			else {  				// We are at end of buffer' just mark Comma to be skipped next time  				charactersToSkipOnNextRead [0] = Keys.Comma;  			}  			// We set to End Element  			MoveToEndElement ();  		}  		else {  			// Enter a new scope  			EnterJsonScope (JsonNodeType.Object);  			// Parse start element  			ParseStartElement ();  		}  		break;  	case Keys.RightClosingBrace:  		this.BufferReader.SkipByte ();  		if (expectingFirstElementInNonPrimitiveChild) {  			SkipWhitespaceInBufferReader ();  			ch = this.BufferReader.GetByte ();  			switch (ch) {  			case Keys.Comma:  			case Keys.RightClosingBrace:  				this.BufferReader.SkipByte ();  				break;  			default:  				throw new XmlException ("JsonEncounteredUnexpectedCharacter");  			}  			expectingFirstElementInNonPrimitiveChild = false;  		}  		MoveToEndElement ();  		break;  	case Keys.Comma:  		this.BufferReader.SkipByte ();  		MoveToEndElement ();  		break;  	case Keys.DoubleQuote:  		if (this.Node.NodeType == XmlNodeType.Element) {  			if (expectingFirstElementInNonPrimitiveChild) {  				EnterJsonScope (JsonNodeType.Object);  				ParseStartElement ();  			}  			else {  				this.BufferReader.SkipByte ();  				ReadQuotedText (true);  			}  		}  		else if (this.Node.NodeType == XmlNodeType.EndElement) {  			EnterJsonScope (JsonNodeType.Element);  			ParseStartElement ();  		}  		else  			throw new XmlException ("JsonEncounteredUnexpectedCharacter");  		break;  	case Keys.LowerF:  		{  			int offset;  			byte[] buffer = this.BufferReader.GetBuffer (5' out offset);  			// Check if it's "false"  			if (buffer [offset + 1] != Keys.LowerA || buffer [offset + 2] != Keys.LowerL || buffer [offset + 3] != Keys.LowerS || buffer [offset + 4] != Keys.LowerE)  				throw new Exception ("Expected False");  			// Advance of 5 byte  			this.BufferReader.Advance (5);  			// Check if char after is a closing one  			if (TryGetByte (out ch) && !IsWhitespace (ch) && (ch != Keys.Comma && ch != Keys.RightClosingBrace) && ch != Keys.RightClosingBracket)  				throw new Exception ("TokenExpected");  			// Move  			this.MoveToAtomicText ().Value.SetValue (ValueHandleType.UTF8' offset' 5);  		}  		break;  	case Keys.LowerT:  		{  			int offset;  			// check if it's "true"  			byte[] buffer = this.BufferReader.GetBuffer (4' out offset);  			if (buffer [offset + 1] != Keys.LowerR || buffer [offset + 2] != Keys.LowerU || buffer [offset + 3] != Keys.LowerE)  				throw new Exception ("expected true");  			this.BufferReader.Advance (4);  			// Check if char after is a closing one  			if (TryGetByte (out ch) && !IsWhitespace (ch) && (ch != Keys.Comma && ch != Keys.RightClosingBrace) && ch != Keys.RightClosingBracket)  				throw new Exception ("TokenExpected");  			// move atomic  			this.MoveToAtomicText ().Value.SetValue (ValueHandleType.UTF8' offset' 4);  		}  		break;  	case Keys.LowerN:  		{  			int offset;  			// check if it's "null"  			byte[] buffer = this.BufferReader.GetBuffer (4' out offset);  			if (buffer [offset + 1] != Keys.LowerU || buffer [offset + 2] != Keys.LowerL || buffer [offset + 3] != Keys.LowerL)  				throw new Exception ("Expected null");  			// advance of 4 chars  			this.BufferReader.Advance (4);  			SkipWhitespaceInBufferReader ();  			if (TryGetByte (out ch)) {  				if (ch == Keys.Comma || ch == Keys.RightClosingBrace)  					this.BufferReader.SkipByte ();  				else if (ch != Keys.RightClosingBracket)  					throw new Exception ("TokenExpected");  			}  			else {  				charactersToSkipOnNextRead [0] = Keys.Comma;  				charactersToSkipOnNextRead [1] = Keys.RightClosingBrace;  			}  			MoveToEndElement ();  		}  		break;  	default:  		if ((ch == (byte)'-') || (((byte)'0' <= ch) && (ch <= (byte)'9')) || (ch == (byte)'I') || (ch == (byte)'N'))  			ReadNumericalText ();  		else  			throw new XmlException ("JsonEncounteredUnexpectedCharacter");  		break;  	}  
Magic Number,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,Read,The following statement contains a magic number: if (scopeDepth == 0) {  	ReadNonExistentElementName (StringHandleConstStringType.Root);  }  else if (IsReadingComplexText) {  	switch (complexTextMode) {  	case JsonComplexTextMode.QuotedText:  		if (ch == Keys.BackSlash) {  			ReadEscapedCharacter (true);  			break;  		}  		ReadQuotedText (true);  		break;  	case JsonComplexTextMode.NumericalText:  		ReadNumericalText ();  		break;  	case JsonComplexTextMode.None:  		throw new XmlException ("JsonEncounteredUnexpectedCharacter");  	}  }  else if (IsReadingCollection)  	ReadNonExistentElementName (StringHandleConstStringType.Item);  else  	switch (ch) {  	case Keys.RightClosingBracket:  		this.BufferReader.SkipByte ();  		MoveToEndElement ();  		ExitJsonScope ();  		break;  	case Keys.LeftOpeningBrace:  		this.BufferReader.SkipByte ();  		SkipWhitespaceInBufferReader ();  		ch = this.BufferReader.GetByte ();  		if (ch == Keys.RightClosingBrace) {  			// Skip this byte  			this.BufferReader.SkipByte ();  			// Skip white spaces  			SkipWhitespaceInBufferReader ();  			// try get next char  			if (TryGetByte (out ch)) {  				if (ch == Keys.Comma)  					this.BufferReader.SkipByte ();  			}  			else {  				// We are at end of buffer' just mark Comma to be skipped next time  				charactersToSkipOnNextRead [0] = Keys.Comma;  			}  			// We set to End Element  			MoveToEndElement ();  		}  		else {  			// Enter a new scope  			EnterJsonScope (JsonNodeType.Object);  			// Parse start element  			ParseStartElement ();  		}  		break;  	case Keys.RightClosingBrace:  		this.BufferReader.SkipByte ();  		if (expectingFirstElementInNonPrimitiveChild) {  			SkipWhitespaceInBufferReader ();  			ch = this.BufferReader.GetByte ();  			switch (ch) {  			case Keys.Comma:  			case Keys.RightClosingBrace:  				this.BufferReader.SkipByte ();  				break;  			default:  				throw new XmlException ("JsonEncounteredUnexpectedCharacter");  			}  			expectingFirstElementInNonPrimitiveChild = false;  		}  		MoveToEndElement ();  		break;  	case Keys.Comma:  		this.BufferReader.SkipByte ();  		MoveToEndElement ();  		break;  	case Keys.DoubleQuote:  		if (this.Node.NodeType == XmlNodeType.Element) {  			if (expectingFirstElementInNonPrimitiveChild) {  				EnterJsonScope (JsonNodeType.Object);  				ParseStartElement ();  			}  			else {  				this.BufferReader.SkipByte ();  				ReadQuotedText (true);  			}  		}  		else if (this.Node.NodeType == XmlNodeType.EndElement) {  			EnterJsonScope (JsonNodeType.Element);  			ParseStartElement ();  		}  		else  			throw new XmlException ("JsonEncounteredUnexpectedCharacter");  		break;  	case Keys.LowerF:  		{  			int offset;  			byte[] buffer = this.BufferReader.GetBuffer (5' out offset);  			// Check if it's "false"  			if (buffer [offset + 1] != Keys.LowerA || buffer [offset + 2] != Keys.LowerL || buffer [offset + 3] != Keys.LowerS || buffer [offset + 4] != Keys.LowerE)  				throw new Exception ("Expected False");  			// Advance of 5 byte  			this.BufferReader.Advance (5);  			// Check if char after is a closing one  			if (TryGetByte (out ch) && !IsWhitespace (ch) && (ch != Keys.Comma && ch != Keys.RightClosingBrace) && ch != Keys.RightClosingBracket)  				throw new Exception ("TokenExpected");  			// Move  			this.MoveToAtomicText ().Value.SetValue (ValueHandleType.UTF8' offset' 5);  		}  		break;  	case Keys.LowerT:  		{  			int offset;  			// check if it's "true"  			byte[] buffer = this.BufferReader.GetBuffer (4' out offset);  			if (buffer [offset + 1] != Keys.LowerR || buffer [offset + 2] != Keys.LowerU || buffer [offset + 3] != Keys.LowerE)  				throw new Exception ("expected true");  			this.BufferReader.Advance (4);  			// Check if char after is a closing one  			if (TryGetByte (out ch) && !IsWhitespace (ch) && (ch != Keys.Comma && ch != Keys.RightClosingBrace) && ch != Keys.RightClosingBracket)  				throw new Exception ("TokenExpected");  			// move atomic  			this.MoveToAtomicText ().Value.SetValue (ValueHandleType.UTF8' offset' 4);  		}  		break;  	case Keys.LowerN:  		{  			int offset;  			// check if it's "null"  			byte[] buffer = this.BufferReader.GetBuffer (4' out offset);  			if (buffer [offset + 1] != Keys.LowerU || buffer [offset + 2] != Keys.LowerL || buffer [offset + 3] != Keys.LowerL)  				throw new Exception ("Expected null");  			// advance of 4 chars  			this.BufferReader.Advance (4);  			SkipWhitespaceInBufferReader ();  			if (TryGetByte (out ch)) {  				if (ch == Keys.Comma || ch == Keys.RightClosingBrace)  					this.BufferReader.SkipByte ();  				else if (ch != Keys.RightClosingBracket)  					throw new Exception ("TokenExpected");  			}  			else {  				charactersToSkipOnNextRead [0] = Keys.Comma;  				charactersToSkipOnNextRead [1] = Keys.RightClosingBrace;  			}  			MoveToEndElement ();  		}  		break;  	default:  		if ((ch == (byte)'-') || (((byte)'0' <= ch) && (ch <= (byte)'9')) || (ch == (byte)'I') || (ch == (byte)'N'))  			ReadNumericalText ();  		else  			throw new XmlException ("JsonEncounteredUnexpectedCharacter");  		break;  	}  
Magic Number,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,Read,The following statement contains a magic number: if (scopeDepth == 0) {  	ReadNonExistentElementName (StringHandleConstStringType.Root);  }  else if (IsReadingComplexText) {  	switch (complexTextMode) {  	case JsonComplexTextMode.QuotedText:  		if (ch == Keys.BackSlash) {  			ReadEscapedCharacter (true);  			break;  		}  		ReadQuotedText (true);  		break;  	case JsonComplexTextMode.NumericalText:  		ReadNumericalText ();  		break;  	case JsonComplexTextMode.None:  		throw new XmlException ("JsonEncounteredUnexpectedCharacter");  	}  }  else if (IsReadingCollection)  	ReadNonExistentElementName (StringHandleConstStringType.Item);  else  	switch (ch) {  	case Keys.RightClosingBracket:  		this.BufferReader.SkipByte ();  		MoveToEndElement ();  		ExitJsonScope ();  		break;  	case Keys.LeftOpeningBrace:  		this.BufferReader.SkipByte ();  		SkipWhitespaceInBufferReader ();  		ch = this.BufferReader.GetByte ();  		if (ch == Keys.RightClosingBrace) {  			// Skip this byte  			this.BufferReader.SkipByte ();  			// Skip white spaces  			SkipWhitespaceInBufferReader ();  			// try get next char  			if (TryGetByte (out ch)) {  				if (ch == Keys.Comma)  					this.BufferReader.SkipByte ();  			}  			else {  				// We are at end of buffer' just mark Comma to be skipped next time  				charactersToSkipOnNextRead [0] = Keys.Comma;  			}  			// We set to End Element  			MoveToEndElement ();  		}  		else {  			// Enter a new scope  			EnterJsonScope (JsonNodeType.Object);  			// Parse start element  			ParseStartElement ();  		}  		break;  	case Keys.RightClosingBrace:  		this.BufferReader.SkipByte ();  		if (expectingFirstElementInNonPrimitiveChild) {  			SkipWhitespaceInBufferReader ();  			ch = this.BufferReader.GetByte ();  			switch (ch) {  			case Keys.Comma:  			case Keys.RightClosingBrace:  				this.BufferReader.SkipByte ();  				break;  			default:  				throw new XmlException ("JsonEncounteredUnexpectedCharacter");  			}  			expectingFirstElementInNonPrimitiveChild = false;  		}  		MoveToEndElement ();  		break;  	case Keys.Comma:  		this.BufferReader.SkipByte ();  		MoveToEndElement ();  		break;  	case Keys.DoubleQuote:  		if (this.Node.NodeType == XmlNodeType.Element) {  			if (expectingFirstElementInNonPrimitiveChild) {  				EnterJsonScope (JsonNodeType.Object);  				ParseStartElement ();  			}  			else {  				this.BufferReader.SkipByte ();  				ReadQuotedText (true);  			}  		}  		else if (this.Node.NodeType == XmlNodeType.EndElement) {  			EnterJsonScope (JsonNodeType.Element);  			ParseStartElement ();  		}  		else  			throw new XmlException ("JsonEncounteredUnexpectedCharacter");  		break;  	case Keys.LowerF:  		{  			int offset;  			byte[] buffer = this.BufferReader.GetBuffer (5' out offset);  			// Check if it's "false"  			if (buffer [offset + 1] != Keys.LowerA || buffer [offset + 2] != Keys.LowerL || buffer [offset + 3] != Keys.LowerS || buffer [offset + 4] != Keys.LowerE)  				throw new Exception ("Expected False");  			// Advance of 5 byte  			this.BufferReader.Advance (5);  			// Check if char after is a closing one  			if (TryGetByte (out ch) && !IsWhitespace (ch) && (ch != Keys.Comma && ch != Keys.RightClosingBrace) && ch != Keys.RightClosingBracket)  				throw new Exception ("TokenExpected");  			// Move  			this.MoveToAtomicText ().Value.SetValue (ValueHandleType.UTF8' offset' 5);  		}  		break;  	case Keys.LowerT:  		{  			int offset;  			// check if it's "true"  			byte[] buffer = this.BufferReader.GetBuffer (4' out offset);  			if (buffer [offset + 1] != Keys.LowerR || buffer [offset + 2] != Keys.LowerU || buffer [offset + 3] != Keys.LowerE)  				throw new Exception ("expected true");  			this.BufferReader.Advance (4);  			// Check if char after is a closing one  			if (TryGetByte (out ch) && !IsWhitespace (ch) && (ch != Keys.Comma && ch != Keys.RightClosingBrace) && ch != Keys.RightClosingBracket)  				throw new Exception ("TokenExpected");  			// move atomic  			this.MoveToAtomicText ().Value.SetValue (ValueHandleType.UTF8' offset' 4);  		}  		break;  	case Keys.LowerN:  		{  			int offset;  			// check if it's "null"  			byte[] buffer = this.BufferReader.GetBuffer (4' out offset);  			if (buffer [offset + 1] != Keys.LowerU || buffer [offset + 2] != Keys.LowerL || buffer [offset + 3] != Keys.LowerL)  				throw new Exception ("Expected null");  			// advance of 4 chars  			this.BufferReader.Advance (4);  			SkipWhitespaceInBufferReader ();  			if (TryGetByte (out ch)) {  				if (ch == Keys.Comma || ch == Keys.RightClosingBrace)  					this.BufferReader.SkipByte ();  				else if (ch != Keys.RightClosingBracket)  					throw new Exception ("TokenExpected");  			}  			else {  				charactersToSkipOnNextRead [0] = Keys.Comma;  				charactersToSkipOnNextRead [1] = Keys.RightClosingBrace;  			}  			MoveToEndElement ();  		}  		break;  	default:  		if ((ch == (byte)'-') || (((byte)'0' <= ch) && (ch <= (byte)'9')) || (ch == (byte)'I') || (ch == (byte)'N'))  			ReadNumericalText ();  		else  			throw new XmlException ("JsonEncounteredUnexpectedCharacter");  		break;  	}  
Magic Number,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,Read,The following statement contains a magic number: if (scopeDepth == 0) {  	ReadNonExistentElementName (StringHandleConstStringType.Root);  }  else if (IsReadingComplexText) {  	switch (complexTextMode) {  	case JsonComplexTextMode.QuotedText:  		if (ch == Keys.BackSlash) {  			ReadEscapedCharacter (true);  			break;  		}  		ReadQuotedText (true);  		break;  	case JsonComplexTextMode.NumericalText:  		ReadNumericalText ();  		break;  	case JsonComplexTextMode.None:  		throw new XmlException ("JsonEncounteredUnexpectedCharacter");  	}  }  else if (IsReadingCollection)  	ReadNonExistentElementName (StringHandleConstStringType.Item);  else  	switch (ch) {  	case Keys.RightClosingBracket:  		this.BufferReader.SkipByte ();  		MoveToEndElement ();  		ExitJsonScope ();  		break;  	case Keys.LeftOpeningBrace:  		this.BufferReader.SkipByte ();  		SkipWhitespaceInBufferReader ();  		ch = this.BufferReader.GetByte ();  		if (ch == Keys.RightClosingBrace) {  			// Skip this byte  			this.BufferReader.SkipByte ();  			// Skip white spaces  			SkipWhitespaceInBufferReader ();  			// try get next char  			if (TryGetByte (out ch)) {  				if (ch == Keys.Comma)  					this.BufferReader.SkipByte ();  			}  			else {  				// We are at end of buffer' just mark Comma to be skipped next time  				charactersToSkipOnNextRead [0] = Keys.Comma;  			}  			// We set to End Element  			MoveToEndElement ();  		}  		else {  			// Enter a new scope  			EnterJsonScope (JsonNodeType.Object);  			// Parse start element  			ParseStartElement ();  		}  		break;  	case Keys.RightClosingBrace:  		this.BufferReader.SkipByte ();  		if (expectingFirstElementInNonPrimitiveChild) {  			SkipWhitespaceInBufferReader ();  			ch = this.BufferReader.GetByte ();  			switch (ch) {  			case Keys.Comma:  			case Keys.RightClosingBrace:  				this.BufferReader.SkipByte ();  				break;  			default:  				throw new XmlException ("JsonEncounteredUnexpectedCharacter");  			}  			expectingFirstElementInNonPrimitiveChild = false;  		}  		MoveToEndElement ();  		break;  	case Keys.Comma:  		this.BufferReader.SkipByte ();  		MoveToEndElement ();  		break;  	case Keys.DoubleQuote:  		if (this.Node.NodeType == XmlNodeType.Element) {  			if (expectingFirstElementInNonPrimitiveChild) {  				EnterJsonScope (JsonNodeType.Object);  				ParseStartElement ();  			}  			else {  				this.BufferReader.SkipByte ();  				ReadQuotedText (true);  			}  		}  		else if (this.Node.NodeType == XmlNodeType.EndElement) {  			EnterJsonScope (JsonNodeType.Element);  			ParseStartElement ();  		}  		else  			throw new XmlException ("JsonEncounteredUnexpectedCharacter");  		break;  	case Keys.LowerF:  		{  			int offset;  			byte[] buffer = this.BufferReader.GetBuffer (5' out offset);  			// Check if it's "false"  			if (buffer [offset + 1] != Keys.LowerA || buffer [offset + 2] != Keys.LowerL || buffer [offset + 3] != Keys.LowerS || buffer [offset + 4] != Keys.LowerE)  				throw new Exception ("Expected False");  			// Advance of 5 byte  			this.BufferReader.Advance (5);  			// Check if char after is a closing one  			if (TryGetByte (out ch) && !IsWhitespace (ch) && (ch != Keys.Comma && ch != Keys.RightClosingBrace) && ch != Keys.RightClosingBracket)  				throw new Exception ("TokenExpected");  			// Move  			this.MoveToAtomicText ().Value.SetValue (ValueHandleType.UTF8' offset' 5);  		}  		break;  	case Keys.LowerT:  		{  			int offset;  			// check if it's "true"  			byte[] buffer = this.BufferReader.GetBuffer (4' out offset);  			if (buffer [offset + 1] != Keys.LowerR || buffer [offset + 2] != Keys.LowerU || buffer [offset + 3] != Keys.LowerE)  				throw new Exception ("expected true");  			this.BufferReader.Advance (4);  			// Check if char after is a closing one  			if (TryGetByte (out ch) && !IsWhitespace (ch) && (ch != Keys.Comma && ch != Keys.RightClosingBrace) && ch != Keys.RightClosingBracket)  				throw new Exception ("TokenExpected");  			// move atomic  			this.MoveToAtomicText ().Value.SetValue (ValueHandleType.UTF8' offset' 4);  		}  		break;  	case Keys.LowerN:  		{  			int offset;  			// check if it's "null"  			byte[] buffer = this.BufferReader.GetBuffer (4' out offset);  			if (buffer [offset + 1] != Keys.LowerU || buffer [offset + 2] != Keys.LowerL || buffer [offset + 3] != Keys.LowerL)  				throw new Exception ("Expected null");  			// advance of 4 chars  			this.BufferReader.Advance (4);  			SkipWhitespaceInBufferReader ();  			if (TryGetByte (out ch)) {  				if (ch == Keys.Comma || ch == Keys.RightClosingBrace)  					this.BufferReader.SkipByte ();  				else if (ch != Keys.RightClosingBracket)  					throw new Exception ("TokenExpected");  			}  			else {  				charactersToSkipOnNextRead [0] = Keys.Comma;  				charactersToSkipOnNextRead [1] = Keys.RightClosingBrace;  			}  			MoveToEndElement ();  		}  		break;  	default:  		if ((ch == (byte)'-') || (((byte)'0' <= ch) && (ch <= (byte)'9')) || (ch == (byte)'I') || (ch == (byte)'N'))  			ReadNumericalText ();  		else  			throw new XmlException ("JsonEncounteredUnexpectedCharacter");  		break;  	}  
Magic Number,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,Read,The following statement contains a magic number: if (scopeDepth == 0) {  	ReadNonExistentElementName (StringHandleConstStringType.Root);  }  else if (IsReadingComplexText) {  	switch (complexTextMode) {  	case JsonComplexTextMode.QuotedText:  		if (ch == Keys.BackSlash) {  			ReadEscapedCharacter (true);  			break;  		}  		ReadQuotedText (true);  		break;  	case JsonComplexTextMode.NumericalText:  		ReadNumericalText ();  		break;  	case JsonComplexTextMode.None:  		throw new XmlException ("JsonEncounteredUnexpectedCharacter");  	}  }  else if (IsReadingCollection)  	ReadNonExistentElementName (StringHandleConstStringType.Item);  else  	switch (ch) {  	case Keys.RightClosingBracket:  		this.BufferReader.SkipByte ();  		MoveToEndElement ();  		ExitJsonScope ();  		break;  	case Keys.LeftOpeningBrace:  		this.BufferReader.SkipByte ();  		SkipWhitespaceInBufferReader ();  		ch = this.BufferReader.GetByte ();  		if (ch == Keys.RightClosingBrace) {  			// Skip this byte  			this.BufferReader.SkipByte ();  			// Skip white spaces  			SkipWhitespaceInBufferReader ();  			// try get next char  			if (TryGetByte (out ch)) {  				if (ch == Keys.Comma)  					this.BufferReader.SkipByte ();  			}  			else {  				// We are at end of buffer' just mark Comma to be skipped next time  				charactersToSkipOnNextRead [0] = Keys.Comma;  			}  			// We set to End Element  			MoveToEndElement ();  		}  		else {  			// Enter a new scope  			EnterJsonScope (JsonNodeType.Object);  			// Parse start element  			ParseStartElement ();  		}  		break;  	case Keys.RightClosingBrace:  		this.BufferReader.SkipByte ();  		if (expectingFirstElementInNonPrimitiveChild) {  			SkipWhitespaceInBufferReader ();  			ch = this.BufferReader.GetByte ();  			switch (ch) {  			case Keys.Comma:  			case Keys.RightClosingBrace:  				this.BufferReader.SkipByte ();  				break;  			default:  				throw new XmlException ("JsonEncounteredUnexpectedCharacter");  			}  			expectingFirstElementInNonPrimitiveChild = false;  		}  		MoveToEndElement ();  		break;  	case Keys.Comma:  		this.BufferReader.SkipByte ();  		MoveToEndElement ();  		break;  	case Keys.DoubleQuote:  		if (this.Node.NodeType == XmlNodeType.Element) {  			if (expectingFirstElementInNonPrimitiveChild) {  				EnterJsonScope (JsonNodeType.Object);  				ParseStartElement ();  			}  			else {  				this.BufferReader.SkipByte ();  				ReadQuotedText (true);  			}  		}  		else if (this.Node.NodeType == XmlNodeType.EndElement) {  			EnterJsonScope (JsonNodeType.Element);  			ParseStartElement ();  		}  		else  			throw new XmlException ("JsonEncounteredUnexpectedCharacter");  		break;  	case Keys.LowerF:  		{  			int offset;  			byte[] buffer = this.BufferReader.GetBuffer (5' out offset);  			// Check if it's "false"  			if (buffer [offset + 1] != Keys.LowerA || buffer [offset + 2] != Keys.LowerL || buffer [offset + 3] != Keys.LowerS || buffer [offset + 4] != Keys.LowerE)  				throw new Exception ("Expected False");  			// Advance of 5 byte  			this.BufferReader.Advance (5);  			// Check if char after is a closing one  			if (TryGetByte (out ch) && !IsWhitespace (ch) && (ch != Keys.Comma && ch != Keys.RightClosingBrace) && ch != Keys.RightClosingBracket)  				throw new Exception ("TokenExpected");  			// Move  			this.MoveToAtomicText ().Value.SetValue (ValueHandleType.UTF8' offset' 5);  		}  		break;  	case Keys.LowerT:  		{  			int offset;  			// check if it's "true"  			byte[] buffer = this.BufferReader.GetBuffer (4' out offset);  			if (buffer [offset + 1] != Keys.LowerR || buffer [offset + 2] != Keys.LowerU || buffer [offset + 3] != Keys.LowerE)  				throw new Exception ("expected true");  			this.BufferReader.Advance (4);  			// Check if char after is a closing one  			if (TryGetByte (out ch) && !IsWhitespace (ch) && (ch != Keys.Comma && ch != Keys.RightClosingBrace) && ch != Keys.RightClosingBracket)  				throw new Exception ("TokenExpected");  			// move atomic  			this.MoveToAtomicText ().Value.SetValue (ValueHandleType.UTF8' offset' 4);  		}  		break;  	case Keys.LowerN:  		{  			int offset;  			// check if it's "null"  			byte[] buffer = this.BufferReader.GetBuffer (4' out offset);  			if (buffer [offset + 1] != Keys.LowerU || buffer [offset + 2] != Keys.LowerL || buffer [offset + 3] != Keys.LowerL)  				throw new Exception ("Expected null");  			// advance of 4 chars  			this.BufferReader.Advance (4);  			SkipWhitespaceInBufferReader ();  			if (TryGetByte (out ch)) {  				if (ch == Keys.Comma || ch == Keys.RightClosingBrace)  					this.BufferReader.SkipByte ();  				else if (ch != Keys.RightClosingBracket)  					throw new Exception ("TokenExpected");  			}  			else {  				charactersToSkipOnNextRead [0] = Keys.Comma;  				charactersToSkipOnNextRead [1] = Keys.RightClosingBrace;  			}  			MoveToEndElement ();  		}  		break;  	default:  		if ((ch == (byte)'-') || (((byte)'0' <= ch) && (ch <= (byte)'9')) || (ch == (byte)'I') || (ch == (byte)'N'))  			ReadNumericalText ();  		else  			throw new XmlException ("JsonEncounteredUnexpectedCharacter");  		break;  	}  
Magic Number,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,Read,The following statement contains a magic number: if (scopeDepth == 0) {  	ReadNonExistentElementName (StringHandleConstStringType.Root);  }  else if (IsReadingComplexText) {  	switch (complexTextMode) {  	case JsonComplexTextMode.QuotedText:  		if (ch == Keys.BackSlash) {  			ReadEscapedCharacter (true);  			break;  		}  		ReadQuotedText (true);  		break;  	case JsonComplexTextMode.NumericalText:  		ReadNumericalText ();  		break;  	case JsonComplexTextMode.None:  		throw new XmlException ("JsonEncounteredUnexpectedCharacter");  	}  }  else if (IsReadingCollection)  	ReadNonExistentElementName (StringHandleConstStringType.Item);  else  	switch (ch) {  	case Keys.RightClosingBracket:  		this.BufferReader.SkipByte ();  		MoveToEndElement ();  		ExitJsonScope ();  		break;  	case Keys.LeftOpeningBrace:  		this.BufferReader.SkipByte ();  		SkipWhitespaceInBufferReader ();  		ch = this.BufferReader.GetByte ();  		if (ch == Keys.RightClosingBrace) {  			// Skip this byte  			this.BufferReader.SkipByte ();  			// Skip white spaces  			SkipWhitespaceInBufferReader ();  			// try get next char  			if (TryGetByte (out ch)) {  				if (ch == Keys.Comma)  					this.BufferReader.SkipByte ();  			}  			else {  				// We are at end of buffer' just mark Comma to be skipped next time  				charactersToSkipOnNextRead [0] = Keys.Comma;  			}  			// We set to End Element  			MoveToEndElement ();  		}  		else {  			// Enter a new scope  			EnterJsonScope (JsonNodeType.Object);  			// Parse start element  			ParseStartElement ();  		}  		break;  	case Keys.RightClosingBrace:  		this.BufferReader.SkipByte ();  		if (expectingFirstElementInNonPrimitiveChild) {  			SkipWhitespaceInBufferReader ();  			ch = this.BufferReader.GetByte ();  			switch (ch) {  			case Keys.Comma:  			case Keys.RightClosingBrace:  				this.BufferReader.SkipByte ();  				break;  			default:  				throw new XmlException ("JsonEncounteredUnexpectedCharacter");  			}  			expectingFirstElementInNonPrimitiveChild = false;  		}  		MoveToEndElement ();  		break;  	case Keys.Comma:  		this.BufferReader.SkipByte ();  		MoveToEndElement ();  		break;  	case Keys.DoubleQuote:  		if (this.Node.NodeType == XmlNodeType.Element) {  			if (expectingFirstElementInNonPrimitiveChild) {  				EnterJsonScope (JsonNodeType.Object);  				ParseStartElement ();  			}  			else {  				this.BufferReader.SkipByte ();  				ReadQuotedText (true);  			}  		}  		else if (this.Node.NodeType == XmlNodeType.EndElement) {  			EnterJsonScope (JsonNodeType.Element);  			ParseStartElement ();  		}  		else  			throw new XmlException ("JsonEncounteredUnexpectedCharacter");  		break;  	case Keys.LowerF:  		{  			int offset;  			byte[] buffer = this.BufferReader.GetBuffer (5' out offset);  			// Check if it's "false"  			if (buffer [offset + 1] != Keys.LowerA || buffer [offset + 2] != Keys.LowerL || buffer [offset + 3] != Keys.LowerS || buffer [offset + 4] != Keys.LowerE)  				throw new Exception ("Expected False");  			// Advance of 5 byte  			this.BufferReader.Advance (5);  			// Check if char after is a closing one  			if (TryGetByte (out ch) && !IsWhitespace (ch) && (ch != Keys.Comma && ch != Keys.RightClosingBrace) && ch != Keys.RightClosingBracket)  				throw new Exception ("TokenExpected");  			// Move  			this.MoveToAtomicText ().Value.SetValue (ValueHandleType.UTF8' offset' 5);  		}  		break;  	case Keys.LowerT:  		{  			int offset;  			// check if it's "true"  			byte[] buffer = this.BufferReader.GetBuffer (4' out offset);  			if (buffer [offset + 1] != Keys.LowerR || buffer [offset + 2] != Keys.LowerU || buffer [offset + 3] != Keys.LowerE)  				throw new Exception ("expected true");  			this.BufferReader.Advance (4);  			// Check if char after is a closing one  			if (TryGetByte (out ch) && !IsWhitespace (ch) && (ch != Keys.Comma && ch != Keys.RightClosingBrace) && ch != Keys.RightClosingBracket)  				throw new Exception ("TokenExpected");  			// move atomic  			this.MoveToAtomicText ().Value.SetValue (ValueHandleType.UTF8' offset' 4);  		}  		break;  	case Keys.LowerN:  		{  			int offset;  			// check if it's "null"  			byte[] buffer = this.BufferReader.GetBuffer (4' out offset);  			if (buffer [offset + 1] != Keys.LowerU || buffer [offset + 2] != Keys.LowerL || buffer [offset + 3] != Keys.LowerL)  				throw new Exception ("Expected null");  			// advance of 4 chars  			this.BufferReader.Advance (4);  			SkipWhitespaceInBufferReader ();  			if (TryGetByte (out ch)) {  				if (ch == Keys.Comma || ch == Keys.RightClosingBrace)  					this.BufferReader.SkipByte ();  				else if (ch != Keys.RightClosingBracket)  					throw new Exception ("TokenExpected");  			}  			else {  				charactersToSkipOnNextRead [0] = Keys.Comma;  				charactersToSkipOnNextRead [1] = Keys.RightClosingBrace;  			}  			MoveToEndElement ();  		}  		break;  	default:  		if ((ch == (byte)'-') || (((byte)'0' <= ch) && (ch <= (byte)'9')) || (ch == (byte)'I') || (ch == (byte)'N'))  			ReadNumericalText ();  		else  			throw new XmlException ("JsonEncounteredUnexpectedCharacter");  		break;  	}  
Magic Number,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,Read,The following statement contains a magic number: if (scopeDepth == 0) {  	ReadNonExistentElementName (StringHandleConstStringType.Root);  }  else if (IsReadingComplexText) {  	switch (complexTextMode) {  	case JsonComplexTextMode.QuotedText:  		if (ch == Keys.BackSlash) {  			ReadEscapedCharacter (true);  			break;  		}  		ReadQuotedText (true);  		break;  	case JsonComplexTextMode.NumericalText:  		ReadNumericalText ();  		break;  	case JsonComplexTextMode.None:  		throw new XmlException ("JsonEncounteredUnexpectedCharacter");  	}  }  else if (IsReadingCollection)  	ReadNonExistentElementName (StringHandleConstStringType.Item);  else  	switch (ch) {  	case Keys.RightClosingBracket:  		this.BufferReader.SkipByte ();  		MoveToEndElement ();  		ExitJsonScope ();  		break;  	case Keys.LeftOpeningBrace:  		this.BufferReader.SkipByte ();  		SkipWhitespaceInBufferReader ();  		ch = this.BufferReader.GetByte ();  		if (ch == Keys.RightClosingBrace) {  			// Skip this byte  			this.BufferReader.SkipByte ();  			// Skip white spaces  			SkipWhitespaceInBufferReader ();  			// try get next char  			if (TryGetByte (out ch)) {  				if (ch == Keys.Comma)  					this.BufferReader.SkipByte ();  			}  			else {  				// We are at end of buffer' just mark Comma to be skipped next time  				charactersToSkipOnNextRead [0] = Keys.Comma;  			}  			// We set to End Element  			MoveToEndElement ();  		}  		else {  			// Enter a new scope  			EnterJsonScope (JsonNodeType.Object);  			// Parse start element  			ParseStartElement ();  		}  		break;  	case Keys.RightClosingBrace:  		this.BufferReader.SkipByte ();  		if (expectingFirstElementInNonPrimitiveChild) {  			SkipWhitespaceInBufferReader ();  			ch = this.BufferReader.GetByte ();  			switch (ch) {  			case Keys.Comma:  			case Keys.RightClosingBrace:  				this.BufferReader.SkipByte ();  				break;  			default:  				throw new XmlException ("JsonEncounteredUnexpectedCharacter");  			}  			expectingFirstElementInNonPrimitiveChild = false;  		}  		MoveToEndElement ();  		break;  	case Keys.Comma:  		this.BufferReader.SkipByte ();  		MoveToEndElement ();  		break;  	case Keys.DoubleQuote:  		if (this.Node.NodeType == XmlNodeType.Element) {  			if (expectingFirstElementInNonPrimitiveChild) {  				EnterJsonScope (JsonNodeType.Object);  				ParseStartElement ();  			}  			else {  				this.BufferReader.SkipByte ();  				ReadQuotedText (true);  			}  		}  		else if (this.Node.NodeType == XmlNodeType.EndElement) {  			EnterJsonScope (JsonNodeType.Element);  			ParseStartElement ();  		}  		else  			throw new XmlException ("JsonEncounteredUnexpectedCharacter");  		break;  	case Keys.LowerF:  		{  			int offset;  			byte[] buffer = this.BufferReader.GetBuffer (5' out offset);  			// Check if it's "false"  			if (buffer [offset + 1] != Keys.LowerA || buffer [offset + 2] != Keys.LowerL || buffer [offset + 3] != Keys.LowerS || buffer [offset + 4] != Keys.LowerE)  				throw new Exception ("Expected False");  			// Advance of 5 byte  			this.BufferReader.Advance (5);  			// Check if char after is a closing one  			if (TryGetByte (out ch) && !IsWhitespace (ch) && (ch != Keys.Comma && ch != Keys.RightClosingBrace) && ch != Keys.RightClosingBracket)  				throw new Exception ("TokenExpected");  			// Move  			this.MoveToAtomicText ().Value.SetValue (ValueHandleType.UTF8' offset' 5);  		}  		break;  	case Keys.LowerT:  		{  			int offset;  			// check if it's "true"  			byte[] buffer = this.BufferReader.GetBuffer (4' out offset);  			if (buffer [offset + 1] != Keys.LowerR || buffer [offset + 2] != Keys.LowerU || buffer [offset + 3] != Keys.LowerE)  				throw new Exception ("expected true");  			this.BufferReader.Advance (4);  			// Check if char after is a closing one  			if (TryGetByte (out ch) && !IsWhitespace (ch) && (ch != Keys.Comma && ch != Keys.RightClosingBrace) && ch != Keys.RightClosingBracket)  				throw new Exception ("TokenExpected");  			// move atomic  			this.MoveToAtomicText ().Value.SetValue (ValueHandleType.UTF8' offset' 4);  		}  		break;  	case Keys.LowerN:  		{  			int offset;  			// check if it's "null"  			byte[] buffer = this.BufferReader.GetBuffer (4' out offset);  			if (buffer [offset + 1] != Keys.LowerU || buffer [offset + 2] != Keys.LowerL || buffer [offset + 3] != Keys.LowerL)  				throw new Exception ("Expected null");  			// advance of 4 chars  			this.BufferReader.Advance (4);  			SkipWhitespaceInBufferReader ();  			if (TryGetByte (out ch)) {  				if (ch == Keys.Comma || ch == Keys.RightClosingBrace)  					this.BufferReader.SkipByte ();  				else if (ch != Keys.RightClosingBracket)  					throw new Exception ("TokenExpected");  			}  			else {  				charactersToSkipOnNextRead [0] = Keys.Comma;  				charactersToSkipOnNextRead [1] = Keys.RightClosingBrace;  			}  			MoveToEndElement ();  		}  		break;  	default:  		if ((ch == (byte)'-') || (((byte)'0' <= ch) && (ch <= (byte)'9')) || (ch == (byte)'I') || (ch == (byte)'N'))  			ReadNumericalText ();  		else  			throw new XmlException ("JsonEncounteredUnexpectedCharacter");  		break;  	}  
Magic Number,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,Read,The following statement contains a magic number: if (IsReadingComplexText) {  	switch (complexTextMode) {  	case JsonComplexTextMode.QuotedText:  		if (ch == Keys.BackSlash) {  			ReadEscapedCharacter (true);  			break;  		}  		ReadQuotedText (true);  		break;  	case JsonComplexTextMode.NumericalText:  		ReadNumericalText ();  		break;  	case JsonComplexTextMode.None:  		throw new XmlException ("JsonEncounteredUnexpectedCharacter");  	}  }  else if (IsReadingCollection)  	ReadNonExistentElementName (StringHandleConstStringType.Item);  else  	switch (ch) {  	case Keys.RightClosingBracket:  		this.BufferReader.SkipByte ();  		MoveToEndElement ();  		ExitJsonScope ();  		break;  	case Keys.LeftOpeningBrace:  		this.BufferReader.SkipByte ();  		SkipWhitespaceInBufferReader ();  		ch = this.BufferReader.GetByte ();  		if (ch == Keys.RightClosingBrace) {  			// Skip this byte  			this.BufferReader.SkipByte ();  			// Skip white spaces  			SkipWhitespaceInBufferReader ();  			// try get next char  			if (TryGetByte (out ch)) {  				if (ch == Keys.Comma)  					this.BufferReader.SkipByte ();  			}  			else {  				// We are at end of buffer' just mark Comma to be skipped next time  				charactersToSkipOnNextRead [0] = Keys.Comma;  			}  			// We set to End Element  			MoveToEndElement ();  		}  		else {  			// Enter a new scope  			EnterJsonScope (JsonNodeType.Object);  			// Parse start element  			ParseStartElement ();  		}  		break;  	case Keys.RightClosingBrace:  		this.BufferReader.SkipByte ();  		if (expectingFirstElementInNonPrimitiveChild) {  			SkipWhitespaceInBufferReader ();  			ch = this.BufferReader.GetByte ();  			switch (ch) {  			case Keys.Comma:  			case Keys.RightClosingBrace:  				this.BufferReader.SkipByte ();  				break;  			default:  				throw new XmlException ("JsonEncounteredUnexpectedCharacter");  			}  			expectingFirstElementInNonPrimitiveChild = false;  		}  		MoveToEndElement ();  		break;  	case Keys.Comma:  		this.BufferReader.SkipByte ();  		MoveToEndElement ();  		break;  	case Keys.DoubleQuote:  		if (this.Node.NodeType == XmlNodeType.Element) {  			if (expectingFirstElementInNonPrimitiveChild) {  				EnterJsonScope (JsonNodeType.Object);  				ParseStartElement ();  			}  			else {  				this.BufferReader.SkipByte ();  				ReadQuotedText (true);  			}  		}  		else if (this.Node.NodeType == XmlNodeType.EndElement) {  			EnterJsonScope (JsonNodeType.Element);  			ParseStartElement ();  		}  		else  			throw new XmlException ("JsonEncounteredUnexpectedCharacter");  		break;  	case Keys.LowerF:  		{  			int offset;  			byte[] buffer = this.BufferReader.GetBuffer (5' out offset);  			// Check if it's "false"  			if (buffer [offset + 1] != Keys.LowerA || buffer [offset + 2] != Keys.LowerL || buffer [offset + 3] != Keys.LowerS || buffer [offset + 4] != Keys.LowerE)  				throw new Exception ("Expected False");  			// Advance of 5 byte  			this.BufferReader.Advance (5);  			// Check if char after is a closing one  			if (TryGetByte (out ch) && !IsWhitespace (ch) && (ch != Keys.Comma && ch != Keys.RightClosingBrace) && ch != Keys.RightClosingBracket)  				throw new Exception ("TokenExpected");  			// Move  			this.MoveToAtomicText ().Value.SetValue (ValueHandleType.UTF8' offset' 5);  		}  		break;  	case Keys.LowerT:  		{  			int offset;  			// check if it's "true"  			byte[] buffer = this.BufferReader.GetBuffer (4' out offset);  			if (buffer [offset + 1] != Keys.LowerR || buffer [offset + 2] != Keys.LowerU || buffer [offset + 3] != Keys.LowerE)  				throw new Exception ("expected true");  			this.BufferReader.Advance (4);  			// Check if char after is a closing one  			if (TryGetByte (out ch) && !IsWhitespace (ch) && (ch != Keys.Comma && ch != Keys.RightClosingBrace) && ch != Keys.RightClosingBracket)  				throw new Exception ("TokenExpected");  			// move atomic  			this.MoveToAtomicText ().Value.SetValue (ValueHandleType.UTF8' offset' 4);  		}  		break;  	case Keys.LowerN:  		{  			int offset;  			// check if it's "null"  			byte[] buffer = this.BufferReader.GetBuffer (4' out offset);  			if (buffer [offset + 1] != Keys.LowerU || buffer [offset + 2] != Keys.LowerL || buffer [offset + 3] != Keys.LowerL)  				throw new Exception ("Expected null");  			// advance of 4 chars  			this.BufferReader.Advance (4);  			SkipWhitespaceInBufferReader ();  			if (TryGetByte (out ch)) {  				if (ch == Keys.Comma || ch == Keys.RightClosingBrace)  					this.BufferReader.SkipByte ();  				else if (ch != Keys.RightClosingBracket)  					throw new Exception ("TokenExpected");  			}  			else {  				charactersToSkipOnNextRead [0] = Keys.Comma;  				charactersToSkipOnNextRead [1] = Keys.RightClosingBrace;  			}  			MoveToEndElement ();  		}  		break;  	default:  		if ((ch == (byte)'-') || (((byte)'0' <= ch) && (ch <= (byte)'9')) || (ch == (byte)'I') || (ch == (byte)'N'))  			ReadNumericalText ();  		else  			throw new XmlException ("JsonEncounteredUnexpectedCharacter");  		break;  	}  
Magic Number,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,Read,The following statement contains a magic number: if (IsReadingComplexText) {  	switch (complexTextMode) {  	case JsonComplexTextMode.QuotedText:  		if (ch == Keys.BackSlash) {  			ReadEscapedCharacter (true);  			break;  		}  		ReadQuotedText (true);  		break;  	case JsonComplexTextMode.NumericalText:  		ReadNumericalText ();  		break;  	case JsonComplexTextMode.None:  		throw new XmlException ("JsonEncounteredUnexpectedCharacter");  	}  }  else if (IsReadingCollection)  	ReadNonExistentElementName (StringHandleConstStringType.Item);  else  	switch (ch) {  	case Keys.RightClosingBracket:  		this.BufferReader.SkipByte ();  		MoveToEndElement ();  		ExitJsonScope ();  		break;  	case Keys.LeftOpeningBrace:  		this.BufferReader.SkipByte ();  		SkipWhitespaceInBufferReader ();  		ch = this.BufferReader.GetByte ();  		if (ch == Keys.RightClosingBrace) {  			// Skip this byte  			this.BufferReader.SkipByte ();  			// Skip white spaces  			SkipWhitespaceInBufferReader ();  			// try get next char  			if (TryGetByte (out ch)) {  				if (ch == Keys.Comma)  					this.BufferReader.SkipByte ();  			}  			else {  				// We are at end of buffer' just mark Comma to be skipped next time  				charactersToSkipOnNextRead [0] = Keys.Comma;  			}  			// We set to End Element  			MoveToEndElement ();  		}  		else {  			// Enter a new scope  			EnterJsonScope (JsonNodeType.Object);  			// Parse start element  			ParseStartElement ();  		}  		break;  	case Keys.RightClosingBrace:  		this.BufferReader.SkipByte ();  		if (expectingFirstElementInNonPrimitiveChild) {  			SkipWhitespaceInBufferReader ();  			ch = this.BufferReader.GetByte ();  			switch (ch) {  			case Keys.Comma:  			case Keys.RightClosingBrace:  				this.BufferReader.SkipByte ();  				break;  			default:  				throw new XmlException ("JsonEncounteredUnexpectedCharacter");  			}  			expectingFirstElementInNonPrimitiveChild = false;  		}  		MoveToEndElement ();  		break;  	case Keys.Comma:  		this.BufferReader.SkipByte ();  		MoveToEndElement ();  		break;  	case Keys.DoubleQuote:  		if (this.Node.NodeType == XmlNodeType.Element) {  			if (expectingFirstElementInNonPrimitiveChild) {  				EnterJsonScope (JsonNodeType.Object);  				ParseStartElement ();  			}  			else {  				this.BufferReader.SkipByte ();  				ReadQuotedText (true);  			}  		}  		else if (this.Node.NodeType == XmlNodeType.EndElement) {  			EnterJsonScope (JsonNodeType.Element);  			ParseStartElement ();  		}  		else  			throw new XmlException ("JsonEncounteredUnexpectedCharacter");  		break;  	case Keys.LowerF:  		{  			int offset;  			byte[] buffer = this.BufferReader.GetBuffer (5' out offset);  			// Check if it's "false"  			if (buffer [offset + 1] != Keys.LowerA || buffer [offset + 2] != Keys.LowerL || buffer [offset + 3] != Keys.LowerS || buffer [offset + 4] != Keys.LowerE)  				throw new Exception ("Expected False");  			// Advance of 5 byte  			this.BufferReader.Advance (5);  			// Check if char after is a closing one  			if (TryGetByte (out ch) && !IsWhitespace (ch) && (ch != Keys.Comma && ch != Keys.RightClosingBrace) && ch != Keys.RightClosingBracket)  				throw new Exception ("TokenExpected");  			// Move  			this.MoveToAtomicText ().Value.SetValue (ValueHandleType.UTF8' offset' 5);  		}  		break;  	case Keys.LowerT:  		{  			int offset;  			// check if it's "true"  			byte[] buffer = this.BufferReader.GetBuffer (4' out offset);  			if (buffer [offset + 1] != Keys.LowerR || buffer [offset + 2] != Keys.LowerU || buffer [offset + 3] != Keys.LowerE)  				throw new Exception ("expected true");  			this.BufferReader.Advance (4);  			// Check if char after is a closing one  			if (TryGetByte (out ch) && !IsWhitespace (ch) && (ch != Keys.Comma && ch != Keys.RightClosingBrace) && ch != Keys.RightClosingBracket)  				throw new Exception ("TokenExpected");  			// move atomic  			this.MoveToAtomicText ().Value.SetValue (ValueHandleType.UTF8' offset' 4);  		}  		break;  	case Keys.LowerN:  		{  			int offset;  			// check if it's "null"  			byte[] buffer = this.BufferReader.GetBuffer (4' out offset);  			if (buffer [offset + 1] != Keys.LowerU || buffer [offset + 2] != Keys.LowerL || buffer [offset + 3] != Keys.LowerL)  				throw new Exception ("Expected null");  			// advance of 4 chars  			this.BufferReader.Advance (4);  			SkipWhitespaceInBufferReader ();  			if (TryGetByte (out ch)) {  				if (ch == Keys.Comma || ch == Keys.RightClosingBrace)  					this.BufferReader.SkipByte ();  				else if (ch != Keys.RightClosingBracket)  					throw new Exception ("TokenExpected");  			}  			else {  				charactersToSkipOnNextRead [0] = Keys.Comma;  				charactersToSkipOnNextRead [1] = Keys.RightClosingBrace;  			}  			MoveToEndElement ();  		}  		break;  	default:  		if ((ch == (byte)'-') || (((byte)'0' <= ch) && (ch <= (byte)'9')) || (ch == (byte)'I') || (ch == (byte)'N'))  			ReadNumericalText ();  		else  			throw new XmlException ("JsonEncounteredUnexpectedCharacter");  		break;  	}  
Magic Number,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,Read,The following statement contains a magic number: if (IsReadingComplexText) {  	switch (complexTextMode) {  	case JsonComplexTextMode.QuotedText:  		if (ch == Keys.BackSlash) {  			ReadEscapedCharacter (true);  			break;  		}  		ReadQuotedText (true);  		break;  	case JsonComplexTextMode.NumericalText:  		ReadNumericalText ();  		break;  	case JsonComplexTextMode.None:  		throw new XmlException ("JsonEncounteredUnexpectedCharacter");  	}  }  else if (IsReadingCollection)  	ReadNonExistentElementName (StringHandleConstStringType.Item);  else  	switch (ch) {  	case Keys.RightClosingBracket:  		this.BufferReader.SkipByte ();  		MoveToEndElement ();  		ExitJsonScope ();  		break;  	case Keys.LeftOpeningBrace:  		this.BufferReader.SkipByte ();  		SkipWhitespaceInBufferReader ();  		ch = this.BufferReader.GetByte ();  		if (ch == Keys.RightClosingBrace) {  			// Skip this byte  			this.BufferReader.SkipByte ();  			// Skip white spaces  			SkipWhitespaceInBufferReader ();  			// try get next char  			if (TryGetByte (out ch)) {  				if (ch == Keys.Comma)  					this.BufferReader.SkipByte ();  			}  			else {  				// We are at end of buffer' just mark Comma to be skipped next time  				charactersToSkipOnNextRead [0] = Keys.Comma;  			}  			// We set to End Element  			MoveToEndElement ();  		}  		else {  			// Enter a new scope  			EnterJsonScope (JsonNodeType.Object);  			// Parse start element  			ParseStartElement ();  		}  		break;  	case Keys.RightClosingBrace:  		this.BufferReader.SkipByte ();  		if (expectingFirstElementInNonPrimitiveChild) {  			SkipWhitespaceInBufferReader ();  			ch = this.BufferReader.GetByte ();  			switch (ch) {  			case Keys.Comma:  			case Keys.RightClosingBrace:  				this.BufferReader.SkipByte ();  				break;  			default:  				throw new XmlException ("JsonEncounteredUnexpectedCharacter");  			}  			expectingFirstElementInNonPrimitiveChild = false;  		}  		MoveToEndElement ();  		break;  	case Keys.Comma:  		this.BufferReader.SkipByte ();  		MoveToEndElement ();  		break;  	case Keys.DoubleQuote:  		if (this.Node.NodeType == XmlNodeType.Element) {  			if (expectingFirstElementInNonPrimitiveChild) {  				EnterJsonScope (JsonNodeType.Object);  				ParseStartElement ();  			}  			else {  				this.BufferReader.SkipByte ();  				ReadQuotedText (true);  			}  		}  		else if (this.Node.NodeType == XmlNodeType.EndElement) {  			EnterJsonScope (JsonNodeType.Element);  			ParseStartElement ();  		}  		else  			throw new XmlException ("JsonEncounteredUnexpectedCharacter");  		break;  	case Keys.LowerF:  		{  			int offset;  			byte[] buffer = this.BufferReader.GetBuffer (5' out offset);  			// Check if it's "false"  			if (buffer [offset + 1] != Keys.LowerA || buffer [offset + 2] != Keys.LowerL || buffer [offset + 3] != Keys.LowerS || buffer [offset + 4] != Keys.LowerE)  				throw new Exception ("Expected False");  			// Advance of 5 byte  			this.BufferReader.Advance (5);  			// Check if char after is a closing one  			if (TryGetByte (out ch) && !IsWhitespace (ch) && (ch != Keys.Comma && ch != Keys.RightClosingBrace) && ch != Keys.RightClosingBracket)  				throw new Exception ("TokenExpected");  			// Move  			this.MoveToAtomicText ().Value.SetValue (ValueHandleType.UTF8' offset' 5);  		}  		break;  	case Keys.LowerT:  		{  			int offset;  			// check if it's "true"  			byte[] buffer = this.BufferReader.GetBuffer (4' out offset);  			if (buffer [offset + 1] != Keys.LowerR || buffer [offset + 2] != Keys.LowerU || buffer [offset + 3] != Keys.LowerE)  				throw new Exception ("expected true");  			this.BufferReader.Advance (4);  			// Check if char after is a closing one  			if (TryGetByte (out ch) && !IsWhitespace (ch) && (ch != Keys.Comma && ch != Keys.RightClosingBrace) && ch != Keys.RightClosingBracket)  				throw new Exception ("TokenExpected");  			// move atomic  			this.MoveToAtomicText ().Value.SetValue (ValueHandleType.UTF8' offset' 4);  		}  		break;  	case Keys.LowerN:  		{  			int offset;  			// check if it's "null"  			byte[] buffer = this.BufferReader.GetBuffer (4' out offset);  			if (buffer [offset + 1] != Keys.LowerU || buffer [offset + 2] != Keys.LowerL || buffer [offset + 3] != Keys.LowerL)  				throw new Exception ("Expected null");  			// advance of 4 chars  			this.BufferReader.Advance (4);  			SkipWhitespaceInBufferReader ();  			if (TryGetByte (out ch)) {  				if (ch == Keys.Comma || ch == Keys.RightClosingBrace)  					this.BufferReader.SkipByte ();  				else if (ch != Keys.RightClosingBracket)  					throw new Exception ("TokenExpected");  			}  			else {  				charactersToSkipOnNextRead [0] = Keys.Comma;  				charactersToSkipOnNextRead [1] = Keys.RightClosingBrace;  			}  			MoveToEndElement ();  		}  		break;  	default:  		if ((ch == (byte)'-') || (((byte)'0' <= ch) && (ch <= (byte)'9')) || (ch == (byte)'I') || (ch == (byte)'N'))  			ReadNumericalText ();  		else  			throw new XmlException ("JsonEncounteredUnexpectedCharacter");  		break;  	}  
Magic Number,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,Read,The following statement contains a magic number: if (IsReadingComplexText) {  	switch (complexTextMode) {  	case JsonComplexTextMode.QuotedText:  		if (ch == Keys.BackSlash) {  			ReadEscapedCharacter (true);  			break;  		}  		ReadQuotedText (true);  		break;  	case JsonComplexTextMode.NumericalText:  		ReadNumericalText ();  		break;  	case JsonComplexTextMode.None:  		throw new XmlException ("JsonEncounteredUnexpectedCharacter");  	}  }  else if (IsReadingCollection)  	ReadNonExistentElementName (StringHandleConstStringType.Item);  else  	switch (ch) {  	case Keys.RightClosingBracket:  		this.BufferReader.SkipByte ();  		MoveToEndElement ();  		ExitJsonScope ();  		break;  	case Keys.LeftOpeningBrace:  		this.BufferReader.SkipByte ();  		SkipWhitespaceInBufferReader ();  		ch = this.BufferReader.GetByte ();  		if (ch == Keys.RightClosingBrace) {  			// Skip this byte  			this.BufferReader.SkipByte ();  			// Skip white spaces  			SkipWhitespaceInBufferReader ();  			// try get next char  			if (TryGetByte (out ch)) {  				if (ch == Keys.Comma)  					this.BufferReader.SkipByte ();  			}  			else {  				// We are at end of buffer' just mark Comma to be skipped next time  				charactersToSkipOnNextRead [0] = Keys.Comma;  			}  			// We set to End Element  			MoveToEndElement ();  		}  		else {  			// Enter a new scope  			EnterJsonScope (JsonNodeType.Object);  			// Parse start element  			ParseStartElement ();  		}  		break;  	case Keys.RightClosingBrace:  		this.BufferReader.SkipByte ();  		if (expectingFirstElementInNonPrimitiveChild) {  			SkipWhitespaceInBufferReader ();  			ch = this.BufferReader.GetByte ();  			switch (ch) {  			case Keys.Comma:  			case Keys.RightClosingBrace:  				this.BufferReader.SkipByte ();  				break;  			default:  				throw new XmlException ("JsonEncounteredUnexpectedCharacter");  			}  			expectingFirstElementInNonPrimitiveChild = false;  		}  		MoveToEndElement ();  		break;  	case Keys.Comma:  		this.BufferReader.SkipByte ();  		MoveToEndElement ();  		break;  	case Keys.DoubleQuote:  		if (this.Node.NodeType == XmlNodeType.Element) {  			if (expectingFirstElementInNonPrimitiveChild) {  				EnterJsonScope (JsonNodeType.Object);  				ParseStartElement ();  			}  			else {  				this.BufferReader.SkipByte ();  				ReadQuotedText (true);  			}  		}  		else if (this.Node.NodeType == XmlNodeType.EndElement) {  			EnterJsonScope (JsonNodeType.Element);  			ParseStartElement ();  		}  		else  			throw new XmlException ("JsonEncounteredUnexpectedCharacter");  		break;  	case Keys.LowerF:  		{  			int offset;  			byte[] buffer = this.BufferReader.GetBuffer (5' out offset);  			// Check if it's "false"  			if (buffer [offset + 1] != Keys.LowerA || buffer [offset + 2] != Keys.LowerL || buffer [offset + 3] != Keys.LowerS || buffer [offset + 4] != Keys.LowerE)  				throw new Exception ("Expected False");  			// Advance of 5 byte  			this.BufferReader.Advance (5);  			// Check if char after is a closing one  			if (TryGetByte (out ch) && !IsWhitespace (ch) && (ch != Keys.Comma && ch != Keys.RightClosingBrace) && ch != Keys.RightClosingBracket)  				throw new Exception ("TokenExpected");  			// Move  			this.MoveToAtomicText ().Value.SetValue (ValueHandleType.UTF8' offset' 5);  		}  		break;  	case Keys.LowerT:  		{  			int offset;  			// check if it's "true"  			byte[] buffer = this.BufferReader.GetBuffer (4' out offset);  			if (buffer [offset + 1] != Keys.LowerR || buffer [offset + 2] != Keys.LowerU || buffer [offset + 3] != Keys.LowerE)  				throw new Exception ("expected true");  			this.BufferReader.Advance (4);  			// Check if char after is a closing one  			if (TryGetByte (out ch) && !IsWhitespace (ch) && (ch != Keys.Comma && ch != Keys.RightClosingBrace) && ch != Keys.RightClosingBracket)  				throw new Exception ("TokenExpected");  			// move atomic  			this.MoveToAtomicText ().Value.SetValue (ValueHandleType.UTF8' offset' 4);  		}  		break;  	case Keys.LowerN:  		{  			int offset;  			// check if it's "null"  			byte[] buffer = this.BufferReader.GetBuffer (4' out offset);  			if (buffer [offset + 1] != Keys.LowerU || buffer [offset + 2] != Keys.LowerL || buffer [offset + 3] != Keys.LowerL)  				throw new Exception ("Expected null");  			// advance of 4 chars  			this.BufferReader.Advance (4);  			SkipWhitespaceInBufferReader ();  			if (TryGetByte (out ch)) {  				if (ch == Keys.Comma || ch == Keys.RightClosingBrace)  					this.BufferReader.SkipByte ();  				else if (ch != Keys.RightClosingBracket)  					throw new Exception ("TokenExpected");  			}  			else {  				charactersToSkipOnNextRead [0] = Keys.Comma;  				charactersToSkipOnNextRead [1] = Keys.RightClosingBrace;  			}  			MoveToEndElement ();  		}  		break;  	default:  		if ((ch == (byte)'-') || (((byte)'0' <= ch) && (ch <= (byte)'9')) || (ch == (byte)'I') || (ch == (byte)'N'))  			ReadNumericalText ();  		else  			throw new XmlException ("JsonEncounteredUnexpectedCharacter");  		break;  	}  
Magic Number,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,Read,The following statement contains a magic number: if (IsReadingComplexText) {  	switch (complexTextMode) {  	case JsonComplexTextMode.QuotedText:  		if (ch == Keys.BackSlash) {  			ReadEscapedCharacter (true);  			break;  		}  		ReadQuotedText (true);  		break;  	case JsonComplexTextMode.NumericalText:  		ReadNumericalText ();  		break;  	case JsonComplexTextMode.None:  		throw new XmlException ("JsonEncounteredUnexpectedCharacter");  	}  }  else if (IsReadingCollection)  	ReadNonExistentElementName (StringHandleConstStringType.Item);  else  	switch (ch) {  	case Keys.RightClosingBracket:  		this.BufferReader.SkipByte ();  		MoveToEndElement ();  		ExitJsonScope ();  		break;  	case Keys.LeftOpeningBrace:  		this.BufferReader.SkipByte ();  		SkipWhitespaceInBufferReader ();  		ch = this.BufferReader.GetByte ();  		if (ch == Keys.RightClosingBrace) {  			// Skip this byte  			this.BufferReader.SkipByte ();  			// Skip white spaces  			SkipWhitespaceInBufferReader ();  			// try get next char  			if (TryGetByte (out ch)) {  				if (ch == Keys.Comma)  					this.BufferReader.SkipByte ();  			}  			else {  				// We are at end of buffer' just mark Comma to be skipped next time  				charactersToSkipOnNextRead [0] = Keys.Comma;  			}  			// We set to End Element  			MoveToEndElement ();  		}  		else {  			// Enter a new scope  			EnterJsonScope (JsonNodeType.Object);  			// Parse start element  			ParseStartElement ();  		}  		break;  	case Keys.RightClosingBrace:  		this.BufferReader.SkipByte ();  		if (expectingFirstElementInNonPrimitiveChild) {  			SkipWhitespaceInBufferReader ();  			ch = this.BufferReader.GetByte ();  			switch (ch) {  			case Keys.Comma:  			case Keys.RightClosingBrace:  				this.BufferReader.SkipByte ();  				break;  			default:  				throw new XmlException ("JsonEncounteredUnexpectedCharacter");  			}  			expectingFirstElementInNonPrimitiveChild = false;  		}  		MoveToEndElement ();  		break;  	case Keys.Comma:  		this.BufferReader.SkipByte ();  		MoveToEndElement ();  		break;  	case Keys.DoubleQuote:  		if (this.Node.NodeType == XmlNodeType.Element) {  			if (expectingFirstElementInNonPrimitiveChild) {  				EnterJsonScope (JsonNodeType.Object);  				ParseStartElement ();  			}  			else {  				this.BufferReader.SkipByte ();  				ReadQuotedText (true);  			}  		}  		else if (this.Node.NodeType == XmlNodeType.EndElement) {  			EnterJsonScope (JsonNodeType.Element);  			ParseStartElement ();  		}  		else  			throw new XmlException ("JsonEncounteredUnexpectedCharacter");  		break;  	case Keys.LowerF:  		{  			int offset;  			byte[] buffer = this.BufferReader.GetBuffer (5' out offset);  			// Check if it's "false"  			if (buffer [offset + 1] != Keys.LowerA || buffer [offset + 2] != Keys.LowerL || buffer [offset + 3] != Keys.LowerS || buffer [offset + 4] != Keys.LowerE)  				throw new Exception ("Expected False");  			// Advance of 5 byte  			this.BufferReader.Advance (5);  			// Check if char after is a closing one  			if (TryGetByte (out ch) && !IsWhitespace (ch) && (ch != Keys.Comma && ch != Keys.RightClosingBrace) && ch != Keys.RightClosingBracket)  				throw new Exception ("TokenExpected");  			// Move  			this.MoveToAtomicText ().Value.SetValue (ValueHandleType.UTF8' offset' 5);  		}  		break;  	case Keys.LowerT:  		{  			int offset;  			// check if it's "true"  			byte[] buffer = this.BufferReader.GetBuffer (4' out offset);  			if (buffer [offset + 1] != Keys.LowerR || buffer [offset + 2] != Keys.LowerU || buffer [offset + 3] != Keys.LowerE)  				throw new Exception ("expected true");  			this.BufferReader.Advance (4);  			// Check if char after is a closing one  			if (TryGetByte (out ch) && !IsWhitespace (ch) && (ch != Keys.Comma && ch != Keys.RightClosingBrace) && ch != Keys.RightClosingBracket)  				throw new Exception ("TokenExpected");  			// move atomic  			this.MoveToAtomicText ().Value.SetValue (ValueHandleType.UTF8' offset' 4);  		}  		break;  	case Keys.LowerN:  		{  			int offset;  			// check if it's "null"  			byte[] buffer = this.BufferReader.GetBuffer (4' out offset);  			if (buffer [offset + 1] != Keys.LowerU || buffer [offset + 2] != Keys.LowerL || buffer [offset + 3] != Keys.LowerL)  				throw new Exception ("Expected null");  			// advance of 4 chars  			this.BufferReader.Advance (4);  			SkipWhitespaceInBufferReader ();  			if (TryGetByte (out ch)) {  				if (ch == Keys.Comma || ch == Keys.RightClosingBrace)  					this.BufferReader.SkipByte ();  				else if (ch != Keys.RightClosingBracket)  					throw new Exception ("TokenExpected");  			}  			else {  				charactersToSkipOnNextRead [0] = Keys.Comma;  				charactersToSkipOnNextRead [1] = Keys.RightClosingBrace;  			}  			MoveToEndElement ();  		}  		break;  	default:  		if ((ch == (byte)'-') || (((byte)'0' <= ch) && (ch <= (byte)'9')) || (ch == (byte)'I') || (ch == (byte)'N'))  			ReadNumericalText ();  		else  			throw new XmlException ("JsonEncounteredUnexpectedCharacter");  		break;  	}  
Magic Number,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,Read,The following statement contains a magic number: if (IsReadingComplexText) {  	switch (complexTextMode) {  	case JsonComplexTextMode.QuotedText:  		if (ch == Keys.BackSlash) {  			ReadEscapedCharacter (true);  			break;  		}  		ReadQuotedText (true);  		break;  	case JsonComplexTextMode.NumericalText:  		ReadNumericalText ();  		break;  	case JsonComplexTextMode.None:  		throw new XmlException ("JsonEncounteredUnexpectedCharacter");  	}  }  else if (IsReadingCollection)  	ReadNonExistentElementName (StringHandleConstStringType.Item);  else  	switch (ch) {  	case Keys.RightClosingBracket:  		this.BufferReader.SkipByte ();  		MoveToEndElement ();  		ExitJsonScope ();  		break;  	case Keys.LeftOpeningBrace:  		this.BufferReader.SkipByte ();  		SkipWhitespaceInBufferReader ();  		ch = this.BufferReader.GetByte ();  		if (ch == Keys.RightClosingBrace) {  			// Skip this byte  			this.BufferReader.SkipByte ();  			// Skip white spaces  			SkipWhitespaceInBufferReader ();  			// try get next char  			if (TryGetByte (out ch)) {  				if (ch == Keys.Comma)  					this.BufferReader.SkipByte ();  			}  			else {  				// We are at end of buffer' just mark Comma to be skipped next time  				charactersToSkipOnNextRead [0] = Keys.Comma;  			}  			// We set to End Element  			MoveToEndElement ();  		}  		else {  			// Enter a new scope  			EnterJsonScope (JsonNodeType.Object);  			// Parse start element  			ParseStartElement ();  		}  		break;  	case Keys.RightClosingBrace:  		this.BufferReader.SkipByte ();  		if (expectingFirstElementInNonPrimitiveChild) {  			SkipWhitespaceInBufferReader ();  			ch = this.BufferReader.GetByte ();  			switch (ch) {  			case Keys.Comma:  			case Keys.RightClosingBrace:  				this.BufferReader.SkipByte ();  				break;  			default:  				throw new XmlException ("JsonEncounteredUnexpectedCharacter");  			}  			expectingFirstElementInNonPrimitiveChild = false;  		}  		MoveToEndElement ();  		break;  	case Keys.Comma:  		this.BufferReader.SkipByte ();  		MoveToEndElement ();  		break;  	case Keys.DoubleQuote:  		if (this.Node.NodeType == XmlNodeType.Element) {  			if (expectingFirstElementInNonPrimitiveChild) {  				EnterJsonScope (JsonNodeType.Object);  				ParseStartElement ();  			}  			else {  				this.BufferReader.SkipByte ();  				ReadQuotedText (true);  			}  		}  		else if (this.Node.NodeType == XmlNodeType.EndElement) {  			EnterJsonScope (JsonNodeType.Element);  			ParseStartElement ();  		}  		else  			throw new XmlException ("JsonEncounteredUnexpectedCharacter");  		break;  	case Keys.LowerF:  		{  			int offset;  			byte[] buffer = this.BufferReader.GetBuffer (5' out offset);  			// Check if it's "false"  			if (buffer [offset + 1] != Keys.LowerA || buffer [offset + 2] != Keys.LowerL || buffer [offset + 3] != Keys.LowerS || buffer [offset + 4] != Keys.LowerE)  				throw new Exception ("Expected False");  			// Advance of 5 byte  			this.BufferReader.Advance (5);  			// Check if char after is a closing one  			if (TryGetByte (out ch) && !IsWhitespace (ch) && (ch != Keys.Comma && ch != Keys.RightClosingBrace) && ch != Keys.RightClosingBracket)  				throw new Exception ("TokenExpected");  			// Move  			this.MoveToAtomicText ().Value.SetValue (ValueHandleType.UTF8' offset' 5);  		}  		break;  	case Keys.LowerT:  		{  			int offset;  			// check if it's "true"  			byte[] buffer = this.BufferReader.GetBuffer (4' out offset);  			if (buffer [offset + 1] != Keys.LowerR || buffer [offset + 2] != Keys.LowerU || buffer [offset + 3] != Keys.LowerE)  				throw new Exception ("expected true");  			this.BufferReader.Advance (4);  			// Check if char after is a closing one  			if (TryGetByte (out ch) && !IsWhitespace (ch) && (ch != Keys.Comma && ch != Keys.RightClosingBrace) && ch != Keys.RightClosingBracket)  				throw new Exception ("TokenExpected");  			// move atomic  			this.MoveToAtomicText ().Value.SetValue (ValueHandleType.UTF8' offset' 4);  		}  		break;  	case Keys.LowerN:  		{  			int offset;  			// check if it's "null"  			byte[] buffer = this.BufferReader.GetBuffer (4' out offset);  			if (buffer [offset + 1] != Keys.LowerU || buffer [offset + 2] != Keys.LowerL || buffer [offset + 3] != Keys.LowerL)  				throw new Exception ("Expected null");  			// advance of 4 chars  			this.BufferReader.Advance (4);  			SkipWhitespaceInBufferReader ();  			if (TryGetByte (out ch)) {  				if (ch == Keys.Comma || ch == Keys.RightClosingBrace)  					this.BufferReader.SkipByte ();  				else if (ch != Keys.RightClosingBracket)  					throw new Exception ("TokenExpected");  			}  			else {  				charactersToSkipOnNextRead [0] = Keys.Comma;  				charactersToSkipOnNextRead [1] = Keys.RightClosingBrace;  			}  			MoveToEndElement ();  		}  		break;  	default:  		if ((ch == (byte)'-') || (((byte)'0' <= ch) && (ch <= (byte)'9')) || (ch == (byte)'I') || (ch == (byte)'N'))  			ReadNumericalText ();  		else  			throw new XmlException ("JsonEncounteredUnexpectedCharacter");  		break;  	}  
Magic Number,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,Read,The following statement contains a magic number: if (IsReadingComplexText) {  	switch (complexTextMode) {  	case JsonComplexTextMode.QuotedText:  		if (ch == Keys.BackSlash) {  			ReadEscapedCharacter (true);  			break;  		}  		ReadQuotedText (true);  		break;  	case JsonComplexTextMode.NumericalText:  		ReadNumericalText ();  		break;  	case JsonComplexTextMode.None:  		throw new XmlException ("JsonEncounteredUnexpectedCharacter");  	}  }  else if (IsReadingCollection)  	ReadNonExistentElementName (StringHandleConstStringType.Item);  else  	switch (ch) {  	case Keys.RightClosingBracket:  		this.BufferReader.SkipByte ();  		MoveToEndElement ();  		ExitJsonScope ();  		break;  	case Keys.LeftOpeningBrace:  		this.BufferReader.SkipByte ();  		SkipWhitespaceInBufferReader ();  		ch = this.BufferReader.GetByte ();  		if (ch == Keys.RightClosingBrace) {  			// Skip this byte  			this.BufferReader.SkipByte ();  			// Skip white spaces  			SkipWhitespaceInBufferReader ();  			// try get next char  			if (TryGetByte (out ch)) {  				if (ch == Keys.Comma)  					this.BufferReader.SkipByte ();  			}  			else {  				// We are at end of buffer' just mark Comma to be skipped next time  				charactersToSkipOnNextRead [0] = Keys.Comma;  			}  			// We set to End Element  			MoveToEndElement ();  		}  		else {  			// Enter a new scope  			EnterJsonScope (JsonNodeType.Object);  			// Parse start element  			ParseStartElement ();  		}  		break;  	case Keys.RightClosingBrace:  		this.BufferReader.SkipByte ();  		if (expectingFirstElementInNonPrimitiveChild) {  			SkipWhitespaceInBufferReader ();  			ch = this.BufferReader.GetByte ();  			switch (ch) {  			case Keys.Comma:  			case Keys.RightClosingBrace:  				this.BufferReader.SkipByte ();  				break;  			default:  				throw new XmlException ("JsonEncounteredUnexpectedCharacter");  			}  			expectingFirstElementInNonPrimitiveChild = false;  		}  		MoveToEndElement ();  		break;  	case Keys.Comma:  		this.BufferReader.SkipByte ();  		MoveToEndElement ();  		break;  	case Keys.DoubleQuote:  		if (this.Node.NodeType == XmlNodeType.Element) {  			if (expectingFirstElementInNonPrimitiveChild) {  				EnterJsonScope (JsonNodeType.Object);  				ParseStartElement ();  			}  			else {  				this.BufferReader.SkipByte ();  				ReadQuotedText (true);  			}  		}  		else if (this.Node.NodeType == XmlNodeType.EndElement) {  			EnterJsonScope (JsonNodeType.Element);  			ParseStartElement ();  		}  		else  			throw new XmlException ("JsonEncounteredUnexpectedCharacter");  		break;  	case Keys.LowerF:  		{  			int offset;  			byte[] buffer = this.BufferReader.GetBuffer (5' out offset);  			// Check if it's "false"  			if (buffer [offset + 1] != Keys.LowerA || buffer [offset + 2] != Keys.LowerL || buffer [offset + 3] != Keys.LowerS || buffer [offset + 4] != Keys.LowerE)  				throw new Exception ("Expected False");  			// Advance of 5 byte  			this.BufferReader.Advance (5);  			// Check if char after is a closing one  			if (TryGetByte (out ch) && !IsWhitespace (ch) && (ch != Keys.Comma && ch != Keys.RightClosingBrace) && ch != Keys.RightClosingBracket)  				throw new Exception ("TokenExpected");  			// Move  			this.MoveToAtomicText ().Value.SetValue (ValueHandleType.UTF8' offset' 5);  		}  		break;  	case Keys.LowerT:  		{  			int offset;  			// check if it's "true"  			byte[] buffer = this.BufferReader.GetBuffer (4' out offset);  			if (buffer [offset + 1] != Keys.LowerR || buffer [offset + 2] != Keys.LowerU || buffer [offset + 3] != Keys.LowerE)  				throw new Exception ("expected true");  			this.BufferReader.Advance (4);  			// Check if char after is a closing one  			if (TryGetByte (out ch) && !IsWhitespace (ch) && (ch != Keys.Comma && ch != Keys.RightClosingBrace) && ch != Keys.RightClosingBracket)  				throw new Exception ("TokenExpected");  			// move atomic  			this.MoveToAtomicText ().Value.SetValue (ValueHandleType.UTF8' offset' 4);  		}  		break;  	case Keys.LowerN:  		{  			int offset;  			// check if it's "null"  			byte[] buffer = this.BufferReader.GetBuffer (4' out offset);  			if (buffer [offset + 1] != Keys.LowerU || buffer [offset + 2] != Keys.LowerL || buffer [offset + 3] != Keys.LowerL)  				throw new Exception ("Expected null");  			// advance of 4 chars  			this.BufferReader.Advance (4);  			SkipWhitespaceInBufferReader ();  			if (TryGetByte (out ch)) {  				if (ch == Keys.Comma || ch == Keys.RightClosingBrace)  					this.BufferReader.SkipByte ();  				else if (ch != Keys.RightClosingBracket)  					throw new Exception ("TokenExpected");  			}  			else {  				charactersToSkipOnNextRead [0] = Keys.Comma;  				charactersToSkipOnNextRead [1] = Keys.RightClosingBrace;  			}  			MoveToEndElement ();  		}  		break;  	default:  		if ((ch == (byte)'-') || (((byte)'0' <= ch) && (ch <= (byte)'9')) || (ch == (byte)'I') || (ch == (byte)'N'))  			ReadNumericalText ();  		else  			throw new XmlException ("JsonEncounteredUnexpectedCharacter");  		break;  	}  
Magic Number,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,Read,The following statement contains a magic number: if (IsReadingComplexText) {  	switch (complexTextMode) {  	case JsonComplexTextMode.QuotedText:  		if (ch == Keys.BackSlash) {  			ReadEscapedCharacter (true);  			break;  		}  		ReadQuotedText (true);  		break;  	case JsonComplexTextMode.NumericalText:  		ReadNumericalText ();  		break;  	case JsonComplexTextMode.None:  		throw new XmlException ("JsonEncounteredUnexpectedCharacter");  	}  }  else if (IsReadingCollection)  	ReadNonExistentElementName (StringHandleConstStringType.Item);  else  	switch (ch) {  	case Keys.RightClosingBracket:  		this.BufferReader.SkipByte ();  		MoveToEndElement ();  		ExitJsonScope ();  		break;  	case Keys.LeftOpeningBrace:  		this.BufferReader.SkipByte ();  		SkipWhitespaceInBufferReader ();  		ch = this.BufferReader.GetByte ();  		if (ch == Keys.RightClosingBrace) {  			// Skip this byte  			this.BufferReader.SkipByte ();  			// Skip white spaces  			SkipWhitespaceInBufferReader ();  			// try get next char  			if (TryGetByte (out ch)) {  				if (ch == Keys.Comma)  					this.BufferReader.SkipByte ();  			}  			else {  				// We are at end of buffer' just mark Comma to be skipped next time  				charactersToSkipOnNextRead [0] = Keys.Comma;  			}  			// We set to End Element  			MoveToEndElement ();  		}  		else {  			// Enter a new scope  			EnterJsonScope (JsonNodeType.Object);  			// Parse start element  			ParseStartElement ();  		}  		break;  	case Keys.RightClosingBrace:  		this.BufferReader.SkipByte ();  		if (expectingFirstElementInNonPrimitiveChild) {  			SkipWhitespaceInBufferReader ();  			ch = this.BufferReader.GetByte ();  			switch (ch) {  			case Keys.Comma:  			case Keys.RightClosingBrace:  				this.BufferReader.SkipByte ();  				break;  			default:  				throw new XmlException ("JsonEncounteredUnexpectedCharacter");  			}  			expectingFirstElementInNonPrimitiveChild = false;  		}  		MoveToEndElement ();  		break;  	case Keys.Comma:  		this.BufferReader.SkipByte ();  		MoveToEndElement ();  		break;  	case Keys.DoubleQuote:  		if (this.Node.NodeType == XmlNodeType.Element) {  			if (expectingFirstElementInNonPrimitiveChild) {  				EnterJsonScope (JsonNodeType.Object);  				ParseStartElement ();  			}  			else {  				this.BufferReader.SkipByte ();  				ReadQuotedText (true);  			}  		}  		else if (this.Node.NodeType == XmlNodeType.EndElement) {  			EnterJsonScope (JsonNodeType.Element);  			ParseStartElement ();  		}  		else  			throw new XmlException ("JsonEncounteredUnexpectedCharacter");  		break;  	case Keys.LowerF:  		{  			int offset;  			byte[] buffer = this.BufferReader.GetBuffer (5' out offset);  			// Check if it's "false"  			if (buffer [offset + 1] != Keys.LowerA || buffer [offset + 2] != Keys.LowerL || buffer [offset + 3] != Keys.LowerS || buffer [offset + 4] != Keys.LowerE)  				throw new Exception ("Expected False");  			// Advance of 5 byte  			this.BufferReader.Advance (5);  			// Check if char after is a closing one  			if (TryGetByte (out ch) && !IsWhitespace (ch) && (ch != Keys.Comma && ch != Keys.RightClosingBrace) && ch != Keys.RightClosingBracket)  				throw new Exception ("TokenExpected");  			// Move  			this.MoveToAtomicText ().Value.SetValue (ValueHandleType.UTF8' offset' 5);  		}  		break;  	case Keys.LowerT:  		{  			int offset;  			// check if it's "true"  			byte[] buffer = this.BufferReader.GetBuffer (4' out offset);  			if (buffer [offset + 1] != Keys.LowerR || buffer [offset + 2] != Keys.LowerU || buffer [offset + 3] != Keys.LowerE)  				throw new Exception ("expected true");  			this.BufferReader.Advance (4);  			// Check if char after is a closing one  			if (TryGetByte (out ch) && !IsWhitespace (ch) && (ch != Keys.Comma && ch != Keys.RightClosingBrace) && ch != Keys.RightClosingBracket)  				throw new Exception ("TokenExpected");  			// move atomic  			this.MoveToAtomicText ().Value.SetValue (ValueHandleType.UTF8' offset' 4);  		}  		break;  	case Keys.LowerN:  		{  			int offset;  			// check if it's "null"  			byte[] buffer = this.BufferReader.GetBuffer (4' out offset);  			if (buffer [offset + 1] != Keys.LowerU || buffer [offset + 2] != Keys.LowerL || buffer [offset + 3] != Keys.LowerL)  				throw new Exception ("Expected null");  			// advance of 4 chars  			this.BufferReader.Advance (4);  			SkipWhitespaceInBufferReader ();  			if (TryGetByte (out ch)) {  				if (ch == Keys.Comma || ch == Keys.RightClosingBrace)  					this.BufferReader.SkipByte ();  				else if (ch != Keys.RightClosingBracket)  					throw new Exception ("TokenExpected");  			}  			else {  				charactersToSkipOnNextRead [0] = Keys.Comma;  				charactersToSkipOnNextRead [1] = Keys.RightClosingBrace;  			}  			MoveToEndElement ();  		}  		break;  	default:  		if ((ch == (byte)'-') || (((byte)'0' <= ch) && (ch <= (byte)'9')) || (ch == (byte)'I') || (ch == (byte)'N'))  			ReadNumericalText ();  		else  			throw new XmlException ("JsonEncounteredUnexpectedCharacter");  		break;  	}  
Magic Number,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,Read,The following statement contains a magic number: if (IsReadingComplexText) {  	switch (complexTextMode) {  	case JsonComplexTextMode.QuotedText:  		if (ch == Keys.BackSlash) {  			ReadEscapedCharacter (true);  			break;  		}  		ReadQuotedText (true);  		break;  	case JsonComplexTextMode.NumericalText:  		ReadNumericalText ();  		break;  	case JsonComplexTextMode.None:  		throw new XmlException ("JsonEncounteredUnexpectedCharacter");  	}  }  else if (IsReadingCollection)  	ReadNonExistentElementName (StringHandleConstStringType.Item);  else  	switch (ch) {  	case Keys.RightClosingBracket:  		this.BufferReader.SkipByte ();  		MoveToEndElement ();  		ExitJsonScope ();  		break;  	case Keys.LeftOpeningBrace:  		this.BufferReader.SkipByte ();  		SkipWhitespaceInBufferReader ();  		ch = this.BufferReader.GetByte ();  		if (ch == Keys.RightClosingBrace) {  			// Skip this byte  			this.BufferReader.SkipByte ();  			// Skip white spaces  			SkipWhitespaceInBufferReader ();  			// try get next char  			if (TryGetByte (out ch)) {  				if (ch == Keys.Comma)  					this.BufferReader.SkipByte ();  			}  			else {  				// We are at end of buffer' just mark Comma to be skipped next time  				charactersToSkipOnNextRead [0] = Keys.Comma;  			}  			// We set to End Element  			MoveToEndElement ();  		}  		else {  			// Enter a new scope  			EnterJsonScope (JsonNodeType.Object);  			// Parse start element  			ParseStartElement ();  		}  		break;  	case Keys.RightClosingBrace:  		this.BufferReader.SkipByte ();  		if (expectingFirstElementInNonPrimitiveChild) {  			SkipWhitespaceInBufferReader ();  			ch = this.BufferReader.GetByte ();  			switch (ch) {  			case Keys.Comma:  			case Keys.RightClosingBrace:  				this.BufferReader.SkipByte ();  				break;  			default:  				throw new XmlException ("JsonEncounteredUnexpectedCharacter");  			}  			expectingFirstElementInNonPrimitiveChild = false;  		}  		MoveToEndElement ();  		break;  	case Keys.Comma:  		this.BufferReader.SkipByte ();  		MoveToEndElement ();  		break;  	case Keys.DoubleQuote:  		if (this.Node.NodeType == XmlNodeType.Element) {  			if (expectingFirstElementInNonPrimitiveChild) {  				EnterJsonScope (JsonNodeType.Object);  				ParseStartElement ();  			}  			else {  				this.BufferReader.SkipByte ();  				ReadQuotedText (true);  			}  		}  		else if (this.Node.NodeType == XmlNodeType.EndElement) {  			EnterJsonScope (JsonNodeType.Element);  			ParseStartElement ();  		}  		else  			throw new XmlException ("JsonEncounteredUnexpectedCharacter");  		break;  	case Keys.LowerF:  		{  			int offset;  			byte[] buffer = this.BufferReader.GetBuffer (5' out offset);  			// Check if it's "false"  			if (buffer [offset + 1] != Keys.LowerA || buffer [offset + 2] != Keys.LowerL || buffer [offset + 3] != Keys.LowerS || buffer [offset + 4] != Keys.LowerE)  				throw new Exception ("Expected False");  			// Advance of 5 byte  			this.BufferReader.Advance (5);  			// Check if char after is a closing one  			if (TryGetByte (out ch) && !IsWhitespace (ch) && (ch != Keys.Comma && ch != Keys.RightClosingBrace) && ch != Keys.RightClosingBracket)  				throw new Exception ("TokenExpected");  			// Move  			this.MoveToAtomicText ().Value.SetValue (ValueHandleType.UTF8' offset' 5);  		}  		break;  	case Keys.LowerT:  		{  			int offset;  			// check if it's "true"  			byte[] buffer = this.BufferReader.GetBuffer (4' out offset);  			if (buffer [offset + 1] != Keys.LowerR || buffer [offset + 2] != Keys.LowerU || buffer [offset + 3] != Keys.LowerE)  				throw new Exception ("expected true");  			this.BufferReader.Advance (4);  			// Check if char after is a closing one  			if (TryGetByte (out ch) && !IsWhitespace (ch) && (ch != Keys.Comma && ch != Keys.RightClosingBrace) && ch != Keys.RightClosingBracket)  				throw new Exception ("TokenExpected");  			// move atomic  			this.MoveToAtomicText ().Value.SetValue (ValueHandleType.UTF8' offset' 4);  		}  		break;  	case Keys.LowerN:  		{  			int offset;  			// check if it's "null"  			byte[] buffer = this.BufferReader.GetBuffer (4' out offset);  			if (buffer [offset + 1] != Keys.LowerU || buffer [offset + 2] != Keys.LowerL || buffer [offset + 3] != Keys.LowerL)  				throw new Exception ("Expected null");  			// advance of 4 chars  			this.BufferReader.Advance (4);  			SkipWhitespaceInBufferReader ();  			if (TryGetByte (out ch)) {  				if (ch == Keys.Comma || ch == Keys.RightClosingBrace)  					this.BufferReader.SkipByte ();  				else if (ch != Keys.RightClosingBracket)  					throw new Exception ("TokenExpected");  			}  			else {  				charactersToSkipOnNextRead [0] = Keys.Comma;  				charactersToSkipOnNextRead [1] = Keys.RightClosingBrace;  			}  			MoveToEndElement ();  		}  		break;  	default:  		if ((ch == (byte)'-') || (((byte)'0' <= ch) && (ch <= (byte)'9')) || (ch == (byte)'I') || (ch == (byte)'N'))  			ReadNumericalText ();  		else  			throw new XmlException ("JsonEncounteredUnexpectedCharacter");  		break;  	}  
Magic Number,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,Read,The following statement contains a magic number: if (IsReadingComplexText) {  	switch (complexTextMode) {  	case JsonComplexTextMode.QuotedText:  		if (ch == Keys.BackSlash) {  			ReadEscapedCharacter (true);  			break;  		}  		ReadQuotedText (true);  		break;  	case JsonComplexTextMode.NumericalText:  		ReadNumericalText ();  		break;  	case JsonComplexTextMode.None:  		throw new XmlException ("JsonEncounteredUnexpectedCharacter");  	}  }  else if (IsReadingCollection)  	ReadNonExistentElementName (StringHandleConstStringType.Item);  else  	switch (ch) {  	case Keys.RightClosingBracket:  		this.BufferReader.SkipByte ();  		MoveToEndElement ();  		ExitJsonScope ();  		break;  	case Keys.LeftOpeningBrace:  		this.BufferReader.SkipByte ();  		SkipWhitespaceInBufferReader ();  		ch = this.BufferReader.GetByte ();  		if (ch == Keys.RightClosingBrace) {  			// Skip this byte  			this.BufferReader.SkipByte ();  			// Skip white spaces  			SkipWhitespaceInBufferReader ();  			// try get next char  			if (TryGetByte (out ch)) {  				if (ch == Keys.Comma)  					this.BufferReader.SkipByte ();  			}  			else {  				// We are at end of buffer' just mark Comma to be skipped next time  				charactersToSkipOnNextRead [0] = Keys.Comma;  			}  			// We set to End Element  			MoveToEndElement ();  		}  		else {  			// Enter a new scope  			EnterJsonScope (JsonNodeType.Object);  			// Parse start element  			ParseStartElement ();  		}  		break;  	case Keys.RightClosingBrace:  		this.BufferReader.SkipByte ();  		if (expectingFirstElementInNonPrimitiveChild) {  			SkipWhitespaceInBufferReader ();  			ch = this.BufferReader.GetByte ();  			switch (ch) {  			case Keys.Comma:  			case Keys.RightClosingBrace:  				this.BufferReader.SkipByte ();  				break;  			default:  				throw new XmlException ("JsonEncounteredUnexpectedCharacter");  			}  			expectingFirstElementInNonPrimitiveChild = false;  		}  		MoveToEndElement ();  		break;  	case Keys.Comma:  		this.BufferReader.SkipByte ();  		MoveToEndElement ();  		break;  	case Keys.DoubleQuote:  		if (this.Node.NodeType == XmlNodeType.Element) {  			if (expectingFirstElementInNonPrimitiveChild) {  				EnterJsonScope (JsonNodeType.Object);  				ParseStartElement ();  			}  			else {  				this.BufferReader.SkipByte ();  				ReadQuotedText (true);  			}  		}  		else if (this.Node.NodeType == XmlNodeType.EndElement) {  			EnterJsonScope (JsonNodeType.Element);  			ParseStartElement ();  		}  		else  			throw new XmlException ("JsonEncounteredUnexpectedCharacter");  		break;  	case Keys.LowerF:  		{  			int offset;  			byte[] buffer = this.BufferReader.GetBuffer (5' out offset);  			// Check if it's "false"  			if (buffer [offset + 1] != Keys.LowerA || buffer [offset + 2] != Keys.LowerL || buffer [offset + 3] != Keys.LowerS || buffer [offset + 4] != Keys.LowerE)  				throw new Exception ("Expected False");  			// Advance of 5 byte  			this.BufferReader.Advance (5);  			// Check if char after is a closing one  			if (TryGetByte (out ch) && !IsWhitespace (ch) && (ch != Keys.Comma && ch != Keys.RightClosingBrace) && ch != Keys.RightClosingBracket)  				throw new Exception ("TokenExpected");  			// Move  			this.MoveToAtomicText ().Value.SetValue (ValueHandleType.UTF8' offset' 5);  		}  		break;  	case Keys.LowerT:  		{  			int offset;  			// check if it's "true"  			byte[] buffer = this.BufferReader.GetBuffer (4' out offset);  			if (buffer [offset + 1] != Keys.LowerR || buffer [offset + 2] != Keys.LowerU || buffer [offset + 3] != Keys.LowerE)  				throw new Exception ("expected true");  			this.BufferReader.Advance (4);  			// Check if char after is a closing one  			if (TryGetByte (out ch) && !IsWhitespace (ch) && (ch != Keys.Comma && ch != Keys.RightClosingBrace) && ch != Keys.RightClosingBracket)  				throw new Exception ("TokenExpected");  			// move atomic  			this.MoveToAtomicText ().Value.SetValue (ValueHandleType.UTF8' offset' 4);  		}  		break;  	case Keys.LowerN:  		{  			int offset;  			// check if it's "null"  			byte[] buffer = this.BufferReader.GetBuffer (4' out offset);  			if (buffer [offset + 1] != Keys.LowerU || buffer [offset + 2] != Keys.LowerL || buffer [offset + 3] != Keys.LowerL)  				throw new Exception ("Expected null");  			// advance of 4 chars  			this.BufferReader.Advance (4);  			SkipWhitespaceInBufferReader ();  			if (TryGetByte (out ch)) {  				if (ch == Keys.Comma || ch == Keys.RightClosingBrace)  					this.BufferReader.SkipByte ();  				else if (ch != Keys.RightClosingBracket)  					throw new Exception ("TokenExpected");  			}  			else {  				charactersToSkipOnNextRead [0] = Keys.Comma;  				charactersToSkipOnNextRead [1] = Keys.RightClosingBrace;  			}  			MoveToEndElement ();  		}  		break;  	default:  		if ((ch == (byte)'-') || (((byte)'0' <= ch) && (ch <= (byte)'9')) || (ch == (byte)'I') || (ch == (byte)'N'))  			ReadNumericalText ();  		else  			throw new XmlException ("JsonEncounteredUnexpectedCharacter");  		break;  	}  
Magic Number,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,Read,The following statement contains a magic number: if (IsReadingComplexText) {  	switch (complexTextMode) {  	case JsonComplexTextMode.QuotedText:  		if (ch == Keys.BackSlash) {  			ReadEscapedCharacter (true);  			break;  		}  		ReadQuotedText (true);  		break;  	case JsonComplexTextMode.NumericalText:  		ReadNumericalText ();  		break;  	case JsonComplexTextMode.None:  		throw new XmlException ("JsonEncounteredUnexpectedCharacter");  	}  }  else if (IsReadingCollection)  	ReadNonExistentElementName (StringHandleConstStringType.Item);  else  	switch (ch) {  	case Keys.RightClosingBracket:  		this.BufferReader.SkipByte ();  		MoveToEndElement ();  		ExitJsonScope ();  		break;  	case Keys.LeftOpeningBrace:  		this.BufferReader.SkipByte ();  		SkipWhitespaceInBufferReader ();  		ch = this.BufferReader.GetByte ();  		if (ch == Keys.RightClosingBrace) {  			// Skip this byte  			this.BufferReader.SkipByte ();  			// Skip white spaces  			SkipWhitespaceInBufferReader ();  			// try get next char  			if (TryGetByte (out ch)) {  				if (ch == Keys.Comma)  					this.BufferReader.SkipByte ();  			}  			else {  				// We are at end of buffer' just mark Comma to be skipped next time  				charactersToSkipOnNextRead [0] = Keys.Comma;  			}  			// We set to End Element  			MoveToEndElement ();  		}  		else {  			// Enter a new scope  			EnterJsonScope (JsonNodeType.Object);  			// Parse start element  			ParseStartElement ();  		}  		break;  	case Keys.RightClosingBrace:  		this.BufferReader.SkipByte ();  		if (expectingFirstElementInNonPrimitiveChild) {  			SkipWhitespaceInBufferReader ();  			ch = this.BufferReader.GetByte ();  			switch (ch) {  			case Keys.Comma:  			case Keys.RightClosingBrace:  				this.BufferReader.SkipByte ();  				break;  			default:  				throw new XmlException ("JsonEncounteredUnexpectedCharacter");  			}  			expectingFirstElementInNonPrimitiveChild = false;  		}  		MoveToEndElement ();  		break;  	case Keys.Comma:  		this.BufferReader.SkipByte ();  		MoveToEndElement ();  		break;  	case Keys.DoubleQuote:  		if (this.Node.NodeType == XmlNodeType.Element) {  			if (expectingFirstElementInNonPrimitiveChild) {  				EnterJsonScope (JsonNodeType.Object);  				ParseStartElement ();  			}  			else {  				this.BufferReader.SkipByte ();  				ReadQuotedText (true);  			}  		}  		else if (this.Node.NodeType == XmlNodeType.EndElement) {  			EnterJsonScope (JsonNodeType.Element);  			ParseStartElement ();  		}  		else  			throw new XmlException ("JsonEncounteredUnexpectedCharacter");  		break;  	case Keys.LowerF:  		{  			int offset;  			byte[] buffer = this.BufferReader.GetBuffer (5' out offset);  			// Check if it's "false"  			if (buffer [offset + 1] != Keys.LowerA || buffer [offset + 2] != Keys.LowerL || buffer [offset + 3] != Keys.LowerS || buffer [offset + 4] != Keys.LowerE)  				throw new Exception ("Expected False");  			// Advance of 5 byte  			this.BufferReader.Advance (5);  			// Check if char after is a closing one  			if (TryGetByte (out ch) && !IsWhitespace (ch) && (ch != Keys.Comma && ch != Keys.RightClosingBrace) && ch != Keys.RightClosingBracket)  				throw new Exception ("TokenExpected");  			// Move  			this.MoveToAtomicText ().Value.SetValue (ValueHandleType.UTF8' offset' 5);  		}  		break;  	case Keys.LowerT:  		{  			int offset;  			// check if it's "true"  			byte[] buffer = this.BufferReader.GetBuffer (4' out offset);  			if (buffer [offset + 1] != Keys.LowerR || buffer [offset + 2] != Keys.LowerU || buffer [offset + 3] != Keys.LowerE)  				throw new Exception ("expected true");  			this.BufferReader.Advance (4);  			// Check if char after is a closing one  			if (TryGetByte (out ch) && !IsWhitespace (ch) && (ch != Keys.Comma && ch != Keys.RightClosingBrace) && ch != Keys.RightClosingBracket)  				throw new Exception ("TokenExpected");  			// move atomic  			this.MoveToAtomicText ().Value.SetValue (ValueHandleType.UTF8' offset' 4);  		}  		break;  	case Keys.LowerN:  		{  			int offset;  			// check if it's "null"  			byte[] buffer = this.BufferReader.GetBuffer (4' out offset);  			if (buffer [offset + 1] != Keys.LowerU || buffer [offset + 2] != Keys.LowerL || buffer [offset + 3] != Keys.LowerL)  				throw new Exception ("Expected null");  			// advance of 4 chars  			this.BufferReader.Advance (4);  			SkipWhitespaceInBufferReader ();  			if (TryGetByte (out ch)) {  				if (ch == Keys.Comma || ch == Keys.RightClosingBrace)  					this.BufferReader.SkipByte ();  				else if (ch != Keys.RightClosingBracket)  					throw new Exception ("TokenExpected");  			}  			else {  				charactersToSkipOnNextRead [0] = Keys.Comma;  				charactersToSkipOnNextRead [1] = Keys.RightClosingBrace;  			}  			MoveToEndElement ();  		}  		break;  	default:  		if ((ch == (byte)'-') || (((byte)'0' <= ch) && (ch <= (byte)'9')) || (ch == (byte)'I') || (ch == (byte)'N'))  			ReadNumericalText ();  		else  			throw new XmlException ("JsonEncounteredUnexpectedCharacter");  		break;  	}  
Magic Number,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,Read,The following statement contains a magic number: if (IsReadingComplexText) {  	switch (complexTextMode) {  	case JsonComplexTextMode.QuotedText:  		if (ch == Keys.BackSlash) {  			ReadEscapedCharacter (true);  			break;  		}  		ReadQuotedText (true);  		break;  	case JsonComplexTextMode.NumericalText:  		ReadNumericalText ();  		break;  	case JsonComplexTextMode.None:  		throw new XmlException ("JsonEncounteredUnexpectedCharacter");  	}  }  else if (IsReadingCollection)  	ReadNonExistentElementName (StringHandleConstStringType.Item);  else  	switch (ch) {  	case Keys.RightClosingBracket:  		this.BufferReader.SkipByte ();  		MoveToEndElement ();  		ExitJsonScope ();  		break;  	case Keys.LeftOpeningBrace:  		this.BufferReader.SkipByte ();  		SkipWhitespaceInBufferReader ();  		ch = this.BufferReader.GetByte ();  		if (ch == Keys.RightClosingBrace) {  			// Skip this byte  			this.BufferReader.SkipByte ();  			// Skip white spaces  			SkipWhitespaceInBufferReader ();  			// try get next char  			if (TryGetByte (out ch)) {  				if (ch == Keys.Comma)  					this.BufferReader.SkipByte ();  			}  			else {  				// We are at end of buffer' just mark Comma to be skipped next time  				charactersToSkipOnNextRead [0] = Keys.Comma;  			}  			// We set to End Element  			MoveToEndElement ();  		}  		else {  			// Enter a new scope  			EnterJsonScope (JsonNodeType.Object);  			// Parse start element  			ParseStartElement ();  		}  		break;  	case Keys.RightClosingBrace:  		this.BufferReader.SkipByte ();  		if (expectingFirstElementInNonPrimitiveChild) {  			SkipWhitespaceInBufferReader ();  			ch = this.BufferReader.GetByte ();  			switch (ch) {  			case Keys.Comma:  			case Keys.RightClosingBrace:  				this.BufferReader.SkipByte ();  				break;  			default:  				throw new XmlException ("JsonEncounteredUnexpectedCharacter");  			}  			expectingFirstElementInNonPrimitiveChild = false;  		}  		MoveToEndElement ();  		break;  	case Keys.Comma:  		this.BufferReader.SkipByte ();  		MoveToEndElement ();  		break;  	case Keys.DoubleQuote:  		if (this.Node.NodeType == XmlNodeType.Element) {  			if (expectingFirstElementInNonPrimitiveChild) {  				EnterJsonScope (JsonNodeType.Object);  				ParseStartElement ();  			}  			else {  				this.BufferReader.SkipByte ();  				ReadQuotedText (true);  			}  		}  		else if (this.Node.NodeType == XmlNodeType.EndElement) {  			EnterJsonScope (JsonNodeType.Element);  			ParseStartElement ();  		}  		else  			throw new XmlException ("JsonEncounteredUnexpectedCharacter");  		break;  	case Keys.LowerF:  		{  			int offset;  			byte[] buffer = this.BufferReader.GetBuffer (5' out offset);  			// Check if it's "false"  			if (buffer [offset + 1] != Keys.LowerA || buffer [offset + 2] != Keys.LowerL || buffer [offset + 3] != Keys.LowerS || buffer [offset + 4] != Keys.LowerE)  				throw new Exception ("Expected False");  			// Advance of 5 byte  			this.BufferReader.Advance (5);  			// Check if char after is a closing one  			if (TryGetByte (out ch) && !IsWhitespace (ch) && (ch != Keys.Comma && ch != Keys.RightClosingBrace) && ch != Keys.RightClosingBracket)  				throw new Exception ("TokenExpected");  			// Move  			this.MoveToAtomicText ().Value.SetValue (ValueHandleType.UTF8' offset' 5);  		}  		break;  	case Keys.LowerT:  		{  			int offset;  			// check if it's "true"  			byte[] buffer = this.BufferReader.GetBuffer (4' out offset);  			if (buffer [offset + 1] != Keys.LowerR || buffer [offset + 2] != Keys.LowerU || buffer [offset + 3] != Keys.LowerE)  				throw new Exception ("expected true");  			this.BufferReader.Advance (4);  			// Check if char after is a closing one  			if (TryGetByte (out ch) && !IsWhitespace (ch) && (ch != Keys.Comma && ch != Keys.RightClosingBrace) && ch != Keys.RightClosingBracket)  				throw new Exception ("TokenExpected");  			// move atomic  			this.MoveToAtomicText ().Value.SetValue (ValueHandleType.UTF8' offset' 4);  		}  		break;  	case Keys.LowerN:  		{  			int offset;  			// check if it's "null"  			byte[] buffer = this.BufferReader.GetBuffer (4' out offset);  			if (buffer [offset + 1] != Keys.LowerU || buffer [offset + 2] != Keys.LowerL || buffer [offset + 3] != Keys.LowerL)  				throw new Exception ("Expected null");  			// advance of 4 chars  			this.BufferReader.Advance (4);  			SkipWhitespaceInBufferReader ();  			if (TryGetByte (out ch)) {  				if (ch == Keys.Comma || ch == Keys.RightClosingBrace)  					this.BufferReader.SkipByte ();  				else if (ch != Keys.RightClosingBracket)  					throw new Exception ("TokenExpected");  			}  			else {  				charactersToSkipOnNextRead [0] = Keys.Comma;  				charactersToSkipOnNextRead [1] = Keys.RightClosingBrace;  			}  			MoveToEndElement ();  		}  		break;  	default:  		if ((ch == (byte)'-') || (((byte)'0' <= ch) && (ch <= (byte)'9')) || (ch == (byte)'I') || (ch == (byte)'N'))  			ReadNumericalText ();  		else  			throw new XmlException ("JsonEncounteredUnexpectedCharacter");  		break;  	}  
Magic Number,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,Read,The following statement contains a magic number: if (IsReadingComplexText) {  	switch (complexTextMode) {  	case JsonComplexTextMode.QuotedText:  		if (ch == Keys.BackSlash) {  			ReadEscapedCharacter (true);  			break;  		}  		ReadQuotedText (true);  		break;  	case JsonComplexTextMode.NumericalText:  		ReadNumericalText ();  		break;  	case JsonComplexTextMode.None:  		throw new XmlException ("JsonEncounteredUnexpectedCharacter");  	}  }  else if (IsReadingCollection)  	ReadNonExistentElementName (StringHandleConstStringType.Item);  else  	switch (ch) {  	case Keys.RightClosingBracket:  		this.BufferReader.SkipByte ();  		MoveToEndElement ();  		ExitJsonScope ();  		break;  	case Keys.LeftOpeningBrace:  		this.BufferReader.SkipByte ();  		SkipWhitespaceInBufferReader ();  		ch = this.BufferReader.GetByte ();  		if (ch == Keys.RightClosingBrace) {  			// Skip this byte  			this.BufferReader.SkipByte ();  			// Skip white spaces  			SkipWhitespaceInBufferReader ();  			// try get next char  			if (TryGetByte (out ch)) {  				if (ch == Keys.Comma)  					this.BufferReader.SkipByte ();  			}  			else {  				// We are at end of buffer' just mark Comma to be skipped next time  				charactersToSkipOnNextRead [0] = Keys.Comma;  			}  			// We set to End Element  			MoveToEndElement ();  		}  		else {  			// Enter a new scope  			EnterJsonScope (JsonNodeType.Object);  			// Parse start element  			ParseStartElement ();  		}  		break;  	case Keys.RightClosingBrace:  		this.BufferReader.SkipByte ();  		if (expectingFirstElementInNonPrimitiveChild) {  			SkipWhitespaceInBufferReader ();  			ch = this.BufferReader.GetByte ();  			switch (ch) {  			case Keys.Comma:  			case Keys.RightClosingBrace:  				this.BufferReader.SkipByte ();  				break;  			default:  				throw new XmlException ("JsonEncounteredUnexpectedCharacter");  			}  			expectingFirstElementInNonPrimitiveChild = false;  		}  		MoveToEndElement ();  		break;  	case Keys.Comma:  		this.BufferReader.SkipByte ();  		MoveToEndElement ();  		break;  	case Keys.DoubleQuote:  		if (this.Node.NodeType == XmlNodeType.Element) {  			if (expectingFirstElementInNonPrimitiveChild) {  				EnterJsonScope (JsonNodeType.Object);  				ParseStartElement ();  			}  			else {  				this.BufferReader.SkipByte ();  				ReadQuotedText (true);  			}  		}  		else if (this.Node.NodeType == XmlNodeType.EndElement) {  			EnterJsonScope (JsonNodeType.Element);  			ParseStartElement ();  		}  		else  			throw new XmlException ("JsonEncounteredUnexpectedCharacter");  		break;  	case Keys.LowerF:  		{  			int offset;  			byte[] buffer = this.BufferReader.GetBuffer (5' out offset);  			// Check if it's "false"  			if (buffer [offset + 1] != Keys.LowerA || buffer [offset + 2] != Keys.LowerL || buffer [offset + 3] != Keys.LowerS || buffer [offset + 4] != Keys.LowerE)  				throw new Exception ("Expected False");  			// Advance of 5 byte  			this.BufferReader.Advance (5);  			// Check if char after is a closing one  			if (TryGetByte (out ch) && !IsWhitespace (ch) && (ch != Keys.Comma && ch != Keys.RightClosingBrace) && ch != Keys.RightClosingBracket)  				throw new Exception ("TokenExpected");  			// Move  			this.MoveToAtomicText ().Value.SetValue (ValueHandleType.UTF8' offset' 5);  		}  		break;  	case Keys.LowerT:  		{  			int offset;  			// check if it's "true"  			byte[] buffer = this.BufferReader.GetBuffer (4' out offset);  			if (buffer [offset + 1] != Keys.LowerR || buffer [offset + 2] != Keys.LowerU || buffer [offset + 3] != Keys.LowerE)  				throw new Exception ("expected true");  			this.BufferReader.Advance (4);  			// Check if char after is a closing one  			if (TryGetByte (out ch) && !IsWhitespace (ch) && (ch != Keys.Comma && ch != Keys.RightClosingBrace) && ch != Keys.RightClosingBracket)  				throw new Exception ("TokenExpected");  			// move atomic  			this.MoveToAtomicText ().Value.SetValue (ValueHandleType.UTF8' offset' 4);  		}  		break;  	case Keys.LowerN:  		{  			int offset;  			// check if it's "null"  			byte[] buffer = this.BufferReader.GetBuffer (4' out offset);  			if (buffer [offset + 1] != Keys.LowerU || buffer [offset + 2] != Keys.LowerL || buffer [offset + 3] != Keys.LowerL)  				throw new Exception ("Expected null");  			// advance of 4 chars  			this.BufferReader.Advance (4);  			SkipWhitespaceInBufferReader ();  			if (TryGetByte (out ch)) {  				if (ch == Keys.Comma || ch == Keys.RightClosingBrace)  					this.BufferReader.SkipByte ();  				else if (ch != Keys.RightClosingBracket)  					throw new Exception ("TokenExpected");  			}  			else {  				charactersToSkipOnNextRead [0] = Keys.Comma;  				charactersToSkipOnNextRead [1] = Keys.RightClosingBrace;  			}  			MoveToEndElement ();  		}  		break;  	default:  		if ((ch == (byte)'-') || (((byte)'0' <= ch) && (ch <= (byte)'9')) || (ch == (byte)'I') || (ch == (byte)'N'))  			ReadNumericalText ();  		else  			throw new XmlException ("JsonEncounteredUnexpectedCharacter");  		break;  	}  
Magic Number,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,Read,The following statement contains a magic number: if (IsReadingComplexText) {  	switch (complexTextMode) {  	case JsonComplexTextMode.QuotedText:  		if (ch == Keys.BackSlash) {  			ReadEscapedCharacter (true);  			break;  		}  		ReadQuotedText (true);  		break;  	case JsonComplexTextMode.NumericalText:  		ReadNumericalText ();  		break;  	case JsonComplexTextMode.None:  		throw new XmlException ("JsonEncounteredUnexpectedCharacter");  	}  }  else if (IsReadingCollection)  	ReadNonExistentElementName (StringHandleConstStringType.Item);  else  	switch (ch) {  	case Keys.RightClosingBracket:  		this.BufferReader.SkipByte ();  		MoveToEndElement ();  		ExitJsonScope ();  		break;  	case Keys.LeftOpeningBrace:  		this.BufferReader.SkipByte ();  		SkipWhitespaceInBufferReader ();  		ch = this.BufferReader.GetByte ();  		if (ch == Keys.RightClosingBrace) {  			// Skip this byte  			this.BufferReader.SkipByte ();  			// Skip white spaces  			SkipWhitespaceInBufferReader ();  			// try get next char  			if (TryGetByte (out ch)) {  				if (ch == Keys.Comma)  					this.BufferReader.SkipByte ();  			}  			else {  				// We are at end of buffer' just mark Comma to be skipped next time  				charactersToSkipOnNextRead [0] = Keys.Comma;  			}  			// We set to End Element  			MoveToEndElement ();  		}  		else {  			// Enter a new scope  			EnterJsonScope (JsonNodeType.Object);  			// Parse start element  			ParseStartElement ();  		}  		break;  	case Keys.RightClosingBrace:  		this.BufferReader.SkipByte ();  		if (expectingFirstElementInNonPrimitiveChild) {  			SkipWhitespaceInBufferReader ();  			ch = this.BufferReader.GetByte ();  			switch (ch) {  			case Keys.Comma:  			case Keys.RightClosingBrace:  				this.BufferReader.SkipByte ();  				break;  			default:  				throw new XmlException ("JsonEncounteredUnexpectedCharacter");  			}  			expectingFirstElementInNonPrimitiveChild = false;  		}  		MoveToEndElement ();  		break;  	case Keys.Comma:  		this.BufferReader.SkipByte ();  		MoveToEndElement ();  		break;  	case Keys.DoubleQuote:  		if (this.Node.NodeType == XmlNodeType.Element) {  			if (expectingFirstElementInNonPrimitiveChild) {  				EnterJsonScope (JsonNodeType.Object);  				ParseStartElement ();  			}  			else {  				this.BufferReader.SkipByte ();  				ReadQuotedText (true);  			}  		}  		else if (this.Node.NodeType == XmlNodeType.EndElement) {  			EnterJsonScope (JsonNodeType.Element);  			ParseStartElement ();  		}  		else  			throw new XmlException ("JsonEncounteredUnexpectedCharacter");  		break;  	case Keys.LowerF:  		{  			int offset;  			byte[] buffer = this.BufferReader.GetBuffer (5' out offset);  			// Check if it's "false"  			if (buffer [offset + 1] != Keys.LowerA || buffer [offset + 2] != Keys.LowerL || buffer [offset + 3] != Keys.LowerS || buffer [offset + 4] != Keys.LowerE)  				throw new Exception ("Expected False");  			// Advance of 5 byte  			this.BufferReader.Advance (5);  			// Check if char after is a closing one  			if (TryGetByte (out ch) && !IsWhitespace (ch) && (ch != Keys.Comma && ch != Keys.RightClosingBrace) && ch != Keys.RightClosingBracket)  				throw new Exception ("TokenExpected");  			// Move  			this.MoveToAtomicText ().Value.SetValue (ValueHandleType.UTF8' offset' 5);  		}  		break;  	case Keys.LowerT:  		{  			int offset;  			// check if it's "true"  			byte[] buffer = this.BufferReader.GetBuffer (4' out offset);  			if (buffer [offset + 1] != Keys.LowerR || buffer [offset + 2] != Keys.LowerU || buffer [offset + 3] != Keys.LowerE)  				throw new Exception ("expected true");  			this.BufferReader.Advance (4);  			// Check if char after is a closing one  			if (TryGetByte (out ch) && !IsWhitespace (ch) && (ch != Keys.Comma && ch != Keys.RightClosingBrace) && ch != Keys.RightClosingBracket)  				throw new Exception ("TokenExpected");  			// move atomic  			this.MoveToAtomicText ().Value.SetValue (ValueHandleType.UTF8' offset' 4);  		}  		break;  	case Keys.LowerN:  		{  			int offset;  			// check if it's "null"  			byte[] buffer = this.BufferReader.GetBuffer (4' out offset);  			if (buffer [offset + 1] != Keys.LowerU || buffer [offset + 2] != Keys.LowerL || buffer [offset + 3] != Keys.LowerL)  				throw new Exception ("Expected null");  			// advance of 4 chars  			this.BufferReader.Advance (4);  			SkipWhitespaceInBufferReader ();  			if (TryGetByte (out ch)) {  				if (ch == Keys.Comma || ch == Keys.RightClosingBrace)  					this.BufferReader.SkipByte ();  				else if (ch != Keys.RightClosingBracket)  					throw new Exception ("TokenExpected");  			}  			else {  				charactersToSkipOnNextRead [0] = Keys.Comma;  				charactersToSkipOnNextRead [1] = Keys.RightClosingBrace;  			}  			MoveToEndElement ();  		}  		break;  	default:  		if ((ch == (byte)'-') || (((byte)'0' <= ch) && (ch <= (byte)'9')) || (ch == (byte)'I') || (ch == (byte)'N'))  			ReadNumericalText ();  		else  			throw new XmlException ("JsonEncounteredUnexpectedCharacter");  		break;  	}  
Magic Number,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,Read,The following statement contains a magic number: if (IsReadingComplexText) {  	switch (complexTextMode) {  	case JsonComplexTextMode.QuotedText:  		if (ch == Keys.BackSlash) {  			ReadEscapedCharacter (true);  			break;  		}  		ReadQuotedText (true);  		break;  	case JsonComplexTextMode.NumericalText:  		ReadNumericalText ();  		break;  	case JsonComplexTextMode.None:  		throw new XmlException ("JsonEncounteredUnexpectedCharacter");  	}  }  else if (IsReadingCollection)  	ReadNonExistentElementName (StringHandleConstStringType.Item);  else  	switch (ch) {  	case Keys.RightClosingBracket:  		this.BufferReader.SkipByte ();  		MoveToEndElement ();  		ExitJsonScope ();  		break;  	case Keys.LeftOpeningBrace:  		this.BufferReader.SkipByte ();  		SkipWhitespaceInBufferReader ();  		ch = this.BufferReader.GetByte ();  		if (ch == Keys.RightClosingBrace) {  			// Skip this byte  			this.BufferReader.SkipByte ();  			// Skip white spaces  			SkipWhitespaceInBufferReader ();  			// try get next char  			if (TryGetByte (out ch)) {  				if (ch == Keys.Comma)  					this.BufferReader.SkipByte ();  			}  			else {  				// We are at end of buffer' just mark Comma to be skipped next time  				charactersToSkipOnNextRead [0] = Keys.Comma;  			}  			// We set to End Element  			MoveToEndElement ();  		}  		else {  			// Enter a new scope  			EnterJsonScope (JsonNodeType.Object);  			// Parse start element  			ParseStartElement ();  		}  		break;  	case Keys.RightClosingBrace:  		this.BufferReader.SkipByte ();  		if (expectingFirstElementInNonPrimitiveChild) {  			SkipWhitespaceInBufferReader ();  			ch = this.BufferReader.GetByte ();  			switch (ch) {  			case Keys.Comma:  			case Keys.RightClosingBrace:  				this.BufferReader.SkipByte ();  				break;  			default:  				throw new XmlException ("JsonEncounteredUnexpectedCharacter");  			}  			expectingFirstElementInNonPrimitiveChild = false;  		}  		MoveToEndElement ();  		break;  	case Keys.Comma:  		this.BufferReader.SkipByte ();  		MoveToEndElement ();  		break;  	case Keys.DoubleQuote:  		if (this.Node.NodeType == XmlNodeType.Element) {  			if (expectingFirstElementInNonPrimitiveChild) {  				EnterJsonScope (JsonNodeType.Object);  				ParseStartElement ();  			}  			else {  				this.BufferReader.SkipByte ();  				ReadQuotedText (true);  			}  		}  		else if (this.Node.NodeType == XmlNodeType.EndElement) {  			EnterJsonScope (JsonNodeType.Element);  			ParseStartElement ();  		}  		else  			throw new XmlException ("JsonEncounteredUnexpectedCharacter");  		break;  	case Keys.LowerF:  		{  			int offset;  			byte[] buffer = this.BufferReader.GetBuffer (5' out offset);  			// Check if it's "false"  			if (buffer [offset + 1] != Keys.LowerA || buffer [offset + 2] != Keys.LowerL || buffer [offset + 3] != Keys.LowerS || buffer [offset + 4] != Keys.LowerE)  				throw new Exception ("Expected False");  			// Advance of 5 byte  			this.BufferReader.Advance (5);  			// Check if char after is a closing one  			if (TryGetByte (out ch) && !IsWhitespace (ch) && (ch != Keys.Comma && ch != Keys.RightClosingBrace) && ch != Keys.RightClosingBracket)  				throw new Exception ("TokenExpected");  			// Move  			this.MoveToAtomicText ().Value.SetValue (ValueHandleType.UTF8' offset' 5);  		}  		break;  	case Keys.LowerT:  		{  			int offset;  			// check if it's "true"  			byte[] buffer = this.BufferReader.GetBuffer (4' out offset);  			if (buffer [offset + 1] != Keys.LowerR || buffer [offset + 2] != Keys.LowerU || buffer [offset + 3] != Keys.LowerE)  				throw new Exception ("expected true");  			this.BufferReader.Advance (4);  			// Check if char after is a closing one  			if (TryGetByte (out ch) && !IsWhitespace (ch) && (ch != Keys.Comma && ch != Keys.RightClosingBrace) && ch != Keys.RightClosingBracket)  				throw new Exception ("TokenExpected");  			// move atomic  			this.MoveToAtomicText ().Value.SetValue (ValueHandleType.UTF8' offset' 4);  		}  		break;  	case Keys.LowerN:  		{  			int offset;  			// check if it's "null"  			byte[] buffer = this.BufferReader.GetBuffer (4' out offset);  			if (buffer [offset + 1] != Keys.LowerU || buffer [offset + 2] != Keys.LowerL || buffer [offset + 3] != Keys.LowerL)  				throw new Exception ("Expected null");  			// advance of 4 chars  			this.BufferReader.Advance (4);  			SkipWhitespaceInBufferReader ();  			if (TryGetByte (out ch)) {  				if (ch == Keys.Comma || ch == Keys.RightClosingBrace)  					this.BufferReader.SkipByte ();  				else if (ch != Keys.RightClosingBracket)  					throw new Exception ("TokenExpected");  			}  			else {  				charactersToSkipOnNextRead [0] = Keys.Comma;  				charactersToSkipOnNextRead [1] = Keys.RightClosingBrace;  			}  			MoveToEndElement ();  		}  		break;  	default:  		if ((ch == (byte)'-') || (((byte)'0' <= ch) && (ch <= (byte)'9')) || (ch == (byte)'I') || (ch == (byte)'N'))  			ReadNumericalText ();  		else  			throw new XmlException ("JsonEncounteredUnexpectedCharacter");  		break;  	}  
Magic Number,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,Read,The following statement contains a magic number: if (IsReadingCollection)  	ReadNonExistentElementName (StringHandleConstStringType.Item);  else  	switch (ch) {  	case Keys.RightClosingBracket:  		this.BufferReader.SkipByte ();  		MoveToEndElement ();  		ExitJsonScope ();  		break;  	case Keys.LeftOpeningBrace:  		this.BufferReader.SkipByte ();  		SkipWhitespaceInBufferReader ();  		ch = this.BufferReader.GetByte ();  		if (ch == Keys.RightClosingBrace) {  			// Skip this byte  			this.BufferReader.SkipByte ();  			// Skip white spaces  			SkipWhitespaceInBufferReader ();  			// try get next char  			if (TryGetByte (out ch)) {  				if (ch == Keys.Comma)  					this.BufferReader.SkipByte ();  			}  			else {  				// We are at end of buffer' just mark Comma to be skipped next time  				charactersToSkipOnNextRead [0] = Keys.Comma;  			}  			// We set to End Element  			MoveToEndElement ();  		}  		else {  			// Enter a new scope  			EnterJsonScope (JsonNodeType.Object);  			// Parse start element  			ParseStartElement ();  		}  		break;  	case Keys.RightClosingBrace:  		this.BufferReader.SkipByte ();  		if (expectingFirstElementInNonPrimitiveChild) {  			SkipWhitespaceInBufferReader ();  			ch = this.BufferReader.GetByte ();  			switch (ch) {  			case Keys.Comma:  			case Keys.RightClosingBrace:  				this.BufferReader.SkipByte ();  				break;  			default:  				throw new XmlException ("JsonEncounteredUnexpectedCharacter");  			}  			expectingFirstElementInNonPrimitiveChild = false;  		}  		MoveToEndElement ();  		break;  	case Keys.Comma:  		this.BufferReader.SkipByte ();  		MoveToEndElement ();  		break;  	case Keys.DoubleQuote:  		if (this.Node.NodeType == XmlNodeType.Element) {  			if (expectingFirstElementInNonPrimitiveChild) {  				EnterJsonScope (JsonNodeType.Object);  				ParseStartElement ();  			}  			else {  				this.BufferReader.SkipByte ();  				ReadQuotedText (true);  			}  		}  		else if (this.Node.NodeType == XmlNodeType.EndElement) {  			EnterJsonScope (JsonNodeType.Element);  			ParseStartElement ();  		}  		else  			throw new XmlException ("JsonEncounteredUnexpectedCharacter");  		break;  	case Keys.LowerF:  		{  			int offset;  			byte[] buffer = this.BufferReader.GetBuffer (5' out offset);  			// Check if it's "false"  			if (buffer [offset + 1] != Keys.LowerA || buffer [offset + 2] != Keys.LowerL || buffer [offset + 3] != Keys.LowerS || buffer [offset + 4] != Keys.LowerE)  				throw new Exception ("Expected False");  			// Advance of 5 byte  			this.BufferReader.Advance (5);  			// Check if char after is a closing one  			if (TryGetByte (out ch) && !IsWhitespace (ch) && (ch != Keys.Comma && ch != Keys.RightClosingBrace) && ch != Keys.RightClosingBracket)  				throw new Exception ("TokenExpected");  			// Move  			this.MoveToAtomicText ().Value.SetValue (ValueHandleType.UTF8' offset' 5);  		}  		break;  	case Keys.LowerT:  		{  			int offset;  			// check if it's "true"  			byte[] buffer = this.BufferReader.GetBuffer (4' out offset);  			if (buffer [offset + 1] != Keys.LowerR || buffer [offset + 2] != Keys.LowerU || buffer [offset + 3] != Keys.LowerE)  				throw new Exception ("expected true");  			this.BufferReader.Advance (4);  			// Check if char after is a closing one  			if (TryGetByte (out ch) && !IsWhitespace (ch) && (ch != Keys.Comma && ch != Keys.RightClosingBrace) && ch != Keys.RightClosingBracket)  				throw new Exception ("TokenExpected");  			// move atomic  			this.MoveToAtomicText ().Value.SetValue (ValueHandleType.UTF8' offset' 4);  		}  		break;  	case Keys.LowerN:  		{  			int offset;  			// check if it's "null"  			byte[] buffer = this.BufferReader.GetBuffer (4' out offset);  			if (buffer [offset + 1] != Keys.LowerU || buffer [offset + 2] != Keys.LowerL || buffer [offset + 3] != Keys.LowerL)  				throw new Exception ("Expected null");  			// advance of 4 chars  			this.BufferReader.Advance (4);  			SkipWhitespaceInBufferReader ();  			if (TryGetByte (out ch)) {  				if (ch == Keys.Comma || ch == Keys.RightClosingBrace)  					this.BufferReader.SkipByte ();  				else if (ch != Keys.RightClosingBracket)  					throw new Exception ("TokenExpected");  			}  			else {  				charactersToSkipOnNextRead [0] = Keys.Comma;  				charactersToSkipOnNextRead [1] = Keys.RightClosingBrace;  			}  			MoveToEndElement ();  		}  		break;  	default:  		if ((ch == (byte)'-') || (((byte)'0' <= ch) && (ch <= (byte)'9')) || (ch == (byte)'I') || (ch == (byte)'N'))  			ReadNumericalText ();  		else  			throw new XmlException ("JsonEncounteredUnexpectedCharacter");  		break;  	}  
Magic Number,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,Read,The following statement contains a magic number: if (IsReadingCollection)  	ReadNonExistentElementName (StringHandleConstStringType.Item);  else  	switch (ch) {  	case Keys.RightClosingBracket:  		this.BufferReader.SkipByte ();  		MoveToEndElement ();  		ExitJsonScope ();  		break;  	case Keys.LeftOpeningBrace:  		this.BufferReader.SkipByte ();  		SkipWhitespaceInBufferReader ();  		ch = this.BufferReader.GetByte ();  		if (ch == Keys.RightClosingBrace) {  			// Skip this byte  			this.BufferReader.SkipByte ();  			// Skip white spaces  			SkipWhitespaceInBufferReader ();  			// try get next char  			if (TryGetByte (out ch)) {  				if (ch == Keys.Comma)  					this.BufferReader.SkipByte ();  			}  			else {  				// We are at end of buffer' just mark Comma to be skipped next time  				charactersToSkipOnNextRead [0] = Keys.Comma;  			}  			// We set to End Element  			MoveToEndElement ();  		}  		else {  			// Enter a new scope  			EnterJsonScope (JsonNodeType.Object);  			// Parse start element  			ParseStartElement ();  		}  		break;  	case Keys.RightClosingBrace:  		this.BufferReader.SkipByte ();  		if (expectingFirstElementInNonPrimitiveChild) {  			SkipWhitespaceInBufferReader ();  			ch = this.BufferReader.GetByte ();  			switch (ch) {  			case Keys.Comma:  			case Keys.RightClosingBrace:  				this.BufferReader.SkipByte ();  				break;  			default:  				throw new XmlException ("JsonEncounteredUnexpectedCharacter");  			}  			expectingFirstElementInNonPrimitiveChild = false;  		}  		MoveToEndElement ();  		break;  	case Keys.Comma:  		this.BufferReader.SkipByte ();  		MoveToEndElement ();  		break;  	case Keys.DoubleQuote:  		if (this.Node.NodeType == XmlNodeType.Element) {  			if (expectingFirstElementInNonPrimitiveChild) {  				EnterJsonScope (JsonNodeType.Object);  				ParseStartElement ();  			}  			else {  				this.BufferReader.SkipByte ();  				ReadQuotedText (true);  			}  		}  		else if (this.Node.NodeType == XmlNodeType.EndElement) {  			EnterJsonScope (JsonNodeType.Element);  			ParseStartElement ();  		}  		else  			throw new XmlException ("JsonEncounteredUnexpectedCharacter");  		break;  	case Keys.LowerF:  		{  			int offset;  			byte[] buffer = this.BufferReader.GetBuffer (5' out offset);  			// Check if it's "false"  			if (buffer [offset + 1] != Keys.LowerA || buffer [offset + 2] != Keys.LowerL || buffer [offset + 3] != Keys.LowerS || buffer [offset + 4] != Keys.LowerE)  				throw new Exception ("Expected False");  			// Advance of 5 byte  			this.BufferReader.Advance (5);  			// Check if char after is a closing one  			if (TryGetByte (out ch) && !IsWhitespace (ch) && (ch != Keys.Comma && ch != Keys.RightClosingBrace) && ch != Keys.RightClosingBracket)  				throw new Exception ("TokenExpected");  			// Move  			this.MoveToAtomicText ().Value.SetValue (ValueHandleType.UTF8' offset' 5);  		}  		break;  	case Keys.LowerT:  		{  			int offset;  			// check if it's "true"  			byte[] buffer = this.BufferReader.GetBuffer (4' out offset);  			if (buffer [offset + 1] != Keys.LowerR || buffer [offset + 2] != Keys.LowerU || buffer [offset + 3] != Keys.LowerE)  				throw new Exception ("expected true");  			this.BufferReader.Advance (4);  			// Check if char after is a closing one  			if (TryGetByte (out ch) && !IsWhitespace (ch) && (ch != Keys.Comma && ch != Keys.RightClosingBrace) && ch != Keys.RightClosingBracket)  				throw new Exception ("TokenExpected");  			// move atomic  			this.MoveToAtomicText ().Value.SetValue (ValueHandleType.UTF8' offset' 4);  		}  		break;  	case Keys.LowerN:  		{  			int offset;  			// check if it's "null"  			byte[] buffer = this.BufferReader.GetBuffer (4' out offset);  			if (buffer [offset + 1] != Keys.LowerU || buffer [offset + 2] != Keys.LowerL || buffer [offset + 3] != Keys.LowerL)  				throw new Exception ("Expected null");  			// advance of 4 chars  			this.BufferReader.Advance (4);  			SkipWhitespaceInBufferReader ();  			if (TryGetByte (out ch)) {  				if (ch == Keys.Comma || ch == Keys.RightClosingBrace)  					this.BufferReader.SkipByte ();  				else if (ch != Keys.RightClosingBracket)  					throw new Exception ("TokenExpected");  			}  			else {  				charactersToSkipOnNextRead [0] = Keys.Comma;  				charactersToSkipOnNextRead [1] = Keys.RightClosingBrace;  			}  			MoveToEndElement ();  		}  		break;  	default:  		if ((ch == (byte)'-') || (((byte)'0' <= ch) && (ch <= (byte)'9')) || (ch == (byte)'I') || (ch == (byte)'N'))  			ReadNumericalText ();  		else  			throw new XmlException ("JsonEncounteredUnexpectedCharacter");  		break;  	}  
Magic Number,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,Read,The following statement contains a magic number: if (IsReadingCollection)  	ReadNonExistentElementName (StringHandleConstStringType.Item);  else  	switch (ch) {  	case Keys.RightClosingBracket:  		this.BufferReader.SkipByte ();  		MoveToEndElement ();  		ExitJsonScope ();  		break;  	case Keys.LeftOpeningBrace:  		this.BufferReader.SkipByte ();  		SkipWhitespaceInBufferReader ();  		ch = this.BufferReader.GetByte ();  		if (ch == Keys.RightClosingBrace) {  			// Skip this byte  			this.BufferReader.SkipByte ();  			// Skip white spaces  			SkipWhitespaceInBufferReader ();  			// try get next char  			if (TryGetByte (out ch)) {  				if (ch == Keys.Comma)  					this.BufferReader.SkipByte ();  			}  			else {  				// We are at end of buffer' just mark Comma to be skipped next time  				charactersToSkipOnNextRead [0] = Keys.Comma;  			}  			// We set to End Element  			MoveToEndElement ();  		}  		else {  			// Enter a new scope  			EnterJsonScope (JsonNodeType.Object);  			// Parse start element  			ParseStartElement ();  		}  		break;  	case Keys.RightClosingBrace:  		this.BufferReader.SkipByte ();  		if (expectingFirstElementInNonPrimitiveChild) {  			SkipWhitespaceInBufferReader ();  			ch = this.BufferReader.GetByte ();  			switch (ch) {  			case Keys.Comma:  			case Keys.RightClosingBrace:  				this.BufferReader.SkipByte ();  				break;  			default:  				throw new XmlException ("JsonEncounteredUnexpectedCharacter");  			}  			expectingFirstElementInNonPrimitiveChild = false;  		}  		MoveToEndElement ();  		break;  	case Keys.Comma:  		this.BufferReader.SkipByte ();  		MoveToEndElement ();  		break;  	case Keys.DoubleQuote:  		if (this.Node.NodeType == XmlNodeType.Element) {  			if (expectingFirstElementInNonPrimitiveChild) {  				EnterJsonScope (JsonNodeType.Object);  				ParseStartElement ();  			}  			else {  				this.BufferReader.SkipByte ();  				ReadQuotedText (true);  			}  		}  		else if (this.Node.NodeType == XmlNodeType.EndElement) {  			EnterJsonScope (JsonNodeType.Element);  			ParseStartElement ();  		}  		else  			throw new XmlException ("JsonEncounteredUnexpectedCharacter");  		break;  	case Keys.LowerF:  		{  			int offset;  			byte[] buffer = this.BufferReader.GetBuffer (5' out offset);  			// Check if it's "false"  			if (buffer [offset + 1] != Keys.LowerA || buffer [offset + 2] != Keys.LowerL || buffer [offset + 3] != Keys.LowerS || buffer [offset + 4] != Keys.LowerE)  				throw new Exception ("Expected False");  			// Advance of 5 byte  			this.BufferReader.Advance (5);  			// Check if char after is a closing one  			if (TryGetByte (out ch) && !IsWhitespace (ch) && (ch != Keys.Comma && ch != Keys.RightClosingBrace) && ch != Keys.RightClosingBracket)  				throw new Exception ("TokenExpected");  			// Move  			this.MoveToAtomicText ().Value.SetValue (ValueHandleType.UTF8' offset' 5);  		}  		break;  	case Keys.LowerT:  		{  			int offset;  			// check if it's "true"  			byte[] buffer = this.BufferReader.GetBuffer (4' out offset);  			if (buffer [offset + 1] != Keys.LowerR || buffer [offset + 2] != Keys.LowerU || buffer [offset + 3] != Keys.LowerE)  				throw new Exception ("expected true");  			this.BufferReader.Advance (4);  			// Check if char after is a closing one  			if (TryGetByte (out ch) && !IsWhitespace (ch) && (ch != Keys.Comma && ch != Keys.RightClosingBrace) && ch != Keys.RightClosingBracket)  				throw new Exception ("TokenExpected");  			// move atomic  			this.MoveToAtomicText ().Value.SetValue (ValueHandleType.UTF8' offset' 4);  		}  		break;  	case Keys.LowerN:  		{  			int offset;  			// check if it's "null"  			byte[] buffer = this.BufferReader.GetBuffer (4' out offset);  			if (buffer [offset + 1] != Keys.LowerU || buffer [offset + 2] != Keys.LowerL || buffer [offset + 3] != Keys.LowerL)  				throw new Exception ("Expected null");  			// advance of 4 chars  			this.BufferReader.Advance (4);  			SkipWhitespaceInBufferReader ();  			if (TryGetByte (out ch)) {  				if (ch == Keys.Comma || ch == Keys.RightClosingBrace)  					this.BufferReader.SkipByte ();  				else if (ch != Keys.RightClosingBracket)  					throw new Exception ("TokenExpected");  			}  			else {  				charactersToSkipOnNextRead [0] = Keys.Comma;  				charactersToSkipOnNextRead [1] = Keys.RightClosingBrace;  			}  			MoveToEndElement ();  		}  		break;  	default:  		if ((ch == (byte)'-') || (((byte)'0' <= ch) && (ch <= (byte)'9')) || (ch == (byte)'I') || (ch == (byte)'N'))  			ReadNumericalText ();  		else  			throw new XmlException ("JsonEncounteredUnexpectedCharacter");  		break;  	}  
Magic Number,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,Read,The following statement contains a magic number: if (IsReadingCollection)  	ReadNonExistentElementName (StringHandleConstStringType.Item);  else  	switch (ch) {  	case Keys.RightClosingBracket:  		this.BufferReader.SkipByte ();  		MoveToEndElement ();  		ExitJsonScope ();  		break;  	case Keys.LeftOpeningBrace:  		this.BufferReader.SkipByte ();  		SkipWhitespaceInBufferReader ();  		ch = this.BufferReader.GetByte ();  		if (ch == Keys.RightClosingBrace) {  			// Skip this byte  			this.BufferReader.SkipByte ();  			// Skip white spaces  			SkipWhitespaceInBufferReader ();  			// try get next char  			if (TryGetByte (out ch)) {  				if (ch == Keys.Comma)  					this.BufferReader.SkipByte ();  			}  			else {  				// We are at end of buffer' just mark Comma to be skipped next time  				charactersToSkipOnNextRead [0] = Keys.Comma;  			}  			// We set to End Element  			MoveToEndElement ();  		}  		else {  			// Enter a new scope  			EnterJsonScope (JsonNodeType.Object);  			// Parse start element  			ParseStartElement ();  		}  		break;  	case Keys.RightClosingBrace:  		this.BufferReader.SkipByte ();  		if (expectingFirstElementInNonPrimitiveChild) {  			SkipWhitespaceInBufferReader ();  			ch = this.BufferReader.GetByte ();  			switch (ch) {  			case Keys.Comma:  			case Keys.RightClosingBrace:  				this.BufferReader.SkipByte ();  				break;  			default:  				throw new XmlException ("JsonEncounteredUnexpectedCharacter");  			}  			expectingFirstElementInNonPrimitiveChild = false;  		}  		MoveToEndElement ();  		break;  	case Keys.Comma:  		this.BufferReader.SkipByte ();  		MoveToEndElement ();  		break;  	case Keys.DoubleQuote:  		if (this.Node.NodeType == XmlNodeType.Element) {  			if (expectingFirstElementInNonPrimitiveChild) {  				EnterJsonScope (JsonNodeType.Object);  				ParseStartElement ();  			}  			else {  				this.BufferReader.SkipByte ();  				ReadQuotedText (true);  			}  		}  		else if (this.Node.NodeType == XmlNodeType.EndElement) {  			EnterJsonScope (JsonNodeType.Element);  			ParseStartElement ();  		}  		else  			throw new XmlException ("JsonEncounteredUnexpectedCharacter");  		break;  	case Keys.LowerF:  		{  			int offset;  			byte[] buffer = this.BufferReader.GetBuffer (5' out offset);  			// Check if it's "false"  			if (buffer [offset + 1] != Keys.LowerA || buffer [offset + 2] != Keys.LowerL || buffer [offset + 3] != Keys.LowerS || buffer [offset + 4] != Keys.LowerE)  				throw new Exception ("Expected False");  			// Advance of 5 byte  			this.BufferReader.Advance (5);  			// Check if char after is a closing one  			if (TryGetByte (out ch) && !IsWhitespace (ch) && (ch != Keys.Comma && ch != Keys.RightClosingBrace) && ch != Keys.RightClosingBracket)  				throw new Exception ("TokenExpected");  			// Move  			this.MoveToAtomicText ().Value.SetValue (ValueHandleType.UTF8' offset' 5);  		}  		break;  	case Keys.LowerT:  		{  			int offset;  			// check if it's "true"  			byte[] buffer = this.BufferReader.GetBuffer (4' out offset);  			if (buffer [offset + 1] != Keys.LowerR || buffer [offset + 2] != Keys.LowerU || buffer [offset + 3] != Keys.LowerE)  				throw new Exception ("expected true");  			this.BufferReader.Advance (4);  			// Check if char after is a closing one  			if (TryGetByte (out ch) && !IsWhitespace (ch) && (ch != Keys.Comma && ch != Keys.RightClosingBrace) && ch != Keys.RightClosingBracket)  				throw new Exception ("TokenExpected");  			// move atomic  			this.MoveToAtomicText ().Value.SetValue (ValueHandleType.UTF8' offset' 4);  		}  		break;  	case Keys.LowerN:  		{  			int offset;  			// check if it's "null"  			byte[] buffer = this.BufferReader.GetBuffer (4' out offset);  			if (buffer [offset + 1] != Keys.LowerU || buffer [offset + 2] != Keys.LowerL || buffer [offset + 3] != Keys.LowerL)  				throw new Exception ("Expected null");  			// advance of 4 chars  			this.BufferReader.Advance (4);  			SkipWhitespaceInBufferReader ();  			if (TryGetByte (out ch)) {  				if (ch == Keys.Comma || ch == Keys.RightClosingBrace)  					this.BufferReader.SkipByte ();  				else if (ch != Keys.RightClosingBracket)  					throw new Exception ("TokenExpected");  			}  			else {  				charactersToSkipOnNextRead [0] = Keys.Comma;  				charactersToSkipOnNextRead [1] = Keys.RightClosingBrace;  			}  			MoveToEndElement ();  		}  		break;  	default:  		if ((ch == (byte)'-') || (((byte)'0' <= ch) && (ch <= (byte)'9')) || (ch == (byte)'I') || (ch == (byte)'N'))  			ReadNumericalText ();  		else  			throw new XmlException ("JsonEncounteredUnexpectedCharacter");  		break;  	}  
Magic Number,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,Read,The following statement contains a magic number: if (IsReadingCollection)  	ReadNonExistentElementName (StringHandleConstStringType.Item);  else  	switch (ch) {  	case Keys.RightClosingBracket:  		this.BufferReader.SkipByte ();  		MoveToEndElement ();  		ExitJsonScope ();  		break;  	case Keys.LeftOpeningBrace:  		this.BufferReader.SkipByte ();  		SkipWhitespaceInBufferReader ();  		ch = this.BufferReader.GetByte ();  		if (ch == Keys.RightClosingBrace) {  			// Skip this byte  			this.BufferReader.SkipByte ();  			// Skip white spaces  			SkipWhitespaceInBufferReader ();  			// try get next char  			if (TryGetByte (out ch)) {  				if (ch == Keys.Comma)  					this.BufferReader.SkipByte ();  			}  			else {  				// We are at end of buffer' just mark Comma to be skipped next time  				charactersToSkipOnNextRead [0] = Keys.Comma;  			}  			// We set to End Element  			MoveToEndElement ();  		}  		else {  			// Enter a new scope  			EnterJsonScope (JsonNodeType.Object);  			// Parse start element  			ParseStartElement ();  		}  		break;  	case Keys.RightClosingBrace:  		this.BufferReader.SkipByte ();  		if (expectingFirstElementInNonPrimitiveChild) {  			SkipWhitespaceInBufferReader ();  			ch = this.BufferReader.GetByte ();  			switch (ch) {  			case Keys.Comma:  			case Keys.RightClosingBrace:  				this.BufferReader.SkipByte ();  				break;  			default:  				throw new XmlException ("JsonEncounteredUnexpectedCharacter");  			}  			expectingFirstElementInNonPrimitiveChild = false;  		}  		MoveToEndElement ();  		break;  	case Keys.Comma:  		this.BufferReader.SkipByte ();  		MoveToEndElement ();  		break;  	case Keys.DoubleQuote:  		if (this.Node.NodeType == XmlNodeType.Element) {  			if (expectingFirstElementInNonPrimitiveChild) {  				EnterJsonScope (JsonNodeType.Object);  				ParseStartElement ();  			}  			else {  				this.BufferReader.SkipByte ();  				ReadQuotedText (true);  			}  		}  		else if (this.Node.NodeType == XmlNodeType.EndElement) {  			EnterJsonScope (JsonNodeType.Element);  			ParseStartElement ();  		}  		else  			throw new XmlException ("JsonEncounteredUnexpectedCharacter");  		break;  	case Keys.LowerF:  		{  			int offset;  			byte[] buffer = this.BufferReader.GetBuffer (5' out offset);  			// Check if it's "false"  			if (buffer [offset + 1] != Keys.LowerA || buffer [offset + 2] != Keys.LowerL || buffer [offset + 3] != Keys.LowerS || buffer [offset + 4] != Keys.LowerE)  				throw new Exception ("Expected False");  			// Advance of 5 byte  			this.BufferReader.Advance (5);  			// Check if char after is a closing one  			if (TryGetByte (out ch) && !IsWhitespace (ch) && (ch != Keys.Comma && ch != Keys.RightClosingBrace) && ch != Keys.RightClosingBracket)  				throw new Exception ("TokenExpected");  			// Move  			this.MoveToAtomicText ().Value.SetValue (ValueHandleType.UTF8' offset' 5);  		}  		break;  	case Keys.LowerT:  		{  			int offset;  			// check if it's "true"  			byte[] buffer = this.BufferReader.GetBuffer (4' out offset);  			if (buffer [offset + 1] != Keys.LowerR || buffer [offset + 2] != Keys.LowerU || buffer [offset + 3] != Keys.LowerE)  				throw new Exception ("expected true");  			this.BufferReader.Advance (4);  			// Check if char after is a closing one  			if (TryGetByte (out ch) && !IsWhitespace (ch) && (ch != Keys.Comma && ch != Keys.RightClosingBrace) && ch != Keys.RightClosingBracket)  				throw new Exception ("TokenExpected");  			// move atomic  			this.MoveToAtomicText ().Value.SetValue (ValueHandleType.UTF8' offset' 4);  		}  		break;  	case Keys.LowerN:  		{  			int offset;  			// check if it's "null"  			byte[] buffer = this.BufferReader.GetBuffer (4' out offset);  			if (buffer [offset + 1] != Keys.LowerU || buffer [offset + 2] != Keys.LowerL || buffer [offset + 3] != Keys.LowerL)  				throw new Exception ("Expected null");  			// advance of 4 chars  			this.BufferReader.Advance (4);  			SkipWhitespaceInBufferReader ();  			if (TryGetByte (out ch)) {  				if (ch == Keys.Comma || ch == Keys.RightClosingBrace)  					this.BufferReader.SkipByte ();  				else if (ch != Keys.RightClosingBracket)  					throw new Exception ("TokenExpected");  			}  			else {  				charactersToSkipOnNextRead [0] = Keys.Comma;  				charactersToSkipOnNextRead [1] = Keys.RightClosingBrace;  			}  			MoveToEndElement ();  		}  		break;  	default:  		if ((ch == (byte)'-') || (((byte)'0' <= ch) && (ch <= (byte)'9')) || (ch == (byte)'I') || (ch == (byte)'N'))  			ReadNumericalText ();  		else  			throw new XmlException ("JsonEncounteredUnexpectedCharacter");  		break;  	}  
Magic Number,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,Read,The following statement contains a magic number: if (IsReadingCollection)  	ReadNonExistentElementName (StringHandleConstStringType.Item);  else  	switch (ch) {  	case Keys.RightClosingBracket:  		this.BufferReader.SkipByte ();  		MoveToEndElement ();  		ExitJsonScope ();  		break;  	case Keys.LeftOpeningBrace:  		this.BufferReader.SkipByte ();  		SkipWhitespaceInBufferReader ();  		ch = this.BufferReader.GetByte ();  		if (ch == Keys.RightClosingBrace) {  			// Skip this byte  			this.BufferReader.SkipByte ();  			// Skip white spaces  			SkipWhitespaceInBufferReader ();  			// try get next char  			if (TryGetByte (out ch)) {  				if (ch == Keys.Comma)  					this.BufferReader.SkipByte ();  			}  			else {  				// We are at end of buffer' just mark Comma to be skipped next time  				charactersToSkipOnNextRead [0] = Keys.Comma;  			}  			// We set to End Element  			MoveToEndElement ();  		}  		else {  			// Enter a new scope  			EnterJsonScope (JsonNodeType.Object);  			// Parse start element  			ParseStartElement ();  		}  		break;  	case Keys.RightClosingBrace:  		this.BufferReader.SkipByte ();  		if (expectingFirstElementInNonPrimitiveChild) {  			SkipWhitespaceInBufferReader ();  			ch = this.BufferReader.GetByte ();  			switch (ch) {  			case Keys.Comma:  			case Keys.RightClosingBrace:  				this.BufferReader.SkipByte ();  				break;  			default:  				throw new XmlException ("JsonEncounteredUnexpectedCharacter");  			}  			expectingFirstElementInNonPrimitiveChild = false;  		}  		MoveToEndElement ();  		break;  	case Keys.Comma:  		this.BufferReader.SkipByte ();  		MoveToEndElement ();  		break;  	case Keys.DoubleQuote:  		if (this.Node.NodeType == XmlNodeType.Element) {  			if (expectingFirstElementInNonPrimitiveChild) {  				EnterJsonScope (JsonNodeType.Object);  				ParseStartElement ();  			}  			else {  				this.BufferReader.SkipByte ();  				ReadQuotedText (true);  			}  		}  		else if (this.Node.NodeType == XmlNodeType.EndElement) {  			EnterJsonScope (JsonNodeType.Element);  			ParseStartElement ();  		}  		else  			throw new XmlException ("JsonEncounteredUnexpectedCharacter");  		break;  	case Keys.LowerF:  		{  			int offset;  			byte[] buffer = this.BufferReader.GetBuffer (5' out offset);  			// Check if it's "false"  			if (buffer [offset + 1] != Keys.LowerA || buffer [offset + 2] != Keys.LowerL || buffer [offset + 3] != Keys.LowerS || buffer [offset + 4] != Keys.LowerE)  				throw new Exception ("Expected False");  			// Advance of 5 byte  			this.BufferReader.Advance (5);  			// Check if char after is a closing one  			if (TryGetByte (out ch) && !IsWhitespace (ch) && (ch != Keys.Comma && ch != Keys.RightClosingBrace) && ch != Keys.RightClosingBracket)  				throw new Exception ("TokenExpected");  			// Move  			this.MoveToAtomicText ().Value.SetValue (ValueHandleType.UTF8' offset' 5);  		}  		break;  	case Keys.LowerT:  		{  			int offset;  			// check if it's "true"  			byte[] buffer = this.BufferReader.GetBuffer (4' out offset);  			if (buffer [offset + 1] != Keys.LowerR || buffer [offset + 2] != Keys.LowerU || buffer [offset + 3] != Keys.LowerE)  				throw new Exception ("expected true");  			this.BufferReader.Advance (4);  			// Check if char after is a closing one  			if (TryGetByte (out ch) && !IsWhitespace (ch) && (ch != Keys.Comma && ch != Keys.RightClosingBrace) && ch != Keys.RightClosingBracket)  				throw new Exception ("TokenExpected");  			// move atomic  			this.MoveToAtomicText ().Value.SetValue (ValueHandleType.UTF8' offset' 4);  		}  		break;  	case Keys.LowerN:  		{  			int offset;  			// check if it's "null"  			byte[] buffer = this.BufferReader.GetBuffer (4' out offset);  			if (buffer [offset + 1] != Keys.LowerU || buffer [offset + 2] != Keys.LowerL || buffer [offset + 3] != Keys.LowerL)  				throw new Exception ("Expected null");  			// advance of 4 chars  			this.BufferReader.Advance (4);  			SkipWhitespaceInBufferReader ();  			if (TryGetByte (out ch)) {  				if (ch == Keys.Comma || ch == Keys.RightClosingBrace)  					this.BufferReader.SkipByte ();  				else if (ch != Keys.RightClosingBracket)  					throw new Exception ("TokenExpected");  			}  			else {  				charactersToSkipOnNextRead [0] = Keys.Comma;  				charactersToSkipOnNextRead [1] = Keys.RightClosingBrace;  			}  			MoveToEndElement ();  		}  		break;  	default:  		if ((ch == (byte)'-') || (((byte)'0' <= ch) && (ch <= (byte)'9')) || (ch == (byte)'I') || (ch == (byte)'N'))  			ReadNumericalText ();  		else  			throw new XmlException ("JsonEncounteredUnexpectedCharacter");  		break;  	}  
Magic Number,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,Read,The following statement contains a magic number: if (IsReadingCollection)  	ReadNonExistentElementName (StringHandleConstStringType.Item);  else  	switch (ch) {  	case Keys.RightClosingBracket:  		this.BufferReader.SkipByte ();  		MoveToEndElement ();  		ExitJsonScope ();  		break;  	case Keys.LeftOpeningBrace:  		this.BufferReader.SkipByte ();  		SkipWhitespaceInBufferReader ();  		ch = this.BufferReader.GetByte ();  		if (ch == Keys.RightClosingBrace) {  			// Skip this byte  			this.BufferReader.SkipByte ();  			// Skip white spaces  			SkipWhitespaceInBufferReader ();  			// try get next char  			if (TryGetByte (out ch)) {  				if (ch == Keys.Comma)  					this.BufferReader.SkipByte ();  			}  			else {  				// We are at end of buffer' just mark Comma to be skipped next time  				charactersToSkipOnNextRead [0] = Keys.Comma;  			}  			// We set to End Element  			MoveToEndElement ();  		}  		else {  			// Enter a new scope  			EnterJsonScope (JsonNodeType.Object);  			// Parse start element  			ParseStartElement ();  		}  		break;  	case Keys.RightClosingBrace:  		this.BufferReader.SkipByte ();  		if (expectingFirstElementInNonPrimitiveChild) {  			SkipWhitespaceInBufferReader ();  			ch = this.BufferReader.GetByte ();  			switch (ch) {  			case Keys.Comma:  			case Keys.RightClosingBrace:  				this.BufferReader.SkipByte ();  				break;  			default:  				throw new XmlException ("JsonEncounteredUnexpectedCharacter");  			}  			expectingFirstElementInNonPrimitiveChild = false;  		}  		MoveToEndElement ();  		break;  	case Keys.Comma:  		this.BufferReader.SkipByte ();  		MoveToEndElement ();  		break;  	case Keys.DoubleQuote:  		if (this.Node.NodeType == XmlNodeType.Element) {  			if (expectingFirstElementInNonPrimitiveChild) {  				EnterJsonScope (JsonNodeType.Object);  				ParseStartElement ();  			}  			else {  				this.BufferReader.SkipByte ();  				ReadQuotedText (true);  			}  		}  		else if (this.Node.NodeType == XmlNodeType.EndElement) {  			EnterJsonScope (JsonNodeType.Element);  			ParseStartElement ();  		}  		else  			throw new XmlException ("JsonEncounteredUnexpectedCharacter");  		break;  	case Keys.LowerF:  		{  			int offset;  			byte[] buffer = this.BufferReader.GetBuffer (5' out offset);  			// Check if it's "false"  			if (buffer [offset + 1] != Keys.LowerA || buffer [offset + 2] != Keys.LowerL || buffer [offset + 3] != Keys.LowerS || buffer [offset + 4] != Keys.LowerE)  				throw new Exception ("Expected False");  			// Advance of 5 byte  			this.BufferReader.Advance (5);  			// Check if char after is a closing one  			if (TryGetByte (out ch) && !IsWhitespace (ch) && (ch != Keys.Comma && ch != Keys.RightClosingBrace) && ch != Keys.RightClosingBracket)  				throw new Exception ("TokenExpected");  			// Move  			this.MoveToAtomicText ().Value.SetValue (ValueHandleType.UTF8' offset' 5);  		}  		break;  	case Keys.LowerT:  		{  			int offset;  			// check if it's "true"  			byte[] buffer = this.BufferReader.GetBuffer (4' out offset);  			if (buffer [offset + 1] != Keys.LowerR || buffer [offset + 2] != Keys.LowerU || buffer [offset + 3] != Keys.LowerE)  				throw new Exception ("expected true");  			this.BufferReader.Advance (4);  			// Check if char after is a closing one  			if (TryGetByte (out ch) && !IsWhitespace (ch) && (ch != Keys.Comma && ch != Keys.RightClosingBrace) && ch != Keys.RightClosingBracket)  				throw new Exception ("TokenExpected");  			// move atomic  			this.MoveToAtomicText ().Value.SetValue (ValueHandleType.UTF8' offset' 4);  		}  		break;  	case Keys.LowerN:  		{  			int offset;  			// check if it's "null"  			byte[] buffer = this.BufferReader.GetBuffer (4' out offset);  			if (buffer [offset + 1] != Keys.LowerU || buffer [offset + 2] != Keys.LowerL || buffer [offset + 3] != Keys.LowerL)  				throw new Exception ("Expected null");  			// advance of 4 chars  			this.BufferReader.Advance (4);  			SkipWhitespaceInBufferReader ();  			if (TryGetByte (out ch)) {  				if (ch == Keys.Comma || ch == Keys.RightClosingBrace)  					this.BufferReader.SkipByte ();  				else if (ch != Keys.RightClosingBracket)  					throw new Exception ("TokenExpected");  			}  			else {  				charactersToSkipOnNextRead [0] = Keys.Comma;  				charactersToSkipOnNextRead [1] = Keys.RightClosingBrace;  			}  			MoveToEndElement ();  		}  		break;  	default:  		if ((ch == (byte)'-') || (((byte)'0' <= ch) && (ch <= (byte)'9')) || (ch == (byte)'I') || (ch == (byte)'N'))  			ReadNumericalText ();  		else  			throw new XmlException ("JsonEncounteredUnexpectedCharacter");  		break;  	}  
Magic Number,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,Read,The following statement contains a magic number: if (IsReadingCollection)  	ReadNonExistentElementName (StringHandleConstStringType.Item);  else  	switch (ch) {  	case Keys.RightClosingBracket:  		this.BufferReader.SkipByte ();  		MoveToEndElement ();  		ExitJsonScope ();  		break;  	case Keys.LeftOpeningBrace:  		this.BufferReader.SkipByte ();  		SkipWhitespaceInBufferReader ();  		ch = this.BufferReader.GetByte ();  		if (ch == Keys.RightClosingBrace) {  			// Skip this byte  			this.BufferReader.SkipByte ();  			// Skip white spaces  			SkipWhitespaceInBufferReader ();  			// try get next char  			if (TryGetByte (out ch)) {  				if (ch == Keys.Comma)  					this.BufferReader.SkipByte ();  			}  			else {  				// We are at end of buffer' just mark Comma to be skipped next time  				charactersToSkipOnNextRead [0] = Keys.Comma;  			}  			// We set to End Element  			MoveToEndElement ();  		}  		else {  			// Enter a new scope  			EnterJsonScope (JsonNodeType.Object);  			// Parse start element  			ParseStartElement ();  		}  		break;  	case Keys.RightClosingBrace:  		this.BufferReader.SkipByte ();  		if (expectingFirstElementInNonPrimitiveChild) {  			SkipWhitespaceInBufferReader ();  			ch = this.BufferReader.GetByte ();  			switch (ch) {  			case Keys.Comma:  			case Keys.RightClosingBrace:  				this.BufferReader.SkipByte ();  				break;  			default:  				throw new XmlException ("JsonEncounteredUnexpectedCharacter");  			}  			expectingFirstElementInNonPrimitiveChild = false;  		}  		MoveToEndElement ();  		break;  	case Keys.Comma:  		this.BufferReader.SkipByte ();  		MoveToEndElement ();  		break;  	case Keys.DoubleQuote:  		if (this.Node.NodeType == XmlNodeType.Element) {  			if (expectingFirstElementInNonPrimitiveChild) {  				EnterJsonScope (JsonNodeType.Object);  				ParseStartElement ();  			}  			else {  				this.BufferReader.SkipByte ();  				ReadQuotedText (true);  			}  		}  		else if (this.Node.NodeType == XmlNodeType.EndElement) {  			EnterJsonScope (JsonNodeType.Element);  			ParseStartElement ();  		}  		else  			throw new XmlException ("JsonEncounteredUnexpectedCharacter");  		break;  	case Keys.LowerF:  		{  			int offset;  			byte[] buffer = this.BufferReader.GetBuffer (5' out offset);  			// Check if it's "false"  			if (buffer [offset + 1] != Keys.LowerA || buffer [offset + 2] != Keys.LowerL || buffer [offset + 3] != Keys.LowerS || buffer [offset + 4] != Keys.LowerE)  				throw new Exception ("Expected False");  			// Advance of 5 byte  			this.BufferReader.Advance (5);  			// Check if char after is a closing one  			if (TryGetByte (out ch) && !IsWhitespace (ch) && (ch != Keys.Comma && ch != Keys.RightClosingBrace) && ch != Keys.RightClosingBracket)  				throw new Exception ("TokenExpected");  			// Move  			this.MoveToAtomicText ().Value.SetValue (ValueHandleType.UTF8' offset' 5);  		}  		break;  	case Keys.LowerT:  		{  			int offset;  			// check if it's "true"  			byte[] buffer = this.BufferReader.GetBuffer (4' out offset);  			if (buffer [offset + 1] != Keys.LowerR || buffer [offset + 2] != Keys.LowerU || buffer [offset + 3] != Keys.LowerE)  				throw new Exception ("expected true");  			this.BufferReader.Advance (4);  			// Check if char after is a closing one  			if (TryGetByte (out ch) && !IsWhitespace (ch) && (ch != Keys.Comma && ch != Keys.RightClosingBrace) && ch != Keys.RightClosingBracket)  				throw new Exception ("TokenExpected");  			// move atomic  			this.MoveToAtomicText ().Value.SetValue (ValueHandleType.UTF8' offset' 4);  		}  		break;  	case Keys.LowerN:  		{  			int offset;  			// check if it's "null"  			byte[] buffer = this.BufferReader.GetBuffer (4' out offset);  			if (buffer [offset + 1] != Keys.LowerU || buffer [offset + 2] != Keys.LowerL || buffer [offset + 3] != Keys.LowerL)  				throw new Exception ("Expected null");  			// advance of 4 chars  			this.BufferReader.Advance (4);  			SkipWhitespaceInBufferReader ();  			if (TryGetByte (out ch)) {  				if (ch == Keys.Comma || ch == Keys.RightClosingBrace)  					this.BufferReader.SkipByte ();  				else if (ch != Keys.RightClosingBracket)  					throw new Exception ("TokenExpected");  			}  			else {  				charactersToSkipOnNextRead [0] = Keys.Comma;  				charactersToSkipOnNextRead [1] = Keys.RightClosingBrace;  			}  			MoveToEndElement ();  		}  		break;  	default:  		if ((ch == (byte)'-') || (((byte)'0' <= ch) && (ch <= (byte)'9')) || (ch == (byte)'I') || (ch == (byte)'N'))  			ReadNumericalText ();  		else  			throw new XmlException ("JsonEncounteredUnexpectedCharacter");  		break;  	}  
Magic Number,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,Read,The following statement contains a magic number: if (IsReadingCollection)  	ReadNonExistentElementName (StringHandleConstStringType.Item);  else  	switch (ch) {  	case Keys.RightClosingBracket:  		this.BufferReader.SkipByte ();  		MoveToEndElement ();  		ExitJsonScope ();  		break;  	case Keys.LeftOpeningBrace:  		this.BufferReader.SkipByte ();  		SkipWhitespaceInBufferReader ();  		ch = this.BufferReader.GetByte ();  		if (ch == Keys.RightClosingBrace) {  			// Skip this byte  			this.BufferReader.SkipByte ();  			// Skip white spaces  			SkipWhitespaceInBufferReader ();  			// try get next char  			if (TryGetByte (out ch)) {  				if (ch == Keys.Comma)  					this.BufferReader.SkipByte ();  			}  			else {  				// We are at end of buffer' just mark Comma to be skipped next time  				charactersToSkipOnNextRead [0] = Keys.Comma;  			}  			// We set to End Element  			MoveToEndElement ();  		}  		else {  			// Enter a new scope  			EnterJsonScope (JsonNodeType.Object);  			// Parse start element  			ParseStartElement ();  		}  		break;  	case Keys.RightClosingBrace:  		this.BufferReader.SkipByte ();  		if (expectingFirstElementInNonPrimitiveChild) {  			SkipWhitespaceInBufferReader ();  			ch = this.BufferReader.GetByte ();  			switch (ch) {  			case Keys.Comma:  			case Keys.RightClosingBrace:  				this.BufferReader.SkipByte ();  				break;  			default:  				throw new XmlException ("JsonEncounteredUnexpectedCharacter");  			}  			expectingFirstElementInNonPrimitiveChild = false;  		}  		MoveToEndElement ();  		break;  	case Keys.Comma:  		this.BufferReader.SkipByte ();  		MoveToEndElement ();  		break;  	case Keys.DoubleQuote:  		if (this.Node.NodeType == XmlNodeType.Element) {  			if (expectingFirstElementInNonPrimitiveChild) {  				EnterJsonScope (JsonNodeType.Object);  				ParseStartElement ();  			}  			else {  				this.BufferReader.SkipByte ();  				ReadQuotedText (true);  			}  		}  		else if (this.Node.NodeType == XmlNodeType.EndElement) {  			EnterJsonScope (JsonNodeType.Element);  			ParseStartElement ();  		}  		else  			throw new XmlException ("JsonEncounteredUnexpectedCharacter");  		break;  	case Keys.LowerF:  		{  			int offset;  			byte[] buffer = this.BufferReader.GetBuffer (5' out offset);  			// Check if it's "false"  			if (buffer [offset + 1] != Keys.LowerA || buffer [offset + 2] != Keys.LowerL || buffer [offset + 3] != Keys.LowerS || buffer [offset + 4] != Keys.LowerE)  				throw new Exception ("Expected False");  			// Advance of 5 byte  			this.BufferReader.Advance (5);  			// Check if char after is a closing one  			if (TryGetByte (out ch) && !IsWhitespace (ch) && (ch != Keys.Comma && ch != Keys.RightClosingBrace) && ch != Keys.RightClosingBracket)  				throw new Exception ("TokenExpected");  			// Move  			this.MoveToAtomicText ().Value.SetValue (ValueHandleType.UTF8' offset' 5);  		}  		break;  	case Keys.LowerT:  		{  			int offset;  			// check if it's "true"  			byte[] buffer = this.BufferReader.GetBuffer (4' out offset);  			if (buffer [offset + 1] != Keys.LowerR || buffer [offset + 2] != Keys.LowerU || buffer [offset + 3] != Keys.LowerE)  				throw new Exception ("expected true");  			this.BufferReader.Advance (4);  			// Check if char after is a closing one  			if (TryGetByte (out ch) && !IsWhitespace (ch) && (ch != Keys.Comma && ch != Keys.RightClosingBrace) && ch != Keys.RightClosingBracket)  				throw new Exception ("TokenExpected");  			// move atomic  			this.MoveToAtomicText ().Value.SetValue (ValueHandleType.UTF8' offset' 4);  		}  		break;  	case Keys.LowerN:  		{  			int offset;  			// check if it's "null"  			byte[] buffer = this.BufferReader.GetBuffer (4' out offset);  			if (buffer [offset + 1] != Keys.LowerU || buffer [offset + 2] != Keys.LowerL || buffer [offset + 3] != Keys.LowerL)  				throw new Exception ("Expected null");  			// advance of 4 chars  			this.BufferReader.Advance (4);  			SkipWhitespaceInBufferReader ();  			if (TryGetByte (out ch)) {  				if (ch == Keys.Comma || ch == Keys.RightClosingBrace)  					this.BufferReader.SkipByte ();  				else if (ch != Keys.RightClosingBracket)  					throw new Exception ("TokenExpected");  			}  			else {  				charactersToSkipOnNextRead [0] = Keys.Comma;  				charactersToSkipOnNextRead [1] = Keys.RightClosingBrace;  			}  			MoveToEndElement ();  		}  		break;  	default:  		if ((ch == (byte)'-') || (((byte)'0' <= ch) && (ch <= (byte)'9')) || (ch == (byte)'I') || (ch == (byte)'N'))  			ReadNumericalText ();  		else  			throw new XmlException ("JsonEncounteredUnexpectedCharacter");  		break;  	}  
Magic Number,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,Read,The following statement contains a magic number: if (IsReadingCollection)  	ReadNonExistentElementName (StringHandleConstStringType.Item);  else  	switch (ch) {  	case Keys.RightClosingBracket:  		this.BufferReader.SkipByte ();  		MoveToEndElement ();  		ExitJsonScope ();  		break;  	case Keys.LeftOpeningBrace:  		this.BufferReader.SkipByte ();  		SkipWhitespaceInBufferReader ();  		ch = this.BufferReader.GetByte ();  		if (ch == Keys.RightClosingBrace) {  			// Skip this byte  			this.BufferReader.SkipByte ();  			// Skip white spaces  			SkipWhitespaceInBufferReader ();  			// try get next char  			if (TryGetByte (out ch)) {  				if (ch == Keys.Comma)  					this.BufferReader.SkipByte ();  			}  			else {  				// We are at end of buffer' just mark Comma to be skipped next time  				charactersToSkipOnNextRead [0] = Keys.Comma;  			}  			// We set to End Element  			MoveToEndElement ();  		}  		else {  			// Enter a new scope  			EnterJsonScope (JsonNodeType.Object);  			// Parse start element  			ParseStartElement ();  		}  		break;  	case Keys.RightClosingBrace:  		this.BufferReader.SkipByte ();  		if (expectingFirstElementInNonPrimitiveChild) {  			SkipWhitespaceInBufferReader ();  			ch = this.BufferReader.GetByte ();  			switch (ch) {  			case Keys.Comma:  			case Keys.RightClosingBrace:  				this.BufferReader.SkipByte ();  				break;  			default:  				throw new XmlException ("JsonEncounteredUnexpectedCharacter");  			}  			expectingFirstElementInNonPrimitiveChild = false;  		}  		MoveToEndElement ();  		break;  	case Keys.Comma:  		this.BufferReader.SkipByte ();  		MoveToEndElement ();  		break;  	case Keys.DoubleQuote:  		if (this.Node.NodeType == XmlNodeType.Element) {  			if (expectingFirstElementInNonPrimitiveChild) {  				EnterJsonScope (JsonNodeType.Object);  				ParseStartElement ();  			}  			else {  				this.BufferReader.SkipByte ();  				ReadQuotedText (true);  			}  		}  		else if (this.Node.NodeType == XmlNodeType.EndElement) {  			EnterJsonScope (JsonNodeType.Element);  			ParseStartElement ();  		}  		else  			throw new XmlException ("JsonEncounteredUnexpectedCharacter");  		break;  	case Keys.LowerF:  		{  			int offset;  			byte[] buffer = this.BufferReader.GetBuffer (5' out offset);  			// Check if it's "false"  			if (buffer [offset + 1] != Keys.LowerA || buffer [offset + 2] != Keys.LowerL || buffer [offset + 3] != Keys.LowerS || buffer [offset + 4] != Keys.LowerE)  				throw new Exception ("Expected False");  			// Advance of 5 byte  			this.BufferReader.Advance (5);  			// Check if char after is a closing one  			if (TryGetByte (out ch) && !IsWhitespace (ch) && (ch != Keys.Comma && ch != Keys.RightClosingBrace) && ch != Keys.RightClosingBracket)  				throw new Exception ("TokenExpected");  			// Move  			this.MoveToAtomicText ().Value.SetValue (ValueHandleType.UTF8' offset' 5);  		}  		break;  	case Keys.LowerT:  		{  			int offset;  			// check if it's "true"  			byte[] buffer = this.BufferReader.GetBuffer (4' out offset);  			if (buffer [offset + 1] != Keys.LowerR || buffer [offset + 2] != Keys.LowerU || buffer [offset + 3] != Keys.LowerE)  				throw new Exception ("expected true");  			this.BufferReader.Advance (4);  			// Check if char after is a closing one  			if (TryGetByte (out ch) && !IsWhitespace (ch) && (ch != Keys.Comma && ch != Keys.RightClosingBrace) && ch != Keys.RightClosingBracket)  				throw new Exception ("TokenExpected");  			// move atomic  			this.MoveToAtomicText ().Value.SetValue (ValueHandleType.UTF8' offset' 4);  		}  		break;  	case Keys.LowerN:  		{  			int offset;  			// check if it's "null"  			byte[] buffer = this.BufferReader.GetBuffer (4' out offset);  			if (buffer [offset + 1] != Keys.LowerU || buffer [offset + 2] != Keys.LowerL || buffer [offset + 3] != Keys.LowerL)  				throw new Exception ("Expected null");  			// advance of 4 chars  			this.BufferReader.Advance (4);  			SkipWhitespaceInBufferReader ();  			if (TryGetByte (out ch)) {  				if (ch == Keys.Comma || ch == Keys.RightClosingBrace)  					this.BufferReader.SkipByte ();  				else if (ch != Keys.RightClosingBracket)  					throw new Exception ("TokenExpected");  			}  			else {  				charactersToSkipOnNextRead [0] = Keys.Comma;  				charactersToSkipOnNextRead [1] = Keys.RightClosingBrace;  			}  			MoveToEndElement ();  		}  		break;  	default:  		if ((ch == (byte)'-') || (((byte)'0' <= ch) && (ch <= (byte)'9')) || (ch == (byte)'I') || (ch == (byte)'N'))  			ReadNumericalText ();  		else  			throw new XmlException ("JsonEncounteredUnexpectedCharacter");  		break;  	}  
Magic Number,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,Read,The following statement contains a magic number: if (IsReadingCollection)  	ReadNonExistentElementName (StringHandleConstStringType.Item);  else  	switch (ch) {  	case Keys.RightClosingBracket:  		this.BufferReader.SkipByte ();  		MoveToEndElement ();  		ExitJsonScope ();  		break;  	case Keys.LeftOpeningBrace:  		this.BufferReader.SkipByte ();  		SkipWhitespaceInBufferReader ();  		ch = this.BufferReader.GetByte ();  		if (ch == Keys.RightClosingBrace) {  			// Skip this byte  			this.BufferReader.SkipByte ();  			// Skip white spaces  			SkipWhitespaceInBufferReader ();  			// try get next char  			if (TryGetByte (out ch)) {  				if (ch == Keys.Comma)  					this.BufferReader.SkipByte ();  			}  			else {  				// We are at end of buffer' just mark Comma to be skipped next time  				charactersToSkipOnNextRead [0] = Keys.Comma;  			}  			// We set to End Element  			MoveToEndElement ();  		}  		else {  			// Enter a new scope  			EnterJsonScope (JsonNodeType.Object);  			// Parse start element  			ParseStartElement ();  		}  		break;  	case Keys.RightClosingBrace:  		this.BufferReader.SkipByte ();  		if (expectingFirstElementInNonPrimitiveChild) {  			SkipWhitespaceInBufferReader ();  			ch = this.BufferReader.GetByte ();  			switch (ch) {  			case Keys.Comma:  			case Keys.RightClosingBrace:  				this.BufferReader.SkipByte ();  				break;  			default:  				throw new XmlException ("JsonEncounteredUnexpectedCharacter");  			}  			expectingFirstElementInNonPrimitiveChild = false;  		}  		MoveToEndElement ();  		break;  	case Keys.Comma:  		this.BufferReader.SkipByte ();  		MoveToEndElement ();  		break;  	case Keys.DoubleQuote:  		if (this.Node.NodeType == XmlNodeType.Element) {  			if (expectingFirstElementInNonPrimitiveChild) {  				EnterJsonScope (JsonNodeType.Object);  				ParseStartElement ();  			}  			else {  				this.BufferReader.SkipByte ();  				ReadQuotedText (true);  			}  		}  		else if (this.Node.NodeType == XmlNodeType.EndElement) {  			EnterJsonScope (JsonNodeType.Element);  			ParseStartElement ();  		}  		else  			throw new XmlException ("JsonEncounteredUnexpectedCharacter");  		break;  	case Keys.LowerF:  		{  			int offset;  			byte[] buffer = this.BufferReader.GetBuffer (5' out offset);  			// Check if it's "false"  			if (buffer [offset + 1] != Keys.LowerA || buffer [offset + 2] != Keys.LowerL || buffer [offset + 3] != Keys.LowerS || buffer [offset + 4] != Keys.LowerE)  				throw new Exception ("Expected False");  			// Advance of 5 byte  			this.BufferReader.Advance (5);  			// Check if char after is a closing one  			if (TryGetByte (out ch) && !IsWhitespace (ch) && (ch != Keys.Comma && ch != Keys.RightClosingBrace) && ch != Keys.RightClosingBracket)  				throw new Exception ("TokenExpected");  			// Move  			this.MoveToAtomicText ().Value.SetValue (ValueHandleType.UTF8' offset' 5);  		}  		break;  	case Keys.LowerT:  		{  			int offset;  			// check if it's "true"  			byte[] buffer = this.BufferReader.GetBuffer (4' out offset);  			if (buffer [offset + 1] != Keys.LowerR || buffer [offset + 2] != Keys.LowerU || buffer [offset + 3] != Keys.LowerE)  				throw new Exception ("expected true");  			this.BufferReader.Advance (4);  			// Check if char after is a closing one  			if (TryGetByte (out ch) && !IsWhitespace (ch) && (ch != Keys.Comma && ch != Keys.RightClosingBrace) && ch != Keys.RightClosingBracket)  				throw new Exception ("TokenExpected");  			// move atomic  			this.MoveToAtomicText ().Value.SetValue (ValueHandleType.UTF8' offset' 4);  		}  		break;  	case Keys.LowerN:  		{  			int offset;  			// check if it's "null"  			byte[] buffer = this.BufferReader.GetBuffer (4' out offset);  			if (buffer [offset + 1] != Keys.LowerU || buffer [offset + 2] != Keys.LowerL || buffer [offset + 3] != Keys.LowerL)  				throw new Exception ("Expected null");  			// advance of 4 chars  			this.BufferReader.Advance (4);  			SkipWhitespaceInBufferReader ();  			if (TryGetByte (out ch)) {  				if (ch == Keys.Comma || ch == Keys.RightClosingBrace)  					this.BufferReader.SkipByte ();  				else if (ch != Keys.RightClosingBracket)  					throw new Exception ("TokenExpected");  			}  			else {  				charactersToSkipOnNextRead [0] = Keys.Comma;  				charactersToSkipOnNextRead [1] = Keys.RightClosingBrace;  			}  			MoveToEndElement ();  		}  		break;  	default:  		if ((ch == (byte)'-') || (((byte)'0' <= ch) && (ch <= (byte)'9')) || (ch == (byte)'I') || (ch == (byte)'N'))  			ReadNumericalText ();  		else  			throw new XmlException ("JsonEncounteredUnexpectedCharacter");  		break;  	}  
Magic Number,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,Read,The following statement contains a magic number: if (IsReadingCollection)  	ReadNonExistentElementName (StringHandleConstStringType.Item);  else  	switch (ch) {  	case Keys.RightClosingBracket:  		this.BufferReader.SkipByte ();  		MoveToEndElement ();  		ExitJsonScope ();  		break;  	case Keys.LeftOpeningBrace:  		this.BufferReader.SkipByte ();  		SkipWhitespaceInBufferReader ();  		ch = this.BufferReader.GetByte ();  		if (ch == Keys.RightClosingBrace) {  			// Skip this byte  			this.BufferReader.SkipByte ();  			// Skip white spaces  			SkipWhitespaceInBufferReader ();  			// try get next char  			if (TryGetByte (out ch)) {  				if (ch == Keys.Comma)  					this.BufferReader.SkipByte ();  			}  			else {  				// We are at end of buffer' just mark Comma to be skipped next time  				charactersToSkipOnNextRead [0] = Keys.Comma;  			}  			// We set to End Element  			MoveToEndElement ();  		}  		else {  			// Enter a new scope  			EnterJsonScope (JsonNodeType.Object);  			// Parse start element  			ParseStartElement ();  		}  		break;  	case Keys.RightClosingBrace:  		this.BufferReader.SkipByte ();  		if (expectingFirstElementInNonPrimitiveChild) {  			SkipWhitespaceInBufferReader ();  			ch = this.BufferReader.GetByte ();  			switch (ch) {  			case Keys.Comma:  			case Keys.RightClosingBrace:  				this.BufferReader.SkipByte ();  				break;  			default:  				throw new XmlException ("JsonEncounteredUnexpectedCharacter");  			}  			expectingFirstElementInNonPrimitiveChild = false;  		}  		MoveToEndElement ();  		break;  	case Keys.Comma:  		this.BufferReader.SkipByte ();  		MoveToEndElement ();  		break;  	case Keys.DoubleQuote:  		if (this.Node.NodeType == XmlNodeType.Element) {  			if (expectingFirstElementInNonPrimitiveChild) {  				EnterJsonScope (JsonNodeType.Object);  				ParseStartElement ();  			}  			else {  				this.BufferReader.SkipByte ();  				ReadQuotedText (true);  			}  		}  		else if (this.Node.NodeType == XmlNodeType.EndElement) {  			EnterJsonScope (JsonNodeType.Element);  			ParseStartElement ();  		}  		else  			throw new XmlException ("JsonEncounteredUnexpectedCharacter");  		break;  	case Keys.LowerF:  		{  			int offset;  			byte[] buffer = this.BufferReader.GetBuffer (5' out offset);  			// Check if it's "false"  			if (buffer [offset + 1] != Keys.LowerA || buffer [offset + 2] != Keys.LowerL || buffer [offset + 3] != Keys.LowerS || buffer [offset + 4] != Keys.LowerE)  				throw new Exception ("Expected False");  			// Advance of 5 byte  			this.BufferReader.Advance (5);  			// Check if char after is a closing one  			if (TryGetByte (out ch) && !IsWhitespace (ch) && (ch != Keys.Comma && ch != Keys.RightClosingBrace) && ch != Keys.RightClosingBracket)  				throw new Exception ("TokenExpected");  			// Move  			this.MoveToAtomicText ().Value.SetValue (ValueHandleType.UTF8' offset' 5);  		}  		break;  	case Keys.LowerT:  		{  			int offset;  			// check if it's "true"  			byte[] buffer = this.BufferReader.GetBuffer (4' out offset);  			if (buffer [offset + 1] != Keys.LowerR || buffer [offset + 2] != Keys.LowerU || buffer [offset + 3] != Keys.LowerE)  				throw new Exception ("expected true");  			this.BufferReader.Advance (4);  			// Check if char after is a closing one  			if (TryGetByte (out ch) && !IsWhitespace (ch) && (ch != Keys.Comma && ch != Keys.RightClosingBrace) && ch != Keys.RightClosingBracket)  				throw new Exception ("TokenExpected");  			// move atomic  			this.MoveToAtomicText ().Value.SetValue (ValueHandleType.UTF8' offset' 4);  		}  		break;  	case Keys.LowerN:  		{  			int offset;  			// check if it's "null"  			byte[] buffer = this.BufferReader.GetBuffer (4' out offset);  			if (buffer [offset + 1] != Keys.LowerU || buffer [offset + 2] != Keys.LowerL || buffer [offset + 3] != Keys.LowerL)  				throw new Exception ("Expected null");  			// advance of 4 chars  			this.BufferReader.Advance (4);  			SkipWhitespaceInBufferReader ();  			if (TryGetByte (out ch)) {  				if (ch == Keys.Comma || ch == Keys.RightClosingBrace)  					this.BufferReader.SkipByte ();  				else if (ch != Keys.RightClosingBracket)  					throw new Exception ("TokenExpected");  			}  			else {  				charactersToSkipOnNextRead [0] = Keys.Comma;  				charactersToSkipOnNextRead [1] = Keys.RightClosingBrace;  			}  			MoveToEndElement ();  		}  		break;  	default:  		if ((ch == (byte)'-') || (((byte)'0' <= ch) && (ch <= (byte)'9')) || (ch == (byte)'I') || (ch == (byte)'N'))  			ReadNumericalText ();  		else  			throw new XmlException ("JsonEncounteredUnexpectedCharacter");  		break;  	}  
Magic Number,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,Read,The following statement contains a magic number: if (IsReadingCollection)  	ReadNonExistentElementName (StringHandleConstStringType.Item);  else  	switch (ch) {  	case Keys.RightClosingBracket:  		this.BufferReader.SkipByte ();  		MoveToEndElement ();  		ExitJsonScope ();  		break;  	case Keys.LeftOpeningBrace:  		this.BufferReader.SkipByte ();  		SkipWhitespaceInBufferReader ();  		ch = this.BufferReader.GetByte ();  		if (ch == Keys.RightClosingBrace) {  			// Skip this byte  			this.BufferReader.SkipByte ();  			// Skip white spaces  			SkipWhitespaceInBufferReader ();  			// try get next char  			if (TryGetByte (out ch)) {  				if (ch == Keys.Comma)  					this.BufferReader.SkipByte ();  			}  			else {  				// We are at end of buffer' just mark Comma to be skipped next time  				charactersToSkipOnNextRead [0] = Keys.Comma;  			}  			// We set to End Element  			MoveToEndElement ();  		}  		else {  			// Enter a new scope  			EnterJsonScope (JsonNodeType.Object);  			// Parse start element  			ParseStartElement ();  		}  		break;  	case Keys.RightClosingBrace:  		this.BufferReader.SkipByte ();  		if (expectingFirstElementInNonPrimitiveChild) {  			SkipWhitespaceInBufferReader ();  			ch = this.BufferReader.GetByte ();  			switch (ch) {  			case Keys.Comma:  			case Keys.RightClosingBrace:  				this.BufferReader.SkipByte ();  				break;  			default:  				throw new XmlException ("JsonEncounteredUnexpectedCharacter");  			}  			expectingFirstElementInNonPrimitiveChild = false;  		}  		MoveToEndElement ();  		break;  	case Keys.Comma:  		this.BufferReader.SkipByte ();  		MoveToEndElement ();  		break;  	case Keys.DoubleQuote:  		if (this.Node.NodeType == XmlNodeType.Element) {  			if (expectingFirstElementInNonPrimitiveChild) {  				EnterJsonScope (JsonNodeType.Object);  				ParseStartElement ();  			}  			else {  				this.BufferReader.SkipByte ();  				ReadQuotedText (true);  			}  		}  		else if (this.Node.NodeType == XmlNodeType.EndElement) {  			EnterJsonScope (JsonNodeType.Element);  			ParseStartElement ();  		}  		else  			throw new XmlException ("JsonEncounteredUnexpectedCharacter");  		break;  	case Keys.LowerF:  		{  			int offset;  			byte[] buffer = this.BufferReader.GetBuffer (5' out offset);  			// Check if it's "false"  			if (buffer [offset + 1] != Keys.LowerA || buffer [offset + 2] != Keys.LowerL || buffer [offset + 3] != Keys.LowerS || buffer [offset + 4] != Keys.LowerE)  				throw new Exception ("Expected False");  			// Advance of 5 byte  			this.BufferReader.Advance (5);  			// Check if char after is a closing one  			if (TryGetByte (out ch) && !IsWhitespace (ch) && (ch != Keys.Comma && ch != Keys.RightClosingBrace) && ch != Keys.RightClosingBracket)  				throw new Exception ("TokenExpected");  			// Move  			this.MoveToAtomicText ().Value.SetValue (ValueHandleType.UTF8' offset' 5);  		}  		break;  	case Keys.LowerT:  		{  			int offset;  			// check if it's "true"  			byte[] buffer = this.BufferReader.GetBuffer (4' out offset);  			if (buffer [offset + 1] != Keys.LowerR || buffer [offset + 2] != Keys.LowerU || buffer [offset + 3] != Keys.LowerE)  				throw new Exception ("expected true");  			this.BufferReader.Advance (4);  			// Check if char after is a closing one  			if (TryGetByte (out ch) && !IsWhitespace (ch) && (ch != Keys.Comma && ch != Keys.RightClosingBrace) && ch != Keys.RightClosingBracket)  				throw new Exception ("TokenExpected");  			// move atomic  			this.MoveToAtomicText ().Value.SetValue (ValueHandleType.UTF8' offset' 4);  		}  		break;  	case Keys.LowerN:  		{  			int offset;  			// check if it's "null"  			byte[] buffer = this.BufferReader.GetBuffer (4' out offset);  			if (buffer [offset + 1] != Keys.LowerU || buffer [offset + 2] != Keys.LowerL || buffer [offset + 3] != Keys.LowerL)  				throw new Exception ("Expected null");  			// advance of 4 chars  			this.BufferReader.Advance (4);  			SkipWhitespaceInBufferReader ();  			if (TryGetByte (out ch)) {  				if (ch == Keys.Comma || ch == Keys.RightClosingBrace)  					this.BufferReader.SkipByte ();  				else if (ch != Keys.RightClosingBracket)  					throw new Exception ("TokenExpected");  			}  			else {  				charactersToSkipOnNextRead [0] = Keys.Comma;  				charactersToSkipOnNextRead [1] = Keys.RightClosingBrace;  			}  			MoveToEndElement ();  		}  		break;  	default:  		if ((ch == (byte)'-') || (((byte)'0' <= ch) && (ch <= (byte)'9')) || (ch == (byte)'I') || (ch == (byte)'N'))  			ReadNumericalText ();  		else  			throw new XmlException ("JsonEncounteredUnexpectedCharacter");  		break;  	}  
Magic Number,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,Read,The following statement contains a magic number: if (IsReadingCollection)  	ReadNonExistentElementName (StringHandleConstStringType.Item);  else  	switch (ch) {  	case Keys.RightClosingBracket:  		this.BufferReader.SkipByte ();  		MoveToEndElement ();  		ExitJsonScope ();  		break;  	case Keys.LeftOpeningBrace:  		this.BufferReader.SkipByte ();  		SkipWhitespaceInBufferReader ();  		ch = this.BufferReader.GetByte ();  		if (ch == Keys.RightClosingBrace) {  			// Skip this byte  			this.BufferReader.SkipByte ();  			// Skip white spaces  			SkipWhitespaceInBufferReader ();  			// try get next char  			if (TryGetByte (out ch)) {  				if (ch == Keys.Comma)  					this.BufferReader.SkipByte ();  			}  			else {  				// We are at end of buffer' just mark Comma to be skipped next time  				charactersToSkipOnNextRead [0] = Keys.Comma;  			}  			// We set to End Element  			MoveToEndElement ();  		}  		else {  			// Enter a new scope  			EnterJsonScope (JsonNodeType.Object);  			// Parse start element  			ParseStartElement ();  		}  		break;  	case Keys.RightClosingBrace:  		this.BufferReader.SkipByte ();  		if (expectingFirstElementInNonPrimitiveChild) {  			SkipWhitespaceInBufferReader ();  			ch = this.BufferReader.GetByte ();  			switch (ch) {  			case Keys.Comma:  			case Keys.RightClosingBrace:  				this.BufferReader.SkipByte ();  				break;  			default:  				throw new XmlException ("JsonEncounteredUnexpectedCharacter");  			}  			expectingFirstElementInNonPrimitiveChild = false;  		}  		MoveToEndElement ();  		break;  	case Keys.Comma:  		this.BufferReader.SkipByte ();  		MoveToEndElement ();  		break;  	case Keys.DoubleQuote:  		if (this.Node.NodeType == XmlNodeType.Element) {  			if (expectingFirstElementInNonPrimitiveChild) {  				EnterJsonScope (JsonNodeType.Object);  				ParseStartElement ();  			}  			else {  				this.BufferReader.SkipByte ();  				ReadQuotedText (true);  			}  		}  		else if (this.Node.NodeType == XmlNodeType.EndElement) {  			EnterJsonScope (JsonNodeType.Element);  			ParseStartElement ();  		}  		else  			throw new XmlException ("JsonEncounteredUnexpectedCharacter");  		break;  	case Keys.LowerF:  		{  			int offset;  			byte[] buffer = this.BufferReader.GetBuffer (5' out offset);  			// Check if it's "false"  			if (buffer [offset + 1] != Keys.LowerA || buffer [offset + 2] != Keys.LowerL || buffer [offset + 3] != Keys.LowerS || buffer [offset + 4] != Keys.LowerE)  				throw new Exception ("Expected False");  			// Advance of 5 byte  			this.BufferReader.Advance (5);  			// Check if char after is a closing one  			if (TryGetByte (out ch) && !IsWhitespace (ch) && (ch != Keys.Comma && ch != Keys.RightClosingBrace) && ch != Keys.RightClosingBracket)  				throw new Exception ("TokenExpected");  			// Move  			this.MoveToAtomicText ().Value.SetValue (ValueHandleType.UTF8' offset' 5);  		}  		break;  	case Keys.LowerT:  		{  			int offset;  			// check if it's "true"  			byte[] buffer = this.BufferReader.GetBuffer (4' out offset);  			if (buffer [offset + 1] != Keys.LowerR || buffer [offset + 2] != Keys.LowerU || buffer [offset + 3] != Keys.LowerE)  				throw new Exception ("expected true");  			this.BufferReader.Advance (4);  			// Check if char after is a closing one  			if (TryGetByte (out ch) && !IsWhitespace (ch) && (ch != Keys.Comma && ch != Keys.RightClosingBrace) && ch != Keys.RightClosingBracket)  				throw new Exception ("TokenExpected");  			// move atomic  			this.MoveToAtomicText ().Value.SetValue (ValueHandleType.UTF8' offset' 4);  		}  		break;  	case Keys.LowerN:  		{  			int offset;  			// check if it's "null"  			byte[] buffer = this.BufferReader.GetBuffer (4' out offset);  			if (buffer [offset + 1] != Keys.LowerU || buffer [offset + 2] != Keys.LowerL || buffer [offset + 3] != Keys.LowerL)  				throw new Exception ("Expected null");  			// advance of 4 chars  			this.BufferReader.Advance (4);  			SkipWhitespaceInBufferReader ();  			if (TryGetByte (out ch)) {  				if (ch == Keys.Comma || ch == Keys.RightClosingBrace)  					this.BufferReader.SkipByte ();  				else if (ch != Keys.RightClosingBracket)  					throw new Exception ("TokenExpected");  			}  			else {  				charactersToSkipOnNextRead [0] = Keys.Comma;  				charactersToSkipOnNextRead [1] = Keys.RightClosingBrace;  			}  			MoveToEndElement ();  		}  		break;  	default:  		if ((ch == (byte)'-') || (((byte)'0' <= ch) && (ch <= (byte)'9')) || (ch == (byte)'I') || (ch == (byte)'N'))  			ReadNumericalText ();  		else  			throw new XmlException ("JsonEncounteredUnexpectedCharacter");  		break;  	}  
Magic Number,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,Read,The following statement contains a magic number: if (IsReadingCollection)  	ReadNonExistentElementName (StringHandleConstStringType.Item);  else  	switch (ch) {  	case Keys.RightClosingBracket:  		this.BufferReader.SkipByte ();  		MoveToEndElement ();  		ExitJsonScope ();  		break;  	case Keys.LeftOpeningBrace:  		this.BufferReader.SkipByte ();  		SkipWhitespaceInBufferReader ();  		ch = this.BufferReader.GetByte ();  		if (ch == Keys.RightClosingBrace) {  			// Skip this byte  			this.BufferReader.SkipByte ();  			// Skip white spaces  			SkipWhitespaceInBufferReader ();  			// try get next char  			if (TryGetByte (out ch)) {  				if (ch == Keys.Comma)  					this.BufferReader.SkipByte ();  			}  			else {  				// We are at end of buffer' just mark Comma to be skipped next time  				charactersToSkipOnNextRead [0] = Keys.Comma;  			}  			// We set to End Element  			MoveToEndElement ();  		}  		else {  			// Enter a new scope  			EnterJsonScope (JsonNodeType.Object);  			// Parse start element  			ParseStartElement ();  		}  		break;  	case Keys.RightClosingBrace:  		this.BufferReader.SkipByte ();  		if (expectingFirstElementInNonPrimitiveChild) {  			SkipWhitespaceInBufferReader ();  			ch = this.BufferReader.GetByte ();  			switch (ch) {  			case Keys.Comma:  			case Keys.RightClosingBrace:  				this.BufferReader.SkipByte ();  				break;  			default:  				throw new XmlException ("JsonEncounteredUnexpectedCharacter");  			}  			expectingFirstElementInNonPrimitiveChild = false;  		}  		MoveToEndElement ();  		break;  	case Keys.Comma:  		this.BufferReader.SkipByte ();  		MoveToEndElement ();  		break;  	case Keys.DoubleQuote:  		if (this.Node.NodeType == XmlNodeType.Element) {  			if (expectingFirstElementInNonPrimitiveChild) {  				EnterJsonScope (JsonNodeType.Object);  				ParseStartElement ();  			}  			else {  				this.BufferReader.SkipByte ();  				ReadQuotedText (true);  			}  		}  		else if (this.Node.NodeType == XmlNodeType.EndElement) {  			EnterJsonScope (JsonNodeType.Element);  			ParseStartElement ();  		}  		else  			throw new XmlException ("JsonEncounteredUnexpectedCharacter");  		break;  	case Keys.LowerF:  		{  			int offset;  			byte[] buffer = this.BufferReader.GetBuffer (5' out offset);  			// Check if it's "false"  			if (buffer [offset + 1] != Keys.LowerA || buffer [offset + 2] != Keys.LowerL || buffer [offset + 3] != Keys.LowerS || buffer [offset + 4] != Keys.LowerE)  				throw new Exception ("Expected False");  			// Advance of 5 byte  			this.BufferReader.Advance (5);  			// Check if char after is a closing one  			if (TryGetByte (out ch) && !IsWhitespace (ch) && (ch != Keys.Comma && ch != Keys.RightClosingBrace) && ch != Keys.RightClosingBracket)  				throw new Exception ("TokenExpected");  			// Move  			this.MoveToAtomicText ().Value.SetValue (ValueHandleType.UTF8' offset' 5);  		}  		break;  	case Keys.LowerT:  		{  			int offset;  			// check if it's "true"  			byte[] buffer = this.BufferReader.GetBuffer (4' out offset);  			if (buffer [offset + 1] != Keys.LowerR || buffer [offset + 2] != Keys.LowerU || buffer [offset + 3] != Keys.LowerE)  				throw new Exception ("expected true");  			this.BufferReader.Advance (4);  			// Check if char after is a closing one  			if (TryGetByte (out ch) && !IsWhitespace (ch) && (ch != Keys.Comma && ch != Keys.RightClosingBrace) && ch != Keys.RightClosingBracket)  				throw new Exception ("TokenExpected");  			// move atomic  			this.MoveToAtomicText ().Value.SetValue (ValueHandleType.UTF8' offset' 4);  		}  		break;  	case Keys.LowerN:  		{  			int offset;  			// check if it's "null"  			byte[] buffer = this.BufferReader.GetBuffer (4' out offset);  			if (buffer [offset + 1] != Keys.LowerU || buffer [offset + 2] != Keys.LowerL || buffer [offset + 3] != Keys.LowerL)  				throw new Exception ("Expected null");  			// advance of 4 chars  			this.BufferReader.Advance (4);  			SkipWhitespaceInBufferReader ();  			if (TryGetByte (out ch)) {  				if (ch == Keys.Comma || ch == Keys.RightClosingBrace)  					this.BufferReader.SkipByte ();  				else if (ch != Keys.RightClosingBracket)  					throw new Exception ("TokenExpected");  			}  			else {  				charactersToSkipOnNextRead [0] = Keys.Comma;  				charactersToSkipOnNextRead [1] = Keys.RightClosingBrace;  			}  			MoveToEndElement ();  		}  		break;  	default:  		if ((ch == (byte)'-') || (((byte)'0' <= ch) && (ch <= (byte)'9')) || (ch == (byte)'I') || (ch == (byte)'N'))  			ReadNumericalText ();  		else  			throw new XmlException ("JsonEncounteredUnexpectedCharacter");  		break;  	}  
Magic Number,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,Read,The following statement contains a magic number: switch (ch) {  case Keys.RightClosingBracket:  	this.BufferReader.SkipByte ();  	MoveToEndElement ();  	ExitJsonScope ();  	break;  case Keys.LeftOpeningBrace:  	this.BufferReader.SkipByte ();  	SkipWhitespaceInBufferReader ();  	ch = this.BufferReader.GetByte ();  	if (ch == Keys.RightClosingBrace) {  		// Skip this byte  		this.BufferReader.SkipByte ();  		// Skip white spaces  		SkipWhitespaceInBufferReader ();  		// try get next char  		if (TryGetByte (out ch)) {  			if (ch == Keys.Comma)  				this.BufferReader.SkipByte ();  		}  		else {  			// We are at end of buffer' just mark Comma to be skipped next time  			charactersToSkipOnNextRead [0] = Keys.Comma;  		}  		// We set to End Element  		MoveToEndElement ();  	}  	else {  		// Enter a new scope  		EnterJsonScope (JsonNodeType.Object);  		// Parse start element  		ParseStartElement ();  	}  	break;  case Keys.RightClosingBrace:  	this.BufferReader.SkipByte ();  	if (expectingFirstElementInNonPrimitiveChild) {  		SkipWhitespaceInBufferReader ();  		ch = this.BufferReader.GetByte ();  		switch (ch) {  		case Keys.Comma:  		case Keys.RightClosingBrace:  			this.BufferReader.SkipByte ();  			break;  		default:  			throw new XmlException ("JsonEncounteredUnexpectedCharacter");  		}  		expectingFirstElementInNonPrimitiveChild = false;  	}  	MoveToEndElement ();  	break;  case Keys.Comma:  	this.BufferReader.SkipByte ();  	MoveToEndElement ();  	break;  case Keys.DoubleQuote:  	if (this.Node.NodeType == XmlNodeType.Element) {  		if (expectingFirstElementInNonPrimitiveChild) {  			EnterJsonScope (JsonNodeType.Object);  			ParseStartElement ();  		}  		else {  			this.BufferReader.SkipByte ();  			ReadQuotedText (true);  		}  	}  	else if (this.Node.NodeType == XmlNodeType.EndElement) {  		EnterJsonScope (JsonNodeType.Element);  		ParseStartElement ();  	}  	else  		throw new XmlException ("JsonEncounteredUnexpectedCharacter");  	break;  case Keys.LowerF:  	{  		int offset;  		byte[] buffer = this.BufferReader.GetBuffer (5' out offset);  		// Check if it's "false"  		if (buffer [offset + 1] != Keys.LowerA || buffer [offset + 2] != Keys.LowerL || buffer [offset + 3] != Keys.LowerS || buffer [offset + 4] != Keys.LowerE)  			throw new Exception ("Expected False");  		// Advance of 5 byte  		this.BufferReader.Advance (5);  		// Check if char after is a closing one  		if (TryGetByte (out ch) && !IsWhitespace (ch) && (ch != Keys.Comma && ch != Keys.RightClosingBrace) && ch != Keys.RightClosingBracket)  			throw new Exception ("TokenExpected");  		// Move  		this.MoveToAtomicText ().Value.SetValue (ValueHandleType.UTF8' offset' 5);  	}  	break;  case Keys.LowerT:  	{  		int offset;  		// check if it's "true"  		byte[] buffer = this.BufferReader.GetBuffer (4' out offset);  		if (buffer [offset + 1] != Keys.LowerR || buffer [offset + 2] != Keys.LowerU || buffer [offset + 3] != Keys.LowerE)  			throw new Exception ("expected true");  		this.BufferReader.Advance (4);  		// Check if char after is a closing one  		if (TryGetByte (out ch) && !IsWhitespace (ch) && (ch != Keys.Comma && ch != Keys.RightClosingBrace) && ch != Keys.RightClosingBracket)  			throw new Exception ("TokenExpected");  		// move atomic  		this.MoveToAtomicText ().Value.SetValue (ValueHandleType.UTF8' offset' 4);  	}  	break;  case Keys.LowerN:  	{  		int offset;  		// check if it's "null"  		byte[] buffer = this.BufferReader.GetBuffer (4' out offset);  		if (buffer [offset + 1] != Keys.LowerU || buffer [offset + 2] != Keys.LowerL || buffer [offset + 3] != Keys.LowerL)  			throw new Exception ("Expected null");  		// advance of 4 chars  		this.BufferReader.Advance (4);  		SkipWhitespaceInBufferReader ();  		if (TryGetByte (out ch)) {  			if (ch == Keys.Comma || ch == Keys.RightClosingBrace)  				this.BufferReader.SkipByte ();  			else if (ch != Keys.RightClosingBracket)  				throw new Exception ("TokenExpected");  		}  		else {  			charactersToSkipOnNextRead [0] = Keys.Comma;  			charactersToSkipOnNextRead [1] = Keys.RightClosingBrace;  		}  		MoveToEndElement ();  	}  	break;  default:  	if ((ch == (byte)'-') || (((byte)'0' <= ch) && (ch <= (byte)'9')) || (ch == (byte)'I') || (ch == (byte)'N'))  		ReadNumericalText ();  	else  		throw new XmlException ("JsonEncounteredUnexpectedCharacter");  	break;  }  
Magic Number,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,Read,The following statement contains a magic number: switch (ch) {  case Keys.RightClosingBracket:  	this.BufferReader.SkipByte ();  	MoveToEndElement ();  	ExitJsonScope ();  	break;  case Keys.LeftOpeningBrace:  	this.BufferReader.SkipByte ();  	SkipWhitespaceInBufferReader ();  	ch = this.BufferReader.GetByte ();  	if (ch == Keys.RightClosingBrace) {  		// Skip this byte  		this.BufferReader.SkipByte ();  		// Skip white spaces  		SkipWhitespaceInBufferReader ();  		// try get next char  		if (TryGetByte (out ch)) {  			if (ch == Keys.Comma)  				this.BufferReader.SkipByte ();  		}  		else {  			// We are at end of buffer' just mark Comma to be skipped next time  			charactersToSkipOnNextRead [0] = Keys.Comma;  		}  		// We set to End Element  		MoveToEndElement ();  	}  	else {  		// Enter a new scope  		EnterJsonScope (JsonNodeType.Object);  		// Parse start element  		ParseStartElement ();  	}  	break;  case Keys.RightClosingBrace:  	this.BufferReader.SkipByte ();  	if (expectingFirstElementInNonPrimitiveChild) {  		SkipWhitespaceInBufferReader ();  		ch = this.BufferReader.GetByte ();  		switch (ch) {  		case Keys.Comma:  		case Keys.RightClosingBrace:  			this.BufferReader.SkipByte ();  			break;  		default:  			throw new XmlException ("JsonEncounteredUnexpectedCharacter");  		}  		expectingFirstElementInNonPrimitiveChild = false;  	}  	MoveToEndElement ();  	break;  case Keys.Comma:  	this.BufferReader.SkipByte ();  	MoveToEndElement ();  	break;  case Keys.DoubleQuote:  	if (this.Node.NodeType == XmlNodeType.Element) {  		if (expectingFirstElementInNonPrimitiveChild) {  			EnterJsonScope (JsonNodeType.Object);  			ParseStartElement ();  		}  		else {  			this.BufferReader.SkipByte ();  			ReadQuotedText (true);  		}  	}  	else if (this.Node.NodeType == XmlNodeType.EndElement) {  		EnterJsonScope (JsonNodeType.Element);  		ParseStartElement ();  	}  	else  		throw new XmlException ("JsonEncounteredUnexpectedCharacter");  	break;  case Keys.LowerF:  	{  		int offset;  		byte[] buffer = this.BufferReader.GetBuffer (5' out offset);  		// Check if it's "false"  		if (buffer [offset + 1] != Keys.LowerA || buffer [offset + 2] != Keys.LowerL || buffer [offset + 3] != Keys.LowerS || buffer [offset + 4] != Keys.LowerE)  			throw new Exception ("Expected False");  		// Advance of 5 byte  		this.BufferReader.Advance (5);  		// Check if char after is a closing one  		if (TryGetByte (out ch) && !IsWhitespace (ch) && (ch != Keys.Comma && ch != Keys.RightClosingBrace) && ch != Keys.RightClosingBracket)  			throw new Exception ("TokenExpected");  		// Move  		this.MoveToAtomicText ().Value.SetValue (ValueHandleType.UTF8' offset' 5);  	}  	break;  case Keys.LowerT:  	{  		int offset;  		// check if it's "true"  		byte[] buffer = this.BufferReader.GetBuffer (4' out offset);  		if (buffer [offset + 1] != Keys.LowerR || buffer [offset + 2] != Keys.LowerU || buffer [offset + 3] != Keys.LowerE)  			throw new Exception ("expected true");  		this.BufferReader.Advance (4);  		// Check if char after is a closing one  		if (TryGetByte (out ch) && !IsWhitespace (ch) && (ch != Keys.Comma && ch != Keys.RightClosingBrace) && ch != Keys.RightClosingBracket)  			throw new Exception ("TokenExpected");  		// move atomic  		this.MoveToAtomicText ().Value.SetValue (ValueHandleType.UTF8' offset' 4);  	}  	break;  case Keys.LowerN:  	{  		int offset;  		// check if it's "null"  		byte[] buffer = this.BufferReader.GetBuffer (4' out offset);  		if (buffer [offset + 1] != Keys.LowerU || buffer [offset + 2] != Keys.LowerL || buffer [offset + 3] != Keys.LowerL)  			throw new Exception ("Expected null");  		// advance of 4 chars  		this.BufferReader.Advance (4);  		SkipWhitespaceInBufferReader ();  		if (TryGetByte (out ch)) {  			if (ch == Keys.Comma || ch == Keys.RightClosingBrace)  				this.BufferReader.SkipByte ();  			else if (ch != Keys.RightClosingBracket)  				throw new Exception ("TokenExpected");  		}  		else {  			charactersToSkipOnNextRead [0] = Keys.Comma;  			charactersToSkipOnNextRead [1] = Keys.RightClosingBrace;  		}  		MoveToEndElement ();  	}  	break;  default:  	if ((ch == (byte)'-') || (((byte)'0' <= ch) && (ch <= (byte)'9')) || (ch == (byte)'I') || (ch == (byte)'N'))  		ReadNumericalText ();  	else  		throw new XmlException ("JsonEncounteredUnexpectedCharacter");  	break;  }  
Magic Number,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,Read,The following statement contains a magic number: switch (ch) {  case Keys.RightClosingBracket:  	this.BufferReader.SkipByte ();  	MoveToEndElement ();  	ExitJsonScope ();  	break;  case Keys.LeftOpeningBrace:  	this.BufferReader.SkipByte ();  	SkipWhitespaceInBufferReader ();  	ch = this.BufferReader.GetByte ();  	if (ch == Keys.RightClosingBrace) {  		// Skip this byte  		this.BufferReader.SkipByte ();  		// Skip white spaces  		SkipWhitespaceInBufferReader ();  		// try get next char  		if (TryGetByte (out ch)) {  			if (ch == Keys.Comma)  				this.BufferReader.SkipByte ();  		}  		else {  			// We are at end of buffer' just mark Comma to be skipped next time  			charactersToSkipOnNextRead [0] = Keys.Comma;  		}  		// We set to End Element  		MoveToEndElement ();  	}  	else {  		// Enter a new scope  		EnterJsonScope (JsonNodeType.Object);  		// Parse start element  		ParseStartElement ();  	}  	break;  case Keys.RightClosingBrace:  	this.BufferReader.SkipByte ();  	if (expectingFirstElementInNonPrimitiveChild) {  		SkipWhitespaceInBufferReader ();  		ch = this.BufferReader.GetByte ();  		switch (ch) {  		case Keys.Comma:  		case Keys.RightClosingBrace:  			this.BufferReader.SkipByte ();  			break;  		default:  			throw new XmlException ("JsonEncounteredUnexpectedCharacter");  		}  		expectingFirstElementInNonPrimitiveChild = false;  	}  	MoveToEndElement ();  	break;  case Keys.Comma:  	this.BufferReader.SkipByte ();  	MoveToEndElement ();  	break;  case Keys.DoubleQuote:  	if (this.Node.NodeType == XmlNodeType.Element) {  		if (expectingFirstElementInNonPrimitiveChild) {  			EnterJsonScope (JsonNodeType.Object);  			ParseStartElement ();  		}  		else {  			this.BufferReader.SkipByte ();  			ReadQuotedText (true);  		}  	}  	else if (this.Node.NodeType == XmlNodeType.EndElement) {  		EnterJsonScope (JsonNodeType.Element);  		ParseStartElement ();  	}  	else  		throw new XmlException ("JsonEncounteredUnexpectedCharacter");  	break;  case Keys.LowerF:  	{  		int offset;  		byte[] buffer = this.BufferReader.GetBuffer (5' out offset);  		// Check if it's "false"  		if (buffer [offset + 1] != Keys.LowerA || buffer [offset + 2] != Keys.LowerL || buffer [offset + 3] != Keys.LowerS || buffer [offset + 4] != Keys.LowerE)  			throw new Exception ("Expected False");  		// Advance of 5 byte  		this.BufferReader.Advance (5);  		// Check if char after is a closing one  		if (TryGetByte (out ch) && !IsWhitespace (ch) && (ch != Keys.Comma && ch != Keys.RightClosingBrace) && ch != Keys.RightClosingBracket)  			throw new Exception ("TokenExpected");  		// Move  		this.MoveToAtomicText ().Value.SetValue (ValueHandleType.UTF8' offset' 5);  	}  	break;  case Keys.LowerT:  	{  		int offset;  		// check if it's "true"  		byte[] buffer = this.BufferReader.GetBuffer (4' out offset);  		if (buffer [offset + 1] != Keys.LowerR || buffer [offset + 2] != Keys.LowerU || buffer [offset + 3] != Keys.LowerE)  			throw new Exception ("expected true");  		this.BufferReader.Advance (4);  		// Check if char after is a closing one  		if (TryGetByte (out ch) && !IsWhitespace (ch) && (ch != Keys.Comma && ch != Keys.RightClosingBrace) && ch != Keys.RightClosingBracket)  			throw new Exception ("TokenExpected");  		// move atomic  		this.MoveToAtomicText ().Value.SetValue (ValueHandleType.UTF8' offset' 4);  	}  	break;  case Keys.LowerN:  	{  		int offset;  		// check if it's "null"  		byte[] buffer = this.BufferReader.GetBuffer (4' out offset);  		if (buffer [offset + 1] != Keys.LowerU || buffer [offset + 2] != Keys.LowerL || buffer [offset + 3] != Keys.LowerL)  			throw new Exception ("Expected null");  		// advance of 4 chars  		this.BufferReader.Advance (4);  		SkipWhitespaceInBufferReader ();  		if (TryGetByte (out ch)) {  			if (ch == Keys.Comma || ch == Keys.RightClosingBrace)  				this.BufferReader.SkipByte ();  			else if (ch != Keys.RightClosingBracket)  				throw new Exception ("TokenExpected");  		}  		else {  			charactersToSkipOnNextRead [0] = Keys.Comma;  			charactersToSkipOnNextRead [1] = Keys.RightClosingBrace;  		}  		MoveToEndElement ();  	}  	break;  default:  	if ((ch == (byte)'-') || (((byte)'0' <= ch) && (ch <= (byte)'9')) || (ch == (byte)'I') || (ch == (byte)'N'))  		ReadNumericalText ();  	else  		throw new XmlException ("JsonEncounteredUnexpectedCharacter");  	break;  }  
Magic Number,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,Read,The following statement contains a magic number: switch (ch) {  case Keys.RightClosingBracket:  	this.BufferReader.SkipByte ();  	MoveToEndElement ();  	ExitJsonScope ();  	break;  case Keys.LeftOpeningBrace:  	this.BufferReader.SkipByte ();  	SkipWhitespaceInBufferReader ();  	ch = this.BufferReader.GetByte ();  	if (ch == Keys.RightClosingBrace) {  		// Skip this byte  		this.BufferReader.SkipByte ();  		// Skip white spaces  		SkipWhitespaceInBufferReader ();  		// try get next char  		if (TryGetByte (out ch)) {  			if (ch == Keys.Comma)  				this.BufferReader.SkipByte ();  		}  		else {  			// We are at end of buffer' just mark Comma to be skipped next time  			charactersToSkipOnNextRead [0] = Keys.Comma;  		}  		// We set to End Element  		MoveToEndElement ();  	}  	else {  		// Enter a new scope  		EnterJsonScope (JsonNodeType.Object);  		// Parse start element  		ParseStartElement ();  	}  	break;  case Keys.RightClosingBrace:  	this.BufferReader.SkipByte ();  	if (expectingFirstElementInNonPrimitiveChild) {  		SkipWhitespaceInBufferReader ();  		ch = this.BufferReader.GetByte ();  		switch (ch) {  		case Keys.Comma:  		case Keys.RightClosingBrace:  			this.BufferReader.SkipByte ();  			break;  		default:  			throw new XmlException ("JsonEncounteredUnexpectedCharacter");  		}  		expectingFirstElementInNonPrimitiveChild = false;  	}  	MoveToEndElement ();  	break;  case Keys.Comma:  	this.BufferReader.SkipByte ();  	MoveToEndElement ();  	break;  case Keys.DoubleQuote:  	if (this.Node.NodeType == XmlNodeType.Element) {  		if (expectingFirstElementInNonPrimitiveChild) {  			EnterJsonScope (JsonNodeType.Object);  			ParseStartElement ();  		}  		else {  			this.BufferReader.SkipByte ();  			ReadQuotedText (true);  		}  	}  	else if (this.Node.NodeType == XmlNodeType.EndElement) {  		EnterJsonScope (JsonNodeType.Element);  		ParseStartElement ();  	}  	else  		throw new XmlException ("JsonEncounteredUnexpectedCharacter");  	break;  case Keys.LowerF:  	{  		int offset;  		byte[] buffer = this.BufferReader.GetBuffer (5' out offset);  		// Check if it's "false"  		if (buffer [offset + 1] != Keys.LowerA || buffer [offset + 2] != Keys.LowerL || buffer [offset + 3] != Keys.LowerS || buffer [offset + 4] != Keys.LowerE)  			throw new Exception ("Expected False");  		// Advance of 5 byte  		this.BufferReader.Advance (5);  		// Check if char after is a closing one  		if (TryGetByte (out ch) && !IsWhitespace (ch) && (ch != Keys.Comma && ch != Keys.RightClosingBrace) && ch != Keys.RightClosingBracket)  			throw new Exception ("TokenExpected");  		// Move  		this.MoveToAtomicText ().Value.SetValue (ValueHandleType.UTF8' offset' 5);  	}  	break;  case Keys.LowerT:  	{  		int offset;  		// check if it's "true"  		byte[] buffer = this.BufferReader.GetBuffer (4' out offset);  		if (buffer [offset + 1] != Keys.LowerR || buffer [offset + 2] != Keys.LowerU || buffer [offset + 3] != Keys.LowerE)  			throw new Exception ("expected true");  		this.BufferReader.Advance (4);  		// Check if char after is a closing one  		if (TryGetByte (out ch) && !IsWhitespace (ch) && (ch != Keys.Comma && ch != Keys.RightClosingBrace) && ch != Keys.RightClosingBracket)  			throw new Exception ("TokenExpected");  		// move atomic  		this.MoveToAtomicText ().Value.SetValue (ValueHandleType.UTF8' offset' 4);  	}  	break;  case Keys.LowerN:  	{  		int offset;  		// check if it's "null"  		byte[] buffer = this.BufferReader.GetBuffer (4' out offset);  		if (buffer [offset + 1] != Keys.LowerU || buffer [offset + 2] != Keys.LowerL || buffer [offset + 3] != Keys.LowerL)  			throw new Exception ("Expected null");  		// advance of 4 chars  		this.BufferReader.Advance (4);  		SkipWhitespaceInBufferReader ();  		if (TryGetByte (out ch)) {  			if (ch == Keys.Comma || ch == Keys.RightClosingBrace)  				this.BufferReader.SkipByte ();  			else if (ch != Keys.RightClosingBracket)  				throw new Exception ("TokenExpected");  		}  		else {  			charactersToSkipOnNextRead [0] = Keys.Comma;  			charactersToSkipOnNextRead [1] = Keys.RightClosingBrace;  		}  		MoveToEndElement ();  	}  	break;  default:  	if ((ch == (byte)'-') || (((byte)'0' <= ch) && (ch <= (byte)'9')) || (ch == (byte)'I') || (ch == (byte)'N'))  		ReadNumericalText ();  	else  		throw new XmlException ("JsonEncounteredUnexpectedCharacter");  	break;  }  
Magic Number,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,Read,The following statement contains a magic number: switch (ch) {  case Keys.RightClosingBracket:  	this.BufferReader.SkipByte ();  	MoveToEndElement ();  	ExitJsonScope ();  	break;  case Keys.LeftOpeningBrace:  	this.BufferReader.SkipByte ();  	SkipWhitespaceInBufferReader ();  	ch = this.BufferReader.GetByte ();  	if (ch == Keys.RightClosingBrace) {  		// Skip this byte  		this.BufferReader.SkipByte ();  		// Skip white spaces  		SkipWhitespaceInBufferReader ();  		// try get next char  		if (TryGetByte (out ch)) {  			if (ch == Keys.Comma)  				this.BufferReader.SkipByte ();  		}  		else {  			// We are at end of buffer' just mark Comma to be skipped next time  			charactersToSkipOnNextRead [0] = Keys.Comma;  		}  		// We set to End Element  		MoveToEndElement ();  	}  	else {  		// Enter a new scope  		EnterJsonScope (JsonNodeType.Object);  		// Parse start element  		ParseStartElement ();  	}  	break;  case Keys.RightClosingBrace:  	this.BufferReader.SkipByte ();  	if (expectingFirstElementInNonPrimitiveChild) {  		SkipWhitespaceInBufferReader ();  		ch = this.BufferReader.GetByte ();  		switch (ch) {  		case Keys.Comma:  		case Keys.RightClosingBrace:  			this.BufferReader.SkipByte ();  			break;  		default:  			throw new XmlException ("JsonEncounteredUnexpectedCharacter");  		}  		expectingFirstElementInNonPrimitiveChild = false;  	}  	MoveToEndElement ();  	break;  case Keys.Comma:  	this.BufferReader.SkipByte ();  	MoveToEndElement ();  	break;  case Keys.DoubleQuote:  	if (this.Node.NodeType == XmlNodeType.Element) {  		if (expectingFirstElementInNonPrimitiveChild) {  			EnterJsonScope (JsonNodeType.Object);  			ParseStartElement ();  		}  		else {  			this.BufferReader.SkipByte ();  			ReadQuotedText (true);  		}  	}  	else if (this.Node.NodeType == XmlNodeType.EndElement) {  		EnterJsonScope (JsonNodeType.Element);  		ParseStartElement ();  	}  	else  		throw new XmlException ("JsonEncounteredUnexpectedCharacter");  	break;  case Keys.LowerF:  	{  		int offset;  		byte[] buffer = this.BufferReader.GetBuffer (5' out offset);  		// Check if it's "false"  		if (buffer [offset + 1] != Keys.LowerA || buffer [offset + 2] != Keys.LowerL || buffer [offset + 3] != Keys.LowerS || buffer [offset + 4] != Keys.LowerE)  			throw new Exception ("Expected False");  		// Advance of 5 byte  		this.BufferReader.Advance (5);  		// Check if char after is a closing one  		if (TryGetByte (out ch) && !IsWhitespace (ch) && (ch != Keys.Comma && ch != Keys.RightClosingBrace) && ch != Keys.RightClosingBracket)  			throw new Exception ("TokenExpected");  		// Move  		this.MoveToAtomicText ().Value.SetValue (ValueHandleType.UTF8' offset' 5);  	}  	break;  case Keys.LowerT:  	{  		int offset;  		// check if it's "true"  		byte[] buffer = this.BufferReader.GetBuffer (4' out offset);  		if (buffer [offset + 1] != Keys.LowerR || buffer [offset + 2] != Keys.LowerU || buffer [offset + 3] != Keys.LowerE)  			throw new Exception ("expected true");  		this.BufferReader.Advance (4);  		// Check if char after is a closing one  		if (TryGetByte (out ch) && !IsWhitespace (ch) && (ch != Keys.Comma && ch != Keys.RightClosingBrace) && ch != Keys.RightClosingBracket)  			throw new Exception ("TokenExpected");  		// move atomic  		this.MoveToAtomicText ().Value.SetValue (ValueHandleType.UTF8' offset' 4);  	}  	break;  case Keys.LowerN:  	{  		int offset;  		// check if it's "null"  		byte[] buffer = this.BufferReader.GetBuffer (4' out offset);  		if (buffer [offset + 1] != Keys.LowerU || buffer [offset + 2] != Keys.LowerL || buffer [offset + 3] != Keys.LowerL)  			throw new Exception ("Expected null");  		// advance of 4 chars  		this.BufferReader.Advance (4);  		SkipWhitespaceInBufferReader ();  		if (TryGetByte (out ch)) {  			if (ch == Keys.Comma || ch == Keys.RightClosingBrace)  				this.BufferReader.SkipByte ();  			else if (ch != Keys.RightClosingBracket)  				throw new Exception ("TokenExpected");  		}  		else {  			charactersToSkipOnNextRead [0] = Keys.Comma;  			charactersToSkipOnNextRead [1] = Keys.RightClosingBrace;  		}  		MoveToEndElement ();  	}  	break;  default:  	if ((ch == (byte)'-') || (((byte)'0' <= ch) && (ch <= (byte)'9')) || (ch == (byte)'I') || (ch == (byte)'N'))  		ReadNumericalText ();  	else  		throw new XmlException ("JsonEncounteredUnexpectedCharacter");  	break;  }  
Magic Number,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,Read,The following statement contains a magic number: switch (ch) {  case Keys.RightClosingBracket:  	this.BufferReader.SkipByte ();  	MoveToEndElement ();  	ExitJsonScope ();  	break;  case Keys.LeftOpeningBrace:  	this.BufferReader.SkipByte ();  	SkipWhitespaceInBufferReader ();  	ch = this.BufferReader.GetByte ();  	if (ch == Keys.RightClosingBrace) {  		// Skip this byte  		this.BufferReader.SkipByte ();  		// Skip white spaces  		SkipWhitespaceInBufferReader ();  		// try get next char  		if (TryGetByte (out ch)) {  			if (ch == Keys.Comma)  				this.BufferReader.SkipByte ();  		}  		else {  			// We are at end of buffer' just mark Comma to be skipped next time  			charactersToSkipOnNextRead [0] = Keys.Comma;  		}  		// We set to End Element  		MoveToEndElement ();  	}  	else {  		// Enter a new scope  		EnterJsonScope (JsonNodeType.Object);  		// Parse start element  		ParseStartElement ();  	}  	break;  case Keys.RightClosingBrace:  	this.BufferReader.SkipByte ();  	if (expectingFirstElementInNonPrimitiveChild) {  		SkipWhitespaceInBufferReader ();  		ch = this.BufferReader.GetByte ();  		switch (ch) {  		case Keys.Comma:  		case Keys.RightClosingBrace:  			this.BufferReader.SkipByte ();  			break;  		default:  			throw new XmlException ("JsonEncounteredUnexpectedCharacter");  		}  		expectingFirstElementInNonPrimitiveChild = false;  	}  	MoveToEndElement ();  	break;  case Keys.Comma:  	this.BufferReader.SkipByte ();  	MoveToEndElement ();  	break;  case Keys.DoubleQuote:  	if (this.Node.NodeType == XmlNodeType.Element) {  		if (expectingFirstElementInNonPrimitiveChild) {  			EnterJsonScope (JsonNodeType.Object);  			ParseStartElement ();  		}  		else {  			this.BufferReader.SkipByte ();  			ReadQuotedText (true);  		}  	}  	else if (this.Node.NodeType == XmlNodeType.EndElement) {  		EnterJsonScope (JsonNodeType.Element);  		ParseStartElement ();  	}  	else  		throw new XmlException ("JsonEncounteredUnexpectedCharacter");  	break;  case Keys.LowerF:  	{  		int offset;  		byte[] buffer = this.BufferReader.GetBuffer (5' out offset);  		// Check if it's "false"  		if (buffer [offset + 1] != Keys.LowerA || buffer [offset + 2] != Keys.LowerL || buffer [offset + 3] != Keys.LowerS || buffer [offset + 4] != Keys.LowerE)  			throw new Exception ("Expected False");  		// Advance of 5 byte  		this.BufferReader.Advance (5);  		// Check if char after is a closing one  		if (TryGetByte (out ch) && !IsWhitespace (ch) && (ch != Keys.Comma && ch != Keys.RightClosingBrace) && ch != Keys.RightClosingBracket)  			throw new Exception ("TokenExpected");  		// Move  		this.MoveToAtomicText ().Value.SetValue (ValueHandleType.UTF8' offset' 5);  	}  	break;  case Keys.LowerT:  	{  		int offset;  		// check if it's "true"  		byte[] buffer = this.BufferReader.GetBuffer (4' out offset);  		if (buffer [offset + 1] != Keys.LowerR || buffer [offset + 2] != Keys.LowerU || buffer [offset + 3] != Keys.LowerE)  			throw new Exception ("expected true");  		this.BufferReader.Advance (4);  		// Check if char after is a closing one  		if (TryGetByte (out ch) && !IsWhitespace (ch) && (ch != Keys.Comma && ch != Keys.RightClosingBrace) && ch != Keys.RightClosingBracket)  			throw new Exception ("TokenExpected");  		// move atomic  		this.MoveToAtomicText ().Value.SetValue (ValueHandleType.UTF8' offset' 4);  	}  	break;  case Keys.LowerN:  	{  		int offset;  		// check if it's "null"  		byte[] buffer = this.BufferReader.GetBuffer (4' out offset);  		if (buffer [offset + 1] != Keys.LowerU || buffer [offset + 2] != Keys.LowerL || buffer [offset + 3] != Keys.LowerL)  			throw new Exception ("Expected null");  		// advance of 4 chars  		this.BufferReader.Advance (4);  		SkipWhitespaceInBufferReader ();  		if (TryGetByte (out ch)) {  			if (ch == Keys.Comma || ch == Keys.RightClosingBrace)  				this.BufferReader.SkipByte ();  			else if (ch != Keys.RightClosingBracket)  				throw new Exception ("TokenExpected");  		}  		else {  			charactersToSkipOnNextRead [0] = Keys.Comma;  			charactersToSkipOnNextRead [1] = Keys.RightClosingBrace;  		}  		MoveToEndElement ();  	}  	break;  default:  	if ((ch == (byte)'-') || (((byte)'0' <= ch) && (ch <= (byte)'9')) || (ch == (byte)'I') || (ch == (byte)'N'))  		ReadNumericalText ();  	else  		throw new XmlException ("JsonEncounteredUnexpectedCharacter");  	break;  }  
Magic Number,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,Read,The following statement contains a magic number: switch (ch) {  case Keys.RightClosingBracket:  	this.BufferReader.SkipByte ();  	MoveToEndElement ();  	ExitJsonScope ();  	break;  case Keys.LeftOpeningBrace:  	this.BufferReader.SkipByte ();  	SkipWhitespaceInBufferReader ();  	ch = this.BufferReader.GetByte ();  	if (ch == Keys.RightClosingBrace) {  		// Skip this byte  		this.BufferReader.SkipByte ();  		// Skip white spaces  		SkipWhitespaceInBufferReader ();  		// try get next char  		if (TryGetByte (out ch)) {  			if (ch == Keys.Comma)  				this.BufferReader.SkipByte ();  		}  		else {  			// We are at end of buffer' just mark Comma to be skipped next time  			charactersToSkipOnNextRead [0] = Keys.Comma;  		}  		// We set to End Element  		MoveToEndElement ();  	}  	else {  		// Enter a new scope  		EnterJsonScope (JsonNodeType.Object);  		// Parse start element  		ParseStartElement ();  	}  	break;  case Keys.RightClosingBrace:  	this.BufferReader.SkipByte ();  	if (expectingFirstElementInNonPrimitiveChild) {  		SkipWhitespaceInBufferReader ();  		ch = this.BufferReader.GetByte ();  		switch (ch) {  		case Keys.Comma:  		case Keys.RightClosingBrace:  			this.BufferReader.SkipByte ();  			break;  		default:  			throw new XmlException ("JsonEncounteredUnexpectedCharacter");  		}  		expectingFirstElementInNonPrimitiveChild = false;  	}  	MoveToEndElement ();  	break;  case Keys.Comma:  	this.BufferReader.SkipByte ();  	MoveToEndElement ();  	break;  case Keys.DoubleQuote:  	if (this.Node.NodeType == XmlNodeType.Element) {  		if (expectingFirstElementInNonPrimitiveChild) {  			EnterJsonScope (JsonNodeType.Object);  			ParseStartElement ();  		}  		else {  			this.BufferReader.SkipByte ();  			ReadQuotedText (true);  		}  	}  	else if (this.Node.NodeType == XmlNodeType.EndElement) {  		EnterJsonScope (JsonNodeType.Element);  		ParseStartElement ();  	}  	else  		throw new XmlException ("JsonEncounteredUnexpectedCharacter");  	break;  case Keys.LowerF:  	{  		int offset;  		byte[] buffer = this.BufferReader.GetBuffer (5' out offset);  		// Check if it's "false"  		if (buffer [offset + 1] != Keys.LowerA || buffer [offset + 2] != Keys.LowerL || buffer [offset + 3] != Keys.LowerS || buffer [offset + 4] != Keys.LowerE)  			throw new Exception ("Expected False");  		// Advance of 5 byte  		this.BufferReader.Advance (5);  		// Check if char after is a closing one  		if (TryGetByte (out ch) && !IsWhitespace (ch) && (ch != Keys.Comma && ch != Keys.RightClosingBrace) && ch != Keys.RightClosingBracket)  			throw new Exception ("TokenExpected");  		// Move  		this.MoveToAtomicText ().Value.SetValue (ValueHandleType.UTF8' offset' 5);  	}  	break;  case Keys.LowerT:  	{  		int offset;  		// check if it's "true"  		byte[] buffer = this.BufferReader.GetBuffer (4' out offset);  		if (buffer [offset + 1] != Keys.LowerR || buffer [offset + 2] != Keys.LowerU || buffer [offset + 3] != Keys.LowerE)  			throw new Exception ("expected true");  		this.BufferReader.Advance (4);  		// Check if char after is a closing one  		if (TryGetByte (out ch) && !IsWhitespace (ch) && (ch != Keys.Comma && ch != Keys.RightClosingBrace) && ch != Keys.RightClosingBracket)  			throw new Exception ("TokenExpected");  		// move atomic  		this.MoveToAtomicText ().Value.SetValue (ValueHandleType.UTF8' offset' 4);  	}  	break;  case Keys.LowerN:  	{  		int offset;  		// check if it's "null"  		byte[] buffer = this.BufferReader.GetBuffer (4' out offset);  		if (buffer [offset + 1] != Keys.LowerU || buffer [offset + 2] != Keys.LowerL || buffer [offset + 3] != Keys.LowerL)  			throw new Exception ("Expected null");  		// advance of 4 chars  		this.BufferReader.Advance (4);  		SkipWhitespaceInBufferReader ();  		if (TryGetByte (out ch)) {  			if (ch == Keys.Comma || ch == Keys.RightClosingBrace)  				this.BufferReader.SkipByte ();  			else if (ch != Keys.RightClosingBracket)  				throw new Exception ("TokenExpected");  		}  		else {  			charactersToSkipOnNextRead [0] = Keys.Comma;  			charactersToSkipOnNextRead [1] = Keys.RightClosingBrace;  		}  		MoveToEndElement ();  	}  	break;  default:  	if ((ch == (byte)'-') || (((byte)'0' <= ch) && (ch <= (byte)'9')) || (ch == (byte)'I') || (ch == (byte)'N'))  		ReadNumericalText ();  	else  		throw new XmlException ("JsonEncounteredUnexpectedCharacter");  	break;  }  
Magic Number,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,Read,The following statement contains a magic number: switch (ch) {  case Keys.RightClosingBracket:  	this.BufferReader.SkipByte ();  	MoveToEndElement ();  	ExitJsonScope ();  	break;  case Keys.LeftOpeningBrace:  	this.BufferReader.SkipByte ();  	SkipWhitespaceInBufferReader ();  	ch = this.BufferReader.GetByte ();  	if (ch == Keys.RightClosingBrace) {  		// Skip this byte  		this.BufferReader.SkipByte ();  		// Skip white spaces  		SkipWhitespaceInBufferReader ();  		// try get next char  		if (TryGetByte (out ch)) {  			if (ch == Keys.Comma)  				this.BufferReader.SkipByte ();  		}  		else {  			// We are at end of buffer' just mark Comma to be skipped next time  			charactersToSkipOnNextRead [0] = Keys.Comma;  		}  		// We set to End Element  		MoveToEndElement ();  	}  	else {  		// Enter a new scope  		EnterJsonScope (JsonNodeType.Object);  		// Parse start element  		ParseStartElement ();  	}  	break;  case Keys.RightClosingBrace:  	this.BufferReader.SkipByte ();  	if (expectingFirstElementInNonPrimitiveChild) {  		SkipWhitespaceInBufferReader ();  		ch = this.BufferReader.GetByte ();  		switch (ch) {  		case Keys.Comma:  		case Keys.RightClosingBrace:  			this.BufferReader.SkipByte ();  			break;  		default:  			throw new XmlException ("JsonEncounteredUnexpectedCharacter");  		}  		expectingFirstElementInNonPrimitiveChild = false;  	}  	MoveToEndElement ();  	break;  case Keys.Comma:  	this.BufferReader.SkipByte ();  	MoveToEndElement ();  	break;  case Keys.DoubleQuote:  	if (this.Node.NodeType == XmlNodeType.Element) {  		if (expectingFirstElementInNonPrimitiveChild) {  			EnterJsonScope (JsonNodeType.Object);  			ParseStartElement ();  		}  		else {  			this.BufferReader.SkipByte ();  			ReadQuotedText (true);  		}  	}  	else if (this.Node.NodeType == XmlNodeType.EndElement) {  		EnterJsonScope (JsonNodeType.Element);  		ParseStartElement ();  	}  	else  		throw new XmlException ("JsonEncounteredUnexpectedCharacter");  	break;  case Keys.LowerF:  	{  		int offset;  		byte[] buffer = this.BufferReader.GetBuffer (5' out offset);  		// Check if it's "false"  		if (buffer [offset + 1] != Keys.LowerA || buffer [offset + 2] != Keys.LowerL || buffer [offset + 3] != Keys.LowerS || buffer [offset + 4] != Keys.LowerE)  			throw new Exception ("Expected False");  		// Advance of 5 byte  		this.BufferReader.Advance (5);  		// Check if char after is a closing one  		if (TryGetByte (out ch) && !IsWhitespace (ch) && (ch != Keys.Comma && ch != Keys.RightClosingBrace) && ch != Keys.RightClosingBracket)  			throw new Exception ("TokenExpected");  		// Move  		this.MoveToAtomicText ().Value.SetValue (ValueHandleType.UTF8' offset' 5);  	}  	break;  case Keys.LowerT:  	{  		int offset;  		// check if it's "true"  		byte[] buffer = this.BufferReader.GetBuffer (4' out offset);  		if (buffer [offset + 1] != Keys.LowerR || buffer [offset + 2] != Keys.LowerU || buffer [offset + 3] != Keys.LowerE)  			throw new Exception ("expected true");  		this.BufferReader.Advance (4);  		// Check if char after is a closing one  		if (TryGetByte (out ch) && !IsWhitespace (ch) && (ch != Keys.Comma && ch != Keys.RightClosingBrace) && ch != Keys.RightClosingBracket)  			throw new Exception ("TokenExpected");  		// move atomic  		this.MoveToAtomicText ().Value.SetValue (ValueHandleType.UTF8' offset' 4);  	}  	break;  case Keys.LowerN:  	{  		int offset;  		// check if it's "null"  		byte[] buffer = this.BufferReader.GetBuffer (4' out offset);  		if (buffer [offset + 1] != Keys.LowerU || buffer [offset + 2] != Keys.LowerL || buffer [offset + 3] != Keys.LowerL)  			throw new Exception ("Expected null");  		// advance of 4 chars  		this.BufferReader.Advance (4);  		SkipWhitespaceInBufferReader ();  		if (TryGetByte (out ch)) {  			if (ch == Keys.Comma || ch == Keys.RightClosingBrace)  				this.BufferReader.SkipByte ();  			else if (ch != Keys.RightClosingBracket)  				throw new Exception ("TokenExpected");  		}  		else {  			charactersToSkipOnNextRead [0] = Keys.Comma;  			charactersToSkipOnNextRead [1] = Keys.RightClosingBrace;  		}  		MoveToEndElement ();  	}  	break;  default:  	if ((ch == (byte)'-') || (((byte)'0' <= ch) && (ch <= (byte)'9')) || (ch == (byte)'I') || (ch == (byte)'N'))  		ReadNumericalText ();  	else  		throw new XmlException ("JsonEncounteredUnexpectedCharacter");  	break;  }  
Magic Number,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,Read,The following statement contains a magic number: switch (ch) {  case Keys.RightClosingBracket:  	this.BufferReader.SkipByte ();  	MoveToEndElement ();  	ExitJsonScope ();  	break;  case Keys.LeftOpeningBrace:  	this.BufferReader.SkipByte ();  	SkipWhitespaceInBufferReader ();  	ch = this.BufferReader.GetByte ();  	if (ch == Keys.RightClosingBrace) {  		// Skip this byte  		this.BufferReader.SkipByte ();  		// Skip white spaces  		SkipWhitespaceInBufferReader ();  		// try get next char  		if (TryGetByte (out ch)) {  			if (ch == Keys.Comma)  				this.BufferReader.SkipByte ();  		}  		else {  			// We are at end of buffer' just mark Comma to be skipped next time  			charactersToSkipOnNextRead [0] = Keys.Comma;  		}  		// We set to End Element  		MoveToEndElement ();  	}  	else {  		// Enter a new scope  		EnterJsonScope (JsonNodeType.Object);  		// Parse start element  		ParseStartElement ();  	}  	break;  case Keys.RightClosingBrace:  	this.BufferReader.SkipByte ();  	if (expectingFirstElementInNonPrimitiveChild) {  		SkipWhitespaceInBufferReader ();  		ch = this.BufferReader.GetByte ();  		switch (ch) {  		case Keys.Comma:  		case Keys.RightClosingBrace:  			this.BufferReader.SkipByte ();  			break;  		default:  			throw new XmlException ("JsonEncounteredUnexpectedCharacter");  		}  		expectingFirstElementInNonPrimitiveChild = false;  	}  	MoveToEndElement ();  	break;  case Keys.Comma:  	this.BufferReader.SkipByte ();  	MoveToEndElement ();  	break;  case Keys.DoubleQuote:  	if (this.Node.NodeType == XmlNodeType.Element) {  		if (expectingFirstElementInNonPrimitiveChild) {  			EnterJsonScope (JsonNodeType.Object);  			ParseStartElement ();  		}  		else {  			this.BufferReader.SkipByte ();  			ReadQuotedText (true);  		}  	}  	else if (this.Node.NodeType == XmlNodeType.EndElement) {  		EnterJsonScope (JsonNodeType.Element);  		ParseStartElement ();  	}  	else  		throw new XmlException ("JsonEncounteredUnexpectedCharacter");  	break;  case Keys.LowerF:  	{  		int offset;  		byte[] buffer = this.BufferReader.GetBuffer (5' out offset);  		// Check if it's "false"  		if (buffer [offset + 1] != Keys.LowerA || buffer [offset + 2] != Keys.LowerL || buffer [offset + 3] != Keys.LowerS || buffer [offset + 4] != Keys.LowerE)  			throw new Exception ("Expected False");  		// Advance of 5 byte  		this.BufferReader.Advance (5);  		// Check if char after is a closing one  		if (TryGetByte (out ch) && !IsWhitespace (ch) && (ch != Keys.Comma && ch != Keys.RightClosingBrace) && ch != Keys.RightClosingBracket)  			throw new Exception ("TokenExpected");  		// Move  		this.MoveToAtomicText ().Value.SetValue (ValueHandleType.UTF8' offset' 5);  	}  	break;  case Keys.LowerT:  	{  		int offset;  		// check if it's "true"  		byte[] buffer = this.BufferReader.GetBuffer (4' out offset);  		if (buffer [offset + 1] != Keys.LowerR || buffer [offset + 2] != Keys.LowerU || buffer [offset + 3] != Keys.LowerE)  			throw new Exception ("expected true");  		this.BufferReader.Advance (4);  		// Check if char after is a closing one  		if (TryGetByte (out ch) && !IsWhitespace (ch) && (ch != Keys.Comma && ch != Keys.RightClosingBrace) && ch != Keys.RightClosingBracket)  			throw new Exception ("TokenExpected");  		// move atomic  		this.MoveToAtomicText ().Value.SetValue (ValueHandleType.UTF8' offset' 4);  	}  	break;  case Keys.LowerN:  	{  		int offset;  		// check if it's "null"  		byte[] buffer = this.BufferReader.GetBuffer (4' out offset);  		if (buffer [offset + 1] != Keys.LowerU || buffer [offset + 2] != Keys.LowerL || buffer [offset + 3] != Keys.LowerL)  			throw new Exception ("Expected null");  		// advance of 4 chars  		this.BufferReader.Advance (4);  		SkipWhitespaceInBufferReader ();  		if (TryGetByte (out ch)) {  			if (ch == Keys.Comma || ch == Keys.RightClosingBrace)  				this.BufferReader.SkipByte ();  			else if (ch != Keys.RightClosingBracket)  				throw new Exception ("TokenExpected");  		}  		else {  			charactersToSkipOnNextRead [0] = Keys.Comma;  			charactersToSkipOnNextRead [1] = Keys.RightClosingBrace;  		}  		MoveToEndElement ();  	}  	break;  default:  	if ((ch == (byte)'-') || (((byte)'0' <= ch) && (ch <= (byte)'9')) || (ch == (byte)'I') || (ch == (byte)'N'))  		ReadNumericalText ();  	else  		throw new XmlException ("JsonEncounteredUnexpectedCharacter");  	break;  }  
Magic Number,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,Read,The following statement contains a magic number: switch (ch) {  case Keys.RightClosingBracket:  	this.BufferReader.SkipByte ();  	MoveToEndElement ();  	ExitJsonScope ();  	break;  case Keys.LeftOpeningBrace:  	this.BufferReader.SkipByte ();  	SkipWhitespaceInBufferReader ();  	ch = this.BufferReader.GetByte ();  	if (ch == Keys.RightClosingBrace) {  		// Skip this byte  		this.BufferReader.SkipByte ();  		// Skip white spaces  		SkipWhitespaceInBufferReader ();  		// try get next char  		if (TryGetByte (out ch)) {  			if (ch == Keys.Comma)  				this.BufferReader.SkipByte ();  		}  		else {  			// We are at end of buffer' just mark Comma to be skipped next time  			charactersToSkipOnNextRead [0] = Keys.Comma;  		}  		// We set to End Element  		MoveToEndElement ();  	}  	else {  		// Enter a new scope  		EnterJsonScope (JsonNodeType.Object);  		// Parse start element  		ParseStartElement ();  	}  	break;  case Keys.RightClosingBrace:  	this.BufferReader.SkipByte ();  	if (expectingFirstElementInNonPrimitiveChild) {  		SkipWhitespaceInBufferReader ();  		ch = this.BufferReader.GetByte ();  		switch (ch) {  		case Keys.Comma:  		case Keys.RightClosingBrace:  			this.BufferReader.SkipByte ();  			break;  		default:  			throw new XmlException ("JsonEncounteredUnexpectedCharacter");  		}  		expectingFirstElementInNonPrimitiveChild = false;  	}  	MoveToEndElement ();  	break;  case Keys.Comma:  	this.BufferReader.SkipByte ();  	MoveToEndElement ();  	break;  case Keys.DoubleQuote:  	if (this.Node.NodeType == XmlNodeType.Element) {  		if (expectingFirstElementInNonPrimitiveChild) {  			EnterJsonScope (JsonNodeType.Object);  			ParseStartElement ();  		}  		else {  			this.BufferReader.SkipByte ();  			ReadQuotedText (true);  		}  	}  	else if (this.Node.NodeType == XmlNodeType.EndElement) {  		EnterJsonScope (JsonNodeType.Element);  		ParseStartElement ();  	}  	else  		throw new XmlException ("JsonEncounteredUnexpectedCharacter");  	break;  case Keys.LowerF:  	{  		int offset;  		byte[] buffer = this.BufferReader.GetBuffer (5' out offset);  		// Check if it's "false"  		if (buffer [offset + 1] != Keys.LowerA || buffer [offset + 2] != Keys.LowerL || buffer [offset + 3] != Keys.LowerS || buffer [offset + 4] != Keys.LowerE)  			throw new Exception ("Expected False");  		// Advance of 5 byte  		this.BufferReader.Advance (5);  		// Check if char after is a closing one  		if (TryGetByte (out ch) && !IsWhitespace (ch) && (ch != Keys.Comma && ch != Keys.RightClosingBrace) && ch != Keys.RightClosingBracket)  			throw new Exception ("TokenExpected");  		// Move  		this.MoveToAtomicText ().Value.SetValue (ValueHandleType.UTF8' offset' 5);  	}  	break;  case Keys.LowerT:  	{  		int offset;  		// check if it's "true"  		byte[] buffer = this.BufferReader.GetBuffer (4' out offset);  		if (buffer [offset + 1] != Keys.LowerR || buffer [offset + 2] != Keys.LowerU || buffer [offset + 3] != Keys.LowerE)  			throw new Exception ("expected true");  		this.BufferReader.Advance (4);  		// Check if char after is a closing one  		if (TryGetByte (out ch) && !IsWhitespace (ch) && (ch != Keys.Comma && ch != Keys.RightClosingBrace) && ch != Keys.RightClosingBracket)  			throw new Exception ("TokenExpected");  		// move atomic  		this.MoveToAtomicText ().Value.SetValue (ValueHandleType.UTF8' offset' 4);  	}  	break;  case Keys.LowerN:  	{  		int offset;  		// check if it's "null"  		byte[] buffer = this.BufferReader.GetBuffer (4' out offset);  		if (buffer [offset + 1] != Keys.LowerU || buffer [offset + 2] != Keys.LowerL || buffer [offset + 3] != Keys.LowerL)  			throw new Exception ("Expected null");  		// advance of 4 chars  		this.BufferReader.Advance (4);  		SkipWhitespaceInBufferReader ();  		if (TryGetByte (out ch)) {  			if (ch == Keys.Comma || ch == Keys.RightClosingBrace)  				this.BufferReader.SkipByte ();  			else if (ch != Keys.RightClosingBracket)  				throw new Exception ("TokenExpected");  		}  		else {  			charactersToSkipOnNextRead [0] = Keys.Comma;  			charactersToSkipOnNextRead [1] = Keys.RightClosingBrace;  		}  		MoveToEndElement ();  	}  	break;  default:  	if ((ch == (byte)'-') || (((byte)'0' <= ch) && (ch <= (byte)'9')) || (ch == (byte)'I') || (ch == (byte)'N'))  		ReadNumericalText ();  	else  		throw new XmlException ("JsonEncounteredUnexpectedCharacter");  	break;  }  
Magic Number,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,Read,The following statement contains a magic number: switch (ch) {  case Keys.RightClosingBracket:  	this.BufferReader.SkipByte ();  	MoveToEndElement ();  	ExitJsonScope ();  	break;  case Keys.LeftOpeningBrace:  	this.BufferReader.SkipByte ();  	SkipWhitespaceInBufferReader ();  	ch = this.BufferReader.GetByte ();  	if (ch == Keys.RightClosingBrace) {  		// Skip this byte  		this.BufferReader.SkipByte ();  		// Skip white spaces  		SkipWhitespaceInBufferReader ();  		// try get next char  		if (TryGetByte (out ch)) {  			if (ch == Keys.Comma)  				this.BufferReader.SkipByte ();  		}  		else {  			// We are at end of buffer' just mark Comma to be skipped next time  			charactersToSkipOnNextRead [0] = Keys.Comma;  		}  		// We set to End Element  		MoveToEndElement ();  	}  	else {  		// Enter a new scope  		EnterJsonScope (JsonNodeType.Object);  		// Parse start element  		ParseStartElement ();  	}  	break;  case Keys.RightClosingBrace:  	this.BufferReader.SkipByte ();  	if (expectingFirstElementInNonPrimitiveChild) {  		SkipWhitespaceInBufferReader ();  		ch = this.BufferReader.GetByte ();  		switch (ch) {  		case Keys.Comma:  		case Keys.RightClosingBrace:  			this.BufferReader.SkipByte ();  			break;  		default:  			throw new XmlException ("JsonEncounteredUnexpectedCharacter");  		}  		expectingFirstElementInNonPrimitiveChild = false;  	}  	MoveToEndElement ();  	break;  case Keys.Comma:  	this.BufferReader.SkipByte ();  	MoveToEndElement ();  	break;  case Keys.DoubleQuote:  	if (this.Node.NodeType == XmlNodeType.Element) {  		if (expectingFirstElementInNonPrimitiveChild) {  			EnterJsonScope (JsonNodeType.Object);  			ParseStartElement ();  		}  		else {  			this.BufferReader.SkipByte ();  			ReadQuotedText (true);  		}  	}  	else if (this.Node.NodeType == XmlNodeType.EndElement) {  		EnterJsonScope (JsonNodeType.Element);  		ParseStartElement ();  	}  	else  		throw new XmlException ("JsonEncounteredUnexpectedCharacter");  	break;  case Keys.LowerF:  	{  		int offset;  		byte[] buffer = this.BufferReader.GetBuffer (5' out offset);  		// Check if it's "false"  		if (buffer [offset + 1] != Keys.LowerA || buffer [offset + 2] != Keys.LowerL || buffer [offset + 3] != Keys.LowerS || buffer [offset + 4] != Keys.LowerE)  			throw new Exception ("Expected False");  		// Advance of 5 byte  		this.BufferReader.Advance (5);  		// Check if char after is a closing one  		if (TryGetByte (out ch) && !IsWhitespace (ch) && (ch != Keys.Comma && ch != Keys.RightClosingBrace) && ch != Keys.RightClosingBracket)  			throw new Exception ("TokenExpected");  		// Move  		this.MoveToAtomicText ().Value.SetValue (ValueHandleType.UTF8' offset' 5);  	}  	break;  case Keys.LowerT:  	{  		int offset;  		// check if it's "true"  		byte[] buffer = this.BufferReader.GetBuffer (4' out offset);  		if (buffer [offset + 1] != Keys.LowerR || buffer [offset + 2] != Keys.LowerU || buffer [offset + 3] != Keys.LowerE)  			throw new Exception ("expected true");  		this.BufferReader.Advance (4);  		// Check if char after is a closing one  		if (TryGetByte (out ch) && !IsWhitespace (ch) && (ch != Keys.Comma && ch != Keys.RightClosingBrace) && ch != Keys.RightClosingBracket)  			throw new Exception ("TokenExpected");  		// move atomic  		this.MoveToAtomicText ().Value.SetValue (ValueHandleType.UTF8' offset' 4);  	}  	break;  case Keys.LowerN:  	{  		int offset;  		// check if it's "null"  		byte[] buffer = this.BufferReader.GetBuffer (4' out offset);  		if (buffer [offset + 1] != Keys.LowerU || buffer [offset + 2] != Keys.LowerL || buffer [offset + 3] != Keys.LowerL)  			throw new Exception ("Expected null");  		// advance of 4 chars  		this.BufferReader.Advance (4);  		SkipWhitespaceInBufferReader ();  		if (TryGetByte (out ch)) {  			if (ch == Keys.Comma || ch == Keys.RightClosingBrace)  				this.BufferReader.SkipByte ();  			else if (ch != Keys.RightClosingBracket)  				throw new Exception ("TokenExpected");  		}  		else {  			charactersToSkipOnNextRead [0] = Keys.Comma;  			charactersToSkipOnNextRead [1] = Keys.RightClosingBrace;  		}  		MoveToEndElement ();  	}  	break;  default:  	if ((ch == (byte)'-') || (((byte)'0' <= ch) && (ch <= (byte)'9')) || (ch == (byte)'I') || (ch == (byte)'N'))  		ReadNumericalText ();  	else  		throw new XmlException ("JsonEncounteredUnexpectedCharacter");  	break;  }  
Magic Number,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,Read,The following statement contains a magic number: switch (ch) {  case Keys.RightClosingBracket:  	this.BufferReader.SkipByte ();  	MoveToEndElement ();  	ExitJsonScope ();  	break;  case Keys.LeftOpeningBrace:  	this.BufferReader.SkipByte ();  	SkipWhitespaceInBufferReader ();  	ch = this.BufferReader.GetByte ();  	if (ch == Keys.RightClosingBrace) {  		// Skip this byte  		this.BufferReader.SkipByte ();  		// Skip white spaces  		SkipWhitespaceInBufferReader ();  		// try get next char  		if (TryGetByte (out ch)) {  			if (ch == Keys.Comma)  				this.BufferReader.SkipByte ();  		}  		else {  			// We are at end of buffer' just mark Comma to be skipped next time  			charactersToSkipOnNextRead [0] = Keys.Comma;  		}  		// We set to End Element  		MoveToEndElement ();  	}  	else {  		// Enter a new scope  		EnterJsonScope (JsonNodeType.Object);  		// Parse start element  		ParseStartElement ();  	}  	break;  case Keys.RightClosingBrace:  	this.BufferReader.SkipByte ();  	if (expectingFirstElementInNonPrimitiveChild) {  		SkipWhitespaceInBufferReader ();  		ch = this.BufferReader.GetByte ();  		switch (ch) {  		case Keys.Comma:  		case Keys.RightClosingBrace:  			this.BufferReader.SkipByte ();  			break;  		default:  			throw new XmlException ("JsonEncounteredUnexpectedCharacter");  		}  		expectingFirstElementInNonPrimitiveChild = false;  	}  	MoveToEndElement ();  	break;  case Keys.Comma:  	this.BufferReader.SkipByte ();  	MoveToEndElement ();  	break;  case Keys.DoubleQuote:  	if (this.Node.NodeType == XmlNodeType.Element) {  		if (expectingFirstElementInNonPrimitiveChild) {  			EnterJsonScope (JsonNodeType.Object);  			ParseStartElement ();  		}  		else {  			this.BufferReader.SkipByte ();  			ReadQuotedText (true);  		}  	}  	else if (this.Node.NodeType == XmlNodeType.EndElement) {  		EnterJsonScope (JsonNodeType.Element);  		ParseStartElement ();  	}  	else  		throw new XmlException ("JsonEncounteredUnexpectedCharacter");  	break;  case Keys.LowerF:  	{  		int offset;  		byte[] buffer = this.BufferReader.GetBuffer (5' out offset);  		// Check if it's "false"  		if (buffer [offset + 1] != Keys.LowerA || buffer [offset + 2] != Keys.LowerL || buffer [offset + 3] != Keys.LowerS || buffer [offset + 4] != Keys.LowerE)  			throw new Exception ("Expected False");  		// Advance of 5 byte  		this.BufferReader.Advance (5);  		// Check if char after is a closing one  		if (TryGetByte (out ch) && !IsWhitespace (ch) && (ch != Keys.Comma && ch != Keys.RightClosingBrace) && ch != Keys.RightClosingBracket)  			throw new Exception ("TokenExpected");  		// Move  		this.MoveToAtomicText ().Value.SetValue (ValueHandleType.UTF8' offset' 5);  	}  	break;  case Keys.LowerT:  	{  		int offset;  		// check if it's "true"  		byte[] buffer = this.BufferReader.GetBuffer (4' out offset);  		if (buffer [offset + 1] != Keys.LowerR || buffer [offset + 2] != Keys.LowerU || buffer [offset + 3] != Keys.LowerE)  			throw new Exception ("expected true");  		this.BufferReader.Advance (4);  		// Check if char after is a closing one  		if (TryGetByte (out ch) && !IsWhitespace (ch) && (ch != Keys.Comma && ch != Keys.RightClosingBrace) && ch != Keys.RightClosingBracket)  			throw new Exception ("TokenExpected");  		// move atomic  		this.MoveToAtomicText ().Value.SetValue (ValueHandleType.UTF8' offset' 4);  	}  	break;  case Keys.LowerN:  	{  		int offset;  		// check if it's "null"  		byte[] buffer = this.BufferReader.GetBuffer (4' out offset);  		if (buffer [offset + 1] != Keys.LowerU || buffer [offset + 2] != Keys.LowerL || buffer [offset + 3] != Keys.LowerL)  			throw new Exception ("Expected null");  		// advance of 4 chars  		this.BufferReader.Advance (4);  		SkipWhitespaceInBufferReader ();  		if (TryGetByte (out ch)) {  			if (ch == Keys.Comma || ch == Keys.RightClosingBrace)  				this.BufferReader.SkipByte ();  			else if (ch != Keys.RightClosingBracket)  				throw new Exception ("TokenExpected");  		}  		else {  			charactersToSkipOnNextRead [0] = Keys.Comma;  			charactersToSkipOnNextRead [1] = Keys.RightClosingBrace;  		}  		MoveToEndElement ();  	}  	break;  default:  	if ((ch == (byte)'-') || (((byte)'0' <= ch) && (ch <= (byte)'9')) || (ch == (byte)'I') || (ch == (byte)'N'))  		ReadNumericalText ();  	else  		throw new XmlException ("JsonEncounteredUnexpectedCharacter");  	break;  }  
Magic Number,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,Read,The following statement contains a magic number: switch (ch) {  case Keys.RightClosingBracket:  	this.BufferReader.SkipByte ();  	MoveToEndElement ();  	ExitJsonScope ();  	break;  case Keys.LeftOpeningBrace:  	this.BufferReader.SkipByte ();  	SkipWhitespaceInBufferReader ();  	ch = this.BufferReader.GetByte ();  	if (ch == Keys.RightClosingBrace) {  		// Skip this byte  		this.BufferReader.SkipByte ();  		// Skip white spaces  		SkipWhitespaceInBufferReader ();  		// try get next char  		if (TryGetByte (out ch)) {  			if (ch == Keys.Comma)  				this.BufferReader.SkipByte ();  		}  		else {  			// We are at end of buffer' just mark Comma to be skipped next time  			charactersToSkipOnNextRead [0] = Keys.Comma;  		}  		// We set to End Element  		MoveToEndElement ();  	}  	else {  		// Enter a new scope  		EnterJsonScope (JsonNodeType.Object);  		// Parse start element  		ParseStartElement ();  	}  	break;  case Keys.RightClosingBrace:  	this.BufferReader.SkipByte ();  	if (expectingFirstElementInNonPrimitiveChild) {  		SkipWhitespaceInBufferReader ();  		ch = this.BufferReader.GetByte ();  		switch (ch) {  		case Keys.Comma:  		case Keys.RightClosingBrace:  			this.BufferReader.SkipByte ();  			break;  		default:  			throw new XmlException ("JsonEncounteredUnexpectedCharacter");  		}  		expectingFirstElementInNonPrimitiveChild = false;  	}  	MoveToEndElement ();  	break;  case Keys.Comma:  	this.BufferReader.SkipByte ();  	MoveToEndElement ();  	break;  case Keys.DoubleQuote:  	if (this.Node.NodeType == XmlNodeType.Element) {  		if (expectingFirstElementInNonPrimitiveChild) {  			EnterJsonScope (JsonNodeType.Object);  			ParseStartElement ();  		}  		else {  			this.BufferReader.SkipByte ();  			ReadQuotedText (true);  		}  	}  	else if (this.Node.NodeType == XmlNodeType.EndElement) {  		EnterJsonScope (JsonNodeType.Element);  		ParseStartElement ();  	}  	else  		throw new XmlException ("JsonEncounteredUnexpectedCharacter");  	break;  case Keys.LowerF:  	{  		int offset;  		byte[] buffer = this.BufferReader.GetBuffer (5' out offset);  		// Check if it's "false"  		if (buffer [offset + 1] != Keys.LowerA || buffer [offset + 2] != Keys.LowerL || buffer [offset + 3] != Keys.LowerS || buffer [offset + 4] != Keys.LowerE)  			throw new Exception ("Expected False");  		// Advance of 5 byte  		this.BufferReader.Advance (5);  		// Check if char after is a closing one  		if (TryGetByte (out ch) && !IsWhitespace (ch) && (ch != Keys.Comma && ch != Keys.RightClosingBrace) && ch != Keys.RightClosingBracket)  			throw new Exception ("TokenExpected");  		// Move  		this.MoveToAtomicText ().Value.SetValue (ValueHandleType.UTF8' offset' 5);  	}  	break;  case Keys.LowerT:  	{  		int offset;  		// check if it's "true"  		byte[] buffer = this.BufferReader.GetBuffer (4' out offset);  		if (buffer [offset + 1] != Keys.LowerR || buffer [offset + 2] != Keys.LowerU || buffer [offset + 3] != Keys.LowerE)  			throw new Exception ("expected true");  		this.BufferReader.Advance (4);  		// Check if char after is a closing one  		if (TryGetByte (out ch) && !IsWhitespace (ch) && (ch != Keys.Comma && ch != Keys.RightClosingBrace) && ch != Keys.RightClosingBracket)  			throw new Exception ("TokenExpected");  		// move atomic  		this.MoveToAtomicText ().Value.SetValue (ValueHandleType.UTF8' offset' 4);  	}  	break;  case Keys.LowerN:  	{  		int offset;  		// check if it's "null"  		byte[] buffer = this.BufferReader.GetBuffer (4' out offset);  		if (buffer [offset + 1] != Keys.LowerU || buffer [offset + 2] != Keys.LowerL || buffer [offset + 3] != Keys.LowerL)  			throw new Exception ("Expected null");  		// advance of 4 chars  		this.BufferReader.Advance (4);  		SkipWhitespaceInBufferReader ();  		if (TryGetByte (out ch)) {  			if (ch == Keys.Comma || ch == Keys.RightClosingBrace)  				this.BufferReader.SkipByte ();  			else if (ch != Keys.RightClosingBracket)  				throw new Exception ("TokenExpected");  		}  		else {  			charactersToSkipOnNextRead [0] = Keys.Comma;  			charactersToSkipOnNextRead [1] = Keys.RightClosingBrace;  		}  		MoveToEndElement ();  	}  	break;  default:  	if ((ch == (byte)'-') || (((byte)'0' <= ch) && (ch <= (byte)'9')) || (ch == (byte)'I') || (ch == (byte)'N'))  		ReadNumericalText ();  	else  		throw new XmlException ("JsonEncounteredUnexpectedCharacter");  	break;  }  
Magic Number,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,Read,The following statement contains a magic number: switch (ch) {  case Keys.RightClosingBracket:  	this.BufferReader.SkipByte ();  	MoveToEndElement ();  	ExitJsonScope ();  	break;  case Keys.LeftOpeningBrace:  	this.BufferReader.SkipByte ();  	SkipWhitespaceInBufferReader ();  	ch = this.BufferReader.GetByte ();  	if (ch == Keys.RightClosingBrace) {  		// Skip this byte  		this.BufferReader.SkipByte ();  		// Skip white spaces  		SkipWhitespaceInBufferReader ();  		// try get next char  		if (TryGetByte (out ch)) {  			if (ch == Keys.Comma)  				this.BufferReader.SkipByte ();  		}  		else {  			// We are at end of buffer' just mark Comma to be skipped next time  			charactersToSkipOnNextRead [0] = Keys.Comma;  		}  		// We set to End Element  		MoveToEndElement ();  	}  	else {  		// Enter a new scope  		EnterJsonScope (JsonNodeType.Object);  		// Parse start element  		ParseStartElement ();  	}  	break;  case Keys.RightClosingBrace:  	this.BufferReader.SkipByte ();  	if (expectingFirstElementInNonPrimitiveChild) {  		SkipWhitespaceInBufferReader ();  		ch = this.BufferReader.GetByte ();  		switch (ch) {  		case Keys.Comma:  		case Keys.RightClosingBrace:  			this.BufferReader.SkipByte ();  			break;  		default:  			throw new XmlException ("JsonEncounteredUnexpectedCharacter");  		}  		expectingFirstElementInNonPrimitiveChild = false;  	}  	MoveToEndElement ();  	break;  case Keys.Comma:  	this.BufferReader.SkipByte ();  	MoveToEndElement ();  	break;  case Keys.DoubleQuote:  	if (this.Node.NodeType == XmlNodeType.Element) {  		if (expectingFirstElementInNonPrimitiveChild) {  			EnterJsonScope (JsonNodeType.Object);  			ParseStartElement ();  		}  		else {  			this.BufferReader.SkipByte ();  			ReadQuotedText (true);  		}  	}  	else if (this.Node.NodeType == XmlNodeType.EndElement) {  		EnterJsonScope (JsonNodeType.Element);  		ParseStartElement ();  	}  	else  		throw new XmlException ("JsonEncounteredUnexpectedCharacter");  	break;  case Keys.LowerF:  	{  		int offset;  		byte[] buffer = this.BufferReader.GetBuffer (5' out offset);  		// Check if it's "false"  		if (buffer [offset + 1] != Keys.LowerA || buffer [offset + 2] != Keys.LowerL || buffer [offset + 3] != Keys.LowerS || buffer [offset + 4] != Keys.LowerE)  			throw new Exception ("Expected False");  		// Advance of 5 byte  		this.BufferReader.Advance (5);  		// Check if char after is a closing one  		if (TryGetByte (out ch) && !IsWhitespace (ch) && (ch != Keys.Comma && ch != Keys.RightClosingBrace) && ch != Keys.RightClosingBracket)  			throw new Exception ("TokenExpected");  		// Move  		this.MoveToAtomicText ().Value.SetValue (ValueHandleType.UTF8' offset' 5);  	}  	break;  case Keys.LowerT:  	{  		int offset;  		// check if it's "true"  		byte[] buffer = this.BufferReader.GetBuffer (4' out offset);  		if (buffer [offset + 1] != Keys.LowerR || buffer [offset + 2] != Keys.LowerU || buffer [offset + 3] != Keys.LowerE)  			throw new Exception ("expected true");  		this.BufferReader.Advance (4);  		// Check if char after is a closing one  		if (TryGetByte (out ch) && !IsWhitespace (ch) && (ch != Keys.Comma && ch != Keys.RightClosingBrace) && ch != Keys.RightClosingBracket)  			throw new Exception ("TokenExpected");  		// move atomic  		this.MoveToAtomicText ().Value.SetValue (ValueHandleType.UTF8' offset' 4);  	}  	break;  case Keys.LowerN:  	{  		int offset;  		// check if it's "null"  		byte[] buffer = this.BufferReader.GetBuffer (4' out offset);  		if (buffer [offset + 1] != Keys.LowerU || buffer [offset + 2] != Keys.LowerL || buffer [offset + 3] != Keys.LowerL)  			throw new Exception ("Expected null");  		// advance of 4 chars  		this.BufferReader.Advance (4);  		SkipWhitespaceInBufferReader ();  		if (TryGetByte (out ch)) {  			if (ch == Keys.Comma || ch == Keys.RightClosingBrace)  				this.BufferReader.SkipByte ();  			else if (ch != Keys.RightClosingBracket)  				throw new Exception ("TokenExpected");  		}  		else {  			charactersToSkipOnNextRead [0] = Keys.Comma;  			charactersToSkipOnNextRead [1] = Keys.RightClosingBrace;  		}  		MoveToEndElement ();  	}  	break;  default:  	if ((ch == (byte)'-') || (((byte)'0' <= ch) && (ch <= (byte)'9')) || (ch == (byte)'I') || (ch == (byte)'N'))  		ReadNumericalText ();  	else  		throw new XmlException ("JsonEncounteredUnexpectedCharacter");  	break;  }  
Magic Number,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,Read,The following statement contains a magic number: switch (ch) {  case Keys.RightClosingBracket:  	this.BufferReader.SkipByte ();  	MoveToEndElement ();  	ExitJsonScope ();  	break;  case Keys.LeftOpeningBrace:  	this.BufferReader.SkipByte ();  	SkipWhitespaceInBufferReader ();  	ch = this.BufferReader.GetByte ();  	if (ch == Keys.RightClosingBrace) {  		// Skip this byte  		this.BufferReader.SkipByte ();  		// Skip white spaces  		SkipWhitespaceInBufferReader ();  		// try get next char  		if (TryGetByte (out ch)) {  			if (ch == Keys.Comma)  				this.BufferReader.SkipByte ();  		}  		else {  			// We are at end of buffer' just mark Comma to be skipped next time  			charactersToSkipOnNextRead [0] = Keys.Comma;  		}  		// We set to End Element  		MoveToEndElement ();  	}  	else {  		// Enter a new scope  		EnterJsonScope (JsonNodeType.Object);  		// Parse start element  		ParseStartElement ();  	}  	break;  case Keys.RightClosingBrace:  	this.BufferReader.SkipByte ();  	if (expectingFirstElementInNonPrimitiveChild) {  		SkipWhitespaceInBufferReader ();  		ch = this.BufferReader.GetByte ();  		switch (ch) {  		case Keys.Comma:  		case Keys.RightClosingBrace:  			this.BufferReader.SkipByte ();  			break;  		default:  			throw new XmlException ("JsonEncounteredUnexpectedCharacter");  		}  		expectingFirstElementInNonPrimitiveChild = false;  	}  	MoveToEndElement ();  	break;  case Keys.Comma:  	this.BufferReader.SkipByte ();  	MoveToEndElement ();  	break;  case Keys.DoubleQuote:  	if (this.Node.NodeType == XmlNodeType.Element) {  		if (expectingFirstElementInNonPrimitiveChild) {  			EnterJsonScope (JsonNodeType.Object);  			ParseStartElement ();  		}  		else {  			this.BufferReader.SkipByte ();  			ReadQuotedText (true);  		}  	}  	else if (this.Node.NodeType == XmlNodeType.EndElement) {  		EnterJsonScope (JsonNodeType.Element);  		ParseStartElement ();  	}  	else  		throw new XmlException ("JsonEncounteredUnexpectedCharacter");  	break;  case Keys.LowerF:  	{  		int offset;  		byte[] buffer = this.BufferReader.GetBuffer (5' out offset);  		// Check if it's "false"  		if (buffer [offset + 1] != Keys.LowerA || buffer [offset + 2] != Keys.LowerL || buffer [offset + 3] != Keys.LowerS || buffer [offset + 4] != Keys.LowerE)  			throw new Exception ("Expected False");  		// Advance of 5 byte  		this.BufferReader.Advance (5);  		// Check if char after is a closing one  		if (TryGetByte (out ch) && !IsWhitespace (ch) && (ch != Keys.Comma && ch != Keys.RightClosingBrace) && ch != Keys.RightClosingBracket)  			throw new Exception ("TokenExpected");  		// Move  		this.MoveToAtomicText ().Value.SetValue (ValueHandleType.UTF8' offset' 5);  	}  	break;  case Keys.LowerT:  	{  		int offset;  		// check if it's "true"  		byte[] buffer = this.BufferReader.GetBuffer (4' out offset);  		if (buffer [offset + 1] != Keys.LowerR || buffer [offset + 2] != Keys.LowerU || buffer [offset + 3] != Keys.LowerE)  			throw new Exception ("expected true");  		this.BufferReader.Advance (4);  		// Check if char after is a closing one  		if (TryGetByte (out ch) && !IsWhitespace (ch) && (ch != Keys.Comma && ch != Keys.RightClosingBrace) && ch != Keys.RightClosingBracket)  			throw new Exception ("TokenExpected");  		// move atomic  		this.MoveToAtomicText ().Value.SetValue (ValueHandleType.UTF8' offset' 4);  	}  	break;  case Keys.LowerN:  	{  		int offset;  		// check if it's "null"  		byte[] buffer = this.BufferReader.GetBuffer (4' out offset);  		if (buffer [offset + 1] != Keys.LowerU || buffer [offset + 2] != Keys.LowerL || buffer [offset + 3] != Keys.LowerL)  			throw new Exception ("Expected null");  		// advance of 4 chars  		this.BufferReader.Advance (4);  		SkipWhitespaceInBufferReader ();  		if (TryGetByte (out ch)) {  			if (ch == Keys.Comma || ch == Keys.RightClosingBrace)  				this.BufferReader.SkipByte ();  			else if (ch != Keys.RightClosingBracket)  				throw new Exception ("TokenExpected");  		}  		else {  			charactersToSkipOnNextRead [0] = Keys.Comma;  			charactersToSkipOnNextRead [1] = Keys.RightClosingBrace;  		}  		MoveToEndElement ();  	}  	break;  default:  	if ((ch == (byte)'-') || (((byte)'0' <= ch) && (ch <= (byte)'9')) || (ch == (byte)'I') || (ch == (byte)'N'))  		ReadNumericalText ();  	else  		throw new XmlException ("JsonEncounteredUnexpectedCharacter");  	break;  }  
Magic Number,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,Read,The following statement contains a magic number: if (buffer [offset + 1] != Keys.LowerA || buffer [offset + 2] != Keys.LowerL || buffer [offset + 3] != Keys.LowerS || buffer [offset + 4] != Keys.LowerE)  	throw new Exception ("Expected False");  
Magic Number,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,Read,The following statement contains a magic number: if (buffer [offset + 1] != Keys.LowerA || buffer [offset + 2] != Keys.LowerL || buffer [offset + 3] != Keys.LowerS || buffer [offset + 4] != Keys.LowerE)  	throw new Exception ("Expected False");  
Magic Number,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,Read,The following statement contains a magic number: if (buffer [offset + 1] != Keys.LowerA || buffer [offset + 2] != Keys.LowerL || buffer [offset + 3] != Keys.LowerS || buffer [offset + 4] != Keys.LowerE)  	throw new Exception ("Expected False");  
Magic Number,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,Read,The following statement contains a magic number: this.BufferReader.Advance (5);  
Magic Number,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,Read,The following statement contains a magic number: this.MoveToAtomicText ().Value.SetValue (ValueHandleType.UTF8' offset' 5);  
Magic Number,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,Read,The following statement contains a magic number: if (buffer [offset + 1] != Keys.LowerR || buffer [offset + 2] != Keys.LowerU || buffer [offset + 3] != Keys.LowerE)  	throw new Exception ("expected true");  
Magic Number,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,Read,The following statement contains a magic number: if (buffer [offset + 1] != Keys.LowerR || buffer [offset + 2] != Keys.LowerU || buffer [offset + 3] != Keys.LowerE)  	throw new Exception ("expected true");  
Magic Number,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,Read,The following statement contains a magic number: this.BufferReader.Advance (4);  
Magic Number,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,Read,The following statement contains a magic number: this.MoveToAtomicText ().Value.SetValue (ValueHandleType.UTF8' offset' 4);  
Magic Number,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,Read,The following statement contains a magic number: if (buffer [offset + 1] != Keys.LowerU || buffer [offset + 2] != Keys.LowerL || buffer [offset + 3] != Keys.LowerL)  	throw new Exception ("Expected null");  
Magic Number,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,Read,The following statement contains a magic number: if (buffer [offset + 1] != Keys.LowerU || buffer [offset + 2] != Keys.LowerL || buffer [offset + 3] != Keys.LowerL)  	throw new Exception ("Expected null");  
Magic Number,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,Read,The following statement contains a magic number: this.BufferReader.Advance (4);  
Magic Number,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,ReadEscapedCharacter,The following statement contains a magic number: if (ch1 == Keys.LowerU) {  	// Skip the lower u  	this.BufferReader.SkipByte ();  	int offset;  	// Get next 5 char  	byte[] buffer = this.BufferReader.GetBuffer (5' out offset);  	string string1 = Encoding.UTF8.GetString (buffer' offset' 4);  	this.BufferReader.Advance (4);  	int ch2 = ParseChar (string1' NumberStyles.HexNumber);  	if (char.IsHighSurrogate ((char)ch2) && this.BufferReader.GetByte () == Keys.BackSlash) {  		this.BufferReader.SkipByte ();  		// Skip the lower U  		this.SkipExpectedByteInBufferReader (Keys.LowerU);  		buffer = this.BufferReader.GetBuffer (5' out offset);  		string string2 = Encoding.UTF8.GetString (buffer' offset' 4);  		this.BufferReader.Advance (4);  		char ch3 = ParseChar (string2' NumberStyles.HexNumber);  		if (!char.IsLowSurrogate (ch3))  			throw new XmlException ("XmlInvalidLowSurrogate");  		// ch2 = new SurrogateChar(ch3' (char)ch2).Char;  	}  	if (buffer [offset + 4] == Keys.DoubleQuote) {  		this.BufferReader.SkipByte ();  		if (moveToText)  			this.MoveToAtomicText ().Value.SetCharValue (ch2);  		this.complexTextMode = JsonComplexTextMode.None;  	}  	else {  		if (moveToText)  			this.MoveToComplexText ().Value.SetCharValue (ch2);  		this.complexTextMode = JsonComplexTextMode.QuotedText;  	}  }  else {  	switch (ch1) {  	case 'n':  		ch1 = '\n';  		break;  	case 'r':  		ch1 = '\r';  		break;  	case 't':  		ch1 = '\t';  		break;  	case 'b':  		ch1 = '\b';  		break;  	case 'f':  		break;  	case '"':  	case '/':  	case '\\':  		break;  	default:  		throw new XmlException ("JsonEncounteredUnexpectedCharacter");  	}  	// skip current byte  	this.BufferReader.SkipByte ();  	if (this.BufferReader.GetByte () == Keys.DoubleQuote) {  		this.BufferReader.SkipByte ();  		if (moveToText)  			this.MoveToAtomicText ().Value.SetCharValue (ch1);  		complexTextMode = JsonComplexTextMode.None;  	}  	else {  		if (moveToText)  			this.MoveToComplexText ().Value.SetCharValue (ch1);  		complexTextMode = JsonComplexTextMode.QuotedText;  	}  }  
Magic Number,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,ReadEscapedCharacter,The following statement contains a magic number: if (ch1 == Keys.LowerU) {  	// Skip the lower u  	this.BufferReader.SkipByte ();  	int offset;  	// Get next 5 char  	byte[] buffer = this.BufferReader.GetBuffer (5' out offset);  	string string1 = Encoding.UTF8.GetString (buffer' offset' 4);  	this.BufferReader.Advance (4);  	int ch2 = ParseChar (string1' NumberStyles.HexNumber);  	if (char.IsHighSurrogate ((char)ch2) && this.BufferReader.GetByte () == Keys.BackSlash) {  		this.BufferReader.SkipByte ();  		// Skip the lower U  		this.SkipExpectedByteInBufferReader (Keys.LowerU);  		buffer = this.BufferReader.GetBuffer (5' out offset);  		string string2 = Encoding.UTF8.GetString (buffer' offset' 4);  		this.BufferReader.Advance (4);  		char ch3 = ParseChar (string2' NumberStyles.HexNumber);  		if (!char.IsLowSurrogate (ch3))  			throw new XmlException ("XmlInvalidLowSurrogate");  		// ch2 = new SurrogateChar(ch3' (char)ch2).Char;  	}  	if (buffer [offset + 4] == Keys.DoubleQuote) {  		this.BufferReader.SkipByte ();  		if (moveToText)  			this.MoveToAtomicText ().Value.SetCharValue (ch2);  		this.complexTextMode = JsonComplexTextMode.None;  	}  	else {  		if (moveToText)  			this.MoveToComplexText ().Value.SetCharValue (ch2);  		this.complexTextMode = JsonComplexTextMode.QuotedText;  	}  }  else {  	switch (ch1) {  	case 'n':  		ch1 = '\n';  		break;  	case 'r':  		ch1 = '\r';  		break;  	case 't':  		ch1 = '\t';  		break;  	case 'b':  		ch1 = '\b';  		break;  	case 'f':  		break;  	case '"':  	case '/':  	case '\\':  		break;  	default:  		throw new XmlException ("JsonEncounteredUnexpectedCharacter");  	}  	// skip current byte  	this.BufferReader.SkipByte ();  	if (this.BufferReader.GetByte () == Keys.DoubleQuote) {  		this.BufferReader.SkipByte ();  		if (moveToText)  			this.MoveToAtomicText ().Value.SetCharValue (ch1);  		complexTextMode = JsonComplexTextMode.None;  	}  	else {  		if (moveToText)  			this.MoveToComplexText ().Value.SetCharValue (ch1);  		complexTextMode = JsonComplexTextMode.QuotedText;  	}  }  
Magic Number,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,ReadEscapedCharacter,The following statement contains a magic number: if (ch1 == Keys.LowerU) {  	// Skip the lower u  	this.BufferReader.SkipByte ();  	int offset;  	// Get next 5 char  	byte[] buffer = this.BufferReader.GetBuffer (5' out offset);  	string string1 = Encoding.UTF8.GetString (buffer' offset' 4);  	this.BufferReader.Advance (4);  	int ch2 = ParseChar (string1' NumberStyles.HexNumber);  	if (char.IsHighSurrogate ((char)ch2) && this.BufferReader.GetByte () == Keys.BackSlash) {  		this.BufferReader.SkipByte ();  		// Skip the lower U  		this.SkipExpectedByteInBufferReader (Keys.LowerU);  		buffer = this.BufferReader.GetBuffer (5' out offset);  		string string2 = Encoding.UTF8.GetString (buffer' offset' 4);  		this.BufferReader.Advance (4);  		char ch3 = ParseChar (string2' NumberStyles.HexNumber);  		if (!char.IsLowSurrogate (ch3))  			throw new XmlException ("XmlInvalidLowSurrogate");  		// ch2 = new SurrogateChar(ch3' (char)ch2).Char;  	}  	if (buffer [offset + 4] == Keys.DoubleQuote) {  		this.BufferReader.SkipByte ();  		if (moveToText)  			this.MoveToAtomicText ().Value.SetCharValue (ch2);  		this.complexTextMode = JsonComplexTextMode.None;  	}  	else {  		if (moveToText)  			this.MoveToComplexText ().Value.SetCharValue (ch2);  		this.complexTextMode = JsonComplexTextMode.QuotedText;  	}  }  else {  	switch (ch1) {  	case 'n':  		ch1 = '\n';  		break;  	case 'r':  		ch1 = '\r';  		break;  	case 't':  		ch1 = '\t';  		break;  	case 'b':  		ch1 = '\b';  		break;  	case 'f':  		break;  	case '"':  	case '/':  	case '\\':  		break;  	default:  		throw new XmlException ("JsonEncounteredUnexpectedCharacter");  	}  	// skip current byte  	this.BufferReader.SkipByte ();  	if (this.BufferReader.GetByte () == Keys.DoubleQuote) {  		this.BufferReader.SkipByte ();  		if (moveToText)  			this.MoveToAtomicText ().Value.SetCharValue (ch1);  		complexTextMode = JsonComplexTextMode.None;  	}  	else {  		if (moveToText)  			this.MoveToComplexText ().Value.SetCharValue (ch1);  		complexTextMode = JsonComplexTextMode.QuotedText;  	}  }  
Magic Number,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,ReadEscapedCharacter,The following statement contains a magic number: if (ch1 == Keys.LowerU) {  	// Skip the lower u  	this.BufferReader.SkipByte ();  	int offset;  	// Get next 5 char  	byte[] buffer = this.BufferReader.GetBuffer (5' out offset);  	string string1 = Encoding.UTF8.GetString (buffer' offset' 4);  	this.BufferReader.Advance (4);  	int ch2 = ParseChar (string1' NumberStyles.HexNumber);  	if (char.IsHighSurrogate ((char)ch2) && this.BufferReader.GetByte () == Keys.BackSlash) {  		this.BufferReader.SkipByte ();  		// Skip the lower U  		this.SkipExpectedByteInBufferReader (Keys.LowerU);  		buffer = this.BufferReader.GetBuffer (5' out offset);  		string string2 = Encoding.UTF8.GetString (buffer' offset' 4);  		this.BufferReader.Advance (4);  		char ch3 = ParseChar (string2' NumberStyles.HexNumber);  		if (!char.IsLowSurrogate (ch3))  			throw new XmlException ("XmlInvalidLowSurrogate");  		// ch2 = new SurrogateChar(ch3' (char)ch2).Char;  	}  	if (buffer [offset + 4] == Keys.DoubleQuote) {  		this.BufferReader.SkipByte ();  		if (moveToText)  			this.MoveToAtomicText ().Value.SetCharValue (ch2);  		this.complexTextMode = JsonComplexTextMode.None;  	}  	else {  		if (moveToText)  			this.MoveToComplexText ().Value.SetCharValue (ch2);  		this.complexTextMode = JsonComplexTextMode.QuotedText;  	}  }  else {  	switch (ch1) {  	case 'n':  		ch1 = '\n';  		break;  	case 'r':  		ch1 = '\r';  		break;  	case 't':  		ch1 = '\t';  		break;  	case 'b':  		ch1 = '\b';  		break;  	case 'f':  		break;  	case '"':  	case '/':  	case '\\':  		break;  	default:  		throw new XmlException ("JsonEncounteredUnexpectedCharacter");  	}  	// skip current byte  	this.BufferReader.SkipByte ();  	if (this.BufferReader.GetByte () == Keys.DoubleQuote) {  		this.BufferReader.SkipByte ();  		if (moveToText)  			this.MoveToAtomicText ().Value.SetCharValue (ch1);  		complexTextMode = JsonComplexTextMode.None;  	}  	else {  		if (moveToText)  			this.MoveToComplexText ().Value.SetCharValue (ch1);  		complexTextMode = JsonComplexTextMode.QuotedText;  	}  }  
Magic Number,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,ReadEscapedCharacter,The following statement contains a magic number: if (ch1 == Keys.LowerU) {  	// Skip the lower u  	this.BufferReader.SkipByte ();  	int offset;  	// Get next 5 char  	byte[] buffer = this.BufferReader.GetBuffer (5' out offset);  	string string1 = Encoding.UTF8.GetString (buffer' offset' 4);  	this.BufferReader.Advance (4);  	int ch2 = ParseChar (string1' NumberStyles.HexNumber);  	if (char.IsHighSurrogate ((char)ch2) && this.BufferReader.GetByte () == Keys.BackSlash) {  		this.BufferReader.SkipByte ();  		// Skip the lower U  		this.SkipExpectedByteInBufferReader (Keys.LowerU);  		buffer = this.BufferReader.GetBuffer (5' out offset);  		string string2 = Encoding.UTF8.GetString (buffer' offset' 4);  		this.BufferReader.Advance (4);  		char ch3 = ParseChar (string2' NumberStyles.HexNumber);  		if (!char.IsLowSurrogate (ch3))  			throw new XmlException ("XmlInvalidLowSurrogate");  		// ch2 = new SurrogateChar(ch3' (char)ch2).Char;  	}  	if (buffer [offset + 4] == Keys.DoubleQuote) {  		this.BufferReader.SkipByte ();  		if (moveToText)  			this.MoveToAtomicText ().Value.SetCharValue (ch2);  		this.complexTextMode = JsonComplexTextMode.None;  	}  	else {  		if (moveToText)  			this.MoveToComplexText ().Value.SetCharValue (ch2);  		this.complexTextMode = JsonComplexTextMode.QuotedText;  	}  }  else {  	switch (ch1) {  	case 'n':  		ch1 = '\n';  		break;  	case 'r':  		ch1 = '\r';  		break;  	case 't':  		ch1 = '\t';  		break;  	case 'b':  		ch1 = '\b';  		break;  	case 'f':  		break;  	case '"':  	case '/':  	case '\\':  		break;  	default:  		throw new XmlException ("JsonEncounteredUnexpectedCharacter");  	}  	// skip current byte  	this.BufferReader.SkipByte ();  	if (this.BufferReader.GetByte () == Keys.DoubleQuote) {  		this.BufferReader.SkipByte ();  		if (moveToText)  			this.MoveToAtomicText ().Value.SetCharValue (ch1);  		complexTextMode = JsonComplexTextMode.None;  	}  	else {  		if (moveToText)  			this.MoveToComplexText ().Value.SetCharValue (ch1);  		complexTextMode = JsonComplexTextMode.QuotedText;  	}  }  
Magic Number,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,ReadEscapedCharacter,The following statement contains a magic number: if (ch1 == Keys.LowerU) {  	// Skip the lower u  	this.BufferReader.SkipByte ();  	int offset;  	// Get next 5 char  	byte[] buffer = this.BufferReader.GetBuffer (5' out offset);  	string string1 = Encoding.UTF8.GetString (buffer' offset' 4);  	this.BufferReader.Advance (4);  	int ch2 = ParseChar (string1' NumberStyles.HexNumber);  	if (char.IsHighSurrogate ((char)ch2) && this.BufferReader.GetByte () == Keys.BackSlash) {  		this.BufferReader.SkipByte ();  		// Skip the lower U  		this.SkipExpectedByteInBufferReader (Keys.LowerU);  		buffer = this.BufferReader.GetBuffer (5' out offset);  		string string2 = Encoding.UTF8.GetString (buffer' offset' 4);  		this.BufferReader.Advance (4);  		char ch3 = ParseChar (string2' NumberStyles.HexNumber);  		if (!char.IsLowSurrogate (ch3))  			throw new XmlException ("XmlInvalidLowSurrogate");  		// ch2 = new SurrogateChar(ch3' (char)ch2).Char;  	}  	if (buffer [offset + 4] == Keys.DoubleQuote) {  		this.BufferReader.SkipByte ();  		if (moveToText)  			this.MoveToAtomicText ().Value.SetCharValue (ch2);  		this.complexTextMode = JsonComplexTextMode.None;  	}  	else {  		if (moveToText)  			this.MoveToComplexText ().Value.SetCharValue (ch2);  		this.complexTextMode = JsonComplexTextMode.QuotedText;  	}  }  else {  	switch (ch1) {  	case 'n':  		ch1 = '\n';  		break;  	case 'r':  		ch1 = '\r';  		break;  	case 't':  		ch1 = '\t';  		break;  	case 'b':  		ch1 = '\b';  		break;  	case 'f':  		break;  	case '"':  	case '/':  	case '\\':  		break;  	default:  		throw new XmlException ("JsonEncounteredUnexpectedCharacter");  	}  	// skip current byte  	this.BufferReader.SkipByte ();  	if (this.BufferReader.GetByte () == Keys.DoubleQuote) {  		this.BufferReader.SkipByte ();  		if (moveToText)  			this.MoveToAtomicText ().Value.SetCharValue (ch1);  		complexTextMode = JsonComplexTextMode.None;  	}  	else {  		if (moveToText)  			this.MoveToComplexText ().Value.SetCharValue (ch1);  		complexTextMode = JsonComplexTextMode.QuotedText;  	}  }  
Magic Number,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,ReadEscapedCharacter,The following statement contains a magic number: if (ch1 == Keys.LowerU) {  	// Skip the lower u  	this.BufferReader.SkipByte ();  	int offset;  	// Get next 5 char  	byte[] buffer = this.BufferReader.GetBuffer (5' out offset);  	string string1 = Encoding.UTF8.GetString (buffer' offset' 4);  	this.BufferReader.Advance (4);  	int ch2 = ParseChar (string1' NumberStyles.HexNumber);  	if (char.IsHighSurrogate ((char)ch2) && this.BufferReader.GetByte () == Keys.BackSlash) {  		this.BufferReader.SkipByte ();  		// Skip the lower U  		this.SkipExpectedByteInBufferReader (Keys.LowerU);  		buffer = this.BufferReader.GetBuffer (5' out offset);  		string string2 = Encoding.UTF8.GetString (buffer' offset' 4);  		this.BufferReader.Advance (4);  		char ch3 = ParseChar (string2' NumberStyles.HexNumber);  		if (!char.IsLowSurrogate (ch3))  			throw new XmlException ("XmlInvalidLowSurrogate");  		// ch2 = new SurrogateChar(ch3' (char)ch2).Char;  	}  	if (buffer [offset + 4] == Keys.DoubleQuote) {  		this.BufferReader.SkipByte ();  		if (moveToText)  			this.MoveToAtomicText ().Value.SetCharValue (ch2);  		this.complexTextMode = JsonComplexTextMode.None;  	}  	else {  		if (moveToText)  			this.MoveToComplexText ().Value.SetCharValue (ch2);  		this.complexTextMode = JsonComplexTextMode.QuotedText;  	}  }  else {  	switch (ch1) {  	case 'n':  		ch1 = '\n';  		break;  	case 'r':  		ch1 = '\r';  		break;  	case 't':  		ch1 = '\t';  		break;  	case 'b':  		ch1 = '\b';  		break;  	case 'f':  		break;  	case '"':  	case '/':  	case '\\':  		break;  	default:  		throw new XmlException ("JsonEncounteredUnexpectedCharacter");  	}  	// skip current byte  	this.BufferReader.SkipByte ();  	if (this.BufferReader.GetByte () == Keys.DoubleQuote) {  		this.BufferReader.SkipByte ();  		if (moveToText)  			this.MoveToAtomicText ().Value.SetCharValue (ch1);  		complexTextMode = JsonComplexTextMode.None;  	}  	else {  		if (moveToText)  			this.MoveToComplexText ().Value.SetCharValue (ch1);  		complexTextMode = JsonComplexTextMode.QuotedText;  	}  }  
Magic Number,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,ReadEscapedCharacter,The following statement contains a magic number: this.BufferReader.Advance (4);  
Magic Number,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,ReadEscapedCharacter,The following statement contains a magic number: if (char.IsHighSurrogate ((char)ch2) && this.BufferReader.GetByte () == Keys.BackSlash) {  	this.BufferReader.SkipByte ();  	// Skip the lower U  	this.SkipExpectedByteInBufferReader (Keys.LowerU);  	buffer = this.BufferReader.GetBuffer (5' out offset);  	string string2 = Encoding.UTF8.GetString (buffer' offset' 4);  	this.BufferReader.Advance (4);  	char ch3 = ParseChar (string2' NumberStyles.HexNumber);  	if (!char.IsLowSurrogate (ch3))  		throw new XmlException ("XmlInvalidLowSurrogate");  	// ch2 = new SurrogateChar(ch3' (char)ch2).Char;  }  
Magic Number,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,ReadEscapedCharacter,The following statement contains a magic number: if (char.IsHighSurrogate ((char)ch2) && this.BufferReader.GetByte () == Keys.BackSlash) {  	this.BufferReader.SkipByte ();  	// Skip the lower U  	this.SkipExpectedByteInBufferReader (Keys.LowerU);  	buffer = this.BufferReader.GetBuffer (5' out offset);  	string string2 = Encoding.UTF8.GetString (buffer' offset' 4);  	this.BufferReader.Advance (4);  	char ch3 = ParseChar (string2' NumberStyles.HexNumber);  	if (!char.IsLowSurrogate (ch3))  		throw new XmlException ("XmlInvalidLowSurrogate");  	// ch2 = new SurrogateChar(ch3' (char)ch2).Char;  }  
Magic Number,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,ReadEscapedCharacter,The following statement contains a magic number: if (char.IsHighSurrogate ((char)ch2) && this.BufferReader.GetByte () == Keys.BackSlash) {  	this.BufferReader.SkipByte ();  	// Skip the lower U  	this.SkipExpectedByteInBufferReader (Keys.LowerU);  	buffer = this.BufferReader.GetBuffer (5' out offset);  	string string2 = Encoding.UTF8.GetString (buffer' offset' 4);  	this.BufferReader.Advance (4);  	char ch3 = ParseChar (string2' NumberStyles.HexNumber);  	if (!char.IsLowSurrogate (ch3))  		throw new XmlException ("XmlInvalidLowSurrogate");  	// ch2 = new SurrogateChar(ch3' (char)ch2).Char;  }  
Magic Number,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,ReadEscapedCharacter,The following statement contains a magic number: buffer = this.BufferReader.GetBuffer (5' out offset);  
Magic Number,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,ReadEscapedCharacter,The following statement contains a magic number: this.BufferReader.Advance (4);  
Magic Number,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,ReadEscapedCharacter,The following statement contains a magic number: if (buffer [offset + 4] == Keys.DoubleQuote) {  	this.BufferReader.SkipByte ();  	if (moveToText)  		this.MoveToAtomicText ().Value.SetCharValue (ch2);  	this.complexTextMode = JsonComplexTextMode.None;  }  else {  	if (moveToText)  		this.MoveToComplexText ().Value.SetCharValue (ch2);  	this.complexTextMode = JsonComplexTextMode.QuotedText;  }  
Magic Number,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,ReadNonFFFE,The following statement contains a magic number: if (buffer [offset + 1] == 191 && (buffer [offset + 2] == 190 || buffer [offset + 2] == 191))  	throw new XmlException ("JsonInvalidFFFE");  
Magic Number,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,ReadNonFFFE,The following statement contains a magic number: if (buffer [offset + 1] == 191 && (buffer [offset + 2] == 190 || buffer [offset + 2] == 191))  	throw new XmlException ("JsonInvalidFFFE");  
Magic Number,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,ReadNonFFFE,The following statement contains a magic number: if (buffer [offset + 1] == 191 && (buffer [offset + 2] == 190 || buffer [offset + 2] == 191))  	throw new XmlException ("JsonInvalidFFFE");  
Magic Number,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,ReadNonFFFE,The following statement contains a magic number: if (buffer [offset + 1] == 191 && (buffer [offset + 2] == 190 || buffer [offset + 2] == 191))  	throw new XmlException ("JsonInvalidFFFE");  
Magic Number,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,ReadNonFFFE,The following statement contains a magic number: if (buffer [offset + 1] == 191 && (buffer [offset + 2] == 190 || buffer [offset + 2] == 191))  	throw new XmlException ("JsonInvalidFFFE");  
Magic Number,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,ReadNonFFFE,The following statement contains a magic number: return 3;  
Magic Number,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,ReadQuotedText,The following statement contains a magic number: if (escaped && this.BufferReader.GetByte () == 239) {  	offset = this.BufferReader.Offset;  	num = ReadNonFFFE ();  }  
Magic Number,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,UnescapeJsonString,The following statement contains a magic number: for (int index = 0; index < val.Length; ++index) {  	// If we have a back slash   	if (val [index] == Keys.BackSlash) {  		// add all the chars before  		stringBuilder.Append (val' startIndex' count);  		// pass the back slash  		++index;  		if (index >= val.Length)  			throw new XmlException ("JsonEncounteredUnexpectedCharacter");  		switch (val [index]) {  		case 'n':  			stringBuilder.Append ('\n');  			break;  		case 'r':  			stringBuilder.Append ('\r');  			break;  		case 't':  			stringBuilder.Append ('\t');  			break;  		case 'u':  			if (index + 3 >= val.Length)  				throw new XmlException ("JsonEncounteredUnexpectedCharacter");  			stringBuilder.Append (ParseChar (val.Substring (index + 1' 4)' NumberStyles.HexNumber));  			index += 4;  			break;  		case 'b':  			stringBuilder.Append ('\b');  			break;  		case 'f':  			stringBuilder.Append ('\f');  			break;  		case '/':  		case '\\':  		case '"':  		case '\'':  			stringBuilder.Append (val [index]);  			break;  		}  		startIndex = index + 1;  		count = 0;  	}  	else  		++count;  }  
Magic Number,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,UnescapeJsonString,The following statement contains a magic number: for (int index = 0; index < val.Length; ++index) {  	// If we have a back slash   	if (val [index] == Keys.BackSlash) {  		// add all the chars before  		stringBuilder.Append (val' startIndex' count);  		// pass the back slash  		++index;  		if (index >= val.Length)  			throw new XmlException ("JsonEncounteredUnexpectedCharacter");  		switch (val [index]) {  		case 'n':  			stringBuilder.Append ('\n');  			break;  		case 'r':  			stringBuilder.Append ('\r');  			break;  		case 't':  			stringBuilder.Append ('\t');  			break;  		case 'u':  			if (index + 3 >= val.Length)  				throw new XmlException ("JsonEncounteredUnexpectedCharacter");  			stringBuilder.Append (ParseChar (val.Substring (index + 1' 4)' NumberStyles.HexNumber));  			index += 4;  			break;  		case 'b':  			stringBuilder.Append ('\b');  			break;  		case 'f':  			stringBuilder.Append ('\f');  			break;  		case '/':  		case '\\':  		case '"':  		case '\'':  			stringBuilder.Append (val [index]);  			break;  		}  		startIndex = index + 1;  		count = 0;  	}  	else  		++count;  }  
Magic Number,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,UnescapeJsonString,The following statement contains a magic number: for (int index = 0; index < val.Length; ++index) {  	// If we have a back slash   	if (val [index] == Keys.BackSlash) {  		// add all the chars before  		stringBuilder.Append (val' startIndex' count);  		// pass the back slash  		++index;  		if (index >= val.Length)  			throw new XmlException ("JsonEncounteredUnexpectedCharacter");  		switch (val [index]) {  		case 'n':  			stringBuilder.Append ('\n');  			break;  		case 'r':  			stringBuilder.Append ('\r');  			break;  		case 't':  			stringBuilder.Append ('\t');  			break;  		case 'u':  			if (index + 3 >= val.Length)  				throw new XmlException ("JsonEncounteredUnexpectedCharacter");  			stringBuilder.Append (ParseChar (val.Substring (index + 1' 4)' NumberStyles.HexNumber));  			index += 4;  			break;  		case 'b':  			stringBuilder.Append ('\b');  			break;  		case 'f':  			stringBuilder.Append ('\f');  			break;  		case '/':  		case '\\':  		case '"':  		case '\'':  			stringBuilder.Append (val [index]);  			break;  		}  		startIndex = index + 1;  		count = 0;  	}  	else  		++count;  }  
Magic Number,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,UnescapeJsonString,The following statement contains a magic number: if (val [index] == Keys.BackSlash) {  	// add all the chars before  	stringBuilder.Append (val' startIndex' count);  	// pass the back slash  	++index;  	if (index >= val.Length)  		throw new XmlException ("JsonEncounteredUnexpectedCharacter");  	switch (val [index]) {  	case 'n':  		stringBuilder.Append ('\n');  		break;  	case 'r':  		stringBuilder.Append ('\r');  		break;  	case 't':  		stringBuilder.Append ('\t');  		break;  	case 'u':  		if (index + 3 >= val.Length)  			throw new XmlException ("JsonEncounteredUnexpectedCharacter");  		stringBuilder.Append (ParseChar (val.Substring (index + 1' 4)' NumberStyles.HexNumber));  		index += 4;  		break;  	case 'b':  		stringBuilder.Append ('\b');  		break;  	case 'f':  		stringBuilder.Append ('\f');  		break;  	case '/':  	case '\\':  	case '"':  	case '\'':  		stringBuilder.Append (val [index]);  		break;  	}  	startIndex = index + 1;  	count = 0;  }  else  	++count;  
Magic Number,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,UnescapeJsonString,The following statement contains a magic number: if (val [index] == Keys.BackSlash) {  	// add all the chars before  	stringBuilder.Append (val' startIndex' count);  	// pass the back slash  	++index;  	if (index >= val.Length)  		throw new XmlException ("JsonEncounteredUnexpectedCharacter");  	switch (val [index]) {  	case 'n':  		stringBuilder.Append ('\n');  		break;  	case 'r':  		stringBuilder.Append ('\r');  		break;  	case 't':  		stringBuilder.Append ('\t');  		break;  	case 'u':  		if (index + 3 >= val.Length)  			throw new XmlException ("JsonEncounteredUnexpectedCharacter");  		stringBuilder.Append (ParseChar (val.Substring (index + 1' 4)' NumberStyles.HexNumber));  		index += 4;  		break;  	case 'b':  		stringBuilder.Append ('\b');  		break;  	case 'f':  		stringBuilder.Append ('\f');  		break;  	case '/':  	case '\\':  	case '"':  	case '\'':  		stringBuilder.Append (val [index]);  		break;  	}  	startIndex = index + 1;  	count = 0;  }  else  	++count;  
Magic Number,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,UnescapeJsonString,The following statement contains a magic number: if (val [index] == Keys.BackSlash) {  	// add all the chars before  	stringBuilder.Append (val' startIndex' count);  	// pass the back slash  	++index;  	if (index >= val.Length)  		throw new XmlException ("JsonEncounteredUnexpectedCharacter");  	switch (val [index]) {  	case 'n':  		stringBuilder.Append ('\n');  		break;  	case 'r':  		stringBuilder.Append ('\r');  		break;  	case 't':  		stringBuilder.Append ('\t');  		break;  	case 'u':  		if (index + 3 >= val.Length)  			throw new XmlException ("JsonEncounteredUnexpectedCharacter");  		stringBuilder.Append (ParseChar (val.Substring (index + 1' 4)' NumberStyles.HexNumber));  		index += 4;  		break;  	case 'b':  		stringBuilder.Append ('\b');  		break;  	case 'f':  		stringBuilder.Append ('\f');  		break;  	case '/':  	case '\\':  	case '"':  	case '\'':  		stringBuilder.Append (val [index]);  		break;  	}  	startIndex = index + 1;  	count = 0;  }  else  	++count;  
Magic Number,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,UnescapeJsonString,The following statement contains a magic number: switch (val [index]) {  case 'n':  	stringBuilder.Append ('\n');  	break;  case 'r':  	stringBuilder.Append ('\r');  	break;  case 't':  	stringBuilder.Append ('\t');  	break;  case 'u':  	if (index + 3 >= val.Length)  		throw new XmlException ("JsonEncounteredUnexpectedCharacter");  	stringBuilder.Append (ParseChar (val.Substring (index + 1' 4)' NumberStyles.HexNumber));  	index += 4;  	break;  case 'b':  	stringBuilder.Append ('\b');  	break;  case 'f':  	stringBuilder.Append ('\f');  	break;  case '/':  case '\\':  case '"':  case '\'':  	stringBuilder.Append (val [index]);  	break;  }  
Magic Number,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,UnescapeJsonString,The following statement contains a magic number: switch (val [index]) {  case 'n':  	stringBuilder.Append ('\n');  	break;  case 'r':  	stringBuilder.Append ('\r');  	break;  case 't':  	stringBuilder.Append ('\t');  	break;  case 'u':  	if (index + 3 >= val.Length)  		throw new XmlException ("JsonEncounteredUnexpectedCharacter");  	stringBuilder.Append (ParseChar (val.Substring (index + 1' 4)' NumberStyles.HexNumber));  	index += 4;  	break;  case 'b':  	stringBuilder.Append ('\b');  	break;  case 'f':  	stringBuilder.Append ('\f');  	break;  case '/':  case '\\':  case '"':  case '\'':  	stringBuilder.Append (val [index]);  	break;  }  
Magic Number,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,UnescapeJsonString,The following statement contains a magic number: switch (val [index]) {  case 'n':  	stringBuilder.Append ('\n');  	break;  case 'r':  	stringBuilder.Append ('\r');  	break;  case 't':  	stringBuilder.Append ('\t');  	break;  case 'u':  	if (index + 3 >= val.Length)  		throw new XmlException ("JsonEncounteredUnexpectedCharacter");  	stringBuilder.Append (ParseChar (val.Substring (index + 1' 4)' NumberStyles.HexNumber));  	index += 4;  	break;  case 'b':  	stringBuilder.Append ('\b');  	break;  case 'f':  	stringBuilder.Append ('\f');  	break;  case '/':  case '\\':  case '"':  case '\'':  	stringBuilder.Append (val [index]);  	break;  }  
Magic Number,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,UnescapeJsonString,The following statement contains a magic number: if (index + 3 >= val.Length)  	throw new XmlException ("JsonEncounteredUnexpectedCharacter");  
Magic Number,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,UnescapeJsonString,The following statement contains a magic number: stringBuilder.Append (ParseChar (val.Substring (index + 1' 4)' NumberStyles.HexNumber));  
Magic Number,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,UnescapeJsonString,The following statement contains a magic number: index += 4;  
Magic Number,Microsoft.Synchronization.ClientServices,XmlJsonWriter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonWriter.cs,EnterScope,The following statement contains a magic number: if (scopes == null)  	scopes = new JsonNodeType[4];  else if (scopes.Length == depth) {  	var jsonNodeTypeArray = new JsonNodeType[depth * 2];  	Array.Copy (scopes' jsonNodeTypeArray' depth);  	scopes = jsonNodeTypeArray;  }  
Magic Number,Microsoft.Synchronization.ClientServices,XmlJsonWriter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonWriter.cs,EnterScope,The following statement contains a magic number: if (scopes == null)  	scopes = new JsonNodeType[4];  else if (scopes.Length == depth) {  	var jsonNodeTypeArray = new JsonNodeType[depth * 2];  	Array.Copy (scopes' jsonNodeTypeArray' depth);  	scopes = jsonNodeTypeArray;  }  
Magic Number,Microsoft.Synchronization.ClientServices,XmlJsonWriter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonWriter.cs,EnterScope,The following statement contains a magic number: scopes = new JsonNodeType[4];  
Magic Number,Microsoft.Synchronization.ClientServices,XmlJsonWriter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonWriter.cs,EnterScope,The following statement contains a magic number: if (scopes.Length == depth) {  	var jsonNodeTypeArray = new JsonNodeType[depth * 2];  	Array.Copy (scopes' jsonNodeTypeArray' depth);  	scopes = jsonNodeTypeArray;  }  
Magic Number,Microsoft.Synchronization.ClientServices,XmlJsonWriter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonWriter.cs,InitializeWriter,The following statement contains a magic number: if (scopes != null && scopes.Length > 25)  	scopes = null;  
Magic Number,Microsoft.Synchronization.ClientServices.SQLite,SQLiteContext,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteContext.cs,CheckSchemaAndUriAsync,The following statement contains a magic number: await Task.Run (() =>  {  	DateTime durationStartDate = DateTime.Now;  	this.Configuration = this.Manager.ReadConfiguration (scope);  	if (progress != null)  		progress.Report (new SyncProgressEvent (SyncStage.ReadingConfiguration' DateTime.Now.Subtract (durationStartDate)));  	if (this.Configuration != null) {  		// Verify the scope uri.  		if (this.Configuration.ServiceUri.AbsoluteUri != uri.AbsoluteUri)  			throw new ArgumentException ("Specified uri does not match uri previously used for the specified database");  		// Verify the types.  		List<Type> userTypes = offlineSchema.Collections.ToList ();  		// Sort by name (the class Type isn't sortable)  		userTypes.Sort ((x' y) => String.Compare (x.FullName' y.FullName' StringComparison.Ordinal));  		if (userTypes.Count != this.Configuration.Types.Count)  			throw new ArgumentException ("Specified offlineSchema does not match database Offline schema previously used for cache path");  		// Fix  		this.Configuration.Types.Sort ((x' y) => String.Compare (x' y' StringComparison.Ordinal));  		if (userTypes.Where ((t' i) => t.FullName != this.Configuration.Types [i]).Any ())  			throw new ArgumentException ("Specified offlineSchema does not match database Offline schema previously used for cache path");  	}  	else {  		bool existScope = this.Manager.ScopeTableExist ();  		if (!existScope) {  			durationStartDate = DateTime.Now;  			this.Manager.CreateScopeTable ();  			if (progress != null)  				progress.Report (new SyncProgressEvent (SyncStage.CreatingScope' DateTime.Now.Subtract (durationStartDate)));  		}  		// Get the list of types as strings and sort to make comparison  		// faster when reading.  		List<string> types = (from type in offlineSchema.Collections  		select type.FullName).ToList ();  		types.Sort ();  		// Create the initial configuration  		this.Configuration = new SQLiteConfiguration {  			AnchorBlob = null'  			LastSyncDate = new DateTime (1900' 01' 01)'  			ScopeName = scope'  			ServiceUri = uri'  			Types = types  		};  		durationStartDate = DateTime.Now;  		this.Manager.SaveConfiguration (this.Configuration);  		if (progress != null)  			progress.Report (new SyncProgressEvent (SyncStage.ApplyingConfiguration' DateTime.Now.Subtract (durationStartDate)));  	}  	// Try to save tables if not exists  	if (schema == null || schema.Collections == null || schema.Collections.Count == 0)  		return;  	durationStartDate = DateTime.Now;  	foreach (var table in schema.Collections.Where (table => table.Name != SQLiteConstants.ScopeInfo)) {  		this.Manager.CreateTable (table);  	}  	if (progress != null)  		progress.Report (new SyncProgressEvent (SyncStage.CheckingTables' DateTime.Now.Subtract (durationStartDate)));  });  
Magic Number,Microsoft.Synchronization.ClientServices.SQLite,SQLiteContext,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteContext.cs,CheckSchemaAndUriAsync,The following statement contains a magic number: if (this.Configuration != null) {  	// Verify the scope uri.  	if (this.Configuration.ServiceUri.AbsoluteUri != uri.AbsoluteUri)  		throw new ArgumentException ("Specified uri does not match uri previously used for the specified database");  	// Verify the types.  	List<Type> userTypes = offlineSchema.Collections.ToList ();  	// Sort by name (the class Type isn't sortable)  	userTypes.Sort ((x' y) => String.Compare (x.FullName' y.FullName' StringComparison.Ordinal));  	if (userTypes.Count != this.Configuration.Types.Count)  		throw new ArgumentException ("Specified offlineSchema does not match database Offline schema previously used for cache path");  	// Fix  	this.Configuration.Types.Sort ((x' y) => String.Compare (x' y' StringComparison.Ordinal));  	if (userTypes.Where ((t' i) => t.FullName != this.Configuration.Types [i]).Any ())  		throw new ArgumentException ("Specified offlineSchema does not match database Offline schema previously used for cache path");  }  else {  	bool existScope = this.Manager.ScopeTableExist ();  	if (!existScope) {  		durationStartDate = DateTime.Now;  		this.Manager.CreateScopeTable ();  		if (progress != null)  			progress.Report (new SyncProgressEvent (SyncStage.CreatingScope' DateTime.Now.Subtract (durationStartDate)));  	}  	// Get the list of types as strings and sort to make comparison  	// faster when reading.  	List<string> types = (from type in offlineSchema.Collections  	select type.FullName).ToList ();  	types.Sort ();  	// Create the initial configuration  	this.Configuration = new SQLiteConfiguration {  		AnchorBlob = null'  		LastSyncDate = new DateTime (1900' 01' 01)'  		ScopeName = scope'  		ServiceUri = uri'  		Types = types  	};  	durationStartDate = DateTime.Now;  	this.Manager.SaveConfiguration (this.Configuration);  	if (progress != null)  		progress.Report (new SyncProgressEvent (SyncStage.ApplyingConfiguration' DateTime.Now.Subtract (durationStartDate)));  }  
Magic Number,Microsoft.Synchronization.ClientServices.SQLite,SQLiteContext,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteContext.cs,CheckSchemaAndUriAsync,The following statement contains a magic number: this.Configuration = new SQLiteConfiguration {  	AnchorBlob = null'  	LastSyncDate = new DateTime (1900' 01' 01)'  	ScopeName = scope'  	ServiceUri = uri'  	Types = types  };  
Magic Number,Microsoft.Synchronization.ClientServices.SQLite,SQLiteHelper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteHelper.cs,UpdateDirtyTrackingEntities,The following statement contains a magic number: using (SQLiteConnection connection = new SQLiteConnection (localFilePath)) {  	// Get mapping from my type  	var map = manager.GetMapping (ty);  	var queryUpdateDirtyTracking = String.Format (SQLiteConstants.UpdateDirtyTracking' map.TableName);  	try {  		using (var statement = connection.Prepare ("Begin Transaction")) {  			statement.Step ();  		}  		using (var stmtTracking = connection.Prepare (queryUpdateDirtyTracking)) {  			foreach (var entity in entities) {  				// Set Values for tracking table  				BindParameter (stmtTracking' 1' entity.ServiceMetadata.IsTombstone);  				BindParameter (stmtTracking' 2' 0);  				BindParameter (stmtTracking' 3' entity.ServiceMetadata.ETag);  				var editUri = String.Empty;  				if (entity.ServiceMetadata.EditUri != null && entity.ServiceMetadata.EditUri.IsAbsoluteUri)  					editUri = entity.ServiceMetadata.EditUri.AbsoluteUri;  				BindParameter (stmtTracking' 4' editUri);  				BindParameter (stmtTracking' 5' entity.ServiceMetadata.Id);  				//await stmtTracking.StepAsync().AsTask().ConfigureAwait(false);  				stmtTracking.Step ();  				stmtTracking.Reset ();  				stmtTracking.ClearBindings ();  			}  		}  		using (var statement = connection.Prepare ("Commit Transaction")) {  			statement.Step ();  		}  	}  	catch (Exception ex) {  		using (var statement = connection.Prepare ("Rollback Transaction")) {  			statement.Step ();  		}  		Debug.WriteLine (ex.Message);  		throw;  	}  }  
Magic Number,Microsoft.Synchronization.ClientServices.SQLite,SQLiteHelper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteHelper.cs,UpdateDirtyTrackingEntities,The following statement contains a magic number: using (SQLiteConnection connection = new SQLiteConnection (localFilePath)) {  	// Get mapping from my type  	var map = manager.GetMapping (ty);  	var queryUpdateDirtyTracking = String.Format (SQLiteConstants.UpdateDirtyTracking' map.TableName);  	try {  		using (var statement = connection.Prepare ("Begin Transaction")) {  			statement.Step ();  		}  		using (var stmtTracking = connection.Prepare (queryUpdateDirtyTracking)) {  			foreach (var entity in entities) {  				// Set Values for tracking table  				BindParameter (stmtTracking' 1' entity.ServiceMetadata.IsTombstone);  				BindParameter (stmtTracking' 2' 0);  				BindParameter (stmtTracking' 3' entity.ServiceMetadata.ETag);  				var editUri = String.Empty;  				if (entity.ServiceMetadata.EditUri != null && entity.ServiceMetadata.EditUri.IsAbsoluteUri)  					editUri = entity.ServiceMetadata.EditUri.AbsoluteUri;  				BindParameter (stmtTracking' 4' editUri);  				BindParameter (stmtTracking' 5' entity.ServiceMetadata.Id);  				//await stmtTracking.StepAsync().AsTask().ConfigureAwait(false);  				stmtTracking.Step ();  				stmtTracking.Reset ();  				stmtTracking.ClearBindings ();  			}  		}  		using (var statement = connection.Prepare ("Commit Transaction")) {  			statement.Step ();  		}  	}  	catch (Exception ex) {  		using (var statement = connection.Prepare ("Rollback Transaction")) {  			statement.Step ();  		}  		Debug.WriteLine (ex.Message);  		throw;  	}  }  
Magic Number,Microsoft.Synchronization.ClientServices.SQLite,SQLiteHelper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteHelper.cs,UpdateDirtyTrackingEntities,The following statement contains a magic number: using (SQLiteConnection connection = new SQLiteConnection (localFilePath)) {  	// Get mapping from my type  	var map = manager.GetMapping (ty);  	var queryUpdateDirtyTracking = String.Format (SQLiteConstants.UpdateDirtyTracking' map.TableName);  	try {  		using (var statement = connection.Prepare ("Begin Transaction")) {  			statement.Step ();  		}  		using (var stmtTracking = connection.Prepare (queryUpdateDirtyTracking)) {  			foreach (var entity in entities) {  				// Set Values for tracking table  				BindParameter (stmtTracking' 1' entity.ServiceMetadata.IsTombstone);  				BindParameter (stmtTracking' 2' 0);  				BindParameter (stmtTracking' 3' entity.ServiceMetadata.ETag);  				var editUri = String.Empty;  				if (entity.ServiceMetadata.EditUri != null && entity.ServiceMetadata.EditUri.IsAbsoluteUri)  					editUri = entity.ServiceMetadata.EditUri.AbsoluteUri;  				BindParameter (stmtTracking' 4' editUri);  				BindParameter (stmtTracking' 5' entity.ServiceMetadata.Id);  				//await stmtTracking.StepAsync().AsTask().ConfigureAwait(false);  				stmtTracking.Step ();  				stmtTracking.Reset ();  				stmtTracking.ClearBindings ();  			}  		}  		using (var statement = connection.Prepare ("Commit Transaction")) {  			statement.Step ();  		}  	}  	catch (Exception ex) {  		using (var statement = connection.Prepare ("Rollback Transaction")) {  			statement.Step ();  		}  		Debug.WriteLine (ex.Message);  		throw;  	}  }  
Magic Number,Microsoft.Synchronization.ClientServices.SQLite,SQLiteHelper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteHelper.cs,UpdateDirtyTrackingEntities,The following statement contains a magic number: using (SQLiteConnection connection = new SQLiteConnection (localFilePath)) {  	// Get mapping from my type  	var map = manager.GetMapping (ty);  	var queryUpdateDirtyTracking = String.Format (SQLiteConstants.UpdateDirtyTracking' map.TableName);  	try {  		using (var statement = connection.Prepare ("Begin Transaction")) {  			statement.Step ();  		}  		using (var stmtTracking = connection.Prepare (queryUpdateDirtyTracking)) {  			foreach (var entity in entities) {  				// Set Values for tracking table  				BindParameter (stmtTracking' 1' entity.ServiceMetadata.IsTombstone);  				BindParameter (stmtTracking' 2' 0);  				BindParameter (stmtTracking' 3' entity.ServiceMetadata.ETag);  				var editUri = String.Empty;  				if (entity.ServiceMetadata.EditUri != null && entity.ServiceMetadata.EditUri.IsAbsoluteUri)  					editUri = entity.ServiceMetadata.EditUri.AbsoluteUri;  				BindParameter (stmtTracking' 4' editUri);  				BindParameter (stmtTracking' 5' entity.ServiceMetadata.Id);  				//await stmtTracking.StepAsync().AsTask().ConfigureAwait(false);  				stmtTracking.Step ();  				stmtTracking.Reset ();  				stmtTracking.ClearBindings ();  			}  		}  		using (var statement = connection.Prepare ("Commit Transaction")) {  			statement.Step ();  		}  	}  	catch (Exception ex) {  		using (var statement = connection.Prepare ("Rollback Transaction")) {  			statement.Step ();  		}  		Debug.WriteLine (ex.Message);  		throw;  	}  }  
Magic Number,Microsoft.Synchronization.ClientServices.SQLite,SQLiteHelper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteHelper.cs,UpdateDirtyTrackingEntities,The following statement contains a magic number: try {  	using (var statement = connection.Prepare ("Begin Transaction")) {  		statement.Step ();  	}  	using (var stmtTracking = connection.Prepare (queryUpdateDirtyTracking)) {  		foreach (var entity in entities) {  			// Set Values for tracking table  			BindParameter (stmtTracking' 1' entity.ServiceMetadata.IsTombstone);  			BindParameter (stmtTracking' 2' 0);  			BindParameter (stmtTracking' 3' entity.ServiceMetadata.ETag);  			var editUri = String.Empty;  			if (entity.ServiceMetadata.EditUri != null && entity.ServiceMetadata.EditUri.IsAbsoluteUri)  				editUri = entity.ServiceMetadata.EditUri.AbsoluteUri;  			BindParameter (stmtTracking' 4' editUri);  			BindParameter (stmtTracking' 5' entity.ServiceMetadata.Id);  			//await stmtTracking.StepAsync().AsTask().ConfigureAwait(false);  			stmtTracking.Step ();  			stmtTracking.Reset ();  			stmtTracking.ClearBindings ();  		}  	}  	using (var statement = connection.Prepare ("Commit Transaction")) {  		statement.Step ();  	}  }  catch (Exception ex) {  	using (var statement = connection.Prepare ("Rollback Transaction")) {  		statement.Step ();  	}  	Debug.WriteLine (ex.Message);  	throw;  }  
Magic Number,Microsoft.Synchronization.ClientServices.SQLite,SQLiteHelper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteHelper.cs,UpdateDirtyTrackingEntities,The following statement contains a magic number: try {  	using (var statement = connection.Prepare ("Begin Transaction")) {  		statement.Step ();  	}  	using (var stmtTracking = connection.Prepare (queryUpdateDirtyTracking)) {  		foreach (var entity in entities) {  			// Set Values for tracking table  			BindParameter (stmtTracking' 1' entity.ServiceMetadata.IsTombstone);  			BindParameter (stmtTracking' 2' 0);  			BindParameter (stmtTracking' 3' entity.ServiceMetadata.ETag);  			var editUri = String.Empty;  			if (entity.ServiceMetadata.EditUri != null && entity.ServiceMetadata.EditUri.IsAbsoluteUri)  				editUri = entity.ServiceMetadata.EditUri.AbsoluteUri;  			BindParameter (stmtTracking' 4' editUri);  			BindParameter (stmtTracking' 5' entity.ServiceMetadata.Id);  			//await stmtTracking.StepAsync().AsTask().ConfigureAwait(false);  			stmtTracking.Step ();  			stmtTracking.Reset ();  			stmtTracking.ClearBindings ();  		}  	}  	using (var statement = connection.Prepare ("Commit Transaction")) {  		statement.Step ();  	}  }  catch (Exception ex) {  	using (var statement = connection.Prepare ("Rollback Transaction")) {  		statement.Step ();  	}  	Debug.WriteLine (ex.Message);  	throw;  }  
Magic Number,Microsoft.Synchronization.ClientServices.SQLite,SQLiteHelper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteHelper.cs,UpdateDirtyTrackingEntities,The following statement contains a magic number: try {  	using (var statement = connection.Prepare ("Begin Transaction")) {  		statement.Step ();  	}  	using (var stmtTracking = connection.Prepare (queryUpdateDirtyTracking)) {  		foreach (var entity in entities) {  			// Set Values for tracking table  			BindParameter (stmtTracking' 1' entity.ServiceMetadata.IsTombstone);  			BindParameter (stmtTracking' 2' 0);  			BindParameter (stmtTracking' 3' entity.ServiceMetadata.ETag);  			var editUri = String.Empty;  			if (entity.ServiceMetadata.EditUri != null && entity.ServiceMetadata.EditUri.IsAbsoluteUri)  				editUri = entity.ServiceMetadata.EditUri.AbsoluteUri;  			BindParameter (stmtTracking' 4' editUri);  			BindParameter (stmtTracking' 5' entity.ServiceMetadata.Id);  			//await stmtTracking.StepAsync().AsTask().ConfigureAwait(false);  			stmtTracking.Step ();  			stmtTracking.Reset ();  			stmtTracking.ClearBindings ();  		}  	}  	using (var statement = connection.Prepare ("Commit Transaction")) {  		statement.Step ();  	}  }  catch (Exception ex) {  	using (var statement = connection.Prepare ("Rollback Transaction")) {  		statement.Step ();  	}  	Debug.WriteLine (ex.Message);  	throw;  }  
Magic Number,Microsoft.Synchronization.ClientServices.SQLite,SQLiteHelper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteHelper.cs,UpdateDirtyTrackingEntities,The following statement contains a magic number: try {  	using (var statement = connection.Prepare ("Begin Transaction")) {  		statement.Step ();  	}  	using (var stmtTracking = connection.Prepare (queryUpdateDirtyTracking)) {  		foreach (var entity in entities) {  			// Set Values for tracking table  			BindParameter (stmtTracking' 1' entity.ServiceMetadata.IsTombstone);  			BindParameter (stmtTracking' 2' 0);  			BindParameter (stmtTracking' 3' entity.ServiceMetadata.ETag);  			var editUri = String.Empty;  			if (entity.ServiceMetadata.EditUri != null && entity.ServiceMetadata.EditUri.IsAbsoluteUri)  				editUri = entity.ServiceMetadata.EditUri.AbsoluteUri;  			BindParameter (stmtTracking' 4' editUri);  			BindParameter (stmtTracking' 5' entity.ServiceMetadata.Id);  			//await stmtTracking.StepAsync().AsTask().ConfigureAwait(false);  			stmtTracking.Step ();  			stmtTracking.Reset ();  			stmtTracking.ClearBindings ();  		}  	}  	using (var statement = connection.Prepare ("Commit Transaction")) {  		statement.Step ();  	}  }  catch (Exception ex) {  	using (var statement = connection.Prepare ("Rollback Transaction")) {  		statement.Step ();  	}  	Debug.WriteLine (ex.Message);  	throw;  }  
Magic Number,Microsoft.Synchronization.ClientServices.SQLite,SQLiteHelper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteHelper.cs,UpdateDirtyTrackingEntities,The following statement contains a magic number: using (var stmtTracking = connection.Prepare (queryUpdateDirtyTracking)) {  	foreach (var entity in entities) {  		// Set Values for tracking table  		BindParameter (stmtTracking' 1' entity.ServiceMetadata.IsTombstone);  		BindParameter (stmtTracking' 2' 0);  		BindParameter (stmtTracking' 3' entity.ServiceMetadata.ETag);  		var editUri = String.Empty;  		if (entity.ServiceMetadata.EditUri != null && entity.ServiceMetadata.EditUri.IsAbsoluteUri)  			editUri = entity.ServiceMetadata.EditUri.AbsoluteUri;  		BindParameter (stmtTracking' 4' editUri);  		BindParameter (stmtTracking' 5' entity.ServiceMetadata.Id);  		//await stmtTracking.StepAsync().AsTask().ConfigureAwait(false);  		stmtTracking.Step ();  		stmtTracking.Reset ();  		stmtTracking.ClearBindings ();  	}  }  
Magic Number,Microsoft.Synchronization.ClientServices.SQLite,SQLiteHelper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteHelper.cs,UpdateDirtyTrackingEntities,The following statement contains a magic number: using (var stmtTracking = connection.Prepare (queryUpdateDirtyTracking)) {  	foreach (var entity in entities) {  		// Set Values for tracking table  		BindParameter (stmtTracking' 1' entity.ServiceMetadata.IsTombstone);  		BindParameter (stmtTracking' 2' 0);  		BindParameter (stmtTracking' 3' entity.ServiceMetadata.ETag);  		var editUri = String.Empty;  		if (entity.ServiceMetadata.EditUri != null && entity.ServiceMetadata.EditUri.IsAbsoluteUri)  			editUri = entity.ServiceMetadata.EditUri.AbsoluteUri;  		BindParameter (stmtTracking' 4' editUri);  		BindParameter (stmtTracking' 5' entity.ServiceMetadata.Id);  		//await stmtTracking.StepAsync().AsTask().ConfigureAwait(false);  		stmtTracking.Step ();  		stmtTracking.Reset ();  		stmtTracking.ClearBindings ();  	}  }  
Magic Number,Microsoft.Synchronization.ClientServices.SQLite,SQLiteHelper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteHelper.cs,UpdateDirtyTrackingEntities,The following statement contains a magic number: using (var stmtTracking = connection.Prepare (queryUpdateDirtyTracking)) {  	foreach (var entity in entities) {  		// Set Values for tracking table  		BindParameter (stmtTracking' 1' entity.ServiceMetadata.IsTombstone);  		BindParameter (stmtTracking' 2' 0);  		BindParameter (stmtTracking' 3' entity.ServiceMetadata.ETag);  		var editUri = String.Empty;  		if (entity.ServiceMetadata.EditUri != null && entity.ServiceMetadata.EditUri.IsAbsoluteUri)  			editUri = entity.ServiceMetadata.EditUri.AbsoluteUri;  		BindParameter (stmtTracking' 4' editUri);  		BindParameter (stmtTracking' 5' entity.ServiceMetadata.Id);  		//await stmtTracking.StepAsync().AsTask().ConfigureAwait(false);  		stmtTracking.Step ();  		stmtTracking.Reset ();  		stmtTracking.ClearBindings ();  	}  }  
Magic Number,Microsoft.Synchronization.ClientServices.SQLite,SQLiteHelper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteHelper.cs,UpdateDirtyTrackingEntities,The following statement contains a magic number: using (var stmtTracking = connection.Prepare (queryUpdateDirtyTracking)) {  	foreach (var entity in entities) {  		// Set Values for tracking table  		BindParameter (stmtTracking' 1' entity.ServiceMetadata.IsTombstone);  		BindParameter (stmtTracking' 2' 0);  		BindParameter (stmtTracking' 3' entity.ServiceMetadata.ETag);  		var editUri = String.Empty;  		if (entity.ServiceMetadata.EditUri != null && entity.ServiceMetadata.EditUri.IsAbsoluteUri)  			editUri = entity.ServiceMetadata.EditUri.AbsoluteUri;  		BindParameter (stmtTracking' 4' editUri);  		BindParameter (stmtTracking' 5' entity.ServiceMetadata.Id);  		//await stmtTracking.StepAsync().AsTask().ConfigureAwait(false);  		stmtTracking.Step ();  		stmtTracking.Reset ();  		stmtTracking.ClearBindings ();  	}  }  
Magic Number,Microsoft.Synchronization.ClientServices.SQLite,SQLiteHelper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteHelper.cs,UpdateDirtyTrackingEntities,The following statement contains a magic number: foreach (var entity in entities) {  	// Set Values for tracking table  	BindParameter (stmtTracking' 1' entity.ServiceMetadata.IsTombstone);  	BindParameter (stmtTracking' 2' 0);  	BindParameter (stmtTracking' 3' entity.ServiceMetadata.ETag);  	var editUri = String.Empty;  	if (entity.ServiceMetadata.EditUri != null && entity.ServiceMetadata.EditUri.IsAbsoluteUri)  		editUri = entity.ServiceMetadata.EditUri.AbsoluteUri;  	BindParameter (stmtTracking' 4' editUri);  	BindParameter (stmtTracking' 5' entity.ServiceMetadata.Id);  	//await stmtTracking.StepAsync().AsTask().ConfigureAwait(false);  	stmtTracking.Step ();  	stmtTracking.Reset ();  	stmtTracking.ClearBindings ();  }  
Magic Number,Microsoft.Synchronization.ClientServices.SQLite,SQLiteHelper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteHelper.cs,UpdateDirtyTrackingEntities,The following statement contains a magic number: foreach (var entity in entities) {  	// Set Values for tracking table  	BindParameter (stmtTracking' 1' entity.ServiceMetadata.IsTombstone);  	BindParameter (stmtTracking' 2' 0);  	BindParameter (stmtTracking' 3' entity.ServiceMetadata.ETag);  	var editUri = String.Empty;  	if (entity.ServiceMetadata.EditUri != null && entity.ServiceMetadata.EditUri.IsAbsoluteUri)  		editUri = entity.ServiceMetadata.EditUri.AbsoluteUri;  	BindParameter (stmtTracking' 4' editUri);  	BindParameter (stmtTracking' 5' entity.ServiceMetadata.Id);  	//await stmtTracking.StepAsync().AsTask().ConfigureAwait(false);  	stmtTracking.Step ();  	stmtTracking.Reset ();  	stmtTracking.ClearBindings ();  }  
Magic Number,Microsoft.Synchronization.ClientServices.SQLite,SQLiteHelper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteHelper.cs,UpdateDirtyTrackingEntities,The following statement contains a magic number: foreach (var entity in entities) {  	// Set Values for tracking table  	BindParameter (stmtTracking' 1' entity.ServiceMetadata.IsTombstone);  	BindParameter (stmtTracking' 2' 0);  	BindParameter (stmtTracking' 3' entity.ServiceMetadata.ETag);  	var editUri = String.Empty;  	if (entity.ServiceMetadata.EditUri != null && entity.ServiceMetadata.EditUri.IsAbsoluteUri)  		editUri = entity.ServiceMetadata.EditUri.AbsoluteUri;  	BindParameter (stmtTracking' 4' editUri);  	BindParameter (stmtTracking' 5' entity.ServiceMetadata.Id);  	//await stmtTracking.StepAsync().AsTask().ConfigureAwait(false);  	stmtTracking.Step ();  	stmtTracking.Reset ();  	stmtTracking.ClearBindings ();  }  
Magic Number,Microsoft.Synchronization.ClientServices.SQLite,SQLiteHelper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteHelper.cs,UpdateDirtyTrackingEntities,The following statement contains a magic number: foreach (var entity in entities) {  	// Set Values for tracking table  	BindParameter (stmtTracking' 1' entity.ServiceMetadata.IsTombstone);  	BindParameter (stmtTracking' 2' 0);  	BindParameter (stmtTracking' 3' entity.ServiceMetadata.ETag);  	var editUri = String.Empty;  	if (entity.ServiceMetadata.EditUri != null && entity.ServiceMetadata.EditUri.IsAbsoluteUri)  		editUri = entity.ServiceMetadata.EditUri.AbsoluteUri;  	BindParameter (stmtTracking' 4' editUri);  	BindParameter (stmtTracking' 5' entity.ServiceMetadata.Id);  	//await stmtTracking.StepAsync().AsTask().ConfigureAwait(false);  	stmtTracking.Step ();  	stmtTracking.Reset ();  	stmtTracking.ClearBindings ();  }  
Magic Number,Microsoft.Synchronization.ClientServices.SQLite,SQLiteHelper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteHelper.cs,UpdateDirtyTrackingEntities,The following statement contains a magic number: BindParameter (stmtTracking' 2' 0);  
Magic Number,Microsoft.Synchronization.ClientServices.SQLite,SQLiteHelper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteHelper.cs,UpdateDirtyTrackingEntities,The following statement contains a magic number: BindParameter (stmtTracking' 3' entity.ServiceMetadata.ETag);  
Magic Number,Microsoft.Synchronization.ClientServices.SQLite,SQLiteHelper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteHelper.cs,UpdateDirtyTrackingEntities,The following statement contains a magic number: BindParameter (stmtTracking' 4' editUri);  
Magic Number,Microsoft.Synchronization.ClientServices.SQLite,SQLiteHelper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteHelper.cs,UpdateDirtyTrackingEntities,The following statement contains a magic number: BindParameter (stmtTracking' 5' entity.ServiceMetadata.Id);  
Magic Number,Microsoft.Synchronization.ClientServices.SQLite,SQLiteHelper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteHelper.cs,MergeEntities,The following statement contains a magic number: using (SQLiteConnection connection = new SQLiteConnection (this.localFilePath)) {  	// Get mapping from my type  	var map = manager.GetMapping (ty);  	// Foreach columns' create the list of columns to insert or update  	var columnsDcl = new List<String> ();  	var columnsValues = new List<String> ();  	var columnsDclTracking = new List<String> ();  	var columnsValuesTracking = new List<String> ();  	foreach (var c in map.Columns) {  		columnsDcl.Add ("[" + c.Name + "]");  		columnsValues.Add ("? ");  	}  	foreach (var c in map.PrimaryKeys) {  		columnsDclTracking.Add ("\"" + c.Name + "\"");  		columnsValuesTracking.Add ("? ");  	}  	var decl = string.Join ("'"' columnsDcl.ToArray ());  	var declValues = string.Join ("'"' columnsValues.ToArray ());  	var declTracking = string.Join ("'"' columnsDclTracking.ToArray ());  	var declValuesTracking = string.Join ("'"' columnsValuesTracking.ToArray ());  	var declValuePairs = columnsDcl.Zip (columnsValues' (col' val) => col + "=" + val).ToArray ();  	var declValuePairsStr = string.Join ("'"' declValuePairs);  	// Creating queries  	var queryInsert = String.Format (SQLiteConstants.InsertOrIgnoreFromChanges' map.TableName' decl' declValues);  	var queryUpdate = String.Format (SQLiteConstants.UpdateOrIgnoreFromChanges' map.TableName' declValuePairsStr' map.GetPrimaryKeysWhereClause);  	var queryUpdateTracking = String.Format (SQLiteConstants.InsertOrReplaceTrackingFromChanges' map.TableName' declTracking' declValuesTracking);  	var queryDelete = String.Format (SQLiteConstants.DeleteFromChanges' map.TableName' map.GetPrimaryKeysWhereClause);  	var queryDeleteTracking = String.Format (SQLiteConstants.DeleteTrackingFromChanges' map.TableName' map.GetPrimaryKeysWhereClause);  	string pkeysNames = String.Join ("' "' map.PrimaryKeys.Select (column => column.Name));  	var querySelectItemPrimaryKeyFromTrackingChangesWithOemID = String.Format (SQLiteConstants.SelectItemPrimaryKeyFromTrackingChangesWithOemID' map.TableName' pkeysNames);  	try {  		using (var statement = connection.Prepare ("Begin Transaction")) {  			statement.Step ();  		}  		// Disable Trigger  		this.DisableTriggers (map' connection);  		// Prepare commandsa  		using (var stmtInsert = connection.Prepare (queryInsert))  			using (var stmtUpdate = connection.Prepare (queryUpdate))  				using (var stmtGetprimaryKey = connection.Prepare (querySelectItemPrimaryKeyFromTrackingChangesWithOemID))  					using (var stmtDeleteItem = connection.Prepare (queryDelete))  						using (var stmtDeleteItemTracking = connection.Prepare (queryDeleteTracking))  							using (var stmtTracking = connection.Prepare (queryUpdateTracking)) {  								foreach (var entity in entities) {  									// Foreach entity check if it's a delete action or un insert/update action  									if (entity.ServiceMetadata.IsTombstone) {  										// Delete Action  										// Bind parameter  										BindParameter (stmtGetprimaryKey' 1' entity.ServiceMetadata.Id);  										// Store values of primaryKeys  										Object[] pkeys = new object[map.PrimaryKeys.Length];  										// While row is available (only 1 if it's good)  										while (stmtGetprimaryKey.Step () == SQLiteResult.ROW) {  											for (int i = 0; i < pkeys.Length; i++) {  												// Read the column  												pkeys [i] = ReadCol (stmtGetprimaryKey' i' map.PrimaryKeys [i].ColumnType);  											}  										}  										stmtGetprimaryKey.Reset ();  										// Bind parameters  										for (int i = 0; i < pkeys.Length; i++) {  											BindParameter (stmtDeleteItem' i + 1' pkeys [i]);  											BindParameter (stmtDeleteItemTracking' i + 1' pkeys [i]);  										}  										// Execute the deletion of 2 rows  										stmtDeleteItem.Step ();  										stmtDeleteItem.Reset ();  										stmtDeleteItem.ClearBindings ();  										stmtDeleteItemTracking.Step ();  										stmtDeleteItemTracking.Reset ();  										stmtDeleteItemTracking.ClearBindings ();  									}  									else {  										// Get columns for insert  										var cols = map.Columns;  										// Set values for table  										for (var i = 0; i < cols.Length; i++) {  											var val = cols [i].GetValue (entity);  											BindParameter (stmtInsert' i + 1' val);  											BindParameter (stmtUpdate' i + 1' val);  										}  										// add where clause  										for (var i = 0; i < map.PrimaryKeys.Length; i++) {  											var val = map.PrimaryKeys [i].GetValue (entity);  											BindParameter (stmtUpdate' cols.Length + i + 1' val);  										}  										stmtUpdate.Step ();  										stmtUpdate.Reset ();  										stmtUpdate.ClearBindings ();  										stmtInsert.Step ();  										stmtInsert.Reset ();  										stmtInsert.ClearBindings ();  										// Set Values for tracking table  										BindParameter (stmtTracking' 1' entity.ServiceMetadata.IsTombstone);  										BindParameter (stmtTracking' 2' 0);  										BindParameter (stmtTracking' 3' entity.ServiceMetadata.Id);  										BindParameter (stmtTracking' 4' "ETag");  										var editUri = String.Empty;  										if (entity.ServiceMetadata.EditUri != null && entity.ServiceMetadata.EditUri.IsAbsoluteUri)  											editUri = entity.ServiceMetadata.EditUri.AbsoluteUri;  										BindParameter (stmtTracking' 5' editUri);  										BindParameter (stmtTracking' 6' DateTime.UtcNow);  										// Set values for tracking table  										for (var i = 0; i < map.PrimaryKeys.Length; i++) {  											var val = map.PrimaryKeys [i].GetValue (entity);  											BindParameter (stmtTracking' i + 7' val);  										}  										stmtTracking.Step ();  										stmtTracking.Reset ();  										stmtTracking.ClearBindings ();  									}  								}  								using (var statement = connection.Prepare ("Commit Transaction")) {  									statement.Step ();  								}  							}  	}  	catch (Exception ex) {  		using (var statement = connection.Prepare ("Rollback Transaction")) {  			statement.Step ();  		}  		Debug.WriteLine (ex.Message);  		throw;  	}  	// Re create Triggers  	this.CreateTriggers (ty' connection);  }  
Magic Number,Microsoft.Synchronization.ClientServices.SQLite,SQLiteHelper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteHelper.cs,MergeEntities,The following statement contains a magic number: using (SQLiteConnection connection = new SQLiteConnection (this.localFilePath)) {  	// Get mapping from my type  	var map = manager.GetMapping (ty);  	// Foreach columns' create the list of columns to insert or update  	var columnsDcl = new List<String> ();  	var columnsValues = new List<String> ();  	var columnsDclTracking = new List<String> ();  	var columnsValuesTracking = new List<String> ();  	foreach (var c in map.Columns) {  		columnsDcl.Add ("[" + c.Name + "]");  		columnsValues.Add ("? ");  	}  	foreach (var c in map.PrimaryKeys) {  		columnsDclTracking.Add ("\"" + c.Name + "\"");  		columnsValuesTracking.Add ("? ");  	}  	var decl = string.Join ("'"' columnsDcl.ToArray ());  	var declValues = string.Join ("'"' columnsValues.ToArray ());  	var declTracking = string.Join ("'"' columnsDclTracking.ToArray ());  	var declValuesTracking = string.Join ("'"' columnsValuesTracking.ToArray ());  	var declValuePairs = columnsDcl.Zip (columnsValues' (col' val) => col + "=" + val).ToArray ();  	var declValuePairsStr = string.Join ("'"' declValuePairs);  	// Creating queries  	var queryInsert = String.Format (SQLiteConstants.InsertOrIgnoreFromChanges' map.TableName' decl' declValues);  	var queryUpdate = String.Format (SQLiteConstants.UpdateOrIgnoreFromChanges' map.TableName' declValuePairsStr' map.GetPrimaryKeysWhereClause);  	var queryUpdateTracking = String.Format (SQLiteConstants.InsertOrReplaceTrackingFromChanges' map.TableName' declTracking' declValuesTracking);  	var queryDelete = String.Format (SQLiteConstants.DeleteFromChanges' map.TableName' map.GetPrimaryKeysWhereClause);  	var queryDeleteTracking = String.Format (SQLiteConstants.DeleteTrackingFromChanges' map.TableName' map.GetPrimaryKeysWhereClause);  	string pkeysNames = String.Join ("' "' map.PrimaryKeys.Select (column => column.Name));  	var querySelectItemPrimaryKeyFromTrackingChangesWithOemID = String.Format (SQLiteConstants.SelectItemPrimaryKeyFromTrackingChangesWithOemID' map.TableName' pkeysNames);  	try {  		using (var statement = connection.Prepare ("Begin Transaction")) {  			statement.Step ();  		}  		// Disable Trigger  		this.DisableTriggers (map' connection);  		// Prepare commandsa  		using (var stmtInsert = connection.Prepare (queryInsert))  			using (var stmtUpdate = connection.Prepare (queryUpdate))  				using (var stmtGetprimaryKey = connection.Prepare (querySelectItemPrimaryKeyFromTrackingChangesWithOemID))  					using (var stmtDeleteItem = connection.Prepare (queryDelete))  						using (var stmtDeleteItemTracking = connection.Prepare (queryDeleteTracking))  							using (var stmtTracking = connection.Prepare (queryUpdateTracking)) {  								foreach (var entity in entities) {  									// Foreach entity check if it's a delete action or un insert/update action  									if (entity.ServiceMetadata.IsTombstone) {  										// Delete Action  										// Bind parameter  										BindParameter (stmtGetprimaryKey' 1' entity.ServiceMetadata.Id);  										// Store values of primaryKeys  										Object[] pkeys = new object[map.PrimaryKeys.Length];  										// While row is available (only 1 if it's good)  										while (stmtGetprimaryKey.Step () == SQLiteResult.ROW) {  											for (int i = 0; i < pkeys.Length; i++) {  												// Read the column  												pkeys [i] = ReadCol (stmtGetprimaryKey' i' map.PrimaryKeys [i].ColumnType);  											}  										}  										stmtGetprimaryKey.Reset ();  										// Bind parameters  										for (int i = 0; i < pkeys.Length; i++) {  											BindParameter (stmtDeleteItem' i + 1' pkeys [i]);  											BindParameter (stmtDeleteItemTracking' i + 1' pkeys [i]);  										}  										// Execute the deletion of 2 rows  										stmtDeleteItem.Step ();  										stmtDeleteItem.Reset ();  										stmtDeleteItem.ClearBindings ();  										stmtDeleteItemTracking.Step ();  										stmtDeleteItemTracking.Reset ();  										stmtDeleteItemTracking.ClearBindings ();  									}  									else {  										// Get columns for insert  										var cols = map.Columns;  										// Set values for table  										for (var i = 0; i < cols.Length; i++) {  											var val = cols [i].GetValue (entity);  											BindParameter (stmtInsert' i + 1' val);  											BindParameter (stmtUpdate' i + 1' val);  										}  										// add where clause  										for (var i = 0; i < map.PrimaryKeys.Length; i++) {  											var val = map.PrimaryKeys [i].GetValue (entity);  											BindParameter (stmtUpdate' cols.Length + i + 1' val);  										}  										stmtUpdate.Step ();  										stmtUpdate.Reset ();  										stmtUpdate.ClearBindings ();  										stmtInsert.Step ();  										stmtInsert.Reset ();  										stmtInsert.ClearBindings ();  										// Set Values for tracking table  										BindParameter (stmtTracking' 1' entity.ServiceMetadata.IsTombstone);  										BindParameter (stmtTracking' 2' 0);  										BindParameter (stmtTracking' 3' entity.ServiceMetadata.Id);  										BindParameter (stmtTracking' 4' "ETag");  										var editUri = String.Empty;  										if (entity.ServiceMetadata.EditUri != null && entity.ServiceMetadata.EditUri.IsAbsoluteUri)  											editUri = entity.ServiceMetadata.EditUri.AbsoluteUri;  										BindParameter (stmtTracking' 5' editUri);  										BindParameter (stmtTracking' 6' DateTime.UtcNow);  										// Set values for tracking table  										for (var i = 0; i < map.PrimaryKeys.Length; i++) {  											var val = map.PrimaryKeys [i].GetValue (entity);  											BindParameter (stmtTracking' i + 7' val);  										}  										stmtTracking.Step ();  										stmtTracking.Reset ();  										stmtTracking.ClearBindings ();  									}  								}  								using (var statement = connection.Prepare ("Commit Transaction")) {  									statement.Step ();  								}  							}  	}  	catch (Exception ex) {  		using (var statement = connection.Prepare ("Rollback Transaction")) {  			statement.Step ();  		}  		Debug.WriteLine (ex.Message);  		throw;  	}  	// Re create Triggers  	this.CreateTriggers (ty' connection);  }  
Magic Number,Microsoft.Synchronization.ClientServices.SQLite,SQLiteHelper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteHelper.cs,MergeEntities,The following statement contains a magic number: using (SQLiteConnection connection = new SQLiteConnection (this.localFilePath)) {  	// Get mapping from my type  	var map = manager.GetMapping (ty);  	// Foreach columns' create the list of columns to insert or update  	var columnsDcl = new List<String> ();  	var columnsValues = new List<String> ();  	var columnsDclTracking = new List<String> ();  	var columnsValuesTracking = new List<String> ();  	foreach (var c in map.Columns) {  		columnsDcl.Add ("[" + c.Name + "]");  		columnsValues.Add ("? ");  	}  	foreach (var c in map.PrimaryKeys) {  		columnsDclTracking.Add ("\"" + c.Name + "\"");  		columnsValuesTracking.Add ("? ");  	}  	var decl = string.Join ("'"' columnsDcl.ToArray ());  	var declValues = string.Join ("'"' columnsValues.ToArray ());  	var declTracking = string.Join ("'"' columnsDclTracking.ToArray ());  	var declValuesTracking = string.Join ("'"' columnsValuesTracking.ToArray ());  	var declValuePairs = columnsDcl.Zip (columnsValues' (col' val) => col + "=" + val).ToArray ();  	var declValuePairsStr = string.Join ("'"' declValuePairs);  	// Creating queries  	var queryInsert = String.Format (SQLiteConstants.InsertOrIgnoreFromChanges' map.TableName' decl' declValues);  	var queryUpdate = String.Format (SQLiteConstants.UpdateOrIgnoreFromChanges' map.TableName' declValuePairsStr' map.GetPrimaryKeysWhereClause);  	var queryUpdateTracking = String.Format (SQLiteConstants.InsertOrReplaceTrackingFromChanges' map.TableName' declTracking' declValuesTracking);  	var queryDelete = String.Format (SQLiteConstants.DeleteFromChanges' map.TableName' map.GetPrimaryKeysWhereClause);  	var queryDeleteTracking = String.Format (SQLiteConstants.DeleteTrackingFromChanges' map.TableName' map.GetPrimaryKeysWhereClause);  	string pkeysNames = String.Join ("' "' map.PrimaryKeys.Select (column => column.Name));  	var querySelectItemPrimaryKeyFromTrackingChangesWithOemID = String.Format (SQLiteConstants.SelectItemPrimaryKeyFromTrackingChangesWithOemID' map.TableName' pkeysNames);  	try {  		using (var statement = connection.Prepare ("Begin Transaction")) {  			statement.Step ();  		}  		// Disable Trigger  		this.DisableTriggers (map' connection);  		// Prepare commandsa  		using (var stmtInsert = connection.Prepare (queryInsert))  			using (var stmtUpdate = connection.Prepare (queryUpdate))  				using (var stmtGetprimaryKey = connection.Prepare (querySelectItemPrimaryKeyFromTrackingChangesWithOemID))  					using (var stmtDeleteItem = connection.Prepare (queryDelete))  						using (var stmtDeleteItemTracking = connection.Prepare (queryDeleteTracking))  							using (var stmtTracking = connection.Prepare (queryUpdateTracking)) {  								foreach (var entity in entities) {  									// Foreach entity check if it's a delete action or un insert/update action  									if (entity.ServiceMetadata.IsTombstone) {  										// Delete Action  										// Bind parameter  										BindParameter (stmtGetprimaryKey' 1' entity.ServiceMetadata.Id);  										// Store values of primaryKeys  										Object[] pkeys = new object[map.PrimaryKeys.Length];  										// While row is available (only 1 if it's good)  										while (stmtGetprimaryKey.Step () == SQLiteResult.ROW) {  											for (int i = 0; i < pkeys.Length; i++) {  												// Read the column  												pkeys [i] = ReadCol (stmtGetprimaryKey' i' map.PrimaryKeys [i].ColumnType);  											}  										}  										stmtGetprimaryKey.Reset ();  										// Bind parameters  										for (int i = 0; i < pkeys.Length; i++) {  											BindParameter (stmtDeleteItem' i + 1' pkeys [i]);  											BindParameter (stmtDeleteItemTracking' i + 1' pkeys [i]);  										}  										// Execute the deletion of 2 rows  										stmtDeleteItem.Step ();  										stmtDeleteItem.Reset ();  										stmtDeleteItem.ClearBindings ();  										stmtDeleteItemTracking.Step ();  										stmtDeleteItemTracking.Reset ();  										stmtDeleteItemTracking.ClearBindings ();  									}  									else {  										// Get columns for insert  										var cols = map.Columns;  										// Set values for table  										for (var i = 0; i < cols.Length; i++) {  											var val = cols [i].GetValue (entity);  											BindParameter (stmtInsert' i + 1' val);  											BindParameter (stmtUpdate' i + 1' val);  										}  										// add where clause  										for (var i = 0; i < map.PrimaryKeys.Length; i++) {  											var val = map.PrimaryKeys [i].GetValue (entity);  											BindParameter (stmtUpdate' cols.Length + i + 1' val);  										}  										stmtUpdate.Step ();  										stmtUpdate.Reset ();  										stmtUpdate.ClearBindings ();  										stmtInsert.Step ();  										stmtInsert.Reset ();  										stmtInsert.ClearBindings ();  										// Set Values for tracking table  										BindParameter (stmtTracking' 1' entity.ServiceMetadata.IsTombstone);  										BindParameter (stmtTracking' 2' 0);  										BindParameter (stmtTracking' 3' entity.ServiceMetadata.Id);  										BindParameter (stmtTracking' 4' "ETag");  										var editUri = String.Empty;  										if (entity.ServiceMetadata.EditUri != null && entity.ServiceMetadata.EditUri.IsAbsoluteUri)  											editUri = entity.ServiceMetadata.EditUri.AbsoluteUri;  										BindParameter (stmtTracking' 5' editUri);  										BindParameter (stmtTracking' 6' DateTime.UtcNow);  										// Set values for tracking table  										for (var i = 0; i < map.PrimaryKeys.Length; i++) {  											var val = map.PrimaryKeys [i].GetValue (entity);  											BindParameter (stmtTracking' i + 7' val);  										}  										stmtTracking.Step ();  										stmtTracking.Reset ();  										stmtTracking.ClearBindings ();  									}  								}  								using (var statement = connection.Prepare ("Commit Transaction")) {  									statement.Step ();  								}  							}  	}  	catch (Exception ex) {  		using (var statement = connection.Prepare ("Rollback Transaction")) {  			statement.Step ();  		}  		Debug.WriteLine (ex.Message);  		throw;  	}  	// Re create Triggers  	this.CreateTriggers (ty' connection);  }  
Magic Number,Microsoft.Synchronization.ClientServices.SQLite,SQLiteHelper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteHelper.cs,MergeEntities,The following statement contains a magic number: using (SQLiteConnection connection = new SQLiteConnection (this.localFilePath)) {  	// Get mapping from my type  	var map = manager.GetMapping (ty);  	// Foreach columns' create the list of columns to insert or update  	var columnsDcl = new List<String> ();  	var columnsValues = new List<String> ();  	var columnsDclTracking = new List<String> ();  	var columnsValuesTracking = new List<String> ();  	foreach (var c in map.Columns) {  		columnsDcl.Add ("[" + c.Name + "]");  		columnsValues.Add ("? ");  	}  	foreach (var c in map.PrimaryKeys) {  		columnsDclTracking.Add ("\"" + c.Name + "\"");  		columnsValuesTracking.Add ("? ");  	}  	var decl = string.Join ("'"' columnsDcl.ToArray ());  	var declValues = string.Join ("'"' columnsValues.ToArray ());  	var declTracking = string.Join ("'"' columnsDclTracking.ToArray ());  	var declValuesTracking = string.Join ("'"' columnsValuesTracking.ToArray ());  	var declValuePairs = columnsDcl.Zip (columnsValues' (col' val) => col + "=" + val).ToArray ();  	var declValuePairsStr = string.Join ("'"' declValuePairs);  	// Creating queries  	var queryInsert = String.Format (SQLiteConstants.InsertOrIgnoreFromChanges' map.TableName' decl' declValues);  	var queryUpdate = String.Format (SQLiteConstants.UpdateOrIgnoreFromChanges' map.TableName' declValuePairsStr' map.GetPrimaryKeysWhereClause);  	var queryUpdateTracking = String.Format (SQLiteConstants.InsertOrReplaceTrackingFromChanges' map.TableName' declTracking' declValuesTracking);  	var queryDelete = String.Format (SQLiteConstants.DeleteFromChanges' map.TableName' map.GetPrimaryKeysWhereClause);  	var queryDeleteTracking = String.Format (SQLiteConstants.DeleteTrackingFromChanges' map.TableName' map.GetPrimaryKeysWhereClause);  	string pkeysNames = String.Join ("' "' map.PrimaryKeys.Select (column => column.Name));  	var querySelectItemPrimaryKeyFromTrackingChangesWithOemID = String.Format (SQLiteConstants.SelectItemPrimaryKeyFromTrackingChangesWithOemID' map.TableName' pkeysNames);  	try {  		using (var statement = connection.Prepare ("Begin Transaction")) {  			statement.Step ();  		}  		// Disable Trigger  		this.DisableTriggers (map' connection);  		// Prepare commandsa  		using (var stmtInsert = connection.Prepare (queryInsert))  			using (var stmtUpdate = connection.Prepare (queryUpdate))  				using (var stmtGetprimaryKey = connection.Prepare (querySelectItemPrimaryKeyFromTrackingChangesWithOemID))  					using (var stmtDeleteItem = connection.Prepare (queryDelete))  						using (var stmtDeleteItemTracking = connection.Prepare (queryDeleteTracking))  							using (var stmtTracking = connection.Prepare (queryUpdateTracking)) {  								foreach (var entity in entities) {  									// Foreach entity check if it's a delete action or un insert/update action  									if (entity.ServiceMetadata.IsTombstone) {  										// Delete Action  										// Bind parameter  										BindParameter (stmtGetprimaryKey' 1' entity.ServiceMetadata.Id);  										// Store values of primaryKeys  										Object[] pkeys = new object[map.PrimaryKeys.Length];  										// While row is available (only 1 if it's good)  										while (stmtGetprimaryKey.Step () == SQLiteResult.ROW) {  											for (int i = 0; i < pkeys.Length; i++) {  												// Read the column  												pkeys [i] = ReadCol (stmtGetprimaryKey' i' map.PrimaryKeys [i].ColumnType);  											}  										}  										stmtGetprimaryKey.Reset ();  										// Bind parameters  										for (int i = 0; i < pkeys.Length; i++) {  											BindParameter (stmtDeleteItem' i + 1' pkeys [i]);  											BindParameter (stmtDeleteItemTracking' i + 1' pkeys [i]);  										}  										// Execute the deletion of 2 rows  										stmtDeleteItem.Step ();  										stmtDeleteItem.Reset ();  										stmtDeleteItem.ClearBindings ();  										stmtDeleteItemTracking.Step ();  										stmtDeleteItemTracking.Reset ();  										stmtDeleteItemTracking.ClearBindings ();  									}  									else {  										// Get columns for insert  										var cols = map.Columns;  										// Set values for table  										for (var i = 0; i < cols.Length; i++) {  											var val = cols [i].GetValue (entity);  											BindParameter (stmtInsert' i + 1' val);  											BindParameter (stmtUpdate' i + 1' val);  										}  										// add where clause  										for (var i = 0; i < map.PrimaryKeys.Length; i++) {  											var val = map.PrimaryKeys [i].GetValue (entity);  											BindParameter (stmtUpdate' cols.Length + i + 1' val);  										}  										stmtUpdate.Step ();  										stmtUpdate.Reset ();  										stmtUpdate.ClearBindings ();  										stmtInsert.Step ();  										stmtInsert.Reset ();  										stmtInsert.ClearBindings ();  										// Set Values for tracking table  										BindParameter (stmtTracking' 1' entity.ServiceMetadata.IsTombstone);  										BindParameter (stmtTracking' 2' 0);  										BindParameter (stmtTracking' 3' entity.ServiceMetadata.Id);  										BindParameter (stmtTracking' 4' "ETag");  										var editUri = String.Empty;  										if (entity.ServiceMetadata.EditUri != null && entity.ServiceMetadata.EditUri.IsAbsoluteUri)  											editUri = entity.ServiceMetadata.EditUri.AbsoluteUri;  										BindParameter (stmtTracking' 5' editUri);  										BindParameter (stmtTracking' 6' DateTime.UtcNow);  										// Set values for tracking table  										for (var i = 0; i < map.PrimaryKeys.Length; i++) {  											var val = map.PrimaryKeys [i].GetValue (entity);  											BindParameter (stmtTracking' i + 7' val);  										}  										stmtTracking.Step ();  										stmtTracking.Reset ();  										stmtTracking.ClearBindings ();  									}  								}  								using (var statement = connection.Prepare ("Commit Transaction")) {  									statement.Step ();  								}  							}  	}  	catch (Exception ex) {  		using (var statement = connection.Prepare ("Rollback Transaction")) {  			statement.Step ();  		}  		Debug.WriteLine (ex.Message);  		throw;  	}  	// Re create Triggers  	this.CreateTriggers (ty' connection);  }  
Magic Number,Microsoft.Synchronization.ClientServices.SQLite,SQLiteHelper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteHelper.cs,MergeEntities,The following statement contains a magic number: using (SQLiteConnection connection = new SQLiteConnection (this.localFilePath)) {  	// Get mapping from my type  	var map = manager.GetMapping (ty);  	// Foreach columns' create the list of columns to insert or update  	var columnsDcl = new List<String> ();  	var columnsValues = new List<String> ();  	var columnsDclTracking = new List<String> ();  	var columnsValuesTracking = new List<String> ();  	foreach (var c in map.Columns) {  		columnsDcl.Add ("[" + c.Name + "]");  		columnsValues.Add ("? ");  	}  	foreach (var c in map.PrimaryKeys) {  		columnsDclTracking.Add ("\"" + c.Name + "\"");  		columnsValuesTracking.Add ("? ");  	}  	var decl = string.Join ("'"' columnsDcl.ToArray ());  	var declValues = string.Join ("'"' columnsValues.ToArray ());  	var declTracking = string.Join ("'"' columnsDclTracking.ToArray ());  	var declValuesTracking = string.Join ("'"' columnsValuesTracking.ToArray ());  	var declValuePairs = columnsDcl.Zip (columnsValues' (col' val) => col + "=" + val).ToArray ();  	var declValuePairsStr = string.Join ("'"' declValuePairs);  	// Creating queries  	var queryInsert = String.Format (SQLiteConstants.InsertOrIgnoreFromChanges' map.TableName' decl' declValues);  	var queryUpdate = String.Format (SQLiteConstants.UpdateOrIgnoreFromChanges' map.TableName' declValuePairsStr' map.GetPrimaryKeysWhereClause);  	var queryUpdateTracking = String.Format (SQLiteConstants.InsertOrReplaceTrackingFromChanges' map.TableName' declTracking' declValuesTracking);  	var queryDelete = String.Format (SQLiteConstants.DeleteFromChanges' map.TableName' map.GetPrimaryKeysWhereClause);  	var queryDeleteTracking = String.Format (SQLiteConstants.DeleteTrackingFromChanges' map.TableName' map.GetPrimaryKeysWhereClause);  	string pkeysNames = String.Join ("' "' map.PrimaryKeys.Select (column => column.Name));  	var querySelectItemPrimaryKeyFromTrackingChangesWithOemID = String.Format (SQLiteConstants.SelectItemPrimaryKeyFromTrackingChangesWithOemID' map.TableName' pkeysNames);  	try {  		using (var statement = connection.Prepare ("Begin Transaction")) {  			statement.Step ();  		}  		// Disable Trigger  		this.DisableTriggers (map' connection);  		// Prepare commandsa  		using (var stmtInsert = connection.Prepare (queryInsert))  			using (var stmtUpdate = connection.Prepare (queryUpdate))  				using (var stmtGetprimaryKey = connection.Prepare (querySelectItemPrimaryKeyFromTrackingChangesWithOemID))  					using (var stmtDeleteItem = connection.Prepare (queryDelete))  						using (var stmtDeleteItemTracking = connection.Prepare (queryDeleteTracking))  							using (var stmtTracking = connection.Prepare (queryUpdateTracking)) {  								foreach (var entity in entities) {  									// Foreach entity check if it's a delete action or un insert/update action  									if (entity.ServiceMetadata.IsTombstone) {  										// Delete Action  										// Bind parameter  										BindParameter (stmtGetprimaryKey' 1' entity.ServiceMetadata.Id);  										// Store values of primaryKeys  										Object[] pkeys = new object[map.PrimaryKeys.Length];  										// While row is available (only 1 if it's good)  										while (stmtGetprimaryKey.Step () == SQLiteResult.ROW) {  											for (int i = 0; i < pkeys.Length; i++) {  												// Read the column  												pkeys [i] = ReadCol (stmtGetprimaryKey' i' map.PrimaryKeys [i].ColumnType);  											}  										}  										stmtGetprimaryKey.Reset ();  										// Bind parameters  										for (int i = 0; i < pkeys.Length; i++) {  											BindParameter (stmtDeleteItem' i + 1' pkeys [i]);  											BindParameter (stmtDeleteItemTracking' i + 1' pkeys [i]);  										}  										// Execute the deletion of 2 rows  										stmtDeleteItem.Step ();  										stmtDeleteItem.Reset ();  										stmtDeleteItem.ClearBindings ();  										stmtDeleteItemTracking.Step ();  										stmtDeleteItemTracking.Reset ();  										stmtDeleteItemTracking.ClearBindings ();  									}  									else {  										// Get columns for insert  										var cols = map.Columns;  										// Set values for table  										for (var i = 0; i < cols.Length; i++) {  											var val = cols [i].GetValue (entity);  											BindParameter (stmtInsert' i + 1' val);  											BindParameter (stmtUpdate' i + 1' val);  										}  										// add where clause  										for (var i = 0; i < map.PrimaryKeys.Length; i++) {  											var val = map.PrimaryKeys [i].GetValue (entity);  											BindParameter (stmtUpdate' cols.Length + i + 1' val);  										}  										stmtUpdate.Step ();  										stmtUpdate.Reset ();  										stmtUpdate.ClearBindings ();  										stmtInsert.Step ();  										stmtInsert.Reset ();  										stmtInsert.ClearBindings ();  										// Set Values for tracking table  										BindParameter (stmtTracking' 1' entity.ServiceMetadata.IsTombstone);  										BindParameter (stmtTracking' 2' 0);  										BindParameter (stmtTracking' 3' entity.ServiceMetadata.Id);  										BindParameter (stmtTracking' 4' "ETag");  										var editUri = String.Empty;  										if (entity.ServiceMetadata.EditUri != null && entity.ServiceMetadata.EditUri.IsAbsoluteUri)  											editUri = entity.ServiceMetadata.EditUri.AbsoluteUri;  										BindParameter (stmtTracking' 5' editUri);  										BindParameter (stmtTracking' 6' DateTime.UtcNow);  										// Set values for tracking table  										for (var i = 0; i < map.PrimaryKeys.Length; i++) {  											var val = map.PrimaryKeys [i].GetValue (entity);  											BindParameter (stmtTracking' i + 7' val);  										}  										stmtTracking.Step ();  										stmtTracking.Reset ();  										stmtTracking.ClearBindings ();  									}  								}  								using (var statement = connection.Prepare ("Commit Transaction")) {  									statement.Step ();  								}  							}  	}  	catch (Exception ex) {  		using (var statement = connection.Prepare ("Rollback Transaction")) {  			statement.Step ();  		}  		Debug.WriteLine (ex.Message);  		throw;  	}  	// Re create Triggers  	this.CreateTriggers (ty' connection);  }  
Magic Number,Microsoft.Synchronization.ClientServices.SQLite,SQLiteHelper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteHelper.cs,MergeEntities,The following statement contains a magic number: using (SQLiteConnection connection = new SQLiteConnection (this.localFilePath)) {  	// Get mapping from my type  	var map = manager.GetMapping (ty);  	// Foreach columns' create the list of columns to insert or update  	var columnsDcl = new List<String> ();  	var columnsValues = new List<String> ();  	var columnsDclTracking = new List<String> ();  	var columnsValuesTracking = new List<String> ();  	foreach (var c in map.Columns) {  		columnsDcl.Add ("[" + c.Name + "]");  		columnsValues.Add ("? ");  	}  	foreach (var c in map.PrimaryKeys) {  		columnsDclTracking.Add ("\"" + c.Name + "\"");  		columnsValuesTracking.Add ("? ");  	}  	var decl = string.Join ("'"' columnsDcl.ToArray ());  	var declValues = string.Join ("'"' columnsValues.ToArray ());  	var declTracking = string.Join ("'"' columnsDclTracking.ToArray ());  	var declValuesTracking = string.Join ("'"' columnsValuesTracking.ToArray ());  	var declValuePairs = columnsDcl.Zip (columnsValues' (col' val) => col + "=" + val).ToArray ();  	var declValuePairsStr = string.Join ("'"' declValuePairs);  	// Creating queries  	var queryInsert = String.Format (SQLiteConstants.InsertOrIgnoreFromChanges' map.TableName' decl' declValues);  	var queryUpdate = String.Format (SQLiteConstants.UpdateOrIgnoreFromChanges' map.TableName' declValuePairsStr' map.GetPrimaryKeysWhereClause);  	var queryUpdateTracking = String.Format (SQLiteConstants.InsertOrReplaceTrackingFromChanges' map.TableName' declTracking' declValuesTracking);  	var queryDelete = String.Format (SQLiteConstants.DeleteFromChanges' map.TableName' map.GetPrimaryKeysWhereClause);  	var queryDeleteTracking = String.Format (SQLiteConstants.DeleteTrackingFromChanges' map.TableName' map.GetPrimaryKeysWhereClause);  	string pkeysNames = String.Join ("' "' map.PrimaryKeys.Select (column => column.Name));  	var querySelectItemPrimaryKeyFromTrackingChangesWithOemID = String.Format (SQLiteConstants.SelectItemPrimaryKeyFromTrackingChangesWithOemID' map.TableName' pkeysNames);  	try {  		using (var statement = connection.Prepare ("Begin Transaction")) {  			statement.Step ();  		}  		// Disable Trigger  		this.DisableTriggers (map' connection);  		// Prepare commandsa  		using (var stmtInsert = connection.Prepare (queryInsert))  			using (var stmtUpdate = connection.Prepare (queryUpdate))  				using (var stmtGetprimaryKey = connection.Prepare (querySelectItemPrimaryKeyFromTrackingChangesWithOemID))  					using (var stmtDeleteItem = connection.Prepare (queryDelete))  						using (var stmtDeleteItemTracking = connection.Prepare (queryDeleteTracking))  							using (var stmtTracking = connection.Prepare (queryUpdateTracking)) {  								foreach (var entity in entities) {  									// Foreach entity check if it's a delete action or un insert/update action  									if (entity.ServiceMetadata.IsTombstone) {  										// Delete Action  										// Bind parameter  										BindParameter (stmtGetprimaryKey' 1' entity.ServiceMetadata.Id);  										// Store values of primaryKeys  										Object[] pkeys = new object[map.PrimaryKeys.Length];  										// While row is available (only 1 if it's good)  										while (stmtGetprimaryKey.Step () == SQLiteResult.ROW) {  											for (int i = 0; i < pkeys.Length; i++) {  												// Read the column  												pkeys [i] = ReadCol (stmtGetprimaryKey' i' map.PrimaryKeys [i].ColumnType);  											}  										}  										stmtGetprimaryKey.Reset ();  										// Bind parameters  										for (int i = 0; i < pkeys.Length; i++) {  											BindParameter (stmtDeleteItem' i + 1' pkeys [i]);  											BindParameter (stmtDeleteItemTracking' i + 1' pkeys [i]);  										}  										// Execute the deletion of 2 rows  										stmtDeleteItem.Step ();  										stmtDeleteItem.Reset ();  										stmtDeleteItem.ClearBindings ();  										stmtDeleteItemTracking.Step ();  										stmtDeleteItemTracking.Reset ();  										stmtDeleteItemTracking.ClearBindings ();  									}  									else {  										// Get columns for insert  										var cols = map.Columns;  										// Set values for table  										for (var i = 0; i < cols.Length; i++) {  											var val = cols [i].GetValue (entity);  											BindParameter (stmtInsert' i + 1' val);  											BindParameter (stmtUpdate' i + 1' val);  										}  										// add where clause  										for (var i = 0; i < map.PrimaryKeys.Length; i++) {  											var val = map.PrimaryKeys [i].GetValue (entity);  											BindParameter (stmtUpdate' cols.Length + i + 1' val);  										}  										stmtUpdate.Step ();  										stmtUpdate.Reset ();  										stmtUpdate.ClearBindings ();  										stmtInsert.Step ();  										stmtInsert.Reset ();  										stmtInsert.ClearBindings ();  										// Set Values for tracking table  										BindParameter (stmtTracking' 1' entity.ServiceMetadata.IsTombstone);  										BindParameter (stmtTracking' 2' 0);  										BindParameter (stmtTracking' 3' entity.ServiceMetadata.Id);  										BindParameter (stmtTracking' 4' "ETag");  										var editUri = String.Empty;  										if (entity.ServiceMetadata.EditUri != null && entity.ServiceMetadata.EditUri.IsAbsoluteUri)  											editUri = entity.ServiceMetadata.EditUri.AbsoluteUri;  										BindParameter (stmtTracking' 5' editUri);  										BindParameter (stmtTracking' 6' DateTime.UtcNow);  										// Set values for tracking table  										for (var i = 0; i < map.PrimaryKeys.Length; i++) {  											var val = map.PrimaryKeys [i].GetValue (entity);  											BindParameter (stmtTracking' i + 7' val);  										}  										stmtTracking.Step ();  										stmtTracking.Reset ();  										stmtTracking.ClearBindings ();  									}  								}  								using (var statement = connection.Prepare ("Commit Transaction")) {  									statement.Step ();  								}  							}  	}  	catch (Exception ex) {  		using (var statement = connection.Prepare ("Rollback Transaction")) {  			statement.Step ();  		}  		Debug.WriteLine (ex.Message);  		throw;  	}  	// Re create Triggers  	this.CreateTriggers (ty' connection);  }  
Magic Number,Microsoft.Synchronization.ClientServices.SQLite,SQLiteHelper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteHelper.cs,MergeEntities,The following statement contains a magic number: try {  	using (var statement = connection.Prepare ("Begin Transaction")) {  		statement.Step ();  	}  	// Disable Trigger  	this.DisableTriggers (map' connection);  	// Prepare commandsa  	using (var stmtInsert = connection.Prepare (queryInsert))  		using (var stmtUpdate = connection.Prepare (queryUpdate))  			using (var stmtGetprimaryKey = connection.Prepare (querySelectItemPrimaryKeyFromTrackingChangesWithOemID))  				using (var stmtDeleteItem = connection.Prepare (queryDelete))  					using (var stmtDeleteItemTracking = connection.Prepare (queryDeleteTracking))  						using (var stmtTracking = connection.Prepare (queryUpdateTracking)) {  							foreach (var entity in entities) {  								// Foreach entity check if it's a delete action or un insert/update action  								if (entity.ServiceMetadata.IsTombstone) {  									// Delete Action  									// Bind parameter  									BindParameter (stmtGetprimaryKey' 1' entity.ServiceMetadata.Id);  									// Store values of primaryKeys  									Object[] pkeys = new object[map.PrimaryKeys.Length];  									// While row is available (only 1 if it's good)  									while (stmtGetprimaryKey.Step () == SQLiteResult.ROW) {  										for (int i = 0; i < pkeys.Length; i++) {  											// Read the column  											pkeys [i] = ReadCol (stmtGetprimaryKey' i' map.PrimaryKeys [i].ColumnType);  										}  									}  									stmtGetprimaryKey.Reset ();  									// Bind parameters  									for (int i = 0; i < pkeys.Length; i++) {  										BindParameter (stmtDeleteItem' i + 1' pkeys [i]);  										BindParameter (stmtDeleteItemTracking' i + 1' pkeys [i]);  									}  									// Execute the deletion of 2 rows  									stmtDeleteItem.Step ();  									stmtDeleteItem.Reset ();  									stmtDeleteItem.ClearBindings ();  									stmtDeleteItemTracking.Step ();  									stmtDeleteItemTracking.Reset ();  									stmtDeleteItemTracking.ClearBindings ();  								}  								else {  									// Get columns for insert  									var cols = map.Columns;  									// Set values for table  									for (var i = 0; i < cols.Length; i++) {  										var val = cols [i].GetValue (entity);  										BindParameter (stmtInsert' i + 1' val);  										BindParameter (stmtUpdate' i + 1' val);  									}  									// add where clause  									for (var i = 0; i < map.PrimaryKeys.Length; i++) {  										var val = map.PrimaryKeys [i].GetValue (entity);  										BindParameter (stmtUpdate' cols.Length + i + 1' val);  									}  									stmtUpdate.Step ();  									stmtUpdate.Reset ();  									stmtUpdate.ClearBindings ();  									stmtInsert.Step ();  									stmtInsert.Reset ();  									stmtInsert.ClearBindings ();  									// Set Values for tracking table  									BindParameter (stmtTracking' 1' entity.ServiceMetadata.IsTombstone);  									BindParameter (stmtTracking' 2' 0);  									BindParameter (stmtTracking' 3' entity.ServiceMetadata.Id);  									BindParameter (stmtTracking' 4' "ETag");  									var editUri = String.Empty;  									if (entity.ServiceMetadata.EditUri != null && entity.ServiceMetadata.EditUri.IsAbsoluteUri)  										editUri = entity.ServiceMetadata.EditUri.AbsoluteUri;  									BindParameter (stmtTracking' 5' editUri);  									BindParameter (stmtTracking' 6' DateTime.UtcNow);  									// Set values for tracking table  									for (var i = 0; i < map.PrimaryKeys.Length; i++) {  										var val = map.PrimaryKeys [i].GetValue (entity);  										BindParameter (stmtTracking' i + 7' val);  									}  									stmtTracking.Step ();  									stmtTracking.Reset ();  									stmtTracking.ClearBindings ();  								}  							}  							using (var statement = connection.Prepare ("Commit Transaction")) {  								statement.Step ();  							}  						}  }  catch (Exception ex) {  	using (var statement = connection.Prepare ("Rollback Transaction")) {  		statement.Step ();  	}  	Debug.WriteLine (ex.Message);  	throw;  }  
Magic Number,Microsoft.Synchronization.ClientServices.SQLite,SQLiteHelper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteHelper.cs,MergeEntities,The following statement contains a magic number: try {  	using (var statement = connection.Prepare ("Begin Transaction")) {  		statement.Step ();  	}  	// Disable Trigger  	this.DisableTriggers (map' connection);  	// Prepare commandsa  	using (var stmtInsert = connection.Prepare (queryInsert))  		using (var stmtUpdate = connection.Prepare (queryUpdate))  			using (var stmtGetprimaryKey = connection.Prepare (querySelectItemPrimaryKeyFromTrackingChangesWithOemID))  				using (var stmtDeleteItem = connection.Prepare (queryDelete))  					using (var stmtDeleteItemTracking = connection.Prepare (queryDeleteTracking))  						using (var stmtTracking = connection.Prepare (queryUpdateTracking)) {  							foreach (var entity in entities) {  								// Foreach entity check if it's a delete action or un insert/update action  								if (entity.ServiceMetadata.IsTombstone) {  									// Delete Action  									// Bind parameter  									BindParameter (stmtGetprimaryKey' 1' entity.ServiceMetadata.Id);  									// Store values of primaryKeys  									Object[] pkeys = new object[map.PrimaryKeys.Length];  									// While row is available (only 1 if it's good)  									while (stmtGetprimaryKey.Step () == SQLiteResult.ROW) {  										for (int i = 0; i < pkeys.Length; i++) {  											// Read the column  											pkeys [i] = ReadCol (stmtGetprimaryKey' i' map.PrimaryKeys [i].ColumnType);  										}  									}  									stmtGetprimaryKey.Reset ();  									// Bind parameters  									for (int i = 0; i < pkeys.Length; i++) {  										BindParameter (stmtDeleteItem' i + 1' pkeys [i]);  										BindParameter (stmtDeleteItemTracking' i + 1' pkeys [i]);  									}  									// Execute the deletion of 2 rows  									stmtDeleteItem.Step ();  									stmtDeleteItem.Reset ();  									stmtDeleteItem.ClearBindings ();  									stmtDeleteItemTracking.Step ();  									stmtDeleteItemTracking.Reset ();  									stmtDeleteItemTracking.ClearBindings ();  								}  								else {  									// Get columns for insert  									var cols = map.Columns;  									// Set values for table  									for (var i = 0; i < cols.Length; i++) {  										var val = cols [i].GetValue (entity);  										BindParameter (stmtInsert' i + 1' val);  										BindParameter (stmtUpdate' i + 1' val);  									}  									// add where clause  									for (var i = 0; i < map.PrimaryKeys.Length; i++) {  										var val = map.PrimaryKeys [i].GetValue (entity);  										BindParameter (stmtUpdate' cols.Length + i + 1' val);  									}  									stmtUpdate.Step ();  									stmtUpdate.Reset ();  									stmtUpdate.ClearBindings ();  									stmtInsert.Step ();  									stmtInsert.Reset ();  									stmtInsert.ClearBindings ();  									// Set Values for tracking table  									BindParameter (stmtTracking' 1' entity.ServiceMetadata.IsTombstone);  									BindParameter (stmtTracking' 2' 0);  									BindParameter (stmtTracking' 3' entity.ServiceMetadata.Id);  									BindParameter (stmtTracking' 4' "ETag");  									var editUri = String.Empty;  									if (entity.ServiceMetadata.EditUri != null && entity.ServiceMetadata.EditUri.IsAbsoluteUri)  										editUri = entity.ServiceMetadata.EditUri.AbsoluteUri;  									BindParameter (stmtTracking' 5' editUri);  									BindParameter (stmtTracking' 6' DateTime.UtcNow);  									// Set values for tracking table  									for (var i = 0; i < map.PrimaryKeys.Length; i++) {  										var val = map.PrimaryKeys [i].GetValue (entity);  										BindParameter (stmtTracking' i + 7' val);  									}  									stmtTracking.Step ();  									stmtTracking.Reset ();  									stmtTracking.ClearBindings ();  								}  							}  							using (var statement = connection.Prepare ("Commit Transaction")) {  								statement.Step ();  							}  						}  }  catch (Exception ex) {  	using (var statement = connection.Prepare ("Rollback Transaction")) {  		statement.Step ();  	}  	Debug.WriteLine (ex.Message);  	throw;  }  
Magic Number,Microsoft.Synchronization.ClientServices.SQLite,SQLiteHelper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteHelper.cs,MergeEntities,The following statement contains a magic number: try {  	using (var statement = connection.Prepare ("Begin Transaction")) {  		statement.Step ();  	}  	// Disable Trigger  	this.DisableTriggers (map' connection);  	// Prepare commandsa  	using (var stmtInsert = connection.Prepare (queryInsert))  		using (var stmtUpdate = connection.Prepare (queryUpdate))  			using (var stmtGetprimaryKey = connection.Prepare (querySelectItemPrimaryKeyFromTrackingChangesWithOemID))  				using (var stmtDeleteItem = connection.Prepare (queryDelete))  					using (var stmtDeleteItemTracking = connection.Prepare (queryDeleteTracking))  						using (var stmtTracking = connection.Prepare (queryUpdateTracking)) {  							foreach (var entity in entities) {  								// Foreach entity check if it's a delete action or un insert/update action  								if (entity.ServiceMetadata.IsTombstone) {  									// Delete Action  									// Bind parameter  									BindParameter (stmtGetprimaryKey' 1' entity.ServiceMetadata.Id);  									// Store values of primaryKeys  									Object[] pkeys = new object[map.PrimaryKeys.Length];  									// While row is available (only 1 if it's good)  									while (stmtGetprimaryKey.Step () == SQLiteResult.ROW) {  										for (int i = 0; i < pkeys.Length; i++) {  											// Read the column  											pkeys [i] = ReadCol (stmtGetprimaryKey' i' map.PrimaryKeys [i].ColumnType);  										}  									}  									stmtGetprimaryKey.Reset ();  									// Bind parameters  									for (int i = 0; i < pkeys.Length; i++) {  										BindParameter (stmtDeleteItem' i + 1' pkeys [i]);  										BindParameter (stmtDeleteItemTracking' i + 1' pkeys [i]);  									}  									// Execute the deletion of 2 rows  									stmtDeleteItem.Step ();  									stmtDeleteItem.Reset ();  									stmtDeleteItem.ClearBindings ();  									stmtDeleteItemTracking.Step ();  									stmtDeleteItemTracking.Reset ();  									stmtDeleteItemTracking.ClearBindings ();  								}  								else {  									// Get columns for insert  									var cols = map.Columns;  									// Set values for table  									for (var i = 0; i < cols.Length; i++) {  										var val = cols [i].GetValue (entity);  										BindParameter (stmtInsert' i + 1' val);  										BindParameter (stmtUpdate' i + 1' val);  									}  									// add where clause  									for (var i = 0; i < map.PrimaryKeys.Length; i++) {  										var val = map.PrimaryKeys [i].GetValue (entity);  										BindParameter (stmtUpdate' cols.Length + i + 1' val);  									}  									stmtUpdate.Step ();  									stmtUpdate.Reset ();  									stmtUpdate.ClearBindings ();  									stmtInsert.Step ();  									stmtInsert.Reset ();  									stmtInsert.ClearBindings ();  									// Set Values for tracking table  									BindParameter (stmtTracking' 1' entity.ServiceMetadata.IsTombstone);  									BindParameter (stmtTracking' 2' 0);  									BindParameter (stmtTracking' 3' entity.ServiceMetadata.Id);  									BindParameter (stmtTracking' 4' "ETag");  									var editUri = String.Empty;  									if (entity.ServiceMetadata.EditUri != null && entity.ServiceMetadata.EditUri.IsAbsoluteUri)  										editUri = entity.ServiceMetadata.EditUri.AbsoluteUri;  									BindParameter (stmtTracking' 5' editUri);  									BindParameter (stmtTracking' 6' DateTime.UtcNow);  									// Set values for tracking table  									for (var i = 0; i < map.PrimaryKeys.Length; i++) {  										var val = map.PrimaryKeys [i].GetValue (entity);  										BindParameter (stmtTracking' i + 7' val);  									}  									stmtTracking.Step ();  									stmtTracking.Reset ();  									stmtTracking.ClearBindings ();  								}  							}  							using (var statement = connection.Prepare ("Commit Transaction")) {  								statement.Step ();  							}  						}  }  catch (Exception ex) {  	using (var statement = connection.Prepare ("Rollback Transaction")) {  		statement.Step ();  	}  	Debug.WriteLine (ex.Message);  	throw;  }  
Magic Number,Microsoft.Synchronization.ClientServices.SQLite,SQLiteHelper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteHelper.cs,MergeEntities,The following statement contains a magic number: try {  	using (var statement = connection.Prepare ("Begin Transaction")) {  		statement.Step ();  	}  	// Disable Trigger  	this.DisableTriggers (map' connection);  	// Prepare commandsa  	using (var stmtInsert = connection.Prepare (queryInsert))  		using (var stmtUpdate = connection.Prepare (queryUpdate))  			using (var stmtGetprimaryKey = connection.Prepare (querySelectItemPrimaryKeyFromTrackingChangesWithOemID))  				using (var stmtDeleteItem = connection.Prepare (queryDelete))  					using (var stmtDeleteItemTracking = connection.Prepare (queryDeleteTracking))  						using (var stmtTracking = connection.Prepare (queryUpdateTracking)) {  							foreach (var entity in entities) {  								// Foreach entity check if it's a delete action or un insert/update action  								if (entity.ServiceMetadata.IsTombstone) {  									// Delete Action  									// Bind parameter  									BindParameter (stmtGetprimaryKey' 1' entity.ServiceMetadata.Id);  									// Store values of primaryKeys  									Object[] pkeys = new object[map.PrimaryKeys.Length];  									// While row is available (only 1 if it's good)  									while (stmtGetprimaryKey.Step () == SQLiteResult.ROW) {  										for (int i = 0; i < pkeys.Length; i++) {  											// Read the column  											pkeys [i] = ReadCol (stmtGetprimaryKey' i' map.PrimaryKeys [i].ColumnType);  										}  									}  									stmtGetprimaryKey.Reset ();  									// Bind parameters  									for (int i = 0; i < pkeys.Length; i++) {  										BindParameter (stmtDeleteItem' i + 1' pkeys [i]);  										BindParameter (stmtDeleteItemTracking' i + 1' pkeys [i]);  									}  									// Execute the deletion of 2 rows  									stmtDeleteItem.Step ();  									stmtDeleteItem.Reset ();  									stmtDeleteItem.ClearBindings ();  									stmtDeleteItemTracking.Step ();  									stmtDeleteItemTracking.Reset ();  									stmtDeleteItemTracking.ClearBindings ();  								}  								else {  									// Get columns for insert  									var cols = map.Columns;  									// Set values for table  									for (var i = 0; i < cols.Length; i++) {  										var val = cols [i].GetValue (entity);  										BindParameter (stmtInsert' i + 1' val);  										BindParameter (stmtUpdate' i + 1' val);  									}  									// add where clause  									for (var i = 0; i < map.PrimaryKeys.Length; i++) {  										var val = map.PrimaryKeys [i].GetValue (entity);  										BindParameter (stmtUpdate' cols.Length + i + 1' val);  									}  									stmtUpdate.Step ();  									stmtUpdate.Reset ();  									stmtUpdate.ClearBindings ();  									stmtInsert.Step ();  									stmtInsert.Reset ();  									stmtInsert.ClearBindings ();  									// Set Values for tracking table  									BindParameter (stmtTracking' 1' entity.ServiceMetadata.IsTombstone);  									BindParameter (stmtTracking' 2' 0);  									BindParameter (stmtTracking' 3' entity.ServiceMetadata.Id);  									BindParameter (stmtTracking' 4' "ETag");  									var editUri = String.Empty;  									if (entity.ServiceMetadata.EditUri != null && entity.ServiceMetadata.EditUri.IsAbsoluteUri)  										editUri = entity.ServiceMetadata.EditUri.AbsoluteUri;  									BindParameter (stmtTracking' 5' editUri);  									BindParameter (stmtTracking' 6' DateTime.UtcNow);  									// Set values for tracking table  									for (var i = 0; i < map.PrimaryKeys.Length; i++) {  										var val = map.PrimaryKeys [i].GetValue (entity);  										BindParameter (stmtTracking' i + 7' val);  									}  									stmtTracking.Step ();  									stmtTracking.Reset ();  									stmtTracking.ClearBindings ();  								}  							}  							using (var statement = connection.Prepare ("Commit Transaction")) {  								statement.Step ();  							}  						}  }  catch (Exception ex) {  	using (var statement = connection.Prepare ("Rollback Transaction")) {  		statement.Step ();  	}  	Debug.WriteLine (ex.Message);  	throw;  }  
Magic Number,Microsoft.Synchronization.ClientServices.SQLite,SQLiteHelper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteHelper.cs,MergeEntities,The following statement contains a magic number: try {  	using (var statement = connection.Prepare ("Begin Transaction")) {  		statement.Step ();  	}  	// Disable Trigger  	this.DisableTriggers (map' connection);  	// Prepare commandsa  	using (var stmtInsert = connection.Prepare (queryInsert))  		using (var stmtUpdate = connection.Prepare (queryUpdate))  			using (var stmtGetprimaryKey = connection.Prepare (querySelectItemPrimaryKeyFromTrackingChangesWithOemID))  				using (var stmtDeleteItem = connection.Prepare (queryDelete))  					using (var stmtDeleteItemTracking = connection.Prepare (queryDeleteTracking))  						using (var stmtTracking = connection.Prepare (queryUpdateTracking)) {  							foreach (var entity in entities) {  								// Foreach entity check if it's a delete action or un insert/update action  								if (entity.ServiceMetadata.IsTombstone) {  									// Delete Action  									// Bind parameter  									BindParameter (stmtGetprimaryKey' 1' entity.ServiceMetadata.Id);  									// Store values of primaryKeys  									Object[] pkeys = new object[map.PrimaryKeys.Length];  									// While row is available (only 1 if it's good)  									while (stmtGetprimaryKey.Step () == SQLiteResult.ROW) {  										for (int i = 0; i < pkeys.Length; i++) {  											// Read the column  											pkeys [i] = ReadCol (stmtGetprimaryKey' i' map.PrimaryKeys [i].ColumnType);  										}  									}  									stmtGetprimaryKey.Reset ();  									// Bind parameters  									for (int i = 0; i < pkeys.Length; i++) {  										BindParameter (stmtDeleteItem' i + 1' pkeys [i]);  										BindParameter (stmtDeleteItemTracking' i + 1' pkeys [i]);  									}  									// Execute the deletion of 2 rows  									stmtDeleteItem.Step ();  									stmtDeleteItem.Reset ();  									stmtDeleteItem.ClearBindings ();  									stmtDeleteItemTracking.Step ();  									stmtDeleteItemTracking.Reset ();  									stmtDeleteItemTracking.ClearBindings ();  								}  								else {  									// Get columns for insert  									var cols = map.Columns;  									// Set values for table  									for (var i = 0; i < cols.Length; i++) {  										var val = cols [i].GetValue (entity);  										BindParameter (stmtInsert' i + 1' val);  										BindParameter (stmtUpdate' i + 1' val);  									}  									// add where clause  									for (var i = 0; i < map.PrimaryKeys.Length; i++) {  										var val = map.PrimaryKeys [i].GetValue (entity);  										BindParameter (stmtUpdate' cols.Length + i + 1' val);  									}  									stmtUpdate.Step ();  									stmtUpdate.Reset ();  									stmtUpdate.ClearBindings ();  									stmtInsert.Step ();  									stmtInsert.Reset ();  									stmtInsert.ClearBindings ();  									// Set Values for tracking table  									BindParameter (stmtTracking' 1' entity.ServiceMetadata.IsTombstone);  									BindParameter (stmtTracking' 2' 0);  									BindParameter (stmtTracking' 3' entity.ServiceMetadata.Id);  									BindParameter (stmtTracking' 4' "ETag");  									var editUri = String.Empty;  									if (entity.ServiceMetadata.EditUri != null && entity.ServiceMetadata.EditUri.IsAbsoluteUri)  										editUri = entity.ServiceMetadata.EditUri.AbsoluteUri;  									BindParameter (stmtTracking' 5' editUri);  									BindParameter (stmtTracking' 6' DateTime.UtcNow);  									// Set values for tracking table  									for (var i = 0; i < map.PrimaryKeys.Length; i++) {  										var val = map.PrimaryKeys [i].GetValue (entity);  										BindParameter (stmtTracking' i + 7' val);  									}  									stmtTracking.Step ();  									stmtTracking.Reset ();  									stmtTracking.ClearBindings ();  								}  							}  							using (var statement = connection.Prepare ("Commit Transaction")) {  								statement.Step ();  							}  						}  }  catch (Exception ex) {  	using (var statement = connection.Prepare ("Rollback Transaction")) {  		statement.Step ();  	}  	Debug.WriteLine (ex.Message);  	throw;  }  
Magic Number,Microsoft.Synchronization.ClientServices.SQLite,SQLiteHelper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteHelper.cs,MergeEntities,The following statement contains a magic number: try {  	using (var statement = connection.Prepare ("Begin Transaction")) {  		statement.Step ();  	}  	// Disable Trigger  	this.DisableTriggers (map' connection);  	// Prepare commandsa  	using (var stmtInsert = connection.Prepare (queryInsert))  		using (var stmtUpdate = connection.Prepare (queryUpdate))  			using (var stmtGetprimaryKey = connection.Prepare (querySelectItemPrimaryKeyFromTrackingChangesWithOemID))  				using (var stmtDeleteItem = connection.Prepare (queryDelete))  					using (var stmtDeleteItemTracking = connection.Prepare (queryDeleteTracking))  						using (var stmtTracking = connection.Prepare (queryUpdateTracking)) {  							foreach (var entity in entities) {  								// Foreach entity check if it's a delete action or un insert/update action  								if (entity.ServiceMetadata.IsTombstone) {  									// Delete Action  									// Bind parameter  									BindParameter (stmtGetprimaryKey' 1' entity.ServiceMetadata.Id);  									// Store values of primaryKeys  									Object[] pkeys = new object[map.PrimaryKeys.Length];  									// While row is available (only 1 if it's good)  									while (stmtGetprimaryKey.Step () == SQLiteResult.ROW) {  										for (int i = 0; i < pkeys.Length; i++) {  											// Read the column  											pkeys [i] = ReadCol (stmtGetprimaryKey' i' map.PrimaryKeys [i].ColumnType);  										}  									}  									stmtGetprimaryKey.Reset ();  									// Bind parameters  									for (int i = 0; i < pkeys.Length; i++) {  										BindParameter (stmtDeleteItem' i + 1' pkeys [i]);  										BindParameter (stmtDeleteItemTracking' i + 1' pkeys [i]);  									}  									// Execute the deletion of 2 rows  									stmtDeleteItem.Step ();  									stmtDeleteItem.Reset ();  									stmtDeleteItem.ClearBindings ();  									stmtDeleteItemTracking.Step ();  									stmtDeleteItemTracking.Reset ();  									stmtDeleteItemTracking.ClearBindings ();  								}  								else {  									// Get columns for insert  									var cols = map.Columns;  									// Set values for table  									for (var i = 0; i < cols.Length; i++) {  										var val = cols [i].GetValue (entity);  										BindParameter (stmtInsert' i + 1' val);  										BindParameter (stmtUpdate' i + 1' val);  									}  									// add where clause  									for (var i = 0; i < map.PrimaryKeys.Length; i++) {  										var val = map.PrimaryKeys [i].GetValue (entity);  										BindParameter (stmtUpdate' cols.Length + i + 1' val);  									}  									stmtUpdate.Step ();  									stmtUpdate.Reset ();  									stmtUpdate.ClearBindings ();  									stmtInsert.Step ();  									stmtInsert.Reset ();  									stmtInsert.ClearBindings ();  									// Set Values for tracking table  									BindParameter (stmtTracking' 1' entity.ServiceMetadata.IsTombstone);  									BindParameter (stmtTracking' 2' 0);  									BindParameter (stmtTracking' 3' entity.ServiceMetadata.Id);  									BindParameter (stmtTracking' 4' "ETag");  									var editUri = String.Empty;  									if (entity.ServiceMetadata.EditUri != null && entity.ServiceMetadata.EditUri.IsAbsoluteUri)  										editUri = entity.ServiceMetadata.EditUri.AbsoluteUri;  									BindParameter (stmtTracking' 5' editUri);  									BindParameter (stmtTracking' 6' DateTime.UtcNow);  									// Set values for tracking table  									for (var i = 0; i < map.PrimaryKeys.Length; i++) {  										var val = map.PrimaryKeys [i].GetValue (entity);  										BindParameter (stmtTracking' i + 7' val);  									}  									stmtTracking.Step ();  									stmtTracking.Reset ();  									stmtTracking.ClearBindings ();  								}  							}  							using (var statement = connection.Prepare ("Commit Transaction")) {  								statement.Step ();  							}  						}  }  catch (Exception ex) {  	using (var statement = connection.Prepare ("Rollback Transaction")) {  		statement.Step ();  	}  	Debug.WriteLine (ex.Message);  	throw;  }  
Magic Number,Microsoft.Synchronization.ClientServices.SQLite,SQLiteHelper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteHelper.cs,MergeEntities,The following statement contains a magic number: using (var stmtInsert = connection.Prepare (queryInsert))  	using (var stmtUpdate = connection.Prepare (queryUpdate))  		using (var stmtGetprimaryKey = connection.Prepare (querySelectItemPrimaryKeyFromTrackingChangesWithOemID))  			using (var stmtDeleteItem = connection.Prepare (queryDelete))  				using (var stmtDeleteItemTracking = connection.Prepare (queryDeleteTracking))  					using (var stmtTracking = connection.Prepare (queryUpdateTracking)) {  						foreach (var entity in entities) {  							// Foreach entity check if it's a delete action or un insert/update action  							if (entity.ServiceMetadata.IsTombstone) {  								// Delete Action  								// Bind parameter  								BindParameter (stmtGetprimaryKey' 1' entity.ServiceMetadata.Id);  								// Store values of primaryKeys  								Object[] pkeys = new object[map.PrimaryKeys.Length];  								// While row is available (only 1 if it's good)  								while (stmtGetprimaryKey.Step () == SQLiteResult.ROW) {  									for (int i = 0; i < pkeys.Length; i++) {  										// Read the column  										pkeys [i] = ReadCol (stmtGetprimaryKey' i' map.PrimaryKeys [i].ColumnType);  									}  								}  								stmtGetprimaryKey.Reset ();  								// Bind parameters  								for (int i = 0; i < pkeys.Length; i++) {  									BindParameter (stmtDeleteItem' i + 1' pkeys [i]);  									BindParameter (stmtDeleteItemTracking' i + 1' pkeys [i]);  								}  								// Execute the deletion of 2 rows  								stmtDeleteItem.Step ();  								stmtDeleteItem.Reset ();  								stmtDeleteItem.ClearBindings ();  								stmtDeleteItemTracking.Step ();  								stmtDeleteItemTracking.Reset ();  								stmtDeleteItemTracking.ClearBindings ();  							}  							else {  								// Get columns for insert  								var cols = map.Columns;  								// Set values for table  								for (var i = 0; i < cols.Length; i++) {  									var val = cols [i].GetValue (entity);  									BindParameter (stmtInsert' i + 1' val);  									BindParameter (stmtUpdate' i + 1' val);  								}  								// add where clause  								for (var i = 0; i < map.PrimaryKeys.Length; i++) {  									var val = map.PrimaryKeys [i].GetValue (entity);  									BindParameter (stmtUpdate' cols.Length + i + 1' val);  								}  								stmtUpdate.Step ();  								stmtUpdate.Reset ();  								stmtUpdate.ClearBindings ();  								stmtInsert.Step ();  								stmtInsert.Reset ();  								stmtInsert.ClearBindings ();  								// Set Values for tracking table  								BindParameter (stmtTracking' 1' entity.ServiceMetadata.IsTombstone);  								BindParameter (stmtTracking' 2' 0);  								BindParameter (stmtTracking' 3' entity.ServiceMetadata.Id);  								BindParameter (stmtTracking' 4' "ETag");  								var editUri = String.Empty;  								if (entity.ServiceMetadata.EditUri != null && entity.ServiceMetadata.EditUri.IsAbsoluteUri)  									editUri = entity.ServiceMetadata.EditUri.AbsoluteUri;  								BindParameter (stmtTracking' 5' editUri);  								BindParameter (stmtTracking' 6' DateTime.UtcNow);  								// Set values for tracking table  								for (var i = 0; i < map.PrimaryKeys.Length; i++) {  									var val = map.PrimaryKeys [i].GetValue (entity);  									BindParameter (stmtTracking' i + 7' val);  								}  								stmtTracking.Step ();  								stmtTracking.Reset ();  								stmtTracking.ClearBindings ();  							}  						}  						using (var statement = connection.Prepare ("Commit Transaction")) {  							statement.Step ();  						}  					}  
Magic Number,Microsoft.Synchronization.ClientServices.SQLite,SQLiteHelper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteHelper.cs,MergeEntities,The following statement contains a magic number: using (var stmtInsert = connection.Prepare (queryInsert))  	using (var stmtUpdate = connection.Prepare (queryUpdate))  		using (var stmtGetprimaryKey = connection.Prepare (querySelectItemPrimaryKeyFromTrackingChangesWithOemID))  			using (var stmtDeleteItem = connection.Prepare (queryDelete))  				using (var stmtDeleteItemTracking = connection.Prepare (queryDeleteTracking))  					using (var stmtTracking = connection.Prepare (queryUpdateTracking)) {  						foreach (var entity in entities) {  							// Foreach entity check if it's a delete action or un insert/update action  							if (entity.ServiceMetadata.IsTombstone) {  								// Delete Action  								// Bind parameter  								BindParameter (stmtGetprimaryKey' 1' entity.ServiceMetadata.Id);  								// Store values of primaryKeys  								Object[] pkeys = new object[map.PrimaryKeys.Length];  								// While row is available (only 1 if it's good)  								while (stmtGetprimaryKey.Step () == SQLiteResult.ROW) {  									for (int i = 0; i < pkeys.Length; i++) {  										// Read the column  										pkeys [i] = ReadCol (stmtGetprimaryKey' i' map.PrimaryKeys [i].ColumnType);  									}  								}  								stmtGetprimaryKey.Reset ();  								// Bind parameters  								for (int i = 0; i < pkeys.Length; i++) {  									BindParameter (stmtDeleteItem' i + 1' pkeys [i]);  									BindParameter (stmtDeleteItemTracking' i + 1' pkeys [i]);  								}  								// Execute the deletion of 2 rows  								stmtDeleteItem.Step ();  								stmtDeleteItem.Reset ();  								stmtDeleteItem.ClearBindings ();  								stmtDeleteItemTracking.Step ();  								stmtDeleteItemTracking.Reset ();  								stmtDeleteItemTracking.ClearBindings ();  							}  							else {  								// Get columns for insert  								var cols = map.Columns;  								// Set values for table  								for (var i = 0; i < cols.Length; i++) {  									var val = cols [i].GetValue (entity);  									BindParameter (stmtInsert' i + 1' val);  									BindParameter (stmtUpdate' i + 1' val);  								}  								// add where clause  								for (var i = 0; i < map.PrimaryKeys.Length; i++) {  									var val = map.PrimaryKeys [i].GetValue (entity);  									BindParameter (stmtUpdate' cols.Length + i + 1' val);  								}  								stmtUpdate.Step ();  								stmtUpdate.Reset ();  								stmtUpdate.ClearBindings ();  								stmtInsert.Step ();  								stmtInsert.Reset ();  								stmtInsert.ClearBindings ();  								// Set Values for tracking table  								BindParameter (stmtTracking' 1' entity.ServiceMetadata.IsTombstone);  								BindParameter (stmtTracking' 2' 0);  								BindParameter (stmtTracking' 3' entity.ServiceMetadata.Id);  								BindParameter (stmtTracking' 4' "ETag");  								var editUri = String.Empty;  								if (entity.ServiceMetadata.EditUri != null && entity.ServiceMetadata.EditUri.IsAbsoluteUri)  									editUri = entity.ServiceMetadata.EditUri.AbsoluteUri;  								BindParameter (stmtTracking' 5' editUri);  								BindParameter (stmtTracking' 6' DateTime.UtcNow);  								// Set values for tracking table  								for (var i = 0; i < map.PrimaryKeys.Length; i++) {  									var val = map.PrimaryKeys [i].GetValue (entity);  									BindParameter (stmtTracking' i + 7' val);  								}  								stmtTracking.Step ();  								stmtTracking.Reset ();  								stmtTracking.ClearBindings ();  							}  						}  						using (var statement = connection.Prepare ("Commit Transaction")) {  							statement.Step ();  						}  					}  
Magic Number,Microsoft.Synchronization.ClientServices.SQLite,SQLiteHelper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteHelper.cs,MergeEntities,The following statement contains a magic number: using (var stmtInsert = connection.Prepare (queryInsert))  	using (var stmtUpdate = connection.Prepare (queryUpdate))  		using (var stmtGetprimaryKey = connection.Prepare (querySelectItemPrimaryKeyFromTrackingChangesWithOemID))  			using (var stmtDeleteItem = connection.Prepare (queryDelete))  				using (var stmtDeleteItemTracking = connection.Prepare (queryDeleteTracking))  					using (var stmtTracking = connection.Prepare (queryUpdateTracking)) {  						foreach (var entity in entities) {  							// Foreach entity check if it's a delete action or un insert/update action  							if (entity.ServiceMetadata.IsTombstone) {  								// Delete Action  								// Bind parameter  								BindParameter (stmtGetprimaryKey' 1' entity.ServiceMetadata.Id);  								// Store values of primaryKeys  								Object[] pkeys = new object[map.PrimaryKeys.Length];  								// While row is available (only 1 if it's good)  								while (stmtGetprimaryKey.Step () == SQLiteResult.ROW) {  									for (int i = 0; i < pkeys.Length; i++) {  										// Read the column  										pkeys [i] = ReadCol (stmtGetprimaryKey' i' map.PrimaryKeys [i].ColumnType);  									}  								}  								stmtGetprimaryKey.Reset ();  								// Bind parameters  								for (int i = 0; i < pkeys.Length; i++) {  									BindParameter (stmtDeleteItem' i + 1' pkeys [i]);  									BindParameter (stmtDeleteItemTracking' i + 1' pkeys [i]);  								}  								// Execute the deletion of 2 rows  								stmtDeleteItem.Step ();  								stmtDeleteItem.Reset ();  								stmtDeleteItem.ClearBindings ();  								stmtDeleteItemTracking.Step ();  								stmtDeleteItemTracking.Reset ();  								stmtDeleteItemTracking.ClearBindings ();  							}  							else {  								// Get columns for insert  								var cols = map.Columns;  								// Set values for table  								for (var i = 0; i < cols.Length; i++) {  									var val = cols [i].GetValue (entity);  									BindParameter (stmtInsert' i + 1' val);  									BindParameter (stmtUpdate' i + 1' val);  								}  								// add where clause  								for (var i = 0; i < map.PrimaryKeys.Length; i++) {  									var val = map.PrimaryKeys [i].GetValue (entity);  									BindParameter (stmtUpdate' cols.Length + i + 1' val);  								}  								stmtUpdate.Step ();  								stmtUpdate.Reset ();  								stmtUpdate.ClearBindings ();  								stmtInsert.Step ();  								stmtInsert.Reset ();  								stmtInsert.ClearBindings ();  								// Set Values for tracking table  								BindParameter (stmtTracking' 1' entity.ServiceMetadata.IsTombstone);  								BindParameter (stmtTracking' 2' 0);  								BindParameter (stmtTracking' 3' entity.ServiceMetadata.Id);  								BindParameter (stmtTracking' 4' "ETag");  								var editUri = String.Empty;  								if (entity.ServiceMetadata.EditUri != null && entity.ServiceMetadata.EditUri.IsAbsoluteUri)  									editUri = entity.ServiceMetadata.EditUri.AbsoluteUri;  								BindParameter (stmtTracking' 5' editUri);  								BindParameter (stmtTracking' 6' DateTime.UtcNow);  								// Set values for tracking table  								for (var i = 0; i < map.PrimaryKeys.Length; i++) {  									var val = map.PrimaryKeys [i].GetValue (entity);  									BindParameter (stmtTracking' i + 7' val);  								}  								stmtTracking.Step ();  								stmtTracking.Reset ();  								stmtTracking.ClearBindings ();  							}  						}  						using (var statement = connection.Prepare ("Commit Transaction")) {  							statement.Step ();  						}  					}  
Magic Number,Microsoft.Synchronization.ClientServices.SQLite,SQLiteHelper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteHelper.cs,MergeEntities,The following statement contains a magic number: using (var stmtInsert = connection.Prepare (queryInsert))  	using (var stmtUpdate = connection.Prepare (queryUpdate))  		using (var stmtGetprimaryKey = connection.Prepare (querySelectItemPrimaryKeyFromTrackingChangesWithOemID))  			using (var stmtDeleteItem = connection.Prepare (queryDelete))  				using (var stmtDeleteItemTracking = connection.Prepare (queryDeleteTracking))  					using (var stmtTracking = connection.Prepare (queryUpdateTracking)) {  						foreach (var entity in entities) {  							// Foreach entity check if it's a delete action or un insert/update action  							if (entity.ServiceMetadata.IsTombstone) {  								// Delete Action  								// Bind parameter  								BindParameter (stmtGetprimaryKey' 1' entity.ServiceMetadata.Id);  								// Store values of primaryKeys  								Object[] pkeys = new object[map.PrimaryKeys.Length];  								// While row is available (only 1 if it's good)  								while (stmtGetprimaryKey.Step () == SQLiteResult.ROW) {  									for (int i = 0; i < pkeys.Length; i++) {  										// Read the column  										pkeys [i] = ReadCol (stmtGetprimaryKey' i' map.PrimaryKeys [i].ColumnType);  									}  								}  								stmtGetprimaryKey.Reset ();  								// Bind parameters  								for (int i = 0; i < pkeys.Length; i++) {  									BindParameter (stmtDeleteItem' i + 1' pkeys [i]);  									BindParameter (stmtDeleteItemTracking' i + 1' pkeys [i]);  								}  								// Execute the deletion of 2 rows  								stmtDeleteItem.Step ();  								stmtDeleteItem.Reset ();  								stmtDeleteItem.ClearBindings ();  								stmtDeleteItemTracking.Step ();  								stmtDeleteItemTracking.Reset ();  								stmtDeleteItemTracking.ClearBindings ();  							}  							else {  								// Get columns for insert  								var cols = map.Columns;  								// Set values for table  								for (var i = 0; i < cols.Length; i++) {  									var val = cols [i].GetValue (entity);  									BindParameter (stmtInsert' i + 1' val);  									BindParameter (stmtUpdate' i + 1' val);  								}  								// add where clause  								for (var i = 0; i < map.PrimaryKeys.Length; i++) {  									var val = map.PrimaryKeys [i].GetValue (entity);  									BindParameter (stmtUpdate' cols.Length + i + 1' val);  								}  								stmtUpdate.Step ();  								stmtUpdate.Reset ();  								stmtUpdate.ClearBindings ();  								stmtInsert.Step ();  								stmtInsert.Reset ();  								stmtInsert.ClearBindings ();  								// Set Values for tracking table  								BindParameter (stmtTracking' 1' entity.ServiceMetadata.IsTombstone);  								BindParameter (stmtTracking' 2' 0);  								BindParameter (stmtTracking' 3' entity.ServiceMetadata.Id);  								BindParameter (stmtTracking' 4' "ETag");  								var editUri = String.Empty;  								if (entity.ServiceMetadata.EditUri != null && entity.ServiceMetadata.EditUri.IsAbsoluteUri)  									editUri = entity.ServiceMetadata.EditUri.AbsoluteUri;  								BindParameter (stmtTracking' 5' editUri);  								BindParameter (stmtTracking' 6' DateTime.UtcNow);  								// Set values for tracking table  								for (var i = 0; i < map.PrimaryKeys.Length; i++) {  									var val = map.PrimaryKeys [i].GetValue (entity);  									BindParameter (stmtTracking' i + 7' val);  								}  								stmtTracking.Step ();  								stmtTracking.Reset ();  								stmtTracking.ClearBindings ();  							}  						}  						using (var statement = connection.Prepare ("Commit Transaction")) {  							statement.Step ();  						}  					}  
Magic Number,Microsoft.Synchronization.ClientServices.SQLite,SQLiteHelper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteHelper.cs,MergeEntities,The following statement contains a magic number: using (var stmtInsert = connection.Prepare (queryInsert))  	using (var stmtUpdate = connection.Prepare (queryUpdate))  		using (var stmtGetprimaryKey = connection.Prepare (querySelectItemPrimaryKeyFromTrackingChangesWithOemID))  			using (var stmtDeleteItem = connection.Prepare (queryDelete))  				using (var stmtDeleteItemTracking = connection.Prepare (queryDeleteTracking))  					using (var stmtTracking = connection.Prepare (queryUpdateTracking)) {  						foreach (var entity in entities) {  							// Foreach entity check if it's a delete action or un insert/update action  							if (entity.ServiceMetadata.IsTombstone) {  								// Delete Action  								// Bind parameter  								BindParameter (stmtGetprimaryKey' 1' entity.ServiceMetadata.Id);  								// Store values of primaryKeys  								Object[] pkeys = new object[map.PrimaryKeys.Length];  								// While row is available (only 1 if it's good)  								while (stmtGetprimaryKey.Step () == SQLiteResult.ROW) {  									for (int i = 0; i < pkeys.Length; i++) {  										// Read the column  										pkeys [i] = ReadCol (stmtGetprimaryKey' i' map.PrimaryKeys [i].ColumnType);  									}  								}  								stmtGetprimaryKey.Reset ();  								// Bind parameters  								for (int i = 0; i < pkeys.Length; i++) {  									BindParameter (stmtDeleteItem' i + 1' pkeys [i]);  									BindParameter (stmtDeleteItemTracking' i + 1' pkeys [i]);  								}  								// Execute the deletion of 2 rows  								stmtDeleteItem.Step ();  								stmtDeleteItem.Reset ();  								stmtDeleteItem.ClearBindings ();  								stmtDeleteItemTracking.Step ();  								stmtDeleteItemTracking.Reset ();  								stmtDeleteItemTracking.ClearBindings ();  							}  							else {  								// Get columns for insert  								var cols = map.Columns;  								// Set values for table  								for (var i = 0; i < cols.Length; i++) {  									var val = cols [i].GetValue (entity);  									BindParameter (stmtInsert' i + 1' val);  									BindParameter (stmtUpdate' i + 1' val);  								}  								// add where clause  								for (var i = 0; i < map.PrimaryKeys.Length; i++) {  									var val = map.PrimaryKeys [i].GetValue (entity);  									BindParameter (stmtUpdate' cols.Length + i + 1' val);  								}  								stmtUpdate.Step ();  								stmtUpdate.Reset ();  								stmtUpdate.ClearBindings ();  								stmtInsert.Step ();  								stmtInsert.Reset ();  								stmtInsert.ClearBindings ();  								// Set Values for tracking table  								BindParameter (stmtTracking' 1' entity.ServiceMetadata.IsTombstone);  								BindParameter (stmtTracking' 2' 0);  								BindParameter (stmtTracking' 3' entity.ServiceMetadata.Id);  								BindParameter (stmtTracking' 4' "ETag");  								var editUri = String.Empty;  								if (entity.ServiceMetadata.EditUri != null && entity.ServiceMetadata.EditUri.IsAbsoluteUri)  									editUri = entity.ServiceMetadata.EditUri.AbsoluteUri;  								BindParameter (stmtTracking' 5' editUri);  								BindParameter (stmtTracking' 6' DateTime.UtcNow);  								// Set values for tracking table  								for (var i = 0; i < map.PrimaryKeys.Length; i++) {  									var val = map.PrimaryKeys [i].GetValue (entity);  									BindParameter (stmtTracking' i + 7' val);  								}  								stmtTracking.Step ();  								stmtTracking.Reset ();  								stmtTracking.ClearBindings ();  							}  						}  						using (var statement = connection.Prepare ("Commit Transaction")) {  							statement.Step ();  						}  					}  
Magic Number,Microsoft.Synchronization.ClientServices.SQLite,SQLiteHelper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteHelper.cs,MergeEntities,The following statement contains a magic number: using (var stmtInsert = connection.Prepare (queryInsert))  	using (var stmtUpdate = connection.Prepare (queryUpdate))  		using (var stmtGetprimaryKey = connection.Prepare (querySelectItemPrimaryKeyFromTrackingChangesWithOemID))  			using (var stmtDeleteItem = connection.Prepare (queryDelete))  				using (var stmtDeleteItemTracking = connection.Prepare (queryDeleteTracking))  					using (var stmtTracking = connection.Prepare (queryUpdateTracking)) {  						foreach (var entity in entities) {  							// Foreach entity check if it's a delete action or un insert/update action  							if (entity.ServiceMetadata.IsTombstone) {  								// Delete Action  								// Bind parameter  								BindParameter (stmtGetprimaryKey' 1' entity.ServiceMetadata.Id);  								// Store values of primaryKeys  								Object[] pkeys = new object[map.PrimaryKeys.Length];  								// While row is available (only 1 if it's good)  								while (stmtGetprimaryKey.Step () == SQLiteResult.ROW) {  									for (int i = 0; i < pkeys.Length; i++) {  										// Read the column  										pkeys [i] = ReadCol (stmtGetprimaryKey' i' map.PrimaryKeys [i].ColumnType);  									}  								}  								stmtGetprimaryKey.Reset ();  								// Bind parameters  								for (int i = 0; i < pkeys.Length; i++) {  									BindParameter (stmtDeleteItem' i + 1' pkeys [i]);  									BindParameter (stmtDeleteItemTracking' i + 1' pkeys [i]);  								}  								// Execute the deletion of 2 rows  								stmtDeleteItem.Step ();  								stmtDeleteItem.Reset ();  								stmtDeleteItem.ClearBindings ();  								stmtDeleteItemTracking.Step ();  								stmtDeleteItemTracking.Reset ();  								stmtDeleteItemTracking.ClearBindings ();  							}  							else {  								// Get columns for insert  								var cols = map.Columns;  								// Set values for table  								for (var i = 0; i < cols.Length; i++) {  									var val = cols [i].GetValue (entity);  									BindParameter (stmtInsert' i + 1' val);  									BindParameter (stmtUpdate' i + 1' val);  								}  								// add where clause  								for (var i = 0; i < map.PrimaryKeys.Length; i++) {  									var val = map.PrimaryKeys [i].GetValue (entity);  									BindParameter (stmtUpdate' cols.Length + i + 1' val);  								}  								stmtUpdate.Step ();  								stmtUpdate.Reset ();  								stmtUpdate.ClearBindings ();  								stmtInsert.Step ();  								stmtInsert.Reset ();  								stmtInsert.ClearBindings ();  								// Set Values for tracking table  								BindParameter (stmtTracking' 1' entity.ServiceMetadata.IsTombstone);  								BindParameter (stmtTracking' 2' 0);  								BindParameter (stmtTracking' 3' entity.ServiceMetadata.Id);  								BindParameter (stmtTracking' 4' "ETag");  								var editUri = String.Empty;  								if (entity.ServiceMetadata.EditUri != null && entity.ServiceMetadata.EditUri.IsAbsoluteUri)  									editUri = entity.ServiceMetadata.EditUri.AbsoluteUri;  								BindParameter (stmtTracking' 5' editUri);  								BindParameter (stmtTracking' 6' DateTime.UtcNow);  								// Set values for tracking table  								for (var i = 0; i < map.PrimaryKeys.Length; i++) {  									var val = map.PrimaryKeys [i].GetValue (entity);  									BindParameter (stmtTracking' i + 7' val);  								}  								stmtTracking.Step ();  								stmtTracking.Reset ();  								stmtTracking.ClearBindings ();  							}  						}  						using (var statement = connection.Prepare ("Commit Transaction")) {  							statement.Step ();  						}  					}  
Magic Number,Microsoft.Synchronization.ClientServices.SQLite,SQLiteHelper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteHelper.cs,MergeEntities,The following statement contains a magic number: using (var stmtUpdate = connection.Prepare (queryUpdate))  	using (var stmtGetprimaryKey = connection.Prepare (querySelectItemPrimaryKeyFromTrackingChangesWithOemID))  		using (var stmtDeleteItem = connection.Prepare (queryDelete))  			using (var stmtDeleteItemTracking = connection.Prepare (queryDeleteTracking))  				using (var stmtTracking = connection.Prepare (queryUpdateTracking)) {  					foreach (var entity in entities) {  						// Foreach entity check if it's a delete action or un insert/update action  						if (entity.ServiceMetadata.IsTombstone) {  							// Delete Action  							// Bind parameter  							BindParameter (stmtGetprimaryKey' 1' entity.ServiceMetadata.Id);  							// Store values of primaryKeys  							Object[] pkeys = new object[map.PrimaryKeys.Length];  							// While row is available (only 1 if it's good)  							while (stmtGetprimaryKey.Step () == SQLiteResult.ROW) {  								for (int i = 0; i < pkeys.Length; i++) {  									// Read the column  									pkeys [i] = ReadCol (stmtGetprimaryKey' i' map.PrimaryKeys [i].ColumnType);  								}  							}  							stmtGetprimaryKey.Reset ();  							// Bind parameters  							for (int i = 0; i < pkeys.Length; i++) {  								BindParameter (stmtDeleteItem' i + 1' pkeys [i]);  								BindParameter (stmtDeleteItemTracking' i + 1' pkeys [i]);  							}  							// Execute the deletion of 2 rows  							stmtDeleteItem.Step ();  							stmtDeleteItem.Reset ();  							stmtDeleteItem.ClearBindings ();  							stmtDeleteItemTracking.Step ();  							stmtDeleteItemTracking.Reset ();  							stmtDeleteItemTracking.ClearBindings ();  						}  						else {  							// Get columns for insert  							var cols = map.Columns;  							// Set values for table  							for (var i = 0; i < cols.Length; i++) {  								var val = cols [i].GetValue (entity);  								BindParameter (stmtInsert' i + 1' val);  								BindParameter (stmtUpdate' i + 1' val);  							}  							// add where clause  							for (var i = 0; i < map.PrimaryKeys.Length; i++) {  								var val = map.PrimaryKeys [i].GetValue (entity);  								BindParameter (stmtUpdate' cols.Length + i + 1' val);  							}  							stmtUpdate.Step ();  							stmtUpdate.Reset ();  							stmtUpdate.ClearBindings ();  							stmtInsert.Step ();  							stmtInsert.Reset ();  							stmtInsert.ClearBindings ();  							// Set Values for tracking table  							BindParameter (stmtTracking' 1' entity.ServiceMetadata.IsTombstone);  							BindParameter (stmtTracking' 2' 0);  							BindParameter (stmtTracking' 3' entity.ServiceMetadata.Id);  							BindParameter (stmtTracking' 4' "ETag");  							var editUri = String.Empty;  							if (entity.ServiceMetadata.EditUri != null && entity.ServiceMetadata.EditUri.IsAbsoluteUri)  								editUri = entity.ServiceMetadata.EditUri.AbsoluteUri;  							BindParameter (stmtTracking' 5' editUri);  							BindParameter (stmtTracking' 6' DateTime.UtcNow);  							// Set values for tracking table  							for (var i = 0; i < map.PrimaryKeys.Length; i++) {  								var val = map.PrimaryKeys [i].GetValue (entity);  								BindParameter (stmtTracking' i + 7' val);  							}  							stmtTracking.Step ();  							stmtTracking.Reset ();  							stmtTracking.ClearBindings ();  						}  					}  					using (var statement = connection.Prepare ("Commit Transaction")) {  						statement.Step ();  					}  				}  
Magic Number,Microsoft.Synchronization.ClientServices.SQLite,SQLiteHelper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteHelper.cs,MergeEntities,The following statement contains a magic number: using (var stmtUpdate = connection.Prepare (queryUpdate))  	using (var stmtGetprimaryKey = connection.Prepare (querySelectItemPrimaryKeyFromTrackingChangesWithOemID))  		using (var stmtDeleteItem = connection.Prepare (queryDelete))  			using (var stmtDeleteItemTracking = connection.Prepare (queryDeleteTracking))  				using (var stmtTracking = connection.Prepare (queryUpdateTracking)) {  					foreach (var entity in entities) {  						// Foreach entity check if it's a delete action or un insert/update action  						if (entity.ServiceMetadata.IsTombstone) {  							// Delete Action  							// Bind parameter  							BindParameter (stmtGetprimaryKey' 1' entity.ServiceMetadata.Id);  							// Store values of primaryKeys  							Object[] pkeys = new object[map.PrimaryKeys.Length];  							// While row is available (only 1 if it's good)  							while (stmtGetprimaryKey.Step () == SQLiteResult.ROW) {  								for (int i = 0; i < pkeys.Length; i++) {  									// Read the column  									pkeys [i] = ReadCol (stmtGetprimaryKey' i' map.PrimaryKeys [i].ColumnType);  								}  							}  							stmtGetprimaryKey.Reset ();  							// Bind parameters  							for (int i = 0; i < pkeys.Length; i++) {  								BindParameter (stmtDeleteItem' i + 1' pkeys [i]);  								BindParameter (stmtDeleteItemTracking' i + 1' pkeys [i]);  							}  							// Execute the deletion of 2 rows  							stmtDeleteItem.Step ();  							stmtDeleteItem.Reset ();  							stmtDeleteItem.ClearBindings ();  							stmtDeleteItemTracking.Step ();  							stmtDeleteItemTracking.Reset ();  							stmtDeleteItemTracking.ClearBindings ();  						}  						else {  							// Get columns for insert  							var cols = map.Columns;  							// Set values for table  							for (var i = 0; i < cols.Length; i++) {  								var val = cols [i].GetValue (entity);  								BindParameter (stmtInsert' i + 1' val);  								BindParameter (stmtUpdate' i + 1' val);  							}  							// add where clause  							for (var i = 0; i < map.PrimaryKeys.Length; i++) {  								var val = map.PrimaryKeys [i].GetValue (entity);  								BindParameter (stmtUpdate' cols.Length + i + 1' val);  							}  							stmtUpdate.Step ();  							stmtUpdate.Reset ();  							stmtUpdate.ClearBindings ();  							stmtInsert.Step ();  							stmtInsert.Reset ();  							stmtInsert.ClearBindings ();  							// Set Values for tracking table  							BindParameter (stmtTracking' 1' entity.ServiceMetadata.IsTombstone);  							BindParameter (stmtTracking' 2' 0);  							BindParameter (stmtTracking' 3' entity.ServiceMetadata.Id);  							BindParameter (stmtTracking' 4' "ETag");  							var editUri = String.Empty;  							if (entity.ServiceMetadata.EditUri != null && entity.ServiceMetadata.EditUri.IsAbsoluteUri)  								editUri = entity.ServiceMetadata.EditUri.AbsoluteUri;  							BindParameter (stmtTracking' 5' editUri);  							BindParameter (stmtTracking' 6' DateTime.UtcNow);  							// Set values for tracking table  							for (var i = 0; i < map.PrimaryKeys.Length; i++) {  								var val = map.PrimaryKeys [i].GetValue (entity);  								BindParameter (stmtTracking' i + 7' val);  							}  							stmtTracking.Step ();  							stmtTracking.Reset ();  							stmtTracking.ClearBindings ();  						}  					}  					using (var statement = connection.Prepare ("Commit Transaction")) {  						statement.Step ();  					}  				}  
Magic Number,Microsoft.Synchronization.ClientServices.SQLite,SQLiteHelper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteHelper.cs,MergeEntities,The following statement contains a magic number: using (var stmtUpdate = connection.Prepare (queryUpdate))  	using (var stmtGetprimaryKey = connection.Prepare (querySelectItemPrimaryKeyFromTrackingChangesWithOemID))  		using (var stmtDeleteItem = connection.Prepare (queryDelete))  			using (var stmtDeleteItemTracking = connection.Prepare (queryDeleteTracking))  				using (var stmtTracking = connection.Prepare (queryUpdateTracking)) {  					foreach (var entity in entities) {  						// Foreach entity check if it's a delete action or un insert/update action  						if (entity.ServiceMetadata.IsTombstone) {  							// Delete Action  							// Bind parameter  							BindParameter (stmtGetprimaryKey' 1' entity.ServiceMetadata.Id);  							// Store values of primaryKeys  							Object[] pkeys = new object[map.PrimaryKeys.Length];  							// While row is available (only 1 if it's good)  							while (stmtGetprimaryKey.Step () == SQLiteResult.ROW) {  								for (int i = 0; i < pkeys.Length; i++) {  									// Read the column  									pkeys [i] = ReadCol (stmtGetprimaryKey' i' map.PrimaryKeys [i].ColumnType);  								}  							}  							stmtGetprimaryKey.Reset ();  							// Bind parameters  							for (int i = 0; i < pkeys.Length; i++) {  								BindParameter (stmtDeleteItem' i + 1' pkeys [i]);  								BindParameter (stmtDeleteItemTracking' i + 1' pkeys [i]);  							}  							// Execute the deletion of 2 rows  							stmtDeleteItem.Step ();  							stmtDeleteItem.Reset ();  							stmtDeleteItem.ClearBindings ();  							stmtDeleteItemTracking.Step ();  							stmtDeleteItemTracking.Reset ();  							stmtDeleteItemTracking.ClearBindings ();  						}  						else {  							// Get columns for insert  							var cols = map.Columns;  							// Set values for table  							for (var i = 0; i < cols.Length; i++) {  								var val = cols [i].GetValue (entity);  								BindParameter (stmtInsert' i + 1' val);  								BindParameter (stmtUpdate' i + 1' val);  							}  							// add where clause  							for (var i = 0; i < map.PrimaryKeys.Length; i++) {  								var val = map.PrimaryKeys [i].GetValue (entity);  								BindParameter (stmtUpdate' cols.Length + i + 1' val);  							}  							stmtUpdate.Step ();  							stmtUpdate.Reset ();  							stmtUpdate.ClearBindings ();  							stmtInsert.Step ();  							stmtInsert.Reset ();  							stmtInsert.ClearBindings ();  							// Set Values for tracking table  							BindParameter (stmtTracking' 1' entity.ServiceMetadata.IsTombstone);  							BindParameter (stmtTracking' 2' 0);  							BindParameter (stmtTracking' 3' entity.ServiceMetadata.Id);  							BindParameter (stmtTracking' 4' "ETag");  							var editUri = String.Empty;  							if (entity.ServiceMetadata.EditUri != null && entity.ServiceMetadata.EditUri.IsAbsoluteUri)  								editUri = entity.ServiceMetadata.EditUri.AbsoluteUri;  							BindParameter (stmtTracking' 5' editUri);  							BindParameter (stmtTracking' 6' DateTime.UtcNow);  							// Set values for tracking table  							for (var i = 0; i < map.PrimaryKeys.Length; i++) {  								var val = map.PrimaryKeys [i].GetValue (entity);  								BindParameter (stmtTracking' i + 7' val);  							}  							stmtTracking.Step ();  							stmtTracking.Reset ();  							stmtTracking.ClearBindings ();  						}  					}  					using (var statement = connection.Prepare ("Commit Transaction")) {  						statement.Step ();  					}  				}  
Magic Number,Microsoft.Synchronization.ClientServices.SQLite,SQLiteHelper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteHelper.cs,MergeEntities,The following statement contains a magic number: using (var stmtUpdate = connection.Prepare (queryUpdate))  	using (var stmtGetprimaryKey = connection.Prepare (querySelectItemPrimaryKeyFromTrackingChangesWithOemID))  		using (var stmtDeleteItem = connection.Prepare (queryDelete))  			using (var stmtDeleteItemTracking = connection.Prepare (queryDeleteTracking))  				using (var stmtTracking = connection.Prepare (queryUpdateTracking)) {  					foreach (var entity in entities) {  						// Foreach entity check if it's a delete action or un insert/update action  						if (entity.ServiceMetadata.IsTombstone) {  							// Delete Action  							// Bind parameter  							BindParameter (stmtGetprimaryKey' 1' entity.ServiceMetadata.Id);  							// Store values of primaryKeys  							Object[] pkeys = new object[map.PrimaryKeys.Length];  							// While row is available (only 1 if it's good)  							while (stmtGetprimaryKey.Step () == SQLiteResult.ROW) {  								for (int i = 0; i < pkeys.Length; i++) {  									// Read the column  									pkeys [i] = ReadCol (stmtGetprimaryKey' i' map.PrimaryKeys [i].ColumnType);  								}  							}  							stmtGetprimaryKey.Reset ();  							// Bind parameters  							for (int i = 0; i < pkeys.Length; i++) {  								BindParameter (stmtDeleteItem' i + 1' pkeys [i]);  								BindParameter (stmtDeleteItemTracking' i + 1' pkeys [i]);  							}  							// Execute the deletion of 2 rows  							stmtDeleteItem.Step ();  							stmtDeleteItem.Reset ();  							stmtDeleteItem.ClearBindings ();  							stmtDeleteItemTracking.Step ();  							stmtDeleteItemTracking.Reset ();  							stmtDeleteItemTracking.ClearBindings ();  						}  						else {  							// Get columns for insert  							var cols = map.Columns;  							// Set values for table  							for (var i = 0; i < cols.Length; i++) {  								var val = cols [i].GetValue (entity);  								BindParameter (stmtInsert' i + 1' val);  								BindParameter (stmtUpdate' i + 1' val);  							}  							// add where clause  							for (var i = 0; i < map.PrimaryKeys.Length; i++) {  								var val = map.PrimaryKeys [i].GetValue (entity);  								BindParameter (stmtUpdate' cols.Length + i + 1' val);  							}  							stmtUpdate.Step ();  							stmtUpdate.Reset ();  							stmtUpdate.ClearBindings ();  							stmtInsert.Step ();  							stmtInsert.Reset ();  							stmtInsert.ClearBindings ();  							// Set Values for tracking table  							BindParameter (stmtTracking' 1' entity.ServiceMetadata.IsTombstone);  							BindParameter (stmtTracking' 2' 0);  							BindParameter (stmtTracking' 3' entity.ServiceMetadata.Id);  							BindParameter (stmtTracking' 4' "ETag");  							var editUri = String.Empty;  							if (entity.ServiceMetadata.EditUri != null && entity.ServiceMetadata.EditUri.IsAbsoluteUri)  								editUri = entity.ServiceMetadata.EditUri.AbsoluteUri;  							BindParameter (stmtTracking' 5' editUri);  							BindParameter (stmtTracking' 6' DateTime.UtcNow);  							// Set values for tracking table  							for (var i = 0; i < map.PrimaryKeys.Length; i++) {  								var val = map.PrimaryKeys [i].GetValue (entity);  								BindParameter (stmtTracking' i + 7' val);  							}  							stmtTracking.Step ();  							stmtTracking.Reset ();  							stmtTracking.ClearBindings ();  						}  					}  					using (var statement = connection.Prepare ("Commit Transaction")) {  						statement.Step ();  					}  				}  
Magic Number,Microsoft.Synchronization.ClientServices.SQLite,SQLiteHelper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteHelper.cs,MergeEntities,The following statement contains a magic number: using (var stmtUpdate = connection.Prepare (queryUpdate))  	using (var stmtGetprimaryKey = connection.Prepare (querySelectItemPrimaryKeyFromTrackingChangesWithOemID))  		using (var stmtDeleteItem = connection.Prepare (queryDelete))  			using (var stmtDeleteItemTracking = connection.Prepare (queryDeleteTracking))  				using (var stmtTracking = connection.Prepare (queryUpdateTracking)) {  					foreach (var entity in entities) {  						// Foreach entity check if it's a delete action or un insert/update action  						if (entity.ServiceMetadata.IsTombstone) {  							// Delete Action  							// Bind parameter  							BindParameter (stmtGetprimaryKey' 1' entity.ServiceMetadata.Id);  							// Store values of primaryKeys  							Object[] pkeys = new object[map.PrimaryKeys.Length];  							// While row is available (only 1 if it's good)  							while (stmtGetprimaryKey.Step () == SQLiteResult.ROW) {  								for (int i = 0; i < pkeys.Length; i++) {  									// Read the column  									pkeys [i] = ReadCol (stmtGetprimaryKey' i' map.PrimaryKeys [i].ColumnType);  								}  							}  							stmtGetprimaryKey.Reset ();  							// Bind parameters  							for (int i = 0; i < pkeys.Length; i++) {  								BindParameter (stmtDeleteItem' i + 1' pkeys [i]);  								BindParameter (stmtDeleteItemTracking' i + 1' pkeys [i]);  							}  							// Execute the deletion of 2 rows  							stmtDeleteItem.Step ();  							stmtDeleteItem.Reset ();  							stmtDeleteItem.ClearBindings ();  							stmtDeleteItemTracking.Step ();  							stmtDeleteItemTracking.Reset ();  							stmtDeleteItemTracking.ClearBindings ();  						}  						else {  							// Get columns for insert  							var cols = map.Columns;  							// Set values for table  							for (var i = 0; i < cols.Length; i++) {  								var val = cols [i].GetValue (entity);  								BindParameter (stmtInsert' i + 1' val);  								BindParameter (stmtUpdate' i + 1' val);  							}  							// add where clause  							for (var i = 0; i < map.PrimaryKeys.Length; i++) {  								var val = map.PrimaryKeys [i].GetValue (entity);  								BindParameter (stmtUpdate' cols.Length + i + 1' val);  							}  							stmtUpdate.Step ();  							stmtUpdate.Reset ();  							stmtUpdate.ClearBindings ();  							stmtInsert.Step ();  							stmtInsert.Reset ();  							stmtInsert.ClearBindings ();  							// Set Values for tracking table  							BindParameter (stmtTracking' 1' entity.ServiceMetadata.IsTombstone);  							BindParameter (stmtTracking' 2' 0);  							BindParameter (stmtTracking' 3' entity.ServiceMetadata.Id);  							BindParameter (stmtTracking' 4' "ETag");  							var editUri = String.Empty;  							if (entity.ServiceMetadata.EditUri != null && entity.ServiceMetadata.EditUri.IsAbsoluteUri)  								editUri = entity.ServiceMetadata.EditUri.AbsoluteUri;  							BindParameter (stmtTracking' 5' editUri);  							BindParameter (stmtTracking' 6' DateTime.UtcNow);  							// Set values for tracking table  							for (var i = 0; i < map.PrimaryKeys.Length; i++) {  								var val = map.PrimaryKeys [i].GetValue (entity);  								BindParameter (stmtTracking' i + 7' val);  							}  							stmtTracking.Step ();  							stmtTracking.Reset ();  							stmtTracking.ClearBindings ();  						}  					}  					using (var statement = connection.Prepare ("Commit Transaction")) {  						statement.Step ();  					}  				}  
Magic Number,Microsoft.Synchronization.ClientServices.SQLite,SQLiteHelper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteHelper.cs,MergeEntities,The following statement contains a magic number: using (var stmtUpdate = connection.Prepare (queryUpdate))  	using (var stmtGetprimaryKey = connection.Prepare (querySelectItemPrimaryKeyFromTrackingChangesWithOemID))  		using (var stmtDeleteItem = connection.Prepare (queryDelete))  			using (var stmtDeleteItemTracking = connection.Prepare (queryDeleteTracking))  				using (var stmtTracking = connection.Prepare (queryUpdateTracking)) {  					foreach (var entity in entities) {  						// Foreach entity check if it's a delete action or un insert/update action  						if (entity.ServiceMetadata.IsTombstone) {  							// Delete Action  							// Bind parameter  							BindParameter (stmtGetprimaryKey' 1' entity.ServiceMetadata.Id);  							// Store values of primaryKeys  							Object[] pkeys = new object[map.PrimaryKeys.Length];  							// While row is available (only 1 if it's good)  							while (stmtGetprimaryKey.Step () == SQLiteResult.ROW) {  								for (int i = 0; i < pkeys.Length; i++) {  									// Read the column  									pkeys [i] = ReadCol (stmtGetprimaryKey' i' map.PrimaryKeys [i].ColumnType);  								}  							}  							stmtGetprimaryKey.Reset ();  							// Bind parameters  							for (int i = 0; i < pkeys.Length; i++) {  								BindParameter (stmtDeleteItem' i + 1' pkeys [i]);  								BindParameter (stmtDeleteItemTracking' i + 1' pkeys [i]);  							}  							// Execute the deletion of 2 rows  							stmtDeleteItem.Step ();  							stmtDeleteItem.Reset ();  							stmtDeleteItem.ClearBindings ();  							stmtDeleteItemTracking.Step ();  							stmtDeleteItemTracking.Reset ();  							stmtDeleteItemTracking.ClearBindings ();  						}  						else {  							// Get columns for insert  							var cols = map.Columns;  							// Set values for table  							for (var i = 0; i < cols.Length; i++) {  								var val = cols [i].GetValue (entity);  								BindParameter (stmtInsert' i + 1' val);  								BindParameter (stmtUpdate' i + 1' val);  							}  							// add where clause  							for (var i = 0; i < map.PrimaryKeys.Length; i++) {  								var val = map.PrimaryKeys [i].GetValue (entity);  								BindParameter (stmtUpdate' cols.Length + i + 1' val);  							}  							stmtUpdate.Step ();  							stmtUpdate.Reset ();  							stmtUpdate.ClearBindings ();  							stmtInsert.Step ();  							stmtInsert.Reset ();  							stmtInsert.ClearBindings ();  							// Set Values for tracking table  							BindParameter (stmtTracking' 1' entity.ServiceMetadata.IsTombstone);  							BindParameter (stmtTracking' 2' 0);  							BindParameter (stmtTracking' 3' entity.ServiceMetadata.Id);  							BindParameter (stmtTracking' 4' "ETag");  							var editUri = String.Empty;  							if (entity.ServiceMetadata.EditUri != null && entity.ServiceMetadata.EditUri.IsAbsoluteUri)  								editUri = entity.ServiceMetadata.EditUri.AbsoluteUri;  							BindParameter (stmtTracking' 5' editUri);  							BindParameter (stmtTracking' 6' DateTime.UtcNow);  							// Set values for tracking table  							for (var i = 0; i < map.PrimaryKeys.Length; i++) {  								var val = map.PrimaryKeys [i].GetValue (entity);  								BindParameter (stmtTracking' i + 7' val);  							}  							stmtTracking.Step ();  							stmtTracking.Reset ();  							stmtTracking.ClearBindings ();  						}  					}  					using (var statement = connection.Prepare ("Commit Transaction")) {  						statement.Step ();  					}  				}  
Magic Number,Microsoft.Synchronization.ClientServices.SQLite,SQLiteHelper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteHelper.cs,MergeEntities,The following statement contains a magic number: using (var stmtGetprimaryKey = connection.Prepare (querySelectItemPrimaryKeyFromTrackingChangesWithOemID))  	using (var stmtDeleteItem = connection.Prepare (queryDelete))  		using (var stmtDeleteItemTracking = connection.Prepare (queryDeleteTracking))  			using (var stmtTracking = connection.Prepare (queryUpdateTracking)) {  				foreach (var entity in entities) {  					// Foreach entity check if it's a delete action or un insert/update action  					if (entity.ServiceMetadata.IsTombstone) {  						// Delete Action  						// Bind parameter  						BindParameter (stmtGetprimaryKey' 1' entity.ServiceMetadata.Id);  						// Store values of primaryKeys  						Object[] pkeys = new object[map.PrimaryKeys.Length];  						// While row is available (only 1 if it's good)  						while (stmtGetprimaryKey.Step () == SQLiteResult.ROW) {  							for (int i = 0; i < pkeys.Length; i++) {  								// Read the column  								pkeys [i] = ReadCol (stmtGetprimaryKey' i' map.PrimaryKeys [i].ColumnType);  							}  						}  						stmtGetprimaryKey.Reset ();  						// Bind parameters  						for (int i = 0; i < pkeys.Length; i++) {  							BindParameter (stmtDeleteItem' i + 1' pkeys [i]);  							BindParameter (stmtDeleteItemTracking' i + 1' pkeys [i]);  						}  						// Execute the deletion of 2 rows  						stmtDeleteItem.Step ();  						stmtDeleteItem.Reset ();  						stmtDeleteItem.ClearBindings ();  						stmtDeleteItemTracking.Step ();  						stmtDeleteItemTracking.Reset ();  						stmtDeleteItemTracking.ClearBindings ();  					}  					else {  						// Get columns for insert  						var cols = map.Columns;  						// Set values for table  						for (var i = 0; i < cols.Length; i++) {  							var val = cols [i].GetValue (entity);  							BindParameter (stmtInsert' i + 1' val);  							BindParameter (stmtUpdate' i + 1' val);  						}  						// add where clause  						for (var i = 0; i < map.PrimaryKeys.Length; i++) {  							var val = map.PrimaryKeys [i].GetValue (entity);  							BindParameter (stmtUpdate' cols.Length + i + 1' val);  						}  						stmtUpdate.Step ();  						stmtUpdate.Reset ();  						stmtUpdate.ClearBindings ();  						stmtInsert.Step ();  						stmtInsert.Reset ();  						stmtInsert.ClearBindings ();  						// Set Values for tracking table  						BindParameter (stmtTracking' 1' entity.ServiceMetadata.IsTombstone);  						BindParameter (stmtTracking' 2' 0);  						BindParameter (stmtTracking' 3' entity.ServiceMetadata.Id);  						BindParameter (stmtTracking' 4' "ETag");  						var editUri = String.Empty;  						if (entity.ServiceMetadata.EditUri != null && entity.ServiceMetadata.EditUri.IsAbsoluteUri)  							editUri = entity.ServiceMetadata.EditUri.AbsoluteUri;  						BindParameter (stmtTracking' 5' editUri);  						BindParameter (stmtTracking' 6' DateTime.UtcNow);  						// Set values for tracking table  						for (var i = 0; i < map.PrimaryKeys.Length; i++) {  							var val = map.PrimaryKeys [i].GetValue (entity);  							BindParameter (stmtTracking' i + 7' val);  						}  						stmtTracking.Step ();  						stmtTracking.Reset ();  						stmtTracking.ClearBindings ();  					}  				}  				using (var statement = connection.Prepare ("Commit Transaction")) {  					statement.Step ();  				}  			}  
Magic Number,Microsoft.Synchronization.ClientServices.SQLite,SQLiteHelper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteHelper.cs,MergeEntities,The following statement contains a magic number: using (var stmtGetprimaryKey = connection.Prepare (querySelectItemPrimaryKeyFromTrackingChangesWithOemID))  	using (var stmtDeleteItem = connection.Prepare (queryDelete))  		using (var stmtDeleteItemTracking = connection.Prepare (queryDeleteTracking))  			using (var stmtTracking = connection.Prepare (queryUpdateTracking)) {  				foreach (var entity in entities) {  					// Foreach entity check if it's a delete action or un insert/update action  					if (entity.ServiceMetadata.IsTombstone) {  						// Delete Action  						// Bind parameter  						BindParameter (stmtGetprimaryKey' 1' entity.ServiceMetadata.Id);  						// Store values of primaryKeys  						Object[] pkeys = new object[map.PrimaryKeys.Length];  						// While row is available (only 1 if it's good)  						while (stmtGetprimaryKey.Step () == SQLiteResult.ROW) {  							for (int i = 0; i < pkeys.Length; i++) {  								// Read the column  								pkeys [i] = ReadCol (stmtGetprimaryKey' i' map.PrimaryKeys [i].ColumnType);  							}  						}  						stmtGetprimaryKey.Reset ();  						// Bind parameters  						for (int i = 0; i < pkeys.Length; i++) {  							BindParameter (stmtDeleteItem' i + 1' pkeys [i]);  							BindParameter (stmtDeleteItemTracking' i + 1' pkeys [i]);  						}  						// Execute the deletion of 2 rows  						stmtDeleteItem.Step ();  						stmtDeleteItem.Reset ();  						stmtDeleteItem.ClearBindings ();  						stmtDeleteItemTracking.Step ();  						stmtDeleteItemTracking.Reset ();  						stmtDeleteItemTracking.ClearBindings ();  					}  					else {  						// Get columns for insert  						var cols = map.Columns;  						// Set values for table  						for (var i = 0; i < cols.Length; i++) {  							var val = cols [i].GetValue (entity);  							BindParameter (stmtInsert' i + 1' val);  							BindParameter (stmtUpdate' i + 1' val);  						}  						// add where clause  						for (var i = 0; i < map.PrimaryKeys.Length; i++) {  							var val = map.PrimaryKeys [i].GetValue (entity);  							BindParameter (stmtUpdate' cols.Length + i + 1' val);  						}  						stmtUpdate.Step ();  						stmtUpdate.Reset ();  						stmtUpdate.ClearBindings ();  						stmtInsert.Step ();  						stmtInsert.Reset ();  						stmtInsert.ClearBindings ();  						// Set Values for tracking table  						BindParameter (stmtTracking' 1' entity.ServiceMetadata.IsTombstone);  						BindParameter (stmtTracking' 2' 0);  						BindParameter (stmtTracking' 3' entity.ServiceMetadata.Id);  						BindParameter (stmtTracking' 4' "ETag");  						var editUri = String.Empty;  						if (entity.ServiceMetadata.EditUri != null && entity.ServiceMetadata.EditUri.IsAbsoluteUri)  							editUri = entity.ServiceMetadata.EditUri.AbsoluteUri;  						BindParameter (stmtTracking' 5' editUri);  						BindParameter (stmtTracking' 6' DateTime.UtcNow);  						// Set values for tracking table  						for (var i = 0; i < map.PrimaryKeys.Length; i++) {  							var val = map.PrimaryKeys [i].GetValue (entity);  							BindParameter (stmtTracking' i + 7' val);  						}  						stmtTracking.Step ();  						stmtTracking.Reset ();  						stmtTracking.ClearBindings ();  					}  				}  				using (var statement = connection.Prepare ("Commit Transaction")) {  					statement.Step ();  				}  			}  
Magic Number,Microsoft.Synchronization.ClientServices.SQLite,SQLiteHelper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteHelper.cs,MergeEntities,The following statement contains a magic number: using (var stmtGetprimaryKey = connection.Prepare (querySelectItemPrimaryKeyFromTrackingChangesWithOemID))  	using (var stmtDeleteItem = connection.Prepare (queryDelete))  		using (var stmtDeleteItemTracking = connection.Prepare (queryDeleteTracking))  			using (var stmtTracking = connection.Prepare (queryUpdateTracking)) {  				foreach (var entity in entities) {  					// Foreach entity check if it's a delete action or un insert/update action  					if (entity.ServiceMetadata.IsTombstone) {  						// Delete Action  						// Bind parameter  						BindParameter (stmtGetprimaryKey' 1' entity.ServiceMetadata.Id);  						// Store values of primaryKeys  						Object[] pkeys = new object[map.PrimaryKeys.Length];  						// While row is available (only 1 if it's good)  						while (stmtGetprimaryKey.Step () == SQLiteResult.ROW) {  							for (int i = 0; i < pkeys.Length; i++) {  								// Read the column  								pkeys [i] = ReadCol (stmtGetprimaryKey' i' map.PrimaryKeys [i].ColumnType);  							}  						}  						stmtGetprimaryKey.Reset ();  						// Bind parameters  						for (int i = 0; i < pkeys.Length; i++) {  							BindParameter (stmtDeleteItem' i + 1' pkeys [i]);  							BindParameter (stmtDeleteItemTracking' i + 1' pkeys [i]);  						}  						// Execute the deletion of 2 rows  						stmtDeleteItem.Step ();  						stmtDeleteItem.Reset ();  						stmtDeleteItem.ClearBindings ();  						stmtDeleteItemTracking.Step ();  						stmtDeleteItemTracking.Reset ();  						stmtDeleteItemTracking.ClearBindings ();  					}  					else {  						// Get columns for insert  						var cols = map.Columns;  						// Set values for table  						for (var i = 0; i < cols.Length; i++) {  							var val = cols [i].GetValue (entity);  							BindParameter (stmtInsert' i + 1' val);  							BindParameter (stmtUpdate' i + 1' val);  						}  						// add where clause  						for (var i = 0; i < map.PrimaryKeys.Length; i++) {  							var val = map.PrimaryKeys [i].GetValue (entity);  							BindParameter (stmtUpdate' cols.Length + i + 1' val);  						}  						stmtUpdate.Step ();  						stmtUpdate.Reset ();  						stmtUpdate.ClearBindings ();  						stmtInsert.Step ();  						stmtInsert.Reset ();  						stmtInsert.ClearBindings ();  						// Set Values for tracking table  						BindParameter (stmtTracking' 1' entity.ServiceMetadata.IsTombstone);  						BindParameter (stmtTracking' 2' 0);  						BindParameter (stmtTracking' 3' entity.ServiceMetadata.Id);  						BindParameter (stmtTracking' 4' "ETag");  						var editUri = String.Empty;  						if (entity.ServiceMetadata.EditUri != null && entity.ServiceMetadata.EditUri.IsAbsoluteUri)  							editUri = entity.ServiceMetadata.EditUri.AbsoluteUri;  						BindParameter (stmtTracking' 5' editUri);  						BindParameter (stmtTracking' 6' DateTime.UtcNow);  						// Set values for tracking table  						for (var i = 0; i < map.PrimaryKeys.Length; i++) {  							var val = map.PrimaryKeys [i].GetValue (entity);  							BindParameter (stmtTracking' i + 7' val);  						}  						stmtTracking.Step ();  						stmtTracking.Reset ();  						stmtTracking.ClearBindings ();  					}  				}  				using (var statement = connection.Prepare ("Commit Transaction")) {  					statement.Step ();  				}  			}  
Magic Number,Microsoft.Synchronization.ClientServices.SQLite,SQLiteHelper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteHelper.cs,MergeEntities,The following statement contains a magic number: using (var stmtGetprimaryKey = connection.Prepare (querySelectItemPrimaryKeyFromTrackingChangesWithOemID))  	using (var stmtDeleteItem = connection.Prepare (queryDelete))  		using (var stmtDeleteItemTracking = connection.Prepare (queryDeleteTracking))  			using (var stmtTracking = connection.Prepare (queryUpdateTracking)) {  				foreach (var entity in entities) {  					// Foreach entity check if it's a delete action or un insert/update action  					if (entity.ServiceMetadata.IsTombstone) {  						// Delete Action  						// Bind parameter  						BindParameter (stmtGetprimaryKey' 1' entity.ServiceMetadata.Id);  						// Store values of primaryKeys  						Object[] pkeys = new object[map.PrimaryKeys.Length];  						// While row is available (only 1 if it's good)  						while (stmtGetprimaryKey.Step () == SQLiteResult.ROW) {  							for (int i = 0; i < pkeys.Length; i++) {  								// Read the column  								pkeys [i] = ReadCol (stmtGetprimaryKey' i' map.PrimaryKeys [i].ColumnType);  							}  						}  						stmtGetprimaryKey.Reset ();  						// Bind parameters  						for (int i = 0; i < pkeys.Length; i++) {  							BindParameter (stmtDeleteItem' i + 1' pkeys [i]);  							BindParameter (stmtDeleteItemTracking' i + 1' pkeys [i]);  						}  						// Execute the deletion of 2 rows  						stmtDeleteItem.Step ();  						stmtDeleteItem.Reset ();  						stmtDeleteItem.ClearBindings ();  						stmtDeleteItemTracking.Step ();  						stmtDeleteItemTracking.Reset ();  						stmtDeleteItemTracking.ClearBindings ();  					}  					else {  						// Get columns for insert  						var cols = map.Columns;  						// Set values for table  						for (var i = 0; i < cols.Length; i++) {  							var val = cols [i].GetValue (entity);  							BindParameter (stmtInsert' i + 1' val);  							BindParameter (stmtUpdate' i + 1' val);  						}  						// add where clause  						for (var i = 0; i < map.PrimaryKeys.Length; i++) {  							var val = map.PrimaryKeys [i].GetValue (entity);  							BindParameter (stmtUpdate' cols.Length + i + 1' val);  						}  						stmtUpdate.Step ();  						stmtUpdate.Reset ();  						stmtUpdate.ClearBindings ();  						stmtInsert.Step ();  						stmtInsert.Reset ();  						stmtInsert.ClearBindings ();  						// Set Values for tracking table  						BindParameter (stmtTracking' 1' entity.ServiceMetadata.IsTombstone);  						BindParameter (stmtTracking' 2' 0);  						BindParameter (stmtTracking' 3' entity.ServiceMetadata.Id);  						BindParameter (stmtTracking' 4' "ETag");  						var editUri = String.Empty;  						if (entity.ServiceMetadata.EditUri != null && entity.ServiceMetadata.EditUri.IsAbsoluteUri)  							editUri = entity.ServiceMetadata.EditUri.AbsoluteUri;  						BindParameter (stmtTracking' 5' editUri);  						BindParameter (stmtTracking' 6' DateTime.UtcNow);  						// Set values for tracking table  						for (var i = 0; i < map.PrimaryKeys.Length; i++) {  							var val = map.PrimaryKeys [i].GetValue (entity);  							BindParameter (stmtTracking' i + 7' val);  						}  						stmtTracking.Step ();  						stmtTracking.Reset ();  						stmtTracking.ClearBindings ();  					}  				}  				using (var statement = connection.Prepare ("Commit Transaction")) {  					statement.Step ();  				}  			}  
Magic Number,Microsoft.Synchronization.ClientServices.SQLite,SQLiteHelper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteHelper.cs,MergeEntities,The following statement contains a magic number: using (var stmtGetprimaryKey = connection.Prepare (querySelectItemPrimaryKeyFromTrackingChangesWithOemID))  	using (var stmtDeleteItem = connection.Prepare (queryDelete))  		using (var stmtDeleteItemTracking = connection.Prepare (queryDeleteTracking))  			using (var stmtTracking = connection.Prepare (queryUpdateTracking)) {  				foreach (var entity in entities) {  					// Foreach entity check if it's a delete action or un insert/update action  					if (entity.ServiceMetadata.IsTombstone) {  						// Delete Action  						// Bind parameter  						BindParameter (stmtGetprimaryKey' 1' entity.ServiceMetadata.Id);  						// Store values of primaryKeys  						Object[] pkeys = new object[map.PrimaryKeys.Length];  						// While row is available (only 1 if it's good)  						while (stmtGetprimaryKey.Step () == SQLiteResult.ROW) {  							for (int i = 0; i < pkeys.Length; i++) {  								// Read the column  								pkeys [i] = ReadCol (stmtGetprimaryKey' i' map.PrimaryKeys [i].ColumnType);  							}  						}  						stmtGetprimaryKey.Reset ();  						// Bind parameters  						for (int i = 0; i < pkeys.Length; i++) {  							BindParameter (stmtDeleteItem' i + 1' pkeys [i]);  							BindParameter (stmtDeleteItemTracking' i + 1' pkeys [i]);  						}  						// Execute the deletion of 2 rows  						stmtDeleteItem.Step ();  						stmtDeleteItem.Reset ();  						stmtDeleteItem.ClearBindings ();  						stmtDeleteItemTracking.Step ();  						stmtDeleteItemTracking.Reset ();  						stmtDeleteItemTracking.ClearBindings ();  					}  					else {  						// Get columns for insert  						var cols = map.Columns;  						// Set values for table  						for (var i = 0; i < cols.Length; i++) {  							var val = cols [i].GetValue (entity);  							BindParameter (stmtInsert' i + 1' val);  							BindParameter (stmtUpdate' i + 1' val);  						}  						// add where clause  						for (var i = 0; i < map.PrimaryKeys.Length; i++) {  							var val = map.PrimaryKeys [i].GetValue (entity);  							BindParameter (stmtUpdate' cols.Length + i + 1' val);  						}  						stmtUpdate.Step ();  						stmtUpdate.Reset ();  						stmtUpdate.ClearBindings ();  						stmtInsert.Step ();  						stmtInsert.Reset ();  						stmtInsert.ClearBindings ();  						// Set Values for tracking table  						BindParameter (stmtTracking' 1' entity.ServiceMetadata.IsTombstone);  						BindParameter (stmtTracking' 2' 0);  						BindParameter (stmtTracking' 3' entity.ServiceMetadata.Id);  						BindParameter (stmtTracking' 4' "ETag");  						var editUri = String.Empty;  						if (entity.ServiceMetadata.EditUri != null && entity.ServiceMetadata.EditUri.IsAbsoluteUri)  							editUri = entity.ServiceMetadata.EditUri.AbsoluteUri;  						BindParameter (stmtTracking' 5' editUri);  						BindParameter (stmtTracking' 6' DateTime.UtcNow);  						// Set values for tracking table  						for (var i = 0; i < map.PrimaryKeys.Length; i++) {  							var val = map.PrimaryKeys [i].GetValue (entity);  							BindParameter (stmtTracking' i + 7' val);  						}  						stmtTracking.Step ();  						stmtTracking.Reset ();  						stmtTracking.ClearBindings ();  					}  				}  				using (var statement = connection.Prepare ("Commit Transaction")) {  					statement.Step ();  				}  			}  
Magic Number,Microsoft.Synchronization.ClientServices.SQLite,SQLiteHelper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteHelper.cs,MergeEntities,The following statement contains a magic number: using (var stmtGetprimaryKey = connection.Prepare (querySelectItemPrimaryKeyFromTrackingChangesWithOemID))  	using (var stmtDeleteItem = connection.Prepare (queryDelete))  		using (var stmtDeleteItemTracking = connection.Prepare (queryDeleteTracking))  			using (var stmtTracking = connection.Prepare (queryUpdateTracking)) {  				foreach (var entity in entities) {  					// Foreach entity check if it's a delete action or un insert/update action  					if (entity.ServiceMetadata.IsTombstone) {  						// Delete Action  						// Bind parameter  						BindParameter (stmtGetprimaryKey' 1' entity.ServiceMetadata.Id);  						// Store values of primaryKeys  						Object[] pkeys = new object[map.PrimaryKeys.Length];  						// While row is available (only 1 if it's good)  						while (stmtGetprimaryKey.Step () == SQLiteResult.ROW) {  							for (int i = 0; i < pkeys.Length; i++) {  								// Read the column  								pkeys [i] = ReadCol (stmtGetprimaryKey' i' map.PrimaryKeys [i].ColumnType);  							}  						}  						stmtGetprimaryKey.Reset ();  						// Bind parameters  						for (int i = 0; i < pkeys.Length; i++) {  							BindParameter (stmtDeleteItem' i + 1' pkeys [i]);  							BindParameter (stmtDeleteItemTracking' i + 1' pkeys [i]);  						}  						// Execute the deletion of 2 rows  						stmtDeleteItem.Step ();  						stmtDeleteItem.Reset ();  						stmtDeleteItem.ClearBindings ();  						stmtDeleteItemTracking.Step ();  						stmtDeleteItemTracking.Reset ();  						stmtDeleteItemTracking.ClearBindings ();  					}  					else {  						// Get columns for insert  						var cols = map.Columns;  						// Set values for table  						for (var i = 0; i < cols.Length; i++) {  							var val = cols [i].GetValue (entity);  							BindParameter (stmtInsert' i + 1' val);  							BindParameter (stmtUpdate' i + 1' val);  						}  						// add where clause  						for (var i = 0; i < map.PrimaryKeys.Length; i++) {  							var val = map.PrimaryKeys [i].GetValue (entity);  							BindParameter (stmtUpdate' cols.Length + i + 1' val);  						}  						stmtUpdate.Step ();  						stmtUpdate.Reset ();  						stmtUpdate.ClearBindings ();  						stmtInsert.Step ();  						stmtInsert.Reset ();  						stmtInsert.ClearBindings ();  						// Set Values for tracking table  						BindParameter (stmtTracking' 1' entity.ServiceMetadata.IsTombstone);  						BindParameter (stmtTracking' 2' 0);  						BindParameter (stmtTracking' 3' entity.ServiceMetadata.Id);  						BindParameter (stmtTracking' 4' "ETag");  						var editUri = String.Empty;  						if (entity.ServiceMetadata.EditUri != null && entity.ServiceMetadata.EditUri.IsAbsoluteUri)  							editUri = entity.ServiceMetadata.EditUri.AbsoluteUri;  						BindParameter (stmtTracking' 5' editUri);  						BindParameter (stmtTracking' 6' DateTime.UtcNow);  						// Set values for tracking table  						for (var i = 0; i < map.PrimaryKeys.Length; i++) {  							var val = map.PrimaryKeys [i].GetValue (entity);  							BindParameter (stmtTracking' i + 7' val);  						}  						stmtTracking.Step ();  						stmtTracking.Reset ();  						stmtTracking.ClearBindings ();  					}  				}  				using (var statement = connection.Prepare ("Commit Transaction")) {  					statement.Step ();  				}  			}  
Magic Number,Microsoft.Synchronization.ClientServices.SQLite,SQLiteHelper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteHelper.cs,MergeEntities,The following statement contains a magic number: using (var stmtDeleteItem = connection.Prepare (queryDelete))  	using (var stmtDeleteItemTracking = connection.Prepare (queryDeleteTracking))  		using (var stmtTracking = connection.Prepare (queryUpdateTracking)) {  			foreach (var entity in entities) {  				// Foreach entity check if it's a delete action or un insert/update action  				if (entity.ServiceMetadata.IsTombstone) {  					// Delete Action  					// Bind parameter  					BindParameter (stmtGetprimaryKey' 1' entity.ServiceMetadata.Id);  					// Store values of primaryKeys  					Object[] pkeys = new object[map.PrimaryKeys.Length];  					// While row is available (only 1 if it's good)  					while (stmtGetprimaryKey.Step () == SQLiteResult.ROW) {  						for (int i = 0; i < pkeys.Length; i++) {  							// Read the column  							pkeys [i] = ReadCol (stmtGetprimaryKey' i' map.PrimaryKeys [i].ColumnType);  						}  					}  					stmtGetprimaryKey.Reset ();  					// Bind parameters  					for (int i = 0; i < pkeys.Length; i++) {  						BindParameter (stmtDeleteItem' i + 1' pkeys [i]);  						BindParameter (stmtDeleteItemTracking' i + 1' pkeys [i]);  					}  					// Execute the deletion of 2 rows  					stmtDeleteItem.Step ();  					stmtDeleteItem.Reset ();  					stmtDeleteItem.ClearBindings ();  					stmtDeleteItemTracking.Step ();  					stmtDeleteItemTracking.Reset ();  					stmtDeleteItemTracking.ClearBindings ();  				}  				else {  					// Get columns for insert  					var cols = map.Columns;  					// Set values for table  					for (var i = 0; i < cols.Length; i++) {  						var val = cols [i].GetValue (entity);  						BindParameter (stmtInsert' i + 1' val);  						BindParameter (stmtUpdate' i + 1' val);  					}  					// add where clause  					for (var i = 0; i < map.PrimaryKeys.Length; i++) {  						var val = map.PrimaryKeys [i].GetValue (entity);  						BindParameter (stmtUpdate' cols.Length + i + 1' val);  					}  					stmtUpdate.Step ();  					stmtUpdate.Reset ();  					stmtUpdate.ClearBindings ();  					stmtInsert.Step ();  					stmtInsert.Reset ();  					stmtInsert.ClearBindings ();  					// Set Values for tracking table  					BindParameter (stmtTracking' 1' entity.ServiceMetadata.IsTombstone);  					BindParameter (stmtTracking' 2' 0);  					BindParameter (stmtTracking' 3' entity.ServiceMetadata.Id);  					BindParameter (stmtTracking' 4' "ETag");  					var editUri = String.Empty;  					if (entity.ServiceMetadata.EditUri != null && entity.ServiceMetadata.EditUri.IsAbsoluteUri)  						editUri = entity.ServiceMetadata.EditUri.AbsoluteUri;  					BindParameter (stmtTracking' 5' editUri);  					BindParameter (stmtTracking' 6' DateTime.UtcNow);  					// Set values for tracking table  					for (var i = 0; i < map.PrimaryKeys.Length; i++) {  						var val = map.PrimaryKeys [i].GetValue (entity);  						BindParameter (stmtTracking' i + 7' val);  					}  					stmtTracking.Step ();  					stmtTracking.Reset ();  					stmtTracking.ClearBindings ();  				}  			}  			using (var statement = connection.Prepare ("Commit Transaction")) {  				statement.Step ();  			}  		}  
Magic Number,Microsoft.Synchronization.ClientServices.SQLite,SQLiteHelper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteHelper.cs,MergeEntities,The following statement contains a magic number: using (var stmtDeleteItem = connection.Prepare (queryDelete))  	using (var stmtDeleteItemTracking = connection.Prepare (queryDeleteTracking))  		using (var stmtTracking = connection.Prepare (queryUpdateTracking)) {  			foreach (var entity in entities) {  				// Foreach entity check if it's a delete action or un insert/update action  				if (entity.ServiceMetadata.IsTombstone) {  					// Delete Action  					// Bind parameter  					BindParameter (stmtGetprimaryKey' 1' entity.ServiceMetadata.Id);  					// Store values of primaryKeys  					Object[] pkeys = new object[map.PrimaryKeys.Length];  					// While row is available (only 1 if it's good)  					while (stmtGetprimaryKey.Step () == SQLiteResult.ROW) {  						for (int i = 0; i < pkeys.Length; i++) {  							// Read the column  							pkeys [i] = ReadCol (stmtGetprimaryKey' i' map.PrimaryKeys [i].ColumnType);  						}  					}  					stmtGetprimaryKey.Reset ();  					// Bind parameters  					for (int i = 0; i < pkeys.Length; i++) {  						BindParameter (stmtDeleteItem' i + 1' pkeys [i]);  						BindParameter (stmtDeleteItemTracking' i + 1' pkeys [i]);  					}  					// Execute the deletion of 2 rows  					stmtDeleteItem.Step ();  					stmtDeleteItem.Reset ();  					stmtDeleteItem.ClearBindings ();  					stmtDeleteItemTracking.Step ();  					stmtDeleteItemTracking.Reset ();  					stmtDeleteItemTracking.ClearBindings ();  				}  				else {  					// Get columns for insert  					var cols = map.Columns;  					// Set values for table  					for (var i = 0; i < cols.Length; i++) {  						var val = cols [i].GetValue (entity);  						BindParameter (stmtInsert' i + 1' val);  						BindParameter (stmtUpdate' i + 1' val);  					}  					// add where clause  					for (var i = 0; i < map.PrimaryKeys.Length; i++) {  						var val = map.PrimaryKeys [i].GetValue (entity);  						BindParameter (stmtUpdate' cols.Length + i + 1' val);  					}  					stmtUpdate.Step ();  					stmtUpdate.Reset ();  					stmtUpdate.ClearBindings ();  					stmtInsert.Step ();  					stmtInsert.Reset ();  					stmtInsert.ClearBindings ();  					// Set Values for tracking table  					BindParameter (stmtTracking' 1' entity.ServiceMetadata.IsTombstone);  					BindParameter (stmtTracking' 2' 0);  					BindParameter (stmtTracking' 3' entity.ServiceMetadata.Id);  					BindParameter (stmtTracking' 4' "ETag");  					var editUri = String.Empty;  					if (entity.ServiceMetadata.EditUri != null && entity.ServiceMetadata.EditUri.IsAbsoluteUri)  						editUri = entity.ServiceMetadata.EditUri.AbsoluteUri;  					BindParameter (stmtTracking' 5' editUri);  					BindParameter (stmtTracking' 6' DateTime.UtcNow);  					// Set values for tracking table  					for (var i = 0; i < map.PrimaryKeys.Length; i++) {  						var val = map.PrimaryKeys [i].GetValue (entity);  						BindParameter (stmtTracking' i + 7' val);  					}  					stmtTracking.Step ();  					stmtTracking.Reset ();  					stmtTracking.ClearBindings ();  				}  			}  			using (var statement = connection.Prepare ("Commit Transaction")) {  				statement.Step ();  			}  		}  
Magic Number,Microsoft.Synchronization.ClientServices.SQLite,SQLiteHelper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteHelper.cs,MergeEntities,The following statement contains a magic number: using (var stmtDeleteItem = connection.Prepare (queryDelete))  	using (var stmtDeleteItemTracking = connection.Prepare (queryDeleteTracking))  		using (var stmtTracking = connection.Prepare (queryUpdateTracking)) {  			foreach (var entity in entities) {  				// Foreach entity check if it's a delete action or un insert/update action  				if (entity.ServiceMetadata.IsTombstone) {  					// Delete Action  					// Bind parameter  					BindParameter (stmtGetprimaryKey' 1' entity.ServiceMetadata.Id);  					// Store values of primaryKeys  					Object[] pkeys = new object[map.PrimaryKeys.Length];  					// While row is available (only 1 if it's good)  					while (stmtGetprimaryKey.Step () == SQLiteResult.ROW) {  						for (int i = 0; i < pkeys.Length; i++) {  							// Read the column  							pkeys [i] = ReadCol (stmtGetprimaryKey' i' map.PrimaryKeys [i].ColumnType);  						}  					}  					stmtGetprimaryKey.Reset ();  					// Bind parameters  					for (int i = 0; i < pkeys.Length; i++) {  						BindParameter (stmtDeleteItem' i + 1' pkeys [i]);  						BindParameter (stmtDeleteItemTracking' i + 1' pkeys [i]);  					}  					// Execute the deletion of 2 rows  					stmtDeleteItem.Step ();  					stmtDeleteItem.Reset ();  					stmtDeleteItem.ClearBindings ();  					stmtDeleteItemTracking.Step ();  					stmtDeleteItemTracking.Reset ();  					stmtDeleteItemTracking.ClearBindings ();  				}  				else {  					// Get columns for insert  					var cols = map.Columns;  					// Set values for table  					for (var i = 0; i < cols.Length; i++) {  						var val = cols [i].GetValue (entity);  						BindParameter (stmtInsert' i + 1' val);  						BindParameter (stmtUpdate' i + 1' val);  					}  					// add where clause  					for (var i = 0; i < map.PrimaryKeys.Length; i++) {  						var val = map.PrimaryKeys [i].GetValue (entity);  						BindParameter (stmtUpdate' cols.Length + i + 1' val);  					}  					stmtUpdate.Step ();  					stmtUpdate.Reset ();  					stmtUpdate.ClearBindings ();  					stmtInsert.Step ();  					stmtInsert.Reset ();  					stmtInsert.ClearBindings ();  					// Set Values for tracking table  					BindParameter (stmtTracking' 1' entity.ServiceMetadata.IsTombstone);  					BindParameter (stmtTracking' 2' 0);  					BindParameter (stmtTracking' 3' entity.ServiceMetadata.Id);  					BindParameter (stmtTracking' 4' "ETag");  					var editUri = String.Empty;  					if (entity.ServiceMetadata.EditUri != null && entity.ServiceMetadata.EditUri.IsAbsoluteUri)  						editUri = entity.ServiceMetadata.EditUri.AbsoluteUri;  					BindParameter (stmtTracking' 5' editUri);  					BindParameter (stmtTracking' 6' DateTime.UtcNow);  					// Set values for tracking table  					for (var i = 0; i < map.PrimaryKeys.Length; i++) {  						var val = map.PrimaryKeys [i].GetValue (entity);  						BindParameter (stmtTracking' i + 7' val);  					}  					stmtTracking.Step ();  					stmtTracking.Reset ();  					stmtTracking.ClearBindings ();  				}  			}  			using (var statement = connection.Prepare ("Commit Transaction")) {  				statement.Step ();  			}  		}  
Magic Number,Microsoft.Synchronization.ClientServices.SQLite,SQLiteHelper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteHelper.cs,MergeEntities,The following statement contains a magic number: using (var stmtDeleteItem = connection.Prepare (queryDelete))  	using (var stmtDeleteItemTracking = connection.Prepare (queryDeleteTracking))  		using (var stmtTracking = connection.Prepare (queryUpdateTracking)) {  			foreach (var entity in entities) {  				// Foreach entity check if it's a delete action or un insert/update action  				if (entity.ServiceMetadata.IsTombstone) {  					// Delete Action  					// Bind parameter  					BindParameter (stmtGetprimaryKey' 1' entity.ServiceMetadata.Id);  					// Store values of primaryKeys  					Object[] pkeys = new object[map.PrimaryKeys.Length];  					// While row is available (only 1 if it's good)  					while (stmtGetprimaryKey.Step () == SQLiteResult.ROW) {  						for (int i = 0; i < pkeys.Length; i++) {  							// Read the column  							pkeys [i] = ReadCol (stmtGetprimaryKey' i' map.PrimaryKeys [i].ColumnType);  						}  					}  					stmtGetprimaryKey.Reset ();  					// Bind parameters  					for (int i = 0; i < pkeys.Length; i++) {  						BindParameter (stmtDeleteItem' i + 1' pkeys [i]);  						BindParameter (stmtDeleteItemTracking' i + 1' pkeys [i]);  					}  					// Execute the deletion of 2 rows  					stmtDeleteItem.Step ();  					stmtDeleteItem.Reset ();  					stmtDeleteItem.ClearBindings ();  					stmtDeleteItemTracking.Step ();  					stmtDeleteItemTracking.Reset ();  					stmtDeleteItemTracking.ClearBindings ();  				}  				else {  					// Get columns for insert  					var cols = map.Columns;  					// Set values for table  					for (var i = 0; i < cols.Length; i++) {  						var val = cols [i].GetValue (entity);  						BindParameter (stmtInsert' i + 1' val);  						BindParameter (stmtUpdate' i + 1' val);  					}  					// add where clause  					for (var i = 0; i < map.PrimaryKeys.Length; i++) {  						var val = map.PrimaryKeys [i].GetValue (entity);  						BindParameter (stmtUpdate' cols.Length + i + 1' val);  					}  					stmtUpdate.Step ();  					stmtUpdate.Reset ();  					stmtUpdate.ClearBindings ();  					stmtInsert.Step ();  					stmtInsert.Reset ();  					stmtInsert.ClearBindings ();  					// Set Values for tracking table  					BindParameter (stmtTracking' 1' entity.ServiceMetadata.IsTombstone);  					BindParameter (stmtTracking' 2' 0);  					BindParameter (stmtTracking' 3' entity.ServiceMetadata.Id);  					BindParameter (stmtTracking' 4' "ETag");  					var editUri = String.Empty;  					if (entity.ServiceMetadata.EditUri != null && entity.ServiceMetadata.EditUri.IsAbsoluteUri)  						editUri = entity.ServiceMetadata.EditUri.AbsoluteUri;  					BindParameter (stmtTracking' 5' editUri);  					BindParameter (stmtTracking' 6' DateTime.UtcNow);  					// Set values for tracking table  					for (var i = 0; i < map.PrimaryKeys.Length; i++) {  						var val = map.PrimaryKeys [i].GetValue (entity);  						BindParameter (stmtTracking' i + 7' val);  					}  					stmtTracking.Step ();  					stmtTracking.Reset ();  					stmtTracking.ClearBindings ();  				}  			}  			using (var statement = connection.Prepare ("Commit Transaction")) {  				statement.Step ();  			}  		}  
Magic Number,Microsoft.Synchronization.ClientServices.SQLite,SQLiteHelper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteHelper.cs,MergeEntities,The following statement contains a magic number: using (var stmtDeleteItem = connection.Prepare (queryDelete))  	using (var stmtDeleteItemTracking = connection.Prepare (queryDeleteTracking))  		using (var stmtTracking = connection.Prepare (queryUpdateTracking)) {  			foreach (var entity in entities) {  				// Foreach entity check if it's a delete action or un insert/update action  				if (entity.ServiceMetadata.IsTombstone) {  					// Delete Action  					// Bind parameter  					BindParameter (stmtGetprimaryKey' 1' entity.ServiceMetadata.Id);  					// Store values of primaryKeys  					Object[] pkeys = new object[map.PrimaryKeys.Length];  					// While row is available (only 1 if it's good)  					while (stmtGetprimaryKey.Step () == SQLiteResult.ROW) {  						for (int i = 0; i < pkeys.Length; i++) {  							// Read the column  							pkeys [i] = ReadCol (stmtGetprimaryKey' i' map.PrimaryKeys [i].ColumnType);  						}  					}  					stmtGetprimaryKey.Reset ();  					// Bind parameters  					for (int i = 0; i < pkeys.Length; i++) {  						BindParameter (stmtDeleteItem' i + 1' pkeys [i]);  						BindParameter (stmtDeleteItemTracking' i + 1' pkeys [i]);  					}  					// Execute the deletion of 2 rows  					stmtDeleteItem.Step ();  					stmtDeleteItem.Reset ();  					stmtDeleteItem.ClearBindings ();  					stmtDeleteItemTracking.Step ();  					stmtDeleteItemTracking.Reset ();  					stmtDeleteItemTracking.ClearBindings ();  				}  				else {  					// Get columns for insert  					var cols = map.Columns;  					// Set values for table  					for (var i = 0; i < cols.Length; i++) {  						var val = cols [i].GetValue (entity);  						BindParameter (stmtInsert' i + 1' val);  						BindParameter (stmtUpdate' i + 1' val);  					}  					// add where clause  					for (var i = 0; i < map.PrimaryKeys.Length; i++) {  						var val = map.PrimaryKeys [i].GetValue (entity);  						BindParameter (stmtUpdate' cols.Length + i + 1' val);  					}  					stmtUpdate.Step ();  					stmtUpdate.Reset ();  					stmtUpdate.ClearBindings ();  					stmtInsert.Step ();  					stmtInsert.Reset ();  					stmtInsert.ClearBindings ();  					// Set Values for tracking table  					BindParameter (stmtTracking' 1' entity.ServiceMetadata.IsTombstone);  					BindParameter (stmtTracking' 2' 0);  					BindParameter (stmtTracking' 3' entity.ServiceMetadata.Id);  					BindParameter (stmtTracking' 4' "ETag");  					var editUri = String.Empty;  					if (entity.ServiceMetadata.EditUri != null && entity.ServiceMetadata.EditUri.IsAbsoluteUri)  						editUri = entity.ServiceMetadata.EditUri.AbsoluteUri;  					BindParameter (stmtTracking' 5' editUri);  					BindParameter (stmtTracking' 6' DateTime.UtcNow);  					// Set values for tracking table  					for (var i = 0; i < map.PrimaryKeys.Length; i++) {  						var val = map.PrimaryKeys [i].GetValue (entity);  						BindParameter (stmtTracking' i + 7' val);  					}  					stmtTracking.Step ();  					stmtTracking.Reset ();  					stmtTracking.ClearBindings ();  				}  			}  			using (var statement = connection.Prepare ("Commit Transaction")) {  				statement.Step ();  			}  		}  
Magic Number,Microsoft.Synchronization.ClientServices.SQLite,SQLiteHelper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteHelper.cs,MergeEntities,The following statement contains a magic number: using (var stmtDeleteItem = connection.Prepare (queryDelete))  	using (var stmtDeleteItemTracking = connection.Prepare (queryDeleteTracking))  		using (var stmtTracking = connection.Prepare (queryUpdateTracking)) {  			foreach (var entity in entities) {  				// Foreach entity check if it's a delete action or un insert/update action  				if (entity.ServiceMetadata.IsTombstone) {  					// Delete Action  					// Bind parameter  					BindParameter (stmtGetprimaryKey' 1' entity.ServiceMetadata.Id);  					// Store values of primaryKeys  					Object[] pkeys = new object[map.PrimaryKeys.Length];  					// While row is available (only 1 if it's good)  					while (stmtGetprimaryKey.Step () == SQLiteResult.ROW) {  						for (int i = 0; i < pkeys.Length; i++) {  							// Read the column  							pkeys [i] = ReadCol (stmtGetprimaryKey' i' map.PrimaryKeys [i].ColumnType);  						}  					}  					stmtGetprimaryKey.Reset ();  					// Bind parameters  					for (int i = 0; i < pkeys.Length; i++) {  						BindParameter (stmtDeleteItem' i + 1' pkeys [i]);  						BindParameter (stmtDeleteItemTracking' i + 1' pkeys [i]);  					}  					// Execute the deletion of 2 rows  					stmtDeleteItem.Step ();  					stmtDeleteItem.Reset ();  					stmtDeleteItem.ClearBindings ();  					stmtDeleteItemTracking.Step ();  					stmtDeleteItemTracking.Reset ();  					stmtDeleteItemTracking.ClearBindings ();  				}  				else {  					// Get columns for insert  					var cols = map.Columns;  					// Set values for table  					for (var i = 0; i < cols.Length; i++) {  						var val = cols [i].GetValue (entity);  						BindParameter (stmtInsert' i + 1' val);  						BindParameter (stmtUpdate' i + 1' val);  					}  					// add where clause  					for (var i = 0; i < map.PrimaryKeys.Length; i++) {  						var val = map.PrimaryKeys [i].GetValue (entity);  						BindParameter (stmtUpdate' cols.Length + i + 1' val);  					}  					stmtUpdate.Step ();  					stmtUpdate.Reset ();  					stmtUpdate.ClearBindings ();  					stmtInsert.Step ();  					stmtInsert.Reset ();  					stmtInsert.ClearBindings ();  					// Set Values for tracking table  					BindParameter (stmtTracking' 1' entity.ServiceMetadata.IsTombstone);  					BindParameter (stmtTracking' 2' 0);  					BindParameter (stmtTracking' 3' entity.ServiceMetadata.Id);  					BindParameter (stmtTracking' 4' "ETag");  					var editUri = String.Empty;  					if (entity.ServiceMetadata.EditUri != null && entity.ServiceMetadata.EditUri.IsAbsoluteUri)  						editUri = entity.ServiceMetadata.EditUri.AbsoluteUri;  					BindParameter (stmtTracking' 5' editUri);  					BindParameter (stmtTracking' 6' DateTime.UtcNow);  					// Set values for tracking table  					for (var i = 0; i < map.PrimaryKeys.Length; i++) {  						var val = map.PrimaryKeys [i].GetValue (entity);  						BindParameter (stmtTracking' i + 7' val);  					}  					stmtTracking.Step ();  					stmtTracking.Reset ();  					stmtTracking.ClearBindings ();  				}  			}  			using (var statement = connection.Prepare ("Commit Transaction")) {  				statement.Step ();  			}  		}  
Magic Number,Microsoft.Synchronization.ClientServices.SQLite,SQLiteHelper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteHelper.cs,MergeEntities,The following statement contains a magic number: using (var stmtDeleteItemTracking = connection.Prepare (queryDeleteTracking))  	using (var stmtTracking = connection.Prepare (queryUpdateTracking)) {  		foreach (var entity in entities) {  			// Foreach entity check if it's a delete action or un insert/update action  			if (entity.ServiceMetadata.IsTombstone) {  				// Delete Action  				// Bind parameter  				BindParameter (stmtGetprimaryKey' 1' entity.ServiceMetadata.Id);  				// Store values of primaryKeys  				Object[] pkeys = new object[map.PrimaryKeys.Length];  				// While row is available (only 1 if it's good)  				while (stmtGetprimaryKey.Step () == SQLiteResult.ROW) {  					for (int i = 0; i < pkeys.Length; i++) {  						// Read the column  						pkeys [i] = ReadCol (stmtGetprimaryKey' i' map.PrimaryKeys [i].ColumnType);  					}  				}  				stmtGetprimaryKey.Reset ();  				// Bind parameters  				for (int i = 0; i < pkeys.Length; i++) {  					BindParameter (stmtDeleteItem' i + 1' pkeys [i]);  					BindParameter (stmtDeleteItemTracking' i + 1' pkeys [i]);  				}  				// Execute the deletion of 2 rows  				stmtDeleteItem.Step ();  				stmtDeleteItem.Reset ();  				stmtDeleteItem.ClearBindings ();  				stmtDeleteItemTracking.Step ();  				stmtDeleteItemTracking.Reset ();  				stmtDeleteItemTracking.ClearBindings ();  			}  			else {  				// Get columns for insert  				var cols = map.Columns;  				// Set values for table  				for (var i = 0; i < cols.Length; i++) {  					var val = cols [i].GetValue (entity);  					BindParameter (stmtInsert' i + 1' val);  					BindParameter (stmtUpdate' i + 1' val);  				}  				// add where clause  				for (var i = 0; i < map.PrimaryKeys.Length; i++) {  					var val = map.PrimaryKeys [i].GetValue (entity);  					BindParameter (stmtUpdate' cols.Length + i + 1' val);  				}  				stmtUpdate.Step ();  				stmtUpdate.Reset ();  				stmtUpdate.ClearBindings ();  				stmtInsert.Step ();  				stmtInsert.Reset ();  				stmtInsert.ClearBindings ();  				// Set Values for tracking table  				BindParameter (stmtTracking' 1' entity.ServiceMetadata.IsTombstone);  				BindParameter (stmtTracking' 2' 0);  				BindParameter (stmtTracking' 3' entity.ServiceMetadata.Id);  				BindParameter (stmtTracking' 4' "ETag");  				var editUri = String.Empty;  				if (entity.ServiceMetadata.EditUri != null && entity.ServiceMetadata.EditUri.IsAbsoluteUri)  					editUri = entity.ServiceMetadata.EditUri.AbsoluteUri;  				BindParameter (stmtTracking' 5' editUri);  				BindParameter (stmtTracking' 6' DateTime.UtcNow);  				// Set values for tracking table  				for (var i = 0; i < map.PrimaryKeys.Length; i++) {  					var val = map.PrimaryKeys [i].GetValue (entity);  					BindParameter (stmtTracking' i + 7' val);  				}  				stmtTracking.Step ();  				stmtTracking.Reset ();  				stmtTracking.ClearBindings ();  			}  		}  		using (var statement = connection.Prepare ("Commit Transaction")) {  			statement.Step ();  		}  	}  
Magic Number,Microsoft.Synchronization.ClientServices.SQLite,SQLiteHelper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteHelper.cs,MergeEntities,The following statement contains a magic number: using (var stmtDeleteItemTracking = connection.Prepare (queryDeleteTracking))  	using (var stmtTracking = connection.Prepare (queryUpdateTracking)) {  		foreach (var entity in entities) {  			// Foreach entity check if it's a delete action or un insert/update action  			if (entity.ServiceMetadata.IsTombstone) {  				// Delete Action  				// Bind parameter  				BindParameter (stmtGetprimaryKey' 1' entity.ServiceMetadata.Id);  				// Store values of primaryKeys  				Object[] pkeys = new object[map.PrimaryKeys.Length];  				// While row is available (only 1 if it's good)  				while (stmtGetprimaryKey.Step () == SQLiteResult.ROW) {  					for (int i = 0; i < pkeys.Length; i++) {  						// Read the column  						pkeys [i] = ReadCol (stmtGetprimaryKey' i' map.PrimaryKeys [i].ColumnType);  					}  				}  				stmtGetprimaryKey.Reset ();  				// Bind parameters  				for (int i = 0; i < pkeys.Length; i++) {  					BindParameter (stmtDeleteItem' i + 1' pkeys [i]);  					BindParameter (stmtDeleteItemTracking' i + 1' pkeys [i]);  				}  				// Execute the deletion of 2 rows  				stmtDeleteItem.Step ();  				stmtDeleteItem.Reset ();  				stmtDeleteItem.ClearBindings ();  				stmtDeleteItemTracking.Step ();  				stmtDeleteItemTracking.Reset ();  				stmtDeleteItemTracking.ClearBindings ();  			}  			else {  				// Get columns for insert  				var cols = map.Columns;  				// Set values for table  				for (var i = 0; i < cols.Length; i++) {  					var val = cols [i].GetValue (entity);  					BindParameter (stmtInsert' i + 1' val);  					BindParameter (stmtUpdate' i + 1' val);  				}  				// add where clause  				for (var i = 0; i < map.PrimaryKeys.Length; i++) {  					var val = map.PrimaryKeys [i].GetValue (entity);  					BindParameter (stmtUpdate' cols.Length + i + 1' val);  				}  				stmtUpdate.Step ();  				stmtUpdate.Reset ();  				stmtUpdate.ClearBindings ();  				stmtInsert.Step ();  				stmtInsert.Reset ();  				stmtInsert.ClearBindings ();  				// Set Values for tracking table  				BindParameter (stmtTracking' 1' entity.ServiceMetadata.IsTombstone);  				BindParameter (stmtTracking' 2' 0);  				BindParameter (stmtTracking' 3' entity.ServiceMetadata.Id);  				BindParameter (stmtTracking' 4' "ETag");  				var editUri = String.Empty;  				if (entity.ServiceMetadata.EditUri != null && entity.ServiceMetadata.EditUri.IsAbsoluteUri)  					editUri = entity.ServiceMetadata.EditUri.AbsoluteUri;  				BindParameter (stmtTracking' 5' editUri);  				BindParameter (stmtTracking' 6' DateTime.UtcNow);  				// Set values for tracking table  				for (var i = 0; i < map.PrimaryKeys.Length; i++) {  					var val = map.PrimaryKeys [i].GetValue (entity);  					BindParameter (stmtTracking' i + 7' val);  				}  				stmtTracking.Step ();  				stmtTracking.Reset ();  				stmtTracking.ClearBindings ();  			}  		}  		using (var statement = connection.Prepare ("Commit Transaction")) {  			statement.Step ();  		}  	}  
Magic Number,Microsoft.Synchronization.ClientServices.SQLite,SQLiteHelper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteHelper.cs,MergeEntities,The following statement contains a magic number: using (var stmtDeleteItemTracking = connection.Prepare (queryDeleteTracking))  	using (var stmtTracking = connection.Prepare (queryUpdateTracking)) {  		foreach (var entity in entities) {  			// Foreach entity check if it's a delete action or un insert/update action  			if (entity.ServiceMetadata.IsTombstone) {  				// Delete Action  				// Bind parameter  				BindParameter (stmtGetprimaryKey' 1' entity.ServiceMetadata.Id);  				// Store values of primaryKeys  				Object[] pkeys = new object[map.PrimaryKeys.Length];  				// While row is available (only 1 if it's good)  				while (stmtGetprimaryKey.Step () == SQLiteResult.ROW) {  					for (int i = 0; i < pkeys.Length; i++) {  						// Read the column  						pkeys [i] = ReadCol (stmtGetprimaryKey' i' map.PrimaryKeys [i].ColumnType);  					}  				}  				stmtGetprimaryKey.Reset ();  				// Bind parameters  				for (int i = 0; i < pkeys.Length; i++) {  					BindParameter (stmtDeleteItem' i + 1' pkeys [i]);  					BindParameter (stmtDeleteItemTracking' i + 1' pkeys [i]);  				}  				// Execute the deletion of 2 rows  				stmtDeleteItem.Step ();  				stmtDeleteItem.Reset ();  				stmtDeleteItem.ClearBindings ();  				stmtDeleteItemTracking.Step ();  				stmtDeleteItemTracking.Reset ();  				stmtDeleteItemTracking.ClearBindings ();  			}  			else {  				// Get columns for insert  				var cols = map.Columns;  				// Set values for table  				for (var i = 0; i < cols.Length; i++) {  					var val = cols [i].GetValue (entity);  					BindParameter (stmtInsert' i + 1' val);  					BindParameter (stmtUpdate' i + 1' val);  				}  				// add where clause  				for (var i = 0; i < map.PrimaryKeys.Length; i++) {  					var val = map.PrimaryKeys [i].GetValue (entity);  					BindParameter (stmtUpdate' cols.Length + i + 1' val);  				}  				stmtUpdate.Step ();  				stmtUpdate.Reset ();  				stmtUpdate.ClearBindings ();  				stmtInsert.Step ();  				stmtInsert.Reset ();  				stmtInsert.ClearBindings ();  				// Set Values for tracking table  				BindParameter (stmtTracking' 1' entity.ServiceMetadata.IsTombstone);  				BindParameter (stmtTracking' 2' 0);  				BindParameter (stmtTracking' 3' entity.ServiceMetadata.Id);  				BindParameter (stmtTracking' 4' "ETag");  				var editUri = String.Empty;  				if (entity.ServiceMetadata.EditUri != null && entity.ServiceMetadata.EditUri.IsAbsoluteUri)  					editUri = entity.ServiceMetadata.EditUri.AbsoluteUri;  				BindParameter (stmtTracking' 5' editUri);  				BindParameter (stmtTracking' 6' DateTime.UtcNow);  				// Set values for tracking table  				for (var i = 0; i < map.PrimaryKeys.Length; i++) {  					var val = map.PrimaryKeys [i].GetValue (entity);  					BindParameter (stmtTracking' i + 7' val);  				}  				stmtTracking.Step ();  				stmtTracking.Reset ();  				stmtTracking.ClearBindings ();  			}  		}  		using (var statement = connection.Prepare ("Commit Transaction")) {  			statement.Step ();  		}  	}  
Magic Number,Microsoft.Synchronization.ClientServices.SQLite,SQLiteHelper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteHelper.cs,MergeEntities,The following statement contains a magic number: using (var stmtDeleteItemTracking = connection.Prepare (queryDeleteTracking))  	using (var stmtTracking = connection.Prepare (queryUpdateTracking)) {  		foreach (var entity in entities) {  			// Foreach entity check if it's a delete action or un insert/update action  			if (entity.ServiceMetadata.IsTombstone) {  				// Delete Action  				// Bind parameter  				BindParameter (stmtGetprimaryKey' 1' entity.ServiceMetadata.Id);  				// Store values of primaryKeys  				Object[] pkeys = new object[map.PrimaryKeys.Length];  				// While row is available (only 1 if it's good)  				while (stmtGetprimaryKey.Step () == SQLiteResult.ROW) {  					for (int i = 0; i < pkeys.Length; i++) {  						// Read the column  						pkeys [i] = ReadCol (stmtGetprimaryKey' i' map.PrimaryKeys [i].ColumnType);  					}  				}  				stmtGetprimaryKey.Reset ();  				// Bind parameters  				for (int i = 0; i < pkeys.Length; i++) {  					BindParameter (stmtDeleteItem' i + 1' pkeys [i]);  					BindParameter (stmtDeleteItemTracking' i + 1' pkeys [i]);  				}  				// Execute the deletion of 2 rows  				stmtDeleteItem.Step ();  				stmtDeleteItem.Reset ();  				stmtDeleteItem.ClearBindings ();  				stmtDeleteItemTracking.Step ();  				stmtDeleteItemTracking.Reset ();  				stmtDeleteItemTracking.ClearBindings ();  			}  			else {  				// Get columns for insert  				var cols = map.Columns;  				// Set values for table  				for (var i = 0; i < cols.Length; i++) {  					var val = cols [i].GetValue (entity);  					BindParameter (stmtInsert' i + 1' val);  					BindParameter (stmtUpdate' i + 1' val);  				}  				// add where clause  				for (var i = 0; i < map.PrimaryKeys.Length; i++) {  					var val = map.PrimaryKeys [i].GetValue (entity);  					BindParameter (stmtUpdate' cols.Length + i + 1' val);  				}  				stmtUpdate.Step ();  				stmtUpdate.Reset ();  				stmtUpdate.ClearBindings ();  				stmtInsert.Step ();  				stmtInsert.Reset ();  				stmtInsert.ClearBindings ();  				// Set Values for tracking table  				BindParameter (stmtTracking' 1' entity.ServiceMetadata.IsTombstone);  				BindParameter (stmtTracking' 2' 0);  				BindParameter (stmtTracking' 3' entity.ServiceMetadata.Id);  				BindParameter (stmtTracking' 4' "ETag");  				var editUri = String.Empty;  				if (entity.ServiceMetadata.EditUri != null && entity.ServiceMetadata.EditUri.IsAbsoluteUri)  					editUri = entity.ServiceMetadata.EditUri.AbsoluteUri;  				BindParameter (stmtTracking' 5' editUri);  				BindParameter (stmtTracking' 6' DateTime.UtcNow);  				// Set values for tracking table  				for (var i = 0; i < map.PrimaryKeys.Length; i++) {  					var val = map.PrimaryKeys [i].GetValue (entity);  					BindParameter (stmtTracking' i + 7' val);  				}  				stmtTracking.Step ();  				stmtTracking.Reset ();  				stmtTracking.ClearBindings ();  			}  		}  		using (var statement = connection.Prepare ("Commit Transaction")) {  			statement.Step ();  		}  	}  
Magic Number,Microsoft.Synchronization.ClientServices.SQLite,SQLiteHelper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteHelper.cs,MergeEntities,The following statement contains a magic number: using (var stmtDeleteItemTracking = connection.Prepare (queryDeleteTracking))  	using (var stmtTracking = connection.Prepare (queryUpdateTracking)) {  		foreach (var entity in entities) {  			// Foreach entity check if it's a delete action or un insert/update action  			if (entity.ServiceMetadata.IsTombstone) {  				// Delete Action  				// Bind parameter  				BindParameter (stmtGetprimaryKey' 1' entity.ServiceMetadata.Id);  				// Store values of primaryKeys  				Object[] pkeys = new object[map.PrimaryKeys.Length];  				// While row is available (only 1 if it's good)  				while (stmtGetprimaryKey.Step () == SQLiteResult.ROW) {  					for (int i = 0; i < pkeys.Length; i++) {  						// Read the column  						pkeys [i] = ReadCol (stmtGetprimaryKey' i' map.PrimaryKeys [i].ColumnType);  					}  				}  				stmtGetprimaryKey.Reset ();  				// Bind parameters  				for (int i = 0; i < pkeys.Length; i++) {  					BindParameter (stmtDeleteItem' i + 1' pkeys [i]);  					BindParameter (stmtDeleteItemTracking' i + 1' pkeys [i]);  				}  				// Execute the deletion of 2 rows  				stmtDeleteItem.Step ();  				stmtDeleteItem.Reset ();  				stmtDeleteItem.ClearBindings ();  				stmtDeleteItemTracking.Step ();  				stmtDeleteItemTracking.Reset ();  				stmtDeleteItemTracking.ClearBindings ();  			}  			else {  				// Get columns for insert  				var cols = map.Columns;  				// Set values for table  				for (var i = 0; i < cols.Length; i++) {  					var val = cols [i].GetValue (entity);  					BindParameter (stmtInsert' i + 1' val);  					BindParameter (stmtUpdate' i + 1' val);  				}  				// add where clause  				for (var i = 0; i < map.PrimaryKeys.Length; i++) {  					var val = map.PrimaryKeys [i].GetValue (entity);  					BindParameter (stmtUpdate' cols.Length + i + 1' val);  				}  				stmtUpdate.Step ();  				stmtUpdate.Reset ();  				stmtUpdate.ClearBindings ();  				stmtInsert.Step ();  				stmtInsert.Reset ();  				stmtInsert.ClearBindings ();  				// Set Values for tracking table  				BindParameter (stmtTracking' 1' entity.ServiceMetadata.IsTombstone);  				BindParameter (stmtTracking' 2' 0);  				BindParameter (stmtTracking' 3' entity.ServiceMetadata.Id);  				BindParameter (stmtTracking' 4' "ETag");  				var editUri = String.Empty;  				if (entity.ServiceMetadata.EditUri != null && entity.ServiceMetadata.EditUri.IsAbsoluteUri)  					editUri = entity.ServiceMetadata.EditUri.AbsoluteUri;  				BindParameter (stmtTracking' 5' editUri);  				BindParameter (stmtTracking' 6' DateTime.UtcNow);  				// Set values for tracking table  				for (var i = 0; i < map.PrimaryKeys.Length; i++) {  					var val = map.PrimaryKeys [i].GetValue (entity);  					BindParameter (stmtTracking' i + 7' val);  				}  				stmtTracking.Step ();  				stmtTracking.Reset ();  				stmtTracking.ClearBindings ();  			}  		}  		using (var statement = connection.Prepare ("Commit Transaction")) {  			statement.Step ();  		}  	}  
Magic Number,Microsoft.Synchronization.ClientServices.SQLite,SQLiteHelper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteHelper.cs,MergeEntities,The following statement contains a magic number: using (var stmtDeleteItemTracking = connection.Prepare (queryDeleteTracking))  	using (var stmtTracking = connection.Prepare (queryUpdateTracking)) {  		foreach (var entity in entities) {  			// Foreach entity check if it's a delete action or un insert/update action  			if (entity.ServiceMetadata.IsTombstone) {  				// Delete Action  				// Bind parameter  				BindParameter (stmtGetprimaryKey' 1' entity.ServiceMetadata.Id);  				// Store values of primaryKeys  				Object[] pkeys = new object[map.PrimaryKeys.Length];  				// While row is available (only 1 if it's good)  				while (stmtGetprimaryKey.Step () == SQLiteResult.ROW) {  					for (int i = 0; i < pkeys.Length; i++) {  						// Read the column  						pkeys [i] = ReadCol (stmtGetprimaryKey' i' map.PrimaryKeys [i].ColumnType);  					}  				}  				stmtGetprimaryKey.Reset ();  				// Bind parameters  				for (int i = 0; i < pkeys.Length; i++) {  					BindParameter (stmtDeleteItem' i + 1' pkeys [i]);  					BindParameter (stmtDeleteItemTracking' i + 1' pkeys [i]);  				}  				// Execute the deletion of 2 rows  				stmtDeleteItem.Step ();  				stmtDeleteItem.Reset ();  				stmtDeleteItem.ClearBindings ();  				stmtDeleteItemTracking.Step ();  				stmtDeleteItemTracking.Reset ();  				stmtDeleteItemTracking.ClearBindings ();  			}  			else {  				// Get columns for insert  				var cols = map.Columns;  				// Set values for table  				for (var i = 0; i < cols.Length; i++) {  					var val = cols [i].GetValue (entity);  					BindParameter (stmtInsert' i + 1' val);  					BindParameter (stmtUpdate' i + 1' val);  				}  				// add where clause  				for (var i = 0; i < map.PrimaryKeys.Length; i++) {  					var val = map.PrimaryKeys [i].GetValue (entity);  					BindParameter (stmtUpdate' cols.Length + i + 1' val);  				}  				stmtUpdate.Step ();  				stmtUpdate.Reset ();  				stmtUpdate.ClearBindings ();  				stmtInsert.Step ();  				stmtInsert.Reset ();  				stmtInsert.ClearBindings ();  				// Set Values for tracking table  				BindParameter (stmtTracking' 1' entity.ServiceMetadata.IsTombstone);  				BindParameter (stmtTracking' 2' 0);  				BindParameter (stmtTracking' 3' entity.ServiceMetadata.Id);  				BindParameter (stmtTracking' 4' "ETag");  				var editUri = String.Empty;  				if (entity.ServiceMetadata.EditUri != null && entity.ServiceMetadata.EditUri.IsAbsoluteUri)  					editUri = entity.ServiceMetadata.EditUri.AbsoluteUri;  				BindParameter (stmtTracking' 5' editUri);  				BindParameter (stmtTracking' 6' DateTime.UtcNow);  				// Set values for tracking table  				for (var i = 0; i < map.PrimaryKeys.Length; i++) {  					var val = map.PrimaryKeys [i].GetValue (entity);  					BindParameter (stmtTracking' i + 7' val);  				}  				stmtTracking.Step ();  				stmtTracking.Reset ();  				stmtTracking.ClearBindings ();  			}  		}  		using (var statement = connection.Prepare ("Commit Transaction")) {  			statement.Step ();  		}  	}  
Magic Number,Microsoft.Synchronization.ClientServices.SQLite,SQLiteHelper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteHelper.cs,MergeEntities,The following statement contains a magic number: using (var stmtTracking = connection.Prepare (queryUpdateTracking)) {  	foreach (var entity in entities) {  		// Foreach entity check if it's a delete action or un insert/update action  		if (entity.ServiceMetadata.IsTombstone) {  			// Delete Action  			// Bind parameter  			BindParameter (stmtGetprimaryKey' 1' entity.ServiceMetadata.Id);  			// Store values of primaryKeys  			Object[] pkeys = new object[map.PrimaryKeys.Length];  			// While row is available (only 1 if it's good)  			while (stmtGetprimaryKey.Step () == SQLiteResult.ROW) {  				for (int i = 0; i < pkeys.Length; i++) {  					// Read the column  					pkeys [i] = ReadCol (stmtGetprimaryKey' i' map.PrimaryKeys [i].ColumnType);  				}  			}  			stmtGetprimaryKey.Reset ();  			// Bind parameters  			for (int i = 0; i < pkeys.Length; i++) {  				BindParameter (stmtDeleteItem' i + 1' pkeys [i]);  				BindParameter (stmtDeleteItemTracking' i + 1' pkeys [i]);  			}  			// Execute the deletion of 2 rows  			stmtDeleteItem.Step ();  			stmtDeleteItem.Reset ();  			stmtDeleteItem.ClearBindings ();  			stmtDeleteItemTracking.Step ();  			stmtDeleteItemTracking.Reset ();  			stmtDeleteItemTracking.ClearBindings ();  		}  		else {  			// Get columns for insert  			var cols = map.Columns;  			// Set values for table  			for (var i = 0; i < cols.Length; i++) {  				var val = cols [i].GetValue (entity);  				BindParameter (stmtInsert' i + 1' val);  				BindParameter (stmtUpdate' i + 1' val);  			}  			// add where clause  			for (var i = 0; i < map.PrimaryKeys.Length; i++) {  				var val = map.PrimaryKeys [i].GetValue (entity);  				BindParameter (stmtUpdate' cols.Length + i + 1' val);  			}  			stmtUpdate.Step ();  			stmtUpdate.Reset ();  			stmtUpdate.ClearBindings ();  			stmtInsert.Step ();  			stmtInsert.Reset ();  			stmtInsert.ClearBindings ();  			// Set Values for tracking table  			BindParameter (stmtTracking' 1' entity.ServiceMetadata.IsTombstone);  			BindParameter (stmtTracking' 2' 0);  			BindParameter (stmtTracking' 3' entity.ServiceMetadata.Id);  			BindParameter (stmtTracking' 4' "ETag");  			var editUri = String.Empty;  			if (entity.ServiceMetadata.EditUri != null && entity.ServiceMetadata.EditUri.IsAbsoluteUri)  				editUri = entity.ServiceMetadata.EditUri.AbsoluteUri;  			BindParameter (stmtTracking' 5' editUri);  			BindParameter (stmtTracking' 6' DateTime.UtcNow);  			// Set values for tracking table  			for (var i = 0; i < map.PrimaryKeys.Length; i++) {  				var val = map.PrimaryKeys [i].GetValue (entity);  				BindParameter (stmtTracking' i + 7' val);  			}  			stmtTracking.Step ();  			stmtTracking.Reset ();  			stmtTracking.ClearBindings ();  		}  	}  	using (var statement = connection.Prepare ("Commit Transaction")) {  		statement.Step ();  	}  }  
Magic Number,Microsoft.Synchronization.ClientServices.SQLite,SQLiteHelper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteHelper.cs,MergeEntities,The following statement contains a magic number: using (var stmtTracking = connection.Prepare (queryUpdateTracking)) {  	foreach (var entity in entities) {  		// Foreach entity check if it's a delete action or un insert/update action  		if (entity.ServiceMetadata.IsTombstone) {  			// Delete Action  			// Bind parameter  			BindParameter (stmtGetprimaryKey' 1' entity.ServiceMetadata.Id);  			// Store values of primaryKeys  			Object[] pkeys = new object[map.PrimaryKeys.Length];  			// While row is available (only 1 if it's good)  			while (stmtGetprimaryKey.Step () == SQLiteResult.ROW) {  				for (int i = 0; i < pkeys.Length; i++) {  					// Read the column  					pkeys [i] = ReadCol (stmtGetprimaryKey' i' map.PrimaryKeys [i].ColumnType);  				}  			}  			stmtGetprimaryKey.Reset ();  			// Bind parameters  			for (int i = 0; i < pkeys.Length; i++) {  				BindParameter (stmtDeleteItem' i + 1' pkeys [i]);  				BindParameter (stmtDeleteItemTracking' i + 1' pkeys [i]);  			}  			// Execute the deletion of 2 rows  			stmtDeleteItem.Step ();  			stmtDeleteItem.Reset ();  			stmtDeleteItem.ClearBindings ();  			stmtDeleteItemTracking.Step ();  			stmtDeleteItemTracking.Reset ();  			stmtDeleteItemTracking.ClearBindings ();  		}  		else {  			// Get columns for insert  			var cols = map.Columns;  			// Set values for table  			for (var i = 0; i < cols.Length; i++) {  				var val = cols [i].GetValue (entity);  				BindParameter (stmtInsert' i + 1' val);  				BindParameter (stmtUpdate' i + 1' val);  			}  			// add where clause  			for (var i = 0; i < map.PrimaryKeys.Length; i++) {  				var val = map.PrimaryKeys [i].GetValue (entity);  				BindParameter (stmtUpdate' cols.Length + i + 1' val);  			}  			stmtUpdate.Step ();  			stmtUpdate.Reset ();  			stmtUpdate.ClearBindings ();  			stmtInsert.Step ();  			stmtInsert.Reset ();  			stmtInsert.ClearBindings ();  			// Set Values for tracking table  			BindParameter (stmtTracking' 1' entity.ServiceMetadata.IsTombstone);  			BindParameter (stmtTracking' 2' 0);  			BindParameter (stmtTracking' 3' entity.ServiceMetadata.Id);  			BindParameter (stmtTracking' 4' "ETag");  			var editUri = String.Empty;  			if (entity.ServiceMetadata.EditUri != null && entity.ServiceMetadata.EditUri.IsAbsoluteUri)  				editUri = entity.ServiceMetadata.EditUri.AbsoluteUri;  			BindParameter (stmtTracking' 5' editUri);  			BindParameter (stmtTracking' 6' DateTime.UtcNow);  			// Set values for tracking table  			for (var i = 0; i < map.PrimaryKeys.Length; i++) {  				var val = map.PrimaryKeys [i].GetValue (entity);  				BindParameter (stmtTracking' i + 7' val);  			}  			stmtTracking.Step ();  			stmtTracking.Reset ();  			stmtTracking.ClearBindings ();  		}  	}  	using (var statement = connection.Prepare ("Commit Transaction")) {  		statement.Step ();  	}  }  
Magic Number,Microsoft.Synchronization.ClientServices.SQLite,SQLiteHelper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteHelper.cs,MergeEntities,The following statement contains a magic number: using (var stmtTracking = connection.Prepare (queryUpdateTracking)) {  	foreach (var entity in entities) {  		// Foreach entity check if it's a delete action or un insert/update action  		if (entity.ServiceMetadata.IsTombstone) {  			// Delete Action  			// Bind parameter  			BindParameter (stmtGetprimaryKey' 1' entity.ServiceMetadata.Id);  			// Store values of primaryKeys  			Object[] pkeys = new object[map.PrimaryKeys.Length];  			// While row is available (only 1 if it's good)  			while (stmtGetprimaryKey.Step () == SQLiteResult.ROW) {  				for (int i = 0; i < pkeys.Length; i++) {  					// Read the column  					pkeys [i] = ReadCol (stmtGetprimaryKey' i' map.PrimaryKeys [i].ColumnType);  				}  			}  			stmtGetprimaryKey.Reset ();  			// Bind parameters  			for (int i = 0; i < pkeys.Length; i++) {  				BindParameter (stmtDeleteItem' i + 1' pkeys [i]);  				BindParameter (stmtDeleteItemTracking' i + 1' pkeys [i]);  			}  			// Execute the deletion of 2 rows  			stmtDeleteItem.Step ();  			stmtDeleteItem.Reset ();  			stmtDeleteItem.ClearBindings ();  			stmtDeleteItemTracking.Step ();  			stmtDeleteItemTracking.Reset ();  			stmtDeleteItemTracking.ClearBindings ();  		}  		else {  			// Get columns for insert  			var cols = map.Columns;  			// Set values for table  			for (var i = 0; i < cols.Length; i++) {  				var val = cols [i].GetValue (entity);  				BindParameter (stmtInsert' i + 1' val);  				BindParameter (stmtUpdate' i + 1' val);  			}  			// add where clause  			for (var i = 0; i < map.PrimaryKeys.Length; i++) {  				var val = map.PrimaryKeys [i].GetValue (entity);  				BindParameter (stmtUpdate' cols.Length + i + 1' val);  			}  			stmtUpdate.Step ();  			stmtUpdate.Reset ();  			stmtUpdate.ClearBindings ();  			stmtInsert.Step ();  			stmtInsert.Reset ();  			stmtInsert.ClearBindings ();  			// Set Values for tracking table  			BindParameter (stmtTracking' 1' entity.ServiceMetadata.IsTombstone);  			BindParameter (stmtTracking' 2' 0);  			BindParameter (stmtTracking' 3' entity.ServiceMetadata.Id);  			BindParameter (stmtTracking' 4' "ETag");  			var editUri = String.Empty;  			if (entity.ServiceMetadata.EditUri != null && entity.ServiceMetadata.EditUri.IsAbsoluteUri)  				editUri = entity.ServiceMetadata.EditUri.AbsoluteUri;  			BindParameter (stmtTracking' 5' editUri);  			BindParameter (stmtTracking' 6' DateTime.UtcNow);  			// Set values for tracking table  			for (var i = 0; i < map.PrimaryKeys.Length; i++) {  				var val = map.PrimaryKeys [i].GetValue (entity);  				BindParameter (stmtTracking' i + 7' val);  			}  			stmtTracking.Step ();  			stmtTracking.Reset ();  			stmtTracking.ClearBindings ();  		}  	}  	using (var statement = connection.Prepare ("Commit Transaction")) {  		statement.Step ();  	}  }  
Magic Number,Microsoft.Synchronization.ClientServices.SQLite,SQLiteHelper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteHelper.cs,MergeEntities,The following statement contains a magic number: using (var stmtTracking = connection.Prepare (queryUpdateTracking)) {  	foreach (var entity in entities) {  		// Foreach entity check if it's a delete action or un insert/update action  		if (entity.ServiceMetadata.IsTombstone) {  			// Delete Action  			// Bind parameter  			BindParameter (stmtGetprimaryKey' 1' entity.ServiceMetadata.Id);  			// Store values of primaryKeys  			Object[] pkeys = new object[map.PrimaryKeys.Length];  			// While row is available (only 1 if it's good)  			while (stmtGetprimaryKey.Step () == SQLiteResult.ROW) {  				for (int i = 0; i < pkeys.Length; i++) {  					// Read the column  					pkeys [i] = ReadCol (stmtGetprimaryKey' i' map.PrimaryKeys [i].ColumnType);  				}  			}  			stmtGetprimaryKey.Reset ();  			// Bind parameters  			for (int i = 0; i < pkeys.Length; i++) {  				BindParameter (stmtDeleteItem' i + 1' pkeys [i]);  				BindParameter (stmtDeleteItemTracking' i + 1' pkeys [i]);  			}  			// Execute the deletion of 2 rows  			stmtDeleteItem.Step ();  			stmtDeleteItem.Reset ();  			stmtDeleteItem.ClearBindings ();  			stmtDeleteItemTracking.Step ();  			stmtDeleteItemTracking.Reset ();  			stmtDeleteItemTracking.ClearBindings ();  		}  		else {  			// Get columns for insert  			var cols = map.Columns;  			// Set values for table  			for (var i = 0; i < cols.Length; i++) {  				var val = cols [i].GetValue (entity);  				BindParameter (stmtInsert' i + 1' val);  				BindParameter (stmtUpdate' i + 1' val);  			}  			// add where clause  			for (var i = 0; i < map.PrimaryKeys.Length; i++) {  				var val = map.PrimaryKeys [i].GetValue (entity);  				BindParameter (stmtUpdate' cols.Length + i + 1' val);  			}  			stmtUpdate.Step ();  			stmtUpdate.Reset ();  			stmtUpdate.ClearBindings ();  			stmtInsert.Step ();  			stmtInsert.Reset ();  			stmtInsert.ClearBindings ();  			// Set Values for tracking table  			BindParameter (stmtTracking' 1' entity.ServiceMetadata.IsTombstone);  			BindParameter (stmtTracking' 2' 0);  			BindParameter (stmtTracking' 3' entity.ServiceMetadata.Id);  			BindParameter (stmtTracking' 4' "ETag");  			var editUri = String.Empty;  			if (entity.ServiceMetadata.EditUri != null && entity.ServiceMetadata.EditUri.IsAbsoluteUri)  				editUri = entity.ServiceMetadata.EditUri.AbsoluteUri;  			BindParameter (stmtTracking' 5' editUri);  			BindParameter (stmtTracking' 6' DateTime.UtcNow);  			// Set values for tracking table  			for (var i = 0; i < map.PrimaryKeys.Length; i++) {  				var val = map.PrimaryKeys [i].GetValue (entity);  				BindParameter (stmtTracking' i + 7' val);  			}  			stmtTracking.Step ();  			stmtTracking.Reset ();  			stmtTracking.ClearBindings ();  		}  	}  	using (var statement = connection.Prepare ("Commit Transaction")) {  		statement.Step ();  	}  }  
Magic Number,Microsoft.Synchronization.ClientServices.SQLite,SQLiteHelper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteHelper.cs,MergeEntities,The following statement contains a magic number: using (var stmtTracking = connection.Prepare (queryUpdateTracking)) {  	foreach (var entity in entities) {  		// Foreach entity check if it's a delete action or un insert/update action  		if (entity.ServiceMetadata.IsTombstone) {  			// Delete Action  			// Bind parameter  			BindParameter (stmtGetprimaryKey' 1' entity.ServiceMetadata.Id);  			// Store values of primaryKeys  			Object[] pkeys = new object[map.PrimaryKeys.Length];  			// While row is available (only 1 if it's good)  			while (stmtGetprimaryKey.Step () == SQLiteResult.ROW) {  				for (int i = 0; i < pkeys.Length; i++) {  					// Read the column  					pkeys [i] = ReadCol (stmtGetprimaryKey' i' map.PrimaryKeys [i].ColumnType);  				}  			}  			stmtGetprimaryKey.Reset ();  			// Bind parameters  			for (int i = 0; i < pkeys.Length; i++) {  				BindParameter (stmtDeleteItem' i + 1' pkeys [i]);  				BindParameter (stmtDeleteItemTracking' i + 1' pkeys [i]);  			}  			// Execute the deletion of 2 rows  			stmtDeleteItem.Step ();  			stmtDeleteItem.Reset ();  			stmtDeleteItem.ClearBindings ();  			stmtDeleteItemTracking.Step ();  			stmtDeleteItemTracking.Reset ();  			stmtDeleteItemTracking.ClearBindings ();  		}  		else {  			// Get columns for insert  			var cols = map.Columns;  			// Set values for table  			for (var i = 0; i < cols.Length; i++) {  				var val = cols [i].GetValue (entity);  				BindParameter (stmtInsert' i + 1' val);  				BindParameter (stmtUpdate' i + 1' val);  			}  			// add where clause  			for (var i = 0; i < map.PrimaryKeys.Length; i++) {  				var val = map.PrimaryKeys [i].GetValue (entity);  				BindParameter (stmtUpdate' cols.Length + i + 1' val);  			}  			stmtUpdate.Step ();  			stmtUpdate.Reset ();  			stmtUpdate.ClearBindings ();  			stmtInsert.Step ();  			stmtInsert.Reset ();  			stmtInsert.ClearBindings ();  			// Set Values for tracking table  			BindParameter (stmtTracking' 1' entity.ServiceMetadata.IsTombstone);  			BindParameter (stmtTracking' 2' 0);  			BindParameter (stmtTracking' 3' entity.ServiceMetadata.Id);  			BindParameter (stmtTracking' 4' "ETag");  			var editUri = String.Empty;  			if (entity.ServiceMetadata.EditUri != null && entity.ServiceMetadata.EditUri.IsAbsoluteUri)  				editUri = entity.ServiceMetadata.EditUri.AbsoluteUri;  			BindParameter (stmtTracking' 5' editUri);  			BindParameter (stmtTracking' 6' DateTime.UtcNow);  			// Set values for tracking table  			for (var i = 0; i < map.PrimaryKeys.Length; i++) {  				var val = map.PrimaryKeys [i].GetValue (entity);  				BindParameter (stmtTracking' i + 7' val);  			}  			stmtTracking.Step ();  			stmtTracking.Reset ();  			stmtTracking.ClearBindings ();  		}  	}  	using (var statement = connection.Prepare ("Commit Transaction")) {  		statement.Step ();  	}  }  
Magic Number,Microsoft.Synchronization.ClientServices.SQLite,SQLiteHelper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteHelper.cs,MergeEntities,The following statement contains a magic number: using (var stmtTracking = connection.Prepare (queryUpdateTracking)) {  	foreach (var entity in entities) {  		// Foreach entity check if it's a delete action or un insert/update action  		if (entity.ServiceMetadata.IsTombstone) {  			// Delete Action  			// Bind parameter  			BindParameter (stmtGetprimaryKey' 1' entity.ServiceMetadata.Id);  			// Store values of primaryKeys  			Object[] pkeys = new object[map.PrimaryKeys.Length];  			// While row is available (only 1 if it's good)  			while (stmtGetprimaryKey.Step () == SQLiteResult.ROW) {  				for (int i = 0; i < pkeys.Length; i++) {  					// Read the column  					pkeys [i] = ReadCol (stmtGetprimaryKey' i' map.PrimaryKeys [i].ColumnType);  				}  			}  			stmtGetprimaryKey.Reset ();  			// Bind parameters  			for (int i = 0; i < pkeys.Length; i++) {  				BindParameter (stmtDeleteItem' i + 1' pkeys [i]);  				BindParameter (stmtDeleteItemTracking' i + 1' pkeys [i]);  			}  			// Execute the deletion of 2 rows  			stmtDeleteItem.Step ();  			stmtDeleteItem.Reset ();  			stmtDeleteItem.ClearBindings ();  			stmtDeleteItemTracking.Step ();  			stmtDeleteItemTracking.Reset ();  			stmtDeleteItemTracking.ClearBindings ();  		}  		else {  			// Get columns for insert  			var cols = map.Columns;  			// Set values for table  			for (var i = 0; i < cols.Length; i++) {  				var val = cols [i].GetValue (entity);  				BindParameter (stmtInsert' i + 1' val);  				BindParameter (stmtUpdate' i + 1' val);  			}  			// add where clause  			for (var i = 0; i < map.PrimaryKeys.Length; i++) {  				var val = map.PrimaryKeys [i].GetValue (entity);  				BindParameter (stmtUpdate' cols.Length + i + 1' val);  			}  			stmtUpdate.Step ();  			stmtUpdate.Reset ();  			stmtUpdate.ClearBindings ();  			stmtInsert.Step ();  			stmtInsert.Reset ();  			stmtInsert.ClearBindings ();  			// Set Values for tracking table  			BindParameter (stmtTracking' 1' entity.ServiceMetadata.IsTombstone);  			BindParameter (stmtTracking' 2' 0);  			BindParameter (stmtTracking' 3' entity.ServiceMetadata.Id);  			BindParameter (stmtTracking' 4' "ETag");  			var editUri = String.Empty;  			if (entity.ServiceMetadata.EditUri != null && entity.ServiceMetadata.EditUri.IsAbsoluteUri)  				editUri = entity.ServiceMetadata.EditUri.AbsoluteUri;  			BindParameter (stmtTracking' 5' editUri);  			BindParameter (stmtTracking' 6' DateTime.UtcNow);  			// Set values for tracking table  			for (var i = 0; i < map.PrimaryKeys.Length; i++) {  				var val = map.PrimaryKeys [i].GetValue (entity);  				BindParameter (stmtTracking' i + 7' val);  			}  			stmtTracking.Step ();  			stmtTracking.Reset ();  			stmtTracking.ClearBindings ();  		}  	}  	using (var statement = connection.Prepare ("Commit Transaction")) {  		statement.Step ();  	}  }  
Magic Number,Microsoft.Synchronization.ClientServices.SQLite,SQLiteHelper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteHelper.cs,MergeEntities,The following statement contains a magic number: foreach (var entity in entities) {  	// Foreach entity check if it's a delete action or un insert/update action  	if (entity.ServiceMetadata.IsTombstone) {  		// Delete Action  		// Bind parameter  		BindParameter (stmtGetprimaryKey' 1' entity.ServiceMetadata.Id);  		// Store values of primaryKeys  		Object[] pkeys = new object[map.PrimaryKeys.Length];  		// While row is available (only 1 if it's good)  		while (stmtGetprimaryKey.Step () == SQLiteResult.ROW) {  			for (int i = 0; i < pkeys.Length; i++) {  				// Read the column  				pkeys [i] = ReadCol (stmtGetprimaryKey' i' map.PrimaryKeys [i].ColumnType);  			}  		}  		stmtGetprimaryKey.Reset ();  		// Bind parameters  		for (int i = 0; i < pkeys.Length; i++) {  			BindParameter (stmtDeleteItem' i + 1' pkeys [i]);  			BindParameter (stmtDeleteItemTracking' i + 1' pkeys [i]);  		}  		// Execute the deletion of 2 rows  		stmtDeleteItem.Step ();  		stmtDeleteItem.Reset ();  		stmtDeleteItem.ClearBindings ();  		stmtDeleteItemTracking.Step ();  		stmtDeleteItemTracking.Reset ();  		stmtDeleteItemTracking.ClearBindings ();  	}  	else {  		// Get columns for insert  		var cols = map.Columns;  		// Set values for table  		for (var i = 0; i < cols.Length; i++) {  			var val = cols [i].GetValue (entity);  			BindParameter (stmtInsert' i + 1' val);  			BindParameter (stmtUpdate' i + 1' val);  		}  		// add where clause  		for (var i = 0; i < map.PrimaryKeys.Length; i++) {  			var val = map.PrimaryKeys [i].GetValue (entity);  			BindParameter (stmtUpdate' cols.Length + i + 1' val);  		}  		stmtUpdate.Step ();  		stmtUpdate.Reset ();  		stmtUpdate.ClearBindings ();  		stmtInsert.Step ();  		stmtInsert.Reset ();  		stmtInsert.ClearBindings ();  		// Set Values for tracking table  		BindParameter (stmtTracking' 1' entity.ServiceMetadata.IsTombstone);  		BindParameter (stmtTracking' 2' 0);  		BindParameter (stmtTracking' 3' entity.ServiceMetadata.Id);  		BindParameter (stmtTracking' 4' "ETag");  		var editUri = String.Empty;  		if (entity.ServiceMetadata.EditUri != null && entity.ServiceMetadata.EditUri.IsAbsoluteUri)  			editUri = entity.ServiceMetadata.EditUri.AbsoluteUri;  		BindParameter (stmtTracking' 5' editUri);  		BindParameter (stmtTracking' 6' DateTime.UtcNow);  		// Set values for tracking table  		for (var i = 0; i < map.PrimaryKeys.Length; i++) {  			var val = map.PrimaryKeys [i].GetValue (entity);  			BindParameter (stmtTracking' i + 7' val);  		}  		stmtTracking.Step ();  		stmtTracking.Reset ();  		stmtTracking.ClearBindings ();  	}  }  
Magic Number,Microsoft.Synchronization.ClientServices.SQLite,SQLiteHelper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteHelper.cs,MergeEntities,The following statement contains a magic number: foreach (var entity in entities) {  	// Foreach entity check if it's a delete action or un insert/update action  	if (entity.ServiceMetadata.IsTombstone) {  		// Delete Action  		// Bind parameter  		BindParameter (stmtGetprimaryKey' 1' entity.ServiceMetadata.Id);  		// Store values of primaryKeys  		Object[] pkeys = new object[map.PrimaryKeys.Length];  		// While row is available (only 1 if it's good)  		while (stmtGetprimaryKey.Step () == SQLiteResult.ROW) {  			for (int i = 0; i < pkeys.Length; i++) {  				// Read the column  				pkeys [i] = ReadCol (stmtGetprimaryKey' i' map.PrimaryKeys [i].ColumnType);  			}  		}  		stmtGetprimaryKey.Reset ();  		// Bind parameters  		for (int i = 0; i < pkeys.Length; i++) {  			BindParameter (stmtDeleteItem' i + 1' pkeys [i]);  			BindParameter (stmtDeleteItemTracking' i + 1' pkeys [i]);  		}  		// Execute the deletion of 2 rows  		stmtDeleteItem.Step ();  		stmtDeleteItem.Reset ();  		stmtDeleteItem.ClearBindings ();  		stmtDeleteItemTracking.Step ();  		stmtDeleteItemTracking.Reset ();  		stmtDeleteItemTracking.ClearBindings ();  	}  	else {  		// Get columns for insert  		var cols = map.Columns;  		// Set values for table  		for (var i = 0; i < cols.Length; i++) {  			var val = cols [i].GetValue (entity);  			BindParameter (stmtInsert' i + 1' val);  			BindParameter (stmtUpdate' i + 1' val);  		}  		// add where clause  		for (var i = 0; i < map.PrimaryKeys.Length; i++) {  			var val = map.PrimaryKeys [i].GetValue (entity);  			BindParameter (stmtUpdate' cols.Length + i + 1' val);  		}  		stmtUpdate.Step ();  		stmtUpdate.Reset ();  		stmtUpdate.ClearBindings ();  		stmtInsert.Step ();  		stmtInsert.Reset ();  		stmtInsert.ClearBindings ();  		// Set Values for tracking table  		BindParameter (stmtTracking' 1' entity.ServiceMetadata.IsTombstone);  		BindParameter (stmtTracking' 2' 0);  		BindParameter (stmtTracking' 3' entity.ServiceMetadata.Id);  		BindParameter (stmtTracking' 4' "ETag");  		var editUri = String.Empty;  		if (entity.ServiceMetadata.EditUri != null && entity.ServiceMetadata.EditUri.IsAbsoluteUri)  			editUri = entity.ServiceMetadata.EditUri.AbsoluteUri;  		BindParameter (stmtTracking' 5' editUri);  		BindParameter (stmtTracking' 6' DateTime.UtcNow);  		// Set values for tracking table  		for (var i = 0; i < map.PrimaryKeys.Length; i++) {  			var val = map.PrimaryKeys [i].GetValue (entity);  			BindParameter (stmtTracking' i + 7' val);  		}  		stmtTracking.Step ();  		stmtTracking.Reset ();  		stmtTracking.ClearBindings ();  	}  }  
Magic Number,Microsoft.Synchronization.ClientServices.SQLite,SQLiteHelper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteHelper.cs,MergeEntities,The following statement contains a magic number: foreach (var entity in entities) {  	// Foreach entity check if it's a delete action or un insert/update action  	if (entity.ServiceMetadata.IsTombstone) {  		// Delete Action  		// Bind parameter  		BindParameter (stmtGetprimaryKey' 1' entity.ServiceMetadata.Id);  		// Store values of primaryKeys  		Object[] pkeys = new object[map.PrimaryKeys.Length];  		// While row is available (only 1 if it's good)  		while (stmtGetprimaryKey.Step () == SQLiteResult.ROW) {  			for (int i = 0; i < pkeys.Length; i++) {  				// Read the column  				pkeys [i] = ReadCol (stmtGetprimaryKey' i' map.PrimaryKeys [i].ColumnType);  			}  		}  		stmtGetprimaryKey.Reset ();  		// Bind parameters  		for (int i = 0; i < pkeys.Length; i++) {  			BindParameter (stmtDeleteItem' i + 1' pkeys [i]);  			BindParameter (stmtDeleteItemTracking' i + 1' pkeys [i]);  		}  		// Execute the deletion of 2 rows  		stmtDeleteItem.Step ();  		stmtDeleteItem.Reset ();  		stmtDeleteItem.ClearBindings ();  		stmtDeleteItemTracking.Step ();  		stmtDeleteItemTracking.Reset ();  		stmtDeleteItemTracking.ClearBindings ();  	}  	else {  		// Get columns for insert  		var cols = map.Columns;  		// Set values for table  		for (var i = 0; i < cols.Length; i++) {  			var val = cols [i].GetValue (entity);  			BindParameter (stmtInsert' i + 1' val);  			BindParameter (stmtUpdate' i + 1' val);  		}  		// add where clause  		for (var i = 0; i < map.PrimaryKeys.Length; i++) {  			var val = map.PrimaryKeys [i].GetValue (entity);  			BindParameter (stmtUpdate' cols.Length + i + 1' val);  		}  		stmtUpdate.Step ();  		stmtUpdate.Reset ();  		stmtUpdate.ClearBindings ();  		stmtInsert.Step ();  		stmtInsert.Reset ();  		stmtInsert.ClearBindings ();  		// Set Values for tracking table  		BindParameter (stmtTracking' 1' entity.ServiceMetadata.IsTombstone);  		BindParameter (stmtTracking' 2' 0);  		BindParameter (stmtTracking' 3' entity.ServiceMetadata.Id);  		BindParameter (stmtTracking' 4' "ETag");  		var editUri = String.Empty;  		if (entity.ServiceMetadata.EditUri != null && entity.ServiceMetadata.EditUri.IsAbsoluteUri)  			editUri = entity.ServiceMetadata.EditUri.AbsoluteUri;  		BindParameter (stmtTracking' 5' editUri);  		BindParameter (stmtTracking' 6' DateTime.UtcNow);  		// Set values for tracking table  		for (var i = 0; i < map.PrimaryKeys.Length; i++) {  			var val = map.PrimaryKeys [i].GetValue (entity);  			BindParameter (stmtTracking' i + 7' val);  		}  		stmtTracking.Step ();  		stmtTracking.Reset ();  		stmtTracking.ClearBindings ();  	}  }  
Magic Number,Microsoft.Synchronization.ClientServices.SQLite,SQLiteHelper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteHelper.cs,MergeEntities,The following statement contains a magic number: foreach (var entity in entities) {  	// Foreach entity check if it's a delete action or un insert/update action  	if (entity.ServiceMetadata.IsTombstone) {  		// Delete Action  		// Bind parameter  		BindParameter (stmtGetprimaryKey' 1' entity.ServiceMetadata.Id);  		// Store values of primaryKeys  		Object[] pkeys = new object[map.PrimaryKeys.Length];  		// While row is available (only 1 if it's good)  		while (stmtGetprimaryKey.Step () == SQLiteResult.ROW) {  			for (int i = 0; i < pkeys.Length; i++) {  				// Read the column  				pkeys [i] = ReadCol (stmtGetprimaryKey' i' map.PrimaryKeys [i].ColumnType);  			}  		}  		stmtGetprimaryKey.Reset ();  		// Bind parameters  		for (int i = 0; i < pkeys.Length; i++) {  			BindParameter (stmtDeleteItem' i + 1' pkeys [i]);  			BindParameter (stmtDeleteItemTracking' i + 1' pkeys [i]);  		}  		// Execute the deletion of 2 rows  		stmtDeleteItem.Step ();  		stmtDeleteItem.Reset ();  		stmtDeleteItem.ClearBindings ();  		stmtDeleteItemTracking.Step ();  		stmtDeleteItemTracking.Reset ();  		stmtDeleteItemTracking.ClearBindings ();  	}  	else {  		// Get columns for insert  		var cols = map.Columns;  		// Set values for table  		for (var i = 0; i < cols.Length; i++) {  			var val = cols [i].GetValue (entity);  			BindParameter (stmtInsert' i + 1' val);  			BindParameter (stmtUpdate' i + 1' val);  		}  		// add where clause  		for (var i = 0; i < map.PrimaryKeys.Length; i++) {  			var val = map.PrimaryKeys [i].GetValue (entity);  			BindParameter (stmtUpdate' cols.Length + i + 1' val);  		}  		stmtUpdate.Step ();  		stmtUpdate.Reset ();  		stmtUpdate.ClearBindings ();  		stmtInsert.Step ();  		stmtInsert.Reset ();  		stmtInsert.ClearBindings ();  		// Set Values for tracking table  		BindParameter (stmtTracking' 1' entity.ServiceMetadata.IsTombstone);  		BindParameter (stmtTracking' 2' 0);  		BindParameter (stmtTracking' 3' entity.ServiceMetadata.Id);  		BindParameter (stmtTracking' 4' "ETag");  		var editUri = String.Empty;  		if (entity.ServiceMetadata.EditUri != null && entity.ServiceMetadata.EditUri.IsAbsoluteUri)  			editUri = entity.ServiceMetadata.EditUri.AbsoluteUri;  		BindParameter (stmtTracking' 5' editUri);  		BindParameter (stmtTracking' 6' DateTime.UtcNow);  		// Set values for tracking table  		for (var i = 0; i < map.PrimaryKeys.Length; i++) {  			var val = map.PrimaryKeys [i].GetValue (entity);  			BindParameter (stmtTracking' i + 7' val);  		}  		stmtTracking.Step ();  		stmtTracking.Reset ();  		stmtTracking.ClearBindings ();  	}  }  
Magic Number,Microsoft.Synchronization.ClientServices.SQLite,SQLiteHelper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteHelper.cs,MergeEntities,The following statement contains a magic number: foreach (var entity in entities) {  	// Foreach entity check if it's a delete action or un insert/update action  	if (entity.ServiceMetadata.IsTombstone) {  		// Delete Action  		// Bind parameter  		BindParameter (stmtGetprimaryKey' 1' entity.ServiceMetadata.Id);  		// Store values of primaryKeys  		Object[] pkeys = new object[map.PrimaryKeys.Length];  		// While row is available (only 1 if it's good)  		while (stmtGetprimaryKey.Step () == SQLiteResult.ROW) {  			for (int i = 0; i < pkeys.Length; i++) {  				// Read the column  				pkeys [i] = ReadCol (stmtGetprimaryKey' i' map.PrimaryKeys [i].ColumnType);  			}  		}  		stmtGetprimaryKey.Reset ();  		// Bind parameters  		for (int i = 0; i < pkeys.Length; i++) {  			BindParameter (stmtDeleteItem' i + 1' pkeys [i]);  			BindParameter (stmtDeleteItemTracking' i + 1' pkeys [i]);  		}  		// Execute the deletion of 2 rows  		stmtDeleteItem.Step ();  		stmtDeleteItem.Reset ();  		stmtDeleteItem.ClearBindings ();  		stmtDeleteItemTracking.Step ();  		stmtDeleteItemTracking.Reset ();  		stmtDeleteItemTracking.ClearBindings ();  	}  	else {  		// Get columns for insert  		var cols = map.Columns;  		// Set values for table  		for (var i = 0; i < cols.Length; i++) {  			var val = cols [i].GetValue (entity);  			BindParameter (stmtInsert' i + 1' val);  			BindParameter (stmtUpdate' i + 1' val);  		}  		// add where clause  		for (var i = 0; i < map.PrimaryKeys.Length; i++) {  			var val = map.PrimaryKeys [i].GetValue (entity);  			BindParameter (stmtUpdate' cols.Length + i + 1' val);  		}  		stmtUpdate.Step ();  		stmtUpdate.Reset ();  		stmtUpdate.ClearBindings ();  		stmtInsert.Step ();  		stmtInsert.Reset ();  		stmtInsert.ClearBindings ();  		// Set Values for tracking table  		BindParameter (stmtTracking' 1' entity.ServiceMetadata.IsTombstone);  		BindParameter (stmtTracking' 2' 0);  		BindParameter (stmtTracking' 3' entity.ServiceMetadata.Id);  		BindParameter (stmtTracking' 4' "ETag");  		var editUri = String.Empty;  		if (entity.ServiceMetadata.EditUri != null && entity.ServiceMetadata.EditUri.IsAbsoluteUri)  			editUri = entity.ServiceMetadata.EditUri.AbsoluteUri;  		BindParameter (stmtTracking' 5' editUri);  		BindParameter (stmtTracking' 6' DateTime.UtcNow);  		// Set values for tracking table  		for (var i = 0; i < map.PrimaryKeys.Length; i++) {  			var val = map.PrimaryKeys [i].GetValue (entity);  			BindParameter (stmtTracking' i + 7' val);  		}  		stmtTracking.Step ();  		stmtTracking.Reset ();  		stmtTracking.ClearBindings ();  	}  }  
Magic Number,Microsoft.Synchronization.ClientServices.SQLite,SQLiteHelper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteHelper.cs,MergeEntities,The following statement contains a magic number: foreach (var entity in entities) {  	// Foreach entity check if it's a delete action or un insert/update action  	if (entity.ServiceMetadata.IsTombstone) {  		// Delete Action  		// Bind parameter  		BindParameter (stmtGetprimaryKey' 1' entity.ServiceMetadata.Id);  		// Store values of primaryKeys  		Object[] pkeys = new object[map.PrimaryKeys.Length];  		// While row is available (only 1 if it's good)  		while (stmtGetprimaryKey.Step () == SQLiteResult.ROW) {  			for (int i = 0; i < pkeys.Length; i++) {  				// Read the column  				pkeys [i] = ReadCol (stmtGetprimaryKey' i' map.PrimaryKeys [i].ColumnType);  			}  		}  		stmtGetprimaryKey.Reset ();  		// Bind parameters  		for (int i = 0; i < pkeys.Length; i++) {  			BindParameter (stmtDeleteItem' i + 1' pkeys [i]);  			BindParameter (stmtDeleteItemTracking' i + 1' pkeys [i]);  		}  		// Execute the deletion of 2 rows  		stmtDeleteItem.Step ();  		stmtDeleteItem.Reset ();  		stmtDeleteItem.ClearBindings ();  		stmtDeleteItemTracking.Step ();  		stmtDeleteItemTracking.Reset ();  		stmtDeleteItemTracking.ClearBindings ();  	}  	else {  		// Get columns for insert  		var cols = map.Columns;  		// Set values for table  		for (var i = 0; i < cols.Length; i++) {  			var val = cols [i].GetValue (entity);  			BindParameter (stmtInsert' i + 1' val);  			BindParameter (stmtUpdate' i + 1' val);  		}  		// add where clause  		for (var i = 0; i < map.PrimaryKeys.Length; i++) {  			var val = map.PrimaryKeys [i].GetValue (entity);  			BindParameter (stmtUpdate' cols.Length + i + 1' val);  		}  		stmtUpdate.Step ();  		stmtUpdate.Reset ();  		stmtUpdate.ClearBindings ();  		stmtInsert.Step ();  		stmtInsert.Reset ();  		stmtInsert.ClearBindings ();  		// Set Values for tracking table  		BindParameter (stmtTracking' 1' entity.ServiceMetadata.IsTombstone);  		BindParameter (stmtTracking' 2' 0);  		BindParameter (stmtTracking' 3' entity.ServiceMetadata.Id);  		BindParameter (stmtTracking' 4' "ETag");  		var editUri = String.Empty;  		if (entity.ServiceMetadata.EditUri != null && entity.ServiceMetadata.EditUri.IsAbsoluteUri)  			editUri = entity.ServiceMetadata.EditUri.AbsoluteUri;  		BindParameter (stmtTracking' 5' editUri);  		BindParameter (stmtTracking' 6' DateTime.UtcNow);  		// Set values for tracking table  		for (var i = 0; i < map.PrimaryKeys.Length; i++) {  			var val = map.PrimaryKeys [i].GetValue (entity);  			BindParameter (stmtTracking' i + 7' val);  		}  		stmtTracking.Step ();  		stmtTracking.Reset ();  		stmtTracking.ClearBindings ();  	}  }  
Magic Number,Microsoft.Synchronization.ClientServices.SQLite,SQLiteHelper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteHelper.cs,MergeEntities,The following statement contains a magic number: if (entity.ServiceMetadata.IsTombstone) {  	// Delete Action  	// Bind parameter  	BindParameter (stmtGetprimaryKey' 1' entity.ServiceMetadata.Id);  	// Store values of primaryKeys  	Object[] pkeys = new object[map.PrimaryKeys.Length];  	// While row is available (only 1 if it's good)  	while (stmtGetprimaryKey.Step () == SQLiteResult.ROW) {  		for (int i = 0; i < pkeys.Length; i++) {  			// Read the column  			pkeys [i] = ReadCol (stmtGetprimaryKey' i' map.PrimaryKeys [i].ColumnType);  		}  	}  	stmtGetprimaryKey.Reset ();  	// Bind parameters  	for (int i = 0; i < pkeys.Length; i++) {  		BindParameter (stmtDeleteItem' i + 1' pkeys [i]);  		BindParameter (stmtDeleteItemTracking' i + 1' pkeys [i]);  	}  	// Execute the deletion of 2 rows  	stmtDeleteItem.Step ();  	stmtDeleteItem.Reset ();  	stmtDeleteItem.ClearBindings ();  	stmtDeleteItemTracking.Step ();  	stmtDeleteItemTracking.Reset ();  	stmtDeleteItemTracking.ClearBindings ();  }  else {  	// Get columns for insert  	var cols = map.Columns;  	// Set values for table  	for (var i = 0; i < cols.Length; i++) {  		var val = cols [i].GetValue (entity);  		BindParameter (stmtInsert' i + 1' val);  		BindParameter (stmtUpdate' i + 1' val);  	}  	// add where clause  	for (var i = 0; i < map.PrimaryKeys.Length; i++) {  		var val = map.PrimaryKeys [i].GetValue (entity);  		BindParameter (stmtUpdate' cols.Length + i + 1' val);  	}  	stmtUpdate.Step ();  	stmtUpdate.Reset ();  	stmtUpdate.ClearBindings ();  	stmtInsert.Step ();  	stmtInsert.Reset ();  	stmtInsert.ClearBindings ();  	// Set Values for tracking table  	BindParameter (stmtTracking' 1' entity.ServiceMetadata.IsTombstone);  	BindParameter (stmtTracking' 2' 0);  	BindParameter (stmtTracking' 3' entity.ServiceMetadata.Id);  	BindParameter (stmtTracking' 4' "ETag");  	var editUri = String.Empty;  	if (entity.ServiceMetadata.EditUri != null && entity.ServiceMetadata.EditUri.IsAbsoluteUri)  		editUri = entity.ServiceMetadata.EditUri.AbsoluteUri;  	BindParameter (stmtTracking' 5' editUri);  	BindParameter (stmtTracking' 6' DateTime.UtcNow);  	// Set values for tracking table  	for (var i = 0; i < map.PrimaryKeys.Length; i++) {  		var val = map.PrimaryKeys [i].GetValue (entity);  		BindParameter (stmtTracking' i + 7' val);  	}  	stmtTracking.Step ();  	stmtTracking.Reset ();  	stmtTracking.ClearBindings ();  }  
Magic Number,Microsoft.Synchronization.ClientServices.SQLite,SQLiteHelper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteHelper.cs,MergeEntities,The following statement contains a magic number: if (entity.ServiceMetadata.IsTombstone) {  	// Delete Action  	// Bind parameter  	BindParameter (stmtGetprimaryKey' 1' entity.ServiceMetadata.Id);  	// Store values of primaryKeys  	Object[] pkeys = new object[map.PrimaryKeys.Length];  	// While row is available (only 1 if it's good)  	while (stmtGetprimaryKey.Step () == SQLiteResult.ROW) {  		for (int i = 0; i < pkeys.Length; i++) {  			// Read the column  			pkeys [i] = ReadCol (stmtGetprimaryKey' i' map.PrimaryKeys [i].ColumnType);  		}  	}  	stmtGetprimaryKey.Reset ();  	// Bind parameters  	for (int i = 0; i < pkeys.Length; i++) {  		BindParameter (stmtDeleteItem' i + 1' pkeys [i]);  		BindParameter (stmtDeleteItemTracking' i + 1' pkeys [i]);  	}  	// Execute the deletion of 2 rows  	stmtDeleteItem.Step ();  	stmtDeleteItem.Reset ();  	stmtDeleteItem.ClearBindings ();  	stmtDeleteItemTracking.Step ();  	stmtDeleteItemTracking.Reset ();  	stmtDeleteItemTracking.ClearBindings ();  }  else {  	// Get columns for insert  	var cols = map.Columns;  	// Set values for table  	for (var i = 0; i < cols.Length; i++) {  		var val = cols [i].GetValue (entity);  		BindParameter (stmtInsert' i + 1' val);  		BindParameter (stmtUpdate' i + 1' val);  	}  	// add where clause  	for (var i = 0; i < map.PrimaryKeys.Length; i++) {  		var val = map.PrimaryKeys [i].GetValue (entity);  		BindParameter (stmtUpdate' cols.Length + i + 1' val);  	}  	stmtUpdate.Step ();  	stmtUpdate.Reset ();  	stmtUpdate.ClearBindings ();  	stmtInsert.Step ();  	stmtInsert.Reset ();  	stmtInsert.ClearBindings ();  	// Set Values for tracking table  	BindParameter (stmtTracking' 1' entity.ServiceMetadata.IsTombstone);  	BindParameter (stmtTracking' 2' 0);  	BindParameter (stmtTracking' 3' entity.ServiceMetadata.Id);  	BindParameter (stmtTracking' 4' "ETag");  	var editUri = String.Empty;  	if (entity.ServiceMetadata.EditUri != null && entity.ServiceMetadata.EditUri.IsAbsoluteUri)  		editUri = entity.ServiceMetadata.EditUri.AbsoluteUri;  	BindParameter (stmtTracking' 5' editUri);  	BindParameter (stmtTracking' 6' DateTime.UtcNow);  	// Set values for tracking table  	for (var i = 0; i < map.PrimaryKeys.Length; i++) {  		var val = map.PrimaryKeys [i].GetValue (entity);  		BindParameter (stmtTracking' i + 7' val);  	}  	stmtTracking.Step ();  	stmtTracking.Reset ();  	stmtTracking.ClearBindings ();  }  
Magic Number,Microsoft.Synchronization.ClientServices.SQLite,SQLiteHelper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteHelper.cs,MergeEntities,The following statement contains a magic number: if (entity.ServiceMetadata.IsTombstone) {  	// Delete Action  	// Bind parameter  	BindParameter (stmtGetprimaryKey' 1' entity.ServiceMetadata.Id);  	// Store values of primaryKeys  	Object[] pkeys = new object[map.PrimaryKeys.Length];  	// While row is available (only 1 if it's good)  	while (stmtGetprimaryKey.Step () == SQLiteResult.ROW) {  		for (int i = 0; i < pkeys.Length; i++) {  			// Read the column  			pkeys [i] = ReadCol (stmtGetprimaryKey' i' map.PrimaryKeys [i].ColumnType);  		}  	}  	stmtGetprimaryKey.Reset ();  	// Bind parameters  	for (int i = 0; i < pkeys.Length; i++) {  		BindParameter (stmtDeleteItem' i + 1' pkeys [i]);  		BindParameter (stmtDeleteItemTracking' i + 1' pkeys [i]);  	}  	// Execute the deletion of 2 rows  	stmtDeleteItem.Step ();  	stmtDeleteItem.Reset ();  	stmtDeleteItem.ClearBindings ();  	stmtDeleteItemTracking.Step ();  	stmtDeleteItemTracking.Reset ();  	stmtDeleteItemTracking.ClearBindings ();  }  else {  	// Get columns for insert  	var cols = map.Columns;  	// Set values for table  	for (var i = 0; i < cols.Length; i++) {  		var val = cols [i].GetValue (entity);  		BindParameter (stmtInsert' i + 1' val);  		BindParameter (stmtUpdate' i + 1' val);  	}  	// add where clause  	for (var i = 0; i < map.PrimaryKeys.Length; i++) {  		var val = map.PrimaryKeys [i].GetValue (entity);  		BindParameter (stmtUpdate' cols.Length + i + 1' val);  	}  	stmtUpdate.Step ();  	stmtUpdate.Reset ();  	stmtUpdate.ClearBindings ();  	stmtInsert.Step ();  	stmtInsert.Reset ();  	stmtInsert.ClearBindings ();  	// Set Values for tracking table  	BindParameter (stmtTracking' 1' entity.ServiceMetadata.IsTombstone);  	BindParameter (stmtTracking' 2' 0);  	BindParameter (stmtTracking' 3' entity.ServiceMetadata.Id);  	BindParameter (stmtTracking' 4' "ETag");  	var editUri = String.Empty;  	if (entity.ServiceMetadata.EditUri != null && entity.ServiceMetadata.EditUri.IsAbsoluteUri)  		editUri = entity.ServiceMetadata.EditUri.AbsoluteUri;  	BindParameter (stmtTracking' 5' editUri);  	BindParameter (stmtTracking' 6' DateTime.UtcNow);  	// Set values for tracking table  	for (var i = 0; i < map.PrimaryKeys.Length; i++) {  		var val = map.PrimaryKeys [i].GetValue (entity);  		BindParameter (stmtTracking' i + 7' val);  	}  	stmtTracking.Step ();  	stmtTracking.Reset ();  	stmtTracking.ClearBindings ();  }  
Magic Number,Microsoft.Synchronization.ClientServices.SQLite,SQLiteHelper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteHelper.cs,MergeEntities,The following statement contains a magic number: if (entity.ServiceMetadata.IsTombstone) {  	// Delete Action  	// Bind parameter  	BindParameter (stmtGetprimaryKey' 1' entity.ServiceMetadata.Id);  	// Store values of primaryKeys  	Object[] pkeys = new object[map.PrimaryKeys.Length];  	// While row is available (only 1 if it's good)  	while (stmtGetprimaryKey.Step () == SQLiteResult.ROW) {  		for (int i = 0; i < pkeys.Length; i++) {  			// Read the column  			pkeys [i] = ReadCol (stmtGetprimaryKey' i' map.PrimaryKeys [i].ColumnType);  		}  	}  	stmtGetprimaryKey.Reset ();  	// Bind parameters  	for (int i = 0; i < pkeys.Length; i++) {  		BindParameter (stmtDeleteItem' i + 1' pkeys [i]);  		BindParameter (stmtDeleteItemTracking' i + 1' pkeys [i]);  	}  	// Execute the deletion of 2 rows  	stmtDeleteItem.Step ();  	stmtDeleteItem.Reset ();  	stmtDeleteItem.ClearBindings ();  	stmtDeleteItemTracking.Step ();  	stmtDeleteItemTracking.Reset ();  	stmtDeleteItemTracking.ClearBindings ();  }  else {  	// Get columns for insert  	var cols = map.Columns;  	// Set values for table  	for (var i = 0; i < cols.Length; i++) {  		var val = cols [i].GetValue (entity);  		BindParameter (stmtInsert' i + 1' val);  		BindParameter (stmtUpdate' i + 1' val);  	}  	// add where clause  	for (var i = 0; i < map.PrimaryKeys.Length; i++) {  		var val = map.PrimaryKeys [i].GetValue (entity);  		BindParameter (stmtUpdate' cols.Length + i + 1' val);  	}  	stmtUpdate.Step ();  	stmtUpdate.Reset ();  	stmtUpdate.ClearBindings ();  	stmtInsert.Step ();  	stmtInsert.Reset ();  	stmtInsert.ClearBindings ();  	// Set Values for tracking table  	BindParameter (stmtTracking' 1' entity.ServiceMetadata.IsTombstone);  	BindParameter (stmtTracking' 2' 0);  	BindParameter (stmtTracking' 3' entity.ServiceMetadata.Id);  	BindParameter (stmtTracking' 4' "ETag");  	var editUri = String.Empty;  	if (entity.ServiceMetadata.EditUri != null && entity.ServiceMetadata.EditUri.IsAbsoluteUri)  		editUri = entity.ServiceMetadata.EditUri.AbsoluteUri;  	BindParameter (stmtTracking' 5' editUri);  	BindParameter (stmtTracking' 6' DateTime.UtcNow);  	// Set values for tracking table  	for (var i = 0; i < map.PrimaryKeys.Length; i++) {  		var val = map.PrimaryKeys [i].GetValue (entity);  		BindParameter (stmtTracking' i + 7' val);  	}  	stmtTracking.Step ();  	stmtTracking.Reset ();  	stmtTracking.ClearBindings ();  }  
Magic Number,Microsoft.Synchronization.ClientServices.SQLite,SQLiteHelper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteHelper.cs,MergeEntities,The following statement contains a magic number: if (entity.ServiceMetadata.IsTombstone) {  	// Delete Action  	// Bind parameter  	BindParameter (stmtGetprimaryKey' 1' entity.ServiceMetadata.Id);  	// Store values of primaryKeys  	Object[] pkeys = new object[map.PrimaryKeys.Length];  	// While row is available (only 1 if it's good)  	while (stmtGetprimaryKey.Step () == SQLiteResult.ROW) {  		for (int i = 0; i < pkeys.Length; i++) {  			// Read the column  			pkeys [i] = ReadCol (stmtGetprimaryKey' i' map.PrimaryKeys [i].ColumnType);  		}  	}  	stmtGetprimaryKey.Reset ();  	// Bind parameters  	for (int i = 0; i < pkeys.Length; i++) {  		BindParameter (stmtDeleteItem' i + 1' pkeys [i]);  		BindParameter (stmtDeleteItemTracking' i + 1' pkeys [i]);  	}  	// Execute the deletion of 2 rows  	stmtDeleteItem.Step ();  	stmtDeleteItem.Reset ();  	stmtDeleteItem.ClearBindings ();  	stmtDeleteItemTracking.Step ();  	stmtDeleteItemTracking.Reset ();  	stmtDeleteItemTracking.ClearBindings ();  }  else {  	// Get columns for insert  	var cols = map.Columns;  	// Set values for table  	for (var i = 0; i < cols.Length; i++) {  		var val = cols [i].GetValue (entity);  		BindParameter (stmtInsert' i + 1' val);  		BindParameter (stmtUpdate' i + 1' val);  	}  	// add where clause  	for (var i = 0; i < map.PrimaryKeys.Length; i++) {  		var val = map.PrimaryKeys [i].GetValue (entity);  		BindParameter (stmtUpdate' cols.Length + i + 1' val);  	}  	stmtUpdate.Step ();  	stmtUpdate.Reset ();  	stmtUpdate.ClearBindings ();  	stmtInsert.Step ();  	stmtInsert.Reset ();  	stmtInsert.ClearBindings ();  	// Set Values for tracking table  	BindParameter (stmtTracking' 1' entity.ServiceMetadata.IsTombstone);  	BindParameter (stmtTracking' 2' 0);  	BindParameter (stmtTracking' 3' entity.ServiceMetadata.Id);  	BindParameter (stmtTracking' 4' "ETag");  	var editUri = String.Empty;  	if (entity.ServiceMetadata.EditUri != null && entity.ServiceMetadata.EditUri.IsAbsoluteUri)  		editUri = entity.ServiceMetadata.EditUri.AbsoluteUri;  	BindParameter (stmtTracking' 5' editUri);  	BindParameter (stmtTracking' 6' DateTime.UtcNow);  	// Set values for tracking table  	for (var i = 0; i < map.PrimaryKeys.Length; i++) {  		var val = map.PrimaryKeys [i].GetValue (entity);  		BindParameter (stmtTracking' i + 7' val);  	}  	stmtTracking.Step ();  	stmtTracking.Reset ();  	stmtTracking.ClearBindings ();  }  
Magic Number,Microsoft.Synchronization.ClientServices.SQLite,SQLiteHelper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteHelper.cs,MergeEntities,The following statement contains a magic number: if (entity.ServiceMetadata.IsTombstone) {  	// Delete Action  	// Bind parameter  	BindParameter (stmtGetprimaryKey' 1' entity.ServiceMetadata.Id);  	// Store values of primaryKeys  	Object[] pkeys = new object[map.PrimaryKeys.Length];  	// While row is available (only 1 if it's good)  	while (stmtGetprimaryKey.Step () == SQLiteResult.ROW) {  		for (int i = 0; i < pkeys.Length; i++) {  			// Read the column  			pkeys [i] = ReadCol (stmtGetprimaryKey' i' map.PrimaryKeys [i].ColumnType);  		}  	}  	stmtGetprimaryKey.Reset ();  	// Bind parameters  	for (int i = 0; i < pkeys.Length; i++) {  		BindParameter (stmtDeleteItem' i + 1' pkeys [i]);  		BindParameter (stmtDeleteItemTracking' i + 1' pkeys [i]);  	}  	// Execute the deletion of 2 rows  	stmtDeleteItem.Step ();  	stmtDeleteItem.Reset ();  	stmtDeleteItem.ClearBindings ();  	stmtDeleteItemTracking.Step ();  	stmtDeleteItemTracking.Reset ();  	stmtDeleteItemTracking.ClearBindings ();  }  else {  	// Get columns for insert  	var cols = map.Columns;  	// Set values for table  	for (var i = 0; i < cols.Length; i++) {  		var val = cols [i].GetValue (entity);  		BindParameter (stmtInsert' i + 1' val);  		BindParameter (stmtUpdate' i + 1' val);  	}  	// add where clause  	for (var i = 0; i < map.PrimaryKeys.Length; i++) {  		var val = map.PrimaryKeys [i].GetValue (entity);  		BindParameter (stmtUpdate' cols.Length + i + 1' val);  	}  	stmtUpdate.Step ();  	stmtUpdate.Reset ();  	stmtUpdate.ClearBindings ();  	stmtInsert.Step ();  	stmtInsert.Reset ();  	stmtInsert.ClearBindings ();  	// Set Values for tracking table  	BindParameter (stmtTracking' 1' entity.ServiceMetadata.IsTombstone);  	BindParameter (stmtTracking' 2' 0);  	BindParameter (stmtTracking' 3' entity.ServiceMetadata.Id);  	BindParameter (stmtTracking' 4' "ETag");  	var editUri = String.Empty;  	if (entity.ServiceMetadata.EditUri != null && entity.ServiceMetadata.EditUri.IsAbsoluteUri)  		editUri = entity.ServiceMetadata.EditUri.AbsoluteUri;  	BindParameter (stmtTracking' 5' editUri);  	BindParameter (stmtTracking' 6' DateTime.UtcNow);  	// Set values for tracking table  	for (var i = 0; i < map.PrimaryKeys.Length; i++) {  		var val = map.PrimaryKeys [i].GetValue (entity);  		BindParameter (stmtTracking' i + 7' val);  	}  	stmtTracking.Step ();  	stmtTracking.Reset ();  	stmtTracking.ClearBindings ();  }  
Magic Number,Microsoft.Synchronization.ClientServices.SQLite,SQLiteHelper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteHelper.cs,MergeEntities,The following statement contains a magic number: BindParameter (stmtTracking' 2' 0);  
Magic Number,Microsoft.Synchronization.ClientServices.SQLite,SQLiteHelper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteHelper.cs,MergeEntities,The following statement contains a magic number: BindParameter (stmtTracking' 3' entity.ServiceMetadata.Id);  
Magic Number,Microsoft.Synchronization.ClientServices.SQLite,SQLiteHelper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteHelper.cs,MergeEntities,The following statement contains a magic number: BindParameter (stmtTracking' 4' "ETag");  
Magic Number,Microsoft.Synchronization.ClientServices.SQLite,SQLiteHelper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteHelper.cs,MergeEntities,The following statement contains a magic number: BindParameter (stmtTracking' 5' editUri);  
Magic Number,Microsoft.Synchronization.ClientServices.SQLite,SQLiteHelper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteHelper.cs,MergeEntities,The following statement contains a magic number: BindParameter (stmtTracking' 6' DateTime.UtcNow);  
Magic Number,Microsoft.Synchronization.ClientServices.SQLite,SQLiteHelper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteHelper.cs,MergeEntities,The following statement contains a magic number: for (var i = 0; i < map.PrimaryKeys.Length; i++) {  	var val = map.PrimaryKeys [i].GetValue (entity);  	BindParameter (stmtTracking' i + 7' val);  }  
Magic Number,Microsoft.Synchronization.ClientServices.SQLite,SQLiteHelper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteHelper.cs,MergeEntities,The following statement contains a magic number: BindParameter (stmtTracking' i + 7' val);  
Magic Number,Microsoft.Synchronization.ClientServices.SQLite,SQLiteHelper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteHelper.cs,GetChanges,The following statement contains a magic number: using (SQLiteConnection connection = new SQLiteConnection (localFilePath)) {  	try {  		foreach (var ty in schema.Collections) {  			// Get mapping from my type  			var map = manager.GetMapping (ty);  			// Create query to select changes   			var querySelect = SQLiteConstants.SelectChanges;  			var columnsDcl = new List<String> ();  			var columnsPK = new List<String> ();  			// Foreach columns' create the tsql command to execute  			foreach (var c in map.Columns) {  				if (!c.IsPK)  					columnsDcl.Add ("[s].[" + c.Name + "]");  				// If it's the PK' add it from Tracking (because of deleted items not in real table  				if (c.IsPK) {  					columnsDcl.Add ("[t].[" + c.Name + "]");  					columnsPK.Add ("[s].[" + c.Name + "] = [t].[" + c.Name + "]");  				}  			}  			var decl = string.Join ("'\n"' columnsDcl.ToArray ());  			var pk = string.Join (" \nAND "' columnsPK.ToArray ());  			querySelect = String.Format (querySelect' map.TableName' pk' decl);  			// Prepare command  			using (var stmt = connection.Prepare (querySelect)) {  				try {  					// Set Values  					BindParameter (stmt' 1' lastModifiedDate);  					// Get mapping form the statement  					var cols = new TableMapping.Column[map.Columns.Length];  					// Foreach column' get the property in my object  					for (int i = 0; i < cols.Length; i++) {  						var name = stmt.ColumnName (i);  						var c = map.FindColumn (name);  						if (c != null)  							cols [i] = map.FindColumn (name);  					}  					// While row is available  					//while (await stmt.StepAsync().AsTask().ConfigureAwait(false))  					while (stmt.Step () == SQLiteResult.ROW) {  						// Create the object  						SQLiteOfflineEntity obj = (SQLiteOfflineEntity)Activator.CreateInstance (map.MappedType);  						for (int i = 0; i < cols.Length; i++) {  							if (cols [i] == null)  								continue;  							// Read the column  							var val = ReadCol (stmt' i' cols [i].ColumnType);  							// Set the value  							cols [i].SetValue (obj' val);  						}  						// Read the Oem Properties  						var newIndex = map.Columns.Count ();  						obj.ServiceMetadata = new OfflineEntityMetadata ();  						obj.ServiceMetadata.IsTombstone = (Boolean)ReadCol (stmt' newIndex' typeof(Boolean));  						obj.ServiceMetadata.Id = (String)ReadCol (stmt' newIndex + 1' typeof(String));  						obj.ServiceMetadata.ETag = (String)ReadCol (stmt' newIndex + 2' typeof(String));  						String absoluteUri = (String)ReadCol (stmt' newIndex + 3' typeof(String));  						obj.ServiceMetadata.EditUri = String.IsNullOrEmpty (absoluteUri) ? null : new Uri (absoluteUri);  						lstChanges.Add (obj);  					}  				}  				catch (Exception ex) {  					Debug.WriteLine (ex.Message);  					throw;  				}  				finally {  					stmt.Reset ();  					stmt.ClearBindings ();  				}  			}  		}  	}  	catch (Exception ex) {  		Debug.WriteLine (ex.Message);  		throw;  	}  }  
Magic Number,Microsoft.Synchronization.ClientServices.SQLite,SQLiteHelper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteHelper.cs,GetChanges,The following statement contains a magic number: using (SQLiteConnection connection = new SQLiteConnection (localFilePath)) {  	try {  		foreach (var ty in schema.Collections) {  			// Get mapping from my type  			var map = manager.GetMapping (ty);  			// Create query to select changes   			var querySelect = SQLiteConstants.SelectChanges;  			var columnsDcl = new List<String> ();  			var columnsPK = new List<String> ();  			// Foreach columns' create the tsql command to execute  			foreach (var c in map.Columns) {  				if (!c.IsPK)  					columnsDcl.Add ("[s].[" + c.Name + "]");  				// If it's the PK' add it from Tracking (because of deleted items not in real table  				if (c.IsPK) {  					columnsDcl.Add ("[t].[" + c.Name + "]");  					columnsPK.Add ("[s].[" + c.Name + "] = [t].[" + c.Name + "]");  				}  			}  			var decl = string.Join ("'\n"' columnsDcl.ToArray ());  			var pk = string.Join (" \nAND "' columnsPK.ToArray ());  			querySelect = String.Format (querySelect' map.TableName' pk' decl);  			// Prepare command  			using (var stmt = connection.Prepare (querySelect)) {  				try {  					// Set Values  					BindParameter (stmt' 1' lastModifiedDate);  					// Get mapping form the statement  					var cols = new TableMapping.Column[map.Columns.Length];  					// Foreach column' get the property in my object  					for (int i = 0; i < cols.Length; i++) {  						var name = stmt.ColumnName (i);  						var c = map.FindColumn (name);  						if (c != null)  							cols [i] = map.FindColumn (name);  					}  					// While row is available  					//while (await stmt.StepAsync().AsTask().ConfigureAwait(false))  					while (stmt.Step () == SQLiteResult.ROW) {  						// Create the object  						SQLiteOfflineEntity obj = (SQLiteOfflineEntity)Activator.CreateInstance (map.MappedType);  						for (int i = 0; i < cols.Length; i++) {  							if (cols [i] == null)  								continue;  							// Read the column  							var val = ReadCol (stmt' i' cols [i].ColumnType);  							// Set the value  							cols [i].SetValue (obj' val);  						}  						// Read the Oem Properties  						var newIndex = map.Columns.Count ();  						obj.ServiceMetadata = new OfflineEntityMetadata ();  						obj.ServiceMetadata.IsTombstone = (Boolean)ReadCol (stmt' newIndex' typeof(Boolean));  						obj.ServiceMetadata.Id = (String)ReadCol (stmt' newIndex + 1' typeof(String));  						obj.ServiceMetadata.ETag = (String)ReadCol (stmt' newIndex + 2' typeof(String));  						String absoluteUri = (String)ReadCol (stmt' newIndex + 3' typeof(String));  						obj.ServiceMetadata.EditUri = String.IsNullOrEmpty (absoluteUri) ? null : new Uri (absoluteUri);  						lstChanges.Add (obj);  					}  				}  				catch (Exception ex) {  					Debug.WriteLine (ex.Message);  					throw;  				}  				finally {  					stmt.Reset ();  					stmt.ClearBindings ();  				}  			}  		}  	}  	catch (Exception ex) {  		Debug.WriteLine (ex.Message);  		throw;  	}  }  
Magic Number,Microsoft.Synchronization.ClientServices.SQLite,SQLiteHelper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteHelper.cs,GetChanges,The following statement contains a magic number: try {  	foreach (var ty in schema.Collections) {  		// Get mapping from my type  		var map = manager.GetMapping (ty);  		// Create query to select changes   		var querySelect = SQLiteConstants.SelectChanges;  		var columnsDcl = new List<String> ();  		var columnsPK = new List<String> ();  		// Foreach columns' create the tsql command to execute  		foreach (var c in map.Columns) {  			if (!c.IsPK)  				columnsDcl.Add ("[s].[" + c.Name + "]");  			// If it's the PK' add it from Tracking (because of deleted items not in real table  			if (c.IsPK) {  				columnsDcl.Add ("[t].[" + c.Name + "]");  				columnsPK.Add ("[s].[" + c.Name + "] = [t].[" + c.Name + "]");  			}  		}  		var decl = string.Join ("'\n"' columnsDcl.ToArray ());  		var pk = string.Join (" \nAND "' columnsPK.ToArray ());  		querySelect = String.Format (querySelect' map.TableName' pk' decl);  		// Prepare command  		using (var stmt = connection.Prepare (querySelect)) {  			try {  				// Set Values  				BindParameter (stmt' 1' lastModifiedDate);  				// Get mapping form the statement  				var cols = new TableMapping.Column[map.Columns.Length];  				// Foreach column' get the property in my object  				for (int i = 0; i < cols.Length; i++) {  					var name = stmt.ColumnName (i);  					var c = map.FindColumn (name);  					if (c != null)  						cols [i] = map.FindColumn (name);  				}  				// While row is available  				//while (await stmt.StepAsync().AsTask().ConfigureAwait(false))  				while (stmt.Step () == SQLiteResult.ROW) {  					// Create the object  					SQLiteOfflineEntity obj = (SQLiteOfflineEntity)Activator.CreateInstance (map.MappedType);  					for (int i = 0; i < cols.Length; i++) {  						if (cols [i] == null)  							continue;  						// Read the column  						var val = ReadCol (stmt' i' cols [i].ColumnType);  						// Set the value  						cols [i].SetValue (obj' val);  					}  					// Read the Oem Properties  					var newIndex = map.Columns.Count ();  					obj.ServiceMetadata = new OfflineEntityMetadata ();  					obj.ServiceMetadata.IsTombstone = (Boolean)ReadCol (stmt' newIndex' typeof(Boolean));  					obj.ServiceMetadata.Id = (String)ReadCol (stmt' newIndex + 1' typeof(String));  					obj.ServiceMetadata.ETag = (String)ReadCol (stmt' newIndex + 2' typeof(String));  					String absoluteUri = (String)ReadCol (stmt' newIndex + 3' typeof(String));  					obj.ServiceMetadata.EditUri = String.IsNullOrEmpty (absoluteUri) ? null : new Uri (absoluteUri);  					lstChanges.Add (obj);  				}  			}  			catch (Exception ex) {  				Debug.WriteLine (ex.Message);  				throw;  			}  			finally {  				stmt.Reset ();  				stmt.ClearBindings ();  			}  		}  	}  }  catch (Exception ex) {  	Debug.WriteLine (ex.Message);  	throw;  }  
Magic Number,Microsoft.Synchronization.ClientServices.SQLite,SQLiteHelper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteHelper.cs,GetChanges,The following statement contains a magic number: try {  	foreach (var ty in schema.Collections) {  		// Get mapping from my type  		var map = manager.GetMapping (ty);  		// Create query to select changes   		var querySelect = SQLiteConstants.SelectChanges;  		var columnsDcl = new List<String> ();  		var columnsPK = new List<String> ();  		// Foreach columns' create the tsql command to execute  		foreach (var c in map.Columns) {  			if (!c.IsPK)  				columnsDcl.Add ("[s].[" + c.Name + "]");  			// If it's the PK' add it from Tracking (because of deleted items not in real table  			if (c.IsPK) {  				columnsDcl.Add ("[t].[" + c.Name + "]");  				columnsPK.Add ("[s].[" + c.Name + "] = [t].[" + c.Name + "]");  			}  		}  		var decl = string.Join ("'\n"' columnsDcl.ToArray ());  		var pk = string.Join (" \nAND "' columnsPK.ToArray ());  		querySelect = String.Format (querySelect' map.TableName' pk' decl);  		// Prepare command  		using (var stmt = connection.Prepare (querySelect)) {  			try {  				// Set Values  				BindParameter (stmt' 1' lastModifiedDate);  				// Get mapping form the statement  				var cols = new TableMapping.Column[map.Columns.Length];  				// Foreach column' get the property in my object  				for (int i = 0; i < cols.Length; i++) {  					var name = stmt.ColumnName (i);  					var c = map.FindColumn (name);  					if (c != null)  						cols [i] = map.FindColumn (name);  				}  				// While row is available  				//while (await stmt.StepAsync().AsTask().ConfigureAwait(false))  				while (stmt.Step () == SQLiteResult.ROW) {  					// Create the object  					SQLiteOfflineEntity obj = (SQLiteOfflineEntity)Activator.CreateInstance (map.MappedType);  					for (int i = 0; i < cols.Length; i++) {  						if (cols [i] == null)  							continue;  						// Read the column  						var val = ReadCol (stmt' i' cols [i].ColumnType);  						// Set the value  						cols [i].SetValue (obj' val);  					}  					// Read the Oem Properties  					var newIndex = map.Columns.Count ();  					obj.ServiceMetadata = new OfflineEntityMetadata ();  					obj.ServiceMetadata.IsTombstone = (Boolean)ReadCol (stmt' newIndex' typeof(Boolean));  					obj.ServiceMetadata.Id = (String)ReadCol (stmt' newIndex + 1' typeof(String));  					obj.ServiceMetadata.ETag = (String)ReadCol (stmt' newIndex + 2' typeof(String));  					String absoluteUri = (String)ReadCol (stmt' newIndex + 3' typeof(String));  					obj.ServiceMetadata.EditUri = String.IsNullOrEmpty (absoluteUri) ? null : new Uri (absoluteUri);  					lstChanges.Add (obj);  				}  			}  			catch (Exception ex) {  				Debug.WriteLine (ex.Message);  				throw;  			}  			finally {  				stmt.Reset ();  				stmt.ClearBindings ();  			}  		}  	}  }  catch (Exception ex) {  	Debug.WriteLine (ex.Message);  	throw;  }  
Magic Number,Microsoft.Synchronization.ClientServices.SQLite,SQLiteHelper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteHelper.cs,GetChanges,The following statement contains a magic number: foreach (var ty in schema.Collections) {  	// Get mapping from my type  	var map = manager.GetMapping (ty);  	// Create query to select changes   	var querySelect = SQLiteConstants.SelectChanges;  	var columnsDcl = new List<String> ();  	var columnsPK = new List<String> ();  	// Foreach columns' create the tsql command to execute  	foreach (var c in map.Columns) {  		if (!c.IsPK)  			columnsDcl.Add ("[s].[" + c.Name + "]");  		// If it's the PK' add it from Tracking (because of deleted items not in real table  		if (c.IsPK) {  			columnsDcl.Add ("[t].[" + c.Name + "]");  			columnsPK.Add ("[s].[" + c.Name + "] = [t].[" + c.Name + "]");  		}  	}  	var decl = string.Join ("'\n"' columnsDcl.ToArray ());  	var pk = string.Join (" \nAND "' columnsPK.ToArray ());  	querySelect = String.Format (querySelect' map.TableName' pk' decl);  	// Prepare command  	using (var stmt = connection.Prepare (querySelect)) {  		try {  			// Set Values  			BindParameter (stmt' 1' lastModifiedDate);  			// Get mapping form the statement  			var cols = new TableMapping.Column[map.Columns.Length];  			// Foreach column' get the property in my object  			for (int i = 0; i < cols.Length; i++) {  				var name = stmt.ColumnName (i);  				var c = map.FindColumn (name);  				if (c != null)  					cols [i] = map.FindColumn (name);  			}  			// While row is available  			//while (await stmt.StepAsync().AsTask().ConfigureAwait(false))  			while (stmt.Step () == SQLiteResult.ROW) {  				// Create the object  				SQLiteOfflineEntity obj = (SQLiteOfflineEntity)Activator.CreateInstance (map.MappedType);  				for (int i = 0; i < cols.Length; i++) {  					if (cols [i] == null)  						continue;  					// Read the column  					var val = ReadCol (stmt' i' cols [i].ColumnType);  					// Set the value  					cols [i].SetValue (obj' val);  				}  				// Read the Oem Properties  				var newIndex = map.Columns.Count ();  				obj.ServiceMetadata = new OfflineEntityMetadata ();  				obj.ServiceMetadata.IsTombstone = (Boolean)ReadCol (stmt' newIndex' typeof(Boolean));  				obj.ServiceMetadata.Id = (String)ReadCol (stmt' newIndex + 1' typeof(String));  				obj.ServiceMetadata.ETag = (String)ReadCol (stmt' newIndex + 2' typeof(String));  				String absoluteUri = (String)ReadCol (stmt' newIndex + 3' typeof(String));  				obj.ServiceMetadata.EditUri = String.IsNullOrEmpty (absoluteUri) ? null : new Uri (absoluteUri);  				lstChanges.Add (obj);  			}  		}  		catch (Exception ex) {  			Debug.WriteLine (ex.Message);  			throw;  		}  		finally {  			stmt.Reset ();  			stmt.ClearBindings ();  		}  	}  }  
Magic Number,Microsoft.Synchronization.ClientServices.SQLite,SQLiteHelper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteHelper.cs,GetChanges,The following statement contains a magic number: foreach (var ty in schema.Collections) {  	// Get mapping from my type  	var map = manager.GetMapping (ty);  	// Create query to select changes   	var querySelect = SQLiteConstants.SelectChanges;  	var columnsDcl = new List<String> ();  	var columnsPK = new List<String> ();  	// Foreach columns' create the tsql command to execute  	foreach (var c in map.Columns) {  		if (!c.IsPK)  			columnsDcl.Add ("[s].[" + c.Name + "]");  		// If it's the PK' add it from Tracking (because of deleted items not in real table  		if (c.IsPK) {  			columnsDcl.Add ("[t].[" + c.Name + "]");  			columnsPK.Add ("[s].[" + c.Name + "] = [t].[" + c.Name + "]");  		}  	}  	var decl = string.Join ("'\n"' columnsDcl.ToArray ());  	var pk = string.Join (" \nAND "' columnsPK.ToArray ());  	querySelect = String.Format (querySelect' map.TableName' pk' decl);  	// Prepare command  	using (var stmt = connection.Prepare (querySelect)) {  		try {  			// Set Values  			BindParameter (stmt' 1' lastModifiedDate);  			// Get mapping form the statement  			var cols = new TableMapping.Column[map.Columns.Length];  			// Foreach column' get the property in my object  			for (int i = 0; i < cols.Length; i++) {  				var name = stmt.ColumnName (i);  				var c = map.FindColumn (name);  				if (c != null)  					cols [i] = map.FindColumn (name);  			}  			// While row is available  			//while (await stmt.StepAsync().AsTask().ConfigureAwait(false))  			while (stmt.Step () == SQLiteResult.ROW) {  				// Create the object  				SQLiteOfflineEntity obj = (SQLiteOfflineEntity)Activator.CreateInstance (map.MappedType);  				for (int i = 0; i < cols.Length; i++) {  					if (cols [i] == null)  						continue;  					// Read the column  					var val = ReadCol (stmt' i' cols [i].ColumnType);  					// Set the value  					cols [i].SetValue (obj' val);  				}  				// Read the Oem Properties  				var newIndex = map.Columns.Count ();  				obj.ServiceMetadata = new OfflineEntityMetadata ();  				obj.ServiceMetadata.IsTombstone = (Boolean)ReadCol (stmt' newIndex' typeof(Boolean));  				obj.ServiceMetadata.Id = (String)ReadCol (stmt' newIndex + 1' typeof(String));  				obj.ServiceMetadata.ETag = (String)ReadCol (stmt' newIndex + 2' typeof(String));  				String absoluteUri = (String)ReadCol (stmt' newIndex + 3' typeof(String));  				obj.ServiceMetadata.EditUri = String.IsNullOrEmpty (absoluteUri) ? null : new Uri (absoluteUri);  				lstChanges.Add (obj);  			}  		}  		catch (Exception ex) {  			Debug.WriteLine (ex.Message);  			throw;  		}  		finally {  			stmt.Reset ();  			stmt.ClearBindings ();  		}  	}  }  
Magic Number,Microsoft.Synchronization.ClientServices.SQLite,SQLiteHelper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteHelper.cs,GetChanges,The following statement contains a magic number: using (var stmt = connection.Prepare (querySelect)) {  	try {  		// Set Values  		BindParameter (stmt' 1' lastModifiedDate);  		// Get mapping form the statement  		var cols = new TableMapping.Column[map.Columns.Length];  		// Foreach column' get the property in my object  		for (int i = 0; i < cols.Length; i++) {  			var name = stmt.ColumnName (i);  			var c = map.FindColumn (name);  			if (c != null)  				cols [i] = map.FindColumn (name);  		}  		// While row is available  		//while (await stmt.StepAsync().AsTask().ConfigureAwait(false))  		while (stmt.Step () == SQLiteResult.ROW) {  			// Create the object  			SQLiteOfflineEntity obj = (SQLiteOfflineEntity)Activator.CreateInstance (map.MappedType);  			for (int i = 0; i < cols.Length; i++) {  				if (cols [i] == null)  					continue;  				// Read the column  				var val = ReadCol (stmt' i' cols [i].ColumnType);  				// Set the value  				cols [i].SetValue (obj' val);  			}  			// Read the Oem Properties  			var newIndex = map.Columns.Count ();  			obj.ServiceMetadata = new OfflineEntityMetadata ();  			obj.ServiceMetadata.IsTombstone = (Boolean)ReadCol (stmt' newIndex' typeof(Boolean));  			obj.ServiceMetadata.Id = (String)ReadCol (stmt' newIndex + 1' typeof(String));  			obj.ServiceMetadata.ETag = (String)ReadCol (stmt' newIndex + 2' typeof(String));  			String absoluteUri = (String)ReadCol (stmt' newIndex + 3' typeof(String));  			obj.ServiceMetadata.EditUri = String.IsNullOrEmpty (absoluteUri) ? null : new Uri (absoluteUri);  			lstChanges.Add (obj);  		}  	}  	catch (Exception ex) {  		Debug.WriteLine (ex.Message);  		throw;  	}  	finally {  		stmt.Reset ();  		stmt.ClearBindings ();  	}  }  
Magic Number,Microsoft.Synchronization.ClientServices.SQLite,SQLiteHelper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteHelper.cs,GetChanges,The following statement contains a magic number: using (var stmt = connection.Prepare (querySelect)) {  	try {  		// Set Values  		BindParameter (stmt' 1' lastModifiedDate);  		// Get mapping form the statement  		var cols = new TableMapping.Column[map.Columns.Length];  		// Foreach column' get the property in my object  		for (int i = 0; i < cols.Length; i++) {  			var name = stmt.ColumnName (i);  			var c = map.FindColumn (name);  			if (c != null)  				cols [i] = map.FindColumn (name);  		}  		// While row is available  		//while (await stmt.StepAsync().AsTask().ConfigureAwait(false))  		while (stmt.Step () == SQLiteResult.ROW) {  			// Create the object  			SQLiteOfflineEntity obj = (SQLiteOfflineEntity)Activator.CreateInstance (map.MappedType);  			for (int i = 0; i < cols.Length; i++) {  				if (cols [i] == null)  					continue;  				// Read the column  				var val = ReadCol (stmt' i' cols [i].ColumnType);  				// Set the value  				cols [i].SetValue (obj' val);  			}  			// Read the Oem Properties  			var newIndex = map.Columns.Count ();  			obj.ServiceMetadata = new OfflineEntityMetadata ();  			obj.ServiceMetadata.IsTombstone = (Boolean)ReadCol (stmt' newIndex' typeof(Boolean));  			obj.ServiceMetadata.Id = (String)ReadCol (stmt' newIndex + 1' typeof(String));  			obj.ServiceMetadata.ETag = (String)ReadCol (stmt' newIndex + 2' typeof(String));  			String absoluteUri = (String)ReadCol (stmt' newIndex + 3' typeof(String));  			obj.ServiceMetadata.EditUri = String.IsNullOrEmpty (absoluteUri) ? null : new Uri (absoluteUri);  			lstChanges.Add (obj);  		}  	}  	catch (Exception ex) {  		Debug.WriteLine (ex.Message);  		throw;  	}  	finally {  		stmt.Reset ();  		stmt.ClearBindings ();  	}  }  
Magic Number,Microsoft.Synchronization.ClientServices.SQLite,SQLiteHelper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteHelper.cs,GetChanges,The following statement contains a magic number: try {  	// Set Values  	BindParameter (stmt' 1' lastModifiedDate);  	// Get mapping form the statement  	var cols = new TableMapping.Column[map.Columns.Length];  	// Foreach column' get the property in my object  	for (int i = 0; i < cols.Length; i++) {  		var name = stmt.ColumnName (i);  		var c = map.FindColumn (name);  		if (c != null)  			cols [i] = map.FindColumn (name);  	}  	// While row is available  	//while (await stmt.StepAsync().AsTask().ConfigureAwait(false))  	while (stmt.Step () == SQLiteResult.ROW) {  		// Create the object  		SQLiteOfflineEntity obj = (SQLiteOfflineEntity)Activator.CreateInstance (map.MappedType);  		for (int i = 0; i < cols.Length; i++) {  			if (cols [i] == null)  				continue;  			// Read the column  			var val = ReadCol (stmt' i' cols [i].ColumnType);  			// Set the value  			cols [i].SetValue (obj' val);  		}  		// Read the Oem Properties  		var newIndex = map.Columns.Count ();  		obj.ServiceMetadata = new OfflineEntityMetadata ();  		obj.ServiceMetadata.IsTombstone = (Boolean)ReadCol (stmt' newIndex' typeof(Boolean));  		obj.ServiceMetadata.Id = (String)ReadCol (stmt' newIndex + 1' typeof(String));  		obj.ServiceMetadata.ETag = (String)ReadCol (stmt' newIndex + 2' typeof(String));  		String absoluteUri = (String)ReadCol (stmt' newIndex + 3' typeof(String));  		obj.ServiceMetadata.EditUri = String.IsNullOrEmpty (absoluteUri) ? null : new Uri (absoluteUri);  		lstChanges.Add (obj);  	}  }  catch (Exception ex) {  	Debug.WriteLine (ex.Message);  	throw;  }  finally {  	stmt.Reset ();  	stmt.ClearBindings ();  }  
Magic Number,Microsoft.Synchronization.ClientServices.SQLite,SQLiteHelper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteHelper.cs,GetChanges,The following statement contains a magic number: try {  	// Set Values  	BindParameter (stmt' 1' lastModifiedDate);  	// Get mapping form the statement  	var cols = new TableMapping.Column[map.Columns.Length];  	// Foreach column' get the property in my object  	for (int i = 0; i < cols.Length; i++) {  		var name = stmt.ColumnName (i);  		var c = map.FindColumn (name);  		if (c != null)  			cols [i] = map.FindColumn (name);  	}  	// While row is available  	//while (await stmt.StepAsync().AsTask().ConfigureAwait(false))  	while (stmt.Step () == SQLiteResult.ROW) {  		// Create the object  		SQLiteOfflineEntity obj = (SQLiteOfflineEntity)Activator.CreateInstance (map.MappedType);  		for (int i = 0; i < cols.Length; i++) {  			if (cols [i] == null)  				continue;  			// Read the column  			var val = ReadCol (stmt' i' cols [i].ColumnType);  			// Set the value  			cols [i].SetValue (obj' val);  		}  		// Read the Oem Properties  		var newIndex = map.Columns.Count ();  		obj.ServiceMetadata = new OfflineEntityMetadata ();  		obj.ServiceMetadata.IsTombstone = (Boolean)ReadCol (stmt' newIndex' typeof(Boolean));  		obj.ServiceMetadata.Id = (String)ReadCol (stmt' newIndex + 1' typeof(String));  		obj.ServiceMetadata.ETag = (String)ReadCol (stmt' newIndex + 2' typeof(String));  		String absoluteUri = (String)ReadCol (stmt' newIndex + 3' typeof(String));  		obj.ServiceMetadata.EditUri = String.IsNullOrEmpty (absoluteUri) ? null : new Uri (absoluteUri);  		lstChanges.Add (obj);  	}  }  catch (Exception ex) {  	Debug.WriteLine (ex.Message);  	throw;  }  finally {  	stmt.Reset ();  	stmt.ClearBindings ();  }  
Magic Number,Microsoft.Synchronization.ClientServices.SQLite,SQLiteHelper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteHelper.cs,GetChanges,The following statement contains a magic number: while (stmt.Step () == SQLiteResult.ROW) {  	// Create the object  	SQLiteOfflineEntity obj = (SQLiteOfflineEntity)Activator.CreateInstance (map.MappedType);  	for (int i = 0; i < cols.Length; i++) {  		if (cols [i] == null)  			continue;  		// Read the column  		var val = ReadCol (stmt' i' cols [i].ColumnType);  		// Set the value  		cols [i].SetValue (obj' val);  	}  	// Read the Oem Properties  	var newIndex = map.Columns.Count ();  	obj.ServiceMetadata = new OfflineEntityMetadata ();  	obj.ServiceMetadata.IsTombstone = (Boolean)ReadCol (stmt' newIndex' typeof(Boolean));  	obj.ServiceMetadata.Id = (String)ReadCol (stmt' newIndex + 1' typeof(String));  	obj.ServiceMetadata.ETag = (String)ReadCol (stmt' newIndex + 2' typeof(String));  	String absoluteUri = (String)ReadCol (stmt' newIndex + 3' typeof(String));  	obj.ServiceMetadata.EditUri = String.IsNullOrEmpty (absoluteUri) ? null : new Uri (absoluteUri);  	lstChanges.Add (obj);  }  
Magic Number,Microsoft.Synchronization.ClientServices.SQLite,SQLiteHelper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteHelper.cs,GetChanges,The following statement contains a magic number: while (stmt.Step () == SQLiteResult.ROW) {  	// Create the object  	SQLiteOfflineEntity obj = (SQLiteOfflineEntity)Activator.CreateInstance (map.MappedType);  	for (int i = 0; i < cols.Length; i++) {  		if (cols [i] == null)  			continue;  		// Read the column  		var val = ReadCol (stmt' i' cols [i].ColumnType);  		// Set the value  		cols [i].SetValue (obj' val);  	}  	// Read the Oem Properties  	var newIndex = map.Columns.Count ();  	obj.ServiceMetadata = new OfflineEntityMetadata ();  	obj.ServiceMetadata.IsTombstone = (Boolean)ReadCol (stmt' newIndex' typeof(Boolean));  	obj.ServiceMetadata.Id = (String)ReadCol (stmt' newIndex + 1' typeof(String));  	obj.ServiceMetadata.ETag = (String)ReadCol (stmt' newIndex + 2' typeof(String));  	String absoluteUri = (String)ReadCol (stmt' newIndex + 3' typeof(String));  	obj.ServiceMetadata.EditUri = String.IsNullOrEmpty (absoluteUri) ? null : new Uri (absoluteUri);  	lstChanges.Add (obj);  }  
Magic Number,Microsoft.Synchronization.ClientServices.SQLite,SQLiteHelper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteHelper.cs,GetChanges,The following statement contains a magic number: obj.ServiceMetadata.ETag = (String)ReadCol (stmt' newIndex + 2' typeof(String));  
Magic Number,Microsoft.Synchronization.ClientServices.SQLite,SQLiteManager,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteManager.cs,ReadConfiguration,The following statement contains a magic number: using (var connection = new SQLiteConnection (localFilePath)) {  	string s = null;  	List<String> t = new List<string> ();  	bool scopeInfoTableFounded;  	DateTime d = new DateTime (1900' 1' 1);  	Byte[] blob = null;  	try {  		string name = databaseScopeName;  		ScopeInfoTable scopeInfoTable = null;  		// Check if Scope Table Exist  		String tableScope = null;  		using (var sqlCommand = connection.Prepare (SQLiteConstants.ScopeExist)) {  			if (sqlCommand.Step () == SQLiteResult.ROW)  				tableScope = sqlCommand [0] as String;  		}  		bool scopeTableExist = tableScope == "ScopeInfoTable";  		if (scopeTableExist) {  			String commandSelect = "Select * From ScopeInfoTable Where ScopeName = ?;";  			using (var stmtSelect = connection.Prepare (commandSelect)) {  				stmtSelect.Bind (1' name);  				var exist = stmtSelect.Step () == SQLiteResult.ROW;  				if (exist) {  					scopeInfoTable = new ScopeInfoTable ();  					scopeInfoTable.ScopeName = (String)SQLiteHelper.ReadCol (stmtSelect' 0' typeof(String));  					scopeInfoTable.ServiceUri = (String)SQLiteHelper.ReadCol (stmtSelect' 1' typeof(String));  					scopeInfoTable.LastSyncDate = (DateTime)SQLiteHelper.ReadCol (stmtSelect' 2' typeof(DateTime));  					scopeInfoTable.AnchorBlob = (Byte[])SQLiteHelper.ReadCol (stmtSelect' 3' typeof(Byte[]));  					scopeInfoTable.Configuration = (String)SQLiteHelper.ReadCol (stmtSelect' 4' typeof(String));  				}  			}  		}  		if (scopeInfoTable == null)  			return null;  		XDocument document = XDocument.Parse (scopeInfoTable.Configuration);  		s = scopeInfoTable.ServiceUri;  		t = (from tt in document.Descendants ()  		where tt.Name == "Types"  		select tt.Value).ToList ();  		d = scopeInfoTable.LastSyncDate;  		blob = scopeInfoTable.AnchorBlob;  		scopeInfoTableFounded = true;  	}  	catch {  		scopeInfoTableFounded = false;  	}  	if (!scopeInfoTableFounded)  		return null;  	// Configure Configuration en return it  	configuration.ScopeName = databaseScopeName;  	configuration.ServiceUri = new Uri (s);  	configuration.Types = t;  	configuration.LastSyncDate = d;  	configuration.AnchorBlob = blob;  }  
Magic Number,Microsoft.Synchronization.ClientServices.SQLite,SQLiteManager,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteManager.cs,ReadConfiguration,The following statement contains a magic number: using (var connection = new SQLiteConnection (localFilePath)) {  	string s = null;  	List<String> t = new List<string> ();  	bool scopeInfoTableFounded;  	DateTime d = new DateTime (1900' 1' 1);  	Byte[] blob = null;  	try {  		string name = databaseScopeName;  		ScopeInfoTable scopeInfoTable = null;  		// Check if Scope Table Exist  		String tableScope = null;  		using (var sqlCommand = connection.Prepare (SQLiteConstants.ScopeExist)) {  			if (sqlCommand.Step () == SQLiteResult.ROW)  				tableScope = sqlCommand [0] as String;  		}  		bool scopeTableExist = tableScope == "ScopeInfoTable";  		if (scopeTableExist) {  			String commandSelect = "Select * From ScopeInfoTable Where ScopeName = ?;";  			using (var stmtSelect = connection.Prepare (commandSelect)) {  				stmtSelect.Bind (1' name);  				var exist = stmtSelect.Step () == SQLiteResult.ROW;  				if (exist) {  					scopeInfoTable = new ScopeInfoTable ();  					scopeInfoTable.ScopeName = (String)SQLiteHelper.ReadCol (stmtSelect' 0' typeof(String));  					scopeInfoTable.ServiceUri = (String)SQLiteHelper.ReadCol (stmtSelect' 1' typeof(String));  					scopeInfoTable.LastSyncDate = (DateTime)SQLiteHelper.ReadCol (stmtSelect' 2' typeof(DateTime));  					scopeInfoTable.AnchorBlob = (Byte[])SQLiteHelper.ReadCol (stmtSelect' 3' typeof(Byte[]));  					scopeInfoTable.Configuration = (String)SQLiteHelper.ReadCol (stmtSelect' 4' typeof(String));  				}  			}  		}  		if (scopeInfoTable == null)  			return null;  		XDocument document = XDocument.Parse (scopeInfoTable.Configuration);  		s = scopeInfoTable.ServiceUri;  		t = (from tt in document.Descendants ()  		where tt.Name == "Types"  		select tt.Value).ToList ();  		d = scopeInfoTable.LastSyncDate;  		blob = scopeInfoTable.AnchorBlob;  		scopeInfoTableFounded = true;  	}  	catch {  		scopeInfoTableFounded = false;  	}  	if (!scopeInfoTableFounded)  		return null;  	// Configure Configuration en return it  	configuration.ScopeName = databaseScopeName;  	configuration.ServiceUri = new Uri (s);  	configuration.Types = t;  	configuration.LastSyncDate = d;  	configuration.AnchorBlob = blob;  }  
Magic Number,Microsoft.Synchronization.ClientServices.SQLite,SQLiteManager,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteManager.cs,ReadConfiguration,The following statement contains a magic number: using (var connection = new SQLiteConnection (localFilePath)) {  	string s = null;  	List<String> t = new List<string> ();  	bool scopeInfoTableFounded;  	DateTime d = new DateTime (1900' 1' 1);  	Byte[] blob = null;  	try {  		string name = databaseScopeName;  		ScopeInfoTable scopeInfoTable = null;  		// Check if Scope Table Exist  		String tableScope = null;  		using (var sqlCommand = connection.Prepare (SQLiteConstants.ScopeExist)) {  			if (sqlCommand.Step () == SQLiteResult.ROW)  				tableScope = sqlCommand [0] as String;  		}  		bool scopeTableExist = tableScope == "ScopeInfoTable";  		if (scopeTableExist) {  			String commandSelect = "Select * From ScopeInfoTable Where ScopeName = ?;";  			using (var stmtSelect = connection.Prepare (commandSelect)) {  				stmtSelect.Bind (1' name);  				var exist = stmtSelect.Step () == SQLiteResult.ROW;  				if (exist) {  					scopeInfoTable = new ScopeInfoTable ();  					scopeInfoTable.ScopeName = (String)SQLiteHelper.ReadCol (stmtSelect' 0' typeof(String));  					scopeInfoTable.ServiceUri = (String)SQLiteHelper.ReadCol (stmtSelect' 1' typeof(String));  					scopeInfoTable.LastSyncDate = (DateTime)SQLiteHelper.ReadCol (stmtSelect' 2' typeof(DateTime));  					scopeInfoTable.AnchorBlob = (Byte[])SQLiteHelper.ReadCol (stmtSelect' 3' typeof(Byte[]));  					scopeInfoTable.Configuration = (String)SQLiteHelper.ReadCol (stmtSelect' 4' typeof(String));  				}  			}  		}  		if (scopeInfoTable == null)  			return null;  		XDocument document = XDocument.Parse (scopeInfoTable.Configuration);  		s = scopeInfoTable.ServiceUri;  		t = (from tt in document.Descendants ()  		where tt.Name == "Types"  		select tt.Value).ToList ();  		d = scopeInfoTable.LastSyncDate;  		blob = scopeInfoTable.AnchorBlob;  		scopeInfoTableFounded = true;  	}  	catch {  		scopeInfoTableFounded = false;  	}  	if (!scopeInfoTableFounded)  		return null;  	// Configure Configuration en return it  	configuration.ScopeName = databaseScopeName;  	configuration.ServiceUri = new Uri (s);  	configuration.Types = t;  	configuration.LastSyncDate = d;  	configuration.AnchorBlob = blob;  }  
Magic Number,Microsoft.Synchronization.ClientServices.SQLite,SQLiteManager,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteManager.cs,ReadConfiguration,The following statement contains a magic number: using (var connection = new SQLiteConnection (localFilePath)) {  	string s = null;  	List<String> t = new List<string> ();  	bool scopeInfoTableFounded;  	DateTime d = new DateTime (1900' 1' 1);  	Byte[] blob = null;  	try {  		string name = databaseScopeName;  		ScopeInfoTable scopeInfoTable = null;  		// Check if Scope Table Exist  		String tableScope = null;  		using (var sqlCommand = connection.Prepare (SQLiteConstants.ScopeExist)) {  			if (sqlCommand.Step () == SQLiteResult.ROW)  				tableScope = sqlCommand [0] as String;  		}  		bool scopeTableExist = tableScope == "ScopeInfoTable";  		if (scopeTableExist) {  			String commandSelect = "Select * From ScopeInfoTable Where ScopeName = ?;";  			using (var stmtSelect = connection.Prepare (commandSelect)) {  				stmtSelect.Bind (1' name);  				var exist = stmtSelect.Step () == SQLiteResult.ROW;  				if (exist) {  					scopeInfoTable = new ScopeInfoTable ();  					scopeInfoTable.ScopeName = (String)SQLiteHelper.ReadCol (stmtSelect' 0' typeof(String));  					scopeInfoTable.ServiceUri = (String)SQLiteHelper.ReadCol (stmtSelect' 1' typeof(String));  					scopeInfoTable.LastSyncDate = (DateTime)SQLiteHelper.ReadCol (stmtSelect' 2' typeof(DateTime));  					scopeInfoTable.AnchorBlob = (Byte[])SQLiteHelper.ReadCol (stmtSelect' 3' typeof(Byte[]));  					scopeInfoTable.Configuration = (String)SQLiteHelper.ReadCol (stmtSelect' 4' typeof(String));  				}  			}  		}  		if (scopeInfoTable == null)  			return null;  		XDocument document = XDocument.Parse (scopeInfoTable.Configuration);  		s = scopeInfoTable.ServiceUri;  		t = (from tt in document.Descendants ()  		where tt.Name == "Types"  		select tt.Value).ToList ();  		d = scopeInfoTable.LastSyncDate;  		blob = scopeInfoTable.AnchorBlob;  		scopeInfoTableFounded = true;  	}  	catch {  		scopeInfoTableFounded = false;  	}  	if (!scopeInfoTableFounded)  		return null;  	// Configure Configuration en return it  	configuration.ScopeName = databaseScopeName;  	configuration.ServiceUri = new Uri (s);  	configuration.Types = t;  	configuration.LastSyncDate = d;  	configuration.AnchorBlob = blob;  }  
Magic Number,Microsoft.Synchronization.ClientServices.SQLite,SQLiteManager,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteManager.cs,ReadConfiguration,The following statement contains a magic number: try {  	string name = databaseScopeName;  	ScopeInfoTable scopeInfoTable = null;  	// Check if Scope Table Exist  	String tableScope = null;  	using (var sqlCommand = connection.Prepare (SQLiteConstants.ScopeExist)) {  		if (sqlCommand.Step () == SQLiteResult.ROW)  			tableScope = sqlCommand [0] as String;  	}  	bool scopeTableExist = tableScope == "ScopeInfoTable";  	if (scopeTableExist) {  		String commandSelect = "Select * From ScopeInfoTable Where ScopeName = ?;";  		using (var stmtSelect = connection.Prepare (commandSelect)) {  			stmtSelect.Bind (1' name);  			var exist = stmtSelect.Step () == SQLiteResult.ROW;  			if (exist) {  				scopeInfoTable = new ScopeInfoTable ();  				scopeInfoTable.ScopeName = (String)SQLiteHelper.ReadCol (stmtSelect' 0' typeof(String));  				scopeInfoTable.ServiceUri = (String)SQLiteHelper.ReadCol (stmtSelect' 1' typeof(String));  				scopeInfoTable.LastSyncDate = (DateTime)SQLiteHelper.ReadCol (stmtSelect' 2' typeof(DateTime));  				scopeInfoTable.AnchorBlob = (Byte[])SQLiteHelper.ReadCol (stmtSelect' 3' typeof(Byte[]));  				scopeInfoTable.Configuration = (String)SQLiteHelper.ReadCol (stmtSelect' 4' typeof(String));  			}  		}  	}  	if (scopeInfoTable == null)  		return null;  	XDocument document = XDocument.Parse (scopeInfoTable.Configuration);  	s = scopeInfoTable.ServiceUri;  	t = (from tt in document.Descendants ()  	where tt.Name == "Types"  	select tt.Value).ToList ();  	d = scopeInfoTable.LastSyncDate;  	blob = scopeInfoTable.AnchorBlob;  	scopeInfoTableFounded = true;  }  catch {  	scopeInfoTableFounded = false;  }  
Magic Number,Microsoft.Synchronization.ClientServices.SQLite,SQLiteManager,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteManager.cs,ReadConfiguration,The following statement contains a magic number: try {  	string name = databaseScopeName;  	ScopeInfoTable scopeInfoTable = null;  	// Check if Scope Table Exist  	String tableScope = null;  	using (var sqlCommand = connection.Prepare (SQLiteConstants.ScopeExist)) {  		if (sqlCommand.Step () == SQLiteResult.ROW)  			tableScope = sqlCommand [0] as String;  	}  	bool scopeTableExist = tableScope == "ScopeInfoTable";  	if (scopeTableExist) {  		String commandSelect = "Select * From ScopeInfoTable Where ScopeName = ?;";  		using (var stmtSelect = connection.Prepare (commandSelect)) {  			stmtSelect.Bind (1' name);  			var exist = stmtSelect.Step () == SQLiteResult.ROW;  			if (exist) {  				scopeInfoTable = new ScopeInfoTable ();  				scopeInfoTable.ScopeName = (String)SQLiteHelper.ReadCol (stmtSelect' 0' typeof(String));  				scopeInfoTable.ServiceUri = (String)SQLiteHelper.ReadCol (stmtSelect' 1' typeof(String));  				scopeInfoTable.LastSyncDate = (DateTime)SQLiteHelper.ReadCol (stmtSelect' 2' typeof(DateTime));  				scopeInfoTable.AnchorBlob = (Byte[])SQLiteHelper.ReadCol (stmtSelect' 3' typeof(Byte[]));  				scopeInfoTable.Configuration = (String)SQLiteHelper.ReadCol (stmtSelect' 4' typeof(String));  			}  		}  	}  	if (scopeInfoTable == null)  		return null;  	XDocument document = XDocument.Parse (scopeInfoTable.Configuration);  	s = scopeInfoTable.ServiceUri;  	t = (from tt in document.Descendants ()  	where tt.Name == "Types"  	select tt.Value).ToList ();  	d = scopeInfoTable.LastSyncDate;  	blob = scopeInfoTable.AnchorBlob;  	scopeInfoTableFounded = true;  }  catch {  	scopeInfoTableFounded = false;  }  
Magic Number,Microsoft.Synchronization.ClientServices.SQLite,SQLiteManager,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteManager.cs,ReadConfiguration,The following statement contains a magic number: try {  	string name = databaseScopeName;  	ScopeInfoTable scopeInfoTable = null;  	// Check if Scope Table Exist  	String tableScope = null;  	using (var sqlCommand = connection.Prepare (SQLiteConstants.ScopeExist)) {  		if (sqlCommand.Step () == SQLiteResult.ROW)  			tableScope = sqlCommand [0] as String;  	}  	bool scopeTableExist = tableScope == "ScopeInfoTable";  	if (scopeTableExist) {  		String commandSelect = "Select * From ScopeInfoTable Where ScopeName = ?;";  		using (var stmtSelect = connection.Prepare (commandSelect)) {  			stmtSelect.Bind (1' name);  			var exist = stmtSelect.Step () == SQLiteResult.ROW;  			if (exist) {  				scopeInfoTable = new ScopeInfoTable ();  				scopeInfoTable.ScopeName = (String)SQLiteHelper.ReadCol (stmtSelect' 0' typeof(String));  				scopeInfoTable.ServiceUri = (String)SQLiteHelper.ReadCol (stmtSelect' 1' typeof(String));  				scopeInfoTable.LastSyncDate = (DateTime)SQLiteHelper.ReadCol (stmtSelect' 2' typeof(DateTime));  				scopeInfoTable.AnchorBlob = (Byte[])SQLiteHelper.ReadCol (stmtSelect' 3' typeof(Byte[]));  				scopeInfoTable.Configuration = (String)SQLiteHelper.ReadCol (stmtSelect' 4' typeof(String));  			}  		}  	}  	if (scopeInfoTable == null)  		return null;  	XDocument document = XDocument.Parse (scopeInfoTable.Configuration);  	s = scopeInfoTable.ServiceUri;  	t = (from tt in document.Descendants ()  	where tt.Name == "Types"  	select tt.Value).ToList ();  	d = scopeInfoTable.LastSyncDate;  	blob = scopeInfoTable.AnchorBlob;  	scopeInfoTableFounded = true;  }  catch {  	scopeInfoTableFounded = false;  }  
Magic Number,Microsoft.Synchronization.ClientServices.SQLite,SQLiteManager,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteManager.cs,ReadConfiguration,The following statement contains a magic number: if (scopeTableExist) {  	String commandSelect = "Select * From ScopeInfoTable Where ScopeName = ?;";  	using (var stmtSelect = connection.Prepare (commandSelect)) {  		stmtSelect.Bind (1' name);  		var exist = stmtSelect.Step () == SQLiteResult.ROW;  		if (exist) {  			scopeInfoTable = new ScopeInfoTable ();  			scopeInfoTable.ScopeName = (String)SQLiteHelper.ReadCol (stmtSelect' 0' typeof(String));  			scopeInfoTable.ServiceUri = (String)SQLiteHelper.ReadCol (stmtSelect' 1' typeof(String));  			scopeInfoTable.LastSyncDate = (DateTime)SQLiteHelper.ReadCol (stmtSelect' 2' typeof(DateTime));  			scopeInfoTable.AnchorBlob = (Byte[])SQLiteHelper.ReadCol (stmtSelect' 3' typeof(Byte[]));  			scopeInfoTable.Configuration = (String)SQLiteHelper.ReadCol (stmtSelect' 4' typeof(String));  		}  	}  }  
Magic Number,Microsoft.Synchronization.ClientServices.SQLite,SQLiteManager,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteManager.cs,ReadConfiguration,The following statement contains a magic number: if (scopeTableExist) {  	String commandSelect = "Select * From ScopeInfoTable Where ScopeName = ?;";  	using (var stmtSelect = connection.Prepare (commandSelect)) {  		stmtSelect.Bind (1' name);  		var exist = stmtSelect.Step () == SQLiteResult.ROW;  		if (exist) {  			scopeInfoTable = new ScopeInfoTable ();  			scopeInfoTable.ScopeName = (String)SQLiteHelper.ReadCol (stmtSelect' 0' typeof(String));  			scopeInfoTable.ServiceUri = (String)SQLiteHelper.ReadCol (stmtSelect' 1' typeof(String));  			scopeInfoTable.LastSyncDate = (DateTime)SQLiteHelper.ReadCol (stmtSelect' 2' typeof(DateTime));  			scopeInfoTable.AnchorBlob = (Byte[])SQLiteHelper.ReadCol (stmtSelect' 3' typeof(Byte[]));  			scopeInfoTable.Configuration = (String)SQLiteHelper.ReadCol (stmtSelect' 4' typeof(String));  		}  	}  }  
Magic Number,Microsoft.Synchronization.ClientServices.SQLite,SQLiteManager,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteManager.cs,ReadConfiguration,The following statement contains a magic number: if (scopeTableExist) {  	String commandSelect = "Select * From ScopeInfoTable Where ScopeName = ?;";  	using (var stmtSelect = connection.Prepare (commandSelect)) {  		stmtSelect.Bind (1' name);  		var exist = stmtSelect.Step () == SQLiteResult.ROW;  		if (exist) {  			scopeInfoTable = new ScopeInfoTable ();  			scopeInfoTable.ScopeName = (String)SQLiteHelper.ReadCol (stmtSelect' 0' typeof(String));  			scopeInfoTable.ServiceUri = (String)SQLiteHelper.ReadCol (stmtSelect' 1' typeof(String));  			scopeInfoTable.LastSyncDate = (DateTime)SQLiteHelper.ReadCol (stmtSelect' 2' typeof(DateTime));  			scopeInfoTable.AnchorBlob = (Byte[])SQLiteHelper.ReadCol (stmtSelect' 3' typeof(Byte[]));  			scopeInfoTable.Configuration = (String)SQLiteHelper.ReadCol (stmtSelect' 4' typeof(String));  		}  	}  }  
Magic Number,Microsoft.Synchronization.ClientServices.SQLite,SQLiteManager,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteManager.cs,ReadConfiguration,The following statement contains a magic number: using (var stmtSelect = connection.Prepare (commandSelect)) {  	stmtSelect.Bind (1' name);  	var exist = stmtSelect.Step () == SQLiteResult.ROW;  	if (exist) {  		scopeInfoTable = new ScopeInfoTable ();  		scopeInfoTable.ScopeName = (String)SQLiteHelper.ReadCol (stmtSelect' 0' typeof(String));  		scopeInfoTable.ServiceUri = (String)SQLiteHelper.ReadCol (stmtSelect' 1' typeof(String));  		scopeInfoTable.LastSyncDate = (DateTime)SQLiteHelper.ReadCol (stmtSelect' 2' typeof(DateTime));  		scopeInfoTable.AnchorBlob = (Byte[])SQLiteHelper.ReadCol (stmtSelect' 3' typeof(Byte[]));  		scopeInfoTable.Configuration = (String)SQLiteHelper.ReadCol (stmtSelect' 4' typeof(String));  	}  }  
Magic Number,Microsoft.Synchronization.ClientServices.SQLite,SQLiteManager,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteManager.cs,ReadConfiguration,The following statement contains a magic number: using (var stmtSelect = connection.Prepare (commandSelect)) {  	stmtSelect.Bind (1' name);  	var exist = stmtSelect.Step () == SQLiteResult.ROW;  	if (exist) {  		scopeInfoTable = new ScopeInfoTable ();  		scopeInfoTable.ScopeName = (String)SQLiteHelper.ReadCol (stmtSelect' 0' typeof(String));  		scopeInfoTable.ServiceUri = (String)SQLiteHelper.ReadCol (stmtSelect' 1' typeof(String));  		scopeInfoTable.LastSyncDate = (DateTime)SQLiteHelper.ReadCol (stmtSelect' 2' typeof(DateTime));  		scopeInfoTable.AnchorBlob = (Byte[])SQLiteHelper.ReadCol (stmtSelect' 3' typeof(Byte[]));  		scopeInfoTable.Configuration = (String)SQLiteHelper.ReadCol (stmtSelect' 4' typeof(String));  	}  }  
Magic Number,Microsoft.Synchronization.ClientServices.SQLite,SQLiteManager,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteManager.cs,ReadConfiguration,The following statement contains a magic number: using (var stmtSelect = connection.Prepare (commandSelect)) {  	stmtSelect.Bind (1' name);  	var exist = stmtSelect.Step () == SQLiteResult.ROW;  	if (exist) {  		scopeInfoTable = new ScopeInfoTable ();  		scopeInfoTable.ScopeName = (String)SQLiteHelper.ReadCol (stmtSelect' 0' typeof(String));  		scopeInfoTable.ServiceUri = (String)SQLiteHelper.ReadCol (stmtSelect' 1' typeof(String));  		scopeInfoTable.LastSyncDate = (DateTime)SQLiteHelper.ReadCol (stmtSelect' 2' typeof(DateTime));  		scopeInfoTable.AnchorBlob = (Byte[])SQLiteHelper.ReadCol (stmtSelect' 3' typeof(Byte[]));  		scopeInfoTable.Configuration = (String)SQLiteHelper.ReadCol (stmtSelect' 4' typeof(String));  	}  }  
Magic Number,Microsoft.Synchronization.ClientServices.SQLite,SQLiteManager,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteManager.cs,ReadConfiguration,The following statement contains a magic number: if (exist) {  	scopeInfoTable = new ScopeInfoTable ();  	scopeInfoTable.ScopeName = (String)SQLiteHelper.ReadCol (stmtSelect' 0' typeof(String));  	scopeInfoTable.ServiceUri = (String)SQLiteHelper.ReadCol (stmtSelect' 1' typeof(String));  	scopeInfoTable.LastSyncDate = (DateTime)SQLiteHelper.ReadCol (stmtSelect' 2' typeof(DateTime));  	scopeInfoTable.AnchorBlob = (Byte[])SQLiteHelper.ReadCol (stmtSelect' 3' typeof(Byte[]));  	scopeInfoTable.Configuration = (String)SQLiteHelper.ReadCol (stmtSelect' 4' typeof(String));  }  
Magic Number,Microsoft.Synchronization.ClientServices.SQLite,SQLiteManager,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteManager.cs,ReadConfiguration,The following statement contains a magic number: if (exist) {  	scopeInfoTable = new ScopeInfoTable ();  	scopeInfoTable.ScopeName = (String)SQLiteHelper.ReadCol (stmtSelect' 0' typeof(String));  	scopeInfoTable.ServiceUri = (String)SQLiteHelper.ReadCol (stmtSelect' 1' typeof(String));  	scopeInfoTable.LastSyncDate = (DateTime)SQLiteHelper.ReadCol (stmtSelect' 2' typeof(DateTime));  	scopeInfoTable.AnchorBlob = (Byte[])SQLiteHelper.ReadCol (stmtSelect' 3' typeof(Byte[]));  	scopeInfoTable.Configuration = (String)SQLiteHelper.ReadCol (stmtSelect' 4' typeof(String));  }  
Magic Number,Microsoft.Synchronization.ClientServices.SQLite,SQLiteManager,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteManager.cs,ReadConfiguration,The following statement contains a magic number: if (exist) {  	scopeInfoTable = new ScopeInfoTable ();  	scopeInfoTable.ScopeName = (String)SQLiteHelper.ReadCol (stmtSelect' 0' typeof(String));  	scopeInfoTable.ServiceUri = (String)SQLiteHelper.ReadCol (stmtSelect' 1' typeof(String));  	scopeInfoTable.LastSyncDate = (DateTime)SQLiteHelper.ReadCol (stmtSelect' 2' typeof(DateTime));  	scopeInfoTable.AnchorBlob = (Byte[])SQLiteHelper.ReadCol (stmtSelect' 3' typeof(Byte[]));  	scopeInfoTable.Configuration = (String)SQLiteHelper.ReadCol (stmtSelect' 4' typeof(String));  }  
Magic Number,Microsoft.Synchronization.ClientServices.SQLite,SQLiteManager,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteManager.cs,ReadConfiguration,The following statement contains a magic number: scopeInfoTable.LastSyncDate = (DateTime)SQLiteHelper.ReadCol (stmtSelect' 2' typeof(DateTime));  
Magic Number,Microsoft.Synchronization.ClientServices.SQLite,SQLiteManager,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteManager.cs,ReadConfiguration,The following statement contains a magic number: scopeInfoTable.AnchorBlob = (Byte[])SQLiteHelper.ReadCol (stmtSelect' 3' typeof(Byte[]));  
Magic Number,Microsoft.Synchronization.ClientServices.SQLite,SQLiteManager,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteManager.cs,ReadConfiguration,The following statement contains a magic number: scopeInfoTable.Configuration = (String)SQLiteHelper.ReadCol (stmtSelect' 4' typeof(String));  
Magic Number,Microsoft.Synchronization.ClientServices.SQLite,SQLiteManager,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteManager.cs,SaveConfiguration,The following statement contains a magic number: using (var connection = new SQLiteConnection (localFilePath)) {  	try {  		String tableScope = null;  		using (var sqlCommand = connection.Prepare (SQLiteConstants.ScopeExist)) {  			if (sqlCommand.Step () == SQLiteResult.ROW)  				tableScope = sqlCommand [0] as string;  		}  		bool scopeTableExist = tableScope == "ScopeInfoTable";  		if (scopeTableExist) {  			String commandSelect = "Select * From ScopeInfoTable Where ScopeName = ?;";  			using (var stmtSelect = connection.Prepare (commandSelect)) {  				stmtSelect.Bind (1' configuration.ScopeName);  				var exist = stmtSelect.Step () == SQLiteResult.ROW;  				string stmtText = exist ? "Update ScopeInfoTable Set ServiceUri = ?' LastSyncDate = ?' Configuration = ?' AnchorBlob = ? Where ScopeName = ?;" : "Insert into ScopeInfoTable (ServiceUri' LastSyncDate' Configuration' AnchorBlob' ScopeName) Values (?' ?' ?' ?' ?);";  				using (var stmt = connection.Prepare (stmtText)) {  					SQLiteHelper.BindParameter (stmt' 1' scopeInfoTable.ServiceUri);  					SQLiteHelper.BindParameter (stmt' 2' scopeInfoTable.LastSyncDate);  					SQLiteHelper.BindParameter (stmt' 3' scopeInfoTable.Configuration);  					SQLiteHelper.BindParameter (stmt' 4' scopeInfoTable.AnchorBlob);  					SQLiteHelper.BindParameter (stmt' 5' scopeInfoTable.ScopeName);  					stmt.Step ();  				}  			}  		}  	}  	catch (Exception ex) {  		throw new Exception ("Impossible to save Sync Configuration"' ex);  	}  }  
Magic Number,Microsoft.Synchronization.ClientServices.SQLite,SQLiteManager,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteManager.cs,SaveConfiguration,The following statement contains a magic number: using (var connection = new SQLiteConnection (localFilePath)) {  	try {  		String tableScope = null;  		using (var sqlCommand = connection.Prepare (SQLiteConstants.ScopeExist)) {  			if (sqlCommand.Step () == SQLiteResult.ROW)  				tableScope = sqlCommand [0] as string;  		}  		bool scopeTableExist = tableScope == "ScopeInfoTable";  		if (scopeTableExist) {  			String commandSelect = "Select * From ScopeInfoTable Where ScopeName = ?;";  			using (var stmtSelect = connection.Prepare (commandSelect)) {  				stmtSelect.Bind (1' configuration.ScopeName);  				var exist = stmtSelect.Step () == SQLiteResult.ROW;  				string stmtText = exist ? "Update ScopeInfoTable Set ServiceUri = ?' LastSyncDate = ?' Configuration = ?' AnchorBlob = ? Where ScopeName = ?;" : "Insert into ScopeInfoTable (ServiceUri' LastSyncDate' Configuration' AnchorBlob' ScopeName) Values (?' ?' ?' ?' ?);";  				using (var stmt = connection.Prepare (stmtText)) {  					SQLiteHelper.BindParameter (stmt' 1' scopeInfoTable.ServiceUri);  					SQLiteHelper.BindParameter (stmt' 2' scopeInfoTable.LastSyncDate);  					SQLiteHelper.BindParameter (stmt' 3' scopeInfoTable.Configuration);  					SQLiteHelper.BindParameter (stmt' 4' scopeInfoTable.AnchorBlob);  					SQLiteHelper.BindParameter (stmt' 5' scopeInfoTable.ScopeName);  					stmt.Step ();  				}  			}  		}  	}  	catch (Exception ex) {  		throw new Exception ("Impossible to save Sync Configuration"' ex);  	}  }  
Magic Number,Microsoft.Synchronization.ClientServices.SQLite,SQLiteManager,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteManager.cs,SaveConfiguration,The following statement contains a magic number: using (var connection = new SQLiteConnection (localFilePath)) {  	try {  		String tableScope = null;  		using (var sqlCommand = connection.Prepare (SQLiteConstants.ScopeExist)) {  			if (sqlCommand.Step () == SQLiteResult.ROW)  				tableScope = sqlCommand [0] as string;  		}  		bool scopeTableExist = tableScope == "ScopeInfoTable";  		if (scopeTableExist) {  			String commandSelect = "Select * From ScopeInfoTable Where ScopeName = ?;";  			using (var stmtSelect = connection.Prepare (commandSelect)) {  				stmtSelect.Bind (1' configuration.ScopeName);  				var exist = stmtSelect.Step () == SQLiteResult.ROW;  				string stmtText = exist ? "Update ScopeInfoTable Set ServiceUri = ?' LastSyncDate = ?' Configuration = ?' AnchorBlob = ? Where ScopeName = ?;" : "Insert into ScopeInfoTable (ServiceUri' LastSyncDate' Configuration' AnchorBlob' ScopeName) Values (?' ?' ?' ?' ?);";  				using (var stmt = connection.Prepare (stmtText)) {  					SQLiteHelper.BindParameter (stmt' 1' scopeInfoTable.ServiceUri);  					SQLiteHelper.BindParameter (stmt' 2' scopeInfoTable.LastSyncDate);  					SQLiteHelper.BindParameter (stmt' 3' scopeInfoTable.Configuration);  					SQLiteHelper.BindParameter (stmt' 4' scopeInfoTable.AnchorBlob);  					SQLiteHelper.BindParameter (stmt' 5' scopeInfoTable.ScopeName);  					stmt.Step ();  				}  			}  		}  	}  	catch (Exception ex) {  		throw new Exception ("Impossible to save Sync Configuration"' ex);  	}  }  
Magic Number,Microsoft.Synchronization.ClientServices.SQLite,SQLiteManager,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteManager.cs,SaveConfiguration,The following statement contains a magic number: using (var connection = new SQLiteConnection (localFilePath)) {  	try {  		String tableScope = null;  		using (var sqlCommand = connection.Prepare (SQLiteConstants.ScopeExist)) {  			if (sqlCommand.Step () == SQLiteResult.ROW)  				tableScope = sqlCommand [0] as string;  		}  		bool scopeTableExist = tableScope == "ScopeInfoTable";  		if (scopeTableExist) {  			String commandSelect = "Select * From ScopeInfoTable Where ScopeName = ?;";  			using (var stmtSelect = connection.Prepare (commandSelect)) {  				stmtSelect.Bind (1' configuration.ScopeName);  				var exist = stmtSelect.Step () == SQLiteResult.ROW;  				string stmtText = exist ? "Update ScopeInfoTable Set ServiceUri = ?' LastSyncDate = ?' Configuration = ?' AnchorBlob = ? Where ScopeName = ?;" : "Insert into ScopeInfoTable (ServiceUri' LastSyncDate' Configuration' AnchorBlob' ScopeName) Values (?' ?' ?' ?' ?);";  				using (var stmt = connection.Prepare (stmtText)) {  					SQLiteHelper.BindParameter (stmt' 1' scopeInfoTable.ServiceUri);  					SQLiteHelper.BindParameter (stmt' 2' scopeInfoTable.LastSyncDate);  					SQLiteHelper.BindParameter (stmt' 3' scopeInfoTable.Configuration);  					SQLiteHelper.BindParameter (stmt' 4' scopeInfoTable.AnchorBlob);  					SQLiteHelper.BindParameter (stmt' 5' scopeInfoTable.ScopeName);  					stmt.Step ();  				}  			}  		}  	}  	catch (Exception ex) {  		throw new Exception ("Impossible to save Sync Configuration"' ex);  	}  }  
Magic Number,Microsoft.Synchronization.ClientServices.SQLite,SQLiteManager,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteManager.cs,SaveConfiguration,The following statement contains a magic number: try {  	String tableScope = null;  	using (var sqlCommand = connection.Prepare (SQLiteConstants.ScopeExist)) {  		if (sqlCommand.Step () == SQLiteResult.ROW)  			tableScope = sqlCommand [0] as string;  	}  	bool scopeTableExist = tableScope == "ScopeInfoTable";  	if (scopeTableExist) {  		String commandSelect = "Select * From ScopeInfoTable Where ScopeName = ?;";  		using (var stmtSelect = connection.Prepare (commandSelect)) {  			stmtSelect.Bind (1' configuration.ScopeName);  			var exist = stmtSelect.Step () == SQLiteResult.ROW;  			string stmtText = exist ? "Update ScopeInfoTable Set ServiceUri = ?' LastSyncDate = ?' Configuration = ?' AnchorBlob = ? Where ScopeName = ?;" : "Insert into ScopeInfoTable (ServiceUri' LastSyncDate' Configuration' AnchorBlob' ScopeName) Values (?' ?' ?' ?' ?);";  			using (var stmt = connection.Prepare (stmtText)) {  				SQLiteHelper.BindParameter (stmt' 1' scopeInfoTable.ServiceUri);  				SQLiteHelper.BindParameter (stmt' 2' scopeInfoTable.LastSyncDate);  				SQLiteHelper.BindParameter (stmt' 3' scopeInfoTable.Configuration);  				SQLiteHelper.BindParameter (stmt' 4' scopeInfoTable.AnchorBlob);  				SQLiteHelper.BindParameter (stmt' 5' scopeInfoTable.ScopeName);  				stmt.Step ();  			}  		}  	}  }  catch (Exception ex) {  	throw new Exception ("Impossible to save Sync Configuration"' ex);  }  
Magic Number,Microsoft.Synchronization.ClientServices.SQLite,SQLiteManager,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteManager.cs,SaveConfiguration,The following statement contains a magic number: try {  	String tableScope = null;  	using (var sqlCommand = connection.Prepare (SQLiteConstants.ScopeExist)) {  		if (sqlCommand.Step () == SQLiteResult.ROW)  			tableScope = sqlCommand [0] as string;  	}  	bool scopeTableExist = tableScope == "ScopeInfoTable";  	if (scopeTableExist) {  		String commandSelect = "Select * From ScopeInfoTable Where ScopeName = ?;";  		using (var stmtSelect = connection.Prepare (commandSelect)) {  			stmtSelect.Bind (1' configuration.ScopeName);  			var exist = stmtSelect.Step () == SQLiteResult.ROW;  			string stmtText = exist ? "Update ScopeInfoTable Set ServiceUri = ?' LastSyncDate = ?' Configuration = ?' AnchorBlob = ? Where ScopeName = ?;" : "Insert into ScopeInfoTable (ServiceUri' LastSyncDate' Configuration' AnchorBlob' ScopeName) Values (?' ?' ?' ?' ?);";  			using (var stmt = connection.Prepare (stmtText)) {  				SQLiteHelper.BindParameter (stmt' 1' scopeInfoTable.ServiceUri);  				SQLiteHelper.BindParameter (stmt' 2' scopeInfoTable.LastSyncDate);  				SQLiteHelper.BindParameter (stmt' 3' scopeInfoTable.Configuration);  				SQLiteHelper.BindParameter (stmt' 4' scopeInfoTable.AnchorBlob);  				SQLiteHelper.BindParameter (stmt' 5' scopeInfoTable.ScopeName);  				stmt.Step ();  			}  		}  	}  }  catch (Exception ex) {  	throw new Exception ("Impossible to save Sync Configuration"' ex);  }  
Magic Number,Microsoft.Synchronization.ClientServices.SQLite,SQLiteManager,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteManager.cs,SaveConfiguration,The following statement contains a magic number: try {  	String tableScope = null;  	using (var sqlCommand = connection.Prepare (SQLiteConstants.ScopeExist)) {  		if (sqlCommand.Step () == SQLiteResult.ROW)  			tableScope = sqlCommand [0] as string;  	}  	bool scopeTableExist = tableScope == "ScopeInfoTable";  	if (scopeTableExist) {  		String commandSelect = "Select * From ScopeInfoTable Where ScopeName = ?;";  		using (var stmtSelect = connection.Prepare (commandSelect)) {  			stmtSelect.Bind (1' configuration.ScopeName);  			var exist = stmtSelect.Step () == SQLiteResult.ROW;  			string stmtText = exist ? "Update ScopeInfoTable Set ServiceUri = ?' LastSyncDate = ?' Configuration = ?' AnchorBlob = ? Where ScopeName = ?;" : "Insert into ScopeInfoTable (ServiceUri' LastSyncDate' Configuration' AnchorBlob' ScopeName) Values (?' ?' ?' ?' ?);";  			using (var stmt = connection.Prepare (stmtText)) {  				SQLiteHelper.BindParameter (stmt' 1' scopeInfoTable.ServiceUri);  				SQLiteHelper.BindParameter (stmt' 2' scopeInfoTable.LastSyncDate);  				SQLiteHelper.BindParameter (stmt' 3' scopeInfoTable.Configuration);  				SQLiteHelper.BindParameter (stmt' 4' scopeInfoTable.AnchorBlob);  				SQLiteHelper.BindParameter (stmt' 5' scopeInfoTable.ScopeName);  				stmt.Step ();  			}  		}  	}  }  catch (Exception ex) {  	throw new Exception ("Impossible to save Sync Configuration"' ex);  }  
Magic Number,Microsoft.Synchronization.ClientServices.SQLite,SQLiteManager,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteManager.cs,SaveConfiguration,The following statement contains a magic number: try {  	String tableScope = null;  	using (var sqlCommand = connection.Prepare (SQLiteConstants.ScopeExist)) {  		if (sqlCommand.Step () == SQLiteResult.ROW)  			tableScope = sqlCommand [0] as string;  	}  	bool scopeTableExist = tableScope == "ScopeInfoTable";  	if (scopeTableExist) {  		String commandSelect = "Select * From ScopeInfoTable Where ScopeName = ?;";  		using (var stmtSelect = connection.Prepare (commandSelect)) {  			stmtSelect.Bind (1' configuration.ScopeName);  			var exist = stmtSelect.Step () == SQLiteResult.ROW;  			string stmtText = exist ? "Update ScopeInfoTable Set ServiceUri = ?' LastSyncDate = ?' Configuration = ?' AnchorBlob = ? Where ScopeName = ?;" : "Insert into ScopeInfoTable (ServiceUri' LastSyncDate' Configuration' AnchorBlob' ScopeName) Values (?' ?' ?' ?' ?);";  			using (var stmt = connection.Prepare (stmtText)) {  				SQLiteHelper.BindParameter (stmt' 1' scopeInfoTable.ServiceUri);  				SQLiteHelper.BindParameter (stmt' 2' scopeInfoTable.LastSyncDate);  				SQLiteHelper.BindParameter (stmt' 3' scopeInfoTable.Configuration);  				SQLiteHelper.BindParameter (stmt' 4' scopeInfoTable.AnchorBlob);  				SQLiteHelper.BindParameter (stmt' 5' scopeInfoTable.ScopeName);  				stmt.Step ();  			}  		}  	}  }  catch (Exception ex) {  	throw new Exception ("Impossible to save Sync Configuration"' ex);  }  
Magic Number,Microsoft.Synchronization.ClientServices.SQLite,SQLiteManager,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteManager.cs,SaveConfiguration,The following statement contains a magic number: if (scopeTableExist) {  	String commandSelect = "Select * From ScopeInfoTable Where ScopeName = ?;";  	using (var stmtSelect = connection.Prepare (commandSelect)) {  		stmtSelect.Bind (1' configuration.ScopeName);  		var exist = stmtSelect.Step () == SQLiteResult.ROW;  		string stmtText = exist ? "Update ScopeInfoTable Set ServiceUri = ?' LastSyncDate = ?' Configuration = ?' AnchorBlob = ? Where ScopeName = ?;" : "Insert into ScopeInfoTable (ServiceUri' LastSyncDate' Configuration' AnchorBlob' ScopeName) Values (?' ?' ?' ?' ?);";  		using (var stmt = connection.Prepare (stmtText)) {  			SQLiteHelper.BindParameter (stmt' 1' scopeInfoTable.ServiceUri);  			SQLiteHelper.BindParameter (stmt' 2' scopeInfoTable.LastSyncDate);  			SQLiteHelper.BindParameter (stmt' 3' scopeInfoTable.Configuration);  			SQLiteHelper.BindParameter (stmt' 4' scopeInfoTable.AnchorBlob);  			SQLiteHelper.BindParameter (stmt' 5' scopeInfoTable.ScopeName);  			stmt.Step ();  		}  	}  }  
Magic Number,Microsoft.Synchronization.ClientServices.SQLite,SQLiteManager,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteManager.cs,SaveConfiguration,The following statement contains a magic number: if (scopeTableExist) {  	String commandSelect = "Select * From ScopeInfoTable Where ScopeName = ?;";  	using (var stmtSelect = connection.Prepare (commandSelect)) {  		stmtSelect.Bind (1' configuration.ScopeName);  		var exist = stmtSelect.Step () == SQLiteResult.ROW;  		string stmtText = exist ? "Update ScopeInfoTable Set ServiceUri = ?' LastSyncDate = ?' Configuration = ?' AnchorBlob = ? Where ScopeName = ?;" : "Insert into ScopeInfoTable (ServiceUri' LastSyncDate' Configuration' AnchorBlob' ScopeName) Values (?' ?' ?' ?' ?);";  		using (var stmt = connection.Prepare (stmtText)) {  			SQLiteHelper.BindParameter (stmt' 1' scopeInfoTable.ServiceUri);  			SQLiteHelper.BindParameter (stmt' 2' scopeInfoTable.LastSyncDate);  			SQLiteHelper.BindParameter (stmt' 3' scopeInfoTable.Configuration);  			SQLiteHelper.BindParameter (stmt' 4' scopeInfoTable.AnchorBlob);  			SQLiteHelper.BindParameter (stmt' 5' scopeInfoTable.ScopeName);  			stmt.Step ();  		}  	}  }  
Magic Number,Microsoft.Synchronization.ClientServices.SQLite,SQLiteManager,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteManager.cs,SaveConfiguration,The following statement contains a magic number: if (scopeTableExist) {  	String commandSelect = "Select * From ScopeInfoTable Where ScopeName = ?;";  	using (var stmtSelect = connection.Prepare (commandSelect)) {  		stmtSelect.Bind (1' configuration.ScopeName);  		var exist = stmtSelect.Step () == SQLiteResult.ROW;  		string stmtText = exist ? "Update ScopeInfoTable Set ServiceUri = ?' LastSyncDate = ?' Configuration = ?' AnchorBlob = ? Where ScopeName = ?;" : "Insert into ScopeInfoTable (ServiceUri' LastSyncDate' Configuration' AnchorBlob' ScopeName) Values (?' ?' ?' ?' ?);";  		using (var stmt = connection.Prepare (stmtText)) {  			SQLiteHelper.BindParameter (stmt' 1' scopeInfoTable.ServiceUri);  			SQLiteHelper.BindParameter (stmt' 2' scopeInfoTable.LastSyncDate);  			SQLiteHelper.BindParameter (stmt' 3' scopeInfoTable.Configuration);  			SQLiteHelper.BindParameter (stmt' 4' scopeInfoTable.AnchorBlob);  			SQLiteHelper.BindParameter (stmt' 5' scopeInfoTable.ScopeName);  			stmt.Step ();  		}  	}  }  
Magic Number,Microsoft.Synchronization.ClientServices.SQLite,SQLiteManager,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteManager.cs,SaveConfiguration,The following statement contains a magic number: if (scopeTableExist) {  	String commandSelect = "Select * From ScopeInfoTable Where ScopeName = ?;";  	using (var stmtSelect = connection.Prepare (commandSelect)) {  		stmtSelect.Bind (1' configuration.ScopeName);  		var exist = stmtSelect.Step () == SQLiteResult.ROW;  		string stmtText = exist ? "Update ScopeInfoTable Set ServiceUri = ?' LastSyncDate = ?' Configuration = ?' AnchorBlob = ? Where ScopeName = ?;" : "Insert into ScopeInfoTable (ServiceUri' LastSyncDate' Configuration' AnchorBlob' ScopeName) Values (?' ?' ?' ?' ?);";  		using (var stmt = connection.Prepare (stmtText)) {  			SQLiteHelper.BindParameter (stmt' 1' scopeInfoTable.ServiceUri);  			SQLiteHelper.BindParameter (stmt' 2' scopeInfoTable.LastSyncDate);  			SQLiteHelper.BindParameter (stmt' 3' scopeInfoTable.Configuration);  			SQLiteHelper.BindParameter (stmt' 4' scopeInfoTable.AnchorBlob);  			SQLiteHelper.BindParameter (stmt' 5' scopeInfoTable.ScopeName);  			stmt.Step ();  		}  	}  }  
Magic Number,Microsoft.Synchronization.ClientServices.SQLite,SQLiteManager,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteManager.cs,SaveConfiguration,The following statement contains a magic number: using (var stmtSelect = connection.Prepare (commandSelect)) {  	stmtSelect.Bind (1' configuration.ScopeName);  	var exist = stmtSelect.Step () == SQLiteResult.ROW;  	string stmtText = exist ? "Update ScopeInfoTable Set ServiceUri = ?' LastSyncDate = ?' Configuration = ?' AnchorBlob = ? Where ScopeName = ?;" : "Insert into ScopeInfoTable (ServiceUri' LastSyncDate' Configuration' AnchorBlob' ScopeName) Values (?' ?' ?' ?' ?);";  	using (var stmt = connection.Prepare (stmtText)) {  		SQLiteHelper.BindParameter (stmt' 1' scopeInfoTable.ServiceUri);  		SQLiteHelper.BindParameter (stmt' 2' scopeInfoTable.LastSyncDate);  		SQLiteHelper.BindParameter (stmt' 3' scopeInfoTable.Configuration);  		SQLiteHelper.BindParameter (stmt' 4' scopeInfoTable.AnchorBlob);  		SQLiteHelper.BindParameter (stmt' 5' scopeInfoTable.ScopeName);  		stmt.Step ();  	}  }  
Magic Number,Microsoft.Synchronization.ClientServices.SQLite,SQLiteManager,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteManager.cs,SaveConfiguration,The following statement contains a magic number: using (var stmtSelect = connection.Prepare (commandSelect)) {  	stmtSelect.Bind (1' configuration.ScopeName);  	var exist = stmtSelect.Step () == SQLiteResult.ROW;  	string stmtText = exist ? "Update ScopeInfoTable Set ServiceUri = ?' LastSyncDate = ?' Configuration = ?' AnchorBlob = ? Where ScopeName = ?;" : "Insert into ScopeInfoTable (ServiceUri' LastSyncDate' Configuration' AnchorBlob' ScopeName) Values (?' ?' ?' ?' ?);";  	using (var stmt = connection.Prepare (stmtText)) {  		SQLiteHelper.BindParameter (stmt' 1' scopeInfoTable.ServiceUri);  		SQLiteHelper.BindParameter (stmt' 2' scopeInfoTable.LastSyncDate);  		SQLiteHelper.BindParameter (stmt' 3' scopeInfoTable.Configuration);  		SQLiteHelper.BindParameter (stmt' 4' scopeInfoTable.AnchorBlob);  		SQLiteHelper.BindParameter (stmt' 5' scopeInfoTable.ScopeName);  		stmt.Step ();  	}  }  
Magic Number,Microsoft.Synchronization.ClientServices.SQLite,SQLiteManager,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteManager.cs,SaveConfiguration,The following statement contains a magic number: using (var stmtSelect = connection.Prepare (commandSelect)) {  	stmtSelect.Bind (1' configuration.ScopeName);  	var exist = stmtSelect.Step () == SQLiteResult.ROW;  	string stmtText = exist ? "Update ScopeInfoTable Set ServiceUri = ?' LastSyncDate = ?' Configuration = ?' AnchorBlob = ? Where ScopeName = ?;" : "Insert into ScopeInfoTable (ServiceUri' LastSyncDate' Configuration' AnchorBlob' ScopeName) Values (?' ?' ?' ?' ?);";  	using (var stmt = connection.Prepare (stmtText)) {  		SQLiteHelper.BindParameter (stmt' 1' scopeInfoTable.ServiceUri);  		SQLiteHelper.BindParameter (stmt' 2' scopeInfoTable.LastSyncDate);  		SQLiteHelper.BindParameter (stmt' 3' scopeInfoTable.Configuration);  		SQLiteHelper.BindParameter (stmt' 4' scopeInfoTable.AnchorBlob);  		SQLiteHelper.BindParameter (stmt' 5' scopeInfoTable.ScopeName);  		stmt.Step ();  	}  }  
Magic Number,Microsoft.Synchronization.ClientServices.SQLite,SQLiteManager,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteManager.cs,SaveConfiguration,The following statement contains a magic number: using (var stmtSelect = connection.Prepare (commandSelect)) {  	stmtSelect.Bind (1' configuration.ScopeName);  	var exist = stmtSelect.Step () == SQLiteResult.ROW;  	string stmtText = exist ? "Update ScopeInfoTable Set ServiceUri = ?' LastSyncDate = ?' Configuration = ?' AnchorBlob = ? Where ScopeName = ?;" : "Insert into ScopeInfoTable (ServiceUri' LastSyncDate' Configuration' AnchorBlob' ScopeName) Values (?' ?' ?' ?' ?);";  	using (var stmt = connection.Prepare (stmtText)) {  		SQLiteHelper.BindParameter (stmt' 1' scopeInfoTable.ServiceUri);  		SQLiteHelper.BindParameter (stmt' 2' scopeInfoTable.LastSyncDate);  		SQLiteHelper.BindParameter (stmt' 3' scopeInfoTable.Configuration);  		SQLiteHelper.BindParameter (stmt' 4' scopeInfoTable.AnchorBlob);  		SQLiteHelper.BindParameter (stmt' 5' scopeInfoTable.ScopeName);  		stmt.Step ();  	}  }  
Magic Number,Microsoft.Synchronization.ClientServices.SQLite,SQLiteManager,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteManager.cs,SaveConfiguration,The following statement contains a magic number: using (var stmt = connection.Prepare (stmtText)) {  	SQLiteHelper.BindParameter (stmt' 1' scopeInfoTable.ServiceUri);  	SQLiteHelper.BindParameter (stmt' 2' scopeInfoTable.LastSyncDate);  	SQLiteHelper.BindParameter (stmt' 3' scopeInfoTable.Configuration);  	SQLiteHelper.BindParameter (stmt' 4' scopeInfoTable.AnchorBlob);  	SQLiteHelper.BindParameter (stmt' 5' scopeInfoTable.ScopeName);  	stmt.Step ();  }  
Magic Number,Microsoft.Synchronization.ClientServices.SQLite,SQLiteManager,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteManager.cs,SaveConfiguration,The following statement contains a magic number: using (var stmt = connection.Prepare (stmtText)) {  	SQLiteHelper.BindParameter (stmt' 1' scopeInfoTable.ServiceUri);  	SQLiteHelper.BindParameter (stmt' 2' scopeInfoTable.LastSyncDate);  	SQLiteHelper.BindParameter (stmt' 3' scopeInfoTable.Configuration);  	SQLiteHelper.BindParameter (stmt' 4' scopeInfoTable.AnchorBlob);  	SQLiteHelper.BindParameter (stmt' 5' scopeInfoTable.ScopeName);  	stmt.Step ();  }  
Magic Number,Microsoft.Synchronization.ClientServices.SQLite,SQLiteManager,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteManager.cs,SaveConfiguration,The following statement contains a magic number: using (var stmt = connection.Prepare (stmtText)) {  	SQLiteHelper.BindParameter (stmt' 1' scopeInfoTable.ServiceUri);  	SQLiteHelper.BindParameter (stmt' 2' scopeInfoTable.LastSyncDate);  	SQLiteHelper.BindParameter (stmt' 3' scopeInfoTable.Configuration);  	SQLiteHelper.BindParameter (stmt' 4' scopeInfoTable.AnchorBlob);  	SQLiteHelper.BindParameter (stmt' 5' scopeInfoTable.ScopeName);  	stmt.Step ();  }  
Magic Number,Microsoft.Synchronization.ClientServices.SQLite,SQLiteManager,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteManager.cs,SaveConfiguration,The following statement contains a magic number: using (var stmt = connection.Prepare (stmtText)) {  	SQLiteHelper.BindParameter (stmt' 1' scopeInfoTable.ServiceUri);  	SQLiteHelper.BindParameter (stmt' 2' scopeInfoTable.LastSyncDate);  	SQLiteHelper.BindParameter (stmt' 3' scopeInfoTable.Configuration);  	SQLiteHelper.BindParameter (stmt' 4' scopeInfoTable.AnchorBlob);  	SQLiteHelper.BindParameter (stmt' 5' scopeInfoTable.ScopeName);  	stmt.Step ();  }  
Magic Number,Microsoft.Synchronization.ClientServices.SQLite,SQLiteManager,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteManager.cs,SaveConfiguration,The following statement contains a magic number: SQLiteHelper.BindParameter (stmt' 2' scopeInfoTable.LastSyncDate);  
Magic Number,Microsoft.Synchronization.ClientServices.SQLite,SQLiteManager,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteManager.cs,SaveConfiguration,The following statement contains a magic number: SQLiteHelper.BindParameter (stmt' 3' scopeInfoTable.Configuration);  
Magic Number,Microsoft.Synchronization.ClientServices.SQLite,SQLiteManager,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteManager.cs,SaveConfiguration,The following statement contains a magic number: SQLiteHelper.BindParameter (stmt' 4' scopeInfoTable.AnchorBlob);  
Magic Number,Microsoft.Synchronization.ClientServices.SQLite,SQLiteManager,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteManager.cs,SaveConfiguration,The following statement contains a magic number: SQLiteHelper.BindParameter (stmt' 5' scopeInfoTable.ScopeName);  
Missing Default,Microsoft.Synchronization.ClientServices,HttpCacheRequestHandler,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\ClientCommon\HttpCacheRequestHandlerAsync.cs,ReadUploadResponse,The following switch statement is missing a default case: switch (syncReader.ItemType) {  case ReaderItemType.Entry:  	IOfflineEntity entity = syncReader.GetItem ();  	IOfflineEntity ackedEntity = entity;  	string tempId = null;  	// If conflict only one temp ID should be set  	if (syncReader.HasTempId () && syncReader.HasConflictTempId ()) {  		throw new CacheControllerException (string.Format ("Service returned a TempId '{0}' in both live and conflicting entities."' syncReader.GetTempId ()));  	}  	// Validate the live temp ID if any' before adding anything to the offline context  	if (syncReader.HasTempId ()) {  		tempId = syncReader.GetTempId ();  		CheckEntityServiceMetadataAndTempIds (wrapper' entity' tempId);  	}  	//  If conflict   	if (syncReader.HasConflict ()) {  		Conflict conflict = syncReader.GetConflict ();  		IOfflineEntity conflictEntity = (conflict is SyncConflict) ? ((SyncConflict)conflict).LosingEntity : ((SyncError)conflict).ErrorEntity;  		// Validate conflict temp ID if any  		if (syncReader.HasConflictTempId ()) {  			tempId = syncReader.GetConflictTempId ();  			CheckEntityServiceMetadataAndTempIds (wrapper' conflictEntity' tempId);  		}  		// Add conflict                                      		wrapper.UploadResponse.AddConflict (conflict);  		//  		// If there is a conflict and the tempId is set in the conflict entity then the client version lost the   		// conflict and the live entity is the server version (ServerWins)  		//  		if (syncReader.HasConflictTempId () && entity.GetServiceMetadata ().IsTombstone) {  			//  			// This is a ServerWins conflict' or conflict error. The winning version is a tombstone without temp Id  			// so there is no way to map the winning entity with a temp Id. The temp Id is in the conflict so we are  			// using the conflict entity' which has the PK' to build a tombstone entity used to update the offline context  			//  			// In theory' we should copy the service metadata but it is the same end result as the service fills in  			// all the properties in the conflict entity  			//  			// Add the conflict entity                                                			conflictEntity.GetServiceMetadata ().IsTombstone = true;  			ackedEntity = conflictEntity;  		}  	}  	// Add ackedEntity to storage. If ackedEntity is still equal to entity then add non-conflict entity.   	if (!String.IsNullOrEmpty (tempId)) {  		wrapper.UploadResponse.AddUpdatedItem (ackedEntity);  	}  	break;  case ReaderItemType.SyncBlob:  	wrapper.UploadResponse.ServerBlob = syncReader.GetServerBlob ();  	break;  }  
Missing Default,Microsoft.Synchronization.ClientServices,HttpCacheRequestHandler,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\ClientCommon\HttpCacheRequestHandlerAsync.cs,ReadDownloadResponse,The following switch statement is missing a default case: switch (syncReader.ItemType) {  case ReaderItemType.Entry:  	wrapper.DownloadResponse.AddItem (syncReader.GetItem ());  	break;  case ReaderItemType.SyncBlob:  	wrapper.DownloadResponse.ServerBlob = syncReader.GetServerBlob ();  	// Debug.WriteLine(SyncBlob.DeSerialize(wrapper.DownloadResponse.ServerBlob).ToString());  	break;  case ReaderItemType.HasMoreChanges:  	wrapper.DownloadResponse.IsLastBatch = !syncReader.GetHasMoreChangesValue ();  	break;  }  
Missing Default,Microsoft.Synchronization.ClientServices,ValueHandle,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\ValueHandle.cs,ToBoolean,The following switch statement is missing a default case: switch (this.type) {  case ValueHandleType.False:  	return false;  case ValueHandleType.True:  	return true;  case ValueHandleType.UTF8:  	return XmlConverter.ToBoolean (this.bufferReader.Buffer' this.offset' this.length);  case ValueHandleType.Int8:  	switch (this.GetInt8 ()) {  	case 0:  		return false;  	case 1:  		return true;  	}  	break;  }  
Missing Default,Microsoft.Synchronization.ClientServices,ValueHandle,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\ValueHandle.cs,ToBoolean,The following switch statement is missing a default case: switch (this.GetInt8 ()) {  case 0:  	return false;  case 1:  	return true;  }  
Missing Default,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,ToBoolean,The following switch statement is missing a default case: switch (buffer [offset]) {  case Keys.One:  	return true;  case Keys.Zero:  	return false;  }  
Missing Default,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,IsStartElement,The following switch statement is missing a default case: switch (this.Node.NodeType) {  case XmlNodeType.Element:  	return true;  case XmlNodeType.EndElement:  	return false;  case XmlNodeType.None:  	this.Read ();  	if (this.Node.NodeType == XmlNodeType.Element)  		return true;  	break;  }  
Missing Default,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,Read,The following switch statement is missing a default case: switch (complexTextMode) {  case JsonComplexTextMode.QuotedText:  	if (ch == Keys.BackSlash) {  		ReadEscapedCharacter (true);  		break;  	}  	ReadQuotedText (true);  	break;  case JsonComplexTextMode.NumericalText:  	ReadNumericalText ();  	break;  case JsonComplexTextMode.None:  	throw new XmlException ("JsonEncounteredUnexpectedCharacter");  }  
Missing Default,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,UnescapeJsonString,The following switch statement is missing a default case: switch (val [index]) {  case 'n':  	stringBuilder.Append ('\n');  	break;  case 'r':  	stringBuilder.Append ('\r');  	break;  case 't':  	stringBuilder.Append ('\t');  	break;  case 'u':  	if (index + 3 >= val.Length)  		throw new XmlException ("JsonEncounteredUnexpectedCharacter");  	stringBuilder.Append (ParseChar (val.Substring (index + 1' 4)' NumberStyles.HexNumber));  	index += 4;  	break;  case 'b':  	stringBuilder.Append ('\b');  	break;  case 'f':  	stringBuilder.Append ('\f');  	break;  case '/':  case '\\':  case '"':  case '\'':  	stringBuilder.Append (val [index]);  	break;  }  
Missing Default,Microsoft.Synchronization.ClientServices,XmlJsonWriter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonWriter.cs,StartText,The following switch statement is missing a default case: switch (dataType) {  case JsonDataType.None:  case JsonDataType.String:  	CheckText (JsonNodeType.QuotedText);  	if (nodeType != JsonNodeType.QuotedText)  		WriteJsonQuote ();  	nodeType = JsonNodeType.QuotedText;  	break;  case JsonDataType.Boolean:  case JsonDataType.Number:  	CheckText (JsonNodeType.StandaloneText);  	nodeType = JsonNodeType.StandaloneText;  	break;  }  
Missing Default,Microsoft.Synchronization.ClientServices,XmlJsonWriter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonWriter.cs,WriteDataTypeServerType,The following switch statement is missing a default case: switch (dataType) {  case JsonDataType.Null:  	nodeWriter.Write ("null");  	break;  case JsonDataType.Object:  	EnterScope (JsonNodeType.Object);  	nodeWriter.Write ("{");  	break;  case JsonDataType.Array:  	EnterScope (JsonNodeType.Collection);  	nodeWriter.Write ("[");  	break;  }  
