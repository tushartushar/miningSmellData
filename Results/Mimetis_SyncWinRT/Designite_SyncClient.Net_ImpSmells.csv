Implementation smell,Namespace,Class,File,Method,Description
Long Method,Microsoft.Synchronization.ClientServices,HttpCacheRequestHandler,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\ClientCommon\HttpCacheRequestHandlerAsync.cs,ProcessRequest,The method has 137 lines of code.
Long Method,Microsoft.Synchronization.ClientServices,HttpCacheRequestHandler,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\ClientCommon\HttpCacheRequestHandlerAsync.cs,ReadUploadResponse,The method has 110 lines of code.
Long Method,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,TryParseDateTime,The method has 109 lines of code.
Long Method,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,Read,The method has 236 lines of code.
Long Method,Microsoft.Synchronization.ClientServices.SQLite,SQLiteHelper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteHelper.cs,MergeEntities,The method has 124 lines of code.
Complex Method,Microsoft.Synchronization.ClientServices,CacheController,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\ClientCommon\CacheControllerAsync.cs,SynchronizeAsync,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.Synchronization.ClientServices,CacheController,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\ClientCommon\CacheControllerAsync.cs,ProcessCacheRequestResults,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.Synchronization.ClientServices,HttpCacheRequestHandler,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\ClientCommon\HttpCacheRequestHandlerAsync.cs,ProcessRequest,Cyclomatic complexity of the method is 12
Complex Method,Microsoft.Synchronization.ClientServices,ValueHandle,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\ValueHandle.cs,ToInt,Cyclomatic complexity of the method is 11
Complex Method,Microsoft.Synchronization.ClientServices,ValueHandle,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\ValueHandle.cs,ToLong,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.Synchronization.ClientServices,ValueHandle,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\ValueHandle.cs,ToSingle,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.Synchronization.ClientServices,ValueHandle,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\ValueHandle.cs,TryReadChars,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Synchronization.ClientServices,XmlBufferReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlBufferReader.cs,TryEnsureBytes,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,ToString,Cyclomatic complexity of the method is 12
Complex Method,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,TryParseInt32,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,TryParseSingle,Cyclomatic complexity of the method is 12
Complex Method,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,TryParseDouble,Cyclomatic complexity of the method is 11
Complex Method,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,TryParseDateTime,Cyclomatic complexity of the method is 16
Complex Method,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,GetAttributeNode,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,ReadValueChunk,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,Read,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,UnescapeJsonString,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,ReadContentAs,Cyclomatic complexity of the method is 15
Complex Method,Microsoft.Synchronization.ClientServices,XmlJsonWriter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonWriter.cs,WriteStartAttribute,Cyclomatic complexity of the method is 12
Complex Method,Microsoft.Synchronization.ClientServices,XmlJsonWriter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonWriter.cs,WriteStartElement,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.Synchronization.Services.Formatters,JsonEntryInfoWrapper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonEntryInfoWrapper.cs,LoadTypeName,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.Synchronization.Services.Formatters,ReflectionUtility,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\ReflectionUtility.cs,GetValueFromType,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.Synchronization.ClientServices.SQLite,SQLiteHelper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteHelper.cs,ReadCol,Cyclomatic complexity of the method is 20
Complex Method,Microsoft.Synchronization.ClientServices.SQLite,Orm,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteManager.cs,SqlType,Cyclomatic complexity of the method is 11
Long Parameter List,Microsoft.Synchronization.ClientServices,CacheRequestResult,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\ClientCommon\CacheRequestResult.cs,CacheRequestResult,The method has 6 parameters. Parameters: id' response' uploadCount' error' step' state
Long Parameter List,Microsoft.Synchronization.ClientServices,CacheRequestResult,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\ClientCommon\CacheRequestResult.cs,CacheRequestResult,The method has 5 parameters. Parameters: id' changeSet' error' step' state
Long Parameter List,Microsoft.Synchronization.ClientServices,SyncProgressEvent,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\ClientCommon\SyncProgressEventArgs.cs,SyncProgressEvent,The method has 6 parameters. Parameters: stage' duration' isLastBatch' changes' conflicts' updatedItems
Long Parameter List,Microsoft.Synchronization.ClientServices,XmlBufferReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlBufferReader.cs,Equals2,The method has 5 parameters. Parameters: offset1' length1' bufferReader2' offset2' length2
Long Parameter List,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,ToChars,The method has 5 parameters. Parameters: buffer' offset' count' chars' charOffset
Long Parameter List,Microsoft.Synchronization.ClientServices,XmlNode,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlNode.cs,XmlNode,The method has 7 parameters. Parameters: nodeType' localName' value' nodeFlags' readState' attributeTextNode' depthDelta
Long Parameter List,Microsoft.Synchronization.ClientServices,XmlTextNode,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlNode.cs,XmlTextNode,The method has 7 parameters. Parameters: nodeType' localName' value' nodeFlags' readState' attributeTextNode' depthDelta
Long Parameter List,Microsoft.Synchronization.Services.Formatters,ODataAtomWriter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\ODataAtomWriter.cs,WriteItemInternal,The method has 7 parameters. Parameters: live' liveTempId' conflicting' conflictingTempId' desc' isConflict' emitMetadataOnly
Long Parameter List,Microsoft.Synchronization.Services.Formatters,ODataJsonWriter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\ODataJsonWriter.cs,WriteItemInternal,The method has 7 parameters. Parameters: live' liveTempId' conflicting' conflictingTempId' desc' isConflict' emitMetadataOnly
Long Parameter List,Microsoft.Synchronization.Services.Formatters,SyncWriter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\SyncWriter.cs,WriteItemInternal,The method has 7 parameters. Parameters: live' liveTempId' conflicting' conflictingTempId' desc' isConflict' emitMetadataOnly
Long Parameter List,Microsoft.Synchronization.ClientServices.SQLite,SQLiteContext,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteContext.cs,SQLiteContext,The method has 6 parameters. Parameters: schema' scopeName' databasePath' uri' cookieContainer' uploadBatchSize
Long Parameter List,Microsoft.Synchronization.ClientServices.SQLite,SQLiteContext,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteContext.cs,CheckSchemaAndUriAsync,The method has 5 parameters. Parameters: offlineSchema' uri' scope' cancellationToken' progress
Long Identifier,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,,The length of the parameter expectingFirstElementInNonPrimitiveChild is 40.
Long Identifier,Microsoft.Synchronization.Services.Formatters,FormatterConstants,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\FormatterConstants.cs,,The length of the parameter ErrorDescriptionElementNamePascalCasing is 39.
Long Identifier,Microsoft.Synchronization.Services.Formatters,FormatterConstants,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\FormatterConstants.cs,,The length of the parameter AtomDateTimeOffsetLexicalRepresentation is 39.
Long Identifier,Microsoft.Synchronization.Services.Formatters,FormatterConstants,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\FormatterConstants.cs,,The length of the parameter AtomDateTimeLexicalRepresentation is 33.
Long Identifier,Microsoft.Synchronization.Services.Formatters,FormatterConstants,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\FormatterConstants.cs,,The length of the parameter JsonSyncEntryMetadataElementName is 32.
Long Identifier,Microsoft.Synchronization.Services.Formatters,FormatterConstants,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\FormatterConstants.cs,,The length of the parameter JsonDateTimeOffsetLexicalRepresentation is 39.
Long Identifier,Microsoft.Synchronization.Services.Formatters,FormatterConstants,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\FormatterConstants.cs,,The length of the parameter JsonDateTimeLexicalRepresentation is 33.
Long Identifier,Microsoft.Synchronization.ClientServices.SQLite,SQLiteConstants,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteConstants.cs,,The length of the parameter SelectItemPrimaryKeyFromTrackingChangesWithOemID is 48.
Long Identifier,Microsoft.Synchronization.ClientServices.SQLite,SQLiteConstants,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteConstants.cs,,The length of the parameter InsertOrReplaceTrackingFromChanges is 34.
Long Identifier,Microsoft.Synchronization.ClientServices.SQLite,SQLiteHelper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteHelper.cs,MergeEntities,The length of the parameter querySelectItemPrimaryKeyFromTrackingChangesWithOemID is 53.
Long Statement,Microsoft.Synchronization.ClientServices,CacheController,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\ClientCommon\CacheControllerAsync.cs,EnqueueUploadRequest,The length of the statement  "                        progress.Report(new SyncProgressEvent(SyncStage.GetChanges' DateTime.Now.Subtract(durationStartDate)' true' (changeSet != null ? changeSet.Data : null))); " is 154.
Long Statement,Microsoft.Synchronization.ClientServices,CacheController,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\ClientCommon\CacheControllerAsync.cs,EnqueueDownloadRequest,The length of the statement  "                        progress.Report(new SyncProgressEvent(SyncStage.DownloadingChanges' DateTime.Now.Subtract(durationStartDate)' true' (requestResult.ChangeSet != null ? requestResult.ChangeSet.Data : null))); " is 190.
Long Statement,Microsoft.Synchronization.ClientServices,CacheController,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\ClientCommon\CacheControllerAsync.cs,ProcessCacheRequestResults,The length of the statement  "                if (cacheRequestResult.ChangeSet != null && cacheRequestResult.ChangeSet.Data != null && cacheRequestResult.ChangeSet.Data.Count > 0) " is 133.
Long Statement,Microsoft.Synchronization.ClientServices,ValueHandle,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\ValueHandle.cs,ToByteArray,The length of the statement  "            //            int bytes2 = ValueHandle.Base64Encoding.GetBytes(this.bufferReader.Buffer' this.offset' this.length' bytes1' 0); " is 126.
Long Statement,Microsoft.Synchronization.ClientServices,ValueHandle,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\ValueHandle.cs,ToByteArray,The length of the statement  "            //    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError((Exception)new XmlException(ex.Message' ex.InnerException)); " is 124.
Long Statement,Microsoft.Synchronization.ClientServices,ValueHandle,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\ValueHandle.cs,TryReadBase64,The length of the statement  "            //            actual = ValueHandle.Base64Encoding.GetBytes(this.bufferReader.Buffer' this.offset' charCount' buffer' offset); " is 125.
Long Statement,Microsoft.Synchronization.ClientServices,ValueHandle,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\ValueHandle.cs,TryReadChars,The length of the statement  "                // If we're asking for more than are possibly available' or more than are truly available then we can return the entire thing " is 125.
Long Statement,Microsoft.Synchronization.ClientServices,ValueHandle,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\ValueHandle.cs,TryReadChars,The length of the statement  "                if (charCount >= encoding.GetMaxCharCount(byteCount) || charCount >= encoding.GetCharCount(bytes' byteOffset' byteCount)) " is 121.
Long Statement,Microsoft.Synchronization.ClientServices,XmlBufferReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlBufferReader.cs,GetChars,The length of the statement  "                    return charOffset + XmlConverter.ToChars(currentBuffer' iOffset + charOffset' iLength - charOffset' iChars' charOffset); " is 120.
Long Statement,Microsoft.Synchronization.ClientServices,XmlBufferReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlBufferReader.cs,GetDecimal,The length of the statement  "            var int1 = numArray[0 + iOffset] | numArray[1 + iOffset] << 8 | numArray[2 + iOffset] << 16 | numArray[3 + iOffset] << 24; " is 122.
Long Statement,Microsoft.Synchronization.ClientServices,XmlBufferReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlBufferReader.cs,GetDecimal,The length of the statement  "            var int2 = numArray[4 + iOffset] | numArray[5 + iOffset] << 8 | numArray[6 + iOffset] << 16 | numArray[7 + iOffset] << 24; " is 122.
Long Statement,Microsoft.Synchronization.ClientServices,XmlBufferReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlBufferReader.cs,GetDecimal,The length of the statement  "            var int3 = numArray[8 + iOffset] | numArray[9 + iOffset] << 8 | numArray[10 + iOffset] << 16 | numArray[11 + iOffset] << 24; " is 124.
Long Statement,Microsoft.Synchronization.ClientServices,XmlBufferReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlBufferReader.cs,GetDecimal,The length of the statement  "            var int4 = numArray[12 + iOffset] | numArray[13 + iOffset] << 8 | numArray[14 + iOffset] << 16 | numArray[15 + iOffset] << 24; " is 126.
Long Statement,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,IsStartElement,The length of the statement  "            if (slocalName == null || namespaceUri == null || this.Node.NodeType != XmlNodeType.Element && !this.IsStartElement() || !(this.Node.LocalName == slocalName)) " is 158.
Long Statement,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,Read,The length of the statement  "                            if (TryGetByte(out ch) && !IsWhitespace(ch) && (ch != Keys.Comma && ch != Keys.RightClosingBrace) && ch != Keys.RightClosingBracket) " is 132.
Long Statement,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,Read,The length of the statement  "                            if (TryGetByte(out ch) && !IsWhitespace(ch) && (ch != Keys.Comma && ch != Keys.RightClosingBrace) && ch != Keys.RightClosingBracket) " is 132.
Long Statement,Microsoft.Synchronization.Services.Formatters,AtomEntryInfoWrapper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\AtomEntryInfoWrapper.cs,LoadConflictEntry,The length of the statement  "            XElement conflictElement = entry.Element(FormatterConstants.SyncNamespace + FormatterConstants.SyncConlflictElementName); " is 121.
Long Statement,Microsoft.Synchronization.Services.Formatters,AtomEntryInfoWrapper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\AtomEntryInfoWrapper.cs,LoadConflictEntry,The length of the statement  "                XElement resolutionType = conflictElement.Element(FormatterConstants.SyncNamespace + FormatterConstants.ConflictResolutionElementName); " is 135.
Long Statement,Microsoft.Synchronization.Services.Formatters,AtomEntryInfoWrapper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\AtomEntryInfoWrapper.cs,LoadConflictEntry,The length of the statement  "                XElement conflictingChangeElement = conflictElement.Element(FormatterConstants.SyncNamespace + FormatterConstants.ConflictEntryElementName); " is 140.
Long Statement,Microsoft.Synchronization.Services.Formatters,AtomEntryInfoWrapper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\AtomEntryInfoWrapper.cs,LoadConflictEntry,The length of the statement  "                XElement errorDesc = errorElement.Element(FormatterConstants.SyncNamespace + FormatterConstants.ErrorDescriptionElementName); " is 125.
Long Statement,Microsoft.Synchronization.Services.Formatters,AtomEntryInfoWrapper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\AtomEntryInfoWrapper.cs,LoadConflictEntry,The length of the statement  "                XElement errorChangeElement = errorElement.Element(FormatterConstants.SyncNamespace + FormatterConstants.ErrorEntryElementName); " is 128.
Long Statement,Microsoft.Synchronization.Services.Formatters,AtomEntryInfoWrapper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\AtomEntryInfoWrapper.cs,GetSubElement,The length of the statement  "            XElement element = entryElement.Element(FormatterConstants.AtomNamespaceUri + FormatterConstants.AtomPubEntryElementName); " is 122.
Long Statement,Microsoft.Synchronization.Services.Formatters,AtomEntryInfoWrapper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\AtomEntryInfoWrapper.cs,GetSubElement,The length of the statement  "                element = entryElement.Element(FormatterConstants.AtomDeletedEntryNamespace + FormatterConstants.AtomDeletedEntryElementName); " is 126.
Long Statement,Microsoft.Synchronization.Services.Formatters,AtomEntryInfoWrapper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\AtomEntryInfoWrapper.cs,LoadEntryProperties,The length of the statement  "                    throw new InvalidOperationException("A atom:ref element must be present for a tombstone entry. Entity in error: " + entry.ToString(SaveOptions.None)); " is 150.
Long Statement,Microsoft.Synchronization.Services.Formatters,AtomEntryInfoWrapper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\AtomEntryInfoWrapper.cs,LoadEntryProperties,The length of the statement  "                foreach (XElement linkElement in entry.Elements(FormatterConstants.AtomXmlNamespace + FormatterConstants.AtomPubLinkElementName)) " is 129.
Long Statement,Microsoft.Synchronization.Services.Formatters,AtomEntryInfoWrapper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\AtomEntryInfoWrapper.cs,LoadEntryProperties,The length of the statement  "                                throw new InvalidOperationException(string.Format(CultureInfo.InvariantCulture' "Multiple Edit Url's found for atom with {0}: '{1}'"' (this.Id == null) ? "TempId" : "Id"' (this.Id == null) ? this.TempId : this.Id)); " is 215.
Long Statement,Microsoft.Synchronization.Services.Formatters,AtomEntryInfoWrapper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\AtomEntryInfoWrapper.cs,LoadEntryProperties,The length of the statement  "                            XAttribute nullableAttr = property.Attribute(FormatterConstants.ODataMetadataNamespace + FormatterConstants.AtomPubIsNullElementName); " is 134.
Long Statement,Microsoft.Synchronization.Services.Formatters,AtomEntryInfoWrapper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\AtomEntryInfoWrapper.cs,LoadTypeName,The length of the statement  "                    string.Format(CultureInfo.InvariantCulture' "Category element not found in {0} element."' (isTombstone)? FormatterConstants.AtomDeletedEntryElementName : FormatterConstants.AtomPubEntryElementName)); " is 199.
Long Statement,Microsoft.Synchronization.Services.Formatters,FormatterUtilities,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\FormatterUtilities.cs,ParseDateTimeFromString,The length of the statement  "                throw new InvalidOperationException(string.Format(USCultureInfo' "Invalid Date/Time value received. Unable to parse value {0} to type {1}."' value' type.Name)); " is 160.
Long Statement,Microsoft.Synchronization.Services.Formatters,FormatterUtilities,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\FormatterUtilities.cs,ParseJsonString,The length of the statement  "                        throw new InvalidOperationException(string.Format("Invalid JSON DateTime value received. Value '{0}' is not a valid DateTime"' ticks)); " is 135.
Long Statement,Microsoft.Synchronization.Services.Formatters,FormatterUtilities,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\FormatterUtilities.cs,ParseJsonString,The length of the statement  "                    throw new InvalidOperationException(string.Format(USCultureInfo' @"Invalid Json DateTime value received. Value {0} is not in format '\/Date(ticks)\/'."' value)); " is 161.
Long Statement,Microsoft.Synchronization.Services.Formatters,FormatterUtilities,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\FormatterUtilities.cs,ParseJsonString,The length of the statement  "                    throw new InvalidOperationException(string.Format(USCultureInfo' @"Invalid Json DateTimeOffset value received. Value {0} is not in format 'datetimeoffset'yyyy-MM-ddTHH:mm:ss.fffffffzzz''."' value)); " is 198.
Long Statement,Microsoft.Synchronization.Services.Formatters,FormatterUtilities,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\FormatterUtilities.cs,ParseJsonString,The length of the statement  "                throw new InvalidOperationException(string.Format(USCultureInfo' @"Invalid Json TimeSpan value received. Value {0} is not in format 'time'HH:mm:ss''."' value)); " is 160.
Long Statement,Microsoft.Synchronization.Services.Formatters,JsonEntryInfoWrapper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonEntryInfoWrapper.cs,LoadEntryProperties,The length of the statement  "                if (!keyValuePair.Name.LocalName.Equals(FormatterConstants.JsonSyncEntryMetadataElementName' StringComparison.CurrentCultureIgnoreCase) && " is 138.
Long Statement,Microsoft.Synchronization.Services.Formatters,JsonEntryInfoWrapper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonEntryInfoWrapper.cs,LoadEntryProperties,The length of the statement  "                    !keyValuePair.Name.LocalName.Equals(FormatterConstants.IsDeletedElementName' StringComparison.CurrentCultureIgnoreCase)) " is 120.
Long Statement,Microsoft.Synchronization.Services.Formatters,JsonEntryInfoWrapper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonEntryInfoWrapper.cs,LoadTypeName,The length of the statement  "                    throw new InvalidOperationException("A uri or a tempId key must be present in the __metadata object. Entity in error: " + entry.ToString(SaveOptions.None)); " is 156.
Long Statement,Microsoft.Synchronization.Services.Formatters,ODataAtomWriter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\ODataAtomWriter.cs,StartFeed,The length of the statement  "                new XAttribute(XNamespace.Xmlns + FormatterConstants.AtomDeletedEntryPrefix' FormatterConstants.AtomDeletedEntryNamespace)' " is 123.
Long Statement,Microsoft.Synchronization.Services.Formatters,ODataAtomWriter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\ODataAtomWriter.cs,WriteItemInternal,The length of the statement  "                XElement conflictElement = new XElement(FormatterConstants.SyncNamespace + ((isConflict) ? FormatterConstants.SyncConlflictElementName : FormatterConstants.SyncErrorElementName)); " is 179.
Long Statement,Microsoft.Synchronization.Services.Formatters,ODataAtomWriter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\ODataAtomWriter.cs,WriteItemInternal,The length of the statement  "                conflictElement.Add(new XElement(FormatterConstants.SyncNamespace + ((isConflict) ? FormatterConstants.ConflictResolutionElementName : FormatterConstants.ErrorDescriptionElementName)' desc)); " is 191.
Long Statement,Microsoft.Synchronization.Services.Formatters,ODataAtomWriter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\ODataAtomWriter.cs,WriteItemInternal,The length of the statement  "                XElement conflictingEntryElement = new XElement(FormatterConstants.SyncNamespace + ((isConflict) ? FormatterConstants.ConflictEntryElementName : FormatterConstants.ErrorEntryElementName)); " is 188.
Long Statement,Microsoft.Synchronization.Services.Formatters,ODataAtomWriter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\ODataAtomWriter.cs,WriteEntry,The length of the statement  "                    entryElement.Add(new XAttribute(FormatterConstants.ODataMetadataNamespace + FormatterConstants.EtagElementName' live.GetServiceMetadata().ETag)); " is 145.
Long Statement,Microsoft.Synchronization.Services.Formatters,ODataAtomWriter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\ODataAtomWriter.cs,WriteEntry,The length of the statement  "                XElement contentElement = new XElement(FormatterConstants.AtomXmlNamespace + FormatterConstants.AtomPubContentElementName); " is 123.
Long Statement,Microsoft.Synchronization.Services.Formatters,ODataAtomWriter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\ODataAtomWriter.cs,WriteEntry,The length of the statement  "            XElement tombstoneElement = new XElement(FormatterConstants.AtomDeletedEntryNamespace + FormatterConstants.AtomDeletedEntryElementName); " is 136.
Long Statement,Microsoft.Synchronization.Services.Formatters,ODataAtomWriter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\ODataAtomWriter.cs,WriteEntry,The length of the statement  "            tombstoneElement.Add(new XElement(FormatterConstants.AtomNamespaceUri + FormatterConstants.AtomReferenceElementName' live.GetServiceMetadata().Id)); " is 148.
Long Statement,Microsoft.Synchronization.Services.Formatters,ODataAtomWriter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\ODataAtomWriter.cs,WriteEntry,The length of the statement  "            tombstoneElement.Add(new XElement(FormatterConstants.SyncNamespace + FormatterConstants.AtomPubCategoryElementName' typeName)); " is 127.
Long Statement,Microsoft.Synchronization.Services.Formatters,ODataAtomWriter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\ODataAtomWriter.cs,WriteEntityContents,The length of the statement  "            XElement contentElement = new XElement(FormatterConstants.ODataMetadataNamespace + FormatterConstants.PropertiesElementName); " is 125.
Long Statement,Microsoft.Synchronization.Services.Formatters,ODataAtomWriter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\ODataAtomWriter.cs,WriteEntityContents,The length of the statement  "                if(fi.PropertyType.IsGenericType() && fi.PropertyType.Name.Equals(FormatterConstants.NullableTypeName' StringComparison.CurrentCultureIgnoreCase)) " is 146.
Long Statement,Microsoft.Synchronization.Services.Formatters,ODataJsonWriter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\ODataJsonWriter.cs,StartFeed,The length of the statement  "                new XAttribute(FormatterConstants.JsonTypeAttributeName' (serverBlob != null) ? JsonElementTypes.String : JsonElementTypes.Object)' " is 131.
Long Statement,Microsoft.Synchronization.Services.Formatters,ODataJsonWriter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\ODataJsonWriter.cs,WriteItemInternal,The length of the statement  "                XElement conflictElement = new XElement(((isConflict) ? FormatterConstants.JsonSyncConflictElementName : FormatterConstants.JsonSyncErrorElementName)' " is 150.
Long Statement,Microsoft.Synchronization.Services.Formatters,ODataJsonWriter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\ODataJsonWriter.cs,WriteItemInternal,The length of the statement  "                conflictElement.Add(new XElement(((isConflict) ? FormatterConstants.ConflictResolutionElementName : FormatterConstants.ErrorDescriptionElementName)' " is 148.
Long Statement,Microsoft.Synchronization.Services.Formatters,ODataJsonWriter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\ODataJsonWriter.cs,WriteItemInternal,The length of the statement  "                XElement conflictingEntryElement = new XElement(((isConflict) ? FormatterConstants.ConflictEntryElementName : FormatterConstants.ErrorEntryElementName)' " is 152.
Long Statement,Microsoft.Synchronization.Services.Formatters,ODataJsonWriter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\ODataJsonWriter.cs,WriteEntityContentsToElement,The length of the statement  "                else if (fi.PropertyType.IsGenericType() && fi.PropertyType.Name.Equals(FormatterConstants.NullableTypeName' StringComparison.CurrentCultureIgnoreCase)) " is 152.
Long Statement,Microsoft.Synchronization.Services.Formatters,ReflectionUtility,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\ReflectionUtility.cs,GetPropertyInfoMapping,The length of the statement  "                                throw new InvalidOperationException(string.Format("Entity {0} does not have the any property marked with the [DataAnnotations.KeyAttribute]. or [SQLite.PrimaryKeyAttribute]"' type.Name)); " is 187.
Long Statement,Microsoft.Synchronization.Services.Formatters,ReflectionUtility,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\ReflectionUtility.cs,GetPropertyInfoMapping,The length of the statement  "                            throw new InvalidOperationException(string.Format("Type {0} does not have a public parameterless constructor."' type.FullName)); " is 128.
Long Statement,Microsoft.Synchronization.Services.Formatters,ReflectionUtility,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\ReflectionUtility.cs,GetObjectForType,The length of the statement  "                    entityType = knownTypes.FirstOrDefault(e => e.FullName.Equals(wrapper.TypeName' StringComparison.CurrentCultureIgnoreCase)); " is 124.
Long Statement,Microsoft.Synchronization.Services.Formatters,ReflectionUtility,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\ReflectionUtility.cs,GetObjectForType,The length of the statement  "                        throw new InvalidOperationException(string.Format(CultureInfo.InvariantCulture' "Unable to find a matching type for entry '{0}' in list of KnownTypes."' wrapper.TypeName)); " is 172.
Long Statement,Microsoft.Synchronization.Services.Formatters,ReflectionUtility,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\ReflectionUtility.cs,GetObjectForType,The length of the statement  "                    throw new InvalidOperationException(string.Format("Unable to find a matching type for entry '{0}' in the loaded assemblies. Specify the type name in the KnownTypes argument to the SyncReader instance."' wrapper.TypeName)); " is 222.
Long Statement,Microsoft.Synchronization.Services.Formatters,SyncWriter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\SyncWriter.cs,AddItem,The length of the statement  "            WriteItemInternal(entry' tempId' null /*conflicting*/' null/*conflictingTempId*/' null /*desc*/' false /*isconflict*/' emitMetadataOnly); " is 137.
Long Statement,Microsoft.Synchronization.ClientServices.SQLite,SQLiteContext,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteContext.cs,OnChangeSetUploaded,The length of the statement  "                        // This approach assumes that there are not duplicates between the conflicts and the updated entities (there shouldn't be) " is 122.
Long Statement,Microsoft.Synchronization.ClientServices.SQLite,SQLiteHelper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteHelper.cs,MergeEntities,The length of the statement  "                var queryUpdate = String.Format(SQLiteConstants.UpdateOrIgnoreFromChanges' map.TableName' declValuePairsStr' map.GetPrimaryKeysWhereClause); " is 140.
Long Statement,Microsoft.Synchronization.ClientServices.SQLite,SQLiteHelper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteHelper.cs,MergeEntities,The length of the statement  "                var queryUpdateTracking = String.Format(SQLiteConstants.InsertOrReplaceTrackingFromChanges' map.TableName' declTracking' declValuesTracking); " is 141.
Long Statement,Microsoft.Synchronization.ClientServices.SQLite,SQLiteHelper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteHelper.cs,MergeEntities,The length of the statement  "                var queryDeleteTracking = String.Format(SQLiteConstants.DeleteTrackingFromChanges' map.TableName' map.GetPrimaryKeysWhereClause); " is 129.
Long Statement,Microsoft.Synchronization.ClientServices.SQLite,SQLiteManager,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteManager.cs,SaveConfiguration,The length of the statement  "                            : "Insert into ScopeInfoTable (ServiceUri' LastSyncDate' Configuration' AnchorBlob' ScopeName) Values (?' ?' ?' ?' ?);"; " is 120.
Long Statement,Microsoft.Synchronization.ClientServices.SQLite,Orm,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteManager.cs,SqlType,The length of the statement  "            if (clrType == typeof(Boolean) || clrType == typeof(Byte) || clrType == typeof(UInt16) || clrType == typeof(SByte) || clrType == typeof(Int16) || clrType == typeof(Int32)) " is 171.
Complex Conditional,Microsoft.Synchronization.ClientServices,ValueHandle,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\ValueHandle.cs,ToSingle,The conditional expression  "(value >= Single.MinValue && value <= Single.MaxValue) || double.IsInfinity(value) || double.IsNaN(value)"  is complex.
Complex Conditional,Microsoft.Synchronization.ClientServices,XmlBufferReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlBufferReader.cs,GetQuoteCharEntity,The conditional expression  "length != 6 ||                  iBuffer[offset + 1] != (byte)'q' ||                  iBuffer[offset + 2] != (byte)'u' ||                  iBuffer[offset + 3] != (byte)'o' ||                  iBuffer[offset + 4] != (byte)'t'"  is complex.
Complex Conditional,Microsoft.Synchronization.ClientServices,XmlBufferReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlBufferReader.cs,GetAmpersandCharEntity,The conditional expression  "length != 5 ||                  iBuffer[offset + 1] != (byte)'a' ||                  iBuffer[offset + 2] != (byte)'m' ||                  iBuffer[offset + 3] != (byte)'p'"  is complex.
Complex Conditional,Microsoft.Synchronization.ClientServices,XmlBufferReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlBufferReader.cs,GetApostropheCharEntity,The conditional expression  "length != 6 ||                  iBuffer[offset + 1] != (byte)'a' ||                  iBuffer[offset + 2] != (byte)'p' ||                  iBuffer[offset + 3] != (byte)'o' ||                  iBuffer[offset + 4] != (byte)'s'"  is complex.
Complex Conditional,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,TryParseDateTime,The conditional expression  "chars[offset + 4] != '-' || chars[offset + 7] != '-' || chars[offset + 10] != 'T' ||                  chars[offset + 13] != ':' || chars[offset + 16] != ':'"  is complex.
Complex Conditional,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,TryParseDateTime,The conditional expression  "hourDelta >= 0 && (value < DateTime.MaxValue - ts) ||                          hourDelta < 0 && (value > DateTime.MinValue - ts)"  is complex.
Complex Conditional,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,ComputeNumericalTextLength,The conditional expression  "ch == Keys.Comma || ch == Keys.RightClosingBrace || ch == Keys.RightClosingBracket || IsWhitespace(ch)"  is complex.
Complex Conditional,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,IsStartElement,The conditional expression  "slocalName == null || namespaceUri == null || this.Node.NodeType != XmlNodeType.Element && !this.IsStartElement() || !(this.Node.LocalName == slocalName)"  is complex.
Complex Conditional,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,Read,The conditional expression  "buffer[offset + 1] != Keys.LowerA                                  || buffer[offset + 2] != Keys.LowerL                                  || buffer[offset + 3] != Keys.LowerS                                  || buffer[offset + 4] != Keys.LowerE"  is complex.
Complex Conditional,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,Read,The conditional expression  "TryGetByte(out ch) && !IsWhitespace(ch) && (ch != Keys.Comma && ch != Keys.RightClosingBrace) && ch != Keys.RightClosingBracket"  is complex.
Complex Conditional,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,Read,The conditional expression  "TryGetByte(out ch) && !IsWhitespace(ch) && (ch != Keys.Comma && ch != Keys.RightClosingBrace) && ch != Keys.RightClosingBracket"  is complex.
Complex Conditional,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,Read,The conditional expression  "(ch == (byte)'-')                              || (((byte)'0' <= ch) && (ch <= (byte)'9'))                              || (ch == (byte)'I')                              || (ch == (byte)'N')"  is complex.
Complex Conditional,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,ReadAttributes,The conditional expression  "nextByte == '-' ||                          (nextByte <= '9' && nextByte >= '0') ||                          nextByte == 'N' ||                          nextByte == 'I'"  is complex.
Complex Conditional,Microsoft.Synchronization.ClientServices,XmlJsonWriter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonWriter.cs,CharacterNeedsEscaping,The conditional expression  "ch == Keys.SlashForward || ch == Keys.DoubleQuote || ch < Keys.Space || ch == Keys.BackSlash"  is complex.
Complex Conditional,Microsoft.Synchronization.ClientServices.SQLite,Orm,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteManager.cs,SqlType,The conditional expression  "clrType == typeof(Boolean) || clrType == typeof(Byte) || clrType == typeof(UInt16) || clrType == typeof(SByte) || clrType == typeof(Int16) || clrType == typeof(Int32)"  is complex.
Virtual Method Call from Constructor,Microsoft.Synchronization.Services.Formatters,EntryInfoWrapper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\EntryInfoWrapper.cs,EntryInfoWrapper,The constructor "EntryInfoWrapper" calls a virtual method "LoadTypeName".
Virtual Method Call from Constructor,Microsoft.Synchronization.Services.Formatters,EntryInfoWrapper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\EntryInfoWrapper.cs,EntryInfoWrapper,The constructor "EntryInfoWrapper" calls a virtual method "LoadEntryProperties".
Virtual Method Call from Constructor,Microsoft.Synchronization.Services.Formatters,EntryInfoWrapper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\EntryInfoWrapper.cs,EntryInfoWrapper,The constructor "EntryInfoWrapper" calls a virtual method "LoadConflictEntry".
Magic Number,Microsoft.Synchronization.ClientServices,ValueHandle,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\ValueHandle.cs,TryReadUnicodeChars,The following statement contains a magic number: int charCount = Math.Min(count' this.length / 2);
Magic Number,Microsoft.Synchronization.ClientServices,ValueHandle,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\ValueHandle.cs,TryReadUnicodeChars,The following statement contains a magic number: for (int index = 0; index < charCount; ++index)                  chars[iOffset + index] = (char)this.bufferReader.GetInt16(this.offset + index * 2);
Magic Number,Microsoft.Synchronization.ClientServices,ValueHandle,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\ValueHandle.cs,TryReadUnicodeChars,The following statement contains a magic number: this.offset += charCount * 2;
Magic Number,Microsoft.Synchronization.ClientServices,ValueHandle,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\ValueHandle.cs,TryReadUnicodeChars,The following statement contains a magic number: this.length -= charCount * 2;
Magic Number,Microsoft.Synchronization.ClientServices,XmlBufferReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlBufferReader.cs,Close,The following statement contains a magic number: if (streamBuffer != null && streamBuffer.Length > 4096)                  streamBuffer = null;
Magic Number,Microsoft.Synchronization.ClientServices,XmlBufferReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlBufferReader.cs,TryEnsureBytes,The following statement contains a magic number: if (newOffsetMax > buffer.Length)              {                  var numBuffer = new byte[Math.Max(newOffsetMax' buffer.Length * 2)];                  System.Buffer.BlockCopy(buffer' 0' numBuffer' 0' offsetMax);                  buffer = numBuffer;                  streamBuffer = numBuffer;              }
Magic Number,Microsoft.Synchronization.ClientServices,XmlBufferReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlBufferReader.cs,ReadMultiByteUInt31,The following statement contains a magic number: int num4 = num2 | (j & sbyte.MaxValue) << 7;
Magic Number,Microsoft.Synchronization.ClientServices,XmlBufferReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlBufferReader.cs,ReadMultiByteUInt31,The following statement contains a magic number: int num6 = num4 | (k & sbyte.MaxValue) << 14;
Magic Number,Microsoft.Synchronization.ClientServices,XmlBufferReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlBufferReader.cs,ReadMultiByteUInt31,The following statement contains a magic number: int num8 = num6 | (l & sbyte.MaxValue) << 21;
Magic Number,Microsoft.Synchronization.ClientServices,XmlBufferReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlBufferReader.cs,ReadMultiByteUInt31,The following statement contains a magic number: int num10 = num8 | m << 28;
Magic Number,Microsoft.Synchronization.ClientServices,XmlBufferReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlBufferReader.cs,ReadMultiByteUInt31,The following statement contains a magic number: if ((m & 248) != 0)                  throw new Exception("XmlExceptionHelper.ThrowInvalidBinaryFormat(this.reader);");
Magic Number,Microsoft.Synchronization.ClientServices,XmlBufferReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlBufferReader.cs,ReadUInt16,The following statement contains a magic number: byte[] currentBuffer = GetBuffer(2' out currentOffset);
Magic Number,Microsoft.Synchronization.ClientServices,XmlBufferReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlBufferReader.cs,ReadUInt16,The following statement contains a magic number: int num = currentBuffer[currentOffset] + (currentBuffer[currentOffset + 1] << 8);
Magic Number,Microsoft.Synchronization.ClientServices,XmlBufferReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlBufferReader.cs,ReadUInt16,The following statement contains a magic number: Advance(2);
Magic Number,Microsoft.Synchronization.ClientServices,XmlBufferReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlBufferReader.cs,ReadInt32,The following statement contains a magic number: byte[] currentBuffer = GetBuffer(4' out currentOffset);
Magic Number,Microsoft.Synchronization.ClientServices,XmlBufferReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlBufferReader.cs,ReadInt32,The following statement contains a magic number: byte b3 = currentBuffer[currentOffset + 2];
Magic Number,Microsoft.Synchronization.ClientServices,XmlBufferReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlBufferReader.cs,ReadInt32,The following statement contains a magic number: byte b4 = currentBuffer[currentOffset + 3];
Magic Number,Microsoft.Synchronization.ClientServices,XmlBufferReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlBufferReader.cs,ReadInt32,The following statement contains a magic number: Advance(4);
Magic Number,Microsoft.Synchronization.ClientServices,XmlBufferReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlBufferReader.cs,ReadInt32,The following statement contains a magic number: return (((b4 << 8) + b3 << 8) + b2 << 8) + b1;
Magic Number,Microsoft.Synchronization.ClientServices,XmlBufferReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlBufferReader.cs,ReadInt32,The following statement contains a magic number: return (((b4 << 8) + b3 << 8) + b2 << 8) + b1;
Magic Number,Microsoft.Synchronization.ClientServices,XmlBufferReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlBufferReader.cs,ReadInt32,The following statement contains a magic number: return (((b4 << 8) + b3 << 8) + b2 << 8) + b1;
Magic Number,Microsoft.Synchronization.ClientServices,XmlBufferReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlBufferReader.cs,ReadInt64,The following statement contains a magic number: return (hi << 32) + lo;
Magic Number,Microsoft.Synchronization.ClientServices,XmlBufferReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlBufferReader.cs,ReadUniqueId,The following statement contains a magic number: var b = GetBuffer(16' out currentOffset);
Magic Number,Microsoft.Synchronization.ClientServices,XmlBufferReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlBufferReader.cs,ReadUniqueId,The following statement contains a magic number: Advance(16);
Magic Number,Microsoft.Synchronization.ClientServices,XmlBufferReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlBufferReader.cs,ReadGuid,The following statement contains a magic number: GetBuffer(16' out currentOffset);
Magic Number,Microsoft.Synchronization.ClientServices,XmlBufferReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlBufferReader.cs,ReadGuid,The following statement contains a magic number: Advance(16);
Magic Number,Microsoft.Synchronization.ClientServices,XmlBufferReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlBufferReader.cs,GetCharBuffer,The following statement contains a magic number: if (count > 1024)                  return new char[count];
Magic Number,Microsoft.Synchronization.ClientServices,XmlBufferReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlBufferReader.cs,GetCharEntity,The following statement contains a magic number: if (length < 3)                  throw new Exception(" XmlExceptionHelper.ThrowInvalidCharRef(this.reader);");
Magic Number,Microsoft.Synchronization.ClientServices,XmlBufferReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlBufferReader.cs,GetCharEntity,The following statement contains a magic number: switch (buffer[offset + 1])              {                  case Keys.LowerA:                      // if it's an "&amp;"                      if (numArray[iOffset + 2] == Keys.LowerM)                          return GetAmpersandCharEntity(iOffset' length);                        return GetApostropheCharEntity(iOffset' length);                  case Keys.Diese:                      if (numArray[iOffset + 2] == Keys.LowerX)                          return GetHexCharEntity(iOffset' length);                      return GetDecimalCharEntity(iOffset' length);                  case Keys.LowerG:                      return GetGreaterThanCharEntity(length);                  case Keys.LowerL:                      return GetLessThanCharEntity(iOffset' length);                  case Keys.LowerQ:                      return GetQuoteCharEntity(iOffset' length);                  default:                      throw new Exception("XmlExceptionHelper.ThrowInvalidCharRef(this.reader);");              }
Magic Number,Microsoft.Synchronization.ClientServices,XmlBufferReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlBufferReader.cs,GetCharEntity,The following statement contains a magic number: switch (buffer[offset + 1])              {                  case Keys.LowerA:                      // if it's an "&amp;"                      if (numArray[iOffset + 2] == Keys.LowerM)                          return GetAmpersandCharEntity(iOffset' length);                        return GetApostropheCharEntity(iOffset' length);                  case Keys.Diese:                      if (numArray[iOffset + 2] == Keys.LowerX)                          return GetHexCharEntity(iOffset' length);                      return GetDecimalCharEntity(iOffset' length);                  case Keys.LowerG:                      return GetGreaterThanCharEntity(length);                  case Keys.LowerL:                      return GetLessThanCharEntity(iOffset' length);                  case Keys.LowerQ:                      return GetQuoteCharEntity(iOffset' length);                  default:                      throw new Exception("XmlExceptionHelper.ThrowInvalidCharRef(this.reader);");              }
Magic Number,Microsoft.Synchronization.ClientServices,XmlBufferReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlBufferReader.cs,GetLessThanCharEntity,The following statement contains a magic number: if (length != 4 ||                  iBuffer[offset + 1] != (byte)'l' ||                  iBuffer[offset + 2] != (byte)'t')                    throw new Exception("XmlExceptionHelper.ThrowInvalidCharRef(this.reader);");
Magic Number,Microsoft.Synchronization.ClientServices,XmlBufferReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlBufferReader.cs,GetLessThanCharEntity,The following statement contains a magic number: if (length != 4 ||                  iBuffer[offset + 1] != (byte)'l' ||                  iBuffer[offset + 2] != (byte)'t')                    throw new Exception("XmlExceptionHelper.ThrowInvalidCharRef(this.reader);");
Magic Number,Microsoft.Synchronization.ClientServices,XmlBufferReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlBufferReader.cs,GetGreaterThanCharEntity,The following statement contains a magic number: if (length != 4 ||                  iBuffer[offset + 1] != (byte)'g' ||                  iBuffer[offset + 2] != (byte)'t')                    throw new Exception("XmlExceptionHelper.ThrowInvalidCharRef(this.reader);");
Magic Number,Microsoft.Synchronization.ClientServices,XmlBufferReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlBufferReader.cs,GetGreaterThanCharEntity,The following statement contains a magic number: if (length != 4 ||                  iBuffer[offset + 1] != (byte)'g' ||                  iBuffer[offset + 2] != (byte)'t')                    throw new Exception("XmlExceptionHelper.ThrowInvalidCharRef(this.reader);");
Magic Number,Microsoft.Synchronization.ClientServices,XmlBufferReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlBufferReader.cs,GetQuoteCharEntity,The following statement contains a magic number: if (length != 6 ||                  iBuffer[offset + 1] != (byte)'q' ||                  iBuffer[offset + 2] != (byte)'u' ||                  iBuffer[offset + 3] != (byte)'o' ||                  iBuffer[offset + 4] != (byte)'t')                    throw new Exception("XmlExceptionHelper.ThrowInvalidCharRef(this.reader);");
Magic Number,Microsoft.Synchronization.ClientServices,XmlBufferReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlBufferReader.cs,GetQuoteCharEntity,The following statement contains a magic number: if (length != 6 ||                  iBuffer[offset + 1] != (byte)'q' ||                  iBuffer[offset + 2] != (byte)'u' ||                  iBuffer[offset + 3] != (byte)'o' ||                  iBuffer[offset + 4] != (byte)'t')                    throw new Exception("XmlExceptionHelper.ThrowInvalidCharRef(this.reader);");
Magic Number,Microsoft.Synchronization.ClientServices,XmlBufferReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlBufferReader.cs,GetQuoteCharEntity,The following statement contains a magic number: if (length != 6 ||                  iBuffer[offset + 1] != (byte)'q' ||                  iBuffer[offset + 2] != (byte)'u' ||                  iBuffer[offset + 3] != (byte)'o' ||                  iBuffer[offset + 4] != (byte)'t')                    throw new Exception("XmlExceptionHelper.ThrowInvalidCharRef(this.reader);");
Magic Number,Microsoft.Synchronization.ClientServices,XmlBufferReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlBufferReader.cs,GetQuoteCharEntity,The following statement contains a magic number: if (length != 6 ||                  iBuffer[offset + 1] != (byte)'q' ||                  iBuffer[offset + 2] != (byte)'u' ||                  iBuffer[offset + 3] != (byte)'o' ||                  iBuffer[offset + 4] != (byte)'t')                    throw new Exception("XmlExceptionHelper.ThrowInvalidCharRef(this.reader);");
Magic Number,Microsoft.Synchronization.ClientServices,XmlBufferReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlBufferReader.cs,GetAmpersandCharEntity,The following statement contains a magic number: if (length != 5 ||                  iBuffer[offset + 1] != (byte)'a' ||                  iBuffer[offset + 2] != (byte)'m' ||                  iBuffer[offset + 3] != (byte)'p')                    throw new Exception("XmlExceptionHelper.ThrowInvalidCharRef(this.reader);");
Magic Number,Microsoft.Synchronization.ClientServices,XmlBufferReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlBufferReader.cs,GetAmpersandCharEntity,The following statement contains a magic number: if (length != 5 ||                  iBuffer[offset + 1] != (byte)'a' ||                  iBuffer[offset + 2] != (byte)'m' ||                  iBuffer[offset + 3] != (byte)'p')                    throw new Exception("XmlExceptionHelper.ThrowInvalidCharRef(this.reader);");
Magic Number,Microsoft.Synchronization.ClientServices,XmlBufferReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlBufferReader.cs,GetAmpersandCharEntity,The following statement contains a magic number: if (length != 5 ||                  iBuffer[offset + 1] != (byte)'a' ||                  iBuffer[offset + 2] != (byte)'m' ||                  iBuffer[offset + 3] != (byte)'p')                    throw new Exception("XmlExceptionHelper.ThrowInvalidCharRef(this.reader);");
Magic Number,Microsoft.Synchronization.ClientServices,XmlBufferReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlBufferReader.cs,GetApostropheCharEntity,The following statement contains a magic number: if (length != 6 ||                  iBuffer[offset + 1] != (byte)'a' ||                  iBuffer[offset + 2] != (byte)'p' ||                  iBuffer[offset + 3] != (byte)'o' ||                  iBuffer[offset + 4] != (byte)'s')                    throw new Exception("XmlExceptionHelper.ThrowInvalidCharRef(this.reader);");
Magic Number,Microsoft.Synchronization.ClientServices,XmlBufferReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlBufferReader.cs,GetApostropheCharEntity,The following statement contains a magic number: if (length != 6 ||                  iBuffer[offset + 1] != (byte)'a' ||                  iBuffer[offset + 2] != (byte)'p' ||                  iBuffer[offset + 3] != (byte)'o' ||                  iBuffer[offset + 4] != (byte)'s')                    throw new Exception("XmlExceptionHelper.ThrowInvalidCharRef(this.reader);");
Magic Number,Microsoft.Synchronization.ClientServices,XmlBufferReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlBufferReader.cs,GetApostropheCharEntity,The following statement contains a magic number: if (length != 6 ||                  iBuffer[offset + 1] != (byte)'a' ||                  iBuffer[offset + 2] != (byte)'p' ||                  iBuffer[offset + 3] != (byte)'o' ||                  iBuffer[offset + 4] != (byte)'s')                    throw new Exception("XmlExceptionHelper.ThrowInvalidCharRef(this.reader);");
Magic Number,Microsoft.Synchronization.ClientServices,XmlBufferReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlBufferReader.cs,GetApostropheCharEntity,The following statement contains a magic number: if (length != 6 ||                  iBuffer[offset + 1] != (byte)'a' ||                  iBuffer[offset + 2] != (byte)'p' ||                  iBuffer[offset + 3] != (byte)'o' ||                  iBuffer[offset + 4] != (byte)'s')                    throw new Exception("XmlExceptionHelper.ThrowInvalidCharRef(this.reader);");
Magic Number,Microsoft.Synchronization.ClientServices,XmlBufferReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlBufferReader.cs,GetDecimalCharEntity,The following statement contains a magic number: for (int i = 2; i < length - 1; i++)              {                    byte ch = iBuffer[offset + i];                    if (ch < (byte)'0' || ch > (byte)'9')                      throw new Exception("XmlExceptionHelper.ThrowInvalidCharRef(this.reader);");                    value = value * 10 + (ch - '0');                    if (value > 1114111)                      throw new Exception("XmlExceptionHelper.ThrowInvalidCharRef(this.reader);");                }
Magic Number,Microsoft.Synchronization.ClientServices,XmlBufferReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlBufferReader.cs,GetDecimalCharEntity,The following statement contains a magic number: for (int i = 2; i < length - 1; i++)              {                    byte ch = iBuffer[offset + i];                    if (ch < (byte)'0' || ch > (byte)'9')                      throw new Exception("XmlExceptionHelper.ThrowInvalidCharRef(this.reader);");                    value = value * 10 + (ch - '0');                    if (value > 1114111)                      throw new Exception("XmlExceptionHelper.ThrowInvalidCharRef(this.reader);");                }
Magic Number,Microsoft.Synchronization.ClientServices,XmlBufferReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlBufferReader.cs,GetDecimalCharEntity,The following statement contains a magic number: for (int i = 2; i < length - 1; i++)              {                    byte ch = iBuffer[offset + i];                    if (ch < (byte)'0' || ch > (byte)'9')                      throw new Exception("XmlExceptionHelper.ThrowInvalidCharRef(this.reader);");                    value = value * 10 + (ch - '0');                    if (value > 1114111)                      throw new Exception("XmlExceptionHelper.ThrowInvalidCharRef(this.reader);");                }
Magic Number,Microsoft.Synchronization.ClientServices,XmlBufferReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlBufferReader.cs,GetDecimal,The following statement contains a magic number: var int1 = numArray[0 + iOffset] | numArray[1 + iOffset] << 8 | numArray[2 + iOffset] << 16 | numArray[3 + iOffset] << 24;
Magic Number,Microsoft.Synchronization.ClientServices,XmlBufferReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlBufferReader.cs,GetDecimal,The following statement contains a magic number: var int1 = numArray[0 + iOffset] | numArray[1 + iOffset] << 8 | numArray[2 + iOffset] << 16 | numArray[3 + iOffset] << 24;
Magic Number,Microsoft.Synchronization.ClientServices,XmlBufferReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlBufferReader.cs,GetDecimal,The following statement contains a magic number: var int1 = numArray[0 + iOffset] | numArray[1 + iOffset] << 8 | numArray[2 + iOffset] << 16 | numArray[3 + iOffset] << 24;
Magic Number,Microsoft.Synchronization.ClientServices,XmlBufferReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlBufferReader.cs,GetDecimal,The following statement contains a magic number: var int1 = numArray[0 + iOffset] | numArray[1 + iOffset] << 8 | numArray[2 + iOffset] << 16 | numArray[3 + iOffset] << 24;
Magic Number,Microsoft.Synchronization.ClientServices,XmlBufferReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlBufferReader.cs,GetDecimal,The following statement contains a magic number: var int1 = numArray[0 + iOffset] | numArray[1 + iOffset] << 8 | numArray[2 + iOffset] << 16 | numArray[3 + iOffset] << 24;
Magic Number,Microsoft.Synchronization.ClientServices,XmlBufferReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlBufferReader.cs,GetDecimal,The following statement contains a magic number: var int2 = numArray[4 + iOffset] | numArray[5 + iOffset] << 8 | numArray[6 + iOffset] << 16 | numArray[7 + iOffset] << 24;
Magic Number,Microsoft.Synchronization.ClientServices,XmlBufferReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlBufferReader.cs,GetDecimal,The following statement contains a magic number: var int2 = numArray[4 + iOffset] | numArray[5 + iOffset] << 8 | numArray[6 + iOffset] << 16 | numArray[7 + iOffset] << 24;
Magic Number,Microsoft.Synchronization.ClientServices,XmlBufferReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlBufferReader.cs,GetDecimal,The following statement contains a magic number: var int2 = numArray[4 + iOffset] | numArray[5 + iOffset] << 8 | numArray[6 + iOffset] << 16 | numArray[7 + iOffset] << 24;
Magic Number,Microsoft.Synchronization.ClientServices,XmlBufferReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlBufferReader.cs,GetDecimal,The following statement contains a magic number: var int2 = numArray[4 + iOffset] | numArray[5 + iOffset] << 8 | numArray[6 + iOffset] << 16 | numArray[7 + iOffset] << 24;
Magic Number,Microsoft.Synchronization.ClientServices,XmlBufferReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlBufferReader.cs,GetDecimal,The following statement contains a magic number: var int2 = numArray[4 + iOffset] | numArray[5 + iOffset] << 8 | numArray[6 + iOffset] << 16 | numArray[7 + iOffset] << 24;
Magic Number,Microsoft.Synchronization.ClientServices,XmlBufferReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlBufferReader.cs,GetDecimal,The following statement contains a magic number: var int2 = numArray[4 + iOffset] | numArray[5 + iOffset] << 8 | numArray[6 + iOffset] << 16 | numArray[7 + iOffset] << 24;
Magic Number,Microsoft.Synchronization.ClientServices,XmlBufferReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlBufferReader.cs,GetDecimal,The following statement contains a magic number: var int2 = numArray[4 + iOffset] | numArray[5 + iOffset] << 8 | numArray[6 + iOffset] << 16 | numArray[7 + iOffset] << 24;
Magic Number,Microsoft.Synchronization.ClientServices,XmlBufferReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlBufferReader.cs,GetDecimal,The following statement contains a magic number: var int3 = numArray[8 + iOffset] | numArray[9 + iOffset] << 8 | numArray[10 + iOffset] << 16 | numArray[11 + iOffset] << 24;
Magic Number,Microsoft.Synchronization.ClientServices,XmlBufferReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlBufferReader.cs,GetDecimal,The following statement contains a magic number: var int3 = numArray[8 + iOffset] | numArray[9 + iOffset] << 8 | numArray[10 + iOffset] << 16 | numArray[11 + iOffset] << 24;
Magic Number,Microsoft.Synchronization.ClientServices,XmlBufferReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlBufferReader.cs,GetDecimal,The following statement contains a magic number: var int3 = numArray[8 + iOffset] | numArray[9 + iOffset] << 8 | numArray[10 + iOffset] << 16 | numArray[11 + iOffset] << 24;
Magic Number,Microsoft.Synchronization.ClientServices,XmlBufferReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlBufferReader.cs,GetDecimal,The following statement contains a magic number: var int3 = numArray[8 + iOffset] | numArray[9 + iOffset] << 8 | numArray[10 + iOffset] << 16 | numArray[11 + iOffset] << 24;
Magic Number,Microsoft.Synchronization.ClientServices,XmlBufferReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlBufferReader.cs,GetDecimal,The following statement contains a magic number: var int3 = numArray[8 + iOffset] | numArray[9 + iOffset] << 8 | numArray[10 + iOffset] << 16 | numArray[11 + iOffset] << 24;
Magic Number,Microsoft.Synchronization.ClientServices,XmlBufferReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlBufferReader.cs,GetDecimal,The following statement contains a magic number: var int3 = numArray[8 + iOffset] | numArray[9 + iOffset] << 8 | numArray[10 + iOffset] << 16 | numArray[11 + iOffset] << 24;
Magic Number,Microsoft.Synchronization.ClientServices,XmlBufferReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlBufferReader.cs,GetDecimal,The following statement contains a magic number: var int3 = numArray[8 + iOffset] | numArray[9 + iOffset] << 8 | numArray[10 + iOffset] << 16 | numArray[11 + iOffset] << 24;
Magic Number,Microsoft.Synchronization.ClientServices,XmlBufferReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlBufferReader.cs,GetDecimal,The following statement contains a magic number: var int4 = numArray[12 + iOffset] | numArray[13 + iOffset] << 8 | numArray[14 + iOffset] << 16 | numArray[15 + iOffset] << 24;
Magic Number,Microsoft.Synchronization.ClientServices,XmlBufferReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlBufferReader.cs,GetDecimal,The following statement contains a magic number: var int4 = numArray[12 + iOffset] | numArray[13 + iOffset] << 8 | numArray[14 + iOffset] << 16 | numArray[15 + iOffset] << 24;
Magic Number,Microsoft.Synchronization.ClientServices,XmlBufferReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlBufferReader.cs,GetDecimal,The following statement contains a magic number: var int4 = numArray[12 + iOffset] | numArray[13 + iOffset] << 8 | numArray[14 + iOffset] << 16 | numArray[15 + iOffset] << 24;
Magic Number,Microsoft.Synchronization.ClientServices,XmlBufferReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlBufferReader.cs,GetDecimal,The following statement contains a magic number: var int4 = numArray[12 + iOffset] | numArray[13 + iOffset] << 8 | numArray[14 + iOffset] << 16 | numArray[15 + iOffset] << 24;
Magic Number,Microsoft.Synchronization.ClientServices,XmlBufferReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlBufferReader.cs,GetDecimal,The following statement contains a magic number: var int4 = numArray[12 + iOffset] | numArray[13 + iOffset] << 8 | numArray[14 + iOffset] << 16 | numArray[15 + iOffset] << 24;
Magic Number,Microsoft.Synchronization.ClientServices,XmlBufferReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlBufferReader.cs,GetDecimal,The following statement contains a magic number: var int4 = numArray[12 + iOffset] | numArray[13 + iOffset] << 8 | numArray[14 + iOffset] << 16 | numArray[15 + iOffset] << 24;
Magic Number,Microsoft.Synchronization.ClientServices,XmlBufferReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlBufferReader.cs,GetDecimal,The following statement contains a magic number: var int4 = numArray[12 + iOffset] | numArray[13 + iOffset] << 8 | numArray[14 + iOffset] << 16 | numArray[15 + iOffset] << 24;
Magic Number,Microsoft.Synchronization.ClientServices,XmlBufferReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlBufferReader.cs,GetHexCharEntity,The following statement contains a magic number: for (int i = 3; i < length - 1; i++)              {                  byte ch = iBuffer[offset + i];                    int digit;                    if (ch >= '0' && ch <= '9')                      digit = (ch - '0');                  else if (ch >= 'a' && ch <= 'f')                      digit = 10 + (ch - 'a');                  else if (ch >= 'A' && ch <= 'F')                      digit = 10 + (ch - 'A');                  else                      throw new Exception(" XmlExceptionHelper.ThrowInvalidCharRef(this.reader);");                    value = value * 16 + digit;                    if (value > 1114111)                      throw new Exception(" XmlExceptionHelper.ThrowInvalidCharRef(this.reader);");              }
Magic Number,Microsoft.Synchronization.ClientServices,XmlBufferReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlBufferReader.cs,GetHexCharEntity,The following statement contains a magic number: for (int i = 3; i < length - 1; i++)              {                  byte ch = iBuffer[offset + i];                    int digit;                    if (ch >= '0' && ch <= '9')                      digit = (ch - '0');                  else if (ch >= 'a' && ch <= 'f')                      digit = 10 + (ch - 'a');                  else if (ch >= 'A' && ch <= 'F')                      digit = 10 + (ch - 'A');                  else                      throw new Exception(" XmlExceptionHelper.ThrowInvalidCharRef(this.reader);");                    value = value * 16 + digit;                    if (value > 1114111)                      throw new Exception(" XmlExceptionHelper.ThrowInvalidCharRef(this.reader);");              }
Magic Number,Microsoft.Synchronization.ClientServices,XmlBufferReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlBufferReader.cs,GetHexCharEntity,The following statement contains a magic number: for (int i = 3; i < length - 1; i++)              {                  byte ch = iBuffer[offset + i];                    int digit;                    if (ch >= '0' && ch <= '9')                      digit = (ch - '0');                  else if (ch >= 'a' && ch <= 'f')                      digit = 10 + (ch - 'a');                  else if (ch >= 'A' && ch <= 'F')                      digit = 10 + (ch - 'A');                  else                      throw new Exception(" XmlExceptionHelper.ThrowInvalidCharRef(this.reader);");                    value = value * 16 + digit;                    if (value > 1114111)                      throw new Exception(" XmlExceptionHelper.ThrowInvalidCharRef(this.reader);");              }
Magic Number,Microsoft.Synchronization.ClientServices,XmlBufferReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlBufferReader.cs,GetHexCharEntity,The following statement contains a magic number: for (int i = 3; i < length - 1; i++)              {                  byte ch = iBuffer[offset + i];                    int digit;                    if (ch >= '0' && ch <= '9')                      digit = (ch - '0');                  else if (ch >= 'a' && ch <= 'f')                      digit = 10 + (ch - 'a');                  else if (ch >= 'A' && ch <= 'F')                      digit = 10 + (ch - 'A');                  else                      throw new Exception(" XmlExceptionHelper.ThrowInvalidCharRef(this.reader);");                    value = value * 16 + digit;                    if (value > 1114111)                      throw new Exception(" XmlExceptionHelper.ThrowInvalidCharRef(this.reader);");              }
Magic Number,Microsoft.Synchronization.ClientServices,XmlBufferReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlBufferReader.cs,GetHexCharEntity,The following statement contains a magic number: for (int i = 3; i < length - 1; i++)              {                  byte ch = iBuffer[offset + i];                    int digit;                    if (ch >= '0' && ch <= '9')                      digit = (ch - '0');                  else if (ch >= 'a' && ch <= 'f')                      digit = 10 + (ch - 'a');                  else if (ch >= 'A' && ch <= 'F')                      digit = 10 + (ch - 'A');                  else                      throw new Exception(" XmlExceptionHelper.ThrowInvalidCharRef(this.reader);");                    value = value * 16 + digit;                    if (value > 1114111)                      throw new Exception(" XmlExceptionHelper.ThrowInvalidCharRef(this.reader);");              }
Magic Number,Microsoft.Synchronization.ClientServices,XmlBufferReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlBufferReader.cs,GetInt16,The following statement contains a magic number: return (short)(numArray[iOffset] + (numArray[iOffset + 1] << 8));
Magic Number,Microsoft.Synchronization.ClientServices,XmlBufferReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlBufferReader.cs,GetGuid,The following statement contains a magic number: if (guid == null)                  guid = new byte[16];
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,ToString,The following statement contains a magic number: var numArray = new byte[64];
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,TryParseInt32,The following statement contains a magic number: if (chars[offset] == '-')              {                  if (count == 1)                      return false;                    for (int i = offset + 1; i < offsetMax; i++)                  {                      int digit = (chars[i] - '0');                        if ((uint)digit > 9)                          return false;                        if (value < int.MinValue / 10)                          return false;                        value *= 10;                      if (value < int.MinValue + digit)                          return false;                        value -= digit;                  }              }              else              {                    for (int i = offset; i < offsetMax; i++)                  {                      int digit = (chars[i] - '0');                        if ((uint)digit > 9)                          return false;                        if (value > int.MaxValue / 10)                          return false;                        value *= 10;                        if (value > int.MaxValue - digit)                          return false;                        value += digit;                  }              }
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,TryParseInt32,The following statement contains a magic number: if (chars[offset] == '-')              {                  if (count == 1)                      return false;                    for (int i = offset + 1; i < offsetMax; i++)                  {                      int digit = (chars[i] - '0');                        if ((uint)digit > 9)                          return false;                        if (value < int.MinValue / 10)                          return false;                        value *= 10;                      if (value < int.MinValue + digit)                          return false;                        value -= digit;                  }              }              else              {                    for (int i = offset; i < offsetMax; i++)                  {                      int digit = (chars[i] - '0');                        if ((uint)digit > 9)                          return false;                        if (value > int.MaxValue / 10)                          return false;                        value *= 10;                        if (value > int.MaxValue - digit)                          return false;                        value += digit;                  }              }
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,TryParseInt32,The following statement contains a magic number: if (chars[offset] == '-')              {                  if (count == 1)                      return false;                    for (int i = offset + 1; i < offsetMax; i++)                  {                      int digit = (chars[i] - '0');                        if ((uint)digit > 9)                          return false;                        if (value < int.MinValue / 10)                          return false;                        value *= 10;                      if (value < int.MinValue + digit)                          return false;                        value -= digit;                  }              }              else              {                    for (int i = offset; i < offsetMax; i++)                  {                      int digit = (chars[i] - '0');                        if ((uint)digit > 9)                          return false;                        if (value > int.MaxValue / 10)                          return false;                        value *= 10;                        if (value > int.MaxValue - digit)                          return false;                        value += digit;                  }              }
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,TryParseInt32,The following statement contains a magic number: if (chars[offset] == '-')              {                  if (count == 1)                      return false;                    for (int i = offset + 1; i < offsetMax; i++)                  {                      int digit = (chars[i] - '0');                        if ((uint)digit > 9)                          return false;                        if (value < int.MinValue / 10)                          return false;                        value *= 10;                      if (value < int.MinValue + digit)                          return false;                        value -= digit;                  }              }              else              {                    for (int i = offset; i < offsetMax; i++)                  {                      int digit = (chars[i] - '0');                        if ((uint)digit > 9)                          return false;                        if (value > int.MaxValue / 10)                          return false;                        value *= 10;                        if (value > int.MaxValue - digit)                          return false;                        value += digit;                  }              }
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,TryParseInt32,The following statement contains a magic number: if (chars[offset] == '-')              {                  if (count == 1)                      return false;                    for (int i = offset + 1; i < offsetMax; i++)                  {                      int digit = (chars[i] - '0');                        if ((uint)digit > 9)                          return false;                        if (value < int.MinValue / 10)                          return false;                        value *= 10;                      if (value < int.MinValue + digit)                          return false;                        value -= digit;                  }              }              else              {                    for (int i = offset; i < offsetMax; i++)                  {                      int digit = (chars[i] - '0');                        if ((uint)digit > 9)                          return false;                        if (value > int.MaxValue / 10)                          return false;                        value *= 10;                        if (value > int.MaxValue - digit)                          return false;                        value += digit;                  }              }
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,TryParseInt32,The following statement contains a magic number: if (chars[offset] == '-')              {                  if (count == 1)                      return false;                    for (int i = offset + 1; i < offsetMax; i++)                  {                      int digit = (chars[i] - '0');                        if ((uint)digit > 9)                          return false;                        if (value < int.MinValue / 10)                          return false;                        value *= 10;                      if (value < int.MinValue + digit)                          return false;                        value -= digit;                  }              }              else              {                    for (int i = offset; i < offsetMax; i++)                  {                      int digit = (chars[i] - '0');                        if ((uint)digit > 9)                          return false;                        if (value > int.MaxValue / 10)                          return false;                        value *= 10;                        if (value > int.MaxValue - digit)                          return false;                        value += digit;                  }              }
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,TryParseInt64,The following statement contains a magic number: if (count < 11)              {                  int value;                    if (!TryParseInt32(chars' offset' count' out value))                      return false;                    result = value;                  return true;              }              else              {                  long value = 0;                  int offsetMax = offset + count;                    if (chars[offset] == '-')                  {                      if (count == 1)                          return false;                        for (int i = offset + 1; i < offsetMax; i++)                      {                          int digit = (chars[i] - '0');                            if ((uint)digit > 9)                              return false;                            if (value < long.MinValue / 10)                              return false;                            value *= 10;                            if (value < long.MinValue + digit)                              return false;                            value -= digit;                      }                  }                  else                  {                      for (int i = offset; i < offsetMax; i++)                      {                          int digit = (chars[i] - '0');                            if ((uint)digit > 9)                              return false;                            if (value > long.MaxValue / 10)                              return false;                            value *= 10;                            if (value > long.MaxValue - digit)                              return false;                            value += digit;                      }                  }                    result = value;                  return true;                }
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,TryParseInt64,The following statement contains a magic number: if (count < 11)              {                  int value;                    if (!TryParseInt32(chars' offset' count' out value))                      return false;                    result = value;                  return true;              }              else              {                  long value = 0;                  int offsetMax = offset + count;                    if (chars[offset] == '-')                  {                      if (count == 1)                          return false;                        for (int i = offset + 1; i < offsetMax; i++)                      {                          int digit = (chars[i] - '0');                            if ((uint)digit > 9)                              return false;                            if (value < long.MinValue / 10)                              return false;                            value *= 10;                            if (value < long.MinValue + digit)                              return false;                            value -= digit;                      }                  }                  else                  {                      for (int i = offset; i < offsetMax; i++)                      {                          int digit = (chars[i] - '0');                            if ((uint)digit > 9)                              return false;                            if (value > long.MaxValue / 10)                              return false;                            value *= 10;                            if (value > long.MaxValue - digit)                              return false;                            value += digit;                      }                  }                    result = value;                  return true;                }
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,TryParseInt64,The following statement contains a magic number: if (count < 11)              {                  int value;                    if (!TryParseInt32(chars' offset' count' out value))                      return false;                    result = value;                  return true;              }              else              {                  long value = 0;                  int offsetMax = offset + count;                    if (chars[offset] == '-')                  {                      if (count == 1)                          return false;                        for (int i = offset + 1; i < offsetMax; i++)                      {                          int digit = (chars[i] - '0');                            if ((uint)digit > 9)                              return false;                            if (value < long.MinValue / 10)                              return false;                            value *= 10;                            if (value < long.MinValue + digit)                              return false;                            value -= digit;                      }                  }                  else                  {                      for (int i = offset; i < offsetMax; i++)                      {                          int digit = (chars[i] - '0');                            if ((uint)digit > 9)                              return false;                            if (value > long.MaxValue / 10)                              return false;                            value *= 10;                            if (value > long.MaxValue - digit)                              return false;                            value += digit;                      }                  }                    result = value;                  return true;                }
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,TryParseInt64,The following statement contains a magic number: if (count < 11)              {                  int value;                    if (!TryParseInt32(chars' offset' count' out value))                      return false;                    result = value;                  return true;              }              else              {                  long value = 0;                  int offsetMax = offset + count;                    if (chars[offset] == '-')                  {                      if (count == 1)                          return false;                        for (int i = offset + 1; i < offsetMax; i++)                      {                          int digit = (chars[i] - '0');                            if ((uint)digit > 9)                              return false;                            if (value < long.MinValue / 10)                              return false;                            value *= 10;                            if (value < long.MinValue + digit)                              return false;                            value -= digit;                      }                  }                  else                  {                      for (int i = offset; i < offsetMax; i++)                      {                          int digit = (chars[i] - '0');                            if ((uint)digit > 9)                              return false;                            if (value > long.MaxValue / 10)                              return false;                            value *= 10;                            if (value > long.MaxValue - digit)                              return false;                            value += digit;                      }                  }                    result = value;                  return true;                }
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,TryParseInt64,The following statement contains a magic number: if (count < 11)              {                  int value;                    if (!TryParseInt32(chars' offset' count' out value))                      return false;                    result = value;                  return true;              }              else              {                  long value = 0;                  int offsetMax = offset + count;                    if (chars[offset] == '-')                  {                      if (count == 1)                          return false;                        for (int i = offset + 1; i < offsetMax; i++)                      {                          int digit = (chars[i] - '0');                            if ((uint)digit > 9)                              return false;                            if (value < long.MinValue / 10)                              return false;                            value *= 10;                            if (value < long.MinValue + digit)                              return false;                            value -= digit;                      }                  }                  else                  {                      for (int i = offset; i < offsetMax; i++)                      {                          int digit = (chars[i] - '0');                            if ((uint)digit > 9)                              return false;                            if (value > long.MaxValue / 10)                              return false;                            value *= 10;                            if (value > long.MaxValue - digit)                              return false;                            value += digit;                      }                  }                    result = value;                  return true;                }
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,TryParseInt64,The following statement contains a magic number: if (count < 11)              {                  int value;                    if (!TryParseInt32(chars' offset' count' out value))                      return false;                    result = value;                  return true;              }              else              {                  long value = 0;                  int offsetMax = offset + count;                    if (chars[offset] == '-')                  {                      if (count == 1)                          return false;                        for (int i = offset + 1; i < offsetMax; i++)                      {                          int digit = (chars[i] - '0');                            if ((uint)digit > 9)                              return false;                            if (value < long.MinValue / 10)                              return false;                            value *= 10;                            if (value < long.MinValue + digit)                              return false;                            value -= digit;                      }                  }                  else                  {                      for (int i = offset; i < offsetMax; i++)                      {                          int digit = (chars[i] - '0');                            if ((uint)digit > 9)                              return false;                            if (value > long.MaxValue / 10)                              return false;                            value *= 10;                            if (value > long.MaxValue - digit)                              return false;                            value += digit;                      }                  }                    result = value;                  return true;                }
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,TryParseInt64,The following statement contains a magic number: if (count < 11)              {                  int value;                    if (!TryParseInt32(chars' offset' count' out value))                      return false;                    result = value;                  return true;              }              else              {                  long value = 0;                  int offsetMax = offset + count;                    if (chars[offset] == '-')                  {                      if (count == 1)                          return false;                        for (int i = offset + 1; i < offsetMax; i++)                      {                          int digit = (chars[i] - '0');                            if ((uint)digit > 9)                              return false;                            if (value < long.MinValue / 10)                              return false;                            value *= 10;                            if (value < long.MinValue + digit)                              return false;                            value -= digit;                      }                  }                  else                  {                      for (int i = offset; i < offsetMax; i++)                      {                          int digit = (chars[i] - '0');                            if ((uint)digit > 9)                              return false;                            if (value > long.MaxValue / 10)                              return false;                            value *= 10;                            if (value > long.MaxValue - digit)                              return false;                            value += digit;                      }                  }                    result = value;                  return true;                }
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,TryParseSingle,The following statement contains a magic number: if (count < 1 || count > 10)                  return false;
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,TryParseSingle,The following statement contains a magic number: while (offset < offsetMax)              {                  int ch = (chars[offset] - '0');                    if (ch == ('.' - '0'))                  {                      offset++;                      int pow10 = 1;                        while (offset < offsetMax)                      {                          ch = chars[offset] - '0';                            if (((uint)ch) >= 10)                              return false;                            pow10 *= 10;                          value = value * 10 + ch;                          offset++;                        }                        // More than 8 characters (7 sig figs and a decimal) and int -> float conversion is lossy' so use double                       if (count > 8)                          result = (float) (value/(double) pow10);                      else                          result = (float) value/pow10;                        if (negative)                          result = -result;                        return true;                    }                  if (((uint)ch) >= 10)                      return false;                    value = value * 10 + ch;                  offset++;                }
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,TryParseSingle,The following statement contains a magic number: while (offset < offsetMax)              {                  int ch = (chars[offset] - '0');                    if (ch == ('.' - '0'))                  {                      offset++;                      int pow10 = 1;                        while (offset < offsetMax)                      {                          ch = chars[offset] - '0';                            if (((uint)ch) >= 10)                              return false;                            pow10 *= 10;                          value = value * 10 + ch;                          offset++;                        }                        // More than 8 characters (7 sig figs and a decimal) and int -> float conversion is lossy' so use double                       if (count > 8)                          result = (float) (value/(double) pow10);                      else                          result = (float) value/pow10;                        if (negative)                          result = -result;                        return true;                    }                  if (((uint)ch) >= 10)                      return false;                    value = value * 10 + ch;                  offset++;                }
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,TryParseSingle,The following statement contains a magic number: while (offset < offsetMax)              {                  int ch = (chars[offset] - '0');                    if (ch == ('.' - '0'))                  {                      offset++;                      int pow10 = 1;                        while (offset < offsetMax)                      {                          ch = chars[offset] - '0';                            if (((uint)ch) >= 10)                              return false;                            pow10 *= 10;                          value = value * 10 + ch;                          offset++;                        }                        // More than 8 characters (7 sig figs and a decimal) and int -> float conversion is lossy' so use double                       if (count > 8)                          result = (float) (value/(double) pow10);                      else                          result = (float) value/pow10;                        if (negative)                          result = -result;                        return true;                    }                  if (((uint)ch) >= 10)                      return false;                    value = value * 10 + ch;                  offset++;                }
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,TryParseSingle,The following statement contains a magic number: while (offset < offsetMax)              {                  int ch = (chars[offset] - '0');                    if (ch == ('.' - '0'))                  {                      offset++;                      int pow10 = 1;                        while (offset < offsetMax)                      {                          ch = chars[offset] - '0';                            if (((uint)ch) >= 10)                              return false;                            pow10 *= 10;                          value = value * 10 + ch;                          offset++;                        }                        // More than 8 characters (7 sig figs and a decimal) and int -> float conversion is lossy' so use double                       if (count > 8)                          result = (float) (value/(double) pow10);                      else                          result = (float) value/pow10;                        if (negative)                          result = -result;                        return true;                    }                  if (((uint)ch) >= 10)                      return false;                    value = value * 10 + ch;                  offset++;                }
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,TryParseSingle,The following statement contains a magic number: while (offset < offsetMax)              {                  int ch = (chars[offset] - '0');                    if (ch == ('.' - '0'))                  {                      offset++;                      int pow10 = 1;                        while (offset < offsetMax)                      {                          ch = chars[offset] - '0';                            if (((uint)ch) >= 10)                              return false;                            pow10 *= 10;                          value = value * 10 + ch;                          offset++;                        }                        // More than 8 characters (7 sig figs and a decimal) and int -> float conversion is lossy' so use double                       if (count > 8)                          result = (float) (value/(double) pow10);                      else                          result = (float) value/pow10;                        if (negative)                          result = -result;                        return true;                    }                  if (((uint)ch) >= 10)                      return false;                    value = value * 10 + ch;                  offset++;                }
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,TryParseSingle,The following statement contains a magic number: while (offset < offsetMax)              {                  int ch = (chars[offset] - '0');                    if (ch == ('.' - '0'))                  {                      offset++;                      int pow10 = 1;                        while (offset < offsetMax)                      {                          ch = chars[offset] - '0';                            if (((uint)ch) >= 10)                              return false;                            pow10 *= 10;                          value = value * 10 + ch;                          offset++;                        }                        // More than 8 characters (7 sig figs and a decimal) and int -> float conversion is lossy' so use double                       if (count > 8)                          result = (float) (value/(double) pow10);                      else                          result = (float) value/pow10;                        if (negative)                          result = -result;                        return true;                    }                  if (((uint)ch) >= 10)                      return false;                    value = value * 10 + ch;                  offset++;                }
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,TryParseSingle,The following statement contains a magic number: if (count == 10)                  return false;
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,TryParseDouble,The following statement contains a magic number: if (count < 1 || count > 10)                  return false;
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,TryParseDouble,The following statement contains a magic number: while (offset < offsetMax)              {                  int ch = (chars[offset] - '0');                    if (ch == ('.' - '0'))                  {                      offset++;                      int pow10 = 1;                      while (offset < offsetMax)                      {                          ch = chars[offset] - '0';                            if (((uint)ch) >= 10)                              return false;                            pow10 *= 10;                          value = value * 10 + ch;                          offset++;                      }                        if (negative)                          result = -(double)value / pow10;                      else                          result = (double)value / pow10;                        return true;                  }                    if (((uint)ch) >= 10)                      return false;                    value = value * 10 + ch;                  offset++;                }
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,TryParseDouble,The following statement contains a magic number: while (offset < offsetMax)              {                  int ch = (chars[offset] - '0');                    if (ch == ('.' - '0'))                  {                      offset++;                      int pow10 = 1;                      while (offset < offsetMax)                      {                          ch = chars[offset] - '0';                            if (((uint)ch) >= 10)                              return false;                            pow10 *= 10;                          value = value * 10 + ch;                          offset++;                      }                        if (negative)                          result = -(double)value / pow10;                      else                          result = (double)value / pow10;                        return true;                  }                    if (((uint)ch) >= 10)                      return false;                    value = value * 10 + ch;                  offset++;                }
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,TryParseDouble,The following statement contains a magic number: while (offset < offsetMax)              {                  int ch = (chars[offset] - '0');                    if (ch == ('.' - '0'))                  {                      offset++;                      int pow10 = 1;                      while (offset < offsetMax)                      {                          ch = chars[offset] - '0';                            if (((uint)ch) >= 10)                              return false;                            pow10 *= 10;                          value = value * 10 + ch;                          offset++;                      }                        if (negative)                          result = -(double)value / pow10;                      else                          result = (double)value / pow10;                        return true;                  }                    if (((uint)ch) >= 10)                      return false;                    value = value * 10 + ch;                  offset++;                }
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,TryParseDouble,The following statement contains a magic number: while (offset < offsetMax)              {                  int ch = (chars[offset] - '0');                    if (ch == ('.' - '0'))                  {                      offset++;                      int pow10 = 1;                      while (offset < offsetMax)                      {                          ch = chars[offset] - '0';                            if (((uint)ch) >= 10)                              return false;                            pow10 *= 10;                          value = value * 10 + ch;                          offset++;                      }                        if (negative)                          result = -(double)value / pow10;                      else                          result = (double)value / pow10;                        return true;                  }                    if (((uint)ch) >= 10)                      return false;                    value = value * 10 + ch;                  offset++;                }
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,TryParseDouble,The following statement contains a magic number: while (offset < offsetMax)              {                  int ch = (chars[offset] - '0');                    if (ch == ('.' - '0'))                  {                      offset++;                      int pow10 = 1;                      while (offset < offsetMax)                      {                          ch = chars[offset] - '0';                            if (((uint)ch) >= 10)                              return false;                            pow10 *= 10;                          value = value * 10 + ch;                          offset++;                      }                        if (negative)                          result = -(double)value / pow10;                      else                          result = (double)value / pow10;                        return true;                  }                    if (((uint)ch) >= 10)                      return false;                    value = value * 10 + ch;                  offset++;                }
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,TryParseDouble,The following statement contains a magic number: if (count == 10)                  return false;
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,ToInt32D2,The following statement contains a magic number: if (ch1 > 9 || ch2 > 9)                  return -1;
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,ToInt32D2,The following statement contains a magic number: if (ch1 > 9 || ch2 > 9)                  return -1;
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,ToInt32D2,The following statement contains a magic number: return 10 * ch1 + ch2;
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,ToInt32D7,The following statement contains a magic number: for (int i = 0; i < count; i++)              {                   byte ch = (byte)(chars[offset + i] - '0');                     if (ch > 9)                      return -1;                     value = value * 10 + ch;              }
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,ToInt32D7,The following statement contains a magic number: for (int i = 0; i < count; i++)              {                   byte ch = (byte)(chars[offset + i] - '0');                     if (ch > 9)                      return -1;                     value = value * 10 + ch;              }
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,TryParseDateTime,The following statement contains a magic number: if (count < 19)                  return false;
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,TryParseDateTime,The following statement contains a magic number: if (chars[offset + 4] != '-' || chars[offset + 7] != '-' || chars[offset + 10] != 'T' ||                  chars[offset + 13] != ':' || chars[offset + 16] != ':')                  return false;
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,TryParseDateTime,The following statement contains a magic number: if (chars[offset + 4] != '-' || chars[offset + 7] != '-' || chars[offset + 10] != 'T' ||                  chars[offset + 13] != ':' || chars[offset + 16] != ':')                  return false;
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,TryParseDateTime,The following statement contains a magic number: if (chars[offset + 4] != '-' || chars[offset + 7] != '-' || chars[offset + 10] != 'T' ||                  chars[offset + 13] != ':' || chars[offset + 16] != ':')                  return false;
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,TryParseDateTime,The following statement contains a magic number: if (chars[offset + 4] != '-' || chars[offset + 7] != '-' || chars[offset + 10] != 'T' ||                  chars[offset + 13] != ':' || chars[offset + 16] != ':')                  return false;
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,TryParseDateTime,The following statement contains a magic number: if (chars[offset + 4] != '-' || chars[offset + 7] != '-' || chars[offset + 10] != 'T' ||                  chars[offset + 13] != ':' || chars[offset + 16] != ':')                  return false;
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,TryParseDateTime,The following statement contains a magic number: int year = ToInt32D4(chars' offset + 0' 4);
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,TryParseDateTime,The following statement contains a magic number: int month = ToInt32D2(chars' offset + 5);
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,TryParseDateTime,The following statement contains a magic number: int day = ToInt32D2(chars' offset + 8);
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,TryParseDateTime,The following statement contains a magic number: int hour = ToInt32D2(chars' offset + 11);
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,TryParseDateTime,The following statement contains a magic number: int minute = ToInt32D2(chars' offset + 14);
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,TryParseDateTime,The following statement contains a magic number: int second = ToInt32D2(chars' offset + 17);
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,TryParseDateTime,The following statement contains a magic number: offset += 19;
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,TryParseDateTime,The following statement contains a magic number: if (offset < offsetMax && chars[offset] == '.')              {                  offset++;                    int digitOffset = offset;                  while (offset < offsetMax)                  {                      byte ch = chars[offset];                        if (ch < '0' || ch > '9')                          break;                        offset++;                  }                    int digitCount = offset - digitOffset;                  if (digitCount < 1 || digitCount > 7)                      return false;                    ticks = ToInt32D7(chars' digitOffset' digitCount);                    if (ticks < 0)                      return false;                    for (int i = digitCount; i < 7; ++i)                      ticks *= 10;              }
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,TryParseDateTime,The following statement contains a magic number: if (offset < offsetMax && chars[offset] == '.')              {                  offset++;                    int digitOffset = offset;                  while (offset < offsetMax)                  {                      byte ch = chars[offset];                        if (ch < '0' || ch > '9')                          break;                        offset++;                  }                    int digitCount = offset - digitOffset;                  if (digitCount < 1 || digitCount > 7)                      return false;                    ticks = ToInt32D7(chars' digitOffset' digitCount);                    if (ticks < 0)                      return false;                    for (int i = digitCount; i < 7; ++i)                      ticks *= 10;              }
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,TryParseDateTime,The following statement contains a magic number: if (offset < offsetMax && chars[offset] == '.')              {                  offset++;                    int digitOffset = offset;                  while (offset < offsetMax)                  {                      byte ch = chars[offset];                        if (ch < '0' || ch > '9')                          break;                        offset++;                  }                    int digitCount = offset - digitOffset;                  if (digitCount < 1 || digitCount > 7)                      return false;                    ticks = ToInt32D7(chars' digitOffset' digitCount);                    if (ticks < 0)                      return false;                    for (int i = digitCount; i < 7; ++i)                      ticks *= 10;              }
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,TryParseDateTime,The following statement contains a magic number: if (offset < offsetMax)              {                  byte ch = chars[offset];                    if (ch == 'Z')                  {                      offset++;                      kind = DateTimeKind.Utc;                  }                    else if (ch == '+' || ch == '-')                  {                      offset++;                        if (offset + 5 > offsetMax || chars[offset + 2] != ':')                          return false;                        kind = DateTimeKind.Utc;                      isLocal = true;                      hourDelta = ToInt32D2(chars' offset);                      minuteDelta = ToInt32D2(chars' offset + 3);                        if ((hourDelta | minuteDelta) < 0)                          return false;                        if (ch == '+')                      {                          hourDelta = -hourDelta;                          minuteDelta = -minuteDelta;                      }                        offset += 5;                  }              }
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,TryParseDateTime,The following statement contains a magic number: if (offset < offsetMax)              {                  byte ch = chars[offset];                    if (ch == 'Z')                  {                      offset++;                      kind = DateTimeKind.Utc;                  }                    else if (ch == '+' || ch == '-')                  {                      offset++;                        if (offset + 5 > offsetMax || chars[offset + 2] != ':')                          return false;                        kind = DateTimeKind.Utc;                      isLocal = true;                      hourDelta = ToInt32D2(chars' offset);                      minuteDelta = ToInt32D2(chars' offset + 3);                        if ((hourDelta | minuteDelta) < 0)                          return false;                        if (ch == '+')                      {                          hourDelta = -hourDelta;                          minuteDelta = -minuteDelta;                      }                        offset += 5;                  }              }
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,TryParseDateTime,The following statement contains a magic number: if (offset < offsetMax)              {                  byte ch = chars[offset];                    if (ch == 'Z')                  {                      offset++;                      kind = DateTimeKind.Utc;                  }                    else if (ch == '+' || ch == '-')                  {                      offset++;                        if (offset + 5 > offsetMax || chars[offset + 2] != ':')                          return false;                        kind = DateTimeKind.Utc;                      isLocal = true;                      hourDelta = ToInt32D2(chars' offset);                      minuteDelta = ToInt32D2(chars' offset + 3);                        if ((hourDelta | minuteDelta) < 0)                          return false;                        if (ch == '+')                      {                          hourDelta = -hourDelta;                          minuteDelta = -minuteDelta;                      }                        offset += 5;                  }              }
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,TryParseDateTime,The following statement contains a magic number: if (offset < offsetMax)              {                  byte ch = chars[offset];                    if (ch == 'Z')                  {                      offset++;                      kind = DateTimeKind.Utc;                  }                    else if (ch == '+' || ch == '-')                  {                      offset++;                        if (offset + 5 > offsetMax || chars[offset + 2] != ':')                          return false;                        kind = DateTimeKind.Utc;                      isLocal = true;                      hourDelta = ToInt32D2(chars' offset);                      minuteDelta = ToInt32D2(chars' offset + 3);                        if ((hourDelta | minuteDelta) < 0)                          return false;                        if (ch == '+')                      {                          hourDelta = -hourDelta;                          minuteDelta = -minuteDelta;                      }                        offset += 5;                  }              }
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,ToChars,The following statement contains a magic number: if (value)              {                  buffer[offset + 0] = (byte)'t';                  buffer[offset + 1] = (byte)'r';                  buffer[offset + 2] = (byte)'u';                  buffer[offset + 3] = (byte)'e';                  return 4;              }
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,ToChars,The following statement contains a magic number: if (value)              {                  buffer[offset + 0] = (byte)'t';                  buffer[offset + 1] = (byte)'r';                  buffer[offset + 2] = (byte)'u';                  buffer[offset + 3] = (byte)'e';                  return 4;              }
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,ToChars,The following statement contains a magic number: if (value)              {                  buffer[offset + 0] = (byte)'t';                  buffer[offset + 1] = (byte)'r';                  buffer[offset + 2] = (byte)'u';                  buffer[offset + 3] = (byte)'e';                  return 4;              }
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,ToChars,The following statement contains a magic number: buffer[offset + 2] = (byte)'l';
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,ToChars,The following statement contains a magic number: buffer[offset + 3] = (byte)'s';
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,ToChars,The following statement contains a magic number: buffer[offset + 4] = (byte)'e';
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,ToChars,The following statement contains a magic number: return 5;
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,ToCharsR,The following statement contains a magic number: if (value >= 0)              {                  while (value >= 10)                  {                      int valueDiv10 = value / 10;                      count++;                      chars[--offset] = (byte)('0' + (value - valueDiv10 * 10));                      value = valueDiv10;                  }                  chars[--offset] = (byte)('0' + value);                  count++;              }              else              {                  while (value <= -10)                  {                      int valueDiv10 = value / 10;                      count++;                      chars[--offset] = (byte)('0' - (value - valueDiv10 * 10));                      value = valueDiv10;                  }                  chars[--offset] = (byte)('0' - value);                  chars[--offset] = (byte)'-';                  count += 2;              }
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,ToCharsR,The following statement contains a magic number: if (value >= 0)              {                  while (value >= 10)                  {                      int valueDiv10 = value / 10;                      count++;                      chars[--offset] = (byte)('0' + (value - valueDiv10 * 10));                      value = valueDiv10;                  }                  chars[--offset] = (byte)('0' + value);                  count++;              }              else              {                  while (value <= -10)                  {                      int valueDiv10 = value / 10;                      count++;                      chars[--offset] = (byte)('0' - (value - valueDiv10 * 10));                      value = valueDiv10;                  }                  chars[--offset] = (byte)('0' - value);                  chars[--offset] = (byte)'-';                  count += 2;              }
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,ToCharsR,The following statement contains a magic number: if (value >= 0)              {                  while (value >= 10)                  {                      int valueDiv10 = value / 10;                      count++;                      chars[--offset] = (byte)('0' + (value - valueDiv10 * 10));                      value = valueDiv10;                  }                  chars[--offset] = (byte)('0' + value);                  count++;              }              else              {                  while (value <= -10)                  {                      int valueDiv10 = value / 10;                      count++;                      chars[--offset] = (byte)('0' - (value - valueDiv10 * 10));                      value = valueDiv10;                  }                  chars[--offset] = (byte)('0' - value);                  chars[--offset] = (byte)'-';                  count += 2;              }
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,ToCharsR,The following statement contains a magic number: if (value >= 0)              {                  while (value >= 10)                  {                      int valueDiv10 = value / 10;                      count++;                      chars[--offset] = (byte)('0' + (value - valueDiv10 * 10));                      value = valueDiv10;                  }                  chars[--offset] = (byte)('0' + value);                  count++;              }              else              {                  while (value <= -10)                  {                      int valueDiv10 = value / 10;                      count++;                      chars[--offset] = (byte)('0' - (value - valueDiv10 * 10));                      value = valueDiv10;                  }                  chars[--offset] = (byte)('0' - value);                  chars[--offset] = (byte)'-';                  count += 2;              }
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,ToCharsR,The following statement contains a magic number: if (value >= 0)              {                  while (value >= 10)                  {                      int valueDiv10 = value / 10;                      count++;                      chars[--offset] = (byte)('0' + (value - valueDiv10 * 10));                      value = valueDiv10;                  }                  chars[--offset] = (byte)('0' + value);                  count++;              }              else              {                  while (value <= -10)                  {                      int valueDiv10 = value / 10;                      count++;                      chars[--offset] = (byte)('0' - (value - valueDiv10 * 10));                      value = valueDiv10;                  }                  chars[--offset] = (byte)('0' - value);                  chars[--offset] = (byte)'-';                  count += 2;              }
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,ToCharsR,The following statement contains a magic number: if (value >= 0)              {                  while (value >= 10)                  {                      int valueDiv10 = value / 10;                      count++;                      chars[--offset] = (byte)('0' + (value - valueDiv10 * 10));                      value = valueDiv10;                  }                  chars[--offset] = (byte)('0' + value);                  count++;              }              else              {                  while (value <= -10)                  {                      int valueDiv10 = value / 10;                      count++;                      chars[--offset] = (byte)('0' - (value - valueDiv10 * 10));                      value = valueDiv10;                  }                  chars[--offset] = (byte)('0' - value);                  chars[--offset] = (byte)'-';                  count += 2;              }
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,ToCharsR,The following statement contains a magic number: if (value >= 0)              {                  while (value >= 10)                  {                      int valueDiv10 = value / 10;                      count++;                      chars[--offset] = (byte)('0' + (value - valueDiv10 * 10));                      value = valueDiv10;                  }                  chars[--offset] = (byte)('0' + value);                  count++;              }              else              {                  while (value <= -10)                  {                      int valueDiv10 = value / 10;                      count++;                      chars[--offset] = (byte)('0' - (value - valueDiv10 * 10));                      value = valueDiv10;                  }                  chars[--offset] = (byte)('0' - value);                  chars[--offset] = (byte)'-';                  count += 2;              }
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,ToChars,The following statement contains a magic number: int count = ToCharsR(value' chars' offset + 16);
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,ToChars,The following statement contains a magic number: Buffer.BlockCopy(chars' offset + 16 - count' chars' offset' count);
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,ToCharsR,The following statement contains a magic number: if (value >= 0)              {                  while (value > int.MaxValue)                  {                      long valueDiv10 = value / 10;                      count++;                      chars[--offset] = (byte)('0' + (int)(value - valueDiv10 * 10));                      value = valueDiv10;                  }              }              else              {                  while (value < int.MinValue)                  {                      long valueDiv10 = value / 10;                      count++;                      chars[--offset] = (byte)('0' - (int)(value - valueDiv10 * 10));                      value = valueDiv10;                  }              }
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,ToCharsR,The following statement contains a magic number: if (value >= 0)              {                  while (value > int.MaxValue)                  {                      long valueDiv10 = value / 10;                      count++;                      chars[--offset] = (byte)('0' + (int)(value - valueDiv10 * 10));                      value = valueDiv10;                  }              }              else              {                  while (value < int.MinValue)                  {                      long valueDiv10 = value / 10;                      count++;                      chars[--offset] = (byte)('0' - (int)(value - valueDiv10 * 10));                      value = valueDiv10;                  }              }
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,ToCharsR,The following statement contains a magic number: if (value >= 0)              {                  while (value > int.MaxValue)                  {                      long valueDiv10 = value / 10;                      count++;                      chars[--offset] = (byte)('0' + (int)(value - valueDiv10 * 10));                      value = valueDiv10;                  }              }              else              {                  while (value < int.MinValue)                  {                      long valueDiv10 = value / 10;                      count++;                      chars[--offset] = (byte)('0' - (int)(value - valueDiv10 * 10));                      value = valueDiv10;                  }              }
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,ToCharsR,The following statement contains a magic number: if (value >= 0)              {                  while (value > int.MaxValue)                  {                      long valueDiv10 = value / 10;                      count++;                      chars[--offset] = (byte)('0' + (int)(value - valueDiv10 * 10));                      value = valueDiv10;                  }              }              else              {                  while (value < int.MinValue)                  {                      long valueDiv10 = value / 10;                      count++;                      chars[--offset] = (byte)('0' - (int)(value - valueDiv10 * 10));                      value = valueDiv10;                  }              }
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,ToChars,The following statement contains a magic number: int count = ToCharsR(value' chars' offset + 32);
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,ToChars,The following statement contains a magic number: Buffer.BlockCopy(chars' offset + 32 - count' chars' offset' count);
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,ToInfinity,The following statement contains a magic number: if (isNegative)              {                  buffer[offset + 0] = (byte)'-';                  buffer[offset + 1] = (byte)'I';                  buffer[offset + 2] = (byte)'N';                  buffer[offset + 3] = (byte)'F';                  return 4;              }
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,ToInfinity,The following statement contains a magic number: if (isNegative)              {                  buffer[offset + 0] = (byte)'-';                  buffer[offset + 1] = (byte)'I';                  buffer[offset + 2] = (byte)'N';                  buffer[offset + 3] = (byte)'F';                  return 4;              }
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,ToInfinity,The following statement contains a magic number: if (isNegative)              {                  buffer[offset + 0] = (byte)'-';                  buffer[offset + 1] = (byte)'I';                  buffer[offset + 2] = (byte)'N';                  buffer[offset + 3] = (byte)'F';                  return 4;              }
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,ToInfinity,The following statement contains a magic number: buffer[offset + 2] = (byte)'F';
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,ToInfinity,The following statement contains a magic number: return 3;
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,ToZero,The following statement contains a magic number: if (isNegative)              {                  buffer[offset + 0] = (byte)'-';                  buffer[offset + 1] = (byte)'0';                  return 2;              }
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,ToCharsD2,The following statement contains a magic number: if (value < 10)              {                  chars[offset + 0] = (byte)'0';                  chars[offset + 1] = (byte)('0' + value);              }              else              {                  int valueDiv10 = value / 10;                  chars[offset + 0] = (byte)('0' + valueDiv10);                  chars[offset + 1] = (byte)('0' + value - valueDiv10 * 10);              }
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,ToCharsD2,The following statement contains a magic number: if (value < 10)              {                  chars[offset + 0] = (byte)'0';                  chars[offset + 1] = (byte)('0' + value);              }              else              {                  int valueDiv10 = value / 10;                  chars[offset + 0] = (byte)('0' + valueDiv10);                  chars[offset + 1] = (byte)('0' + value - valueDiv10 * 10);              }
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,ToCharsD2,The following statement contains a magic number: if (value < 10)              {                  chars[offset + 0] = (byte)'0';                  chars[offset + 1] = (byte)('0' + value);              }              else              {                  int valueDiv10 = value / 10;                  chars[offset + 0] = (byte)('0' + valueDiv10);                  chars[offset + 1] = (byte)('0' + value - valueDiv10 * 10);              }
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,ToCharsD2,The following statement contains a magic number: return 2;
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,ToCharsD4,The following statement contains a magic number: ToCharsD2(value/100' chars' offset);
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,ToCharsD4,The following statement contains a magic number: ToCharsD2(value%100' chars' offset + 2);
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,ToCharsD4,The following statement contains a magic number: ToCharsD2(value%100' chars' offset + 2);
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,ToCharsD4,The following statement contains a magic number: return 4;
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,ToCharsD7,The following statement contains a magic number: int zeroCount = 7 - ToCharsR(value' chars' offset + 7);
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,ToCharsD7,The following statement contains a magic number: int zeroCount = 7 - ToCharsR(value' chars' offset + 7);
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,ToCharsD7,The following statement contains a magic number: int count = 7;
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,ToChars,The following statement contains a magic number: const long TicksPerMillisecond = 10000;
Magic Number,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,ToChars,The following statement contains a magic number: const long TicksPerSecond = TicksPerMillisecond * 1000;
Magic Number,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,ResetState,The following statement contains a magic number: charactersToSkipOnNextRead = new byte[2];
Magic Number,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,BreakText,The following statement contains a magic number: if (length > 0 && (buffer[offset + length - 1] & BufferAllocation) == BufferAllocation)              {                  // Find the lead char of the utf8 sequence (0x11xxxxxx)                   int originalLength = length;                  do                  {                      --length;                  } while (length > 0 && (buffer[offset + length] & 192) != 192);                    // Couldn't find the lead char                  if (length == 0)                      return originalLength;                    // Count how many bytes follow the lead char                   byte b = (byte)(buffer[offset + length] << 2);                    int byteCount = 2;                  while ((b & BufferAllocation) == BufferAllocation)                  {                      b <<= 1;                      ++byteCount;                        // There shouldn't be more than 3 bytes following the lead char                       if (byteCount > 4)                          return originalLength; // Invalid utf8 sequence - can't break                   }                    if (length + byteCount == originalLength)                      return originalLength; // sequence fits exactly                    if (length == 0)                      return originalLength; // Quota too small to read a char               }
Magic Number,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,BreakText,The following statement contains a magic number: if (length > 0 && (buffer[offset + length - 1] & BufferAllocation) == BufferAllocation)              {                  // Find the lead char of the utf8 sequence (0x11xxxxxx)                   int originalLength = length;                  do                  {                      --length;                  } while (length > 0 && (buffer[offset + length] & 192) != 192);                    // Couldn't find the lead char                  if (length == 0)                      return originalLength;                    // Count how many bytes follow the lead char                   byte b = (byte)(buffer[offset + length] << 2);                    int byteCount = 2;                  while ((b & BufferAllocation) == BufferAllocation)                  {                      b <<= 1;                      ++byteCount;                        // There shouldn't be more than 3 bytes following the lead char                       if (byteCount > 4)                          return originalLength; // Invalid utf8 sequence - can't break                   }                    if (length + byteCount == originalLength)                      return originalLength; // sequence fits exactly                    if (length == 0)                      return originalLength; // Quota too small to read a char               }
Magic Number,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,BreakText,The following statement contains a magic number: if (length > 0 && (buffer[offset + length - 1] & BufferAllocation) == BufferAllocation)              {                  // Find the lead char of the utf8 sequence (0x11xxxxxx)                   int originalLength = length;                  do                  {                      --length;                  } while (length > 0 && (buffer[offset + length] & 192) != 192);                    // Couldn't find the lead char                  if (length == 0)                      return originalLength;                    // Count how many bytes follow the lead char                   byte b = (byte)(buffer[offset + length] << 2);                    int byteCount = 2;                  while ((b & BufferAllocation) == BufferAllocation)                  {                      b <<= 1;                      ++byteCount;                        // There shouldn't be more than 3 bytes following the lead char                       if (byteCount > 4)                          return originalLength; // Invalid utf8 sequence - can't break                   }                    if (length + byteCount == originalLength)                      return originalLength; // sequence fits exactly                    if (length == 0)                      return originalLength; // Quota too small to read a char               }
Magic Number,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,BreakText,The following statement contains a magic number: if (length > 0 && (buffer[offset + length - 1] & BufferAllocation) == BufferAllocation)              {                  // Find the lead char of the utf8 sequence (0x11xxxxxx)                   int originalLength = length;                  do                  {                      --length;                  } while (length > 0 && (buffer[offset + length] & 192) != 192);                    // Couldn't find the lead char                  if (length == 0)                      return originalLength;                    // Count how many bytes follow the lead char                   byte b = (byte)(buffer[offset + length] << 2);                    int byteCount = 2;                  while ((b & BufferAllocation) == BufferAllocation)                  {                      b <<= 1;                      ++byteCount;                        // There shouldn't be more than 3 bytes following the lead char                       if (byteCount > 4)                          return originalLength; // Invalid utf8 sequence - can't break                   }                    if (length + byteCount == originalLength)                      return originalLength; // sequence fits exactly                    if (length == 0)                      return originalLength; // Quota too small to read a char               }
Magic Number,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,BreakText,The following statement contains a magic number: if (length > 0 && (buffer[offset + length - 1] & BufferAllocation) == BufferAllocation)              {                  // Find the lead char of the utf8 sequence (0x11xxxxxx)                   int originalLength = length;                  do                  {                      --length;                  } while (length > 0 && (buffer[offset + length] & 192) != 192);                    // Couldn't find the lead char                  if (length == 0)                      return originalLength;                    // Count how many bytes follow the lead char                   byte b = (byte)(buffer[offset + length] << 2);                    int byteCount = 2;                  while ((b & BufferAllocation) == BufferAllocation)                  {                      b <<= 1;                      ++byteCount;                        // There shouldn't be more than 3 bytes following the lead char                       if (byteCount > 4)                          return originalLength; // Invalid utf8 sequence - can't break                   }                    if (length + byteCount == originalLength)                      return originalLength; // sequence fits exactly                    if (length == 0)                      return originalLength; // Quota too small to read a char               }
Magic Number,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,Read,The following statement contains a magic number: if (scopeDepth == 0)              {                  ReadNonExistentElementName(StringHandleConstStringType.Root);              }              else if (IsReadingComplexText)              {                  switch (complexTextMode)                  {                      case JsonComplexTextMode.QuotedText:                          if (ch == Keys.BackSlash)                          {                              ReadEscapedCharacter(true);                              break;                          }                            ReadQuotedText(true);                          break;                      case JsonComplexTextMode.NumericalText:                          ReadNumericalText();                          break;                      case JsonComplexTextMode.None:                          throw new XmlException("JsonEncounteredUnexpectedCharacter");                  }              }              else if (IsReadingCollection)                  ReadNonExistentElementName(StringHandleConstStringType.Item);                else switch (ch)                  {                      case Keys.RightClosingBracket:                          this.BufferReader.SkipByte();                          MoveToEndElement();                          ExitJsonScope();                          break;                      case Keys.LeftOpeningBrace:                          this.BufferReader.SkipByte();                          SkipWhitespaceInBufferReader();                          ch = this.BufferReader.GetByte();                          if (ch == Keys.RightClosingBrace)                          {                              // Skip this byte                              this.BufferReader.SkipByte();                              // Skip white spaces                              SkipWhitespaceInBufferReader();                                // try get next char                              if (TryGetByte(out ch))                              {                                  if (ch == Keys.Comma)                                      this.BufferReader.SkipByte();                              }                              else                              {                                  // We are at end of buffer' just mark Comma to be skipped next time                                  charactersToSkipOnNextRead[0] = Keys.Comma;                              }                                // We set to End Element                              MoveToEndElement();                          }                          else                          {                              // Enter a new scope                              EnterJsonScope(JsonNodeType.Object);                              // Parse start element                              ParseStartElement();                          }                          break;                      case Keys.RightClosingBrace:                          this.BufferReader.SkipByte();                          if (expectingFirstElementInNonPrimitiveChild)                          {                              SkipWhitespaceInBufferReader();                              ch = this.BufferReader.GetByte();                              switch (ch)                              {                                  case Keys.Comma:                                  case Keys.RightClosingBrace:                                      this.BufferReader.SkipByte();                                      break;                                  default:                                      throw new XmlException("JsonEncounteredUnexpectedCharacter");                              }                              expectingFirstElementInNonPrimitiveChild = false;                          }                          MoveToEndElement();                          break;                      case Keys.Comma:                          this.BufferReader.SkipByte();                          MoveToEndElement();                          break;                      case Keys.DoubleQuote:                          if (this.Node.NodeType == XmlNodeType.Element)                          {                              if (expectingFirstElementInNonPrimitiveChild)                              {                                  EnterJsonScope(JsonNodeType.Object);                                  ParseStartElement();                              }                              else                              {                                  this.BufferReader.SkipByte();                                  ReadQuotedText(true);                              }                          }                          else if (this.Node.NodeType == XmlNodeType.EndElement)                          {                              EnterJsonScope(JsonNodeType.Element);                              ParseStartElement();                          }                          else                              throw new XmlException("JsonEncounteredUnexpectedCharacter");                          break;                      case Keys.LowerF:                          {                              int offset;                              byte[] buffer = this.BufferReader.GetBuffer(5' out offset);                                // Check if it's "false"                              if (buffer[offset + 1] != Keys.LowerA                                  || buffer[offset + 2] != Keys.LowerL                                  || buffer[offset + 3] != Keys.LowerS                                  || buffer[offset + 4] != Keys.LowerE)                                  throw new Exception("Expected False");                                // Advance of 5 byte                              this.BufferReader.Advance(5);                                // Check if char after is a closing one                              if (TryGetByte(out ch) && !IsWhitespace(ch) && (ch != Keys.Comma && ch != Keys.RightClosingBrace) && ch != Keys.RightClosingBracket)                                  throw new Exception("TokenExpected");                                // Move                              this.MoveToAtomicText().Value.SetValue(ValueHandleType.UTF8' offset' 5);                          }                          break;                      case Keys.LowerT:                          {                              int offset;                                // check if it's "true"                              byte[] buffer = this.BufferReader.GetBuffer(4' out offset);                              if (buffer[offset + 1] != Keys.LowerR                                  || buffer[offset + 2] != Keys.LowerU                                  || buffer[offset + 3] != Keys.LowerE)                                  throw new Exception("expected true");                                this.BufferReader.Advance(4);                                // Check if char after is a closing one                              if (TryGetByte(out ch) && !IsWhitespace(ch) && (ch != Keys.Comma && ch != Keys.RightClosingBrace) && ch != Keys.RightClosingBracket)                                  throw new Exception("TokenExpected");                                // move atomic                              this.MoveToAtomicText().Value.SetValue(ValueHandleType.UTF8' offset' 4);                          }                          break;                      case Keys.LowerN:                          {                              int offset;                              // check if it's "null"                              byte[] buffer = this.BufferReader.GetBuffer(4' out offset);                                if (buffer[offset + 1] != Keys.LowerU                                  || buffer[offset + 2] != Keys.LowerL                                  || buffer[offset + 3] != Keys.LowerL)                                  throw new Exception("Expected null");                                // advance of 4 chars                              this.BufferReader.Advance(4);                                SkipWhitespaceInBufferReader();                                if (TryGetByte(out ch))                              {                                  if (ch == Keys.Comma || ch == Keys.RightClosingBrace)                                      this.BufferReader.SkipByte();                                  else if (ch != Keys.RightClosingBracket)                                      throw new Exception("TokenExpected");                              }                              else                              {                                  charactersToSkipOnNextRead[0] = Keys.Comma;                                  charactersToSkipOnNextRead[1] = Keys.RightClosingBrace;                              }                              MoveToEndElement();                          }                          break;                      default:                          if ((ch == (byte)'-')                              || (((byte)'0' <= ch) && (ch <= (byte)'9'))                              || (ch == (byte)'I')                              || (ch == (byte)'N'))                              ReadNumericalText();                          else                              throw new XmlException("JsonEncounteredUnexpectedCharacter");                          break;                  }
Magic Number,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,Read,The following statement contains a magic number: if (scopeDepth == 0)              {                  ReadNonExistentElementName(StringHandleConstStringType.Root);              }              else if (IsReadingComplexText)              {                  switch (complexTextMode)                  {                      case JsonComplexTextMode.QuotedText:                          if (ch == Keys.BackSlash)                          {                              ReadEscapedCharacter(true);                              break;                          }                            ReadQuotedText(true);                          break;                      case JsonComplexTextMode.NumericalText:                          ReadNumericalText();                          break;                      case JsonComplexTextMode.None:                          throw new XmlException("JsonEncounteredUnexpectedCharacter");                  }              }              else if (IsReadingCollection)                  ReadNonExistentElementName(StringHandleConstStringType.Item);                else switch (ch)                  {                      case Keys.RightClosingBracket:                          this.BufferReader.SkipByte();                          MoveToEndElement();                          ExitJsonScope();                          break;                      case Keys.LeftOpeningBrace:                          this.BufferReader.SkipByte();                          SkipWhitespaceInBufferReader();                          ch = this.BufferReader.GetByte();                          if (ch == Keys.RightClosingBrace)                          {                              // Skip this byte                              this.BufferReader.SkipByte();                              // Skip white spaces                              SkipWhitespaceInBufferReader();                                // try get next char                              if (TryGetByte(out ch))                              {                                  if (ch == Keys.Comma)                                      this.BufferReader.SkipByte();                              }                              else                              {                                  // We are at end of buffer' just mark Comma to be skipped next time                                  charactersToSkipOnNextRead[0] = Keys.Comma;                              }                                // We set to End Element                              MoveToEndElement();                          }                          else                          {                              // Enter a new scope                              EnterJsonScope(JsonNodeType.Object);                              // Parse start element                              ParseStartElement();                          }                          break;                      case Keys.RightClosingBrace:                          this.BufferReader.SkipByte();                          if (expectingFirstElementInNonPrimitiveChild)                          {                              SkipWhitespaceInBufferReader();                              ch = this.BufferReader.GetByte();                              switch (ch)                              {                                  case Keys.Comma:                                  case Keys.RightClosingBrace:                                      this.BufferReader.SkipByte();                                      break;                                  default:                                      throw new XmlException("JsonEncounteredUnexpectedCharacter");                              }                              expectingFirstElementInNonPrimitiveChild = false;                          }                          MoveToEndElement();                          break;                      case Keys.Comma:                          this.BufferReader.SkipByte();                          MoveToEndElement();                          break;                      case Keys.DoubleQuote:                          if (this.Node.NodeType == XmlNodeType.Element)                          {                              if (expectingFirstElementInNonPrimitiveChild)                              {                                  EnterJsonScope(JsonNodeType.Object);                                  ParseStartElement();                              }                              else                              {                                  this.BufferReader.SkipByte();                                  ReadQuotedText(true);                              }                          }                          else if (this.Node.NodeType == XmlNodeType.EndElement)                          {                              EnterJsonScope(JsonNodeType.Element);                              ParseStartElement();                          }                          else                              throw new XmlException("JsonEncounteredUnexpectedCharacter");                          break;                      case Keys.LowerF:                          {                              int offset;                              byte[] buffer = this.BufferReader.GetBuffer(5' out offset);                                // Check if it's "false"                              if (buffer[offset + 1] != Keys.LowerA                                  || buffer[offset + 2] != Keys.LowerL                                  || buffer[offset + 3] != Keys.LowerS                                  || buffer[offset + 4] != Keys.LowerE)                                  throw new Exception("Expected False");                                // Advance of 5 byte                              this.BufferReader.Advance(5);                                // Check if char after is a closing one                              if (TryGetByte(out ch) && !IsWhitespace(ch) && (ch != Keys.Comma && ch != Keys.RightClosingBrace) && ch != Keys.RightClosingBracket)                                  throw new Exception("TokenExpected");                                // Move                              this.MoveToAtomicText().Value.SetValue(ValueHandleType.UTF8' offset' 5);                          }                          break;                      case Keys.LowerT:                          {                              int offset;                                // check if it's "true"                              byte[] buffer = this.BufferReader.GetBuffer(4' out offset);                              if (buffer[offset + 1] != Keys.LowerR                                  || buffer[offset + 2] != Keys.LowerU                                  || buffer[offset + 3] != Keys.LowerE)                                  throw new Exception("expected true");                                this.BufferReader.Advance(4);                                // Check if char after is a closing one                              if (TryGetByte(out ch) && !IsWhitespace(ch) && (ch != Keys.Comma && ch != Keys.RightClosingBrace) && ch != Keys.RightClosingBracket)                                  throw new Exception("TokenExpected");                                // move atomic                              this.MoveToAtomicText().Value.SetValue(ValueHandleType.UTF8' offset' 4);                          }                          break;                      case Keys.LowerN:                          {                              int offset;                              // check if it's "null"                              byte[] buffer = this.BufferReader.GetBuffer(4' out offset);                                if (buffer[offset + 1] != Keys.LowerU                                  || buffer[offset + 2] != Keys.LowerL                                  || buffer[offset + 3] != Keys.LowerL)                                  throw new Exception("Expected null");                                // advance of 4 chars                              this.BufferReader.Advance(4);                                SkipWhitespaceInBufferReader();                                if (TryGetByte(out ch))                              {                                  if (ch == Keys.Comma || ch == Keys.RightClosingBrace)                                      this.BufferReader.SkipByte();                                  else if (ch != Keys.RightClosingBracket)                                      throw new Exception("TokenExpected");                              }                              else                              {                                  charactersToSkipOnNextRead[0] = Keys.Comma;                                  charactersToSkipOnNextRead[1] = Keys.RightClosingBrace;                              }                              MoveToEndElement();                          }                          break;                      default:                          if ((ch == (byte)'-')                              || (((byte)'0' <= ch) && (ch <= (byte)'9'))                              || (ch == (byte)'I')                              || (ch == (byte)'N'))                              ReadNumericalText();                          else                              throw new XmlException("JsonEncounteredUnexpectedCharacter");                          break;                  }
Magic Number,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,Read,The following statement contains a magic number: if (scopeDepth == 0)              {                  ReadNonExistentElementName(StringHandleConstStringType.Root);              }              else if (IsReadingComplexText)              {                  switch (complexTextMode)                  {                      case JsonComplexTextMode.QuotedText:                          if (ch == Keys.BackSlash)                          {                              ReadEscapedCharacter(true);                              break;                          }                            ReadQuotedText(true);                          break;                      case JsonComplexTextMode.NumericalText:                          ReadNumericalText();                          break;                      case JsonComplexTextMode.None:                          throw new XmlException("JsonEncounteredUnexpectedCharacter");                  }              }              else if (IsReadingCollection)                  ReadNonExistentElementName(StringHandleConstStringType.Item);                else switch (ch)                  {                      case Keys.RightClosingBracket:                          this.BufferReader.SkipByte();                          MoveToEndElement();                          ExitJsonScope();                          break;                      case Keys.LeftOpeningBrace:                          this.BufferReader.SkipByte();                          SkipWhitespaceInBufferReader();                          ch = this.BufferReader.GetByte();                          if (ch == Keys.RightClosingBrace)                          {                              // Skip this byte                              this.BufferReader.SkipByte();                              // Skip white spaces                              SkipWhitespaceInBufferReader();                                // try get next char                              if (TryGetByte(out ch))                              {                                  if (ch == Keys.Comma)                                      this.BufferReader.SkipByte();                              }                              else                              {                                  // We are at end of buffer' just mark Comma to be skipped next time                                  charactersToSkipOnNextRead[0] = Keys.Comma;                              }                                // We set to End Element                              MoveToEndElement();                          }                          else                          {                              // Enter a new scope                              EnterJsonScope(JsonNodeType.Object);                              // Parse start element                              ParseStartElement();                          }                          break;                      case Keys.RightClosingBrace:                          this.BufferReader.SkipByte();                          if (expectingFirstElementInNonPrimitiveChild)                          {                              SkipWhitespaceInBufferReader();                              ch = this.BufferReader.GetByte();                              switch (ch)                              {                                  case Keys.Comma:                                  case Keys.RightClosingBrace:                                      this.BufferReader.SkipByte();                                      break;                                  default:                                      throw new XmlException("JsonEncounteredUnexpectedCharacter");                              }                              expectingFirstElementInNonPrimitiveChild = false;                          }                          MoveToEndElement();                          break;                      case Keys.Comma:                          this.BufferReader.SkipByte();                          MoveToEndElement();                          break;                      case Keys.DoubleQuote:                          if (this.Node.NodeType == XmlNodeType.Element)                          {                              if (expectingFirstElementInNonPrimitiveChild)                              {                                  EnterJsonScope(JsonNodeType.Object);                                  ParseStartElement();                              }                              else                              {                                  this.BufferReader.SkipByte();                                  ReadQuotedText(true);                              }                          }                          else if (this.Node.NodeType == XmlNodeType.EndElement)                          {                              EnterJsonScope(JsonNodeType.Element);                              ParseStartElement();                          }                          else                              throw new XmlException("JsonEncounteredUnexpectedCharacter");                          break;                      case Keys.LowerF:                          {                              int offset;                              byte[] buffer = this.BufferReader.GetBuffer(5' out offset);                                // Check if it's "false"                              if (buffer[offset + 1] != Keys.LowerA                                  || buffer[offset + 2] != Keys.LowerL                                  || buffer[offset + 3] != Keys.LowerS                                  || buffer[offset + 4] != Keys.LowerE)                                  throw new Exception("Expected False");                                // Advance of 5 byte                              this.BufferReader.Advance(5);                                // Check if char after is a closing one                              if (TryGetByte(out ch) && !IsWhitespace(ch) && (ch != Keys.Comma && ch != Keys.RightClosingBrace) && ch != Keys.RightClosingBracket)                                  throw new Exception("TokenExpected");                                // Move                              this.MoveToAtomicText().Value.SetValue(ValueHandleType.UTF8' offset' 5);                          }                          break;                      case Keys.LowerT:                          {                              int offset;                                // check if it's "true"                              byte[] buffer = this.BufferReader.GetBuffer(4' out offset);                              if (buffer[offset + 1] != Keys.LowerR                                  || buffer[offset + 2] != Keys.LowerU                                  || buffer[offset + 3] != Keys.LowerE)                                  throw new Exception("expected true");                                this.BufferReader.Advance(4);                                // Check if char after is a closing one                              if (TryGetByte(out ch) && !IsWhitespace(ch) && (ch != Keys.Comma && ch != Keys.RightClosingBrace) && ch != Keys.RightClosingBracket)                                  throw new Exception("TokenExpected");                                // move atomic                              this.MoveToAtomicText().Value.SetValue(ValueHandleType.UTF8' offset' 4);                          }                          break;                      case Keys.LowerN:                          {                              int offset;                              // check if it's "null"                              byte[] buffer = this.BufferReader.GetBuffer(4' out offset);                                if (buffer[offset + 1] != Keys.LowerU                                  || buffer[offset + 2] != Keys.LowerL                                  || buffer[offset + 3] != Keys.LowerL)                                  throw new Exception("Expected null");                                // advance of 4 chars                              this.BufferReader.Advance(4);                                SkipWhitespaceInBufferReader();                                if (TryGetByte(out ch))                              {                                  if (ch == Keys.Comma || ch == Keys.RightClosingBrace)                                      this.BufferReader.SkipByte();                                  else if (ch != Keys.RightClosingBracket)                                      throw new Exception("TokenExpected");                              }                              else                              {                                  charactersToSkipOnNextRead[0] = Keys.Comma;                                  charactersToSkipOnNextRead[1] = Keys.RightClosingBrace;                              }                              MoveToEndElement();                          }                          break;                      default:                          if ((ch == (byte)'-')                              || (((byte)'0' <= ch) && (ch <= (byte)'9'))                              || (ch == (byte)'I')                              || (ch == (byte)'N'))                              ReadNumericalText();                          else                              throw new XmlException("JsonEncounteredUnexpectedCharacter");                          break;                  }
Magic Number,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,Read,The following statement contains a magic number: if (scopeDepth == 0)              {                  ReadNonExistentElementName(StringHandleConstStringType.Root);              }              else if (IsReadingComplexText)              {                  switch (complexTextMode)                  {                      case JsonComplexTextMode.QuotedText:                          if (ch == Keys.BackSlash)                          {                              ReadEscapedCharacter(true);                              break;                          }                            ReadQuotedText(true);                          break;                      case JsonComplexTextMode.NumericalText:                          ReadNumericalText();                          break;                      case JsonComplexTextMode.None:                          throw new XmlException("JsonEncounteredUnexpectedCharacter");                  }              }              else if (IsReadingCollection)                  ReadNonExistentElementName(StringHandleConstStringType.Item);                else switch (ch)                  {                      case Keys.RightClosingBracket:                          this.BufferReader.SkipByte();                          MoveToEndElement();                          ExitJsonScope();                          break;                      case Keys.LeftOpeningBrace:                          this.BufferReader.SkipByte();                          SkipWhitespaceInBufferReader();                          ch = this.BufferReader.GetByte();                          if (ch == Keys.RightClosingBrace)                          {                              // Skip this byte                              this.BufferReader.SkipByte();                              // Skip white spaces                              SkipWhitespaceInBufferReader();                                // try get next char                              if (TryGetByte(out ch))                              {                                  if (ch == Keys.Comma)                                      this.BufferReader.SkipByte();                              }                              else                              {                                  // We are at end of buffer' just mark Comma to be skipped next time                                  charactersToSkipOnNextRead[0] = Keys.Comma;                              }                                // We set to End Element                              MoveToEndElement();                          }                          else                          {                              // Enter a new scope                              EnterJsonScope(JsonNodeType.Object);                              // Parse start element                              ParseStartElement();                          }                          break;                      case Keys.RightClosingBrace:                          this.BufferReader.SkipByte();                          if (expectingFirstElementInNonPrimitiveChild)                          {                              SkipWhitespaceInBufferReader();                              ch = this.BufferReader.GetByte();                              switch (ch)                              {                                  case Keys.Comma:                                  case Keys.RightClosingBrace:                                      this.BufferReader.SkipByte();                                      break;                                  default:                                      throw new XmlException("JsonEncounteredUnexpectedCharacter");                              }                              expectingFirstElementInNonPrimitiveChild = false;                          }                          MoveToEndElement();                          break;                      case Keys.Comma:                          this.BufferReader.SkipByte();                          MoveToEndElement();                          break;                      case Keys.DoubleQuote:                          if (this.Node.NodeType == XmlNodeType.Element)                          {                              if (expectingFirstElementInNonPrimitiveChild)                              {                                  EnterJsonScope(JsonNodeType.Object);                                  ParseStartElement();                              }                              else                              {                                  this.BufferReader.SkipByte();                                  ReadQuotedText(true);                              }                          }                          else if (this.Node.NodeType == XmlNodeType.EndElement)                          {                              EnterJsonScope(JsonNodeType.Element);                              ParseStartElement();                          }                          else                              throw new XmlException("JsonEncounteredUnexpectedCharacter");                          break;                      case Keys.LowerF:                          {                              int offset;                              byte[] buffer = this.BufferReader.GetBuffer(5' out offset);                                // Check if it's "false"                              if (buffer[offset + 1] != Keys.LowerA                                  || buffer[offset + 2] != Keys.LowerL                                  || buffer[offset + 3] != Keys.LowerS                                  || buffer[offset + 4] != Keys.LowerE)                                  throw new Exception("Expected False");                                // Advance of 5 byte                              this.BufferReader.Advance(5);                                // Check if char after is a closing one                              if (TryGetByte(out ch) && !IsWhitespace(ch) && (ch != Keys.Comma && ch != Keys.RightClosingBrace) && ch != Keys.RightClosingBracket)                                  throw new Exception("TokenExpected");                                // Move                              this.MoveToAtomicText().Value.SetValue(ValueHandleType.UTF8' offset' 5);                          }                          break;                      case Keys.LowerT:                          {                              int offset;                                // check if it's "true"                              byte[] buffer = this.BufferReader.GetBuffer(4' out offset);                              if (buffer[offset + 1] != Keys.LowerR                                  || buffer[offset + 2] != Keys.LowerU                                  || buffer[offset + 3] != Keys.LowerE)                                  throw new Exception("expected true");                                this.BufferReader.Advance(4);                                // Check if char after is a closing one                              if (TryGetByte(out ch) && !IsWhitespace(ch) && (ch != Keys.Comma && ch != Keys.RightClosingBrace) && ch != Keys.RightClosingBracket)                                  throw new Exception("TokenExpected");                                // move atomic                              this.MoveToAtomicText().Value.SetValue(ValueHandleType.UTF8' offset' 4);                          }                          break;                      case Keys.LowerN:                          {                              int offset;                              // check if it's "null"                              byte[] buffer = this.BufferReader.GetBuffer(4' out offset);                                if (buffer[offset + 1] != Keys.LowerU                                  || buffer[offset + 2] != Keys.LowerL                                  || buffer[offset + 3] != Keys.LowerL)                                  throw new Exception("Expected null");                                // advance of 4 chars                              this.BufferReader.Advance(4);                                SkipWhitespaceInBufferReader();                                if (TryGetByte(out ch))                              {                                  if (ch == Keys.Comma || ch == Keys.RightClosingBrace)                                      this.BufferReader.SkipByte();                                  else if (ch != Keys.RightClosingBracket)                                      throw new Exception("TokenExpected");                              }                              else                              {                                  charactersToSkipOnNextRead[0] = Keys.Comma;                                  charactersToSkipOnNextRead[1] = Keys.RightClosingBrace;                              }                              MoveToEndElement();                          }                          break;                      default:                          if ((ch == (byte)'-')                              || (((byte)'0' <= ch) && (ch <= (byte)'9'))                              || (ch == (byte)'I')                              || (ch == (byte)'N'))                              ReadNumericalText();                          else                              throw new XmlException("JsonEncounteredUnexpectedCharacter");                          break;                  }
Magic Number,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,Read,The following statement contains a magic number: if (scopeDepth == 0)              {                  ReadNonExistentElementName(StringHandleConstStringType.Root);              }              else if (IsReadingComplexText)              {                  switch (complexTextMode)                  {                      case JsonComplexTextMode.QuotedText:                          if (ch == Keys.BackSlash)                          {                              ReadEscapedCharacter(true);                              break;                          }                            ReadQuotedText(true);                          break;                      case JsonComplexTextMode.NumericalText:                          ReadNumericalText();                          break;                      case JsonComplexTextMode.None:                          throw new XmlException("JsonEncounteredUnexpectedCharacter");                  }              }              else if (IsReadingCollection)                  ReadNonExistentElementName(StringHandleConstStringType.Item);                else switch (ch)                  {                      case Keys.RightClosingBracket:                          this.BufferReader.SkipByte();                          MoveToEndElement();                          ExitJsonScope();                          break;                      case Keys.LeftOpeningBrace:                          this.BufferReader.SkipByte();                          SkipWhitespaceInBufferReader();                          ch = this.BufferReader.GetByte();                          if (ch == Keys.RightClosingBrace)                          {                              // Skip this byte                              this.BufferReader.SkipByte();                              // Skip white spaces                              SkipWhitespaceInBufferReader();                                // try get next char                              if (TryGetByte(out ch))                              {                                  if (ch == Keys.Comma)                                      this.BufferReader.SkipByte();                              }                              else                              {                                  // We are at end of buffer' just mark Comma to be skipped next time                                  charactersToSkipOnNextRead[0] = Keys.Comma;                              }                                // We set to End Element                              MoveToEndElement();                          }                          else                          {                              // Enter a new scope                              EnterJsonScope(JsonNodeType.Object);                              // Parse start element                              ParseStartElement();                          }                          break;                      case Keys.RightClosingBrace:                          this.BufferReader.SkipByte();                          if (expectingFirstElementInNonPrimitiveChild)                          {                              SkipWhitespaceInBufferReader();                              ch = this.BufferReader.GetByte();                              switch (ch)                              {                                  case Keys.Comma:                                  case Keys.RightClosingBrace:                                      this.BufferReader.SkipByte();                                      break;                                  default:                                      throw new XmlException("JsonEncounteredUnexpectedCharacter");                              }                              expectingFirstElementInNonPrimitiveChild = false;                          }                          MoveToEndElement();                          break;                      case Keys.Comma:                          this.BufferReader.SkipByte();                          MoveToEndElement();                          break;                      case Keys.DoubleQuote:                          if (this.Node.NodeType == XmlNodeType.Element)                          {                              if (expectingFirstElementInNonPrimitiveChild)                              {                                  EnterJsonScope(JsonNodeType.Object);                                  ParseStartElement();                              }                              else                              {                                  this.BufferReader.SkipByte();                                  ReadQuotedText(true);                              }                          }                          else if (this.Node.NodeType == XmlNodeType.EndElement)                          {                              EnterJsonScope(JsonNodeType.Element);                              ParseStartElement();                          }                          else                              throw new XmlException("JsonEncounteredUnexpectedCharacter");                          break;                      case Keys.LowerF:                          {                              int offset;                              byte[] buffer = this.BufferReader.GetBuffer(5' out offset);                                // Check if it's "false"                              if (buffer[offset + 1] != Keys.LowerA                                  || buffer[offset + 2] != Keys.LowerL                                  || buffer[offset + 3] != Keys.LowerS                                  || buffer[offset + 4] != Keys.LowerE)                                  throw new Exception("Expected False");                                // Advance of 5 byte                              this.BufferReader.Advance(5);                                // Check if char after is a closing one                              if (TryGetByte(out ch) && !IsWhitespace(ch) && (ch != Keys.Comma && ch != Keys.RightClosingBrace) && ch != Keys.RightClosingBracket)                                  throw new Exception("TokenExpected");                                // Move                              this.MoveToAtomicText().Value.SetValue(ValueHandleType.UTF8' offset' 5);                          }                          break;                      case Keys.LowerT:                          {                              int offset;                                // check if it's "true"                              byte[] buffer = this.BufferReader.GetBuffer(4' out offset);                              if (buffer[offset + 1] != Keys.LowerR                                  || buffer[offset + 2] != Keys.LowerU                                  || buffer[offset + 3] != Keys.LowerE)                                  throw new Exception("expected true");                                this.BufferReader.Advance(4);                                // Check if char after is a closing one                              if (TryGetByte(out ch) && !IsWhitespace(ch) && (ch != Keys.Comma && ch != Keys.RightClosingBrace) && ch != Keys.RightClosingBracket)                                  throw new Exception("TokenExpected");                                // move atomic                              this.MoveToAtomicText().Value.SetValue(ValueHandleType.UTF8' offset' 4);                          }                          break;                      case Keys.LowerN:                          {                              int offset;                              // check if it's "null"                              byte[] buffer = this.BufferReader.GetBuffer(4' out offset);                                if (buffer[offset + 1] != Keys.LowerU                                  || buffer[offset + 2] != Keys.LowerL                                  || buffer[offset + 3] != Keys.LowerL)                                  throw new Exception("Expected null");                                // advance of 4 chars                              this.BufferReader.Advance(4);                                SkipWhitespaceInBufferReader();                                if (TryGetByte(out ch))                              {                                  if (ch == Keys.Comma || ch == Keys.RightClosingBrace)                                      this.BufferReader.SkipByte();                                  else if (ch != Keys.RightClosingBracket)                                      throw new Exception("TokenExpected");                              }                              else                              {                                  charactersToSkipOnNextRead[0] = Keys.Comma;                                  charactersToSkipOnNextRead[1] = Keys.RightClosingBrace;                              }                              MoveToEndElement();                          }                          break;                      default:                          if ((ch == (byte)'-')                              || (((byte)'0' <= ch) && (ch <= (byte)'9'))                              || (ch == (byte)'I')                              || (ch == (byte)'N'))                              ReadNumericalText();                          else                              throw new XmlException("JsonEncounteredUnexpectedCharacter");                          break;                  }
Magic Number,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,Read,The following statement contains a magic number: if (scopeDepth == 0)              {                  ReadNonExistentElementName(StringHandleConstStringType.Root);              }              else if (IsReadingComplexText)              {                  switch (complexTextMode)                  {                      case JsonComplexTextMode.QuotedText:                          if (ch == Keys.BackSlash)                          {                              ReadEscapedCharacter(true);                              break;                          }                            ReadQuotedText(true);                          break;                      case JsonComplexTextMode.NumericalText:                          ReadNumericalText();                          break;                      case JsonComplexTextMode.None:                          throw new XmlException("JsonEncounteredUnexpectedCharacter");                  }              }              else if (IsReadingCollection)                  ReadNonExistentElementName(StringHandleConstStringType.Item);                else switch (ch)                  {                      case Keys.RightClosingBracket:                          this.BufferReader.SkipByte();                          MoveToEndElement();                          ExitJsonScope();                          break;                      case Keys.LeftOpeningBrace:                          this.BufferReader.SkipByte();                          SkipWhitespaceInBufferReader();                          ch = this.BufferReader.GetByte();                          if (ch == Keys.RightClosingBrace)                          {                              // Skip this byte                              this.BufferReader.SkipByte();                              // Skip white spaces                              SkipWhitespaceInBufferReader();                                // try get next char                              if (TryGetByte(out ch))                              {                                  if (ch == Keys.Comma)                                      this.BufferReader.SkipByte();                              }                              else                              {                                  // We are at end of buffer' just mark Comma to be skipped next time                                  charactersToSkipOnNextRead[0] = Keys.Comma;                              }                                // We set to End Element                              MoveToEndElement();                          }                          else                          {                              // Enter a new scope                              EnterJsonScope(JsonNodeType.Object);                              // Parse start element                              ParseStartElement();                          }                          break;                      case Keys.RightClosingBrace:                          this.BufferReader.SkipByte();                          if (expectingFirstElementInNonPrimitiveChild)                          {                              SkipWhitespaceInBufferReader();                              ch = this.BufferReader.GetByte();                              switch (ch)                              {                                  case Keys.Comma:                                  case Keys.RightClosingBrace:                                      this.BufferReader.SkipByte();                                      break;                                  default:                                      throw new XmlException("JsonEncounteredUnexpectedCharacter");                              }                              expectingFirstElementInNonPrimitiveChild = false;                          }                          MoveToEndElement();                          break;                      case Keys.Comma:                          this.BufferReader.SkipByte();                          MoveToEndElement();                          break;                      case Keys.DoubleQuote:                          if (this.Node.NodeType == XmlNodeType.Element)                          {                              if (expectingFirstElementInNonPrimitiveChild)                              {                                  EnterJsonScope(JsonNodeType.Object);                                  ParseStartElement();                              }                              else                              {                                  this.BufferReader.SkipByte();                                  ReadQuotedText(true);                              }                          }                          else if (this.Node.NodeType == XmlNodeType.EndElement)                          {                              EnterJsonScope(JsonNodeType.Element);                              ParseStartElement();                          }                          else                              throw new XmlException("JsonEncounteredUnexpectedCharacter");                          break;                      case Keys.LowerF:                          {                              int offset;                              byte[] buffer = this.BufferReader.GetBuffer(5' out offset);                                // Check if it's "false"                              if (buffer[offset + 1] != Keys.LowerA                                  || buffer[offset + 2] != Keys.LowerL                                  || buffer[offset + 3] != Keys.LowerS                                  || buffer[offset + 4] != Keys.LowerE)                                  throw new Exception("Expected False");                                // Advance of 5 byte                              this.BufferReader.Advance(5);                                // Check if char after is a closing one                              if (TryGetByte(out ch) && !IsWhitespace(ch) && (ch != Keys.Comma && ch != Keys.RightClosingBrace) && ch != Keys.RightClosingBracket)                                  throw new Exception("TokenExpected");                                // Move                              this.MoveToAtomicText().Value.SetValue(ValueHandleType.UTF8' offset' 5);                          }                          break;                      case Keys.LowerT:                          {                              int offset;                                // check if it's "true"                              byte[] buffer = this.BufferReader.GetBuffer(4' out offset);                              if (buffer[offset + 1] != Keys.LowerR                                  || buffer[offset + 2] != Keys.LowerU                                  || buffer[offset + 3] != Keys.LowerE)                                  throw new Exception("expected true");                                this.BufferReader.Advance(4);                                // Check if char after is a closing one                              if (TryGetByte(out ch) && !IsWhitespace(ch) && (ch != Keys.Comma && ch != Keys.RightClosingBrace) && ch != Keys.RightClosingBracket)                                  throw new Exception("TokenExpected");                                // move atomic                              this.MoveToAtomicText().Value.SetValue(ValueHandleType.UTF8' offset' 4);                          }                          break;                      case Keys.LowerN:                          {                              int offset;                              // check if it's "null"                              byte[] buffer = this.BufferReader.GetBuffer(4' out offset);                                if (buffer[offset + 1] != Keys.LowerU                                  || buffer[offset + 2] != Keys.LowerL                                  || buffer[offset + 3] != Keys.LowerL)                                  throw new Exception("Expected null");                                // advance of 4 chars                              this.BufferReader.Advance(4);                                SkipWhitespaceInBufferReader();                                if (TryGetByte(out ch))                              {                                  if (ch == Keys.Comma || ch == Keys.RightClosingBrace)                                      this.BufferReader.SkipByte();                                  else if (ch != Keys.RightClosingBracket)                                      throw new Exception("TokenExpected");                              }                              else                              {                                  charactersToSkipOnNextRead[0] = Keys.Comma;                                  charactersToSkipOnNextRead[1] = Keys.RightClosingBrace;                              }                              MoveToEndElement();                          }                          break;                      default:                          if ((ch == (byte)'-')                              || (((byte)'0' <= ch) && (ch <= (byte)'9'))                              || (ch == (byte)'I')                              || (ch == (byte)'N'))                              ReadNumericalText();                          else                              throw new XmlException("JsonEncounteredUnexpectedCharacter");                          break;                  }
Magic Number,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,Read,The following statement contains a magic number: if (scopeDepth == 0)              {                  ReadNonExistentElementName(StringHandleConstStringType.Root);              }              else if (IsReadingComplexText)              {                  switch (complexTextMode)                  {                      case JsonComplexTextMode.QuotedText:                          if (ch == Keys.BackSlash)                          {                              ReadEscapedCharacter(true);                              break;                          }                            ReadQuotedText(true);                          break;                      case JsonComplexTextMode.NumericalText:                          ReadNumericalText();                          break;                      case JsonComplexTextMode.None:                          throw new XmlException("JsonEncounteredUnexpectedCharacter");                  }              }              else if (IsReadingCollection)                  ReadNonExistentElementName(StringHandleConstStringType.Item);                else switch (ch)                  {                      case Keys.RightClosingBracket:                          this.BufferReader.SkipByte();                          MoveToEndElement();                          ExitJsonScope();                          break;                      case Keys.LeftOpeningBrace:                          this.BufferReader.SkipByte();                          SkipWhitespaceInBufferReader();                          ch = this.BufferReader.GetByte();                          if (ch == Keys.RightClosingBrace)                          {                              // Skip this byte                              this.BufferReader.SkipByte();                              // Skip white spaces                              SkipWhitespaceInBufferReader();                                // try get next char                              if (TryGetByte(out ch))                              {                                  if (ch == Keys.Comma)                                      this.BufferReader.SkipByte();                              }                              else                              {                                  // We are at end of buffer' just mark Comma to be skipped next time                                  charactersToSkipOnNextRead[0] = Keys.Comma;                              }                                // We set to End Element                              MoveToEndElement();                          }                          else                          {                              // Enter a new scope                              EnterJsonScope(JsonNodeType.Object);                              // Parse start element                              ParseStartElement();                          }                          break;                      case Keys.RightClosingBrace:                          this.BufferReader.SkipByte();                          if (expectingFirstElementInNonPrimitiveChild)                          {                              SkipWhitespaceInBufferReader();                              ch = this.BufferReader.GetByte();                              switch (ch)                              {                                  case Keys.Comma:                                  case Keys.RightClosingBrace:                                      this.BufferReader.SkipByte();                                      break;                                  default:                                      throw new XmlException("JsonEncounteredUnexpectedCharacter");                              }                              expectingFirstElementInNonPrimitiveChild = false;                          }                          MoveToEndElement();                          break;                      case Keys.Comma:                          this.BufferReader.SkipByte();                          MoveToEndElement();                          break;                      case Keys.DoubleQuote:                          if (this.Node.NodeType == XmlNodeType.Element)                          {                              if (expectingFirstElementInNonPrimitiveChild)                              {                                  EnterJsonScope(JsonNodeType.Object);                                  ParseStartElement();                              }                              else                              {                                  this.BufferReader.SkipByte();                                  ReadQuotedText(true);                              }                          }                          else if (this.Node.NodeType == XmlNodeType.EndElement)                          {                              EnterJsonScope(JsonNodeType.Element);                              ParseStartElement();                          }                          else                              throw new XmlException("JsonEncounteredUnexpectedCharacter");                          break;                      case Keys.LowerF:                          {                              int offset;                              byte[] buffer = this.BufferReader.GetBuffer(5' out offset);                                // Check if it's "false"                              if (buffer[offset + 1] != Keys.LowerA                                  || buffer[offset + 2] != Keys.LowerL                                  || buffer[offset + 3] != Keys.LowerS                                  || buffer[offset + 4] != Keys.LowerE)                                  throw new Exception("Expected False");                                // Advance of 5 byte                              this.BufferReader.Advance(5);                                // Check if char after is a closing one                              if (TryGetByte(out ch) && !IsWhitespace(ch) && (ch != Keys.Comma && ch != Keys.RightClosingBrace) && ch != Keys.RightClosingBracket)                                  throw new Exception("TokenExpected");                                // Move                              this.MoveToAtomicText().Value.SetValue(ValueHandleType.UTF8' offset' 5);                          }                          break;                      case Keys.LowerT:                          {                              int offset;                                // check if it's "true"                              byte[] buffer = this.BufferReader.GetBuffer(4' out offset);                              if (buffer[offset + 1] != Keys.LowerR                                  || buffer[offset + 2] != Keys.LowerU                                  || buffer[offset + 3] != Keys.LowerE)                                  throw new Exception("expected true");                                this.BufferReader.Advance(4);                                // Check if char after is a closing one                              if (TryGetByte(out ch) && !IsWhitespace(ch) && (ch != Keys.Comma && ch != Keys.RightClosingBrace) && ch != Keys.RightClosingBracket)                                  throw new Exception("TokenExpected");                                // move atomic                              this.MoveToAtomicText().Value.SetValue(ValueHandleType.UTF8' offset' 4);                          }                          break;                      case Keys.LowerN:                          {                              int offset;                              // check if it's "null"                              byte[] buffer = this.BufferReader.GetBuffer(4' out offset);                                if (buffer[offset + 1] != Keys.LowerU                                  || buffer[offset + 2] != Keys.LowerL                                  || buffer[offset + 3] != Keys.LowerL)                                  throw new Exception("Expected null");                                // advance of 4 chars                              this.BufferReader.Advance(4);                                SkipWhitespaceInBufferReader();                                if (TryGetByte(out ch))                              {                                  if (ch == Keys.Comma || ch == Keys.RightClosingBrace)                                      this.BufferReader.SkipByte();                                  else if (ch != Keys.RightClosingBracket)                                      throw new Exception("TokenExpected");                              }                              else                              {                                  charactersToSkipOnNextRead[0] = Keys.Comma;                                  charactersToSkipOnNextRead[1] = Keys.RightClosingBrace;                              }                              MoveToEndElement();                          }                          break;                      default:                          if ((ch == (byte)'-')                              || (((byte)'0' <= ch) && (ch <= (byte)'9'))                              || (ch == (byte)'I')                              || (ch == (byte)'N'))                              ReadNumericalText();                          else                              throw new XmlException("JsonEncounteredUnexpectedCharacter");                          break;                  }
Magic Number,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,Read,The following statement contains a magic number: if (scopeDepth == 0)              {                  ReadNonExistentElementName(StringHandleConstStringType.Root);              }              else if (IsReadingComplexText)              {                  switch (complexTextMode)                  {                      case JsonComplexTextMode.QuotedText:                          if (ch == Keys.BackSlash)                          {                              ReadEscapedCharacter(true);                              break;                          }                            ReadQuotedText(true);                          break;                      case JsonComplexTextMode.NumericalText:                          ReadNumericalText();                          break;                      case JsonComplexTextMode.None:                          throw new XmlException("JsonEncounteredUnexpectedCharacter");                  }              }              else if (IsReadingCollection)                  ReadNonExistentElementName(StringHandleConstStringType.Item);                else switch (ch)                  {                      case Keys.RightClosingBracket:                          this.BufferReader.SkipByte();                          MoveToEndElement();                          ExitJsonScope();                          break;                      case Keys.LeftOpeningBrace:                          this.BufferReader.SkipByte();                          SkipWhitespaceInBufferReader();                          ch = this.BufferReader.GetByte();                          if (ch == Keys.RightClosingBrace)                          {                              // Skip this byte                              this.BufferReader.SkipByte();                              // Skip white spaces                              SkipWhitespaceInBufferReader();                                // try get next char                              if (TryGetByte(out ch))                              {                                  if (ch == Keys.Comma)                                      this.BufferReader.SkipByte();                              }                              else                              {                                  // We are at end of buffer' just mark Comma to be skipped next time                                  charactersToSkipOnNextRead[0] = Keys.Comma;                              }                                // We set to End Element                              MoveToEndElement();                          }                          else                          {                              // Enter a new scope                              EnterJsonScope(JsonNodeType.Object);                              // Parse start element                              ParseStartElement();                          }                          break;                      case Keys.RightClosingBrace:                          this.BufferReader.SkipByte();                          if (expectingFirstElementInNonPrimitiveChild)                          {                              SkipWhitespaceInBufferReader();                              ch = this.BufferReader.GetByte();                              switch (ch)                              {                                  case Keys.Comma:                                  case Keys.RightClosingBrace:                                      this.BufferReader.SkipByte();                                      break;                                  default:                                      throw new XmlException("JsonEncounteredUnexpectedCharacter");                              }                              expectingFirstElementInNonPrimitiveChild = false;                          }                          MoveToEndElement();                          break;                      case Keys.Comma:                          this.BufferReader.SkipByte();                          MoveToEndElement();                          break;                      case Keys.DoubleQuote:                          if (this.Node.NodeType == XmlNodeType.Element)                          {                              if (expectingFirstElementInNonPrimitiveChild)                              {                                  EnterJsonScope(JsonNodeType.Object);                                  ParseStartElement();                              }                              else                              {                                  this.BufferReader.SkipByte();                                  ReadQuotedText(true);                              }                          }                          else if (this.Node.NodeType == XmlNodeType.EndElement)                          {                              EnterJsonScope(JsonNodeType.Element);                              ParseStartElement();                          }                          else                              throw new XmlException("JsonEncounteredUnexpectedCharacter");                          break;                      case Keys.LowerF:                          {                              int offset;                              byte[] buffer = this.BufferReader.GetBuffer(5' out offset);                                // Check if it's "false"                              if (buffer[offset + 1] != Keys.LowerA                                  || buffer[offset + 2] != Keys.LowerL                                  || buffer[offset + 3] != Keys.LowerS                                  || buffer[offset + 4] != Keys.LowerE)                                  throw new Exception("Expected False");                                // Advance of 5 byte                              this.BufferReader.Advance(5);                                // Check if char after is a closing one                              if (TryGetByte(out ch) && !IsWhitespace(ch) && (ch != Keys.Comma && ch != Keys.RightClosingBrace) && ch != Keys.RightClosingBracket)                                  throw new Exception("TokenExpected");                                // Move                              this.MoveToAtomicText().Value.SetValue(ValueHandleType.UTF8' offset' 5);                          }                          break;                      case Keys.LowerT:                          {                              int offset;                                // check if it's "true"                              byte[] buffer = this.BufferReader.GetBuffer(4' out offset);                              if (buffer[offset + 1] != Keys.LowerR                                  || buffer[offset + 2] != Keys.LowerU                                  || buffer[offset + 3] != Keys.LowerE)                                  throw new Exception("expected true");                                this.BufferReader.Advance(4);                                // Check if char after is a closing one                              if (TryGetByte(out ch) && !IsWhitespace(ch) && (ch != Keys.Comma && ch != Keys.RightClosingBrace) && ch != Keys.RightClosingBracket)                                  throw new Exception("TokenExpected");                                // move atomic                              this.MoveToAtomicText().Value.SetValue(ValueHandleType.UTF8' offset' 4);                          }                          break;                      case Keys.LowerN:                          {                              int offset;                              // check if it's "null"                              byte[] buffer = this.BufferReader.GetBuffer(4' out offset);                                if (buffer[offset + 1] != Keys.LowerU                                  || buffer[offset + 2] != Keys.LowerL                                  || buffer[offset + 3] != Keys.LowerL)                                  throw new Exception("Expected null");                                // advance of 4 chars                              this.BufferReader.Advance(4);                                SkipWhitespaceInBufferReader();                                if (TryGetByte(out ch))                              {                                  if (ch == Keys.Comma || ch == Keys.RightClosingBrace)                                      this.BufferReader.SkipByte();                                  else if (ch != Keys.RightClosingBracket)                                      throw new Exception("TokenExpected");                              }                              else                              {                                  charactersToSkipOnNextRead[0] = Keys.Comma;                                  charactersToSkipOnNextRead[1] = Keys.RightClosingBrace;                              }                              MoveToEndElement();                          }                          break;                      default:                          if ((ch == (byte)'-')                              || (((byte)'0' <= ch) && (ch <= (byte)'9'))                              || (ch == (byte)'I')                              || (ch == (byte)'N'))                              ReadNumericalText();                          else                              throw new XmlException("JsonEncounteredUnexpectedCharacter");                          break;                  }
Magic Number,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,Read,The following statement contains a magic number: if (scopeDepth == 0)              {                  ReadNonExistentElementName(StringHandleConstStringType.Root);              }              else if (IsReadingComplexText)              {                  switch (complexTextMode)                  {                      case JsonComplexTextMode.QuotedText:                          if (ch == Keys.BackSlash)                          {                              ReadEscapedCharacter(true);                              break;                          }                            ReadQuotedText(true);                          break;                      case JsonComplexTextMode.NumericalText:                          ReadNumericalText();                          break;                      case JsonComplexTextMode.None:                          throw new XmlException("JsonEncounteredUnexpectedCharacter");                  }              }              else if (IsReadingCollection)                  ReadNonExistentElementName(StringHandleConstStringType.Item);                else switch (ch)                  {                      case Keys.RightClosingBracket:                          this.BufferReader.SkipByte();                          MoveToEndElement();                          ExitJsonScope();                          break;                      case Keys.LeftOpeningBrace:                          this.BufferReader.SkipByte();                          SkipWhitespaceInBufferReader();                          ch = this.BufferReader.GetByte();                          if (ch == Keys.RightClosingBrace)                          {                              // Skip this byte                              this.BufferReader.SkipByte();                              // Skip white spaces                              SkipWhitespaceInBufferReader();                                // try get next char                              if (TryGetByte(out ch))                              {                                  if (ch == Keys.Comma)                                      this.BufferReader.SkipByte();                              }                              else                              {                                  // We are at end of buffer' just mark Comma to be skipped next time                                  charactersToSkipOnNextRead[0] = Keys.Comma;                              }                                // We set to End Element                              MoveToEndElement();                          }                          else                          {                              // Enter a new scope                              EnterJsonScope(JsonNodeType.Object);                              // Parse start element                              ParseStartElement();                          }                          break;                      case Keys.RightClosingBrace:                          this.BufferReader.SkipByte();                          if (expectingFirstElementInNonPrimitiveChild)                          {                              SkipWhitespaceInBufferReader();                              ch = this.BufferReader.GetByte();                              switch (ch)                              {                                  case Keys.Comma:                                  case Keys.RightClosingBrace:                                      this.BufferReader.SkipByte();                                      break;                                  default:                                      throw new XmlException("JsonEncounteredUnexpectedCharacter");                              }                              expectingFirstElementInNonPrimitiveChild = false;                          }                          MoveToEndElement();                          break;                      case Keys.Comma:                          this.BufferReader.SkipByte();                          MoveToEndElement();                          break;                      case Keys.DoubleQuote:                          if (this.Node.NodeType == XmlNodeType.Element)                          {                              if (expectingFirstElementInNonPrimitiveChild)                              {                                  EnterJsonScope(JsonNodeType.Object);                                  ParseStartElement();                              }                              else                              {                                  this.BufferReader.SkipByte();                                  ReadQuotedText(true);                              }                          }                          else if (this.Node.NodeType == XmlNodeType.EndElement)                          {                              EnterJsonScope(JsonNodeType.Element);                              ParseStartElement();                          }                          else                              throw new XmlException("JsonEncounteredUnexpectedCharacter");                          break;                      case Keys.LowerF:                          {                              int offset;                              byte[] buffer = this.BufferReader.GetBuffer(5' out offset);                                // Check if it's "false"                              if (buffer[offset + 1] != Keys.LowerA                                  || buffer[offset + 2] != Keys.LowerL                                  || buffer[offset + 3] != Keys.LowerS                                  || buffer[offset + 4] != Keys.LowerE)                                  throw new Exception("Expected False");                                // Advance of 5 byte                              this.BufferReader.Advance(5);                                // Check if char after is a closing one                              if (TryGetByte(out ch) && !IsWhitespace(ch) && (ch != Keys.Comma && ch != Keys.RightClosingBrace) && ch != Keys.RightClosingBracket)                                  throw new Exception("TokenExpected");                                // Move                              this.MoveToAtomicText().Value.SetValue(ValueHandleType.UTF8' offset' 5);                          }                          break;                      case Keys.LowerT:                          {                              int offset;                                // check if it's "true"                              byte[] buffer = this.BufferReader.GetBuffer(4' out offset);                              if (buffer[offset + 1] != Keys.LowerR                                  || buffer[offset + 2] != Keys.LowerU                                  || buffer[offset + 3] != Keys.LowerE)                                  throw new Exception("expected true");                                this.BufferReader.Advance(4);                                // Check if char after is a closing one                              if (TryGetByte(out ch) && !IsWhitespace(ch) && (ch != Keys.Comma && ch != Keys.RightClosingBrace) && ch != Keys.RightClosingBracket)                                  throw new Exception("TokenExpected");                                // move atomic                              this.MoveToAtomicText().Value.SetValue(ValueHandleType.UTF8' offset' 4);                          }                          break;                      case Keys.LowerN:                          {                              int offset;                              // check if it's "null"                              byte[] buffer = this.BufferReader.GetBuffer(4' out offset);                                if (buffer[offset + 1] != Keys.LowerU                                  || buffer[offset + 2] != Keys.LowerL                                  || buffer[offset + 3] != Keys.LowerL)                                  throw new Exception("Expected null");                                // advance of 4 chars                              this.BufferReader.Advance(4);                                SkipWhitespaceInBufferReader();                                if (TryGetByte(out ch))                              {                                  if (ch == Keys.Comma || ch == Keys.RightClosingBrace)                                      this.BufferReader.SkipByte();                                  else if (ch != Keys.RightClosingBracket)                                      throw new Exception("TokenExpected");                              }                              else                              {                                  charactersToSkipOnNextRead[0] = Keys.Comma;                                  charactersToSkipOnNextRead[1] = Keys.RightClosingBrace;                              }                              MoveToEndElement();                          }                          break;                      default:                          if ((ch == (byte)'-')                              || (((byte)'0' <= ch) && (ch <= (byte)'9'))                              || (ch == (byte)'I')                              || (ch == (byte)'N'))                              ReadNumericalText();                          else                              throw new XmlException("JsonEncounteredUnexpectedCharacter");                          break;                  }
Magic Number,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,Read,The following statement contains a magic number: if (scopeDepth == 0)              {                  ReadNonExistentElementName(StringHandleConstStringType.Root);              }              else if (IsReadingComplexText)              {                  switch (complexTextMode)                  {                      case JsonComplexTextMode.QuotedText:                          if (ch == Keys.BackSlash)                          {                              ReadEscapedCharacter(true);                              break;                          }                            ReadQuotedText(true);                          break;                      case JsonComplexTextMode.NumericalText:                          ReadNumericalText();                          break;                      case JsonComplexTextMode.None:                          throw new XmlException("JsonEncounteredUnexpectedCharacter");                  }              }              else if (IsReadingCollection)                  ReadNonExistentElementName(StringHandleConstStringType.Item);                else switch (ch)                  {                      case Keys.RightClosingBracket:                          this.BufferReader.SkipByte();                          MoveToEndElement();                          ExitJsonScope();                          break;                      case Keys.LeftOpeningBrace:                          this.BufferReader.SkipByte();                          SkipWhitespaceInBufferReader();                          ch = this.BufferReader.GetByte();                          if (ch == Keys.RightClosingBrace)                          {                              // Skip this byte                              this.BufferReader.SkipByte();                              // Skip white spaces                              SkipWhitespaceInBufferReader();                                // try get next char                              if (TryGetByte(out ch))                              {                                  if (ch == Keys.Comma)                                      this.BufferReader.SkipByte();                              }                              else                              {                                  // We are at end of buffer' just mark Comma to be skipped next time                                  charactersToSkipOnNextRead[0] = Keys.Comma;                              }                                // We set to End Element                              MoveToEndElement();                          }                          else                          {                              // Enter a new scope                              EnterJsonScope(JsonNodeType.Object);                              // Parse start element                              ParseStartElement();                          }                          break;                      case Keys.RightClosingBrace:                          this.BufferReader.SkipByte();                          if (expectingFirstElementInNonPrimitiveChild)                          {                              SkipWhitespaceInBufferReader();                              ch = this.BufferReader.GetByte();                              switch (ch)                              {                                  case Keys.Comma:                                  case Keys.RightClosingBrace:                                      this.BufferReader.SkipByte();                                      break;                                  default:                                      throw new XmlException("JsonEncounteredUnexpectedCharacter");                              }                              expectingFirstElementInNonPrimitiveChild = false;                          }                          MoveToEndElement();                          break;                      case Keys.Comma:                          this.BufferReader.SkipByte();                          MoveToEndElement();                          break;                      case Keys.DoubleQuote:                          if (this.Node.NodeType == XmlNodeType.Element)                          {                              if (expectingFirstElementInNonPrimitiveChild)                              {                                  EnterJsonScope(JsonNodeType.Object);                                  ParseStartElement();                              }                              else                              {                                  this.BufferReader.SkipByte();                                  ReadQuotedText(true);                              }                          }                          else if (this.Node.NodeType == XmlNodeType.EndElement)                          {                              EnterJsonScope(JsonNodeType.Element);                              ParseStartElement();                          }                          else                              throw new XmlException("JsonEncounteredUnexpectedCharacter");                          break;                      case Keys.LowerF:                          {                              int offset;                              byte[] buffer = this.BufferReader.GetBuffer(5' out offset);                                // Check if it's "false"                              if (buffer[offset + 1] != Keys.LowerA                                  || buffer[offset + 2] != Keys.LowerL                                  || buffer[offset + 3] != Keys.LowerS                                  || buffer[offset + 4] != Keys.LowerE)                                  throw new Exception("Expected False");                                // Advance of 5 byte                              this.BufferReader.Advance(5);                                // Check if char after is a closing one                              if (TryGetByte(out ch) && !IsWhitespace(ch) && (ch != Keys.Comma && ch != Keys.RightClosingBrace) && ch != Keys.RightClosingBracket)                                  throw new Exception("TokenExpected");                                // Move                              this.MoveToAtomicText().Value.SetValue(ValueHandleType.UTF8' offset' 5);                          }                          break;                      case Keys.LowerT:                          {                              int offset;                                // check if it's "true"                              byte[] buffer = this.BufferReader.GetBuffer(4' out offset);                              if (buffer[offset + 1] != Keys.LowerR                                  || buffer[offset + 2] != Keys.LowerU                                  || buffer[offset + 3] != Keys.LowerE)                                  throw new Exception("expected true");                                this.BufferReader.Advance(4);                                // Check if char after is a closing one                              if (TryGetByte(out ch) && !IsWhitespace(ch) && (ch != Keys.Comma && ch != Keys.RightClosingBrace) && ch != Keys.RightClosingBracket)                                  throw new Exception("TokenExpected");                                // move atomic                              this.MoveToAtomicText().Value.SetValue(ValueHandleType.UTF8' offset' 4);                          }                          break;                      case Keys.LowerN:                          {                              int offset;                              // check if it's "null"                              byte[] buffer = this.BufferReader.GetBuffer(4' out offset);                                if (buffer[offset + 1] != Keys.LowerU                                  || buffer[offset + 2] != Keys.LowerL                                  || buffer[offset + 3] != Keys.LowerL)                                  throw new Exception("Expected null");                                // advance of 4 chars                              this.BufferReader.Advance(4);                                SkipWhitespaceInBufferReader();                                if (TryGetByte(out ch))                              {                                  if (ch == Keys.Comma || ch == Keys.RightClosingBrace)                                      this.BufferReader.SkipByte();                                  else if (ch != Keys.RightClosingBracket)                                      throw new Exception("TokenExpected");                              }                              else                              {                                  charactersToSkipOnNextRead[0] = Keys.Comma;                                  charactersToSkipOnNextRead[1] = Keys.RightClosingBrace;                              }                              MoveToEndElement();                          }                          break;                      default:                          if ((ch == (byte)'-')                              || (((byte)'0' <= ch) && (ch <= (byte)'9'))                              || (ch == (byte)'I')                              || (ch == (byte)'N'))                              ReadNumericalText();                          else                              throw new XmlException("JsonEncounteredUnexpectedCharacter");                          break;                  }
Magic Number,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,Read,The following statement contains a magic number: if (scopeDepth == 0)              {                  ReadNonExistentElementName(StringHandleConstStringType.Root);              }              else if (IsReadingComplexText)              {                  switch (complexTextMode)                  {                      case JsonComplexTextMode.QuotedText:                          if (ch == Keys.BackSlash)                          {                              ReadEscapedCharacter(true);                              break;                          }                            ReadQuotedText(true);                          break;                      case JsonComplexTextMode.NumericalText:                          ReadNumericalText();                          break;                      case JsonComplexTextMode.None:                          throw new XmlException("JsonEncounteredUnexpectedCharacter");                  }              }              else if (IsReadingCollection)                  ReadNonExistentElementName(StringHandleConstStringType.Item);                else switch (ch)                  {                      case Keys.RightClosingBracket:                          this.BufferReader.SkipByte();                          MoveToEndElement();                          ExitJsonScope();                          break;                      case Keys.LeftOpeningBrace:                          this.BufferReader.SkipByte();                          SkipWhitespaceInBufferReader();                          ch = this.BufferReader.GetByte();                          if (ch == Keys.RightClosingBrace)                          {                              // Skip this byte                              this.BufferReader.SkipByte();                              // Skip white spaces                              SkipWhitespaceInBufferReader();                                // try get next char                              if (TryGetByte(out ch))                              {                                  if (ch == Keys.Comma)                                      this.BufferReader.SkipByte();                              }                              else                              {                                  // We are at end of buffer' just mark Comma to be skipped next time                                  charactersToSkipOnNextRead[0] = Keys.Comma;                              }                                // We set to End Element                              MoveToEndElement();                          }                          else                          {                              // Enter a new scope                              EnterJsonScope(JsonNodeType.Object);                              // Parse start element                              ParseStartElement();                          }                          break;                      case Keys.RightClosingBrace:                          this.BufferReader.SkipByte();                          if (expectingFirstElementInNonPrimitiveChild)                          {                              SkipWhitespaceInBufferReader();                              ch = this.BufferReader.GetByte();                              switch (ch)                              {                                  case Keys.Comma:                                  case Keys.RightClosingBrace:                                      this.BufferReader.SkipByte();                                      break;                                  default:                                      throw new XmlException("JsonEncounteredUnexpectedCharacter");                              }                              expectingFirstElementInNonPrimitiveChild = false;                          }                          MoveToEndElement();                          break;                      case Keys.Comma:                          this.BufferReader.SkipByte();                          MoveToEndElement();                          break;                      case Keys.DoubleQuote:                          if (this.Node.NodeType == XmlNodeType.Element)                          {                              if (expectingFirstElementInNonPrimitiveChild)                              {                                  EnterJsonScope(JsonNodeType.Object);                                  ParseStartElement();                              }                              else                              {                                  this.BufferReader.SkipByte();                                  ReadQuotedText(true);                              }                          }                          else if (this.Node.NodeType == XmlNodeType.EndElement)                          {                              EnterJsonScope(JsonNodeType.Element);                              ParseStartElement();                          }                          else                              throw new XmlException("JsonEncounteredUnexpectedCharacter");                          break;                      case Keys.LowerF:                          {                              int offset;                              byte[] buffer = this.BufferReader.GetBuffer(5' out offset);                                // Check if it's "false"                              if (buffer[offset + 1] != Keys.LowerA                                  || buffer[offset + 2] != Keys.LowerL                                  || buffer[offset + 3] != Keys.LowerS                                  || buffer[offset + 4] != Keys.LowerE)                                  throw new Exception("Expected False");                                // Advance of 5 byte                              this.BufferReader.Advance(5);                                // Check if char after is a closing one                              if (TryGetByte(out ch) && !IsWhitespace(ch) && (ch != Keys.Comma && ch != Keys.RightClosingBrace) && ch != Keys.RightClosingBracket)                                  throw new Exception("TokenExpected");                                // Move                              this.MoveToAtomicText().Value.SetValue(ValueHandleType.UTF8' offset' 5);                          }                          break;                      case Keys.LowerT:                          {                              int offset;                                // check if it's "true"                              byte[] buffer = this.BufferReader.GetBuffer(4' out offset);                              if (buffer[offset + 1] != Keys.LowerR                                  || buffer[offset + 2] != Keys.LowerU                                  || buffer[offset + 3] != Keys.LowerE)                                  throw new Exception("expected true");                                this.BufferReader.Advance(4);                                // Check if char after is a closing one                              if (TryGetByte(out ch) && !IsWhitespace(ch) && (ch != Keys.Comma && ch != Keys.RightClosingBrace) && ch != Keys.RightClosingBracket)                                  throw new Exception("TokenExpected");                                // move atomic                              this.MoveToAtomicText().Value.SetValue(ValueHandleType.UTF8' offset' 4);                          }                          break;                      case Keys.LowerN:                          {                              int offset;                              // check if it's "null"                              byte[] buffer = this.BufferReader.GetBuffer(4' out offset);                                if (buffer[offset + 1] != Keys.LowerU                                  || buffer[offset + 2] != Keys.LowerL                                  || buffer[offset + 3] != Keys.LowerL)                                  throw new Exception("Expected null");                                // advance of 4 chars                              this.BufferReader.Advance(4);                                SkipWhitespaceInBufferReader();                                if (TryGetByte(out ch))                              {                                  if (ch == Keys.Comma || ch == Keys.RightClosingBrace)                                      this.BufferReader.SkipByte();                                  else if (ch != Keys.RightClosingBracket)                                      throw new Exception("TokenExpected");                              }                              else                              {                                  charactersToSkipOnNextRead[0] = Keys.Comma;                                  charactersToSkipOnNextRead[1] = Keys.RightClosingBrace;                              }                              MoveToEndElement();                          }                          break;                      default:                          if ((ch == (byte)'-')                              || (((byte)'0' <= ch) && (ch <= (byte)'9'))                              || (ch == (byte)'I')                              || (ch == (byte)'N'))                              ReadNumericalText();                          else                              throw new XmlException("JsonEncounteredUnexpectedCharacter");                          break;                  }
Magic Number,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,Read,The following statement contains a magic number: if (scopeDepth == 0)              {                  ReadNonExistentElementName(StringHandleConstStringType.Root);              }              else if (IsReadingComplexText)              {                  switch (complexTextMode)                  {                      case JsonComplexTextMode.QuotedText:                          if (ch == Keys.BackSlash)                          {                              ReadEscapedCharacter(true);                              break;                          }                            ReadQuotedText(true);                          break;                      case JsonComplexTextMode.NumericalText:                          ReadNumericalText();                          break;                      case JsonComplexTextMode.None:                          throw new XmlException("JsonEncounteredUnexpectedCharacter");                  }              }              else if (IsReadingCollection)                  ReadNonExistentElementName(StringHandleConstStringType.Item);                else switch (ch)                  {                      case Keys.RightClosingBracket:                          this.BufferReader.SkipByte();                          MoveToEndElement();                          ExitJsonScope();                          break;                      case Keys.LeftOpeningBrace:                          this.BufferReader.SkipByte();                          SkipWhitespaceInBufferReader();                          ch = this.BufferReader.GetByte();                          if (ch == Keys.RightClosingBrace)                          {                              // Skip this byte                              this.BufferReader.SkipByte();                              // Skip white spaces                              SkipWhitespaceInBufferReader();                                // try get next char                              if (TryGetByte(out ch))                              {                                  if (ch == Keys.Comma)                                      this.BufferReader.SkipByte();                              }                              else                              {                                  // We are at end of buffer' just mark Comma to be skipped next time                                  charactersToSkipOnNextRead[0] = Keys.Comma;                              }                                // We set to End Element                              MoveToEndElement();                          }                          else                          {                              // Enter a new scope                              EnterJsonScope(JsonNodeType.Object);                              // Parse start element                              ParseStartElement();                          }                          break;                      case Keys.RightClosingBrace:                          this.BufferReader.SkipByte();                          if (expectingFirstElementInNonPrimitiveChild)                          {                              SkipWhitespaceInBufferReader();                              ch = this.BufferReader.GetByte();                              switch (ch)                              {                                  case Keys.Comma:                                  case Keys.RightClosingBrace:                                      this.BufferReader.SkipByte();                                      break;                                  default:                                      throw new XmlException("JsonEncounteredUnexpectedCharacter");                              }                              expectingFirstElementInNonPrimitiveChild = false;                          }                          MoveToEndElement();                          break;                      case Keys.Comma:                          this.BufferReader.SkipByte();                          MoveToEndElement();                          break;                      case Keys.DoubleQuote:                          if (this.Node.NodeType == XmlNodeType.Element)                          {                              if (expectingFirstElementInNonPrimitiveChild)                              {                                  EnterJsonScope(JsonNodeType.Object);                                  ParseStartElement();                              }                              else                              {                                  this.BufferReader.SkipByte();                                  ReadQuotedText(true);                              }                          }                          else if (this.Node.NodeType == XmlNodeType.EndElement)                          {                              EnterJsonScope(JsonNodeType.Element);                              ParseStartElement();                          }                          else                              throw new XmlException("JsonEncounteredUnexpectedCharacter");                          break;                      case Keys.LowerF:                          {                              int offset;                              byte[] buffer = this.BufferReader.GetBuffer(5' out offset);                                // Check if it's "false"                              if (buffer[offset + 1] != Keys.LowerA                                  || buffer[offset + 2] != Keys.LowerL                                  || buffer[offset + 3] != Keys.LowerS                                  || buffer[offset + 4] != Keys.LowerE)                                  throw new Exception("Expected False");                                // Advance of 5 byte                              this.BufferReader.Advance(5);                                // Check if char after is a closing one                              if (TryGetByte(out ch) && !IsWhitespace(ch) && (ch != Keys.Comma && ch != Keys.RightClosingBrace) && ch != Keys.RightClosingBracket)                                  throw new Exception("TokenExpected");                                // Move                              this.MoveToAtomicText().Value.SetValue(ValueHandleType.UTF8' offset' 5);                          }                          break;                      case Keys.LowerT:                          {                              int offset;                                // check if it's "true"                              byte[] buffer = this.BufferReader.GetBuffer(4' out offset);                              if (buffer[offset + 1] != Keys.LowerR                                  || buffer[offset + 2] != Keys.LowerU                                  || buffer[offset + 3] != Keys.LowerE)                                  throw new Exception("expected true");                                this.BufferReader.Advance(4);                                // Check if char after is a closing one                              if (TryGetByte(out ch) && !IsWhitespace(ch) && (ch != Keys.Comma && ch != Keys.RightClosingBrace) && ch != Keys.RightClosingBracket)                                  throw new Exception("TokenExpected");                                // move atomic                              this.MoveToAtomicText().Value.SetValue(ValueHandleType.UTF8' offset' 4);                          }                          break;                      case Keys.LowerN:                          {                              int offset;                              // check if it's "null"                              byte[] buffer = this.BufferReader.GetBuffer(4' out offset);                                if (buffer[offset + 1] != Keys.LowerU                                  || buffer[offset + 2] != Keys.LowerL                                  || buffer[offset + 3] != Keys.LowerL)                                  throw new Exception("Expected null");                                // advance of 4 chars                              this.BufferReader.Advance(4);                                SkipWhitespaceInBufferReader();                                if (TryGetByte(out ch))                              {                                  if (ch == Keys.Comma || ch == Keys.RightClosingBrace)                                      this.BufferReader.SkipByte();                                  else if (ch != Keys.RightClosingBracket)                                      throw new Exception("TokenExpected");                              }                              else                              {                                  charactersToSkipOnNextRead[0] = Keys.Comma;                                  charactersToSkipOnNextRead[1] = Keys.RightClosingBrace;                              }                              MoveToEndElement();                          }                          break;                      default:                          if ((ch == (byte)'-')                              || (((byte)'0' <= ch) && (ch <= (byte)'9'))                              || (ch == (byte)'I')                              || (ch == (byte)'N'))                              ReadNumericalText();                          else                              throw new XmlException("JsonEncounteredUnexpectedCharacter");                          break;                  }
Magic Number,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,Read,The following statement contains a magic number: if (scopeDepth == 0)              {                  ReadNonExistentElementName(StringHandleConstStringType.Root);              }              else if (IsReadingComplexText)              {                  switch (complexTextMode)                  {                      case JsonComplexTextMode.QuotedText:                          if (ch == Keys.BackSlash)                          {                              ReadEscapedCharacter(true);                              break;                          }                            ReadQuotedText(true);                          break;                      case JsonComplexTextMode.NumericalText:                          ReadNumericalText();                          break;                      case JsonComplexTextMode.None:                          throw new XmlException("JsonEncounteredUnexpectedCharacter");                  }              }              else if (IsReadingCollection)                  ReadNonExistentElementName(StringHandleConstStringType.Item);                else switch (ch)                  {                      case Keys.RightClosingBracket:                          this.BufferReader.SkipByte();                          MoveToEndElement();                          ExitJsonScope();                          break;                      case Keys.LeftOpeningBrace:                          this.BufferReader.SkipByte();                          SkipWhitespaceInBufferReader();                          ch = this.BufferReader.GetByte();                          if (ch == Keys.RightClosingBrace)                          {                              // Skip this byte                              this.BufferReader.SkipByte();                              // Skip white spaces                              SkipWhitespaceInBufferReader();                                // try get next char                              if (TryGetByte(out ch))                              {                                  if (ch == Keys.Comma)                                      this.BufferReader.SkipByte();                              }                              else                              {                                  // We are at end of buffer' just mark Comma to be skipped next time                                  charactersToSkipOnNextRead[0] = Keys.Comma;                              }                                // We set to End Element                              MoveToEndElement();                          }                          else                          {                              // Enter a new scope                              EnterJsonScope(JsonNodeType.Object);                              // Parse start element                              ParseStartElement();                          }                          break;                      case Keys.RightClosingBrace:                          this.BufferReader.SkipByte();                          if (expectingFirstElementInNonPrimitiveChild)                          {                              SkipWhitespaceInBufferReader();                              ch = this.BufferReader.GetByte();                              switch (ch)                              {                                  case Keys.Comma:                                  case Keys.RightClosingBrace:                                      this.BufferReader.SkipByte();                                      break;                                  default:                                      throw new XmlException("JsonEncounteredUnexpectedCharacter");                              }                              expectingFirstElementInNonPrimitiveChild = false;                          }                          MoveToEndElement();                          break;                      case Keys.Comma:                          this.BufferReader.SkipByte();                          MoveToEndElement();                          break;                      case Keys.DoubleQuote:                          if (this.Node.NodeType == XmlNodeType.Element)                          {                              if (expectingFirstElementInNonPrimitiveChild)                              {                                  EnterJsonScope(JsonNodeType.Object);                                  ParseStartElement();                              }                              else                              {                                  this.BufferReader.SkipByte();                                  ReadQuotedText(true);                              }                          }                          else if (this.Node.NodeType == XmlNodeType.EndElement)                          {                              EnterJsonScope(JsonNodeType.Element);                              ParseStartElement();                          }                          else                              throw new XmlException("JsonEncounteredUnexpectedCharacter");                          break;                      case Keys.LowerF:                          {                              int offset;                              byte[] buffer = this.BufferReader.GetBuffer(5' out offset);                                // Check if it's "false"                              if (buffer[offset + 1] != Keys.LowerA                                  || buffer[offset + 2] != Keys.LowerL                                  || buffer[offset + 3] != Keys.LowerS                                  || buffer[offset + 4] != Keys.LowerE)                                  throw new Exception("Expected False");                                // Advance of 5 byte                              this.BufferReader.Advance(5);                                // Check if char after is a closing one                              if (TryGetByte(out ch) && !IsWhitespace(ch) && (ch != Keys.Comma && ch != Keys.RightClosingBrace) && ch != Keys.RightClosingBracket)                                  throw new Exception("TokenExpected");                                // Move                              this.MoveToAtomicText().Value.SetValue(ValueHandleType.UTF8' offset' 5);                          }                          break;                      case Keys.LowerT:                          {                              int offset;                                // check if it's "true"                              byte[] buffer = this.BufferReader.GetBuffer(4' out offset);                              if (buffer[offset + 1] != Keys.LowerR                                  || buffer[offset + 2] != Keys.LowerU                                  || buffer[offset + 3] != Keys.LowerE)                                  throw new Exception("expected true");                                this.BufferReader.Advance(4);                                // Check if char after is a closing one                              if (TryGetByte(out ch) && !IsWhitespace(ch) && (ch != Keys.Comma && ch != Keys.RightClosingBrace) && ch != Keys.RightClosingBracket)                                  throw new Exception("TokenExpected");                                // move atomic                              this.MoveToAtomicText().Value.SetValue(ValueHandleType.UTF8' offset' 4);                          }                          break;                      case Keys.LowerN:                          {                              int offset;                              // check if it's "null"                              byte[] buffer = this.BufferReader.GetBuffer(4' out offset);                                if (buffer[offset + 1] != Keys.LowerU                                  || buffer[offset + 2] != Keys.LowerL                                  || buffer[offset + 3] != Keys.LowerL)                                  throw new Exception("Expected null");                                // advance of 4 chars                              this.BufferReader.Advance(4);                                SkipWhitespaceInBufferReader();                                if (TryGetByte(out ch))                              {                                  if (ch == Keys.Comma || ch == Keys.RightClosingBrace)                                      this.BufferReader.SkipByte();                                  else if (ch != Keys.RightClosingBracket)                                      throw new Exception("TokenExpected");                              }                              else                              {                                  charactersToSkipOnNextRead[0] = Keys.Comma;                                  charactersToSkipOnNextRead[1] = Keys.RightClosingBrace;                              }                              MoveToEndElement();                          }                          break;                      default:                          if ((ch == (byte)'-')                              || (((byte)'0' <= ch) && (ch <= (byte)'9'))                              || (ch == (byte)'I')                              || (ch == (byte)'N'))                              ReadNumericalText();                          else                              throw new XmlException("JsonEncounteredUnexpectedCharacter");                          break;                  }
Magic Number,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,Read,The following statement contains a magic number: if (scopeDepth == 0)              {                  ReadNonExistentElementName(StringHandleConstStringType.Root);              }              else if (IsReadingComplexText)              {                  switch (complexTextMode)                  {                      case JsonComplexTextMode.QuotedText:                          if (ch == Keys.BackSlash)                          {                              ReadEscapedCharacter(true);                              break;                          }                            ReadQuotedText(true);                          break;                      case JsonComplexTextMode.NumericalText:                          ReadNumericalText();                          break;                      case JsonComplexTextMode.None:                          throw new XmlException("JsonEncounteredUnexpectedCharacter");                  }              }              else if (IsReadingCollection)                  ReadNonExistentElementName(StringHandleConstStringType.Item);                else switch (ch)                  {                      case Keys.RightClosingBracket:                          this.BufferReader.SkipByte();                          MoveToEndElement();                          ExitJsonScope();                          break;                      case Keys.LeftOpeningBrace:                          this.BufferReader.SkipByte();                          SkipWhitespaceInBufferReader();                          ch = this.BufferReader.GetByte();                          if (ch == Keys.RightClosingBrace)                          {                              // Skip this byte                              this.BufferReader.SkipByte();                              // Skip white spaces                              SkipWhitespaceInBufferReader();                                // try get next char                              if (TryGetByte(out ch))                              {                                  if (ch == Keys.Comma)                                      this.BufferReader.SkipByte();                              }                              else                              {                                  // We are at end of buffer' just mark Comma to be skipped next time                                  charactersToSkipOnNextRead[0] = Keys.Comma;                              }                                // We set to End Element                              MoveToEndElement();                          }                          else                          {                              // Enter a new scope                              EnterJsonScope(JsonNodeType.Object);                              // Parse start element                              ParseStartElement();                          }                          break;                      case Keys.RightClosingBrace:                          this.BufferReader.SkipByte();                          if (expectingFirstElementInNonPrimitiveChild)                          {                              SkipWhitespaceInBufferReader();                              ch = this.BufferReader.GetByte();                              switch (ch)                              {                                  case Keys.Comma:                                  case Keys.RightClosingBrace:                                      this.BufferReader.SkipByte();                                      break;                                  default:                                      throw new XmlException("JsonEncounteredUnexpectedCharacter");                              }                              expectingFirstElementInNonPrimitiveChild = false;                          }                          MoveToEndElement();                          break;                      case Keys.Comma:                          this.BufferReader.SkipByte();                          MoveToEndElement();                          break;                      case Keys.DoubleQuote:                          if (this.Node.NodeType == XmlNodeType.Element)                          {                              if (expectingFirstElementInNonPrimitiveChild)                              {                                  EnterJsonScope(JsonNodeType.Object);                                  ParseStartElement();                              }                              else                              {                                  this.BufferReader.SkipByte();                                  ReadQuotedText(true);                              }                          }                          else if (this.Node.NodeType == XmlNodeType.EndElement)                          {                              EnterJsonScope(JsonNodeType.Element);                              ParseStartElement();                          }                          else                              throw new XmlException("JsonEncounteredUnexpectedCharacter");                          break;                      case Keys.LowerF:                          {                              int offset;                              byte[] buffer = this.BufferReader.GetBuffer(5' out offset);                                // Check if it's "false"                              if (buffer[offset + 1] != Keys.LowerA                                  || buffer[offset + 2] != Keys.LowerL                                  || buffer[offset + 3] != Keys.LowerS                                  || buffer[offset + 4] != Keys.LowerE)                                  throw new Exception("Expected False");                                // Advance of 5 byte                              this.BufferReader.Advance(5);                                // Check if char after is a closing one                              if (TryGetByte(out ch) && !IsWhitespace(ch) && (ch != Keys.Comma && ch != Keys.RightClosingBrace) && ch != Keys.RightClosingBracket)                                  throw new Exception("TokenExpected");                                // Move                              this.MoveToAtomicText().Value.SetValue(ValueHandleType.UTF8' offset' 5);                          }                          break;                      case Keys.LowerT:                          {                              int offset;                                // check if it's "true"                              byte[] buffer = this.BufferReader.GetBuffer(4' out offset);                              if (buffer[offset + 1] != Keys.LowerR                                  || buffer[offset + 2] != Keys.LowerU                                  || buffer[offset + 3] != Keys.LowerE)                                  throw new Exception("expected true");                                this.BufferReader.Advance(4);                                // Check if char after is a closing one                              if (TryGetByte(out ch) && !IsWhitespace(ch) && (ch != Keys.Comma && ch != Keys.RightClosingBrace) && ch != Keys.RightClosingBracket)                                  throw new Exception("TokenExpected");                                // move atomic                              this.MoveToAtomicText().Value.SetValue(ValueHandleType.UTF8' offset' 4);                          }                          break;                      case Keys.LowerN:                          {                              int offset;                              // check if it's "null"                              byte[] buffer = this.BufferReader.GetBuffer(4' out offset);                                if (buffer[offset + 1] != Keys.LowerU                                  || buffer[offset + 2] != Keys.LowerL                                  || buffer[offset + 3] != Keys.LowerL)                                  throw new Exception("Expected null");                                // advance of 4 chars                              this.BufferReader.Advance(4);                                SkipWhitespaceInBufferReader();                                if (TryGetByte(out ch))                              {                                  if (ch == Keys.Comma || ch == Keys.RightClosingBrace)                                      this.BufferReader.SkipByte();                                  else if (ch != Keys.RightClosingBracket)                                      throw new Exception("TokenExpected");                              }                              else                              {                                  charactersToSkipOnNextRead[0] = Keys.Comma;                                  charactersToSkipOnNextRead[1] = Keys.RightClosingBrace;                              }                              MoveToEndElement();                          }                          break;                      default:                          if ((ch == (byte)'-')                              || (((byte)'0' <= ch) && (ch <= (byte)'9'))                              || (ch == (byte)'I')                              || (ch == (byte)'N'))                              ReadNumericalText();                          else                              throw new XmlException("JsonEncounteredUnexpectedCharacter");                          break;                  }
Magic Number,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,Read,The following statement contains a magic number: if (scopeDepth == 0)              {                  ReadNonExistentElementName(StringHandleConstStringType.Root);              }              else if (IsReadingComplexText)              {                  switch (complexTextMode)                  {                      case JsonComplexTextMode.QuotedText:                          if (ch == Keys.BackSlash)                          {                              ReadEscapedCharacter(true);                              break;                          }                            ReadQuotedText(true);                          break;                      case JsonComplexTextMode.NumericalText:                          ReadNumericalText();                          break;                      case JsonComplexTextMode.None:                          throw new XmlException("JsonEncounteredUnexpectedCharacter");                  }              }              else if (IsReadingCollection)                  ReadNonExistentElementName(StringHandleConstStringType.Item);                else switch (ch)                  {                      case Keys.RightClosingBracket:                          this.BufferReader.SkipByte();                          MoveToEndElement();                          ExitJsonScope();                          break;                      case Keys.LeftOpeningBrace:                          this.BufferReader.SkipByte();                          SkipWhitespaceInBufferReader();                          ch = this.BufferReader.GetByte();                          if (ch == Keys.RightClosingBrace)                          {                              // Skip this byte                              this.BufferReader.SkipByte();                              // Skip white spaces                              SkipWhitespaceInBufferReader();                                // try get next char                              if (TryGetByte(out ch))                              {                                  if (ch == Keys.Comma)                                      this.BufferReader.SkipByte();                              }                              else                              {                                  // We are at end of buffer' just mark Comma to be skipped next time                                  charactersToSkipOnNextRead[0] = Keys.Comma;                              }                                // We set to End Element                              MoveToEndElement();                          }                          else                          {                              // Enter a new scope                              EnterJsonScope(JsonNodeType.Object);                              // Parse start element                              ParseStartElement();                          }                          break;                      case Keys.RightClosingBrace:                          this.BufferReader.SkipByte();                          if (expectingFirstElementInNonPrimitiveChild)                          {                              SkipWhitespaceInBufferReader();                              ch = this.BufferReader.GetByte();                              switch (ch)                              {                                  case Keys.Comma:                                  case Keys.RightClosingBrace:                                      this.BufferReader.SkipByte();                                      break;                                  default:                                      throw new XmlException("JsonEncounteredUnexpectedCharacter");                              }                              expectingFirstElementInNonPrimitiveChild = false;                          }                          MoveToEndElement();                          break;                      case Keys.Comma:                          this.BufferReader.SkipByte();                          MoveToEndElement();                          break;                      case Keys.DoubleQuote:                          if (this.Node.NodeType == XmlNodeType.Element)                          {                              if (expectingFirstElementInNonPrimitiveChild)                              {                                  EnterJsonScope(JsonNodeType.Object);                                  ParseStartElement();                              }                              else                              {                                  this.BufferReader.SkipByte();                                  ReadQuotedText(true);                              }                          }                          else if (this.Node.NodeType == XmlNodeType.EndElement)                          {                              EnterJsonScope(JsonNodeType.Element);                              ParseStartElement();                          }                          else                              throw new XmlException("JsonEncounteredUnexpectedCharacter");                          break;                      case Keys.LowerF:                          {                              int offset;                              byte[] buffer = this.BufferReader.GetBuffer(5' out offset);                                // Check if it's "false"                              if (buffer[offset + 1] != Keys.LowerA                                  || buffer[offset + 2] != Keys.LowerL                                  || buffer[offset + 3] != Keys.LowerS                                  || buffer[offset + 4] != Keys.LowerE)                                  throw new Exception("Expected False");                                // Advance of 5 byte                              this.BufferReader.Advance(5);                                // Check if char after is a closing one                              if (TryGetByte(out ch) && !IsWhitespace(ch) && (ch != Keys.Comma && ch != Keys.RightClosingBrace) && ch != Keys.RightClosingBracket)                                  throw new Exception("TokenExpected");                                // Move                              this.MoveToAtomicText().Value.SetValue(ValueHandleType.UTF8' offset' 5);                          }                          break;                      case Keys.LowerT:                          {                              int offset;                                // check if it's "true"                              byte[] buffer = this.BufferReader.GetBuffer(4' out offset);                              if (buffer[offset + 1] != Keys.LowerR                                  || buffer[offset + 2] != Keys.LowerU                                  || buffer[offset + 3] != Keys.LowerE)                                  throw new Exception("expected true");                                this.BufferReader.Advance(4);                                // Check if char after is a closing one                              if (TryGetByte(out ch) && !IsWhitespace(ch) && (ch != Keys.Comma && ch != Keys.RightClosingBrace) && ch != Keys.RightClosingBracket)                                  throw new Exception("TokenExpected");                                // move atomic                              this.MoveToAtomicText().Value.SetValue(ValueHandleType.UTF8' offset' 4);                          }                          break;                      case Keys.LowerN:                          {                              int offset;                              // check if it's "null"                              byte[] buffer = this.BufferReader.GetBuffer(4' out offset);                                if (buffer[offset + 1] != Keys.LowerU                                  || buffer[offset + 2] != Keys.LowerL                                  || buffer[offset + 3] != Keys.LowerL)                                  throw new Exception("Expected null");                                // advance of 4 chars                              this.BufferReader.Advance(4);                                SkipWhitespaceInBufferReader();                                if (TryGetByte(out ch))                              {                                  if (ch == Keys.Comma || ch == Keys.RightClosingBrace)                                      this.BufferReader.SkipByte();                                  else if (ch != Keys.RightClosingBracket)                                      throw new Exception("TokenExpected");                              }                              else                              {                                  charactersToSkipOnNextRead[0] = Keys.Comma;                                  charactersToSkipOnNextRead[1] = Keys.RightClosingBrace;                              }                              MoveToEndElement();                          }                          break;                      default:                          if ((ch == (byte)'-')                              || (((byte)'0' <= ch) && (ch <= (byte)'9'))                              || (ch == (byte)'I')                              || (ch == (byte)'N'))                              ReadNumericalText();                          else                              throw new XmlException("JsonEncounteredUnexpectedCharacter");                          break;                  }
Magic Number,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,ReadEscapedCharacter,The following statement contains a magic number: if (ch1 == Keys.LowerU)              {                  // Skip the lower u                  this.BufferReader.SkipByte();                    int offset;                  // Get next 5 char                    byte[] buffer = this.BufferReader.GetBuffer(5' out offset);                    string string1 = Encoding.UTF8.GetString(buffer' offset' 4);                  this.BufferReader.Advance(4);                    int ch2 = ParseChar(string1' NumberStyles.HexNumber);                    if (char.IsHighSurrogate((char)ch2) && this.BufferReader.GetByte() == Keys.BackSlash)                  {                      this.BufferReader.SkipByte();                        // Skip the lower U                      this.SkipExpectedByteInBufferReader(Keys.LowerU);                        buffer = this.BufferReader.GetBuffer(5' out offset);                        string string2 = Encoding.UTF8.GetString(buffer' offset' 4);                        this.BufferReader.Advance(4);                        char ch3 = ParseChar(string2' NumberStyles.HexNumber);                        if (!char.IsLowSurrogate(ch3))                          throw new XmlException("XmlInvalidLowSurrogate");                        // ch2 = new SurrogateChar(ch3' (char)ch2).Char;                  }                  if (buffer[offset + 4] == Keys.DoubleQuote)                  {                      this.BufferReader.SkipByte();                      if (moveToText)                          this.MoveToAtomicText().Value.SetCharValue(ch2);                      this.complexTextMode = JsonComplexTextMode.None;                  }                  else                  {                      if (moveToText)                          this.MoveToComplexText().Value.SetCharValue(ch2);                      this.complexTextMode = JsonComplexTextMode.QuotedText;                  }                }              else              {                  switch (ch1)                  {                      case 'n':                          ch1 = '\n';                          break;                      case 'r':                          ch1 = '\r';                          break;                      case 't':                          ch1 = '\t';                          break;                      case 'b':                          ch1 = '\b';                          break;                      case 'f':                          break;                      case '"':                      case '/':                      case '\\':                          break;                      default:                          throw new XmlException("JsonEncounteredUnexpectedCharacter");                  }                    // skip current byte                  this.BufferReader.SkipByte();                    if (this.BufferReader.GetByte() == Keys.DoubleQuote)                  {                      this.BufferReader.SkipByte();                      if (moveToText)                          this.MoveToAtomicText().Value.SetCharValue(ch1);                        complexTextMode = JsonComplexTextMode.None;                  }                  else                  {                      if (moveToText)                          this.MoveToComplexText().Value.SetCharValue(ch1);                        complexTextMode = JsonComplexTextMode.QuotedText;                  }              }
Magic Number,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,ReadEscapedCharacter,The following statement contains a magic number: if (ch1 == Keys.LowerU)              {                  // Skip the lower u                  this.BufferReader.SkipByte();                    int offset;                  // Get next 5 char                    byte[] buffer = this.BufferReader.GetBuffer(5' out offset);                    string string1 = Encoding.UTF8.GetString(buffer' offset' 4);                  this.BufferReader.Advance(4);                    int ch2 = ParseChar(string1' NumberStyles.HexNumber);                    if (char.IsHighSurrogate((char)ch2) && this.BufferReader.GetByte() == Keys.BackSlash)                  {                      this.BufferReader.SkipByte();                        // Skip the lower U                      this.SkipExpectedByteInBufferReader(Keys.LowerU);                        buffer = this.BufferReader.GetBuffer(5' out offset);                        string string2 = Encoding.UTF8.GetString(buffer' offset' 4);                        this.BufferReader.Advance(4);                        char ch3 = ParseChar(string2' NumberStyles.HexNumber);                        if (!char.IsLowSurrogate(ch3))                          throw new XmlException("XmlInvalidLowSurrogate");                        // ch2 = new SurrogateChar(ch3' (char)ch2).Char;                  }                  if (buffer[offset + 4] == Keys.DoubleQuote)                  {                      this.BufferReader.SkipByte();                      if (moveToText)                          this.MoveToAtomicText().Value.SetCharValue(ch2);                      this.complexTextMode = JsonComplexTextMode.None;                  }                  else                  {                      if (moveToText)                          this.MoveToComplexText().Value.SetCharValue(ch2);                      this.complexTextMode = JsonComplexTextMode.QuotedText;                  }                }              else              {                  switch (ch1)                  {                      case 'n':                          ch1 = '\n';                          break;                      case 'r':                          ch1 = '\r';                          break;                      case 't':                          ch1 = '\t';                          break;                      case 'b':                          ch1 = '\b';                          break;                      case 'f':                          break;                      case '"':                      case '/':                      case '\\':                          break;                      default:                          throw new XmlException("JsonEncounteredUnexpectedCharacter");                  }                    // skip current byte                  this.BufferReader.SkipByte();                    if (this.BufferReader.GetByte() == Keys.DoubleQuote)                  {                      this.BufferReader.SkipByte();                      if (moveToText)                          this.MoveToAtomicText().Value.SetCharValue(ch1);                        complexTextMode = JsonComplexTextMode.None;                  }                  else                  {                      if (moveToText)                          this.MoveToComplexText().Value.SetCharValue(ch1);                        complexTextMode = JsonComplexTextMode.QuotedText;                  }              }
Magic Number,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,ReadEscapedCharacter,The following statement contains a magic number: if (ch1 == Keys.LowerU)              {                  // Skip the lower u                  this.BufferReader.SkipByte();                    int offset;                  // Get next 5 char                    byte[] buffer = this.BufferReader.GetBuffer(5' out offset);                    string string1 = Encoding.UTF8.GetString(buffer' offset' 4);                  this.BufferReader.Advance(4);                    int ch2 = ParseChar(string1' NumberStyles.HexNumber);                    if (char.IsHighSurrogate((char)ch2) && this.BufferReader.GetByte() == Keys.BackSlash)                  {                      this.BufferReader.SkipByte();                        // Skip the lower U                      this.SkipExpectedByteInBufferReader(Keys.LowerU);                        buffer = this.BufferReader.GetBuffer(5' out offset);                        string string2 = Encoding.UTF8.GetString(buffer' offset' 4);                        this.BufferReader.Advance(4);                        char ch3 = ParseChar(string2' NumberStyles.HexNumber);                        if (!char.IsLowSurrogate(ch3))                          throw new XmlException("XmlInvalidLowSurrogate");                        // ch2 = new SurrogateChar(ch3' (char)ch2).Char;                  }                  if (buffer[offset + 4] == Keys.DoubleQuote)                  {                      this.BufferReader.SkipByte();                      if (moveToText)                          this.MoveToAtomicText().Value.SetCharValue(ch2);                      this.complexTextMode = JsonComplexTextMode.None;                  }                  else                  {                      if (moveToText)                          this.MoveToComplexText().Value.SetCharValue(ch2);                      this.complexTextMode = JsonComplexTextMode.QuotedText;                  }                }              else              {                  switch (ch1)                  {                      case 'n':                          ch1 = '\n';                          break;                      case 'r':                          ch1 = '\r';                          break;                      case 't':                          ch1 = '\t';                          break;                      case 'b':                          ch1 = '\b';                          break;                      case 'f':                          break;                      case '"':                      case '/':                      case '\\':                          break;                      default:                          throw new XmlException("JsonEncounteredUnexpectedCharacter");                  }                    // skip current byte                  this.BufferReader.SkipByte();                    if (this.BufferReader.GetByte() == Keys.DoubleQuote)                  {                      this.BufferReader.SkipByte();                      if (moveToText)                          this.MoveToAtomicText().Value.SetCharValue(ch1);                        complexTextMode = JsonComplexTextMode.None;                  }                  else                  {                      if (moveToText)                          this.MoveToComplexText().Value.SetCharValue(ch1);                        complexTextMode = JsonComplexTextMode.QuotedText;                  }              }
Magic Number,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,ReadEscapedCharacter,The following statement contains a magic number: if (ch1 == Keys.LowerU)              {                  // Skip the lower u                  this.BufferReader.SkipByte();                    int offset;                  // Get next 5 char                    byte[] buffer = this.BufferReader.GetBuffer(5' out offset);                    string string1 = Encoding.UTF8.GetString(buffer' offset' 4);                  this.BufferReader.Advance(4);                    int ch2 = ParseChar(string1' NumberStyles.HexNumber);                    if (char.IsHighSurrogate((char)ch2) && this.BufferReader.GetByte() == Keys.BackSlash)                  {                      this.BufferReader.SkipByte();                        // Skip the lower U                      this.SkipExpectedByteInBufferReader(Keys.LowerU);                        buffer = this.BufferReader.GetBuffer(5' out offset);                        string string2 = Encoding.UTF8.GetString(buffer' offset' 4);                        this.BufferReader.Advance(4);                        char ch3 = ParseChar(string2' NumberStyles.HexNumber);                        if (!char.IsLowSurrogate(ch3))                          throw new XmlException("XmlInvalidLowSurrogate");                        // ch2 = new SurrogateChar(ch3' (char)ch2).Char;                  }                  if (buffer[offset + 4] == Keys.DoubleQuote)                  {                      this.BufferReader.SkipByte();                      if (moveToText)                          this.MoveToAtomicText().Value.SetCharValue(ch2);                      this.complexTextMode = JsonComplexTextMode.None;                  }                  else                  {                      if (moveToText)                          this.MoveToComplexText().Value.SetCharValue(ch2);                      this.complexTextMode = JsonComplexTextMode.QuotedText;                  }                }              else              {                  switch (ch1)                  {                      case 'n':                          ch1 = '\n';                          break;                      case 'r':                          ch1 = '\r';                          break;                      case 't':                          ch1 = '\t';                          break;                      case 'b':                          ch1 = '\b';                          break;                      case 'f':                          break;                      case '"':                      case '/':                      case '\\':                          break;                      default:                          throw new XmlException("JsonEncounteredUnexpectedCharacter");                  }                    // skip current byte                  this.BufferReader.SkipByte();                    if (this.BufferReader.GetByte() == Keys.DoubleQuote)                  {                      this.BufferReader.SkipByte();                      if (moveToText)                          this.MoveToAtomicText().Value.SetCharValue(ch1);                        complexTextMode = JsonComplexTextMode.None;                  }                  else                  {                      if (moveToText)                          this.MoveToComplexText().Value.SetCharValue(ch1);                        complexTextMode = JsonComplexTextMode.QuotedText;                  }              }
Magic Number,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,ReadEscapedCharacter,The following statement contains a magic number: if (ch1 == Keys.LowerU)              {                  // Skip the lower u                  this.BufferReader.SkipByte();                    int offset;                  // Get next 5 char                    byte[] buffer = this.BufferReader.GetBuffer(5' out offset);                    string string1 = Encoding.UTF8.GetString(buffer' offset' 4);                  this.BufferReader.Advance(4);                    int ch2 = ParseChar(string1' NumberStyles.HexNumber);                    if (char.IsHighSurrogate((char)ch2) && this.BufferReader.GetByte() == Keys.BackSlash)                  {                      this.BufferReader.SkipByte();                        // Skip the lower U                      this.SkipExpectedByteInBufferReader(Keys.LowerU);                        buffer = this.BufferReader.GetBuffer(5' out offset);                        string string2 = Encoding.UTF8.GetString(buffer' offset' 4);                        this.BufferReader.Advance(4);                        char ch3 = ParseChar(string2' NumberStyles.HexNumber);                        if (!char.IsLowSurrogate(ch3))                          throw new XmlException("XmlInvalidLowSurrogate");                        // ch2 = new SurrogateChar(ch3' (char)ch2).Char;                  }                  if (buffer[offset + 4] == Keys.DoubleQuote)                  {                      this.BufferReader.SkipByte();                      if (moveToText)                          this.MoveToAtomicText().Value.SetCharValue(ch2);                      this.complexTextMode = JsonComplexTextMode.None;                  }                  else                  {                      if (moveToText)                          this.MoveToComplexText().Value.SetCharValue(ch2);                      this.complexTextMode = JsonComplexTextMode.QuotedText;                  }                }              else              {                  switch (ch1)                  {                      case 'n':                          ch1 = '\n';                          break;                      case 'r':                          ch1 = '\r';                          break;                      case 't':                          ch1 = '\t';                          break;                      case 'b':                          ch1 = '\b';                          break;                      case 'f':                          break;                      case '"':                      case '/':                      case '\\':                          break;                      default:                          throw new XmlException("JsonEncounteredUnexpectedCharacter");                  }                    // skip current byte                  this.BufferReader.SkipByte();                    if (this.BufferReader.GetByte() == Keys.DoubleQuote)                  {                      this.BufferReader.SkipByte();                      if (moveToText)                          this.MoveToAtomicText().Value.SetCharValue(ch1);                        complexTextMode = JsonComplexTextMode.None;                  }                  else                  {                      if (moveToText)                          this.MoveToComplexText().Value.SetCharValue(ch1);                        complexTextMode = JsonComplexTextMode.QuotedText;                  }              }
Magic Number,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,ReadEscapedCharacter,The following statement contains a magic number: if (ch1 == Keys.LowerU)              {                  // Skip the lower u                  this.BufferReader.SkipByte();                    int offset;                  // Get next 5 char                    byte[] buffer = this.BufferReader.GetBuffer(5' out offset);                    string string1 = Encoding.UTF8.GetString(buffer' offset' 4);                  this.BufferReader.Advance(4);                    int ch2 = ParseChar(string1' NumberStyles.HexNumber);                    if (char.IsHighSurrogate((char)ch2) && this.BufferReader.GetByte() == Keys.BackSlash)                  {                      this.BufferReader.SkipByte();                        // Skip the lower U                      this.SkipExpectedByteInBufferReader(Keys.LowerU);                        buffer = this.BufferReader.GetBuffer(5' out offset);                        string string2 = Encoding.UTF8.GetString(buffer' offset' 4);                        this.BufferReader.Advance(4);                        char ch3 = ParseChar(string2' NumberStyles.HexNumber);                        if (!char.IsLowSurrogate(ch3))                          throw new XmlException("XmlInvalidLowSurrogate");                        // ch2 = new SurrogateChar(ch3' (char)ch2).Char;                  }                  if (buffer[offset + 4] == Keys.DoubleQuote)                  {                      this.BufferReader.SkipByte();                      if (moveToText)                          this.MoveToAtomicText().Value.SetCharValue(ch2);                      this.complexTextMode = JsonComplexTextMode.None;                  }                  else                  {                      if (moveToText)                          this.MoveToComplexText().Value.SetCharValue(ch2);                      this.complexTextMode = JsonComplexTextMode.QuotedText;                  }                }              else              {                  switch (ch1)                  {                      case 'n':                          ch1 = '\n';                          break;                      case 'r':                          ch1 = '\r';                          break;                      case 't':                          ch1 = '\t';                          break;                      case 'b':                          ch1 = '\b';                          break;                      case 'f':                          break;                      case '"':                      case '/':                      case '\\':                          break;                      default:                          throw new XmlException("JsonEncounteredUnexpectedCharacter");                  }                    // skip current byte                  this.BufferReader.SkipByte();                    if (this.BufferReader.GetByte() == Keys.DoubleQuote)                  {                      this.BufferReader.SkipByte();                      if (moveToText)                          this.MoveToAtomicText().Value.SetCharValue(ch1);                        complexTextMode = JsonComplexTextMode.None;                  }                  else                  {                      if (moveToText)                          this.MoveToComplexText().Value.SetCharValue(ch1);                        complexTextMode = JsonComplexTextMode.QuotedText;                  }              }
Magic Number,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,ReadEscapedCharacter,The following statement contains a magic number: if (ch1 == Keys.LowerU)              {                  // Skip the lower u                  this.BufferReader.SkipByte();                    int offset;                  // Get next 5 char                    byte[] buffer = this.BufferReader.GetBuffer(5' out offset);                    string string1 = Encoding.UTF8.GetString(buffer' offset' 4);                  this.BufferReader.Advance(4);                    int ch2 = ParseChar(string1' NumberStyles.HexNumber);                    if (char.IsHighSurrogate((char)ch2) && this.BufferReader.GetByte() == Keys.BackSlash)                  {                      this.BufferReader.SkipByte();                        // Skip the lower U                      this.SkipExpectedByteInBufferReader(Keys.LowerU);                        buffer = this.BufferReader.GetBuffer(5' out offset);                        string string2 = Encoding.UTF8.GetString(buffer' offset' 4);                        this.BufferReader.Advance(4);                        char ch3 = ParseChar(string2' NumberStyles.HexNumber);                        if (!char.IsLowSurrogate(ch3))                          throw new XmlException("XmlInvalidLowSurrogate");                        // ch2 = new SurrogateChar(ch3' (char)ch2).Char;                  }                  if (buffer[offset + 4] == Keys.DoubleQuote)                  {                      this.BufferReader.SkipByte();                      if (moveToText)                          this.MoveToAtomicText().Value.SetCharValue(ch2);                      this.complexTextMode = JsonComplexTextMode.None;                  }                  else                  {                      if (moveToText)                          this.MoveToComplexText().Value.SetCharValue(ch2);                      this.complexTextMode = JsonComplexTextMode.QuotedText;                  }                }              else              {                  switch (ch1)                  {                      case 'n':                          ch1 = '\n';                          break;                      case 'r':                          ch1 = '\r';                          break;                      case 't':                          ch1 = '\t';                          break;                      case 'b':                          ch1 = '\b';                          break;                      case 'f':                          break;                      case '"':                      case '/':                      case '\\':                          break;                      default:                          throw new XmlException("JsonEncounteredUnexpectedCharacter");                  }                    // skip current byte                  this.BufferReader.SkipByte();                    if (this.BufferReader.GetByte() == Keys.DoubleQuote)                  {                      this.BufferReader.SkipByte();                      if (moveToText)                          this.MoveToAtomicText().Value.SetCharValue(ch1);                        complexTextMode = JsonComplexTextMode.None;                  }                  else                  {                      if (moveToText)                          this.MoveToComplexText().Value.SetCharValue(ch1);                        complexTextMode = JsonComplexTextMode.QuotedText;                  }              }
Magic Number,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,ReadNonFFFE,The following statement contains a magic number: byte[] buffer = this.BufferReader.GetBuffer(3' out offset);
Magic Number,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,ReadNonFFFE,The following statement contains a magic number: if (buffer[offset + 1] == 191 && (buffer[offset + 2] == 190 || buffer[offset + 2] == 191))                  throw new XmlException("JsonInvalidFFFE");
Magic Number,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,ReadNonFFFE,The following statement contains a magic number: if (buffer[offset + 1] == 191 && (buffer[offset + 2] == 190 || buffer[offset + 2] == 191))                  throw new XmlException("JsonInvalidFFFE");
Magic Number,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,ReadNonFFFE,The following statement contains a magic number: if (buffer[offset + 1] == 191 && (buffer[offset + 2] == 190 || buffer[offset + 2] == 191))                  throw new XmlException("JsonInvalidFFFE");
Magic Number,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,ReadNonFFFE,The following statement contains a magic number: if (buffer[offset + 1] == 191 && (buffer[offset + 2] == 190 || buffer[offset + 2] == 191))                  throw new XmlException("JsonInvalidFFFE");
Magic Number,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,ReadNonFFFE,The following statement contains a magic number: if (buffer[offset + 1] == 191 && (buffer[offset + 2] == 190 || buffer[offset + 2] == 191))                  throw new XmlException("JsonInvalidFFFE");
Magic Number,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,ReadNonFFFE,The following statement contains a magic number: return 3;
Magic Number,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,ReadQuotedText,The following statement contains a magic number: if (escaped && this.BufferReader.GetByte() == 239)              {                  offset = this.BufferReader.Offset;                  num = ReadNonFFFE();              }
Magic Number,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,UnescapeJsonString,The following statement contains a magic number: for (int index = 0; index < val.Length; ++index)              {                  // If we have a back slash                   if (val[index] == Keys.BackSlash)                  {                      // add all the chars before                      stringBuilder.Append(val' startIndex' count);                        // pass the back slash                      ++index;                        if (index >= val.Length)                          throw new XmlException("JsonEncounteredUnexpectedCharacter");                        switch (val[index])                      {                          case 'n':                              stringBuilder.Append('\n');                              break;                          case 'r':                              stringBuilder.Append('\r');                              break;                          case 't':                              stringBuilder.Append('\t');                              break;                          case 'u':                              if (index + 3 >= val.Length)                                  throw new XmlException("JsonEncounteredUnexpectedCharacter");                                stringBuilder.Append(ParseChar(val.Substring(index + 1' 4)' NumberStyles.HexNumber));                              index += 4;                              break;                          case 'b':                              stringBuilder.Append('\b');                              break;                          case 'f':                              stringBuilder.Append('\f');                              break;                          case '/':                          case '\\':                          case '"':                          case '\'':                              stringBuilder.Append(val[index]);                              break;                      }                      startIndex = index + 1;                      count = 0;                  }                  else                      ++count;              }
Magic Number,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,UnescapeJsonString,The following statement contains a magic number: for (int index = 0; index < val.Length; ++index)              {                  // If we have a back slash                   if (val[index] == Keys.BackSlash)                  {                      // add all the chars before                      stringBuilder.Append(val' startIndex' count);                        // pass the back slash                      ++index;                        if (index >= val.Length)                          throw new XmlException("JsonEncounteredUnexpectedCharacter");                        switch (val[index])                      {                          case 'n':                              stringBuilder.Append('\n');                              break;                          case 'r':                              stringBuilder.Append('\r');                              break;                          case 't':                              stringBuilder.Append('\t');                              break;                          case 'u':                              if (index + 3 >= val.Length)                                  throw new XmlException("JsonEncounteredUnexpectedCharacter");                                stringBuilder.Append(ParseChar(val.Substring(index + 1' 4)' NumberStyles.HexNumber));                              index += 4;                              break;                          case 'b':                              stringBuilder.Append('\b');                              break;                          case 'f':                              stringBuilder.Append('\f');                              break;                          case '/':                          case '\\':                          case '"':                          case '\'':                              stringBuilder.Append(val[index]);                              break;                      }                      startIndex = index + 1;                      count = 0;                  }                  else                      ++count;              }
Magic Number,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,UnescapeJsonString,The following statement contains a magic number: for (int index = 0; index < val.Length; ++index)              {                  // If we have a back slash                   if (val[index] == Keys.BackSlash)                  {                      // add all the chars before                      stringBuilder.Append(val' startIndex' count);                        // pass the back slash                      ++index;                        if (index >= val.Length)                          throw new XmlException("JsonEncounteredUnexpectedCharacter");                        switch (val[index])                      {                          case 'n':                              stringBuilder.Append('\n');                              break;                          case 'r':                              stringBuilder.Append('\r');                              break;                          case 't':                              stringBuilder.Append('\t');                              break;                          case 'u':                              if (index + 3 >= val.Length)                                  throw new XmlException("JsonEncounteredUnexpectedCharacter");                                stringBuilder.Append(ParseChar(val.Substring(index + 1' 4)' NumberStyles.HexNumber));                              index += 4;                              break;                          case 'b':                              stringBuilder.Append('\b');                              break;                          case 'f':                              stringBuilder.Append('\f');                              break;                          case '/':                          case '\\':                          case '"':                          case '\'':                              stringBuilder.Append(val[index]);                              break;                      }                      startIndex = index + 1;                      count = 0;                  }                  else                      ++count;              }
Magic Number,Microsoft.Synchronization.ClientServices,XmlJsonWriter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonWriter.cs,EnterScope,The following statement contains a magic number: if (scopes == null)                  scopes = new JsonNodeType[4];              else if (scopes.Length == depth)              {                  var jsonNodeTypeArray = new JsonNodeType[depth * 2];                  Array.Copy(scopes' jsonNodeTypeArray' depth);                  scopes = jsonNodeTypeArray;              }
Magic Number,Microsoft.Synchronization.ClientServices,XmlJsonWriter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonWriter.cs,EnterScope,The following statement contains a magic number: if (scopes == null)                  scopes = new JsonNodeType[4];              else if (scopes.Length == depth)              {                  var jsonNodeTypeArray = new JsonNodeType[depth * 2];                  Array.Copy(scopes' jsonNodeTypeArray' depth);                  scopes = jsonNodeTypeArray;              }
Magic Number,Microsoft.Synchronization.ClientServices,XmlJsonWriter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonWriter.cs,InitializeWriter,The following statement contains a magic number: if (scopes != null && scopes.Length > 25)                  scopes = null;
Magic Number,Microsoft.Synchronization.ClientServices.SQLite,SQLiteContext,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteContext.cs,CheckSchemaAndUriAsync,The following statement contains a magic number: await Task.Run(() =>              {                    DateTime durationStartDate = DateTime.Now;                    this.Configuration = this.Manager.ReadConfiguration(scope);                    if (progress != null)                      progress.Report(new SyncProgressEvent(SyncStage.ReadingConfiguration' DateTime.Now.Subtract(durationStartDate)));                    if (this.Configuration != null)                  {                        // Verify the scope uri.                      if (this.Configuration.ServiceUri.AbsoluteUri != uri.AbsoluteUri)                          throw new ArgumentException(                              "Specified uri does not match uri previously used for the specified database");                        // Verify the types.                      List<Type> userTypes = offlineSchema.Collections.ToList();                        // Sort by name (the class Type isn't sortable)                      userTypes.Sort((x' y) => String.Compare(x.FullName' y.FullName' StringComparison.Ordinal));                        if (userTypes.Count != this.Configuration.Types.Count)                          throw new ArgumentException(                              "Specified offlineSchema does not match database Offline schema previously used for cache path");                        // Fix                     this.Configuration.Types.Sort((x' y) => String.Compare(x' y' StringComparison.Ordinal));                        if (userTypes.Where(                          (t' i) => t.FullName != this.Configuration.Types[i]).Any())                          throw new ArgumentException(                              "Specified offlineSchema does not match database Offline schema previously used for cache path");                    }                  else                  {                      bool existScope = this.Manager.ScopeTableExist();                        if (!existScope)                      {                          durationStartDate = DateTime.Now;                            this.Manager.CreateScopeTable();                            if (progress != null)                              progress.Report(new SyncProgressEvent(SyncStage.CreatingScope' DateTime.Now.Subtract(durationStartDate)));                      }                        // Get the list of types as strings and sort to make comparison                      // faster when reading.                      List<string> types = (from type in offlineSchema.Collections                                            select type.FullName).ToList();                      types.Sort();                        // Create the initial configuration                      this.Configuration = new SQLiteConfiguration                      {                          AnchorBlob = null'                          LastSyncDate = new DateTime(1900' 01' 01)'                          ScopeName = scope'                          ServiceUri = uri'                          Types = types                      };                        durationStartDate = DateTime.Now;                        this.Manager.SaveConfiguration(this.Configuration);                        if (progress != null)                          progress.Report(new SyncProgressEvent(SyncStage.ApplyingConfiguration' DateTime.Now.Subtract(durationStartDate)));                  }                    // Try to save tables if not exists                  if (schema == null || schema.Collections == null || schema.Collections.Count == 0)                      return;                    durationStartDate = DateTime.Now;                  foreach (var table in schema.Collections.Where(table => table.Name != SQLiteConstants.ScopeInfo))                  {                      this.Manager.CreateTable(table);                  }                    if (progress != null)                      progress.Report(new SyncProgressEvent(SyncStage.CheckingTables' DateTime.Now.Subtract(durationStartDate)));                  });
Magic Number,Microsoft.Synchronization.ClientServices.SQLite,SQLiteHelper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteHelper.cs,UpdateDirtyTrackingEntities,The following statement contains a magic number: using (SQLiteDatabaseConnection connection = SQLitePCL.pretty.SQLite3.Open(localFilePath))              {                  // Get mapping from my type                  var map = manager.GetMapping(ty);                  var queryUpdateDirtyTracking = String.Format(SQLiteConstants.UpdateDirtyTracking' map.TableName);                    connection.RunInTransaction((conn) =>                  {                      try                      {                          foreach (var entity in entities)                          {                                // Set Values for tracking table                              var parameters = new object[5];                              parameters[0] = P(entity.ServiceMetadata.IsTombstone);                              parameters[1] = P(0);                              parameters[2] = P(entity.ServiceMetadata.ETag);                                  var editUri = String.Empty;                              if (entity.ServiceMetadata.EditUri != null && entity.ServiceMetadata.EditUri.IsAbsoluteUri)                                  editUri = entity.ServiceMetadata.EditUri.AbsoluteUri;                                parameters[3] = P(editUri);                              parameters[4] = P(entity.ServiceMetadata.Id);                                conn.Execute(queryUpdateDirtyTracking' parameters);                          }                      }                      catch (Exception ex)                      {                          Debug.WriteLine(ex.Message);                          throw;                      }                  });              }
Magic Number,Microsoft.Synchronization.ClientServices.SQLite,SQLiteHelper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteHelper.cs,UpdateDirtyTrackingEntities,The following statement contains a magic number: using (SQLiteDatabaseConnection connection = SQLitePCL.pretty.SQLite3.Open(localFilePath))              {                  // Get mapping from my type                  var map = manager.GetMapping(ty);                  var queryUpdateDirtyTracking = String.Format(SQLiteConstants.UpdateDirtyTracking' map.TableName);                    connection.RunInTransaction((conn) =>                  {                      try                      {                          foreach (var entity in entities)                          {                                // Set Values for tracking table                              var parameters = new object[5];                              parameters[0] = P(entity.ServiceMetadata.IsTombstone);                              parameters[1] = P(0);                              parameters[2] = P(entity.ServiceMetadata.ETag);                                  var editUri = String.Empty;                              if (entity.ServiceMetadata.EditUri != null && entity.ServiceMetadata.EditUri.IsAbsoluteUri)                                  editUri = entity.ServiceMetadata.EditUri.AbsoluteUri;                                parameters[3] = P(editUri);                              parameters[4] = P(entity.ServiceMetadata.Id);                                conn.Execute(queryUpdateDirtyTracking' parameters);                          }                      }                      catch (Exception ex)                      {                          Debug.WriteLine(ex.Message);                          throw;                      }                  });              }
Magic Number,Microsoft.Synchronization.ClientServices.SQLite,SQLiteHelper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteHelper.cs,UpdateDirtyTrackingEntities,The following statement contains a magic number: using (SQLiteDatabaseConnection connection = SQLitePCL.pretty.SQLite3.Open(localFilePath))              {                  // Get mapping from my type                  var map = manager.GetMapping(ty);                  var queryUpdateDirtyTracking = String.Format(SQLiteConstants.UpdateDirtyTracking' map.TableName);                    connection.RunInTransaction((conn) =>                  {                      try                      {                          foreach (var entity in entities)                          {                                // Set Values for tracking table                              var parameters = new object[5];                              parameters[0] = P(entity.ServiceMetadata.IsTombstone);                              parameters[1] = P(0);                              parameters[2] = P(entity.ServiceMetadata.ETag);                                  var editUri = String.Empty;                              if (entity.ServiceMetadata.EditUri != null && entity.ServiceMetadata.EditUri.IsAbsoluteUri)                                  editUri = entity.ServiceMetadata.EditUri.AbsoluteUri;                                parameters[3] = P(editUri);                              parameters[4] = P(entity.ServiceMetadata.Id);                                conn.Execute(queryUpdateDirtyTracking' parameters);                          }                      }                      catch (Exception ex)                      {                          Debug.WriteLine(ex.Message);                          throw;                      }                  });              }
Magic Number,Microsoft.Synchronization.ClientServices.SQLite,SQLiteHelper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteHelper.cs,UpdateDirtyTrackingEntities,The following statement contains a magic number: using (SQLiteDatabaseConnection connection = SQLitePCL.pretty.SQLite3.Open(localFilePath))              {                  // Get mapping from my type                  var map = manager.GetMapping(ty);                  var queryUpdateDirtyTracking = String.Format(SQLiteConstants.UpdateDirtyTracking' map.TableName);                    connection.RunInTransaction((conn) =>                  {                      try                      {                          foreach (var entity in entities)                          {                                // Set Values for tracking table                              var parameters = new object[5];                              parameters[0] = P(entity.ServiceMetadata.IsTombstone);                              parameters[1] = P(0);                              parameters[2] = P(entity.ServiceMetadata.ETag);                                  var editUri = String.Empty;                              if (entity.ServiceMetadata.EditUri != null && entity.ServiceMetadata.EditUri.IsAbsoluteUri)                                  editUri = entity.ServiceMetadata.EditUri.AbsoluteUri;                                parameters[3] = P(editUri);                              parameters[4] = P(entity.ServiceMetadata.Id);                                conn.Execute(queryUpdateDirtyTracking' parameters);                          }                      }                      catch (Exception ex)                      {                          Debug.WriteLine(ex.Message);                          throw;                      }                  });              }
Magic Number,Microsoft.Synchronization.ClientServices.SQLite,SQLiteHelper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteHelper.cs,GetChanges,The following statement contains a magic number: using (SQLiteDatabaseConnection connection = SQLitePCL.pretty.SQLite3.Open(localFilePath))              {                  try                  {                      foreach (var ty in schema.Collections)                      {                          // Get mapping from my type                          var map = manager.GetMapping(ty);                            // Create query to select changes                           var querySelect = SQLiteConstants.SelectChanges;                            var columnsDcl = new List<String>();                          var columnsPK = new List<String>();                              // Foreach columns' create the tsql command to execute                          foreach (var c in map.Columns)                          {                              if (!c.IsPK)                                  columnsDcl.Add("[s].[" + c.Name + "]");                                // If it's the PK' add it from Tracking (because of deleted items not in real table                              if (c.IsPK)                              {                                  columnsDcl.Add("[t].[" + c.Name + "]");                                  columnsPK.Add("[s].[" + c.Name + "] = [t].[" + c.Name + "]");                              }                            }                            var decl = string.Join("'\n"' columnsDcl.ToArray());                          var pk = string.Join(" \nAND "' columnsPK.ToArray());                          querySelect = String.Format(querySelect' map.TableName' pk' decl);                            // add limit if specified                          if (uploadBatchSize > 0)                              querySelect += $" LIMIT {uploadBatchSize}";                                                    try                          {                              // Get mapping form the statement                              var cols = new TableMapping.Column[map.Columns.Length];                              bool firstRow = true;                                // While row is available                              foreach(var row in connection.Query(querySelect' P(lastModifiedDate)))                              {                                  if (firstRow)                                  {                                      // Foreach column' get the property in my object                                      for (int i = 0; i < cols.Length; i++)                                      {                                          var name = row[i].ColumnInfo.Name;                                          var c = map.FindColumn(name);                                          if (c != null)                                              cols[i] = map.FindColumn(name);                                      }                                        firstRow = false;                                  }                                    // Create the object                                  SQLiteOfflineEntity obj = (SQLiteOfflineEntity)Activator.CreateInstance(map.MappedType);                                    for (int i = 0; i < cols.Length; i++)                                  {                                      if (cols[i] == null)                                          continue;                                        // Read the column                                      var val = ReadCol(row' i' cols[i].ColumnType);                                        // Set the value                                      cols[i].SetValue(obj' val);                                  }                                    // Read the Oem Properties                                  var newIndex = map.Columns.Count();                                    obj.ServiceMetadata = new OfflineEntityMetadata();                                    obj.ServiceMetadata.IsTombstone = (bool)ReadCol(row' newIndex' typeof(Boolean));                                  obj.ServiceMetadata.Id = (String)ReadCol(row' newIndex + 1' typeof(String));                                  obj.ServiceMetadata.ETag = (String)ReadCol(row' newIndex + 2' typeof(String));                                  String absoluteUri = (String)ReadCol(row' newIndex + 3' typeof(String));                                  obj.ServiceMetadata.EditUri = String.IsNullOrEmpty(absoluteUri) ? null : new Uri(absoluteUri);                                    lstChanges.Add(obj);                                }                          }                          catch (Exception ex)                          {                              Debug.WriteLine(ex.Message);                              throw;                          }                            // if we are batching uploads and the upload rowcount has been reached' skip                          if (uploadBatchSize > 0 && lstChanges.Count >= uploadBatchSize)                              break;                        }                  }                  catch (Exception ex)                  {                      Debug.WriteLine(ex.Message);                      throw;                  }                }
Magic Number,Microsoft.Synchronization.ClientServices.SQLite,SQLiteHelper,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteHelper.cs,GetChanges,The following statement contains a magic number: using (SQLiteDatabaseConnection connection = SQLitePCL.pretty.SQLite3.Open(localFilePath))              {                  try                  {                      foreach (var ty in schema.Collections)                      {                          // Get mapping from my type                          var map = manager.GetMapping(ty);                            // Create query to select changes                           var querySelect = SQLiteConstants.SelectChanges;                            var columnsDcl = new List<String>();                          var columnsPK = new List<String>();                              // Foreach columns' create the tsql command to execute                          foreach (var c in map.Columns)                          {                              if (!c.IsPK)                                  columnsDcl.Add("[s].[" + c.Name + "]");                                // If it's the PK' add it from Tracking (because of deleted items not in real table                              if (c.IsPK)                              {                                  columnsDcl.Add("[t].[" + c.Name + "]");                                  columnsPK.Add("[s].[" + c.Name + "] = [t].[" + c.Name + "]");                              }                            }                            var decl = string.Join("'\n"' columnsDcl.ToArray());                          var pk = string.Join(" \nAND "' columnsPK.ToArray());                          querySelect = String.Format(querySelect' map.TableName' pk' decl);                            // add limit if specified                          if (uploadBatchSize > 0)                              querySelect += $" LIMIT {uploadBatchSize}";                                                    try                          {                              // Get mapping form the statement                              var cols = new TableMapping.Column[map.Columns.Length];                              bool firstRow = true;                                // While row is available                              foreach(var row in connection.Query(querySelect' P(lastModifiedDate)))                              {                                  if (firstRow)                                  {                                      // Foreach column' get the property in my object                                      for (int i = 0; i < cols.Length; i++)                                      {                                          var name = row[i].ColumnInfo.Name;                                          var c = map.FindColumn(name);                                          if (c != null)                                              cols[i] = map.FindColumn(name);                                      }                                        firstRow = false;                                  }                                    // Create the object                                  SQLiteOfflineEntity obj = (SQLiteOfflineEntity)Activator.CreateInstance(map.MappedType);                                    for (int i = 0; i < cols.Length; i++)                                  {                                      if (cols[i] == null)                                          continue;                                        // Read the column                                      var val = ReadCol(row' i' cols[i].ColumnType);                                        // Set the value                                      cols[i].SetValue(obj' val);                                  }                                    // Read the Oem Properties                                  var newIndex = map.Columns.Count();                                    obj.ServiceMetadata = new OfflineEntityMetadata();                                    obj.ServiceMetadata.IsTombstone = (bool)ReadCol(row' newIndex' typeof(Boolean));                                  obj.ServiceMetadata.Id = (String)ReadCol(row' newIndex + 1' typeof(String));                                  obj.ServiceMetadata.ETag = (String)ReadCol(row' newIndex + 2' typeof(String));                                  String absoluteUri = (String)ReadCol(row' newIndex + 3' typeof(String));                                  obj.ServiceMetadata.EditUri = String.IsNullOrEmpty(absoluteUri) ? null : new Uri(absoluteUri);                                    lstChanges.Add(obj);                                }                          }                          catch (Exception ex)                          {                              Debug.WriteLine(ex.Message);                              throw;                          }                            // if we are batching uploads and the upload rowcount has been reached' skip                          if (uploadBatchSize > 0 && lstChanges.Count >= uploadBatchSize)                              break;                        }                  }                  catch (Exception ex)                  {                      Debug.WriteLine(ex.Message);                      throw;                  }                }
Magic Number,Microsoft.Synchronization.ClientServices.SQLite,SQLiteManager,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteManager.cs,ReadConfiguration,The following statement contains a magic number: using (var connection = SQLitePCL.pretty.SQLite3.Open(localFilePath))              {                  string s = null;                  List<String> t = new List<string>();                  bool scopeInfoTableFounded;                  DateTime d = new DateTime(1900' 1' 1);                  Byte[] blob = null;                  try                  {                        string name = databaseScopeName;                        ScopeInfoTable scopeInfoTable = null;                      // Check if Scope Table Exist                      string tableScope = connection.Query(SQLiteConstants.ScopeExist).Select(r => r[0].ToString()).FirstOrDefault();                        bool scopeTableExist = tableScope == "ScopeInfoTable";                        if (scopeTableExist)                      {                          String commandSelect = "Select * From ScopeInfoTable Where ScopeName = ?;";                          foreach(var row in connection.Query(commandSelect' SQLiteHelper.P(name)))                          {                              scopeInfoTable = new ScopeInfoTable();                              scopeInfoTable.ScopeName = (String)SQLiteHelper.ReadCol(row' 0' typeof(String));                              scopeInfoTable.ServiceUri =  (String)SQLiteHelper.ReadCol(row' 1' typeof(String));                              scopeInfoTable.LastSyncDate = (DateTime)SQLiteHelper.ReadCol(row' 2' typeof(DateTime));                              scopeInfoTable.AnchorBlob = (Byte[])SQLiteHelper.ReadCol(row' 3' typeof(Byte[]));                              scopeInfoTable.Configuration = (String)SQLiteHelper.ReadCol(row' 4' typeof(String));                          }                      }                          if (scopeInfoTable == null)                          return null;                        XDocument document = XDocument.Parse(scopeInfoTable.Configuration);                        s = scopeInfoTable.ServiceUri;                        t = (from tt in document.Descendants()                           where tt.Name == "Types"                           select tt.Value).ToList();                        d = scopeInfoTable.LastSyncDate;                        blob = scopeInfoTable.AnchorBlob;                        scopeInfoTableFounded = true;                      }                  catch                  {                      scopeInfoTableFounded = false;                  }                    if (!scopeInfoTableFounded)                      return null;                    // Configure Configuration en return it                  configuration.ScopeName = databaseScopeName;                  configuration.ServiceUri = new Uri(s);                  configuration.Types = t;                  configuration.LastSyncDate = d;                  configuration.AnchorBlob = blob;                  }
Magic Number,Microsoft.Synchronization.ClientServices.SQLite,SQLiteManager,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteManager.cs,ReadConfiguration,The following statement contains a magic number: using (var connection = SQLitePCL.pretty.SQLite3.Open(localFilePath))              {                  string s = null;                  List<String> t = new List<string>();                  bool scopeInfoTableFounded;                  DateTime d = new DateTime(1900' 1' 1);                  Byte[] blob = null;                  try                  {                        string name = databaseScopeName;                        ScopeInfoTable scopeInfoTable = null;                      // Check if Scope Table Exist                      string tableScope = connection.Query(SQLiteConstants.ScopeExist).Select(r => r[0].ToString()).FirstOrDefault();                        bool scopeTableExist = tableScope == "ScopeInfoTable";                        if (scopeTableExist)                      {                          String commandSelect = "Select * From ScopeInfoTable Where ScopeName = ?;";                          foreach(var row in connection.Query(commandSelect' SQLiteHelper.P(name)))                          {                              scopeInfoTable = new ScopeInfoTable();                              scopeInfoTable.ScopeName = (String)SQLiteHelper.ReadCol(row' 0' typeof(String));                              scopeInfoTable.ServiceUri =  (String)SQLiteHelper.ReadCol(row' 1' typeof(String));                              scopeInfoTable.LastSyncDate = (DateTime)SQLiteHelper.ReadCol(row' 2' typeof(DateTime));                              scopeInfoTable.AnchorBlob = (Byte[])SQLiteHelper.ReadCol(row' 3' typeof(Byte[]));                              scopeInfoTable.Configuration = (String)SQLiteHelper.ReadCol(row' 4' typeof(String));                          }                      }                          if (scopeInfoTable == null)                          return null;                        XDocument document = XDocument.Parse(scopeInfoTable.Configuration);                        s = scopeInfoTable.ServiceUri;                        t = (from tt in document.Descendants()                           where tt.Name == "Types"                           select tt.Value).ToList();                        d = scopeInfoTable.LastSyncDate;                        blob = scopeInfoTable.AnchorBlob;                        scopeInfoTableFounded = true;                      }                  catch                  {                      scopeInfoTableFounded = false;                  }                    if (!scopeInfoTableFounded)                      return null;                    // Configure Configuration en return it                  configuration.ScopeName = databaseScopeName;                  configuration.ServiceUri = new Uri(s);                  configuration.Types = t;                  configuration.LastSyncDate = d;                  configuration.AnchorBlob = blob;                  }
Magic Number,Microsoft.Synchronization.ClientServices.SQLite,SQLiteManager,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteManager.cs,ReadConfiguration,The following statement contains a magic number: using (var connection = SQLitePCL.pretty.SQLite3.Open(localFilePath))              {                  string s = null;                  List<String> t = new List<string>();                  bool scopeInfoTableFounded;                  DateTime d = new DateTime(1900' 1' 1);                  Byte[] blob = null;                  try                  {                        string name = databaseScopeName;                        ScopeInfoTable scopeInfoTable = null;                      // Check if Scope Table Exist                      string tableScope = connection.Query(SQLiteConstants.ScopeExist).Select(r => r[0].ToString()).FirstOrDefault();                        bool scopeTableExist = tableScope == "ScopeInfoTable";                        if (scopeTableExist)                      {                          String commandSelect = "Select * From ScopeInfoTable Where ScopeName = ?;";                          foreach(var row in connection.Query(commandSelect' SQLiteHelper.P(name)))                          {                              scopeInfoTable = new ScopeInfoTable();                              scopeInfoTable.ScopeName = (String)SQLiteHelper.ReadCol(row' 0' typeof(String));                              scopeInfoTable.ServiceUri =  (String)SQLiteHelper.ReadCol(row' 1' typeof(String));                              scopeInfoTable.LastSyncDate = (DateTime)SQLiteHelper.ReadCol(row' 2' typeof(DateTime));                              scopeInfoTable.AnchorBlob = (Byte[])SQLiteHelper.ReadCol(row' 3' typeof(Byte[]));                              scopeInfoTable.Configuration = (String)SQLiteHelper.ReadCol(row' 4' typeof(String));                          }                      }                          if (scopeInfoTable == null)                          return null;                        XDocument document = XDocument.Parse(scopeInfoTable.Configuration);                        s = scopeInfoTable.ServiceUri;                        t = (from tt in document.Descendants()                           where tt.Name == "Types"                           select tt.Value).ToList();                        d = scopeInfoTable.LastSyncDate;                        blob = scopeInfoTable.AnchorBlob;                        scopeInfoTableFounded = true;                      }                  catch                  {                      scopeInfoTableFounded = false;                  }                    if (!scopeInfoTableFounded)                      return null;                    // Configure Configuration en return it                  configuration.ScopeName = databaseScopeName;                  configuration.ServiceUri = new Uri(s);                  configuration.Types = t;                  configuration.LastSyncDate = d;                  configuration.AnchorBlob = blob;                  }
Magic Number,Microsoft.Synchronization.ClientServices.SQLite,SQLiteManager,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\SQLite\SQLiteManager.cs,ReadConfiguration,The following statement contains a magic number: using (var connection = SQLitePCL.pretty.SQLite3.Open(localFilePath))              {                  string s = null;                  List<String> t = new List<string>();                  bool scopeInfoTableFounded;                  DateTime d = new DateTime(1900' 1' 1);                  Byte[] blob = null;                  try                  {                        string name = databaseScopeName;                        ScopeInfoTable scopeInfoTable = null;                      // Check if Scope Table Exist                      string tableScope = connection.Query(SQLiteConstants.ScopeExist).Select(r => r[0].ToString()).FirstOrDefault();                        bool scopeTableExist = tableScope == "ScopeInfoTable";                        if (scopeTableExist)                      {                          String commandSelect = "Select * From ScopeInfoTable Where ScopeName = ?;";                          foreach(var row in connection.Query(commandSelect' SQLiteHelper.P(name)))                          {                              scopeInfoTable = new ScopeInfoTable();                              scopeInfoTable.ScopeName = (String)SQLiteHelper.ReadCol(row' 0' typeof(String));                              scopeInfoTable.ServiceUri =  (String)SQLiteHelper.ReadCol(row' 1' typeof(String));                              scopeInfoTable.LastSyncDate = (DateTime)SQLiteHelper.ReadCol(row' 2' typeof(DateTime));                              scopeInfoTable.AnchorBlob = (Byte[])SQLiteHelper.ReadCol(row' 3' typeof(Byte[]));                              scopeInfoTable.Configuration = (String)SQLiteHelper.ReadCol(row' 4' typeof(String));                          }                      }                          if (scopeInfoTable == null)                          return null;                        XDocument document = XDocument.Parse(scopeInfoTable.Configuration);                        s = scopeInfoTable.ServiceUri;                        t = (from tt in document.Descendants()                           where tt.Name == "Types"                           select tt.Value).ToList();                        d = scopeInfoTable.LastSyncDate;                        blob = scopeInfoTable.AnchorBlob;                        scopeInfoTableFounded = true;                      }                  catch                  {                      scopeInfoTableFounded = false;                  }                    if (!scopeInfoTableFounded)                      return null;                    // Configure Configuration en return it                  configuration.ScopeName = databaseScopeName;                  configuration.ServiceUri = new Uri(s);                  configuration.Types = t;                  configuration.LastSyncDate = d;                  configuration.AnchorBlob = blob;                  }
Missing Default,Microsoft.Synchronization.ClientServices,HttpCacheRequestHandler,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\ClientCommon\HttpCacheRequestHandlerAsync.cs,ReadUploadResponse,The following switch statement is missing a default case: switch (syncReader.ItemType)                                      {                                          case ReaderItemType.Entry:                                              IOfflineEntity entity = syncReader.GetItem();                                              IOfflineEntity ackedEntity = entity;                                              string tempId = null;                                                // If conflict only one temp ID should be set                                              if (syncReader.HasTempId() && syncReader.HasConflictTempId())                                              {                                                  throw new CacheControllerException(                                                      string.Format(                                                          "Service returned a TempId '{0}' in both live and conflicting entities."'                                                          syncReader.GetTempId()));                                              }                                                // Validate the live temp ID if any' before adding anything to the offline context                                              if (syncReader.HasTempId())                                              {                                                  tempId = syncReader.GetTempId();                                                  CheckEntityServiceMetadataAndTempIds(wrapper' entity' tempId);                                              }                                                //  If conflict                                               if (syncReader.HasConflict())                                              {                                                  Conflict conflict = syncReader.GetConflict();                                                  IOfflineEntity conflictEntity = (conflict is SyncConflict)                                                                                      ? ((SyncConflict)conflict).LosingEntity                                                                                      : ((SyncError)conflict).ErrorEntity;                                                    // Validate conflict temp ID if any                                                  if (syncReader.HasConflictTempId())                                                  {                                                      tempId = syncReader.GetConflictTempId();                                                      CheckEntityServiceMetadataAndTempIds(wrapper' conflictEntity' tempId);                                                  }                                                    // Add conflict                                                                                      wrapper.UploadResponse.AddConflict(conflict);                                                    //                                                  // If there is a conflict and the tempId is set in the conflict entity then the client version lost the                                                   // conflict and the live entity is the server version (ServerWins)                                                  //                                                  if (syncReader.HasConflictTempId() && entity.GetServiceMetadata().IsTombstone)                                                  {                                                      //                                                      // This is a ServerWins conflict' or conflict error. The winning version is a tombstone without temp Id                                                      // so there is no way to map the winning entity with a temp Id. The temp Id is in the conflict so we are                                                      // using the conflict entity' which has the PK' to build a tombstone entity used to update the offline context                                                      //                                                      // In theory' we should copy the service metadata but it is the same end result as the service fills in                                                      // all the properties in the conflict entity                                                      //                                                        // Add the conflict entity                                                                                                    conflictEntity.GetServiceMetadata().IsTombstone = true;                                                      ackedEntity = conflictEntity;                                                  }                                              }                                                // Add ackedEntity to storage. If ackedEntity is still equal to entity then add non-conflict entity.                                               if (!String.IsNullOrEmpty(tempId))                                              {                                                  wrapper.UploadResponse.AddUpdatedItem(ackedEntity);                                              }                                              break;                                            case ReaderItemType.SyncBlob:                                              wrapper.UploadResponse.ServerBlob = syncReader.GetServerBlob();                                              break;                                      }
Missing Default,Microsoft.Synchronization.ClientServices,HttpCacheRequestHandler,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\ClientCommon\HttpCacheRequestHandlerAsync.cs,ReadDownloadResponse,The following switch statement is missing a default case: switch (syncReader.ItemType)                                      {                                          case ReaderItemType.Entry:                                              wrapper.DownloadResponse.AddItem(syncReader.GetItem());                                              break;                                          case ReaderItemType.SyncBlob:                                              wrapper.DownloadResponse.ServerBlob = syncReader.GetServerBlob();                                              // Debug.WriteLine(SyncBlob.DeSerialize(wrapper.DownloadResponse.ServerBlob).ToString());                                              break;                                          case ReaderItemType.HasMoreChanges:                                              wrapper.DownloadResponse.IsLastBatch = !syncReader.GetHasMoreChangesValue();                                              break;                                      }
Missing Default,Microsoft.Synchronization.ClientServices,ValueHandle,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\ValueHandle.cs,ToBoolean,The following switch statement is missing a default case: switch (this.type)              {                  case ValueHandleType.False:                      return false;                  case ValueHandleType.True:                      return true;                  case ValueHandleType.UTF8:                      return XmlConverter.ToBoolean(this.bufferReader.Buffer' this.offset' this.length);                  case ValueHandleType.Int8:                      switch (this.GetInt8())                      {                          case 0:                              return false;                          case 1:                              return true;                      }                      break;              }
Missing Default,Microsoft.Synchronization.ClientServices,ValueHandle,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\ValueHandle.cs,ToBoolean,The following switch statement is missing a default case: switch (this.GetInt8())                      {                          case 0:                              return false;                          case 1:                              return true;                      }
Missing Default,Microsoft.Synchronization.ClientServices,XmlConverter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlConverter.cs,ToBoolean,The following switch statement is missing a default case: switch (buffer[offset])                  {                      case Keys.One:                          return true;                      case Keys.Zero:                          return false;                  }
Missing Default,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,IsStartElement,The following switch statement is missing a default case: switch (this.Node.NodeType)              {                  case XmlNodeType.Element:                      return true;                  case XmlNodeType.EndElement:                      return false;                  case XmlNodeType.None:                      this.Read();                      if (this.Node.NodeType == XmlNodeType.Element)                          return true;                      break;              }
Missing Default,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,Read,The following switch statement is missing a default case: switch (complexTextMode)                  {                      case JsonComplexTextMode.QuotedText:                          if (ch == Keys.BackSlash)                          {                              ReadEscapedCharacter(true);                              break;                          }                            ReadQuotedText(true);                          break;                      case JsonComplexTextMode.NumericalText:                          ReadNumericalText();                          break;                      case JsonComplexTextMode.None:                          throw new XmlException("JsonEncounteredUnexpectedCharacter");                  }
Missing Default,Microsoft.Synchronization.ClientServices,XmlJsonReader,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonReader.cs,UnescapeJsonString,The following switch statement is missing a default case: switch (val[index])                      {                          case 'n':                              stringBuilder.Append('\n');                              break;                          case 'r':                              stringBuilder.Append('\r');                              break;                          case 't':                              stringBuilder.Append('\t');                              break;                          case 'u':                              if (index + 3 >= val.Length)                                  throw new XmlException("JsonEncounteredUnexpectedCharacter");                                stringBuilder.Append(ParseChar(val.Substring(index + 1' 4)' NumberStyles.HexNumber));                              index += 4;                              break;                          case 'b':                              stringBuilder.Append('\b');                              break;                          case 'f':                              stringBuilder.Append('\f');                              break;                          case '/':                          case '\\':                          case '"':                          case '\'':                              stringBuilder.Append(val[index]);                              break;                      }
Missing Default,Microsoft.Synchronization.ClientServices,XmlJsonWriter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonWriter.cs,StartText,The following switch statement is missing a default case: switch (dataType)              {                  case JsonDataType.None:                  case JsonDataType.String:                      CheckText(JsonNodeType.QuotedText);                        if (nodeType != JsonNodeType.QuotedText)                          WriteJsonQuote();                        nodeType = JsonNodeType.QuotedText;                      break;                  case JsonDataType.Boolean:                  case JsonDataType.Number:                      CheckText(JsonNodeType.StandaloneText);                      nodeType = JsonNodeType.StandaloneText;                      break;              }
Missing Default,Microsoft.Synchronization.ClientServices,XmlJsonWriter,C:\repos\Mimetis_SyncWinRT\C#\SyncClient.Shared\Formatters\JsonXmlReader\XmlJsonWriter.cs,WriteDataTypeServerType,The following switch statement is missing a default case: switch (dataType)              {                  case JsonDataType.Null:                      nodeWriter.Write("null");                      break;                  case JsonDataType.Object:                      EnterScope(JsonNodeType.Object);                      nodeWriter.Write("{");                      break;                  case JsonDataType.Array:                      EnterScope(JsonNodeType.Collection);                      nodeWriter.Write("[");                      break;              }
