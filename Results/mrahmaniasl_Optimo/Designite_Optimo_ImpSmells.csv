Implementation smell,Namespace,Class,File,Method,Description
Long Method,Optimo,NSGAII,C:\repos\mrahmaniasl_Optimo\Optimo\metaheuristics\NSGAII.cs,execute,The method has 133 lines of code.
Complex Method,Optimo,EqualSolutions,C:\repos\mrahmaniasl_Optimo\Optimo\comparator\EqualSolutions.cs,Compare,Cyclomatic complexity of the method is 8
Complex Method,Optimo,SBXCrossover,C:\repos\mrahmaniasl_Optimo\Optimo\crossover\SBXCrossover.cs,doCrossover,Cyclomatic complexity of the method is 13
Complex Method,Optimo,NSGAII,C:\repos\mrahmaniasl_Optimo\Optimo\metaheuristics\NSGAII.cs,execute,Cyclomatic complexity of the method is 10
Complex Method,Optimo,Distance,C:\repos\mrahmaniasl_Optimo\Optimo\util\Distance.cs,crowdingDistanceAssignment,Cyclomatic complexity of the method is 10
Complex Method,Optimo,RandomPermutation,C:\repos\mrahmaniasl_Optimo\Optimo\util\RandomPermutation.cs,execute,Cyclomatic complexity of the method is 8
Complex Method,Optimo,Ranking,C:\repos\mrahmaniasl_Optimo\Optimo\util\Ranking.cs,Ranking,Cyclomatic complexity of the method is 12
Long Parameter List,Optimo,myTest,C:\repos\mrahmaniasl_Optimo\Optimo\problems\myTest.cs,myTest,The method has 5 parameters. Parameters: solutionType' NumParam' lowerLim' upperLim' numObj
Long Parameter List,Optimo,ProblemFactory,C:\repos\mrahmaniasl_Optimo\Optimo\problems\ProblemFactory.cs,getProblem,The method has 6 parameters. Parameters: name' parameters' numParam' lowerLimit' upperLimit' numObj
Long Parameter List,Optimo,NSGAII_settings,C:\repos\mrahmaniasl_Optimo\Optimo\settings\NSGAII_settings.cs,NSGAII_settings,The method has 5 parameters. Parameters: problemName' numPar' lowerLim' upperLim' numObj
Long Parameter List,Optimo,Settings,C:\repos\mrahmaniasl_Optimo\Optimo\settings\Settings.cs,Settings,The method has 5 parameters. Parameters: problemName' numP' lowerLim' upperLim' numObj
Long Parameter List,Optimo,SettingsFactory,C:\repos\mrahmaniasl_Optimo\Optimo\settings\SettingsFactory.cs,getSettingsObject,The method has 6 parameters. Parameters: algorithmName' problemName' NumParam' lowerLim' upperLim' numObj
Virtual Method Call from Constructor,Optimo,Solution,C:\repos\mrahmaniasl_Optimo\Optimo\jmetal.core\Solution.cs,Solution,The constructor "Solution" calls a virtual method "createVariables".
Magic Number,Optimo,NSGA_II,C:\repos\mrahmaniasl_Optimo\Optimo\Optimo.cs,GenerationAlgorithm,The following statement contains a magic number: Solution[] parents = new Solution[2];
Magic Number,Optimo,NSGA_II,C:\repos\mrahmaniasl_Optimo\Optimo\Optimo.cs,GenerationAlgorithm,The following statement contains a magic number: for (int i = 0; i < (populationSize / 2); i++)              {                  // selection                  parents[0] = (Solution)selectionOperator.execute(population);                  parents[1] = (Solution)selectionOperator.execute(population);                    // crossover                  Solution[] offSpring = (Solution[])crossoverOperator.execute(parents);                    // mutation                  mutationOperator.execute(offSpring[0]);                  mutationOperator.execute(offSpring[1]);                    offspringPopulation.@add(offSpring[0]);                  offspringPopulation.add(offSpring[1]);              }
Magic Number,Optimo,EqualSolutions,C:\repos\mrahmaniasl_Optimo\Optimo\comparator\EqualSolutions.cs,Compare,The following statement contains a magic number: return 2;
Magic Number,Optimo,DifferentialEvolutionCrossover,C:\repos\mrahmaniasl_Optimo\Optimo\crossover\DifferentialEvolutionCrossover.cs,execute,The following statement contains a magic number: if (DE_Variant_.CompareTo ("rand/1/bin") == 0) {          for (int j = 0; j < numberOfVariables; j++) {            if (PseudoRandom.Instance ().NextDouble () < CR_ || j == jrand) {              double val;              val = parent[2].variable_[j].value_ + F_ * (parent[0].variable_[j].value_ - parent[1].variable_[j].value_);              if (val < child.variable_[j].lowerBound_)                val = child.variable_[j].value_ = child.variable_[j].lowerBound_;              if (val > child.variable_[j].upperBound_)                val = child.variable_[j].value_ = child.variable_[j].upperBound_;                child.variable_[j].value_ = val;            } else {              child.variable_[j].value_ = current.variable_[j].value_ ;          } // else        } // for      }
Magic Number,Optimo,SBXCrossover,C:\repos\mrahmaniasl_Optimo\Optimo\crossover\SBXCrossover.cs,doCrossover,The following statement contains a magic number: Solution[] offSpring = new Solution[2];
Magic Number,Optimo,SBXCrossover,C:\repos\mrahmaniasl_Optimo\Optimo\crossover\SBXCrossover.cs,doCrossover,The following statement contains a magic number: if (PseudoRandom.Instance ().NextDouble () <= crossoverProbability_) {          for (i = 0; i < numberOfVariables; i++) {            valueX1 = x1.variable_[i].value_;            valueX2 = x2.variable_[i].value_;            if (PseudoRandom.Instance ().NextDouble () <= 0.5) {              if (Math.Abs (valueX1 - valueX2) > EPS) {                                if (valueX1 < valueX2) {                  y1 = valueX1;                  y2 = valueX2;                } else {                  y1 = valueX2;                  y2 = valueX1;                }                // if                yL = x1.variable_[i].lowerBound_;                yu = x1.variable_[i].upperBound_;                rand = PseudoRandom.Instance ().NextDouble ();                beta = 1.0 + (2.0 * (y1 - yL) / (y2 - y1));                alpha = 2.0 - Math.Pow (beta' -(distributionIndex_ + 1.0));                                if (rand <= (1.0 / alpha)) {                  betaq = Math.Pow ((rand * alpha)' (1.0 / (distributionIndex_ + 1.0)));                } else {                  betaq = Math.Pow ((1.0 / (2.0 - rand * alpha))' (1.0 / (distributionIndex_ + 1.0)));                }                // if                c1 = 0.5 * ((y1 + y2) - betaq * (y2 - y1));                beta = 1.0 + (2.0 * (yu - y2) / (y2 - y1));                alpha = 2.0 - Math.Pow (beta' -(distributionIndex_ + 1.0));                                if (rand <= (1.0 / alpha)) {                  betaq = Math.Pow ((rand * alpha)' (1.0 / (distributionIndex_ + 1.0)));                } else {                  betaq = Math.Pow ((1.0 / (2.0 - rand * alpha))' (1.0 / (distributionIndex_ + 1.0)));                }                // if                c2 = 0.5 * ((y1 + y2) + betaq * (y2 - y1));                                if (c1 < yL)                  c1 = yL;                                if (c2 < yL)                  c2 = yL;                                if (c1 > yu)                  c1 = yu;                                if (c2 > yu)                  c2 = yu;                                if (PseudoRandom.Instance ().NextDouble () <= 0.5) {                  offs1.variable_[i].value_ = c2;                  offs2.variable_[i].value_ = c1;                } else {                  offs1.variable_[i].value_ = c1;                  offs2.variable_[i].value_ = c2;                }                // if              } else {                offs1.variable_[i].value_ = valueX1;                offs2.variable_[i].value_ = valueX2;              }              // if            } else {              offs1.variable_[i].value_ = valueX2;              offs2.variable_[i].value_ = valueX1;            }            // if          }          // if        }
Magic Number,Optimo,SBXCrossover,C:\repos\mrahmaniasl_Optimo\Optimo\crossover\SBXCrossover.cs,doCrossover,The following statement contains a magic number: if (PseudoRandom.Instance ().NextDouble () <= crossoverProbability_) {          for (i = 0; i < numberOfVariables; i++) {            valueX1 = x1.variable_[i].value_;            valueX2 = x2.variable_[i].value_;            if (PseudoRandom.Instance ().NextDouble () <= 0.5) {              if (Math.Abs (valueX1 - valueX2) > EPS) {                                if (valueX1 < valueX2) {                  y1 = valueX1;                  y2 = valueX2;                } else {                  y1 = valueX2;                  y2 = valueX1;                }                // if                yL = x1.variable_[i].lowerBound_;                yu = x1.variable_[i].upperBound_;                rand = PseudoRandom.Instance ().NextDouble ();                beta = 1.0 + (2.0 * (y1 - yL) / (y2 - y1));                alpha = 2.0 - Math.Pow (beta' -(distributionIndex_ + 1.0));                                if (rand <= (1.0 / alpha)) {                  betaq = Math.Pow ((rand * alpha)' (1.0 / (distributionIndex_ + 1.0)));                } else {                  betaq = Math.Pow ((1.0 / (2.0 - rand * alpha))' (1.0 / (distributionIndex_ + 1.0)));                }                // if                c1 = 0.5 * ((y1 + y2) - betaq * (y2 - y1));                beta = 1.0 + (2.0 * (yu - y2) / (y2 - y1));                alpha = 2.0 - Math.Pow (beta' -(distributionIndex_ + 1.0));                                if (rand <= (1.0 / alpha)) {                  betaq = Math.Pow ((rand * alpha)' (1.0 / (distributionIndex_ + 1.0)));                } else {                  betaq = Math.Pow ((1.0 / (2.0 - rand * alpha))' (1.0 / (distributionIndex_ + 1.0)));                }                // if                c2 = 0.5 * ((y1 + y2) + betaq * (y2 - y1));                                if (c1 < yL)                  c1 = yL;                                if (c2 < yL)                  c2 = yL;                                if (c1 > yu)                  c1 = yu;                                if (c2 > yu)                  c2 = yu;                                if (PseudoRandom.Instance ().NextDouble () <= 0.5) {                  offs1.variable_[i].value_ = c2;                  offs2.variable_[i].value_ = c1;                } else {                  offs1.variable_[i].value_ = c1;                  offs2.variable_[i].value_ = c2;                }                // if              } else {                offs1.variable_[i].value_ = valueX1;                offs2.variable_[i].value_ = valueX2;              }              // if            } else {              offs1.variable_[i].value_ = valueX2;              offs2.variable_[i].value_ = valueX1;            }            // if          }          // if        }
Magic Number,Optimo,SBXCrossover,C:\repos\mrahmaniasl_Optimo\Optimo\crossover\SBXCrossover.cs,doCrossover,The following statement contains a magic number: if (PseudoRandom.Instance ().NextDouble () <= crossoverProbability_) {          for (i = 0; i < numberOfVariables; i++) {            valueX1 = x1.variable_[i].value_;            valueX2 = x2.variable_[i].value_;            if (PseudoRandom.Instance ().NextDouble () <= 0.5) {              if (Math.Abs (valueX1 - valueX2) > EPS) {                                if (valueX1 < valueX2) {                  y1 = valueX1;                  y2 = valueX2;                } else {                  y1 = valueX2;                  y2 = valueX1;                }                // if                yL = x1.variable_[i].lowerBound_;                yu = x1.variable_[i].upperBound_;                rand = PseudoRandom.Instance ().NextDouble ();                beta = 1.0 + (2.0 * (y1 - yL) / (y2 - y1));                alpha = 2.0 - Math.Pow (beta' -(distributionIndex_ + 1.0));                                if (rand <= (1.0 / alpha)) {                  betaq = Math.Pow ((rand * alpha)' (1.0 / (distributionIndex_ + 1.0)));                } else {                  betaq = Math.Pow ((1.0 / (2.0 - rand * alpha))' (1.0 / (distributionIndex_ + 1.0)));                }                // if                c1 = 0.5 * ((y1 + y2) - betaq * (y2 - y1));                beta = 1.0 + (2.0 * (yu - y2) / (y2 - y1));                alpha = 2.0 - Math.Pow (beta' -(distributionIndex_ + 1.0));                                if (rand <= (1.0 / alpha)) {                  betaq = Math.Pow ((rand * alpha)' (1.0 / (distributionIndex_ + 1.0)));                } else {                  betaq = Math.Pow ((1.0 / (2.0 - rand * alpha))' (1.0 / (distributionIndex_ + 1.0)));                }                // if                c2 = 0.5 * ((y1 + y2) + betaq * (y2 - y1));                                if (c1 < yL)                  c1 = yL;                                if (c2 < yL)                  c2 = yL;                                if (c1 > yu)                  c1 = yu;                                if (c2 > yu)                  c2 = yu;                                if (PseudoRandom.Instance ().NextDouble () <= 0.5) {                  offs1.variable_[i].value_ = c2;                  offs2.variable_[i].value_ = c1;                } else {                  offs1.variable_[i].value_ = c1;                  offs2.variable_[i].value_ = c2;                }                // if              } else {                offs1.variable_[i].value_ = valueX1;                offs2.variable_[i].value_ = valueX2;              }              // if            } else {              offs1.variable_[i].value_ = valueX2;              offs2.variable_[i].value_ = valueX1;            }            // if          }          // if        }
Magic Number,Optimo,SBXCrossover,C:\repos\mrahmaniasl_Optimo\Optimo\crossover\SBXCrossover.cs,doCrossover,The following statement contains a magic number: if (PseudoRandom.Instance ().NextDouble () <= crossoverProbability_) {          for (i = 0; i < numberOfVariables; i++) {            valueX1 = x1.variable_[i].value_;            valueX2 = x2.variable_[i].value_;            if (PseudoRandom.Instance ().NextDouble () <= 0.5) {              if (Math.Abs (valueX1 - valueX2) > EPS) {                                if (valueX1 < valueX2) {                  y1 = valueX1;                  y2 = valueX2;                } else {                  y1 = valueX2;                  y2 = valueX1;                }                // if                yL = x1.variable_[i].lowerBound_;                yu = x1.variable_[i].upperBound_;                rand = PseudoRandom.Instance ().NextDouble ();                beta = 1.0 + (2.0 * (y1 - yL) / (y2 - y1));                alpha = 2.0 - Math.Pow (beta' -(distributionIndex_ + 1.0));                                if (rand <= (1.0 / alpha)) {                  betaq = Math.Pow ((rand * alpha)' (1.0 / (distributionIndex_ + 1.0)));                } else {                  betaq = Math.Pow ((1.0 / (2.0 - rand * alpha))' (1.0 / (distributionIndex_ + 1.0)));                }                // if                c1 = 0.5 * ((y1 + y2) - betaq * (y2 - y1));                beta = 1.0 + (2.0 * (yu - y2) / (y2 - y1));                alpha = 2.0 - Math.Pow (beta' -(distributionIndex_ + 1.0));                                if (rand <= (1.0 / alpha)) {                  betaq = Math.Pow ((rand * alpha)' (1.0 / (distributionIndex_ + 1.0)));                } else {                  betaq = Math.Pow ((1.0 / (2.0 - rand * alpha))' (1.0 / (distributionIndex_ + 1.0)));                }                // if                c2 = 0.5 * ((y1 + y2) + betaq * (y2 - y1));                                if (c1 < yL)                  c1 = yL;                                if (c2 < yL)                  c2 = yL;                                if (c1 > yu)                  c1 = yu;                                if (c2 > yu)                  c2 = yu;                                if (PseudoRandom.Instance ().NextDouble () <= 0.5) {                  offs1.variable_[i].value_ = c2;                  offs2.variable_[i].value_ = c1;                } else {                  offs1.variable_[i].value_ = c1;                  offs2.variable_[i].value_ = c2;                }                // if              } else {                offs1.variable_[i].value_ = valueX1;                offs2.variable_[i].value_ = valueX2;              }              // if            } else {              offs1.variable_[i].value_ = valueX2;              offs2.variable_[i].value_ = valueX1;            }            // if          }          // if        }
Magic Number,Optimo,SBXCrossover,C:\repos\mrahmaniasl_Optimo\Optimo\crossover\SBXCrossover.cs,doCrossover,The following statement contains a magic number: if (PseudoRandom.Instance ().NextDouble () <= crossoverProbability_) {          for (i = 0; i < numberOfVariables; i++) {            valueX1 = x1.variable_[i].value_;            valueX2 = x2.variable_[i].value_;            if (PseudoRandom.Instance ().NextDouble () <= 0.5) {              if (Math.Abs (valueX1 - valueX2) > EPS) {                                if (valueX1 < valueX2) {                  y1 = valueX1;                  y2 = valueX2;                } else {                  y1 = valueX2;                  y2 = valueX1;                }                // if                yL = x1.variable_[i].lowerBound_;                yu = x1.variable_[i].upperBound_;                rand = PseudoRandom.Instance ().NextDouble ();                beta = 1.0 + (2.0 * (y1 - yL) / (y2 - y1));                alpha = 2.0 - Math.Pow (beta' -(distributionIndex_ + 1.0));                                if (rand <= (1.0 / alpha)) {                  betaq = Math.Pow ((rand * alpha)' (1.0 / (distributionIndex_ + 1.0)));                } else {                  betaq = Math.Pow ((1.0 / (2.0 - rand * alpha))' (1.0 / (distributionIndex_ + 1.0)));                }                // if                c1 = 0.5 * ((y1 + y2) - betaq * (y2 - y1));                beta = 1.0 + (2.0 * (yu - y2) / (y2 - y1));                alpha = 2.0 - Math.Pow (beta' -(distributionIndex_ + 1.0));                                if (rand <= (1.0 / alpha)) {                  betaq = Math.Pow ((rand * alpha)' (1.0 / (distributionIndex_ + 1.0)));                } else {                  betaq = Math.Pow ((1.0 / (2.0 - rand * alpha))' (1.0 / (distributionIndex_ + 1.0)));                }                // if                c2 = 0.5 * ((y1 + y2) + betaq * (y2 - y1));                                if (c1 < yL)                  c1 = yL;                                if (c2 < yL)                  c2 = yL;                                if (c1 > yu)                  c1 = yu;                                if (c2 > yu)                  c2 = yu;                                if (PseudoRandom.Instance ().NextDouble () <= 0.5) {                  offs1.variable_[i].value_ = c2;                  offs2.variable_[i].value_ = c1;                } else {                  offs1.variable_[i].value_ = c1;                  offs2.variable_[i].value_ = c2;                }                // if              } else {                offs1.variable_[i].value_ = valueX1;                offs2.variable_[i].value_ = valueX2;              }              // if            } else {              offs1.variable_[i].value_ = valueX2;              offs2.variable_[i].value_ = valueX1;            }            // if          }          // if        }
Magic Number,Optimo,SBXCrossover,C:\repos\mrahmaniasl_Optimo\Optimo\crossover\SBXCrossover.cs,doCrossover,The following statement contains a magic number: if (PseudoRandom.Instance ().NextDouble () <= crossoverProbability_) {          for (i = 0; i < numberOfVariables; i++) {            valueX1 = x1.variable_[i].value_;            valueX2 = x2.variable_[i].value_;            if (PseudoRandom.Instance ().NextDouble () <= 0.5) {              if (Math.Abs (valueX1 - valueX2) > EPS) {                                if (valueX1 < valueX2) {                  y1 = valueX1;                  y2 = valueX2;                } else {                  y1 = valueX2;                  y2 = valueX1;                }                // if                yL = x1.variable_[i].lowerBound_;                yu = x1.variable_[i].upperBound_;                rand = PseudoRandom.Instance ().NextDouble ();                beta = 1.0 + (2.0 * (y1 - yL) / (y2 - y1));                alpha = 2.0 - Math.Pow (beta' -(distributionIndex_ + 1.0));                                if (rand <= (1.0 / alpha)) {                  betaq = Math.Pow ((rand * alpha)' (1.0 / (distributionIndex_ + 1.0)));                } else {                  betaq = Math.Pow ((1.0 / (2.0 - rand * alpha))' (1.0 / (distributionIndex_ + 1.0)));                }                // if                c1 = 0.5 * ((y1 + y2) - betaq * (y2 - y1));                beta = 1.0 + (2.0 * (yu - y2) / (y2 - y1));                alpha = 2.0 - Math.Pow (beta' -(distributionIndex_ + 1.0));                                if (rand <= (1.0 / alpha)) {                  betaq = Math.Pow ((rand * alpha)' (1.0 / (distributionIndex_ + 1.0)));                } else {                  betaq = Math.Pow ((1.0 / (2.0 - rand * alpha))' (1.0 / (distributionIndex_ + 1.0)));                }                // if                c2 = 0.5 * ((y1 + y2) + betaq * (y2 - y1));                                if (c1 < yL)                  c1 = yL;                                if (c2 < yL)                  c2 = yL;                                if (c1 > yu)                  c1 = yu;                                if (c2 > yu)                  c2 = yu;                                if (PseudoRandom.Instance ().NextDouble () <= 0.5) {                  offs1.variable_[i].value_ = c2;                  offs2.variable_[i].value_ = c1;                } else {                  offs1.variable_[i].value_ = c1;                  offs2.variable_[i].value_ = c2;                }                // if              } else {                offs1.variable_[i].value_ = valueX1;                offs2.variable_[i].value_ = valueX2;              }              // if            } else {              offs1.variable_[i].value_ = valueX2;              offs2.variable_[i].value_ = valueX1;            }            // if          }          // if        }
Magic Number,Optimo,SBXCrossover,C:\repos\mrahmaniasl_Optimo\Optimo\crossover\SBXCrossover.cs,doCrossover,The following statement contains a magic number: if (PseudoRandom.Instance ().NextDouble () <= crossoverProbability_) {          for (i = 0; i < numberOfVariables; i++) {            valueX1 = x1.variable_[i].value_;            valueX2 = x2.variable_[i].value_;            if (PseudoRandom.Instance ().NextDouble () <= 0.5) {              if (Math.Abs (valueX1 - valueX2) > EPS) {                                if (valueX1 < valueX2) {                  y1 = valueX1;                  y2 = valueX2;                } else {                  y1 = valueX2;                  y2 = valueX1;                }                // if                yL = x1.variable_[i].lowerBound_;                yu = x1.variable_[i].upperBound_;                rand = PseudoRandom.Instance ().NextDouble ();                beta = 1.0 + (2.0 * (y1 - yL) / (y2 - y1));                alpha = 2.0 - Math.Pow (beta' -(distributionIndex_ + 1.0));                                if (rand <= (1.0 / alpha)) {                  betaq = Math.Pow ((rand * alpha)' (1.0 / (distributionIndex_ + 1.0)));                } else {                  betaq = Math.Pow ((1.0 / (2.0 - rand * alpha))' (1.0 / (distributionIndex_ + 1.0)));                }                // if                c1 = 0.5 * ((y1 + y2) - betaq * (y2 - y1));                beta = 1.0 + (2.0 * (yu - y2) / (y2 - y1));                alpha = 2.0 - Math.Pow (beta' -(distributionIndex_ + 1.0));                                if (rand <= (1.0 / alpha)) {                  betaq = Math.Pow ((rand * alpha)' (1.0 / (distributionIndex_ + 1.0)));                } else {                  betaq = Math.Pow ((1.0 / (2.0 - rand * alpha))' (1.0 / (distributionIndex_ + 1.0)));                }                // if                c2 = 0.5 * ((y1 + y2) + betaq * (y2 - y1));                                if (c1 < yL)                  c1 = yL;                                if (c2 < yL)                  c2 = yL;                                if (c1 > yu)                  c1 = yu;                                if (c2 > yu)                  c2 = yu;                                if (PseudoRandom.Instance ().NextDouble () <= 0.5) {                  offs1.variable_[i].value_ = c2;                  offs2.variable_[i].value_ = c1;                } else {                  offs1.variable_[i].value_ = c1;                  offs2.variable_[i].value_ = c2;                }                // if              } else {                offs1.variable_[i].value_ = valueX1;                offs2.variable_[i].value_ = valueX2;              }              // if            } else {              offs1.variable_[i].value_ = valueX2;              offs2.variable_[i].value_ = valueX1;            }            // if          }          // if        }
Magic Number,Optimo,SBXCrossover,C:\repos\mrahmaniasl_Optimo\Optimo\crossover\SBXCrossover.cs,doCrossover,The following statement contains a magic number: if (PseudoRandom.Instance ().NextDouble () <= crossoverProbability_) {          for (i = 0; i < numberOfVariables; i++) {            valueX1 = x1.variable_[i].value_;            valueX2 = x2.variable_[i].value_;            if (PseudoRandom.Instance ().NextDouble () <= 0.5) {              if (Math.Abs (valueX1 - valueX2) > EPS) {                                if (valueX1 < valueX2) {                  y1 = valueX1;                  y2 = valueX2;                } else {                  y1 = valueX2;                  y2 = valueX1;                }                // if                yL = x1.variable_[i].lowerBound_;                yu = x1.variable_[i].upperBound_;                rand = PseudoRandom.Instance ().NextDouble ();                beta = 1.0 + (2.0 * (y1 - yL) / (y2 - y1));                alpha = 2.0 - Math.Pow (beta' -(distributionIndex_ + 1.0));                                if (rand <= (1.0 / alpha)) {                  betaq = Math.Pow ((rand * alpha)' (1.0 / (distributionIndex_ + 1.0)));                } else {                  betaq = Math.Pow ((1.0 / (2.0 - rand * alpha))' (1.0 / (distributionIndex_ + 1.0)));                }                // if                c1 = 0.5 * ((y1 + y2) - betaq * (y2 - y1));                beta = 1.0 + (2.0 * (yu - y2) / (y2 - y1));                alpha = 2.0 - Math.Pow (beta' -(distributionIndex_ + 1.0));                                if (rand <= (1.0 / alpha)) {                  betaq = Math.Pow ((rand * alpha)' (1.0 / (distributionIndex_ + 1.0)));                } else {                  betaq = Math.Pow ((1.0 / (2.0 - rand * alpha))' (1.0 / (distributionIndex_ + 1.0)));                }                // if                c2 = 0.5 * ((y1 + y2) + betaq * (y2 - y1));                                if (c1 < yL)                  c1 = yL;                                if (c2 < yL)                  c2 = yL;                                if (c1 > yu)                  c1 = yu;                                if (c2 > yu)                  c2 = yu;                                if (PseudoRandom.Instance ().NextDouble () <= 0.5) {                  offs1.variable_[i].value_ = c2;                  offs2.variable_[i].value_ = c1;                } else {                  offs1.variable_[i].value_ = c1;                  offs2.variable_[i].value_ = c2;                }                // if              } else {                offs1.variable_[i].value_ = valueX1;                offs2.variable_[i].value_ = valueX2;              }              // if            } else {              offs1.variable_[i].value_ = valueX2;              offs2.variable_[i].value_ = valueX1;            }            // if          }          // if        }
Magic Number,Optimo,SBXCrossover,C:\repos\mrahmaniasl_Optimo\Optimo\crossover\SBXCrossover.cs,doCrossover,The following statement contains a magic number: if (PseudoRandom.Instance ().NextDouble () <= crossoverProbability_) {          for (i = 0; i < numberOfVariables; i++) {            valueX1 = x1.variable_[i].value_;            valueX2 = x2.variable_[i].value_;            if (PseudoRandom.Instance ().NextDouble () <= 0.5) {              if (Math.Abs (valueX1 - valueX2) > EPS) {                                if (valueX1 < valueX2) {                  y1 = valueX1;                  y2 = valueX2;                } else {                  y1 = valueX2;                  y2 = valueX1;                }                // if                yL = x1.variable_[i].lowerBound_;                yu = x1.variable_[i].upperBound_;                rand = PseudoRandom.Instance ().NextDouble ();                beta = 1.0 + (2.0 * (y1 - yL) / (y2 - y1));                alpha = 2.0 - Math.Pow (beta' -(distributionIndex_ + 1.0));                                if (rand <= (1.0 / alpha)) {                  betaq = Math.Pow ((rand * alpha)' (1.0 / (distributionIndex_ + 1.0)));                } else {                  betaq = Math.Pow ((1.0 / (2.0 - rand * alpha))' (1.0 / (distributionIndex_ + 1.0)));                }                // if                c1 = 0.5 * ((y1 + y2) - betaq * (y2 - y1));                beta = 1.0 + (2.0 * (yu - y2) / (y2 - y1));                alpha = 2.0 - Math.Pow (beta' -(distributionIndex_ + 1.0));                                if (rand <= (1.0 / alpha)) {                  betaq = Math.Pow ((rand * alpha)' (1.0 / (distributionIndex_ + 1.0)));                } else {                  betaq = Math.Pow ((1.0 / (2.0 - rand * alpha))' (1.0 / (distributionIndex_ + 1.0)));                }                // if                c2 = 0.5 * ((y1 + y2) + betaq * (y2 - y1));                                if (c1 < yL)                  c1 = yL;                                if (c2 < yL)                  c2 = yL;                                if (c1 > yu)                  c1 = yu;                                if (c2 > yu)                  c2 = yu;                                if (PseudoRandom.Instance ().NextDouble () <= 0.5) {                  offs1.variable_[i].value_ = c2;                  offs2.variable_[i].value_ = c1;                } else {                  offs1.variable_[i].value_ = c1;                  offs2.variable_[i].value_ = c2;                }                // if              } else {                offs1.variable_[i].value_ = valueX1;                offs2.variable_[i].value_ = valueX2;              }              // if            } else {              offs1.variable_[i].value_ = valueX2;              offs2.variable_[i].value_ = valueX1;            }            // if          }          // if        }
Magic Number,Optimo,SBXCrossover,C:\repos\mrahmaniasl_Optimo\Optimo\crossover\SBXCrossover.cs,doCrossover,The following statement contains a magic number: if (PseudoRandom.Instance ().NextDouble () <= crossoverProbability_) {          for (i = 0; i < numberOfVariables; i++) {            valueX1 = x1.variable_[i].value_;            valueX2 = x2.variable_[i].value_;            if (PseudoRandom.Instance ().NextDouble () <= 0.5) {              if (Math.Abs (valueX1 - valueX2) > EPS) {                                if (valueX1 < valueX2) {                  y1 = valueX1;                  y2 = valueX2;                } else {                  y1 = valueX2;                  y2 = valueX1;                }                // if                yL = x1.variable_[i].lowerBound_;                yu = x1.variable_[i].upperBound_;                rand = PseudoRandom.Instance ().NextDouble ();                beta = 1.0 + (2.0 * (y1 - yL) / (y2 - y1));                alpha = 2.0 - Math.Pow (beta' -(distributionIndex_ + 1.0));                                if (rand <= (1.0 / alpha)) {                  betaq = Math.Pow ((rand * alpha)' (1.0 / (distributionIndex_ + 1.0)));                } else {                  betaq = Math.Pow ((1.0 / (2.0 - rand * alpha))' (1.0 / (distributionIndex_ + 1.0)));                }                // if                c1 = 0.5 * ((y1 + y2) - betaq * (y2 - y1));                beta = 1.0 + (2.0 * (yu - y2) / (y2 - y1));                alpha = 2.0 - Math.Pow (beta' -(distributionIndex_ + 1.0));                                if (rand <= (1.0 / alpha)) {                  betaq = Math.Pow ((rand * alpha)' (1.0 / (distributionIndex_ + 1.0)));                } else {                  betaq = Math.Pow ((1.0 / (2.0 - rand * alpha))' (1.0 / (distributionIndex_ + 1.0)));                }                // if                c2 = 0.5 * ((y1 + y2) + betaq * (y2 - y1));                                if (c1 < yL)                  c1 = yL;                                if (c2 < yL)                  c2 = yL;                                if (c1 > yu)                  c1 = yu;                                if (c2 > yu)                  c2 = yu;                                if (PseudoRandom.Instance ().NextDouble () <= 0.5) {                  offs1.variable_[i].value_ = c2;                  offs2.variable_[i].value_ = c1;                } else {                  offs1.variable_[i].value_ = c1;                  offs2.variable_[i].value_ = c2;                }                // if              } else {                offs1.variable_[i].value_ = valueX1;                offs2.variable_[i].value_ = valueX2;              }              // if            } else {              offs1.variable_[i].value_ = valueX2;              offs2.variable_[i].value_ = valueX1;            }            // if          }          // if        }
Magic Number,Optimo,NSGAII,C:\repos\mrahmaniasl_Optimo\Optimo\metaheuristics\NSGAII.cs,execute,The following statement contains a magic number: while (evaluations < maxEvaluations)              {                  // Creating the offSpring solutionSet                    offspringPopulation = new SolutionSet(populationSize);                  Solution[] parents = new Solution[2];                    for (int i = 0; i < (populationSize / 2); i++)                  {                      if (evaluations < maxEvaluations)                      {                          //if ((evaluations % 1000) == 0)                          //    Console.WriteLine("Evals: " + evaluations);                          // selection                          parents[0] = (Solution)selectionOperator.execute(population);                          parents[1] = (Solution)selectionOperator.execute(population);                            // crossover                          Solution[] offSpring = (Solution[])crossoverOperator.execute(parents);                            // mutation                          mutationOperator.execute(offSpring[0]);                          mutationOperator.execute(offSpring[1]);                            //Environment.Exit(0);                          // evaluation                          problem_.evaluate(offSpring[0]);                          problem_.evaluate(offSpring[1]);                            offspringPopulation.@add(offSpring[0]);                          offspringPopulation.add(offSpring[1]);                            evaluations += 2;                      }                      // if                  }                  // for                  // Creating the solutionSet union of solutionSet and offSpring                  union = ((SolutionSet)population).union(offspringPopulation);                    //Mohammad                  allTest = ((SolutionSet)allTest).union(union);                  //System.Console.WriteLine ("Union size:" + union.size ());                    // Ranking the union                  Ranking ranking = new Ranking(union);                    int remain = populationSize;                  int index = 0;                  SolutionSet front = null;                    //Distance distance = new Distance ();                    population.clear();                    // Obtain the next front                  front = ranking.getSubfront(index);                  //*                  while ((remain > 0) && (remain >= front.size()))                  {                      //Assign crowding distance to individuals                      Distance.crowdingDistanceAssignment(front' problem_.numberOfObjectives_);                      //Add the individuals of this front                      for (int k = 0; k < front.size(); k++)                      {                          population.@add(front[k]);                      }                      // for                      //Decrement remain                      remain = remain - front.size();                        //Obtain the next front                      index++;                      if (remain > 0)                      {                          front = ranking.getSubfront(index);                      }                      // if                          }                  // while                  // Remain is less than front(index).size' insert only the best one                  if (remain > 0)                  {                      // front contains individuals to insert                                              Distance.crowdingDistanceAssignment(front' problem_.numberOfObjectives_);                      IComparer comp = new CrowdingDistanceComparator();                      front.solutionList_.Sort(comp.Compare);                      for (int k = 0; k < remain; k++)                      {                          population.@add(front[k]);                      }                      // for                      remain = 0;                  }                  // if              }
Magic Number,Optimo,NSGAII,C:\repos\mrahmaniasl_Optimo\Optimo\metaheuristics\NSGAII.cs,execute,The following statement contains a magic number: while (evaluations < maxEvaluations)              {                  // Creating the offSpring solutionSet                    offspringPopulation = new SolutionSet(populationSize);                  Solution[] parents = new Solution[2];                    for (int i = 0; i < (populationSize / 2); i++)                  {                      if (evaluations < maxEvaluations)                      {                          //if ((evaluations % 1000) == 0)                          //    Console.WriteLine("Evals: " + evaluations);                          // selection                          parents[0] = (Solution)selectionOperator.execute(population);                          parents[1] = (Solution)selectionOperator.execute(population);                            // crossover                          Solution[] offSpring = (Solution[])crossoverOperator.execute(parents);                            // mutation                          mutationOperator.execute(offSpring[0]);                          mutationOperator.execute(offSpring[1]);                            //Environment.Exit(0);                          // evaluation                          problem_.evaluate(offSpring[0]);                          problem_.evaluate(offSpring[1]);                            offspringPopulation.@add(offSpring[0]);                          offspringPopulation.add(offSpring[1]);                            evaluations += 2;                      }                      // if                  }                  // for                  // Creating the solutionSet union of solutionSet and offSpring                  union = ((SolutionSet)population).union(offspringPopulation);                    //Mohammad                  allTest = ((SolutionSet)allTest).union(union);                  //System.Console.WriteLine ("Union size:" + union.size ());                    // Ranking the union                  Ranking ranking = new Ranking(union);                    int remain = populationSize;                  int index = 0;                  SolutionSet front = null;                    //Distance distance = new Distance ();                    population.clear();                    // Obtain the next front                  front = ranking.getSubfront(index);                  //*                  while ((remain > 0) && (remain >= front.size()))                  {                      //Assign crowding distance to individuals                      Distance.crowdingDistanceAssignment(front' problem_.numberOfObjectives_);                      //Add the individuals of this front                      for (int k = 0; k < front.size(); k++)                      {                          population.@add(front[k]);                      }                      // for                      //Decrement remain                      remain = remain - front.size();                        //Obtain the next front                      index++;                      if (remain > 0)                      {                          front = ranking.getSubfront(index);                      }                      // if                          }                  // while                  // Remain is less than front(index).size' insert only the best one                  if (remain > 0)                  {                      // front contains individuals to insert                                              Distance.crowdingDistanceAssignment(front' problem_.numberOfObjectives_);                      IComparer comp = new CrowdingDistanceComparator();                      front.solutionList_.Sort(comp.Compare);                      for (int k = 0; k < remain; k++)                      {                          population.@add(front[k]);                      }                      // for                      remain = 0;                  }                  // if              }
Magic Number,Optimo,NSGAII,C:\repos\mrahmaniasl_Optimo\Optimo\metaheuristics\NSGAII.cs,execute,The following statement contains a magic number: while (evaluations < maxEvaluations)              {                  // Creating the offSpring solutionSet                    offspringPopulation = new SolutionSet(populationSize);                  Solution[] parents = new Solution[2];                    for (int i = 0; i < (populationSize / 2); i++)                  {                      if (evaluations < maxEvaluations)                      {                          //if ((evaluations % 1000) == 0)                          //    Console.WriteLine("Evals: " + evaluations);                          // selection                          parents[0] = (Solution)selectionOperator.execute(population);                          parents[1] = (Solution)selectionOperator.execute(population);                            // crossover                          Solution[] offSpring = (Solution[])crossoverOperator.execute(parents);                            // mutation                          mutationOperator.execute(offSpring[0]);                          mutationOperator.execute(offSpring[1]);                            //Environment.Exit(0);                          // evaluation                          problem_.evaluate(offSpring[0]);                          problem_.evaluate(offSpring[1]);                            offspringPopulation.@add(offSpring[0]);                          offspringPopulation.add(offSpring[1]);                            evaluations += 2;                      }                      // if                  }                  // for                  // Creating the solutionSet union of solutionSet and offSpring                  union = ((SolutionSet)population).union(offspringPopulation);                    //Mohammad                  allTest = ((SolutionSet)allTest).union(union);                  //System.Console.WriteLine ("Union size:" + union.size ());                    // Ranking the union                  Ranking ranking = new Ranking(union);                    int remain = populationSize;                  int index = 0;                  SolutionSet front = null;                    //Distance distance = new Distance ();                    population.clear();                    // Obtain the next front                  front = ranking.getSubfront(index);                  //*                  while ((remain > 0) && (remain >= front.size()))                  {                      //Assign crowding distance to individuals                      Distance.crowdingDistanceAssignment(front' problem_.numberOfObjectives_);                      //Add the individuals of this front                      for (int k = 0; k < front.size(); k++)                      {                          population.@add(front[k]);                      }                      // for                      //Decrement remain                      remain = remain - front.size();                        //Obtain the next front                      index++;                      if (remain > 0)                      {                          front = ranking.getSubfront(index);                      }                      // if                          }                  // while                  // Remain is less than front(index).size' insert only the best one                  if (remain > 0)                  {                      // front contains individuals to insert                                              Distance.crowdingDistanceAssignment(front' problem_.numberOfObjectives_);                      IComparer comp = new CrowdingDistanceComparator();                      front.solutionList_.Sort(comp.Compare);                      for (int k = 0; k < remain; k++)                      {                          population.@add(front[k]);                      }                      // for                      remain = 0;                  }                  // if              }
Magic Number,Optimo,PolynomialMutation,C:\repos\mrahmaniasl_Optimo\Optimo\mutation\PolynomialMutation.cs,doMutation,The following statement contains a magic number: for (int var = 0; var < x.numberOfVariables_; var++) {          if (PseudoRandom.Instance ().NextDouble () <= mutationProbability_) {            y = x.variable_[var].value_;            yl = x.variable_[var].lowerBound_;            yu = x.variable_[var].upperBound_;            delta1 = (y - yl) / (yu - yl);            delta2 = (yu - y) / (yu - yl);            rnd = PseudoRandom.Instance ().NextDouble ();            mut_pow = 1.0 / (eta_m + 1.0);            if (rnd <= 0.5) {              xy = 1.0 - delta1;              val = 2.0 * rnd + (1.0 - 2.0 * rnd) * (Math.Pow (xy' (eta_m + 1.0)));              deltaq = Math.Pow (val' mut_pow) - 1.0;            } else {              xy = 1.0 - delta2;              val = 2.0 * (1.0 - rnd) + 2.0 * (rnd - 0.5) * (Math.Pow (xy' (eta_m + 1.0)));              deltaq = 1.0 - (Math.Pow (val' mut_pow));            }            y = y + deltaq * (yu - yl);            if (y < yl)              y = yl;            if (y > yu)              y = yu;            x.variable_[var].value_ = y;          }        }
Magic Number,Optimo,PolynomialMutation,C:\repos\mrahmaniasl_Optimo\Optimo\mutation\PolynomialMutation.cs,doMutation,The following statement contains a magic number: for (int var = 0; var < x.numberOfVariables_; var++) {          if (PseudoRandom.Instance ().NextDouble () <= mutationProbability_) {            y = x.variable_[var].value_;            yl = x.variable_[var].lowerBound_;            yu = x.variable_[var].upperBound_;            delta1 = (y - yl) / (yu - yl);            delta2 = (yu - y) / (yu - yl);            rnd = PseudoRandom.Instance ().NextDouble ();            mut_pow = 1.0 / (eta_m + 1.0);            if (rnd <= 0.5) {              xy = 1.0 - delta1;              val = 2.0 * rnd + (1.0 - 2.0 * rnd) * (Math.Pow (xy' (eta_m + 1.0)));              deltaq = Math.Pow (val' mut_pow) - 1.0;            } else {              xy = 1.0 - delta2;              val = 2.0 * (1.0 - rnd) + 2.0 * (rnd - 0.5) * (Math.Pow (xy' (eta_m + 1.0)));              deltaq = 1.0 - (Math.Pow (val' mut_pow));            }            y = y + deltaq * (yu - yl);            if (y < yl)              y = yl;            if (y > yu)              y = yu;            x.variable_[var].value_ = y;          }        }
Magic Number,Optimo,PolynomialMutation,C:\repos\mrahmaniasl_Optimo\Optimo\mutation\PolynomialMutation.cs,doMutation,The following statement contains a magic number: for (int var = 0; var < x.numberOfVariables_; var++) {          if (PseudoRandom.Instance ().NextDouble () <= mutationProbability_) {            y = x.variable_[var].value_;            yl = x.variable_[var].lowerBound_;            yu = x.variable_[var].upperBound_;            delta1 = (y - yl) / (yu - yl);            delta2 = (yu - y) / (yu - yl);            rnd = PseudoRandom.Instance ().NextDouble ();            mut_pow = 1.0 / (eta_m + 1.0);            if (rnd <= 0.5) {              xy = 1.0 - delta1;              val = 2.0 * rnd + (1.0 - 2.0 * rnd) * (Math.Pow (xy' (eta_m + 1.0)));              deltaq = Math.Pow (val' mut_pow) - 1.0;            } else {              xy = 1.0 - delta2;              val = 2.0 * (1.0 - rnd) + 2.0 * (rnd - 0.5) * (Math.Pow (xy' (eta_m + 1.0)));              deltaq = 1.0 - (Math.Pow (val' mut_pow));            }            y = y + deltaq * (yu - yl);            if (y < yl)              y = yl;            if (y > yu)              y = yu;            x.variable_[var].value_ = y;          }        }
Magic Number,Optimo,PolynomialMutation,C:\repos\mrahmaniasl_Optimo\Optimo\mutation\PolynomialMutation.cs,doMutation,The following statement contains a magic number: for (int var = 0; var < x.numberOfVariables_; var++) {          if (PseudoRandom.Instance ().NextDouble () <= mutationProbability_) {            y = x.variable_[var].value_;            yl = x.variable_[var].lowerBound_;            yu = x.variable_[var].upperBound_;            delta1 = (y - yl) / (yu - yl);            delta2 = (yu - y) / (yu - yl);            rnd = PseudoRandom.Instance ().NextDouble ();            mut_pow = 1.0 / (eta_m + 1.0);            if (rnd <= 0.5) {              xy = 1.0 - delta1;              val = 2.0 * rnd + (1.0 - 2.0 * rnd) * (Math.Pow (xy' (eta_m + 1.0)));              deltaq = Math.Pow (val' mut_pow) - 1.0;            } else {              xy = 1.0 - delta2;              val = 2.0 * (1.0 - rnd) + 2.0 * (rnd - 0.5) * (Math.Pow (xy' (eta_m + 1.0)));              deltaq = 1.0 - (Math.Pow (val' mut_pow));            }            y = y + deltaq * (yu - yl);            if (y < yl)              y = yl;            if (y > yu)              y = yu;            x.variable_[var].value_ = y;          }        }
Magic Number,Optimo,PolynomialMutation,C:\repos\mrahmaniasl_Optimo\Optimo\mutation\PolynomialMutation.cs,doMutation,The following statement contains a magic number: for (int var = 0; var < x.numberOfVariables_; var++) {          if (PseudoRandom.Instance ().NextDouble () <= mutationProbability_) {            y = x.variable_[var].value_;            yl = x.variable_[var].lowerBound_;            yu = x.variable_[var].upperBound_;            delta1 = (y - yl) / (yu - yl);            delta2 = (yu - y) / (yu - yl);            rnd = PseudoRandom.Instance ().NextDouble ();            mut_pow = 1.0 / (eta_m + 1.0);            if (rnd <= 0.5) {              xy = 1.0 - delta1;              val = 2.0 * rnd + (1.0 - 2.0 * rnd) * (Math.Pow (xy' (eta_m + 1.0)));              deltaq = Math.Pow (val' mut_pow) - 1.0;            } else {              xy = 1.0 - delta2;              val = 2.0 * (1.0 - rnd) + 2.0 * (rnd - 0.5) * (Math.Pow (xy' (eta_m + 1.0)));              deltaq = 1.0 - (Math.Pow (val' mut_pow));            }            y = y + deltaq * (yu - yl);            if (y < yl)              y = yl;            if (y > yu)              y = yu;            x.variable_[var].value_ = y;          }        }
Magic Number,Optimo,PolynomialMutation,C:\repos\mrahmaniasl_Optimo\Optimo\mutation\PolynomialMutation.cs,doMutation,The following statement contains a magic number: for (int var = 0; var < x.numberOfVariables_; var++) {          if (PseudoRandom.Instance ().NextDouble () <= mutationProbability_) {            y = x.variable_[var].value_;            yl = x.variable_[var].lowerBound_;            yu = x.variable_[var].upperBound_;            delta1 = (y - yl) / (yu - yl);            delta2 = (yu - y) / (yu - yl);            rnd = PseudoRandom.Instance ().NextDouble ();            mut_pow = 1.0 / (eta_m + 1.0);            if (rnd <= 0.5) {              xy = 1.0 - delta1;              val = 2.0 * rnd + (1.0 - 2.0 * rnd) * (Math.Pow (xy' (eta_m + 1.0)));              deltaq = Math.Pow (val' mut_pow) - 1.0;            } else {              xy = 1.0 - delta2;              val = 2.0 * (1.0 - rnd) + 2.0 * (rnd - 0.5) * (Math.Pow (xy' (eta_m + 1.0)));              deltaq = 1.0 - (Math.Pow (val' mut_pow));            }            y = y + deltaq * (yu - yl);            if (y < yl)              y = yl;            if (y > yu)              y = yu;            x.variable_[var].value_ = y;          }        }
Magic Number,Optimo,myTest,C:\repos\mrahmaniasl_Optimo\Optimo\problems\myTest.cs,evaluate,The following statement contains a magic number: sum1 = Math.Sqrt(Math.Pow((x[0].value_ -2)'2) + Math.Pow((x[1].value_ -3) '2)) ;
Magic Number,Optimo,myTest,C:\repos\mrahmaniasl_Optimo\Optimo\problems\myTest.cs,evaluate,The following statement contains a magic number: sum1 = Math.Sqrt(Math.Pow((x[0].value_ -2)'2) + Math.Pow((x[1].value_ -3) '2)) ;
Magic Number,Optimo,myTest,C:\repos\mrahmaniasl_Optimo\Optimo\problems\myTest.cs,evaluate,The following statement contains a magic number: sum1 = Math.Sqrt(Math.Pow((x[0].value_ -2)'2) + Math.Pow((x[1].value_ -3) '2)) ;
Magic Number,Optimo,myTest,C:\repos\mrahmaniasl_Optimo\Optimo\problems\myTest.cs,evaluate,The following statement contains a magic number: sum1 = Math.Sqrt(Math.Pow((x[0].value_ -2)'2) + Math.Pow((x[1].value_ -3) '2)) ;
Magic Number,Optimo,ProblemFactory,C:\repos\mrahmaniasl_Optimo\Optimo\problems\ProblemFactory.cs,getProblem,The following statement contains a magic number: Type[] types = new Type[5];
Magic Number,Optimo,ProblemFactory,C:\repos\mrahmaniasl_Optimo\Optimo\problems\ProblemFactory.cs,getProblem,The following statement contains a magic number: types[2] = typeof(double[]);
Magic Number,Optimo,ProblemFactory,C:\repos\mrahmaniasl_Optimo\Optimo\problems\ProblemFactory.cs,getProblem,The following statement contains a magic number: types[3] = typeof(double[]);
Magic Number,Optimo,ProblemFactory,C:\repos\mrahmaniasl_Optimo\Optimo\problems\ProblemFactory.cs,getProblem,The following statement contains a magic number: types[4] = typeof(int);
Magic Number,Optimo,BinaryTournament,C:\repos\mrahmaniasl_Optimo\Optimo\selection\BinaryTournament.cs,execute,The following statement contains a magic number: if (result == -1)              return solution1;          else if (result == 1)              return solution2;          else          {              if (PseudoRandom.Instance().NextDouble() < 0.5)                  return solution1;              else                  return solution2;          }
Magic Number,Optimo,NSGAII_settings,C:\repos\mrahmaniasl_Optimo\Optimo\settings\NSGAII_settings.cs,NSGAII_settings,The following statement contains a magic number: populationSize_ = 30;
Magic Number,Optimo,NSGAII_settings,C:\repos\mrahmaniasl_Optimo\Optimo\settings\NSGAII_settings.cs,NSGAII_settings,The following statement contains a magic number: maxEvaluations_ = 600;
Magic Number,Optimo,NSGAII_settings,C:\repos\mrahmaniasl_Optimo\Optimo\settings\NSGAII_settings.cs,NSGAII_settings,The following statement contains a magic number: crossoverProbability_ = 0.9;
Magic Number,Optimo,NSGAII_settings,C:\repos\mrahmaniasl_Optimo\Optimo\settings\NSGAII_settings.cs,NSGAII_settings,The following statement contains a magic number: mutationDistributionIndex_ = 10.0;
Magic Number,Optimo,NSGAII_settings,C:\repos\mrahmaniasl_Optimo\Optimo\settings\NSGAII_settings.cs,NSGAII_settings,The following statement contains a magic number: crossoverDistributionIndex_ = 10.0;
Magic Number,Optimo,NSGAII_settings,C:\repos\mrahmaniasl_Optimo\Optimo\settings\NSGAII_settings.cs,configure,The following statement contains a magic number: parameters.Add("probability"' 0.9);
Magic Number,Optimo,NSGAII_settings,C:\repos\mrahmaniasl_Optimo\Optimo\settings\NSGAII_settings.cs,configure,The following statement contains a magic number: parameters.Add("distributionIndex"' 20.0);
Magic Number,Optimo,NSGAII_settings,C:\repos\mrahmaniasl_Optimo\Optimo\settings\NSGAII_settings.cs,configure,The following statement contains a magic number: parameters.Add("probability"' 0.01);
Magic Number,Optimo,NSGAII_settings,C:\repos\mrahmaniasl_Optimo\Optimo\settings\NSGAII_settings.cs,configure,The following statement contains a magic number: parameters.Add("distributionIndex"' 20.0);
Magic Number,Optimo,SettingsFactory,C:\repos\mrahmaniasl_Optimo\Optimo\settings\SettingsFactory.cs,getSettingsObject,The following statement contains a magic number: Type[] types = new Type[5];
Magic Number,Optimo,SettingsFactory,C:\repos\mrahmaniasl_Optimo\Optimo\settings\SettingsFactory.cs,getSettingsObject,The following statement contains a magic number: types[2] = typeof(double[]);
Magic Number,Optimo,SettingsFactory,C:\repos\mrahmaniasl_Optimo\Optimo\settings\SettingsFactory.cs,getSettingsObject,The following statement contains a magic number: types[3] = typeof(double[]);
Magic Number,Optimo,SettingsFactory,C:\repos\mrahmaniasl_Optimo\Optimo\settings\SettingsFactory.cs,getSettingsObject,The following statement contains a magic number: types[4] = typeof(int);
Magic Number,Optimo,Distance,C:\repos\mrahmaniasl_Optimo\Optimo\util\Distance.cs,crowdingDistanceAssignment,The following statement contains a magic number: if (size == 2) {        solutionSet[0].crowdingDistance_ = Double.MaxValue;        solutionSet[1].crowdingDistance_ = Double.MaxValue;        return;      }
Magic Number,Optimo,RandomPermutation,C:\repos\mrahmaniasl_Optimo\Optimo\util\RandomPermutation.cs,execute,The following statement contains a magic number: if (perm.Length < 2)          throw new ArgumentException("perm.Length < 2"' "perm");
Magic Number,Optimo,Binary,C:\repos\mrahmaniasl_Optimo\Optimo\variables\Binary.cs,Binary,The following statement contains a magic number: for (int i = 0; i < numberOfBits_; i++)        {           if (PseudoRandom.Instance().NextDouble() < 0.5)          {            bits_[i]  = true;          }          else          {            bits_[i] = false;          }        }
