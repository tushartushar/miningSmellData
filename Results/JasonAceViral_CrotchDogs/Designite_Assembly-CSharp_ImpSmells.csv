Implementation smell,Namespace,Class,File,Method,Description
Long Method,tk2dRuntime,SpriteCollectionGenerator,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The method has 100 lines of code.
Long Method,tk2dRuntime.TileMap,ColliderBuilder2D,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder2D.cs,BuildLocalMeshForChunk,The method has 111 lines of code.
Long Method,tk2dRuntime.TileMap,RenderMeshBuilder,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapMeshBuilder.cs,BuildForChunk,The method has 105 lines of code.
Long Method,SimpleJSON,JSONNode,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\Utility\SimpleJSON.cs,Parse,The method has 140 lines of code.
Complex Method,AceViral,MsgBox,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\AVSharedScripts\AceVIral\MsgBox.cs,Update,Cyclomatic complexity of the method is 14
Complex Method,AceViral,MsgBox,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\AVSharedScripts\AceVIral\MsgBox.cs,CanMsgBoxShow,Cyclomatic complexity of the method is 8
Complex Method,AceViral,ScrollPage,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\AVSharedScripts\AceVIral\ScrollPage.cs,Update,Cyclomatic complexity of the method is 15
Complex Method,AceViral,ScrollPage,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\AVSharedScripts\AceVIral\ScrollPage.cs,TouchUpdateAtPosition,Cyclomatic complexity of the method is 8
Complex Method,AceViral,CloudManager,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\AVSharedScripts\Cloud\CloudManager.cs,LoadAllData,Cyclomatic complexity of the method is 8
Complex Method,AceViral,AVFacebook,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\AVSharedScripts\Facebook\AVFacebook.cs,LoadFriendsFromPrefs,Cyclomatic complexity of the method is 8
Complex Method,AceViral,HouseAdManager,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\AVSharedScripts\HouseAds\HouseAdManager.cs,ParseXmlFile,Cyclomatic complexity of the method is 11
Complex Method,AceViral,LanguageLoader,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\AVSharedScripts\Locallization\LanguageLoader.cs,LoadLanguageXMLFile,Cyclomatic complexity of the method is 11
Complex Method,AceViral,Utility,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\AVSharedScripts\Utility\Utility.cs,WordWrap,Cyclomatic complexity of the method is 8
Complex Method,Facebook,AndroidFacebook,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\Facebook\Scripts\AndroidFacebook.cs,Init,Cyclomatic complexity of the method is 9
Complex Method,Facebook,AndroidFacebook,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\Facebook\Scripts\AndroidFacebook.cs,AppRequest,Cyclomatic complexity of the method is 12
Complex Method,Facebook,AndroidFacebook,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\Facebook\Scripts\AndroidFacebook.cs,FeedRequest,Cyclomatic complexity of the method is 15
Complex Method,tk2dRuntime,SpriteCollectionGenerator,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,Cyclomatic complexity of the method is 34
Complex Method,tk2dRuntime.TileMap,BuilderUtil,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapBuilderUtil.cs,InitDataStore,Cyclomatic complexity of the method is 15
Complex Method,tk2dRuntime.TileMap,BuilderUtil,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapBuilderUtil.cs,SpawnPrefabsForChunk,Cyclomatic complexity of the method is 13
Complex Method,tk2dRuntime.TileMap,BuilderUtil,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapBuilderUtil.cs,HideTileMapPrefabs,Cyclomatic complexity of the method is 13
Complex Method,tk2dRuntime.TileMap,BuilderUtil,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapBuilderUtil.cs,CreateRenderData,Cyclomatic complexity of the method is 15
Complex Method,tk2dRuntime.TileMap,BuilderUtil,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapBuilderUtil.cs,GetLoopOrder,Cyclomatic complexity of the method is 35
Complex Method,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,Build,Cyclomatic complexity of the method is 8
Complex Method,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildForChunk,Cyclomatic complexity of the method is 8
Complex Method,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,Cyclomatic complexity of the method is 13
Complex Method,tk2dRuntime.TileMap,ColliderBuilder2D,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder2D.cs,Build,Cyclomatic complexity of the method is 9
Complex Method,tk2dRuntime.TileMap,ColliderBuilder2D,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder2D.cs,BuildForChunk,Cyclomatic complexity of the method is 13
Complex Method,tk2dRuntime.TileMap,ColliderBuilder2D,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder2D.cs,BuildLocalMeshForChunk,Cyclomatic complexity of the method is 21
Complex Method,tk2dRuntime.TileMap,ColliderBuilder2D,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder2D.cs,RemoveDuplicateEdges,Cyclomatic complexity of the method is 8
Complex Method,tk2dRuntime.TileMap,ColliderBuilder2D,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder2D.cs,MergeEdges,Cyclomatic complexity of the method is 10
Complex Method,tk2dRuntime.TileMap,RenderMeshBuilder,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapMeshBuilder.cs,BuildForChunk,Cyclomatic complexity of the method is 20
Complex Method,tk2dRuntime.TileMap,RenderMeshBuilder,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapMeshBuilder.cs,Build,Cyclomatic complexity of the method is 10
Complex Method,SimpleJSON,JSONNode,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\Utility\SimpleJSON.cs,Escape,Cyclomatic complexity of the method is 25
Complex Method,SimpleJSON,JSONNode,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\Utility\SimpleJSON.cs,Parse,Cyclomatic complexity of the method is 96
Complex Method,SimpleJSON,JSONNode,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\Utility\SimpleJSON.cs,Deserialize,Cyclomatic complexity of the method is 19
Long Parameter List,Facebook,AndroidFacebook,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\Facebook\Scripts\AndroidFacebook.cs,Init,The method has 10 parameters.
Long Parameter List,Facebook,AndroidFacebook,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\Facebook\Scripts\AndroidFacebook.cs,AppRequest,The method has 10 parameters.
Long Parameter List,Facebook,AndroidFacebook,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\Facebook\Scripts\AndroidFacebook.cs,FeedRequest,The method has 12 parameters.
Long Parameter List,Facebook,AndroidFacebook,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\Facebook\Scripts\AndroidFacebook.cs,Pay,The method has 9 parameters.
Long Parameter List,Facebook,EditorFacebook,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\Facebook\Scripts\EditorFacebook.cs,Init,The method has 10 parameters.
Long Parameter List,Facebook,EditorFacebook,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\Facebook\Scripts\EditorFacebook.cs,OnInit,The method has 10 parameters.
Long Parameter List,Facebook,EditorFacebook,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\Facebook\Scripts\EditorFacebook.cs,AppRequest,The method has 10 parameters.
Long Parameter List,Facebook,EditorFacebook,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\Facebook\Scripts\EditorFacebook.cs,FeedRequest,The method has 12 parameters.
Long Parameter List,Facebook,EditorFacebook,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\Facebook\Scripts\EditorFacebook.cs,Pay,The method has 9 parameters.
Long Parameter List,Facebook,IOSFacebook,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\Facebook\Scripts\IOSFacebook.cs,iosInit,The method has 6 parameters.
Long Parameter List,Facebook,IOSFacebook,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\Facebook\Scripts\IOSFacebook.cs,iosFeedRequest,The method has 11 parameters.
Long Parameter List,Facebook,IOSFacebook,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\Facebook\Scripts\IOSFacebook.cs,iosAppRequest,The method has 13 parameters.
Long Parameter List,Facebook,IOSFacebook,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\Facebook\Scripts\IOSFacebook.cs,iosFBAppEventsLogEvent,The method has 5 parameters.
Long Parameter List,Facebook,IOSFacebook,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\Facebook\Scripts\IOSFacebook.cs,iosFBAppEventsLogPurchase,The method has 5 parameters.
Long Parameter List,Facebook,IOSFacebook,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\Facebook\Scripts\IOSFacebook.cs,Init,The method has 10 parameters.
Long Parameter List,Facebook,IOSFacebook,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\Facebook\Scripts\IOSFacebook.cs,AppRequest,The method has 10 parameters.
Long Parameter List,Facebook,IOSFacebook,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\Facebook\Scripts\IOSFacebook.cs,FeedRequest,The method has 12 parameters.
Long Parameter List,Facebook,IOSFacebook,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\Facebook\Scripts\IOSFacebook.cs,Pay,The method has 9 parameters.
Long Parameter List,tk2dRuntime,SpriteCollectionGenerator,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexture,The method has 5 parameters.
Long Parameter List,tk2dRuntime,SpriteCollectionGenerator,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexture,The method has 8 parameters.
Long Parameter List,tk2dRuntime,SpriteCollectionGenerator,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexture,The method has 9 parameters.
Long Parameter List,tk2dRuntime,SpriteCollectionGenerator,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateDefinitionForRegionInTexture,The method has 7 parameters.
Long Parameter List,tk2dRuntime.TileMap,BuilderUtil,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapBuilderUtil.cs,SpawnPrefabsForChunk,The method has 6 parameters.
Long Parameter List,tk2dRuntime.TileMap,BuilderUtil,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapBuilderUtil.cs,GetLoopOrder,The method has 9 parameters.
Long Parameter List,tk2dRuntime.TileMap,BuilderUtil,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapBuilderUtil.cs,ApplySpriteVertexTileFlags,The method has 6 parameters.
Long Parameter List,tk2dRuntime.TileMap,BuilderUtil,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapBuilderUtil.cs,ApplySpriteVertexTileFlags,The method has 6 parameters.
Long Parameter List,tk2dRuntime.TileMap,Layer,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapChunks.cs,Layer,The method has 5 parameters.
Long Parameter List,tk2dRuntime.TileMap,Layer,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapChunks.cs,Init,The method has 5 parameters.
Long Parameter List,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The method has 6 parameters.
Long Parameter List,tk2dRuntime.TileMap,ColliderBuilder2D,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder2D.cs,BuildLocalMeshForChunk,The method has 6 parameters.
Long Parameter List,tk2dRuntime.TileMap,RenderMeshBuilder,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapMeshBuilder.cs,BuildForChunk,The method has 7 parameters.
Long Statement,AceViral,Prefs,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\AVSharedScripts\AceVIral\Prefs.cs,Save,The length of the statement  "	//Debug.Log (" ******************* Saving to prefs(" + m_KeysSaved + ") *******************" + System.Environment.NewLine + sb.ToString()); " is 139.
Long Statement,AceViral,RatingsManager,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\AVSharedScripts\AceVIral\RatingsManager.cs,AskIfEnjoyingThenRateMe,The length of the statement  "	MsgBox.Show (Localization.Instance.GetString (Localization.eLocalKeys.AV_Rate_This_App)' Localization.Instance.GetString (Localization.eLocalKeys.AV_Are_You_Enjoying_This_App)' MsgBoxType.YES_NO' response =>  { " is 210.
Long Statement,AceViral,RatingsManager,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\AVSharedScripts\AceVIral\RatingsManager.cs,ShowRateMePopup,The length of the statement  "	MsgBox.Show (Localization.Instance.GetString (Localization.eLocalKeys.AV_Rate_This_App)' Localization.Instance.GetString (Localization.eLocalKeys.AV_Would_You_Like_To_Rate)' MsgBoxType.YES_NO' response =>  { " is 207.
Long Statement,AceViral,ScrollPage,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\AVSharedScripts\AceVIral\ScrollPage.cs,MoveToIndex,The length of the statement  "		transform.localPosition = new Vector3 (-selectableObjects [index].localPosition.x' transform.localPosition.y' transform.localPosition.z); " is 137.
Long Statement,AceViral,ScrollPage,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\AVSharedScripts\AceVIral\ScrollPage.cs,Update,The length of the statement  "		transform.localPosition = new Vector3 (transform.localPosition.x + lastSwipeSpeed' transform.localPosition.y' transform.localPosition.z); " is 137.
Long Statement,AceViral,ScrollPage,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\AVSharedScripts\AceVIral\ScrollPage.cs,TouchUpdateAtPosition,The length of the statement  "		gameObject.transform.localPosition = new Vector3 (toSetXPos - overHang' gameObject.transform.localPosition.y' gameObject.transform.localPosition.z); " is 148.
Long Statement,AceViral,AVInterstitialManager,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\AVSharedScripts\AdMob\AVInterstitialManager.cs,VideoInterstitialHasNoFill,The length of the statement  "	MsgBox.Show (Localization.Instance.GetString (Localization.eLocalKeys.AV_Video_Advert)' Localization.Instance.GetString (Localization.eLocalKeys.AV_No_Content_Available_At_This_Time)); " is 184.
Long Statement,AceViral,AVInterstitialManager,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\AVSharedScripts\AdMob\AVInterstitialManager.cs,VideoInterstitialGeneralFail,The length of the statement  "	MsgBox.Show (Localization.Instance.GetString (Localization.eLocalKeys.AV_Video_Advert)' Localization.Instance.GetString (Localization.eLocalKeys.AV_An_Error_Occurred_Try_Later)); " is 178.
Long Statement,AceViral,CloudManager,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\AVSharedScripts\Cloud\CloudManager.cs,LoadAllData,The length of the statement  "				MsgBox.Show (Localization.Instance.GetString (Localization.eLocalKeys.AV_Cloud_Out_Of_Sync)' Localization.Instance.GetString (Localization.eLocalKeys.AV_Cloud_Would_You_Like_To_Use_Cloud)' MsgBoxType.YES_NO' (MsgBoxResponse response) =>  { " is 239.
Long Statement,AceViral,CloudManager,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\AVSharedScripts\Cloud\CloudManager.cs,CheckForCloudRestore,The length of the statement  "	Debug.LogWarning ("CloudManager :: CheckForCloudRestore. Update available? " + cloudUpdateAvailable + " Questioned already? " + Prefs.GetBool ("CloudManager.UserAnsweredRestore"' false)); " is 187.
Long Statement,AceViral,CloudManager,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\AVSharedScripts\Cloud\CloudManager.cs,CheckForCloudRestore,The length of the statement  "			MsgBox.Show (Localization.Instance.GetString (Localization.eLocalKeys.AV_Cloud_Restore_From)' Localization.Instance.GetString (Localization.eLocalKeys.AV_Cloud_Save_Available)' MsgBoxType.YES_NO' (MsgBoxResponse response) =>  { " is 227.
Long Statement,AceViral,AVFacebook,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\AVSharedScripts\Facebook\AVFacebook.cs,CheckForProfilePictureToDownload,The length of the statement  "		//Debug.Log("Friend: " + m_FriendList[i].Name + " + " + m_FriendList[i].ProfilePicture + " failed? " + m_FriendList[i].DownloadFailed); " is 135.
Long Statement,AceViral,AVFacebook,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\AVSharedScripts\Facebook\AVFacebook.cs,CheckForProfilePictureToDownload,The length of the statement  "			FB.API (query: GetPictureURL (m_FriendList [i].ID' AppConstants.Facebook.PreferredPicSize' AppConstants.Facebook.PreferredPicSize' null)' method: Facebook.HttpMethod.GET' callback: ((FBResult result) =>  { " is 205.
Long Statement,AceViral,HouseAdInterface,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\AVSharedScripts\HouseAds\HouseAdInterface.cs,OpenHouseAdUrl,The length of the statement  "            AVHiddenInterface.AndroidInterface.HouseAds.ShowAppLinkInMarketPlaceWithReferral(urlLink' AppConstants.AppReferralName' fromSlotId);" is 132.
Long Statement,AceViral,InAppUnity,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\AVSharedScripts\InApp\InAppUnity.cs,OnPurchaseFailed,The length of the statement  "	MsgBox.Show (Localization.Instance.GetString (Localization.eLocalKeys.AV_In_App_Purchases)' Localization.Instance.GetStringWithInput (Localization.eLocalKeys.AV_Purchase_Failed_For_x' id.Name)); " is 194.
Long Statement,AceViral,FPSCounter,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\AVSharedScripts\Utility\FPSCounter.cs,Start,The length of the statement  "	fpsLabel.transform.position = new Vector3 (-Screen.width * 0.5f / 100f' -Screen.height * 0.5f / 100f' fpsLabel.transform.position.z); " is 133.
Long Statement,AceViral,Utility,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\AVSharedScripts\Utility\Utility.cs,IsIOSDeviceRetina5Inch,The length of the statement  "	    		if(iPhone.generation == iPhoneGeneration.iPhone5 || iPhone.generation == iPhoneGeneration.iPodTouch5Gen || Screen.height == 1136){" is 130.
Long Statement,AVHiddenInterface,GameServicesEditorInterface,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\AVSharedScripts\GameServices\GameServicesEditorInterface.cs,UpdateAchievement,The length of the statement  "	Debug.Log ("GameServicesEditorInterface :: UpdateAchievement. <Achievement(iOS) : " + achievement.iOSId + "> <Progress : " + progress + "> <Steps : " + steps + " >"); " is 166.
Long Statement,AVHiddenInterface,GameServicesEditorInterface,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\AVSharedScripts\GameServices\GameServicesEditorInterface.cs,UpdateScore,The length of the statement  "	Debug.Log ("GameServicesEditorInterface :: UpdateScore. <Score : " + score + "> <Leaderboard(iOS) : " + leaderboard.iOSId + ">"); " is 129.
Long Statement,AVHiddenInterface,InAppUnityAndoid,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\AVSharedScripts\InApp\InAppUnityAndoid.cs,PurchaseSuccess,The length of the statement  "					MsgBox.Show (Localization.Instance.GetString (Localization.eLocalKeys.AV_In_App_Purchases)' Localization.Instance.GetStringWithInput (Localization.eLocalKeys.AV_Congratulations_Purchase_Of_x_Successful' id.Name)); " is 213.
Long Statement,AVHiddenInterface,InAppUnityAndoid,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\AVSharedScripts\InApp\InAppUnityAndoid.cs,PurchaseSuccess,The length of the statement  "				MsgBox.Show (Localization.Instance.GetString (Localization.eLocalKeys.AV_In_App_Purchases)' Localization.Instance.GetStringWithInput (Localization.eLocalKeys.AV_Congratulations_Purchase_Of_x_Successful' id.Name)); " is 213.
Long Statement,AVHiddenInterface,InAppUnityAndoid,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\AVSharedScripts\InApp\InAppUnityAndoid.cs,OnPurchaseFailed,The length of the statement  "		MsgBox.Show (Localization.Instance.GetString (Localization.eLocalKeys.AV_In_App_Purchases)' Localization.Instance.GetString (Localization.eLocalKeys.AV_Purchase_Failed_Already_Owned) + " " + Localization.Instance.GetString (Localization.eLocalKeys.AV_Purchase_Would_You_Like_Restore_Purchases)' MsgBoxType.YES_NO' response =>  { " is 328.
Long Statement,AVHiddenInterface,InAppUnityAndoid,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\AVSharedScripts\InApp\InAppUnityAndoid.cs,OnPurchaseFailed,The length of the statement  "		MsgBox.Show (Localization.Instance.GetString (Localization.eLocalKeys.AV_In_App_Purchases)' Localization.Instance.GetStringWithInput (Localization.eLocalKeys.AV_Purchase_Failed_For_x' id.Name)); " is 194.
Long Statement,AVHiddenInterface,InAppUnityEditor,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\AVSharedScripts\InApp\InAppUnityEditor.cs,PurchaseNotification,The length of the statement  "					MsgBox.Show (Localization.Instance.GetString (Localization.eLocalKeys.AV_In_App_Purchases)' Localization.Instance.GetStringWithInput (Localization.eLocalKeys.AV_Congratulations_Purchase_Of_x_Successful' id.Name)); " is 213.
Long Statement,AVHiddenInterface,InAppUnityEditor,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\AVSharedScripts\InApp\InAppUnityEditor.cs,PurchaseNotification,The length of the statement  "				MsgBox.Show (Localization.Instance.GetString (Localization.eLocalKeys.AV_In_App_Purchases)' Localization.Instance.GetStringWithInput (Localization.eLocalKeys.AV_Congratulations_Purchase_Of_x_Successful' id.Name)); " is 213.
Long Statement,AVHiddenInterface,InAppUnityIOS,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\AVSharedScripts\InApp\InAppUnityIOS.cs,PurchaseNotification,The length of the statement  "                                Localization.Instance.GetStringWithInput(Localization.eLocalKeys.AV_Congratulations_Purchase_Of_x_Successful' id.Name));" is 120.
Long Statement,AVHiddenInterface,InAppUnityIOS,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\AVSharedScripts\InApp\InAppUnityIOS.cs,PurchaseNotification,The length of the statement  "                            Localization.Instance.GetStringWithInput(Localization.eLocalKeys.AV_Congratulations_Purchase_Of_x_Successful' id.Name));" is 120.
Long Statement,AVHiddenInterface,InAppUnityMac,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\AVSharedScripts\InApp\InAppUnityMac.cs,RequestPurchase,The length of the statement  "			MsgBox.Show (Localization.Instance.GetString (Localization.eLocalKeys.AV_In_App_Purchases)' Localization.Instance.GetString (Localization.eLocalKeys.AV_Purchase_Failed_Already_Owned)); " is 184.
Long Statement,AVHiddenInterface,InAppUnityMac,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\AVSharedScripts\InApp\InAppUnityMac.cs,PurchaseNotification,The length of the statement  "					MsgBox.Show (Localization.Instance.GetString (Localization.eLocalKeys.AV_In_App_Purchases)' Localization.Instance.GetStringWithInput (Localization.eLocalKeys.AV_Congratulations_Purchase_Of_x_Successful' id.Name)); " is 213.
Long Statement,AVHiddenInterface,InAppUnityMac,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\AVSharedScripts\InApp\InAppUnityMac.cs,PurchaseNotification,The length of the statement  "				MsgBox.Show (Localization.Instance.GetString (Localization.eLocalKeys.AV_In_App_Purchases)' Localization.Instance.GetStringWithInput (Localization.eLocalKeys.AV_Congratulations_Purchase_Of_x_Successful' id.Name)); " is 213.
Long Statement,Facebook,AndroidFacebook,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\Facebook\Scripts\AndroidFacebook.cs,OnAppRequestsComplete,The length of the statement  "			OnFacebookResponse (callbackId' new FBResult (MiniJSON.Json.Serialize (result)' "Malformed request response.  Please file a bug with facebook here: https://developers.facebook.com/bugs/create")); " is 195.
Long Statement,Facebook,AndroidFacebook,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\Facebook\Scripts\AndroidFacebook.cs,OnFeedRequestComplete,The length of the statement  "			OnFacebookResponse (callbackId' new FBResult (MiniJSON.Json.Serialize (result)' "Malformed request response.  Please file a bug with facebook here: https://developers.facebook.com/bugs/create")); " is 195.
Long Statement,Facebook,EditorFacebook,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\Facebook\Scripts\EditorFacebook.cs,Init,The length of the statement  "	StartCoroutine (OnInit (onInitComplete' appId' cookie' logging' status' xfbml' channelUrl' authResponse' frictionlessRequests' hideUnityDelegate)); " is 147.
Long Statement,Facebook,EditorFacebook,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\Facebook\Scripts\EditorFacebook.cs,OnInit,The length of the statement  "	fb.Init (onInitComplete' appId' cookie' logging' status' xfbml' channelUrl' authResponse' frictionlessRequests' hideUnityDelegate); " is 131.
Long Statement,Facebook,EditorFacebook,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\Facebook\Scripts\EditorFacebook.cs,FeedRequest,The length of the statement  "	fb.FeedRequest (toId' link' linkName' linkCaption' linkDescription' picture' mediaSource' actionName' actionLink' reference' properties' callback); " is 147.
Long Statement,Facebook,IOSFacebook,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\Facebook\Scripts\IOSFacebook.cs,AppRequest,The length of the statement  "	iosAppRequest (Convert.ToInt32 (AddFacebookDelegate (callback))' message' (actionType != null) ? actionType.ToString () : null' objectId' to' to != null ? to.Length : 0' mobileFilter != null ? mobileFilter : ""' excludeIds' excludeIds != null ? excludeIds.Length : 0' maxRecipients.HasValue' maxRecipients.HasValue ? maxRecipients.Value : 0' data' title); " is 355.
Long Statement,Facebook,IOSFacebook,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\Facebook\Scripts\IOSFacebook.cs,FeedRequest,The length of the statement  "	iosFeedRequest (System.Convert.ToInt32 (AddFacebookDelegate (callback))' toId' link' linkName' linkCaption' linkDescription' picture' mediaSource' actionName' actionLink' reference); " is 182.
Long Statement,Facebook,IOSFacebook,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\Facebook\Scripts\IOSFacebook.cs,OnRequestComplete,The length of the statement  "		FbDebug.Error ("Malformed callback from ios.  I expected the form id:message but couldn't find either the ':' character or the id."); " is 133.
Long Statement,tk2dRuntime,SpriteCollectionGenerator,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexture,The length of the statement  "			UnityEditor.EditorUtility.DisplayDialog ("tk2dRuntimeSpriteCollection Error"' "The tk2d/BlendVertexColor shader needs to be in a resources folder for this to work.\n\n" + "Create a subdirectory named 'resources' where the shaders are' and move the BlendVertexColor shader into this directory.\n\n" + "eg. TK2DROOT/tk2d/Shaders/Resources/BlendVertexColor\n\n" + "Be sure to do this from within Unity and not from Explorer/Finder."' "Ok"); " is 437.
Long Statement,tk2dRuntime,SpriteCollectionGenerator,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexture,The length of the statement  "		sc.spriteDefinitions [i] = CreateDefinitionForRegionInTexture (names [i]' textureDimensions' scale' regions [i]' trimRect' anchors [i]' defRotated); " is 148.
Long Statement,tk2dRuntime,SpriteCollectionGenerator,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateDefinitionForRegionInTexture,The length of the statement  "	Vector2 v0 = new Vector2 ((uvRegion.x + uvOffset.x) / fwidth' 1.0f - (uvRegion.y + uvRegion.height + uvOffset.y) / fheight); " is 124.
Long Statement,tk2dRuntime,SpriteCollectionGenerator,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateDefinitionForRegionInTexture,The length of the statement  "	Vector2 v1 = new Vector2 ((uvRegion.x + uvRegion.width - uvOffset.x) / fwidth' 1.0f - (uvRegion.y - uvOffset.y) / fheight); " is 123.
Long Statement,tk2dRuntime,SpriteCollectionGenerator,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The length of the statement  "							entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4])); " is 123.
Long Statement,tk2dRuntime,SpriteCollectionGenerator,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The length of the statement  "	return CreateFromTexture (texture' spriteCollectionSize' textureDimensions' names.ToArray ()' rects.ToArray ()' trimRects.ToArray ()' anchors.ToArray ()' rotated.ToArray ()); " is 174.
Long Statement,tk2dRuntime.TileMap,BuilderUtil,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapBuilderUtil.cs,InitDataStore,The length of the statement  "			tileMap.Layers [i] = new Layer (tileMap.data.Layers [i].hash' tileMap.width' tileMap.height' tileMap.partitionSizeX' tileMap.partitionSizeY); " is 141.
Long Statement,tk2dRuntime.TileMap,BuilderUtil,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapBuilderUtil.cs,InitDataStore,The length of the statement  "				newLayers [i] = new Layer (layerInfo.hash' tileMap.width' tileMap.height' tileMap.partitionSizeX' tileMap.partitionSizeY); " is 122.
Long Statement,tk2dRuntime.TileMap,BuilderUtil,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapBuilderUtil.cs,InitDataStore,The length of the statement  "		tileMap.ColorChannel = new ColorChannel (tileMap.width' tileMap.height' tileMap.partitionSizeX' tileMap.partitionSizeY); " is 120.
Long Statement,tk2dRuntime.TileMap,BuilderUtil,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapBuilderUtil.cs,CreateRenderData,The length of the statement  "			layer.gameObject.transform.localPosition = new Vector3 (0' 0' tileMap.data.layersFixedZ ? (-layerInfoZ) : accumulatedLayerZ); " is 125.
Long Statement,tk2dRuntime.TileMap,BuilderUtil,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapBuilderUtil.cs,CreateRenderData,The length of the statement  "		BuilderUtil.GetLoopOrder (tileMap.data.sortMethod' layer.numColumns' layer.numRows' out x0' out x1' out dx' out y0' out y1' out dy); " is 132.
Long Statement,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The length of the statement  "					Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90); " is 136.
Long Statement,tk2dRuntime.TileMap,RenderMeshBuilder,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapMeshBuilder.cs,BuildForChunk,The length of the statement  "	BuilderUtil.GetLoopOrder (tileMap.data.sortMethod' tileMap.partitionSizeX' tileMap.partitionSizeY' out x0' out x1' out dx' out y0' out y1' out dy); " is 147.
Long Statement,tk2dRuntime.TileMap,RenderMeshBuilder,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapMeshBuilder.cs,BuildForChunk,The length of the statement  "				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' sprite' sprite.positions [v]' flipH' flipV' rot90); " is 121.
Long Statement,tk2dRuntime.TileMap,RenderMeshBuilder,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapMeshBuilder.cs,BuildForChunk,The length of the statement  "					Color color = Color.Lerp (Color.Lerp (tileColorx0y0' tileColorx1y0' tileColorX)' Color.Lerp (tileColorx0y1' tileColorx1y1' tileColorX)' tileColorY); " is 148.
Long Statement,SimpleJSON,JSONNode,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\Utility\SimpleJSON.cs,SaveToCompressedStream,The length of the statement  "	throw new Exception ("Can't use compressed functions. You need include the SharpZipLib and uncomment the define at the top of SimpleJSON"); " is 139.
Long Statement,SimpleJSON,JSONNode,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\Utility\SimpleJSON.cs,SaveToCompressedFile,The length of the statement  "	throw new Exception ("Can't use compressed functions. You need include the SharpZipLib and uncomment the define at the top of SimpleJSON"); " is 139.
Long Statement,SimpleJSON,JSONNode,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\Utility\SimpleJSON.cs,SaveToCompressedBase64,The length of the statement  "	throw new Exception ("Can't use compressed functions. You need include the SharpZipLib and uncomment the define at the top of SimpleJSON"); " is 139.
Long Statement,SimpleJSON,JSONNode,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\Utility\SimpleJSON.cs,LoadFromCompressedFile,The length of the statement  "	throw new Exception ("Can't use compressed functions. You need include the SharpZipLib and uncomment the define at the top of SimpleJSON"); " is 139.
Long Statement,SimpleJSON,JSONNode,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\Utility\SimpleJSON.cs,LoadFromCompressedStream,The length of the statement  "	throw new Exception ("Can't use compressed functions. You need include the SharpZipLib and uncomment the define at the top of SimpleJSON"); " is 139.
Long Statement,SimpleJSON,JSONNode,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\Utility\SimpleJSON.cs,LoadFromCompressedBase64,The length of the statement  "	throw new Exception ("Can't use compressed functions. You need include the SharpZipLib and uncomment the define at the top of SimpleJSON"); " is 139.
Complex Conditional,AceViral,AVFacebook,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\AVSharedScripts\Facebook\AVFacebook.cs,PublishNewScore,The conditional expression  "(isHigherScoreBetter && currentScore < score) || (!isHigherScoreBetter && currentScore > score)"  is complex.
Complex Conditional,tk2dRuntime.TileMap,ColorChannel,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapChunks.cs,Optimize,The conditional expression  "c.r != clearColor32.r || c.g != clearColor32.g || c.b != clearColor32.b || c.a != clearColor32.a"  is complex.
Magic Number,AceViral,ScrollPage,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\AVSharedScripts\AceVIral\ScrollPage.cs,TouchUp,The following statement contains a magic number: if (touchAccepted) {  	if (!touchHasScrolled) {  		Ray ray = Camera.main.ScreenPointToRay (Camera.main.WorldToScreenPoint (previousTouchPosition));  		RaycastHit[] hits = Physics.RaycastAll (ray' 100);  		for (int i = 0; i < hits.Length; i++) {  			int hitId = hits [i].transform.gameObject.GetInstanceID ();  			for (int j = 0; j < selectableObjects.Length; j++) {  				int instanceId = selectableObjects [j].gameObject.GetInstanceID ();  				if (instanceId == hitId) {  					ObjectSelected (selectableObjects [j]' j);  					return;  				}  			}  		}  	}  	else {  		autoScrollActive = true;  	}  }  
Magic Number,AceViral,ScrollPage,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\AVSharedScripts\AceVIral\ScrollPage.cs,TouchUp,The following statement contains a magic number: if (!touchHasScrolled) {  	Ray ray = Camera.main.ScreenPointToRay (Camera.main.WorldToScreenPoint (previousTouchPosition));  	RaycastHit[] hits = Physics.RaycastAll (ray' 100);  	for (int i = 0; i < hits.Length; i++) {  		int hitId = hits [i].transform.gameObject.GetInstanceID ();  		for (int j = 0; j < selectableObjects.Length; j++) {  			int instanceId = selectableObjects [j].gameObject.GetInstanceID ();  			if (instanceId == hitId) {  				ObjectSelected (selectableObjects [j]' j);  				return;  			}  		}  	}  }  else {  	autoScrollActive = true;  }  
Magic Number,AceViral,CloudManager,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\AVSharedScripts\Cloud\CloudManager.cs,LoadAllData,The following statement contains a magic number: for (int i = 0; i < array.Length; i++) {  	string[] splitInfo = array [i].Split (new string[] {  		"|-|"  	}' System.StringSplitOptions.None);  	if (splitInfo.Length == 2) {  		string key = splitInfo [0];  		string data = splitInfo [1];  		dict.Add (key' data);  	}  }  
Magic Number,AceViral,CloudManager,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\AVSharedScripts\Cloud\CloudManager.cs,LoadAllData,The following statement contains a magic number: if (splitInfo.Length == 2) {  	string key = splitInfo [0];  	string data = splitInfo [1];  	dict.Add (key' data);  }  
Magic Number,AceViral,AVFacebook,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\AVSharedScripts\Facebook\AVFacebook.cs,RequestNewFriendScores,The following statement contains a magic number: if (IsLoggedIn () && !m_RequestingFriendScores) {  	m_RequestingFriendScores = true;  	FB.API (FB.AppId + "/scores"' Facebook.HttpMethod.GET' result =>  {  		m_RequestingFriendScores = false;  		if (result.Error != null && result.Error != string.Empty) {  			Debug.LogError ("Facebook Request Scores Error: " + result.Error + " TEXT: " + result.Text);  			return;  		}  		JSONNode users = JSON.Parse (result.Text) ["data"];  		foreach (JSONNode node in users.Childs) {  			UpdateFriendListWithUserJSONData (node);  		}  		#if UNITY_EDITOR  		UpdateFriendData ("Test A"' "7"' UnityEngine.Random.Range (0' 99999));  		UpdateFriendData ("Test B"' "11"' UnityEngine.Random.Range (0' 99999));  		UpdateFriendData ("Test C"' "12"' UnityEngine.Random.Range (0' 99999));  		UpdateFriendData ("Test D"' "10"' UnityEngine.Random.Range (0' 99999));  		UpdateFriendData ("Test E"' "4"' UnityEngine.Random.Range (0' 99999));  		UpdateFriendData ("Test F"' "5"' UnityEngine.Random.Range (0' 99999));  		UpdateFriendData ("Test G"' "6"' UnityEngine.Random.Range (0' 99999));  		#endif  		SortFriendScores ();  		CheckForProfilePictureToDownload ();  		if (m_FriendList != null && m_FriendList.Count > 0) {  			SendOnScoresReceivedEvent (m_FriendList.ToArray ());  		}  		SendOnScoresReceivedEvent (null);  	});  }  else {  	Debug.LogWarning ("Facebook Error: Attempted to get scores whilst not logged in. / Already requesting scores");  }  
Magic Number,AceViral,AVFacebook,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\AVSharedScripts\Facebook\AVFacebook.cs,RequestNewFriendScores,The following statement contains a magic number: if (IsLoggedIn () && !m_RequestingFriendScores) {  	m_RequestingFriendScores = true;  	FB.API (FB.AppId + "/scores"' Facebook.HttpMethod.GET' result =>  {  		m_RequestingFriendScores = false;  		if (result.Error != null && result.Error != string.Empty) {  			Debug.LogError ("Facebook Request Scores Error: " + result.Error + " TEXT: " + result.Text);  			return;  		}  		JSONNode users = JSON.Parse (result.Text) ["data"];  		foreach (JSONNode node in users.Childs) {  			UpdateFriendListWithUserJSONData (node);  		}  		#if UNITY_EDITOR  		UpdateFriendData ("Test A"' "7"' UnityEngine.Random.Range (0' 99999));  		UpdateFriendData ("Test B"' "11"' UnityEngine.Random.Range (0' 99999));  		UpdateFriendData ("Test C"' "12"' UnityEngine.Random.Range (0' 99999));  		UpdateFriendData ("Test D"' "10"' UnityEngine.Random.Range (0' 99999));  		UpdateFriendData ("Test E"' "4"' UnityEngine.Random.Range (0' 99999));  		UpdateFriendData ("Test F"' "5"' UnityEngine.Random.Range (0' 99999));  		UpdateFriendData ("Test G"' "6"' UnityEngine.Random.Range (0' 99999));  		#endif  		SortFriendScores ();  		CheckForProfilePictureToDownload ();  		if (m_FriendList != null && m_FriendList.Count > 0) {  			SendOnScoresReceivedEvent (m_FriendList.ToArray ());  		}  		SendOnScoresReceivedEvent (null);  	});  }  else {  	Debug.LogWarning ("Facebook Error: Attempted to get scores whilst not logged in. / Already requesting scores");  }  
Magic Number,AceViral,AVFacebook,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\AVSharedScripts\Facebook\AVFacebook.cs,RequestNewFriendScores,The following statement contains a magic number: if (IsLoggedIn () && !m_RequestingFriendScores) {  	m_RequestingFriendScores = true;  	FB.API (FB.AppId + "/scores"' Facebook.HttpMethod.GET' result =>  {  		m_RequestingFriendScores = false;  		if (result.Error != null && result.Error != string.Empty) {  			Debug.LogError ("Facebook Request Scores Error: " + result.Error + " TEXT: " + result.Text);  			return;  		}  		JSONNode users = JSON.Parse (result.Text) ["data"];  		foreach (JSONNode node in users.Childs) {  			UpdateFriendListWithUserJSONData (node);  		}  		#if UNITY_EDITOR  		UpdateFriendData ("Test A"' "7"' UnityEngine.Random.Range (0' 99999));  		UpdateFriendData ("Test B"' "11"' UnityEngine.Random.Range (0' 99999));  		UpdateFriendData ("Test C"' "12"' UnityEngine.Random.Range (0' 99999));  		UpdateFriendData ("Test D"' "10"' UnityEngine.Random.Range (0' 99999));  		UpdateFriendData ("Test E"' "4"' UnityEngine.Random.Range (0' 99999));  		UpdateFriendData ("Test F"' "5"' UnityEngine.Random.Range (0' 99999));  		UpdateFriendData ("Test G"' "6"' UnityEngine.Random.Range (0' 99999));  		#endif  		SortFriendScores ();  		CheckForProfilePictureToDownload ();  		if (m_FriendList != null && m_FriendList.Count > 0) {  			SendOnScoresReceivedEvent (m_FriendList.ToArray ());  		}  		SendOnScoresReceivedEvent (null);  	});  }  else {  	Debug.LogWarning ("Facebook Error: Attempted to get scores whilst not logged in. / Already requesting scores");  }  
Magic Number,AceViral,AVFacebook,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\AVSharedScripts\Facebook\AVFacebook.cs,RequestNewFriendScores,The following statement contains a magic number: if (IsLoggedIn () && !m_RequestingFriendScores) {  	m_RequestingFriendScores = true;  	FB.API (FB.AppId + "/scores"' Facebook.HttpMethod.GET' result =>  {  		m_RequestingFriendScores = false;  		if (result.Error != null && result.Error != string.Empty) {  			Debug.LogError ("Facebook Request Scores Error: " + result.Error + " TEXT: " + result.Text);  			return;  		}  		JSONNode users = JSON.Parse (result.Text) ["data"];  		foreach (JSONNode node in users.Childs) {  			UpdateFriendListWithUserJSONData (node);  		}  		#if UNITY_EDITOR  		UpdateFriendData ("Test A"' "7"' UnityEngine.Random.Range (0' 99999));  		UpdateFriendData ("Test B"' "11"' UnityEngine.Random.Range (0' 99999));  		UpdateFriendData ("Test C"' "12"' UnityEngine.Random.Range (0' 99999));  		UpdateFriendData ("Test D"' "10"' UnityEngine.Random.Range (0' 99999));  		UpdateFriendData ("Test E"' "4"' UnityEngine.Random.Range (0' 99999));  		UpdateFriendData ("Test F"' "5"' UnityEngine.Random.Range (0' 99999));  		UpdateFriendData ("Test G"' "6"' UnityEngine.Random.Range (0' 99999));  		#endif  		SortFriendScores ();  		CheckForProfilePictureToDownload ();  		if (m_FriendList != null && m_FriendList.Count > 0) {  			SendOnScoresReceivedEvent (m_FriendList.ToArray ());  		}  		SendOnScoresReceivedEvent (null);  	});  }  else {  	Debug.LogWarning ("Facebook Error: Attempted to get scores whilst not logged in. / Already requesting scores");  }  
Magic Number,AceViral,AVFacebook,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\AVSharedScripts\Facebook\AVFacebook.cs,RequestNewFriendScores,The following statement contains a magic number: if (IsLoggedIn () && !m_RequestingFriendScores) {  	m_RequestingFriendScores = true;  	FB.API (FB.AppId + "/scores"' Facebook.HttpMethod.GET' result =>  {  		m_RequestingFriendScores = false;  		if (result.Error != null && result.Error != string.Empty) {  			Debug.LogError ("Facebook Request Scores Error: " + result.Error + " TEXT: " + result.Text);  			return;  		}  		JSONNode users = JSON.Parse (result.Text) ["data"];  		foreach (JSONNode node in users.Childs) {  			UpdateFriendListWithUserJSONData (node);  		}  		#if UNITY_EDITOR  		UpdateFriendData ("Test A"' "7"' UnityEngine.Random.Range (0' 99999));  		UpdateFriendData ("Test B"' "11"' UnityEngine.Random.Range (0' 99999));  		UpdateFriendData ("Test C"' "12"' UnityEngine.Random.Range (0' 99999));  		UpdateFriendData ("Test D"' "10"' UnityEngine.Random.Range (0' 99999));  		UpdateFriendData ("Test E"' "4"' UnityEngine.Random.Range (0' 99999));  		UpdateFriendData ("Test F"' "5"' UnityEngine.Random.Range (0' 99999));  		UpdateFriendData ("Test G"' "6"' UnityEngine.Random.Range (0' 99999));  		#endif  		SortFriendScores ();  		CheckForProfilePictureToDownload ();  		if (m_FriendList != null && m_FriendList.Count > 0) {  			SendOnScoresReceivedEvent (m_FriendList.ToArray ());  		}  		SendOnScoresReceivedEvent (null);  	});  }  else {  	Debug.LogWarning ("Facebook Error: Attempted to get scores whilst not logged in. / Already requesting scores");  }  
Magic Number,AceViral,AVFacebook,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\AVSharedScripts\Facebook\AVFacebook.cs,RequestNewFriendScores,The following statement contains a magic number: if (IsLoggedIn () && !m_RequestingFriendScores) {  	m_RequestingFriendScores = true;  	FB.API (FB.AppId + "/scores"' Facebook.HttpMethod.GET' result =>  {  		m_RequestingFriendScores = false;  		if (result.Error != null && result.Error != string.Empty) {  			Debug.LogError ("Facebook Request Scores Error: " + result.Error + " TEXT: " + result.Text);  			return;  		}  		JSONNode users = JSON.Parse (result.Text) ["data"];  		foreach (JSONNode node in users.Childs) {  			UpdateFriendListWithUserJSONData (node);  		}  		#if UNITY_EDITOR  		UpdateFriendData ("Test A"' "7"' UnityEngine.Random.Range (0' 99999));  		UpdateFriendData ("Test B"' "11"' UnityEngine.Random.Range (0' 99999));  		UpdateFriendData ("Test C"' "12"' UnityEngine.Random.Range (0' 99999));  		UpdateFriendData ("Test D"' "10"' UnityEngine.Random.Range (0' 99999));  		UpdateFriendData ("Test E"' "4"' UnityEngine.Random.Range (0' 99999));  		UpdateFriendData ("Test F"' "5"' UnityEngine.Random.Range (0' 99999));  		UpdateFriendData ("Test G"' "6"' UnityEngine.Random.Range (0' 99999));  		#endif  		SortFriendScores ();  		CheckForProfilePictureToDownload ();  		if (m_FriendList != null && m_FriendList.Count > 0) {  			SendOnScoresReceivedEvent (m_FriendList.ToArray ());  		}  		SendOnScoresReceivedEvent (null);  	});  }  else {  	Debug.LogWarning ("Facebook Error: Attempted to get scores whilst not logged in. / Already requesting scores");  }  
Magic Number,AceViral,AVFacebook,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\AVSharedScripts\Facebook\AVFacebook.cs,RequestNewFriendScores,The following statement contains a magic number: if (IsLoggedIn () && !m_RequestingFriendScores) {  	m_RequestingFriendScores = true;  	FB.API (FB.AppId + "/scores"' Facebook.HttpMethod.GET' result =>  {  		m_RequestingFriendScores = false;  		if (result.Error != null && result.Error != string.Empty) {  			Debug.LogError ("Facebook Request Scores Error: " + result.Error + " TEXT: " + result.Text);  			return;  		}  		JSONNode users = JSON.Parse (result.Text) ["data"];  		foreach (JSONNode node in users.Childs) {  			UpdateFriendListWithUserJSONData (node);  		}  		#if UNITY_EDITOR  		UpdateFriendData ("Test A"' "7"' UnityEngine.Random.Range (0' 99999));  		UpdateFriendData ("Test B"' "11"' UnityEngine.Random.Range (0' 99999));  		UpdateFriendData ("Test C"' "12"' UnityEngine.Random.Range (0' 99999));  		UpdateFriendData ("Test D"' "10"' UnityEngine.Random.Range (0' 99999));  		UpdateFriendData ("Test E"' "4"' UnityEngine.Random.Range (0' 99999));  		UpdateFriendData ("Test F"' "5"' UnityEngine.Random.Range (0' 99999));  		UpdateFriendData ("Test G"' "6"' UnityEngine.Random.Range (0' 99999));  		#endif  		SortFriendScores ();  		CheckForProfilePictureToDownload ();  		if (m_FriendList != null && m_FriendList.Count > 0) {  			SendOnScoresReceivedEvent (m_FriendList.ToArray ());  		}  		SendOnScoresReceivedEvent (null);  	});  }  else {  	Debug.LogWarning ("Facebook Error: Attempted to get scores whilst not logged in. / Already requesting scores");  }  
Magic Number,AceViral,AVFacebook,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\AVSharedScripts\Facebook\AVFacebook.cs,RequestNewFriendScores,The following statement contains a magic number: FB.API (FB.AppId + "/scores"' Facebook.HttpMethod.GET' result =>  {  	m_RequestingFriendScores = false;  	if (result.Error != null && result.Error != string.Empty) {  		Debug.LogError ("Facebook Request Scores Error: " + result.Error + " TEXT: " + result.Text);  		return;  	}  	JSONNode users = JSON.Parse (result.Text) ["data"];  	foreach (JSONNode node in users.Childs) {  		UpdateFriendListWithUserJSONData (node);  	}  	#if UNITY_EDITOR  	UpdateFriendData ("Test A"' "7"' UnityEngine.Random.Range (0' 99999));  	UpdateFriendData ("Test B"' "11"' UnityEngine.Random.Range (0' 99999));  	UpdateFriendData ("Test C"' "12"' UnityEngine.Random.Range (0' 99999));  	UpdateFriendData ("Test D"' "10"' UnityEngine.Random.Range (0' 99999));  	UpdateFriendData ("Test E"' "4"' UnityEngine.Random.Range (0' 99999));  	UpdateFriendData ("Test F"' "5"' UnityEngine.Random.Range (0' 99999));  	UpdateFriendData ("Test G"' "6"' UnityEngine.Random.Range (0' 99999));  	#endif  	SortFriendScores ();  	CheckForProfilePictureToDownload ();  	if (m_FriendList != null && m_FriendList.Count > 0) {  		SendOnScoresReceivedEvent (m_FriendList.ToArray ());  	}  	SendOnScoresReceivedEvent (null);  });  
Magic Number,AceViral,AVFacebook,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\AVSharedScripts\Facebook\AVFacebook.cs,RequestNewFriendScores,The following statement contains a magic number: FB.API (FB.AppId + "/scores"' Facebook.HttpMethod.GET' result =>  {  	m_RequestingFriendScores = false;  	if (result.Error != null && result.Error != string.Empty) {  		Debug.LogError ("Facebook Request Scores Error: " + result.Error + " TEXT: " + result.Text);  		return;  	}  	JSONNode users = JSON.Parse (result.Text) ["data"];  	foreach (JSONNode node in users.Childs) {  		UpdateFriendListWithUserJSONData (node);  	}  	#if UNITY_EDITOR  	UpdateFriendData ("Test A"' "7"' UnityEngine.Random.Range (0' 99999));  	UpdateFriendData ("Test B"' "11"' UnityEngine.Random.Range (0' 99999));  	UpdateFriendData ("Test C"' "12"' UnityEngine.Random.Range (0' 99999));  	UpdateFriendData ("Test D"' "10"' UnityEngine.Random.Range (0' 99999));  	UpdateFriendData ("Test E"' "4"' UnityEngine.Random.Range (0' 99999));  	UpdateFriendData ("Test F"' "5"' UnityEngine.Random.Range (0' 99999));  	UpdateFriendData ("Test G"' "6"' UnityEngine.Random.Range (0' 99999));  	#endif  	SortFriendScores ();  	CheckForProfilePictureToDownload ();  	if (m_FriendList != null && m_FriendList.Count > 0) {  		SendOnScoresReceivedEvent (m_FriendList.ToArray ());  	}  	SendOnScoresReceivedEvent (null);  });  
Magic Number,AceViral,AVFacebook,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\AVSharedScripts\Facebook\AVFacebook.cs,RequestNewFriendScores,The following statement contains a magic number: FB.API (FB.AppId + "/scores"' Facebook.HttpMethod.GET' result =>  {  	m_RequestingFriendScores = false;  	if (result.Error != null && result.Error != string.Empty) {  		Debug.LogError ("Facebook Request Scores Error: " + result.Error + " TEXT: " + result.Text);  		return;  	}  	JSONNode users = JSON.Parse (result.Text) ["data"];  	foreach (JSONNode node in users.Childs) {  		UpdateFriendListWithUserJSONData (node);  	}  	#if UNITY_EDITOR  	UpdateFriendData ("Test A"' "7"' UnityEngine.Random.Range (0' 99999));  	UpdateFriendData ("Test B"' "11"' UnityEngine.Random.Range (0' 99999));  	UpdateFriendData ("Test C"' "12"' UnityEngine.Random.Range (0' 99999));  	UpdateFriendData ("Test D"' "10"' UnityEngine.Random.Range (0' 99999));  	UpdateFriendData ("Test E"' "4"' UnityEngine.Random.Range (0' 99999));  	UpdateFriendData ("Test F"' "5"' UnityEngine.Random.Range (0' 99999));  	UpdateFriendData ("Test G"' "6"' UnityEngine.Random.Range (0' 99999));  	#endif  	SortFriendScores ();  	CheckForProfilePictureToDownload ();  	if (m_FriendList != null && m_FriendList.Count > 0) {  		SendOnScoresReceivedEvent (m_FriendList.ToArray ());  	}  	SendOnScoresReceivedEvent (null);  });  
Magic Number,AceViral,AVFacebook,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\AVSharedScripts\Facebook\AVFacebook.cs,RequestNewFriendScores,The following statement contains a magic number: FB.API (FB.AppId + "/scores"' Facebook.HttpMethod.GET' result =>  {  	m_RequestingFriendScores = false;  	if (result.Error != null && result.Error != string.Empty) {  		Debug.LogError ("Facebook Request Scores Error: " + result.Error + " TEXT: " + result.Text);  		return;  	}  	JSONNode users = JSON.Parse (result.Text) ["data"];  	foreach (JSONNode node in users.Childs) {  		UpdateFriendListWithUserJSONData (node);  	}  	#if UNITY_EDITOR  	UpdateFriendData ("Test A"' "7"' UnityEngine.Random.Range (0' 99999));  	UpdateFriendData ("Test B"' "11"' UnityEngine.Random.Range (0' 99999));  	UpdateFriendData ("Test C"' "12"' UnityEngine.Random.Range (0' 99999));  	UpdateFriendData ("Test D"' "10"' UnityEngine.Random.Range (0' 99999));  	UpdateFriendData ("Test E"' "4"' UnityEngine.Random.Range (0' 99999));  	UpdateFriendData ("Test F"' "5"' UnityEngine.Random.Range (0' 99999));  	UpdateFriendData ("Test G"' "6"' UnityEngine.Random.Range (0' 99999));  	#endif  	SortFriendScores ();  	CheckForProfilePictureToDownload ();  	if (m_FriendList != null && m_FriendList.Count > 0) {  		SendOnScoresReceivedEvent (m_FriendList.ToArray ());  	}  	SendOnScoresReceivedEvent (null);  });  
Magic Number,AceViral,AVFacebook,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\AVSharedScripts\Facebook\AVFacebook.cs,RequestNewFriendScores,The following statement contains a magic number: FB.API (FB.AppId + "/scores"' Facebook.HttpMethod.GET' result =>  {  	m_RequestingFriendScores = false;  	if (result.Error != null && result.Error != string.Empty) {  		Debug.LogError ("Facebook Request Scores Error: " + result.Error + " TEXT: " + result.Text);  		return;  	}  	JSONNode users = JSON.Parse (result.Text) ["data"];  	foreach (JSONNode node in users.Childs) {  		UpdateFriendListWithUserJSONData (node);  	}  	#if UNITY_EDITOR  	UpdateFriendData ("Test A"' "7"' UnityEngine.Random.Range (0' 99999));  	UpdateFriendData ("Test B"' "11"' UnityEngine.Random.Range (0' 99999));  	UpdateFriendData ("Test C"' "12"' UnityEngine.Random.Range (0' 99999));  	UpdateFriendData ("Test D"' "10"' UnityEngine.Random.Range (0' 99999));  	UpdateFriendData ("Test E"' "4"' UnityEngine.Random.Range (0' 99999));  	UpdateFriendData ("Test F"' "5"' UnityEngine.Random.Range (0' 99999));  	UpdateFriendData ("Test G"' "6"' UnityEngine.Random.Range (0' 99999));  	#endif  	SortFriendScores ();  	CheckForProfilePictureToDownload ();  	if (m_FriendList != null && m_FriendList.Count > 0) {  		SendOnScoresReceivedEvent (m_FriendList.ToArray ());  	}  	SendOnScoresReceivedEvent (null);  });  
Magic Number,AceViral,AVFacebook,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\AVSharedScripts\Facebook\AVFacebook.cs,RequestNewFriendScores,The following statement contains a magic number: FB.API (FB.AppId + "/scores"' Facebook.HttpMethod.GET' result =>  {  	m_RequestingFriendScores = false;  	if (result.Error != null && result.Error != string.Empty) {  		Debug.LogError ("Facebook Request Scores Error: " + result.Error + " TEXT: " + result.Text);  		return;  	}  	JSONNode users = JSON.Parse (result.Text) ["data"];  	foreach (JSONNode node in users.Childs) {  		UpdateFriendListWithUserJSONData (node);  	}  	#if UNITY_EDITOR  	UpdateFriendData ("Test A"' "7"' UnityEngine.Random.Range (0' 99999));  	UpdateFriendData ("Test B"' "11"' UnityEngine.Random.Range (0' 99999));  	UpdateFriendData ("Test C"' "12"' UnityEngine.Random.Range (0' 99999));  	UpdateFriendData ("Test D"' "10"' UnityEngine.Random.Range (0' 99999));  	UpdateFriendData ("Test E"' "4"' UnityEngine.Random.Range (0' 99999));  	UpdateFriendData ("Test F"' "5"' UnityEngine.Random.Range (0' 99999));  	UpdateFriendData ("Test G"' "6"' UnityEngine.Random.Range (0' 99999));  	#endif  	SortFriendScores ();  	CheckForProfilePictureToDownload ();  	if (m_FriendList != null && m_FriendList.Count > 0) {  		SendOnScoresReceivedEvent (m_FriendList.ToArray ());  	}  	SendOnScoresReceivedEvent (null);  });  
Magic Number,AceViral,AVFacebook,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\AVSharedScripts\Facebook\AVFacebook.cs,RequestNewFriendScores,The following statement contains a magic number: FB.API (FB.AppId + "/scores"' Facebook.HttpMethod.GET' result =>  {  	m_RequestingFriendScores = false;  	if (result.Error != null && result.Error != string.Empty) {  		Debug.LogError ("Facebook Request Scores Error: " + result.Error + " TEXT: " + result.Text);  		return;  	}  	JSONNode users = JSON.Parse (result.Text) ["data"];  	foreach (JSONNode node in users.Childs) {  		UpdateFriendListWithUserJSONData (node);  	}  	#if UNITY_EDITOR  	UpdateFriendData ("Test A"' "7"' UnityEngine.Random.Range (0' 99999));  	UpdateFriendData ("Test B"' "11"' UnityEngine.Random.Range (0' 99999));  	UpdateFriendData ("Test C"' "12"' UnityEngine.Random.Range (0' 99999));  	UpdateFriendData ("Test D"' "10"' UnityEngine.Random.Range (0' 99999));  	UpdateFriendData ("Test E"' "4"' UnityEngine.Random.Range (0' 99999));  	UpdateFriendData ("Test F"' "5"' UnityEngine.Random.Range (0' 99999));  	UpdateFriendData ("Test G"' "6"' UnityEngine.Random.Range (0' 99999));  	#endif  	SortFriendScores ();  	CheckForProfilePictureToDownload ();  	if (m_FriendList != null && m_FriendList.Count > 0) {  		SendOnScoresReceivedEvent (m_FriendList.ToArray ());  	}  	SendOnScoresReceivedEvent (null);  });  
Magic Number,AceViral,AVFacebook,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\AVSharedScripts\Facebook\AVFacebook.cs,RequestNewFriendScores,The following statement contains a magic number: UpdateFriendData ("Test A"' "7"' UnityEngine.Random.Range (0' 99999));  
Magic Number,AceViral,AVFacebook,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\AVSharedScripts\Facebook\AVFacebook.cs,RequestNewFriendScores,The following statement contains a magic number: UpdateFriendData ("Test B"' "11"' UnityEngine.Random.Range (0' 99999));  
Magic Number,AceViral,AVFacebook,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\AVSharedScripts\Facebook\AVFacebook.cs,RequestNewFriendScores,The following statement contains a magic number: UpdateFriendData ("Test C"' "12"' UnityEngine.Random.Range (0' 99999));  
Magic Number,AceViral,AVFacebook,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\AVSharedScripts\Facebook\AVFacebook.cs,RequestNewFriendScores,The following statement contains a magic number: UpdateFriendData ("Test D"' "10"' UnityEngine.Random.Range (0' 99999));  
Magic Number,AceViral,AVFacebook,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\AVSharedScripts\Facebook\AVFacebook.cs,RequestNewFriendScores,The following statement contains a magic number: UpdateFriendData ("Test E"' "4"' UnityEngine.Random.Range (0' 99999));  
Magic Number,AceViral,AVFacebook,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\AVSharedScripts\Facebook\AVFacebook.cs,RequestNewFriendScores,The following statement contains a magic number: UpdateFriendData ("Test F"' "5"' UnityEngine.Random.Range (0' 99999));  
Magic Number,AceViral,AVFacebook,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\AVSharedScripts\Facebook\AVFacebook.cs,RequestNewFriendScores,The following statement contains a magic number: UpdateFriendData ("Test G"' "6"' UnityEngine.Random.Range (0' 99999));  
Magic Number,AceViral,AVFacebook,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\AVSharedScripts\Facebook\AVFacebook.cs,LoadFriendsFromPrefs,The following statement contains a magic number: if (!string.IsNullOrEmpty (rawFriendData)) {  	string[] eachFriend = rawFriendData.Split (new string[] {  		"||"  	}' StringSplitOptions.None);  	for (int i = 0; i < eachFriend.Length - 1; i++) {  		string[] friendData = eachFriend [i].Split (new string[] {  			"|"  		}' StringSplitOptions.None);  		bool profilePicDownloaded = bool.Parse (friendData [2]);  		AVFacebookFriend friend = new AVFacebookFriend (friendData [0]' friendData [1]' 0);  		#if !UNITY_WEBPLAYER  		if (profilePicDownloaded) {  			string loadPath = Path.Combine (Application.persistentDataPath' "FacebookPP/" + friend.ID);  			if (File.Exists (loadPath)) {  				byte[] imageBytes = System.IO.File.ReadAllBytes (loadPath);  				Texture2D imageTex = new Texture2D (1' 1' TextureFormat.RGBA32' false);  				imageTex.LoadImage (imageBytes);  				// Sometimes our ad images come in corrupted so check for this  				if (imageTex != null && imageTex.width > 20 && imageTex.height > 20) {  					friend.ProfilePicture = imageTex;  				}  				else {  					Debug.LogError ("AVFacebook.RecoverProfilePicFromCache - Error loading image: " + loadPath);  				}  			}  		}  		#endif  		m_FriendList.Add (friend);  	}  	Debug.Log ("Facebook friend info recovered from cache.");  	FindCurrentUsersProfile ();  }  
Magic Number,AceViral,AVFacebook,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\AVSharedScripts\Facebook\AVFacebook.cs,LoadFriendsFromPrefs,The following statement contains a magic number: if (!string.IsNullOrEmpty (rawFriendData)) {  	string[] eachFriend = rawFriendData.Split (new string[] {  		"||"  	}' StringSplitOptions.None);  	for (int i = 0; i < eachFriend.Length - 1; i++) {  		string[] friendData = eachFriend [i].Split (new string[] {  			"|"  		}' StringSplitOptions.None);  		bool profilePicDownloaded = bool.Parse (friendData [2]);  		AVFacebookFriend friend = new AVFacebookFriend (friendData [0]' friendData [1]' 0);  		#if !UNITY_WEBPLAYER  		if (profilePicDownloaded) {  			string loadPath = Path.Combine (Application.persistentDataPath' "FacebookPP/" + friend.ID);  			if (File.Exists (loadPath)) {  				byte[] imageBytes = System.IO.File.ReadAllBytes (loadPath);  				Texture2D imageTex = new Texture2D (1' 1' TextureFormat.RGBA32' false);  				imageTex.LoadImage (imageBytes);  				// Sometimes our ad images come in corrupted so check for this  				if (imageTex != null && imageTex.width > 20 && imageTex.height > 20) {  					friend.ProfilePicture = imageTex;  				}  				else {  					Debug.LogError ("AVFacebook.RecoverProfilePicFromCache - Error loading image: " + loadPath);  				}  			}  		}  		#endif  		m_FriendList.Add (friend);  	}  	Debug.Log ("Facebook friend info recovered from cache.");  	FindCurrentUsersProfile ();  }  
Magic Number,AceViral,AVFacebook,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\AVSharedScripts\Facebook\AVFacebook.cs,LoadFriendsFromPrefs,The following statement contains a magic number: if (!string.IsNullOrEmpty (rawFriendData)) {  	string[] eachFriend = rawFriendData.Split (new string[] {  		"||"  	}' StringSplitOptions.None);  	for (int i = 0; i < eachFriend.Length - 1; i++) {  		string[] friendData = eachFriend [i].Split (new string[] {  			"|"  		}' StringSplitOptions.None);  		bool profilePicDownloaded = bool.Parse (friendData [2]);  		AVFacebookFriend friend = new AVFacebookFriend (friendData [0]' friendData [1]' 0);  		#if !UNITY_WEBPLAYER  		if (profilePicDownloaded) {  			string loadPath = Path.Combine (Application.persistentDataPath' "FacebookPP/" + friend.ID);  			if (File.Exists (loadPath)) {  				byte[] imageBytes = System.IO.File.ReadAllBytes (loadPath);  				Texture2D imageTex = new Texture2D (1' 1' TextureFormat.RGBA32' false);  				imageTex.LoadImage (imageBytes);  				// Sometimes our ad images come in corrupted so check for this  				if (imageTex != null && imageTex.width > 20 && imageTex.height > 20) {  					friend.ProfilePicture = imageTex;  				}  				else {  					Debug.LogError ("AVFacebook.RecoverProfilePicFromCache - Error loading image: " + loadPath);  				}  			}  		}  		#endif  		m_FriendList.Add (friend);  	}  	Debug.Log ("Facebook friend info recovered from cache.");  	FindCurrentUsersProfile ();  }  
Magic Number,AceViral,AVFacebook,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\AVSharedScripts\Facebook\AVFacebook.cs,LoadFriendsFromPrefs,The following statement contains a magic number: for (int i = 0; i < eachFriend.Length - 1; i++) {  	string[] friendData = eachFriend [i].Split (new string[] {  		"|"  	}' StringSplitOptions.None);  	bool profilePicDownloaded = bool.Parse (friendData [2]);  	AVFacebookFriend friend = new AVFacebookFriend (friendData [0]' friendData [1]' 0);  	#if !UNITY_WEBPLAYER  	if (profilePicDownloaded) {  		string loadPath = Path.Combine (Application.persistentDataPath' "FacebookPP/" + friend.ID);  		if (File.Exists (loadPath)) {  			byte[] imageBytes = System.IO.File.ReadAllBytes (loadPath);  			Texture2D imageTex = new Texture2D (1' 1' TextureFormat.RGBA32' false);  			imageTex.LoadImage (imageBytes);  			// Sometimes our ad images come in corrupted so check for this  			if (imageTex != null && imageTex.width > 20 && imageTex.height > 20) {  				friend.ProfilePicture = imageTex;  			}  			else {  				Debug.LogError ("AVFacebook.RecoverProfilePicFromCache - Error loading image: " + loadPath);  			}  		}  	}  	#endif  	m_FriendList.Add (friend);  }  
Magic Number,AceViral,AVFacebook,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\AVSharedScripts\Facebook\AVFacebook.cs,LoadFriendsFromPrefs,The following statement contains a magic number: for (int i = 0; i < eachFriend.Length - 1; i++) {  	string[] friendData = eachFriend [i].Split (new string[] {  		"|"  	}' StringSplitOptions.None);  	bool profilePicDownloaded = bool.Parse (friendData [2]);  	AVFacebookFriend friend = new AVFacebookFriend (friendData [0]' friendData [1]' 0);  	#if !UNITY_WEBPLAYER  	if (profilePicDownloaded) {  		string loadPath = Path.Combine (Application.persistentDataPath' "FacebookPP/" + friend.ID);  		if (File.Exists (loadPath)) {  			byte[] imageBytes = System.IO.File.ReadAllBytes (loadPath);  			Texture2D imageTex = new Texture2D (1' 1' TextureFormat.RGBA32' false);  			imageTex.LoadImage (imageBytes);  			// Sometimes our ad images come in corrupted so check for this  			if (imageTex != null && imageTex.width > 20 && imageTex.height > 20) {  				friend.ProfilePicture = imageTex;  			}  			else {  				Debug.LogError ("AVFacebook.RecoverProfilePicFromCache - Error loading image: " + loadPath);  			}  		}  	}  	#endif  	m_FriendList.Add (friend);  }  
Magic Number,AceViral,AVFacebook,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\AVSharedScripts\Facebook\AVFacebook.cs,LoadFriendsFromPrefs,The following statement contains a magic number: for (int i = 0; i < eachFriend.Length - 1; i++) {  	string[] friendData = eachFriend [i].Split (new string[] {  		"|"  	}' StringSplitOptions.None);  	bool profilePicDownloaded = bool.Parse (friendData [2]);  	AVFacebookFriend friend = new AVFacebookFriend (friendData [0]' friendData [1]' 0);  	#if !UNITY_WEBPLAYER  	if (profilePicDownloaded) {  		string loadPath = Path.Combine (Application.persistentDataPath' "FacebookPP/" + friend.ID);  		if (File.Exists (loadPath)) {  			byte[] imageBytes = System.IO.File.ReadAllBytes (loadPath);  			Texture2D imageTex = new Texture2D (1' 1' TextureFormat.RGBA32' false);  			imageTex.LoadImage (imageBytes);  			// Sometimes our ad images come in corrupted so check for this  			if (imageTex != null && imageTex.width > 20 && imageTex.height > 20) {  				friend.ProfilePicture = imageTex;  			}  			else {  				Debug.LogError ("AVFacebook.RecoverProfilePicFromCache - Error loading image: " + loadPath);  			}  		}  	}  	#endif  	m_FriendList.Add (friend);  }  
Magic Number,AceViral,AVFacebook,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\AVSharedScripts\Facebook\AVFacebook.cs,LoadFriendsFromPrefs,The following statement contains a magic number: if (profilePicDownloaded) {  	string loadPath = Path.Combine (Application.persistentDataPath' "FacebookPP/" + friend.ID);  	if (File.Exists (loadPath)) {  		byte[] imageBytes = System.IO.File.ReadAllBytes (loadPath);  		Texture2D imageTex = new Texture2D (1' 1' TextureFormat.RGBA32' false);  		imageTex.LoadImage (imageBytes);  		// Sometimes our ad images come in corrupted so check for this  		if (imageTex != null && imageTex.width > 20 && imageTex.height > 20) {  			friend.ProfilePicture = imageTex;  		}  		else {  			Debug.LogError ("AVFacebook.RecoverProfilePicFromCache - Error loading image: " + loadPath);  		}  	}  }  
Magic Number,AceViral,AVFacebook,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\AVSharedScripts\Facebook\AVFacebook.cs,LoadFriendsFromPrefs,The following statement contains a magic number: if (profilePicDownloaded) {  	string loadPath = Path.Combine (Application.persistentDataPath' "FacebookPP/" + friend.ID);  	if (File.Exists (loadPath)) {  		byte[] imageBytes = System.IO.File.ReadAllBytes (loadPath);  		Texture2D imageTex = new Texture2D (1' 1' TextureFormat.RGBA32' false);  		imageTex.LoadImage (imageBytes);  		// Sometimes our ad images come in corrupted so check for this  		if (imageTex != null && imageTex.width > 20 && imageTex.height > 20) {  			friend.ProfilePicture = imageTex;  		}  		else {  			Debug.LogError ("AVFacebook.RecoverProfilePicFromCache - Error loading image: " + loadPath);  		}  	}  }  
Magic Number,AceViral,AVFacebook,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\AVSharedScripts\Facebook\AVFacebook.cs,LoadFriendsFromPrefs,The following statement contains a magic number: if (File.Exists (loadPath)) {  	byte[] imageBytes = System.IO.File.ReadAllBytes (loadPath);  	Texture2D imageTex = new Texture2D (1' 1' TextureFormat.RGBA32' false);  	imageTex.LoadImage (imageBytes);  	// Sometimes our ad images come in corrupted so check for this  	if (imageTex != null && imageTex.width > 20 && imageTex.height > 20) {  		friend.ProfilePicture = imageTex;  	}  	else {  		Debug.LogError ("AVFacebook.RecoverProfilePicFromCache - Error loading image: " + loadPath);  	}  }  
Magic Number,AceViral,AVFacebook,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\AVSharedScripts\Facebook\AVFacebook.cs,LoadFriendsFromPrefs,The following statement contains a magic number: if (File.Exists (loadPath)) {  	byte[] imageBytes = System.IO.File.ReadAllBytes (loadPath);  	Texture2D imageTex = new Texture2D (1' 1' TextureFormat.RGBA32' false);  	imageTex.LoadImage (imageBytes);  	// Sometimes our ad images come in corrupted so check for this  	if (imageTex != null && imageTex.width > 20 && imageTex.height > 20) {  		friend.ProfilePicture = imageTex;  	}  	else {  		Debug.LogError ("AVFacebook.RecoverProfilePicFromCache - Error loading image: " + loadPath);  	}  }  
Magic Number,AceViral,AVFacebook,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\AVSharedScripts\Facebook\AVFacebook.cs,LoadFriendsFromPrefs,The following statement contains a magic number: if (imageTex != null && imageTex.width > 20 && imageTex.height > 20) {  	friend.ProfilePicture = imageTex;  }  else {  	Debug.LogError ("AVFacebook.RecoverProfilePicFromCache - Error loading image: " + loadPath);  }  
Magic Number,AceViral,AVFacebook,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\AVSharedScripts\Facebook\AVFacebook.cs,LoadFriendsFromPrefs,The following statement contains a magic number: if (imageTex != null && imageTex.width > 20 && imageTex.height > 20) {  	friend.ProfilePicture = imageTex;  }  else {  	Debug.LogError ("AVFacebook.RecoverProfilePicFromCache - Error loading image: " + loadPath);  }  
Magic Number,AceViral,HouseAdManager,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\AVSharedScripts\HouseAds\HouseAdManager.cs,GetLocalImage,The following statement contains a magic number: if (File.Exists (path)) {  	byte[] imageBytes = System.IO.File.ReadAllBytes (path);  	Texture2D imageTex = new Texture2D (1' 1' TextureFormat.RGBA32' false);  	imageTex.LoadImage (imageBytes);  	// Sometimes our ad images come in corrupted so check for this  	if (imageTex != null && imageTex.width > 20 && imageTex.height > 20) {  		return imageTex;  	}  	Debug.LogError ("AVHouseAdManager.GetLocalImage() - Error loading image: " + path);  }  
Magic Number,AceViral,HouseAdManager,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\AVSharedScripts\HouseAds\HouseAdManager.cs,GetLocalImage,The following statement contains a magic number: if (File.Exists (path)) {  	byte[] imageBytes = System.IO.File.ReadAllBytes (path);  	Texture2D imageTex = new Texture2D (1' 1' TextureFormat.RGBA32' false);  	imageTex.LoadImage (imageBytes);  	// Sometimes our ad images come in corrupted so check for this  	if (imageTex != null && imageTex.width > 20 && imageTex.height > 20) {  		return imageTex;  	}  	Debug.LogError ("AVHouseAdManager.GetLocalImage() - Error loading image: " + path);  }  
Magic Number,AceViral,HouseAdManager,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\AVSharedScripts\HouseAds\HouseAdManager.cs,GetLocalImage,The following statement contains a magic number: if (imageTex != null && imageTex.width > 20 && imageTex.height > 20) {  	return imageTex;  }  
Magic Number,AceViral,HouseAdManager,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\AVSharedScripts\HouseAds\HouseAdManager.cs,GetLocalImage,The following statement contains a magic number: if (imageTex != null && imageTex.width > 20 && imageTex.height > 20) {  	return imageTex;  }  
Magic Number,AceViral,BillboardPlane,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\AVSharedScripts\Utility\BillboardPlane.cs,Update,The following statement contains a magic number: if (rotated) {  	m_Transform.Rotate (90' 0' 0);  }  else {  	m_Transform.Rotate (0' 0' 90);  }  
Magic Number,AceViral,BillboardPlane,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\AVSharedScripts\Utility\BillboardPlane.cs,Update,The following statement contains a magic number: if (rotated) {  	m_Transform.Rotate (90' 0' 0);  }  else {  	m_Transform.Rotate (0' 0' 90);  }  
Magic Number,AceViral,BillboardPlane,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\AVSharedScripts\Utility\BillboardPlane.cs,Update,The following statement contains a magic number: m_Transform.Rotate (90' 0' 0);  
Magic Number,AceViral,BillboardPlane,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\AVSharedScripts\Utility\BillboardPlane.cs,Update,The following statement contains a magic number: m_Transform.Rotate (0' 0' 90);  
Magic Number,AceViral,Utility,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\AVSharedScripts\Utility\Utility.cs,Round,The following statement contains a magic number: if ((digits < -15) || (digits > 15))  	throw new ArgumentOutOfRangeException ("digits"' "Rounding digits must be between -15 and 15' inclusive.");  
Magic Number,AceViral,Utility,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\AVSharedScripts\Utility\Utility.cs,Round,The following statement contains a magic number: if ((digits < -15) || (digits > 15))  	throw new ArgumentOutOfRangeException ("digits"' "Rounding digits must be between -15 and 15' inclusive.");  
Magic Number,AceViral,Utility,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\AVSharedScripts\Utility\Utility.cs,ScrambleString,The following statement contains a magic number: for (int i = 0; i < c.Length; i++) {  	c [i] = Convert.ToChar ((int)c [i] + ((front) ? 4 : -3));  	if (c [i] < '!')  		c [i] = '!';  	if (c [i] > 'z')  		c [i] = 'z';  	if (front)  		endString = c [i] + endString;  	else  		endString = endString + c [i];  }  
Magic Number,AceViral,Utility,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\AVSharedScripts\Utility\Utility.cs,ScrambleString,The following statement contains a magic number: for (int i = 0; i < c.Length; i++) {  	c [i] = Convert.ToChar ((int)c [i] + ((front) ? 4 : -3));  	if (c [i] < '!')  		c [i] = '!';  	if (c [i] > 'z')  		c [i] = 'z';  	if (front)  		endString = c [i] + endString;  	else  		endString = endString + c [i];  }  
Magic Number,AceViral,Utility,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\AVSharedScripts\Utility\Utility.cs,ScrambleString,The following statement contains a magic number: c [i] = Convert.ToChar ((int)c [i] + ((front) ? 4 : -3));  
Magic Number,AceViral,Utility,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\AVSharedScripts\Utility\Utility.cs,ScrambleString,The following statement contains a magic number: c [i] = Convert.ToChar ((int)c [i] + ((front) ? 4 : -3));  
Magic Number,AceViral,Utility,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\AVSharedScripts\Utility\Utility.cs,ScrambleStringFlip,The following statement contains a magic number: for (int i = 0; i < c.Length; i++) {  	c [i] = Convert.ToChar ((int)c [i] + ((front) ? 4 : -3));  	if (c [i] < '!')  		c [i] = '!';  	if (c [i] > 'z')  		c [i] = 'z';  	if (front)  		endString = c [i] + endString;  	else  		endString = endString + c [i];  	front = !front;  }  
Magic Number,AceViral,Utility,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\AVSharedScripts\Utility\Utility.cs,ScrambleStringFlip,The following statement contains a magic number: for (int i = 0; i < c.Length; i++) {  	c [i] = Convert.ToChar ((int)c [i] + ((front) ? 4 : -3));  	if (c [i] < '!')  		c [i] = '!';  	if (c [i] > 'z')  		c [i] = 'z';  	if (front)  		endString = c [i] + endString;  	else  		endString = endString + c [i];  	front = !front;  }  
Magic Number,AceViral,Utility,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\AVSharedScripts\Utility\Utility.cs,ScrambleStringFlip,The following statement contains a magic number: c [i] = Convert.ToChar ((int)c [i] + ((front) ? 4 : -3));  
Magic Number,AceViral,Utility,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\AVSharedScripts\Utility\Utility.cs,ScrambleStringFlip,The following statement contains a magic number: c [i] = Convert.ToChar ((int)c [i] + ((front) ? 4 : -3));  
Magic Number,AceViral,Utility,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\AVSharedScripts\Utility\Utility.cs,CreatePlane,The following statement contains a magic number: m.triangles = new int[] {  	0'  	1'  	2'  	0'  	2'  	3  };  
Magic Number,AceViral,Utility,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\AVSharedScripts\Utility\Utility.cs,CreatePlane,The following statement contains a magic number: m.triangles = new int[] {  	0'  	1'  	2'  	0'  	2'  	3  };  
Magic Number,AceViral,Utility,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\AVSharedScripts\Utility\Utility.cs,CreatePlane,The following statement contains a magic number: m.triangles = new int[] {  	0'  	1'  	2'  	0'  	2'  	3  };  
Magic Number,AVHiddenInterface,AVAdMobManagerIOS,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\AVSharedScripts\AdMob\AVAdMobManagerIOS.cs,GetAdvertHeight,The following statement contains a magic number: return 50;  
Magic Number,AVHiddenInterface,GameServicesTest,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\AVSharedScripts\Test Scenes\GameServicesTest.cs,Start,The following statement contains a magic number: updateAchievement.UIItem.OnClick += () =>  {  	outputText.text = "Update Achievement";  	GameServicesInterface.Instance.UpdateAchievement (AceViral.AppConstants.Achievements [0]' 0.5f' 5);  };  
Magic Number,AVHiddenInterface,GameServicesTest,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\AVSharedScripts\Test Scenes\GameServicesTest.cs,Start,The following statement contains a magic number: GameServicesInterface.Instance.UpdateAchievement (AceViral.AppConstants.Achievements [0]' 0.5f' 5);  
Magic Number,Facebook,AndroidFacebook,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\Facebook\Scripts\AndroidFacebook.cs,FromTimestamp,The following statement contains a magic number: return new DateTime (1970' 1' 1' 0' 0' 0' 0).AddSeconds (timestamp);  
Magic Number,Facebook,IOSFacebook,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\Facebook\Scripts\IOSFacebook.cs,FromTimestamp,The following statement contains a magic number: return new DateTime (1970' 1' 1' 0' 0' 0' 0).AddSeconds (timestamp);  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateDefinitionForRegionInTexture,The following statement contains a magic number: def.indices = new int[] {  	0'  	3'  	1'  	2'  	3'  	0  };  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateDefinitionForRegionInTexture,The following statement contains a magic number: def.indices = new int[] {  	0'  	3'  	1'  	2'  	3'  	0  };  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateDefinitionForRegionInTexture,The following statement contains a magic number: def.indices = new int[] {  	0'  	3'  	1'  	2'  	3'  	0  };  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateDefinitionForRegionInTexture,The following statement contains a magic number: def.boundsData = new Vector3[2] {  	(boundsMax + boundsMin) / 2.0f'  	(boundsMax - boundsMin)  };  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateDefinitionForRegionInTexture,The following statement contains a magic number: def.untrimmedBoundsData = new Vector3[2] {  	(boundsMax + boundsMin) / 2.0f'  	(boundsMax - boundsMin)  };  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: while (line != null) {  	if (line.Length > 0) {  		char cmd = line [0];  		switch (state) {  		case 0:  			{  				switch (cmd) {  				case 'i':  					break;  				// ignore version field for now  				case 'w':  					textureDimensions.x = Int32.Parse (line.Substring (2));  					break;  				case 'h':  					textureDimensions.y = Int32.Parse (line.Substring (2));  					break;  				// total number of sprites would be ideal to statically allocate  				case '~':  					state++;  					break;  				}  			}  			break;  		case 1:  			{  				switch (cmd) {  				case 'n':  					entryName = line.Substring (2);  					break;  				case 'r':  					entryRotated = Int32.Parse (line.Substring (2)) == 1;  					break;  				case 's':  					{  						// sprite  						string[] tokens = line.Split ();  						entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  					}  					break;  				case 'o':  					{  						// origin  						string[] tokens = line.Split ();  						entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  						entryTrimmed = true;  					}  					break;  				case '~':  					{  						names.Add (entryName);  						rotated.Add (entryRotated);  						rects.Add (entryRect);  						if (!entryTrimmed) {  							// The entryRect dimensions will be the wrong way around if the sprite is rotated  							if (entryRotated)  								entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  							else  								entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  						}  						trimRects.Add (entryTrimData);  						anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  						anchors.Add (anchor);  						entryName = "";  						entryTrimmed = false;  						entryRotated = false;  					}  					break;  				}  			}  			break;  		}  	}  	line = tr.ReadLine ();  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: while (line != null) {  	if (line.Length > 0) {  		char cmd = line [0];  		switch (state) {  		case 0:  			{  				switch (cmd) {  				case 'i':  					break;  				// ignore version field for now  				case 'w':  					textureDimensions.x = Int32.Parse (line.Substring (2));  					break;  				case 'h':  					textureDimensions.y = Int32.Parse (line.Substring (2));  					break;  				// total number of sprites would be ideal to statically allocate  				case '~':  					state++;  					break;  				}  			}  			break;  		case 1:  			{  				switch (cmd) {  				case 'n':  					entryName = line.Substring (2);  					break;  				case 'r':  					entryRotated = Int32.Parse (line.Substring (2)) == 1;  					break;  				case 's':  					{  						// sprite  						string[] tokens = line.Split ();  						entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  					}  					break;  				case 'o':  					{  						// origin  						string[] tokens = line.Split ();  						entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  						entryTrimmed = true;  					}  					break;  				case '~':  					{  						names.Add (entryName);  						rotated.Add (entryRotated);  						rects.Add (entryRect);  						if (!entryTrimmed) {  							// The entryRect dimensions will be the wrong way around if the sprite is rotated  							if (entryRotated)  								entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  							else  								entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  						}  						trimRects.Add (entryTrimData);  						anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  						anchors.Add (anchor);  						entryName = "";  						entryTrimmed = false;  						entryRotated = false;  					}  					break;  				}  			}  			break;  		}  	}  	line = tr.ReadLine ();  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: while (line != null) {  	if (line.Length > 0) {  		char cmd = line [0];  		switch (state) {  		case 0:  			{  				switch (cmd) {  				case 'i':  					break;  				// ignore version field for now  				case 'w':  					textureDimensions.x = Int32.Parse (line.Substring (2));  					break;  				case 'h':  					textureDimensions.y = Int32.Parse (line.Substring (2));  					break;  				// total number of sprites would be ideal to statically allocate  				case '~':  					state++;  					break;  				}  			}  			break;  		case 1:  			{  				switch (cmd) {  				case 'n':  					entryName = line.Substring (2);  					break;  				case 'r':  					entryRotated = Int32.Parse (line.Substring (2)) == 1;  					break;  				case 's':  					{  						// sprite  						string[] tokens = line.Split ();  						entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  					}  					break;  				case 'o':  					{  						// origin  						string[] tokens = line.Split ();  						entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  						entryTrimmed = true;  					}  					break;  				case '~':  					{  						names.Add (entryName);  						rotated.Add (entryRotated);  						rects.Add (entryRect);  						if (!entryTrimmed) {  							// The entryRect dimensions will be the wrong way around if the sprite is rotated  							if (entryRotated)  								entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  							else  								entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  						}  						trimRects.Add (entryTrimData);  						anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  						anchors.Add (anchor);  						entryName = "";  						entryTrimmed = false;  						entryRotated = false;  					}  					break;  				}  			}  			break;  		}  	}  	line = tr.ReadLine ();  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: while (line != null) {  	if (line.Length > 0) {  		char cmd = line [0];  		switch (state) {  		case 0:  			{  				switch (cmd) {  				case 'i':  					break;  				// ignore version field for now  				case 'w':  					textureDimensions.x = Int32.Parse (line.Substring (2));  					break;  				case 'h':  					textureDimensions.y = Int32.Parse (line.Substring (2));  					break;  				// total number of sprites would be ideal to statically allocate  				case '~':  					state++;  					break;  				}  			}  			break;  		case 1:  			{  				switch (cmd) {  				case 'n':  					entryName = line.Substring (2);  					break;  				case 'r':  					entryRotated = Int32.Parse (line.Substring (2)) == 1;  					break;  				case 's':  					{  						// sprite  						string[] tokens = line.Split ();  						entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  					}  					break;  				case 'o':  					{  						// origin  						string[] tokens = line.Split ();  						entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  						entryTrimmed = true;  					}  					break;  				case '~':  					{  						names.Add (entryName);  						rotated.Add (entryRotated);  						rects.Add (entryRect);  						if (!entryTrimmed) {  							// The entryRect dimensions will be the wrong way around if the sprite is rotated  							if (entryRotated)  								entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  							else  								entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  						}  						trimRects.Add (entryTrimData);  						anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  						anchors.Add (anchor);  						entryName = "";  						entryTrimmed = false;  						entryRotated = false;  					}  					break;  				}  			}  			break;  		}  	}  	line = tr.ReadLine ();  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: while (line != null) {  	if (line.Length > 0) {  		char cmd = line [0];  		switch (state) {  		case 0:  			{  				switch (cmd) {  				case 'i':  					break;  				// ignore version field for now  				case 'w':  					textureDimensions.x = Int32.Parse (line.Substring (2));  					break;  				case 'h':  					textureDimensions.y = Int32.Parse (line.Substring (2));  					break;  				// total number of sprites would be ideal to statically allocate  				case '~':  					state++;  					break;  				}  			}  			break;  		case 1:  			{  				switch (cmd) {  				case 'n':  					entryName = line.Substring (2);  					break;  				case 'r':  					entryRotated = Int32.Parse (line.Substring (2)) == 1;  					break;  				case 's':  					{  						// sprite  						string[] tokens = line.Split ();  						entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  					}  					break;  				case 'o':  					{  						// origin  						string[] tokens = line.Split ();  						entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  						entryTrimmed = true;  					}  					break;  				case '~':  					{  						names.Add (entryName);  						rotated.Add (entryRotated);  						rects.Add (entryRect);  						if (!entryTrimmed) {  							// The entryRect dimensions will be the wrong way around if the sprite is rotated  							if (entryRotated)  								entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  							else  								entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  						}  						trimRects.Add (entryTrimData);  						anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  						anchors.Add (anchor);  						entryName = "";  						entryTrimmed = false;  						entryRotated = false;  					}  					break;  				}  			}  			break;  		}  	}  	line = tr.ReadLine ();  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: while (line != null) {  	if (line.Length > 0) {  		char cmd = line [0];  		switch (state) {  		case 0:  			{  				switch (cmd) {  				case 'i':  					break;  				// ignore version field for now  				case 'w':  					textureDimensions.x = Int32.Parse (line.Substring (2));  					break;  				case 'h':  					textureDimensions.y = Int32.Parse (line.Substring (2));  					break;  				// total number of sprites would be ideal to statically allocate  				case '~':  					state++;  					break;  				}  			}  			break;  		case 1:  			{  				switch (cmd) {  				case 'n':  					entryName = line.Substring (2);  					break;  				case 'r':  					entryRotated = Int32.Parse (line.Substring (2)) == 1;  					break;  				case 's':  					{  						// sprite  						string[] tokens = line.Split ();  						entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  					}  					break;  				case 'o':  					{  						// origin  						string[] tokens = line.Split ();  						entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  						entryTrimmed = true;  					}  					break;  				case '~':  					{  						names.Add (entryName);  						rotated.Add (entryRotated);  						rects.Add (entryRect);  						if (!entryTrimmed) {  							// The entryRect dimensions will be the wrong way around if the sprite is rotated  							if (entryRotated)  								entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  							else  								entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  						}  						trimRects.Add (entryTrimData);  						anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  						anchors.Add (anchor);  						entryName = "";  						entryTrimmed = false;  						entryRotated = false;  					}  					break;  				}  			}  			break;  		}  	}  	line = tr.ReadLine ();  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: while (line != null) {  	if (line.Length > 0) {  		char cmd = line [0];  		switch (state) {  		case 0:  			{  				switch (cmd) {  				case 'i':  					break;  				// ignore version field for now  				case 'w':  					textureDimensions.x = Int32.Parse (line.Substring (2));  					break;  				case 'h':  					textureDimensions.y = Int32.Parse (line.Substring (2));  					break;  				// total number of sprites would be ideal to statically allocate  				case '~':  					state++;  					break;  				}  			}  			break;  		case 1:  			{  				switch (cmd) {  				case 'n':  					entryName = line.Substring (2);  					break;  				case 'r':  					entryRotated = Int32.Parse (line.Substring (2)) == 1;  					break;  				case 's':  					{  						// sprite  						string[] tokens = line.Split ();  						entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  					}  					break;  				case 'o':  					{  						// origin  						string[] tokens = line.Split ();  						entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  						entryTrimmed = true;  					}  					break;  				case '~':  					{  						names.Add (entryName);  						rotated.Add (entryRotated);  						rects.Add (entryRect);  						if (!entryTrimmed) {  							// The entryRect dimensions will be the wrong way around if the sprite is rotated  							if (entryRotated)  								entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  							else  								entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  						}  						trimRects.Add (entryTrimData);  						anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  						anchors.Add (anchor);  						entryName = "";  						entryTrimmed = false;  						entryRotated = false;  					}  					break;  				}  			}  			break;  		}  	}  	line = tr.ReadLine ();  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: while (line != null) {  	if (line.Length > 0) {  		char cmd = line [0];  		switch (state) {  		case 0:  			{  				switch (cmd) {  				case 'i':  					break;  				// ignore version field for now  				case 'w':  					textureDimensions.x = Int32.Parse (line.Substring (2));  					break;  				case 'h':  					textureDimensions.y = Int32.Parse (line.Substring (2));  					break;  				// total number of sprites would be ideal to statically allocate  				case '~':  					state++;  					break;  				}  			}  			break;  		case 1:  			{  				switch (cmd) {  				case 'n':  					entryName = line.Substring (2);  					break;  				case 'r':  					entryRotated = Int32.Parse (line.Substring (2)) == 1;  					break;  				case 's':  					{  						// sprite  						string[] tokens = line.Split ();  						entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  					}  					break;  				case 'o':  					{  						// origin  						string[] tokens = line.Split ();  						entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  						entryTrimmed = true;  					}  					break;  				case '~':  					{  						names.Add (entryName);  						rotated.Add (entryRotated);  						rects.Add (entryRect);  						if (!entryTrimmed) {  							// The entryRect dimensions will be the wrong way around if the sprite is rotated  							if (entryRotated)  								entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  							else  								entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  						}  						trimRects.Add (entryTrimData);  						anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  						anchors.Add (anchor);  						entryName = "";  						entryTrimmed = false;  						entryRotated = false;  					}  					break;  				}  			}  			break;  		}  	}  	line = tr.ReadLine ();  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: while (line != null) {  	if (line.Length > 0) {  		char cmd = line [0];  		switch (state) {  		case 0:  			{  				switch (cmd) {  				case 'i':  					break;  				// ignore version field for now  				case 'w':  					textureDimensions.x = Int32.Parse (line.Substring (2));  					break;  				case 'h':  					textureDimensions.y = Int32.Parse (line.Substring (2));  					break;  				// total number of sprites would be ideal to statically allocate  				case '~':  					state++;  					break;  				}  			}  			break;  		case 1:  			{  				switch (cmd) {  				case 'n':  					entryName = line.Substring (2);  					break;  				case 'r':  					entryRotated = Int32.Parse (line.Substring (2)) == 1;  					break;  				case 's':  					{  						// sprite  						string[] tokens = line.Split ();  						entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  					}  					break;  				case 'o':  					{  						// origin  						string[] tokens = line.Split ();  						entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  						entryTrimmed = true;  					}  					break;  				case '~':  					{  						names.Add (entryName);  						rotated.Add (entryRotated);  						rects.Add (entryRect);  						if (!entryTrimmed) {  							// The entryRect dimensions will be the wrong way around if the sprite is rotated  							if (entryRotated)  								entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  							else  								entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  						}  						trimRects.Add (entryTrimData);  						anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  						anchors.Add (anchor);  						entryName = "";  						entryTrimmed = false;  						entryRotated = false;  					}  					break;  				}  			}  			break;  		}  	}  	line = tr.ReadLine ();  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: while (line != null) {  	if (line.Length > 0) {  		char cmd = line [0];  		switch (state) {  		case 0:  			{  				switch (cmd) {  				case 'i':  					break;  				// ignore version field for now  				case 'w':  					textureDimensions.x = Int32.Parse (line.Substring (2));  					break;  				case 'h':  					textureDimensions.y = Int32.Parse (line.Substring (2));  					break;  				// total number of sprites would be ideal to statically allocate  				case '~':  					state++;  					break;  				}  			}  			break;  		case 1:  			{  				switch (cmd) {  				case 'n':  					entryName = line.Substring (2);  					break;  				case 'r':  					entryRotated = Int32.Parse (line.Substring (2)) == 1;  					break;  				case 's':  					{  						// sprite  						string[] tokens = line.Split ();  						entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  					}  					break;  				case 'o':  					{  						// origin  						string[] tokens = line.Split ();  						entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  						entryTrimmed = true;  					}  					break;  				case '~':  					{  						names.Add (entryName);  						rotated.Add (entryRotated);  						rects.Add (entryRect);  						if (!entryTrimmed) {  							// The entryRect dimensions will be the wrong way around if the sprite is rotated  							if (entryRotated)  								entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  							else  								entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  						}  						trimRects.Add (entryTrimData);  						anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  						anchors.Add (anchor);  						entryName = "";  						entryTrimmed = false;  						entryRotated = false;  					}  					break;  				}  			}  			break;  		}  	}  	line = tr.ReadLine ();  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: while (line != null) {  	if (line.Length > 0) {  		char cmd = line [0];  		switch (state) {  		case 0:  			{  				switch (cmd) {  				case 'i':  					break;  				// ignore version field for now  				case 'w':  					textureDimensions.x = Int32.Parse (line.Substring (2));  					break;  				case 'h':  					textureDimensions.y = Int32.Parse (line.Substring (2));  					break;  				// total number of sprites would be ideal to statically allocate  				case '~':  					state++;  					break;  				}  			}  			break;  		case 1:  			{  				switch (cmd) {  				case 'n':  					entryName = line.Substring (2);  					break;  				case 'r':  					entryRotated = Int32.Parse (line.Substring (2)) == 1;  					break;  				case 's':  					{  						// sprite  						string[] tokens = line.Split ();  						entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  					}  					break;  				case 'o':  					{  						// origin  						string[] tokens = line.Split ();  						entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  						entryTrimmed = true;  					}  					break;  				case '~':  					{  						names.Add (entryName);  						rotated.Add (entryRotated);  						rects.Add (entryRect);  						if (!entryTrimmed) {  							// The entryRect dimensions will be the wrong way around if the sprite is rotated  							if (entryRotated)  								entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  							else  								entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  						}  						trimRects.Add (entryTrimData);  						anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  						anchors.Add (anchor);  						entryName = "";  						entryTrimmed = false;  						entryRotated = false;  					}  					break;  				}  			}  			break;  		}  	}  	line = tr.ReadLine ();  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: while (line != null) {  	if (line.Length > 0) {  		char cmd = line [0];  		switch (state) {  		case 0:  			{  				switch (cmd) {  				case 'i':  					break;  				// ignore version field for now  				case 'w':  					textureDimensions.x = Int32.Parse (line.Substring (2));  					break;  				case 'h':  					textureDimensions.y = Int32.Parse (line.Substring (2));  					break;  				// total number of sprites would be ideal to statically allocate  				case '~':  					state++;  					break;  				}  			}  			break;  		case 1:  			{  				switch (cmd) {  				case 'n':  					entryName = line.Substring (2);  					break;  				case 'r':  					entryRotated = Int32.Parse (line.Substring (2)) == 1;  					break;  				case 's':  					{  						// sprite  						string[] tokens = line.Split ();  						entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  					}  					break;  				case 'o':  					{  						// origin  						string[] tokens = line.Split ();  						entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  						entryTrimmed = true;  					}  					break;  				case '~':  					{  						names.Add (entryName);  						rotated.Add (entryRotated);  						rects.Add (entryRect);  						if (!entryTrimmed) {  							// The entryRect dimensions will be the wrong way around if the sprite is rotated  							if (entryRotated)  								entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  							else  								entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  						}  						trimRects.Add (entryTrimData);  						anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  						anchors.Add (anchor);  						entryName = "";  						entryTrimmed = false;  						entryRotated = false;  					}  					break;  				}  			}  			break;  		}  	}  	line = tr.ReadLine ();  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: if (line.Length > 0) {  	char cmd = line [0];  	switch (state) {  	case 0:  		{  			switch (cmd) {  			case 'i':  				break;  			// ignore version field for now  			case 'w':  				textureDimensions.x = Int32.Parse (line.Substring (2));  				break;  			case 'h':  				textureDimensions.y = Int32.Parse (line.Substring (2));  				break;  			// total number of sprites would be ideal to statically allocate  			case '~':  				state++;  				break;  			}  		}  		break;  	case 1:  		{  			switch (cmd) {  			case 'n':  				entryName = line.Substring (2);  				break;  			case 'r':  				entryRotated = Int32.Parse (line.Substring (2)) == 1;  				break;  			case 's':  				{  					// sprite  					string[] tokens = line.Split ();  					entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  				}  				break;  			case 'o':  				{  					// origin  					string[] tokens = line.Split ();  					entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  					entryTrimmed = true;  				}  				break;  			case '~':  				{  					names.Add (entryName);  					rotated.Add (entryRotated);  					rects.Add (entryRect);  					if (!entryTrimmed) {  						// The entryRect dimensions will be the wrong way around if the sprite is rotated  						if (entryRotated)  							entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  						else  							entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  					}  					trimRects.Add (entryTrimData);  					anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  					anchors.Add (anchor);  					entryName = "";  					entryTrimmed = false;  					entryRotated = false;  				}  				break;  			}  		}  		break;  	}  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: if (line.Length > 0) {  	char cmd = line [0];  	switch (state) {  	case 0:  		{  			switch (cmd) {  			case 'i':  				break;  			// ignore version field for now  			case 'w':  				textureDimensions.x = Int32.Parse (line.Substring (2));  				break;  			case 'h':  				textureDimensions.y = Int32.Parse (line.Substring (2));  				break;  			// total number of sprites would be ideal to statically allocate  			case '~':  				state++;  				break;  			}  		}  		break;  	case 1:  		{  			switch (cmd) {  			case 'n':  				entryName = line.Substring (2);  				break;  			case 'r':  				entryRotated = Int32.Parse (line.Substring (2)) == 1;  				break;  			case 's':  				{  					// sprite  					string[] tokens = line.Split ();  					entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  				}  				break;  			case 'o':  				{  					// origin  					string[] tokens = line.Split ();  					entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  					entryTrimmed = true;  				}  				break;  			case '~':  				{  					names.Add (entryName);  					rotated.Add (entryRotated);  					rects.Add (entryRect);  					if (!entryTrimmed) {  						// The entryRect dimensions will be the wrong way around if the sprite is rotated  						if (entryRotated)  							entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  						else  							entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  					}  					trimRects.Add (entryTrimData);  					anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  					anchors.Add (anchor);  					entryName = "";  					entryTrimmed = false;  					entryRotated = false;  				}  				break;  			}  		}  		break;  	}  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: if (line.Length > 0) {  	char cmd = line [0];  	switch (state) {  	case 0:  		{  			switch (cmd) {  			case 'i':  				break;  			// ignore version field for now  			case 'w':  				textureDimensions.x = Int32.Parse (line.Substring (2));  				break;  			case 'h':  				textureDimensions.y = Int32.Parse (line.Substring (2));  				break;  			// total number of sprites would be ideal to statically allocate  			case '~':  				state++;  				break;  			}  		}  		break;  	case 1:  		{  			switch (cmd) {  			case 'n':  				entryName = line.Substring (2);  				break;  			case 'r':  				entryRotated = Int32.Parse (line.Substring (2)) == 1;  				break;  			case 's':  				{  					// sprite  					string[] tokens = line.Split ();  					entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  				}  				break;  			case 'o':  				{  					// origin  					string[] tokens = line.Split ();  					entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  					entryTrimmed = true;  				}  				break;  			case '~':  				{  					names.Add (entryName);  					rotated.Add (entryRotated);  					rects.Add (entryRect);  					if (!entryTrimmed) {  						// The entryRect dimensions will be the wrong way around if the sprite is rotated  						if (entryRotated)  							entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  						else  							entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  					}  					trimRects.Add (entryTrimData);  					anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  					anchors.Add (anchor);  					entryName = "";  					entryTrimmed = false;  					entryRotated = false;  				}  				break;  			}  		}  		break;  	}  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: if (line.Length > 0) {  	char cmd = line [0];  	switch (state) {  	case 0:  		{  			switch (cmd) {  			case 'i':  				break;  			// ignore version field for now  			case 'w':  				textureDimensions.x = Int32.Parse (line.Substring (2));  				break;  			case 'h':  				textureDimensions.y = Int32.Parse (line.Substring (2));  				break;  			// total number of sprites would be ideal to statically allocate  			case '~':  				state++;  				break;  			}  		}  		break;  	case 1:  		{  			switch (cmd) {  			case 'n':  				entryName = line.Substring (2);  				break;  			case 'r':  				entryRotated = Int32.Parse (line.Substring (2)) == 1;  				break;  			case 's':  				{  					// sprite  					string[] tokens = line.Split ();  					entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  				}  				break;  			case 'o':  				{  					// origin  					string[] tokens = line.Split ();  					entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  					entryTrimmed = true;  				}  				break;  			case '~':  				{  					names.Add (entryName);  					rotated.Add (entryRotated);  					rects.Add (entryRect);  					if (!entryTrimmed) {  						// The entryRect dimensions will be the wrong way around if the sprite is rotated  						if (entryRotated)  							entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  						else  							entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  					}  					trimRects.Add (entryTrimData);  					anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  					anchors.Add (anchor);  					entryName = "";  					entryTrimmed = false;  					entryRotated = false;  				}  				break;  			}  		}  		break;  	}  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: if (line.Length > 0) {  	char cmd = line [0];  	switch (state) {  	case 0:  		{  			switch (cmd) {  			case 'i':  				break;  			// ignore version field for now  			case 'w':  				textureDimensions.x = Int32.Parse (line.Substring (2));  				break;  			case 'h':  				textureDimensions.y = Int32.Parse (line.Substring (2));  				break;  			// total number of sprites would be ideal to statically allocate  			case '~':  				state++;  				break;  			}  		}  		break;  	case 1:  		{  			switch (cmd) {  			case 'n':  				entryName = line.Substring (2);  				break;  			case 'r':  				entryRotated = Int32.Parse (line.Substring (2)) == 1;  				break;  			case 's':  				{  					// sprite  					string[] tokens = line.Split ();  					entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  				}  				break;  			case 'o':  				{  					// origin  					string[] tokens = line.Split ();  					entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  					entryTrimmed = true;  				}  				break;  			case '~':  				{  					names.Add (entryName);  					rotated.Add (entryRotated);  					rects.Add (entryRect);  					if (!entryTrimmed) {  						// The entryRect dimensions will be the wrong way around if the sprite is rotated  						if (entryRotated)  							entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  						else  							entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  					}  					trimRects.Add (entryTrimData);  					anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  					anchors.Add (anchor);  					entryName = "";  					entryTrimmed = false;  					entryRotated = false;  				}  				break;  			}  		}  		break;  	}  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: if (line.Length > 0) {  	char cmd = line [0];  	switch (state) {  	case 0:  		{  			switch (cmd) {  			case 'i':  				break;  			// ignore version field for now  			case 'w':  				textureDimensions.x = Int32.Parse (line.Substring (2));  				break;  			case 'h':  				textureDimensions.y = Int32.Parse (line.Substring (2));  				break;  			// total number of sprites would be ideal to statically allocate  			case '~':  				state++;  				break;  			}  		}  		break;  	case 1:  		{  			switch (cmd) {  			case 'n':  				entryName = line.Substring (2);  				break;  			case 'r':  				entryRotated = Int32.Parse (line.Substring (2)) == 1;  				break;  			case 's':  				{  					// sprite  					string[] tokens = line.Split ();  					entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  				}  				break;  			case 'o':  				{  					// origin  					string[] tokens = line.Split ();  					entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  					entryTrimmed = true;  				}  				break;  			case '~':  				{  					names.Add (entryName);  					rotated.Add (entryRotated);  					rects.Add (entryRect);  					if (!entryTrimmed) {  						// The entryRect dimensions will be the wrong way around if the sprite is rotated  						if (entryRotated)  							entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  						else  							entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  					}  					trimRects.Add (entryTrimData);  					anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  					anchors.Add (anchor);  					entryName = "";  					entryTrimmed = false;  					entryRotated = false;  				}  				break;  			}  		}  		break;  	}  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: if (line.Length > 0) {  	char cmd = line [0];  	switch (state) {  	case 0:  		{  			switch (cmd) {  			case 'i':  				break;  			// ignore version field for now  			case 'w':  				textureDimensions.x = Int32.Parse (line.Substring (2));  				break;  			case 'h':  				textureDimensions.y = Int32.Parse (line.Substring (2));  				break;  			// total number of sprites would be ideal to statically allocate  			case '~':  				state++;  				break;  			}  		}  		break;  	case 1:  		{  			switch (cmd) {  			case 'n':  				entryName = line.Substring (2);  				break;  			case 'r':  				entryRotated = Int32.Parse (line.Substring (2)) == 1;  				break;  			case 's':  				{  					// sprite  					string[] tokens = line.Split ();  					entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  				}  				break;  			case 'o':  				{  					// origin  					string[] tokens = line.Split ();  					entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  					entryTrimmed = true;  				}  				break;  			case '~':  				{  					names.Add (entryName);  					rotated.Add (entryRotated);  					rects.Add (entryRect);  					if (!entryTrimmed) {  						// The entryRect dimensions will be the wrong way around if the sprite is rotated  						if (entryRotated)  							entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  						else  							entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  					}  					trimRects.Add (entryTrimData);  					anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  					anchors.Add (anchor);  					entryName = "";  					entryTrimmed = false;  					entryRotated = false;  				}  				break;  			}  		}  		break;  	}  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: if (line.Length > 0) {  	char cmd = line [0];  	switch (state) {  	case 0:  		{  			switch (cmd) {  			case 'i':  				break;  			// ignore version field for now  			case 'w':  				textureDimensions.x = Int32.Parse (line.Substring (2));  				break;  			case 'h':  				textureDimensions.y = Int32.Parse (line.Substring (2));  				break;  			// total number of sprites would be ideal to statically allocate  			case '~':  				state++;  				break;  			}  		}  		break;  	case 1:  		{  			switch (cmd) {  			case 'n':  				entryName = line.Substring (2);  				break;  			case 'r':  				entryRotated = Int32.Parse (line.Substring (2)) == 1;  				break;  			case 's':  				{  					// sprite  					string[] tokens = line.Split ();  					entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  				}  				break;  			case 'o':  				{  					// origin  					string[] tokens = line.Split ();  					entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  					entryTrimmed = true;  				}  				break;  			case '~':  				{  					names.Add (entryName);  					rotated.Add (entryRotated);  					rects.Add (entryRect);  					if (!entryTrimmed) {  						// The entryRect dimensions will be the wrong way around if the sprite is rotated  						if (entryRotated)  							entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  						else  							entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  					}  					trimRects.Add (entryTrimData);  					anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  					anchors.Add (anchor);  					entryName = "";  					entryTrimmed = false;  					entryRotated = false;  				}  				break;  			}  		}  		break;  	}  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: if (line.Length > 0) {  	char cmd = line [0];  	switch (state) {  	case 0:  		{  			switch (cmd) {  			case 'i':  				break;  			// ignore version field for now  			case 'w':  				textureDimensions.x = Int32.Parse (line.Substring (2));  				break;  			case 'h':  				textureDimensions.y = Int32.Parse (line.Substring (2));  				break;  			// total number of sprites would be ideal to statically allocate  			case '~':  				state++;  				break;  			}  		}  		break;  	case 1:  		{  			switch (cmd) {  			case 'n':  				entryName = line.Substring (2);  				break;  			case 'r':  				entryRotated = Int32.Parse (line.Substring (2)) == 1;  				break;  			case 's':  				{  					// sprite  					string[] tokens = line.Split ();  					entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  				}  				break;  			case 'o':  				{  					// origin  					string[] tokens = line.Split ();  					entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  					entryTrimmed = true;  				}  				break;  			case '~':  				{  					names.Add (entryName);  					rotated.Add (entryRotated);  					rects.Add (entryRect);  					if (!entryTrimmed) {  						// The entryRect dimensions will be the wrong way around if the sprite is rotated  						if (entryRotated)  							entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  						else  							entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  					}  					trimRects.Add (entryTrimData);  					anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  					anchors.Add (anchor);  					entryName = "";  					entryTrimmed = false;  					entryRotated = false;  				}  				break;  			}  		}  		break;  	}  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: if (line.Length > 0) {  	char cmd = line [0];  	switch (state) {  	case 0:  		{  			switch (cmd) {  			case 'i':  				break;  			// ignore version field for now  			case 'w':  				textureDimensions.x = Int32.Parse (line.Substring (2));  				break;  			case 'h':  				textureDimensions.y = Int32.Parse (line.Substring (2));  				break;  			// total number of sprites would be ideal to statically allocate  			case '~':  				state++;  				break;  			}  		}  		break;  	case 1:  		{  			switch (cmd) {  			case 'n':  				entryName = line.Substring (2);  				break;  			case 'r':  				entryRotated = Int32.Parse (line.Substring (2)) == 1;  				break;  			case 's':  				{  					// sprite  					string[] tokens = line.Split ();  					entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  				}  				break;  			case 'o':  				{  					// origin  					string[] tokens = line.Split ();  					entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  					entryTrimmed = true;  				}  				break;  			case '~':  				{  					names.Add (entryName);  					rotated.Add (entryRotated);  					rects.Add (entryRect);  					if (!entryTrimmed) {  						// The entryRect dimensions will be the wrong way around if the sprite is rotated  						if (entryRotated)  							entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  						else  							entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  					}  					trimRects.Add (entryTrimData);  					anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  					anchors.Add (anchor);  					entryName = "";  					entryTrimmed = false;  					entryRotated = false;  				}  				break;  			}  		}  		break;  	}  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: if (line.Length > 0) {  	char cmd = line [0];  	switch (state) {  	case 0:  		{  			switch (cmd) {  			case 'i':  				break;  			// ignore version field for now  			case 'w':  				textureDimensions.x = Int32.Parse (line.Substring (2));  				break;  			case 'h':  				textureDimensions.y = Int32.Parse (line.Substring (2));  				break;  			// total number of sprites would be ideal to statically allocate  			case '~':  				state++;  				break;  			}  		}  		break;  	case 1:  		{  			switch (cmd) {  			case 'n':  				entryName = line.Substring (2);  				break;  			case 'r':  				entryRotated = Int32.Parse (line.Substring (2)) == 1;  				break;  			case 's':  				{  					// sprite  					string[] tokens = line.Split ();  					entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  				}  				break;  			case 'o':  				{  					// origin  					string[] tokens = line.Split ();  					entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  					entryTrimmed = true;  				}  				break;  			case '~':  				{  					names.Add (entryName);  					rotated.Add (entryRotated);  					rects.Add (entryRect);  					if (!entryTrimmed) {  						// The entryRect dimensions will be the wrong way around if the sprite is rotated  						if (entryRotated)  							entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  						else  							entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  					}  					trimRects.Add (entryTrimData);  					anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  					anchors.Add (anchor);  					entryName = "";  					entryTrimmed = false;  					entryRotated = false;  				}  				break;  			}  		}  		break;  	}  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: if (line.Length > 0) {  	char cmd = line [0];  	switch (state) {  	case 0:  		{  			switch (cmd) {  			case 'i':  				break;  			// ignore version field for now  			case 'w':  				textureDimensions.x = Int32.Parse (line.Substring (2));  				break;  			case 'h':  				textureDimensions.y = Int32.Parse (line.Substring (2));  				break;  			// total number of sprites would be ideal to statically allocate  			case '~':  				state++;  				break;  			}  		}  		break;  	case 1:  		{  			switch (cmd) {  			case 'n':  				entryName = line.Substring (2);  				break;  			case 'r':  				entryRotated = Int32.Parse (line.Substring (2)) == 1;  				break;  			case 's':  				{  					// sprite  					string[] tokens = line.Split ();  					entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  				}  				break;  			case 'o':  				{  					// origin  					string[] tokens = line.Split ();  					entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  					entryTrimmed = true;  				}  				break;  			case '~':  				{  					names.Add (entryName);  					rotated.Add (entryRotated);  					rects.Add (entryRect);  					if (!entryTrimmed) {  						// The entryRect dimensions will be the wrong way around if the sprite is rotated  						if (entryRotated)  							entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  						else  							entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  					}  					trimRects.Add (entryTrimData);  					anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  					anchors.Add (anchor);  					entryName = "";  					entryTrimmed = false;  					entryRotated = false;  				}  				break;  			}  		}  		break;  	}  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: switch (state) {  case 0:  	{  		switch (cmd) {  		case 'i':  			break;  		// ignore version field for now  		case 'w':  			textureDimensions.x = Int32.Parse (line.Substring (2));  			break;  		case 'h':  			textureDimensions.y = Int32.Parse (line.Substring (2));  			break;  		// total number of sprites would be ideal to statically allocate  		case '~':  			state++;  			break;  		}  	}  	break;  case 1:  	{  		switch (cmd) {  		case 'n':  			entryName = line.Substring (2);  			break;  		case 'r':  			entryRotated = Int32.Parse (line.Substring (2)) == 1;  			break;  		case 's':  			{  				// sprite  				string[] tokens = line.Split ();  				entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  			}  			break;  		case 'o':  			{  				// origin  				string[] tokens = line.Split ();  				entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  				entryTrimmed = true;  			}  			break;  		case '~':  			{  				names.Add (entryName);  				rotated.Add (entryRotated);  				rects.Add (entryRect);  				if (!entryTrimmed) {  					// The entryRect dimensions will be the wrong way around if the sprite is rotated  					if (entryRotated)  						entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  					else  						entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  				}  				trimRects.Add (entryTrimData);  				anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  				anchors.Add (anchor);  				entryName = "";  				entryTrimmed = false;  				entryRotated = false;  			}  			break;  		}  	}  	break;  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: switch (state) {  case 0:  	{  		switch (cmd) {  		case 'i':  			break;  		// ignore version field for now  		case 'w':  			textureDimensions.x = Int32.Parse (line.Substring (2));  			break;  		case 'h':  			textureDimensions.y = Int32.Parse (line.Substring (2));  			break;  		// total number of sprites would be ideal to statically allocate  		case '~':  			state++;  			break;  		}  	}  	break;  case 1:  	{  		switch (cmd) {  		case 'n':  			entryName = line.Substring (2);  			break;  		case 'r':  			entryRotated = Int32.Parse (line.Substring (2)) == 1;  			break;  		case 's':  			{  				// sprite  				string[] tokens = line.Split ();  				entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  			}  			break;  		case 'o':  			{  				// origin  				string[] tokens = line.Split ();  				entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  				entryTrimmed = true;  			}  			break;  		case '~':  			{  				names.Add (entryName);  				rotated.Add (entryRotated);  				rects.Add (entryRect);  				if (!entryTrimmed) {  					// The entryRect dimensions will be the wrong way around if the sprite is rotated  					if (entryRotated)  						entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  					else  						entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  				}  				trimRects.Add (entryTrimData);  				anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  				anchors.Add (anchor);  				entryName = "";  				entryTrimmed = false;  				entryRotated = false;  			}  			break;  		}  	}  	break;  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: switch (state) {  case 0:  	{  		switch (cmd) {  		case 'i':  			break;  		// ignore version field for now  		case 'w':  			textureDimensions.x = Int32.Parse (line.Substring (2));  			break;  		case 'h':  			textureDimensions.y = Int32.Parse (line.Substring (2));  			break;  		// total number of sprites would be ideal to statically allocate  		case '~':  			state++;  			break;  		}  	}  	break;  case 1:  	{  		switch (cmd) {  		case 'n':  			entryName = line.Substring (2);  			break;  		case 'r':  			entryRotated = Int32.Parse (line.Substring (2)) == 1;  			break;  		case 's':  			{  				// sprite  				string[] tokens = line.Split ();  				entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  			}  			break;  		case 'o':  			{  				// origin  				string[] tokens = line.Split ();  				entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  				entryTrimmed = true;  			}  			break;  		case '~':  			{  				names.Add (entryName);  				rotated.Add (entryRotated);  				rects.Add (entryRect);  				if (!entryTrimmed) {  					// The entryRect dimensions will be the wrong way around if the sprite is rotated  					if (entryRotated)  						entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  					else  						entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  				}  				trimRects.Add (entryTrimData);  				anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  				anchors.Add (anchor);  				entryName = "";  				entryTrimmed = false;  				entryRotated = false;  			}  			break;  		}  	}  	break;  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: switch (state) {  case 0:  	{  		switch (cmd) {  		case 'i':  			break;  		// ignore version field for now  		case 'w':  			textureDimensions.x = Int32.Parse (line.Substring (2));  			break;  		case 'h':  			textureDimensions.y = Int32.Parse (line.Substring (2));  			break;  		// total number of sprites would be ideal to statically allocate  		case '~':  			state++;  			break;  		}  	}  	break;  case 1:  	{  		switch (cmd) {  		case 'n':  			entryName = line.Substring (2);  			break;  		case 'r':  			entryRotated = Int32.Parse (line.Substring (2)) == 1;  			break;  		case 's':  			{  				// sprite  				string[] tokens = line.Split ();  				entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  			}  			break;  		case 'o':  			{  				// origin  				string[] tokens = line.Split ();  				entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  				entryTrimmed = true;  			}  			break;  		case '~':  			{  				names.Add (entryName);  				rotated.Add (entryRotated);  				rects.Add (entryRect);  				if (!entryTrimmed) {  					// The entryRect dimensions will be the wrong way around if the sprite is rotated  					if (entryRotated)  						entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  					else  						entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  				}  				trimRects.Add (entryTrimData);  				anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  				anchors.Add (anchor);  				entryName = "";  				entryTrimmed = false;  				entryRotated = false;  			}  			break;  		}  	}  	break;  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: switch (state) {  case 0:  	{  		switch (cmd) {  		case 'i':  			break;  		// ignore version field for now  		case 'w':  			textureDimensions.x = Int32.Parse (line.Substring (2));  			break;  		case 'h':  			textureDimensions.y = Int32.Parse (line.Substring (2));  			break;  		// total number of sprites would be ideal to statically allocate  		case '~':  			state++;  			break;  		}  	}  	break;  case 1:  	{  		switch (cmd) {  		case 'n':  			entryName = line.Substring (2);  			break;  		case 'r':  			entryRotated = Int32.Parse (line.Substring (2)) == 1;  			break;  		case 's':  			{  				// sprite  				string[] tokens = line.Split ();  				entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  			}  			break;  		case 'o':  			{  				// origin  				string[] tokens = line.Split ();  				entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  				entryTrimmed = true;  			}  			break;  		case '~':  			{  				names.Add (entryName);  				rotated.Add (entryRotated);  				rects.Add (entryRect);  				if (!entryTrimmed) {  					// The entryRect dimensions will be the wrong way around if the sprite is rotated  					if (entryRotated)  						entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  					else  						entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  				}  				trimRects.Add (entryTrimData);  				anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  				anchors.Add (anchor);  				entryName = "";  				entryTrimmed = false;  				entryRotated = false;  			}  			break;  		}  	}  	break;  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: switch (state) {  case 0:  	{  		switch (cmd) {  		case 'i':  			break;  		// ignore version field for now  		case 'w':  			textureDimensions.x = Int32.Parse (line.Substring (2));  			break;  		case 'h':  			textureDimensions.y = Int32.Parse (line.Substring (2));  			break;  		// total number of sprites would be ideal to statically allocate  		case '~':  			state++;  			break;  		}  	}  	break;  case 1:  	{  		switch (cmd) {  		case 'n':  			entryName = line.Substring (2);  			break;  		case 'r':  			entryRotated = Int32.Parse (line.Substring (2)) == 1;  			break;  		case 's':  			{  				// sprite  				string[] tokens = line.Split ();  				entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  			}  			break;  		case 'o':  			{  				// origin  				string[] tokens = line.Split ();  				entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  				entryTrimmed = true;  			}  			break;  		case '~':  			{  				names.Add (entryName);  				rotated.Add (entryRotated);  				rects.Add (entryRect);  				if (!entryTrimmed) {  					// The entryRect dimensions will be the wrong way around if the sprite is rotated  					if (entryRotated)  						entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  					else  						entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  				}  				trimRects.Add (entryTrimData);  				anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  				anchors.Add (anchor);  				entryName = "";  				entryTrimmed = false;  				entryRotated = false;  			}  			break;  		}  	}  	break;  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: switch (state) {  case 0:  	{  		switch (cmd) {  		case 'i':  			break;  		// ignore version field for now  		case 'w':  			textureDimensions.x = Int32.Parse (line.Substring (2));  			break;  		case 'h':  			textureDimensions.y = Int32.Parse (line.Substring (2));  			break;  		// total number of sprites would be ideal to statically allocate  		case '~':  			state++;  			break;  		}  	}  	break;  case 1:  	{  		switch (cmd) {  		case 'n':  			entryName = line.Substring (2);  			break;  		case 'r':  			entryRotated = Int32.Parse (line.Substring (2)) == 1;  			break;  		case 's':  			{  				// sprite  				string[] tokens = line.Split ();  				entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  			}  			break;  		case 'o':  			{  				// origin  				string[] tokens = line.Split ();  				entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  				entryTrimmed = true;  			}  			break;  		case '~':  			{  				names.Add (entryName);  				rotated.Add (entryRotated);  				rects.Add (entryRect);  				if (!entryTrimmed) {  					// The entryRect dimensions will be the wrong way around if the sprite is rotated  					if (entryRotated)  						entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  					else  						entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  				}  				trimRects.Add (entryTrimData);  				anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  				anchors.Add (anchor);  				entryName = "";  				entryTrimmed = false;  				entryRotated = false;  			}  			break;  		}  	}  	break;  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: switch (state) {  case 0:  	{  		switch (cmd) {  		case 'i':  			break;  		// ignore version field for now  		case 'w':  			textureDimensions.x = Int32.Parse (line.Substring (2));  			break;  		case 'h':  			textureDimensions.y = Int32.Parse (line.Substring (2));  			break;  		// total number of sprites would be ideal to statically allocate  		case '~':  			state++;  			break;  		}  	}  	break;  case 1:  	{  		switch (cmd) {  		case 'n':  			entryName = line.Substring (2);  			break;  		case 'r':  			entryRotated = Int32.Parse (line.Substring (2)) == 1;  			break;  		case 's':  			{  				// sprite  				string[] tokens = line.Split ();  				entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  			}  			break;  		case 'o':  			{  				// origin  				string[] tokens = line.Split ();  				entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  				entryTrimmed = true;  			}  			break;  		case '~':  			{  				names.Add (entryName);  				rotated.Add (entryRotated);  				rects.Add (entryRect);  				if (!entryTrimmed) {  					// The entryRect dimensions will be the wrong way around if the sprite is rotated  					if (entryRotated)  						entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  					else  						entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  				}  				trimRects.Add (entryTrimData);  				anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  				anchors.Add (anchor);  				entryName = "";  				entryTrimmed = false;  				entryRotated = false;  			}  			break;  		}  	}  	break;  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: switch (state) {  case 0:  	{  		switch (cmd) {  		case 'i':  			break;  		// ignore version field for now  		case 'w':  			textureDimensions.x = Int32.Parse (line.Substring (2));  			break;  		case 'h':  			textureDimensions.y = Int32.Parse (line.Substring (2));  			break;  		// total number of sprites would be ideal to statically allocate  		case '~':  			state++;  			break;  		}  	}  	break;  case 1:  	{  		switch (cmd) {  		case 'n':  			entryName = line.Substring (2);  			break;  		case 'r':  			entryRotated = Int32.Parse (line.Substring (2)) == 1;  			break;  		case 's':  			{  				// sprite  				string[] tokens = line.Split ();  				entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  			}  			break;  		case 'o':  			{  				// origin  				string[] tokens = line.Split ();  				entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  				entryTrimmed = true;  			}  			break;  		case '~':  			{  				names.Add (entryName);  				rotated.Add (entryRotated);  				rects.Add (entryRect);  				if (!entryTrimmed) {  					// The entryRect dimensions will be the wrong way around if the sprite is rotated  					if (entryRotated)  						entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  					else  						entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  				}  				trimRects.Add (entryTrimData);  				anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  				anchors.Add (anchor);  				entryName = "";  				entryTrimmed = false;  				entryRotated = false;  			}  			break;  		}  	}  	break;  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: switch (state) {  case 0:  	{  		switch (cmd) {  		case 'i':  			break;  		// ignore version field for now  		case 'w':  			textureDimensions.x = Int32.Parse (line.Substring (2));  			break;  		case 'h':  			textureDimensions.y = Int32.Parse (line.Substring (2));  			break;  		// total number of sprites would be ideal to statically allocate  		case '~':  			state++;  			break;  		}  	}  	break;  case 1:  	{  		switch (cmd) {  		case 'n':  			entryName = line.Substring (2);  			break;  		case 'r':  			entryRotated = Int32.Parse (line.Substring (2)) == 1;  			break;  		case 's':  			{  				// sprite  				string[] tokens = line.Split ();  				entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  			}  			break;  		case 'o':  			{  				// origin  				string[] tokens = line.Split ();  				entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  				entryTrimmed = true;  			}  			break;  		case '~':  			{  				names.Add (entryName);  				rotated.Add (entryRotated);  				rects.Add (entryRect);  				if (!entryTrimmed) {  					// The entryRect dimensions will be the wrong way around if the sprite is rotated  					if (entryRotated)  						entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  					else  						entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  				}  				trimRects.Add (entryTrimData);  				anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  				anchors.Add (anchor);  				entryName = "";  				entryTrimmed = false;  				entryRotated = false;  			}  			break;  		}  	}  	break;  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: switch (state) {  case 0:  	{  		switch (cmd) {  		case 'i':  			break;  		// ignore version field for now  		case 'w':  			textureDimensions.x = Int32.Parse (line.Substring (2));  			break;  		case 'h':  			textureDimensions.y = Int32.Parse (line.Substring (2));  			break;  		// total number of sprites would be ideal to statically allocate  		case '~':  			state++;  			break;  		}  	}  	break;  case 1:  	{  		switch (cmd) {  		case 'n':  			entryName = line.Substring (2);  			break;  		case 'r':  			entryRotated = Int32.Parse (line.Substring (2)) == 1;  			break;  		case 's':  			{  				// sprite  				string[] tokens = line.Split ();  				entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  			}  			break;  		case 'o':  			{  				// origin  				string[] tokens = line.Split ();  				entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  				entryTrimmed = true;  			}  			break;  		case '~':  			{  				names.Add (entryName);  				rotated.Add (entryRotated);  				rects.Add (entryRect);  				if (!entryTrimmed) {  					// The entryRect dimensions will be the wrong way around if the sprite is rotated  					if (entryRotated)  						entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  					else  						entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  				}  				trimRects.Add (entryTrimData);  				anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  				anchors.Add (anchor);  				entryName = "";  				entryTrimmed = false;  				entryRotated = false;  			}  			break;  		}  	}  	break;  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: switch (state) {  case 0:  	{  		switch (cmd) {  		case 'i':  			break;  		// ignore version field for now  		case 'w':  			textureDimensions.x = Int32.Parse (line.Substring (2));  			break;  		case 'h':  			textureDimensions.y = Int32.Parse (line.Substring (2));  			break;  		// total number of sprites would be ideal to statically allocate  		case '~':  			state++;  			break;  		}  	}  	break;  case 1:  	{  		switch (cmd) {  		case 'n':  			entryName = line.Substring (2);  			break;  		case 'r':  			entryRotated = Int32.Parse (line.Substring (2)) == 1;  			break;  		case 's':  			{  				// sprite  				string[] tokens = line.Split ();  				entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  			}  			break;  		case 'o':  			{  				// origin  				string[] tokens = line.Split ();  				entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  				entryTrimmed = true;  			}  			break;  		case '~':  			{  				names.Add (entryName);  				rotated.Add (entryRotated);  				rects.Add (entryRect);  				if (!entryTrimmed) {  					// The entryRect dimensions will be the wrong way around if the sprite is rotated  					if (entryRotated)  						entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  					else  						entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  				}  				trimRects.Add (entryTrimData);  				anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  				anchors.Add (anchor);  				entryName = "";  				entryTrimmed = false;  				entryRotated = false;  			}  			break;  		}  	}  	break;  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: switch (cmd) {  case 'i':  	break;  // ignore version field for now  case 'w':  	textureDimensions.x = Int32.Parse (line.Substring (2));  	break;  case 'h':  	textureDimensions.y = Int32.Parse (line.Substring (2));  	break;  // total number of sprites would be ideal to statically allocate  case '~':  	state++;  	break;  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: switch (cmd) {  case 'i':  	break;  // ignore version field for now  case 'w':  	textureDimensions.x = Int32.Parse (line.Substring (2));  	break;  case 'h':  	textureDimensions.y = Int32.Parse (line.Substring (2));  	break;  // total number of sprites would be ideal to statically allocate  case '~':  	state++;  	break;  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: textureDimensions.x = Int32.Parse (line.Substring (2));  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: textureDimensions.y = Int32.Parse (line.Substring (2));  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: switch (cmd) {  case 'n':  	entryName = line.Substring (2);  	break;  case 'r':  	entryRotated = Int32.Parse (line.Substring (2)) == 1;  	break;  case 's':  	{  		// sprite  		string[] tokens = line.Split ();  		entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  	}  	break;  case 'o':  	{  		// origin  		string[] tokens = line.Split ();  		entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  		entryTrimmed = true;  	}  	break;  case '~':  	{  		names.Add (entryName);  		rotated.Add (entryRotated);  		rects.Add (entryRect);  		if (!entryTrimmed) {  			// The entryRect dimensions will be the wrong way around if the sprite is rotated  			if (entryRotated)  				entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  			else  				entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  		}  		trimRects.Add (entryTrimData);  		anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  		anchors.Add (anchor);  		entryName = "";  		entryTrimmed = false;  		entryRotated = false;  	}  	break;  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: switch (cmd) {  case 'n':  	entryName = line.Substring (2);  	break;  case 'r':  	entryRotated = Int32.Parse (line.Substring (2)) == 1;  	break;  case 's':  	{  		// sprite  		string[] tokens = line.Split ();  		entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  	}  	break;  case 'o':  	{  		// origin  		string[] tokens = line.Split ();  		entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  		entryTrimmed = true;  	}  	break;  case '~':  	{  		names.Add (entryName);  		rotated.Add (entryRotated);  		rects.Add (entryRect);  		if (!entryTrimmed) {  			// The entryRect dimensions will be the wrong way around if the sprite is rotated  			if (entryRotated)  				entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  			else  				entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  		}  		trimRects.Add (entryTrimData);  		anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  		anchors.Add (anchor);  		entryName = "";  		entryTrimmed = false;  		entryRotated = false;  	}  	break;  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: switch (cmd) {  case 'n':  	entryName = line.Substring (2);  	break;  case 'r':  	entryRotated = Int32.Parse (line.Substring (2)) == 1;  	break;  case 's':  	{  		// sprite  		string[] tokens = line.Split ();  		entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  	}  	break;  case 'o':  	{  		// origin  		string[] tokens = line.Split ();  		entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  		entryTrimmed = true;  	}  	break;  case '~':  	{  		names.Add (entryName);  		rotated.Add (entryRotated);  		rects.Add (entryRect);  		if (!entryTrimmed) {  			// The entryRect dimensions will be the wrong way around if the sprite is rotated  			if (entryRotated)  				entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  			else  				entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  		}  		trimRects.Add (entryTrimData);  		anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  		anchors.Add (anchor);  		entryName = "";  		entryTrimmed = false;  		entryRotated = false;  	}  	break;  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: switch (cmd) {  case 'n':  	entryName = line.Substring (2);  	break;  case 'r':  	entryRotated = Int32.Parse (line.Substring (2)) == 1;  	break;  case 's':  	{  		// sprite  		string[] tokens = line.Split ();  		entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  	}  	break;  case 'o':  	{  		// origin  		string[] tokens = line.Split ();  		entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  		entryTrimmed = true;  	}  	break;  case '~':  	{  		names.Add (entryName);  		rotated.Add (entryRotated);  		rects.Add (entryRect);  		if (!entryTrimmed) {  			// The entryRect dimensions will be the wrong way around if the sprite is rotated  			if (entryRotated)  				entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  			else  				entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  		}  		trimRects.Add (entryTrimData);  		anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  		anchors.Add (anchor);  		entryName = "";  		entryTrimmed = false;  		entryRotated = false;  	}  	break;  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: switch (cmd) {  case 'n':  	entryName = line.Substring (2);  	break;  case 'r':  	entryRotated = Int32.Parse (line.Substring (2)) == 1;  	break;  case 's':  	{  		// sprite  		string[] tokens = line.Split ();  		entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  	}  	break;  case 'o':  	{  		// origin  		string[] tokens = line.Split ();  		entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  		entryTrimmed = true;  	}  	break;  case '~':  	{  		names.Add (entryName);  		rotated.Add (entryRotated);  		rects.Add (entryRect);  		if (!entryTrimmed) {  			// The entryRect dimensions will be the wrong way around if the sprite is rotated  			if (entryRotated)  				entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  			else  				entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  		}  		trimRects.Add (entryTrimData);  		anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  		anchors.Add (anchor);  		entryName = "";  		entryTrimmed = false;  		entryRotated = false;  	}  	break;  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: switch (cmd) {  case 'n':  	entryName = line.Substring (2);  	break;  case 'r':  	entryRotated = Int32.Parse (line.Substring (2)) == 1;  	break;  case 's':  	{  		// sprite  		string[] tokens = line.Split ();  		entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  	}  	break;  case 'o':  	{  		// origin  		string[] tokens = line.Split ();  		entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  		entryTrimmed = true;  	}  	break;  case '~':  	{  		names.Add (entryName);  		rotated.Add (entryRotated);  		rects.Add (entryRect);  		if (!entryTrimmed) {  			// The entryRect dimensions will be the wrong way around if the sprite is rotated  			if (entryRotated)  				entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  			else  				entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  		}  		trimRects.Add (entryTrimData);  		anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  		anchors.Add (anchor);  		entryName = "";  		entryTrimmed = false;  		entryRotated = false;  	}  	break;  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: switch (cmd) {  case 'n':  	entryName = line.Substring (2);  	break;  case 'r':  	entryRotated = Int32.Parse (line.Substring (2)) == 1;  	break;  case 's':  	{  		// sprite  		string[] tokens = line.Split ();  		entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  	}  	break;  case 'o':  	{  		// origin  		string[] tokens = line.Split ();  		entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  		entryTrimmed = true;  	}  	break;  case '~':  	{  		names.Add (entryName);  		rotated.Add (entryRotated);  		rects.Add (entryRect);  		if (!entryTrimmed) {  			// The entryRect dimensions will be the wrong way around if the sprite is rotated  			if (entryRotated)  				entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  			else  				entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  		}  		trimRects.Add (entryTrimData);  		anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  		anchors.Add (anchor);  		entryName = "";  		entryTrimmed = false;  		entryRotated = false;  	}  	break;  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: switch (cmd) {  case 'n':  	entryName = line.Substring (2);  	break;  case 'r':  	entryRotated = Int32.Parse (line.Substring (2)) == 1;  	break;  case 's':  	{  		// sprite  		string[] tokens = line.Split ();  		entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  	}  	break;  case 'o':  	{  		// origin  		string[] tokens = line.Split ();  		entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  		entryTrimmed = true;  	}  	break;  case '~':  	{  		names.Add (entryName);  		rotated.Add (entryRotated);  		rects.Add (entryRect);  		if (!entryTrimmed) {  			// The entryRect dimensions will be the wrong way around if the sprite is rotated  			if (entryRotated)  				entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  			else  				entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  		}  		trimRects.Add (entryTrimData);  		anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  		anchors.Add (anchor);  		entryName = "";  		entryTrimmed = false;  		entryRotated = false;  	}  	break;  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: switch (cmd) {  case 'n':  	entryName = line.Substring (2);  	break;  case 'r':  	entryRotated = Int32.Parse (line.Substring (2)) == 1;  	break;  case 's':  	{  		// sprite  		string[] tokens = line.Split ();  		entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  	}  	break;  case 'o':  	{  		// origin  		string[] tokens = line.Split ();  		entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  		entryTrimmed = true;  	}  	break;  case '~':  	{  		names.Add (entryName);  		rotated.Add (entryRotated);  		rects.Add (entryRect);  		if (!entryTrimmed) {  			// The entryRect dimensions will be the wrong way around if the sprite is rotated  			if (entryRotated)  				entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  			else  				entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  		}  		trimRects.Add (entryTrimData);  		anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  		anchors.Add (anchor);  		entryName = "";  		entryTrimmed = false;  		entryRotated = false;  	}  	break;  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: switch (cmd) {  case 'n':  	entryName = line.Substring (2);  	break;  case 'r':  	entryRotated = Int32.Parse (line.Substring (2)) == 1;  	break;  case 's':  	{  		// sprite  		string[] tokens = line.Split ();  		entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  	}  	break;  case 'o':  	{  		// origin  		string[] tokens = line.Split ();  		entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  		entryTrimmed = true;  	}  	break;  case '~':  	{  		names.Add (entryName);  		rotated.Add (entryRotated);  		rects.Add (entryRect);  		if (!entryTrimmed) {  			// The entryRect dimensions will be the wrong way around if the sprite is rotated  			if (entryRotated)  				entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  			else  				entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  		}  		trimRects.Add (entryTrimData);  		anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  		anchors.Add (anchor);  		entryName = "";  		entryTrimmed = false;  		entryRotated = false;  	}  	break;  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: entryName = line.Substring (2);  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: entryRotated = Int32.Parse (line.Substring (2)) == 1;  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildForChunk,The following statement contains a magic number: if (localMeshIndices.Length > 6) {  	// Remove duplicate verts  	localMeshVertices = WeldVertices (localMeshVertices' ref localMeshIndices);  	// Remove duplicate and back-to-back faces  	// Removes inside faces  	localMeshIndices = RemoveDuplicateFaces (localMeshIndices);  	// Merge coplanar faces  	// Optimize (remove unused vertices' reindex)  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int y = 0; y < tileMap.partitionSizeY; ++y) {  	float xOffset = ((baseY + y) & 1) * xOffsetMult;  	for (int x = 0; x < tileMap.partitionSizeX; ++x) {  		int spriteId = chunkData [y * tileMap.partitionSizeX + x];  		int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  		Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  		if (spriteIdx < 0 || spriteIdx >= spriteCount)  			continue;  		if (tilePrefabs [spriteIdx])  			continue;  		bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  		bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  		bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  		bool reverseIndices = false;  		if (flipH)  			reverseIndices = !reverseIndices;  		if (flipV)  			reverseIndices = !reverseIndices;  		var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  		int baseVertexIndex = vertexList.Count;  		if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  			Vector3 origin = spriteData.colliderVertices [0];  			Vector3 extents = spriteData.colliderVertices [1];  			Vector3 min = origin - extents;  			Vector3 max = origin + extents;  			Vector3[] pos = new Vector3[8];  			pos [0] = new Vector3 (min.x' min.y' min.z);  			pos [1] = new Vector3 (min.x' min.y' max.z);  			pos [2] = new Vector3 (max.x' min.y' min.z);  			pos [3] = new Vector3 (max.x' min.y' max.z);  			pos [4] = new Vector3 (min.x' max.y' min.z);  			pos [5] = new Vector3 (min.x' max.y' max.z);  			pos [6] = new Vector3 (max.x' max.y' min.z);  			pos [7] = new Vector3 (max.x' max.y' max.z);  			for (int i = 0; i < 8; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  			int[] indicesFwd =  {  				2'  				1'  				0'  				3'  				1'  				2'  				4'  				5'  				6'  				6'  				5'  				7'  				6'  				7'  				3'  				6'  				3'  				2'  				1'  				5'  				4'  				0'  				1'  				4  			};  			var srcIndices = indicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  		else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  			for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			var srcIndices = spriteData.colliderIndicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int y = 0; y < tileMap.partitionSizeY; ++y) {  	float xOffset = ((baseY + y) & 1) * xOffsetMult;  	for (int x = 0; x < tileMap.partitionSizeX; ++x) {  		int spriteId = chunkData [y * tileMap.partitionSizeX + x];  		int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  		Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  		if (spriteIdx < 0 || spriteIdx >= spriteCount)  			continue;  		if (tilePrefabs [spriteIdx])  			continue;  		bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  		bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  		bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  		bool reverseIndices = false;  		if (flipH)  			reverseIndices = !reverseIndices;  		if (flipV)  			reverseIndices = !reverseIndices;  		var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  		int baseVertexIndex = vertexList.Count;  		if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  			Vector3 origin = spriteData.colliderVertices [0];  			Vector3 extents = spriteData.colliderVertices [1];  			Vector3 min = origin - extents;  			Vector3 max = origin + extents;  			Vector3[] pos = new Vector3[8];  			pos [0] = new Vector3 (min.x' min.y' min.z);  			pos [1] = new Vector3 (min.x' min.y' max.z);  			pos [2] = new Vector3 (max.x' min.y' min.z);  			pos [3] = new Vector3 (max.x' min.y' max.z);  			pos [4] = new Vector3 (min.x' max.y' min.z);  			pos [5] = new Vector3 (min.x' max.y' max.z);  			pos [6] = new Vector3 (max.x' max.y' min.z);  			pos [7] = new Vector3 (max.x' max.y' max.z);  			for (int i = 0; i < 8; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  			int[] indicesFwd =  {  				2'  				1'  				0'  				3'  				1'  				2'  				4'  				5'  				6'  				6'  				5'  				7'  				6'  				7'  				3'  				6'  				3'  				2'  				1'  				5'  				4'  				0'  				1'  				4  			};  			var srcIndices = indicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  		else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  			for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			var srcIndices = spriteData.colliderIndicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int y = 0; y < tileMap.partitionSizeY; ++y) {  	float xOffset = ((baseY + y) & 1) * xOffsetMult;  	for (int x = 0; x < tileMap.partitionSizeX; ++x) {  		int spriteId = chunkData [y * tileMap.partitionSizeX + x];  		int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  		Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  		if (spriteIdx < 0 || spriteIdx >= spriteCount)  			continue;  		if (tilePrefabs [spriteIdx])  			continue;  		bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  		bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  		bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  		bool reverseIndices = false;  		if (flipH)  			reverseIndices = !reverseIndices;  		if (flipV)  			reverseIndices = !reverseIndices;  		var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  		int baseVertexIndex = vertexList.Count;  		if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  			Vector3 origin = spriteData.colliderVertices [0];  			Vector3 extents = spriteData.colliderVertices [1];  			Vector3 min = origin - extents;  			Vector3 max = origin + extents;  			Vector3[] pos = new Vector3[8];  			pos [0] = new Vector3 (min.x' min.y' min.z);  			pos [1] = new Vector3 (min.x' min.y' max.z);  			pos [2] = new Vector3 (max.x' min.y' min.z);  			pos [3] = new Vector3 (max.x' min.y' max.z);  			pos [4] = new Vector3 (min.x' max.y' min.z);  			pos [5] = new Vector3 (min.x' max.y' max.z);  			pos [6] = new Vector3 (max.x' max.y' min.z);  			pos [7] = new Vector3 (max.x' max.y' max.z);  			for (int i = 0; i < 8; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  			int[] indicesFwd =  {  				2'  				1'  				0'  				3'  				1'  				2'  				4'  				5'  				6'  				6'  				5'  				7'  				6'  				7'  				3'  				6'  				3'  				2'  				1'  				5'  				4'  				0'  				1'  				4  			};  			var srcIndices = indicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  		else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  			for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			var srcIndices = spriteData.colliderIndicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int y = 0; y < tileMap.partitionSizeY; ++y) {  	float xOffset = ((baseY + y) & 1) * xOffsetMult;  	for (int x = 0; x < tileMap.partitionSizeX; ++x) {  		int spriteId = chunkData [y * tileMap.partitionSizeX + x];  		int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  		Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  		if (spriteIdx < 0 || spriteIdx >= spriteCount)  			continue;  		if (tilePrefabs [spriteIdx])  			continue;  		bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  		bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  		bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  		bool reverseIndices = false;  		if (flipH)  			reverseIndices = !reverseIndices;  		if (flipV)  			reverseIndices = !reverseIndices;  		var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  		int baseVertexIndex = vertexList.Count;  		if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  			Vector3 origin = spriteData.colliderVertices [0];  			Vector3 extents = spriteData.colliderVertices [1];  			Vector3 min = origin - extents;  			Vector3 max = origin + extents;  			Vector3[] pos = new Vector3[8];  			pos [0] = new Vector3 (min.x' min.y' min.z);  			pos [1] = new Vector3 (min.x' min.y' max.z);  			pos [2] = new Vector3 (max.x' min.y' min.z);  			pos [3] = new Vector3 (max.x' min.y' max.z);  			pos [4] = new Vector3 (min.x' max.y' min.z);  			pos [5] = new Vector3 (min.x' max.y' max.z);  			pos [6] = new Vector3 (max.x' max.y' min.z);  			pos [7] = new Vector3 (max.x' max.y' max.z);  			for (int i = 0; i < 8; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  			int[] indicesFwd =  {  				2'  				1'  				0'  				3'  				1'  				2'  				4'  				5'  				6'  				6'  				5'  				7'  				6'  				7'  				3'  				6'  				3'  				2'  				1'  				5'  				4'  				0'  				1'  				4  			};  			var srcIndices = indicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  		else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  			for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			var srcIndices = spriteData.colliderIndicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int y = 0; y < tileMap.partitionSizeY; ++y) {  	float xOffset = ((baseY + y) & 1) * xOffsetMult;  	for (int x = 0; x < tileMap.partitionSizeX; ++x) {  		int spriteId = chunkData [y * tileMap.partitionSizeX + x];  		int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  		Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  		if (spriteIdx < 0 || spriteIdx >= spriteCount)  			continue;  		if (tilePrefabs [spriteIdx])  			continue;  		bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  		bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  		bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  		bool reverseIndices = false;  		if (flipH)  			reverseIndices = !reverseIndices;  		if (flipV)  			reverseIndices = !reverseIndices;  		var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  		int baseVertexIndex = vertexList.Count;  		if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  			Vector3 origin = spriteData.colliderVertices [0];  			Vector3 extents = spriteData.colliderVertices [1];  			Vector3 min = origin - extents;  			Vector3 max = origin + extents;  			Vector3[] pos = new Vector3[8];  			pos [0] = new Vector3 (min.x' min.y' min.z);  			pos [1] = new Vector3 (min.x' min.y' max.z);  			pos [2] = new Vector3 (max.x' min.y' min.z);  			pos [3] = new Vector3 (max.x' min.y' max.z);  			pos [4] = new Vector3 (min.x' max.y' min.z);  			pos [5] = new Vector3 (min.x' max.y' max.z);  			pos [6] = new Vector3 (max.x' max.y' min.z);  			pos [7] = new Vector3 (max.x' max.y' max.z);  			for (int i = 0; i < 8; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  			int[] indicesFwd =  {  				2'  				1'  				0'  				3'  				1'  				2'  				4'  				5'  				6'  				6'  				5'  				7'  				6'  				7'  				3'  				6'  				3'  				2'  				1'  				5'  				4'  				0'  				1'  				4  			};  			var srcIndices = indicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  		else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  			for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			var srcIndices = spriteData.colliderIndicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int y = 0; y < tileMap.partitionSizeY; ++y) {  	float xOffset = ((baseY + y) & 1) * xOffsetMult;  	for (int x = 0; x < tileMap.partitionSizeX; ++x) {  		int spriteId = chunkData [y * tileMap.partitionSizeX + x];  		int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  		Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  		if (spriteIdx < 0 || spriteIdx >= spriteCount)  			continue;  		if (tilePrefabs [spriteIdx])  			continue;  		bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  		bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  		bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  		bool reverseIndices = false;  		if (flipH)  			reverseIndices = !reverseIndices;  		if (flipV)  			reverseIndices = !reverseIndices;  		var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  		int baseVertexIndex = vertexList.Count;  		if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  			Vector3 origin = spriteData.colliderVertices [0];  			Vector3 extents = spriteData.colliderVertices [1];  			Vector3 min = origin - extents;  			Vector3 max = origin + extents;  			Vector3[] pos = new Vector3[8];  			pos [0] = new Vector3 (min.x' min.y' min.z);  			pos [1] = new Vector3 (min.x' min.y' max.z);  			pos [2] = new Vector3 (max.x' min.y' min.z);  			pos [3] = new Vector3 (max.x' min.y' max.z);  			pos [4] = new Vector3 (min.x' max.y' min.z);  			pos [5] = new Vector3 (min.x' max.y' max.z);  			pos [6] = new Vector3 (max.x' max.y' min.z);  			pos [7] = new Vector3 (max.x' max.y' max.z);  			for (int i = 0; i < 8; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  			int[] indicesFwd =  {  				2'  				1'  				0'  				3'  				1'  				2'  				4'  				5'  				6'  				6'  				5'  				7'  				6'  				7'  				3'  				6'  				3'  				2'  				1'  				5'  				4'  				0'  				1'  				4  			};  			var srcIndices = indicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  		else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  			for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			var srcIndices = spriteData.colliderIndicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int y = 0; y < tileMap.partitionSizeY; ++y) {  	float xOffset = ((baseY + y) & 1) * xOffsetMult;  	for (int x = 0; x < tileMap.partitionSizeX; ++x) {  		int spriteId = chunkData [y * tileMap.partitionSizeX + x];  		int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  		Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  		if (spriteIdx < 0 || spriteIdx >= spriteCount)  			continue;  		if (tilePrefabs [spriteIdx])  			continue;  		bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  		bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  		bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  		bool reverseIndices = false;  		if (flipH)  			reverseIndices = !reverseIndices;  		if (flipV)  			reverseIndices = !reverseIndices;  		var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  		int baseVertexIndex = vertexList.Count;  		if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  			Vector3 origin = spriteData.colliderVertices [0];  			Vector3 extents = spriteData.colliderVertices [1];  			Vector3 min = origin - extents;  			Vector3 max = origin + extents;  			Vector3[] pos = new Vector3[8];  			pos [0] = new Vector3 (min.x' min.y' min.z);  			pos [1] = new Vector3 (min.x' min.y' max.z);  			pos [2] = new Vector3 (max.x' min.y' min.z);  			pos [3] = new Vector3 (max.x' min.y' max.z);  			pos [4] = new Vector3 (min.x' max.y' min.z);  			pos [5] = new Vector3 (min.x' max.y' max.z);  			pos [6] = new Vector3 (max.x' max.y' min.z);  			pos [7] = new Vector3 (max.x' max.y' max.z);  			for (int i = 0; i < 8; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  			int[] indicesFwd =  {  				2'  				1'  				0'  				3'  				1'  				2'  				4'  				5'  				6'  				6'  				5'  				7'  				6'  				7'  				3'  				6'  				3'  				2'  				1'  				5'  				4'  				0'  				1'  				4  			};  			var srcIndices = indicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  		else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  			for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			var srcIndices = spriteData.colliderIndicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int y = 0; y < tileMap.partitionSizeY; ++y) {  	float xOffset = ((baseY + y) & 1) * xOffsetMult;  	for (int x = 0; x < tileMap.partitionSizeX; ++x) {  		int spriteId = chunkData [y * tileMap.partitionSizeX + x];  		int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  		Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  		if (spriteIdx < 0 || spriteIdx >= spriteCount)  			continue;  		if (tilePrefabs [spriteIdx])  			continue;  		bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  		bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  		bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  		bool reverseIndices = false;  		if (flipH)  			reverseIndices = !reverseIndices;  		if (flipV)  			reverseIndices = !reverseIndices;  		var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  		int baseVertexIndex = vertexList.Count;  		if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  			Vector3 origin = spriteData.colliderVertices [0];  			Vector3 extents = spriteData.colliderVertices [1];  			Vector3 min = origin - extents;  			Vector3 max = origin + extents;  			Vector3[] pos = new Vector3[8];  			pos [0] = new Vector3 (min.x' min.y' min.z);  			pos [1] = new Vector3 (min.x' min.y' max.z);  			pos [2] = new Vector3 (max.x' min.y' min.z);  			pos [3] = new Vector3 (max.x' min.y' max.z);  			pos [4] = new Vector3 (min.x' max.y' min.z);  			pos [5] = new Vector3 (min.x' max.y' max.z);  			pos [6] = new Vector3 (max.x' max.y' min.z);  			pos [7] = new Vector3 (max.x' max.y' max.z);  			for (int i = 0; i < 8; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  			int[] indicesFwd =  {  				2'  				1'  				0'  				3'  				1'  				2'  				4'  				5'  				6'  				6'  				5'  				7'  				6'  				7'  				3'  				6'  				3'  				2'  				1'  				5'  				4'  				0'  				1'  				4  			};  			var srcIndices = indicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  		else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  			for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			var srcIndices = spriteData.colliderIndicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int y = 0; y < tileMap.partitionSizeY; ++y) {  	float xOffset = ((baseY + y) & 1) * xOffsetMult;  	for (int x = 0; x < tileMap.partitionSizeX; ++x) {  		int spriteId = chunkData [y * tileMap.partitionSizeX + x];  		int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  		Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  		if (spriteIdx < 0 || spriteIdx >= spriteCount)  			continue;  		if (tilePrefabs [spriteIdx])  			continue;  		bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  		bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  		bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  		bool reverseIndices = false;  		if (flipH)  			reverseIndices = !reverseIndices;  		if (flipV)  			reverseIndices = !reverseIndices;  		var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  		int baseVertexIndex = vertexList.Count;  		if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  			Vector3 origin = spriteData.colliderVertices [0];  			Vector3 extents = spriteData.colliderVertices [1];  			Vector3 min = origin - extents;  			Vector3 max = origin + extents;  			Vector3[] pos = new Vector3[8];  			pos [0] = new Vector3 (min.x' min.y' min.z);  			pos [1] = new Vector3 (min.x' min.y' max.z);  			pos [2] = new Vector3 (max.x' min.y' min.z);  			pos [3] = new Vector3 (max.x' min.y' max.z);  			pos [4] = new Vector3 (min.x' max.y' min.z);  			pos [5] = new Vector3 (min.x' max.y' max.z);  			pos [6] = new Vector3 (max.x' max.y' min.z);  			pos [7] = new Vector3 (max.x' max.y' max.z);  			for (int i = 0; i < 8; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  			int[] indicesFwd =  {  				2'  				1'  				0'  				3'  				1'  				2'  				4'  				5'  				6'  				6'  				5'  				7'  				6'  				7'  				3'  				6'  				3'  				2'  				1'  				5'  				4'  				0'  				1'  				4  			};  			var srcIndices = indicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  		else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  			for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			var srcIndices = spriteData.colliderIndicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int y = 0; y < tileMap.partitionSizeY; ++y) {  	float xOffset = ((baseY + y) & 1) * xOffsetMult;  	for (int x = 0; x < tileMap.partitionSizeX; ++x) {  		int spriteId = chunkData [y * tileMap.partitionSizeX + x];  		int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  		Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  		if (spriteIdx < 0 || spriteIdx >= spriteCount)  			continue;  		if (tilePrefabs [spriteIdx])  			continue;  		bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  		bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  		bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  		bool reverseIndices = false;  		if (flipH)  			reverseIndices = !reverseIndices;  		if (flipV)  			reverseIndices = !reverseIndices;  		var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  		int baseVertexIndex = vertexList.Count;  		if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  			Vector3 origin = spriteData.colliderVertices [0];  			Vector3 extents = spriteData.colliderVertices [1];  			Vector3 min = origin - extents;  			Vector3 max = origin + extents;  			Vector3[] pos = new Vector3[8];  			pos [0] = new Vector3 (min.x' min.y' min.z);  			pos [1] = new Vector3 (min.x' min.y' max.z);  			pos [2] = new Vector3 (max.x' min.y' min.z);  			pos [3] = new Vector3 (max.x' min.y' max.z);  			pos [4] = new Vector3 (min.x' max.y' min.z);  			pos [5] = new Vector3 (min.x' max.y' max.z);  			pos [6] = new Vector3 (max.x' max.y' min.z);  			pos [7] = new Vector3 (max.x' max.y' max.z);  			for (int i = 0; i < 8; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  			int[] indicesFwd =  {  				2'  				1'  				0'  				3'  				1'  				2'  				4'  				5'  				6'  				6'  				5'  				7'  				6'  				7'  				3'  				6'  				3'  				2'  				1'  				5'  				4'  				0'  				1'  				4  			};  			var srcIndices = indicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  		else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  			for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			var srcIndices = spriteData.colliderIndicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int y = 0; y < tileMap.partitionSizeY; ++y) {  	float xOffset = ((baseY + y) & 1) * xOffsetMult;  	for (int x = 0; x < tileMap.partitionSizeX; ++x) {  		int spriteId = chunkData [y * tileMap.partitionSizeX + x];  		int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  		Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  		if (spriteIdx < 0 || spriteIdx >= spriteCount)  			continue;  		if (tilePrefabs [spriteIdx])  			continue;  		bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  		bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  		bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  		bool reverseIndices = false;  		if (flipH)  			reverseIndices = !reverseIndices;  		if (flipV)  			reverseIndices = !reverseIndices;  		var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  		int baseVertexIndex = vertexList.Count;  		if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  			Vector3 origin = spriteData.colliderVertices [0];  			Vector3 extents = spriteData.colliderVertices [1];  			Vector3 min = origin - extents;  			Vector3 max = origin + extents;  			Vector3[] pos = new Vector3[8];  			pos [0] = new Vector3 (min.x' min.y' min.z);  			pos [1] = new Vector3 (min.x' min.y' max.z);  			pos [2] = new Vector3 (max.x' min.y' min.z);  			pos [3] = new Vector3 (max.x' min.y' max.z);  			pos [4] = new Vector3 (min.x' max.y' min.z);  			pos [5] = new Vector3 (min.x' max.y' max.z);  			pos [6] = new Vector3 (max.x' max.y' min.z);  			pos [7] = new Vector3 (max.x' max.y' max.z);  			for (int i = 0; i < 8; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  			int[] indicesFwd =  {  				2'  				1'  				0'  				3'  				1'  				2'  				4'  				5'  				6'  				6'  				5'  				7'  				6'  				7'  				3'  				6'  				3'  				2'  				1'  				5'  				4'  				0'  				1'  				4  			};  			var srcIndices = indicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  		else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  			for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			var srcIndices = spriteData.colliderIndicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int y = 0; y < tileMap.partitionSizeY; ++y) {  	float xOffset = ((baseY + y) & 1) * xOffsetMult;  	for (int x = 0; x < tileMap.partitionSizeX; ++x) {  		int spriteId = chunkData [y * tileMap.partitionSizeX + x];  		int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  		Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  		if (spriteIdx < 0 || spriteIdx >= spriteCount)  			continue;  		if (tilePrefabs [spriteIdx])  			continue;  		bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  		bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  		bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  		bool reverseIndices = false;  		if (flipH)  			reverseIndices = !reverseIndices;  		if (flipV)  			reverseIndices = !reverseIndices;  		var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  		int baseVertexIndex = vertexList.Count;  		if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  			Vector3 origin = spriteData.colliderVertices [0];  			Vector3 extents = spriteData.colliderVertices [1];  			Vector3 min = origin - extents;  			Vector3 max = origin + extents;  			Vector3[] pos = new Vector3[8];  			pos [0] = new Vector3 (min.x' min.y' min.z);  			pos [1] = new Vector3 (min.x' min.y' max.z);  			pos [2] = new Vector3 (max.x' min.y' min.z);  			pos [3] = new Vector3 (max.x' min.y' max.z);  			pos [4] = new Vector3 (min.x' max.y' min.z);  			pos [5] = new Vector3 (min.x' max.y' max.z);  			pos [6] = new Vector3 (max.x' max.y' min.z);  			pos [7] = new Vector3 (max.x' max.y' max.z);  			for (int i = 0; i < 8; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  			int[] indicesFwd =  {  				2'  				1'  				0'  				3'  				1'  				2'  				4'  				5'  				6'  				6'  				5'  				7'  				6'  				7'  				3'  				6'  				3'  				2'  				1'  				5'  				4'  				0'  				1'  				4  			};  			var srcIndices = indicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  		else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  			for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			var srcIndices = spriteData.colliderIndicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int y = 0; y < tileMap.partitionSizeY; ++y) {  	float xOffset = ((baseY + y) & 1) * xOffsetMult;  	for (int x = 0; x < tileMap.partitionSizeX; ++x) {  		int spriteId = chunkData [y * tileMap.partitionSizeX + x];  		int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  		Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  		if (spriteIdx < 0 || spriteIdx >= spriteCount)  			continue;  		if (tilePrefabs [spriteIdx])  			continue;  		bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  		bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  		bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  		bool reverseIndices = false;  		if (flipH)  			reverseIndices = !reverseIndices;  		if (flipV)  			reverseIndices = !reverseIndices;  		var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  		int baseVertexIndex = vertexList.Count;  		if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  			Vector3 origin = spriteData.colliderVertices [0];  			Vector3 extents = spriteData.colliderVertices [1];  			Vector3 min = origin - extents;  			Vector3 max = origin + extents;  			Vector3[] pos = new Vector3[8];  			pos [0] = new Vector3 (min.x' min.y' min.z);  			pos [1] = new Vector3 (min.x' min.y' max.z);  			pos [2] = new Vector3 (max.x' min.y' min.z);  			pos [3] = new Vector3 (max.x' min.y' max.z);  			pos [4] = new Vector3 (min.x' max.y' min.z);  			pos [5] = new Vector3 (min.x' max.y' max.z);  			pos [6] = new Vector3 (max.x' max.y' min.z);  			pos [7] = new Vector3 (max.x' max.y' max.z);  			for (int i = 0; i < 8; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  			int[] indicesFwd =  {  				2'  				1'  				0'  				3'  				1'  				2'  				4'  				5'  				6'  				6'  				5'  				7'  				6'  				7'  				3'  				6'  				3'  				2'  				1'  				5'  				4'  				0'  				1'  				4  			};  			var srcIndices = indicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  		else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  			for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			var srcIndices = spriteData.colliderIndicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int y = 0; y < tileMap.partitionSizeY; ++y) {  	float xOffset = ((baseY + y) & 1) * xOffsetMult;  	for (int x = 0; x < tileMap.partitionSizeX; ++x) {  		int spriteId = chunkData [y * tileMap.partitionSizeX + x];  		int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  		Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  		if (spriteIdx < 0 || spriteIdx >= spriteCount)  			continue;  		if (tilePrefabs [spriteIdx])  			continue;  		bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  		bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  		bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  		bool reverseIndices = false;  		if (flipH)  			reverseIndices = !reverseIndices;  		if (flipV)  			reverseIndices = !reverseIndices;  		var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  		int baseVertexIndex = vertexList.Count;  		if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  			Vector3 origin = spriteData.colliderVertices [0];  			Vector3 extents = spriteData.colliderVertices [1];  			Vector3 min = origin - extents;  			Vector3 max = origin + extents;  			Vector3[] pos = new Vector3[8];  			pos [0] = new Vector3 (min.x' min.y' min.z);  			pos [1] = new Vector3 (min.x' min.y' max.z);  			pos [2] = new Vector3 (max.x' min.y' min.z);  			pos [3] = new Vector3 (max.x' min.y' max.z);  			pos [4] = new Vector3 (min.x' max.y' min.z);  			pos [5] = new Vector3 (min.x' max.y' max.z);  			pos [6] = new Vector3 (max.x' max.y' min.z);  			pos [7] = new Vector3 (max.x' max.y' max.z);  			for (int i = 0; i < 8; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  			int[] indicesFwd =  {  				2'  				1'  				0'  				3'  				1'  				2'  				4'  				5'  				6'  				6'  				5'  				7'  				6'  				7'  				3'  				6'  				3'  				2'  				1'  				5'  				4'  				0'  				1'  				4  			};  			var srcIndices = indicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  		else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  			for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			var srcIndices = spriteData.colliderIndicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int y = 0; y < tileMap.partitionSizeY; ++y) {  	float xOffset = ((baseY + y) & 1) * xOffsetMult;  	for (int x = 0; x < tileMap.partitionSizeX; ++x) {  		int spriteId = chunkData [y * tileMap.partitionSizeX + x];  		int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  		Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  		if (spriteIdx < 0 || spriteIdx >= spriteCount)  			continue;  		if (tilePrefabs [spriteIdx])  			continue;  		bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  		bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  		bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  		bool reverseIndices = false;  		if (flipH)  			reverseIndices = !reverseIndices;  		if (flipV)  			reverseIndices = !reverseIndices;  		var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  		int baseVertexIndex = vertexList.Count;  		if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  			Vector3 origin = spriteData.colliderVertices [0];  			Vector3 extents = spriteData.colliderVertices [1];  			Vector3 min = origin - extents;  			Vector3 max = origin + extents;  			Vector3[] pos = new Vector3[8];  			pos [0] = new Vector3 (min.x' min.y' min.z);  			pos [1] = new Vector3 (min.x' min.y' max.z);  			pos [2] = new Vector3 (max.x' min.y' min.z);  			pos [3] = new Vector3 (max.x' min.y' max.z);  			pos [4] = new Vector3 (min.x' max.y' min.z);  			pos [5] = new Vector3 (min.x' max.y' max.z);  			pos [6] = new Vector3 (max.x' max.y' min.z);  			pos [7] = new Vector3 (max.x' max.y' max.z);  			for (int i = 0; i < 8; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  			int[] indicesFwd =  {  				2'  				1'  				0'  				3'  				1'  				2'  				4'  				5'  				6'  				6'  				5'  				7'  				6'  				7'  				3'  				6'  				3'  				2'  				1'  				5'  				4'  				0'  				1'  				4  			};  			var srcIndices = indicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  		else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  			for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			var srcIndices = spriteData.colliderIndicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int y = 0; y < tileMap.partitionSizeY; ++y) {  	float xOffset = ((baseY + y) & 1) * xOffsetMult;  	for (int x = 0; x < tileMap.partitionSizeX; ++x) {  		int spriteId = chunkData [y * tileMap.partitionSizeX + x];  		int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  		Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  		if (spriteIdx < 0 || spriteIdx >= spriteCount)  			continue;  		if (tilePrefabs [spriteIdx])  			continue;  		bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  		bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  		bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  		bool reverseIndices = false;  		if (flipH)  			reverseIndices = !reverseIndices;  		if (flipV)  			reverseIndices = !reverseIndices;  		var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  		int baseVertexIndex = vertexList.Count;  		if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  			Vector3 origin = spriteData.colliderVertices [0];  			Vector3 extents = spriteData.colliderVertices [1];  			Vector3 min = origin - extents;  			Vector3 max = origin + extents;  			Vector3[] pos = new Vector3[8];  			pos [0] = new Vector3 (min.x' min.y' min.z);  			pos [1] = new Vector3 (min.x' min.y' max.z);  			pos [2] = new Vector3 (max.x' min.y' min.z);  			pos [3] = new Vector3 (max.x' min.y' max.z);  			pos [4] = new Vector3 (min.x' max.y' min.z);  			pos [5] = new Vector3 (min.x' max.y' max.z);  			pos [6] = new Vector3 (max.x' max.y' min.z);  			pos [7] = new Vector3 (max.x' max.y' max.z);  			for (int i = 0; i < 8; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  			int[] indicesFwd =  {  				2'  				1'  				0'  				3'  				1'  				2'  				4'  				5'  				6'  				6'  				5'  				7'  				6'  				7'  				3'  				6'  				3'  				2'  				1'  				5'  				4'  				0'  				1'  				4  			};  			var srcIndices = indicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  		else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  			for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			var srcIndices = spriteData.colliderIndicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int y = 0; y < tileMap.partitionSizeY; ++y) {  	float xOffset = ((baseY + y) & 1) * xOffsetMult;  	for (int x = 0; x < tileMap.partitionSizeX; ++x) {  		int spriteId = chunkData [y * tileMap.partitionSizeX + x];  		int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  		Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  		if (spriteIdx < 0 || spriteIdx >= spriteCount)  			continue;  		if (tilePrefabs [spriteIdx])  			continue;  		bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  		bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  		bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  		bool reverseIndices = false;  		if (flipH)  			reverseIndices = !reverseIndices;  		if (flipV)  			reverseIndices = !reverseIndices;  		var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  		int baseVertexIndex = vertexList.Count;  		if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  			Vector3 origin = spriteData.colliderVertices [0];  			Vector3 extents = spriteData.colliderVertices [1];  			Vector3 min = origin - extents;  			Vector3 max = origin + extents;  			Vector3[] pos = new Vector3[8];  			pos [0] = new Vector3 (min.x' min.y' min.z);  			pos [1] = new Vector3 (min.x' min.y' max.z);  			pos [2] = new Vector3 (max.x' min.y' min.z);  			pos [3] = new Vector3 (max.x' min.y' max.z);  			pos [4] = new Vector3 (min.x' max.y' min.z);  			pos [5] = new Vector3 (min.x' max.y' max.z);  			pos [6] = new Vector3 (max.x' max.y' min.z);  			pos [7] = new Vector3 (max.x' max.y' max.z);  			for (int i = 0; i < 8; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  			int[] indicesFwd =  {  				2'  				1'  				0'  				3'  				1'  				2'  				4'  				5'  				6'  				6'  				5'  				7'  				6'  				7'  				3'  				6'  				3'  				2'  				1'  				5'  				4'  				0'  				1'  				4  			};  			var srcIndices = indicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  		else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  			for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			var srcIndices = spriteData.colliderIndicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int y = 0; y < tileMap.partitionSizeY; ++y) {  	float xOffset = ((baseY + y) & 1) * xOffsetMult;  	for (int x = 0; x < tileMap.partitionSizeX; ++x) {  		int spriteId = chunkData [y * tileMap.partitionSizeX + x];  		int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  		Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  		if (spriteIdx < 0 || spriteIdx >= spriteCount)  			continue;  		if (tilePrefabs [spriteIdx])  			continue;  		bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  		bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  		bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  		bool reverseIndices = false;  		if (flipH)  			reverseIndices = !reverseIndices;  		if (flipV)  			reverseIndices = !reverseIndices;  		var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  		int baseVertexIndex = vertexList.Count;  		if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  			Vector3 origin = spriteData.colliderVertices [0];  			Vector3 extents = spriteData.colliderVertices [1];  			Vector3 min = origin - extents;  			Vector3 max = origin + extents;  			Vector3[] pos = new Vector3[8];  			pos [0] = new Vector3 (min.x' min.y' min.z);  			pos [1] = new Vector3 (min.x' min.y' max.z);  			pos [2] = new Vector3 (max.x' min.y' min.z);  			pos [3] = new Vector3 (max.x' min.y' max.z);  			pos [4] = new Vector3 (min.x' max.y' min.z);  			pos [5] = new Vector3 (min.x' max.y' max.z);  			pos [6] = new Vector3 (max.x' max.y' min.z);  			pos [7] = new Vector3 (max.x' max.y' max.z);  			for (int i = 0; i < 8; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  			int[] indicesFwd =  {  				2'  				1'  				0'  				3'  				1'  				2'  				4'  				5'  				6'  				6'  				5'  				7'  				6'  				7'  				3'  				6'  				3'  				2'  				1'  				5'  				4'  				0'  				1'  				4  			};  			var srcIndices = indicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  		else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  			for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			var srcIndices = spriteData.colliderIndicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int y = 0; y < tileMap.partitionSizeY; ++y) {  	float xOffset = ((baseY + y) & 1) * xOffsetMult;  	for (int x = 0; x < tileMap.partitionSizeX; ++x) {  		int spriteId = chunkData [y * tileMap.partitionSizeX + x];  		int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  		Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  		if (spriteIdx < 0 || spriteIdx >= spriteCount)  			continue;  		if (tilePrefabs [spriteIdx])  			continue;  		bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  		bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  		bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  		bool reverseIndices = false;  		if (flipH)  			reverseIndices = !reverseIndices;  		if (flipV)  			reverseIndices = !reverseIndices;  		var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  		int baseVertexIndex = vertexList.Count;  		if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  			Vector3 origin = spriteData.colliderVertices [0];  			Vector3 extents = spriteData.colliderVertices [1];  			Vector3 min = origin - extents;  			Vector3 max = origin + extents;  			Vector3[] pos = new Vector3[8];  			pos [0] = new Vector3 (min.x' min.y' min.z);  			pos [1] = new Vector3 (min.x' min.y' max.z);  			pos [2] = new Vector3 (max.x' min.y' min.z);  			pos [3] = new Vector3 (max.x' min.y' max.z);  			pos [4] = new Vector3 (min.x' max.y' min.z);  			pos [5] = new Vector3 (min.x' max.y' max.z);  			pos [6] = new Vector3 (max.x' max.y' min.z);  			pos [7] = new Vector3 (max.x' max.y' max.z);  			for (int i = 0; i < 8; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  			int[] indicesFwd =  {  				2'  				1'  				0'  				3'  				1'  				2'  				4'  				5'  				6'  				6'  				5'  				7'  				6'  				7'  				3'  				6'  				3'  				2'  				1'  				5'  				4'  				0'  				1'  				4  			};  			var srcIndices = indicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  		else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  			for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			var srcIndices = spriteData.colliderIndicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int y = 0; y < tileMap.partitionSizeY; ++y) {  	float xOffset = ((baseY + y) & 1) * xOffsetMult;  	for (int x = 0; x < tileMap.partitionSizeX; ++x) {  		int spriteId = chunkData [y * tileMap.partitionSizeX + x];  		int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  		Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  		if (spriteIdx < 0 || spriteIdx >= spriteCount)  			continue;  		if (tilePrefabs [spriteIdx])  			continue;  		bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  		bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  		bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  		bool reverseIndices = false;  		if (flipH)  			reverseIndices = !reverseIndices;  		if (flipV)  			reverseIndices = !reverseIndices;  		var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  		int baseVertexIndex = vertexList.Count;  		if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  			Vector3 origin = spriteData.colliderVertices [0];  			Vector3 extents = spriteData.colliderVertices [1];  			Vector3 min = origin - extents;  			Vector3 max = origin + extents;  			Vector3[] pos = new Vector3[8];  			pos [0] = new Vector3 (min.x' min.y' min.z);  			pos [1] = new Vector3 (min.x' min.y' max.z);  			pos [2] = new Vector3 (max.x' min.y' min.z);  			pos [3] = new Vector3 (max.x' min.y' max.z);  			pos [4] = new Vector3 (min.x' max.y' min.z);  			pos [5] = new Vector3 (min.x' max.y' max.z);  			pos [6] = new Vector3 (max.x' max.y' min.z);  			pos [7] = new Vector3 (max.x' max.y' max.z);  			for (int i = 0; i < 8; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  			int[] indicesFwd =  {  				2'  				1'  				0'  				3'  				1'  				2'  				4'  				5'  				6'  				6'  				5'  				7'  				6'  				7'  				3'  				6'  				3'  				2'  				1'  				5'  				4'  				0'  				1'  				4  			};  			var srcIndices = indicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  		else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  			for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			var srcIndices = spriteData.colliderIndicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int y = 0; y < tileMap.partitionSizeY; ++y) {  	float xOffset = ((baseY + y) & 1) * xOffsetMult;  	for (int x = 0; x < tileMap.partitionSizeX; ++x) {  		int spriteId = chunkData [y * tileMap.partitionSizeX + x];  		int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  		Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  		if (spriteIdx < 0 || spriteIdx >= spriteCount)  			continue;  		if (tilePrefabs [spriteIdx])  			continue;  		bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  		bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  		bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  		bool reverseIndices = false;  		if (flipH)  			reverseIndices = !reverseIndices;  		if (flipV)  			reverseIndices = !reverseIndices;  		var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  		int baseVertexIndex = vertexList.Count;  		if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  			Vector3 origin = spriteData.colliderVertices [0];  			Vector3 extents = spriteData.colliderVertices [1];  			Vector3 min = origin - extents;  			Vector3 max = origin + extents;  			Vector3[] pos = new Vector3[8];  			pos [0] = new Vector3 (min.x' min.y' min.z);  			pos [1] = new Vector3 (min.x' min.y' max.z);  			pos [2] = new Vector3 (max.x' min.y' min.z);  			pos [3] = new Vector3 (max.x' min.y' max.z);  			pos [4] = new Vector3 (min.x' max.y' min.z);  			pos [5] = new Vector3 (min.x' max.y' max.z);  			pos [6] = new Vector3 (max.x' max.y' min.z);  			pos [7] = new Vector3 (max.x' max.y' max.z);  			for (int i = 0; i < 8; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  			int[] indicesFwd =  {  				2'  				1'  				0'  				3'  				1'  				2'  				4'  				5'  				6'  				6'  				5'  				7'  				6'  				7'  				3'  				6'  				3'  				2'  				1'  				5'  				4'  				0'  				1'  				4  			};  			var srcIndices = indicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  		else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  			for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			var srcIndices = spriteData.colliderIndicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int y = 0; y < tileMap.partitionSizeY; ++y) {  	float xOffset = ((baseY + y) & 1) * xOffsetMult;  	for (int x = 0; x < tileMap.partitionSizeX; ++x) {  		int spriteId = chunkData [y * tileMap.partitionSizeX + x];  		int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  		Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  		if (spriteIdx < 0 || spriteIdx >= spriteCount)  			continue;  		if (tilePrefabs [spriteIdx])  			continue;  		bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  		bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  		bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  		bool reverseIndices = false;  		if (flipH)  			reverseIndices = !reverseIndices;  		if (flipV)  			reverseIndices = !reverseIndices;  		var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  		int baseVertexIndex = vertexList.Count;  		if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  			Vector3 origin = spriteData.colliderVertices [0];  			Vector3 extents = spriteData.colliderVertices [1];  			Vector3 min = origin - extents;  			Vector3 max = origin + extents;  			Vector3[] pos = new Vector3[8];  			pos [0] = new Vector3 (min.x' min.y' min.z);  			pos [1] = new Vector3 (min.x' min.y' max.z);  			pos [2] = new Vector3 (max.x' min.y' min.z);  			pos [3] = new Vector3 (max.x' min.y' max.z);  			pos [4] = new Vector3 (min.x' max.y' min.z);  			pos [5] = new Vector3 (min.x' max.y' max.z);  			pos [6] = new Vector3 (max.x' max.y' min.z);  			pos [7] = new Vector3 (max.x' max.y' max.z);  			for (int i = 0; i < 8; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  			int[] indicesFwd =  {  				2'  				1'  				0'  				3'  				1'  				2'  				4'  				5'  				6'  				6'  				5'  				7'  				6'  				7'  				3'  				6'  				3'  				2'  				1'  				5'  				4'  				0'  				1'  				4  			};  			var srcIndices = indicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  		else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  			for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			var srcIndices = spriteData.colliderIndicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int y = 0; y < tileMap.partitionSizeY; ++y) {  	float xOffset = ((baseY + y) & 1) * xOffsetMult;  	for (int x = 0; x < tileMap.partitionSizeX; ++x) {  		int spriteId = chunkData [y * tileMap.partitionSizeX + x];  		int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  		Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  		if (spriteIdx < 0 || spriteIdx >= spriteCount)  			continue;  		if (tilePrefabs [spriteIdx])  			continue;  		bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  		bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  		bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  		bool reverseIndices = false;  		if (flipH)  			reverseIndices = !reverseIndices;  		if (flipV)  			reverseIndices = !reverseIndices;  		var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  		int baseVertexIndex = vertexList.Count;  		if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  			Vector3 origin = spriteData.colliderVertices [0];  			Vector3 extents = spriteData.colliderVertices [1];  			Vector3 min = origin - extents;  			Vector3 max = origin + extents;  			Vector3[] pos = new Vector3[8];  			pos [0] = new Vector3 (min.x' min.y' min.z);  			pos [1] = new Vector3 (min.x' min.y' max.z);  			pos [2] = new Vector3 (max.x' min.y' min.z);  			pos [3] = new Vector3 (max.x' min.y' max.z);  			pos [4] = new Vector3 (min.x' max.y' min.z);  			pos [5] = new Vector3 (min.x' max.y' max.z);  			pos [6] = new Vector3 (max.x' max.y' min.z);  			pos [7] = new Vector3 (max.x' max.y' max.z);  			for (int i = 0; i < 8; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  			int[] indicesFwd =  {  				2'  				1'  				0'  				3'  				1'  				2'  				4'  				5'  				6'  				6'  				5'  				7'  				6'  				7'  				3'  				6'  				3'  				2'  				1'  				5'  				4'  				0'  				1'  				4  			};  			var srcIndices = indicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  		else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  			for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			var srcIndices = spriteData.colliderIndicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int y = 0; y < tileMap.partitionSizeY; ++y) {  	float xOffset = ((baseY + y) & 1) * xOffsetMult;  	for (int x = 0; x < tileMap.partitionSizeX; ++x) {  		int spriteId = chunkData [y * tileMap.partitionSizeX + x];  		int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  		Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  		if (spriteIdx < 0 || spriteIdx >= spriteCount)  			continue;  		if (tilePrefabs [spriteIdx])  			continue;  		bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  		bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  		bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  		bool reverseIndices = false;  		if (flipH)  			reverseIndices = !reverseIndices;  		if (flipV)  			reverseIndices = !reverseIndices;  		var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  		int baseVertexIndex = vertexList.Count;  		if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  			Vector3 origin = spriteData.colliderVertices [0];  			Vector3 extents = spriteData.colliderVertices [1];  			Vector3 min = origin - extents;  			Vector3 max = origin + extents;  			Vector3[] pos = new Vector3[8];  			pos [0] = new Vector3 (min.x' min.y' min.z);  			pos [1] = new Vector3 (min.x' min.y' max.z);  			pos [2] = new Vector3 (max.x' min.y' min.z);  			pos [3] = new Vector3 (max.x' min.y' max.z);  			pos [4] = new Vector3 (min.x' max.y' min.z);  			pos [5] = new Vector3 (min.x' max.y' max.z);  			pos [6] = new Vector3 (max.x' max.y' min.z);  			pos [7] = new Vector3 (max.x' max.y' max.z);  			for (int i = 0; i < 8; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  			int[] indicesFwd =  {  				2'  				1'  				0'  				3'  				1'  				2'  				4'  				5'  				6'  				6'  				5'  				7'  				6'  				7'  				3'  				6'  				3'  				2'  				1'  				5'  				4'  				0'  				1'  				4  			};  			var srcIndices = indicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  		else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  			for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			var srcIndices = spriteData.colliderIndicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int y = 0; y < tileMap.partitionSizeY; ++y) {  	float xOffset = ((baseY + y) & 1) * xOffsetMult;  	for (int x = 0; x < tileMap.partitionSizeX; ++x) {  		int spriteId = chunkData [y * tileMap.partitionSizeX + x];  		int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  		Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  		if (spriteIdx < 0 || spriteIdx >= spriteCount)  			continue;  		if (tilePrefabs [spriteIdx])  			continue;  		bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  		bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  		bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  		bool reverseIndices = false;  		if (flipH)  			reverseIndices = !reverseIndices;  		if (flipV)  			reverseIndices = !reverseIndices;  		var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  		int baseVertexIndex = vertexList.Count;  		if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  			Vector3 origin = spriteData.colliderVertices [0];  			Vector3 extents = spriteData.colliderVertices [1];  			Vector3 min = origin - extents;  			Vector3 max = origin + extents;  			Vector3[] pos = new Vector3[8];  			pos [0] = new Vector3 (min.x' min.y' min.z);  			pos [1] = new Vector3 (min.x' min.y' max.z);  			pos [2] = new Vector3 (max.x' min.y' min.z);  			pos [3] = new Vector3 (max.x' min.y' max.z);  			pos [4] = new Vector3 (min.x' max.y' min.z);  			pos [5] = new Vector3 (min.x' max.y' max.z);  			pos [6] = new Vector3 (max.x' max.y' min.z);  			pos [7] = new Vector3 (max.x' max.y' max.z);  			for (int i = 0; i < 8; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  			int[] indicesFwd =  {  				2'  				1'  				0'  				3'  				1'  				2'  				4'  				5'  				6'  				6'  				5'  				7'  				6'  				7'  				3'  				6'  				3'  				2'  				1'  				5'  				4'  				0'  				1'  				4  			};  			var srcIndices = indicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  		else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  			for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			var srcIndices = spriteData.colliderIndicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int y = 0; y < tileMap.partitionSizeY; ++y) {  	float xOffset = ((baseY + y) & 1) * xOffsetMult;  	for (int x = 0; x < tileMap.partitionSizeX; ++x) {  		int spriteId = chunkData [y * tileMap.partitionSizeX + x];  		int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  		Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  		if (spriteIdx < 0 || spriteIdx >= spriteCount)  			continue;  		if (tilePrefabs [spriteIdx])  			continue;  		bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  		bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  		bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  		bool reverseIndices = false;  		if (flipH)  			reverseIndices = !reverseIndices;  		if (flipV)  			reverseIndices = !reverseIndices;  		var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  		int baseVertexIndex = vertexList.Count;  		if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  			Vector3 origin = spriteData.colliderVertices [0];  			Vector3 extents = spriteData.colliderVertices [1];  			Vector3 min = origin - extents;  			Vector3 max = origin + extents;  			Vector3[] pos = new Vector3[8];  			pos [0] = new Vector3 (min.x' min.y' min.z);  			pos [1] = new Vector3 (min.x' min.y' max.z);  			pos [2] = new Vector3 (max.x' min.y' min.z);  			pos [3] = new Vector3 (max.x' min.y' max.z);  			pos [4] = new Vector3 (min.x' max.y' min.z);  			pos [5] = new Vector3 (min.x' max.y' max.z);  			pos [6] = new Vector3 (max.x' max.y' min.z);  			pos [7] = new Vector3 (max.x' max.y' max.z);  			for (int i = 0; i < 8; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  			int[] indicesFwd =  {  				2'  				1'  				0'  				3'  				1'  				2'  				4'  				5'  				6'  				6'  				5'  				7'  				6'  				7'  				3'  				6'  				3'  				2'  				1'  				5'  				4'  				0'  				1'  				4  			};  			var srcIndices = indicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  		else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  			for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			var srcIndices = spriteData.colliderIndicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int x = 0; x < tileMap.partitionSizeX; ++x) {  	int spriteId = chunkData [y * tileMap.partitionSizeX + x];  	int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  	Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  	if (spriteIdx < 0 || spriteIdx >= spriteCount)  		continue;  	if (tilePrefabs [spriteIdx])  		continue;  	bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  	bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  	bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  	bool reverseIndices = false;  	if (flipH)  		reverseIndices = !reverseIndices;  	if (flipV)  		reverseIndices = !reverseIndices;  	var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  	int baseVertexIndex = vertexList.Count;  	if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  		Vector3 origin = spriteData.colliderVertices [0];  		Vector3 extents = spriteData.colliderVertices [1];  		Vector3 min = origin - extents;  		Vector3 max = origin + extents;  		Vector3[] pos = new Vector3[8];  		pos [0] = new Vector3 (min.x' min.y' min.z);  		pos [1] = new Vector3 (min.x' min.y' max.z);  		pos [2] = new Vector3 (max.x' min.y' min.z);  		pos [3] = new Vector3 (max.x' min.y' max.z);  		pos [4] = new Vector3 (min.x' max.y' min.z);  		pos [5] = new Vector3 (min.x' max.y' max.z);  		pos [6] = new Vector3 (max.x' max.y' min.z);  		pos [7] = new Vector3 (max.x' max.y' max.z);  		for (int i = 0; i < 8; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  		int[] indicesFwd =  {  			2'  			1'  			0'  			3'  			1'  			2'  			4'  			5'  			6'  			6'  			5'  			7'  			6'  			7'  			3'  			6'  			3'  			2'  			1'  			5'  			4'  			0'  			1'  			4  		};  		var srcIndices = indicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  	else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  		for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		var srcIndices = spriteData.colliderIndicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int x = 0; x < tileMap.partitionSizeX; ++x) {  	int spriteId = chunkData [y * tileMap.partitionSizeX + x];  	int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  	Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  	if (spriteIdx < 0 || spriteIdx >= spriteCount)  		continue;  	if (tilePrefabs [spriteIdx])  		continue;  	bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  	bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  	bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  	bool reverseIndices = false;  	if (flipH)  		reverseIndices = !reverseIndices;  	if (flipV)  		reverseIndices = !reverseIndices;  	var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  	int baseVertexIndex = vertexList.Count;  	if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  		Vector3 origin = spriteData.colliderVertices [0];  		Vector3 extents = spriteData.colliderVertices [1];  		Vector3 min = origin - extents;  		Vector3 max = origin + extents;  		Vector3[] pos = new Vector3[8];  		pos [0] = new Vector3 (min.x' min.y' min.z);  		pos [1] = new Vector3 (min.x' min.y' max.z);  		pos [2] = new Vector3 (max.x' min.y' min.z);  		pos [3] = new Vector3 (max.x' min.y' max.z);  		pos [4] = new Vector3 (min.x' max.y' min.z);  		pos [5] = new Vector3 (min.x' max.y' max.z);  		pos [6] = new Vector3 (max.x' max.y' min.z);  		pos [7] = new Vector3 (max.x' max.y' max.z);  		for (int i = 0; i < 8; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  		int[] indicesFwd =  {  			2'  			1'  			0'  			3'  			1'  			2'  			4'  			5'  			6'  			6'  			5'  			7'  			6'  			7'  			3'  			6'  			3'  			2'  			1'  			5'  			4'  			0'  			1'  			4  		};  		var srcIndices = indicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  	else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  		for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		var srcIndices = spriteData.colliderIndicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int x = 0; x < tileMap.partitionSizeX; ++x) {  	int spriteId = chunkData [y * tileMap.partitionSizeX + x];  	int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  	Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  	if (spriteIdx < 0 || spriteIdx >= spriteCount)  		continue;  	if (tilePrefabs [spriteIdx])  		continue;  	bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  	bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  	bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  	bool reverseIndices = false;  	if (flipH)  		reverseIndices = !reverseIndices;  	if (flipV)  		reverseIndices = !reverseIndices;  	var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  	int baseVertexIndex = vertexList.Count;  	if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  		Vector3 origin = spriteData.colliderVertices [0];  		Vector3 extents = spriteData.colliderVertices [1];  		Vector3 min = origin - extents;  		Vector3 max = origin + extents;  		Vector3[] pos = new Vector3[8];  		pos [0] = new Vector3 (min.x' min.y' min.z);  		pos [1] = new Vector3 (min.x' min.y' max.z);  		pos [2] = new Vector3 (max.x' min.y' min.z);  		pos [3] = new Vector3 (max.x' min.y' max.z);  		pos [4] = new Vector3 (min.x' max.y' min.z);  		pos [5] = new Vector3 (min.x' max.y' max.z);  		pos [6] = new Vector3 (max.x' max.y' min.z);  		pos [7] = new Vector3 (max.x' max.y' max.z);  		for (int i = 0; i < 8; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  		int[] indicesFwd =  {  			2'  			1'  			0'  			3'  			1'  			2'  			4'  			5'  			6'  			6'  			5'  			7'  			6'  			7'  			3'  			6'  			3'  			2'  			1'  			5'  			4'  			0'  			1'  			4  		};  		var srcIndices = indicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  	else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  		for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		var srcIndices = spriteData.colliderIndicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int x = 0; x < tileMap.partitionSizeX; ++x) {  	int spriteId = chunkData [y * tileMap.partitionSizeX + x];  	int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  	Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  	if (spriteIdx < 0 || spriteIdx >= spriteCount)  		continue;  	if (tilePrefabs [spriteIdx])  		continue;  	bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  	bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  	bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  	bool reverseIndices = false;  	if (flipH)  		reverseIndices = !reverseIndices;  	if (flipV)  		reverseIndices = !reverseIndices;  	var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  	int baseVertexIndex = vertexList.Count;  	if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  		Vector3 origin = spriteData.colliderVertices [0];  		Vector3 extents = spriteData.colliderVertices [1];  		Vector3 min = origin - extents;  		Vector3 max = origin + extents;  		Vector3[] pos = new Vector3[8];  		pos [0] = new Vector3 (min.x' min.y' min.z);  		pos [1] = new Vector3 (min.x' min.y' max.z);  		pos [2] = new Vector3 (max.x' min.y' min.z);  		pos [3] = new Vector3 (max.x' min.y' max.z);  		pos [4] = new Vector3 (min.x' max.y' min.z);  		pos [5] = new Vector3 (min.x' max.y' max.z);  		pos [6] = new Vector3 (max.x' max.y' min.z);  		pos [7] = new Vector3 (max.x' max.y' max.z);  		for (int i = 0; i < 8; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  		int[] indicesFwd =  {  			2'  			1'  			0'  			3'  			1'  			2'  			4'  			5'  			6'  			6'  			5'  			7'  			6'  			7'  			3'  			6'  			3'  			2'  			1'  			5'  			4'  			0'  			1'  			4  		};  		var srcIndices = indicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  	else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  		for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		var srcIndices = spriteData.colliderIndicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int x = 0; x < tileMap.partitionSizeX; ++x) {  	int spriteId = chunkData [y * tileMap.partitionSizeX + x];  	int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  	Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  	if (spriteIdx < 0 || spriteIdx >= spriteCount)  		continue;  	if (tilePrefabs [spriteIdx])  		continue;  	bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  	bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  	bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  	bool reverseIndices = false;  	if (flipH)  		reverseIndices = !reverseIndices;  	if (flipV)  		reverseIndices = !reverseIndices;  	var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  	int baseVertexIndex = vertexList.Count;  	if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  		Vector3 origin = spriteData.colliderVertices [0];  		Vector3 extents = spriteData.colliderVertices [1];  		Vector3 min = origin - extents;  		Vector3 max = origin + extents;  		Vector3[] pos = new Vector3[8];  		pos [0] = new Vector3 (min.x' min.y' min.z);  		pos [1] = new Vector3 (min.x' min.y' max.z);  		pos [2] = new Vector3 (max.x' min.y' min.z);  		pos [3] = new Vector3 (max.x' min.y' max.z);  		pos [4] = new Vector3 (min.x' max.y' min.z);  		pos [5] = new Vector3 (min.x' max.y' max.z);  		pos [6] = new Vector3 (max.x' max.y' min.z);  		pos [7] = new Vector3 (max.x' max.y' max.z);  		for (int i = 0; i < 8; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  		int[] indicesFwd =  {  			2'  			1'  			0'  			3'  			1'  			2'  			4'  			5'  			6'  			6'  			5'  			7'  			6'  			7'  			3'  			6'  			3'  			2'  			1'  			5'  			4'  			0'  			1'  			4  		};  		var srcIndices = indicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  	else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  		for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		var srcIndices = spriteData.colliderIndicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int x = 0; x < tileMap.partitionSizeX; ++x) {  	int spriteId = chunkData [y * tileMap.partitionSizeX + x];  	int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  	Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  	if (spriteIdx < 0 || spriteIdx >= spriteCount)  		continue;  	if (tilePrefabs [spriteIdx])  		continue;  	bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  	bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  	bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  	bool reverseIndices = false;  	if (flipH)  		reverseIndices = !reverseIndices;  	if (flipV)  		reverseIndices = !reverseIndices;  	var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  	int baseVertexIndex = vertexList.Count;  	if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  		Vector3 origin = spriteData.colliderVertices [0];  		Vector3 extents = spriteData.colliderVertices [1];  		Vector3 min = origin - extents;  		Vector3 max = origin + extents;  		Vector3[] pos = new Vector3[8];  		pos [0] = new Vector3 (min.x' min.y' min.z);  		pos [1] = new Vector3 (min.x' min.y' max.z);  		pos [2] = new Vector3 (max.x' min.y' min.z);  		pos [3] = new Vector3 (max.x' min.y' max.z);  		pos [4] = new Vector3 (min.x' max.y' min.z);  		pos [5] = new Vector3 (min.x' max.y' max.z);  		pos [6] = new Vector3 (max.x' max.y' min.z);  		pos [7] = new Vector3 (max.x' max.y' max.z);  		for (int i = 0; i < 8; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  		int[] indicesFwd =  {  			2'  			1'  			0'  			3'  			1'  			2'  			4'  			5'  			6'  			6'  			5'  			7'  			6'  			7'  			3'  			6'  			3'  			2'  			1'  			5'  			4'  			0'  			1'  			4  		};  		var srcIndices = indicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  	else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  		for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		var srcIndices = spriteData.colliderIndicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int x = 0; x < tileMap.partitionSizeX; ++x) {  	int spriteId = chunkData [y * tileMap.partitionSizeX + x];  	int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  	Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  	if (spriteIdx < 0 || spriteIdx >= spriteCount)  		continue;  	if (tilePrefabs [spriteIdx])  		continue;  	bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  	bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  	bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  	bool reverseIndices = false;  	if (flipH)  		reverseIndices = !reverseIndices;  	if (flipV)  		reverseIndices = !reverseIndices;  	var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  	int baseVertexIndex = vertexList.Count;  	if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  		Vector3 origin = spriteData.colliderVertices [0];  		Vector3 extents = spriteData.colliderVertices [1];  		Vector3 min = origin - extents;  		Vector3 max = origin + extents;  		Vector3[] pos = new Vector3[8];  		pos [0] = new Vector3 (min.x' min.y' min.z);  		pos [1] = new Vector3 (min.x' min.y' max.z);  		pos [2] = new Vector3 (max.x' min.y' min.z);  		pos [3] = new Vector3 (max.x' min.y' max.z);  		pos [4] = new Vector3 (min.x' max.y' min.z);  		pos [5] = new Vector3 (min.x' max.y' max.z);  		pos [6] = new Vector3 (max.x' max.y' min.z);  		pos [7] = new Vector3 (max.x' max.y' max.z);  		for (int i = 0; i < 8; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  		int[] indicesFwd =  {  			2'  			1'  			0'  			3'  			1'  			2'  			4'  			5'  			6'  			6'  			5'  			7'  			6'  			7'  			3'  			6'  			3'  			2'  			1'  			5'  			4'  			0'  			1'  			4  		};  		var srcIndices = indicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  	else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  		for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		var srcIndices = spriteData.colliderIndicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int x = 0; x < tileMap.partitionSizeX; ++x) {  	int spriteId = chunkData [y * tileMap.partitionSizeX + x];  	int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  	Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  	if (spriteIdx < 0 || spriteIdx >= spriteCount)  		continue;  	if (tilePrefabs [spriteIdx])  		continue;  	bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  	bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  	bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  	bool reverseIndices = false;  	if (flipH)  		reverseIndices = !reverseIndices;  	if (flipV)  		reverseIndices = !reverseIndices;  	var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  	int baseVertexIndex = vertexList.Count;  	if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  		Vector3 origin = spriteData.colliderVertices [0];  		Vector3 extents = spriteData.colliderVertices [1];  		Vector3 min = origin - extents;  		Vector3 max = origin + extents;  		Vector3[] pos = new Vector3[8];  		pos [0] = new Vector3 (min.x' min.y' min.z);  		pos [1] = new Vector3 (min.x' min.y' max.z);  		pos [2] = new Vector3 (max.x' min.y' min.z);  		pos [3] = new Vector3 (max.x' min.y' max.z);  		pos [4] = new Vector3 (min.x' max.y' min.z);  		pos [5] = new Vector3 (min.x' max.y' max.z);  		pos [6] = new Vector3 (max.x' max.y' min.z);  		pos [7] = new Vector3 (max.x' max.y' max.z);  		for (int i = 0; i < 8; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  		int[] indicesFwd =  {  			2'  			1'  			0'  			3'  			1'  			2'  			4'  			5'  			6'  			6'  			5'  			7'  			6'  			7'  			3'  			6'  			3'  			2'  			1'  			5'  			4'  			0'  			1'  			4  		};  		var srcIndices = indicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  	else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  		for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		var srcIndices = spriteData.colliderIndicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int x = 0; x < tileMap.partitionSizeX; ++x) {  	int spriteId = chunkData [y * tileMap.partitionSizeX + x];  	int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  	Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  	if (spriteIdx < 0 || spriteIdx >= spriteCount)  		continue;  	if (tilePrefabs [spriteIdx])  		continue;  	bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  	bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  	bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  	bool reverseIndices = false;  	if (flipH)  		reverseIndices = !reverseIndices;  	if (flipV)  		reverseIndices = !reverseIndices;  	var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  	int baseVertexIndex = vertexList.Count;  	if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  		Vector3 origin = spriteData.colliderVertices [0];  		Vector3 extents = spriteData.colliderVertices [1];  		Vector3 min = origin - extents;  		Vector3 max = origin + extents;  		Vector3[] pos = new Vector3[8];  		pos [0] = new Vector3 (min.x' min.y' min.z);  		pos [1] = new Vector3 (min.x' min.y' max.z);  		pos [2] = new Vector3 (max.x' min.y' min.z);  		pos [3] = new Vector3 (max.x' min.y' max.z);  		pos [4] = new Vector3 (min.x' max.y' min.z);  		pos [5] = new Vector3 (min.x' max.y' max.z);  		pos [6] = new Vector3 (max.x' max.y' min.z);  		pos [7] = new Vector3 (max.x' max.y' max.z);  		for (int i = 0; i < 8; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  		int[] indicesFwd =  {  			2'  			1'  			0'  			3'  			1'  			2'  			4'  			5'  			6'  			6'  			5'  			7'  			6'  			7'  			3'  			6'  			3'  			2'  			1'  			5'  			4'  			0'  			1'  			4  		};  		var srcIndices = indicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  	else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  		for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		var srcIndices = spriteData.colliderIndicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int x = 0; x < tileMap.partitionSizeX; ++x) {  	int spriteId = chunkData [y * tileMap.partitionSizeX + x];  	int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  	Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  	if (spriteIdx < 0 || spriteIdx >= spriteCount)  		continue;  	if (tilePrefabs [spriteIdx])  		continue;  	bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  	bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  	bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  	bool reverseIndices = false;  	if (flipH)  		reverseIndices = !reverseIndices;  	if (flipV)  		reverseIndices = !reverseIndices;  	var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  	int baseVertexIndex = vertexList.Count;  	if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  		Vector3 origin = spriteData.colliderVertices [0];  		Vector3 extents = spriteData.colliderVertices [1];  		Vector3 min = origin - extents;  		Vector3 max = origin + extents;  		Vector3[] pos = new Vector3[8];  		pos [0] = new Vector3 (min.x' min.y' min.z);  		pos [1] = new Vector3 (min.x' min.y' max.z);  		pos [2] = new Vector3 (max.x' min.y' min.z);  		pos [3] = new Vector3 (max.x' min.y' max.z);  		pos [4] = new Vector3 (min.x' max.y' min.z);  		pos [5] = new Vector3 (min.x' max.y' max.z);  		pos [6] = new Vector3 (max.x' max.y' min.z);  		pos [7] = new Vector3 (max.x' max.y' max.z);  		for (int i = 0; i < 8; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  		int[] indicesFwd =  {  			2'  			1'  			0'  			3'  			1'  			2'  			4'  			5'  			6'  			6'  			5'  			7'  			6'  			7'  			3'  			6'  			3'  			2'  			1'  			5'  			4'  			0'  			1'  			4  		};  		var srcIndices = indicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  	else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  		for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		var srcIndices = spriteData.colliderIndicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int x = 0; x < tileMap.partitionSizeX; ++x) {  	int spriteId = chunkData [y * tileMap.partitionSizeX + x];  	int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  	Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  	if (spriteIdx < 0 || spriteIdx >= spriteCount)  		continue;  	if (tilePrefabs [spriteIdx])  		continue;  	bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  	bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  	bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  	bool reverseIndices = false;  	if (flipH)  		reverseIndices = !reverseIndices;  	if (flipV)  		reverseIndices = !reverseIndices;  	var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  	int baseVertexIndex = vertexList.Count;  	if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  		Vector3 origin = spriteData.colliderVertices [0];  		Vector3 extents = spriteData.colliderVertices [1];  		Vector3 min = origin - extents;  		Vector3 max = origin + extents;  		Vector3[] pos = new Vector3[8];  		pos [0] = new Vector3 (min.x' min.y' min.z);  		pos [1] = new Vector3 (min.x' min.y' max.z);  		pos [2] = new Vector3 (max.x' min.y' min.z);  		pos [3] = new Vector3 (max.x' min.y' max.z);  		pos [4] = new Vector3 (min.x' max.y' min.z);  		pos [5] = new Vector3 (min.x' max.y' max.z);  		pos [6] = new Vector3 (max.x' max.y' min.z);  		pos [7] = new Vector3 (max.x' max.y' max.z);  		for (int i = 0; i < 8; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  		int[] indicesFwd =  {  			2'  			1'  			0'  			3'  			1'  			2'  			4'  			5'  			6'  			6'  			5'  			7'  			6'  			7'  			3'  			6'  			3'  			2'  			1'  			5'  			4'  			0'  			1'  			4  		};  		var srcIndices = indicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  	else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  		for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		var srcIndices = spriteData.colliderIndicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int x = 0; x < tileMap.partitionSizeX; ++x) {  	int spriteId = chunkData [y * tileMap.partitionSizeX + x];  	int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  	Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  	if (spriteIdx < 0 || spriteIdx >= spriteCount)  		continue;  	if (tilePrefabs [spriteIdx])  		continue;  	bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  	bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  	bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  	bool reverseIndices = false;  	if (flipH)  		reverseIndices = !reverseIndices;  	if (flipV)  		reverseIndices = !reverseIndices;  	var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  	int baseVertexIndex = vertexList.Count;  	if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  		Vector3 origin = spriteData.colliderVertices [0];  		Vector3 extents = spriteData.colliderVertices [1];  		Vector3 min = origin - extents;  		Vector3 max = origin + extents;  		Vector3[] pos = new Vector3[8];  		pos [0] = new Vector3 (min.x' min.y' min.z);  		pos [1] = new Vector3 (min.x' min.y' max.z);  		pos [2] = new Vector3 (max.x' min.y' min.z);  		pos [3] = new Vector3 (max.x' min.y' max.z);  		pos [4] = new Vector3 (min.x' max.y' min.z);  		pos [5] = new Vector3 (min.x' max.y' max.z);  		pos [6] = new Vector3 (max.x' max.y' min.z);  		pos [7] = new Vector3 (max.x' max.y' max.z);  		for (int i = 0; i < 8; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  		int[] indicesFwd =  {  			2'  			1'  			0'  			3'  			1'  			2'  			4'  			5'  			6'  			6'  			5'  			7'  			6'  			7'  			3'  			6'  			3'  			2'  			1'  			5'  			4'  			0'  			1'  			4  		};  		var srcIndices = indicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  	else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  		for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		var srcIndices = spriteData.colliderIndicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int x = 0; x < tileMap.partitionSizeX; ++x) {  	int spriteId = chunkData [y * tileMap.partitionSizeX + x];  	int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  	Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  	if (spriteIdx < 0 || spriteIdx >= spriteCount)  		continue;  	if (tilePrefabs [spriteIdx])  		continue;  	bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  	bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  	bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  	bool reverseIndices = false;  	if (flipH)  		reverseIndices = !reverseIndices;  	if (flipV)  		reverseIndices = !reverseIndices;  	var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  	int baseVertexIndex = vertexList.Count;  	if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  		Vector3 origin = spriteData.colliderVertices [0];  		Vector3 extents = spriteData.colliderVertices [1];  		Vector3 min = origin - extents;  		Vector3 max = origin + extents;  		Vector3[] pos = new Vector3[8];  		pos [0] = new Vector3 (min.x' min.y' min.z);  		pos [1] = new Vector3 (min.x' min.y' max.z);  		pos [2] = new Vector3 (max.x' min.y' min.z);  		pos [3] = new Vector3 (max.x' min.y' max.z);  		pos [4] = new Vector3 (min.x' max.y' min.z);  		pos [5] = new Vector3 (min.x' max.y' max.z);  		pos [6] = new Vector3 (max.x' max.y' min.z);  		pos [7] = new Vector3 (max.x' max.y' max.z);  		for (int i = 0; i < 8; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  		int[] indicesFwd =  {  			2'  			1'  			0'  			3'  			1'  			2'  			4'  			5'  			6'  			6'  			5'  			7'  			6'  			7'  			3'  			6'  			3'  			2'  			1'  			5'  			4'  			0'  			1'  			4  		};  		var srcIndices = indicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  	else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  		for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		var srcIndices = spriteData.colliderIndicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int x = 0; x < tileMap.partitionSizeX; ++x) {  	int spriteId = chunkData [y * tileMap.partitionSizeX + x];  	int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  	Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  	if (spriteIdx < 0 || spriteIdx >= spriteCount)  		continue;  	if (tilePrefabs [spriteIdx])  		continue;  	bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  	bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  	bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  	bool reverseIndices = false;  	if (flipH)  		reverseIndices = !reverseIndices;  	if (flipV)  		reverseIndices = !reverseIndices;  	var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  	int baseVertexIndex = vertexList.Count;  	if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  		Vector3 origin = spriteData.colliderVertices [0];  		Vector3 extents = spriteData.colliderVertices [1];  		Vector3 min = origin - extents;  		Vector3 max = origin + extents;  		Vector3[] pos = new Vector3[8];  		pos [0] = new Vector3 (min.x' min.y' min.z);  		pos [1] = new Vector3 (min.x' min.y' max.z);  		pos [2] = new Vector3 (max.x' min.y' min.z);  		pos [3] = new Vector3 (max.x' min.y' max.z);  		pos [4] = new Vector3 (min.x' max.y' min.z);  		pos [5] = new Vector3 (min.x' max.y' max.z);  		pos [6] = new Vector3 (max.x' max.y' min.z);  		pos [7] = new Vector3 (max.x' max.y' max.z);  		for (int i = 0; i < 8; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  		int[] indicesFwd =  {  			2'  			1'  			0'  			3'  			1'  			2'  			4'  			5'  			6'  			6'  			5'  			7'  			6'  			7'  			3'  			6'  			3'  			2'  			1'  			5'  			4'  			0'  			1'  			4  		};  		var srcIndices = indicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  	else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  		for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		var srcIndices = spriteData.colliderIndicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int x = 0; x < tileMap.partitionSizeX; ++x) {  	int spriteId = chunkData [y * tileMap.partitionSizeX + x];  	int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  	Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  	if (spriteIdx < 0 || spriteIdx >= spriteCount)  		continue;  	if (tilePrefabs [spriteIdx])  		continue;  	bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  	bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  	bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  	bool reverseIndices = false;  	if (flipH)  		reverseIndices = !reverseIndices;  	if (flipV)  		reverseIndices = !reverseIndices;  	var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  	int baseVertexIndex = vertexList.Count;  	if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  		Vector3 origin = spriteData.colliderVertices [0];  		Vector3 extents = spriteData.colliderVertices [1];  		Vector3 min = origin - extents;  		Vector3 max = origin + extents;  		Vector3[] pos = new Vector3[8];  		pos [0] = new Vector3 (min.x' min.y' min.z);  		pos [1] = new Vector3 (min.x' min.y' max.z);  		pos [2] = new Vector3 (max.x' min.y' min.z);  		pos [3] = new Vector3 (max.x' min.y' max.z);  		pos [4] = new Vector3 (min.x' max.y' min.z);  		pos [5] = new Vector3 (min.x' max.y' max.z);  		pos [6] = new Vector3 (max.x' max.y' min.z);  		pos [7] = new Vector3 (max.x' max.y' max.z);  		for (int i = 0; i < 8; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  		int[] indicesFwd =  {  			2'  			1'  			0'  			3'  			1'  			2'  			4'  			5'  			6'  			6'  			5'  			7'  			6'  			7'  			3'  			6'  			3'  			2'  			1'  			5'  			4'  			0'  			1'  			4  		};  		var srcIndices = indicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  	else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  		for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		var srcIndices = spriteData.colliderIndicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int x = 0; x < tileMap.partitionSizeX; ++x) {  	int spriteId = chunkData [y * tileMap.partitionSizeX + x];  	int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  	Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  	if (spriteIdx < 0 || spriteIdx >= spriteCount)  		continue;  	if (tilePrefabs [spriteIdx])  		continue;  	bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  	bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  	bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  	bool reverseIndices = false;  	if (flipH)  		reverseIndices = !reverseIndices;  	if (flipV)  		reverseIndices = !reverseIndices;  	var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  	int baseVertexIndex = vertexList.Count;  	if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  		Vector3 origin = spriteData.colliderVertices [0];  		Vector3 extents = spriteData.colliderVertices [1];  		Vector3 min = origin - extents;  		Vector3 max = origin + extents;  		Vector3[] pos = new Vector3[8];  		pos [0] = new Vector3 (min.x' min.y' min.z);  		pos [1] = new Vector3 (min.x' min.y' max.z);  		pos [2] = new Vector3 (max.x' min.y' min.z);  		pos [3] = new Vector3 (max.x' min.y' max.z);  		pos [4] = new Vector3 (min.x' max.y' min.z);  		pos [5] = new Vector3 (min.x' max.y' max.z);  		pos [6] = new Vector3 (max.x' max.y' min.z);  		pos [7] = new Vector3 (max.x' max.y' max.z);  		for (int i = 0; i < 8; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  		int[] indicesFwd =  {  			2'  			1'  			0'  			3'  			1'  			2'  			4'  			5'  			6'  			6'  			5'  			7'  			6'  			7'  			3'  			6'  			3'  			2'  			1'  			5'  			4'  			0'  			1'  			4  		};  		var srcIndices = indicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  	else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  		for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		var srcIndices = spriteData.colliderIndicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int x = 0; x < tileMap.partitionSizeX; ++x) {  	int spriteId = chunkData [y * tileMap.partitionSizeX + x];  	int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  	Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  	if (spriteIdx < 0 || spriteIdx >= spriteCount)  		continue;  	if (tilePrefabs [spriteIdx])  		continue;  	bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  	bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  	bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  	bool reverseIndices = false;  	if (flipH)  		reverseIndices = !reverseIndices;  	if (flipV)  		reverseIndices = !reverseIndices;  	var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  	int baseVertexIndex = vertexList.Count;  	if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  		Vector3 origin = spriteData.colliderVertices [0];  		Vector3 extents = spriteData.colliderVertices [1];  		Vector3 min = origin - extents;  		Vector3 max = origin + extents;  		Vector3[] pos = new Vector3[8];  		pos [0] = new Vector3 (min.x' min.y' min.z);  		pos [1] = new Vector3 (min.x' min.y' max.z);  		pos [2] = new Vector3 (max.x' min.y' min.z);  		pos [3] = new Vector3 (max.x' min.y' max.z);  		pos [4] = new Vector3 (min.x' max.y' min.z);  		pos [5] = new Vector3 (min.x' max.y' max.z);  		pos [6] = new Vector3 (max.x' max.y' min.z);  		pos [7] = new Vector3 (max.x' max.y' max.z);  		for (int i = 0; i < 8; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  		int[] indicesFwd =  {  			2'  			1'  			0'  			3'  			1'  			2'  			4'  			5'  			6'  			6'  			5'  			7'  			6'  			7'  			3'  			6'  			3'  			2'  			1'  			5'  			4'  			0'  			1'  			4  		};  		var srcIndices = indicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  	else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  		for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		var srcIndices = spriteData.colliderIndicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int x = 0; x < tileMap.partitionSizeX; ++x) {  	int spriteId = chunkData [y * tileMap.partitionSizeX + x];  	int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  	Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  	if (spriteIdx < 0 || spriteIdx >= spriteCount)  		continue;  	if (tilePrefabs [spriteIdx])  		continue;  	bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  	bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  	bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  	bool reverseIndices = false;  	if (flipH)  		reverseIndices = !reverseIndices;  	if (flipV)  		reverseIndices = !reverseIndices;  	var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  	int baseVertexIndex = vertexList.Count;  	if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  		Vector3 origin = spriteData.colliderVertices [0];  		Vector3 extents = spriteData.colliderVertices [1];  		Vector3 min = origin - extents;  		Vector3 max = origin + extents;  		Vector3[] pos = new Vector3[8];  		pos [0] = new Vector3 (min.x' min.y' min.z);  		pos [1] = new Vector3 (min.x' min.y' max.z);  		pos [2] = new Vector3 (max.x' min.y' min.z);  		pos [3] = new Vector3 (max.x' min.y' max.z);  		pos [4] = new Vector3 (min.x' max.y' min.z);  		pos [5] = new Vector3 (min.x' max.y' max.z);  		pos [6] = new Vector3 (max.x' max.y' min.z);  		pos [7] = new Vector3 (max.x' max.y' max.z);  		for (int i = 0; i < 8; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  		int[] indicesFwd =  {  			2'  			1'  			0'  			3'  			1'  			2'  			4'  			5'  			6'  			6'  			5'  			7'  			6'  			7'  			3'  			6'  			3'  			2'  			1'  			5'  			4'  			0'  			1'  			4  		};  		var srcIndices = indicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  	else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  		for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		var srcIndices = spriteData.colliderIndicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int x = 0; x < tileMap.partitionSizeX; ++x) {  	int spriteId = chunkData [y * tileMap.partitionSizeX + x];  	int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  	Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  	if (spriteIdx < 0 || spriteIdx >= spriteCount)  		continue;  	if (tilePrefabs [spriteIdx])  		continue;  	bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  	bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  	bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  	bool reverseIndices = false;  	if (flipH)  		reverseIndices = !reverseIndices;  	if (flipV)  		reverseIndices = !reverseIndices;  	var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  	int baseVertexIndex = vertexList.Count;  	if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  		Vector3 origin = spriteData.colliderVertices [0];  		Vector3 extents = spriteData.colliderVertices [1];  		Vector3 min = origin - extents;  		Vector3 max = origin + extents;  		Vector3[] pos = new Vector3[8];  		pos [0] = new Vector3 (min.x' min.y' min.z);  		pos [1] = new Vector3 (min.x' min.y' max.z);  		pos [2] = new Vector3 (max.x' min.y' min.z);  		pos [3] = new Vector3 (max.x' min.y' max.z);  		pos [4] = new Vector3 (min.x' max.y' min.z);  		pos [5] = new Vector3 (min.x' max.y' max.z);  		pos [6] = new Vector3 (max.x' max.y' min.z);  		pos [7] = new Vector3 (max.x' max.y' max.z);  		for (int i = 0; i < 8; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  		int[] indicesFwd =  {  			2'  			1'  			0'  			3'  			1'  			2'  			4'  			5'  			6'  			6'  			5'  			7'  			6'  			7'  			3'  			6'  			3'  			2'  			1'  			5'  			4'  			0'  			1'  			4  		};  		var srcIndices = indicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  	else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  		for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		var srcIndices = spriteData.colliderIndicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int x = 0; x < tileMap.partitionSizeX; ++x) {  	int spriteId = chunkData [y * tileMap.partitionSizeX + x];  	int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  	Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  	if (spriteIdx < 0 || spriteIdx >= spriteCount)  		continue;  	if (tilePrefabs [spriteIdx])  		continue;  	bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  	bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  	bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  	bool reverseIndices = false;  	if (flipH)  		reverseIndices = !reverseIndices;  	if (flipV)  		reverseIndices = !reverseIndices;  	var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  	int baseVertexIndex = vertexList.Count;  	if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  		Vector3 origin = spriteData.colliderVertices [0];  		Vector3 extents = spriteData.colliderVertices [1];  		Vector3 min = origin - extents;  		Vector3 max = origin + extents;  		Vector3[] pos = new Vector3[8];  		pos [0] = new Vector3 (min.x' min.y' min.z);  		pos [1] = new Vector3 (min.x' min.y' max.z);  		pos [2] = new Vector3 (max.x' min.y' min.z);  		pos [3] = new Vector3 (max.x' min.y' max.z);  		pos [4] = new Vector3 (min.x' max.y' min.z);  		pos [5] = new Vector3 (min.x' max.y' max.z);  		pos [6] = new Vector3 (max.x' max.y' min.z);  		pos [7] = new Vector3 (max.x' max.y' max.z);  		for (int i = 0; i < 8; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  		int[] indicesFwd =  {  			2'  			1'  			0'  			3'  			1'  			2'  			4'  			5'  			6'  			6'  			5'  			7'  			6'  			7'  			3'  			6'  			3'  			2'  			1'  			5'  			4'  			0'  			1'  			4  		};  		var srcIndices = indicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  	else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  		for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		var srcIndices = spriteData.colliderIndicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int x = 0; x < tileMap.partitionSizeX; ++x) {  	int spriteId = chunkData [y * tileMap.partitionSizeX + x];  	int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  	Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  	if (spriteIdx < 0 || spriteIdx >= spriteCount)  		continue;  	if (tilePrefabs [spriteIdx])  		continue;  	bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  	bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  	bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  	bool reverseIndices = false;  	if (flipH)  		reverseIndices = !reverseIndices;  	if (flipV)  		reverseIndices = !reverseIndices;  	var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  	int baseVertexIndex = vertexList.Count;  	if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  		Vector3 origin = spriteData.colliderVertices [0];  		Vector3 extents = spriteData.colliderVertices [1];  		Vector3 min = origin - extents;  		Vector3 max = origin + extents;  		Vector3[] pos = new Vector3[8];  		pos [0] = new Vector3 (min.x' min.y' min.z);  		pos [1] = new Vector3 (min.x' min.y' max.z);  		pos [2] = new Vector3 (max.x' min.y' min.z);  		pos [3] = new Vector3 (max.x' min.y' max.z);  		pos [4] = new Vector3 (min.x' max.y' min.z);  		pos [5] = new Vector3 (min.x' max.y' max.z);  		pos [6] = new Vector3 (max.x' max.y' min.z);  		pos [7] = new Vector3 (max.x' max.y' max.z);  		for (int i = 0; i < 8; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  		int[] indicesFwd =  {  			2'  			1'  			0'  			3'  			1'  			2'  			4'  			5'  			6'  			6'  			5'  			7'  			6'  			7'  			3'  			6'  			3'  			2'  			1'  			5'  			4'  			0'  			1'  			4  		};  		var srcIndices = indicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  	else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  		for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		var srcIndices = spriteData.colliderIndicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int x = 0; x < tileMap.partitionSizeX; ++x) {  	int spriteId = chunkData [y * tileMap.partitionSizeX + x];  	int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  	Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  	if (spriteIdx < 0 || spriteIdx >= spriteCount)  		continue;  	if (tilePrefabs [spriteIdx])  		continue;  	bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  	bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  	bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  	bool reverseIndices = false;  	if (flipH)  		reverseIndices = !reverseIndices;  	if (flipV)  		reverseIndices = !reverseIndices;  	var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  	int baseVertexIndex = vertexList.Count;  	if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  		Vector3 origin = spriteData.colliderVertices [0];  		Vector3 extents = spriteData.colliderVertices [1];  		Vector3 min = origin - extents;  		Vector3 max = origin + extents;  		Vector3[] pos = new Vector3[8];  		pos [0] = new Vector3 (min.x' min.y' min.z);  		pos [1] = new Vector3 (min.x' min.y' max.z);  		pos [2] = new Vector3 (max.x' min.y' min.z);  		pos [3] = new Vector3 (max.x' min.y' max.z);  		pos [4] = new Vector3 (min.x' max.y' min.z);  		pos [5] = new Vector3 (min.x' max.y' max.z);  		pos [6] = new Vector3 (max.x' max.y' min.z);  		pos [7] = new Vector3 (max.x' max.y' max.z);  		for (int i = 0; i < 8; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  		int[] indicesFwd =  {  			2'  			1'  			0'  			3'  			1'  			2'  			4'  			5'  			6'  			6'  			5'  			7'  			6'  			7'  			3'  			6'  			3'  			2'  			1'  			5'  			4'  			0'  			1'  			4  		};  		var srcIndices = indicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  	else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  		for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		var srcIndices = spriteData.colliderIndicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int x = 0; x < tileMap.partitionSizeX; ++x) {  	int spriteId = chunkData [y * tileMap.partitionSizeX + x];  	int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  	Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  	if (spriteIdx < 0 || spriteIdx >= spriteCount)  		continue;  	if (tilePrefabs [spriteIdx])  		continue;  	bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  	bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  	bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  	bool reverseIndices = false;  	if (flipH)  		reverseIndices = !reverseIndices;  	if (flipV)  		reverseIndices = !reverseIndices;  	var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  	int baseVertexIndex = vertexList.Count;  	if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  		Vector3 origin = spriteData.colliderVertices [0];  		Vector3 extents = spriteData.colliderVertices [1];  		Vector3 min = origin - extents;  		Vector3 max = origin + extents;  		Vector3[] pos = new Vector3[8];  		pos [0] = new Vector3 (min.x' min.y' min.z);  		pos [1] = new Vector3 (min.x' min.y' max.z);  		pos [2] = new Vector3 (max.x' min.y' min.z);  		pos [3] = new Vector3 (max.x' min.y' max.z);  		pos [4] = new Vector3 (min.x' max.y' min.z);  		pos [5] = new Vector3 (min.x' max.y' max.z);  		pos [6] = new Vector3 (max.x' max.y' min.z);  		pos [7] = new Vector3 (max.x' max.y' max.z);  		for (int i = 0; i < 8; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  		int[] indicesFwd =  {  			2'  			1'  			0'  			3'  			1'  			2'  			4'  			5'  			6'  			6'  			5'  			7'  			6'  			7'  			3'  			6'  			3'  			2'  			1'  			5'  			4'  			0'  			1'  			4  		};  		var srcIndices = indicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  	else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  		for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		var srcIndices = spriteData.colliderIndicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int x = 0; x < tileMap.partitionSizeX; ++x) {  	int spriteId = chunkData [y * tileMap.partitionSizeX + x];  	int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  	Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  	if (spriteIdx < 0 || spriteIdx >= spriteCount)  		continue;  	if (tilePrefabs [spriteIdx])  		continue;  	bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  	bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  	bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  	bool reverseIndices = false;  	if (flipH)  		reverseIndices = !reverseIndices;  	if (flipV)  		reverseIndices = !reverseIndices;  	var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  	int baseVertexIndex = vertexList.Count;  	if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  		Vector3 origin = spriteData.colliderVertices [0];  		Vector3 extents = spriteData.colliderVertices [1];  		Vector3 min = origin - extents;  		Vector3 max = origin + extents;  		Vector3[] pos = new Vector3[8];  		pos [0] = new Vector3 (min.x' min.y' min.z);  		pos [1] = new Vector3 (min.x' min.y' max.z);  		pos [2] = new Vector3 (max.x' min.y' min.z);  		pos [3] = new Vector3 (max.x' min.y' max.z);  		pos [4] = new Vector3 (min.x' max.y' min.z);  		pos [5] = new Vector3 (min.x' max.y' max.z);  		pos [6] = new Vector3 (max.x' max.y' min.z);  		pos [7] = new Vector3 (max.x' max.y' max.z);  		for (int i = 0; i < 8; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  		int[] indicesFwd =  {  			2'  			1'  			0'  			3'  			1'  			2'  			4'  			5'  			6'  			6'  			5'  			7'  			6'  			7'  			3'  			6'  			3'  			2'  			1'  			5'  			4'  			0'  			1'  			4  		};  		var srcIndices = indicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  	else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  		for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		var srcIndices = spriteData.colliderIndicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int x = 0; x < tileMap.partitionSizeX; ++x) {  	int spriteId = chunkData [y * tileMap.partitionSizeX + x];  	int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  	Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  	if (spriteIdx < 0 || spriteIdx >= spriteCount)  		continue;  	if (tilePrefabs [spriteIdx])  		continue;  	bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  	bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  	bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  	bool reverseIndices = false;  	if (flipH)  		reverseIndices = !reverseIndices;  	if (flipV)  		reverseIndices = !reverseIndices;  	var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  	int baseVertexIndex = vertexList.Count;  	if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  		Vector3 origin = spriteData.colliderVertices [0];  		Vector3 extents = spriteData.colliderVertices [1];  		Vector3 min = origin - extents;  		Vector3 max = origin + extents;  		Vector3[] pos = new Vector3[8];  		pos [0] = new Vector3 (min.x' min.y' min.z);  		pos [1] = new Vector3 (min.x' min.y' max.z);  		pos [2] = new Vector3 (max.x' min.y' min.z);  		pos [3] = new Vector3 (max.x' min.y' max.z);  		pos [4] = new Vector3 (min.x' max.y' min.z);  		pos [5] = new Vector3 (min.x' max.y' max.z);  		pos [6] = new Vector3 (max.x' max.y' min.z);  		pos [7] = new Vector3 (max.x' max.y' max.z);  		for (int i = 0; i < 8; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  		int[] indicesFwd =  {  			2'  			1'  			0'  			3'  			1'  			2'  			4'  			5'  			6'  			6'  			5'  			7'  			6'  			7'  			3'  			6'  			3'  			2'  			1'  			5'  			4'  			0'  			1'  			4  		};  		var srcIndices = indicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  	else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  		for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		var srcIndices = spriteData.colliderIndicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int x = 0; x < tileMap.partitionSizeX; ++x) {  	int spriteId = chunkData [y * tileMap.partitionSizeX + x];  	int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  	Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  	if (spriteIdx < 0 || spriteIdx >= spriteCount)  		continue;  	if (tilePrefabs [spriteIdx])  		continue;  	bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  	bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  	bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  	bool reverseIndices = false;  	if (flipH)  		reverseIndices = !reverseIndices;  	if (flipV)  		reverseIndices = !reverseIndices;  	var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  	int baseVertexIndex = vertexList.Count;  	if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  		Vector3 origin = spriteData.colliderVertices [0];  		Vector3 extents = spriteData.colliderVertices [1];  		Vector3 min = origin - extents;  		Vector3 max = origin + extents;  		Vector3[] pos = new Vector3[8];  		pos [0] = new Vector3 (min.x' min.y' min.z);  		pos [1] = new Vector3 (min.x' min.y' max.z);  		pos [2] = new Vector3 (max.x' min.y' min.z);  		pos [3] = new Vector3 (max.x' min.y' max.z);  		pos [4] = new Vector3 (min.x' max.y' min.z);  		pos [5] = new Vector3 (min.x' max.y' max.z);  		pos [6] = new Vector3 (max.x' max.y' min.z);  		pos [7] = new Vector3 (max.x' max.y' max.z);  		for (int i = 0; i < 8; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  		int[] indicesFwd =  {  			2'  			1'  			0'  			3'  			1'  			2'  			4'  			5'  			6'  			6'  			5'  			7'  			6'  			7'  			3'  			6'  			3'  			2'  			1'  			5'  			4'  			0'  			1'  			4  		};  		var srcIndices = indicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  	else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  		for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		var srcIndices = spriteData.colliderIndicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  	Vector3 origin = spriteData.colliderVertices [0];  	Vector3 extents = spriteData.colliderVertices [1];  	Vector3 min = origin - extents;  	Vector3 max = origin + extents;  	Vector3[] pos = new Vector3[8];  	pos [0] = new Vector3 (min.x' min.y' min.z);  	pos [1] = new Vector3 (min.x' min.y' max.z);  	pos [2] = new Vector3 (max.x' min.y' min.z);  	pos [3] = new Vector3 (max.x' min.y' max.z);  	pos [4] = new Vector3 (min.x' max.y' min.z);  	pos [5] = new Vector3 (min.x' max.y' max.z);  	pos [6] = new Vector3 (max.x' max.y' min.z);  	pos [7] = new Vector3 (max.x' max.y' max.z);  	for (int i = 0; i < 8; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  	int[] indicesFwd =  {  		2'  		1'  		0'  		3'  		1'  		2'  		4'  		5'  		6'  		6'  		5'  		7'  		6'  		7'  		3'  		6'  		3'  		2'  		1'  		5'  		4'  		0'  		1'  		4  	};  	var srcIndices = indicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  	for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	var srcIndices = spriteData.colliderIndicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  	Vector3 origin = spriteData.colliderVertices [0];  	Vector3 extents = spriteData.colliderVertices [1];  	Vector3 min = origin - extents;  	Vector3 max = origin + extents;  	Vector3[] pos = new Vector3[8];  	pos [0] = new Vector3 (min.x' min.y' min.z);  	pos [1] = new Vector3 (min.x' min.y' max.z);  	pos [2] = new Vector3 (max.x' min.y' min.z);  	pos [3] = new Vector3 (max.x' min.y' max.z);  	pos [4] = new Vector3 (min.x' max.y' min.z);  	pos [5] = new Vector3 (min.x' max.y' max.z);  	pos [6] = new Vector3 (max.x' max.y' min.z);  	pos [7] = new Vector3 (max.x' max.y' max.z);  	for (int i = 0; i < 8; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  	int[] indicesFwd =  {  		2'  		1'  		0'  		3'  		1'  		2'  		4'  		5'  		6'  		6'  		5'  		7'  		6'  		7'  		3'  		6'  		3'  		2'  		1'  		5'  		4'  		0'  		1'  		4  	};  	var srcIndices = indicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  	for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	var srcIndices = spriteData.colliderIndicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  	Vector3 origin = spriteData.colliderVertices [0];  	Vector3 extents = spriteData.colliderVertices [1];  	Vector3 min = origin - extents;  	Vector3 max = origin + extents;  	Vector3[] pos = new Vector3[8];  	pos [0] = new Vector3 (min.x' min.y' min.z);  	pos [1] = new Vector3 (min.x' min.y' max.z);  	pos [2] = new Vector3 (max.x' min.y' min.z);  	pos [3] = new Vector3 (max.x' min.y' max.z);  	pos [4] = new Vector3 (min.x' max.y' min.z);  	pos [5] = new Vector3 (min.x' max.y' max.z);  	pos [6] = new Vector3 (max.x' max.y' min.z);  	pos [7] = new Vector3 (max.x' max.y' max.z);  	for (int i = 0; i < 8; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  	int[] indicesFwd =  {  		2'  		1'  		0'  		3'  		1'  		2'  		4'  		5'  		6'  		6'  		5'  		7'  		6'  		7'  		3'  		6'  		3'  		2'  		1'  		5'  		4'  		0'  		1'  		4  	};  	var srcIndices = indicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  	for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	var srcIndices = spriteData.colliderIndicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  	Vector3 origin = spriteData.colliderVertices [0];  	Vector3 extents = spriteData.colliderVertices [1];  	Vector3 min = origin - extents;  	Vector3 max = origin + extents;  	Vector3[] pos = new Vector3[8];  	pos [0] = new Vector3 (min.x' min.y' min.z);  	pos [1] = new Vector3 (min.x' min.y' max.z);  	pos [2] = new Vector3 (max.x' min.y' min.z);  	pos [3] = new Vector3 (max.x' min.y' max.z);  	pos [4] = new Vector3 (min.x' max.y' min.z);  	pos [5] = new Vector3 (min.x' max.y' max.z);  	pos [6] = new Vector3 (max.x' max.y' min.z);  	pos [7] = new Vector3 (max.x' max.y' max.z);  	for (int i = 0; i < 8; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  	int[] indicesFwd =  {  		2'  		1'  		0'  		3'  		1'  		2'  		4'  		5'  		6'  		6'  		5'  		7'  		6'  		7'  		3'  		6'  		3'  		2'  		1'  		5'  		4'  		0'  		1'  		4  	};  	var srcIndices = indicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  	for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	var srcIndices = spriteData.colliderIndicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  	Vector3 origin = spriteData.colliderVertices [0];  	Vector3 extents = spriteData.colliderVertices [1];  	Vector3 min = origin - extents;  	Vector3 max = origin + extents;  	Vector3[] pos = new Vector3[8];  	pos [0] = new Vector3 (min.x' min.y' min.z);  	pos [1] = new Vector3 (min.x' min.y' max.z);  	pos [2] = new Vector3 (max.x' min.y' min.z);  	pos [3] = new Vector3 (max.x' min.y' max.z);  	pos [4] = new Vector3 (min.x' max.y' min.z);  	pos [5] = new Vector3 (min.x' max.y' max.z);  	pos [6] = new Vector3 (max.x' max.y' min.z);  	pos [7] = new Vector3 (max.x' max.y' max.z);  	for (int i = 0; i < 8; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  	int[] indicesFwd =  {  		2'  		1'  		0'  		3'  		1'  		2'  		4'  		5'  		6'  		6'  		5'  		7'  		6'  		7'  		3'  		6'  		3'  		2'  		1'  		5'  		4'  		0'  		1'  		4  	};  	var srcIndices = indicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  	for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	var srcIndices = spriteData.colliderIndicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  	Vector3 origin = spriteData.colliderVertices [0];  	Vector3 extents = spriteData.colliderVertices [1];  	Vector3 min = origin - extents;  	Vector3 max = origin + extents;  	Vector3[] pos = new Vector3[8];  	pos [0] = new Vector3 (min.x' min.y' min.z);  	pos [1] = new Vector3 (min.x' min.y' max.z);  	pos [2] = new Vector3 (max.x' min.y' min.z);  	pos [3] = new Vector3 (max.x' min.y' max.z);  	pos [4] = new Vector3 (min.x' max.y' min.z);  	pos [5] = new Vector3 (min.x' max.y' max.z);  	pos [6] = new Vector3 (max.x' max.y' min.z);  	pos [7] = new Vector3 (max.x' max.y' max.z);  	for (int i = 0; i < 8; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  	int[] indicesFwd =  {  		2'  		1'  		0'  		3'  		1'  		2'  		4'  		5'  		6'  		6'  		5'  		7'  		6'  		7'  		3'  		6'  		3'  		2'  		1'  		5'  		4'  		0'  		1'  		4  	};  	var srcIndices = indicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  	for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	var srcIndices = spriteData.colliderIndicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  	Vector3 origin = spriteData.colliderVertices [0];  	Vector3 extents = spriteData.colliderVertices [1];  	Vector3 min = origin - extents;  	Vector3 max = origin + extents;  	Vector3[] pos = new Vector3[8];  	pos [0] = new Vector3 (min.x' min.y' min.z);  	pos [1] = new Vector3 (min.x' min.y' max.z);  	pos [2] = new Vector3 (max.x' min.y' min.z);  	pos [3] = new Vector3 (max.x' min.y' max.z);  	pos [4] = new Vector3 (min.x' max.y' min.z);  	pos [5] = new Vector3 (min.x' max.y' max.z);  	pos [6] = new Vector3 (max.x' max.y' min.z);  	pos [7] = new Vector3 (max.x' max.y' max.z);  	for (int i = 0; i < 8; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  	int[] indicesFwd =  {  		2'  		1'  		0'  		3'  		1'  		2'  		4'  		5'  		6'  		6'  		5'  		7'  		6'  		7'  		3'  		6'  		3'  		2'  		1'  		5'  		4'  		0'  		1'  		4  	};  	var srcIndices = indicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  	for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	var srcIndices = spriteData.colliderIndicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  	Vector3 origin = spriteData.colliderVertices [0];  	Vector3 extents = spriteData.colliderVertices [1];  	Vector3 min = origin - extents;  	Vector3 max = origin + extents;  	Vector3[] pos = new Vector3[8];  	pos [0] = new Vector3 (min.x' min.y' min.z);  	pos [1] = new Vector3 (min.x' min.y' max.z);  	pos [2] = new Vector3 (max.x' min.y' min.z);  	pos [3] = new Vector3 (max.x' min.y' max.z);  	pos [4] = new Vector3 (min.x' max.y' min.z);  	pos [5] = new Vector3 (min.x' max.y' max.z);  	pos [6] = new Vector3 (max.x' max.y' min.z);  	pos [7] = new Vector3 (max.x' max.y' max.z);  	for (int i = 0; i < 8; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  	int[] indicesFwd =  {  		2'  		1'  		0'  		3'  		1'  		2'  		4'  		5'  		6'  		6'  		5'  		7'  		6'  		7'  		3'  		6'  		3'  		2'  		1'  		5'  		4'  		0'  		1'  		4  	};  	var srcIndices = indicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  	for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	var srcIndices = spriteData.colliderIndicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  	Vector3 origin = spriteData.colliderVertices [0];  	Vector3 extents = spriteData.colliderVertices [1];  	Vector3 min = origin - extents;  	Vector3 max = origin + extents;  	Vector3[] pos = new Vector3[8];  	pos [0] = new Vector3 (min.x' min.y' min.z);  	pos [1] = new Vector3 (min.x' min.y' max.z);  	pos [2] = new Vector3 (max.x' min.y' min.z);  	pos [3] = new Vector3 (max.x' min.y' max.z);  	pos [4] = new Vector3 (min.x' max.y' min.z);  	pos [5] = new Vector3 (min.x' max.y' max.z);  	pos [6] = new Vector3 (max.x' max.y' min.z);  	pos [7] = new Vector3 (max.x' max.y' max.z);  	for (int i = 0; i < 8; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  	int[] indicesFwd =  {  		2'  		1'  		0'  		3'  		1'  		2'  		4'  		5'  		6'  		6'  		5'  		7'  		6'  		7'  		3'  		6'  		3'  		2'  		1'  		5'  		4'  		0'  		1'  		4  	};  	var srcIndices = indicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  	for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	var srcIndices = spriteData.colliderIndicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  	Vector3 origin = spriteData.colliderVertices [0];  	Vector3 extents = spriteData.colliderVertices [1];  	Vector3 min = origin - extents;  	Vector3 max = origin + extents;  	Vector3[] pos = new Vector3[8];  	pos [0] = new Vector3 (min.x' min.y' min.z);  	pos [1] = new Vector3 (min.x' min.y' max.z);  	pos [2] = new Vector3 (max.x' min.y' min.z);  	pos [3] = new Vector3 (max.x' min.y' max.z);  	pos [4] = new Vector3 (min.x' max.y' min.z);  	pos [5] = new Vector3 (min.x' max.y' max.z);  	pos [6] = new Vector3 (max.x' max.y' min.z);  	pos [7] = new Vector3 (max.x' max.y' max.z);  	for (int i = 0; i < 8; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  	int[] indicesFwd =  {  		2'  		1'  		0'  		3'  		1'  		2'  		4'  		5'  		6'  		6'  		5'  		7'  		6'  		7'  		3'  		6'  		3'  		2'  		1'  		5'  		4'  		0'  		1'  		4  	};  	var srcIndices = indicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  	for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	var srcIndices = spriteData.colliderIndicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  	Vector3 origin = spriteData.colliderVertices [0];  	Vector3 extents = spriteData.colliderVertices [1];  	Vector3 min = origin - extents;  	Vector3 max = origin + extents;  	Vector3[] pos = new Vector3[8];  	pos [0] = new Vector3 (min.x' min.y' min.z);  	pos [1] = new Vector3 (min.x' min.y' max.z);  	pos [2] = new Vector3 (max.x' min.y' min.z);  	pos [3] = new Vector3 (max.x' min.y' max.z);  	pos [4] = new Vector3 (min.x' max.y' min.z);  	pos [5] = new Vector3 (min.x' max.y' max.z);  	pos [6] = new Vector3 (max.x' max.y' min.z);  	pos [7] = new Vector3 (max.x' max.y' max.z);  	for (int i = 0; i < 8; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  	int[] indicesFwd =  {  		2'  		1'  		0'  		3'  		1'  		2'  		4'  		5'  		6'  		6'  		5'  		7'  		6'  		7'  		3'  		6'  		3'  		2'  		1'  		5'  		4'  		0'  		1'  		4  	};  	var srcIndices = indicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  	for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	var srcIndices = spriteData.colliderIndicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  	Vector3 origin = spriteData.colliderVertices [0];  	Vector3 extents = spriteData.colliderVertices [1];  	Vector3 min = origin - extents;  	Vector3 max = origin + extents;  	Vector3[] pos = new Vector3[8];  	pos [0] = new Vector3 (min.x' min.y' min.z);  	pos [1] = new Vector3 (min.x' min.y' max.z);  	pos [2] = new Vector3 (max.x' min.y' min.z);  	pos [3] = new Vector3 (max.x' min.y' max.z);  	pos [4] = new Vector3 (min.x' max.y' min.z);  	pos [5] = new Vector3 (min.x' max.y' max.z);  	pos [6] = new Vector3 (max.x' max.y' min.z);  	pos [7] = new Vector3 (max.x' max.y' max.z);  	for (int i = 0; i < 8; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  	int[] indicesFwd =  {  		2'  		1'  		0'  		3'  		1'  		2'  		4'  		5'  		6'  		6'  		5'  		7'  		6'  		7'  		3'  		6'  		3'  		2'  		1'  		5'  		4'  		0'  		1'  		4  	};  	var srcIndices = indicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  	for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	var srcIndices = spriteData.colliderIndicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  	Vector3 origin = spriteData.colliderVertices [0];  	Vector3 extents = spriteData.colliderVertices [1];  	Vector3 min = origin - extents;  	Vector3 max = origin + extents;  	Vector3[] pos = new Vector3[8];  	pos [0] = new Vector3 (min.x' min.y' min.z);  	pos [1] = new Vector3 (min.x' min.y' max.z);  	pos [2] = new Vector3 (max.x' min.y' min.z);  	pos [3] = new Vector3 (max.x' min.y' max.z);  	pos [4] = new Vector3 (min.x' max.y' min.z);  	pos [5] = new Vector3 (min.x' max.y' max.z);  	pos [6] = new Vector3 (max.x' max.y' min.z);  	pos [7] = new Vector3 (max.x' max.y' max.z);  	for (int i = 0; i < 8; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  	int[] indicesFwd =  {  		2'  		1'  		0'  		3'  		1'  		2'  		4'  		5'  		6'  		6'  		5'  		7'  		6'  		7'  		3'  		6'  		3'  		2'  		1'  		5'  		4'  		0'  		1'  		4  	};  	var srcIndices = indicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  	for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	var srcIndices = spriteData.colliderIndicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  	Vector3 origin = spriteData.colliderVertices [0];  	Vector3 extents = spriteData.colliderVertices [1];  	Vector3 min = origin - extents;  	Vector3 max = origin + extents;  	Vector3[] pos = new Vector3[8];  	pos [0] = new Vector3 (min.x' min.y' min.z);  	pos [1] = new Vector3 (min.x' min.y' max.z);  	pos [2] = new Vector3 (max.x' min.y' min.z);  	pos [3] = new Vector3 (max.x' min.y' max.z);  	pos [4] = new Vector3 (min.x' max.y' min.z);  	pos [5] = new Vector3 (min.x' max.y' max.z);  	pos [6] = new Vector3 (max.x' max.y' min.z);  	pos [7] = new Vector3 (max.x' max.y' max.z);  	for (int i = 0; i < 8; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  	int[] indicesFwd =  {  		2'  		1'  		0'  		3'  		1'  		2'  		4'  		5'  		6'  		6'  		5'  		7'  		6'  		7'  		3'  		6'  		3'  		2'  		1'  		5'  		4'  		0'  		1'  		4  	};  	var srcIndices = indicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  	for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	var srcIndices = spriteData.colliderIndicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  	Vector3 origin = spriteData.colliderVertices [0];  	Vector3 extents = spriteData.colliderVertices [1];  	Vector3 min = origin - extents;  	Vector3 max = origin + extents;  	Vector3[] pos = new Vector3[8];  	pos [0] = new Vector3 (min.x' min.y' min.z);  	pos [1] = new Vector3 (min.x' min.y' max.z);  	pos [2] = new Vector3 (max.x' min.y' min.z);  	pos [3] = new Vector3 (max.x' min.y' max.z);  	pos [4] = new Vector3 (min.x' max.y' min.z);  	pos [5] = new Vector3 (min.x' max.y' max.z);  	pos [6] = new Vector3 (max.x' max.y' min.z);  	pos [7] = new Vector3 (max.x' max.y' max.z);  	for (int i = 0; i < 8; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  	int[] indicesFwd =  {  		2'  		1'  		0'  		3'  		1'  		2'  		4'  		5'  		6'  		6'  		5'  		7'  		6'  		7'  		3'  		6'  		3'  		2'  		1'  		5'  		4'  		0'  		1'  		4  	};  	var srcIndices = indicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  	for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	var srcIndices = spriteData.colliderIndicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  	Vector3 origin = spriteData.colliderVertices [0];  	Vector3 extents = spriteData.colliderVertices [1];  	Vector3 min = origin - extents;  	Vector3 max = origin + extents;  	Vector3[] pos = new Vector3[8];  	pos [0] = new Vector3 (min.x' min.y' min.z);  	pos [1] = new Vector3 (min.x' min.y' max.z);  	pos [2] = new Vector3 (max.x' min.y' min.z);  	pos [3] = new Vector3 (max.x' min.y' max.z);  	pos [4] = new Vector3 (min.x' max.y' min.z);  	pos [5] = new Vector3 (min.x' max.y' max.z);  	pos [6] = new Vector3 (max.x' max.y' min.z);  	pos [7] = new Vector3 (max.x' max.y' max.z);  	for (int i = 0; i < 8; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  	int[] indicesFwd =  {  		2'  		1'  		0'  		3'  		1'  		2'  		4'  		5'  		6'  		6'  		5'  		7'  		6'  		7'  		3'  		6'  		3'  		2'  		1'  		5'  		4'  		0'  		1'  		4  	};  	var srcIndices = indicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  	for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	var srcIndices = spriteData.colliderIndicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  	Vector3 origin = spriteData.colliderVertices [0];  	Vector3 extents = spriteData.colliderVertices [1];  	Vector3 min = origin - extents;  	Vector3 max = origin + extents;  	Vector3[] pos = new Vector3[8];  	pos [0] = new Vector3 (min.x' min.y' min.z);  	pos [1] = new Vector3 (min.x' min.y' max.z);  	pos [2] = new Vector3 (max.x' min.y' min.z);  	pos [3] = new Vector3 (max.x' min.y' max.z);  	pos [4] = new Vector3 (min.x' max.y' min.z);  	pos [5] = new Vector3 (min.x' max.y' max.z);  	pos [6] = new Vector3 (max.x' max.y' min.z);  	pos [7] = new Vector3 (max.x' max.y' max.z);  	for (int i = 0; i < 8; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  	int[] indicesFwd =  {  		2'  		1'  		0'  		3'  		1'  		2'  		4'  		5'  		6'  		6'  		5'  		7'  		6'  		7'  		3'  		6'  		3'  		2'  		1'  		5'  		4'  		0'  		1'  		4  	};  	var srcIndices = indicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  	for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	var srcIndices = spriteData.colliderIndicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  	Vector3 origin = spriteData.colliderVertices [0];  	Vector3 extents = spriteData.colliderVertices [1];  	Vector3 min = origin - extents;  	Vector3 max = origin + extents;  	Vector3[] pos = new Vector3[8];  	pos [0] = new Vector3 (min.x' min.y' min.z);  	pos [1] = new Vector3 (min.x' min.y' max.z);  	pos [2] = new Vector3 (max.x' min.y' min.z);  	pos [3] = new Vector3 (max.x' min.y' max.z);  	pos [4] = new Vector3 (min.x' max.y' min.z);  	pos [5] = new Vector3 (min.x' max.y' max.z);  	pos [6] = new Vector3 (max.x' max.y' min.z);  	pos [7] = new Vector3 (max.x' max.y' max.z);  	for (int i = 0; i < 8; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  	int[] indicesFwd =  {  		2'  		1'  		0'  		3'  		1'  		2'  		4'  		5'  		6'  		6'  		5'  		7'  		6'  		7'  		3'  		6'  		3'  		2'  		1'  		5'  		4'  		0'  		1'  		4  	};  	var srcIndices = indicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  	for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	var srcIndices = spriteData.colliderIndicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  	Vector3 origin = spriteData.colliderVertices [0];  	Vector3 extents = spriteData.colliderVertices [1];  	Vector3 min = origin - extents;  	Vector3 max = origin + extents;  	Vector3[] pos = new Vector3[8];  	pos [0] = new Vector3 (min.x' min.y' min.z);  	pos [1] = new Vector3 (min.x' min.y' max.z);  	pos [2] = new Vector3 (max.x' min.y' min.z);  	pos [3] = new Vector3 (max.x' min.y' max.z);  	pos [4] = new Vector3 (min.x' max.y' min.z);  	pos [5] = new Vector3 (min.x' max.y' max.z);  	pos [6] = new Vector3 (max.x' max.y' min.z);  	pos [7] = new Vector3 (max.x' max.y' max.z);  	for (int i = 0; i < 8; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  	int[] indicesFwd =  {  		2'  		1'  		0'  		3'  		1'  		2'  		4'  		5'  		6'  		6'  		5'  		7'  		6'  		7'  		3'  		6'  		3'  		2'  		1'  		5'  		4'  		0'  		1'  		4  	};  	var srcIndices = indicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  	for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	var srcIndices = spriteData.colliderIndicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  	Vector3 origin = spriteData.colliderVertices [0];  	Vector3 extents = spriteData.colliderVertices [1];  	Vector3 min = origin - extents;  	Vector3 max = origin + extents;  	Vector3[] pos = new Vector3[8];  	pos [0] = new Vector3 (min.x' min.y' min.z);  	pos [1] = new Vector3 (min.x' min.y' max.z);  	pos [2] = new Vector3 (max.x' min.y' min.z);  	pos [3] = new Vector3 (max.x' min.y' max.z);  	pos [4] = new Vector3 (min.x' max.y' min.z);  	pos [5] = new Vector3 (min.x' max.y' max.z);  	pos [6] = new Vector3 (max.x' max.y' min.z);  	pos [7] = new Vector3 (max.x' max.y' max.z);  	for (int i = 0; i < 8; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  	int[] indicesFwd =  {  		2'  		1'  		0'  		3'  		1'  		2'  		4'  		5'  		6'  		6'  		5'  		7'  		6'  		7'  		3'  		6'  		3'  		2'  		1'  		5'  		4'  		0'  		1'  		4  	};  	var srcIndices = indicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  	for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	var srcIndices = spriteData.colliderIndicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  	Vector3 origin = spriteData.colliderVertices [0];  	Vector3 extents = spriteData.colliderVertices [1];  	Vector3 min = origin - extents;  	Vector3 max = origin + extents;  	Vector3[] pos = new Vector3[8];  	pos [0] = new Vector3 (min.x' min.y' min.z);  	pos [1] = new Vector3 (min.x' min.y' max.z);  	pos [2] = new Vector3 (max.x' min.y' min.z);  	pos [3] = new Vector3 (max.x' min.y' max.z);  	pos [4] = new Vector3 (min.x' max.y' min.z);  	pos [5] = new Vector3 (min.x' max.y' max.z);  	pos [6] = new Vector3 (max.x' max.y' min.z);  	pos [7] = new Vector3 (max.x' max.y' max.z);  	for (int i = 0; i < 8; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  	int[] indicesFwd =  {  		2'  		1'  		0'  		3'  		1'  		2'  		4'  		5'  		6'  		6'  		5'  		7'  		6'  		7'  		3'  		6'  		3'  		2'  		1'  		5'  		4'  		0'  		1'  		4  	};  	var srcIndices = indicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  	for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	var srcIndices = spriteData.colliderIndicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  	Vector3 origin = spriteData.colliderVertices [0];  	Vector3 extents = spriteData.colliderVertices [1];  	Vector3 min = origin - extents;  	Vector3 max = origin + extents;  	Vector3[] pos = new Vector3[8];  	pos [0] = new Vector3 (min.x' min.y' min.z);  	pos [1] = new Vector3 (min.x' min.y' max.z);  	pos [2] = new Vector3 (max.x' min.y' min.z);  	pos [3] = new Vector3 (max.x' min.y' max.z);  	pos [4] = new Vector3 (min.x' max.y' min.z);  	pos [5] = new Vector3 (min.x' max.y' max.z);  	pos [6] = new Vector3 (max.x' max.y' min.z);  	pos [7] = new Vector3 (max.x' max.y' max.z);  	for (int i = 0; i < 8; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  	int[] indicesFwd =  {  		2'  		1'  		0'  		3'  		1'  		2'  		4'  		5'  		6'  		6'  		5'  		7'  		6'  		7'  		3'  		6'  		3'  		2'  		1'  		5'  		4'  		0'  		1'  		4  	};  	var srcIndices = indicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  	for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	var srcIndices = spriteData.colliderIndicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  	Vector3 origin = spriteData.colliderVertices [0];  	Vector3 extents = spriteData.colliderVertices [1];  	Vector3 min = origin - extents;  	Vector3 max = origin + extents;  	Vector3[] pos = new Vector3[8];  	pos [0] = new Vector3 (min.x' min.y' min.z);  	pos [1] = new Vector3 (min.x' min.y' max.z);  	pos [2] = new Vector3 (max.x' min.y' min.z);  	pos [3] = new Vector3 (max.x' min.y' max.z);  	pos [4] = new Vector3 (min.x' max.y' min.z);  	pos [5] = new Vector3 (min.x' max.y' max.z);  	pos [6] = new Vector3 (max.x' max.y' min.z);  	pos [7] = new Vector3 (max.x' max.y' max.z);  	for (int i = 0; i < 8; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  	int[] indicesFwd =  {  		2'  		1'  		0'  		3'  		1'  		2'  		4'  		5'  		6'  		6'  		5'  		7'  		6'  		7'  		3'  		6'  		3'  		2'  		1'  		5'  		4'  		0'  		1'  		4  	};  	var srcIndices = indicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  	for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	var srcIndices = spriteData.colliderIndicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  	Vector3 origin = spriteData.colliderVertices [0];  	Vector3 extents = spriteData.colliderVertices [1];  	Vector3 min = origin - extents;  	Vector3 max = origin + extents;  	Vector3[] pos = new Vector3[8];  	pos [0] = new Vector3 (min.x' min.y' min.z);  	pos [1] = new Vector3 (min.x' min.y' max.z);  	pos [2] = new Vector3 (max.x' min.y' min.z);  	pos [3] = new Vector3 (max.x' min.y' max.z);  	pos [4] = new Vector3 (min.x' max.y' min.z);  	pos [5] = new Vector3 (min.x' max.y' max.z);  	pos [6] = new Vector3 (max.x' max.y' min.z);  	pos [7] = new Vector3 (max.x' max.y' max.z);  	for (int i = 0; i < 8; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  	int[] indicesFwd =  {  		2'  		1'  		0'  		3'  		1'  		2'  		4'  		5'  		6'  		6'  		5'  		7'  		6'  		7'  		3'  		6'  		3'  		2'  		1'  		5'  		4'  		0'  		1'  		4  	};  	var srcIndices = indicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  	for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	var srcIndices = spriteData.colliderIndicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  	Vector3 origin = spriteData.colliderVertices [0];  	Vector3 extents = spriteData.colliderVertices [1];  	Vector3 min = origin - extents;  	Vector3 max = origin + extents;  	Vector3[] pos = new Vector3[8];  	pos [0] = new Vector3 (min.x' min.y' min.z);  	pos [1] = new Vector3 (min.x' min.y' max.z);  	pos [2] = new Vector3 (max.x' min.y' min.z);  	pos [3] = new Vector3 (max.x' min.y' max.z);  	pos [4] = new Vector3 (min.x' max.y' min.z);  	pos [5] = new Vector3 (min.x' max.y' max.z);  	pos [6] = new Vector3 (max.x' max.y' min.z);  	pos [7] = new Vector3 (max.x' max.y' max.z);  	for (int i = 0; i < 8; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  	int[] indicesFwd =  {  		2'  		1'  		0'  		3'  		1'  		2'  		4'  		5'  		6'  		6'  		5'  		7'  		6'  		7'  		3'  		6'  		3'  		2'  		1'  		5'  		4'  		0'  		1'  		4  	};  	var srcIndices = indicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  	for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	var srcIndices = spriteData.colliderIndicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  	Vector3 origin = spriteData.colliderVertices [0];  	Vector3 extents = spriteData.colliderVertices [1];  	Vector3 min = origin - extents;  	Vector3 max = origin + extents;  	Vector3[] pos = new Vector3[8];  	pos [0] = new Vector3 (min.x' min.y' min.z);  	pos [1] = new Vector3 (min.x' min.y' max.z);  	pos [2] = new Vector3 (max.x' min.y' min.z);  	pos [3] = new Vector3 (max.x' min.y' max.z);  	pos [4] = new Vector3 (min.x' max.y' min.z);  	pos [5] = new Vector3 (min.x' max.y' max.z);  	pos [6] = new Vector3 (max.x' max.y' min.z);  	pos [7] = new Vector3 (max.x' max.y' max.z);  	for (int i = 0; i < 8; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  	int[] indicesFwd =  {  		2'  		1'  		0'  		3'  		1'  		2'  		4'  		5'  		6'  		6'  		5'  		7'  		6'  		7'  		3'  		6'  		3'  		2'  		1'  		5'  		4'  		0'  		1'  		4  	};  	var srcIndices = indicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  	for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	var srcIndices = spriteData.colliderIndicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: pos [2] = new Vector3 (max.x' min.y' min.z);  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: pos [3] = new Vector3 (max.x' min.y' max.z);  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: pos [4] = new Vector3 (min.x' max.y' min.z);  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: pos [5] = new Vector3 (min.x' max.y' max.z);  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: pos [6] = new Vector3 (max.x' max.y' min.z);  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: pos [7] = new Vector3 (max.x' max.y' max.z);  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int i = 0; i < 8; ++i) {  	Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  	vertexList.Add (flippedPos + currentPos);  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,CompareDuplicateFaces,The following statement contains a magic number: for (int i = 0; i < 3; ++i) {  	int d = indices [face0index + i] - indices [face1index + i];  	if (d != 0)  		return d;  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,RemoveDuplicateFaces,The following statement contains a magic number: for (int i = 0; i < indices.Length; i += 3) {  	int[] faceIndices =  {  		indices [i]'  		indices [i + 1]'  		indices [i + 2]  	};  	System.Array.Sort (faceIndices);  	sortedFaceIndices [i] = faceIndices [0];  	sortedFaceIndices [i + 1] = faceIndices [1];  	sortedFaceIndices [i + 2] = faceIndices [2];  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,RemoveDuplicateFaces,The following statement contains a magic number: for (int i = 0; i < indices.Length; i += 3) {  	int[] faceIndices =  {  		indices [i]'  		indices [i + 1]'  		indices [i + 2]  	};  	System.Array.Sort (faceIndices);  	sortedFaceIndices [i] = faceIndices [0];  	sortedFaceIndices [i + 1] = faceIndices [1];  	sortedFaceIndices [i + 2] = faceIndices [2];  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,RemoveDuplicateFaces,The following statement contains a magic number: for (int i = 0; i < indices.Length; i += 3) {  	int[] faceIndices =  {  		indices [i]'  		indices [i + 1]'  		indices [i + 2]  	};  	System.Array.Sort (faceIndices);  	sortedFaceIndices [i] = faceIndices [0];  	sortedFaceIndices [i + 1] = faceIndices [1];  	sortedFaceIndices [i + 2] = faceIndices [2];  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,RemoveDuplicateFaces,The following statement contains a magic number: for (int i = 0; i < indices.Length; i += 3) {  	int[] faceIndices =  {  		indices [i]'  		indices [i + 1]'  		indices [i + 2]  	};  	System.Array.Sort (faceIndices);  	sortedFaceIndices [i] = faceIndices [0];  	sortedFaceIndices [i + 1] = faceIndices [1];  	sortedFaceIndices [i + 2] = faceIndices [2];  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,RemoveDuplicateFaces,The following statement contains a magic number: i += 3
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,RemoveDuplicateFaces,The following statement contains a magic number: sortedFaceIndices [i + 2] = faceIndices [2];  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,RemoveDuplicateFaces,The following statement contains a magic number: sortedFaceIndices [i + 2] = faceIndices [2];  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,RemoveDuplicateFaces,The following statement contains a magic number: for (int i = 0; i < indices.Length; i += 3) {  	sortIndex [i / 3] = i;  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,RemoveDuplicateFaces,The following statement contains a magic number: for (int i = 0; i < indices.Length; i += 3) {  	sortIndex [i / 3] = i;  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,RemoveDuplicateFaces,The following statement contains a magic number: i += 3
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,RemoveDuplicateFaces,The following statement contains a magic number: sortIndex [i / 3] = i;  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,RemoveDuplicateFaces,The following statement contains a magic number: for (int i = 0; i < sortIndex.Length; ++i) {  	if (i != sortIndex.Length - 1 && CompareDuplicateFaces (sortedFaceIndices' sortIndex [i]' sortIndex [i + 1]) == 0) {  		// skip both faces  		// this will fail in the case where there are 3 coplanar faces  		// but that is probably likely user error / intentional  		i++;  		continue;  	}  	for (int j = 0; j < 3; ++j)  		newIndices.Add (indices [sortIndex [i] + j]);  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,RemoveDuplicateFaces,The following statement contains a magic number: for (int j = 0; j < 3; ++j)  	newIndices.Add (indices [sortIndex [i] + j]);  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder2D,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder2D.cs,BuildForChunk,The following statement contains a magic number: if (localIndices.Length > 4) {  	// Remove duplicate verts' reindex  	localVerts = WeldVertices (localVerts' ref localIndices);  	// Remove duplicate and back-to-back edges  	// Removes inside edges  	localIndices = RemoveDuplicateEdges (localIndices);  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder2D,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder2D.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int y = 0; y < tileMap.partitionSizeY; ++y) {  	float xOffset = ((baseY + y) & 1) * xOffsetMult;  	for (int x = 0; x < tileMap.partitionSizeX; ++x) {  		int spriteId = chunkData [y * tileMap.partitionSizeX + x];  		int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  		Vector2 currentPos = new Vector2 (tileSize.x * (x + xOffset)' tileSize.y * y);  		if (spriteIdx < 0 || spriteIdx >= spriteCount)  			continue;  		if (tilePrefabs [spriteIdx])  			continue;  		bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  		bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  		bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  		bool reverseIndices = false;  		if (flipH)  			reverseIndices = !reverseIndices;  		if (flipV)  			reverseIndices = !reverseIndices;  		tk2dSpriteDefinition spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  		int baseVertexIndex = verts.Count;  		if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  			Vector3 origin = spriteData.colliderVertices [0];  			Vector3 extents = spriteData.colliderVertices [1];  			Vector3 min = origin - extents;  			Vector3 max = origin + extents;  			boxPos [0] = new Vector2 (min.x' min.y);  			boxPos [1] = new Vector2 (max.x' min.y);  			boxPos [2] = new Vector2 (max.x' max.y);  			boxPos [3] = new Vector2 (min.x' max.y);  			for (int i = 0; i < 4; ++i) {  				verts.Add (BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' boxPos [i]' flipH' flipV' rot90) + currentPos);  			}  			int[] boxIndices = reverseIndices ? boxIndsFlipped : boxInds;  			for (int i = 0; i < 8; ++i) {  				inds.Add (baseVertexIndex + boxIndices [i]);  			}  		}  		else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  			foreach (tk2dCollider2DData dat in spriteData.edgeCollider2D) {  				foreach (Vector2 pos in dat.points) {  					verts.Add (BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos' flipH' flipV' rot90) + currentPos);  				}  				int numVerts = dat.points.Length;  				if (reverseIndices) {  					for (int i = numVerts - 1; i > 0; --i) {  						inds.Add (baseVertexIndex + i);  						inds.Add (baseVertexIndex + i - 1);  					}  				}  				else {  					for (int i = 0; i < numVerts - 1; ++i) {  						inds.Add (baseVertexIndex + i);  						inds.Add (baseVertexIndex + i + 1);  					}  				}  			}  			foreach (tk2dCollider2DData dat in spriteData.polygonCollider2D) {  				foreach (Vector2 pos in dat.points) {  					verts.Add (BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos' flipH' flipV' rot90) + currentPos);  				}  				int numVerts = dat.points.Length;  				if (reverseIndices) {  					for (int i = numVerts; i > 0; --i) {  						inds.Add (baseVertexIndex + (i % numVerts));  						inds.Add (baseVertexIndex + i - 1);  					}  				}  				else {  					for (int i = 0; i < numVerts; ++i) {  						inds.Add (baseVertexIndex + i);  						inds.Add (baseVertexIndex + (i + 1) % numVerts);  					}  				}  			}  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder2D,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder2D.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int y = 0; y < tileMap.partitionSizeY; ++y) {  	float xOffset = ((baseY + y) & 1) * xOffsetMult;  	for (int x = 0; x < tileMap.partitionSizeX; ++x) {  		int spriteId = chunkData [y * tileMap.partitionSizeX + x];  		int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  		Vector2 currentPos = new Vector2 (tileSize.x * (x + xOffset)' tileSize.y * y);  		if (spriteIdx < 0 || spriteIdx >= spriteCount)  			continue;  		if (tilePrefabs [spriteIdx])  			continue;  		bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  		bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  		bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  		bool reverseIndices = false;  		if (flipH)  			reverseIndices = !reverseIndices;  		if (flipV)  			reverseIndices = !reverseIndices;  		tk2dSpriteDefinition spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  		int baseVertexIndex = verts.Count;  		if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  			Vector3 origin = spriteData.colliderVertices [0];  			Vector3 extents = spriteData.colliderVertices [1];  			Vector3 min = origin - extents;  			Vector3 max = origin + extents;  			boxPos [0] = new Vector2 (min.x' min.y);  			boxPos [1] = new Vector2 (max.x' min.y);  			boxPos [2] = new Vector2 (max.x' max.y);  			boxPos [3] = new Vector2 (min.x' max.y);  			for (int i = 0; i < 4; ++i) {  				verts.Add (BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' boxPos [i]' flipH' flipV' rot90) + currentPos);  			}  			int[] boxIndices = reverseIndices ? boxIndsFlipped : boxInds;  			for (int i = 0; i < 8; ++i) {  				inds.Add (baseVertexIndex + boxIndices [i]);  			}  		}  		else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  			foreach (tk2dCollider2DData dat in spriteData.edgeCollider2D) {  				foreach (Vector2 pos in dat.points) {  					verts.Add (BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos' flipH' flipV' rot90) + currentPos);  				}  				int numVerts = dat.points.Length;  				if (reverseIndices) {  					for (int i = numVerts - 1; i > 0; --i) {  						inds.Add (baseVertexIndex + i);  						inds.Add (baseVertexIndex + i - 1);  					}  				}  				else {  					for (int i = 0; i < numVerts - 1; ++i) {  						inds.Add (baseVertexIndex + i);  						inds.Add (baseVertexIndex + i + 1);  					}  				}  			}  			foreach (tk2dCollider2DData dat in spriteData.polygonCollider2D) {  				foreach (Vector2 pos in dat.points) {  					verts.Add (BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos' flipH' flipV' rot90) + currentPos);  				}  				int numVerts = dat.points.Length;  				if (reverseIndices) {  					for (int i = numVerts; i > 0; --i) {  						inds.Add (baseVertexIndex + (i % numVerts));  						inds.Add (baseVertexIndex + i - 1);  					}  				}  				else {  					for (int i = 0; i < numVerts; ++i) {  						inds.Add (baseVertexIndex + i);  						inds.Add (baseVertexIndex + (i + 1) % numVerts);  					}  				}  			}  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder2D,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder2D.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int y = 0; y < tileMap.partitionSizeY; ++y) {  	float xOffset = ((baseY + y) & 1) * xOffsetMult;  	for (int x = 0; x < tileMap.partitionSizeX; ++x) {  		int spriteId = chunkData [y * tileMap.partitionSizeX + x];  		int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  		Vector2 currentPos = new Vector2 (tileSize.x * (x + xOffset)' tileSize.y * y);  		if (spriteIdx < 0 || spriteIdx >= spriteCount)  			continue;  		if (tilePrefabs [spriteIdx])  			continue;  		bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  		bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  		bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  		bool reverseIndices = false;  		if (flipH)  			reverseIndices = !reverseIndices;  		if (flipV)  			reverseIndices = !reverseIndices;  		tk2dSpriteDefinition spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  		int baseVertexIndex = verts.Count;  		if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  			Vector3 origin = spriteData.colliderVertices [0];  			Vector3 extents = spriteData.colliderVertices [1];  			Vector3 min = origin - extents;  			Vector3 max = origin + extents;  			boxPos [0] = new Vector2 (min.x' min.y);  			boxPos [1] = new Vector2 (max.x' min.y);  			boxPos [2] = new Vector2 (max.x' max.y);  			boxPos [3] = new Vector2 (min.x' max.y);  			for (int i = 0; i < 4; ++i) {  				verts.Add (BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' boxPos [i]' flipH' flipV' rot90) + currentPos);  			}  			int[] boxIndices = reverseIndices ? boxIndsFlipped : boxInds;  			for (int i = 0; i < 8; ++i) {  				inds.Add (baseVertexIndex + boxIndices [i]);  			}  		}  		else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  			foreach (tk2dCollider2DData dat in spriteData.edgeCollider2D) {  				foreach (Vector2 pos in dat.points) {  					verts.Add (BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos' flipH' flipV' rot90) + currentPos);  				}  				int numVerts = dat.points.Length;  				if (reverseIndices) {  					for (int i = numVerts - 1; i > 0; --i) {  						inds.Add (baseVertexIndex + i);  						inds.Add (baseVertexIndex + i - 1);  					}  				}  				else {  					for (int i = 0; i < numVerts - 1; ++i) {  						inds.Add (baseVertexIndex + i);  						inds.Add (baseVertexIndex + i + 1);  					}  				}  			}  			foreach (tk2dCollider2DData dat in spriteData.polygonCollider2D) {  				foreach (Vector2 pos in dat.points) {  					verts.Add (BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos' flipH' flipV' rot90) + currentPos);  				}  				int numVerts = dat.points.Length;  				if (reverseIndices) {  					for (int i = numVerts; i > 0; --i) {  						inds.Add (baseVertexIndex + (i % numVerts));  						inds.Add (baseVertexIndex + i - 1);  					}  				}  				else {  					for (int i = 0; i < numVerts; ++i) {  						inds.Add (baseVertexIndex + i);  						inds.Add (baseVertexIndex + (i + 1) % numVerts);  					}  				}  			}  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder2D,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder2D.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int y = 0; y < tileMap.partitionSizeY; ++y) {  	float xOffset = ((baseY + y) & 1) * xOffsetMult;  	for (int x = 0; x < tileMap.partitionSizeX; ++x) {  		int spriteId = chunkData [y * tileMap.partitionSizeX + x];  		int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  		Vector2 currentPos = new Vector2 (tileSize.x * (x + xOffset)' tileSize.y * y);  		if (spriteIdx < 0 || spriteIdx >= spriteCount)  			continue;  		if (tilePrefabs [spriteIdx])  			continue;  		bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  		bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  		bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  		bool reverseIndices = false;  		if (flipH)  			reverseIndices = !reverseIndices;  		if (flipV)  			reverseIndices = !reverseIndices;  		tk2dSpriteDefinition spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  		int baseVertexIndex = verts.Count;  		if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  			Vector3 origin = spriteData.colliderVertices [0];  			Vector3 extents = spriteData.colliderVertices [1];  			Vector3 min = origin - extents;  			Vector3 max = origin + extents;  			boxPos [0] = new Vector2 (min.x' min.y);  			boxPos [1] = new Vector2 (max.x' min.y);  			boxPos [2] = new Vector2 (max.x' max.y);  			boxPos [3] = new Vector2 (min.x' max.y);  			for (int i = 0; i < 4; ++i) {  				verts.Add (BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' boxPos [i]' flipH' flipV' rot90) + currentPos);  			}  			int[] boxIndices = reverseIndices ? boxIndsFlipped : boxInds;  			for (int i = 0; i < 8; ++i) {  				inds.Add (baseVertexIndex + boxIndices [i]);  			}  		}  		else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  			foreach (tk2dCollider2DData dat in spriteData.edgeCollider2D) {  				foreach (Vector2 pos in dat.points) {  					verts.Add (BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos' flipH' flipV' rot90) + currentPos);  				}  				int numVerts = dat.points.Length;  				if (reverseIndices) {  					for (int i = numVerts - 1; i > 0; --i) {  						inds.Add (baseVertexIndex + i);  						inds.Add (baseVertexIndex + i - 1);  					}  				}  				else {  					for (int i = 0; i < numVerts - 1; ++i) {  						inds.Add (baseVertexIndex + i);  						inds.Add (baseVertexIndex + i + 1);  					}  				}  			}  			foreach (tk2dCollider2DData dat in spriteData.polygonCollider2D) {  				foreach (Vector2 pos in dat.points) {  					verts.Add (BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos' flipH' flipV' rot90) + currentPos);  				}  				int numVerts = dat.points.Length;  				if (reverseIndices) {  					for (int i = numVerts; i > 0; --i) {  						inds.Add (baseVertexIndex + (i % numVerts));  						inds.Add (baseVertexIndex + i - 1);  					}  				}  				else {  					for (int i = 0; i < numVerts; ++i) {  						inds.Add (baseVertexIndex + i);  						inds.Add (baseVertexIndex + (i + 1) % numVerts);  					}  				}  			}  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder2D,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder2D.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int x = 0; x < tileMap.partitionSizeX; ++x) {  	int spriteId = chunkData [y * tileMap.partitionSizeX + x];  	int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  	Vector2 currentPos = new Vector2 (tileSize.x * (x + xOffset)' tileSize.y * y);  	if (spriteIdx < 0 || spriteIdx >= spriteCount)  		continue;  	if (tilePrefabs [spriteIdx])  		continue;  	bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  	bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  	bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  	bool reverseIndices = false;  	if (flipH)  		reverseIndices = !reverseIndices;  	if (flipV)  		reverseIndices = !reverseIndices;  	tk2dSpriteDefinition spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  	int baseVertexIndex = verts.Count;  	if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  		Vector3 origin = spriteData.colliderVertices [0];  		Vector3 extents = spriteData.colliderVertices [1];  		Vector3 min = origin - extents;  		Vector3 max = origin + extents;  		boxPos [0] = new Vector2 (min.x' min.y);  		boxPos [1] = new Vector2 (max.x' min.y);  		boxPos [2] = new Vector2 (max.x' max.y);  		boxPos [3] = new Vector2 (min.x' max.y);  		for (int i = 0; i < 4; ++i) {  			verts.Add (BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' boxPos [i]' flipH' flipV' rot90) + currentPos);  		}  		int[] boxIndices = reverseIndices ? boxIndsFlipped : boxInds;  		for (int i = 0; i < 8; ++i) {  			inds.Add (baseVertexIndex + boxIndices [i]);  		}  	}  	else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  		foreach (tk2dCollider2DData dat in spriteData.edgeCollider2D) {  			foreach (Vector2 pos in dat.points) {  				verts.Add (BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos' flipH' flipV' rot90) + currentPos);  			}  			int numVerts = dat.points.Length;  			if (reverseIndices) {  				for (int i = numVerts - 1; i > 0; --i) {  					inds.Add (baseVertexIndex + i);  					inds.Add (baseVertexIndex + i - 1);  				}  			}  			else {  				for (int i = 0; i < numVerts - 1; ++i) {  					inds.Add (baseVertexIndex + i);  					inds.Add (baseVertexIndex + i + 1);  				}  			}  		}  		foreach (tk2dCollider2DData dat in spriteData.polygonCollider2D) {  			foreach (Vector2 pos in dat.points) {  				verts.Add (BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos' flipH' flipV' rot90) + currentPos);  			}  			int numVerts = dat.points.Length;  			if (reverseIndices) {  				for (int i = numVerts; i > 0; --i) {  					inds.Add (baseVertexIndex + (i % numVerts));  					inds.Add (baseVertexIndex + i - 1);  				}  			}  			else {  				for (int i = 0; i < numVerts; ++i) {  					inds.Add (baseVertexIndex + i);  					inds.Add (baseVertexIndex + (i + 1) % numVerts);  				}  			}  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder2D,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder2D.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int x = 0; x < tileMap.partitionSizeX; ++x) {  	int spriteId = chunkData [y * tileMap.partitionSizeX + x];  	int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  	Vector2 currentPos = new Vector2 (tileSize.x * (x + xOffset)' tileSize.y * y);  	if (spriteIdx < 0 || spriteIdx >= spriteCount)  		continue;  	if (tilePrefabs [spriteIdx])  		continue;  	bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  	bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  	bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  	bool reverseIndices = false;  	if (flipH)  		reverseIndices = !reverseIndices;  	if (flipV)  		reverseIndices = !reverseIndices;  	tk2dSpriteDefinition spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  	int baseVertexIndex = verts.Count;  	if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  		Vector3 origin = spriteData.colliderVertices [0];  		Vector3 extents = spriteData.colliderVertices [1];  		Vector3 min = origin - extents;  		Vector3 max = origin + extents;  		boxPos [0] = new Vector2 (min.x' min.y);  		boxPos [1] = new Vector2 (max.x' min.y);  		boxPos [2] = new Vector2 (max.x' max.y);  		boxPos [3] = new Vector2 (min.x' max.y);  		for (int i = 0; i < 4; ++i) {  			verts.Add (BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' boxPos [i]' flipH' flipV' rot90) + currentPos);  		}  		int[] boxIndices = reverseIndices ? boxIndsFlipped : boxInds;  		for (int i = 0; i < 8; ++i) {  			inds.Add (baseVertexIndex + boxIndices [i]);  		}  	}  	else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  		foreach (tk2dCollider2DData dat in spriteData.edgeCollider2D) {  			foreach (Vector2 pos in dat.points) {  				verts.Add (BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos' flipH' flipV' rot90) + currentPos);  			}  			int numVerts = dat.points.Length;  			if (reverseIndices) {  				for (int i = numVerts - 1; i > 0; --i) {  					inds.Add (baseVertexIndex + i);  					inds.Add (baseVertexIndex + i - 1);  				}  			}  			else {  				for (int i = 0; i < numVerts - 1; ++i) {  					inds.Add (baseVertexIndex + i);  					inds.Add (baseVertexIndex + i + 1);  				}  			}  		}  		foreach (tk2dCollider2DData dat in spriteData.polygonCollider2D) {  			foreach (Vector2 pos in dat.points) {  				verts.Add (BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos' flipH' flipV' rot90) + currentPos);  			}  			int numVerts = dat.points.Length;  			if (reverseIndices) {  				for (int i = numVerts; i > 0; --i) {  					inds.Add (baseVertexIndex + (i % numVerts));  					inds.Add (baseVertexIndex + i - 1);  				}  			}  			else {  				for (int i = 0; i < numVerts; ++i) {  					inds.Add (baseVertexIndex + i);  					inds.Add (baseVertexIndex + (i + 1) % numVerts);  				}  			}  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder2D,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder2D.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int x = 0; x < tileMap.partitionSizeX; ++x) {  	int spriteId = chunkData [y * tileMap.partitionSizeX + x];  	int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  	Vector2 currentPos = new Vector2 (tileSize.x * (x + xOffset)' tileSize.y * y);  	if (spriteIdx < 0 || spriteIdx >= spriteCount)  		continue;  	if (tilePrefabs [spriteIdx])  		continue;  	bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  	bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  	bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  	bool reverseIndices = false;  	if (flipH)  		reverseIndices = !reverseIndices;  	if (flipV)  		reverseIndices = !reverseIndices;  	tk2dSpriteDefinition spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  	int baseVertexIndex = verts.Count;  	if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  		Vector3 origin = spriteData.colliderVertices [0];  		Vector3 extents = spriteData.colliderVertices [1];  		Vector3 min = origin - extents;  		Vector3 max = origin + extents;  		boxPos [0] = new Vector2 (min.x' min.y);  		boxPos [1] = new Vector2 (max.x' min.y);  		boxPos [2] = new Vector2 (max.x' max.y);  		boxPos [3] = new Vector2 (min.x' max.y);  		for (int i = 0; i < 4; ++i) {  			verts.Add (BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' boxPos [i]' flipH' flipV' rot90) + currentPos);  		}  		int[] boxIndices = reverseIndices ? boxIndsFlipped : boxInds;  		for (int i = 0; i < 8; ++i) {  			inds.Add (baseVertexIndex + boxIndices [i]);  		}  	}  	else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  		foreach (tk2dCollider2DData dat in spriteData.edgeCollider2D) {  			foreach (Vector2 pos in dat.points) {  				verts.Add (BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos' flipH' flipV' rot90) + currentPos);  			}  			int numVerts = dat.points.Length;  			if (reverseIndices) {  				for (int i = numVerts - 1; i > 0; --i) {  					inds.Add (baseVertexIndex + i);  					inds.Add (baseVertexIndex + i - 1);  				}  			}  			else {  				for (int i = 0; i < numVerts - 1; ++i) {  					inds.Add (baseVertexIndex + i);  					inds.Add (baseVertexIndex + i + 1);  				}  			}  		}  		foreach (tk2dCollider2DData dat in spriteData.polygonCollider2D) {  			foreach (Vector2 pos in dat.points) {  				verts.Add (BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos' flipH' flipV' rot90) + currentPos);  			}  			int numVerts = dat.points.Length;  			if (reverseIndices) {  				for (int i = numVerts; i > 0; --i) {  					inds.Add (baseVertexIndex + (i % numVerts));  					inds.Add (baseVertexIndex + i - 1);  				}  			}  			else {  				for (int i = 0; i < numVerts; ++i) {  					inds.Add (baseVertexIndex + i);  					inds.Add (baseVertexIndex + (i + 1) % numVerts);  				}  			}  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder2D,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder2D.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int x = 0; x < tileMap.partitionSizeX; ++x) {  	int spriteId = chunkData [y * tileMap.partitionSizeX + x];  	int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  	Vector2 currentPos = new Vector2 (tileSize.x * (x + xOffset)' tileSize.y * y);  	if (spriteIdx < 0 || spriteIdx >= spriteCount)  		continue;  	if (tilePrefabs [spriteIdx])  		continue;  	bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  	bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  	bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  	bool reverseIndices = false;  	if (flipH)  		reverseIndices = !reverseIndices;  	if (flipV)  		reverseIndices = !reverseIndices;  	tk2dSpriteDefinition spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  	int baseVertexIndex = verts.Count;  	if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  		Vector3 origin = spriteData.colliderVertices [0];  		Vector3 extents = spriteData.colliderVertices [1];  		Vector3 min = origin - extents;  		Vector3 max = origin + extents;  		boxPos [0] = new Vector2 (min.x' min.y);  		boxPos [1] = new Vector2 (max.x' min.y);  		boxPos [2] = new Vector2 (max.x' max.y);  		boxPos [3] = new Vector2 (min.x' max.y);  		for (int i = 0; i < 4; ++i) {  			verts.Add (BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' boxPos [i]' flipH' flipV' rot90) + currentPos);  		}  		int[] boxIndices = reverseIndices ? boxIndsFlipped : boxInds;  		for (int i = 0; i < 8; ++i) {  			inds.Add (baseVertexIndex + boxIndices [i]);  		}  	}  	else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  		foreach (tk2dCollider2DData dat in spriteData.edgeCollider2D) {  			foreach (Vector2 pos in dat.points) {  				verts.Add (BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos' flipH' flipV' rot90) + currentPos);  			}  			int numVerts = dat.points.Length;  			if (reverseIndices) {  				for (int i = numVerts - 1; i > 0; --i) {  					inds.Add (baseVertexIndex + i);  					inds.Add (baseVertexIndex + i - 1);  				}  			}  			else {  				for (int i = 0; i < numVerts - 1; ++i) {  					inds.Add (baseVertexIndex + i);  					inds.Add (baseVertexIndex + i + 1);  				}  			}  		}  		foreach (tk2dCollider2DData dat in spriteData.polygonCollider2D) {  			foreach (Vector2 pos in dat.points) {  				verts.Add (BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos' flipH' flipV' rot90) + currentPos);  			}  			int numVerts = dat.points.Length;  			if (reverseIndices) {  				for (int i = numVerts; i > 0; --i) {  					inds.Add (baseVertexIndex + (i % numVerts));  					inds.Add (baseVertexIndex + i - 1);  				}  			}  			else {  				for (int i = 0; i < numVerts; ++i) {  					inds.Add (baseVertexIndex + i);  					inds.Add (baseVertexIndex + (i + 1) % numVerts);  				}  			}  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder2D,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder2D.cs,BuildLocalMeshForChunk,The following statement contains a magic number: if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  	Vector3 origin = spriteData.colliderVertices [0];  	Vector3 extents = spriteData.colliderVertices [1];  	Vector3 min = origin - extents;  	Vector3 max = origin + extents;  	boxPos [0] = new Vector2 (min.x' min.y);  	boxPos [1] = new Vector2 (max.x' min.y);  	boxPos [2] = new Vector2 (max.x' max.y);  	boxPos [3] = new Vector2 (min.x' max.y);  	for (int i = 0; i < 4; ++i) {  		verts.Add (BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' boxPos [i]' flipH' flipV' rot90) + currentPos);  	}  	int[] boxIndices = reverseIndices ? boxIndsFlipped : boxInds;  	for (int i = 0; i < 8; ++i) {  		inds.Add (baseVertexIndex + boxIndices [i]);  	}  }  else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  	foreach (tk2dCollider2DData dat in spriteData.edgeCollider2D) {  		foreach (Vector2 pos in dat.points) {  			verts.Add (BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos' flipH' flipV' rot90) + currentPos);  		}  		int numVerts = dat.points.Length;  		if (reverseIndices) {  			for (int i = numVerts - 1; i > 0; --i) {  				inds.Add (baseVertexIndex + i);  				inds.Add (baseVertexIndex + i - 1);  			}  		}  		else {  			for (int i = 0; i < numVerts - 1; ++i) {  				inds.Add (baseVertexIndex + i);  				inds.Add (baseVertexIndex + i + 1);  			}  		}  	}  	foreach (tk2dCollider2DData dat in spriteData.polygonCollider2D) {  		foreach (Vector2 pos in dat.points) {  			verts.Add (BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos' flipH' flipV' rot90) + currentPos);  		}  		int numVerts = dat.points.Length;  		if (reverseIndices) {  			for (int i = numVerts; i > 0; --i) {  				inds.Add (baseVertexIndex + (i % numVerts));  				inds.Add (baseVertexIndex + i - 1);  			}  		}  		else {  			for (int i = 0; i < numVerts; ++i) {  				inds.Add (baseVertexIndex + i);  				inds.Add (baseVertexIndex + (i + 1) % numVerts);  			}  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder2D,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder2D.cs,BuildLocalMeshForChunk,The following statement contains a magic number: if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  	Vector3 origin = spriteData.colliderVertices [0];  	Vector3 extents = spriteData.colliderVertices [1];  	Vector3 min = origin - extents;  	Vector3 max = origin + extents;  	boxPos [0] = new Vector2 (min.x' min.y);  	boxPos [1] = new Vector2 (max.x' min.y);  	boxPos [2] = new Vector2 (max.x' max.y);  	boxPos [3] = new Vector2 (min.x' max.y);  	for (int i = 0; i < 4; ++i) {  		verts.Add (BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' boxPos [i]' flipH' flipV' rot90) + currentPos);  	}  	int[] boxIndices = reverseIndices ? boxIndsFlipped : boxInds;  	for (int i = 0; i < 8; ++i) {  		inds.Add (baseVertexIndex + boxIndices [i]);  	}  }  else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  	foreach (tk2dCollider2DData dat in spriteData.edgeCollider2D) {  		foreach (Vector2 pos in dat.points) {  			verts.Add (BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos' flipH' flipV' rot90) + currentPos);  		}  		int numVerts = dat.points.Length;  		if (reverseIndices) {  			for (int i = numVerts - 1; i > 0; --i) {  				inds.Add (baseVertexIndex + i);  				inds.Add (baseVertexIndex + i - 1);  			}  		}  		else {  			for (int i = 0; i < numVerts - 1; ++i) {  				inds.Add (baseVertexIndex + i);  				inds.Add (baseVertexIndex + i + 1);  			}  		}  	}  	foreach (tk2dCollider2DData dat in spriteData.polygonCollider2D) {  		foreach (Vector2 pos in dat.points) {  			verts.Add (BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos' flipH' flipV' rot90) + currentPos);  		}  		int numVerts = dat.points.Length;  		if (reverseIndices) {  			for (int i = numVerts; i > 0; --i) {  				inds.Add (baseVertexIndex + (i % numVerts));  				inds.Add (baseVertexIndex + i - 1);  			}  		}  		else {  			for (int i = 0; i < numVerts; ++i) {  				inds.Add (baseVertexIndex + i);  				inds.Add (baseVertexIndex + (i + 1) % numVerts);  			}  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder2D,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder2D.cs,BuildLocalMeshForChunk,The following statement contains a magic number: if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  	Vector3 origin = spriteData.colliderVertices [0];  	Vector3 extents = spriteData.colliderVertices [1];  	Vector3 min = origin - extents;  	Vector3 max = origin + extents;  	boxPos [0] = new Vector2 (min.x' min.y);  	boxPos [1] = new Vector2 (max.x' min.y);  	boxPos [2] = new Vector2 (max.x' max.y);  	boxPos [3] = new Vector2 (min.x' max.y);  	for (int i = 0; i < 4; ++i) {  		verts.Add (BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' boxPos [i]' flipH' flipV' rot90) + currentPos);  	}  	int[] boxIndices = reverseIndices ? boxIndsFlipped : boxInds;  	for (int i = 0; i < 8; ++i) {  		inds.Add (baseVertexIndex + boxIndices [i]);  	}  }  else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  	foreach (tk2dCollider2DData dat in spriteData.edgeCollider2D) {  		foreach (Vector2 pos in dat.points) {  			verts.Add (BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos' flipH' flipV' rot90) + currentPos);  		}  		int numVerts = dat.points.Length;  		if (reverseIndices) {  			for (int i = numVerts - 1; i > 0; --i) {  				inds.Add (baseVertexIndex + i);  				inds.Add (baseVertexIndex + i - 1);  			}  		}  		else {  			for (int i = 0; i < numVerts - 1; ++i) {  				inds.Add (baseVertexIndex + i);  				inds.Add (baseVertexIndex + i + 1);  			}  		}  	}  	foreach (tk2dCollider2DData dat in spriteData.polygonCollider2D) {  		foreach (Vector2 pos in dat.points) {  			verts.Add (BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos' flipH' flipV' rot90) + currentPos);  		}  		int numVerts = dat.points.Length;  		if (reverseIndices) {  			for (int i = numVerts; i > 0; --i) {  				inds.Add (baseVertexIndex + (i % numVerts));  				inds.Add (baseVertexIndex + i - 1);  			}  		}  		else {  			for (int i = 0; i < numVerts; ++i) {  				inds.Add (baseVertexIndex + i);  				inds.Add (baseVertexIndex + (i + 1) % numVerts);  			}  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder2D,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder2D.cs,BuildLocalMeshForChunk,The following statement contains a magic number: if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  	Vector3 origin = spriteData.colliderVertices [0];  	Vector3 extents = spriteData.colliderVertices [1];  	Vector3 min = origin - extents;  	Vector3 max = origin + extents;  	boxPos [0] = new Vector2 (min.x' min.y);  	boxPos [1] = new Vector2 (max.x' min.y);  	boxPos [2] = new Vector2 (max.x' max.y);  	boxPos [3] = new Vector2 (min.x' max.y);  	for (int i = 0; i < 4; ++i) {  		verts.Add (BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' boxPos [i]' flipH' flipV' rot90) + currentPos);  	}  	int[] boxIndices = reverseIndices ? boxIndsFlipped : boxInds;  	for (int i = 0; i < 8; ++i) {  		inds.Add (baseVertexIndex + boxIndices [i]);  	}  }  else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  	foreach (tk2dCollider2DData dat in spriteData.edgeCollider2D) {  		foreach (Vector2 pos in dat.points) {  			verts.Add (BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos' flipH' flipV' rot90) + currentPos);  		}  		int numVerts = dat.points.Length;  		if (reverseIndices) {  			for (int i = numVerts - 1; i > 0; --i) {  				inds.Add (baseVertexIndex + i);  				inds.Add (baseVertexIndex + i - 1);  			}  		}  		else {  			for (int i = 0; i < numVerts - 1; ++i) {  				inds.Add (baseVertexIndex + i);  				inds.Add (baseVertexIndex + i + 1);  			}  		}  	}  	foreach (tk2dCollider2DData dat in spriteData.polygonCollider2D) {  		foreach (Vector2 pos in dat.points) {  			verts.Add (BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos' flipH' flipV' rot90) + currentPos);  		}  		int numVerts = dat.points.Length;  		if (reverseIndices) {  			for (int i = numVerts; i > 0; --i) {  				inds.Add (baseVertexIndex + (i % numVerts));  				inds.Add (baseVertexIndex + i - 1);  			}  		}  		else {  			for (int i = 0; i < numVerts; ++i) {  				inds.Add (baseVertexIndex + i);  				inds.Add (baseVertexIndex + (i + 1) % numVerts);  			}  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder2D,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder2D.cs,BuildLocalMeshForChunk,The following statement contains a magic number: boxPos [2] = new Vector2 (max.x' max.y);  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder2D,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder2D.cs,BuildLocalMeshForChunk,The following statement contains a magic number: boxPos [3] = new Vector2 (min.x' max.y);  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder2D,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder2D.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int i = 0; i < 4; ++i) {  	verts.Add (BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' boxPos [i]' flipH' flipV' rot90) + currentPos);  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder2D,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder2D.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int i = 0; i < 8; ++i) {  	inds.Add (baseVertexIndex + boxIndices [i]);  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder2D,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder2D.cs,CompareDuplicateFaces,The following statement contains a magic number: for (int i = 0; i < 2; ++i) {  	int d = indices [face0index + i] - indices [face1index + i];  	if (d != 0)  		return d;  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder2D,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder2D.cs,RemoveDuplicateEdges,The following statement contains a magic number: for (int i = 0; i < indices.Length; i += 2) {  	if (indices [i] > indices [i + 1]) {  		sortedFaceIndices [i] = indices [i + 1];  		sortedFaceIndices [i + 1] = indices [i];  	}  	else {  		sortedFaceIndices [i] = indices [i];  		sortedFaceIndices [i + 1] = indices [i + 1];  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder2D,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder2D.cs,RemoveDuplicateEdges,The following statement contains a magic number: i += 2
Magic Number,tk2dRuntime.TileMap,ColliderBuilder2D,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder2D.cs,RemoveDuplicateEdges,The following statement contains a magic number: for (int i = 0; i < indices.Length; i += 2) {  	sortIndex [i / 2] = i;  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder2D,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder2D.cs,RemoveDuplicateEdges,The following statement contains a magic number: for (int i = 0; i < indices.Length; i += 2) {  	sortIndex [i / 2] = i;  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder2D,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder2D.cs,RemoveDuplicateEdges,The following statement contains a magic number: i += 2
Magic Number,tk2dRuntime.TileMap,ColliderBuilder2D,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder2D.cs,RemoveDuplicateEdges,The following statement contains a magic number: sortIndex [i / 2] = i;  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder2D,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder2D.cs,RemoveDuplicateEdges,The following statement contains a magic number: for (int i = 0; i < sortIndex.Length; ++i) {  	if (i != sortIndex.Length - 1 && CompareDuplicateFaces (sortedFaceIndices' sortIndex [i]' sortIndex [i + 1]) == 0) {  		// skip both faces  		// this will fail in the case where there are 3 coplanar faces  		// but that is probably likely user error / intentional  		i++;  		continue;  	}  	for (int j = 0; j < 2; ++j)  		newIndices.Add (indices [sortIndex [i] + j]);  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder2D,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder2D.cs,RemoveDuplicateEdges,The following statement contains a magic number: for (int j = 0; j < 2; ++j)  	newIndices.Add (indices [sortIndex [i] + j]);  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder2D,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder2D.cs,MergeEdges,The following statement contains a magic number: while (processedEdge) {  	processedEdge = false;  	for (int i = 0; i < edgeUsed.Length; ++i) {  		if (!edgeUsed [i]) {  			edgeUsed [i] = true;  			int v0 = indices [i * 2 + 0];  			int v1 = indices [i * 2 + 1];  			d0 = (verts [v1] - verts [v0]).normalized;  			edgeIndices.Add (v0);  			edgeIndices.Add (v1);  			// The connecting vertex for this edge list  			for (int k = i + 1; k < edgeUsed.Length; ++k) {  				if (edgeUsed [k]) {  					continue;  				}  				int w0 = indices [k * 2 + 0];  				if (w0 == v1) {  					int w1 = indices [k * 2 + 1];  					d1 = (verts [w1] - verts [w0]).normalized;  					// Same direction?  					if (Vector2.Dot (d1' d0) > 0.999f) {  						edgeIndices.RemoveAt (edgeIndices.Count - 1);  						// remove last  					}  					edgeIndices.Add (w1);  					edgeUsed [k] = true;  					d0 = d1;  					// new normal  					k = i;  					// restart the loop  					v1 = w1;  					// continuing from the end of the loop  					continue;  				}  			}  			processedEdge = true;  			break;  		}  	}  	if (processedEdge) {  		edgeVerts.Clear ();  		edgeVerts.Capacity = Mathf.Max (edgeVerts.Capacity' edgeIndices.Count);  		for (int i = 0; i < edgeIndices.Count; ++i) {  			edgeVerts.Add (verts [edgeIndices [i]]);  		}  		edges.Add (edgeVerts.ToArray ());  		edgeIndices.Clear ();  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder2D,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder2D.cs,MergeEdges,The following statement contains a magic number: while (processedEdge) {  	processedEdge = false;  	for (int i = 0; i < edgeUsed.Length; ++i) {  		if (!edgeUsed [i]) {  			edgeUsed [i] = true;  			int v0 = indices [i * 2 + 0];  			int v1 = indices [i * 2 + 1];  			d0 = (verts [v1] - verts [v0]).normalized;  			edgeIndices.Add (v0);  			edgeIndices.Add (v1);  			// The connecting vertex for this edge list  			for (int k = i + 1; k < edgeUsed.Length; ++k) {  				if (edgeUsed [k]) {  					continue;  				}  				int w0 = indices [k * 2 + 0];  				if (w0 == v1) {  					int w1 = indices [k * 2 + 1];  					d1 = (verts [w1] - verts [w0]).normalized;  					// Same direction?  					if (Vector2.Dot (d1' d0) > 0.999f) {  						edgeIndices.RemoveAt (edgeIndices.Count - 1);  						// remove last  					}  					edgeIndices.Add (w1);  					edgeUsed [k] = true;  					d0 = d1;  					// new normal  					k = i;  					// restart the loop  					v1 = w1;  					// continuing from the end of the loop  					continue;  				}  			}  			processedEdge = true;  			break;  		}  	}  	if (processedEdge) {  		edgeVerts.Clear ();  		edgeVerts.Capacity = Mathf.Max (edgeVerts.Capacity' edgeIndices.Count);  		for (int i = 0; i < edgeIndices.Count; ++i) {  			edgeVerts.Add (verts [edgeIndices [i]]);  		}  		edges.Add (edgeVerts.ToArray ());  		edgeIndices.Clear ();  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder2D,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder2D.cs,MergeEdges,The following statement contains a magic number: while (processedEdge) {  	processedEdge = false;  	for (int i = 0; i < edgeUsed.Length; ++i) {  		if (!edgeUsed [i]) {  			edgeUsed [i] = true;  			int v0 = indices [i * 2 + 0];  			int v1 = indices [i * 2 + 1];  			d0 = (verts [v1] - verts [v0]).normalized;  			edgeIndices.Add (v0);  			edgeIndices.Add (v1);  			// The connecting vertex for this edge list  			for (int k = i + 1; k < edgeUsed.Length; ++k) {  				if (edgeUsed [k]) {  					continue;  				}  				int w0 = indices [k * 2 + 0];  				if (w0 == v1) {  					int w1 = indices [k * 2 + 1];  					d1 = (verts [w1] - verts [w0]).normalized;  					// Same direction?  					if (Vector2.Dot (d1' d0) > 0.999f) {  						edgeIndices.RemoveAt (edgeIndices.Count - 1);  						// remove last  					}  					edgeIndices.Add (w1);  					edgeUsed [k] = true;  					d0 = d1;  					// new normal  					k = i;  					// restart the loop  					v1 = w1;  					// continuing from the end of the loop  					continue;  				}  			}  			processedEdge = true;  			break;  		}  	}  	if (processedEdge) {  		edgeVerts.Clear ();  		edgeVerts.Capacity = Mathf.Max (edgeVerts.Capacity' edgeIndices.Count);  		for (int i = 0; i < edgeIndices.Count; ++i) {  			edgeVerts.Add (verts [edgeIndices [i]]);  		}  		edges.Add (edgeVerts.ToArray ());  		edgeIndices.Clear ();  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder2D,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder2D.cs,MergeEdges,The following statement contains a magic number: while (processedEdge) {  	processedEdge = false;  	for (int i = 0; i < edgeUsed.Length; ++i) {  		if (!edgeUsed [i]) {  			edgeUsed [i] = true;  			int v0 = indices [i * 2 + 0];  			int v1 = indices [i * 2 + 1];  			d0 = (verts [v1] - verts [v0]).normalized;  			edgeIndices.Add (v0);  			edgeIndices.Add (v1);  			// The connecting vertex for this edge list  			for (int k = i + 1; k < edgeUsed.Length; ++k) {  				if (edgeUsed [k]) {  					continue;  				}  				int w0 = indices [k * 2 + 0];  				if (w0 == v1) {  					int w1 = indices [k * 2 + 1];  					d1 = (verts [w1] - verts [w0]).normalized;  					// Same direction?  					if (Vector2.Dot (d1' d0) > 0.999f) {  						edgeIndices.RemoveAt (edgeIndices.Count - 1);  						// remove last  					}  					edgeIndices.Add (w1);  					edgeUsed [k] = true;  					d0 = d1;  					// new normal  					k = i;  					// restart the loop  					v1 = w1;  					// continuing from the end of the loop  					continue;  				}  			}  			processedEdge = true;  			break;  		}  	}  	if (processedEdge) {  		edgeVerts.Clear ();  		edgeVerts.Capacity = Mathf.Max (edgeVerts.Capacity' edgeIndices.Count);  		for (int i = 0; i < edgeIndices.Count; ++i) {  			edgeVerts.Add (verts [edgeIndices [i]]);  		}  		edges.Add (edgeVerts.ToArray ());  		edgeIndices.Clear ();  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder2D,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder2D.cs,MergeEdges,The following statement contains a magic number: for (int i = 0; i < edgeUsed.Length; ++i) {  	if (!edgeUsed [i]) {  		edgeUsed [i] = true;  		int v0 = indices [i * 2 + 0];  		int v1 = indices [i * 2 + 1];  		d0 = (verts [v1] - verts [v0]).normalized;  		edgeIndices.Add (v0);  		edgeIndices.Add (v1);  		// The connecting vertex for this edge list  		for (int k = i + 1; k < edgeUsed.Length; ++k) {  			if (edgeUsed [k]) {  				continue;  			}  			int w0 = indices [k * 2 + 0];  			if (w0 == v1) {  				int w1 = indices [k * 2 + 1];  				d1 = (verts [w1] - verts [w0]).normalized;  				// Same direction?  				if (Vector2.Dot (d1' d0) > 0.999f) {  					edgeIndices.RemoveAt (edgeIndices.Count - 1);  					// remove last  				}  				edgeIndices.Add (w1);  				edgeUsed [k] = true;  				d0 = d1;  				// new normal  				k = i;  				// restart the loop  				v1 = w1;  				// continuing from the end of the loop  				continue;  			}  		}  		processedEdge = true;  		break;  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder2D,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder2D.cs,MergeEdges,The following statement contains a magic number: for (int i = 0; i < edgeUsed.Length; ++i) {  	if (!edgeUsed [i]) {  		edgeUsed [i] = true;  		int v0 = indices [i * 2 + 0];  		int v1 = indices [i * 2 + 1];  		d0 = (verts [v1] - verts [v0]).normalized;  		edgeIndices.Add (v0);  		edgeIndices.Add (v1);  		// The connecting vertex for this edge list  		for (int k = i + 1; k < edgeUsed.Length; ++k) {  			if (edgeUsed [k]) {  				continue;  			}  			int w0 = indices [k * 2 + 0];  			if (w0 == v1) {  				int w1 = indices [k * 2 + 1];  				d1 = (verts [w1] - verts [w0]).normalized;  				// Same direction?  				if (Vector2.Dot (d1' d0) > 0.999f) {  					edgeIndices.RemoveAt (edgeIndices.Count - 1);  					// remove last  				}  				edgeIndices.Add (w1);  				edgeUsed [k] = true;  				d0 = d1;  				// new normal  				k = i;  				// restart the loop  				v1 = w1;  				// continuing from the end of the loop  				continue;  			}  		}  		processedEdge = true;  		break;  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder2D,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder2D.cs,MergeEdges,The following statement contains a magic number: for (int i = 0; i < edgeUsed.Length; ++i) {  	if (!edgeUsed [i]) {  		edgeUsed [i] = true;  		int v0 = indices [i * 2 + 0];  		int v1 = indices [i * 2 + 1];  		d0 = (verts [v1] - verts [v0]).normalized;  		edgeIndices.Add (v0);  		edgeIndices.Add (v1);  		// The connecting vertex for this edge list  		for (int k = i + 1; k < edgeUsed.Length; ++k) {  			if (edgeUsed [k]) {  				continue;  			}  			int w0 = indices [k * 2 + 0];  			if (w0 == v1) {  				int w1 = indices [k * 2 + 1];  				d1 = (verts [w1] - verts [w0]).normalized;  				// Same direction?  				if (Vector2.Dot (d1' d0) > 0.999f) {  					edgeIndices.RemoveAt (edgeIndices.Count - 1);  					// remove last  				}  				edgeIndices.Add (w1);  				edgeUsed [k] = true;  				d0 = d1;  				// new normal  				k = i;  				// restart the loop  				v1 = w1;  				// continuing from the end of the loop  				continue;  			}  		}  		processedEdge = true;  		break;  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder2D,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder2D.cs,MergeEdges,The following statement contains a magic number: for (int i = 0; i < edgeUsed.Length; ++i) {  	if (!edgeUsed [i]) {  		edgeUsed [i] = true;  		int v0 = indices [i * 2 + 0];  		int v1 = indices [i * 2 + 1];  		d0 = (verts [v1] - verts [v0]).normalized;  		edgeIndices.Add (v0);  		edgeIndices.Add (v1);  		// The connecting vertex for this edge list  		for (int k = i + 1; k < edgeUsed.Length; ++k) {  			if (edgeUsed [k]) {  				continue;  			}  			int w0 = indices [k * 2 + 0];  			if (w0 == v1) {  				int w1 = indices [k * 2 + 1];  				d1 = (verts [w1] - verts [w0]).normalized;  				// Same direction?  				if (Vector2.Dot (d1' d0) > 0.999f) {  					edgeIndices.RemoveAt (edgeIndices.Count - 1);  					// remove last  				}  				edgeIndices.Add (w1);  				edgeUsed [k] = true;  				d0 = d1;  				// new normal  				k = i;  				// restart the loop  				v1 = w1;  				// continuing from the end of the loop  				continue;  			}  		}  		processedEdge = true;  		break;  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder2D,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder2D.cs,MergeEdges,The following statement contains a magic number: if (!edgeUsed [i]) {  	edgeUsed [i] = true;  	int v0 = indices [i * 2 + 0];  	int v1 = indices [i * 2 + 1];  	d0 = (verts [v1] - verts [v0]).normalized;  	edgeIndices.Add (v0);  	edgeIndices.Add (v1);  	// The connecting vertex for this edge list  	for (int k = i + 1; k < edgeUsed.Length; ++k) {  		if (edgeUsed [k]) {  			continue;  		}  		int w0 = indices [k * 2 + 0];  		if (w0 == v1) {  			int w1 = indices [k * 2 + 1];  			d1 = (verts [w1] - verts [w0]).normalized;  			// Same direction?  			if (Vector2.Dot (d1' d0) > 0.999f) {  				edgeIndices.RemoveAt (edgeIndices.Count - 1);  				// remove last  			}  			edgeIndices.Add (w1);  			edgeUsed [k] = true;  			d0 = d1;  			// new normal  			k = i;  			// restart the loop  			v1 = w1;  			// continuing from the end of the loop  			continue;  		}  	}  	processedEdge = true;  	break;  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder2D,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder2D.cs,MergeEdges,The following statement contains a magic number: if (!edgeUsed [i]) {  	edgeUsed [i] = true;  	int v0 = indices [i * 2 + 0];  	int v1 = indices [i * 2 + 1];  	d0 = (verts [v1] - verts [v0]).normalized;  	edgeIndices.Add (v0);  	edgeIndices.Add (v1);  	// The connecting vertex for this edge list  	for (int k = i + 1; k < edgeUsed.Length; ++k) {  		if (edgeUsed [k]) {  			continue;  		}  		int w0 = indices [k * 2 + 0];  		if (w0 == v1) {  			int w1 = indices [k * 2 + 1];  			d1 = (verts [w1] - verts [w0]).normalized;  			// Same direction?  			if (Vector2.Dot (d1' d0) > 0.999f) {  				edgeIndices.RemoveAt (edgeIndices.Count - 1);  				// remove last  			}  			edgeIndices.Add (w1);  			edgeUsed [k] = true;  			d0 = d1;  			// new normal  			k = i;  			// restart the loop  			v1 = w1;  			// continuing from the end of the loop  			continue;  		}  	}  	processedEdge = true;  	break;  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder2D,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder2D.cs,MergeEdges,The following statement contains a magic number: if (!edgeUsed [i]) {  	edgeUsed [i] = true;  	int v0 = indices [i * 2 + 0];  	int v1 = indices [i * 2 + 1];  	d0 = (verts [v1] - verts [v0]).normalized;  	edgeIndices.Add (v0);  	edgeIndices.Add (v1);  	// The connecting vertex for this edge list  	for (int k = i + 1; k < edgeUsed.Length; ++k) {  		if (edgeUsed [k]) {  			continue;  		}  		int w0 = indices [k * 2 + 0];  		if (w0 == v1) {  			int w1 = indices [k * 2 + 1];  			d1 = (verts [w1] - verts [w0]).normalized;  			// Same direction?  			if (Vector2.Dot (d1' d0) > 0.999f) {  				edgeIndices.RemoveAt (edgeIndices.Count - 1);  				// remove last  			}  			edgeIndices.Add (w1);  			edgeUsed [k] = true;  			d0 = d1;  			// new normal  			k = i;  			// restart the loop  			v1 = w1;  			// continuing from the end of the loop  			continue;  		}  	}  	processedEdge = true;  	break;  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder2D,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder2D.cs,MergeEdges,The following statement contains a magic number: if (!edgeUsed [i]) {  	edgeUsed [i] = true;  	int v0 = indices [i * 2 + 0];  	int v1 = indices [i * 2 + 1];  	d0 = (verts [v1] - verts [v0]).normalized;  	edgeIndices.Add (v0);  	edgeIndices.Add (v1);  	// The connecting vertex for this edge list  	for (int k = i + 1; k < edgeUsed.Length; ++k) {  		if (edgeUsed [k]) {  			continue;  		}  		int w0 = indices [k * 2 + 0];  		if (w0 == v1) {  			int w1 = indices [k * 2 + 1];  			d1 = (verts [w1] - verts [w0]).normalized;  			// Same direction?  			if (Vector2.Dot (d1' d0) > 0.999f) {  				edgeIndices.RemoveAt (edgeIndices.Count - 1);  				// remove last  			}  			edgeIndices.Add (w1);  			edgeUsed [k] = true;  			d0 = d1;  			// new normal  			k = i;  			// restart the loop  			v1 = w1;  			// continuing from the end of the loop  			continue;  		}  	}  	processedEdge = true;  	break;  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder2D,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder2D.cs,MergeEdges,The following statement contains a magic number: for (int k = i + 1; k < edgeUsed.Length; ++k) {  	if (edgeUsed [k]) {  		continue;  	}  	int w0 = indices [k * 2 + 0];  	if (w0 == v1) {  		int w1 = indices [k * 2 + 1];  		d1 = (verts [w1] - verts [w0]).normalized;  		// Same direction?  		if (Vector2.Dot (d1' d0) > 0.999f) {  			edgeIndices.RemoveAt (edgeIndices.Count - 1);  			// remove last  		}  		edgeIndices.Add (w1);  		edgeUsed [k] = true;  		d0 = d1;  		// new normal  		k = i;  		// restart the loop  		v1 = w1;  		// continuing from the end of the loop  		continue;  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder2D,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder2D.cs,MergeEdges,The following statement contains a magic number: for (int k = i + 1; k < edgeUsed.Length; ++k) {  	if (edgeUsed [k]) {  		continue;  	}  	int w0 = indices [k * 2 + 0];  	if (w0 == v1) {  		int w1 = indices [k * 2 + 1];  		d1 = (verts [w1] - verts [w0]).normalized;  		// Same direction?  		if (Vector2.Dot (d1' d0) > 0.999f) {  			edgeIndices.RemoveAt (edgeIndices.Count - 1);  			// remove last  		}  		edgeIndices.Add (w1);  		edgeUsed [k] = true;  		d0 = d1;  		// new normal  		k = i;  		// restart the loop  		v1 = w1;  		// continuing from the end of the loop  		continue;  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder2D,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder2D.cs,MergeEdges,The following statement contains a magic number: if (w0 == v1) {  	int w1 = indices [k * 2 + 1];  	d1 = (verts [w1] - verts [w0]).normalized;  	// Same direction?  	if (Vector2.Dot (d1' d0) > 0.999f) {  		edgeIndices.RemoveAt (edgeIndices.Count - 1);  		// remove last  	}  	edgeIndices.Add (w1);  	edgeUsed [k] = true;  	d0 = d1;  	// new normal  	k = i;  	// restart the loop  	v1 = w1;  	// continuing from the end of the loop  	continue;  }  
Magic Number,SimpleJSON,JSONNode,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\Utility\SimpleJSON.cs,Parse,The following statement contains a magic number: while (i < aJSON.Length) {  	switch (aJSON [i]) {  	case '{':  		if (QuoteMode) {  			Token += aJSON [i];  			break;  		}  		stack.Push (new JSONClass ());  		if (ctx != null) {  			TokenName = TokenName.Trim ();  			if (ctx is JSONArray)  				ctx.Add (stack.Peek ());  			else if (TokenName != "")  				ctx.Add (TokenName' stack.Peek ());  		}  		TokenName = "";  		Token = "";  		ctx = stack.Peek ();  		break;  	case '[':  		if (QuoteMode) {  			Token += aJSON [i];  			break;  		}  		stack.Push (new JSONArray ());  		if (ctx != null) {  			TokenName = TokenName.Trim ();  			if (ctx is JSONArray)  				ctx.Add (stack.Peek ());  			else if (TokenName != "")  				ctx.Add (TokenName' stack.Peek ());  		}  		TokenName = "";  		Token = "";  		ctx = stack.Peek ();  		break;  	case '}':  	case ']':  		if (QuoteMode) {  			Token += aJSON [i];  			break;  		}  		if (stack.Count == 0)  			throw new Exception ("JSON Parse: Too many closing brackets");  		stack.Pop ();  		if (Token != "") {  			TokenName = TokenName.Trim ();  			if (ctx is JSONArray)  				ctx.Add (Token);  			else if (TokenName != "")  				ctx.Add (TokenName' Token);  		}  		TokenName = "";  		Token = "";  		if (stack.Count > 0)  			ctx = stack.Peek ();  		break;  	case ':':  		if (QuoteMode) {  			Token += aJSON [i];  			break;  		}  		TokenName = Token;  		Token = "";  		break;  	case '"':  		QuoteMode ^= true;  		break;  	case ''':  		if (QuoteMode) {  			Token += aJSON [i];  			break;  		}  		if (Token != "") {  			if (ctx is JSONArray)  				ctx.Add (Token);  			else if (TokenName != "")  				ctx.Add (TokenName' Token);  		}  		TokenName = "";  		Token = "";  		break;  	case '\r':  	case '\n':  		break;  	case ' ':  	case '\t':  		if (QuoteMode)  			Token += aJSON [i];  		break;  	case '\\':  		++i;  		if (QuoteMode) {  			char C = aJSON [i];  			switch (C) {  			case 't':  				Token += '\t';  				break;  			case 'r':  				Token += '\r';  				break;  			case 'n':  				Token += '\n';  				break;  			case 'b':  				Token += '\b';  				break;  			case 'f':  				Token += '\f';  				break;  			case 'u': {  				string s = aJSON.Substring (i + 1' 4);  				Token += (char)int.Parse (s' System.Globalization.NumberStyles.AllowHexSpecifier);  				i += 4;  				break;  			}  			default:  				Token += C;  				break;  			}  		}  		break;  	default:  		Token += aJSON [i];  		break;  	}  	++i;  }  
Magic Number,SimpleJSON,JSONNode,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\Utility\SimpleJSON.cs,Parse,The following statement contains a magic number: while (i < aJSON.Length) {  	switch (aJSON [i]) {  	case '{':  		if (QuoteMode) {  			Token += aJSON [i];  			break;  		}  		stack.Push (new JSONClass ());  		if (ctx != null) {  			TokenName = TokenName.Trim ();  			if (ctx is JSONArray)  				ctx.Add (stack.Peek ());  			else if (TokenName != "")  				ctx.Add (TokenName' stack.Peek ());  		}  		TokenName = "";  		Token = "";  		ctx = stack.Peek ();  		break;  	case '[':  		if (QuoteMode) {  			Token += aJSON [i];  			break;  		}  		stack.Push (new JSONArray ());  		if (ctx != null) {  			TokenName = TokenName.Trim ();  			if (ctx is JSONArray)  				ctx.Add (stack.Peek ());  			else if (TokenName != "")  				ctx.Add (TokenName' stack.Peek ());  		}  		TokenName = "";  		Token = "";  		ctx = stack.Peek ();  		break;  	case '}':  	case ']':  		if (QuoteMode) {  			Token += aJSON [i];  			break;  		}  		if (stack.Count == 0)  			throw new Exception ("JSON Parse: Too many closing brackets");  		stack.Pop ();  		if (Token != "") {  			TokenName = TokenName.Trim ();  			if (ctx is JSONArray)  				ctx.Add (Token);  			else if (TokenName != "")  				ctx.Add (TokenName' Token);  		}  		TokenName = "";  		Token = "";  		if (stack.Count > 0)  			ctx = stack.Peek ();  		break;  	case ':':  		if (QuoteMode) {  			Token += aJSON [i];  			break;  		}  		TokenName = Token;  		Token = "";  		break;  	case '"':  		QuoteMode ^= true;  		break;  	case ''':  		if (QuoteMode) {  			Token += aJSON [i];  			break;  		}  		if (Token != "") {  			if (ctx is JSONArray)  				ctx.Add (Token);  			else if (TokenName != "")  				ctx.Add (TokenName' Token);  		}  		TokenName = "";  		Token = "";  		break;  	case '\r':  	case '\n':  		break;  	case ' ':  	case '\t':  		if (QuoteMode)  			Token += aJSON [i];  		break;  	case '\\':  		++i;  		if (QuoteMode) {  			char C = aJSON [i];  			switch (C) {  			case 't':  				Token += '\t';  				break;  			case 'r':  				Token += '\r';  				break;  			case 'n':  				Token += '\n';  				break;  			case 'b':  				Token += '\b';  				break;  			case 'f':  				Token += '\f';  				break;  			case 'u': {  				string s = aJSON.Substring (i + 1' 4);  				Token += (char)int.Parse (s' System.Globalization.NumberStyles.AllowHexSpecifier);  				i += 4;  				break;  			}  			default:  				Token += C;  				break;  			}  		}  		break;  	default:  		Token += aJSON [i];  		break;  	}  	++i;  }  
Magic Number,SimpleJSON,JSONNode,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\Utility\SimpleJSON.cs,Parse,The following statement contains a magic number: switch (aJSON [i]) {  case '{':  	if (QuoteMode) {  		Token += aJSON [i];  		break;  	}  	stack.Push (new JSONClass ());  	if (ctx != null) {  		TokenName = TokenName.Trim ();  		if (ctx is JSONArray)  			ctx.Add (stack.Peek ());  		else if (TokenName != "")  			ctx.Add (TokenName' stack.Peek ());  	}  	TokenName = "";  	Token = "";  	ctx = stack.Peek ();  	break;  case '[':  	if (QuoteMode) {  		Token += aJSON [i];  		break;  	}  	stack.Push (new JSONArray ());  	if (ctx != null) {  		TokenName = TokenName.Trim ();  		if (ctx is JSONArray)  			ctx.Add (stack.Peek ());  		else if (TokenName != "")  			ctx.Add (TokenName' stack.Peek ());  	}  	TokenName = "";  	Token = "";  	ctx = stack.Peek ();  	break;  case '}':  case ']':  	if (QuoteMode) {  		Token += aJSON [i];  		break;  	}  	if (stack.Count == 0)  		throw new Exception ("JSON Parse: Too many closing brackets");  	stack.Pop ();  	if (Token != "") {  		TokenName = TokenName.Trim ();  		if (ctx is JSONArray)  			ctx.Add (Token);  		else if (TokenName != "")  			ctx.Add (TokenName' Token);  	}  	TokenName = "";  	Token = "";  	if (stack.Count > 0)  		ctx = stack.Peek ();  	break;  case ':':  	if (QuoteMode) {  		Token += aJSON [i];  		break;  	}  	TokenName = Token;  	Token = "";  	break;  case '"':  	QuoteMode ^= true;  	break;  case ''':  	if (QuoteMode) {  		Token += aJSON [i];  		break;  	}  	if (Token != "") {  		if (ctx is JSONArray)  			ctx.Add (Token);  		else if (TokenName != "")  			ctx.Add (TokenName' Token);  	}  	TokenName = "";  	Token = "";  	break;  case '\r':  case '\n':  	break;  case ' ':  case '\t':  	if (QuoteMode)  		Token += aJSON [i];  	break;  case '\\':  	++i;  	if (QuoteMode) {  		char C = aJSON [i];  		switch (C) {  		case 't':  			Token += '\t';  			break;  		case 'r':  			Token += '\r';  			break;  		case 'n':  			Token += '\n';  			break;  		case 'b':  			Token += '\b';  			break;  		case 'f':  			Token += '\f';  			break;  		case 'u': {  			string s = aJSON.Substring (i + 1' 4);  			Token += (char)int.Parse (s' System.Globalization.NumberStyles.AllowHexSpecifier);  			i += 4;  			break;  		}  		default:  			Token += C;  			break;  		}  	}  	break;  default:  	Token += aJSON [i];  	break;  }  
Magic Number,SimpleJSON,JSONNode,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\Utility\SimpleJSON.cs,Parse,The following statement contains a magic number: switch (aJSON [i]) {  case '{':  	if (QuoteMode) {  		Token += aJSON [i];  		break;  	}  	stack.Push (new JSONClass ());  	if (ctx != null) {  		TokenName = TokenName.Trim ();  		if (ctx is JSONArray)  			ctx.Add (stack.Peek ());  		else if (TokenName != "")  			ctx.Add (TokenName' stack.Peek ());  	}  	TokenName = "";  	Token = "";  	ctx = stack.Peek ();  	break;  case '[':  	if (QuoteMode) {  		Token += aJSON [i];  		break;  	}  	stack.Push (new JSONArray ());  	if (ctx != null) {  		TokenName = TokenName.Trim ();  		if (ctx is JSONArray)  			ctx.Add (stack.Peek ());  		else if (TokenName != "")  			ctx.Add (TokenName' stack.Peek ());  	}  	TokenName = "";  	Token = "";  	ctx = stack.Peek ();  	break;  case '}':  case ']':  	if (QuoteMode) {  		Token += aJSON [i];  		break;  	}  	if (stack.Count == 0)  		throw new Exception ("JSON Parse: Too many closing brackets");  	stack.Pop ();  	if (Token != "") {  		TokenName = TokenName.Trim ();  		if (ctx is JSONArray)  			ctx.Add (Token);  		else if (TokenName != "")  			ctx.Add (TokenName' Token);  	}  	TokenName = "";  	Token = "";  	if (stack.Count > 0)  		ctx = stack.Peek ();  	break;  case ':':  	if (QuoteMode) {  		Token += aJSON [i];  		break;  	}  	TokenName = Token;  	Token = "";  	break;  case '"':  	QuoteMode ^= true;  	break;  case ''':  	if (QuoteMode) {  		Token += aJSON [i];  		break;  	}  	if (Token != "") {  		if (ctx is JSONArray)  			ctx.Add (Token);  		else if (TokenName != "")  			ctx.Add (TokenName' Token);  	}  	TokenName = "";  	Token = "";  	break;  case '\r':  case '\n':  	break;  case ' ':  case '\t':  	if (QuoteMode)  		Token += aJSON [i];  	break;  case '\\':  	++i;  	if (QuoteMode) {  		char C = aJSON [i];  		switch (C) {  		case 't':  			Token += '\t';  			break;  		case 'r':  			Token += '\r';  			break;  		case 'n':  			Token += '\n';  			break;  		case 'b':  			Token += '\b';  			break;  		case 'f':  			Token += '\f';  			break;  		case 'u': {  			string s = aJSON.Substring (i + 1' 4);  			Token += (char)int.Parse (s' System.Globalization.NumberStyles.AllowHexSpecifier);  			i += 4;  			break;  		}  		default:  			Token += C;  			break;  		}  	}  	break;  default:  	Token += aJSON [i];  	break;  }  
Magic Number,SimpleJSON,JSONNode,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\Utility\SimpleJSON.cs,Parse,The following statement contains a magic number: if (QuoteMode) {  	char C = aJSON [i];  	switch (C) {  	case 't':  		Token += '\t';  		break;  	case 'r':  		Token += '\r';  		break;  	case 'n':  		Token += '\n';  		break;  	case 'b':  		Token += '\b';  		break;  	case 'f':  		Token += '\f';  		break;  	case 'u': {  		string s = aJSON.Substring (i + 1' 4);  		Token += (char)int.Parse (s' System.Globalization.NumberStyles.AllowHexSpecifier);  		i += 4;  		break;  	}  	default:  		Token += C;  		break;  	}  }  
Magic Number,SimpleJSON,JSONNode,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\Utility\SimpleJSON.cs,Parse,The following statement contains a magic number: if (QuoteMode) {  	char C = aJSON [i];  	switch (C) {  	case 't':  		Token += '\t';  		break;  	case 'r':  		Token += '\r';  		break;  	case 'n':  		Token += '\n';  		break;  	case 'b':  		Token += '\b';  		break;  	case 'f':  		Token += '\f';  		break;  	case 'u': {  		string s = aJSON.Substring (i + 1' 4);  		Token += (char)int.Parse (s' System.Globalization.NumberStyles.AllowHexSpecifier);  		i += 4;  		break;  	}  	default:  		Token += C;  		break;  	}  }  
Magic Number,SimpleJSON,JSONNode,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\Utility\SimpleJSON.cs,Parse,The following statement contains a magic number: switch (C) {  case 't':  	Token += '\t';  	break;  case 'r':  	Token += '\r';  	break;  case 'n':  	Token += '\n';  	break;  case 'b':  	Token += '\b';  	break;  case 'f':  	Token += '\f';  	break;  case 'u': {  	string s = aJSON.Substring (i + 1' 4);  	Token += (char)int.Parse (s' System.Globalization.NumberStyles.AllowHexSpecifier);  	i += 4;  	break;  }  default:  	Token += C;  	break;  }  
Magic Number,SimpleJSON,JSONNode,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\Utility\SimpleJSON.cs,Parse,The following statement contains a magic number: switch (C) {  case 't':  	Token += '\t';  	break;  case 'r':  	Token += '\r';  	break;  case 'n':  	Token += '\n';  	break;  case 'b':  	Token += '\b';  	break;  case 'f':  	Token += '\f';  	break;  case 'u': {  	string s = aJSON.Substring (i + 1' 4);  	Token += (char)int.Parse (s' System.Globalization.NumberStyles.AllowHexSpecifier);  	i += 4;  	break;  }  default:  	Token += C;  	break;  }  
Magic Number,SimpleJSON,JSONNode,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\Utility\SimpleJSON.cs,Parse,The following statement contains a magic number: i += 4;  
Magic Number,SimpleJSON,JSONArray,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\Utility\SimpleJSON.cs,ToString,The following statement contains a magic number: foreach (JSONNode N in m_List) {  	if (result.Length > 2)  		result += "' ";  	result += N.ToString ();  }  
Magic Number,SimpleJSON,JSONArray,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\Utility\SimpleJSON.cs,ToString,The following statement contains a magic number: if (result.Length > 2)  	result += "' ";  
Magic Number,SimpleJSON,JSONArray,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\Utility\SimpleJSON.cs,ToString,The following statement contains a magic number: foreach (JSONNode N in m_List) {  	if (result.Length > 3)  		result += "' ";  	result += "\n" + aPrefix + "   ";  	result += N.ToString (aPrefix + "   ");  }  
Magic Number,SimpleJSON,JSONArray,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\Utility\SimpleJSON.cs,ToString,The following statement contains a magic number: if (result.Length > 3)  	result += "' ";  
Magic Number,SimpleJSON,JSONClass,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\Utility\SimpleJSON.cs,ToString,The following statement contains a magic number: foreach (KeyValuePair<string' JSONNode> N in m_Dict) {  	if (result.Length > 2)  		result += "' ";  	result += "\"" + Escape (N.Key) + "\":" + N.Value.ToString ();  }  
Magic Number,SimpleJSON,JSONClass,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\Utility\SimpleJSON.cs,ToString,The following statement contains a magic number: if (result.Length > 2)  	result += "' ";  
Magic Number,SimpleJSON,JSONClass,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\Utility\SimpleJSON.cs,ToString,The following statement contains a magic number: foreach (KeyValuePair<string' JSONNode> N in m_Dict) {  	if (result.Length > 3)  		result += "' ";  	result += "\n" + aPrefix + "   ";  	result += "\"" + Escape (N.Key) + "\" : " + N.Value.ToString (aPrefix + "   ");  }  
Magic Number,SimpleJSON,JSONClass,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\Utility\SimpleJSON.cs,ToString,The following statement contains a magic number: if (result.Length > 3)  	result += "' ";  
Missing Default,AceViral,MsgBox,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\AVSharedScripts\AceVIral\MsgBox.cs,ShowMsgDialog,The following switch statement is missing a default case: switch (message.MsgType) {  case MsgBoxType.OK:  	SetMsgBoxAsTypeOK ();  	break;  case MsgBoxType.YES_NO:  	SetMsgBoxAsTypeYesNo ();  	break;  }  
Missing Default,tk2dRuntime,SpriteCollectionGenerator,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following switch statement is missing a default case: switch (state) {  case 0:  	{  		switch (cmd) {  		case 'i':  			break;  		// ignore version field for now  		case 'w':  			textureDimensions.x = Int32.Parse (line.Substring (2));  			break;  		case 'h':  			textureDimensions.y = Int32.Parse (line.Substring (2));  			break;  		// total number of sprites would be ideal to statically allocate  		case '~':  			state++;  			break;  		}  	}  	break;  case 1:  	{  		switch (cmd) {  		case 'n':  			entryName = line.Substring (2);  			break;  		case 'r':  			entryRotated = Int32.Parse (line.Substring (2)) == 1;  			break;  		case 's':  			{  				// sprite  				string[] tokens = line.Split ();  				entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  			}  			break;  		case 'o':  			{  				// origin  				string[] tokens = line.Split ();  				entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  				entryTrimmed = true;  			}  			break;  		case '~':  			{  				names.Add (entryName);  				rotated.Add (entryRotated);  				rects.Add (entryRect);  				if (!entryTrimmed) {  					// The entryRect dimensions will be the wrong way around if the sprite is rotated  					if (entryRotated)  						entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  					else  						entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  				}  				trimRects.Add (entryTrimData);  				anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  				anchors.Add (anchor);  				entryName = "";  				entryTrimmed = false;  				entryRotated = false;  			}  			break;  		}  	}  	break;  }  
Missing Default,tk2dRuntime,SpriteCollectionGenerator,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following switch statement is missing a default case: switch (cmd) {  case 'i':  	break;  // ignore version field for now  case 'w':  	textureDimensions.x = Int32.Parse (line.Substring (2));  	break;  case 'h':  	textureDimensions.y = Int32.Parse (line.Substring (2));  	break;  // total number of sprites would be ideal to statically allocate  case '~':  	state++;  	break;  }  
Missing Default,tk2dRuntime,SpriteCollectionGenerator,C:\repos\JasonAceViral_CrotchDogs\CrotchDogs\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following switch statement is missing a default case: switch (cmd) {  case 'n':  	entryName = line.Substring (2);  	break;  case 'r':  	entryRotated = Int32.Parse (line.Substring (2)) == 1;  	break;  case 's':  	{  		// sprite  		string[] tokens = line.Split ();  		entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  	}  	break;  case 'o':  	{  		// origin  		string[] tokens = line.Split ();  		entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  		entryTrimmed = true;  	}  	break;  case '~':  	{  		names.Add (entryName);  		rotated.Add (entryRotated);  		rects.Add (entryRect);  		if (!entryTrimmed) {  			// The entryRect dimensions will be the wrong way around if the sprite is rotated  			if (entryRotated)  				entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  			else  				entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  		}  		trimRects.Add (entryTrimData);  		anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  		anchors.Add (anchor);  		entryName = "";  		entryTrimmed = false;  		entryRotated = false;  	}  	break;  }  
