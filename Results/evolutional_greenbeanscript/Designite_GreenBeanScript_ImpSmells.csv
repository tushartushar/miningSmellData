Implementation smell,Namespace,Class,File,Method,Description
Long Method,GreenBeanScript,Library,C:\repos\evolutional_greenbeanscript\GreenBeanScript\VirtualMachine\Library.cs,ListBytecode,The method has 223 lines of code.
Long Method,GreenBeanScript,Library,C:\repos\evolutional_greenbeanscript\GreenBeanScript\VirtualMachine\Library.cs,Load,The method has 208 lines of code.
Long Method,GreenBeanScript,Thread,C:\repos\evolutional_greenbeanscript\GreenBeanScript\VirtualMachine\Thread.cs,Execute,The method has 341 lines of code.
Complex Method,GreenBeanScript,Library,C:\repos\evolutional_greenbeanscript\GreenBeanScript\VirtualMachine\Library.cs,ListBytecode,Cyclomatic complexity of the method is 196
Complex Method,GreenBeanScript,Library,C:\repos\evolutional_greenbeanscript\GreenBeanScript\VirtualMachine\Library.cs,Load,Cyclomatic complexity of the method is 65
Complex Method,GreenBeanScript,Thread,C:\repos\evolutional_greenbeanscript\GreenBeanScript\VirtualMachine\Thread.cs,PushStackFrame,Cyclomatic complexity of the method is 16
Complex Method,GreenBeanScript,Thread,C:\repos\evolutional_greenbeanscript\GreenBeanScript\VirtualMachine\Thread.cs,Execute,Cyclomatic complexity of the method is 127
Complex Method,GreenBeanScript,Machine,C:\repos\evolutional_greenbeanscript\GreenBeanScript\VirtualMachine\Machine.cs,SwitchThreadState,Cyclomatic complexity of the method is 24
Long Parameter List,TableOperators,OperatorCallbacks,C:\repos\evolutional_greenbeanscript\GreenBeanScript\VirtualMachine\Operations\TableObject.cs,Iterator,The method has 5 parameters.
Long Statement,GreenBeanScript,Library,C:\repos\evolutional_greenbeanscript\GreenBeanScript\VirtualMachine\Library.cs,List,The length of the statement  "	log.AppendFormat ("STRING TABLE' SIZE={0}\r\n" + "===============================================================================\r\n"' stringTable.Size.ToString ().PadLeft (5)); " is 178.
Long Statement,GreenBeanScript,Library,C:\repos\evolutional_greenbeanscript\GreenBeanScript\VirtualMachine\Library.cs,List,The length of the statement  "	log.AppendFormat ("FUNCTIONS' COUNT={0}\r\n" + "===============================================================================\r\n\r\n"' numFunctions); " is 152.
Long Statement,GreenBeanScript,Library,C:\repos\evolutional_greenbeanscript\GreenBeanScript\VirtualMachine\Library.cs,Load,The length of the statement  "			else if ((instruction.OpCode == ByteCode.Opcode.Bra) || (instruction.OpCode == ByteCode.Opcode.Brz) || (instruction.OpCode == ByteCode.Opcode.Brzk)) { " is 150.
Long Statement,GreenBeanScript,Thread,C:\repos\evolutional_greenbeanscript\GreenBeanScript\VirtualMachine\Thread.cs,Execute,The length of the statement  "				_stack.PokeAbs (operand - 2' op (this' _stack.PeekAbs (operand - 2)' _stack.PeekAbs (operand - 1)' _stack.PeekAbs (operand))); " is 126.
Long Statement,GreenBeanScript,Thread,C:\repos\evolutional_greenbeanscript\GreenBeanScript\VirtualMachine\Thread.cs,Execute,The length of the statement  "				_stack.PokeAbs (operand - 2' op (this' _stack.PeekAbs (operand - 2)' _stack.PeekAbs (operand - 1)' _stack.PeekAbs (operand))); " is 126.
Long Statement,GreenBeanScript,Thread,C:\repos\evolutional_greenbeanscript\GreenBeanScript\VirtualMachine\Thread.cs,Execute,The length of the statement  "			iteratorPos = itr (this' obj' iteratorPos' _stack.PeekBase (inst [1].GetInteger ())' _stack.PeekBase (inst [0].GetInteger ())); " is 127.
Magic Number,GreenBeanScript.Libs,StdLibrary,C:\repos\evolutional_greenbeanscript\GreenBeanScript\Libs\StdLibrary.cs,Tick,The following statement contains a magic number: ScriptThread.PushInteger ((d.Minutes * 60) + d.Seconds);  
Magic Number,GreenBeanScript.Libs,StdLibrary,C:\repos\evolutional_greenbeanscript\GreenBeanScript\Libs\StdLibrary.cs,FormatFunction,The following statement contains a magic number: while (charnum < format.Length) {  	var c = format [charnum];  	if (c == '%') {  		var c1 = format [charnum + 1];  		switch (c1) {  		case 'X':  		case 'x': {  			if (!ScriptThread.Param (param).IsInt) {  				return FunctionResult.Exception;  			}  			sb.AppendFormat ("{0:X}"' ScriptThread.Param (param).GetIntegerNoCheck ());  			++param;  			break;  		}  		}  		charnum += 2;  	}  	else {  		sb.Append (c);  		++charnum;  	}  }  
Magic Number,GreenBeanScript.Libs,StdLibrary,C:\repos\evolutional_greenbeanscript\GreenBeanScript\Libs\StdLibrary.cs,FormatFunction,The following statement contains a magic number: if (c == '%') {  	var c1 = format [charnum + 1];  	switch (c1) {  	case 'X':  	case 'x': {  		if (!ScriptThread.Param (param).IsInt) {  			return FunctionResult.Exception;  		}  		sb.AppendFormat ("{0:X}"' ScriptThread.Param (param).GetIntegerNoCheck ());  		++param;  		break;  	}  	}  	charnum += 2;  }  else {  	sb.Append (c);  	++charnum;  }  
Magic Number,GreenBeanScript.Libs,StdLibrary,C:\repos\evolutional_greenbeanscript\GreenBeanScript\Libs\StdLibrary.cs,FormatFunction,The following statement contains a magic number: charnum += 2;  
Magic Number,GreenBeanScript.Libs,StdLibrary,C:\repos\evolutional_greenbeanscript\GreenBeanScript\Libs\StdLibrary.cs,BlockFunction,The following statement contains a magic number: if (res == -1) {  	return FunctionResult.Sys_Block;  }  else if (res == -2) {  	return FunctionResult.Sys_Yield;  }  
Magic Number,GreenBeanScript.Libs,StdLibrary,C:\repos\evolutional_greenbeanscript\GreenBeanScript\Libs\StdLibrary.cs,BlockFunction,The following statement contains a magic number: if (res == -2) {  	return FunctionResult.Sys_Yield;  }  
Magic Number,GreenBeanScript,Library,C:\repos\evolutional_greenbeanscript\GreenBeanScript\VirtualMachine\Library.cs,List,The following statement contains a magic number: log.AppendFormat ("STRING TABLE' SIZE={0}\r\n" + "===============================================================================\r\n"' stringTable.Size.ToString ().PadLeft (5));  
Magic Number,GreenBeanScript,Library,C:\repos\evolutional_greenbeanscript\GreenBeanScript\VirtualMachine\Library.cs,ListBytecode,The following statement contains a magic number: while (instruction < end) {  	var opiptr = false;  	var opf32 = false;  	var opisymbol = false;  	var cp = "";  	int addr = instruction - start;  	var bc = BitConverter.ToUInt32 (byteCode' instruction);  	switch ((ByteCode.Opcode)bc) {  	case ByteCode.Opcode.Nop:  		cp = "nop";  		break;  	case ByteCode.Opcode.Line:  		cp = "line";  		break;  	case ByteCode.Opcode.GetDot:  		cp = "get dot";  		opiptr = true;  		break;  	case ByteCode.Opcode.SetDot:  		cp = "set dot";  		opiptr = true;  		break;  	case ByteCode.Opcode.GetInd:  		cp = "get index";  		break;  	case ByteCode.Opcode.SetInd:  		cp = "set index";  		break;  	case ByteCode.Opcode.Bra:  		cp = "bra";  		opiptr = true;  		break;  	case ByteCode.Opcode.Brz:  		cp = "brz";  		opiptr = true;  		break;  	case ByteCode.Opcode.Brnz:  		cp = "brnz";  		opiptr = true;  		break;  	case ByteCode.Opcode.Brzk:  		cp = "brzk";  		opiptr = true;  		break;  	case ByteCode.Opcode.Brnzk:  		cp = "brnzk";  		opiptr = true;  		break;  	case ByteCode.Opcode.Call:  		cp = "call";  		opiptr = true;  		break;  	case ByteCode.Opcode.Ret:  		cp = "ret";  		break;  	case ByteCode.Opcode.Retv:  		cp = "retv";  		break;  	case ByteCode.Opcode.ForEach:  		cp = "foreach";  		opiptr = true;  		break;  	case ByteCode.Opcode.Pop:  		cp = "pop";  		break;  	case ByteCode.Opcode.Pop2:  		cp = "pop2";  		break;  	case ByteCode.Opcode.Dup:  		cp = "dup";  		break;  	case ByteCode.Opcode.Dup2:  		cp = "dup2";  		break;  	case ByteCode.Opcode.Swap:  		cp = "swap";  		break;  	case ByteCode.Opcode.PushNull:  		cp = "push null";  		break;  	case ByteCode.Opcode.PushInt:  		cp = "push int";  		opiptr = true;  		break;  	case ByteCode.Opcode.PushInt0:  		cp = "push int 0";  		break;  	case ByteCode.Opcode.PushInt1:  		cp = "push int 1";  		break;  	case ByteCode.Opcode.PushFp:  		cp = "push fp";  		opf32 = true;  		break;  	case ByteCode.Opcode.PushStr:  		cp = "push str";  		opiptr = true;  		break;  	case ByteCode.Opcode.PushTbl:  		cp = "push tbl";  		break;  	case ByteCode.Opcode.PushFn:  		cp = "push fn";  		opiptr = true;  		break;  	case ByteCode.Opcode.PushThis:  		cp = "push this";  		break;  	case ByteCode.Opcode.GetLocal:  		cp = "get local";  		opiptr = true;  		break;  	case ByteCode.Opcode.SetLocal:  		cp = "set local";  		opiptr = true;  		break;  	case ByteCode.Opcode.GetGlobal:  		cp = "get global";  		opiptr = true;  		break;  	case ByteCode.Opcode.SetGlobal:  		cp = "set global";  		opiptr = true;  		break;  	case ByteCode.Opcode.GetThis:  		cp = "get this";  		opiptr = true;  		break;  	case ByteCode.Opcode.SetThis:  		cp = "set this";  		opiptr = true;  		break;  	case ByteCode.Opcode.OpAdd:  		cp = "add";  		break;  	case ByteCode.Opcode.OpSub:  		cp = "sub";  		break;  	case ByteCode.Opcode.OpMul:  		cp = "mul";  		break;  	case ByteCode.Opcode.OpDiv:  		cp = "div";  		break;  	case ByteCode.Opcode.OpRem:  		cp = "rem";  		break;  	case ByteCode.Opcode.OpInc:  		cp = "inc";  		break;  	case ByteCode.Opcode.OpDec:  		cp = "dec";  		break;  	case ByteCode.Opcode.BitOr:  		cp = "bor";  		break;  	case ByteCode.Opcode.BitXor:  		cp = "bxor";  		break;  	case ByteCode.Opcode.BitAnd:  		cp = "band";  		break;  	case ByteCode.Opcode.BitInv:  		cp = "binv";  		break;  	case ByteCode.Opcode.BitShl:  		cp = "bshl";  		break;  	case ByteCode.Opcode.BitShr:  		cp = "bshr";  		break;  	case ByteCode.Opcode.OpNeg:  		cp = "neg";  		break;  	case ByteCode.Opcode.OpPos:  		cp = "pos";  		break;  	case ByteCode.Opcode.OpNot:  		cp = "not";  		break;  	case ByteCode.Opcode.OpLt:  		cp = "lt";  		break;  	case ByteCode.Opcode.OpGt:  		cp = "gt";  		break;  	case ByteCode.Opcode.OpLte:  		cp = "lte";  		break;  	case ByteCode.Opcode.OpGte:  		cp = "gte";  		break;  	case ByteCode.Opcode.OpEq:  		cp = "eq";  		break;  	case ByteCode.Opcode.OpNeq:  		cp = "neq";  		break;  	//case ByteCode.Operator.Fork: cp = "fork"; opiptr = true; break;  	default:  		cp = "ERROR";  		break;  	}  	instruction += 4;  	if (opf32) {  		var val = BitConverter.ToSingle (byteCode' instruction);  		instruction += 4;  		log.AppendFormat ("  {0:D4} {1} {2:F6}\r\r\n"' addr' cp' val);  	}  	else if (opiptr) {  		var val = BitConverter.ToInt32 (byteCode' instruction);  		instruction += 4;  		log.AppendFormat ("  {0:D4} {1} {2}\r\r\n"' addr' cp' val);  	}  	else {  		log.AppendFormat ("  {0:D4} {1}\r\r\n"' addr' cp);  	}  }  
Magic Number,GreenBeanScript,Library,C:\repos\evolutional_greenbeanscript\GreenBeanScript\VirtualMachine\Library.cs,ListBytecode,The following statement contains a magic number: while (instruction < end) {  	var opiptr = false;  	var opf32 = false;  	var opisymbol = false;  	var cp = "";  	int addr = instruction - start;  	var bc = BitConverter.ToUInt32 (byteCode' instruction);  	switch ((ByteCode.Opcode)bc) {  	case ByteCode.Opcode.Nop:  		cp = "nop";  		break;  	case ByteCode.Opcode.Line:  		cp = "line";  		break;  	case ByteCode.Opcode.GetDot:  		cp = "get dot";  		opiptr = true;  		break;  	case ByteCode.Opcode.SetDot:  		cp = "set dot";  		opiptr = true;  		break;  	case ByteCode.Opcode.GetInd:  		cp = "get index";  		break;  	case ByteCode.Opcode.SetInd:  		cp = "set index";  		break;  	case ByteCode.Opcode.Bra:  		cp = "bra";  		opiptr = true;  		break;  	case ByteCode.Opcode.Brz:  		cp = "brz";  		opiptr = true;  		break;  	case ByteCode.Opcode.Brnz:  		cp = "brnz";  		opiptr = true;  		break;  	case ByteCode.Opcode.Brzk:  		cp = "brzk";  		opiptr = true;  		break;  	case ByteCode.Opcode.Brnzk:  		cp = "brnzk";  		opiptr = true;  		break;  	case ByteCode.Opcode.Call:  		cp = "call";  		opiptr = true;  		break;  	case ByteCode.Opcode.Ret:  		cp = "ret";  		break;  	case ByteCode.Opcode.Retv:  		cp = "retv";  		break;  	case ByteCode.Opcode.ForEach:  		cp = "foreach";  		opiptr = true;  		break;  	case ByteCode.Opcode.Pop:  		cp = "pop";  		break;  	case ByteCode.Opcode.Pop2:  		cp = "pop2";  		break;  	case ByteCode.Opcode.Dup:  		cp = "dup";  		break;  	case ByteCode.Opcode.Dup2:  		cp = "dup2";  		break;  	case ByteCode.Opcode.Swap:  		cp = "swap";  		break;  	case ByteCode.Opcode.PushNull:  		cp = "push null";  		break;  	case ByteCode.Opcode.PushInt:  		cp = "push int";  		opiptr = true;  		break;  	case ByteCode.Opcode.PushInt0:  		cp = "push int 0";  		break;  	case ByteCode.Opcode.PushInt1:  		cp = "push int 1";  		break;  	case ByteCode.Opcode.PushFp:  		cp = "push fp";  		opf32 = true;  		break;  	case ByteCode.Opcode.PushStr:  		cp = "push str";  		opiptr = true;  		break;  	case ByteCode.Opcode.PushTbl:  		cp = "push tbl";  		break;  	case ByteCode.Opcode.PushFn:  		cp = "push fn";  		opiptr = true;  		break;  	case ByteCode.Opcode.PushThis:  		cp = "push this";  		break;  	case ByteCode.Opcode.GetLocal:  		cp = "get local";  		opiptr = true;  		break;  	case ByteCode.Opcode.SetLocal:  		cp = "set local";  		opiptr = true;  		break;  	case ByteCode.Opcode.GetGlobal:  		cp = "get global";  		opiptr = true;  		break;  	case ByteCode.Opcode.SetGlobal:  		cp = "set global";  		opiptr = true;  		break;  	case ByteCode.Opcode.GetThis:  		cp = "get this";  		opiptr = true;  		break;  	case ByteCode.Opcode.SetThis:  		cp = "set this";  		opiptr = true;  		break;  	case ByteCode.Opcode.OpAdd:  		cp = "add";  		break;  	case ByteCode.Opcode.OpSub:  		cp = "sub";  		break;  	case ByteCode.Opcode.OpMul:  		cp = "mul";  		break;  	case ByteCode.Opcode.OpDiv:  		cp = "div";  		break;  	case ByteCode.Opcode.OpRem:  		cp = "rem";  		break;  	case ByteCode.Opcode.OpInc:  		cp = "inc";  		break;  	case ByteCode.Opcode.OpDec:  		cp = "dec";  		break;  	case ByteCode.Opcode.BitOr:  		cp = "bor";  		break;  	case ByteCode.Opcode.BitXor:  		cp = "bxor";  		break;  	case ByteCode.Opcode.BitAnd:  		cp = "band";  		break;  	case ByteCode.Opcode.BitInv:  		cp = "binv";  		break;  	case ByteCode.Opcode.BitShl:  		cp = "bshl";  		break;  	case ByteCode.Opcode.BitShr:  		cp = "bshr";  		break;  	case ByteCode.Opcode.OpNeg:  		cp = "neg";  		break;  	case ByteCode.Opcode.OpPos:  		cp = "pos";  		break;  	case ByteCode.Opcode.OpNot:  		cp = "not";  		break;  	case ByteCode.Opcode.OpLt:  		cp = "lt";  		break;  	case ByteCode.Opcode.OpGt:  		cp = "gt";  		break;  	case ByteCode.Opcode.OpLte:  		cp = "lte";  		break;  	case ByteCode.Opcode.OpGte:  		cp = "gte";  		break;  	case ByteCode.Opcode.OpEq:  		cp = "eq";  		break;  	case ByteCode.Opcode.OpNeq:  		cp = "neq";  		break;  	//case ByteCode.Operator.Fork: cp = "fork"; opiptr = true; break;  	default:  		cp = "ERROR";  		break;  	}  	instruction += 4;  	if (opf32) {  		var val = BitConverter.ToSingle (byteCode' instruction);  		instruction += 4;  		log.AppendFormat ("  {0:D4} {1} {2:F6}\r\r\n"' addr' cp' val);  	}  	else if (opiptr) {  		var val = BitConverter.ToInt32 (byteCode' instruction);  		instruction += 4;  		log.AppendFormat ("  {0:D4} {1} {2}\r\r\n"' addr' cp' val);  	}  	else {  		log.AppendFormat ("  {0:D4} {1}\r\r\n"' addr' cp);  	}  }  
Magic Number,GreenBeanScript,Library,C:\repos\evolutional_greenbeanscript\GreenBeanScript\VirtualMachine\Library.cs,ListBytecode,The following statement contains a magic number: while (instruction < end) {  	var opiptr = false;  	var opf32 = false;  	var opisymbol = false;  	var cp = "";  	int addr = instruction - start;  	var bc = BitConverter.ToUInt32 (byteCode' instruction);  	switch ((ByteCode.Opcode)bc) {  	case ByteCode.Opcode.Nop:  		cp = "nop";  		break;  	case ByteCode.Opcode.Line:  		cp = "line";  		break;  	case ByteCode.Opcode.GetDot:  		cp = "get dot";  		opiptr = true;  		break;  	case ByteCode.Opcode.SetDot:  		cp = "set dot";  		opiptr = true;  		break;  	case ByteCode.Opcode.GetInd:  		cp = "get index";  		break;  	case ByteCode.Opcode.SetInd:  		cp = "set index";  		break;  	case ByteCode.Opcode.Bra:  		cp = "bra";  		opiptr = true;  		break;  	case ByteCode.Opcode.Brz:  		cp = "brz";  		opiptr = true;  		break;  	case ByteCode.Opcode.Brnz:  		cp = "brnz";  		opiptr = true;  		break;  	case ByteCode.Opcode.Brzk:  		cp = "brzk";  		opiptr = true;  		break;  	case ByteCode.Opcode.Brnzk:  		cp = "brnzk";  		opiptr = true;  		break;  	case ByteCode.Opcode.Call:  		cp = "call";  		opiptr = true;  		break;  	case ByteCode.Opcode.Ret:  		cp = "ret";  		break;  	case ByteCode.Opcode.Retv:  		cp = "retv";  		break;  	case ByteCode.Opcode.ForEach:  		cp = "foreach";  		opiptr = true;  		break;  	case ByteCode.Opcode.Pop:  		cp = "pop";  		break;  	case ByteCode.Opcode.Pop2:  		cp = "pop2";  		break;  	case ByteCode.Opcode.Dup:  		cp = "dup";  		break;  	case ByteCode.Opcode.Dup2:  		cp = "dup2";  		break;  	case ByteCode.Opcode.Swap:  		cp = "swap";  		break;  	case ByteCode.Opcode.PushNull:  		cp = "push null";  		break;  	case ByteCode.Opcode.PushInt:  		cp = "push int";  		opiptr = true;  		break;  	case ByteCode.Opcode.PushInt0:  		cp = "push int 0";  		break;  	case ByteCode.Opcode.PushInt1:  		cp = "push int 1";  		break;  	case ByteCode.Opcode.PushFp:  		cp = "push fp";  		opf32 = true;  		break;  	case ByteCode.Opcode.PushStr:  		cp = "push str";  		opiptr = true;  		break;  	case ByteCode.Opcode.PushTbl:  		cp = "push tbl";  		break;  	case ByteCode.Opcode.PushFn:  		cp = "push fn";  		opiptr = true;  		break;  	case ByteCode.Opcode.PushThis:  		cp = "push this";  		break;  	case ByteCode.Opcode.GetLocal:  		cp = "get local";  		opiptr = true;  		break;  	case ByteCode.Opcode.SetLocal:  		cp = "set local";  		opiptr = true;  		break;  	case ByteCode.Opcode.GetGlobal:  		cp = "get global";  		opiptr = true;  		break;  	case ByteCode.Opcode.SetGlobal:  		cp = "set global";  		opiptr = true;  		break;  	case ByteCode.Opcode.GetThis:  		cp = "get this";  		opiptr = true;  		break;  	case ByteCode.Opcode.SetThis:  		cp = "set this";  		opiptr = true;  		break;  	case ByteCode.Opcode.OpAdd:  		cp = "add";  		break;  	case ByteCode.Opcode.OpSub:  		cp = "sub";  		break;  	case ByteCode.Opcode.OpMul:  		cp = "mul";  		break;  	case ByteCode.Opcode.OpDiv:  		cp = "div";  		break;  	case ByteCode.Opcode.OpRem:  		cp = "rem";  		break;  	case ByteCode.Opcode.OpInc:  		cp = "inc";  		break;  	case ByteCode.Opcode.OpDec:  		cp = "dec";  		break;  	case ByteCode.Opcode.BitOr:  		cp = "bor";  		break;  	case ByteCode.Opcode.BitXor:  		cp = "bxor";  		break;  	case ByteCode.Opcode.BitAnd:  		cp = "band";  		break;  	case ByteCode.Opcode.BitInv:  		cp = "binv";  		break;  	case ByteCode.Opcode.BitShl:  		cp = "bshl";  		break;  	case ByteCode.Opcode.BitShr:  		cp = "bshr";  		break;  	case ByteCode.Opcode.OpNeg:  		cp = "neg";  		break;  	case ByteCode.Opcode.OpPos:  		cp = "pos";  		break;  	case ByteCode.Opcode.OpNot:  		cp = "not";  		break;  	case ByteCode.Opcode.OpLt:  		cp = "lt";  		break;  	case ByteCode.Opcode.OpGt:  		cp = "gt";  		break;  	case ByteCode.Opcode.OpLte:  		cp = "lte";  		break;  	case ByteCode.Opcode.OpGte:  		cp = "gte";  		break;  	case ByteCode.Opcode.OpEq:  		cp = "eq";  		break;  	case ByteCode.Opcode.OpNeq:  		cp = "neq";  		break;  	//case ByteCode.Operator.Fork: cp = "fork"; opiptr = true; break;  	default:  		cp = "ERROR";  		break;  	}  	instruction += 4;  	if (opf32) {  		var val = BitConverter.ToSingle (byteCode' instruction);  		instruction += 4;  		log.AppendFormat ("  {0:D4} {1} {2:F6}\r\r\n"' addr' cp' val);  	}  	else if (opiptr) {  		var val = BitConverter.ToInt32 (byteCode' instruction);  		instruction += 4;  		log.AppendFormat ("  {0:D4} {1} {2}\r\r\n"' addr' cp' val);  	}  	else {  		log.AppendFormat ("  {0:D4} {1}\r\r\n"' addr' cp);  	}  }  
Magic Number,GreenBeanScript,Library,C:\repos\evolutional_greenbeanscript\GreenBeanScript\VirtualMachine\Library.cs,ListBytecode,The following statement contains a magic number: instruction += 4;  
Magic Number,GreenBeanScript,Library,C:\repos\evolutional_greenbeanscript\GreenBeanScript\VirtualMachine\Library.cs,ListBytecode,The following statement contains a magic number: if (opf32) {  	var val = BitConverter.ToSingle (byteCode' instruction);  	instruction += 4;  	log.AppendFormat ("  {0:D4} {1} {2:F6}\r\r\n"' addr' cp' val);  }  else if (opiptr) {  	var val = BitConverter.ToInt32 (byteCode' instruction);  	instruction += 4;  	log.AppendFormat ("  {0:D4} {1} {2}\r\r\n"' addr' cp' val);  }  else {  	log.AppendFormat ("  {0:D4} {1}\r\r\n"' addr' cp);  }  
Magic Number,GreenBeanScript,Library,C:\repos\evolutional_greenbeanscript\GreenBeanScript\VirtualMachine\Library.cs,ListBytecode,The following statement contains a magic number: if (opf32) {  	var val = BitConverter.ToSingle (byteCode' instruction);  	instruction += 4;  	log.AppendFormat ("  {0:D4} {1} {2:F6}\r\r\n"' addr' cp' val);  }  else if (opiptr) {  	var val = BitConverter.ToInt32 (byteCode' instruction);  	instruction += 4;  	log.AppendFormat ("  {0:D4} {1} {2}\r\r\n"' addr' cp' val);  }  else {  	log.AppendFormat ("  {0:D4} {1}\r\r\n"' addr' cp);  }  
Magic Number,GreenBeanScript,Library,C:\repos\evolutional_greenbeanscript\GreenBeanScript\VirtualMachine\Library.cs,ListBytecode,The following statement contains a magic number: instruction += 4;  
Magic Number,GreenBeanScript,Library,C:\repos\evolutional_greenbeanscript\GreenBeanScript\VirtualMachine\Library.cs,ListBytecode,The following statement contains a magic number: if (opiptr) {  	var val = BitConverter.ToInt32 (byteCode' instruction);  	instruction += 4;  	log.AppendFormat ("  {0:D4} {1} {2}\r\r\n"' addr' cp' val);  }  else {  	log.AppendFormat ("  {0:D4} {1}\r\r\n"' addr' cp);  }  
Magic Number,GreenBeanScript,Library,C:\repos\evolutional_greenbeanscript\GreenBeanScript\VirtualMachine\Library.cs,ListBytecode,The following statement contains a magic number: instruction += 4;  
Magic Number,GreenBeanScript,Library,C:\repos\evolutional_greenbeanscript\GreenBeanScript\VirtualMachine\Library.cs,Load,The following statement contains a magic number: for (int i = 0; i < numFunctions; ++i) {  	// Read out function entry  	var function = ReadFunction (data);  	if (function.flags == 1)  		_MainFunctionId = i;  	byte[] bytecode = data.ReadBytes ((int)function.byteCodeLen);  	uint end = function.byteCodeLen;  	List<ByteCode.Instruction> InstructionList = new List<ByteCode.Instruction> ();  	for (int instruction = 0; instruction < end;) {  		ByteCode.Opcode instr = (ByteCode.Opcode)BitConverter.ToUInt32 (bytecode' instruction);  		int bytecodeoffset = instruction;  		instruction += 4;  		switch (instr) {  		#region Operators  		case ByteCode.Opcode.OpRem:  		case ByteCode.Opcode.OpAdd:  		case ByteCode.Opcode.OpDiv:  		case ByteCode.Opcode.OpEq:  		case ByteCode.Opcode.OpGt:  		case ByteCode.Opcode.OpGte:  		case ByteCode.Opcode.OpLt:  		case ByteCode.Opcode.OpLte:  		case ByteCode.Opcode.OpMul:  		case ByteCode.Opcode.OpNeg:  		case ByteCode.Opcode.OpSub:  		case ByteCode.Opcode.SetInd:  		case ByteCode.Opcode.GetInd: {  			InstructionList.Add (new ByteCode.Instruction (instr' bytecodeoffset));  			break;  		}  		case ByteCode.Opcode.SetDot:  		case ByteCode.Opcode.GetDot: {  			uint reference = System.BitConverter.ToUInt32 (bytecode' instruction);  			instruction += sizeof(uint);  			var s = stringTable.GetByOffset ((int)reference);  			InstructionList.Add (new ByteCode.Instruction (instr' bytecodeoffset' new Variable[] {  				new Variable (s.Value)  			}));  			break;  		}  		#endregion  		case ByteCode.Opcode.Ret:  		case ByteCode.Opcode.Retv:  		case ByteCode.Opcode.Dup:  		case ByteCode.Opcode.Pop:  		case ByteCode.Opcode.Pop2: {  			InstructionList.Add (new ByteCode.Instruction (instr' bytecodeoffset));  			break;  		}  		case ByteCode.Opcode.ForEach: {  			Int16 localref = System.BitConverter.ToInt16 (bytecode' instruction);  			instruction += sizeof(Int16);  			Int16 localkey = System.BitConverter.ToInt16 (bytecode' instruction);  			instruction += sizeof(Int16);  			InstructionList.Add (new ByteCode.Instruction (instr' bytecodeoffset' new Variable[] {  				new Variable ((int)localref)'  				new Variable ((int)localkey)  			}));  			break;  		}  		case ByteCode.Opcode.Call: {  			int numParams = BitConverter.ToInt32 (bytecode' instruction);  			instruction += sizeof(int);  			InstructionList.Add (new ByteCode.Instruction (instr' bytecodeoffset' new Variable[] {  				new Variable (numParams)  			}));  			break;  		}  		case ByteCode.Opcode.GetLocal:  		case ByteCode.Opcode.SetLocal: {  			uint reference = System.BitConverter.ToUInt32 (bytecode' instruction);  			instruction += sizeof(uint);  			uint offset = reference;  			InstructionList.Add (new ByteCode.Instruction (instr' bytecodeoffset' new Variable[] {  				new Variable ((int)offset)  			}));  			break;  		}  		case ByteCode.Opcode.GetGlobal:  		case ByteCode.Opcode.SetGlobal: {  			uint reference = BitConverter.ToUInt32 (bytecode' instruction);  			instruction += sizeof(int);  			var s = stringTable.GetByOffset ((int)reference);  			InstructionList.Add (new ByteCode.Instruction (instr' bytecodeoffset' new Variable[] {  				new Variable (s.Value)  			}));  			break;  		}  		#region Branch  		case ByteCode.Opcode.Brzk:  		case ByteCode.Opcode.Brz:  		case ByteCode.Opcode.Bra: {  			int offset = BitConverter.ToInt32 (bytecode' instruction);  			instruction += sizeof(int);  			InstructionList.Add (new ByteCode.Instruction (instr' bytecodeoffset' new Variable[] {  				new Variable (offset)  			}));  			break;  		}  		#endregion  		#region Push Operators  		case ByteCode.Opcode.PushThis:  		case ByteCode.Opcode.PushNull: {  			InstructionList.Add (new ByteCode.Instruction (instr' bytecodeoffset));  			break;  		}  		case ByteCode.Opcode.PushInt0: {  			InstructionList.Add (new ByteCode.Instruction (instr' bytecodeoffset' new Variable[] {  				new Variable (0)  			}));  			break;  		}  		case ByteCode.Opcode.PushInt1: {  			InstructionList.Add (new ByteCode.Instruction (instr' bytecodeoffset' new Variable[] {  				new Variable (1)  			}));  			break;  		}  		case ByteCode.Opcode.PushInt: {  			int val = BitConverter.ToInt32 (bytecode' instruction);  			instruction += sizeof(int);  			InstructionList.Add (new ByteCode.Instruction (instr' bytecodeoffset' new Variable[] {  				new Variable (val)  			}));  			break;  		}  		case ByteCode.Opcode.PushFp: {  			var i32 = BitConverter.ToInt32 (bytecode' instruction);  			float f = BitConverter.ToSingle (bytecode' instruction);  			instruction += sizeof(float);  			InstructionList.Add (new ByteCode.Instruction (instr' bytecodeoffset' new Variable[] {  				new Variable (f)  			}));  			break;  		}  		case ByteCode.Opcode.PushTbl: {  			InstructionList.Add (new ByteCode.Instruction (instr' bytecodeoffset));  			//' new Variable[] { new Variable(Machine.CreateTable()) }));  			break;  		}  		case ByteCode.Opcode.PushStr: {  			uint reference = System.BitConverter.ToUInt32 (bytecode' instruction);  			instruction += sizeof(uint);  			var s = stringTable.GetByOffset ((int)reference);  			InstructionList.Add (new ByteCode.Instruction (instr' bytecodeoffset' new Variable[] {  				new Variable (s.Value)  			}));  			break;  		}  		case ByteCode.Opcode.PushFn: {  			uint reference = System.BitConverter.ToUInt32 (bytecode' instruction);  			instruction += sizeof(uint);  			uint offset = reference;  			InstructionList.Add (new ByteCode.Instruction (instr' bytecodeoffset' new Variable[] {  				new Variable ((int)offset)  			}));  			break;  		}  		#endregion  		default: {  			throw new Exception ("Invalid opcode " + instr.ToString ());  		}  		}  		;  		// end of switch  	}  	// end of function loop  	functionObjects.Add (new FunctionObject ());  	functionObjects [i].Initialise (InstructionList' (int)function.numLocals' (int)function.numParams);  }  
Magic Number,GreenBeanScript,Library,C:\repos\evolutional_greenbeanscript\GreenBeanScript\VirtualMachine\Library.cs,Load,The following statement contains a magic number: for (int instruction = 0; instruction < end;) {  	ByteCode.Opcode instr = (ByteCode.Opcode)BitConverter.ToUInt32 (bytecode' instruction);  	int bytecodeoffset = instruction;  	instruction += 4;  	switch (instr) {  	#region Operators  	case ByteCode.Opcode.OpRem:  	case ByteCode.Opcode.OpAdd:  	case ByteCode.Opcode.OpDiv:  	case ByteCode.Opcode.OpEq:  	case ByteCode.Opcode.OpGt:  	case ByteCode.Opcode.OpGte:  	case ByteCode.Opcode.OpLt:  	case ByteCode.Opcode.OpLte:  	case ByteCode.Opcode.OpMul:  	case ByteCode.Opcode.OpNeg:  	case ByteCode.Opcode.OpSub:  	case ByteCode.Opcode.SetInd:  	case ByteCode.Opcode.GetInd: {  		InstructionList.Add (new ByteCode.Instruction (instr' bytecodeoffset));  		break;  	}  	case ByteCode.Opcode.SetDot:  	case ByteCode.Opcode.GetDot: {  		uint reference = System.BitConverter.ToUInt32 (bytecode' instruction);  		instruction += sizeof(uint);  		var s = stringTable.GetByOffset ((int)reference);  		InstructionList.Add (new ByteCode.Instruction (instr' bytecodeoffset' new Variable[] {  			new Variable (s.Value)  		}));  		break;  	}  	#endregion  	case ByteCode.Opcode.Ret:  	case ByteCode.Opcode.Retv:  	case ByteCode.Opcode.Dup:  	case ByteCode.Opcode.Pop:  	case ByteCode.Opcode.Pop2: {  		InstructionList.Add (new ByteCode.Instruction (instr' bytecodeoffset));  		break;  	}  	case ByteCode.Opcode.ForEach: {  		Int16 localref = System.BitConverter.ToInt16 (bytecode' instruction);  		instruction += sizeof(Int16);  		Int16 localkey = System.BitConverter.ToInt16 (bytecode' instruction);  		instruction += sizeof(Int16);  		InstructionList.Add (new ByteCode.Instruction (instr' bytecodeoffset' new Variable[] {  			new Variable ((int)localref)'  			new Variable ((int)localkey)  		}));  		break;  	}  	case ByteCode.Opcode.Call: {  		int numParams = BitConverter.ToInt32 (bytecode' instruction);  		instruction += sizeof(int);  		InstructionList.Add (new ByteCode.Instruction (instr' bytecodeoffset' new Variable[] {  			new Variable (numParams)  		}));  		break;  	}  	case ByteCode.Opcode.GetLocal:  	case ByteCode.Opcode.SetLocal: {  		uint reference = System.BitConverter.ToUInt32 (bytecode' instruction);  		instruction += sizeof(uint);  		uint offset = reference;  		InstructionList.Add (new ByteCode.Instruction (instr' bytecodeoffset' new Variable[] {  			new Variable ((int)offset)  		}));  		break;  	}  	case ByteCode.Opcode.GetGlobal:  	case ByteCode.Opcode.SetGlobal: {  		uint reference = BitConverter.ToUInt32 (bytecode' instruction);  		instruction += sizeof(int);  		var s = stringTable.GetByOffset ((int)reference);  		InstructionList.Add (new ByteCode.Instruction (instr' bytecodeoffset' new Variable[] {  			new Variable (s.Value)  		}));  		break;  	}  	#region Branch  	case ByteCode.Opcode.Brzk:  	case ByteCode.Opcode.Brz:  	case ByteCode.Opcode.Bra: {  		int offset = BitConverter.ToInt32 (bytecode' instruction);  		instruction += sizeof(int);  		InstructionList.Add (new ByteCode.Instruction (instr' bytecodeoffset' new Variable[] {  			new Variable (offset)  		}));  		break;  	}  	#endregion  	#region Push Operators  	case ByteCode.Opcode.PushThis:  	case ByteCode.Opcode.PushNull: {  		InstructionList.Add (new ByteCode.Instruction (instr' bytecodeoffset));  		break;  	}  	case ByteCode.Opcode.PushInt0: {  		InstructionList.Add (new ByteCode.Instruction (instr' bytecodeoffset' new Variable[] {  			new Variable (0)  		}));  		break;  	}  	case ByteCode.Opcode.PushInt1: {  		InstructionList.Add (new ByteCode.Instruction (instr' bytecodeoffset' new Variable[] {  			new Variable (1)  		}));  		break;  	}  	case ByteCode.Opcode.PushInt: {  		int val = BitConverter.ToInt32 (bytecode' instruction);  		instruction += sizeof(int);  		InstructionList.Add (new ByteCode.Instruction (instr' bytecodeoffset' new Variable[] {  			new Variable (val)  		}));  		break;  	}  	case ByteCode.Opcode.PushFp: {  		var i32 = BitConverter.ToInt32 (bytecode' instruction);  		float f = BitConverter.ToSingle (bytecode' instruction);  		instruction += sizeof(float);  		InstructionList.Add (new ByteCode.Instruction (instr' bytecodeoffset' new Variable[] {  			new Variable (f)  		}));  		break;  	}  	case ByteCode.Opcode.PushTbl: {  		InstructionList.Add (new ByteCode.Instruction (instr' bytecodeoffset));  		//' new Variable[] { new Variable(Machine.CreateTable()) }));  		break;  	}  	case ByteCode.Opcode.PushStr: {  		uint reference = System.BitConverter.ToUInt32 (bytecode' instruction);  		instruction += sizeof(uint);  		var s = stringTable.GetByOffset ((int)reference);  		InstructionList.Add (new ByteCode.Instruction (instr' bytecodeoffset' new Variable[] {  			new Variable (s.Value)  		}));  		break;  	}  	case ByteCode.Opcode.PushFn: {  		uint reference = System.BitConverter.ToUInt32 (bytecode' instruction);  		instruction += sizeof(uint);  		uint offset = reference;  		InstructionList.Add (new ByteCode.Instruction (instr' bytecodeoffset' new Variable[] {  			new Variable ((int)offset)  		}));  		break;  	}  	#endregion  	default: {  		throw new Exception ("Invalid opcode " + instr.ToString ());  	}  	}  	;  	// end of switch  }  
Magic Number,GreenBeanScript,Library,C:\repos\evolutional_greenbeanscript\GreenBeanScript\VirtualMachine\Library.cs,Load,The following statement contains a magic number: instruction += 4;  
Magic Number,GreenBeanScript,Thread,C:\repos\evolutional_greenbeanscript\GreenBeanScript\VirtualMachine\Thread.cs,PopStackFrame,The following statement contains a magic number: _stack.PokeBase (-2' _stack.Peek (-1));  
Magic Number,GreenBeanScript,Thread,C:\repos\evolutional_greenbeanscript\GreenBeanScript\VirtualMachine\Thread.cs,PushStackFrame,The following statement contains a magic number: if (Base == 2) {  	// TODO: New thread callback  	_stack.BasePointer = Base;  }  
Magic Number,GreenBeanScript,Thread,C:\repos\evolutional_greenbeanscript\GreenBeanScript\VirtualMachine\Thread.cs,PushStackFrame,The following statement contains a magic number: if (func.Native != null) {  	var lastBase = _stack.BasePointer;  	var lastTop = _stack.StackPointer;  	_stack.BasePointer = Base;  	_paramCount = parameterCount;  	FunctionResult res = func.Native (this);  	if (lastTop == _stack.StackPointer) {  		_stack.PokeBase (-2' Variable.Null);  	}  	else {  		_stack.PokeBase (-2' _stack.Peek (-1));  	}  	// return stack  	_stack.StackPointer = _stack.BasePointer - 1;  	_stack.BasePointer = lastBase;  	switch (res) {  	case FunctionResult.Ok: {  		break;  	}  	case FunctionResult.Sys_Block: {  		// Todo: Sort out return addr  		_machine.SwitchThreadState (this' ThreadState.Blocked);  		return ThreadState.Blocked;  	}  	case FunctionResult.Sys_Yield: {  		// Todo: Remove signals  		// Todo: Sort out return addr  		return ThreadState.Sys_Yield;  	}  	case FunctionResult.Sys_Sleep: {  		// Todo: Sort out return addr  		_machine.SwitchThreadState (this' ThreadState.Sleeping);  		return ThreadState.Sleeping;  	}  	case FunctionResult.Sys_Kill: {  		return ThreadState.Killed;  	}  	default: {  		return ThreadState.Exception;  	}  	}  	return _stackFrames.Count == 0 ? ThreadState.Killed : ThreadState.Running;  }  
Magic Number,GreenBeanScript,Thread,C:\repos\evolutional_greenbeanscript\GreenBeanScript\VirtualMachine\Thread.cs,PushStackFrame,The following statement contains a magic number: if (func.Native != null) {  	var lastBase = _stack.BasePointer;  	var lastTop = _stack.StackPointer;  	_stack.BasePointer = Base;  	_paramCount = parameterCount;  	FunctionResult res = func.Native (this);  	if (lastTop == _stack.StackPointer) {  		_stack.PokeBase (-2' Variable.Null);  	}  	else {  		_stack.PokeBase (-2' _stack.Peek (-1));  	}  	// return stack  	_stack.StackPointer = _stack.BasePointer - 1;  	_stack.BasePointer = lastBase;  	switch (res) {  	case FunctionResult.Ok: {  		break;  	}  	case FunctionResult.Sys_Block: {  		// Todo: Sort out return addr  		_machine.SwitchThreadState (this' ThreadState.Blocked);  		return ThreadState.Blocked;  	}  	case FunctionResult.Sys_Yield: {  		// Todo: Remove signals  		// Todo: Sort out return addr  		return ThreadState.Sys_Yield;  	}  	case FunctionResult.Sys_Sleep: {  		// Todo: Sort out return addr  		_machine.SwitchThreadState (this' ThreadState.Sleeping);  		return ThreadState.Sleeping;  	}  	case FunctionResult.Sys_Kill: {  		return ThreadState.Killed;  	}  	default: {  		return ThreadState.Exception;  	}  	}  	return _stackFrames.Count == 0 ? ThreadState.Killed : ThreadState.Running;  }  
Magic Number,GreenBeanScript,Thread,C:\repos\evolutional_greenbeanscript\GreenBeanScript\VirtualMachine\Thread.cs,PushStackFrame,The following statement contains a magic number: if (lastTop == _stack.StackPointer) {  	_stack.PokeBase (-2' Variable.Null);  }  else {  	_stack.PokeBase (-2' _stack.Peek (-1));  }  
Magic Number,GreenBeanScript,Thread,C:\repos\evolutional_greenbeanscript\GreenBeanScript\VirtualMachine\Thread.cs,PushStackFrame,The following statement contains a magic number: if (lastTop == _stack.StackPointer) {  	_stack.PokeBase (-2' Variable.Null);  }  else {  	_stack.PokeBase (-2' _stack.Peek (-1));  }  
Magic Number,GreenBeanScript,Thread,C:\repos\evolutional_greenbeanscript\GreenBeanScript\VirtualMachine\Thread.cs,PushStackFrame,The following statement contains a magic number: _stack.PokeBase (-2' Variable.Null);  
Magic Number,GreenBeanScript,Thread,C:\repos\evolutional_greenbeanscript\GreenBeanScript\VirtualMachine\Thread.cs,PushStackFrame,The following statement contains a magic number: _stack.PokeBase (-2' _stack.Peek (-1));  
Magic Number,GreenBeanScript,Thread,C:\repos\evolutional_greenbeanscript\GreenBeanScript\VirtualMachine\Thread.cs,Execute,The following statement contains a magic number: for (; ;) {  	if (_instructionPtr >= _instructionList.Count)  		break;  	var inst = _instructionList [_instructionPtr++];  	switch (inst.OpCode) {  	case ByteCode.Opcode.Pop: {  		_stack.Pop ();  		break;  	}  	case ByteCode.Opcode.Pop2: {  		_stack.Pop (2);  		break;  	}  	case ByteCode.Opcode.Dup: {  		_stack.Push (_stack.Peek ());  		break;  	}  	case ByteCode.Opcode.Call: {  		// pop arg count from stack  		ThreadState res = PushStackFrame (inst [0].GetInteger ());  		switch (res) {  		case ThreadState.Running: {  			break;  		}  		case ThreadState.Sys_Yield: {  			return ThreadState.Running;  		}  		case ThreadState.Exception: {  			_machine.SwitchThreadState (this' ThreadState.Killed);  			return ThreadState.Exception;  		}  		case ThreadState.Killed: {  			_machine.SwitchThreadState (this' ThreadState.Killed);  			break;  		}  		default: {  			break;  		}  		}  		break;  	}  	#region Push Operations  	case ByteCode.Opcode.PushNull: {  		Push (Variable.Null);  		break;  	}  	case ByteCode.Opcode.PushThis: {  		Push (This);  		break;  	}  	case ByteCode.Opcode.PushInt0:  	case ByteCode.Opcode.PushInt1:  	case ByteCode.Opcode.PushInt:  	case ByteCode.Opcode.PushFp:  	case ByteCode.Opcode.PushStr:  	case ByteCode.Opcode.PushFn: {  		Push (inst [0]);  		break;  	}  	case ByteCode.Opcode.PushTbl: {  		Push (new TableObject ());  		break;  	}  	#endregion  	case ByteCode.Opcode.Ret:// Ret pushes a null  	 {  		Push (Variable.Null);  		ThreadState res = PopStackFrame ();  		switch (res) {  		case ThreadState.Exception:  		case ThreadState.Killed: {  			_machine.SwitchThreadState (this' res);  			return res;  		}  		default: {  			break;  		}  		}  		break;  	}  	case ByteCode.Opcode.Retv: {  		ThreadState res = PopStackFrame ();  		if (res == ThreadState.Killed) {  			return res;  		}  		break;  	}  	case ByteCode.Opcode.SetGlobal: {  		Variable v1 = inst [0];  		if (v1.Type != VariableType.String) {  			throw new Exception ("String required");  		}  		Variable v2 = _stack.Pop ();  		_machine.Globals [v1] = v2;  		break;  	}  	case ByteCode.Opcode.GetGlobal: {  		Variable v1 = inst [0];  		// global name  		// TODO: Check for string  		if (v1.Type != VariableType.String) {  			throw new Exception ("String required");  		}  		var global = _machine.Globals [v1];  		Push (global);  		break;  	}  	case ByteCode.Opcode.SetLocal: {  		int offset = inst [0].GetInteger ();  		_stack.PokeBase (offset' _stack.Pop ());  		break;  	}  	case ByteCode.Opcode.GetLocal: {  		int offset = inst [0].GetInteger ();  		Push (_stack.PeekBase (offset));  		break;  	}  	#region Operators  	case ByteCode.Opcode.OpEq:  	case ByteCode.Opcode.OpNeq:  	case ByteCode.Opcode.OpLt:  	case ByteCode.Opcode.OpLte:  	case ByteCode.Opcode.OpGt:  	case ByteCode.Opcode.OpGte:  	case ByteCode.Opcode.OpRem:  	case ByteCode.Opcode.OpAdd:  	case ByteCode.Opcode.OpSub:  	case ByteCode.Opcode.OpMul:  	case ByteCode.Opcode.OpDiv: {  		Operator o = Operator._MAX;  		switch (inst.OpCode) {  		#region fold  		case ByteCode.Opcode.OpAdd: {  			o = Operator.Add;  			break;  		}  		case ByteCode.Opcode.OpSub: {  			o = Operator.Sub;  			break;  		}  		case ByteCode.Opcode.OpMul: {  			o = Operator.Mul;  			break;  		}  		case ByteCode.Opcode.OpDiv: {  			o = Operator.Div;  			break;  		}  		case ByteCode.Opcode.GetInd: {  			o = Operator.GetInd;  			break;  		}  		case ByteCode.Opcode.OpEq: {  			o = Operator.Eq;  			break;  		}  		case ByteCode.Opcode.OpNeq: {  			o = Operator.Neq;  			break;  		}  		case ByteCode.Opcode.OpLt: {  			o = Operator.Lt;  			break;  		}  		case ByteCode.Opcode.OpLte: {  			o = Operator.Lte;  			break;  		}  		case ByteCode.Opcode.OpGt: {  			o = Operator.Gt;  			break;  		}  		case ByteCode.Opcode.OpGte: {  			o = Operator.Gte;  			break;  		}  		case ByteCode.Opcode.OpRem: {  			o = Operator.Rem;  			break;  		}  		#endregion  		}  		if (o == Operator._MAX) {  			throw new NotImplementedException ("Operator not mapped or implemented");  		}  		var t1 = _stack.Peek (-1).TypeCode;  		var t2 = _stack.Peek (-2).TypeCode;  		if (t2 > t1) {  			t1 = t2;  		}  		OperatorCallback op = Machine.GetTypeOperator (t1' o);  		if (op != null) {  			var operand = _stack.StackPointer--;  			_stack.PokeAbs (operand - 2' op (this' _stack.PeekAbs (operand - 2)' _stack.PeekAbs (operand - 1)' _stack.PeekAbs (operand)));  		}  		else {  			throw new Exception ("Operator not defined");  		}  		break;  	}  	case ByteCode.Opcode.GetInd: {  		var type = _stack.Peek (-2).TypeCode;  		var op = Machine.GetTypeOperator (type' Operator.GetInd);  		if (op != null) {  			var operand = _stack.StackPointer--;  			_stack.PokeAbs (operand - 2' op (this' _stack.PeekAbs (operand - 2)' _stack.PeekAbs (operand - 1)' _stack.PeekAbs (operand)));  		}  		else {  			throw new Exception ("Operator not defined");  		}  		break;  	}  	case ByteCode.Opcode.SetInd: {  		var topMin3 = _stack.Peek (-3);  		OperatorCallback op = Machine.GetTypeOperator (topMin3.TypeCode' Operator.SetInd);  		if (op != null) {  			_stack.Poke (-3' op (this' topMin3' _stack.Peek (-2)' _stack.Peek (-1)));  			_stack.StackPointer -= 3;  		}  		else {  			throw new Exception ("Operator not defined");  		}  		break;  	}  	case ByteCode.Opcode.ForEach: {  		var topMin2 = _stack.Peek (-2);  		TypeIteratorCallback itr = Machine.GetTypeIterator (topMin2.TypeCode);  		if (itr == null) {  			_machine.Log.LogEntry ("Undefined iterator for type");  			return ThreadState.Exception;  		}  		var iteratorPos = _stack.Peek (-1).GetInteger ();  		var obj = _stack.Peek (-2).GetReference ();  		iteratorPos = itr (this' obj' iteratorPos' _stack.PeekBase (inst [1].GetInteger ())' _stack.PeekBase (inst [0].GetInteger ()));  		if (iteratorPos != -1) {  			//_Stack2[_Base + Inst[1].GetInteger()] = Key;  			//_Stack2[_Base + Inst[0].GetInteger()] = Item;  			_stack.Poke (Variable.Zero);  		}  		else {  			_stack.Poke (Variable.Zero);  		}  		_stack.Poke (-1' iteratorPos);  		++_stack.StackPointer;  		break;  	}  	#region Dot Operators  	case ByteCode.Opcode.GetDot: {  		var v1 = _stack.Peek (-1);  		OperatorCallback op = Machine.GetTypeOperator (v1.TypeCode' Operator.GetDot);  		_stack.Poke (inst [0]);  		if (op != null) {  			_stack.Poke (-1' op (this' v1' _stack.Peek ()' _stack.Peek ()));  		}  		else {  			throw new Exception ("Operator not defined");  		}  		break;  	}  	case ByteCode.Opcode.SetDot: {  		var v1 = _stack.Peek (-2);  		OperatorCallback op = Machine.GetTypeOperator (v1.TypeCode' Operator.SetDot);  		_stack.Poke (inst [0]);  		if (op != null) {  			_stack.Poke (-2' op (this' _stack.Peek (-2)' _stack.Peek (-1)' _stack.Peek ()));  			_stack.StackPointer -= 2;  		}  		else {  			throw new Exception ("Operator not defined");  		}  		break;  	}  	#endregion  	#endregion  	#region Branch  	case ByteCode.Opcode.Brz: {  		var v = _stack.Pop ();  		if (v.IsZero) {  			var newIp = inst [0].GetInteger ();  			if (newIp >= _instructionList.Count) {  				throw new Exception ("BRZ: Corrupt IP");  			}  			_instructionPtr = newIp;  		}  		break;  	}  	case ByteCode.Opcode.Brnz: {  		var v = _stack.Pop ();  		if (!v.IsZero) {  			var newIp = inst [0].GetInteger ();  			if (newIp >= _instructionList.Count) {  				throw new Exception ("BRZ: Corrupt IP");  			}  			_instructionPtr = newIp;  		}  		break;  	}  	case ByteCode.Opcode.Brzk: {  		var v = _stack.Peek (-1);  		if (v.IsZero) {  			var newIp = inst [0].GetInteger ();  			if (newIp >= _instructionList.Count) {  				throw new Exception ("BRZ: Corrupt IP");  			}  			_instructionPtr = newIp;  		}  		break;  	}  	case ByteCode.Opcode.Brnzk: {  		var v = _stack.Peek (-1);  		if (!v.IsZero) {  			var newIp = inst [0].GetInteger ();  			if (newIp >= _instructionList.Count) {  				throw new Exception ("BRNZK: Corrupt IP");  			}  			_instructionPtr = newIp;  		}  		break;  	}  	case ByteCode.Opcode.Bra: {  		var newIp = inst [0].GetInteger ();  		if (newIp >= _instructionList.Count) {  			throw new Exception ("BRA: Corrupt IP");  		}  		_instructionPtr = newIp;  		break;  	}  	#endregion  	default: {  		throw new Exception ("Unknown instr");  	}  	}  	// end switch instruction  }  
Magic Number,GreenBeanScript,Thread,C:\repos\evolutional_greenbeanscript\GreenBeanScript\VirtualMachine\Thread.cs,Execute,The following statement contains a magic number: for (; ;) {  	if (_instructionPtr >= _instructionList.Count)  		break;  	var inst = _instructionList [_instructionPtr++];  	switch (inst.OpCode) {  	case ByteCode.Opcode.Pop: {  		_stack.Pop ();  		break;  	}  	case ByteCode.Opcode.Pop2: {  		_stack.Pop (2);  		break;  	}  	case ByteCode.Opcode.Dup: {  		_stack.Push (_stack.Peek ());  		break;  	}  	case ByteCode.Opcode.Call: {  		// pop arg count from stack  		ThreadState res = PushStackFrame (inst [0].GetInteger ());  		switch (res) {  		case ThreadState.Running: {  			break;  		}  		case ThreadState.Sys_Yield: {  			return ThreadState.Running;  		}  		case ThreadState.Exception: {  			_machine.SwitchThreadState (this' ThreadState.Killed);  			return ThreadState.Exception;  		}  		case ThreadState.Killed: {  			_machine.SwitchThreadState (this' ThreadState.Killed);  			break;  		}  		default: {  			break;  		}  		}  		break;  	}  	#region Push Operations  	case ByteCode.Opcode.PushNull: {  		Push (Variable.Null);  		break;  	}  	case ByteCode.Opcode.PushThis: {  		Push (This);  		break;  	}  	case ByteCode.Opcode.PushInt0:  	case ByteCode.Opcode.PushInt1:  	case ByteCode.Opcode.PushInt:  	case ByteCode.Opcode.PushFp:  	case ByteCode.Opcode.PushStr:  	case ByteCode.Opcode.PushFn: {  		Push (inst [0]);  		break;  	}  	case ByteCode.Opcode.PushTbl: {  		Push (new TableObject ());  		break;  	}  	#endregion  	case ByteCode.Opcode.Ret:// Ret pushes a null  	 {  		Push (Variable.Null);  		ThreadState res = PopStackFrame ();  		switch (res) {  		case ThreadState.Exception:  		case ThreadState.Killed: {  			_machine.SwitchThreadState (this' res);  			return res;  		}  		default: {  			break;  		}  		}  		break;  	}  	case ByteCode.Opcode.Retv: {  		ThreadState res = PopStackFrame ();  		if (res == ThreadState.Killed) {  			return res;  		}  		break;  	}  	case ByteCode.Opcode.SetGlobal: {  		Variable v1 = inst [0];  		if (v1.Type != VariableType.String) {  			throw new Exception ("String required");  		}  		Variable v2 = _stack.Pop ();  		_machine.Globals [v1] = v2;  		break;  	}  	case ByteCode.Opcode.GetGlobal: {  		Variable v1 = inst [0];  		// global name  		// TODO: Check for string  		if (v1.Type != VariableType.String) {  			throw new Exception ("String required");  		}  		var global = _machine.Globals [v1];  		Push (global);  		break;  	}  	case ByteCode.Opcode.SetLocal: {  		int offset = inst [0].GetInteger ();  		_stack.PokeBase (offset' _stack.Pop ());  		break;  	}  	case ByteCode.Opcode.GetLocal: {  		int offset = inst [0].GetInteger ();  		Push (_stack.PeekBase (offset));  		break;  	}  	#region Operators  	case ByteCode.Opcode.OpEq:  	case ByteCode.Opcode.OpNeq:  	case ByteCode.Opcode.OpLt:  	case ByteCode.Opcode.OpLte:  	case ByteCode.Opcode.OpGt:  	case ByteCode.Opcode.OpGte:  	case ByteCode.Opcode.OpRem:  	case ByteCode.Opcode.OpAdd:  	case ByteCode.Opcode.OpSub:  	case ByteCode.Opcode.OpMul:  	case ByteCode.Opcode.OpDiv: {  		Operator o = Operator._MAX;  		switch (inst.OpCode) {  		#region fold  		case ByteCode.Opcode.OpAdd: {  			o = Operator.Add;  			break;  		}  		case ByteCode.Opcode.OpSub: {  			o = Operator.Sub;  			break;  		}  		case ByteCode.Opcode.OpMul: {  			o = Operator.Mul;  			break;  		}  		case ByteCode.Opcode.OpDiv: {  			o = Operator.Div;  			break;  		}  		case ByteCode.Opcode.GetInd: {  			o = Operator.GetInd;  			break;  		}  		case ByteCode.Opcode.OpEq: {  			o = Operator.Eq;  			break;  		}  		case ByteCode.Opcode.OpNeq: {  			o = Operator.Neq;  			break;  		}  		case ByteCode.Opcode.OpLt: {  			o = Operator.Lt;  			break;  		}  		case ByteCode.Opcode.OpLte: {  			o = Operator.Lte;  			break;  		}  		case ByteCode.Opcode.OpGt: {  			o = Operator.Gt;  			break;  		}  		case ByteCode.Opcode.OpGte: {  			o = Operator.Gte;  			break;  		}  		case ByteCode.Opcode.OpRem: {  			o = Operator.Rem;  			break;  		}  		#endregion  		}  		if (o == Operator._MAX) {  			throw new NotImplementedException ("Operator not mapped or implemented");  		}  		var t1 = _stack.Peek (-1).TypeCode;  		var t2 = _stack.Peek (-2).TypeCode;  		if (t2 > t1) {  			t1 = t2;  		}  		OperatorCallback op = Machine.GetTypeOperator (t1' o);  		if (op != null) {  			var operand = _stack.StackPointer--;  			_stack.PokeAbs (operand - 2' op (this' _stack.PeekAbs (operand - 2)' _stack.PeekAbs (operand - 1)' _stack.PeekAbs (operand)));  		}  		else {  			throw new Exception ("Operator not defined");  		}  		break;  	}  	case ByteCode.Opcode.GetInd: {  		var type = _stack.Peek (-2).TypeCode;  		var op = Machine.GetTypeOperator (type' Operator.GetInd);  		if (op != null) {  			var operand = _stack.StackPointer--;  			_stack.PokeAbs (operand - 2' op (this' _stack.PeekAbs (operand - 2)' _stack.PeekAbs (operand - 1)' _stack.PeekAbs (operand)));  		}  		else {  			throw new Exception ("Operator not defined");  		}  		break;  	}  	case ByteCode.Opcode.SetInd: {  		var topMin3 = _stack.Peek (-3);  		OperatorCallback op = Machine.GetTypeOperator (topMin3.TypeCode' Operator.SetInd);  		if (op != null) {  			_stack.Poke (-3' op (this' topMin3' _stack.Peek (-2)' _stack.Peek (-1)));  			_stack.StackPointer -= 3;  		}  		else {  			throw new Exception ("Operator not defined");  		}  		break;  	}  	case ByteCode.Opcode.ForEach: {  		var topMin2 = _stack.Peek (-2);  		TypeIteratorCallback itr = Machine.GetTypeIterator (topMin2.TypeCode);  		if (itr == null) {  			_machine.Log.LogEntry ("Undefined iterator for type");  			return ThreadState.Exception;  		}  		var iteratorPos = _stack.Peek (-1).GetInteger ();  		var obj = _stack.Peek (-2).GetReference ();  		iteratorPos = itr (this' obj' iteratorPos' _stack.PeekBase (inst [1].GetInteger ())' _stack.PeekBase (inst [0].GetInteger ()));  		if (iteratorPos != -1) {  			//_Stack2[_Base + Inst[1].GetInteger()] = Key;  			//_Stack2[_Base + Inst[0].GetInteger()] = Item;  			_stack.Poke (Variable.Zero);  		}  		else {  			_stack.Poke (Variable.Zero);  		}  		_stack.Poke (-1' iteratorPos);  		++_stack.StackPointer;  		break;  	}  	#region Dot Operators  	case ByteCode.Opcode.GetDot: {  		var v1 = _stack.Peek (-1);  		OperatorCallback op = Machine.GetTypeOperator (v1.TypeCode' Operator.GetDot);  		_stack.Poke (inst [0]);  		if (op != null) {  			_stack.Poke (-1' op (this' v1' _stack.Peek ()' _stack.Peek ()));  		}  		else {  			throw new Exception ("Operator not defined");  		}  		break;  	}  	case ByteCode.Opcode.SetDot: {  		var v1 = _stack.Peek (-2);  		OperatorCallback op = Machine.GetTypeOperator (v1.TypeCode' Operator.SetDot);  		_stack.Poke (inst [0]);  		if (op != null) {  			_stack.Poke (-2' op (this' _stack.Peek (-2)' _stack.Peek (-1)' _stack.Peek ()));  			_stack.StackPointer -= 2;  		}  		else {  			throw new Exception ("Operator not defined");  		}  		break;  	}  	#endregion  	#endregion  	#region Branch  	case ByteCode.Opcode.Brz: {  		var v = _stack.Pop ();  		if (v.IsZero) {  			var newIp = inst [0].GetInteger ();  			if (newIp >= _instructionList.Count) {  				throw new Exception ("BRZ: Corrupt IP");  			}  			_instructionPtr = newIp;  		}  		break;  	}  	case ByteCode.Opcode.Brnz: {  		var v = _stack.Pop ();  		if (!v.IsZero) {  			var newIp = inst [0].GetInteger ();  			if (newIp >= _instructionList.Count) {  				throw new Exception ("BRZ: Corrupt IP");  			}  			_instructionPtr = newIp;  		}  		break;  	}  	case ByteCode.Opcode.Brzk: {  		var v = _stack.Peek (-1);  		if (v.IsZero) {  			var newIp = inst [0].GetInteger ();  			if (newIp >= _instructionList.Count) {  				throw new Exception ("BRZ: Corrupt IP");  			}  			_instructionPtr = newIp;  		}  		break;  	}  	case ByteCode.Opcode.Brnzk: {  		var v = _stack.Peek (-1);  		if (!v.IsZero) {  			var newIp = inst [0].GetInteger ();  			if (newIp >= _instructionList.Count) {  				throw new Exception ("BRNZK: Corrupt IP");  			}  			_instructionPtr = newIp;  		}  		break;  	}  	case ByteCode.Opcode.Bra: {  		var newIp = inst [0].GetInteger ();  		if (newIp >= _instructionList.Count) {  			throw new Exception ("BRA: Corrupt IP");  		}  		_instructionPtr = newIp;  		break;  	}  	#endregion  	default: {  		throw new Exception ("Unknown instr");  	}  	}  	// end switch instruction  }  
Magic Number,GreenBeanScript,Thread,C:\repos\evolutional_greenbeanscript\GreenBeanScript\VirtualMachine\Thread.cs,Execute,The following statement contains a magic number: for (; ;) {  	if (_instructionPtr >= _instructionList.Count)  		break;  	var inst = _instructionList [_instructionPtr++];  	switch (inst.OpCode) {  	case ByteCode.Opcode.Pop: {  		_stack.Pop ();  		break;  	}  	case ByteCode.Opcode.Pop2: {  		_stack.Pop (2);  		break;  	}  	case ByteCode.Opcode.Dup: {  		_stack.Push (_stack.Peek ());  		break;  	}  	case ByteCode.Opcode.Call: {  		// pop arg count from stack  		ThreadState res = PushStackFrame (inst [0].GetInteger ());  		switch (res) {  		case ThreadState.Running: {  			break;  		}  		case ThreadState.Sys_Yield: {  			return ThreadState.Running;  		}  		case ThreadState.Exception: {  			_machine.SwitchThreadState (this' ThreadState.Killed);  			return ThreadState.Exception;  		}  		case ThreadState.Killed: {  			_machine.SwitchThreadState (this' ThreadState.Killed);  			break;  		}  		default: {  			break;  		}  		}  		break;  	}  	#region Push Operations  	case ByteCode.Opcode.PushNull: {  		Push (Variable.Null);  		break;  	}  	case ByteCode.Opcode.PushThis: {  		Push (This);  		break;  	}  	case ByteCode.Opcode.PushInt0:  	case ByteCode.Opcode.PushInt1:  	case ByteCode.Opcode.PushInt:  	case ByteCode.Opcode.PushFp:  	case ByteCode.Opcode.PushStr:  	case ByteCode.Opcode.PushFn: {  		Push (inst [0]);  		break;  	}  	case ByteCode.Opcode.PushTbl: {  		Push (new TableObject ());  		break;  	}  	#endregion  	case ByteCode.Opcode.Ret:// Ret pushes a null  	 {  		Push (Variable.Null);  		ThreadState res = PopStackFrame ();  		switch (res) {  		case ThreadState.Exception:  		case ThreadState.Killed: {  			_machine.SwitchThreadState (this' res);  			return res;  		}  		default: {  			break;  		}  		}  		break;  	}  	case ByteCode.Opcode.Retv: {  		ThreadState res = PopStackFrame ();  		if (res == ThreadState.Killed) {  			return res;  		}  		break;  	}  	case ByteCode.Opcode.SetGlobal: {  		Variable v1 = inst [0];  		if (v1.Type != VariableType.String) {  			throw new Exception ("String required");  		}  		Variable v2 = _stack.Pop ();  		_machine.Globals [v1] = v2;  		break;  	}  	case ByteCode.Opcode.GetGlobal: {  		Variable v1 = inst [0];  		// global name  		// TODO: Check for string  		if (v1.Type != VariableType.String) {  			throw new Exception ("String required");  		}  		var global = _machine.Globals [v1];  		Push (global);  		break;  	}  	case ByteCode.Opcode.SetLocal: {  		int offset = inst [0].GetInteger ();  		_stack.PokeBase (offset' _stack.Pop ());  		break;  	}  	case ByteCode.Opcode.GetLocal: {  		int offset = inst [0].GetInteger ();  		Push (_stack.PeekBase (offset));  		break;  	}  	#region Operators  	case ByteCode.Opcode.OpEq:  	case ByteCode.Opcode.OpNeq:  	case ByteCode.Opcode.OpLt:  	case ByteCode.Opcode.OpLte:  	case ByteCode.Opcode.OpGt:  	case ByteCode.Opcode.OpGte:  	case ByteCode.Opcode.OpRem:  	case ByteCode.Opcode.OpAdd:  	case ByteCode.Opcode.OpSub:  	case ByteCode.Opcode.OpMul:  	case ByteCode.Opcode.OpDiv: {  		Operator o = Operator._MAX;  		switch (inst.OpCode) {  		#region fold  		case ByteCode.Opcode.OpAdd: {  			o = Operator.Add;  			break;  		}  		case ByteCode.Opcode.OpSub: {  			o = Operator.Sub;  			break;  		}  		case ByteCode.Opcode.OpMul: {  			o = Operator.Mul;  			break;  		}  		case ByteCode.Opcode.OpDiv: {  			o = Operator.Div;  			break;  		}  		case ByteCode.Opcode.GetInd: {  			o = Operator.GetInd;  			break;  		}  		case ByteCode.Opcode.OpEq: {  			o = Operator.Eq;  			break;  		}  		case ByteCode.Opcode.OpNeq: {  			o = Operator.Neq;  			break;  		}  		case ByteCode.Opcode.OpLt: {  			o = Operator.Lt;  			break;  		}  		case ByteCode.Opcode.OpLte: {  			o = Operator.Lte;  			break;  		}  		case ByteCode.Opcode.OpGt: {  			o = Operator.Gt;  			break;  		}  		case ByteCode.Opcode.OpGte: {  			o = Operator.Gte;  			break;  		}  		case ByteCode.Opcode.OpRem: {  			o = Operator.Rem;  			break;  		}  		#endregion  		}  		if (o == Operator._MAX) {  			throw new NotImplementedException ("Operator not mapped or implemented");  		}  		var t1 = _stack.Peek (-1).TypeCode;  		var t2 = _stack.Peek (-2).TypeCode;  		if (t2 > t1) {  			t1 = t2;  		}  		OperatorCallback op = Machine.GetTypeOperator (t1' o);  		if (op != null) {  			var operand = _stack.StackPointer--;  			_stack.PokeAbs (operand - 2' op (this' _stack.PeekAbs (operand - 2)' _stack.PeekAbs (operand - 1)' _stack.PeekAbs (operand)));  		}  		else {  			throw new Exception ("Operator not defined");  		}  		break;  	}  	case ByteCode.Opcode.GetInd: {  		var type = _stack.Peek (-2).TypeCode;  		var op = Machine.GetTypeOperator (type' Operator.GetInd);  		if (op != null) {  			var operand = _stack.StackPointer--;  			_stack.PokeAbs (operand - 2' op (this' _stack.PeekAbs (operand - 2)' _stack.PeekAbs (operand - 1)' _stack.PeekAbs (operand)));  		}  		else {  			throw new Exception ("Operator not defined");  		}  		break;  	}  	case ByteCode.Opcode.SetInd: {  		var topMin3 = _stack.Peek (-3);  		OperatorCallback op = Machine.GetTypeOperator (topMin3.TypeCode' Operator.SetInd);  		if (op != null) {  			_stack.Poke (-3' op (this' topMin3' _stack.Peek (-2)' _stack.Peek (-1)));  			_stack.StackPointer -= 3;  		}  		else {  			throw new Exception ("Operator not defined");  		}  		break;  	}  	case ByteCode.Opcode.ForEach: {  		var topMin2 = _stack.Peek (-2);  		TypeIteratorCallback itr = Machine.GetTypeIterator (topMin2.TypeCode);  		if (itr == null) {  			_machine.Log.LogEntry ("Undefined iterator for type");  			return ThreadState.Exception;  		}  		var iteratorPos = _stack.Peek (-1).GetInteger ();  		var obj = _stack.Peek (-2).GetReference ();  		iteratorPos = itr (this' obj' iteratorPos' _stack.PeekBase (inst [1].GetInteger ())' _stack.PeekBase (inst [0].GetInteger ()));  		if (iteratorPos != -1) {  			//_Stack2[_Base + Inst[1].GetInteger()] = Key;  			//_Stack2[_Base + Inst[0].GetInteger()] = Item;  			_stack.Poke (Variable.Zero);  		}  		else {  			_stack.Poke (Variable.Zero);  		}  		_stack.Poke (-1' iteratorPos);  		++_stack.StackPointer;  		break;  	}  	#region Dot Operators  	case ByteCode.Opcode.GetDot: {  		var v1 = _stack.Peek (-1);  		OperatorCallback op = Machine.GetTypeOperator (v1.TypeCode' Operator.GetDot);  		_stack.Poke (inst [0]);  		if (op != null) {  			_stack.Poke (-1' op (this' v1' _stack.Peek ()' _stack.Peek ()));  		}  		else {  			throw new Exception ("Operator not defined");  		}  		break;  	}  	case ByteCode.Opcode.SetDot: {  		var v1 = _stack.Peek (-2);  		OperatorCallback op = Machine.GetTypeOperator (v1.TypeCode' Operator.SetDot);  		_stack.Poke (inst [0]);  		if (op != null) {  			_stack.Poke (-2' op (this' _stack.Peek (-2)' _stack.Peek (-1)' _stack.Peek ()));  			_stack.StackPointer -= 2;  		}  		else {  			throw new Exception ("Operator not defined");  		}  		break;  	}  	#endregion  	#endregion  	#region Branch  	case ByteCode.Opcode.Brz: {  		var v = _stack.Pop ();  		if (v.IsZero) {  			var newIp = inst [0].GetInteger ();  			if (newIp >= _instructionList.Count) {  				throw new Exception ("BRZ: Corrupt IP");  			}  			_instructionPtr = newIp;  		}  		break;  	}  	case ByteCode.Opcode.Brnz: {  		var v = _stack.Pop ();  		if (!v.IsZero) {  			var newIp = inst [0].GetInteger ();  			if (newIp >= _instructionList.Count) {  				throw new Exception ("BRZ: Corrupt IP");  			}  			_instructionPtr = newIp;  		}  		break;  	}  	case ByteCode.Opcode.Brzk: {  		var v = _stack.Peek (-1);  		if (v.IsZero) {  			var newIp = inst [0].GetInteger ();  			if (newIp >= _instructionList.Count) {  				throw new Exception ("BRZ: Corrupt IP");  			}  			_instructionPtr = newIp;  		}  		break;  	}  	case ByteCode.Opcode.Brnzk: {  		var v = _stack.Peek (-1);  		if (!v.IsZero) {  			var newIp = inst [0].GetInteger ();  			if (newIp >= _instructionList.Count) {  				throw new Exception ("BRNZK: Corrupt IP");  			}  			_instructionPtr = newIp;  		}  		break;  	}  	case ByteCode.Opcode.Bra: {  		var newIp = inst [0].GetInteger ();  		if (newIp >= _instructionList.Count) {  			throw new Exception ("BRA: Corrupt IP");  		}  		_instructionPtr = newIp;  		break;  	}  	#endregion  	default: {  		throw new Exception ("Unknown instr");  	}  	}  	// end switch instruction  }  
Magic Number,GreenBeanScript,Thread,C:\repos\evolutional_greenbeanscript\GreenBeanScript\VirtualMachine\Thread.cs,Execute,The following statement contains a magic number: for (; ;) {  	if (_instructionPtr >= _instructionList.Count)  		break;  	var inst = _instructionList [_instructionPtr++];  	switch (inst.OpCode) {  	case ByteCode.Opcode.Pop: {  		_stack.Pop ();  		break;  	}  	case ByteCode.Opcode.Pop2: {  		_stack.Pop (2);  		break;  	}  	case ByteCode.Opcode.Dup: {  		_stack.Push (_stack.Peek ());  		break;  	}  	case ByteCode.Opcode.Call: {  		// pop arg count from stack  		ThreadState res = PushStackFrame (inst [0].GetInteger ());  		switch (res) {  		case ThreadState.Running: {  			break;  		}  		case ThreadState.Sys_Yield: {  			return ThreadState.Running;  		}  		case ThreadState.Exception: {  			_machine.SwitchThreadState (this' ThreadState.Killed);  			return ThreadState.Exception;  		}  		case ThreadState.Killed: {  			_machine.SwitchThreadState (this' ThreadState.Killed);  			break;  		}  		default: {  			break;  		}  		}  		break;  	}  	#region Push Operations  	case ByteCode.Opcode.PushNull: {  		Push (Variable.Null);  		break;  	}  	case ByteCode.Opcode.PushThis: {  		Push (This);  		break;  	}  	case ByteCode.Opcode.PushInt0:  	case ByteCode.Opcode.PushInt1:  	case ByteCode.Opcode.PushInt:  	case ByteCode.Opcode.PushFp:  	case ByteCode.Opcode.PushStr:  	case ByteCode.Opcode.PushFn: {  		Push (inst [0]);  		break;  	}  	case ByteCode.Opcode.PushTbl: {  		Push (new TableObject ());  		break;  	}  	#endregion  	case ByteCode.Opcode.Ret:// Ret pushes a null  	 {  		Push (Variable.Null);  		ThreadState res = PopStackFrame ();  		switch (res) {  		case ThreadState.Exception:  		case ThreadState.Killed: {  			_machine.SwitchThreadState (this' res);  			return res;  		}  		default: {  			break;  		}  		}  		break;  	}  	case ByteCode.Opcode.Retv: {  		ThreadState res = PopStackFrame ();  		if (res == ThreadState.Killed) {  			return res;  		}  		break;  	}  	case ByteCode.Opcode.SetGlobal: {  		Variable v1 = inst [0];  		if (v1.Type != VariableType.String) {  			throw new Exception ("String required");  		}  		Variable v2 = _stack.Pop ();  		_machine.Globals [v1] = v2;  		break;  	}  	case ByteCode.Opcode.GetGlobal: {  		Variable v1 = inst [0];  		// global name  		// TODO: Check for string  		if (v1.Type != VariableType.String) {  			throw new Exception ("String required");  		}  		var global = _machine.Globals [v1];  		Push (global);  		break;  	}  	case ByteCode.Opcode.SetLocal: {  		int offset = inst [0].GetInteger ();  		_stack.PokeBase (offset' _stack.Pop ());  		break;  	}  	case ByteCode.Opcode.GetLocal: {  		int offset = inst [0].GetInteger ();  		Push (_stack.PeekBase (offset));  		break;  	}  	#region Operators  	case ByteCode.Opcode.OpEq:  	case ByteCode.Opcode.OpNeq:  	case ByteCode.Opcode.OpLt:  	case ByteCode.Opcode.OpLte:  	case ByteCode.Opcode.OpGt:  	case ByteCode.Opcode.OpGte:  	case ByteCode.Opcode.OpRem:  	case ByteCode.Opcode.OpAdd:  	case ByteCode.Opcode.OpSub:  	case ByteCode.Opcode.OpMul:  	case ByteCode.Opcode.OpDiv: {  		Operator o = Operator._MAX;  		switch (inst.OpCode) {  		#region fold  		case ByteCode.Opcode.OpAdd: {  			o = Operator.Add;  			break;  		}  		case ByteCode.Opcode.OpSub: {  			o = Operator.Sub;  			break;  		}  		case ByteCode.Opcode.OpMul: {  			o = Operator.Mul;  			break;  		}  		case ByteCode.Opcode.OpDiv: {  			o = Operator.Div;  			break;  		}  		case ByteCode.Opcode.GetInd: {  			o = Operator.GetInd;  			break;  		}  		case ByteCode.Opcode.OpEq: {  			o = Operator.Eq;  			break;  		}  		case ByteCode.Opcode.OpNeq: {  			o = Operator.Neq;  			break;  		}  		case ByteCode.Opcode.OpLt: {  			o = Operator.Lt;  			break;  		}  		case ByteCode.Opcode.OpLte: {  			o = Operator.Lte;  			break;  		}  		case ByteCode.Opcode.OpGt: {  			o = Operator.Gt;  			break;  		}  		case ByteCode.Opcode.OpGte: {  			o = Operator.Gte;  			break;  		}  		case ByteCode.Opcode.OpRem: {  			o = Operator.Rem;  			break;  		}  		#endregion  		}  		if (o == Operator._MAX) {  			throw new NotImplementedException ("Operator not mapped or implemented");  		}  		var t1 = _stack.Peek (-1).TypeCode;  		var t2 = _stack.Peek (-2).TypeCode;  		if (t2 > t1) {  			t1 = t2;  		}  		OperatorCallback op = Machine.GetTypeOperator (t1' o);  		if (op != null) {  			var operand = _stack.StackPointer--;  			_stack.PokeAbs (operand - 2' op (this' _stack.PeekAbs (operand - 2)' _stack.PeekAbs (operand - 1)' _stack.PeekAbs (operand)));  		}  		else {  			throw new Exception ("Operator not defined");  		}  		break;  	}  	case ByteCode.Opcode.GetInd: {  		var type = _stack.Peek (-2).TypeCode;  		var op = Machine.GetTypeOperator (type' Operator.GetInd);  		if (op != null) {  			var operand = _stack.StackPointer--;  			_stack.PokeAbs (operand - 2' op (this' _stack.PeekAbs (operand - 2)' _stack.PeekAbs (operand - 1)' _stack.PeekAbs (operand)));  		}  		else {  			throw new Exception ("Operator not defined");  		}  		break;  	}  	case ByteCode.Opcode.SetInd: {  		var topMin3 = _stack.Peek (-3);  		OperatorCallback op = Machine.GetTypeOperator (topMin3.TypeCode' Operator.SetInd);  		if (op != null) {  			_stack.Poke (-3' op (this' topMin3' _stack.Peek (-2)' _stack.Peek (-1)));  			_stack.StackPointer -= 3;  		}  		else {  			throw new Exception ("Operator not defined");  		}  		break;  	}  	case ByteCode.Opcode.ForEach: {  		var topMin2 = _stack.Peek (-2);  		TypeIteratorCallback itr = Machine.GetTypeIterator (topMin2.TypeCode);  		if (itr == null) {  			_machine.Log.LogEntry ("Undefined iterator for type");  			return ThreadState.Exception;  		}  		var iteratorPos = _stack.Peek (-1).GetInteger ();  		var obj = _stack.Peek (-2).GetReference ();  		iteratorPos = itr (this' obj' iteratorPos' _stack.PeekBase (inst [1].GetInteger ())' _stack.PeekBase (inst [0].GetInteger ()));  		if (iteratorPos != -1) {  			//_Stack2[_Base + Inst[1].GetInteger()] = Key;  			//_Stack2[_Base + Inst[0].GetInteger()] = Item;  			_stack.Poke (Variable.Zero);  		}  		else {  			_stack.Poke (Variable.Zero);  		}  		_stack.Poke (-1' iteratorPos);  		++_stack.StackPointer;  		break;  	}  	#region Dot Operators  	case ByteCode.Opcode.GetDot: {  		var v1 = _stack.Peek (-1);  		OperatorCallback op = Machine.GetTypeOperator (v1.TypeCode' Operator.GetDot);  		_stack.Poke (inst [0]);  		if (op != null) {  			_stack.Poke (-1' op (this' v1' _stack.Peek ()' _stack.Peek ()));  		}  		else {  			throw new Exception ("Operator not defined");  		}  		break;  	}  	case ByteCode.Opcode.SetDot: {  		var v1 = _stack.Peek (-2);  		OperatorCallback op = Machine.GetTypeOperator (v1.TypeCode' Operator.SetDot);  		_stack.Poke (inst [0]);  		if (op != null) {  			_stack.Poke (-2' op (this' _stack.Peek (-2)' _stack.Peek (-1)' _stack.Peek ()));  			_stack.StackPointer -= 2;  		}  		else {  			throw new Exception ("Operator not defined");  		}  		break;  	}  	#endregion  	#endregion  	#region Branch  	case ByteCode.Opcode.Brz: {  		var v = _stack.Pop ();  		if (v.IsZero) {  			var newIp = inst [0].GetInteger ();  			if (newIp >= _instructionList.Count) {  				throw new Exception ("BRZ: Corrupt IP");  			}  			_instructionPtr = newIp;  		}  		break;  	}  	case ByteCode.Opcode.Brnz: {  		var v = _stack.Pop ();  		if (!v.IsZero) {  			var newIp = inst [0].GetInteger ();  			if (newIp >= _instructionList.Count) {  				throw new Exception ("BRZ: Corrupt IP");  			}  			_instructionPtr = newIp;  		}  		break;  	}  	case ByteCode.Opcode.Brzk: {  		var v = _stack.Peek (-1);  		if (v.IsZero) {  			var newIp = inst [0].GetInteger ();  			if (newIp >= _instructionList.Count) {  				throw new Exception ("BRZ: Corrupt IP");  			}  			_instructionPtr = newIp;  		}  		break;  	}  	case ByteCode.Opcode.Brnzk: {  		var v = _stack.Peek (-1);  		if (!v.IsZero) {  			var newIp = inst [0].GetInteger ();  			if (newIp >= _instructionList.Count) {  				throw new Exception ("BRNZK: Corrupt IP");  			}  			_instructionPtr = newIp;  		}  		break;  	}  	case ByteCode.Opcode.Bra: {  		var newIp = inst [0].GetInteger ();  		if (newIp >= _instructionList.Count) {  			throw new Exception ("BRA: Corrupt IP");  		}  		_instructionPtr = newIp;  		break;  	}  	#endregion  	default: {  		throw new Exception ("Unknown instr");  	}  	}  	// end switch instruction  }  
Magic Number,GreenBeanScript,Thread,C:\repos\evolutional_greenbeanscript\GreenBeanScript\VirtualMachine\Thread.cs,Execute,The following statement contains a magic number: for (; ;) {  	if (_instructionPtr >= _instructionList.Count)  		break;  	var inst = _instructionList [_instructionPtr++];  	switch (inst.OpCode) {  	case ByteCode.Opcode.Pop: {  		_stack.Pop ();  		break;  	}  	case ByteCode.Opcode.Pop2: {  		_stack.Pop (2);  		break;  	}  	case ByteCode.Opcode.Dup: {  		_stack.Push (_stack.Peek ());  		break;  	}  	case ByteCode.Opcode.Call: {  		// pop arg count from stack  		ThreadState res = PushStackFrame (inst [0].GetInteger ());  		switch (res) {  		case ThreadState.Running: {  			break;  		}  		case ThreadState.Sys_Yield: {  			return ThreadState.Running;  		}  		case ThreadState.Exception: {  			_machine.SwitchThreadState (this' ThreadState.Killed);  			return ThreadState.Exception;  		}  		case ThreadState.Killed: {  			_machine.SwitchThreadState (this' ThreadState.Killed);  			break;  		}  		default: {  			break;  		}  		}  		break;  	}  	#region Push Operations  	case ByteCode.Opcode.PushNull: {  		Push (Variable.Null);  		break;  	}  	case ByteCode.Opcode.PushThis: {  		Push (This);  		break;  	}  	case ByteCode.Opcode.PushInt0:  	case ByteCode.Opcode.PushInt1:  	case ByteCode.Opcode.PushInt:  	case ByteCode.Opcode.PushFp:  	case ByteCode.Opcode.PushStr:  	case ByteCode.Opcode.PushFn: {  		Push (inst [0]);  		break;  	}  	case ByteCode.Opcode.PushTbl: {  		Push (new TableObject ());  		break;  	}  	#endregion  	case ByteCode.Opcode.Ret:// Ret pushes a null  	 {  		Push (Variable.Null);  		ThreadState res = PopStackFrame ();  		switch (res) {  		case ThreadState.Exception:  		case ThreadState.Killed: {  			_machine.SwitchThreadState (this' res);  			return res;  		}  		default: {  			break;  		}  		}  		break;  	}  	case ByteCode.Opcode.Retv: {  		ThreadState res = PopStackFrame ();  		if (res == ThreadState.Killed) {  			return res;  		}  		break;  	}  	case ByteCode.Opcode.SetGlobal: {  		Variable v1 = inst [0];  		if (v1.Type != VariableType.String) {  			throw new Exception ("String required");  		}  		Variable v2 = _stack.Pop ();  		_machine.Globals [v1] = v2;  		break;  	}  	case ByteCode.Opcode.GetGlobal: {  		Variable v1 = inst [0];  		// global name  		// TODO: Check for string  		if (v1.Type != VariableType.String) {  			throw new Exception ("String required");  		}  		var global = _machine.Globals [v1];  		Push (global);  		break;  	}  	case ByteCode.Opcode.SetLocal: {  		int offset = inst [0].GetInteger ();  		_stack.PokeBase (offset' _stack.Pop ());  		break;  	}  	case ByteCode.Opcode.GetLocal: {  		int offset = inst [0].GetInteger ();  		Push (_stack.PeekBase (offset));  		break;  	}  	#region Operators  	case ByteCode.Opcode.OpEq:  	case ByteCode.Opcode.OpNeq:  	case ByteCode.Opcode.OpLt:  	case ByteCode.Opcode.OpLte:  	case ByteCode.Opcode.OpGt:  	case ByteCode.Opcode.OpGte:  	case ByteCode.Opcode.OpRem:  	case ByteCode.Opcode.OpAdd:  	case ByteCode.Opcode.OpSub:  	case ByteCode.Opcode.OpMul:  	case ByteCode.Opcode.OpDiv: {  		Operator o = Operator._MAX;  		switch (inst.OpCode) {  		#region fold  		case ByteCode.Opcode.OpAdd: {  			o = Operator.Add;  			break;  		}  		case ByteCode.Opcode.OpSub: {  			o = Operator.Sub;  			break;  		}  		case ByteCode.Opcode.OpMul: {  			o = Operator.Mul;  			break;  		}  		case ByteCode.Opcode.OpDiv: {  			o = Operator.Div;  			break;  		}  		case ByteCode.Opcode.GetInd: {  			o = Operator.GetInd;  			break;  		}  		case ByteCode.Opcode.OpEq: {  			o = Operator.Eq;  			break;  		}  		case ByteCode.Opcode.OpNeq: {  			o = Operator.Neq;  			break;  		}  		case ByteCode.Opcode.OpLt: {  			o = Operator.Lt;  			break;  		}  		case ByteCode.Opcode.OpLte: {  			o = Operator.Lte;  			break;  		}  		case ByteCode.Opcode.OpGt: {  			o = Operator.Gt;  			break;  		}  		case ByteCode.Opcode.OpGte: {  			o = Operator.Gte;  			break;  		}  		case ByteCode.Opcode.OpRem: {  			o = Operator.Rem;  			break;  		}  		#endregion  		}  		if (o == Operator._MAX) {  			throw new NotImplementedException ("Operator not mapped or implemented");  		}  		var t1 = _stack.Peek (-1).TypeCode;  		var t2 = _stack.Peek (-2).TypeCode;  		if (t2 > t1) {  			t1 = t2;  		}  		OperatorCallback op = Machine.GetTypeOperator (t1' o);  		if (op != null) {  			var operand = _stack.StackPointer--;  			_stack.PokeAbs (operand - 2' op (this' _stack.PeekAbs (operand - 2)' _stack.PeekAbs (operand - 1)' _stack.PeekAbs (operand)));  		}  		else {  			throw new Exception ("Operator not defined");  		}  		break;  	}  	case ByteCode.Opcode.GetInd: {  		var type = _stack.Peek (-2).TypeCode;  		var op = Machine.GetTypeOperator (type' Operator.GetInd);  		if (op != null) {  			var operand = _stack.StackPointer--;  			_stack.PokeAbs (operand - 2' op (this' _stack.PeekAbs (operand - 2)' _stack.PeekAbs (operand - 1)' _stack.PeekAbs (operand)));  		}  		else {  			throw new Exception ("Operator not defined");  		}  		break;  	}  	case ByteCode.Opcode.SetInd: {  		var topMin3 = _stack.Peek (-3);  		OperatorCallback op = Machine.GetTypeOperator (topMin3.TypeCode' Operator.SetInd);  		if (op != null) {  			_stack.Poke (-3' op (this' topMin3' _stack.Peek (-2)' _stack.Peek (-1)));  			_stack.StackPointer -= 3;  		}  		else {  			throw new Exception ("Operator not defined");  		}  		break;  	}  	case ByteCode.Opcode.ForEach: {  		var topMin2 = _stack.Peek (-2);  		TypeIteratorCallback itr = Machine.GetTypeIterator (topMin2.TypeCode);  		if (itr == null) {  			_machine.Log.LogEntry ("Undefined iterator for type");  			return ThreadState.Exception;  		}  		var iteratorPos = _stack.Peek (-1).GetInteger ();  		var obj = _stack.Peek (-2).GetReference ();  		iteratorPos = itr (this' obj' iteratorPos' _stack.PeekBase (inst [1].GetInteger ())' _stack.PeekBase (inst [0].GetInteger ()));  		if (iteratorPos != -1) {  			//_Stack2[_Base + Inst[1].GetInteger()] = Key;  			//_Stack2[_Base + Inst[0].GetInteger()] = Item;  			_stack.Poke (Variable.Zero);  		}  		else {  			_stack.Poke (Variable.Zero);  		}  		_stack.Poke (-1' iteratorPos);  		++_stack.StackPointer;  		break;  	}  	#region Dot Operators  	case ByteCode.Opcode.GetDot: {  		var v1 = _stack.Peek (-1);  		OperatorCallback op = Machine.GetTypeOperator (v1.TypeCode' Operator.GetDot);  		_stack.Poke (inst [0]);  		if (op != null) {  			_stack.Poke (-1' op (this' v1' _stack.Peek ()' _stack.Peek ()));  		}  		else {  			throw new Exception ("Operator not defined");  		}  		break;  	}  	case ByteCode.Opcode.SetDot: {  		var v1 = _stack.Peek (-2);  		OperatorCallback op = Machine.GetTypeOperator (v1.TypeCode' Operator.SetDot);  		_stack.Poke (inst [0]);  		if (op != null) {  			_stack.Poke (-2' op (this' _stack.Peek (-2)' _stack.Peek (-1)' _stack.Peek ()));  			_stack.StackPointer -= 2;  		}  		else {  			throw new Exception ("Operator not defined");  		}  		break;  	}  	#endregion  	#endregion  	#region Branch  	case ByteCode.Opcode.Brz: {  		var v = _stack.Pop ();  		if (v.IsZero) {  			var newIp = inst [0].GetInteger ();  			if (newIp >= _instructionList.Count) {  				throw new Exception ("BRZ: Corrupt IP");  			}  			_instructionPtr = newIp;  		}  		break;  	}  	case ByteCode.Opcode.Brnz: {  		var v = _stack.Pop ();  		if (!v.IsZero) {  			var newIp = inst [0].GetInteger ();  			if (newIp >= _instructionList.Count) {  				throw new Exception ("BRZ: Corrupt IP");  			}  			_instructionPtr = newIp;  		}  		break;  	}  	case ByteCode.Opcode.Brzk: {  		var v = _stack.Peek (-1);  		if (v.IsZero) {  			var newIp = inst [0].GetInteger ();  			if (newIp >= _instructionList.Count) {  				throw new Exception ("BRZ: Corrupt IP");  			}  			_instructionPtr = newIp;  		}  		break;  	}  	case ByteCode.Opcode.Brnzk: {  		var v = _stack.Peek (-1);  		if (!v.IsZero) {  			var newIp = inst [0].GetInteger ();  			if (newIp >= _instructionList.Count) {  				throw new Exception ("BRNZK: Corrupt IP");  			}  			_instructionPtr = newIp;  		}  		break;  	}  	case ByteCode.Opcode.Bra: {  		var newIp = inst [0].GetInteger ();  		if (newIp >= _instructionList.Count) {  			throw new Exception ("BRA: Corrupt IP");  		}  		_instructionPtr = newIp;  		break;  	}  	#endregion  	default: {  		throw new Exception ("Unknown instr");  	}  	}  	// end switch instruction  }  
Magic Number,GreenBeanScript,Thread,C:\repos\evolutional_greenbeanscript\GreenBeanScript\VirtualMachine\Thread.cs,Execute,The following statement contains a magic number: for (; ;) {  	if (_instructionPtr >= _instructionList.Count)  		break;  	var inst = _instructionList [_instructionPtr++];  	switch (inst.OpCode) {  	case ByteCode.Opcode.Pop: {  		_stack.Pop ();  		break;  	}  	case ByteCode.Opcode.Pop2: {  		_stack.Pop (2);  		break;  	}  	case ByteCode.Opcode.Dup: {  		_stack.Push (_stack.Peek ());  		break;  	}  	case ByteCode.Opcode.Call: {  		// pop arg count from stack  		ThreadState res = PushStackFrame (inst [0].GetInteger ());  		switch (res) {  		case ThreadState.Running: {  			break;  		}  		case ThreadState.Sys_Yield: {  			return ThreadState.Running;  		}  		case ThreadState.Exception: {  			_machine.SwitchThreadState (this' ThreadState.Killed);  			return ThreadState.Exception;  		}  		case ThreadState.Killed: {  			_machine.SwitchThreadState (this' ThreadState.Killed);  			break;  		}  		default: {  			break;  		}  		}  		break;  	}  	#region Push Operations  	case ByteCode.Opcode.PushNull: {  		Push (Variable.Null);  		break;  	}  	case ByteCode.Opcode.PushThis: {  		Push (This);  		break;  	}  	case ByteCode.Opcode.PushInt0:  	case ByteCode.Opcode.PushInt1:  	case ByteCode.Opcode.PushInt:  	case ByteCode.Opcode.PushFp:  	case ByteCode.Opcode.PushStr:  	case ByteCode.Opcode.PushFn: {  		Push (inst [0]);  		break;  	}  	case ByteCode.Opcode.PushTbl: {  		Push (new TableObject ());  		break;  	}  	#endregion  	case ByteCode.Opcode.Ret:// Ret pushes a null  	 {  		Push (Variable.Null);  		ThreadState res = PopStackFrame ();  		switch (res) {  		case ThreadState.Exception:  		case ThreadState.Killed: {  			_machine.SwitchThreadState (this' res);  			return res;  		}  		default: {  			break;  		}  		}  		break;  	}  	case ByteCode.Opcode.Retv: {  		ThreadState res = PopStackFrame ();  		if (res == ThreadState.Killed) {  			return res;  		}  		break;  	}  	case ByteCode.Opcode.SetGlobal: {  		Variable v1 = inst [0];  		if (v1.Type != VariableType.String) {  			throw new Exception ("String required");  		}  		Variable v2 = _stack.Pop ();  		_machine.Globals [v1] = v2;  		break;  	}  	case ByteCode.Opcode.GetGlobal: {  		Variable v1 = inst [0];  		// global name  		// TODO: Check for string  		if (v1.Type != VariableType.String) {  			throw new Exception ("String required");  		}  		var global = _machine.Globals [v1];  		Push (global);  		break;  	}  	case ByteCode.Opcode.SetLocal: {  		int offset = inst [0].GetInteger ();  		_stack.PokeBase (offset' _stack.Pop ());  		break;  	}  	case ByteCode.Opcode.GetLocal: {  		int offset = inst [0].GetInteger ();  		Push (_stack.PeekBase (offset));  		break;  	}  	#region Operators  	case ByteCode.Opcode.OpEq:  	case ByteCode.Opcode.OpNeq:  	case ByteCode.Opcode.OpLt:  	case ByteCode.Opcode.OpLte:  	case ByteCode.Opcode.OpGt:  	case ByteCode.Opcode.OpGte:  	case ByteCode.Opcode.OpRem:  	case ByteCode.Opcode.OpAdd:  	case ByteCode.Opcode.OpSub:  	case ByteCode.Opcode.OpMul:  	case ByteCode.Opcode.OpDiv: {  		Operator o = Operator._MAX;  		switch (inst.OpCode) {  		#region fold  		case ByteCode.Opcode.OpAdd: {  			o = Operator.Add;  			break;  		}  		case ByteCode.Opcode.OpSub: {  			o = Operator.Sub;  			break;  		}  		case ByteCode.Opcode.OpMul: {  			o = Operator.Mul;  			break;  		}  		case ByteCode.Opcode.OpDiv: {  			o = Operator.Div;  			break;  		}  		case ByteCode.Opcode.GetInd: {  			o = Operator.GetInd;  			break;  		}  		case ByteCode.Opcode.OpEq: {  			o = Operator.Eq;  			break;  		}  		case ByteCode.Opcode.OpNeq: {  			o = Operator.Neq;  			break;  		}  		case ByteCode.Opcode.OpLt: {  			o = Operator.Lt;  			break;  		}  		case ByteCode.Opcode.OpLte: {  			o = Operator.Lte;  			break;  		}  		case ByteCode.Opcode.OpGt: {  			o = Operator.Gt;  			break;  		}  		case ByteCode.Opcode.OpGte: {  			o = Operator.Gte;  			break;  		}  		case ByteCode.Opcode.OpRem: {  			o = Operator.Rem;  			break;  		}  		#endregion  		}  		if (o == Operator._MAX) {  			throw new NotImplementedException ("Operator not mapped or implemented");  		}  		var t1 = _stack.Peek (-1).TypeCode;  		var t2 = _stack.Peek (-2).TypeCode;  		if (t2 > t1) {  			t1 = t2;  		}  		OperatorCallback op = Machine.GetTypeOperator (t1' o);  		if (op != null) {  			var operand = _stack.StackPointer--;  			_stack.PokeAbs (operand - 2' op (this' _stack.PeekAbs (operand - 2)' _stack.PeekAbs (operand - 1)' _stack.PeekAbs (operand)));  		}  		else {  			throw new Exception ("Operator not defined");  		}  		break;  	}  	case ByteCode.Opcode.GetInd: {  		var type = _stack.Peek (-2).TypeCode;  		var op = Machine.GetTypeOperator (type' Operator.GetInd);  		if (op != null) {  			var operand = _stack.StackPointer--;  			_stack.PokeAbs (operand - 2' op (this' _stack.PeekAbs (operand - 2)' _stack.PeekAbs (operand - 1)' _stack.PeekAbs (operand)));  		}  		else {  			throw new Exception ("Operator not defined");  		}  		break;  	}  	case ByteCode.Opcode.SetInd: {  		var topMin3 = _stack.Peek (-3);  		OperatorCallback op = Machine.GetTypeOperator (topMin3.TypeCode' Operator.SetInd);  		if (op != null) {  			_stack.Poke (-3' op (this' topMin3' _stack.Peek (-2)' _stack.Peek (-1)));  			_stack.StackPointer -= 3;  		}  		else {  			throw new Exception ("Operator not defined");  		}  		break;  	}  	case ByteCode.Opcode.ForEach: {  		var topMin2 = _stack.Peek (-2);  		TypeIteratorCallback itr = Machine.GetTypeIterator (topMin2.TypeCode);  		if (itr == null) {  			_machine.Log.LogEntry ("Undefined iterator for type");  			return ThreadState.Exception;  		}  		var iteratorPos = _stack.Peek (-1).GetInteger ();  		var obj = _stack.Peek (-2).GetReference ();  		iteratorPos = itr (this' obj' iteratorPos' _stack.PeekBase (inst [1].GetInteger ())' _stack.PeekBase (inst [0].GetInteger ()));  		if (iteratorPos != -1) {  			//_Stack2[_Base + Inst[1].GetInteger()] = Key;  			//_Stack2[_Base + Inst[0].GetInteger()] = Item;  			_stack.Poke (Variable.Zero);  		}  		else {  			_stack.Poke (Variable.Zero);  		}  		_stack.Poke (-1' iteratorPos);  		++_stack.StackPointer;  		break;  	}  	#region Dot Operators  	case ByteCode.Opcode.GetDot: {  		var v1 = _stack.Peek (-1);  		OperatorCallback op = Machine.GetTypeOperator (v1.TypeCode' Operator.GetDot);  		_stack.Poke (inst [0]);  		if (op != null) {  			_stack.Poke (-1' op (this' v1' _stack.Peek ()' _stack.Peek ()));  		}  		else {  			throw new Exception ("Operator not defined");  		}  		break;  	}  	case ByteCode.Opcode.SetDot: {  		var v1 = _stack.Peek (-2);  		OperatorCallback op = Machine.GetTypeOperator (v1.TypeCode' Operator.SetDot);  		_stack.Poke (inst [0]);  		if (op != null) {  			_stack.Poke (-2' op (this' _stack.Peek (-2)' _stack.Peek (-1)' _stack.Peek ()));  			_stack.StackPointer -= 2;  		}  		else {  			throw new Exception ("Operator not defined");  		}  		break;  	}  	#endregion  	#endregion  	#region Branch  	case ByteCode.Opcode.Brz: {  		var v = _stack.Pop ();  		if (v.IsZero) {  			var newIp = inst [0].GetInteger ();  			if (newIp >= _instructionList.Count) {  				throw new Exception ("BRZ: Corrupt IP");  			}  			_instructionPtr = newIp;  		}  		break;  	}  	case ByteCode.Opcode.Brnz: {  		var v = _stack.Pop ();  		if (!v.IsZero) {  			var newIp = inst [0].GetInteger ();  			if (newIp >= _instructionList.Count) {  				throw new Exception ("BRZ: Corrupt IP");  			}  			_instructionPtr = newIp;  		}  		break;  	}  	case ByteCode.Opcode.Brzk: {  		var v = _stack.Peek (-1);  		if (v.IsZero) {  			var newIp = inst [0].GetInteger ();  			if (newIp >= _instructionList.Count) {  				throw new Exception ("BRZ: Corrupt IP");  			}  			_instructionPtr = newIp;  		}  		break;  	}  	case ByteCode.Opcode.Brnzk: {  		var v = _stack.Peek (-1);  		if (!v.IsZero) {  			var newIp = inst [0].GetInteger ();  			if (newIp >= _instructionList.Count) {  				throw new Exception ("BRNZK: Corrupt IP");  			}  			_instructionPtr = newIp;  		}  		break;  	}  	case ByteCode.Opcode.Bra: {  		var newIp = inst [0].GetInteger ();  		if (newIp >= _instructionList.Count) {  			throw new Exception ("BRA: Corrupt IP");  		}  		_instructionPtr = newIp;  		break;  	}  	#endregion  	default: {  		throw new Exception ("Unknown instr");  	}  	}  	// end switch instruction  }  
Magic Number,GreenBeanScript,Thread,C:\repos\evolutional_greenbeanscript\GreenBeanScript\VirtualMachine\Thread.cs,Execute,The following statement contains a magic number: for (; ;) {  	if (_instructionPtr >= _instructionList.Count)  		break;  	var inst = _instructionList [_instructionPtr++];  	switch (inst.OpCode) {  	case ByteCode.Opcode.Pop: {  		_stack.Pop ();  		break;  	}  	case ByteCode.Opcode.Pop2: {  		_stack.Pop (2);  		break;  	}  	case ByteCode.Opcode.Dup: {  		_stack.Push (_stack.Peek ());  		break;  	}  	case ByteCode.Opcode.Call: {  		// pop arg count from stack  		ThreadState res = PushStackFrame (inst [0].GetInteger ());  		switch (res) {  		case ThreadState.Running: {  			break;  		}  		case ThreadState.Sys_Yield: {  			return ThreadState.Running;  		}  		case ThreadState.Exception: {  			_machine.SwitchThreadState (this' ThreadState.Killed);  			return ThreadState.Exception;  		}  		case ThreadState.Killed: {  			_machine.SwitchThreadState (this' ThreadState.Killed);  			break;  		}  		default: {  			break;  		}  		}  		break;  	}  	#region Push Operations  	case ByteCode.Opcode.PushNull: {  		Push (Variable.Null);  		break;  	}  	case ByteCode.Opcode.PushThis: {  		Push (This);  		break;  	}  	case ByteCode.Opcode.PushInt0:  	case ByteCode.Opcode.PushInt1:  	case ByteCode.Opcode.PushInt:  	case ByteCode.Opcode.PushFp:  	case ByteCode.Opcode.PushStr:  	case ByteCode.Opcode.PushFn: {  		Push (inst [0]);  		break;  	}  	case ByteCode.Opcode.PushTbl: {  		Push (new TableObject ());  		break;  	}  	#endregion  	case ByteCode.Opcode.Ret:// Ret pushes a null  	 {  		Push (Variable.Null);  		ThreadState res = PopStackFrame ();  		switch (res) {  		case ThreadState.Exception:  		case ThreadState.Killed: {  			_machine.SwitchThreadState (this' res);  			return res;  		}  		default: {  			break;  		}  		}  		break;  	}  	case ByteCode.Opcode.Retv: {  		ThreadState res = PopStackFrame ();  		if (res == ThreadState.Killed) {  			return res;  		}  		break;  	}  	case ByteCode.Opcode.SetGlobal: {  		Variable v1 = inst [0];  		if (v1.Type != VariableType.String) {  			throw new Exception ("String required");  		}  		Variable v2 = _stack.Pop ();  		_machine.Globals [v1] = v2;  		break;  	}  	case ByteCode.Opcode.GetGlobal: {  		Variable v1 = inst [0];  		// global name  		// TODO: Check for string  		if (v1.Type != VariableType.String) {  			throw new Exception ("String required");  		}  		var global = _machine.Globals [v1];  		Push (global);  		break;  	}  	case ByteCode.Opcode.SetLocal: {  		int offset = inst [0].GetInteger ();  		_stack.PokeBase (offset' _stack.Pop ());  		break;  	}  	case ByteCode.Opcode.GetLocal: {  		int offset = inst [0].GetInteger ();  		Push (_stack.PeekBase (offset));  		break;  	}  	#region Operators  	case ByteCode.Opcode.OpEq:  	case ByteCode.Opcode.OpNeq:  	case ByteCode.Opcode.OpLt:  	case ByteCode.Opcode.OpLte:  	case ByteCode.Opcode.OpGt:  	case ByteCode.Opcode.OpGte:  	case ByteCode.Opcode.OpRem:  	case ByteCode.Opcode.OpAdd:  	case ByteCode.Opcode.OpSub:  	case ByteCode.Opcode.OpMul:  	case ByteCode.Opcode.OpDiv: {  		Operator o = Operator._MAX;  		switch (inst.OpCode) {  		#region fold  		case ByteCode.Opcode.OpAdd: {  			o = Operator.Add;  			break;  		}  		case ByteCode.Opcode.OpSub: {  			o = Operator.Sub;  			break;  		}  		case ByteCode.Opcode.OpMul: {  			o = Operator.Mul;  			break;  		}  		case ByteCode.Opcode.OpDiv: {  			o = Operator.Div;  			break;  		}  		case ByteCode.Opcode.GetInd: {  			o = Operator.GetInd;  			break;  		}  		case ByteCode.Opcode.OpEq: {  			o = Operator.Eq;  			break;  		}  		case ByteCode.Opcode.OpNeq: {  			o = Operator.Neq;  			break;  		}  		case ByteCode.Opcode.OpLt: {  			o = Operator.Lt;  			break;  		}  		case ByteCode.Opcode.OpLte: {  			o = Operator.Lte;  			break;  		}  		case ByteCode.Opcode.OpGt: {  			o = Operator.Gt;  			break;  		}  		case ByteCode.Opcode.OpGte: {  			o = Operator.Gte;  			break;  		}  		case ByteCode.Opcode.OpRem: {  			o = Operator.Rem;  			break;  		}  		#endregion  		}  		if (o == Operator._MAX) {  			throw new NotImplementedException ("Operator not mapped or implemented");  		}  		var t1 = _stack.Peek (-1).TypeCode;  		var t2 = _stack.Peek (-2).TypeCode;  		if (t2 > t1) {  			t1 = t2;  		}  		OperatorCallback op = Machine.GetTypeOperator (t1' o);  		if (op != null) {  			var operand = _stack.StackPointer--;  			_stack.PokeAbs (operand - 2' op (this' _stack.PeekAbs (operand - 2)' _stack.PeekAbs (operand - 1)' _stack.PeekAbs (operand)));  		}  		else {  			throw new Exception ("Operator not defined");  		}  		break;  	}  	case ByteCode.Opcode.GetInd: {  		var type = _stack.Peek (-2).TypeCode;  		var op = Machine.GetTypeOperator (type' Operator.GetInd);  		if (op != null) {  			var operand = _stack.StackPointer--;  			_stack.PokeAbs (operand - 2' op (this' _stack.PeekAbs (operand - 2)' _stack.PeekAbs (operand - 1)' _stack.PeekAbs (operand)));  		}  		else {  			throw new Exception ("Operator not defined");  		}  		break;  	}  	case ByteCode.Opcode.SetInd: {  		var topMin3 = _stack.Peek (-3);  		OperatorCallback op = Machine.GetTypeOperator (topMin3.TypeCode' Operator.SetInd);  		if (op != null) {  			_stack.Poke (-3' op (this' topMin3' _stack.Peek (-2)' _stack.Peek (-1)));  			_stack.StackPointer -= 3;  		}  		else {  			throw new Exception ("Operator not defined");  		}  		break;  	}  	case ByteCode.Opcode.ForEach: {  		var topMin2 = _stack.Peek (-2);  		TypeIteratorCallback itr = Machine.GetTypeIterator (topMin2.TypeCode);  		if (itr == null) {  			_machine.Log.LogEntry ("Undefined iterator for type");  			return ThreadState.Exception;  		}  		var iteratorPos = _stack.Peek (-1).GetInteger ();  		var obj = _stack.Peek (-2).GetReference ();  		iteratorPos = itr (this' obj' iteratorPos' _stack.PeekBase (inst [1].GetInteger ())' _stack.PeekBase (inst [0].GetInteger ()));  		if (iteratorPos != -1) {  			//_Stack2[_Base + Inst[1].GetInteger()] = Key;  			//_Stack2[_Base + Inst[0].GetInteger()] = Item;  			_stack.Poke (Variable.Zero);  		}  		else {  			_stack.Poke (Variable.Zero);  		}  		_stack.Poke (-1' iteratorPos);  		++_stack.StackPointer;  		break;  	}  	#region Dot Operators  	case ByteCode.Opcode.GetDot: {  		var v1 = _stack.Peek (-1);  		OperatorCallback op = Machine.GetTypeOperator (v1.TypeCode' Operator.GetDot);  		_stack.Poke (inst [0]);  		if (op != null) {  			_stack.Poke (-1' op (this' v1' _stack.Peek ()' _stack.Peek ()));  		}  		else {  			throw new Exception ("Operator not defined");  		}  		break;  	}  	case ByteCode.Opcode.SetDot: {  		var v1 = _stack.Peek (-2);  		OperatorCallback op = Machine.GetTypeOperator (v1.TypeCode' Operator.SetDot);  		_stack.Poke (inst [0]);  		if (op != null) {  			_stack.Poke (-2' op (this' _stack.Peek (-2)' _stack.Peek (-1)' _stack.Peek ()));  			_stack.StackPointer -= 2;  		}  		else {  			throw new Exception ("Operator not defined");  		}  		break;  	}  	#endregion  	#endregion  	#region Branch  	case ByteCode.Opcode.Brz: {  		var v = _stack.Pop ();  		if (v.IsZero) {  			var newIp = inst [0].GetInteger ();  			if (newIp >= _instructionList.Count) {  				throw new Exception ("BRZ: Corrupt IP");  			}  			_instructionPtr = newIp;  		}  		break;  	}  	case ByteCode.Opcode.Brnz: {  		var v = _stack.Pop ();  		if (!v.IsZero) {  			var newIp = inst [0].GetInteger ();  			if (newIp >= _instructionList.Count) {  				throw new Exception ("BRZ: Corrupt IP");  			}  			_instructionPtr = newIp;  		}  		break;  	}  	case ByteCode.Opcode.Brzk: {  		var v = _stack.Peek (-1);  		if (v.IsZero) {  			var newIp = inst [0].GetInteger ();  			if (newIp >= _instructionList.Count) {  				throw new Exception ("BRZ: Corrupt IP");  			}  			_instructionPtr = newIp;  		}  		break;  	}  	case ByteCode.Opcode.Brnzk: {  		var v = _stack.Peek (-1);  		if (!v.IsZero) {  			var newIp = inst [0].GetInteger ();  			if (newIp >= _instructionList.Count) {  				throw new Exception ("BRNZK: Corrupt IP");  			}  			_instructionPtr = newIp;  		}  		break;  	}  	case ByteCode.Opcode.Bra: {  		var newIp = inst [0].GetInteger ();  		if (newIp >= _instructionList.Count) {  			throw new Exception ("BRA: Corrupt IP");  		}  		_instructionPtr = newIp;  		break;  	}  	#endregion  	default: {  		throw new Exception ("Unknown instr");  	}  	}  	// end switch instruction  }  
Magic Number,GreenBeanScript,Thread,C:\repos\evolutional_greenbeanscript\GreenBeanScript\VirtualMachine\Thread.cs,Execute,The following statement contains a magic number: for (; ;) {  	if (_instructionPtr >= _instructionList.Count)  		break;  	var inst = _instructionList [_instructionPtr++];  	switch (inst.OpCode) {  	case ByteCode.Opcode.Pop: {  		_stack.Pop ();  		break;  	}  	case ByteCode.Opcode.Pop2: {  		_stack.Pop (2);  		break;  	}  	case ByteCode.Opcode.Dup: {  		_stack.Push (_stack.Peek ());  		break;  	}  	case ByteCode.Opcode.Call: {  		// pop arg count from stack  		ThreadState res = PushStackFrame (inst [0].GetInteger ());  		switch (res) {  		case ThreadState.Running: {  			break;  		}  		case ThreadState.Sys_Yield: {  			return ThreadState.Running;  		}  		case ThreadState.Exception: {  			_machine.SwitchThreadState (this' ThreadState.Killed);  			return ThreadState.Exception;  		}  		case ThreadState.Killed: {  			_machine.SwitchThreadState (this' ThreadState.Killed);  			break;  		}  		default: {  			break;  		}  		}  		break;  	}  	#region Push Operations  	case ByteCode.Opcode.PushNull: {  		Push (Variable.Null);  		break;  	}  	case ByteCode.Opcode.PushThis: {  		Push (This);  		break;  	}  	case ByteCode.Opcode.PushInt0:  	case ByteCode.Opcode.PushInt1:  	case ByteCode.Opcode.PushInt:  	case ByteCode.Opcode.PushFp:  	case ByteCode.Opcode.PushStr:  	case ByteCode.Opcode.PushFn: {  		Push (inst [0]);  		break;  	}  	case ByteCode.Opcode.PushTbl: {  		Push (new TableObject ());  		break;  	}  	#endregion  	case ByteCode.Opcode.Ret:// Ret pushes a null  	 {  		Push (Variable.Null);  		ThreadState res = PopStackFrame ();  		switch (res) {  		case ThreadState.Exception:  		case ThreadState.Killed: {  			_machine.SwitchThreadState (this' res);  			return res;  		}  		default: {  			break;  		}  		}  		break;  	}  	case ByteCode.Opcode.Retv: {  		ThreadState res = PopStackFrame ();  		if (res == ThreadState.Killed) {  			return res;  		}  		break;  	}  	case ByteCode.Opcode.SetGlobal: {  		Variable v1 = inst [0];  		if (v1.Type != VariableType.String) {  			throw new Exception ("String required");  		}  		Variable v2 = _stack.Pop ();  		_machine.Globals [v1] = v2;  		break;  	}  	case ByteCode.Opcode.GetGlobal: {  		Variable v1 = inst [0];  		// global name  		// TODO: Check for string  		if (v1.Type != VariableType.String) {  			throw new Exception ("String required");  		}  		var global = _machine.Globals [v1];  		Push (global);  		break;  	}  	case ByteCode.Opcode.SetLocal: {  		int offset = inst [0].GetInteger ();  		_stack.PokeBase (offset' _stack.Pop ());  		break;  	}  	case ByteCode.Opcode.GetLocal: {  		int offset = inst [0].GetInteger ();  		Push (_stack.PeekBase (offset));  		break;  	}  	#region Operators  	case ByteCode.Opcode.OpEq:  	case ByteCode.Opcode.OpNeq:  	case ByteCode.Opcode.OpLt:  	case ByteCode.Opcode.OpLte:  	case ByteCode.Opcode.OpGt:  	case ByteCode.Opcode.OpGte:  	case ByteCode.Opcode.OpRem:  	case ByteCode.Opcode.OpAdd:  	case ByteCode.Opcode.OpSub:  	case ByteCode.Opcode.OpMul:  	case ByteCode.Opcode.OpDiv: {  		Operator o = Operator._MAX;  		switch (inst.OpCode) {  		#region fold  		case ByteCode.Opcode.OpAdd: {  			o = Operator.Add;  			break;  		}  		case ByteCode.Opcode.OpSub: {  			o = Operator.Sub;  			break;  		}  		case ByteCode.Opcode.OpMul: {  			o = Operator.Mul;  			break;  		}  		case ByteCode.Opcode.OpDiv: {  			o = Operator.Div;  			break;  		}  		case ByteCode.Opcode.GetInd: {  			o = Operator.GetInd;  			break;  		}  		case ByteCode.Opcode.OpEq: {  			o = Operator.Eq;  			break;  		}  		case ByteCode.Opcode.OpNeq: {  			o = Operator.Neq;  			break;  		}  		case ByteCode.Opcode.OpLt: {  			o = Operator.Lt;  			break;  		}  		case ByteCode.Opcode.OpLte: {  			o = Operator.Lte;  			break;  		}  		case ByteCode.Opcode.OpGt: {  			o = Operator.Gt;  			break;  		}  		case ByteCode.Opcode.OpGte: {  			o = Operator.Gte;  			break;  		}  		case ByteCode.Opcode.OpRem: {  			o = Operator.Rem;  			break;  		}  		#endregion  		}  		if (o == Operator._MAX) {  			throw new NotImplementedException ("Operator not mapped or implemented");  		}  		var t1 = _stack.Peek (-1).TypeCode;  		var t2 = _stack.Peek (-2).TypeCode;  		if (t2 > t1) {  			t1 = t2;  		}  		OperatorCallback op = Machine.GetTypeOperator (t1' o);  		if (op != null) {  			var operand = _stack.StackPointer--;  			_stack.PokeAbs (operand - 2' op (this' _stack.PeekAbs (operand - 2)' _stack.PeekAbs (operand - 1)' _stack.PeekAbs (operand)));  		}  		else {  			throw new Exception ("Operator not defined");  		}  		break;  	}  	case ByteCode.Opcode.GetInd: {  		var type = _stack.Peek (-2).TypeCode;  		var op = Machine.GetTypeOperator (type' Operator.GetInd);  		if (op != null) {  			var operand = _stack.StackPointer--;  			_stack.PokeAbs (operand - 2' op (this' _stack.PeekAbs (operand - 2)' _stack.PeekAbs (operand - 1)' _stack.PeekAbs (operand)));  		}  		else {  			throw new Exception ("Operator not defined");  		}  		break;  	}  	case ByteCode.Opcode.SetInd: {  		var topMin3 = _stack.Peek (-3);  		OperatorCallback op = Machine.GetTypeOperator (topMin3.TypeCode' Operator.SetInd);  		if (op != null) {  			_stack.Poke (-3' op (this' topMin3' _stack.Peek (-2)' _stack.Peek (-1)));  			_stack.StackPointer -= 3;  		}  		else {  			throw new Exception ("Operator not defined");  		}  		break;  	}  	case ByteCode.Opcode.ForEach: {  		var topMin2 = _stack.Peek (-2);  		TypeIteratorCallback itr = Machine.GetTypeIterator (topMin2.TypeCode);  		if (itr == null) {  			_machine.Log.LogEntry ("Undefined iterator for type");  			return ThreadState.Exception;  		}  		var iteratorPos = _stack.Peek (-1).GetInteger ();  		var obj = _stack.Peek (-2).GetReference ();  		iteratorPos = itr (this' obj' iteratorPos' _stack.PeekBase (inst [1].GetInteger ())' _stack.PeekBase (inst [0].GetInteger ()));  		if (iteratorPos != -1) {  			//_Stack2[_Base + Inst[1].GetInteger()] = Key;  			//_Stack2[_Base + Inst[0].GetInteger()] = Item;  			_stack.Poke (Variable.Zero);  		}  		else {  			_stack.Poke (Variable.Zero);  		}  		_stack.Poke (-1' iteratorPos);  		++_stack.StackPointer;  		break;  	}  	#region Dot Operators  	case ByteCode.Opcode.GetDot: {  		var v1 = _stack.Peek (-1);  		OperatorCallback op = Machine.GetTypeOperator (v1.TypeCode' Operator.GetDot);  		_stack.Poke (inst [0]);  		if (op != null) {  			_stack.Poke (-1' op (this' v1' _stack.Peek ()' _stack.Peek ()));  		}  		else {  			throw new Exception ("Operator not defined");  		}  		break;  	}  	case ByteCode.Opcode.SetDot: {  		var v1 = _stack.Peek (-2);  		OperatorCallback op = Machine.GetTypeOperator (v1.TypeCode' Operator.SetDot);  		_stack.Poke (inst [0]);  		if (op != null) {  			_stack.Poke (-2' op (this' _stack.Peek (-2)' _stack.Peek (-1)' _stack.Peek ()));  			_stack.StackPointer -= 2;  		}  		else {  			throw new Exception ("Operator not defined");  		}  		break;  	}  	#endregion  	#endregion  	#region Branch  	case ByteCode.Opcode.Brz: {  		var v = _stack.Pop ();  		if (v.IsZero) {  			var newIp = inst [0].GetInteger ();  			if (newIp >= _instructionList.Count) {  				throw new Exception ("BRZ: Corrupt IP");  			}  			_instructionPtr = newIp;  		}  		break;  	}  	case ByteCode.Opcode.Brnz: {  		var v = _stack.Pop ();  		if (!v.IsZero) {  			var newIp = inst [0].GetInteger ();  			if (newIp >= _instructionList.Count) {  				throw new Exception ("BRZ: Corrupt IP");  			}  			_instructionPtr = newIp;  		}  		break;  	}  	case ByteCode.Opcode.Brzk: {  		var v = _stack.Peek (-1);  		if (v.IsZero) {  			var newIp = inst [0].GetInteger ();  			if (newIp >= _instructionList.Count) {  				throw new Exception ("BRZ: Corrupt IP");  			}  			_instructionPtr = newIp;  		}  		break;  	}  	case ByteCode.Opcode.Brnzk: {  		var v = _stack.Peek (-1);  		if (!v.IsZero) {  			var newIp = inst [0].GetInteger ();  			if (newIp >= _instructionList.Count) {  				throw new Exception ("BRNZK: Corrupt IP");  			}  			_instructionPtr = newIp;  		}  		break;  	}  	case ByteCode.Opcode.Bra: {  		var newIp = inst [0].GetInteger ();  		if (newIp >= _instructionList.Count) {  			throw new Exception ("BRA: Corrupt IP");  		}  		_instructionPtr = newIp;  		break;  	}  	#endregion  	default: {  		throw new Exception ("Unknown instr");  	}  	}  	// end switch instruction  }  
Magic Number,GreenBeanScript,Thread,C:\repos\evolutional_greenbeanscript\GreenBeanScript\VirtualMachine\Thread.cs,Execute,The following statement contains a magic number: for (; ;) {  	if (_instructionPtr >= _instructionList.Count)  		break;  	var inst = _instructionList [_instructionPtr++];  	switch (inst.OpCode) {  	case ByteCode.Opcode.Pop: {  		_stack.Pop ();  		break;  	}  	case ByteCode.Opcode.Pop2: {  		_stack.Pop (2);  		break;  	}  	case ByteCode.Opcode.Dup: {  		_stack.Push (_stack.Peek ());  		break;  	}  	case ByteCode.Opcode.Call: {  		// pop arg count from stack  		ThreadState res = PushStackFrame (inst [0].GetInteger ());  		switch (res) {  		case ThreadState.Running: {  			break;  		}  		case ThreadState.Sys_Yield: {  			return ThreadState.Running;  		}  		case ThreadState.Exception: {  			_machine.SwitchThreadState (this' ThreadState.Killed);  			return ThreadState.Exception;  		}  		case ThreadState.Killed: {  			_machine.SwitchThreadState (this' ThreadState.Killed);  			break;  		}  		default: {  			break;  		}  		}  		break;  	}  	#region Push Operations  	case ByteCode.Opcode.PushNull: {  		Push (Variable.Null);  		break;  	}  	case ByteCode.Opcode.PushThis: {  		Push (This);  		break;  	}  	case ByteCode.Opcode.PushInt0:  	case ByteCode.Opcode.PushInt1:  	case ByteCode.Opcode.PushInt:  	case ByteCode.Opcode.PushFp:  	case ByteCode.Opcode.PushStr:  	case ByteCode.Opcode.PushFn: {  		Push (inst [0]);  		break;  	}  	case ByteCode.Opcode.PushTbl: {  		Push (new TableObject ());  		break;  	}  	#endregion  	case ByteCode.Opcode.Ret:// Ret pushes a null  	 {  		Push (Variable.Null);  		ThreadState res = PopStackFrame ();  		switch (res) {  		case ThreadState.Exception:  		case ThreadState.Killed: {  			_machine.SwitchThreadState (this' res);  			return res;  		}  		default: {  			break;  		}  		}  		break;  	}  	case ByteCode.Opcode.Retv: {  		ThreadState res = PopStackFrame ();  		if (res == ThreadState.Killed) {  			return res;  		}  		break;  	}  	case ByteCode.Opcode.SetGlobal: {  		Variable v1 = inst [0];  		if (v1.Type != VariableType.String) {  			throw new Exception ("String required");  		}  		Variable v2 = _stack.Pop ();  		_machine.Globals [v1] = v2;  		break;  	}  	case ByteCode.Opcode.GetGlobal: {  		Variable v1 = inst [0];  		// global name  		// TODO: Check for string  		if (v1.Type != VariableType.String) {  			throw new Exception ("String required");  		}  		var global = _machine.Globals [v1];  		Push (global);  		break;  	}  	case ByteCode.Opcode.SetLocal: {  		int offset = inst [0].GetInteger ();  		_stack.PokeBase (offset' _stack.Pop ());  		break;  	}  	case ByteCode.Opcode.GetLocal: {  		int offset = inst [0].GetInteger ();  		Push (_stack.PeekBase (offset));  		break;  	}  	#region Operators  	case ByteCode.Opcode.OpEq:  	case ByteCode.Opcode.OpNeq:  	case ByteCode.Opcode.OpLt:  	case ByteCode.Opcode.OpLte:  	case ByteCode.Opcode.OpGt:  	case ByteCode.Opcode.OpGte:  	case ByteCode.Opcode.OpRem:  	case ByteCode.Opcode.OpAdd:  	case ByteCode.Opcode.OpSub:  	case ByteCode.Opcode.OpMul:  	case ByteCode.Opcode.OpDiv: {  		Operator o = Operator._MAX;  		switch (inst.OpCode) {  		#region fold  		case ByteCode.Opcode.OpAdd: {  			o = Operator.Add;  			break;  		}  		case ByteCode.Opcode.OpSub: {  			o = Operator.Sub;  			break;  		}  		case ByteCode.Opcode.OpMul: {  			o = Operator.Mul;  			break;  		}  		case ByteCode.Opcode.OpDiv: {  			o = Operator.Div;  			break;  		}  		case ByteCode.Opcode.GetInd: {  			o = Operator.GetInd;  			break;  		}  		case ByteCode.Opcode.OpEq: {  			o = Operator.Eq;  			break;  		}  		case ByteCode.Opcode.OpNeq: {  			o = Operator.Neq;  			break;  		}  		case ByteCode.Opcode.OpLt: {  			o = Operator.Lt;  			break;  		}  		case ByteCode.Opcode.OpLte: {  			o = Operator.Lte;  			break;  		}  		case ByteCode.Opcode.OpGt: {  			o = Operator.Gt;  			break;  		}  		case ByteCode.Opcode.OpGte: {  			o = Operator.Gte;  			break;  		}  		case ByteCode.Opcode.OpRem: {  			o = Operator.Rem;  			break;  		}  		#endregion  		}  		if (o == Operator._MAX) {  			throw new NotImplementedException ("Operator not mapped or implemented");  		}  		var t1 = _stack.Peek (-1).TypeCode;  		var t2 = _stack.Peek (-2).TypeCode;  		if (t2 > t1) {  			t1 = t2;  		}  		OperatorCallback op = Machine.GetTypeOperator (t1' o);  		if (op != null) {  			var operand = _stack.StackPointer--;  			_stack.PokeAbs (operand - 2' op (this' _stack.PeekAbs (operand - 2)' _stack.PeekAbs (operand - 1)' _stack.PeekAbs (operand)));  		}  		else {  			throw new Exception ("Operator not defined");  		}  		break;  	}  	case ByteCode.Opcode.GetInd: {  		var type = _stack.Peek (-2).TypeCode;  		var op = Machine.GetTypeOperator (type' Operator.GetInd);  		if (op != null) {  			var operand = _stack.StackPointer--;  			_stack.PokeAbs (operand - 2' op (this' _stack.PeekAbs (operand - 2)' _stack.PeekAbs (operand - 1)' _stack.PeekAbs (operand)));  		}  		else {  			throw new Exception ("Operator not defined");  		}  		break;  	}  	case ByteCode.Opcode.SetInd: {  		var topMin3 = _stack.Peek (-3);  		OperatorCallback op = Machine.GetTypeOperator (topMin3.TypeCode' Operator.SetInd);  		if (op != null) {  			_stack.Poke (-3' op (this' topMin3' _stack.Peek (-2)' _stack.Peek (-1)));  			_stack.StackPointer -= 3;  		}  		else {  			throw new Exception ("Operator not defined");  		}  		break;  	}  	case ByteCode.Opcode.ForEach: {  		var topMin2 = _stack.Peek (-2);  		TypeIteratorCallback itr = Machine.GetTypeIterator (topMin2.TypeCode);  		if (itr == null) {  			_machine.Log.LogEntry ("Undefined iterator for type");  			return ThreadState.Exception;  		}  		var iteratorPos = _stack.Peek (-1).GetInteger ();  		var obj = _stack.Peek (-2).GetReference ();  		iteratorPos = itr (this' obj' iteratorPos' _stack.PeekBase (inst [1].GetInteger ())' _stack.PeekBase (inst [0].GetInteger ()));  		if (iteratorPos != -1) {  			//_Stack2[_Base + Inst[1].GetInteger()] = Key;  			//_Stack2[_Base + Inst[0].GetInteger()] = Item;  			_stack.Poke (Variable.Zero);  		}  		else {  			_stack.Poke (Variable.Zero);  		}  		_stack.Poke (-1' iteratorPos);  		++_stack.StackPointer;  		break;  	}  	#region Dot Operators  	case ByteCode.Opcode.GetDot: {  		var v1 = _stack.Peek (-1);  		OperatorCallback op = Machine.GetTypeOperator (v1.TypeCode' Operator.GetDot);  		_stack.Poke (inst [0]);  		if (op != null) {  			_stack.Poke (-1' op (this' v1' _stack.Peek ()' _stack.Peek ()));  		}  		else {  			throw new Exception ("Operator not defined");  		}  		break;  	}  	case ByteCode.Opcode.SetDot: {  		var v1 = _stack.Peek (-2);  		OperatorCallback op = Machine.GetTypeOperator (v1.TypeCode' Operator.SetDot);  		_stack.Poke (inst [0]);  		if (op != null) {  			_stack.Poke (-2' op (this' _stack.Peek (-2)' _stack.Peek (-1)' _stack.Peek ()));  			_stack.StackPointer -= 2;  		}  		else {  			throw new Exception ("Operator not defined");  		}  		break;  	}  	#endregion  	#endregion  	#region Branch  	case ByteCode.Opcode.Brz: {  		var v = _stack.Pop ();  		if (v.IsZero) {  			var newIp = inst [0].GetInteger ();  			if (newIp >= _instructionList.Count) {  				throw new Exception ("BRZ: Corrupt IP");  			}  			_instructionPtr = newIp;  		}  		break;  	}  	case ByteCode.Opcode.Brnz: {  		var v = _stack.Pop ();  		if (!v.IsZero) {  			var newIp = inst [0].GetInteger ();  			if (newIp >= _instructionList.Count) {  				throw new Exception ("BRZ: Corrupt IP");  			}  			_instructionPtr = newIp;  		}  		break;  	}  	case ByteCode.Opcode.Brzk: {  		var v = _stack.Peek (-1);  		if (v.IsZero) {  			var newIp = inst [0].GetInteger ();  			if (newIp >= _instructionList.Count) {  				throw new Exception ("BRZ: Corrupt IP");  			}  			_instructionPtr = newIp;  		}  		break;  	}  	case ByteCode.Opcode.Brnzk: {  		var v = _stack.Peek (-1);  		if (!v.IsZero) {  			var newIp = inst [0].GetInteger ();  			if (newIp >= _instructionList.Count) {  				throw new Exception ("BRNZK: Corrupt IP");  			}  			_instructionPtr = newIp;  		}  		break;  	}  	case ByteCode.Opcode.Bra: {  		var newIp = inst [0].GetInteger ();  		if (newIp >= _instructionList.Count) {  			throw new Exception ("BRA: Corrupt IP");  		}  		_instructionPtr = newIp;  		break;  	}  	#endregion  	default: {  		throw new Exception ("Unknown instr");  	}  	}  	// end switch instruction  }  
Magic Number,GreenBeanScript,Thread,C:\repos\evolutional_greenbeanscript\GreenBeanScript\VirtualMachine\Thread.cs,Execute,The following statement contains a magic number: for (; ;) {  	if (_instructionPtr >= _instructionList.Count)  		break;  	var inst = _instructionList [_instructionPtr++];  	switch (inst.OpCode) {  	case ByteCode.Opcode.Pop: {  		_stack.Pop ();  		break;  	}  	case ByteCode.Opcode.Pop2: {  		_stack.Pop (2);  		break;  	}  	case ByteCode.Opcode.Dup: {  		_stack.Push (_stack.Peek ());  		break;  	}  	case ByteCode.Opcode.Call: {  		// pop arg count from stack  		ThreadState res = PushStackFrame (inst [0].GetInteger ());  		switch (res) {  		case ThreadState.Running: {  			break;  		}  		case ThreadState.Sys_Yield: {  			return ThreadState.Running;  		}  		case ThreadState.Exception: {  			_machine.SwitchThreadState (this' ThreadState.Killed);  			return ThreadState.Exception;  		}  		case ThreadState.Killed: {  			_machine.SwitchThreadState (this' ThreadState.Killed);  			break;  		}  		default: {  			break;  		}  		}  		break;  	}  	#region Push Operations  	case ByteCode.Opcode.PushNull: {  		Push (Variable.Null);  		break;  	}  	case ByteCode.Opcode.PushThis: {  		Push (This);  		break;  	}  	case ByteCode.Opcode.PushInt0:  	case ByteCode.Opcode.PushInt1:  	case ByteCode.Opcode.PushInt:  	case ByteCode.Opcode.PushFp:  	case ByteCode.Opcode.PushStr:  	case ByteCode.Opcode.PushFn: {  		Push (inst [0]);  		break;  	}  	case ByteCode.Opcode.PushTbl: {  		Push (new TableObject ());  		break;  	}  	#endregion  	case ByteCode.Opcode.Ret:// Ret pushes a null  	 {  		Push (Variable.Null);  		ThreadState res = PopStackFrame ();  		switch (res) {  		case ThreadState.Exception:  		case ThreadState.Killed: {  			_machine.SwitchThreadState (this' res);  			return res;  		}  		default: {  			break;  		}  		}  		break;  	}  	case ByteCode.Opcode.Retv: {  		ThreadState res = PopStackFrame ();  		if (res == ThreadState.Killed) {  			return res;  		}  		break;  	}  	case ByteCode.Opcode.SetGlobal: {  		Variable v1 = inst [0];  		if (v1.Type != VariableType.String) {  			throw new Exception ("String required");  		}  		Variable v2 = _stack.Pop ();  		_machine.Globals [v1] = v2;  		break;  	}  	case ByteCode.Opcode.GetGlobal: {  		Variable v1 = inst [0];  		// global name  		// TODO: Check for string  		if (v1.Type != VariableType.String) {  			throw new Exception ("String required");  		}  		var global = _machine.Globals [v1];  		Push (global);  		break;  	}  	case ByteCode.Opcode.SetLocal: {  		int offset = inst [0].GetInteger ();  		_stack.PokeBase (offset' _stack.Pop ());  		break;  	}  	case ByteCode.Opcode.GetLocal: {  		int offset = inst [0].GetInteger ();  		Push (_stack.PeekBase (offset));  		break;  	}  	#region Operators  	case ByteCode.Opcode.OpEq:  	case ByteCode.Opcode.OpNeq:  	case ByteCode.Opcode.OpLt:  	case ByteCode.Opcode.OpLte:  	case ByteCode.Opcode.OpGt:  	case ByteCode.Opcode.OpGte:  	case ByteCode.Opcode.OpRem:  	case ByteCode.Opcode.OpAdd:  	case ByteCode.Opcode.OpSub:  	case ByteCode.Opcode.OpMul:  	case ByteCode.Opcode.OpDiv: {  		Operator o = Operator._MAX;  		switch (inst.OpCode) {  		#region fold  		case ByteCode.Opcode.OpAdd: {  			o = Operator.Add;  			break;  		}  		case ByteCode.Opcode.OpSub: {  			o = Operator.Sub;  			break;  		}  		case ByteCode.Opcode.OpMul: {  			o = Operator.Mul;  			break;  		}  		case ByteCode.Opcode.OpDiv: {  			o = Operator.Div;  			break;  		}  		case ByteCode.Opcode.GetInd: {  			o = Operator.GetInd;  			break;  		}  		case ByteCode.Opcode.OpEq: {  			o = Operator.Eq;  			break;  		}  		case ByteCode.Opcode.OpNeq: {  			o = Operator.Neq;  			break;  		}  		case ByteCode.Opcode.OpLt: {  			o = Operator.Lt;  			break;  		}  		case ByteCode.Opcode.OpLte: {  			o = Operator.Lte;  			break;  		}  		case ByteCode.Opcode.OpGt: {  			o = Operator.Gt;  			break;  		}  		case ByteCode.Opcode.OpGte: {  			o = Operator.Gte;  			break;  		}  		case ByteCode.Opcode.OpRem: {  			o = Operator.Rem;  			break;  		}  		#endregion  		}  		if (o == Operator._MAX) {  			throw new NotImplementedException ("Operator not mapped or implemented");  		}  		var t1 = _stack.Peek (-1).TypeCode;  		var t2 = _stack.Peek (-2).TypeCode;  		if (t2 > t1) {  			t1 = t2;  		}  		OperatorCallback op = Machine.GetTypeOperator (t1' o);  		if (op != null) {  			var operand = _stack.StackPointer--;  			_stack.PokeAbs (operand - 2' op (this' _stack.PeekAbs (operand - 2)' _stack.PeekAbs (operand - 1)' _stack.PeekAbs (operand)));  		}  		else {  			throw new Exception ("Operator not defined");  		}  		break;  	}  	case ByteCode.Opcode.GetInd: {  		var type = _stack.Peek (-2).TypeCode;  		var op = Machine.GetTypeOperator (type' Operator.GetInd);  		if (op != null) {  			var operand = _stack.StackPointer--;  			_stack.PokeAbs (operand - 2' op (this' _stack.PeekAbs (operand - 2)' _stack.PeekAbs (operand - 1)' _stack.PeekAbs (operand)));  		}  		else {  			throw new Exception ("Operator not defined");  		}  		break;  	}  	case ByteCode.Opcode.SetInd: {  		var topMin3 = _stack.Peek (-3);  		OperatorCallback op = Machine.GetTypeOperator (topMin3.TypeCode' Operator.SetInd);  		if (op != null) {  			_stack.Poke (-3' op (this' topMin3' _stack.Peek (-2)' _stack.Peek (-1)));  			_stack.StackPointer -= 3;  		}  		else {  			throw new Exception ("Operator not defined");  		}  		break;  	}  	case ByteCode.Opcode.ForEach: {  		var topMin2 = _stack.Peek (-2);  		TypeIteratorCallback itr = Machine.GetTypeIterator (topMin2.TypeCode);  		if (itr == null) {  			_machine.Log.LogEntry ("Undefined iterator for type");  			return ThreadState.Exception;  		}  		var iteratorPos = _stack.Peek (-1).GetInteger ();  		var obj = _stack.Peek (-2).GetReference ();  		iteratorPos = itr (this' obj' iteratorPos' _stack.PeekBase (inst [1].GetInteger ())' _stack.PeekBase (inst [0].GetInteger ()));  		if (iteratorPos != -1) {  			//_Stack2[_Base + Inst[1].GetInteger()] = Key;  			//_Stack2[_Base + Inst[0].GetInteger()] = Item;  			_stack.Poke (Variable.Zero);  		}  		else {  			_stack.Poke (Variable.Zero);  		}  		_stack.Poke (-1' iteratorPos);  		++_stack.StackPointer;  		break;  	}  	#region Dot Operators  	case ByteCode.Opcode.GetDot: {  		var v1 = _stack.Peek (-1);  		OperatorCallback op = Machine.GetTypeOperator (v1.TypeCode' Operator.GetDot);  		_stack.Poke (inst [0]);  		if (op != null) {  			_stack.Poke (-1' op (this' v1' _stack.Peek ()' _stack.Peek ()));  		}  		else {  			throw new Exception ("Operator not defined");  		}  		break;  	}  	case ByteCode.Opcode.SetDot: {  		var v1 = _stack.Peek (-2);  		OperatorCallback op = Machine.GetTypeOperator (v1.TypeCode' Operator.SetDot);  		_stack.Poke (inst [0]);  		if (op != null) {  			_stack.Poke (-2' op (this' _stack.Peek (-2)' _stack.Peek (-1)' _stack.Peek ()));  			_stack.StackPointer -= 2;  		}  		else {  			throw new Exception ("Operator not defined");  		}  		break;  	}  	#endregion  	#endregion  	#region Branch  	case ByteCode.Opcode.Brz: {  		var v = _stack.Pop ();  		if (v.IsZero) {  			var newIp = inst [0].GetInteger ();  			if (newIp >= _instructionList.Count) {  				throw new Exception ("BRZ: Corrupt IP");  			}  			_instructionPtr = newIp;  		}  		break;  	}  	case ByteCode.Opcode.Brnz: {  		var v = _stack.Pop ();  		if (!v.IsZero) {  			var newIp = inst [0].GetInteger ();  			if (newIp >= _instructionList.Count) {  				throw new Exception ("BRZ: Corrupt IP");  			}  			_instructionPtr = newIp;  		}  		break;  	}  	case ByteCode.Opcode.Brzk: {  		var v = _stack.Peek (-1);  		if (v.IsZero) {  			var newIp = inst [0].GetInteger ();  			if (newIp >= _instructionList.Count) {  				throw new Exception ("BRZ: Corrupt IP");  			}  			_instructionPtr = newIp;  		}  		break;  	}  	case ByteCode.Opcode.Brnzk: {  		var v = _stack.Peek (-1);  		if (!v.IsZero) {  			var newIp = inst [0].GetInteger ();  			if (newIp >= _instructionList.Count) {  				throw new Exception ("BRNZK: Corrupt IP");  			}  			_instructionPtr = newIp;  		}  		break;  	}  	case ByteCode.Opcode.Bra: {  		var newIp = inst [0].GetInteger ();  		if (newIp >= _instructionList.Count) {  			throw new Exception ("BRA: Corrupt IP");  		}  		_instructionPtr = newIp;  		break;  	}  	#endregion  	default: {  		throw new Exception ("Unknown instr");  	}  	}  	// end switch instruction  }  
Magic Number,GreenBeanScript,Thread,C:\repos\evolutional_greenbeanscript\GreenBeanScript\VirtualMachine\Thread.cs,Execute,The following statement contains a magic number: for (; ;) {  	if (_instructionPtr >= _instructionList.Count)  		break;  	var inst = _instructionList [_instructionPtr++];  	switch (inst.OpCode) {  	case ByteCode.Opcode.Pop: {  		_stack.Pop ();  		break;  	}  	case ByteCode.Opcode.Pop2: {  		_stack.Pop (2);  		break;  	}  	case ByteCode.Opcode.Dup: {  		_stack.Push (_stack.Peek ());  		break;  	}  	case ByteCode.Opcode.Call: {  		// pop arg count from stack  		ThreadState res = PushStackFrame (inst [0].GetInteger ());  		switch (res) {  		case ThreadState.Running: {  			break;  		}  		case ThreadState.Sys_Yield: {  			return ThreadState.Running;  		}  		case ThreadState.Exception: {  			_machine.SwitchThreadState (this' ThreadState.Killed);  			return ThreadState.Exception;  		}  		case ThreadState.Killed: {  			_machine.SwitchThreadState (this' ThreadState.Killed);  			break;  		}  		default: {  			break;  		}  		}  		break;  	}  	#region Push Operations  	case ByteCode.Opcode.PushNull: {  		Push (Variable.Null);  		break;  	}  	case ByteCode.Opcode.PushThis: {  		Push (This);  		break;  	}  	case ByteCode.Opcode.PushInt0:  	case ByteCode.Opcode.PushInt1:  	case ByteCode.Opcode.PushInt:  	case ByteCode.Opcode.PushFp:  	case ByteCode.Opcode.PushStr:  	case ByteCode.Opcode.PushFn: {  		Push (inst [0]);  		break;  	}  	case ByteCode.Opcode.PushTbl: {  		Push (new TableObject ());  		break;  	}  	#endregion  	case ByteCode.Opcode.Ret:// Ret pushes a null  	 {  		Push (Variable.Null);  		ThreadState res = PopStackFrame ();  		switch (res) {  		case ThreadState.Exception:  		case ThreadState.Killed: {  			_machine.SwitchThreadState (this' res);  			return res;  		}  		default: {  			break;  		}  		}  		break;  	}  	case ByteCode.Opcode.Retv: {  		ThreadState res = PopStackFrame ();  		if (res == ThreadState.Killed) {  			return res;  		}  		break;  	}  	case ByteCode.Opcode.SetGlobal: {  		Variable v1 = inst [0];  		if (v1.Type != VariableType.String) {  			throw new Exception ("String required");  		}  		Variable v2 = _stack.Pop ();  		_machine.Globals [v1] = v2;  		break;  	}  	case ByteCode.Opcode.GetGlobal: {  		Variable v1 = inst [0];  		// global name  		// TODO: Check for string  		if (v1.Type != VariableType.String) {  			throw new Exception ("String required");  		}  		var global = _machine.Globals [v1];  		Push (global);  		break;  	}  	case ByteCode.Opcode.SetLocal: {  		int offset = inst [0].GetInteger ();  		_stack.PokeBase (offset' _stack.Pop ());  		break;  	}  	case ByteCode.Opcode.GetLocal: {  		int offset = inst [0].GetInteger ();  		Push (_stack.PeekBase (offset));  		break;  	}  	#region Operators  	case ByteCode.Opcode.OpEq:  	case ByteCode.Opcode.OpNeq:  	case ByteCode.Opcode.OpLt:  	case ByteCode.Opcode.OpLte:  	case ByteCode.Opcode.OpGt:  	case ByteCode.Opcode.OpGte:  	case ByteCode.Opcode.OpRem:  	case ByteCode.Opcode.OpAdd:  	case ByteCode.Opcode.OpSub:  	case ByteCode.Opcode.OpMul:  	case ByteCode.Opcode.OpDiv: {  		Operator o = Operator._MAX;  		switch (inst.OpCode) {  		#region fold  		case ByteCode.Opcode.OpAdd: {  			o = Operator.Add;  			break;  		}  		case ByteCode.Opcode.OpSub: {  			o = Operator.Sub;  			break;  		}  		case ByteCode.Opcode.OpMul: {  			o = Operator.Mul;  			break;  		}  		case ByteCode.Opcode.OpDiv: {  			o = Operator.Div;  			break;  		}  		case ByteCode.Opcode.GetInd: {  			o = Operator.GetInd;  			break;  		}  		case ByteCode.Opcode.OpEq: {  			o = Operator.Eq;  			break;  		}  		case ByteCode.Opcode.OpNeq: {  			o = Operator.Neq;  			break;  		}  		case ByteCode.Opcode.OpLt: {  			o = Operator.Lt;  			break;  		}  		case ByteCode.Opcode.OpLte: {  			o = Operator.Lte;  			break;  		}  		case ByteCode.Opcode.OpGt: {  			o = Operator.Gt;  			break;  		}  		case ByteCode.Opcode.OpGte: {  			o = Operator.Gte;  			break;  		}  		case ByteCode.Opcode.OpRem: {  			o = Operator.Rem;  			break;  		}  		#endregion  		}  		if (o == Operator._MAX) {  			throw new NotImplementedException ("Operator not mapped or implemented");  		}  		var t1 = _stack.Peek (-1).TypeCode;  		var t2 = _stack.Peek (-2).TypeCode;  		if (t2 > t1) {  			t1 = t2;  		}  		OperatorCallback op = Machine.GetTypeOperator (t1' o);  		if (op != null) {  			var operand = _stack.StackPointer--;  			_stack.PokeAbs (operand - 2' op (this' _stack.PeekAbs (operand - 2)' _stack.PeekAbs (operand - 1)' _stack.PeekAbs (operand)));  		}  		else {  			throw new Exception ("Operator not defined");  		}  		break;  	}  	case ByteCode.Opcode.GetInd: {  		var type = _stack.Peek (-2).TypeCode;  		var op = Machine.GetTypeOperator (type' Operator.GetInd);  		if (op != null) {  			var operand = _stack.StackPointer--;  			_stack.PokeAbs (operand - 2' op (this' _stack.PeekAbs (operand - 2)' _stack.PeekAbs (operand - 1)' _stack.PeekAbs (operand)));  		}  		else {  			throw new Exception ("Operator not defined");  		}  		break;  	}  	case ByteCode.Opcode.SetInd: {  		var topMin3 = _stack.Peek (-3);  		OperatorCallback op = Machine.GetTypeOperator (topMin3.TypeCode' Operator.SetInd);  		if (op != null) {  			_stack.Poke (-3' op (this' topMin3' _stack.Peek (-2)' _stack.Peek (-1)));  			_stack.StackPointer -= 3;  		}  		else {  			throw new Exception ("Operator not defined");  		}  		break;  	}  	case ByteCode.Opcode.ForEach: {  		var topMin2 = _stack.Peek (-2);  		TypeIteratorCallback itr = Machine.GetTypeIterator (topMin2.TypeCode);  		if (itr == null) {  			_machine.Log.LogEntry ("Undefined iterator for type");  			return ThreadState.Exception;  		}  		var iteratorPos = _stack.Peek (-1).GetInteger ();  		var obj = _stack.Peek (-2).GetReference ();  		iteratorPos = itr (this' obj' iteratorPos' _stack.PeekBase (inst [1].GetInteger ())' _stack.PeekBase (inst [0].GetInteger ()));  		if (iteratorPos != -1) {  			//_Stack2[_Base + Inst[1].GetInteger()] = Key;  			//_Stack2[_Base + Inst[0].GetInteger()] = Item;  			_stack.Poke (Variable.Zero);  		}  		else {  			_stack.Poke (Variable.Zero);  		}  		_stack.Poke (-1' iteratorPos);  		++_stack.StackPointer;  		break;  	}  	#region Dot Operators  	case ByteCode.Opcode.GetDot: {  		var v1 = _stack.Peek (-1);  		OperatorCallback op = Machine.GetTypeOperator (v1.TypeCode' Operator.GetDot);  		_stack.Poke (inst [0]);  		if (op != null) {  			_stack.Poke (-1' op (this' v1' _stack.Peek ()' _stack.Peek ()));  		}  		else {  			throw new Exception ("Operator not defined");  		}  		break;  	}  	case ByteCode.Opcode.SetDot: {  		var v1 = _stack.Peek (-2);  		OperatorCallback op = Machine.GetTypeOperator (v1.TypeCode' Operator.SetDot);  		_stack.Poke (inst [0]);  		if (op != null) {  			_stack.Poke (-2' op (this' _stack.Peek (-2)' _stack.Peek (-1)' _stack.Peek ()));  			_stack.StackPointer -= 2;  		}  		else {  			throw new Exception ("Operator not defined");  		}  		break;  	}  	#endregion  	#endregion  	#region Branch  	case ByteCode.Opcode.Brz: {  		var v = _stack.Pop ();  		if (v.IsZero) {  			var newIp = inst [0].GetInteger ();  			if (newIp >= _instructionList.Count) {  				throw new Exception ("BRZ: Corrupt IP");  			}  			_instructionPtr = newIp;  		}  		break;  	}  	case ByteCode.Opcode.Brnz: {  		var v = _stack.Pop ();  		if (!v.IsZero) {  			var newIp = inst [0].GetInteger ();  			if (newIp >= _instructionList.Count) {  				throw new Exception ("BRZ: Corrupt IP");  			}  			_instructionPtr = newIp;  		}  		break;  	}  	case ByteCode.Opcode.Brzk: {  		var v = _stack.Peek (-1);  		if (v.IsZero) {  			var newIp = inst [0].GetInteger ();  			if (newIp >= _instructionList.Count) {  				throw new Exception ("BRZ: Corrupt IP");  			}  			_instructionPtr = newIp;  		}  		break;  	}  	case ByteCode.Opcode.Brnzk: {  		var v = _stack.Peek (-1);  		if (!v.IsZero) {  			var newIp = inst [0].GetInteger ();  			if (newIp >= _instructionList.Count) {  				throw new Exception ("BRNZK: Corrupt IP");  			}  			_instructionPtr = newIp;  		}  		break;  	}  	case ByteCode.Opcode.Bra: {  		var newIp = inst [0].GetInteger ();  		if (newIp >= _instructionList.Count) {  			throw new Exception ("BRA: Corrupt IP");  		}  		_instructionPtr = newIp;  		break;  	}  	#endregion  	default: {  		throw new Exception ("Unknown instr");  	}  	}  	// end switch instruction  }  
Magic Number,GreenBeanScript,Thread,C:\repos\evolutional_greenbeanscript\GreenBeanScript\VirtualMachine\Thread.cs,Execute,The following statement contains a magic number: for (; ;) {  	if (_instructionPtr >= _instructionList.Count)  		break;  	var inst = _instructionList [_instructionPtr++];  	switch (inst.OpCode) {  	case ByteCode.Opcode.Pop: {  		_stack.Pop ();  		break;  	}  	case ByteCode.Opcode.Pop2: {  		_stack.Pop (2);  		break;  	}  	case ByteCode.Opcode.Dup: {  		_stack.Push (_stack.Peek ());  		break;  	}  	case ByteCode.Opcode.Call: {  		// pop arg count from stack  		ThreadState res = PushStackFrame (inst [0].GetInteger ());  		switch (res) {  		case ThreadState.Running: {  			break;  		}  		case ThreadState.Sys_Yield: {  			return ThreadState.Running;  		}  		case ThreadState.Exception: {  			_machine.SwitchThreadState (this' ThreadState.Killed);  			return ThreadState.Exception;  		}  		case ThreadState.Killed: {  			_machine.SwitchThreadState (this' ThreadState.Killed);  			break;  		}  		default: {  			break;  		}  		}  		break;  	}  	#region Push Operations  	case ByteCode.Opcode.PushNull: {  		Push (Variable.Null);  		break;  	}  	case ByteCode.Opcode.PushThis: {  		Push (This);  		break;  	}  	case ByteCode.Opcode.PushInt0:  	case ByteCode.Opcode.PushInt1:  	case ByteCode.Opcode.PushInt:  	case ByteCode.Opcode.PushFp:  	case ByteCode.Opcode.PushStr:  	case ByteCode.Opcode.PushFn: {  		Push (inst [0]);  		break;  	}  	case ByteCode.Opcode.PushTbl: {  		Push (new TableObject ());  		break;  	}  	#endregion  	case ByteCode.Opcode.Ret:// Ret pushes a null  	 {  		Push (Variable.Null);  		ThreadState res = PopStackFrame ();  		switch (res) {  		case ThreadState.Exception:  		case ThreadState.Killed: {  			_machine.SwitchThreadState (this' res);  			return res;  		}  		default: {  			break;  		}  		}  		break;  	}  	case ByteCode.Opcode.Retv: {  		ThreadState res = PopStackFrame ();  		if (res == ThreadState.Killed) {  			return res;  		}  		break;  	}  	case ByteCode.Opcode.SetGlobal: {  		Variable v1 = inst [0];  		if (v1.Type != VariableType.String) {  			throw new Exception ("String required");  		}  		Variable v2 = _stack.Pop ();  		_machine.Globals [v1] = v2;  		break;  	}  	case ByteCode.Opcode.GetGlobal: {  		Variable v1 = inst [0];  		// global name  		// TODO: Check for string  		if (v1.Type != VariableType.String) {  			throw new Exception ("String required");  		}  		var global = _machine.Globals [v1];  		Push (global);  		break;  	}  	case ByteCode.Opcode.SetLocal: {  		int offset = inst [0].GetInteger ();  		_stack.PokeBase (offset' _stack.Pop ());  		break;  	}  	case ByteCode.Opcode.GetLocal: {  		int offset = inst [0].GetInteger ();  		Push (_stack.PeekBase (offset));  		break;  	}  	#region Operators  	case ByteCode.Opcode.OpEq:  	case ByteCode.Opcode.OpNeq:  	case ByteCode.Opcode.OpLt:  	case ByteCode.Opcode.OpLte:  	case ByteCode.Opcode.OpGt:  	case ByteCode.Opcode.OpGte:  	case ByteCode.Opcode.OpRem:  	case ByteCode.Opcode.OpAdd:  	case ByteCode.Opcode.OpSub:  	case ByteCode.Opcode.OpMul:  	case ByteCode.Opcode.OpDiv: {  		Operator o = Operator._MAX;  		switch (inst.OpCode) {  		#region fold  		case ByteCode.Opcode.OpAdd: {  			o = Operator.Add;  			break;  		}  		case ByteCode.Opcode.OpSub: {  			o = Operator.Sub;  			break;  		}  		case ByteCode.Opcode.OpMul: {  			o = Operator.Mul;  			break;  		}  		case ByteCode.Opcode.OpDiv: {  			o = Operator.Div;  			break;  		}  		case ByteCode.Opcode.GetInd: {  			o = Operator.GetInd;  			break;  		}  		case ByteCode.Opcode.OpEq: {  			o = Operator.Eq;  			break;  		}  		case ByteCode.Opcode.OpNeq: {  			o = Operator.Neq;  			break;  		}  		case ByteCode.Opcode.OpLt: {  			o = Operator.Lt;  			break;  		}  		case ByteCode.Opcode.OpLte: {  			o = Operator.Lte;  			break;  		}  		case ByteCode.Opcode.OpGt: {  			o = Operator.Gt;  			break;  		}  		case ByteCode.Opcode.OpGte: {  			o = Operator.Gte;  			break;  		}  		case ByteCode.Opcode.OpRem: {  			o = Operator.Rem;  			break;  		}  		#endregion  		}  		if (o == Operator._MAX) {  			throw new NotImplementedException ("Operator not mapped or implemented");  		}  		var t1 = _stack.Peek (-1).TypeCode;  		var t2 = _stack.Peek (-2).TypeCode;  		if (t2 > t1) {  			t1 = t2;  		}  		OperatorCallback op = Machine.GetTypeOperator (t1' o);  		if (op != null) {  			var operand = _stack.StackPointer--;  			_stack.PokeAbs (operand - 2' op (this' _stack.PeekAbs (operand - 2)' _stack.PeekAbs (operand - 1)' _stack.PeekAbs (operand)));  		}  		else {  			throw new Exception ("Operator not defined");  		}  		break;  	}  	case ByteCode.Opcode.GetInd: {  		var type = _stack.Peek (-2).TypeCode;  		var op = Machine.GetTypeOperator (type' Operator.GetInd);  		if (op != null) {  			var operand = _stack.StackPointer--;  			_stack.PokeAbs (operand - 2' op (this' _stack.PeekAbs (operand - 2)' _stack.PeekAbs (operand - 1)' _stack.PeekAbs (operand)));  		}  		else {  			throw new Exception ("Operator not defined");  		}  		break;  	}  	case ByteCode.Opcode.SetInd: {  		var topMin3 = _stack.Peek (-3);  		OperatorCallback op = Machine.GetTypeOperator (topMin3.TypeCode' Operator.SetInd);  		if (op != null) {  			_stack.Poke (-3' op (this' topMin3' _stack.Peek (-2)' _stack.Peek (-1)));  			_stack.StackPointer -= 3;  		}  		else {  			throw new Exception ("Operator not defined");  		}  		break;  	}  	case ByteCode.Opcode.ForEach: {  		var topMin2 = _stack.Peek (-2);  		TypeIteratorCallback itr = Machine.GetTypeIterator (topMin2.TypeCode);  		if (itr == null) {  			_machine.Log.LogEntry ("Undefined iterator for type");  			return ThreadState.Exception;  		}  		var iteratorPos = _stack.Peek (-1).GetInteger ();  		var obj = _stack.Peek (-2).GetReference ();  		iteratorPos = itr (this' obj' iteratorPos' _stack.PeekBase (inst [1].GetInteger ())' _stack.PeekBase (inst [0].GetInteger ()));  		if (iteratorPos != -1) {  			//_Stack2[_Base + Inst[1].GetInteger()] = Key;  			//_Stack2[_Base + Inst[0].GetInteger()] = Item;  			_stack.Poke (Variable.Zero);  		}  		else {  			_stack.Poke (Variable.Zero);  		}  		_stack.Poke (-1' iteratorPos);  		++_stack.StackPointer;  		break;  	}  	#region Dot Operators  	case ByteCode.Opcode.GetDot: {  		var v1 = _stack.Peek (-1);  		OperatorCallback op = Machine.GetTypeOperator (v1.TypeCode' Operator.GetDot);  		_stack.Poke (inst [0]);  		if (op != null) {  			_stack.Poke (-1' op (this' v1' _stack.Peek ()' _stack.Peek ()));  		}  		else {  			throw new Exception ("Operator not defined");  		}  		break;  	}  	case ByteCode.Opcode.SetDot: {  		var v1 = _stack.Peek (-2);  		OperatorCallback op = Machine.GetTypeOperator (v1.TypeCode' Operator.SetDot);  		_stack.Poke (inst [0]);  		if (op != null) {  			_stack.Poke (-2' op (this' _stack.Peek (-2)' _stack.Peek (-1)' _stack.Peek ()));  			_stack.StackPointer -= 2;  		}  		else {  			throw new Exception ("Operator not defined");  		}  		break;  	}  	#endregion  	#endregion  	#region Branch  	case ByteCode.Opcode.Brz: {  		var v = _stack.Pop ();  		if (v.IsZero) {  			var newIp = inst [0].GetInteger ();  			if (newIp >= _instructionList.Count) {  				throw new Exception ("BRZ: Corrupt IP");  			}  			_instructionPtr = newIp;  		}  		break;  	}  	case ByteCode.Opcode.Brnz: {  		var v = _stack.Pop ();  		if (!v.IsZero) {  			var newIp = inst [0].GetInteger ();  			if (newIp >= _instructionList.Count) {  				throw new Exception ("BRZ: Corrupt IP");  			}  			_instructionPtr = newIp;  		}  		break;  	}  	case ByteCode.Opcode.Brzk: {  		var v = _stack.Peek (-1);  		if (v.IsZero) {  			var newIp = inst [0].GetInteger ();  			if (newIp >= _instructionList.Count) {  				throw new Exception ("BRZ: Corrupt IP");  			}  			_instructionPtr = newIp;  		}  		break;  	}  	case ByteCode.Opcode.Brnzk: {  		var v = _stack.Peek (-1);  		if (!v.IsZero) {  			var newIp = inst [0].GetInteger ();  			if (newIp >= _instructionList.Count) {  				throw new Exception ("BRNZK: Corrupt IP");  			}  			_instructionPtr = newIp;  		}  		break;  	}  	case ByteCode.Opcode.Bra: {  		var newIp = inst [0].GetInteger ();  		if (newIp >= _instructionList.Count) {  			throw new Exception ("BRA: Corrupt IP");  		}  		_instructionPtr = newIp;  		break;  	}  	#endregion  	default: {  		throw new Exception ("Unknown instr");  	}  	}  	// end switch instruction  }  
Magic Number,GreenBeanScript,Thread,C:\repos\evolutional_greenbeanscript\GreenBeanScript\VirtualMachine\Thread.cs,Execute,The following statement contains a magic number: for (; ;) {  	if (_instructionPtr >= _instructionList.Count)  		break;  	var inst = _instructionList [_instructionPtr++];  	switch (inst.OpCode) {  	case ByteCode.Opcode.Pop: {  		_stack.Pop ();  		break;  	}  	case ByteCode.Opcode.Pop2: {  		_stack.Pop (2);  		break;  	}  	case ByteCode.Opcode.Dup: {  		_stack.Push (_stack.Peek ());  		break;  	}  	case ByteCode.Opcode.Call: {  		// pop arg count from stack  		ThreadState res = PushStackFrame (inst [0].GetInteger ());  		switch (res) {  		case ThreadState.Running: {  			break;  		}  		case ThreadState.Sys_Yield: {  			return ThreadState.Running;  		}  		case ThreadState.Exception: {  			_machine.SwitchThreadState (this' ThreadState.Killed);  			return ThreadState.Exception;  		}  		case ThreadState.Killed: {  			_machine.SwitchThreadState (this' ThreadState.Killed);  			break;  		}  		default: {  			break;  		}  		}  		break;  	}  	#region Push Operations  	case ByteCode.Opcode.PushNull: {  		Push (Variable.Null);  		break;  	}  	case ByteCode.Opcode.PushThis: {  		Push (This);  		break;  	}  	case ByteCode.Opcode.PushInt0:  	case ByteCode.Opcode.PushInt1:  	case ByteCode.Opcode.PushInt:  	case ByteCode.Opcode.PushFp:  	case ByteCode.Opcode.PushStr:  	case ByteCode.Opcode.PushFn: {  		Push (inst [0]);  		break;  	}  	case ByteCode.Opcode.PushTbl: {  		Push (new TableObject ());  		break;  	}  	#endregion  	case ByteCode.Opcode.Ret:// Ret pushes a null  	 {  		Push (Variable.Null);  		ThreadState res = PopStackFrame ();  		switch (res) {  		case ThreadState.Exception:  		case ThreadState.Killed: {  			_machine.SwitchThreadState (this' res);  			return res;  		}  		default: {  			break;  		}  		}  		break;  	}  	case ByteCode.Opcode.Retv: {  		ThreadState res = PopStackFrame ();  		if (res == ThreadState.Killed) {  			return res;  		}  		break;  	}  	case ByteCode.Opcode.SetGlobal: {  		Variable v1 = inst [0];  		if (v1.Type != VariableType.String) {  			throw new Exception ("String required");  		}  		Variable v2 = _stack.Pop ();  		_machine.Globals [v1] = v2;  		break;  	}  	case ByteCode.Opcode.GetGlobal: {  		Variable v1 = inst [0];  		// global name  		// TODO: Check for string  		if (v1.Type != VariableType.String) {  			throw new Exception ("String required");  		}  		var global = _machine.Globals [v1];  		Push (global);  		break;  	}  	case ByteCode.Opcode.SetLocal: {  		int offset = inst [0].GetInteger ();  		_stack.PokeBase (offset' _stack.Pop ());  		break;  	}  	case ByteCode.Opcode.GetLocal: {  		int offset = inst [0].GetInteger ();  		Push (_stack.PeekBase (offset));  		break;  	}  	#region Operators  	case ByteCode.Opcode.OpEq:  	case ByteCode.Opcode.OpNeq:  	case ByteCode.Opcode.OpLt:  	case ByteCode.Opcode.OpLte:  	case ByteCode.Opcode.OpGt:  	case ByteCode.Opcode.OpGte:  	case ByteCode.Opcode.OpRem:  	case ByteCode.Opcode.OpAdd:  	case ByteCode.Opcode.OpSub:  	case ByteCode.Opcode.OpMul:  	case ByteCode.Opcode.OpDiv: {  		Operator o = Operator._MAX;  		switch (inst.OpCode) {  		#region fold  		case ByteCode.Opcode.OpAdd: {  			o = Operator.Add;  			break;  		}  		case ByteCode.Opcode.OpSub: {  			o = Operator.Sub;  			break;  		}  		case ByteCode.Opcode.OpMul: {  			o = Operator.Mul;  			break;  		}  		case ByteCode.Opcode.OpDiv: {  			o = Operator.Div;  			break;  		}  		case ByteCode.Opcode.GetInd: {  			o = Operator.GetInd;  			break;  		}  		case ByteCode.Opcode.OpEq: {  			o = Operator.Eq;  			break;  		}  		case ByteCode.Opcode.OpNeq: {  			o = Operator.Neq;  			break;  		}  		case ByteCode.Opcode.OpLt: {  			o = Operator.Lt;  			break;  		}  		case ByteCode.Opcode.OpLte: {  			o = Operator.Lte;  			break;  		}  		case ByteCode.Opcode.OpGt: {  			o = Operator.Gt;  			break;  		}  		case ByteCode.Opcode.OpGte: {  			o = Operator.Gte;  			break;  		}  		case ByteCode.Opcode.OpRem: {  			o = Operator.Rem;  			break;  		}  		#endregion  		}  		if (o == Operator._MAX) {  			throw new NotImplementedException ("Operator not mapped or implemented");  		}  		var t1 = _stack.Peek (-1).TypeCode;  		var t2 = _stack.Peek (-2).TypeCode;  		if (t2 > t1) {  			t1 = t2;  		}  		OperatorCallback op = Machine.GetTypeOperator (t1' o);  		if (op != null) {  			var operand = _stack.StackPointer--;  			_stack.PokeAbs (operand - 2' op (this' _stack.PeekAbs (operand - 2)' _stack.PeekAbs (operand - 1)' _stack.PeekAbs (operand)));  		}  		else {  			throw new Exception ("Operator not defined");  		}  		break;  	}  	case ByteCode.Opcode.GetInd: {  		var type = _stack.Peek (-2).TypeCode;  		var op = Machine.GetTypeOperator (type' Operator.GetInd);  		if (op != null) {  			var operand = _stack.StackPointer--;  			_stack.PokeAbs (operand - 2' op (this' _stack.PeekAbs (operand - 2)' _stack.PeekAbs (operand - 1)' _stack.PeekAbs (operand)));  		}  		else {  			throw new Exception ("Operator not defined");  		}  		break;  	}  	case ByteCode.Opcode.SetInd: {  		var topMin3 = _stack.Peek (-3);  		OperatorCallback op = Machine.GetTypeOperator (topMin3.TypeCode' Operator.SetInd);  		if (op != null) {  			_stack.Poke (-3' op (this' topMin3' _stack.Peek (-2)' _stack.Peek (-1)));  			_stack.StackPointer -= 3;  		}  		else {  			throw new Exception ("Operator not defined");  		}  		break;  	}  	case ByteCode.Opcode.ForEach: {  		var topMin2 = _stack.Peek (-2);  		TypeIteratorCallback itr = Machine.GetTypeIterator (topMin2.TypeCode);  		if (itr == null) {  			_machine.Log.LogEntry ("Undefined iterator for type");  			return ThreadState.Exception;  		}  		var iteratorPos = _stack.Peek (-1).GetInteger ();  		var obj = _stack.Peek (-2).GetReference ();  		iteratorPos = itr (this' obj' iteratorPos' _stack.PeekBase (inst [1].GetInteger ())' _stack.PeekBase (inst [0].GetInteger ()));  		if (iteratorPos != -1) {  			//_Stack2[_Base + Inst[1].GetInteger()] = Key;  			//_Stack2[_Base + Inst[0].GetInteger()] = Item;  			_stack.Poke (Variable.Zero);  		}  		else {  			_stack.Poke (Variable.Zero);  		}  		_stack.Poke (-1' iteratorPos);  		++_stack.StackPointer;  		break;  	}  	#region Dot Operators  	case ByteCode.Opcode.GetDot: {  		var v1 = _stack.Peek (-1);  		OperatorCallback op = Machine.GetTypeOperator (v1.TypeCode' Operator.GetDot);  		_stack.Poke (inst [0]);  		if (op != null) {  			_stack.Poke (-1' op (this' v1' _stack.Peek ()' _stack.Peek ()));  		}  		else {  			throw new Exception ("Operator not defined");  		}  		break;  	}  	case ByteCode.Opcode.SetDot: {  		var v1 = _stack.Peek (-2);  		OperatorCallback op = Machine.GetTypeOperator (v1.TypeCode' Operator.SetDot);  		_stack.Poke (inst [0]);  		if (op != null) {  			_stack.Poke (-2' op (this' _stack.Peek (-2)' _stack.Peek (-1)' _stack.Peek ()));  			_stack.StackPointer -= 2;  		}  		else {  			throw new Exception ("Operator not defined");  		}  		break;  	}  	#endregion  	#endregion  	#region Branch  	case ByteCode.Opcode.Brz: {  		var v = _stack.Pop ();  		if (v.IsZero) {  			var newIp = inst [0].GetInteger ();  			if (newIp >= _instructionList.Count) {  				throw new Exception ("BRZ: Corrupt IP");  			}  			_instructionPtr = newIp;  		}  		break;  	}  	case ByteCode.Opcode.Brnz: {  		var v = _stack.Pop ();  		if (!v.IsZero) {  			var newIp = inst [0].GetInteger ();  			if (newIp >= _instructionList.Count) {  				throw new Exception ("BRZ: Corrupt IP");  			}  			_instructionPtr = newIp;  		}  		break;  	}  	case ByteCode.Opcode.Brzk: {  		var v = _stack.Peek (-1);  		if (v.IsZero) {  			var newIp = inst [0].GetInteger ();  			if (newIp >= _instructionList.Count) {  				throw new Exception ("BRZ: Corrupt IP");  			}  			_instructionPtr = newIp;  		}  		break;  	}  	case ByteCode.Opcode.Brnzk: {  		var v = _stack.Peek (-1);  		if (!v.IsZero) {  			var newIp = inst [0].GetInteger ();  			if (newIp >= _instructionList.Count) {  				throw new Exception ("BRNZK: Corrupt IP");  			}  			_instructionPtr = newIp;  		}  		break;  	}  	case ByteCode.Opcode.Bra: {  		var newIp = inst [0].GetInteger ();  		if (newIp >= _instructionList.Count) {  			throw new Exception ("BRA: Corrupt IP");  		}  		_instructionPtr = newIp;  		break;  	}  	#endregion  	default: {  		throw new Exception ("Unknown instr");  	}  	}  	// end switch instruction  }  
Magic Number,GreenBeanScript,Thread,C:\repos\evolutional_greenbeanscript\GreenBeanScript\VirtualMachine\Thread.cs,Execute,The following statement contains a magic number: for (; ;) {  	if (_instructionPtr >= _instructionList.Count)  		break;  	var inst = _instructionList [_instructionPtr++];  	switch (inst.OpCode) {  	case ByteCode.Opcode.Pop: {  		_stack.Pop ();  		break;  	}  	case ByteCode.Opcode.Pop2: {  		_stack.Pop (2);  		break;  	}  	case ByteCode.Opcode.Dup: {  		_stack.Push (_stack.Peek ());  		break;  	}  	case ByteCode.Opcode.Call: {  		// pop arg count from stack  		ThreadState res = PushStackFrame (inst [0].GetInteger ());  		switch (res) {  		case ThreadState.Running: {  			break;  		}  		case ThreadState.Sys_Yield: {  			return ThreadState.Running;  		}  		case ThreadState.Exception: {  			_machine.SwitchThreadState (this' ThreadState.Killed);  			return ThreadState.Exception;  		}  		case ThreadState.Killed: {  			_machine.SwitchThreadState (this' ThreadState.Killed);  			break;  		}  		default: {  			break;  		}  		}  		break;  	}  	#region Push Operations  	case ByteCode.Opcode.PushNull: {  		Push (Variable.Null);  		break;  	}  	case ByteCode.Opcode.PushThis: {  		Push (This);  		break;  	}  	case ByteCode.Opcode.PushInt0:  	case ByteCode.Opcode.PushInt1:  	case ByteCode.Opcode.PushInt:  	case ByteCode.Opcode.PushFp:  	case ByteCode.Opcode.PushStr:  	case ByteCode.Opcode.PushFn: {  		Push (inst [0]);  		break;  	}  	case ByteCode.Opcode.PushTbl: {  		Push (new TableObject ());  		break;  	}  	#endregion  	case ByteCode.Opcode.Ret:// Ret pushes a null  	 {  		Push (Variable.Null);  		ThreadState res = PopStackFrame ();  		switch (res) {  		case ThreadState.Exception:  		case ThreadState.Killed: {  			_machine.SwitchThreadState (this' res);  			return res;  		}  		default: {  			break;  		}  		}  		break;  	}  	case ByteCode.Opcode.Retv: {  		ThreadState res = PopStackFrame ();  		if (res == ThreadState.Killed) {  			return res;  		}  		break;  	}  	case ByteCode.Opcode.SetGlobal: {  		Variable v1 = inst [0];  		if (v1.Type != VariableType.String) {  			throw new Exception ("String required");  		}  		Variable v2 = _stack.Pop ();  		_machine.Globals [v1] = v2;  		break;  	}  	case ByteCode.Opcode.GetGlobal: {  		Variable v1 = inst [0];  		// global name  		// TODO: Check for string  		if (v1.Type != VariableType.String) {  			throw new Exception ("String required");  		}  		var global = _machine.Globals [v1];  		Push (global);  		break;  	}  	case ByteCode.Opcode.SetLocal: {  		int offset = inst [0].GetInteger ();  		_stack.PokeBase (offset' _stack.Pop ());  		break;  	}  	case ByteCode.Opcode.GetLocal: {  		int offset = inst [0].GetInteger ();  		Push (_stack.PeekBase (offset));  		break;  	}  	#region Operators  	case ByteCode.Opcode.OpEq:  	case ByteCode.Opcode.OpNeq:  	case ByteCode.Opcode.OpLt:  	case ByteCode.Opcode.OpLte:  	case ByteCode.Opcode.OpGt:  	case ByteCode.Opcode.OpGte:  	case ByteCode.Opcode.OpRem:  	case ByteCode.Opcode.OpAdd:  	case ByteCode.Opcode.OpSub:  	case ByteCode.Opcode.OpMul:  	case ByteCode.Opcode.OpDiv: {  		Operator o = Operator._MAX;  		switch (inst.OpCode) {  		#region fold  		case ByteCode.Opcode.OpAdd: {  			o = Operator.Add;  			break;  		}  		case ByteCode.Opcode.OpSub: {  			o = Operator.Sub;  			break;  		}  		case ByteCode.Opcode.OpMul: {  			o = Operator.Mul;  			break;  		}  		case ByteCode.Opcode.OpDiv: {  			o = Operator.Div;  			break;  		}  		case ByteCode.Opcode.GetInd: {  			o = Operator.GetInd;  			break;  		}  		case ByteCode.Opcode.OpEq: {  			o = Operator.Eq;  			break;  		}  		case ByteCode.Opcode.OpNeq: {  			o = Operator.Neq;  			break;  		}  		case ByteCode.Opcode.OpLt: {  			o = Operator.Lt;  			break;  		}  		case ByteCode.Opcode.OpLte: {  			o = Operator.Lte;  			break;  		}  		case ByteCode.Opcode.OpGt: {  			o = Operator.Gt;  			break;  		}  		case ByteCode.Opcode.OpGte: {  			o = Operator.Gte;  			break;  		}  		case ByteCode.Opcode.OpRem: {  			o = Operator.Rem;  			break;  		}  		#endregion  		}  		if (o == Operator._MAX) {  			throw new NotImplementedException ("Operator not mapped or implemented");  		}  		var t1 = _stack.Peek (-1).TypeCode;  		var t2 = _stack.Peek (-2).TypeCode;  		if (t2 > t1) {  			t1 = t2;  		}  		OperatorCallback op = Machine.GetTypeOperator (t1' o);  		if (op != null) {  			var operand = _stack.StackPointer--;  			_stack.PokeAbs (operand - 2' op (this' _stack.PeekAbs (operand - 2)' _stack.PeekAbs (operand - 1)' _stack.PeekAbs (operand)));  		}  		else {  			throw new Exception ("Operator not defined");  		}  		break;  	}  	case ByteCode.Opcode.GetInd: {  		var type = _stack.Peek (-2).TypeCode;  		var op = Machine.GetTypeOperator (type' Operator.GetInd);  		if (op != null) {  			var operand = _stack.StackPointer--;  			_stack.PokeAbs (operand - 2' op (this' _stack.PeekAbs (operand - 2)' _stack.PeekAbs (operand - 1)' _stack.PeekAbs (operand)));  		}  		else {  			throw new Exception ("Operator not defined");  		}  		break;  	}  	case ByteCode.Opcode.SetInd: {  		var topMin3 = _stack.Peek (-3);  		OperatorCallback op = Machine.GetTypeOperator (topMin3.TypeCode' Operator.SetInd);  		if (op != null) {  			_stack.Poke (-3' op (this' topMin3' _stack.Peek (-2)' _stack.Peek (-1)));  			_stack.StackPointer -= 3;  		}  		else {  			throw new Exception ("Operator not defined");  		}  		break;  	}  	case ByteCode.Opcode.ForEach: {  		var topMin2 = _stack.Peek (-2);  		TypeIteratorCallback itr = Machine.GetTypeIterator (topMin2.TypeCode);  		if (itr == null) {  			_machine.Log.LogEntry ("Undefined iterator for type");  			return ThreadState.Exception;  		}  		var iteratorPos = _stack.Peek (-1).GetInteger ();  		var obj = _stack.Peek (-2).GetReference ();  		iteratorPos = itr (this' obj' iteratorPos' _stack.PeekBase (inst [1].GetInteger ())' _stack.PeekBase (inst [0].GetInteger ()));  		if (iteratorPos != -1) {  			//_Stack2[_Base + Inst[1].GetInteger()] = Key;  			//_Stack2[_Base + Inst[0].GetInteger()] = Item;  			_stack.Poke (Variable.Zero);  		}  		else {  			_stack.Poke (Variable.Zero);  		}  		_stack.Poke (-1' iteratorPos);  		++_stack.StackPointer;  		break;  	}  	#region Dot Operators  	case ByteCode.Opcode.GetDot: {  		var v1 = _stack.Peek (-1);  		OperatorCallback op = Machine.GetTypeOperator (v1.TypeCode' Operator.GetDot);  		_stack.Poke (inst [0]);  		if (op != null) {  			_stack.Poke (-1' op (this' v1' _stack.Peek ()' _stack.Peek ()));  		}  		else {  			throw new Exception ("Operator not defined");  		}  		break;  	}  	case ByteCode.Opcode.SetDot: {  		var v1 = _stack.Peek (-2);  		OperatorCallback op = Machine.GetTypeOperator (v1.TypeCode' Operator.SetDot);  		_stack.Poke (inst [0]);  		if (op != null) {  			_stack.Poke (-2' op (this' _stack.Peek (-2)' _stack.Peek (-1)' _stack.Peek ()));  			_stack.StackPointer -= 2;  		}  		else {  			throw new Exception ("Operator not defined");  		}  		break;  	}  	#endregion  	#endregion  	#region Branch  	case ByteCode.Opcode.Brz: {  		var v = _stack.Pop ();  		if (v.IsZero) {  			var newIp = inst [0].GetInteger ();  			if (newIp >= _instructionList.Count) {  				throw new Exception ("BRZ: Corrupt IP");  			}  			_instructionPtr = newIp;  		}  		break;  	}  	case ByteCode.Opcode.Brnz: {  		var v = _stack.Pop ();  		if (!v.IsZero) {  			var newIp = inst [0].GetInteger ();  			if (newIp >= _instructionList.Count) {  				throw new Exception ("BRZ: Corrupt IP");  			}  			_instructionPtr = newIp;  		}  		break;  	}  	case ByteCode.Opcode.Brzk: {  		var v = _stack.Peek (-1);  		if (v.IsZero) {  			var newIp = inst [0].GetInteger ();  			if (newIp >= _instructionList.Count) {  				throw new Exception ("BRZ: Corrupt IP");  			}  			_instructionPtr = newIp;  		}  		break;  	}  	case ByteCode.Opcode.Brnzk: {  		var v = _stack.Peek (-1);  		if (!v.IsZero) {  			var newIp = inst [0].GetInteger ();  			if (newIp >= _instructionList.Count) {  				throw new Exception ("BRNZK: Corrupt IP");  			}  			_instructionPtr = newIp;  		}  		break;  	}  	case ByteCode.Opcode.Bra: {  		var newIp = inst [0].GetInteger ();  		if (newIp >= _instructionList.Count) {  			throw new Exception ("BRA: Corrupt IP");  		}  		_instructionPtr = newIp;  		break;  	}  	#endregion  	default: {  		throw new Exception ("Unknown instr");  	}  	}  	// end switch instruction  }  
Magic Number,GreenBeanScript,Thread,C:\repos\evolutional_greenbeanscript\GreenBeanScript\VirtualMachine\Thread.cs,Execute,The following statement contains a magic number: for (; ;) {  	if (_instructionPtr >= _instructionList.Count)  		break;  	var inst = _instructionList [_instructionPtr++];  	switch (inst.OpCode) {  	case ByteCode.Opcode.Pop: {  		_stack.Pop ();  		break;  	}  	case ByteCode.Opcode.Pop2: {  		_stack.Pop (2);  		break;  	}  	case ByteCode.Opcode.Dup: {  		_stack.Push (_stack.Peek ());  		break;  	}  	case ByteCode.Opcode.Call: {  		// pop arg count from stack  		ThreadState res = PushStackFrame (inst [0].GetInteger ());  		switch (res) {  		case ThreadState.Running: {  			break;  		}  		case ThreadState.Sys_Yield: {  			return ThreadState.Running;  		}  		case ThreadState.Exception: {  			_machine.SwitchThreadState (this' ThreadState.Killed);  			return ThreadState.Exception;  		}  		case ThreadState.Killed: {  			_machine.SwitchThreadState (this' ThreadState.Killed);  			break;  		}  		default: {  			break;  		}  		}  		break;  	}  	#region Push Operations  	case ByteCode.Opcode.PushNull: {  		Push (Variable.Null);  		break;  	}  	case ByteCode.Opcode.PushThis: {  		Push (This);  		break;  	}  	case ByteCode.Opcode.PushInt0:  	case ByteCode.Opcode.PushInt1:  	case ByteCode.Opcode.PushInt:  	case ByteCode.Opcode.PushFp:  	case ByteCode.Opcode.PushStr:  	case ByteCode.Opcode.PushFn: {  		Push (inst [0]);  		break;  	}  	case ByteCode.Opcode.PushTbl: {  		Push (new TableObject ());  		break;  	}  	#endregion  	case ByteCode.Opcode.Ret:// Ret pushes a null  	 {  		Push (Variable.Null);  		ThreadState res = PopStackFrame ();  		switch (res) {  		case ThreadState.Exception:  		case ThreadState.Killed: {  			_machine.SwitchThreadState (this' res);  			return res;  		}  		default: {  			break;  		}  		}  		break;  	}  	case ByteCode.Opcode.Retv: {  		ThreadState res = PopStackFrame ();  		if (res == ThreadState.Killed) {  			return res;  		}  		break;  	}  	case ByteCode.Opcode.SetGlobal: {  		Variable v1 = inst [0];  		if (v1.Type != VariableType.String) {  			throw new Exception ("String required");  		}  		Variable v2 = _stack.Pop ();  		_machine.Globals [v1] = v2;  		break;  	}  	case ByteCode.Opcode.GetGlobal: {  		Variable v1 = inst [0];  		// global name  		// TODO: Check for string  		if (v1.Type != VariableType.String) {  			throw new Exception ("String required");  		}  		var global = _machine.Globals [v1];  		Push (global);  		break;  	}  	case ByteCode.Opcode.SetLocal: {  		int offset = inst [0].GetInteger ();  		_stack.PokeBase (offset' _stack.Pop ());  		break;  	}  	case ByteCode.Opcode.GetLocal: {  		int offset = inst [0].GetInteger ();  		Push (_stack.PeekBase (offset));  		break;  	}  	#region Operators  	case ByteCode.Opcode.OpEq:  	case ByteCode.Opcode.OpNeq:  	case ByteCode.Opcode.OpLt:  	case ByteCode.Opcode.OpLte:  	case ByteCode.Opcode.OpGt:  	case ByteCode.Opcode.OpGte:  	case ByteCode.Opcode.OpRem:  	case ByteCode.Opcode.OpAdd:  	case ByteCode.Opcode.OpSub:  	case ByteCode.Opcode.OpMul:  	case ByteCode.Opcode.OpDiv: {  		Operator o = Operator._MAX;  		switch (inst.OpCode) {  		#region fold  		case ByteCode.Opcode.OpAdd: {  			o = Operator.Add;  			break;  		}  		case ByteCode.Opcode.OpSub: {  			o = Operator.Sub;  			break;  		}  		case ByteCode.Opcode.OpMul: {  			o = Operator.Mul;  			break;  		}  		case ByteCode.Opcode.OpDiv: {  			o = Operator.Div;  			break;  		}  		case ByteCode.Opcode.GetInd: {  			o = Operator.GetInd;  			break;  		}  		case ByteCode.Opcode.OpEq: {  			o = Operator.Eq;  			break;  		}  		case ByteCode.Opcode.OpNeq: {  			o = Operator.Neq;  			break;  		}  		case ByteCode.Opcode.OpLt: {  			o = Operator.Lt;  			break;  		}  		case ByteCode.Opcode.OpLte: {  			o = Operator.Lte;  			break;  		}  		case ByteCode.Opcode.OpGt: {  			o = Operator.Gt;  			break;  		}  		case ByteCode.Opcode.OpGte: {  			o = Operator.Gte;  			break;  		}  		case ByteCode.Opcode.OpRem: {  			o = Operator.Rem;  			break;  		}  		#endregion  		}  		if (o == Operator._MAX) {  			throw new NotImplementedException ("Operator not mapped or implemented");  		}  		var t1 = _stack.Peek (-1).TypeCode;  		var t2 = _stack.Peek (-2).TypeCode;  		if (t2 > t1) {  			t1 = t2;  		}  		OperatorCallback op = Machine.GetTypeOperator (t1' o);  		if (op != null) {  			var operand = _stack.StackPointer--;  			_stack.PokeAbs (operand - 2' op (this' _stack.PeekAbs (operand - 2)' _stack.PeekAbs (operand - 1)' _stack.PeekAbs (operand)));  		}  		else {  			throw new Exception ("Operator not defined");  		}  		break;  	}  	case ByteCode.Opcode.GetInd: {  		var type = _stack.Peek (-2).TypeCode;  		var op = Machine.GetTypeOperator (type' Operator.GetInd);  		if (op != null) {  			var operand = _stack.StackPointer--;  			_stack.PokeAbs (operand - 2' op (this' _stack.PeekAbs (operand - 2)' _stack.PeekAbs (operand - 1)' _stack.PeekAbs (operand)));  		}  		else {  			throw new Exception ("Operator not defined");  		}  		break;  	}  	case ByteCode.Opcode.SetInd: {  		var topMin3 = _stack.Peek (-3);  		OperatorCallback op = Machine.GetTypeOperator (topMin3.TypeCode' Operator.SetInd);  		if (op != null) {  			_stack.Poke (-3' op (this' topMin3' _stack.Peek (-2)' _stack.Peek (-1)));  			_stack.StackPointer -= 3;  		}  		else {  			throw new Exception ("Operator not defined");  		}  		break;  	}  	case ByteCode.Opcode.ForEach: {  		var topMin2 = _stack.Peek (-2);  		TypeIteratorCallback itr = Machine.GetTypeIterator (topMin2.TypeCode);  		if (itr == null) {  			_machine.Log.LogEntry ("Undefined iterator for type");  			return ThreadState.Exception;  		}  		var iteratorPos = _stack.Peek (-1).GetInteger ();  		var obj = _stack.Peek (-2).GetReference ();  		iteratorPos = itr (this' obj' iteratorPos' _stack.PeekBase (inst [1].GetInteger ())' _stack.PeekBase (inst [0].GetInteger ()));  		if (iteratorPos != -1) {  			//_Stack2[_Base + Inst[1].GetInteger()] = Key;  			//_Stack2[_Base + Inst[0].GetInteger()] = Item;  			_stack.Poke (Variable.Zero);  		}  		else {  			_stack.Poke (Variable.Zero);  		}  		_stack.Poke (-1' iteratorPos);  		++_stack.StackPointer;  		break;  	}  	#region Dot Operators  	case ByteCode.Opcode.GetDot: {  		var v1 = _stack.Peek (-1);  		OperatorCallback op = Machine.GetTypeOperator (v1.TypeCode' Operator.GetDot);  		_stack.Poke (inst [0]);  		if (op != null) {  			_stack.Poke (-1' op (this' v1' _stack.Peek ()' _stack.Peek ()));  		}  		else {  			throw new Exception ("Operator not defined");  		}  		break;  	}  	case ByteCode.Opcode.SetDot: {  		var v1 = _stack.Peek (-2);  		OperatorCallback op = Machine.GetTypeOperator (v1.TypeCode' Operator.SetDot);  		_stack.Poke (inst [0]);  		if (op != null) {  			_stack.Poke (-2' op (this' _stack.Peek (-2)' _stack.Peek (-1)' _stack.Peek ()));  			_stack.StackPointer -= 2;  		}  		else {  			throw new Exception ("Operator not defined");  		}  		break;  	}  	#endregion  	#endregion  	#region Branch  	case ByteCode.Opcode.Brz: {  		var v = _stack.Pop ();  		if (v.IsZero) {  			var newIp = inst [0].GetInteger ();  			if (newIp >= _instructionList.Count) {  				throw new Exception ("BRZ: Corrupt IP");  			}  			_instructionPtr = newIp;  		}  		break;  	}  	case ByteCode.Opcode.Brnz: {  		var v = _stack.Pop ();  		if (!v.IsZero) {  			var newIp = inst [0].GetInteger ();  			if (newIp >= _instructionList.Count) {  				throw new Exception ("BRZ: Corrupt IP");  			}  			_instructionPtr = newIp;  		}  		break;  	}  	case ByteCode.Opcode.Brzk: {  		var v = _stack.Peek (-1);  		if (v.IsZero) {  			var newIp = inst [0].GetInteger ();  			if (newIp >= _instructionList.Count) {  				throw new Exception ("BRZ: Corrupt IP");  			}  			_instructionPtr = newIp;  		}  		break;  	}  	case ByteCode.Opcode.Brnzk: {  		var v = _stack.Peek (-1);  		if (!v.IsZero) {  			var newIp = inst [0].GetInteger ();  			if (newIp >= _instructionList.Count) {  				throw new Exception ("BRNZK: Corrupt IP");  			}  			_instructionPtr = newIp;  		}  		break;  	}  	case ByteCode.Opcode.Bra: {  		var newIp = inst [0].GetInteger ();  		if (newIp >= _instructionList.Count) {  			throw new Exception ("BRA: Corrupt IP");  		}  		_instructionPtr = newIp;  		break;  	}  	#endregion  	default: {  		throw new Exception ("Unknown instr");  	}  	}  	// end switch instruction  }  
Magic Number,GreenBeanScript,Thread,C:\repos\evolutional_greenbeanscript\GreenBeanScript\VirtualMachine\Thread.cs,Execute,The following statement contains a magic number: for (; ;) {  	if (_instructionPtr >= _instructionList.Count)  		break;  	var inst = _instructionList [_instructionPtr++];  	switch (inst.OpCode) {  	case ByteCode.Opcode.Pop: {  		_stack.Pop ();  		break;  	}  	case ByteCode.Opcode.Pop2: {  		_stack.Pop (2);  		break;  	}  	case ByteCode.Opcode.Dup: {  		_stack.Push (_stack.Peek ());  		break;  	}  	case ByteCode.Opcode.Call: {  		// pop arg count from stack  		ThreadState res = PushStackFrame (inst [0].GetInteger ());  		switch (res) {  		case ThreadState.Running: {  			break;  		}  		case ThreadState.Sys_Yield: {  			return ThreadState.Running;  		}  		case ThreadState.Exception: {  			_machine.SwitchThreadState (this' ThreadState.Killed);  			return ThreadState.Exception;  		}  		case ThreadState.Killed: {  			_machine.SwitchThreadState (this' ThreadState.Killed);  			break;  		}  		default: {  			break;  		}  		}  		break;  	}  	#region Push Operations  	case ByteCode.Opcode.PushNull: {  		Push (Variable.Null);  		break;  	}  	case ByteCode.Opcode.PushThis: {  		Push (This);  		break;  	}  	case ByteCode.Opcode.PushInt0:  	case ByteCode.Opcode.PushInt1:  	case ByteCode.Opcode.PushInt:  	case ByteCode.Opcode.PushFp:  	case ByteCode.Opcode.PushStr:  	case ByteCode.Opcode.PushFn: {  		Push (inst [0]);  		break;  	}  	case ByteCode.Opcode.PushTbl: {  		Push (new TableObject ());  		break;  	}  	#endregion  	case ByteCode.Opcode.Ret:// Ret pushes a null  	 {  		Push (Variable.Null);  		ThreadState res = PopStackFrame ();  		switch (res) {  		case ThreadState.Exception:  		case ThreadState.Killed: {  			_machine.SwitchThreadState (this' res);  			return res;  		}  		default: {  			break;  		}  		}  		break;  	}  	case ByteCode.Opcode.Retv: {  		ThreadState res = PopStackFrame ();  		if (res == ThreadState.Killed) {  			return res;  		}  		break;  	}  	case ByteCode.Opcode.SetGlobal: {  		Variable v1 = inst [0];  		if (v1.Type != VariableType.String) {  			throw new Exception ("String required");  		}  		Variable v2 = _stack.Pop ();  		_machine.Globals [v1] = v2;  		break;  	}  	case ByteCode.Opcode.GetGlobal: {  		Variable v1 = inst [0];  		// global name  		// TODO: Check for string  		if (v1.Type != VariableType.String) {  			throw new Exception ("String required");  		}  		var global = _machine.Globals [v1];  		Push (global);  		break;  	}  	case ByteCode.Opcode.SetLocal: {  		int offset = inst [0].GetInteger ();  		_stack.PokeBase (offset' _stack.Pop ());  		break;  	}  	case ByteCode.Opcode.GetLocal: {  		int offset = inst [0].GetInteger ();  		Push (_stack.PeekBase (offset));  		break;  	}  	#region Operators  	case ByteCode.Opcode.OpEq:  	case ByteCode.Opcode.OpNeq:  	case ByteCode.Opcode.OpLt:  	case ByteCode.Opcode.OpLte:  	case ByteCode.Opcode.OpGt:  	case ByteCode.Opcode.OpGte:  	case ByteCode.Opcode.OpRem:  	case ByteCode.Opcode.OpAdd:  	case ByteCode.Opcode.OpSub:  	case ByteCode.Opcode.OpMul:  	case ByteCode.Opcode.OpDiv: {  		Operator o = Operator._MAX;  		switch (inst.OpCode) {  		#region fold  		case ByteCode.Opcode.OpAdd: {  			o = Operator.Add;  			break;  		}  		case ByteCode.Opcode.OpSub: {  			o = Operator.Sub;  			break;  		}  		case ByteCode.Opcode.OpMul: {  			o = Operator.Mul;  			break;  		}  		case ByteCode.Opcode.OpDiv: {  			o = Operator.Div;  			break;  		}  		case ByteCode.Opcode.GetInd: {  			o = Operator.GetInd;  			break;  		}  		case ByteCode.Opcode.OpEq: {  			o = Operator.Eq;  			break;  		}  		case ByteCode.Opcode.OpNeq: {  			o = Operator.Neq;  			break;  		}  		case ByteCode.Opcode.OpLt: {  			o = Operator.Lt;  			break;  		}  		case ByteCode.Opcode.OpLte: {  			o = Operator.Lte;  			break;  		}  		case ByteCode.Opcode.OpGt: {  			o = Operator.Gt;  			break;  		}  		case ByteCode.Opcode.OpGte: {  			o = Operator.Gte;  			break;  		}  		case ByteCode.Opcode.OpRem: {  			o = Operator.Rem;  			break;  		}  		#endregion  		}  		if (o == Operator._MAX) {  			throw new NotImplementedException ("Operator not mapped or implemented");  		}  		var t1 = _stack.Peek (-1).TypeCode;  		var t2 = _stack.Peek (-2).TypeCode;  		if (t2 > t1) {  			t1 = t2;  		}  		OperatorCallback op = Machine.GetTypeOperator (t1' o);  		if (op != null) {  			var operand = _stack.StackPointer--;  			_stack.PokeAbs (operand - 2' op (this' _stack.PeekAbs (operand - 2)' _stack.PeekAbs (operand - 1)' _stack.PeekAbs (operand)));  		}  		else {  			throw new Exception ("Operator not defined");  		}  		break;  	}  	case ByteCode.Opcode.GetInd: {  		var type = _stack.Peek (-2).TypeCode;  		var op = Machine.GetTypeOperator (type' Operator.GetInd);  		if (op != null) {  			var operand = _stack.StackPointer--;  			_stack.PokeAbs (operand - 2' op (this' _stack.PeekAbs (operand - 2)' _stack.PeekAbs (operand - 1)' _stack.PeekAbs (operand)));  		}  		else {  			throw new Exception ("Operator not defined");  		}  		break;  	}  	case ByteCode.Opcode.SetInd: {  		var topMin3 = _stack.Peek (-3);  		OperatorCallback op = Machine.GetTypeOperator (topMin3.TypeCode' Operator.SetInd);  		if (op != null) {  			_stack.Poke (-3' op (this' topMin3' _stack.Peek (-2)' _stack.Peek (-1)));  			_stack.StackPointer -= 3;  		}  		else {  			throw new Exception ("Operator not defined");  		}  		break;  	}  	case ByteCode.Opcode.ForEach: {  		var topMin2 = _stack.Peek (-2);  		TypeIteratorCallback itr = Machine.GetTypeIterator (topMin2.TypeCode);  		if (itr == null) {  			_machine.Log.LogEntry ("Undefined iterator for type");  			return ThreadState.Exception;  		}  		var iteratorPos = _stack.Peek (-1).GetInteger ();  		var obj = _stack.Peek (-2).GetReference ();  		iteratorPos = itr (this' obj' iteratorPos' _stack.PeekBase (inst [1].GetInteger ())' _stack.PeekBase (inst [0].GetInteger ()));  		if (iteratorPos != -1) {  			//_Stack2[_Base + Inst[1].GetInteger()] = Key;  			//_Stack2[_Base + Inst[0].GetInteger()] = Item;  			_stack.Poke (Variable.Zero);  		}  		else {  			_stack.Poke (Variable.Zero);  		}  		_stack.Poke (-1' iteratorPos);  		++_stack.StackPointer;  		break;  	}  	#region Dot Operators  	case ByteCode.Opcode.GetDot: {  		var v1 = _stack.Peek (-1);  		OperatorCallback op = Machine.GetTypeOperator (v1.TypeCode' Operator.GetDot);  		_stack.Poke (inst [0]);  		if (op != null) {  			_stack.Poke (-1' op (this' v1' _stack.Peek ()' _stack.Peek ()));  		}  		else {  			throw new Exception ("Operator not defined");  		}  		break;  	}  	case ByteCode.Opcode.SetDot: {  		var v1 = _stack.Peek (-2);  		OperatorCallback op = Machine.GetTypeOperator (v1.TypeCode' Operator.SetDot);  		_stack.Poke (inst [0]);  		if (op != null) {  			_stack.Poke (-2' op (this' _stack.Peek (-2)' _stack.Peek (-1)' _stack.Peek ()));  			_stack.StackPointer -= 2;  		}  		else {  			throw new Exception ("Operator not defined");  		}  		break;  	}  	#endregion  	#endregion  	#region Branch  	case ByteCode.Opcode.Brz: {  		var v = _stack.Pop ();  		if (v.IsZero) {  			var newIp = inst [0].GetInteger ();  			if (newIp >= _instructionList.Count) {  				throw new Exception ("BRZ: Corrupt IP");  			}  			_instructionPtr = newIp;  		}  		break;  	}  	case ByteCode.Opcode.Brnz: {  		var v = _stack.Pop ();  		if (!v.IsZero) {  			var newIp = inst [0].GetInteger ();  			if (newIp >= _instructionList.Count) {  				throw new Exception ("BRZ: Corrupt IP");  			}  			_instructionPtr = newIp;  		}  		break;  	}  	case ByteCode.Opcode.Brzk: {  		var v = _stack.Peek (-1);  		if (v.IsZero) {  			var newIp = inst [0].GetInteger ();  			if (newIp >= _instructionList.Count) {  				throw new Exception ("BRZ: Corrupt IP");  			}  			_instructionPtr = newIp;  		}  		break;  	}  	case ByteCode.Opcode.Brnzk: {  		var v = _stack.Peek (-1);  		if (!v.IsZero) {  			var newIp = inst [0].GetInteger ();  			if (newIp >= _instructionList.Count) {  				throw new Exception ("BRNZK: Corrupt IP");  			}  			_instructionPtr = newIp;  		}  		break;  	}  	case ByteCode.Opcode.Bra: {  		var newIp = inst [0].GetInteger ();  		if (newIp >= _instructionList.Count) {  			throw new Exception ("BRA: Corrupt IP");  		}  		_instructionPtr = newIp;  		break;  	}  	#endregion  	default: {  		throw new Exception ("Unknown instr");  	}  	}  	// end switch instruction  }  
Magic Number,GreenBeanScript,Thread,C:\repos\evolutional_greenbeanscript\GreenBeanScript\VirtualMachine\Thread.cs,Execute,The following statement contains a magic number: for (; ;) {  	if (_instructionPtr >= _instructionList.Count)  		break;  	var inst = _instructionList [_instructionPtr++];  	switch (inst.OpCode) {  	case ByteCode.Opcode.Pop: {  		_stack.Pop ();  		break;  	}  	case ByteCode.Opcode.Pop2: {  		_stack.Pop (2);  		break;  	}  	case ByteCode.Opcode.Dup: {  		_stack.Push (_stack.Peek ());  		break;  	}  	case ByteCode.Opcode.Call: {  		// pop arg count from stack  		ThreadState res = PushStackFrame (inst [0].GetInteger ());  		switch (res) {  		case ThreadState.Running: {  			break;  		}  		case ThreadState.Sys_Yield: {  			return ThreadState.Running;  		}  		case ThreadState.Exception: {  			_machine.SwitchThreadState (this' ThreadState.Killed);  			return ThreadState.Exception;  		}  		case ThreadState.Killed: {  			_machine.SwitchThreadState (this' ThreadState.Killed);  			break;  		}  		default: {  			break;  		}  		}  		break;  	}  	#region Push Operations  	case ByteCode.Opcode.PushNull: {  		Push (Variable.Null);  		break;  	}  	case ByteCode.Opcode.PushThis: {  		Push (This);  		break;  	}  	case ByteCode.Opcode.PushInt0:  	case ByteCode.Opcode.PushInt1:  	case ByteCode.Opcode.PushInt:  	case ByteCode.Opcode.PushFp:  	case ByteCode.Opcode.PushStr:  	case ByteCode.Opcode.PushFn: {  		Push (inst [0]);  		break;  	}  	case ByteCode.Opcode.PushTbl: {  		Push (new TableObject ());  		break;  	}  	#endregion  	case ByteCode.Opcode.Ret:// Ret pushes a null  	 {  		Push (Variable.Null);  		ThreadState res = PopStackFrame ();  		switch (res) {  		case ThreadState.Exception:  		case ThreadState.Killed: {  			_machine.SwitchThreadState (this' res);  			return res;  		}  		default: {  			break;  		}  		}  		break;  	}  	case ByteCode.Opcode.Retv: {  		ThreadState res = PopStackFrame ();  		if (res == ThreadState.Killed) {  			return res;  		}  		break;  	}  	case ByteCode.Opcode.SetGlobal: {  		Variable v1 = inst [0];  		if (v1.Type != VariableType.String) {  			throw new Exception ("String required");  		}  		Variable v2 = _stack.Pop ();  		_machine.Globals [v1] = v2;  		break;  	}  	case ByteCode.Opcode.GetGlobal: {  		Variable v1 = inst [0];  		// global name  		// TODO: Check for string  		if (v1.Type != VariableType.String) {  			throw new Exception ("String required");  		}  		var global = _machine.Globals [v1];  		Push (global);  		break;  	}  	case ByteCode.Opcode.SetLocal: {  		int offset = inst [0].GetInteger ();  		_stack.PokeBase (offset' _stack.Pop ());  		break;  	}  	case ByteCode.Opcode.GetLocal: {  		int offset = inst [0].GetInteger ();  		Push (_stack.PeekBase (offset));  		break;  	}  	#region Operators  	case ByteCode.Opcode.OpEq:  	case ByteCode.Opcode.OpNeq:  	case ByteCode.Opcode.OpLt:  	case ByteCode.Opcode.OpLte:  	case ByteCode.Opcode.OpGt:  	case ByteCode.Opcode.OpGte:  	case ByteCode.Opcode.OpRem:  	case ByteCode.Opcode.OpAdd:  	case ByteCode.Opcode.OpSub:  	case ByteCode.Opcode.OpMul:  	case ByteCode.Opcode.OpDiv: {  		Operator o = Operator._MAX;  		switch (inst.OpCode) {  		#region fold  		case ByteCode.Opcode.OpAdd: {  			o = Operator.Add;  			break;  		}  		case ByteCode.Opcode.OpSub: {  			o = Operator.Sub;  			break;  		}  		case ByteCode.Opcode.OpMul: {  			o = Operator.Mul;  			break;  		}  		case ByteCode.Opcode.OpDiv: {  			o = Operator.Div;  			break;  		}  		case ByteCode.Opcode.GetInd: {  			o = Operator.GetInd;  			break;  		}  		case ByteCode.Opcode.OpEq: {  			o = Operator.Eq;  			break;  		}  		case ByteCode.Opcode.OpNeq: {  			o = Operator.Neq;  			break;  		}  		case ByteCode.Opcode.OpLt: {  			o = Operator.Lt;  			break;  		}  		case ByteCode.Opcode.OpLte: {  			o = Operator.Lte;  			break;  		}  		case ByteCode.Opcode.OpGt: {  			o = Operator.Gt;  			break;  		}  		case ByteCode.Opcode.OpGte: {  			o = Operator.Gte;  			break;  		}  		case ByteCode.Opcode.OpRem: {  			o = Operator.Rem;  			break;  		}  		#endregion  		}  		if (o == Operator._MAX) {  			throw new NotImplementedException ("Operator not mapped or implemented");  		}  		var t1 = _stack.Peek (-1).TypeCode;  		var t2 = _stack.Peek (-2).TypeCode;  		if (t2 > t1) {  			t1 = t2;  		}  		OperatorCallback op = Machine.GetTypeOperator (t1' o);  		if (op != null) {  			var operand = _stack.StackPointer--;  			_stack.PokeAbs (operand - 2' op (this' _stack.PeekAbs (operand - 2)' _stack.PeekAbs (operand - 1)' _stack.PeekAbs (operand)));  		}  		else {  			throw new Exception ("Operator not defined");  		}  		break;  	}  	case ByteCode.Opcode.GetInd: {  		var type = _stack.Peek (-2).TypeCode;  		var op = Machine.GetTypeOperator (type' Operator.GetInd);  		if (op != null) {  			var operand = _stack.StackPointer--;  			_stack.PokeAbs (operand - 2' op (this' _stack.PeekAbs (operand - 2)' _stack.PeekAbs (operand - 1)' _stack.PeekAbs (operand)));  		}  		else {  			throw new Exception ("Operator not defined");  		}  		break;  	}  	case ByteCode.Opcode.SetInd: {  		var topMin3 = _stack.Peek (-3);  		OperatorCallback op = Machine.GetTypeOperator (topMin3.TypeCode' Operator.SetInd);  		if (op != null) {  			_stack.Poke (-3' op (this' topMin3' _stack.Peek (-2)' _stack.Peek (-1)));  			_stack.StackPointer -= 3;  		}  		else {  			throw new Exception ("Operator not defined");  		}  		break;  	}  	case ByteCode.Opcode.ForEach: {  		var topMin2 = _stack.Peek (-2);  		TypeIteratorCallback itr = Machine.GetTypeIterator (topMin2.TypeCode);  		if (itr == null) {  			_machine.Log.LogEntry ("Undefined iterator for type");  			return ThreadState.Exception;  		}  		var iteratorPos = _stack.Peek (-1).GetInteger ();  		var obj = _stack.Peek (-2).GetReference ();  		iteratorPos = itr (this' obj' iteratorPos' _stack.PeekBase (inst [1].GetInteger ())' _stack.PeekBase (inst [0].GetInteger ()));  		if (iteratorPos != -1) {  			//_Stack2[_Base + Inst[1].GetInteger()] = Key;  			//_Stack2[_Base + Inst[0].GetInteger()] = Item;  			_stack.Poke (Variable.Zero);  		}  		else {  			_stack.Poke (Variable.Zero);  		}  		_stack.Poke (-1' iteratorPos);  		++_stack.StackPointer;  		break;  	}  	#region Dot Operators  	case ByteCode.Opcode.GetDot: {  		var v1 = _stack.Peek (-1);  		OperatorCallback op = Machine.GetTypeOperator (v1.TypeCode' Operator.GetDot);  		_stack.Poke (inst [0]);  		if (op != null) {  			_stack.Poke (-1' op (this' v1' _stack.Peek ()' _stack.Peek ()));  		}  		else {  			throw new Exception ("Operator not defined");  		}  		break;  	}  	case ByteCode.Opcode.SetDot: {  		var v1 = _stack.Peek (-2);  		OperatorCallback op = Machine.GetTypeOperator (v1.TypeCode' Operator.SetDot);  		_stack.Poke (inst [0]);  		if (op != null) {  			_stack.Poke (-2' op (this' _stack.Peek (-2)' _stack.Peek (-1)' _stack.Peek ()));  			_stack.StackPointer -= 2;  		}  		else {  			throw new Exception ("Operator not defined");  		}  		break;  	}  	#endregion  	#endregion  	#region Branch  	case ByteCode.Opcode.Brz: {  		var v = _stack.Pop ();  		if (v.IsZero) {  			var newIp = inst [0].GetInteger ();  			if (newIp >= _instructionList.Count) {  				throw new Exception ("BRZ: Corrupt IP");  			}  			_instructionPtr = newIp;  		}  		break;  	}  	case ByteCode.Opcode.Brnz: {  		var v = _stack.Pop ();  		if (!v.IsZero) {  			var newIp = inst [0].GetInteger ();  			if (newIp >= _instructionList.Count) {  				throw new Exception ("BRZ: Corrupt IP");  			}  			_instructionPtr = newIp;  		}  		break;  	}  	case ByteCode.Opcode.Brzk: {  		var v = _stack.Peek (-1);  		if (v.IsZero) {  			var newIp = inst [0].GetInteger ();  			if (newIp >= _instructionList.Count) {  				throw new Exception ("BRZ: Corrupt IP");  			}  			_instructionPtr = newIp;  		}  		break;  	}  	case ByteCode.Opcode.Brnzk: {  		var v = _stack.Peek (-1);  		if (!v.IsZero) {  			var newIp = inst [0].GetInteger ();  			if (newIp >= _instructionList.Count) {  				throw new Exception ("BRNZK: Corrupt IP");  			}  			_instructionPtr = newIp;  		}  		break;  	}  	case ByteCode.Opcode.Bra: {  		var newIp = inst [0].GetInteger ();  		if (newIp >= _instructionList.Count) {  			throw new Exception ("BRA: Corrupt IP");  		}  		_instructionPtr = newIp;  		break;  	}  	#endregion  	default: {  		throw new Exception ("Unknown instr");  	}  	}  	// end switch instruction  }  
Magic Number,GreenBeanScript,Thread,C:\repos\evolutional_greenbeanscript\GreenBeanScript\VirtualMachine\Thread.cs,Execute,The following statement contains a magic number: switch (inst.OpCode) {  case ByteCode.Opcode.Pop: {  	_stack.Pop ();  	break;  }  case ByteCode.Opcode.Pop2: {  	_stack.Pop (2);  	break;  }  case ByteCode.Opcode.Dup: {  	_stack.Push (_stack.Peek ());  	break;  }  case ByteCode.Opcode.Call: {  	// pop arg count from stack  	ThreadState res = PushStackFrame (inst [0].GetInteger ());  	switch (res) {  	case ThreadState.Running: {  		break;  	}  	case ThreadState.Sys_Yield: {  		return ThreadState.Running;  	}  	case ThreadState.Exception: {  		_machine.SwitchThreadState (this' ThreadState.Killed);  		return ThreadState.Exception;  	}  	case ThreadState.Killed: {  		_machine.SwitchThreadState (this' ThreadState.Killed);  		break;  	}  	default: {  		break;  	}  	}  	break;  }  #region Push Operations  case ByteCode.Opcode.PushNull: {  	Push (Variable.Null);  	break;  }  case ByteCode.Opcode.PushThis: {  	Push (This);  	break;  }  case ByteCode.Opcode.PushInt0:  case ByteCode.Opcode.PushInt1:  case ByteCode.Opcode.PushInt:  case ByteCode.Opcode.PushFp:  case ByteCode.Opcode.PushStr:  case ByteCode.Opcode.PushFn: {  	Push (inst [0]);  	break;  }  case ByteCode.Opcode.PushTbl: {  	Push (new TableObject ());  	break;  }  #endregion  case ByteCode.Opcode.Ret:// Ret pushes a null   {  	Push (Variable.Null);  	ThreadState res = PopStackFrame ();  	switch (res) {  	case ThreadState.Exception:  	case ThreadState.Killed: {  		_machine.SwitchThreadState (this' res);  		return res;  	}  	default: {  		break;  	}  	}  	break;  }  case ByteCode.Opcode.Retv: {  	ThreadState res = PopStackFrame ();  	if (res == ThreadState.Killed) {  		return res;  	}  	break;  }  case ByteCode.Opcode.SetGlobal: {  	Variable v1 = inst [0];  	if (v1.Type != VariableType.String) {  		throw new Exception ("String required");  	}  	Variable v2 = _stack.Pop ();  	_machine.Globals [v1] = v2;  	break;  }  case ByteCode.Opcode.GetGlobal: {  	Variable v1 = inst [0];  	// global name  	// TODO: Check for string  	if (v1.Type != VariableType.String) {  		throw new Exception ("String required");  	}  	var global = _machine.Globals [v1];  	Push (global);  	break;  }  case ByteCode.Opcode.SetLocal: {  	int offset = inst [0].GetInteger ();  	_stack.PokeBase (offset' _stack.Pop ());  	break;  }  case ByteCode.Opcode.GetLocal: {  	int offset = inst [0].GetInteger ();  	Push (_stack.PeekBase (offset));  	break;  }  #region Operators  case ByteCode.Opcode.OpEq:  case ByteCode.Opcode.OpNeq:  case ByteCode.Opcode.OpLt:  case ByteCode.Opcode.OpLte:  case ByteCode.Opcode.OpGt:  case ByteCode.Opcode.OpGte:  case ByteCode.Opcode.OpRem:  case ByteCode.Opcode.OpAdd:  case ByteCode.Opcode.OpSub:  case ByteCode.Opcode.OpMul:  case ByteCode.Opcode.OpDiv: {  	Operator o = Operator._MAX;  	switch (inst.OpCode) {  	#region fold  	case ByteCode.Opcode.OpAdd: {  		o = Operator.Add;  		break;  	}  	case ByteCode.Opcode.OpSub: {  		o = Operator.Sub;  		break;  	}  	case ByteCode.Opcode.OpMul: {  		o = Operator.Mul;  		break;  	}  	case ByteCode.Opcode.OpDiv: {  		o = Operator.Div;  		break;  	}  	case ByteCode.Opcode.GetInd: {  		o = Operator.GetInd;  		break;  	}  	case ByteCode.Opcode.OpEq: {  		o = Operator.Eq;  		break;  	}  	case ByteCode.Opcode.OpNeq: {  		o = Operator.Neq;  		break;  	}  	case ByteCode.Opcode.OpLt: {  		o = Operator.Lt;  		break;  	}  	case ByteCode.Opcode.OpLte: {  		o = Operator.Lte;  		break;  	}  	case ByteCode.Opcode.OpGt: {  		o = Operator.Gt;  		break;  	}  	case ByteCode.Opcode.OpGte: {  		o = Operator.Gte;  		break;  	}  	case ByteCode.Opcode.OpRem: {  		o = Operator.Rem;  		break;  	}  	#endregion  	}  	if (o == Operator._MAX) {  		throw new NotImplementedException ("Operator not mapped or implemented");  	}  	var t1 = _stack.Peek (-1).TypeCode;  	var t2 = _stack.Peek (-2).TypeCode;  	if (t2 > t1) {  		t1 = t2;  	}  	OperatorCallback op = Machine.GetTypeOperator (t1' o);  	if (op != null) {  		var operand = _stack.StackPointer--;  		_stack.PokeAbs (operand - 2' op (this' _stack.PeekAbs (operand - 2)' _stack.PeekAbs (operand - 1)' _stack.PeekAbs (operand)));  	}  	else {  		throw new Exception ("Operator not defined");  	}  	break;  }  case ByteCode.Opcode.GetInd: {  	var type = _stack.Peek (-2).TypeCode;  	var op = Machine.GetTypeOperator (type' Operator.GetInd);  	if (op != null) {  		var operand = _stack.StackPointer--;  		_stack.PokeAbs (operand - 2' op (this' _stack.PeekAbs (operand - 2)' _stack.PeekAbs (operand - 1)' _stack.PeekAbs (operand)));  	}  	else {  		throw new Exception ("Operator not defined");  	}  	break;  }  case ByteCode.Opcode.SetInd: {  	var topMin3 = _stack.Peek (-3);  	OperatorCallback op = Machine.GetTypeOperator (topMin3.TypeCode' Operator.SetInd);  	if (op != null) {  		_stack.Poke (-3' op (this' topMin3' _stack.Peek (-2)' _stack.Peek (-1)));  		_stack.StackPointer -= 3;  	}  	else {  		throw new Exception ("Operator not defined");  	}  	break;  }  case ByteCode.Opcode.ForEach: {  	var topMin2 = _stack.Peek (-2);  	TypeIteratorCallback itr = Machine.GetTypeIterator (topMin2.TypeCode);  	if (itr == null) {  		_machine.Log.LogEntry ("Undefined iterator for type");  		return ThreadState.Exception;  	}  	var iteratorPos = _stack.Peek (-1).GetInteger ();  	var obj = _stack.Peek (-2).GetReference ();  	iteratorPos = itr (this' obj' iteratorPos' _stack.PeekBase (inst [1].GetInteger ())' _stack.PeekBase (inst [0].GetInteger ()));  	if (iteratorPos != -1) {  		//_Stack2[_Base + Inst[1].GetInteger()] = Key;  		//_Stack2[_Base + Inst[0].GetInteger()] = Item;  		_stack.Poke (Variable.Zero);  	}  	else {  		_stack.Poke (Variable.Zero);  	}  	_stack.Poke (-1' iteratorPos);  	++_stack.StackPointer;  	break;  }  #region Dot Operators  case ByteCode.Opcode.GetDot: {  	var v1 = _stack.Peek (-1);  	OperatorCallback op = Machine.GetTypeOperator (v1.TypeCode' Operator.GetDot);  	_stack.Poke (inst [0]);  	if (op != null) {  		_stack.Poke (-1' op (this' v1' _stack.Peek ()' _stack.Peek ()));  	}  	else {  		throw new Exception ("Operator not defined");  	}  	break;  }  case ByteCode.Opcode.SetDot: {  	var v1 = _stack.Peek (-2);  	OperatorCallback op = Machine.GetTypeOperator (v1.TypeCode' Operator.SetDot);  	_stack.Poke (inst [0]);  	if (op != null) {  		_stack.Poke (-2' op (this' _stack.Peek (-2)' _stack.Peek (-1)' _stack.Peek ()));  		_stack.StackPointer -= 2;  	}  	else {  		throw new Exception ("Operator not defined");  	}  	break;  }  #endregion  #endregion  #region Branch  case ByteCode.Opcode.Brz: {  	var v = _stack.Pop ();  	if (v.IsZero) {  		var newIp = inst [0].GetInteger ();  		if (newIp >= _instructionList.Count) {  			throw new Exception ("BRZ: Corrupt IP");  		}  		_instructionPtr = newIp;  	}  	break;  }  case ByteCode.Opcode.Brnz: {  	var v = _stack.Pop ();  	if (!v.IsZero) {  		var newIp = inst [0].GetInteger ();  		if (newIp >= _instructionList.Count) {  			throw new Exception ("BRZ: Corrupt IP");  		}  		_instructionPtr = newIp;  	}  	break;  }  case ByteCode.Opcode.Brzk: {  	var v = _stack.Peek (-1);  	if (v.IsZero) {  		var newIp = inst [0].GetInteger ();  		if (newIp >= _instructionList.Count) {  			throw new Exception ("BRZ: Corrupt IP");  		}  		_instructionPtr = newIp;  	}  	break;  }  case ByteCode.Opcode.Brnzk: {  	var v = _stack.Peek (-1);  	if (!v.IsZero) {  		var newIp = inst [0].GetInteger ();  		if (newIp >= _instructionList.Count) {  			throw new Exception ("BRNZK: Corrupt IP");  		}  		_instructionPtr = newIp;  	}  	break;  }  case ByteCode.Opcode.Bra: {  	var newIp = inst [0].GetInteger ();  	if (newIp >= _instructionList.Count) {  		throw new Exception ("BRA: Corrupt IP");  	}  	_instructionPtr = newIp;  	break;  }  #endregion  default: {  	throw new Exception ("Unknown instr");  }  }  
Magic Number,GreenBeanScript,Thread,C:\repos\evolutional_greenbeanscript\GreenBeanScript\VirtualMachine\Thread.cs,Execute,The following statement contains a magic number: switch (inst.OpCode) {  case ByteCode.Opcode.Pop: {  	_stack.Pop ();  	break;  }  case ByteCode.Opcode.Pop2: {  	_stack.Pop (2);  	break;  }  case ByteCode.Opcode.Dup: {  	_stack.Push (_stack.Peek ());  	break;  }  case ByteCode.Opcode.Call: {  	// pop arg count from stack  	ThreadState res = PushStackFrame (inst [0].GetInteger ());  	switch (res) {  	case ThreadState.Running: {  		break;  	}  	case ThreadState.Sys_Yield: {  		return ThreadState.Running;  	}  	case ThreadState.Exception: {  		_machine.SwitchThreadState (this' ThreadState.Killed);  		return ThreadState.Exception;  	}  	case ThreadState.Killed: {  		_machine.SwitchThreadState (this' ThreadState.Killed);  		break;  	}  	default: {  		break;  	}  	}  	break;  }  #region Push Operations  case ByteCode.Opcode.PushNull: {  	Push (Variable.Null);  	break;  }  case ByteCode.Opcode.PushThis: {  	Push (This);  	break;  }  case ByteCode.Opcode.PushInt0:  case ByteCode.Opcode.PushInt1:  case ByteCode.Opcode.PushInt:  case ByteCode.Opcode.PushFp:  case ByteCode.Opcode.PushStr:  case ByteCode.Opcode.PushFn: {  	Push (inst [0]);  	break;  }  case ByteCode.Opcode.PushTbl: {  	Push (new TableObject ());  	break;  }  #endregion  case ByteCode.Opcode.Ret:// Ret pushes a null   {  	Push (Variable.Null);  	ThreadState res = PopStackFrame ();  	switch (res) {  	case ThreadState.Exception:  	case ThreadState.Killed: {  		_machine.SwitchThreadState (this' res);  		return res;  	}  	default: {  		break;  	}  	}  	break;  }  case ByteCode.Opcode.Retv: {  	ThreadState res = PopStackFrame ();  	if (res == ThreadState.Killed) {  		return res;  	}  	break;  }  case ByteCode.Opcode.SetGlobal: {  	Variable v1 = inst [0];  	if (v1.Type != VariableType.String) {  		throw new Exception ("String required");  	}  	Variable v2 = _stack.Pop ();  	_machine.Globals [v1] = v2;  	break;  }  case ByteCode.Opcode.GetGlobal: {  	Variable v1 = inst [0];  	// global name  	// TODO: Check for string  	if (v1.Type != VariableType.String) {  		throw new Exception ("String required");  	}  	var global = _machine.Globals [v1];  	Push (global);  	break;  }  case ByteCode.Opcode.SetLocal: {  	int offset = inst [0].GetInteger ();  	_stack.PokeBase (offset' _stack.Pop ());  	break;  }  case ByteCode.Opcode.GetLocal: {  	int offset = inst [0].GetInteger ();  	Push (_stack.PeekBase (offset));  	break;  }  #region Operators  case ByteCode.Opcode.OpEq:  case ByteCode.Opcode.OpNeq:  case ByteCode.Opcode.OpLt:  case ByteCode.Opcode.OpLte:  case ByteCode.Opcode.OpGt:  case ByteCode.Opcode.OpGte:  case ByteCode.Opcode.OpRem:  case ByteCode.Opcode.OpAdd:  case ByteCode.Opcode.OpSub:  case ByteCode.Opcode.OpMul:  case ByteCode.Opcode.OpDiv: {  	Operator o = Operator._MAX;  	switch (inst.OpCode) {  	#region fold  	case ByteCode.Opcode.OpAdd: {  		o = Operator.Add;  		break;  	}  	case ByteCode.Opcode.OpSub: {  		o = Operator.Sub;  		break;  	}  	case ByteCode.Opcode.OpMul: {  		o = Operator.Mul;  		break;  	}  	case ByteCode.Opcode.OpDiv: {  		o = Operator.Div;  		break;  	}  	case ByteCode.Opcode.GetInd: {  		o = Operator.GetInd;  		break;  	}  	case ByteCode.Opcode.OpEq: {  		o = Operator.Eq;  		break;  	}  	case ByteCode.Opcode.OpNeq: {  		o = Operator.Neq;  		break;  	}  	case ByteCode.Opcode.OpLt: {  		o = Operator.Lt;  		break;  	}  	case ByteCode.Opcode.OpLte: {  		o = Operator.Lte;  		break;  	}  	case ByteCode.Opcode.OpGt: {  		o = Operator.Gt;  		break;  	}  	case ByteCode.Opcode.OpGte: {  		o = Operator.Gte;  		break;  	}  	case ByteCode.Opcode.OpRem: {  		o = Operator.Rem;  		break;  	}  	#endregion  	}  	if (o == Operator._MAX) {  		throw new NotImplementedException ("Operator not mapped or implemented");  	}  	var t1 = _stack.Peek (-1).TypeCode;  	var t2 = _stack.Peek (-2).TypeCode;  	if (t2 > t1) {  		t1 = t2;  	}  	OperatorCallback op = Machine.GetTypeOperator (t1' o);  	if (op != null) {  		var operand = _stack.StackPointer--;  		_stack.PokeAbs (operand - 2' op (this' _stack.PeekAbs (operand - 2)' _stack.PeekAbs (operand - 1)' _stack.PeekAbs (operand)));  	}  	else {  		throw new Exception ("Operator not defined");  	}  	break;  }  case ByteCode.Opcode.GetInd: {  	var type = _stack.Peek (-2).TypeCode;  	var op = Machine.GetTypeOperator (type' Operator.GetInd);  	if (op != null) {  		var operand = _stack.StackPointer--;  		_stack.PokeAbs (operand - 2' op (this' _stack.PeekAbs (operand - 2)' _stack.PeekAbs (operand - 1)' _stack.PeekAbs (operand)));  	}  	else {  		throw new Exception ("Operator not defined");  	}  	break;  }  case ByteCode.Opcode.SetInd: {  	var topMin3 = _stack.Peek (-3);  	OperatorCallback op = Machine.GetTypeOperator (topMin3.TypeCode' Operator.SetInd);  	if (op != null) {  		_stack.Poke (-3' op (this' topMin3' _stack.Peek (-2)' _stack.Peek (-1)));  		_stack.StackPointer -= 3;  	}  	else {  		throw new Exception ("Operator not defined");  	}  	break;  }  case ByteCode.Opcode.ForEach: {  	var topMin2 = _stack.Peek (-2);  	TypeIteratorCallback itr = Machine.GetTypeIterator (topMin2.TypeCode);  	if (itr == null) {  		_machine.Log.LogEntry ("Undefined iterator for type");  		return ThreadState.Exception;  	}  	var iteratorPos = _stack.Peek (-1).GetInteger ();  	var obj = _stack.Peek (-2).GetReference ();  	iteratorPos = itr (this' obj' iteratorPos' _stack.PeekBase (inst [1].GetInteger ())' _stack.PeekBase (inst [0].GetInteger ()));  	if (iteratorPos != -1) {  		//_Stack2[_Base + Inst[1].GetInteger()] = Key;  		//_Stack2[_Base + Inst[0].GetInteger()] = Item;  		_stack.Poke (Variable.Zero);  	}  	else {  		_stack.Poke (Variable.Zero);  	}  	_stack.Poke (-1' iteratorPos);  	++_stack.StackPointer;  	break;  }  #region Dot Operators  case ByteCode.Opcode.GetDot: {  	var v1 = _stack.Peek (-1);  	OperatorCallback op = Machine.GetTypeOperator (v1.TypeCode' Operator.GetDot);  	_stack.Poke (inst [0]);  	if (op != null) {  		_stack.Poke (-1' op (this' v1' _stack.Peek ()' _stack.Peek ()));  	}  	else {  		throw new Exception ("Operator not defined");  	}  	break;  }  case ByteCode.Opcode.SetDot: {  	var v1 = _stack.Peek (-2);  	OperatorCallback op = Machine.GetTypeOperator (v1.TypeCode' Operator.SetDot);  	_stack.Poke (inst [0]);  	if (op != null) {  		_stack.Poke (-2' op (this' _stack.Peek (-2)' _stack.Peek (-1)' _stack.Peek ()));  		_stack.StackPointer -= 2;  	}  	else {  		throw new Exception ("Operator not defined");  	}  	break;  }  #endregion  #endregion  #region Branch  case ByteCode.Opcode.Brz: {  	var v = _stack.Pop ();  	if (v.IsZero) {  		var newIp = inst [0].GetInteger ();  		if (newIp >= _instructionList.Count) {  			throw new Exception ("BRZ: Corrupt IP");  		}  		_instructionPtr = newIp;  	}  	break;  }  case ByteCode.Opcode.Brnz: {  	var v = _stack.Pop ();  	if (!v.IsZero) {  		var newIp = inst [0].GetInteger ();  		if (newIp >= _instructionList.Count) {  			throw new Exception ("BRZ: Corrupt IP");  		}  		_instructionPtr = newIp;  	}  	break;  }  case ByteCode.Opcode.Brzk: {  	var v = _stack.Peek (-1);  	if (v.IsZero) {  		var newIp = inst [0].GetInteger ();  		if (newIp >= _instructionList.Count) {  			throw new Exception ("BRZ: Corrupt IP");  		}  		_instructionPtr = newIp;  	}  	break;  }  case ByteCode.Opcode.Brnzk: {  	var v = _stack.Peek (-1);  	if (!v.IsZero) {  		var newIp = inst [0].GetInteger ();  		if (newIp >= _instructionList.Count) {  			throw new Exception ("BRNZK: Corrupt IP");  		}  		_instructionPtr = newIp;  	}  	break;  }  case ByteCode.Opcode.Bra: {  	var newIp = inst [0].GetInteger ();  	if (newIp >= _instructionList.Count) {  		throw new Exception ("BRA: Corrupt IP");  	}  	_instructionPtr = newIp;  	break;  }  #endregion  default: {  	throw new Exception ("Unknown instr");  }  }  
Magic Number,GreenBeanScript,Thread,C:\repos\evolutional_greenbeanscript\GreenBeanScript\VirtualMachine\Thread.cs,Execute,The following statement contains a magic number: switch (inst.OpCode) {  case ByteCode.Opcode.Pop: {  	_stack.Pop ();  	break;  }  case ByteCode.Opcode.Pop2: {  	_stack.Pop (2);  	break;  }  case ByteCode.Opcode.Dup: {  	_stack.Push (_stack.Peek ());  	break;  }  case ByteCode.Opcode.Call: {  	// pop arg count from stack  	ThreadState res = PushStackFrame (inst [0].GetInteger ());  	switch (res) {  	case ThreadState.Running: {  		break;  	}  	case ThreadState.Sys_Yield: {  		return ThreadState.Running;  	}  	case ThreadState.Exception: {  		_machine.SwitchThreadState (this' ThreadState.Killed);  		return ThreadState.Exception;  	}  	case ThreadState.Killed: {  		_machine.SwitchThreadState (this' ThreadState.Killed);  		break;  	}  	default: {  		break;  	}  	}  	break;  }  #region Push Operations  case ByteCode.Opcode.PushNull: {  	Push (Variable.Null);  	break;  }  case ByteCode.Opcode.PushThis: {  	Push (This);  	break;  }  case ByteCode.Opcode.PushInt0:  case ByteCode.Opcode.PushInt1:  case ByteCode.Opcode.PushInt:  case ByteCode.Opcode.PushFp:  case ByteCode.Opcode.PushStr:  case ByteCode.Opcode.PushFn: {  	Push (inst [0]);  	break;  }  case ByteCode.Opcode.PushTbl: {  	Push (new TableObject ());  	break;  }  #endregion  case ByteCode.Opcode.Ret:// Ret pushes a null   {  	Push (Variable.Null);  	ThreadState res = PopStackFrame ();  	switch (res) {  	case ThreadState.Exception:  	case ThreadState.Killed: {  		_machine.SwitchThreadState (this' res);  		return res;  	}  	default: {  		break;  	}  	}  	break;  }  case ByteCode.Opcode.Retv: {  	ThreadState res = PopStackFrame ();  	if (res == ThreadState.Killed) {  		return res;  	}  	break;  }  case ByteCode.Opcode.SetGlobal: {  	Variable v1 = inst [0];  	if (v1.Type != VariableType.String) {  		throw new Exception ("String required");  	}  	Variable v2 = _stack.Pop ();  	_machine.Globals [v1] = v2;  	break;  }  case ByteCode.Opcode.GetGlobal: {  	Variable v1 = inst [0];  	// global name  	// TODO: Check for string  	if (v1.Type != VariableType.String) {  		throw new Exception ("String required");  	}  	var global = _machine.Globals [v1];  	Push (global);  	break;  }  case ByteCode.Opcode.SetLocal: {  	int offset = inst [0].GetInteger ();  	_stack.PokeBase (offset' _stack.Pop ());  	break;  }  case ByteCode.Opcode.GetLocal: {  	int offset = inst [0].GetInteger ();  	Push (_stack.PeekBase (offset));  	break;  }  #region Operators  case ByteCode.Opcode.OpEq:  case ByteCode.Opcode.OpNeq:  case ByteCode.Opcode.OpLt:  case ByteCode.Opcode.OpLte:  case ByteCode.Opcode.OpGt:  case ByteCode.Opcode.OpGte:  case ByteCode.Opcode.OpRem:  case ByteCode.Opcode.OpAdd:  case ByteCode.Opcode.OpSub:  case ByteCode.Opcode.OpMul:  case ByteCode.Opcode.OpDiv: {  	Operator o = Operator._MAX;  	switch (inst.OpCode) {  	#region fold  	case ByteCode.Opcode.OpAdd: {  		o = Operator.Add;  		break;  	}  	case ByteCode.Opcode.OpSub: {  		o = Operator.Sub;  		break;  	}  	case ByteCode.Opcode.OpMul: {  		o = Operator.Mul;  		break;  	}  	case ByteCode.Opcode.OpDiv: {  		o = Operator.Div;  		break;  	}  	case ByteCode.Opcode.GetInd: {  		o = Operator.GetInd;  		break;  	}  	case ByteCode.Opcode.OpEq: {  		o = Operator.Eq;  		break;  	}  	case ByteCode.Opcode.OpNeq: {  		o = Operator.Neq;  		break;  	}  	case ByteCode.Opcode.OpLt: {  		o = Operator.Lt;  		break;  	}  	case ByteCode.Opcode.OpLte: {  		o = Operator.Lte;  		break;  	}  	case ByteCode.Opcode.OpGt: {  		o = Operator.Gt;  		break;  	}  	case ByteCode.Opcode.OpGte: {  		o = Operator.Gte;  		break;  	}  	case ByteCode.Opcode.OpRem: {  		o = Operator.Rem;  		break;  	}  	#endregion  	}  	if (o == Operator._MAX) {  		throw new NotImplementedException ("Operator not mapped or implemented");  	}  	var t1 = _stack.Peek (-1).TypeCode;  	var t2 = _stack.Peek (-2).TypeCode;  	if (t2 > t1) {  		t1 = t2;  	}  	OperatorCallback op = Machine.GetTypeOperator (t1' o);  	if (op != null) {  		var operand = _stack.StackPointer--;  		_stack.PokeAbs (operand - 2' op (this' _stack.PeekAbs (operand - 2)' _stack.PeekAbs (operand - 1)' _stack.PeekAbs (operand)));  	}  	else {  		throw new Exception ("Operator not defined");  	}  	break;  }  case ByteCode.Opcode.GetInd: {  	var type = _stack.Peek (-2).TypeCode;  	var op = Machine.GetTypeOperator (type' Operator.GetInd);  	if (op != null) {  		var operand = _stack.StackPointer--;  		_stack.PokeAbs (operand - 2' op (this' _stack.PeekAbs (operand - 2)' _stack.PeekAbs (operand - 1)' _stack.PeekAbs (operand)));  	}  	else {  		throw new Exception ("Operator not defined");  	}  	break;  }  case ByteCode.Opcode.SetInd: {  	var topMin3 = _stack.Peek (-3);  	OperatorCallback op = Machine.GetTypeOperator (topMin3.TypeCode' Operator.SetInd);  	if (op != null) {  		_stack.Poke (-3' op (this' topMin3' _stack.Peek (-2)' _stack.Peek (-1)));  		_stack.StackPointer -= 3;  	}  	else {  		throw new Exception ("Operator not defined");  	}  	break;  }  case ByteCode.Opcode.ForEach: {  	var topMin2 = _stack.Peek (-2);  	TypeIteratorCallback itr = Machine.GetTypeIterator (topMin2.TypeCode);  	if (itr == null) {  		_machine.Log.LogEntry ("Undefined iterator for type");  		return ThreadState.Exception;  	}  	var iteratorPos = _stack.Peek (-1).GetInteger ();  	var obj = _stack.Peek (-2).GetReference ();  	iteratorPos = itr (this' obj' iteratorPos' _stack.PeekBase (inst [1].GetInteger ())' _stack.PeekBase (inst [0].GetInteger ()));  	if (iteratorPos != -1) {  		//_Stack2[_Base + Inst[1].GetInteger()] = Key;  		//_Stack2[_Base + Inst[0].GetInteger()] = Item;  		_stack.Poke (Variable.Zero);  	}  	else {  		_stack.Poke (Variable.Zero);  	}  	_stack.Poke (-1' iteratorPos);  	++_stack.StackPointer;  	break;  }  #region Dot Operators  case ByteCode.Opcode.GetDot: {  	var v1 = _stack.Peek (-1);  	OperatorCallback op = Machine.GetTypeOperator (v1.TypeCode' Operator.GetDot);  	_stack.Poke (inst [0]);  	if (op != null) {  		_stack.Poke (-1' op (this' v1' _stack.Peek ()' _stack.Peek ()));  	}  	else {  		throw new Exception ("Operator not defined");  	}  	break;  }  case ByteCode.Opcode.SetDot: {  	var v1 = _stack.Peek (-2);  	OperatorCallback op = Machine.GetTypeOperator (v1.TypeCode' Operator.SetDot);  	_stack.Poke (inst [0]);  	if (op != null) {  		_stack.Poke (-2' op (this' _stack.Peek (-2)' _stack.Peek (-1)' _stack.Peek ()));  		_stack.StackPointer -= 2;  	}  	else {  		throw new Exception ("Operator not defined");  	}  	break;  }  #endregion  #endregion  #region Branch  case ByteCode.Opcode.Brz: {  	var v = _stack.Pop ();  	if (v.IsZero) {  		var newIp = inst [0].GetInteger ();  		if (newIp >= _instructionList.Count) {  			throw new Exception ("BRZ: Corrupt IP");  		}  		_instructionPtr = newIp;  	}  	break;  }  case ByteCode.Opcode.Brnz: {  	var v = _stack.Pop ();  	if (!v.IsZero) {  		var newIp = inst [0].GetInteger ();  		if (newIp >= _instructionList.Count) {  			throw new Exception ("BRZ: Corrupt IP");  		}  		_instructionPtr = newIp;  	}  	break;  }  case ByteCode.Opcode.Brzk: {  	var v = _stack.Peek (-1);  	if (v.IsZero) {  		var newIp = inst [0].GetInteger ();  		if (newIp >= _instructionList.Count) {  			throw new Exception ("BRZ: Corrupt IP");  		}  		_instructionPtr = newIp;  	}  	break;  }  case ByteCode.Opcode.Brnzk: {  	var v = _stack.Peek (-1);  	if (!v.IsZero) {  		var newIp = inst [0].GetInteger ();  		if (newIp >= _instructionList.Count) {  			throw new Exception ("BRNZK: Corrupt IP");  		}  		_instructionPtr = newIp;  	}  	break;  }  case ByteCode.Opcode.Bra: {  	var newIp = inst [0].GetInteger ();  	if (newIp >= _instructionList.Count) {  		throw new Exception ("BRA: Corrupt IP");  	}  	_instructionPtr = newIp;  	break;  }  #endregion  default: {  	throw new Exception ("Unknown instr");  }  }  
Magic Number,GreenBeanScript,Thread,C:\repos\evolutional_greenbeanscript\GreenBeanScript\VirtualMachine\Thread.cs,Execute,The following statement contains a magic number: switch (inst.OpCode) {  case ByteCode.Opcode.Pop: {  	_stack.Pop ();  	break;  }  case ByteCode.Opcode.Pop2: {  	_stack.Pop (2);  	break;  }  case ByteCode.Opcode.Dup: {  	_stack.Push (_stack.Peek ());  	break;  }  case ByteCode.Opcode.Call: {  	// pop arg count from stack  	ThreadState res = PushStackFrame (inst [0].GetInteger ());  	switch (res) {  	case ThreadState.Running: {  		break;  	}  	case ThreadState.Sys_Yield: {  		return ThreadState.Running;  	}  	case ThreadState.Exception: {  		_machine.SwitchThreadState (this' ThreadState.Killed);  		return ThreadState.Exception;  	}  	case ThreadState.Killed: {  		_machine.SwitchThreadState (this' ThreadState.Killed);  		break;  	}  	default: {  		break;  	}  	}  	break;  }  #region Push Operations  case ByteCode.Opcode.PushNull: {  	Push (Variable.Null);  	break;  }  case ByteCode.Opcode.PushThis: {  	Push (This);  	break;  }  case ByteCode.Opcode.PushInt0:  case ByteCode.Opcode.PushInt1:  case ByteCode.Opcode.PushInt:  case ByteCode.Opcode.PushFp:  case ByteCode.Opcode.PushStr:  case ByteCode.Opcode.PushFn: {  	Push (inst [0]);  	break;  }  case ByteCode.Opcode.PushTbl: {  	Push (new TableObject ());  	break;  }  #endregion  case ByteCode.Opcode.Ret:// Ret pushes a null   {  	Push (Variable.Null);  	ThreadState res = PopStackFrame ();  	switch (res) {  	case ThreadState.Exception:  	case ThreadState.Killed: {  		_machine.SwitchThreadState (this' res);  		return res;  	}  	default: {  		break;  	}  	}  	break;  }  case ByteCode.Opcode.Retv: {  	ThreadState res = PopStackFrame ();  	if (res == ThreadState.Killed) {  		return res;  	}  	break;  }  case ByteCode.Opcode.SetGlobal: {  	Variable v1 = inst [0];  	if (v1.Type != VariableType.String) {  		throw new Exception ("String required");  	}  	Variable v2 = _stack.Pop ();  	_machine.Globals [v1] = v2;  	break;  }  case ByteCode.Opcode.GetGlobal: {  	Variable v1 = inst [0];  	// global name  	// TODO: Check for string  	if (v1.Type != VariableType.String) {  		throw new Exception ("String required");  	}  	var global = _machine.Globals [v1];  	Push (global);  	break;  }  case ByteCode.Opcode.SetLocal: {  	int offset = inst [0].GetInteger ();  	_stack.PokeBase (offset' _stack.Pop ());  	break;  }  case ByteCode.Opcode.GetLocal: {  	int offset = inst [0].GetInteger ();  	Push (_stack.PeekBase (offset));  	break;  }  #region Operators  case ByteCode.Opcode.OpEq:  case ByteCode.Opcode.OpNeq:  case ByteCode.Opcode.OpLt:  case ByteCode.Opcode.OpLte:  case ByteCode.Opcode.OpGt:  case ByteCode.Opcode.OpGte:  case ByteCode.Opcode.OpRem:  case ByteCode.Opcode.OpAdd:  case ByteCode.Opcode.OpSub:  case ByteCode.Opcode.OpMul:  case ByteCode.Opcode.OpDiv: {  	Operator o = Operator._MAX;  	switch (inst.OpCode) {  	#region fold  	case ByteCode.Opcode.OpAdd: {  		o = Operator.Add;  		break;  	}  	case ByteCode.Opcode.OpSub: {  		o = Operator.Sub;  		break;  	}  	case ByteCode.Opcode.OpMul: {  		o = Operator.Mul;  		break;  	}  	case ByteCode.Opcode.OpDiv: {  		o = Operator.Div;  		break;  	}  	case ByteCode.Opcode.GetInd: {  		o = Operator.GetInd;  		break;  	}  	case ByteCode.Opcode.OpEq: {  		o = Operator.Eq;  		break;  	}  	case ByteCode.Opcode.OpNeq: {  		o = Operator.Neq;  		break;  	}  	case ByteCode.Opcode.OpLt: {  		o = Operator.Lt;  		break;  	}  	case ByteCode.Opcode.OpLte: {  		o = Operator.Lte;  		break;  	}  	case ByteCode.Opcode.OpGt: {  		o = Operator.Gt;  		break;  	}  	case ByteCode.Opcode.OpGte: {  		o = Operator.Gte;  		break;  	}  	case ByteCode.Opcode.OpRem: {  		o = Operator.Rem;  		break;  	}  	#endregion  	}  	if (o == Operator._MAX) {  		throw new NotImplementedException ("Operator not mapped or implemented");  	}  	var t1 = _stack.Peek (-1).TypeCode;  	var t2 = _stack.Peek (-2).TypeCode;  	if (t2 > t1) {  		t1 = t2;  	}  	OperatorCallback op = Machine.GetTypeOperator (t1' o);  	if (op != null) {  		var operand = _stack.StackPointer--;  		_stack.PokeAbs (operand - 2' op (this' _stack.PeekAbs (operand - 2)' _stack.PeekAbs (operand - 1)' _stack.PeekAbs (operand)));  	}  	else {  		throw new Exception ("Operator not defined");  	}  	break;  }  case ByteCode.Opcode.GetInd: {  	var type = _stack.Peek (-2).TypeCode;  	var op = Machine.GetTypeOperator (type' Operator.GetInd);  	if (op != null) {  		var operand = _stack.StackPointer--;  		_stack.PokeAbs (operand - 2' op (this' _stack.PeekAbs (operand - 2)' _stack.PeekAbs (operand - 1)' _stack.PeekAbs (operand)));  	}  	else {  		throw new Exception ("Operator not defined");  	}  	break;  }  case ByteCode.Opcode.SetInd: {  	var topMin3 = _stack.Peek (-3);  	OperatorCallback op = Machine.GetTypeOperator (topMin3.TypeCode' Operator.SetInd);  	if (op != null) {  		_stack.Poke (-3' op (this' topMin3' _stack.Peek (-2)' _stack.Peek (-1)));  		_stack.StackPointer -= 3;  	}  	else {  		throw new Exception ("Operator not defined");  	}  	break;  }  case ByteCode.Opcode.ForEach: {  	var topMin2 = _stack.Peek (-2);  	TypeIteratorCallback itr = Machine.GetTypeIterator (topMin2.TypeCode);  	if (itr == null) {  		_machine.Log.LogEntry ("Undefined iterator for type");  		return ThreadState.Exception;  	}  	var iteratorPos = _stack.Peek (-1).GetInteger ();  	var obj = _stack.Peek (-2).GetReference ();  	iteratorPos = itr (this' obj' iteratorPos' _stack.PeekBase (inst [1].GetInteger ())' _stack.PeekBase (inst [0].GetInteger ()));  	if (iteratorPos != -1) {  		//_Stack2[_Base + Inst[1].GetInteger()] = Key;  		//_Stack2[_Base + Inst[0].GetInteger()] = Item;  		_stack.Poke (Variable.Zero);  	}  	else {  		_stack.Poke (Variable.Zero);  	}  	_stack.Poke (-1' iteratorPos);  	++_stack.StackPointer;  	break;  }  #region Dot Operators  case ByteCode.Opcode.GetDot: {  	var v1 = _stack.Peek (-1);  	OperatorCallback op = Machine.GetTypeOperator (v1.TypeCode' Operator.GetDot);  	_stack.Poke (inst [0]);  	if (op != null) {  		_stack.Poke (-1' op (this' v1' _stack.Peek ()' _stack.Peek ()));  	}  	else {  		throw new Exception ("Operator not defined");  	}  	break;  }  case ByteCode.Opcode.SetDot: {  	var v1 = _stack.Peek (-2);  	OperatorCallback op = Machine.GetTypeOperator (v1.TypeCode' Operator.SetDot);  	_stack.Poke (inst [0]);  	if (op != null) {  		_stack.Poke (-2' op (this' _stack.Peek (-2)' _stack.Peek (-1)' _stack.Peek ()));  		_stack.StackPointer -= 2;  	}  	else {  		throw new Exception ("Operator not defined");  	}  	break;  }  #endregion  #endregion  #region Branch  case ByteCode.Opcode.Brz: {  	var v = _stack.Pop ();  	if (v.IsZero) {  		var newIp = inst [0].GetInteger ();  		if (newIp >= _instructionList.Count) {  			throw new Exception ("BRZ: Corrupt IP");  		}  		_instructionPtr = newIp;  	}  	break;  }  case ByteCode.Opcode.Brnz: {  	var v = _stack.Pop ();  	if (!v.IsZero) {  		var newIp = inst [0].GetInteger ();  		if (newIp >= _instructionList.Count) {  			throw new Exception ("BRZ: Corrupt IP");  		}  		_instructionPtr = newIp;  	}  	break;  }  case ByteCode.Opcode.Brzk: {  	var v = _stack.Peek (-1);  	if (v.IsZero) {  		var newIp = inst [0].GetInteger ();  		if (newIp >= _instructionList.Count) {  			throw new Exception ("BRZ: Corrupt IP");  		}  		_instructionPtr = newIp;  	}  	break;  }  case ByteCode.Opcode.Brnzk: {  	var v = _stack.Peek (-1);  	if (!v.IsZero) {  		var newIp = inst [0].GetInteger ();  		if (newIp >= _instructionList.Count) {  			throw new Exception ("BRNZK: Corrupt IP");  		}  		_instructionPtr = newIp;  	}  	break;  }  case ByteCode.Opcode.Bra: {  	var newIp = inst [0].GetInteger ();  	if (newIp >= _instructionList.Count) {  		throw new Exception ("BRA: Corrupt IP");  	}  	_instructionPtr = newIp;  	break;  }  #endregion  default: {  	throw new Exception ("Unknown instr");  }  }  
Magic Number,GreenBeanScript,Thread,C:\repos\evolutional_greenbeanscript\GreenBeanScript\VirtualMachine\Thread.cs,Execute,The following statement contains a magic number: switch (inst.OpCode) {  case ByteCode.Opcode.Pop: {  	_stack.Pop ();  	break;  }  case ByteCode.Opcode.Pop2: {  	_stack.Pop (2);  	break;  }  case ByteCode.Opcode.Dup: {  	_stack.Push (_stack.Peek ());  	break;  }  case ByteCode.Opcode.Call: {  	// pop arg count from stack  	ThreadState res = PushStackFrame (inst [0].GetInteger ());  	switch (res) {  	case ThreadState.Running: {  		break;  	}  	case ThreadState.Sys_Yield: {  		return ThreadState.Running;  	}  	case ThreadState.Exception: {  		_machine.SwitchThreadState (this' ThreadState.Killed);  		return ThreadState.Exception;  	}  	case ThreadState.Killed: {  		_machine.SwitchThreadState (this' ThreadState.Killed);  		break;  	}  	default: {  		break;  	}  	}  	break;  }  #region Push Operations  case ByteCode.Opcode.PushNull: {  	Push (Variable.Null);  	break;  }  case ByteCode.Opcode.PushThis: {  	Push (This);  	break;  }  case ByteCode.Opcode.PushInt0:  case ByteCode.Opcode.PushInt1:  case ByteCode.Opcode.PushInt:  case ByteCode.Opcode.PushFp:  case ByteCode.Opcode.PushStr:  case ByteCode.Opcode.PushFn: {  	Push (inst [0]);  	break;  }  case ByteCode.Opcode.PushTbl: {  	Push (new TableObject ());  	break;  }  #endregion  case ByteCode.Opcode.Ret:// Ret pushes a null   {  	Push (Variable.Null);  	ThreadState res = PopStackFrame ();  	switch (res) {  	case ThreadState.Exception:  	case ThreadState.Killed: {  		_machine.SwitchThreadState (this' res);  		return res;  	}  	default: {  		break;  	}  	}  	break;  }  case ByteCode.Opcode.Retv: {  	ThreadState res = PopStackFrame ();  	if (res == ThreadState.Killed) {  		return res;  	}  	break;  }  case ByteCode.Opcode.SetGlobal: {  	Variable v1 = inst [0];  	if (v1.Type != VariableType.String) {  		throw new Exception ("String required");  	}  	Variable v2 = _stack.Pop ();  	_machine.Globals [v1] = v2;  	break;  }  case ByteCode.Opcode.GetGlobal: {  	Variable v1 = inst [0];  	// global name  	// TODO: Check for string  	if (v1.Type != VariableType.String) {  		throw new Exception ("String required");  	}  	var global = _machine.Globals [v1];  	Push (global);  	break;  }  case ByteCode.Opcode.SetLocal: {  	int offset = inst [0].GetInteger ();  	_stack.PokeBase (offset' _stack.Pop ());  	break;  }  case ByteCode.Opcode.GetLocal: {  	int offset = inst [0].GetInteger ();  	Push (_stack.PeekBase (offset));  	break;  }  #region Operators  case ByteCode.Opcode.OpEq:  case ByteCode.Opcode.OpNeq:  case ByteCode.Opcode.OpLt:  case ByteCode.Opcode.OpLte:  case ByteCode.Opcode.OpGt:  case ByteCode.Opcode.OpGte:  case ByteCode.Opcode.OpRem:  case ByteCode.Opcode.OpAdd:  case ByteCode.Opcode.OpSub:  case ByteCode.Opcode.OpMul:  case ByteCode.Opcode.OpDiv: {  	Operator o = Operator._MAX;  	switch (inst.OpCode) {  	#region fold  	case ByteCode.Opcode.OpAdd: {  		o = Operator.Add;  		break;  	}  	case ByteCode.Opcode.OpSub: {  		o = Operator.Sub;  		break;  	}  	case ByteCode.Opcode.OpMul: {  		o = Operator.Mul;  		break;  	}  	case ByteCode.Opcode.OpDiv: {  		o = Operator.Div;  		break;  	}  	case ByteCode.Opcode.GetInd: {  		o = Operator.GetInd;  		break;  	}  	case ByteCode.Opcode.OpEq: {  		o = Operator.Eq;  		break;  	}  	case ByteCode.Opcode.OpNeq: {  		o = Operator.Neq;  		break;  	}  	case ByteCode.Opcode.OpLt: {  		o = Operator.Lt;  		break;  	}  	case ByteCode.Opcode.OpLte: {  		o = Operator.Lte;  		break;  	}  	case ByteCode.Opcode.OpGt: {  		o = Operator.Gt;  		break;  	}  	case ByteCode.Opcode.OpGte: {  		o = Operator.Gte;  		break;  	}  	case ByteCode.Opcode.OpRem: {  		o = Operator.Rem;  		break;  	}  	#endregion  	}  	if (o == Operator._MAX) {  		throw new NotImplementedException ("Operator not mapped or implemented");  	}  	var t1 = _stack.Peek (-1).TypeCode;  	var t2 = _stack.Peek (-2).TypeCode;  	if (t2 > t1) {  		t1 = t2;  	}  	OperatorCallback op = Machine.GetTypeOperator (t1' o);  	if (op != null) {  		var operand = _stack.StackPointer--;  		_stack.PokeAbs (operand - 2' op (this' _stack.PeekAbs (operand - 2)' _stack.PeekAbs (operand - 1)' _stack.PeekAbs (operand)));  	}  	else {  		throw new Exception ("Operator not defined");  	}  	break;  }  case ByteCode.Opcode.GetInd: {  	var type = _stack.Peek (-2).TypeCode;  	var op = Machine.GetTypeOperator (type' Operator.GetInd);  	if (op != null) {  		var operand = _stack.StackPointer--;  		_stack.PokeAbs (operand - 2' op (this' _stack.PeekAbs (operand - 2)' _stack.PeekAbs (operand - 1)' _stack.PeekAbs (operand)));  	}  	else {  		throw new Exception ("Operator not defined");  	}  	break;  }  case ByteCode.Opcode.SetInd: {  	var topMin3 = _stack.Peek (-3);  	OperatorCallback op = Machine.GetTypeOperator (topMin3.TypeCode' Operator.SetInd);  	if (op != null) {  		_stack.Poke (-3' op (this' topMin3' _stack.Peek (-2)' _stack.Peek (-1)));  		_stack.StackPointer -= 3;  	}  	else {  		throw new Exception ("Operator not defined");  	}  	break;  }  case ByteCode.Opcode.ForEach: {  	var topMin2 = _stack.Peek (-2);  	TypeIteratorCallback itr = Machine.GetTypeIterator (topMin2.TypeCode);  	if (itr == null) {  		_machine.Log.LogEntry ("Undefined iterator for type");  		return ThreadState.Exception;  	}  	var iteratorPos = _stack.Peek (-1).GetInteger ();  	var obj = _stack.Peek (-2).GetReference ();  	iteratorPos = itr (this' obj' iteratorPos' _stack.PeekBase (inst [1].GetInteger ())' _stack.PeekBase (inst [0].GetInteger ()));  	if (iteratorPos != -1) {  		//_Stack2[_Base + Inst[1].GetInteger()] = Key;  		//_Stack2[_Base + Inst[0].GetInteger()] = Item;  		_stack.Poke (Variable.Zero);  	}  	else {  		_stack.Poke (Variable.Zero);  	}  	_stack.Poke (-1' iteratorPos);  	++_stack.StackPointer;  	break;  }  #region Dot Operators  case ByteCode.Opcode.GetDot: {  	var v1 = _stack.Peek (-1);  	OperatorCallback op = Machine.GetTypeOperator (v1.TypeCode' Operator.GetDot);  	_stack.Poke (inst [0]);  	if (op != null) {  		_stack.Poke (-1' op (this' v1' _stack.Peek ()' _stack.Peek ()));  	}  	else {  		throw new Exception ("Operator not defined");  	}  	break;  }  case ByteCode.Opcode.SetDot: {  	var v1 = _stack.Peek (-2);  	OperatorCallback op = Machine.GetTypeOperator (v1.TypeCode' Operator.SetDot);  	_stack.Poke (inst [0]);  	if (op != null) {  		_stack.Poke (-2' op (this' _stack.Peek (-2)' _stack.Peek (-1)' _stack.Peek ()));  		_stack.StackPointer -= 2;  	}  	else {  		throw new Exception ("Operator not defined");  	}  	break;  }  #endregion  #endregion  #region Branch  case ByteCode.Opcode.Brz: {  	var v = _stack.Pop ();  	if (v.IsZero) {  		var newIp = inst [0].GetInteger ();  		if (newIp >= _instructionList.Count) {  			throw new Exception ("BRZ: Corrupt IP");  		}  		_instructionPtr = newIp;  	}  	break;  }  case ByteCode.Opcode.Brnz: {  	var v = _stack.Pop ();  	if (!v.IsZero) {  		var newIp = inst [0].GetInteger ();  		if (newIp >= _instructionList.Count) {  			throw new Exception ("BRZ: Corrupt IP");  		}  		_instructionPtr = newIp;  	}  	break;  }  case ByteCode.Opcode.Brzk: {  	var v = _stack.Peek (-1);  	if (v.IsZero) {  		var newIp = inst [0].GetInteger ();  		if (newIp >= _instructionList.Count) {  			throw new Exception ("BRZ: Corrupt IP");  		}  		_instructionPtr = newIp;  	}  	break;  }  case ByteCode.Opcode.Brnzk: {  	var v = _stack.Peek (-1);  	if (!v.IsZero) {  		var newIp = inst [0].GetInteger ();  		if (newIp >= _instructionList.Count) {  			throw new Exception ("BRNZK: Corrupt IP");  		}  		_instructionPtr = newIp;  	}  	break;  }  case ByteCode.Opcode.Bra: {  	var newIp = inst [0].GetInteger ();  	if (newIp >= _instructionList.Count) {  		throw new Exception ("BRA: Corrupt IP");  	}  	_instructionPtr = newIp;  	break;  }  #endregion  default: {  	throw new Exception ("Unknown instr");  }  }  
Magic Number,GreenBeanScript,Thread,C:\repos\evolutional_greenbeanscript\GreenBeanScript\VirtualMachine\Thread.cs,Execute,The following statement contains a magic number: switch (inst.OpCode) {  case ByteCode.Opcode.Pop: {  	_stack.Pop ();  	break;  }  case ByteCode.Opcode.Pop2: {  	_stack.Pop (2);  	break;  }  case ByteCode.Opcode.Dup: {  	_stack.Push (_stack.Peek ());  	break;  }  case ByteCode.Opcode.Call: {  	// pop arg count from stack  	ThreadState res = PushStackFrame (inst [0].GetInteger ());  	switch (res) {  	case ThreadState.Running: {  		break;  	}  	case ThreadState.Sys_Yield: {  		return ThreadState.Running;  	}  	case ThreadState.Exception: {  		_machine.SwitchThreadState (this' ThreadState.Killed);  		return ThreadState.Exception;  	}  	case ThreadState.Killed: {  		_machine.SwitchThreadState (this' ThreadState.Killed);  		break;  	}  	default: {  		break;  	}  	}  	break;  }  #region Push Operations  case ByteCode.Opcode.PushNull: {  	Push (Variable.Null);  	break;  }  case ByteCode.Opcode.PushThis: {  	Push (This);  	break;  }  case ByteCode.Opcode.PushInt0:  case ByteCode.Opcode.PushInt1:  case ByteCode.Opcode.PushInt:  case ByteCode.Opcode.PushFp:  case ByteCode.Opcode.PushStr:  case ByteCode.Opcode.PushFn: {  	Push (inst [0]);  	break;  }  case ByteCode.Opcode.PushTbl: {  	Push (new TableObject ());  	break;  }  #endregion  case ByteCode.Opcode.Ret:// Ret pushes a null   {  	Push (Variable.Null);  	ThreadState res = PopStackFrame ();  	switch (res) {  	case ThreadState.Exception:  	case ThreadState.Killed: {  		_machine.SwitchThreadState (this' res);  		return res;  	}  	default: {  		break;  	}  	}  	break;  }  case ByteCode.Opcode.Retv: {  	ThreadState res = PopStackFrame ();  	if (res == ThreadState.Killed) {  		return res;  	}  	break;  }  case ByteCode.Opcode.SetGlobal: {  	Variable v1 = inst [0];  	if (v1.Type != VariableType.String) {  		throw new Exception ("String required");  	}  	Variable v2 = _stack.Pop ();  	_machine.Globals [v1] = v2;  	break;  }  case ByteCode.Opcode.GetGlobal: {  	Variable v1 = inst [0];  	// global name  	// TODO: Check for string  	if (v1.Type != VariableType.String) {  		throw new Exception ("String required");  	}  	var global = _machine.Globals [v1];  	Push (global);  	break;  }  case ByteCode.Opcode.SetLocal: {  	int offset = inst [0].GetInteger ();  	_stack.PokeBase (offset' _stack.Pop ());  	break;  }  case ByteCode.Opcode.GetLocal: {  	int offset = inst [0].GetInteger ();  	Push (_stack.PeekBase (offset));  	break;  }  #region Operators  case ByteCode.Opcode.OpEq:  case ByteCode.Opcode.OpNeq:  case ByteCode.Opcode.OpLt:  case ByteCode.Opcode.OpLte:  case ByteCode.Opcode.OpGt:  case ByteCode.Opcode.OpGte:  case ByteCode.Opcode.OpRem:  case ByteCode.Opcode.OpAdd:  case ByteCode.Opcode.OpSub:  case ByteCode.Opcode.OpMul:  case ByteCode.Opcode.OpDiv: {  	Operator o = Operator._MAX;  	switch (inst.OpCode) {  	#region fold  	case ByteCode.Opcode.OpAdd: {  		o = Operator.Add;  		break;  	}  	case ByteCode.Opcode.OpSub: {  		o = Operator.Sub;  		break;  	}  	case ByteCode.Opcode.OpMul: {  		o = Operator.Mul;  		break;  	}  	case ByteCode.Opcode.OpDiv: {  		o = Operator.Div;  		break;  	}  	case ByteCode.Opcode.GetInd: {  		o = Operator.GetInd;  		break;  	}  	case ByteCode.Opcode.OpEq: {  		o = Operator.Eq;  		break;  	}  	case ByteCode.Opcode.OpNeq: {  		o = Operator.Neq;  		break;  	}  	case ByteCode.Opcode.OpLt: {  		o = Operator.Lt;  		break;  	}  	case ByteCode.Opcode.OpLte: {  		o = Operator.Lte;  		break;  	}  	case ByteCode.Opcode.OpGt: {  		o = Operator.Gt;  		break;  	}  	case ByteCode.Opcode.OpGte: {  		o = Operator.Gte;  		break;  	}  	case ByteCode.Opcode.OpRem: {  		o = Operator.Rem;  		break;  	}  	#endregion  	}  	if (o == Operator._MAX) {  		throw new NotImplementedException ("Operator not mapped or implemented");  	}  	var t1 = _stack.Peek (-1).TypeCode;  	var t2 = _stack.Peek (-2).TypeCode;  	if (t2 > t1) {  		t1 = t2;  	}  	OperatorCallback op = Machine.GetTypeOperator (t1' o);  	if (op != null) {  		var operand = _stack.StackPointer--;  		_stack.PokeAbs (operand - 2' op (this' _stack.PeekAbs (operand - 2)' _stack.PeekAbs (operand - 1)' _stack.PeekAbs (operand)));  	}  	else {  		throw new Exception ("Operator not defined");  	}  	break;  }  case ByteCode.Opcode.GetInd: {  	var type = _stack.Peek (-2).TypeCode;  	var op = Machine.GetTypeOperator (type' Operator.GetInd);  	if (op != null) {  		var operand = _stack.StackPointer--;  		_stack.PokeAbs (operand - 2' op (this' _stack.PeekAbs (operand - 2)' _stack.PeekAbs (operand - 1)' _stack.PeekAbs (operand)));  	}  	else {  		throw new Exception ("Operator not defined");  	}  	break;  }  case ByteCode.Opcode.SetInd: {  	var topMin3 = _stack.Peek (-3);  	OperatorCallback op = Machine.GetTypeOperator (topMin3.TypeCode' Operator.SetInd);  	if (op != null) {  		_stack.Poke (-3' op (this' topMin3' _stack.Peek (-2)' _stack.Peek (-1)));  		_stack.StackPointer -= 3;  	}  	else {  		throw new Exception ("Operator not defined");  	}  	break;  }  case ByteCode.Opcode.ForEach: {  	var topMin2 = _stack.Peek (-2);  	TypeIteratorCallback itr = Machine.GetTypeIterator (topMin2.TypeCode);  	if (itr == null) {  		_machine.Log.LogEntry ("Undefined iterator for type");  		return ThreadState.Exception;  	}  	var iteratorPos = _stack.Peek (-1).GetInteger ();  	var obj = _stack.Peek (-2).GetReference ();  	iteratorPos = itr (this' obj' iteratorPos' _stack.PeekBase (inst [1].GetInteger ())' _stack.PeekBase (inst [0].GetInteger ()));  	if (iteratorPos != -1) {  		//_Stack2[_Base + Inst[1].GetInteger()] = Key;  		//_Stack2[_Base + Inst[0].GetInteger()] = Item;  		_stack.Poke (Variable.Zero);  	}  	else {  		_stack.Poke (Variable.Zero);  	}  	_stack.Poke (-1' iteratorPos);  	++_stack.StackPointer;  	break;  }  #region Dot Operators  case ByteCode.Opcode.GetDot: {  	var v1 = _stack.Peek (-1);  	OperatorCallback op = Machine.GetTypeOperator (v1.TypeCode' Operator.GetDot);  	_stack.Poke (inst [0]);  	if (op != null) {  		_stack.Poke (-1' op (this' v1' _stack.Peek ()' _stack.Peek ()));  	}  	else {  		throw new Exception ("Operator not defined");  	}  	break;  }  case ByteCode.Opcode.SetDot: {  	var v1 = _stack.Peek (-2);  	OperatorCallback op = Machine.GetTypeOperator (v1.TypeCode' Operator.SetDot);  	_stack.Poke (inst [0]);  	if (op != null) {  		_stack.Poke (-2' op (this' _stack.Peek (-2)' _stack.Peek (-1)' _stack.Peek ()));  		_stack.StackPointer -= 2;  	}  	else {  		throw new Exception ("Operator not defined");  	}  	break;  }  #endregion  #endregion  #region Branch  case ByteCode.Opcode.Brz: {  	var v = _stack.Pop ();  	if (v.IsZero) {  		var newIp = inst [0].GetInteger ();  		if (newIp >= _instructionList.Count) {  			throw new Exception ("BRZ: Corrupt IP");  		}  		_instructionPtr = newIp;  	}  	break;  }  case ByteCode.Opcode.Brnz: {  	var v = _stack.Pop ();  	if (!v.IsZero) {  		var newIp = inst [0].GetInteger ();  		if (newIp >= _instructionList.Count) {  			throw new Exception ("BRZ: Corrupt IP");  		}  		_instructionPtr = newIp;  	}  	break;  }  case ByteCode.Opcode.Brzk: {  	var v = _stack.Peek (-1);  	if (v.IsZero) {  		var newIp = inst [0].GetInteger ();  		if (newIp >= _instructionList.Count) {  			throw new Exception ("BRZ: Corrupt IP");  		}  		_instructionPtr = newIp;  	}  	break;  }  case ByteCode.Opcode.Brnzk: {  	var v = _stack.Peek (-1);  	if (!v.IsZero) {  		var newIp = inst [0].GetInteger ();  		if (newIp >= _instructionList.Count) {  			throw new Exception ("BRNZK: Corrupt IP");  		}  		_instructionPtr = newIp;  	}  	break;  }  case ByteCode.Opcode.Bra: {  	var newIp = inst [0].GetInteger ();  	if (newIp >= _instructionList.Count) {  		throw new Exception ("BRA: Corrupt IP");  	}  	_instructionPtr = newIp;  	break;  }  #endregion  default: {  	throw new Exception ("Unknown instr");  }  }  
Magic Number,GreenBeanScript,Thread,C:\repos\evolutional_greenbeanscript\GreenBeanScript\VirtualMachine\Thread.cs,Execute,The following statement contains a magic number: switch (inst.OpCode) {  case ByteCode.Opcode.Pop: {  	_stack.Pop ();  	break;  }  case ByteCode.Opcode.Pop2: {  	_stack.Pop (2);  	break;  }  case ByteCode.Opcode.Dup: {  	_stack.Push (_stack.Peek ());  	break;  }  case ByteCode.Opcode.Call: {  	// pop arg count from stack  	ThreadState res = PushStackFrame (inst [0].GetInteger ());  	switch (res) {  	case ThreadState.Running: {  		break;  	}  	case ThreadState.Sys_Yield: {  		return ThreadState.Running;  	}  	case ThreadState.Exception: {  		_machine.SwitchThreadState (this' ThreadState.Killed);  		return ThreadState.Exception;  	}  	case ThreadState.Killed: {  		_machine.SwitchThreadState (this' ThreadState.Killed);  		break;  	}  	default: {  		break;  	}  	}  	break;  }  #region Push Operations  case ByteCode.Opcode.PushNull: {  	Push (Variable.Null);  	break;  }  case ByteCode.Opcode.PushThis: {  	Push (This);  	break;  }  case ByteCode.Opcode.PushInt0:  case ByteCode.Opcode.PushInt1:  case ByteCode.Opcode.PushInt:  case ByteCode.Opcode.PushFp:  case ByteCode.Opcode.PushStr:  case ByteCode.Opcode.PushFn: {  	Push (inst [0]);  	break;  }  case ByteCode.Opcode.PushTbl: {  	Push (new TableObject ());  	break;  }  #endregion  case ByteCode.Opcode.Ret:// Ret pushes a null   {  	Push (Variable.Null);  	ThreadState res = PopStackFrame ();  	switch (res) {  	case ThreadState.Exception:  	case ThreadState.Killed: {  		_machine.SwitchThreadState (this' res);  		return res;  	}  	default: {  		break;  	}  	}  	break;  }  case ByteCode.Opcode.Retv: {  	ThreadState res = PopStackFrame ();  	if (res == ThreadState.Killed) {  		return res;  	}  	break;  }  case ByteCode.Opcode.SetGlobal: {  	Variable v1 = inst [0];  	if (v1.Type != VariableType.String) {  		throw new Exception ("String required");  	}  	Variable v2 = _stack.Pop ();  	_machine.Globals [v1] = v2;  	break;  }  case ByteCode.Opcode.GetGlobal: {  	Variable v1 = inst [0];  	// global name  	// TODO: Check for string  	if (v1.Type != VariableType.String) {  		throw new Exception ("String required");  	}  	var global = _machine.Globals [v1];  	Push (global);  	break;  }  case ByteCode.Opcode.SetLocal: {  	int offset = inst [0].GetInteger ();  	_stack.PokeBase (offset' _stack.Pop ());  	break;  }  case ByteCode.Opcode.GetLocal: {  	int offset = inst [0].GetInteger ();  	Push (_stack.PeekBase (offset));  	break;  }  #region Operators  case ByteCode.Opcode.OpEq:  case ByteCode.Opcode.OpNeq:  case ByteCode.Opcode.OpLt:  case ByteCode.Opcode.OpLte:  case ByteCode.Opcode.OpGt:  case ByteCode.Opcode.OpGte:  case ByteCode.Opcode.OpRem:  case ByteCode.Opcode.OpAdd:  case ByteCode.Opcode.OpSub:  case ByteCode.Opcode.OpMul:  case ByteCode.Opcode.OpDiv: {  	Operator o = Operator._MAX;  	switch (inst.OpCode) {  	#region fold  	case ByteCode.Opcode.OpAdd: {  		o = Operator.Add;  		break;  	}  	case ByteCode.Opcode.OpSub: {  		o = Operator.Sub;  		break;  	}  	case ByteCode.Opcode.OpMul: {  		o = Operator.Mul;  		break;  	}  	case ByteCode.Opcode.OpDiv: {  		o = Operator.Div;  		break;  	}  	case ByteCode.Opcode.GetInd: {  		o = Operator.GetInd;  		break;  	}  	case ByteCode.Opcode.OpEq: {  		o = Operator.Eq;  		break;  	}  	case ByteCode.Opcode.OpNeq: {  		o = Operator.Neq;  		break;  	}  	case ByteCode.Opcode.OpLt: {  		o = Operator.Lt;  		break;  	}  	case ByteCode.Opcode.OpLte: {  		o = Operator.Lte;  		break;  	}  	case ByteCode.Opcode.OpGt: {  		o = Operator.Gt;  		break;  	}  	case ByteCode.Opcode.OpGte: {  		o = Operator.Gte;  		break;  	}  	case ByteCode.Opcode.OpRem: {  		o = Operator.Rem;  		break;  	}  	#endregion  	}  	if (o == Operator._MAX) {  		throw new NotImplementedException ("Operator not mapped or implemented");  	}  	var t1 = _stack.Peek (-1).TypeCode;  	var t2 = _stack.Peek (-2).TypeCode;  	if (t2 > t1) {  		t1 = t2;  	}  	OperatorCallback op = Machine.GetTypeOperator (t1' o);  	if (op != null) {  		var operand = _stack.StackPointer--;  		_stack.PokeAbs (operand - 2' op (this' _stack.PeekAbs (operand - 2)' _stack.PeekAbs (operand - 1)' _stack.PeekAbs (operand)));  	}  	else {  		throw new Exception ("Operator not defined");  	}  	break;  }  case ByteCode.Opcode.GetInd: {  	var type = _stack.Peek (-2).TypeCode;  	var op = Machine.GetTypeOperator (type' Operator.GetInd);  	if (op != null) {  		var operand = _stack.StackPointer--;  		_stack.PokeAbs (operand - 2' op (this' _stack.PeekAbs (operand - 2)' _stack.PeekAbs (operand - 1)' _stack.PeekAbs (operand)));  	}  	else {  		throw new Exception ("Operator not defined");  	}  	break;  }  case ByteCode.Opcode.SetInd: {  	var topMin3 = _stack.Peek (-3);  	OperatorCallback op = Machine.GetTypeOperator (topMin3.TypeCode' Operator.SetInd);  	if (op != null) {  		_stack.Poke (-3' op (this' topMin3' _stack.Peek (-2)' _stack.Peek (-1)));  		_stack.StackPointer -= 3;  	}  	else {  		throw new Exception ("Operator not defined");  	}  	break;  }  case ByteCode.Opcode.ForEach: {  	var topMin2 = _stack.Peek (-2);  	TypeIteratorCallback itr = Machine.GetTypeIterator (topMin2.TypeCode);  	if (itr == null) {  		_machine.Log.LogEntry ("Undefined iterator for type");  		return ThreadState.Exception;  	}  	var iteratorPos = _stack.Peek (-1).GetInteger ();  	var obj = _stack.Peek (-2).GetReference ();  	iteratorPos = itr (this' obj' iteratorPos' _stack.PeekBase (inst [1].GetInteger ())' _stack.PeekBase (inst [0].GetInteger ()));  	if (iteratorPos != -1) {  		//_Stack2[_Base + Inst[1].GetInteger()] = Key;  		//_Stack2[_Base + Inst[0].GetInteger()] = Item;  		_stack.Poke (Variable.Zero);  	}  	else {  		_stack.Poke (Variable.Zero);  	}  	_stack.Poke (-1' iteratorPos);  	++_stack.StackPointer;  	break;  }  #region Dot Operators  case ByteCode.Opcode.GetDot: {  	var v1 = _stack.Peek (-1);  	OperatorCallback op = Machine.GetTypeOperator (v1.TypeCode' Operator.GetDot);  	_stack.Poke (inst [0]);  	if (op != null) {  		_stack.Poke (-1' op (this' v1' _stack.Peek ()' _stack.Peek ()));  	}  	else {  		throw new Exception ("Operator not defined");  	}  	break;  }  case ByteCode.Opcode.SetDot: {  	var v1 = _stack.Peek (-2);  	OperatorCallback op = Machine.GetTypeOperator (v1.TypeCode' Operator.SetDot);  	_stack.Poke (inst [0]);  	if (op != null) {  		_stack.Poke (-2' op (this' _stack.Peek (-2)' _stack.Peek (-1)' _stack.Peek ()));  		_stack.StackPointer -= 2;  	}  	else {  		throw new Exception ("Operator not defined");  	}  	break;  }  #endregion  #endregion  #region Branch  case ByteCode.Opcode.Brz: {  	var v = _stack.Pop ();  	if (v.IsZero) {  		var newIp = inst [0].GetInteger ();  		if (newIp >= _instructionList.Count) {  			throw new Exception ("BRZ: Corrupt IP");  		}  		_instructionPtr = newIp;  	}  	break;  }  case ByteCode.Opcode.Brnz: {  	var v = _stack.Pop ();  	if (!v.IsZero) {  		var newIp = inst [0].GetInteger ();  		if (newIp >= _instructionList.Count) {  			throw new Exception ("BRZ: Corrupt IP");  		}  		_instructionPtr = newIp;  	}  	break;  }  case ByteCode.Opcode.Brzk: {  	var v = _stack.Peek (-1);  	if (v.IsZero) {  		var newIp = inst [0].GetInteger ();  		if (newIp >= _instructionList.Count) {  			throw new Exception ("BRZ: Corrupt IP");  		}  		_instructionPtr = newIp;  	}  	break;  }  case ByteCode.Opcode.Brnzk: {  	var v = _stack.Peek (-1);  	if (!v.IsZero) {  		var newIp = inst [0].GetInteger ();  		if (newIp >= _instructionList.Count) {  			throw new Exception ("BRNZK: Corrupt IP");  		}  		_instructionPtr = newIp;  	}  	break;  }  case ByteCode.Opcode.Bra: {  	var newIp = inst [0].GetInteger ();  	if (newIp >= _instructionList.Count) {  		throw new Exception ("BRA: Corrupt IP");  	}  	_instructionPtr = newIp;  	break;  }  #endregion  default: {  	throw new Exception ("Unknown instr");  }  }  
Magic Number,GreenBeanScript,Thread,C:\repos\evolutional_greenbeanscript\GreenBeanScript\VirtualMachine\Thread.cs,Execute,The following statement contains a magic number: switch (inst.OpCode) {  case ByteCode.Opcode.Pop: {  	_stack.Pop ();  	break;  }  case ByteCode.Opcode.Pop2: {  	_stack.Pop (2);  	break;  }  case ByteCode.Opcode.Dup: {  	_stack.Push (_stack.Peek ());  	break;  }  case ByteCode.Opcode.Call: {  	// pop arg count from stack  	ThreadState res = PushStackFrame (inst [0].GetInteger ());  	switch (res) {  	case ThreadState.Running: {  		break;  	}  	case ThreadState.Sys_Yield: {  		return ThreadState.Running;  	}  	case ThreadState.Exception: {  		_machine.SwitchThreadState (this' ThreadState.Killed);  		return ThreadState.Exception;  	}  	case ThreadState.Killed: {  		_machine.SwitchThreadState (this' ThreadState.Killed);  		break;  	}  	default: {  		break;  	}  	}  	break;  }  #region Push Operations  case ByteCode.Opcode.PushNull: {  	Push (Variable.Null);  	break;  }  case ByteCode.Opcode.PushThis: {  	Push (This);  	break;  }  case ByteCode.Opcode.PushInt0:  case ByteCode.Opcode.PushInt1:  case ByteCode.Opcode.PushInt:  case ByteCode.Opcode.PushFp:  case ByteCode.Opcode.PushStr:  case ByteCode.Opcode.PushFn: {  	Push (inst [0]);  	break;  }  case ByteCode.Opcode.PushTbl: {  	Push (new TableObject ());  	break;  }  #endregion  case ByteCode.Opcode.Ret:// Ret pushes a null   {  	Push (Variable.Null);  	ThreadState res = PopStackFrame ();  	switch (res) {  	case ThreadState.Exception:  	case ThreadState.Killed: {  		_machine.SwitchThreadState (this' res);  		return res;  	}  	default: {  		break;  	}  	}  	break;  }  case ByteCode.Opcode.Retv: {  	ThreadState res = PopStackFrame ();  	if (res == ThreadState.Killed) {  		return res;  	}  	break;  }  case ByteCode.Opcode.SetGlobal: {  	Variable v1 = inst [0];  	if (v1.Type != VariableType.String) {  		throw new Exception ("String required");  	}  	Variable v2 = _stack.Pop ();  	_machine.Globals [v1] = v2;  	break;  }  case ByteCode.Opcode.GetGlobal: {  	Variable v1 = inst [0];  	// global name  	// TODO: Check for string  	if (v1.Type != VariableType.String) {  		throw new Exception ("String required");  	}  	var global = _machine.Globals [v1];  	Push (global);  	break;  }  case ByteCode.Opcode.SetLocal: {  	int offset = inst [0].GetInteger ();  	_stack.PokeBase (offset' _stack.Pop ());  	break;  }  case ByteCode.Opcode.GetLocal: {  	int offset = inst [0].GetInteger ();  	Push (_stack.PeekBase (offset));  	break;  }  #region Operators  case ByteCode.Opcode.OpEq:  case ByteCode.Opcode.OpNeq:  case ByteCode.Opcode.OpLt:  case ByteCode.Opcode.OpLte:  case ByteCode.Opcode.OpGt:  case ByteCode.Opcode.OpGte:  case ByteCode.Opcode.OpRem:  case ByteCode.Opcode.OpAdd:  case ByteCode.Opcode.OpSub:  case ByteCode.Opcode.OpMul:  case ByteCode.Opcode.OpDiv: {  	Operator o = Operator._MAX;  	switch (inst.OpCode) {  	#region fold  	case ByteCode.Opcode.OpAdd: {  		o = Operator.Add;  		break;  	}  	case ByteCode.Opcode.OpSub: {  		o = Operator.Sub;  		break;  	}  	case ByteCode.Opcode.OpMul: {  		o = Operator.Mul;  		break;  	}  	case ByteCode.Opcode.OpDiv: {  		o = Operator.Div;  		break;  	}  	case ByteCode.Opcode.GetInd: {  		o = Operator.GetInd;  		break;  	}  	case ByteCode.Opcode.OpEq: {  		o = Operator.Eq;  		break;  	}  	case ByteCode.Opcode.OpNeq: {  		o = Operator.Neq;  		break;  	}  	case ByteCode.Opcode.OpLt: {  		o = Operator.Lt;  		break;  	}  	case ByteCode.Opcode.OpLte: {  		o = Operator.Lte;  		break;  	}  	case ByteCode.Opcode.OpGt: {  		o = Operator.Gt;  		break;  	}  	case ByteCode.Opcode.OpGte: {  		o = Operator.Gte;  		break;  	}  	case ByteCode.Opcode.OpRem: {  		o = Operator.Rem;  		break;  	}  	#endregion  	}  	if (o == Operator._MAX) {  		throw new NotImplementedException ("Operator not mapped or implemented");  	}  	var t1 = _stack.Peek (-1).TypeCode;  	var t2 = _stack.Peek (-2).TypeCode;  	if (t2 > t1) {  		t1 = t2;  	}  	OperatorCallback op = Machine.GetTypeOperator (t1' o);  	if (op != null) {  		var operand = _stack.StackPointer--;  		_stack.PokeAbs (operand - 2' op (this' _stack.PeekAbs (operand - 2)' _stack.PeekAbs (operand - 1)' _stack.PeekAbs (operand)));  	}  	else {  		throw new Exception ("Operator not defined");  	}  	break;  }  case ByteCode.Opcode.GetInd: {  	var type = _stack.Peek (-2).TypeCode;  	var op = Machine.GetTypeOperator (type' Operator.GetInd);  	if (op != null) {  		var operand = _stack.StackPointer--;  		_stack.PokeAbs (operand - 2' op (this' _stack.PeekAbs (operand - 2)' _stack.PeekAbs (operand - 1)' _stack.PeekAbs (operand)));  	}  	else {  		throw new Exception ("Operator not defined");  	}  	break;  }  case ByteCode.Opcode.SetInd: {  	var topMin3 = _stack.Peek (-3);  	OperatorCallback op = Machine.GetTypeOperator (topMin3.TypeCode' Operator.SetInd);  	if (op != null) {  		_stack.Poke (-3' op (this' topMin3' _stack.Peek (-2)' _stack.Peek (-1)));  		_stack.StackPointer -= 3;  	}  	else {  		throw new Exception ("Operator not defined");  	}  	break;  }  case ByteCode.Opcode.ForEach: {  	var topMin2 = _stack.Peek (-2);  	TypeIteratorCallback itr = Machine.GetTypeIterator (topMin2.TypeCode);  	if (itr == null) {  		_machine.Log.LogEntry ("Undefined iterator for type");  		return ThreadState.Exception;  	}  	var iteratorPos = _stack.Peek (-1).GetInteger ();  	var obj = _stack.Peek (-2).GetReference ();  	iteratorPos = itr (this' obj' iteratorPos' _stack.PeekBase (inst [1].GetInteger ())' _stack.PeekBase (inst [0].GetInteger ()));  	if (iteratorPos != -1) {  		//_Stack2[_Base + Inst[1].GetInteger()] = Key;  		//_Stack2[_Base + Inst[0].GetInteger()] = Item;  		_stack.Poke (Variable.Zero);  	}  	else {  		_stack.Poke (Variable.Zero);  	}  	_stack.Poke (-1' iteratorPos);  	++_stack.StackPointer;  	break;  }  #region Dot Operators  case ByteCode.Opcode.GetDot: {  	var v1 = _stack.Peek (-1);  	OperatorCallback op = Machine.GetTypeOperator (v1.TypeCode' Operator.GetDot);  	_stack.Poke (inst [0]);  	if (op != null) {  		_stack.Poke (-1' op (this' v1' _stack.Peek ()' _stack.Peek ()));  	}  	else {  		throw new Exception ("Operator not defined");  	}  	break;  }  case ByteCode.Opcode.SetDot: {  	var v1 = _stack.Peek (-2);  	OperatorCallback op = Machine.GetTypeOperator (v1.TypeCode' Operator.SetDot);  	_stack.Poke (inst [0]);  	if (op != null) {  		_stack.Poke (-2' op (this' _stack.Peek (-2)' _stack.Peek (-1)' _stack.Peek ()));  		_stack.StackPointer -= 2;  	}  	else {  		throw new Exception ("Operator not defined");  	}  	break;  }  #endregion  #endregion  #region Branch  case ByteCode.Opcode.Brz: {  	var v = _stack.Pop ();  	if (v.IsZero) {  		var newIp = inst [0].GetInteger ();  		if (newIp >= _instructionList.Count) {  			throw new Exception ("BRZ: Corrupt IP");  		}  		_instructionPtr = newIp;  	}  	break;  }  case ByteCode.Opcode.Brnz: {  	var v = _stack.Pop ();  	if (!v.IsZero) {  		var newIp = inst [0].GetInteger ();  		if (newIp >= _instructionList.Count) {  			throw new Exception ("BRZ: Corrupt IP");  		}  		_instructionPtr = newIp;  	}  	break;  }  case ByteCode.Opcode.Brzk: {  	var v = _stack.Peek (-1);  	if (v.IsZero) {  		var newIp = inst [0].GetInteger ();  		if (newIp >= _instructionList.Count) {  			throw new Exception ("BRZ: Corrupt IP");  		}  		_instructionPtr = newIp;  	}  	break;  }  case ByteCode.Opcode.Brnzk: {  	var v = _stack.Peek (-1);  	if (!v.IsZero) {  		var newIp = inst [0].GetInteger ();  		if (newIp >= _instructionList.Count) {  			throw new Exception ("BRNZK: Corrupt IP");  		}  		_instructionPtr = newIp;  	}  	break;  }  case ByteCode.Opcode.Bra: {  	var newIp = inst [0].GetInteger ();  	if (newIp >= _instructionList.Count) {  		throw new Exception ("BRA: Corrupt IP");  	}  	_instructionPtr = newIp;  	break;  }  #endregion  default: {  	throw new Exception ("Unknown instr");  }  }  
Magic Number,GreenBeanScript,Thread,C:\repos\evolutional_greenbeanscript\GreenBeanScript\VirtualMachine\Thread.cs,Execute,The following statement contains a magic number: switch (inst.OpCode) {  case ByteCode.Opcode.Pop: {  	_stack.Pop ();  	break;  }  case ByteCode.Opcode.Pop2: {  	_stack.Pop (2);  	break;  }  case ByteCode.Opcode.Dup: {  	_stack.Push (_stack.Peek ());  	break;  }  case ByteCode.Opcode.Call: {  	// pop arg count from stack  	ThreadState res = PushStackFrame (inst [0].GetInteger ());  	switch (res) {  	case ThreadState.Running: {  		break;  	}  	case ThreadState.Sys_Yield: {  		return ThreadState.Running;  	}  	case ThreadState.Exception: {  		_machine.SwitchThreadState (this' ThreadState.Killed);  		return ThreadState.Exception;  	}  	case ThreadState.Killed: {  		_machine.SwitchThreadState (this' ThreadState.Killed);  		break;  	}  	default: {  		break;  	}  	}  	break;  }  #region Push Operations  case ByteCode.Opcode.PushNull: {  	Push (Variable.Null);  	break;  }  case ByteCode.Opcode.PushThis: {  	Push (This);  	break;  }  case ByteCode.Opcode.PushInt0:  case ByteCode.Opcode.PushInt1:  case ByteCode.Opcode.PushInt:  case ByteCode.Opcode.PushFp:  case ByteCode.Opcode.PushStr:  case ByteCode.Opcode.PushFn: {  	Push (inst [0]);  	break;  }  case ByteCode.Opcode.PushTbl: {  	Push (new TableObject ());  	break;  }  #endregion  case ByteCode.Opcode.Ret:// Ret pushes a null   {  	Push (Variable.Null);  	ThreadState res = PopStackFrame ();  	switch (res) {  	case ThreadState.Exception:  	case ThreadState.Killed: {  		_machine.SwitchThreadState (this' res);  		return res;  	}  	default: {  		break;  	}  	}  	break;  }  case ByteCode.Opcode.Retv: {  	ThreadState res = PopStackFrame ();  	if (res == ThreadState.Killed) {  		return res;  	}  	break;  }  case ByteCode.Opcode.SetGlobal: {  	Variable v1 = inst [0];  	if (v1.Type != VariableType.String) {  		throw new Exception ("String required");  	}  	Variable v2 = _stack.Pop ();  	_machine.Globals [v1] = v2;  	break;  }  case ByteCode.Opcode.GetGlobal: {  	Variable v1 = inst [0];  	// global name  	// TODO: Check for string  	if (v1.Type != VariableType.String) {  		throw new Exception ("String required");  	}  	var global = _machine.Globals [v1];  	Push (global);  	break;  }  case ByteCode.Opcode.SetLocal: {  	int offset = inst [0].GetInteger ();  	_stack.PokeBase (offset' _stack.Pop ());  	break;  }  case ByteCode.Opcode.GetLocal: {  	int offset = inst [0].GetInteger ();  	Push (_stack.PeekBase (offset));  	break;  }  #region Operators  case ByteCode.Opcode.OpEq:  case ByteCode.Opcode.OpNeq:  case ByteCode.Opcode.OpLt:  case ByteCode.Opcode.OpLte:  case ByteCode.Opcode.OpGt:  case ByteCode.Opcode.OpGte:  case ByteCode.Opcode.OpRem:  case ByteCode.Opcode.OpAdd:  case ByteCode.Opcode.OpSub:  case ByteCode.Opcode.OpMul:  case ByteCode.Opcode.OpDiv: {  	Operator o = Operator._MAX;  	switch (inst.OpCode) {  	#region fold  	case ByteCode.Opcode.OpAdd: {  		o = Operator.Add;  		break;  	}  	case ByteCode.Opcode.OpSub: {  		o = Operator.Sub;  		break;  	}  	case ByteCode.Opcode.OpMul: {  		o = Operator.Mul;  		break;  	}  	case ByteCode.Opcode.OpDiv: {  		o = Operator.Div;  		break;  	}  	case ByteCode.Opcode.GetInd: {  		o = Operator.GetInd;  		break;  	}  	case ByteCode.Opcode.OpEq: {  		o = Operator.Eq;  		break;  	}  	case ByteCode.Opcode.OpNeq: {  		o = Operator.Neq;  		break;  	}  	case ByteCode.Opcode.OpLt: {  		o = Operator.Lt;  		break;  	}  	case ByteCode.Opcode.OpLte: {  		o = Operator.Lte;  		break;  	}  	case ByteCode.Opcode.OpGt: {  		o = Operator.Gt;  		break;  	}  	case ByteCode.Opcode.OpGte: {  		o = Operator.Gte;  		break;  	}  	case ByteCode.Opcode.OpRem: {  		o = Operator.Rem;  		break;  	}  	#endregion  	}  	if (o == Operator._MAX) {  		throw new NotImplementedException ("Operator not mapped or implemented");  	}  	var t1 = _stack.Peek (-1).TypeCode;  	var t2 = _stack.Peek (-2).TypeCode;  	if (t2 > t1) {  		t1 = t2;  	}  	OperatorCallback op = Machine.GetTypeOperator (t1' o);  	if (op != null) {  		var operand = _stack.StackPointer--;  		_stack.PokeAbs (operand - 2' op (this' _stack.PeekAbs (operand - 2)' _stack.PeekAbs (operand - 1)' _stack.PeekAbs (operand)));  	}  	else {  		throw new Exception ("Operator not defined");  	}  	break;  }  case ByteCode.Opcode.GetInd: {  	var type = _stack.Peek (-2).TypeCode;  	var op = Machine.GetTypeOperator (type' Operator.GetInd);  	if (op != null) {  		var operand = _stack.StackPointer--;  		_stack.PokeAbs (operand - 2' op (this' _stack.PeekAbs (operand - 2)' _stack.PeekAbs (operand - 1)' _stack.PeekAbs (operand)));  	}  	else {  		throw new Exception ("Operator not defined");  	}  	break;  }  case ByteCode.Opcode.SetInd: {  	var topMin3 = _stack.Peek (-3);  	OperatorCallback op = Machine.GetTypeOperator (topMin3.TypeCode' Operator.SetInd);  	if (op != null) {  		_stack.Poke (-3' op (this' topMin3' _stack.Peek (-2)' _stack.Peek (-1)));  		_stack.StackPointer -= 3;  	}  	else {  		throw new Exception ("Operator not defined");  	}  	break;  }  case ByteCode.Opcode.ForEach: {  	var topMin2 = _stack.Peek (-2);  	TypeIteratorCallback itr = Machine.GetTypeIterator (topMin2.TypeCode);  	if (itr == null) {  		_machine.Log.LogEntry ("Undefined iterator for type");  		return ThreadState.Exception;  	}  	var iteratorPos = _stack.Peek (-1).GetInteger ();  	var obj = _stack.Peek (-2).GetReference ();  	iteratorPos = itr (this' obj' iteratorPos' _stack.PeekBase (inst [1].GetInteger ())' _stack.PeekBase (inst [0].GetInteger ()));  	if (iteratorPos != -1) {  		//_Stack2[_Base + Inst[1].GetInteger()] = Key;  		//_Stack2[_Base + Inst[0].GetInteger()] = Item;  		_stack.Poke (Variable.Zero);  	}  	else {  		_stack.Poke (Variable.Zero);  	}  	_stack.Poke (-1' iteratorPos);  	++_stack.StackPointer;  	break;  }  #region Dot Operators  case ByteCode.Opcode.GetDot: {  	var v1 = _stack.Peek (-1);  	OperatorCallback op = Machine.GetTypeOperator (v1.TypeCode' Operator.GetDot);  	_stack.Poke (inst [0]);  	if (op != null) {  		_stack.Poke (-1' op (this' v1' _stack.Peek ()' _stack.Peek ()));  	}  	else {  		throw new Exception ("Operator not defined");  	}  	break;  }  case ByteCode.Opcode.SetDot: {  	var v1 = _stack.Peek (-2);  	OperatorCallback op = Machine.GetTypeOperator (v1.TypeCode' Operator.SetDot);  	_stack.Poke (inst [0]);  	if (op != null) {  		_stack.Poke (-2' op (this' _stack.Peek (-2)' _stack.Peek (-1)' _stack.Peek ()));  		_stack.StackPointer -= 2;  	}  	else {  		throw new Exception ("Operator not defined");  	}  	break;  }  #endregion  #endregion  #region Branch  case ByteCode.Opcode.Brz: {  	var v = _stack.Pop ();  	if (v.IsZero) {  		var newIp = inst [0].GetInteger ();  		if (newIp >= _instructionList.Count) {  			throw new Exception ("BRZ: Corrupt IP");  		}  		_instructionPtr = newIp;  	}  	break;  }  case ByteCode.Opcode.Brnz: {  	var v = _stack.Pop ();  	if (!v.IsZero) {  		var newIp = inst [0].GetInteger ();  		if (newIp >= _instructionList.Count) {  			throw new Exception ("BRZ: Corrupt IP");  		}  		_instructionPtr = newIp;  	}  	break;  }  case ByteCode.Opcode.Brzk: {  	var v = _stack.Peek (-1);  	if (v.IsZero) {  		var newIp = inst [0].GetInteger ();  		if (newIp >= _instructionList.Count) {  			throw new Exception ("BRZ: Corrupt IP");  		}  		_instructionPtr = newIp;  	}  	break;  }  case ByteCode.Opcode.Brnzk: {  	var v = _stack.Peek (-1);  	if (!v.IsZero) {  		var newIp = inst [0].GetInteger ();  		if (newIp >= _instructionList.Count) {  			throw new Exception ("BRNZK: Corrupt IP");  		}  		_instructionPtr = newIp;  	}  	break;  }  case ByteCode.Opcode.Bra: {  	var newIp = inst [0].GetInteger ();  	if (newIp >= _instructionList.Count) {  		throw new Exception ("BRA: Corrupt IP");  	}  	_instructionPtr = newIp;  	break;  }  #endregion  default: {  	throw new Exception ("Unknown instr");  }  }  
Magic Number,GreenBeanScript,Thread,C:\repos\evolutional_greenbeanscript\GreenBeanScript\VirtualMachine\Thread.cs,Execute,The following statement contains a magic number: switch (inst.OpCode) {  case ByteCode.Opcode.Pop: {  	_stack.Pop ();  	break;  }  case ByteCode.Opcode.Pop2: {  	_stack.Pop (2);  	break;  }  case ByteCode.Opcode.Dup: {  	_stack.Push (_stack.Peek ());  	break;  }  case ByteCode.Opcode.Call: {  	// pop arg count from stack  	ThreadState res = PushStackFrame (inst [0].GetInteger ());  	switch (res) {  	case ThreadState.Running: {  		break;  	}  	case ThreadState.Sys_Yield: {  		return ThreadState.Running;  	}  	case ThreadState.Exception: {  		_machine.SwitchThreadState (this' ThreadState.Killed);  		return ThreadState.Exception;  	}  	case ThreadState.Killed: {  		_machine.SwitchThreadState (this' ThreadState.Killed);  		break;  	}  	default: {  		break;  	}  	}  	break;  }  #region Push Operations  case ByteCode.Opcode.PushNull: {  	Push (Variable.Null);  	break;  }  case ByteCode.Opcode.PushThis: {  	Push (This);  	break;  }  case ByteCode.Opcode.PushInt0:  case ByteCode.Opcode.PushInt1:  case ByteCode.Opcode.PushInt:  case ByteCode.Opcode.PushFp:  case ByteCode.Opcode.PushStr:  case ByteCode.Opcode.PushFn: {  	Push (inst [0]);  	break;  }  case ByteCode.Opcode.PushTbl: {  	Push (new TableObject ());  	break;  }  #endregion  case ByteCode.Opcode.Ret:// Ret pushes a null   {  	Push (Variable.Null);  	ThreadState res = PopStackFrame ();  	switch (res) {  	case ThreadState.Exception:  	case ThreadState.Killed: {  		_machine.SwitchThreadState (this' res);  		return res;  	}  	default: {  		break;  	}  	}  	break;  }  case ByteCode.Opcode.Retv: {  	ThreadState res = PopStackFrame ();  	if (res == ThreadState.Killed) {  		return res;  	}  	break;  }  case ByteCode.Opcode.SetGlobal: {  	Variable v1 = inst [0];  	if (v1.Type != VariableType.String) {  		throw new Exception ("String required");  	}  	Variable v2 = _stack.Pop ();  	_machine.Globals [v1] = v2;  	break;  }  case ByteCode.Opcode.GetGlobal: {  	Variable v1 = inst [0];  	// global name  	// TODO: Check for string  	if (v1.Type != VariableType.String) {  		throw new Exception ("String required");  	}  	var global = _machine.Globals [v1];  	Push (global);  	break;  }  case ByteCode.Opcode.SetLocal: {  	int offset = inst [0].GetInteger ();  	_stack.PokeBase (offset' _stack.Pop ());  	break;  }  case ByteCode.Opcode.GetLocal: {  	int offset = inst [0].GetInteger ();  	Push (_stack.PeekBase (offset));  	break;  }  #region Operators  case ByteCode.Opcode.OpEq:  case ByteCode.Opcode.OpNeq:  case ByteCode.Opcode.OpLt:  case ByteCode.Opcode.OpLte:  case ByteCode.Opcode.OpGt:  case ByteCode.Opcode.OpGte:  case ByteCode.Opcode.OpRem:  case ByteCode.Opcode.OpAdd:  case ByteCode.Opcode.OpSub:  case ByteCode.Opcode.OpMul:  case ByteCode.Opcode.OpDiv: {  	Operator o = Operator._MAX;  	switch (inst.OpCode) {  	#region fold  	case ByteCode.Opcode.OpAdd: {  		o = Operator.Add;  		break;  	}  	case ByteCode.Opcode.OpSub: {  		o = Operator.Sub;  		break;  	}  	case ByteCode.Opcode.OpMul: {  		o = Operator.Mul;  		break;  	}  	case ByteCode.Opcode.OpDiv: {  		o = Operator.Div;  		break;  	}  	case ByteCode.Opcode.GetInd: {  		o = Operator.GetInd;  		break;  	}  	case ByteCode.Opcode.OpEq: {  		o = Operator.Eq;  		break;  	}  	case ByteCode.Opcode.OpNeq: {  		o = Operator.Neq;  		break;  	}  	case ByteCode.Opcode.OpLt: {  		o = Operator.Lt;  		break;  	}  	case ByteCode.Opcode.OpLte: {  		o = Operator.Lte;  		break;  	}  	case ByteCode.Opcode.OpGt: {  		o = Operator.Gt;  		break;  	}  	case ByteCode.Opcode.OpGte: {  		o = Operator.Gte;  		break;  	}  	case ByteCode.Opcode.OpRem: {  		o = Operator.Rem;  		break;  	}  	#endregion  	}  	if (o == Operator._MAX) {  		throw new NotImplementedException ("Operator not mapped or implemented");  	}  	var t1 = _stack.Peek (-1).TypeCode;  	var t2 = _stack.Peek (-2).TypeCode;  	if (t2 > t1) {  		t1 = t2;  	}  	OperatorCallback op = Machine.GetTypeOperator (t1' o);  	if (op != null) {  		var operand = _stack.StackPointer--;  		_stack.PokeAbs (operand - 2' op (this' _stack.PeekAbs (operand - 2)' _stack.PeekAbs (operand - 1)' _stack.PeekAbs (operand)));  	}  	else {  		throw new Exception ("Operator not defined");  	}  	break;  }  case ByteCode.Opcode.GetInd: {  	var type = _stack.Peek (-2).TypeCode;  	var op = Machine.GetTypeOperator (type' Operator.GetInd);  	if (op != null) {  		var operand = _stack.StackPointer--;  		_stack.PokeAbs (operand - 2' op (this' _stack.PeekAbs (operand - 2)' _stack.PeekAbs (operand - 1)' _stack.PeekAbs (operand)));  	}  	else {  		throw new Exception ("Operator not defined");  	}  	break;  }  case ByteCode.Opcode.SetInd: {  	var topMin3 = _stack.Peek (-3);  	OperatorCallback op = Machine.GetTypeOperator (topMin3.TypeCode' Operator.SetInd);  	if (op != null) {  		_stack.Poke (-3' op (this' topMin3' _stack.Peek (-2)' _stack.Peek (-1)));  		_stack.StackPointer -= 3;  	}  	else {  		throw new Exception ("Operator not defined");  	}  	break;  }  case ByteCode.Opcode.ForEach: {  	var topMin2 = _stack.Peek (-2);  	TypeIteratorCallback itr = Machine.GetTypeIterator (topMin2.TypeCode);  	if (itr == null) {  		_machine.Log.LogEntry ("Undefined iterator for type");  		return ThreadState.Exception;  	}  	var iteratorPos = _stack.Peek (-1).GetInteger ();  	var obj = _stack.Peek (-2).GetReference ();  	iteratorPos = itr (this' obj' iteratorPos' _stack.PeekBase (inst [1].GetInteger ())' _stack.PeekBase (inst [0].GetInteger ()));  	if (iteratorPos != -1) {  		//_Stack2[_Base + Inst[1].GetInteger()] = Key;  		//_Stack2[_Base + Inst[0].GetInteger()] = Item;  		_stack.Poke (Variable.Zero);  	}  	else {  		_stack.Poke (Variable.Zero);  	}  	_stack.Poke (-1' iteratorPos);  	++_stack.StackPointer;  	break;  }  #region Dot Operators  case ByteCode.Opcode.GetDot: {  	var v1 = _stack.Peek (-1);  	OperatorCallback op = Machine.GetTypeOperator (v1.TypeCode' Operator.GetDot);  	_stack.Poke (inst [0]);  	if (op != null) {  		_stack.Poke (-1' op (this' v1' _stack.Peek ()' _stack.Peek ()));  	}  	else {  		throw new Exception ("Operator not defined");  	}  	break;  }  case ByteCode.Opcode.SetDot: {  	var v1 = _stack.Peek (-2);  	OperatorCallback op = Machine.GetTypeOperator (v1.TypeCode' Operator.SetDot);  	_stack.Poke (inst [0]);  	if (op != null) {  		_stack.Poke (-2' op (this' _stack.Peek (-2)' _stack.Peek (-1)' _stack.Peek ()));  		_stack.StackPointer -= 2;  	}  	else {  		throw new Exception ("Operator not defined");  	}  	break;  }  #endregion  #endregion  #region Branch  case ByteCode.Opcode.Brz: {  	var v = _stack.Pop ();  	if (v.IsZero) {  		var newIp = inst [0].GetInteger ();  		if (newIp >= _instructionList.Count) {  			throw new Exception ("BRZ: Corrupt IP");  		}  		_instructionPtr = newIp;  	}  	break;  }  case ByteCode.Opcode.Brnz: {  	var v = _stack.Pop ();  	if (!v.IsZero) {  		var newIp = inst [0].GetInteger ();  		if (newIp >= _instructionList.Count) {  			throw new Exception ("BRZ: Corrupt IP");  		}  		_instructionPtr = newIp;  	}  	break;  }  case ByteCode.Opcode.Brzk: {  	var v = _stack.Peek (-1);  	if (v.IsZero) {  		var newIp = inst [0].GetInteger ();  		if (newIp >= _instructionList.Count) {  			throw new Exception ("BRZ: Corrupt IP");  		}  		_instructionPtr = newIp;  	}  	break;  }  case ByteCode.Opcode.Brnzk: {  	var v = _stack.Peek (-1);  	if (!v.IsZero) {  		var newIp = inst [0].GetInteger ();  		if (newIp >= _instructionList.Count) {  			throw new Exception ("BRNZK: Corrupt IP");  		}  		_instructionPtr = newIp;  	}  	break;  }  case ByteCode.Opcode.Bra: {  	var newIp = inst [0].GetInteger ();  	if (newIp >= _instructionList.Count) {  		throw new Exception ("BRA: Corrupt IP");  	}  	_instructionPtr = newIp;  	break;  }  #endregion  default: {  	throw new Exception ("Unknown instr");  }  }  
Magic Number,GreenBeanScript,Thread,C:\repos\evolutional_greenbeanscript\GreenBeanScript\VirtualMachine\Thread.cs,Execute,The following statement contains a magic number: switch (inst.OpCode) {  case ByteCode.Opcode.Pop: {  	_stack.Pop ();  	break;  }  case ByteCode.Opcode.Pop2: {  	_stack.Pop (2);  	break;  }  case ByteCode.Opcode.Dup: {  	_stack.Push (_stack.Peek ());  	break;  }  case ByteCode.Opcode.Call: {  	// pop arg count from stack  	ThreadState res = PushStackFrame (inst [0].GetInteger ());  	switch (res) {  	case ThreadState.Running: {  		break;  	}  	case ThreadState.Sys_Yield: {  		return ThreadState.Running;  	}  	case ThreadState.Exception: {  		_machine.SwitchThreadState (this' ThreadState.Killed);  		return ThreadState.Exception;  	}  	case ThreadState.Killed: {  		_machine.SwitchThreadState (this' ThreadState.Killed);  		break;  	}  	default: {  		break;  	}  	}  	break;  }  #region Push Operations  case ByteCode.Opcode.PushNull: {  	Push (Variable.Null);  	break;  }  case ByteCode.Opcode.PushThis: {  	Push (This);  	break;  }  case ByteCode.Opcode.PushInt0:  case ByteCode.Opcode.PushInt1:  case ByteCode.Opcode.PushInt:  case ByteCode.Opcode.PushFp:  case ByteCode.Opcode.PushStr:  case ByteCode.Opcode.PushFn: {  	Push (inst [0]);  	break;  }  case ByteCode.Opcode.PushTbl: {  	Push (new TableObject ());  	break;  }  #endregion  case ByteCode.Opcode.Ret:// Ret pushes a null   {  	Push (Variable.Null);  	ThreadState res = PopStackFrame ();  	switch (res) {  	case ThreadState.Exception:  	case ThreadState.Killed: {  		_machine.SwitchThreadState (this' res);  		return res;  	}  	default: {  		break;  	}  	}  	break;  }  case ByteCode.Opcode.Retv: {  	ThreadState res = PopStackFrame ();  	if (res == ThreadState.Killed) {  		return res;  	}  	break;  }  case ByteCode.Opcode.SetGlobal: {  	Variable v1 = inst [0];  	if (v1.Type != VariableType.String) {  		throw new Exception ("String required");  	}  	Variable v2 = _stack.Pop ();  	_machine.Globals [v1] = v2;  	break;  }  case ByteCode.Opcode.GetGlobal: {  	Variable v1 = inst [0];  	// global name  	// TODO: Check for string  	if (v1.Type != VariableType.String) {  		throw new Exception ("String required");  	}  	var global = _machine.Globals [v1];  	Push (global);  	break;  }  case ByteCode.Opcode.SetLocal: {  	int offset = inst [0].GetInteger ();  	_stack.PokeBase (offset' _stack.Pop ());  	break;  }  case ByteCode.Opcode.GetLocal: {  	int offset = inst [0].GetInteger ();  	Push (_stack.PeekBase (offset));  	break;  }  #region Operators  case ByteCode.Opcode.OpEq:  case ByteCode.Opcode.OpNeq:  case ByteCode.Opcode.OpLt:  case ByteCode.Opcode.OpLte:  case ByteCode.Opcode.OpGt:  case ByteCode.Opcode.OpGte:  case ByteCode.Opcode.OpRem:  case ByteCode.Opcode.OpAdd:  case ByteCode.Opcode.OpSub:  case ByteCode.Opcode.OpMul:  case ByteCode.Opcode.OpDiv: {  	Operator o = Operator._MAX;  	switch (inst.OpCode) {  	#region fold  	case ByteCode.Opcode.OpAdd: {  		o = Operator.Add;  		break;  	}  	case ByteCode.Opcode.OpSub: {  		o = Operator.Sub;  		break;  	}  	case ByteCode.Opcode.OpMul: {  		o = Operator.Mul;  		break;  	}  	case ByteCode.Opcode.OpDiv: {  		o = Operator.Div;  		break;  	}  	case ByteCode.Opcode.GetInd: {  		o = Operator.GetInd;  		break;  	}  	case ByteCode.Opcode.OpEq: {  		o = Operator.Eq;  		break;  	}  	case ByteCode.Opcode.OpNeq: {  		o = Operator.Neq;  		break;  	}  	case ByteCode.Opcode.OpLt: {  		o = Operator.Lt;  		break;  	}  	case ByteCode.Opcode.OpLte: {  		o = Operator.Lte;  		break;  	}  	case ByteCode.Opcode.OpGt: {  		o = Operator.Gt;  		break;  	}  	case ByteCode.Opcode.OpGte: {  		o = Operator.Gte;  		break;  	}  	case ByteCode.Opcode.OpRem: {  		o = Operator.Rem;  		break;  	}  	#endregion  	}  	if (o == Operator._MAX) {  		throw new NotImplementedException ("Operator not mapped or implemented");  	}  	var t1 = _stack.Peek (-1).TypeCode;  	var t2 = _stack.Peek (-2).TypeCode;  	if (t2 > t1) {  		t1 = t2;  	}  	OperatorCallback op = Machine.GetTypeOperator (t1' o);  	if (op != null) {  		var operand = _stack.StackPointer--;  		_stack.PokeAbs (operand - 2' op (this' _stack.PeekAbs (operand - 2)' _stack.PeekAbs (operand - 1)' _stack.PeekAbs (operand)));  	}  	else {  		throw new Exception ("Operator not defined");  	}  	break;  }  case ByteCode.Opcode.GetInd: {  	var type = _stack.Peek (-2).TypeCode;  	var op = Machine.GetTypeOperator (type' Operator.GetInd);  	if (op != null) {  		var operand = _stack.StackPointer--;  		_stack.PokeAbs (operand - 2' op (this' _stack.PeekAbs (operand - 2)' _stack.PeekAbs (operand - 1)' _stack.PeekAbs (operand)));  	}  	else {  		throw new Exception ("Operator not defined");  	}  	break;  }  case ByteCode.Opcode.SetInd: {  	var topMin3 = _stack.Peek (-3);  	OperatorCallback op = Machine.GetTypeOperator (topMin3.TypeCode' Operator.SetInd);  	if (op != null) {  		_stack.Poke (-3' op (this' topMin3' _stack.Peek (-2)' _stack.Peek (-1)));  		_stack.StackPointer -= 3;  	}  	else {  		throw new Exception ("Operator not defined");  	}  	break;  }  case ByteCode.Opcode.ForEach: {  	var topMin2 = _stack.Peek (-2);  	TypeIteratorCallback itr = Machine.GetTypeIterator (topMin2.TypeCode);  	if (itr == null) {  		_machine.Log.LogEntry ("Undefined iterator for type");  		return ThreadState.Exception;  	}  	var iteratorPos = _stack.Peek (-1).GetInteger ();  	var obj = _stack.Peek (-2).GetReference ();  	iteratorPos = itr (this' obj' iteratorPos' _stack.PeekBase (inst [1].GetInteger ())' _stack.PeekBase (inst [0].GetInteger ()));  	if (iteratorPos != -1) {  		//_Stack2[_Base + Inst[1].GetInteger()] = Key;  		//_Stack2[_Base + Inst[0].GetInteger()] = Item;  		_stack.Poke (Variable.Zero);  	}  	else {  		_stack.Poke (Variable.Zero);  	}  	_stack.Poke (-1' iteratorPos);  	++_stack.StackPointer;  	break;  }  #region Dot Operators  case ByteCode.Opcode.GetDot: {  	var v1 = _stack.Peek (-1);  	OperatorCallback op = Machine.GetTypeOperator (v1.TypeCode' Operator.GetDot);  	_stack.Poke (inst [0]);  	if (op != null) {  		_stack.Poke (-1' op (this' v1' _stack.Peek ()' _stack.Peek ()));  	}  	else {  		throw new Exception ("Operator not defined");  	}  	break;  }  case ByteCode.Opcode.SetDot: {  	var v1 = _stack.Peek (-2);  	OperatorCallback op = Machine.GetTypeOperator (v1.TypeCode' Operator.SetDot);  	_stack.Poke (inst [0]);  	if (op != null) {  		_stack.Poke (-2' op (this' _stack.Peek (-2)' _stack.Peek (-1)' _stack.Peek ()));  		_stack.StackPointer -= 2;  	}  	else {  		throw new Exception ("Operator not defined");  	}  	break;  }  #endregion  #endregion  #region Branch  case ByteCode.Opcode.Brz: {  	var v = _stack.Pop ();  	if (v.IsZero) {  		var newIp = inst [0].GetInteger ();  		if (newIp >= _instructionList.Count) {  			throw new Exception ("BRZ: Corrupt IP");  		}  		_instructionPtr = newIp;  	}  	break;  }  case ByteCode.Opcode.Brnz: {  	var v = _stack.Pop ();  	if (!v.IsZero) {  		var newIp = inst [0].GetInteger ();  		if (newIp >= _instructionList.Count) {  			throw new Exception ("BRZ: Corrupt IP");  		}  		_instructionPtr = newIp;  	}  	break;  }  case ByteCode.Opcode.Brzk: {  	var v = _stack.Peek (-1);  	if (v.IsZero) {  		var newIp = inst [0].GetInteger ();  		if (newIp >= _instructionList.Count) {  			throw new Exception ("BRZ: Corrupt IP");  		}  		_instructionPtr = newIp;  	}  	break;  }  case ByteCode.Opcode.Brnzk: {  	var v = _stack.Peek (-1);  	if (!v.IsZero) {  		var newIp = inst [0].GetInteger ();  		if (newIp >= _instructionList.Count) {  			throw new Exception ("BRNZK: Corrupt IP");  		}  		_instructionPtr = newIp;  	}  	break;  }  case ByteCode.Opcode.Bra: {  	var newIp = inst [0].GetInteger ();  	if (newIp >= _instructionList.Count) {  		throw new Exception ("BRA: Corrupt IP");  	}  	_instructionPtr = newIp;  	break;  }  #endregion  default: {  	throw new Exception ("Unknown instr");  }  }  
Magic Number,GreenBeanScript,Thread,C:\repos\evolutional_greenbeanscript\GreenBeanScript\VirtualMachine\Thread.cs,Execute,The following statement contains a magic number: switch (inst.OpCode) {  case ByteCode.Opcode.Pop: {  	_stack.Pop ();  	break;  }  case ByteCode.Opcode.Pop2: {  	_stack.Pop (2);  	break;  }  case ByteCode.Opcode.Dup: {  	_stack.Push (_stack.Peek ());  	break;  }  case ByteCode.Opcode.Call: {  	// pop arg count from stack  	ThreadState res = PushStackFrame (inst [0].GetInteger ());  	switch (res) {  	case ThreadState.Running: {  		break;  	}  	case ThreadState.Sys_Yield: {  		return ThreadState.Running;  	}  	case ThreadState.Exception: {  		_machine.SwitchThreadState (this' ThreadState.Killed);  		return ThreadState.Exception;  	}  	case ThreadState.Killed: {  		_machine.SwitchThreadState (this' ThreadState.Killed);  		break;  	}  	default: {  		break;  	}  	}  	break;  }  #region Push Operations  case ByteCode.Opcode.PushNull: {  	Push (Variable.Null);  	break;  }  case ByteCode.Opcode.PushThis: {  	Push (This);  	break;  }  case ByteCode.Opcode.PushInt0:  case ByteCode.Opcode.PushInt1:  case ByteCode.Opcode.PushInt:  case ByteCode.Opcode.PushFp:  case ByteCode.Opcode.PushStr:  case ByteCode.Opcode.PushFn: {  	Push (inst [0]);  	break;  }  case ByteCode.Opcode.PushTbl: {  	Push (new TableObject ());  	break;  }  #endregion  case ByteCode.Opcode.Ret:// Ret pushes a null   {  	Push (Variable.Null);  	ThreadState res = PopStackFrame ();  	switch (res) {  	case ThreadState.Exception:  	case ThreadState.Killed: {  		_machine.SwitchThreadState (this' res);  		return res;  	}  	default: {  		break;  	}  	}  	break;  }  case ByteCode.Opcode.Retv: {  	ThreadState res = PopStackFrame ();  	if (res == ThreadState.Killed) {  		return res;  	}  	break;  }  case ByteCode.Opcode.SetGlobal: {  	Variable v1 = inst [0];  	if (v1.Type != VariableType.String) {  		throw new Exception ("String required");  	}  	Variable v2 = _stack.Pop ();  	_machine.Globals [v1] = v2;  	break;  }  case ByteCode.Opcode.GetGlobal: {  	Variable v1 = inst [0];  	// global name  	// TODO: Check for string  	if (v1.Type != VariableType.String) {  		throw new Exception ("String required");  	}  	var global = _machine.Globals [v1];  	Push (global);  	break;  }  case ByteCode.Opcode.SetLocal: {  	int offset = inst [0].GetInteger ();  	_stack.PokeBase (offset' _stack.Pop ());  	break;  }  case ByteCode.Opcode.GetLocal: {  	int offset = inst [0].GetInteger ();  	Push (_stack.PeekBase (offset));  	break;  }  #region Operators  case ByteCode.Opcode.OpEq:  case ByteCode.Opcode.OpNeq:  case ByteCode.Opcode.OpLt:  case ByteCode.Opcode.OpLte:  case ByteCode.Opcode.OpGt:  case ByteCode.Opcode.OpGte:  case ByteCode.Opcode.OpRem:  case ByteCode.Opcode.OpAdd:  case ByteCode.Opcode.OpSub:  case ByteCode.Opcode.OpMul:  case ByteCode.Opcode.OpDiv: {  	Operator o = Operator._MAX;  	switch (inst.OpCode) {  	#region fold  	case ByteCode.Opcode.OpAdd: {  		o = Operator.Add;  		break;  	}  	case ByteCode.Opcode.OpSub: {  		o = Operator.Sub;  		break;  	}  	case ByteCode.Opcode.OpMul: {  		o = Operator.Mul;  		break;  	}  	case ByteCode.Opcode.OpDiv: {  		o = Operator.Div;  		break;  	}  	case ByteCode.Opcode.GetInd: {  		o = Operator.GetInd;  		break;  	}  	case ByteCode.Opcode.OpEq: {  		o = Operator.Eq;  		break;  	}  	case ByteCode.Opcode.OpNeq: {  		o = Operator.Neq;  		break;  	}  	case ByteCode.Opcode.OpLt: {  		o = Operator.Lt;  		break;  	}  	case ByteCode.Opcode.OpLte: {  		o = Operator.Lte;  		break;  	}  	case ByteCode.Opcode.OpGt: {  		o = Operator.Gt;  		break;  	}  	case ByteCode.Opcode.OpGte: {  		o = Operator.Gte;  		break;  	}  	case ByteCode.Opcode.OpRem: {  		o = Operator.Rem;  		break;  	}  	#endregion  	}  	if (o == Operator._MAX) {  		throw new NotImplementedException ("Operator not mapped or implemented");  	}  	var t1 = _stack.Peek (-1).TypeCode;  	var t2 = _stack.Peek (-2).TypeCode;  	if (t2 > t1) {  		t1 = t2;  	}  	OperatorCallback op = Machine.GetTypeOperator (t1' o);  	if (op != null) {  		var operand = _stack.StackPointer--;  		_stack.PokeAbs (operand - 2' op (this' _stack.PeekAbs (operand - 2)' _stack.PeekAbs (operand - 1)' _stack.PeekAbs (operand)));  	}  	else {  		throw new Exception ("Operator not defined");  	}  	break;  }  case ByteCode.Opcode.GetInd: {  	var type = _stack.Peek (-2).TypeCode;  	var op = Machine.GetTypeOperator (type' Operator.GetInd);  	if (op != null) {  		var operand = _stack.StackPointer--;  		_stack.PokeAbs (operand - 2' op (this' _stack.PeekAbs (operand - 2)' _stack.PeekAbs (operand - 1)' _stack.PeekAbs (operand)));  	}  	else {  		throw new Exception ("Operator not defined");  	}  	break;  }  case ByteCode.Opcode.SetInd: {  	var topMin3 = _stack.Peek (-3);  	OperatorCallback op = Machine.GetTypeOperator (topMin3.TypeCode' Operator.SetInd);  	if (op != null) {  		_stack.Poke (-3' op (this' topMin3' _stack.Peek (-2)' _stack.Peek (-1)));  		_stack.StackPointer -= 3;  	}  	else {  		throw new Exception ("Operator not defined");  	}  	break;  }  case ByteCode.Opcode.ForEach: {  	var topMin2 = _stack.Peek (-2);  	TypeIteratorCallback itr = Machine.GetTypeIterator (topMin2.TypeCode);  	if (itr == null) {  		_machine.Log.LogEntry ("Undefined iterator for type");  		return ThreadState.Exception;  	}  	var iteratorPos = _stack.Peek (-1).GetInteger ();  	var obj = _stack.Peek (-2).GetReference ();  	iteratorPos = itr (this' obj' iteratorPos' _stack.PeekBase (inst [1].GetInteger ())' _stack.PeekBase (inst [0].GetInteger ()));  	if (iteratorPos != -1) {  		//_Stack2[_Base + Inst[1].GetInteger()] = Key;  		//_Stack2[_Base + Inst[0].GetInteger()] = Item;  		_stack.Poke (Variable.Zero);  	}  	else {  		_stack.Poke (Variable.Zero);  	}  	_stack.Poke (-1' iteratorPos);  	++_stack.StackPointer;  	break;  }  #region Dot Operators  case ByteCode.Opcode.GetDot: {  	var v1 = _stack.Peek (-1);  	OperatorCallback op = Machine.GetTypeOperator (v1.TypeCode' Operator.GetDot);  	_stack.Poke (inst [0]);  	if (op != null) {  		_stack.Poke (-1' op (this' v1' _stack.Peek ()' _stack.Peek ()));  	}  	else {  		throw new Exception ("Operator not defined");  	}  	break;  }  case ByteCode.Opcode.SetDot: {  	var v1 = _stack.Peek (-2);  	OperatorCallback op = Machine.GetTypeOperator (v1.TypeCode' Operator.SetDot);  	_stack.Poke (inst [0]);  	if (op != null) {  		_stack.Poke (-2' op (this' _stack.Peek (-2)' _stack.Peek (-1)' _stack.Peek ()));  		_stack.StackPointer -= 2;  	}  	else {  		throw new Exception ("Operator not defined");  	}  	break;  }  #endregion  #endregion  #region Branch  case ByteCode.Opcode.Brz: {  	var v = _stack.Pop ();  	if (v.IsZero) {  		var newIp = inst [0].GetInteger ();  		if (newIp >= _instructionList.Count) {  			throw new Exception ("BRZ: Corrupt IP");  		}  		_instructionPtr = newIp;  	}  	break;  }  case ByteCode.Opcode.Brnz: {  	var v = _stack.Pop ();  	if (!v.IsZero) {  		var newIp = inst [0].GetInteger ();  		if (newIp >= _instructionList.Count) {  			throw new Exception ("BRZ: Corrupt IP");  		}  		_instructionPtr = newIp;  	}  	break;  }  case ByteCode.Opcode.Brzk: {  	var v = _stack.Peek (-1);  	if (v.IsZero) {  		var newIp = inst [0].GetInteger ();  		if (newIp >= _instructionList.Count) {  			throw new Exception ("BRZ: Corrupt IP");  		}  		_instructionPtr = newIp;  	}  	break;  }  case ByteCode.Opcode.Brnzk: {  	var v = _stack.Peek (-1);  	if (!v.IsZero) {  		var newIp = inst [0].GetInteger ();  		if (newIp >= _instructionList.Count) {  			throw new Exception ("BRNZK: Corrupt IP");  		}  		_instructionPtr = newIp;  	}  	break;  }  case ByteCode.Opcode.Bra: {  	var newIp = inst [0].GetInteger ();  	if (newIp >= _instructionList.Count) {  		throw new Exception ("BRA: Corrupt IP");  	}  	_instructionPtr = newIp;  	break;  }  #endregion  default: {  	throw new Exception ("Unknown instr");  }  }  
Magic Number,GreenBeanScript,Thread,C:\repos\evolutional_greenbeanscript\GreenBeanScript\VirtualMachine\Thread.cs,Execute,The following statement contains a magic number: switch (inst.OpCode) {  case ByteCode.Opcode.Pop: {  	_stack.Pop ();  	break;  }  case ByteCode.Opcode.Pop2: {  	_stack.Pop (2);  	break;  }  case ByteCode.Opcode.Dup: {  	_stack.Push (_stack.Peek ());  	break;  }  case ByteCode.Opcode.Call: {  	// pop arg count from stack  	ThreadState res = PushStackFrame (inst [0].GetInteger ());  	switch (res) {  	case ThreadState.Running: {  		break;  	}  	case ThreadState.Sys_Yield: {  		return ThreadState.Running;  	}  	case ThreadState.Exception: {  		_machine.SwitchThreadState (this' ThreadState.Killed);  		return ThreadState.Exception;  	}  	case ThreadState.Killed: {  		_machine.SwitchThreadState (this' ThreadState.Killed);  		break;  	}  	default: {  		break;  	}  	}  	break;  }  #region Push Operations  case ByteCode.Opcode.PushNull: {  	Push (Variable.Null);  	break;  }  case ByteCode.Opcode.PushThis: {  	Push (This);  	break;  }  case ByteCode.Opcode.PushInt0:  case ByteCode.Opcode.PushInt1:  case ByteCode.Opcode.PushInt:  case ByteCode.Opcode.PushFp:  case ByteCode.Opcode.PushStr:  case ByteCode.Opcode.PushFn: {  	Push (inst [0]);  	break;  }  case ByteCode.Opcode.PushTbl: {  	Push (new TableObject ());  	break;  }  #endregion  case ByteCode.Opcode.Ret:// Ret pushes a null   {  	Push (Variable.Null);  	ThreadState res = PopStackFrame ();  	switch (res) {  	case ThreadState.Exception:  	case ThreadState.Killed: {  		_machine.SwitchThreadState (this' res);  		return res;  	}  	default: {  		break;  	}  	}  	break;  }  case ByteCode.Opcode.Retv: {  	ThreadState res = PopStackFrame ();  	if (res == ThreadState.Killed) {  		return res;  	}  	break;  }  case ByteCode.Opcode.SetGlobal: {  	Variable v1 = inst [0];  	if (v1.Type != VariableType.String) {  		throw new Exception ("String required");  	}  	Variable v2 = _stack.Pop ();  	_machine.Globals [v1] = v2;  	break;  }  case ByteCode.Opcode.GetGlobal: {  	Variable v1 = inst [0];  	// global name  	// TODO: Check for string  	if (v1.Type != VariableType.String) {  		throw new Exception ("String required");  	}  	var global = _machine.Globals [v1];  	Push (global);  	break;  }  case ByteCode.Opcode.SetLocal: {  	int offset = inst [0].GetInteger ();  	_stack.PokeBase (offset' _stack.Pop ());  	break;  }  case ByteCode.Opcode.GetLocal: {  	int offset = inst [0].GetInteger ();  	Push (_stack.PeekBase (offset));  	break;  }  #region Operators  case ByteCode.Opcode.OpEq:  case ByteCode.Opcode.OpNeq:  case ByteCode.Opcode.OpLt:  case ByteCode.Opcode.OpLte:  case ByteCode.Opcode.OpGt:  case ByteCode.Opcode.OpGte:  case ByteCode.Opcode.OpRem:  case ByteCode.Opcode.OpAdd:  case ByteCode.Opcode.OpSub:  case ByteCode.Opcode.OpMul:  case ByteCode.Opcode.OpDiv: {  	Operator o = Operator._MAX;  	switch (inst.OpCode) {  	#region fold  	case ByteCode.Opcode.OpAdd: {  		o = Operator.Add;  		break;  	}  	case ByteCode.Opcode.OpSub: {  		o = Operator.Sub;  		break;  	}  	case ByteCode.Opcode.OpMul: {  		o = Operator.Mul;  		break;  	}  	case ByteCode.Opcode.OpDiv: {  		o = Operator.Div;  		break;  	}  	case ByteCode.Opcode.GetInd: {  		o = Operator.GetInd;  		break;  	}  	case ByteCode.Opcode.OpEq: {  		o = Operator.Eq;  		break;  	}  	case ByteCode.Opcode.OpNeq: {  		o = Operator.Neq;  		break;  	}  	case ByteCode.Opcode.OpLt: {  		o = Operator.Lt;  		break;  	}  	case ByteCode.Opcode.OpLte: {  		o = Operator.Lte;  		break;  	}  	case ByteCode.Opcode.OpGt: {  		o = Operator.Gt;  		break;  	}  	case ByteCode.Opcode.OpGte: {  		o = Operator.Gte;  		break;  	}  	case ByteCode.Opcode.OpRem: {  		o = Operator.Rem;  		break;  	}  	#endregion  	}  	if (o == Operator._MAX) {  		throw new NotImplementedException ("Operator not mapped or implemented");  	}  	var t1 = _stack.Peek (-1).TypeCode;  	var t2 = _stack.Peek (-2).TypeCode;  	if (t2 > t1) {  		t1 = t2;  	}  	OperatorCallback op = Machine.GetTypeOperator (t1' o);  	if (op != null) {  		var operand = _stack.StackPointer--;  		_stack.PokeAbs (operand - 2' op (this' _stack.PeekAbs (operand - 2)' _stack.PeekAbs (operand - 1)' _stack.PeekAbs (operand)));  	}  	else {  		throw new Exception ("Operator not defined");  	}  	break;  }  case ByteCode.Opcode.GetInd: {  	var type = _stack.Peek (-2).TypeCode;  	var op = Machine.GetTypeOperator (type' Operator.GetInd);  	if (op != null) {  		var operand = _stack.StackPointer--;  		_stack.PokeAbs (operand - 2' op (this' _stack.PeekAbs (operand - 2)' _stack.PeekAbs (operand - 1)' _stack.PeekAbs (operand)));  	}  	else {  		throw new Exception ("Operator not defined");  	}  	break;  }  case ByteCode.Opcode.SetInd: {  	var topMin3 = _stack.Peek (-3);  	OperatorCallback op = Machine.GetTypeOperator (topMin3.TypeCode' Operator.SetInd);  	if (op != null) {  		_stack.Poke (-3' op (this' topMin3' _stack.Peek (-2)' _stack.Peek (-1)));  		_stack.StackPointer -= 3;  	}  	else {  		throw new Exception ("Operator not defined");  	}  	break;  }  case ByteCode.Opcode.ForEach: {  	var topMin2 = _stack.Peek (-2);  	TypeIteratorCallback itr = Machine.GetTypeIterator (topMin2.TypeCode);  	if (itr == null) {  		_machine.Log.LogEntry ("Undefined iterator for type");  		return ThreadState.Exception;  	}  	var iteratorPos = _stack.Peek (-1).GetInteger ();  	var obj = _stack.Peek (-2).GetReference ();  	iteratorPos = itr (this' obj' iteratorPos' _stack.PeekBase (inst [1].GetInteger ())' _stack.PeekBase (inst [0].GetInteger ()));  	if (iteratorPos != -1) {  		//_Stack2[_Base + Inst[1].GetInteger()] = Key;  		//_Stack2[_Base + Inst[0].GetInteger()] = Item;  		_stack.Poke (Variable.Zero);  	}  	else {  		_stack.Poke (Variable.Zero);  	}  	_stack.Poke (-1' iteratorPos);  	++_stack.StackPointer;  	break;  }  #region Dot Operators  case ByteCode.Opcode.GetDot: {  	var v1 = _stack.Peek (-1);  	OperatorCallback op = Machine.GetTypeOperator (v1.TypeCode' Operator.GetDot);  	_stack.Poke (inst [0]);  	if (op != null) {  		_stack.Poke (-1' op (this' v1' _stack.Peek ()' _stack.Peek ()));  	}  	else {  		throw new Exception ("Operator not defined");  	}  	break;  }  case ByteCode.Opcode.SetDot: {  	var v1 = _stack.Peek (-2);  	OperatorCallback op = Machine.GetTypeOperator (v1.TypeCode' Operator.SetDot);  	_stack.Poke (inst [0]);  	if (op != null) {  		_stack.Poke (-2' op (this' _stack.Peek (-2)' _stack.Peek (-1)' _stack.Peek ()));  		_stack.StackPointer -= 2;  	}  	else {  		throw new Exception ("Operator not defined");  	}  	break;  }  #endregion  #endregion  #region Branch  case ByteCode.Opcode.Brz: {  	var v = _stack.Pop ();  	if (v.IsZero) {  		var newIp = inst [0].GetInteger ();  		if (newIp >= _instructionList.Count) {  			throw new Exception ("BRZ: Corrupt IP");  		}  		_instructionPtr = newIp;  	}  	break;  }  case ByteCode.Opcode.Brnz: {  	var v = _stack.Pop ();  	if (!v.IsZero) {  		var newIp = inst [0].GetInteger ();  		if (newIp >= _instructionList.Count) {  			throw new Exception ("BRZ: Corrupt IP");  		}  		_instructionPtr = newIp;  	}  	break;  }  case ByteCode.Opcode.Brzk: {  	var v = _stack.Peek (-1);  	if (v.IsZero) {  		var newIp = inst [0].GetInteger ();  		if (newIp >= _instructionList.Count) {  			throw new Exception ("BRZ: Corrupt IP");  		}  		_instructionPtr = newIp;  	}  	break;  }  case ByteCode.Opcode.Brnzk: {  	var v = _stack.Peek (-1);  	if (!v.IsZero) {  		var newIp = inst [0].GetInteger ();  		if (newIp >= _instructionList.Count) {  			throw new Exception ("BRNZK: Corrupt IP");  		}  		_instructionPtr = newIp;  	}  	break;  }  case ByteCode.Opcode.Bra: {  	var newIp = inst [0].GetInteger ();  	if (newIp >= _instructionList.Count) {  		throw new Exception ("BRA: Corrupt IP");  	}  	_instructionPtr = newIp;  	break;  }  #endregion  default: {  	throw new Exception ("Unknown instr");  }  }  
Magic Number,GreenBeanScript,Thread,C:\repos\evolutional_greenbeanscript\GreenBeanScript\VirtualMachine\Thread.cs,Execute,The following statement contains a magic number: switch (inst.OpCode) {  case ByteCode.Opcode.Pop: {  	_stack.Pop ();  	break;  }  case ByteCode.Opcode.Pop2: {  	_stack.Pop (2);  	break;  }  case ByteCode.Opcode.Dup: {  	_stack.Push (_stack.Peek ());  	break;  }  case ByteCode.Opcode.Call: {  	// pop arg count from stack  	ThreadState res = PushStackFrame (inst [0].GetInteger ());  	switch (res) {  	case ThreadState.Running: {  		break;  	}  	case ThreadState.Sys_Yield: {  		return ThreadState.Running;  	}  	case ThreadState.Exception: {  		_machine.SwitchThreadState (this' ThreadState.Killed);  		return ThreadState.Exception;  	}  	case ThreadState.Killed: {  		_machine.SwitchThreadState (this' ThreadState.Killed);  		break;  	}  	default: {  		break;  	}  	}  	break;  }  #region Push Operations  case ByteCode.Opcode.PushNull: {  	Push (Variable.Null);  	break;  }  case ByteCode.Opcode.PushThis: {  	Push (This);  	break;  }  case ByteCode.Opcode.PushInt0:  case ByteCode.Opcode.PushInt1:  case ByteCode.Opcode.PushInt:  case ByteCode.Opcode.PushFp:  case ByteCode.Opcode.PushStr:  case ByteCode.Opcode.PushFn: {  	Push (inst [0]);  	break;  }  case ByteCode.Opcode.PushTbl: {  	Push (new TableObject ());  	break;  }  #endregion  case ByteCode.Opcode.Ret:// Ret pushes a null   {  	Push (Variable.Null);  	ThreadState res = PopStackFrame ();  	switch (res) {  	case ThreadState.Exception:  	case ThreadState.Killed: {  		_machine.SwitchThreadState (this' res);  		return res;  	}  	default: {  		break;  	}  	}  	break;  }  case ByteCode.Opcode.Retv: {  	ThreadState res = PopStackFrame ();  	if (res == ThreadState.Killed) {  		return res;  	}  	break;  }  case ByteCode.Opcode.SetGlobal: {  	Variable v1 = inst [0];  	if (v1.Type != VariableType.String) {  		throw new Exception ("String required");  	}  	Variable v2 = _stack.Pop ();  	_machine.Globals [v1] = v2;  	break;  }  case ByteCode.Opcode.GetGlobal: {  	Variable v1 = inst [0];  	// global name  	// TODO: Check for string  	if (v1.Type != VariableType.String) {  		throw new Exception ("String required");  	}  	var global = _machine.Globals [v1];  	Push (global);  	break;  }  case ByteCode.Opcode.SetLocal: {  	int offset = inst [0].GetInteger ();  	_stack.PokeBase (offset' _stack.Pop ());  	break;  }  case ByteCode.Opcode.GetLocal: {  	int offset = inst [0].GetInteger ();  	Push (_stack.PeekBase (offset));  	break;  }  #region Operators  case ByteCode.Opcode.OpEq:  case ByteCode.Opcode.OpNeq:  case ByteCode.Opcode.OpLt:  case ByteCode.Opcode.OpLte:  case ByteCode.Opcode.OpGt:  case ByteCode.Opcode.OpGte:  case ByteCode.Opcode.OpRem:  case ByteCode.Opcode.OpAdd:  case ByteCode.Opcode.OpSub:  case ByteCode.Opcode.OpMul:  case ByteCode.Opcode.OpDiv: {  	Operator o = Operator._MAX;  	switch (inst.OpCode) {  	#region fold  	case ByteCode.Opcode.OpAdd: {  		o = Operator.Add;  		break;  	}  	case ByteCode.Opcode.OpSub: {  		o = Operator.Sub;  		break;  	}  	case ByteCode.Opcode.OpMul: {  		o = Operator.Mul;  		break;  	}  	case ByteCode.Opcode.OpDiv: {  		o = Operator.Div;  		break;  	}  	case ByteCode.Opcode.GetInd: {  		o = Operator.GetInd;  		break;  	}  	case ByteCode.Opcode.OpEq: {  		o = Operator.Eq;  		break;  	}  	case ByteCode.Opcode.OpNeq: {  		o = Operator.Neq;  		break;  	}  	case ByteCode.Opcode.OpLt: {  		o = Operator.Lt;  		break;  	}  	case ByteCode.Opcode.OpLte: {  		o = Operator.Lte;  		break;  	}  	case ByteCode.Opcode.OpGt: {  		o = Operator.Gt;  		break;  	}  	case ByteCode.Opcode.OpGte: {  		o = Operator.Gte;  		break;  	}  	case ByteCode.Opcode.OpRem: {  		o = Operator.Rem;  		break;  	}  	#endregion  	}  	if (o == Operator._MAX) {  		throw new NotImplementedException ("Operator not mapped or implemented");  	}  	var t1 = _stack.Peek (-1).TypeCode;  	var t2 = _stack.Peek (-2).TypeCode;  	if (t2 > t1) {  		t1 = t2;  	}  	OperatorCallback op = Machine.GetTypeOperator (t1' o);  	if (op != null) {  		var operand = _stack.StackPointer--;  		_stack.PokeAbs (operand - 2' op (this' _stack.PeekAbs (operand - 2)' _stack.PeekAbs (operand - 1)' _stack.PeekAbs (operand)));  	}  	else {  		throw new Exception ("Operator not defined");  	}  	break;  }  case ByteCode.Opcode.GetInd: {  	var type = _stack.Peek (-2).TypeCode;  	var op = Machine.GetTypeOperator (type' Operator.GetInd);  	if (op != null) {  		var operand = _stack.StackPointer--;  		_stack.PokeAbs (operand - 2' op (this' _stack.PeekAbs (operand - 2)' _stack.PeekAbs (operand - 1)' _stack.PeekAbs (operand)));  	}  	else {  		throw new Exception ("Operator not defined");  	}  	break;  }  case ByteCode.Opcode.SetInd: {  	var topMin3 = _stack.Peek (-3);  	OperatorCallback op = Machine.GetTypeOperator (topMin3.TypeCode' Operator.SetInd);  	if (op != null) {  		_stack.Poke (-3' op (this' topMin3' _stack.Peek (-2)' _stack.Peek (-1)));  		_stack.StackPointer -= 3;  	}  	else {  		throw new Exception ("Operator not defined");  	}  	break;  }  case ByteCode.Opcode.ForEach: {  	var topMin2 = _stack.Peek (-2);  	TypeIteratorCallback itr = Machine.GetTypeIterator (topMin2.TypeCode);  	if (itr == null) {  		_machine.Log.LogEntry ("Undefined iterator for type");  		return ThreadState.Exception;  	}  	var iteratorPos = _stack.Peek (-1).GetInteger ();  	var obj = _stack.Peek (-2).GetReference ();  	iteratorPos = itr (this' obj' iteratorPos' _stack.PeekBase (inst [1].GetInteger ())' _stack.PeekBase (inst [0].GetInteger ()));  	if (iteratorPos != -1) {  		//_Stack2[_Base + Inst[1].GetInteger()] = Key;  		//_Stack2[_Base + Inst[0].GetInteger()] = Item;  		_stack.Poke (Variable.Zero);  	}  	else {  		_stack.Poke (Variable.Zero);  	}  	_stack.Poke (-1' iteratorPos);  	++_stack.StackPointer;  	break;  }  #region Dot Operators  case ByteCode.Opcode.GetDot: {  	var v1 = _stack.Peek (-1);  	OperatorCallback op = Machine.GetTypeOperator (v1.TypeCode' Operator.GetDot);  	_stack.Poke (inst [0]);  	if (op != null) {  		_stack.Poke (-1' op (this' v1' _stack.Peek ()' _stack.Peek ()));  	}  	else {  		throw new Exception ("Operator not defined");  	}  	break;  }  case ByteCode.Opcode.SetDot: {  	var v1 = _stack.Peek (-2);  	OperatorCallback op = Machine.GetTypeOperator (v1.TypeCode' Operator.SetDot);  	_stack.Poke (inst [0]);  	if (op != null) {  		_stack.Poke (-2' op (this' _stack.Peek (-2)' _stack.Peek (-1)' _stack.Peek ()));  		_stack.StackPointer -= 2;  	}  	else {  		throw new Exception ("Operator not defined");  	}  	break;  }  #endregion  #endregion  #region Branch  case ByteCode.Opcode.Brz: {  	var v = _stack.Pop ();  	if (v.IsZero) {  		var newIp = inst [0].GetInteger ();  		if (newIp >= _instructionList.Count) {  			throw new Exception ("BRZ: Corrupt IP");  		}  		_instructionPtr = newIp;  	}  	break;  }  case ByteCode.Opcode.Brnz: {  	var v = _stack.Pop ();  	if (!v.IsZero) {  		var newIp = inst [0].GetInteger ();  		if (newIp >= _instructionList.Count) {  			throw new Exception ("BRZ: Corrupt IP");  		}  		_instructionPtr = newIp;  	}  	break;  }  case ByteCode.Opcode.Brzk: {  	var v = _stack.Peek (-1);  	if (v.IsZero) {  		var newIp = inst [0].GetInteger ();  		if (newIp >= _instructionList.Count) {  			throw new Exception ("BRZ: Corrupt IP");  		}  		_instructionPtr = newIp;  	}  	break;  }  case ByteCode.Opcode.Brnzk: {  	var v = _stack.Peek (-1);  	if (!v.IsZero) {  		var newIp = inst [0].GetInteger ();  		if (newIp >= _instructionList.Count) {  			throw new Exception ("BRNZK: Corrupt IP");  		}  		_instructionPtr = newIp;  	}  	break;  }  case ByteCode.Opcode.Bra: {  	var newIp = inst [0].GetInteger ();  	if (newIp >= _instructionList.Count) {  		throw new Exception ("BRA: Corrupt IP");  	}  	_instructionPtr = newIp;  	break;  }  #endregion  default: {  	throw new Exception ("Unknown instr");  }  }  
Magic Number,GreenBeanScript,Thread,C:\repos\evolutional_greenbeanscript\GreenBeanScript\VirtualMachine\Thread.cs,Execute,The following statement contains a magic number: switch (inst.OpCode) {  case ByteCode.Opcode.Pop: {  	_stack.Pop ();  	break;  }  case ByteCode.Opcode.Pop2: {  	_stack.Pop (2);  	break;  }  case ByteCode.Opcode.Dup: {  	_stack.Push (_stack.Peek ());  	break;  }  case ByteCode.Opcode.Call: {  	// pop arg count from stack  	ThreadState res = PushStackFrame (inst [0].GetInteger ());  	switch (res) {  	case ThreadState.Running: {  		break;  	}  	case ThreadState.Sys_Yield: {  		return ThreadState.Running;  	}  	case ThreadState.Exception: {  		_machine.SwitchThreadState (this' ThreadState.Killed);  		return ThreadState.Exception;  	}  	case ThreadState.Killed: {  		_machine.SwitchThreadState (this' ThreadState.Killed);  		break;  	}  	default: {  		break;  	}  	}  	break;  }  #region Push Operations  case ByteCode.Opcode.PushNull: {  	Push (Variable.Null);  	break;  }  case ByteCode.Opcode.PushThis: {  	Push (This);  	break;  }  case ByteCode.Opcode.PushInt0:  case ByteCode.Opcode.PushInt1:  case ByteCode.Opcode.PushInt:  case ByteCode.Opcode.PushFp:  case ByteCode.Opcode.PushStr:  case ByteCode.Opcode.PushFn: {  	Push (inst [0]);  	break;  }  case ByteCode.Opcode.PushTbl: {  	Push (new TableObject ());  	break;  }  #endregion  case ByteCode.Opcode.Ret:// Ret pushes a null   {  	Push (Variable.Null);  	ThreadState res = PopStackFrame ();  	switch (res) {  	case ThreadState.Exception:  	case ThreadState.Killed: {  		_machine.SwitchThreadState (this' res);  		return res;  	}  	default: {  		break;  	}  	}  	break;  }  case ByteCode.Opcode.Retv: {  	ThreadState res = PopStackFrame ();  	if (res == ThreadState.Killed) {  		return res;  	}  	break;  }  case ByteCode.Opcode.SetGlobal: {  	Variable v1 = inst [0];  	if (v1.Type != VariableType.String) {  		throw new Exception ("String required");  	}  	Variable v2 = _stack.Pop ();  	_machine.Globals [v1] = v2;  	break;  }  case ByteCode.Opcode.GetGlobal: {  	Variable v1 = inst [0];  	// global name  	// TODO: Check for string  	if (v1.Type != VariableType.String) {  		throw new Exception ("String required");  	}  	var global = _machine.Globals [v1];  	Push (global);  	break;  }  case ByteCode.Opcode.SetLocal: {  	int offset = inst [0].GetInteger ();  	_stack.PokeBase (offset' _stack.Pop ());  	break;  }  case ByteCode.Opcode.GetLocal: {  	int offset = inst [0].GetInteger ();  	Push (_stack.PeekBase (offset));  	break;  }  #region Operators  case ByteCode.Opcode.OpEq:  case ByteCode.Opcode.OpNeq:  case ByteCode.Opcode.OpLt:  case ByteCode.Opcode.OpLte:  case ByteCode.Opcode.OpGt:  case ByteCode.Opcode.OpGte:  case ByteCode.Opcode.OpRem:  case ByteCode.Opcode.OpAdd:  case ByteCode.Opcode.OpSub:  case ByteCode.Opcode.OpMul:  case ByteCode.Opcode.OpDiv: {  	Operator o = Operator._MAX;  	switch (inst.OpCode) {  	#region fold  	case ByteCode.Opcode.OpAdd: {  		o = Operator.Add;  		break;  	}  	case ByteCode.Opcode.OpSub: {  		o = Operator.Sub;  		break;  	}  	case ByteCode.Opcode.OpMul: {  		o = Operator.Mul;  		break;  	}  	case ByteCode.Opcode.OpDiv: {  		o = Operator.Div;  		break;  	}  	case ByteCode.Opcode.GetInd: {  		o = Operator.GetInd;  		break;  	}  	case ByteCode.Opcode.OpEq: {  		o = Operator.Eq;  		break;  	}  	case ByteCode.Opcode.OpNeq: {  		o = Operator.Neq;  		break;  	}  	case ByteCode.Opcode.OpLt: {  		o = Operator.Lt;  		break;  	}  	case ByteCode.Opcode.OpLte: {  		o = Operator.Lte;  		break;  	}  	case ByteCode.Opcode.OpGt: {  		o = Operator.Gt;  		break;  	}  	case ByteCode.Opcode.OpGte: {  		o = Operator.Gte;  		break;  	}  	case ByteCode.Opcode.OpRem: {  		o = Operator.Rem;  		break;  	}  	#endregion  	}  	if (o == Operator._MAX) {  		throw new NotImplementedException ("Operator not mapped or implemented");  	}  	var t1 = _stack.Peek (-1).TypeCode;  	var t2 = _stack.Peek (-2).TypeCode;  	if (t2 > t1) {  		t1 = t2;  	}  	OperatorCallback op = Machine.GetTypeOperator (t1' o);  	if (op != null) {  		var operand = _stack.StackPointer--;  		_stack.PokeAbs (operand - 2' op (this' _stack.PeekAbs (operand - 2)' _stack.PeekAbs (operand - 1)' _stack.PeekAbs (operand)));  	}  	else {  		throw new Exception ("Operator not defined");  	}  	break;  }  case ByteCode.Opcode.GetInd: {  	var type = _stack.Peek (-2).TypeCode;  	var op = Machine.GetTypeOperator (type' Operator.GetInd);  	if (op != null) {  		var operand = _stack.StackPointer--;  		_stack.PokeAbs (operand - 2' op (this' _stack.PeekAbs (operand - 2)' _stack.PeekAbs (operand - 1)' _stack.PeekAbs (operand)));  	}  	else {  		throw new Exception ("Operator not defined");  	}  	break;  }  case ByteCode.Opcode.SetInd: {  	var topMin3 = _stack.Peek (-3);  	OperatorCallback op = Machine.GetTypeOperator (topMin3.TypeCode' Operator.SetInd);  	if (op != null) {  		_stack.Poke (-3' op (this' topMin3' _stack.Peek (-2)' _stack.Peek (-1)));  		_stack.StackPointer -= 3;  	}  	else {  		throw new Exception ("Operator not defined");  	}  	break;  }  case ByteCode.Opcode.ForEach: {  	var topMin2 = _stack.Peek (-2);  	TypeIteratorCallback itr = Machine.GetTypeIterator (topMin2.TypeCode);  	if (itr == null) {  		_machine.Log.LogEntry ("Undefined iterator for type");  		return ThreadState.Exception;  	}  	var iteratorPos = _stack.Peek (-1).GetInteger ();  	var obj = _stack.Peek (-2).GetReference ();  	iteratorPos = itr (this' obj' iteratorPos' _stack.PeekBase (inst [1].GetInteger ())' _stack.PeekBase (inst [0].GetInteger ()));  	if (iteratorPos != -1) {  		//_Stack2[_Base + Inst[1].GetInteger()] = Key;  		//_Stack2[_Base + Inst[0].GetInteger()] = Item;  		_stack.Poke (Variable.Zero);  	}  	else {  		_stack.Poke (Variable.Zero);  	}  	_stack.Poke (-1' iteratorPos);  	++_stack.StackPointer;  	break;  }  #region Dot Operators  case ByteCode.Opcode.GetDot: {  	var v1 = _stack.Peek (-1);  	OperatorCallback op = Machine.GetTypeOperator (v1.TypeCode' Operator.GetDot);  	_stack.Poke (inst [0]);  	if (op != null) {  		_stack.Poke (-1' op (this' v1' _stack.Peek ()' _stack.Peek ()));  	}  	else {  		throw new Exception ("Operator not defined");  	}  	break;  }  case ByteCode.Opcode.SetDot: {  	var v1 = _stack.Peek (-2);  	OperatorCallback op = Machine.GetTypeOperator (v1.TypeCode' Operator.SetDot);  	_stack.Poke (inst [0]);  	if (op != null) {  		_stack.Poke (-2' op (this' _stack.Peek (-2)' _stack.Peek (-1)' _stack.Peek ()));  		_stack.StackPointer -= 2;  	}  	else {  		throw new Exception ("Operator not defined");  	}  	break;  }  #endregion  #endregion  #region Branch  case ByteCode.Opcode.Brz: {  	var v = _stack.Pop ();  	if (v.IsZero) {  		var newIp = inst [0].GetInteger ();  		if (newIp >= _instructionList.Count) {  			throw new Exception ("BRZ: Corrupt IP");  		}  		_instructionPtr = newIp;  	}  	break;  }  case ByteCode.Opcode.Brnz: {  	var v = _stack.Pop ();  	if (!v.IsZero) {  		var newIp = inst [0].GetInteger ();  		if (newIp >= _instructionList.Count) {  			throw new Exception ("BRZ: Corrupt IP");  		}  		_instructionPtr = newIp;  	}  	break;  }  case ByteCode.Opcode.Brzk: {  	var v = _stack.Peek (-1);  	if (v.IsZero) {  		var newIp = inst [0].GetInteger ();  		if (newIp >= _instructionList.Count) {  			throw new Exception ("BRZ: Corrupt IP");  		}  		_instructionPtr = newIp;  	}  	break;  }  case ByteCode.Opcode.Brnzk: {  	var v = _stack.Peek (-1);  	if (!v.IsZero) {  		var newIp = inst [0].GetInteger ();  		if (newIp >= _instructionList.Count) {  			throw new Exception ("BRNZK: Corrupt IP");  		}  		_instructionPtr = newIp;  	}  	break;  }  case ByteCode.Opcode.Bra: {  	var newIp = inst [0].GetInteger ();  	if (newIp >= _instructionList.Count) {  		throw new Exception ("BRA: Corrupt IP");  	}  	_instructionPtr = newIp;  	break;  }  #endregion  default: {  	throw new Exception ("Unknown instr");  }  }  
Magic Number,GreenBeanScript,Thread,C:\repos\evolutional_greenbeanscript\GreenBeanScript\VirtualMachine\Thread.cs,Execute,The following statement contains a magic number: switch (inst.OpCode) {  case ByteCode.Opcode.Pop: {  	_stack.Pop ();  	break;  }  case ByteCode.Opcode.Pop2: {  	_stack.Pop (2);  	break;  }  case ByteCode.Opcode.Dup: {  	_stack.Push (_stack.Peek ());  	break;  }  case ByteCode.Opcode.Call: {  	// pop arg count from stack  	ThreadState res = PushStackFrame (inst [0].GetInteger ());  	switch (res) {  	case ThreadState.Running: {  		break;  	}  	case ThreadState.Sys_Yield: {  		return ThreadState.Running;  	}  	case ThreadState.Exception: {  		_machine.SwitchThreadState (this' ThreadState.Killed);  		return ThreadState.Exception;  	}  	case ThreadState.Killed: {  		_machine.SwitchThreadState (this' ThreadState.Killed);  		break;  	}  	default: {  		break;  	}  	}  	break;  }  #region Push Operations  case ByteCode.Opcode.PushNull: {  	Push (Variable.Null);  	break;  }  case ByteCode.Opcode.PushThis: {  	Push (This);  	break;  }  case ByteCode.Opcode.PushInt0:  case ByteCode.Opcode.PushInt1:  case ByteCode.Opcode.PushInt:  case ByteCode.Opcode.PushFp:  case ByteCode.Opcode.PushStr:  case ByteCode.Opcode.PushFn: {  	Push (inst [0]);  	break;  }  case ByteCode.Opcode.PushTbl: {  	Push (new TableObject ());  	break;  }  #endregion  case ByteCode.Opcode.Ret:// Ret pushes a null   {  	Push (Variable.Null);  	ThreadState res = PopStackFrame ();  	switch (res) {  	case ThreadState.Exception:  	case ThreadState.Killed: {  		_machine.SwitchThreadState (this' res);  		return res;  	}  	default: {  		break;  	}  	}  	break;  }  case ByteCode.Opcode.Retv: {  	ThreadState res = PopStackFrame ();  	if (res == ThreadState.Killed) {  		return res;  	}  	break;  }  case ByteCode.Opcode.SetGlobal: {  	Variable v1 = inst [0];  	if (v1.Type != VariableType.String) {  		throw new Exception ("String required");  	}  	Variable v2 = _stack.Pop ();  	_machine.Globals [v1] = v2;  	break;  }  case ByteCode.Opcode.GetGlobal: {  	Variable v1 = inst [0];  	// global name  	// TODO: Check for string  	if (v1.Type != VariableType.String) {  		throw new Exception ("String required");  	}  	var global = _machine.Globals [v1];  	Push (global);  	break;  }  case ByteCode.Opcode.SetLocal: {  	int offset = inst [0].GetInteger ();  	_stack.PokeBase (offset' _stack.Pop ());  	break;  }  case ByteCode.Opcode.GetLocal: {  	int offset = inst [0].GetInteger ();  	Push (_stack.PeekBase (offset));  	break;  }  #region Operators  case ByteCode.Opcode.OpEq:  case ByteCode.Opcode.OpNeq:  case ByteCode.Opcode.OpLt:  case ByteCode.Opcode.OpLte:  case ByteCode.Opcode.OpGt:  case ByteCode.Opcode.OpGte:  case ByteCode.Opcode.OpRem:  case ByteCode.Opcode.OpAdd:  case ByteCode.Opcode.OpSub:  case ByteCode.Opcode.OpMul:  case ByteCode.Opcode.OpDiv: {  	Operator o = Operator._MAX;  	switch (inst.OpCode) {  	#region fold  	case ByteCode.Opcode.OpAdd: {  		o = Operator.Add;  		break;  	}  	case ByteCode.Opcode.OpSub: {  		o = Operator.Sub;  		break;  	}  	case ByteCode.Opcode.OpMul: {  		o = Operator.Mul;  		break;  	}  	case ByteCode.Opcode.OpDiv: {  		o = Operator.Div;  		break;  	}  	case ByteCode.Opcode.GetInd: {  		o = Operator.GetInd;  		break;  	}  	case ByteCode.Opcode.OpEq: {  		o = Operator.Eq;  		break;  	}  	case ByteCode.Opcode.OpNeq: {  		o = Operator.Neq;  		break;  	}  	case ByteCode.Opcode.OpLt: {  		o = Operator.Lt;  		break;  	}  	case ByteCode.Opcode.OpLte: {  		o = Operator.Lte;  		break;  	}  	case ByteCode.Opcode.OpGt: {  		o = Operator.Gt;  		break;  	}  	case ByteCode.Opcode.OpGte: {  		o = Operator.Gte;  		break;  	}  	case ByteCode.Opcode.OpRem: {  		o = Operator.Rem;  		break;  	}  	#endregion  	}  	if (o == Operator._MAX) {  		throw new NotImplementedException ("Operator not mapped or implemented");  	}  	var t1 = _stack.Peek (-1).TypeCode;  	var t2 = _stack.Peek (-2).TypeCode;  	if (t2 > t1) {  		t1 = t2;  	}  	OperatorCallback op = Machine.GetTypeOperator (t1' o);  	if (op != null) {  		var operand = _stack.StackPointer--;  		_stack.PokeAbs (operand - 2' op (this' _stack.PeekAbs (operand - 2)' _stack.PeekAbs (operand - 1)' _stack.PeekAbs (operand)));  	}  	else {  		throw new Exception ("Operator not defined");  	}  	break;  }  case ByteCode.Opcode.GetInd: {  	var type = _stack.Peek (-2).TypeCode;  	var op = Machine.GetTypeOperator (type' Operator.GetInd);  	if (op != null) {  		var operand = _stack.StackPointer--;  		_stack.PokeAbs (operand - 2' op (this' _stack.PeekAbs (operand - 2)' _stack.PeekAbs (operand - 1)' _stack.PeekAbs (operand)));  	}  	else {  		throw new Exception ("Operator not defined");  	}  	break;  }  case ByteCode.Opcode.SetInd: {  	var topMin3 = _stack.Peek (-3);  	OperatorCallback op = Machine.GetTypeOperator (topMin3.TypeCode' Operator.SetInd);  	if (op != null) {  		_stack.Poke (-3' op (this' topMin3' _stack.Peek (-2)' _stack.Peek (-1)));  		_stack.StackPointer -= 3;  	}  	else {  		throw new Exception ("Operator not defined");  	}  	break;  }  case ByteCode.Opcode.ForEach: {  	var topMin2 = _stack.Peek (-2);  	TypeIteratorCallback itr = Machine.GetTypeIterator (topMin2.TypeCode);  	if (itr == null) {  		_machine.Log.LogEntry ("Undefined iterator for type");  		return ThreadState.Exception;  	}  	var iteratorPos = _stack.Peek (-1).GetInteger ();  	var obj = _stack.Peek (-2).GetReference ();  	iteratorPos = itr (this' obj' iteratorPos' _stack.PeekBase (inst [1].GetInteger ())' _stack.PeekBase (inst [0].GetInteger ()));  	if (iteratorPos != -1) {  		//_Stack2[_Base + Inst[1].GetInteger()] = Key;  		//_Stack2[_Base + Inst[0].GetInteger()] = Item;  		_stack.Poke (Variable.Zero);  	}  	else {  		_stack.Poke (Variable.Zero);  	}  	_stack.Poke (-1' iteratorPos);  	++_stack.StackPointer;  	break;  }  #region Dot Operators  case ByteCode.Opcode.GetDot: {  	var v1 = _stack.Peek (-1);  	OperatorCallback op = Machine.GetTypeOperator (v1.TypeCode' Operator.GetDot);  	_stack.Poke (inst [0]);  	if (op != null) {  		_stack.Poke (-1' op (this' v1' _stack.Peek ()' _stack.Peek ()));  	}  	else {  		throw new Exception ("Operator not defined");  	}  	break;  }  case ByteCode.Opcode.SetDot: {  	var v1 = _stack.Peek (-2);  	OperatorCallback op = Machine.GetTypeOperator (v1.TypeCode' Operator.SetDot);  	_stack.Poke (inst [0]);  	if (op != null) {  		_stack.Poke (-2' op (this' _stack.Peek (-2)' _stack.Peek (-1)' _stack.Peek ()));  		_stack.StackPointer -= 2;  	}  	else {  		throw new Exception ("Operator not defined");  	}  	break;  }  #endregion  #endregion  #region Branch  case ByteCode.Opcode.Brz: {  	var v = _stack.Pop ();  	if (v.IsZero) {  		var newIp = inst [0].GetInteger ();  		if (newIp >= _instructionList.Count) {  			throw new Exception ("BRZ: Corrupt IP");  		}  		_instructionPtr = newIp;  	}  	break;  }  case ByteCode.Opcode.Brnz: {  	var v = _stack.Pop ();  	if (!v.IsZero) {  		var newIp = inst [0].GetInteger ();  		if (newIp >= _instructionList.Count) {  			throw new Exception ("BRZ: Corrupt IP");  		}  		_instructionPtr = newIp;  	}  	break;  }  case ByteCode.Opcode.Brzk: {  	var v = _stack.Peek (-1);  	if (v.IsZero) {  		var newIp = inst [0].GetInteger ();  		if (newIp >= _instructionList.Count) {  			throw new Exception ("BRZ: Corrupt IP");  		}  		_instructionPtr = newIp;  	}  	break;  }  case ByteCode.Opcode.Brnzk: {  	var v = _stack.Peek (-1);  	if (!v.IsZero) {  		var newIp = inst [0].GetInteger ();  		if (newIp >= _instructionList.Count) {  			throw new Exception ("BRNZK: Corrupt IP");  		}  		_instructionPtr = newIp;  	}  	break;  }  case ByteCode.Opcode.Bra: {  	var newIp = inst [0].GetInteger ();  	if (newIp >= _instructionList.Count) {  		throw new Exception ("BRA: Corrupt IP");  	}  	_instructionPtr = newIp;  	break;  }  #endregion  default: {  	throw new Exception ("Unknown instr");  }  }  
Magic Number,GreenBeanScript,Thread,C:\repos\evolutional_greenbeanscript\GreenBeanScript\VirtualMachine\Thread.cs,Execute,The following statement contains a magic number: switch (inst.OpCode) {  case ByteCode.Opcode.Pop: {  	_stack.Pop ();  	break;  }  case ByteCode.Opcode.Pop2: {  	_stack.Pop (2);  	break;  }  case ByteCode.Opcode.Dup: {  	_stack.Push (_stack.Peek ());  	break;  }  case ByteCode.Opcode.Call: {  	// pop arg count from stack  	ThreadState res = PushStackFrame (inst [0].GetInteger ());  	switch (res) {  	case ThreadState.Running: {  		break;  	}  	case ThreadState.Sys_Yield: {  		return ThreadState.Running;  	}  	case ThreadState.Exception: {  		_machine.SwitchThreadState (this' ThreadState.Killed);  		return ThreadState.Exception;  	}  	case ThreadState.Killed: {  		_machine.SwitchThreadState (this' ThreadState.Killed);  		break;  	}  	default: {  		break;  	}  	}  	break;  }  #region Push Operations  case ByteCode.Opcode.PushNull: {  	Push (Variable.Null);  	break;  }  case ByteCode.Opcode.PushThis: {  	Push (This);  	break;  }  case ByteCode.Opcode.PushInt0:  case ByteCode.Opcode.PushInt1:  case ByteCode.Opcode.PushInt:  case ByteCode.Opcode.PushFp:  case ByteCode.Opcode.PushStr:  case ByteCode.Opcode.PushFn: {  	Push (inst [0]);  	break;  }  case ByteCode.Opcode.PushTbl: {  	Push (new TableObject ());  	break;  }  #endregion  case ByteCode.Opcode.Ret:// Ret pushes a null   {  	Push (Variable.Null);  	ThreadState res = PopStackFrame ();  	switch (res) {  	case ThreadState.Exception:  	case ThreadState.Killed: {  		_machine.SwitchThreadState (this' res);  		return res;  	}  	default: {  		break;  	}  	}  	break;  }  case ByteCode.Opcode.Retv: {  	ThreadState res = PopStackFrame ();  	if (res == ThreadState.Killed) {  		return res;  	}  	break;  }  case ByteCode.Opcode.SetGlobal: {  	Variable v1 = inst [0];  	if (v1.Type != VariableType.String) {  		throw new Exception ("String required");  	}  	Variable v2 = _stack.Pop ();  	_machine.Globals [v1] = v2;  	break;  }  case ByteCode.Opcode.GetGlobal: {  	Variable v1 = inst [0];  	// global name  	// TODO: Check for string  	if (v1.Type != VariableType.String) {  		throw new Exception ("String required");  	}  	var global = _machine.Globals [v1];  	Push (global);  	break;  }  case ByteCode.Opcode.SetLocal: {  	int offset = inst [0].GetInteger ();  	_stack.PokeBase (offset' _stack.Pop ());  	break;  }  case ByteCode.Opcode.GetLocal: {  	int offset = inst [0].GetInteger ();  	Push (_stack.PeekBase (offset));  	break;  }  #region Operators  case ByteCode.Opcode.OpEq:  case ByteCode.Opcode.OpNeq:  case ByteCode.Opcode.OpLt:  case ByteCode.Opcode.OpLte:  case ByteCode.Opcode.OpGt:  case ByteCode.Opcode.OpGte:  case ByteCode.Opcode.OpRem:  case ByteCode.Opcode.OpAdd:  case ByteCode.Opcode.OpSub:  case ByteCode.Opcode.OpMul:  case ByteCode.Opcode.OpDiv: {  	Operator o = Operator._MAX;  	switch (inst.OpCode) {  	#region fold  	case ByteCode.Opcode.OpAdd: {  		o = Operator.Add;  		break;  	}  	case ByteCode.Opcode.OpSub: {  		o = Operator.Sub;  		break;  	}  	case ByteCode.Opcode.OpMul: {  		o = Operator.Mul;  		break;  	}  	case ByteCode.Opcode.OpDiv: {  		o = Operator.Div;  		break;  	}  	case ByteCode.Opcode.GetInd: {  		o = Operator.GetInd;  		break;  	}  	case ByteCode.Opcode.OpEq: {  		o = Operator.Eq;  		break;  	}  	case ByteCode.Opcode.OpNeq: {  		o = Operator.Neq;  		break;  	}  	case ByteCode.Opcode.OpLt: {  		o = Operator.Lt;  		break;  	}  	case ByteCode.Opcode.OpLte: {  		o = Operator.Lte;  		break;  	}  	case ByteCode.Opcode.OpGt: {  		o = Operator.Gt;  		break;  	}  	case ByteCode.Opcode.OpGte: {  		o = Operator.Gte;  		break;  	}  	case ByteCode.Opcode.OpRem: {  		o = Operator.Rem;  		break;  	}  	#endregion  	}  	if (o == Operator._MAX) {  		throw new NotImplementedException ("Operator not mapped or implemented");  	}  	var t1 = _stack.Peek (-1).TypeCode;  	var t2 = _stack.Peek (-2).TypeCode;  	if (t2 > t1) {  		t1 = t2;  	}  	OperatorCallback op = Machine.GetTypeOperator (t1' o);  	if (op != null) {  		var operand = _stack.StackPointer--;  		_stack.PokeAbs (operand - 2' op (this' _stack.PeekAbs (operand - 2)' _stack.PeekAbs (operand - 1)' _stack.PeekAbs (operand)));  	}  	else {  		throw new Exception ("Operator not defined");  	}  	break;  }  case ByteCode.Opcode.GetInd: {  	var type = _stack.Peek (-2).TypeCode;  	var op = Machine.GetTypeOperator (type' Operator.GetInd);  	if (op != null) {  		var operand = _stack.StackPointer--;  		_stack.PokeAbs (operand - 2' op (this' _stack.PeekAbs (operand - 2)' _stack.PeekAbs (operand - 1)' _stack.PeekAbs (operand)));  	}  	else {  		throw new Exception ("Operator not defined");  	}  	break;  }  case ByteCode.Opcode.SetInd: {  	var topMin3 = _stack.Peek (-3);  	OperatorCallback op = Machine.GetTypeOperator (topMin3.TypeCode' Operator.SetInd);  	if (op != null) {  		_stack.Poke (-3' op (this' topMin3' _stack.Peek (-2)' _stack.Peek (-1)));  		_stack.StackPointer -= 3;  	}  	else {  		throw new Exception ("Operator not defined");  	}  	break;  }  case ByteCode.Opcode.ForEach: {  	var topMin2 = _stack.Peek (-2);  	TypeIteratorCallback itr = Machine.GetTypeIterator (topMin2.TypeCode);  	if (itr == null) {  		_machine.Log.LogEntry ("Undefined iterator for type");  		return ThreadState.Exception;  	}  	var iteratorPos = _stack.Peek (-1).GetInteger ();  	var obj = _stack.Peek (-2).GetReference ();  	iteratorPos = itr (this' obj' iteratorPos' _stack.PeekBase (inst [1].GetInteger ())' _stack.PeekBase (inst [0].GetInteger ()));  	if (iteratorPos != -1) {  		//_Stack2[_Base + Inst[1].GetInteger()] = Key;  		//_Stack2[_Base + Inst[0].GetInteger()] = Item;  		_stack.Poke (Variable.Zero);  	}  	else {  		_stack.Poke (Variable.Zero);  	}  	_stack.Poke (-1' iteratorPos);  	++_stack.StackPointer;  	break;  }  #region Dot Operators  case ByteCode.Opcode.GetDot: {  	var v1 = _stack.Peek (-1);  	OperatorCallback op = Machine.GetTypeOperator (v1.TypeCode' Operator.GetDot);  	_stack.Poke (inst [0]);  	if (op != null) {  		_stack.Poke (-1' op (this' v1' _stack.Peek ()' _stack.Peek ()));  	}  	else {  		throw new Exception ("Operator not defined");  	}  	break;  }  case ByteCode.Opcode.SetDot: {  	var v1 = _stack.Peek (-2);  	OperatorCallback op = Machine.GetTypeOperator (v1.TypeCode' Operator.SetDot);  	_stack.Poke (inst [0]);  	if (op != null) {  		_stack.Poke (-2' op (this' _stack.Peek (-2)' _stack.Peek (-1)' _stack.Peek ()));  		_stack.StackPointer -= 2;  	}  	else {  		throw new Exception ("Operator not defined");  	}  	break;  }  #endregion  #endregion  #region Branch  case ByteCode.Opcode.Brz: {  	var v = _stack.Pop ();  	if (v.IsZero) {  		var newIp = inst [0].GetInteger ();  		if (newIp >= _instructionList.Count) {  			throw new Exception ("BRZ: Corrupt IP");  		}  		_instructionPtr = newIp;  	}  	break;  }  case ByteCode.Opcode.Brnz: {  	var v = _stack.Pop ();  	if (!v.IsZero) {  		var newIp = inst [0].GetInteger ();  		if (newIp >= _instructionList.Count) {  			throw new Exception ("BRZ: Corrupt IP");  		}  		_instructionPtr = newIp;  	}  	break;  }  case ByteCode.Opcode.Brzk: {  	var v = _stack.Peek (-1);  	if (v.IsZero) {  		var newIp = inst [0].GetInteger ();  		if (newIp >= _instructionList.Count) {  			throw new Exception ("BRZ: Corrupt IP");  		}  		_instructionPtr = newIp;  	}  	break;  }  case ByteCode.Opcode.Brnzk: {  	var v = _stack.Peek (-1);  	if (!v.IsZero) {  		var newIp = inst [0].GetInteger ();  		if (newIp >= _instructionList.Count) {  			throw new Exception ("BRNZK: Corrupt IP");  		}  		_instructionPtr = newIp;  	}  	break;  }  case ByteCode.Opcode.Bra: {  	var newIp = inst [0].GetInteger ();  	if (newIp >= _instructionList.Count) {  		throw new Exception ("BRA: Corrupt IP");  	}  	_instructionPtr = newIp;  	break;  }  #endregion  default: {  	throw new Exception ("Unknown instr");  }  }  
Magic Number,GreenBeanScript,Thread,C:\repos\evolutional_greenbeanscript\GreenBeanScript\VirtualMachine\Thread.cs,Execute,The following statement contains a magic number: _stack.Pop (2);  
Magic Number,GreenBeanScript,Thread,C:\repos\evolutional_greenbeanscript\GreenBeanScript\VirtualMachine\Thread.cs,Execute,The following statement contains a magic number: if (op != null) {  	var operand = _stack.StackPointer--;  	_stack.PokeAbs (operand - 2' op (this' _stack.PeekAbs (operand - 2)' _stack.PeekAbs (operand - 1)' _stack.PeekAbs (operand)));  }  else {  	throw new Exception ("Operator not defined");  }  
Magic Number,GreenBeanScript,Thread,C:\repos\evolutional_greenbeanscript\GreenBeanScript\VirtualMachine\Thread.cs,Execute,The following statement contains a magic number: if (op != null) {  	var operand = _stack.StackPointer--;  	_stack.PokeAbs (operand - 2' op (this' _stack.PeekAbs (operand - 2)' _stack.PeekAbs (operand - 1)' _stack.PeekAbs (operand)));  }  else {  	throw new Exception ("Operator not defined");  }  
Magic Number,GreenBeanScript,Thread,C:\repos\evolutional_greenbeanscript\GreenBeanScript\VirtualMachine\Thread.cs,Execute,The following statement contains a magic number: _stack.PokeAbs (operand - 2' op (this' _stack.PeekAbs (operand - 2)' _stack.PeekAbs (operand - 1)' _stack.PeekAbs (operand)));  
Magic Number,GreenBeanScript,Thread,C:\repos\evolutional_greenbeanscript\GreenBeanScript\VirtualMachine\Thread.cs,Execute,The following statement contains a magic number: _stack.PokeAbs (operand - 2' op (this' _stack.PeekAbs (operand - 2)' _stack.PeekAbs (operand - 1)' _stack.PeekAbs (operand)));  
Magic Number,GreenBeanScript,Thread,C:\repos\evolutional_greenbeanscript\GreenBeanScript\VirtualMachine\Thread.cs,Execute,The following statement contains a magic number: if (op != null) {  	var operand = _stack.StackPointer--;  	_stack.PokeAbs (operand - 2' op (this' _stack.PeekAbs (operand - 2)' _stack.PeekAbs (operand - 1)' _stack.PeekAbs (operand)));  }  else {  	throw new Exception ("Operator not defined");  }  
Magic Number,GreenBeanScript,Thread,C:\repos\evolutional_greenbeanscript\GreenBeanScript\VirtualMachine\Thread.cs,Execute,The following statement contains a magic number: if (op != null) {  	var operand = _stack.StackPointer--;  	_stack.PokeAbs (operand - 2' op (this' _stack.PeekAbs (operand - 2)' _stack.PeekAbs (operand - 1)' _stack.PeekAbs (operand)));  }  else {  	throw new Exception ("Operator not defined");  }  
Magic Number,GreenBeanScript,Thread,C:\repos\evolutional_greenbeanscript\GreenBeanScript\VirtualMachine\Thread.cs,Execute,The following statement contains a magic number: _stack.PokeAbs (operand - 2' op (this' _stack.PeekAbs (operand - 2)' _stack.PeekAbs (operand - 1)' _stack.PeekAbs (operand)));  
Magic Number,GreenBeanScript,Thread,C:\repos\evolutional_greenbeanscript\GreenBeanScript\VirtualMachine\Thread.cs,Execute,The following statement contains a magic number: _stack.PokeAbs (operand - 2' op (this' _stack.PeekAbs (operand - 2)' _stack.PeekAbs (operand - 1)' _stack.PeekAbs (operand)));  
Magic Number,GreenBeanScript,Thread,C:\repos\evolutional_greenbeanscript\GreenBeanScript\VirtualMachine\Thread.cs,Execute,The following statement contains a magic number: if (op != null) {  	_stack.Poke (-3' op (this' topMin3' _stack.Peek (-2)' _stack.Peek (-1)));  	_stack.StackPointer -= 3;  }  else {  	throw new Exception ("Operator not defined");  }  
Magic Number,GreenBeanScript,Thread,C:\repos\evolutional_greenbeanscript\GreenBeanScript\VirtualMachine\Thread.cs,Execute,The following statement contains a magic number: if (op != null) {  	_stack.Poke (-3' op (this' topMin3' _stack.Peek (-2)' _stack.Peek (-1)));  	_stack.StackPointer -= 3;  }  else {  	throw new Exception ("Operator not defined");  }  
Magic Number,GreenBeanScript,Thread,C:\repos\evolutional_greenbeanscript\GreenBeanScript\VirtualMachine\Thread.cs,Execute,The following statement contains a magic number: if (op != null) {  	_stack.Poke (-3' op (this' topMin3' _stack.Peek (-2)' _stack.Peek (-1)));  	_stack.StackPointer -= 3;  }  else {  	throw new Exception ("Operator not defined");  }  
Magic Number,GreenBeanScript,Thread,C:\repos\evolutional_greenbeanscript\GreenBeanScript\VirtualMachine\Thread.cs,Execute,The following statement contains a magic number: _stack.Poke (-3' op (this' topMin3' _stack.Peek (-2)' _stack.Peek (-1)));  
Magic Number,GreenBeanScript,Thread,C:\repos\evolutional_greenbeanscript\GreenBeanScript\VirtualMachine\Thread.cs,Execute,The following statement contains a magic number: _stack.Poke (-3' op (this' topMin3' _stack.Peek (-2)' _stack.Peek (-1)));  
Magic Number,GreenBeanScript,Thread,C:\repos\evolutional_greenbeanscript\GreenBeanScript\VirtualMachine\Thread.cs,Execute,The following statement contains a magic number: _stack.StackPointer -= 3;  
Magic Number,GreenBeanScript,Thread,C:\repos\evolutional_greenbeanscript\GreenBeanScript\VirtualMachine\Thread.cs,Execute,The following statement contains a magic number: if (op != null) {  	_stack.Poke (-2' op (this' _stack.Peek (-2)' _stack.Peek (-1)' _stack.Peek ()));  	_stack.StackPointer -= 2;  }  else {  	throw new Exception ("Operator not defined");  }  
Magic Number,GreenBeanScript,Thread,C:\repos\evolutional_greenbeanscript\GreenBeanScript\VirtualMachine\Thread.cs,Execute,The following statement contains a magic number: if (op != null) {  	_stack.Poke (-2' op (this' _stack.Peek (-2)' _stack.Peek (-1)' _stack.Peek ()));  	_stack.StackPointer -= 2;  }  else {  	throw new Exception ("Operator not defined");  }  
Magic Number,GreenBeanScript,Thread,C:\repos\evolutional_greenbeanscript\GreenBeanScript\VirtualMachine\Thread.cs,Execute,The following statement contains a magic number: if (op != null) {  	_stack.Poke (-2' op (this' _stack.Peek (-2)' _stack.Peek (-1)' _stack.Peek ()));  	_stack.StackPointer -= 2;  }  else {  	throw new Exception ("Operator not defined");  }  
Magic Number,GreenBeanScript,Thread,C:\repos\evolutional_greenbeanscript\GreenBeanScript\VirtualMachine\Thread.cs,Execute,The following statement contains a magic number: _stack.Poke (-2' op (this' _stack.Peek (-2)' _stack.Peek (-1)' _stack.Peek ()));  
Magic Number,GreenBeanScript,Thread,C:\repos\evolutional_greenbeanscript\GreenBeanScript\VirtualMachine\Thread.cs,Execute,The following statement contains a magic number: _stack.Poke (-2' op (this' _stack.Peek (-2)' _stack.Peek (-1)' _stack.Peek ()));  
Magic Number,GreenBeanScript,Thread,C:\repos\evolutional_greenbeanscript\GreenBeanScript\VirtualMachine\Thread.cs,Execute,The following statement contains a magic number: _stack.StackPointer -= 2;  
Magic Number,TableOperators,OperatorCallbacks,C:\repos\evolutional_greenbeanscript\GreenBeanScript\VirtualMachine\Operations\TableObject.cs,Iterator,The following statement contains a magic number: if (IteratorPosition == -2) {  	IteratorPosition = 0;  }  
Missing Default,GreenBeanScript.Libs,StdLibrary,C:\repos\evolutional_greenbeanscript\GreenBeanScript\Libs\StdLibrary.cs,FormatFunction,The following switch statement is missing a default case: switch (c1) {  case 'X':  case 'x': {  	if (!ScriptThread.Param (param).IsInt) {  		return FunctionResult.Exception;  	}  	sb.AppendFormat ("{0:X}"' ScriptThread.Param (param).GetIntegerNoCheck ());  	++param;  	break;  }  }  
Missing Default,GreenBeanScript,Thread,C:\repos\evolutional_greenbeanscript\GreenBeanScript\VirtualMachine\Thread.cs,Execute,The following switch statement is missing a default case: switch (inst.OpCode) {  #region fold  case ByteCode.Opcode.OpAdd: {  	o = Operator.Add;  	break;  }  case ByteCode.Opcode.OpSub: {  	o = Operator.Sub;  	break;  }  case ByteCode.Opcode.OpMul: {  	o = Operator.Mul;  	break;  }  case ByteCode.Opcode.OpDiv: {  	o = Operator.Div;  	break;  }  case ByteCode.Opcode.GetInd: {  	o = Operator.GetInd;  	break;  }  case ByteCode.Opcode.OpEq: {  	o = Operator.Eq;  	break;  }  case ByteCode.Opcode.OpNeq: {  	o = Operator.Neq;  	break;  }  case ByteCode.Opcode.OpLt: {  	o = Operator.Lt;  	break;  }  case ByteCode.Opcode.OpLte: {  	o = Operator.Lte;  	break;  }  case ByteCode.Opcode.OpGt: {  	o = Operator.Gt;  	break;  }  case ByteCode.Opcode.OpGte: {  	o = Operator.Gte;  	break;  }  case ByteCode.Opcode.OpRem: {  	o = Operator.Rem;  	break;  }  #endregion  }  
