Implementation smell,Namespace,Class,File,Method,Description
Long Method,GotDotNet.XPath,XPathScanner,C:\repos\Consid-Varnamo_Common\XPathReader\xpathscanner.cs,NextLex,The method has 129 lines of code.
Complex Method,GotDotNet.XPath,BaseAxisQuery,C:\repos\Consid-Varnamo_Common\XPathReader\BaseQuery.cs,MatchType,Cyclomatic complexity of the method is 22
Complex Method,GotDotNet.XPath,LogicalExpr,C:\repos\Consid-Varnamo_Common\XPathReader\ExprQuery.cs,CompareAsNumber,Cyclomatic complexity of the method is 19
Complex Method,GotDotNet.XPath,LogicalExpr,C:\repos\Consid-Varnamo_Common\XPathReader\ExprQuery.cs,CompareAsString,Cyclomatic complexity of the method is 20
Complex Method,GotDotNet.XPath,LogicalExpr,C:\repos\Consid-Varnamo_Common\XPathReader\ExprQuery.cs,CompareAsBoolean,Cyclomatic complexity of the method is 17
Complex Method,GotDotNet.XPath,StringFunctions,C:\repos\Consid-Varnamo_Common\XPathReader\FunctionQuery.cs,GetValue,Cyclomatic complexity of the method is 30
Complex Method,GotDotNet.XPath,NumberFunctions,C:\repos\Consid-Varnamo_Common\XPathReader\FunctionQuery.cs,GetValue,Cyclomatic complexity of the method is 12
Complex Method,GotDotNet.XPath,BooleanFunctions,C:\repos\Consid-Varnamo_Common\XPathReader\FunctionQuery.cs,GetValue,Cyclomatic complexity of the method is 15
Complex Method,GotDotNet.XPath,MethodOperand,C:\repos\Consid-Varnamo_Common\XPathReader\OperandQuery.cs,GetValue,Cyclomatic complexity of the method is 15
Complex Method,GotDotNet.XPath,QueryBuilder,C:\repos\Consid-Varnamo_Common\XPathReader\queryBuilder.cs,MapNodeType,Cyclomatic complexity of the method is 17
Complex Method,GotDotNet.XPath,QueryBuilder,C:\repos\Consid-Varnamo_Common\XPathReader\queryBuilder.cs,ProcessFunction,Cyclomatic complexity of the method is 42
Complex Method,GotDotNet.XPath,QueryBuilder,C:\repos\Consid-Varnamo_Common\XPathReader\queryBuilder.cs,ProcessAxis,Cyclomatic complexity of the method is 15
Complex Method,GotDotNet.XPath,QueryBuilder,C:\repos\Consid-Varnamo_Common\XPathReader\queryBuilder.cs,ProcessNode,Cyclomatic complexity of the method is 25
Complex Method,GotDotNet.XPath,QueryBuilder,C:\repos\Consid-Varnamo_Common\XPathReader\queryBuilder.cs,Build,Cyclomatic complexity of the method is 9
Complex Method,GotDotNet.XPath,XPathParser,C:\repos\Consid-Varnamo_Common\XPathReader\xpathparser.cs,ParseStep,Cyclomatic complexity of the method is 11
Complex Method,GotDotNet.XPath,XPathParser,C:\repos\Consid-Varnamo_Common\XPathReader\xpathparser.cs,ParseNodeTest,Cyclomatic complexity of the method is 14
Complex Method,GotDotNet.XPath,XPathParser,C:\repos\Consid-Varnamo_Common\XPathReader\xpathparser.cs,ParsePrimaryExpr,Cyclomatic complexity of the method is 25
Complex Method,GotDotNet.XPath,XPathParser,C:\repos\Consid-Varnamo_Common\XPathReader\xpathparser.cs,ParseMethod,Cyclomatic complexity of the method is 26
Complex Method,GotDotNet.XPath,XPathParser,C:\repos\Consid-Varnamo_Common\XPathReader\xpathparser.cs,ParseLocationPathPattern,Cyclomatic complexity of the method is 22
Complex Method,GotDotNet.XPath,XPathParser,C:\repos\Consid-Varnamo_Common\XPathReader\xpathparser.cs,ParseStepPattern,Cyclomatic complexity of the method is 11
Complex Method,GotDotNet.XPath,XPathScanner,C:\repos\Consid-Varnamo_Common\XPathReader\xpathscanner.cs,NextLex,Cyclomatic complexity of the method is 65
Complex Method,GotDotNet.XPath,XPathScanner,C:\repos\Consid-Varnamo_Common\XPathReader\xpathscanner.cs,ToXPathDouble,Cyclomatic complexity of the method is 8
Long Parameter List,GotDotNet.XPath,Axis,C:\repos\Consid-Varnamo_Common\XPathReader\axis.cs,Axis,The method has 5 parameters.
Long Statement,GotDotNet.XPath,ChildQuery,C:\repos\Consid-Varnamo_Common\XPathReader\AxisQuery.cs,MatchNode,The length of the statement  "		else if (base.Name != string.Empty && (base.Name != reader.LocalName || (base.Prefix.Length != 0 && reader.MapPrefixWithNamespace (base.Prefix) == false))) { " is 157.
Long Statement,GotDotNet.XPath,XPathParser,C:\repos\Consid-Varnamo_Common\XPathReader\xpathparser.cs,ParseEqualityExpr,The length of the statement  "		Operator.Op op = (this.scanner.Kind == XPathScanner.LexKind.Eq ? Operator.Op.EQ : this.scanner.Kind == XPathScanner.LexKind.Ne ? Operator.Op.NE : /*default :*/Operator.Op.INVALID); " is 180.
Long Statement,GotDotNet.XPath,XPathParser,C:\repos\Consid-Varnamo_Common\XPathReader\xpathparser.cs,ParseRelationalExpr,The length of the statement  "		Operator.Op op = (this.scanner.Kind == XPathScanner.LexKind.Lt ? Operator.Op.LT : this.scanner.Kind == XPathScanner.LexKind.Le ? Operator.Op.LE : this.scanner.Kind == XPathScanner.LexKind.Gt ? Operator.Op.GT : this.scanner.Kind == XPathScanner.LexKind.Ge ? Operator.Op.GE : /*default :*/Operator.Op.INVALID); " is 308.
Long Statement,GotDotNet.XPath,XPathParser,C:\repos\Consid-Varnamo_Common\XPathReader\xpathparser.cs,ParseAdditiveExpr,The length of the statement  "		Operator.Op op = (this.scanner.Kind == XPathScanner.LexKind.Plus ? Operator.Op.PLUS : this.scanner.Kind == XPathScanner.LexKind.Minus ? Operator.Op.MINUS : /*default :*/Operator.Op.INVALID); " is 190.
Long Statement,GotDotNet.XPath,XPathParser,C:\repos\Consid-Varnamo_Common\XPathReader\xpathparser.cs,ParseMultiplicativeExpr,The length of the statement  "		Operator.Op op = (this.scanner.Kind == XPathScanner.LexKind.Star ? Operator.Op.MUL : TestOp ("div") ? Operator.Op.DIV : TestOp ("mod") ? Operator.Op.MOD : /*default :*/Operator.Op.INVALID); " is 189.
Long Statement,GotDotNet.XPath,XPathParser,C:\repos\Consid-Varnamo_Common\XPathReader\xpathparser.cs,IsNodeType,The length of the statement  "	return (scaner.Prefix.Length == 0 && (scaner.Name == "node" || scaner.Name == "text" || scaner.Name == "processing-instruction" || scaner.Name == "comment")); " is 158.
Long Statement,GotDotNet.XPath,XPathParser,C:\repos\Consid-Varnamo_Common\XPathReader\xpathparser.cs,IsStep,The length of the statement  "	return (lexKind == XPathScanner.LexKind.Dot || lexKind == XPathScanner.LexKind.DotDot || lexKind == XPathScanner.LexKind.At || lexKind == XPathScanner.LexKind.Axe || lexKind == XPathScanner.LexKind.Star || lexKind == XPathScanner.LexKind.Name// NodeTest is also Name " is 266.
Long Statement,GotDotNet.XPath,XPathParser,C:\repos\Consid-Varnamo_Common\XPathReader\xpathparser.cs,ParseStep,The length of the statement  "		XPathNodeType nodeType = (axisType == Axis.AxisType.Attribute ? XPathNodeType.Attribute : //                    axisType == Axis.AxisType.Namespace ? XPathNodeType.Namespace : // No Idea why it's this way but othervise Axes doesn't work " is 236.
Long Statement,GotDotNet.XPath,XPathParser,C:\repos\Consid-Varnamo_Common\XPathReader\xpathparser.cs,ParseNodeTest,The length of the statement  "			nodeType = (this.scanner.Name == "comment" ? XPathNodeType.Comment : this.scanner.Name == "text" ? XPathNodeType.Text : this.scanner.Name == "node" ? XPathNodeType.All : this.scanner.Name == "processing-instruction" ? XPathNodeType.ProcessingInstruction : /* default: */XPathNodeType.Root); " is 290.
Long Statement,GotDotNet.XPath,XPathParser,C:\repos\Consid-Varnamo_Common\XPathReader\xpathparser.cs,IsPrimaryExpr,The length of the statement  "	return (scanner.Kind == XPathScanner.LexKind.String || scanner.Kind == XPathScanner.LexKind.Number || scanner.Kind == XPathScanner.LexKind.Dollar || scanner.Kind == XPathScanner.LexKind.LParens || scanner.Kind == XPathScanner.LexKind.Name && scanner.CanBeFunction && !IsNodeType (scanner)); " is 290.
Long Statement,GotDotNet.XPath,XPathParser,C:\repos\Consid-Varnamo_Common\XPathReader\xpathparser.cs,ParseMethod,The length of the statement  "				throw new XPathException (String.Format ("Function '{0}' in '{1}' has invalid number of arguments."' name' this.scanner.SourceText)); " is 133.
Long Statement,GotDotNet.XPath,XPathParser,C:\repos\Consid-Varnamo_Common\XPathReader\xpathparser.cs,ParseMethod,The length of the statement  "					throw new XPathException (String.Format ("Function '{0}' in '{1}' has invalid number of arguments."' name' this.scanner.SourceText)); " is 133.
Long Statement,GotDotNet.XPath,XPathParser,C:\repos\Consid-Varnamo_Common\XPathReader\xpathparser.cs,ParseMethod,The length of the statement  "								throw new XPathException (String.Format ("Function '{0}' in '{1}' has invalid number of arguments."' name' this.scanner.SourceText)); " is 133.
Long Statement,GotDotNet.XPath,XPathParser,C:\repos\Consid-Varnamo_Common\XPathReader\xpathparser.cs,ParseStepPattern,The length of the statement  "	XPathNodeType nodeType = (axisType == Axis.AxisType.Attribute ? XPathNodeType.Attribute : /* default: */XPathNodeType.Element); " is 127.
Long Statement,GotDotNet.XPath,XPathParser,C:\repos\Consid-Varnamo_Common\XPathReader\xpathparser.cs,TestOp,The length of the statement  "	return (this.scanner.Kind == XPathScanner.LexKind.Name && this.scanner.Prefix.Length == 0 && this.scanner.Name.Equals (op)); " is 124.
Long Statement,GotDotNet.XPath,XPathScanner,C:\repos\Consid-Varnamo_Common\XPathReader\xpathscanner.cs,ToXPathDouble,The length of the statement  "					return Double.Parse (str' NumberStyles.AllowLeadingSign | NumberStyles.AllowDecimalPoint | NumberStyles.AllowTrailingWhite' NumberFormatInfo.InvariantInfo); " is 156.
Complex Conditional,GotDotNet.XPath,ChildQuery,C:\repos\Consid-Varnamo_Common\XPathReader\AxisQuery.cs,MatchNode,The conditional expression  "base.Name != string.Empty && (base.Name != reader.LocalName || (base.Prefix.Length != 0 && reader.MapPrefixWithNamespace (base.Prefix) == false))"  is complex.
Complex Conditional,GotDotNet.XPath,LogicalExpr,C:\repos\Consid-Varnamo_Common\XPathReader\ExprQuery.cs,CompareAsString,The conditional expression  "(Operator.Op.EQ == op && s1.Equals (s2)) || (Operator.Op.NE == op && !s2.Equals (s2))"  is complex.
Complex Conditional,GotDotNet.XPath,LogicalExpr,C:\repos\Consid-Varnamo_Common\XPathReader\ExprQuery.cs,CompareAsBoolean,The conditional expression  "(Operator.Op.EQ == op && b1 == b2) || (Operator.Op.NE == op && b1 != b2)"  is complex.
Virtual Method Call from Constructor,GotDotNet.XPath,NumericExpr,C:\repos\Consid-Varnamo_Common\XPathReader\ExprQuery.cs,NumericExpr,The constructor "NumericExpr" calls a virtual method "ReturnType".
Virtual Method Call from Constructor,GotDotNet.XPath,NumericExpr,C:\repos\Consid-Varnamo_Common\XPathReader\ExprQuery.cs,NumericExpr,The constructor "NumericExpr" calls a virtual method "ReturnType".
Empty Catch Block,GotDotNet.XPath,LogicalExpr,C:\repos\Consid-Varnamo_Common\XPathReader\ExprQuery.cs,CompareAsString,The method has an empty catch block.
Empty Catch Block,GotDotNet.XPath,XPathScanner,C:\repos\Consid-Varnamo_Common\XPathReader\xpathscanner.cs,ToXPathDouble,The method has an empty catch block.
Empty Catch Block,GotDotNet.XPath,XPathScanner,C:\repos\Consid-Varnamo_Common\XPathReader\xpathscanner.cs,ToXPathDouble,The method has an empty catch block.
Magic Number,GotDotNet.XPath,UnionQuery,C:\repos\Consid-Varnamo_Common\XPathReader\AxisQuery.cs,GetValue,The following statement contains a magic number: objArray = new object[2];  
Magic Number,GotDotNet.XPath,StringFunctions,C:\repos\Consid-Varnamo_Common\XPathReader\FunctionQuery.cs,Substring,The following statement contains a magic number: if (this.argList.Count == 3) {  	double num1 = Math.Round (Convert.ToDouble (((IQuery)this.argList [2]).GetValue (reader)));  	if (double.IsNaN (num1))  		return String.Empty;  	if (num < 0) {  		num1 = num + num1;  		if (num1 <= 0)  			return String.Empty;  		num = 0;  	}  	double maxlength = str1.Length - num;  	if (num1 > maxlength)  		num1 = maxlength;  	return str1.Substring ((int)num' (int)num1);  }  
Magic Number,GotDotNet.XPath,StringFunctions,C:\repos\Consid-Varnamo_Common\XPathReader\FunctionQuery.cs,Substring,The following statement contains a magic number: if (this.argList.Count == 3) {  	double num1 = Math.Round (Convert.ToDouble (((IQuery)this.argList [2]).GetValue (reader)));  	if (double.IsNaN (num1))  		return String.Empty;  	if (num < 0) {  		num1 = num + num1;  		if (num1 <= 0)  			return String.Empty;  		num = 0;  	}  	double maxlength = str1.Length - num;  	if (num1 > maxlength)  		num1 = maxlength;  	return str1.Substring ((int)num' (int)num1);  }  
Magic Number,GotDotNet.XPath,NumberFunctions,C:\repos\Consid-Varnamo_Common\XPathReader\FunctionQuery.cs,Round,The following statement contains a magic number: return (-0.5 <= n && n <= 0.0) ? Math.Round (n) : Math.Floor (n + 0.5);  
Magic Number,GotDotNet.XPath,NumberFunctions,C:\repos\Consid-Varnamo_Common\XPathReader\FunctionQuery.cs,Round,The following statement contains a magic number: return (-0.5 <= n && n <= 0.0) ? Math.Round (n) : Math.Floor (n + 0.5);  
Magic Number,GotDotNet.XPath,XmlCharType,C:\repos\Consid-Varnamo_Common\XPathReader\xmlchartype.cs,XmlCharType,The following statement contains a magic number: s_CharProperties = new byte[65536];  
Magic Number,GotDotNet.XPath,XmlCharType,C:\repos\Consid-Varnamo_Common\XPathReader\xmlchartype.cs,SetProperties,The following statement contains a magic number: for (int p = 0; p < ranges.Length; p += 2) {  	for (int i = ranges [p]' last = ranges [p + 1]; i <= last; i++) {  		s_CharProperties [i] |= value;  	}  }  
Magic Number,GotDotNet.XPath,XmlCharType,C:\repos\Consid-Varnamo_Common\XPathReader\xmlchartype.cs,SetProperties,The following statement contains a magic number: p += 2
Magic Number,GotDotNet.XPath,XPathQuery,C:\repos\Consid-Varnamo_Common\XPathReader\XPathCollection.cs,Advance,The following statement contains a magic number: if ((IQuery)compiledXPath [matchIndex] is DescendantQuery) {  	//look through the subtree for the node is  	//looking for  	if (((IQuery)compiledXPath [matchIndex + 1]).MatchNode (reader)) {  		//found the node that we were looking for  		matchIndex = matchIndex + 2;  		matchCount = matchIndex;  		//set the expected depth for the rest of query  		for (int i = matchCount; i < compiledXPath.Count - 1; ++i) {  			((BaseAxisQuery)compiledXPath [matchIndex]).Depth += reader.Depth - 1;  		}  	}  }  else {  	while (reader.Depth == ((BaseAxisQuery)compiledXPath [matchIndex]).Depth) {  		if (((IQuery)compiledXPath [matchIndex]).MatchNode (reader)) {  			++matchIndex;  			matchCount = matchIndex;  		}  		else {  			//--matchIndex;  			break;  		}  	}  	SetMatchState (reader);  }  
Magic Number,GotDotNet.XPath,XPathQuery,C:\repos\Consid-Varnamo_Common\XPathReader\XPathCollection.cs,Advance,The following statement contains a magic number: if (((IQuery)compiledXPath [matchIndex + 1]).MatchNode (reader)) {  	//found the node that we were looking for  	matchIndex = matchIndex + 2;  	matchCount = matchIndex;  	//set the expected depth for the rest of query  	for (int i = matchCount; i < compiledXPath.Count - 1; ++i) {  		((BaseAxisQuery)compiledXPath [matchIndex]).Depth += reader.Depth - 1;  	}  }  
Magic Number,GotDotNet.XPath,XPathQuery,C:\repos\Consid-Varnamo_Common\XPathReader\XPathCollection.cs,Advance,The following statement contains a magic number: matchIndex = matchIndex + 2;  
Magic Number,GotDotNet.XPath,XPathParser,C:\repos\Consid-Varnamo_Common\XPathReader\xpathparser.cs,CreateFunctionTable,The following statement contains a magic number: table.Add ("concat"' new ParamInfo (Function.FunctionType.FuncConcat' 2' 100' temparray4));  
Magic Number,GotDotNet.XPath,XPathParser,C:\repos\Consid-Varnamo_Common\XPathReader\xpathparser.cs,CreateFunctionTable,The following statement contains a magic number: table.Add ("concat"' new ParamInfo (Function.FunctionType.FuncConcat' 2' 100' temparray4));  
Magic Number,GotDotNet.XPath,XPathParser,C:\repos\Consid-Varnamo_Common\XPathReader\xpathparser.cs,CreateFunctionTable,The following statement contains a magic number: table.Add ("starts-with"' new ParamInfo (Function.FunctionType.FuncStartsWith' 2' 2' temparray5));  
Magic Number,GotDotNet.XPath,XPathParser,C:\repos\Consid-Varnamo_Common\XPathReader\xpathparser.cs,CreateFunctionTable,The following statement contains a magic number: table.Add ("starts-with"' new ParamInfo (Function.FunctionType.FuncStartsWith' 2' 2' temparray5));  
Magic Number,GotDotNet.XPath,XPathParser,C:\repos\Consid-Varnamo_Common\XPathReader\xpathparser.cs,CreateFunctionTable,The following statement contains a magic number: table.Add ("contains"' new ParamInfo (Function.FunctionType.FuncContains' 2' 2' temparray5));  
Magic Number,GotDotNet.XPath,XPathParser,C:\repos\Consid-Varnamo_Common\XPathReader\xpathparser.cs,CreateFunctionTable,The following statement contains a magic number: table.Add ("contains"' new ParamInfo (Function.FunctionType.FuncContains' 2' 2' temparray5));  
Magic Number,GotDotNet.XPath,XPathParser,C:\repos\Consid-Varnamo_Common\XPathReader\xpathparser.cs,CreateFunctionTable,The following statement contains a magic number: table.Add ("substring-before"' new ParamInfo (Function.FunctionType.FuncSubstringBefore' 2' 2' temparray5));  
Magic Number,GotDotNet.XPath,XPathParser,C:\repos\Consid-Varnamo_Common\XPathReader\xpathparser.cs,CreateFunctionTable,The following statement contains a magic number: table.Add ("substring-before"' new ParamInfo (Function.FunctionType.FuncSubstringBefore' 2' 2' temparray5));  
Magic Number,GotDotNet.XPath,XPathParser,C:\repos\Consid-Varnamo_Common\XPathReader\xpathparser.cs,CreateFunctionTable,The following statement contains a magic number: table.Add ("substring-after"' new ParamInfo (Function.FunctionType.FuncSubstringAfter' 2' 2' temparray5));  
Magic Number,GotDotNet.XPath,XPathParser,C:\repos\Consid-Varnamo_Common\XPathReader\xpathparser.cs,CreateFunctionTable,The following statement contains a magic number: table.Add ("substring-after"' new ParamInfo (Function.FunctionType.FuncSubstringAfter' 2' 2' temparray5));  
Magic Number,GotDotNet.XPath,XPathParser,C:\repos\Consid-Varnamo_Common\XPathReader\xpathparser.cs,CreateFunctionTable,The following statement contains a magic number: table.Add ("substring"' new ParamInfo (Function.FunctionType.FuncSubstring' 2' 3' temparray6));  
Magic Number,GotDotNet.XPath,XPathParser,C:\repos\Consid-Varnamo_Common\XPathReader\xpathparser.cs,CreateFunctionTable,The following statement contains a magic number: table.Add ("substring"' new ParamInfo (Function.FunctionType.FuncSubstring' 2' 3' temparray6));  
Magic Number,GotDotNet.XPath,XPathParser,C:\repos\Consid-Varnamo_Common\XPathReader\xpathparser.cs,CreateFunctionTable,The following statement contains a magic number: table.Add ("translate"' new ParamInfo (Function.FunctionType.FuncTranslate' 3' 3' temparray7));  
Magic Number,GotDotNet.XPath,XPathParser,C:\repos\Consid-Varnamo_Common\XPathReader\xpathparser.cs,CreateFunctionTable,The following statement contains a magic number: table.Add ("translate"' new ParamInfo (Function.FunctionType.FuncTranslate' 3' 3' temparray7));  
Missing Default,GotDotNet.XPath,LogicalExpr,C:\repos\Consid-Varnamo_Common\XPathReader\ExprQuery.cs,CompareAsNumber,The following switch statement is missing a default case: switch (op) {  case Operator.Op.LT:  	if (n1 < n2)  		return true;  	break;  case Operator.Op.GT:  	if (n1 > n2)  		return true;  	break;  case Operator.Op.LE:  	if (n1 <= n2)  		return true;  	break;  case Operator.Op.GE:  	if (n1 >= n2)  		return true;  	break;  case Operator.Op.EQ:  	if (n1 == n2)  		return true;  	break;  case Operator.Op.NE:  	if (n1 != n2)  		return true;  	break;  }  
Missing Default,GotDotNet.XPath,LogicalExpr,C:\repos\Consid-Varnamo_Common\XPathReader\ExprQuery.cs,CompareAsString,The following switch statement is missing a default case: switch (op) {  case Operator.Op.LT:  	if (n1 < n2)  		ret = true;  	break;  case Operator.Op.GT:  	if (n1 > n2)  		ret = true;  	break;  case Operator.Op.LE:  	if (n1 <= n2)  		ret = true;  	break;  case Operator.Op.GE:  	if (n1 >= n2)  		ret = true;  	break;  }  
Missing Default,GotDotNet.XPath,LogicalExpr,C:\repos\Consid-Varnamo_Common\XPathReader\ExprQuery.cs,CompareAsBoolean,The following switch statement is missing a default case: switch (op) {  case Operator.Op.LT:  	if (n1 < n2)  		return true;  	break;  case Operator.Op.GT:  	if (n1 > n2)  		return true;  	break;  case Operator.Op.LE:  	if (n1 <= n2)  		return true;  	break;  case Operator.Op.GE:  	if (n1 >= n2)  		return true;  	break;  }  
Missing Default,GotDotNet.XPath,NumericExpr,C:\repos\Consid-Varnamo_Common\XPathReader\ExprQuery.cs,GetValue,The following switch statement is missing a default case: switch (this.op) {  case Operator.Op.PLUS:  	return n1 + n2;  case Operator.Op.MINUS:  	return n1 - n2;  case Operator.Op.MOD:  	return n1 % n2;  case Operator.Op.DIV:  	return n1 / n2;  case Operator.Op.MUL:  	return n1 * n2;  case Operator.Op.NEGATE:  	return -n1;  }  
Missing Default,GotDotNet.XPath,StringFunctions,C:\repos\Consid-Varnamo_Common\XPathReader\FunctionQuery.cs,GetValue,The following switch statement is missing a default case: switch (this.funcType) {  case FT.FuncString:  	obj = toString (reader);  	break;  case FT.FuncConcat:  	obj = Concat (reader);  	break;  case FT.FuncStartsWith:  	obj = Startswith (reader);  	break;  case FT.FuncContains:  	obj = Contains (reader);  	break;  case FT.FuncSubstringBefore:  	obj = Substringbefore (reader);  	break;  case FT.FuncSubstringAfter:  	obj = Substringafter (reader);  	break;  case FT.FuncSubstring:  	obj = Substring (reader);  	break;  case FT.FuncStringLength:  	obj = StringLength (reader);  	break;  case FT.FuncNormalize:  	obj = Normalize (reader);  	break;  case FT.FuncTranslate:  	obj = Translate (reader);  	break;  }  
Missing Default,GotDotNet.XPath,NumberFunctions,C:\repos\Consid-Varnamo_Common\XPathReader\FunctionQuery.cs,GetValue,The following switch statement is missing a default case: switch (_FuncType) {  case FT.FuncNumber:  	obj = Number (reader);  	break;  // case FT.FuncSum:  //     obj = Sum(reader);  //     break;  case FT.FuncFloor:  	obj = Floor (reader);  	break;  case FT.FuncCeiling:  	obj = Ceiling (reader);  	break;  case FT.FuncRound:  	obj = Round (reader);  	break;  }  
Missing Default,GotDotNet.XPath,BooleanFunctions,C:\repos\Consid-Varnamo_Common\XPathReader\FunctionQuery.cs,GetValue,The following switch statement is missing a default case: switch (_FuncType) {  case FT.FuncBoolean:  	obj = toBoolean (reader);  	break;  case FT.FuncNot:  	obj = Not (reader);  	break;  case FT.FuncTrue:  	obj = true;  	break;  case FT.FuncFalse:  	obj = false;  	break;  case FT.FuncLang:  	obj = Lang (reader);  	break;  }  
Missing Default,GotDotNet.XPath,MethodOperand,C:\repos\Consid-Varnamo_Common\XPathReader\OperandQuery.cs,GetValue,The following switch statement is missing a default case: switch (this.funcType) {  case FT.FuncCount:  	ret = reader.AttributeCount;  	break;  case FT.FuncPosition:  	//we need to go back to the fileter query to get count  	ret = base.PositionCount;  	break;  case FT.FuncNameSpaceUri:  	ret = reader.NamespaceURI;  	break;  case FT.FuncLocalName:  	ret = reader.LocalName;  	break;  case FT.FuncName:  	ret = reader.Name;  	break;  }  
Missing Default,GotDotNet.XPath,QueryBuilder,C:\repos\Consid-Varnamo_Common\XPathReader\queryBuilder.cs,ProcessOperator,The following switch statement is missing a default case: switch (root.OperatorType) {  case Operator.Op.OR:  	ret = new OrExpr (ProcessNode (root.Operand1' null)' ProcessNode (root.Operand2' null));  	return ret;  case Operator.Op.AND:  	ret = new AndExpr (ProcessNode (root.Operand1' null)' ProcessNode (root.Operand2' null));  	return ret;  }  
Missing Default,GotDotNet.XPath,QueryBuilder,C:\repos\Consid-Varnamo_Common\XPathReader\queryBuilder.cs,ProcessOperator,The following switch statement is missing a default case: switch (root.ReturnType) {  case XPathResultType.Number:  	ret = new NumericExpr (root.OperatorType' ProcessNode (root.Operand1' null)' ProcessNode (root.Operand2' null));  	return ret;  case XPathResultType.Boolean:  	ret = new LogicalExpr (root.OperatorType' ProcessNode (root.Operand1' null)' ProcessNode (root.Operand2' null));  	return ret;  }  
Missing Default,GotDotNet.XPath,XPathParser,C:\repos\Consid-Varnamo_Common\XPathReader\xpathparser.cs,ParseStep,The following switch statement is missing a default case: switch (this.scanner.Kind) {  case XPathScanner.LexKind.At:  	//>> '@'  	axisType = Axis.AxisType.Attribute;  	NextLex ();  	break;  case XPathScanner.LexKind.Axe:  	//>> AxisName '::'  	axisType = GetAxis (this.scanner);  	NextLex ();  	break;  }  
Missing Default,GotDotNet.XPath,XPathParser,C:\repos\Consid-Varnamo_Common\XPathReader\xpathparser.cs,ParsePrimaryExpr,The following switch statement is missing a default case: switch (this.scanner.Kind) {  case XPathScanner.LexKind.String:  	opnd = new Operand (this.scanner.StringValue);  	NextLex ();  	break;  case XPathScanner.LexKind.Number:  	opnd = new Operand (this.scanner.NumberValue);  	NextLex ();  	break;  case XPathScanner.LexKind.Dollar:  	NextLex ();  	CheckToken (XPathScanner.LexKind.Name);  	opnd = new Variable (this.scanner.Name' this.scanner.Prefix);  	NextLex ();  	break;  case XPathScanner.LexKind.LParens:  	NextLex ();  	opnd = ParseExpresion (qyInput);  	if (opnd.TypeOfAst != AstNode.QueryType.ConstantOperand) {  		opnd = new Group (opnd);  	}  	PassToken (XPathScanner.LexKind.RParens);  	break;  case XPathScanner.LexKind.Name:  	if (this.scanner.CanBeFunction && !IsNodeType (this.scanner)) {  		opnd = ParseMethod (null);  	}  	break;  }  
Missing Default,GotDotNet.XPath,XPathParser,C:\repos\Consid-Varnamo_Common\XPathReader\xpathparser.cs,ParseMethod,The following switch statement is missing a default case: switch (pi.ArgTypes [i]) {  case XPathResultType.NodeSet:  	if (!(arg is Variable) && !(arg is Function && arg.ReturnType == XPathResultType.Error)) {  		throw new XPathException (String.Format ("Function '{0}' in '{1}' has invalid number of arguments."' name' this.scanner.SourceText));  	}  	break;  case XPathResultType.String:  	arg = new Function (Function.FunctionType.FuncString' arg);  	break;  case XPathResultType.Number:  	arg = new Function (Function.FunctionType.FuncNumber' arg);  	break;  case XPathResultType.Boolean:  	arg = new Function (Function.FunctionType.FuncBoolean' arg);  	break;  }  
Missing Default,GotDotNet.XPath,XPathParser,C:\repos\Consid-Varnamo_Common\XPathReader\xpathparser.cs,ParseStepPattern,The following switch statement is missing a default case: switch (this.scanner.Kind) {  case XPathScanner.LexKind.At:  	//>> '@'  	axisType = Axis.AxisType.Attribute;  	NextLex ();  	break;  case XPathScanner.LexKind.Axe:  	//>> AxisName '::'  	axisType = GetAxis (this.scanner);  	if (axisType != Axis.AxisType.Child && axisType != Axis.AxisType.Attribute) {  		throw new XPathException (String.Format ("'{0}' has an invalid token."' scanner.SourceText));  	}  	NextLex ();  	break;  }  
