Implementation smell,Namespace,Class,File,Method,Description
Complex Method,RemoteMon_Lib,Alert,C:\repos\fronn_win-net-mon\WinNetMon\RemoteMon Lib\Alerts.cs,GetSend,Cyclomatic complexity of the method is 10
Complex Method,RemoteMon_Lib,BasicMonitor,C:\repos\fronn_win-net-mon\WinNetMon\RemoteMon Lib\BasicMonitors.cs,Check,Cyclomatic complexity of the method is 19
Complex Method,RemoteMon_Lib,EventMonitor,C:\repos\fronn_win-net-mon\WinNetMon\RemoteMon Lib\EventMonitors.cs,Check,Cyclomatic complexity of the method is 12
Complex Method,RemoteMon_Lib,PfcMonitor,C:\repos\fronn_win-net-mon\WinNetMon\RemoteMon Lib\PfcMonitors.cs,Check,Cyclomatic complexity of the method is 8
Complex Method,RemoteMon_Lib,TcpTalker,C:\repos\fronn_win-net-mon\WinNetMon\RemoteMon Lib\TcpStuff.cs,SendCommand,Cyclomatic complexity of the method is 8
Complex Method,RemoteMon_Lib,TcpTalker,C:\repos\fronn_win-net-mon\WinNetMon\RemoteMon Lib\TcpStuff.cs,GetCommand,Cyclomatic complexity of the method is 8
Complex Method,RemoteMon_Lib,MessageQueueTalker,C:\repos\fronn_win-net-mon\WinNetMon\RemoteMon Lib\TcpStuff.cs,SendCommand,Cyclomatic complexity of the method is 13
Complex Method,RemoteMon_Lib,MessageQueueTalker,C:\repos\fronn_win-net-mon\WinNetMon\RemoteMon Lib\TcpStuff.cs,GetCommand,Cyclomatic complexity of the method is 10
Complex Method,RemoteMon_Lib,WmiMonitor,C:\repos\fronn_win-net-mon\WinNetMon\RemoteMon Lib\WmiMonitors.cs,Check,Cyclomatic complexity of the method is 19
Long Parameter List,RemoteMon_Lib,Logger,C:\repos\fronn_win-net-mon\WinNetMon\RemoteMon Lib\Logger.cs,Log,The method has 6 parameters.
Long Statement,RemoteMon_Lib,Alert,C:\repos\fronn_win-net-mon\WinNetMon\RemoteMon Lib\Alerts.cs,GetSend,The length of the statement  "				using (MailMessage message = new MailMessage (ea.EmailAddressFrom' ea.Info' "MONITOR ALERT: Type: " + result.Type + "' Named: " + ((IMonitor)result.Monitor).FriendlyName' "The Monitor: " + ((IMonitor)result.Monitor).FriendlyName + "\r\n\r\nDescription: " + ((IMonitor)result.Monitor).ToString () + "\r\n\r\nValue: " + result.Value + "\r\n\r\nResult: " + result.ToString () + "\r\n\r\nRan at: " + result.RunTime)) { " is 414.
Long Statement,RemoteMon_Lib,Alert,C:\repos\fronn_win-net-mon\WinNetMon\RemoteMon Lib\Alerts.cs,GetSend,The length of the statement  "						Logger.Instance.Log (typeof(Alert)' LogType.Info' "Alert Email successfully sent for: " + ((IMonitor)result.Monitor).FriendlyName); " is 131.
Long Statement,RemoteMon_Lib,Alert,C:\repos\fronn_win-net-mon\WinNetMon\RemoteMon Lib\Alerts.cs,GetSend,The length of the statement  "						Logger.Instance.Log (typeof(Alert)' LogType.Info' "Alert Email for: " + ((IMonitor)result.Monitor).FriendlyName + " failed to send."); " is 134.
Long Statement,RemoteMon_Lib,BasicMonitor,C:\repos\fronn_win-net-mon\WinNetMon\RemoteMon Lib\BasicMonitors.cs,Check,The length of the statement  "			http.UserAgent = "Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.1; WOW64; Trident/4.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; MDDC)"; " is 184.
Long Statement,RemoteMon_Lib,BasicMonitor,C:\repos\fronn_win-net-mon\WinNetMon\RemoteMon Lib\BasicMonitors.cs,GetHashCode,The length of the statement  "	String s = _friendlyName + _alertInfo.GetHashCode () + _common + _updateFrequency + _basicMonitorType + _credential.Username + _credential.Domain + _data; " is 154.
Long Statement,RemoteMon_Lib,EventMonitor,C:\repos\fronn_win-net-mon\WinNetMon\RemoteMon Lib\EventMonitors.cs,ToString,The length of the statement  "	return "Event Log Type: " + _eventLogKind + "' Event Log Entry Types: " + _eventType + "' Event Log Match: " + _eventNameMatch; " is 127.
Long Statement,RemoteMon_Lib,EventMonitor,C:\repos\fronn_win-net-mon\WinNetMon\RemoteMon Lib\EventMonitors.cs,GetHashCode,The length of the statement  "	String s = _friendlyName + _server + _alertInfo.GetHashCode () + _common + _updateFrequency + _clearOldLogs + _eventLogKind + _eventType; " is 137.
Long Statement,RemoteMon_Lib,Logger,C:\repos\fronn_win-net-mon\WinNetMon\RemoteMon Lib\Logger.cs,Log,The length of the statement  "		_logWorking.Add (dateTime + "\t" + logType + "\t" + type.ToString () + " " + (logType == LogType.Debug ? ((methodName != "" ? (methodName + ": ") : "") + "\t Line: " + lineNumber + "\t File: " + filePath) : "") + text + "\t"); " is 226.
Long Statement,RemoteMon_Lib,Logger,C:\repos\fronn_win-net-mon\WinNetMon\RemoteMon Lib\Logger.cs,LogException,The length of the statement  "		_logWorking.Add (dateTime + "\t" + LogType.Exception + "\t" + type.ToString () + " " + methodName + " threw exception: " + exception.Message.Replace ("\r\n"' "") + innerExceptions.Replace ("\r\n"' "") + "\t"); " is 209.
Long Statement,RemoteMon_Lib,Logger,C:\repos\fronn_win-net-mon\WinNetMon\RemoteMon Lib\Logger.cs,LogMonitorException,The length of the statement  "		_logWorking.Add (dateTime + "\t" + LogType.MonitorException + "\t" + ((IMonitor)result.Monitor).FriendlyName + " threw exception: " + exception.Message.Replace ("\r\n"' "") + innerExceptions.Replace ("\r\n"' "") + "\t"); " is 220.
Long Statement,RemoteMon_Lib,Logger,C:\repos\fronn_win-net-mon\WinNetMon\RemoteMon Lib\Logger.cs,LogMonitor,The length of the statement  "			_logWorking.Add (dateTime + "\t" + LogType.MonitorException + "\t" + "Name: " + ((IMonitor)result.Monitor).FriendlyName + "' " + ((IMonitor)result.Monitor).Type + " Ok: " + result.Ok + " Exception: " + result.Exception + "' Last run length: " + result.RunLength + "\t"); " is 270.
Long Statement,RemoteMon_Lib,Logger,C:\repos\fronn_win-net-mon\WinNetMon\RemoteMon Lib\Logger.cs,LogMonitor,The length of the statement  "			_logWorking.Add (dateTime + "\t" + LogType.Monitor + "\t" + "Name: " + ((IMonitor)result.Monitor).FriendlyName + "' " + result.ToString () + "' Last run length: " + result.RunLength + "\t" + result.Value); " is 205.
Long Statement,RemoteMon_Lib,Logger,C:\repos\fronn_win-net-mon\WinNetMon\RemoteMon Lib\Logger.cs,PushLog,The length of the statement  "							using (FileStream newfs = new FileStream (fi.Directory.FullName + @"\" + fi.CreationTime.ToString ("yyyy'-'MM'-'dd' 'HH' 'mm") + " to " + datetime + ".zip"' FileMode.OpenOrCreate)) { " is 182.
Long Statement,RemoteMon_Lib,Logger,C:\repos\fronn_win-net-mon\WinNetMon\RemoteMon Lib\Logger.cs,PushLog,The length of the statement  "									Logger.Instance.Log (this.GetType ()' LogType.Wtf' "Mismatch of buffer sizes - zipped log file likely corrupt: " + fi.Directory.FullName + @"\" + fi.CreationTime.ToString ("yyyy'-'MM'-'dd' 'HH' 'mm") + " to " + datetime + ".zip"); " is 230.
Long Statement,RemoteMon_Lib,PfcMonitor,C:\repos\fronn_win-net-mon\WinNetMon\RemoteMon Lib\PfcMonitors.cs,GetHashCode,The length of the statement  "	String s = _friendlyName + _server + _alertInfo.GetHashCode () + _common + _updateFrequency + _category + _counter + _instance + _thresholdBreachCount + _thresholdLessThan + _thresholdPanic + _thresholdWarning; " is 210.
Long Statement,RemoteMon_Lib,PfcResult,C:\repos\fronn_win-net-mon\WinNetMon\RemoteMon Lib\PfcMonitors.cs,ToString,The length of the statement  "	return this.Type + " Result Name: " + _monitor.FriendlyName + "' Ok: " + _ok + "' Panic: " + _critical + "' Value: " + _value; " is 126.
Long Statement,RemoteMon_Lib,ServiceMonitor,C:\repos\fronn_win-net-mon\WinNetMon\RemoteMon Lib\ServiceMonitors.cs,Check,The length of the statement  "			Boolean ok = (service.GoodStatus == ServiceStatus.Running ? (sc.Status != ServiceControllerStatus.Running ? false : true) : (sc.Status != ServiceControllerStatus.Stopped ? false : true)); " is 187.
Long Statement,RemoteMon_Lib,ServiceResultStatus,C:\repos\fronn_win-net-mon\WinNetMon\RemoteMon Lib\ServiceMonitors.cs,ToString,The length of the statement  "	return "Service Name: " + _service.ServiceName + "' Current Status: " + (_ok ? _service.GoodStatus.ToString () : (_service.GoodStatus == ServiceStatus.Running ? ServiceStatus.Stopped.ToString () : ServiceStatus.Running.ToString ())); " is 233.
Long Statement,RemoteMon_Lib,SmsParser,C:\repos\fronn_win-net-mon\WinNetMon\RemoteMon Lib\SmsParser.cs,FormatSmsXml,The length of the statement  "	return xmlToFormat.Replace ("XMLDATA="' "").Replace ("%20"' " ").Replace ("%3C"' "<").Replace ("%3F"' "?").Replace ("%3D"' "=").Replace ("%22"' "\"").Replace ("%3E"' ">").Replace ("%0D%0A"' Environment.NewLine).Replace ("%2B"' "+").Replace ("%2F"' "/").Replace ("%3A"' ":"); " is 274.
Long Statement,RemoteMon_Lib,SmsParser,C:\repos\fronn_win-net-mon\WinNetMon\RemoteMon Lib\SmsParser.cs,LogReceive,The length of the statement  "	Logger.Instance.Log (this.GetType ()' LogType.Sms' "Time Received: " + DateTime.Now + "' Phone Number: " + _phone + "' Message: " + _message); " is 142.
Long Statement,RemoteMon_Lib,SmsParser,C:\repos\fronn_win-net-mon\WinNetMon\RemoteMon Lib\SmsParser.cs,LogSend,The length of the statement  "	Logger.Instance.Log (this.GetType ()' LogType.Sms' "Time Sent: " + DateTime.Now + "' Phone Number: " + phone + "' Message: " + message + "' Original message: " + _fullmessage); " is 176.
Long Statement,RemoteMon_Lib,SmsParser,C:\repos\fronn_win-net-mon\WinNetMon\RemoteMon Lib\SmsParser.cs,ParseNodes,The length of the statement  "		_phone = _fullxml.Substring (sendernumberindex' _fullxml.IndexOf ("</SenderNumber>"' sendernumberindex) - sendernumberindex).Replace ("<SenderNumber>"' ""); " is 156.
Long Statement,RemoteMon_Lib,SmsParser,C:\repos\fronn_win-net-mon\WinNetMon\RemoteMon Lib\SmsParser.cs,ParseNodes,The length of the statement  "			_fullmessage = _fullxml.Substring (messageindex' _fullxml.IndexOf ("</message>"' messageindex) - messageindex).Replace ("<message>"' ""); " is 137.
Long Statement,RemoteMon_Lib,SmsParser,C:\repos\fronn_win-net-mon\WinNetMon\RemoteMon Lib\SmsParser.cs,SendMessage,The length of the statement  "		request = (HttpWebRequest)WebRequest.Create (@"http://192.168.51.248:81/sendmsg?user=admin&passwd=adminmts&cat=1&to=""" + phone + @"""&text=" + message); " is 153.
Long Statement,RemoteMon_Lib,WmiMonitor,C:\repos\fronn_win-net-mon\WinNetMon\RemoteMon Lib\WmiMonitors.cs,Check,The length of the statement  "			ObjectQuery objectQueryInUse = new ObjectQuery ("SELECT TotalVisibleMemorySize' FreePhysicalMemory FROM Win32_OperatingSystem"); " is 128.
Long Statement,RemoteMon_Lib,WmiMonitor,C:\repos\fronn_win-net-mon\WinNetMon\RemoteMon Lib\WmiMonitors.cs,GetHashCode,The length of the statement  "	String s = _friendlyName + _server + _alertInfo.GetHashCode () + _common + _thresholdBreachCount + _thresholdLessThan + _thresholdPanic + _thresholdWarning + _updateFrequency + _wmiType; " is 186.
Long Statement,RemoteMon_Lib,WmiResult,C:\repos\fronn_win-net-mon\WinNetMon\RemoteMon Lib\WmiMonitors.cs,ToString,The length of the statement  "	return this.Type + " Result Name: " + _monitor.FriendlyName + "' Ok: " + _ok + "' Panic: " + _critical + "' Value: " + _value; " is 126.
Empty Catch Block,RemoteMon_Lib,Listener,C:\repos\fronn_win-net-mon\WinNetMon\RemoteMon Lib\TcpStuff.cs,GetConnections,The method has an empty catch block.
Magic Number,RemoteMon_Lib,Logger,C:\repos\fronn_win-net-mon\WinNetMon\RemoteMon Lib\Logger.cs,PushLog,The following statement contains a magic number: if (lazy && (DateTime.Now - _lastTimePushed).TotalSeconds < 10)  	//only push every 10 seconds max  	return;  
Magic Number,RemoteMon_Lib,Logger,C:\repos\fronn_win-net-mon\WinNetMon\RemoteMon Lib\Logger.cs,PushLog,The following statement contains a magic number: if (_keepLogging) {  	//try  	//{  	lock (log_lock) {  		//_toLog = null;  		//_toLog = _toLogWorking;  		//_toLogWorking = new Dictionary<String' Log>();  		_log = null;  		_log = _logWorking;  		_logWorking = new Log ();  		//foreach (Log toLog in _toLog.Values)  		//{  		if (_log.FileName == "") {  			_log.FileName = _fileName;  			//default filename  		}  		FileInfo fi = new FileInfo (_log.FileName);  		if (!fi.Exists) {  			if (!fi.Directory.Exists)  				fi.Directory.Create ();  			fi.Create ().Close ();  		}  		else {  			if (fi.Length > 52428800)//50MB  			 {  				try {  					const Int32 lohsize = 10000;  					using (FileStream originalfs = fi.OpenRead ())//new FileStream(fi.FullName' FileMode.Open' FileAccess.Read))  					 {  						String datetime = DateTime.Now.ToString ("yyyy'-'MM'-'dd' 'HH' 'mm");  						using (FileStream newfs = new FileStream (fi.Directory.FullName + @"\" + fi.CreationTime.ToString ("yyyy'-'MM'-'dd' 'HH' 'mm") + " to " + datetime + ".zip"' FileMode.OpenOrCreate)) {  							Int64 count = originalfs.Length;  							using (GZipStream gzip = new GZipStream (newfs' CompressionMode.Compress)) {  								Int32 leftover = (Int32)count % lohsize;  								Int32 buckets = (Int32)count / lohsize;  								if (leftover > 0)  									buckets++;  								for (Int32 x = 0; x < buckets; x++) {  									Int32 size;  									if (count >= lohsize)  										size = lohsize;  									else  										size = (Int32)count;  									Byte[] buffer = new Byte[size];  									//Bucket buffer = new Bucket(originalfs.Length);  									originalfs.Read (buffer' 0' size);  									gzip.Write (buffer' 0' size);  									count -= size;  								}  							}  							if (count != 0) {  								Logger.Instance.Log (this.GetType ()' LogType.Wtf' "Mismatch of buffer sizes - zipped log file likely corrupt: " + fi.Directory.FullName + @"\" + fi.CreationTime.ToString ("yyyy'-'MM'-'dd' 'HH' 'mm") + " to " + datetime + ".zip");  							}  						}  					}  					fi.Delete ();  				}  				catch (Exception ex) {  					Logger.Instance.LogException (this.GetType ()' ex);  				}  			}  		}  		using (StreamWriter sw = new StreamWriter (fi.OpenWrite ()))//_log.FileName' true))  		 {  			foreach (String s in _log) {  				sw.WriteLine (s);  			}  			_lastTimePushed = DateTime.Now;  		}  		_log.Clear ();  	}  	//}  	//catch (Exception ex)  	//{  	//    //LogImmediate("log_danger.log"' ex.Message);  	//    throw;  	//}  }  
Magic Number,RemoteMon_Lib,Logger,C:\repos\fronn_win-net-mon\WinNetMon\RemoteMon Lib\Logger.cs,PushLog,The following statement contains a magic number: if (_keepLogging) {  	//try  	//{  	lock (log_lock) {  		//_toLog = null;  		//_toLog = _toLogWorking;  		//_toLogWorking = new Dictionary<String' Log>();  		_log = null;  		_log = _logWorking;  		_logWorking = new Log ();  		//foreach (Log toLog in _toLog.Values)  		//{  		if (_log.FileName == "") {  			_log.FileName = _fileName;  			//default filename  		}  		FileInfo fi = new FileInfo (_log.FileName);  		if (!fi.Exists) {  			if (!fi.Directory.Exists)  				fi.Directory.Create ();  			fi.Create ().Close ();  		}  		else {  			if (fi.Length > 52428800)//50MB  			 {  				try {  					const Int32 lohsize = 10000;  					using (FileStream originalfs = fi.OpenRead ())//new FileStream(fi.FullName' FileMode.Open' FileAccess.Read))  					 {  						String datetime = DateTime.Now.ToString ("yyyy'-'MM'-'dd' 'HH' 'mm");  						using (FileStream newfs = new FileStream (fi.Directory.FullName + @"\" + fi.CreationTime.ToString ("yyyy'-'MM'-'dd' 'HH' 'mm") + " to " + datetime + ".zip"' FileMode.OpenOrCreate)) {  							Int64 count = originalfs.Length;  							using (GZipStream gzip = new GZipStream (newfs' CompressionMode.Compress)) {  								Int32 leftover = (Int32)count % lohsize;  								Int32 buckets = (Int32)count / lohsize;  								if (leftover > 0)  									buckets++;  								for (Int32 x = 0; x < buckets; x++) {  									Int32 size;  									if (count >= lohsize)  										size = lohsize;  									else  										size = (Int32)count;  									Byte[] buffer = new Byte[size];  									//Bucket buffer = new Bucket(originalfs.Length);  									originalfs.Read (buffer' 0' size);  									gzip.Write (buffer' 0' size);  									count -= size;  								}  							}  							if (count != 0) {  								Logger.Instance.Log (this.GetType ()' LogType.Wtf' "Mismatch of buffer sizes - zipped log file likely corrupt: " + fi.Directory.FullName + @"\" + fi.CreationTime.ToString ("yyyy'-'MM'-'dd' 'HH' 'mm") + " to " + datetime + ".zip");  							}  						}  					}  					fi.Delete ();  				}  				catch (Exception ex) {  					Logger.Instance.LogException (this.GetType ()' ex);  				}  			}  		}  		using (StreamWriter sw = new StreamWriter (fi.OpenWrite ()))//_log.FileName' true))  		 {  			foreach (String s in _log) {  				sw.WriteLine (s);  			}  			_lastTimePushed = DateTime.Now;  		}  		_log.Clear ();  	}  	//}  	//catch (Exception ex)  	//{  	//    //LogImmediate("log_danger.log"' ex.Message);  	//    throw;  	//}  }  
Magic Number,RemoteMon_Lib,Logger,C:\repos\fronn_win-net-mon\WinNetMon\RemoteMon Lib\Logger.cs,PushLog,The following statement contains a magic number: lock (log_lock) {  	//_toLog = null;  	//_toLog = _toLogWorking;  	//_toLogWorking = new Dictionary<String' Log>();  	_log = null;  	_log = _logWorking;  	_logWorking = new Log ();  	//foreach (Log toLog in _toLog.Values)  	//{  	if (_log.FileName == "") {  		_log.FileName = _fileName;  		//default filename  	}  	FileInfo fi = new FileInfo (_log.FileName);  	if (!fi.Exists) {  		if (!fi.Directory.Exists)  			fi.Directory.Create ();  		fi.Create ().Close ();  	}  	else {  		if (fi.Length > 52428800)//50MB  		 {  			try {  				const Int32 lohsize = 10000;  				using (FileStream originalfs = fi.OpenRead ())//new FileStream(fi.FullName' FileMode.Open' FileAccess.Read))  				 {  					String datetime = DateTime.Now.ToString ("yyyy'-'MM'-'dd' 'HH' 'mm");  					using (FileStream newfs = new FileStream (fi.Directory.FullName + @"\" + fi.CreationTime.ToString ("yyyy'-'MM'-'dd' 'HH' 'mm") + " to " + datetime + ".zip"' FileMode.OpenOrCreate)) {  						Int64 count = originalfs.Length;  						using (GZipStream gzip = new GZipStream (newfs' CompressionMode.Compress)) {  							Int32 leftover = (Int32)count % lohsize;  							Int32 buckets = (Int32)count / lohsize;  							if (leftover > 0)  								buckets++;  							for (Int32 x = 0; x < buckets; x++) {  								Int32 size;  								if (count >= lohsize)  									size = lohsize;  								else  									size = (Int32)count;  								Byte[] buffer = new Byte[size];  								//Bucket buffer = new Bucket(originalfs.Length);  								originalfs.Read (buffer' 0' size);  								gzip.Write (buffer' 0' size);  								count -= size;  							}  						}  						if (count != 0) {  							Logger.Instance.Log (this.GetType ()' LogType.Wtf' "Mismatch of buffer sizes - zipped log file likely corrupt: " + fi.Directory.FullName + @"\" + fi.CreationTime.ToString ("yyyy'-'MM'-'dd' 'HH' 'mm") + " to " + datetime + ".zip");  						}  					}  				}  				fi.Delete ();  			}  			catch (Exception ex) {  				Logger.Instance.LogException (this.GetType ()' ex);  			}  		}  	}  	using (StreamWriter sw = new StreamWriter (fi.OpenWrite ()))//_log.FileName' true))  	 {  		foreach (String s in _log) {  			sw.WriteLine (s);  		}  		_lastTimePushed = DateTime.Now;  	}  	_log.Clear ();  }  
Magic Number,RemoteMon_Lib,Logger,C:\repos\fronn_win-net-mon\WinNetMon\RemoteMon Lib\Logger.cs,PushLog,The following statement contains a magic number: lock (log_lock) {  	//_toLog = null;  	//_toLog = _toLogWorking;  	//_toLogWorking = new Dictionary<String' Log>();  	_log = null;  	_log = _logWorking;  	_logWorking = new Log ();  	//foreach (Log toLog in _toLog.Values)  	//{  	if (_log.FileName == "") {  		_log.FileName = _fileName;  		//default filename  	}  	FileInfo fi = new FileInfo (_log.FileName);  	if (!fi.Exists) {  		if (!fi.Directory.Exists)  			fi.Directory.Create ();  		fi.Create ().Close ();  	}  	else {  		if (fi.Length > 52428800)//50MB  		 {  			try {  				const Int32 lohsize = 10000;  				using (FileStream originalfs = fi.OpenRead ())//new FileStream(fi.FullName' FileMode.Open' FileAccess.Read))  				 {  					String datetime = DateTime.Now.ToString ("yyyy'-'MM'-'dd' 'HH' 'mm");  					using (FileStream newfs = new FileStream (fi.Directory.FullName + @"\" + fi.CreationTime.ToString ("yyyy'-'MM'-'dd' 'HH' 'mm") + " to " + datetime + ".zip"' FileMode.OpenOrCreate)) {  						Int64 count = originalfs.Length;  						using (GZipStream gzip = new GZipStream (newfs' CompressionMode.Compress)) {  							Int32 leftover = (Int32)count % lohsize;  							Int32 buckets = (Int32)count / lohsize;  							if (leftover > 0)  								buckets++;  							for (Int32 x = 0; x < buckets; x++) {  								Int32 size;  								if (count >= lohsize)  									size = lohsize;  								else  									size = (Int32)count;  								Byte[] buffer = new Byte[size];  								//Bucket buffer = new Bucket(originalfs.Length);  								originalfs.Read (buffer' 0' size);  								gzip.Write (buffer' 0' size);  								count -= size;  							}  						}  						if (count != 0) {  							Logger.Instance.Log (this.GetType ()' LogType.Wtf' "Mismatch of buffer sizes - zipped log file likely corrupt: " + fi.Directory.FullName + @"\" + fi.CreationTime.ToString ("yyyy'-'MM'-'dd' 'HH' 'mm") + " to " + datetime + ".zip");  						}  					}  				}  				fi.Delete ();  			}  			catch (Exception ex) {  				Logger.Instance.LogException (this.GetType ()' ex);  			}  		}  	}  	using (StreamWriter sw = new StreamWriter (fi.OpenWrite ()))//_log.FileName' true))  	 {  		foreach (String s in _log) {  			sw.WriteLine (s);  		}  		_lastTimePushed = DateTime.Now;  	}  	_log.Clear ();  }  
Magic Number,RemoteMon_Lib,Logger,C:\repos\fronn_win-net-mon\WinNetMon\RemoteMon Lib\Logger.cs,PushLog,The following statement contains a magic number: if (!fi.Exists) {  	if (!fi.Directory.Exists)  		fi.Directory.Create ();  	fi.Create ().Close ();  }  else {  	if (fi.Length > 52428800)//50MB  	 {  		try {  			const Int32 lohsize = 10000;  			using (FileStream originalfs = fi.OpenRead ())//new FileStream(fi.FullName' FileMode.Open' FileAccess.Read))  			 {  				String datetime = DateTime.Now.ToString ("yyyy'-'MM'-'dd' 'HH' 'mm");  				using (FileStream newfs = new FileStream (fi.Directory.FullName + @"\" + fi.CreationTime.ToString ("yyyy'-'MM'-'dd' 'HH' 'mm") + " to " + datetime + ".zip"' FileMode.OpenOrCreate)) {  					Int64 count = originalfs.Length;  					using (GZipStream gzip = new GZipStream (newfs' CompressionMode.Compress)) {  						Int32 leftover = (Int32)count % lohsize;  						Int32 buckets = (Int32)count / lohsize;  						if (leftover > 0)  							buckets++;  						for (Int32 x = 0; x < buckets; x++) {  							Int32 size;  							if (count >= lohsize)  								size = lohsize;  							else  								size = (Int32)count;  							Byte[] buffer = new Byte[size];  							//Bucket buffer = new Bucket(originalfs.Length);  							originalfs.Read (buffer' 0' size);  							gzip.Write (buffer' 0' size);  							count -= size;  						}  					}  					if (count != 0) {  						Logger.Instance.Log (this.GetType ()' LogType.Wtf' "Mismatch of buffer sizes - zipped log file likely corrupt: " + fi.Directory.FullName + @"\" + fi.CreationTime.ToString ("yyyy'-'MM'-'dd' 'HH' 'mm") + " to " + datetime + ".zip");  					}  				}  			}  			fi.Delete ();  		}  		catch (Exception ex) {  			Logger.Instance.LogException (this.GetType ()' ex);  		}  	}  }  
Magic Number,RemoteMon_Lib,Logger,C:\repos\fronn_win-net-mon\WinNetMon\RemoteMon Lib\Logger.cs,PushLog,The following statement contains a magic number: if (!fi.Exists) {  	if (!fi.Directory.Exists)  		fi.Directory.Create ();  	fi.Create ().Close ();  }  else {  	if (fi.Length > 52428800)//50MB  	 {  		try {  			const Int32 lohsize = 10000;  			using (FileStream originalfs = fi.OpenRead ())//new FileStream(fi.FullName' FileMode.Open' FileAccess.Read))  			 {  				String datetime = DateTime.Now.ToString ("yyyy'-'MM'-'dd' 'HH' 'mm");  				using (FileStream newfs = new FileStream (fi.Directory.FullName + @"\" + fi.CreationTime.ToString ("yyyy'-'MM'-'dd' 'HH' 'mm") + " to " + datetime + ".zip"' FileMode.OpenOrCreate)) {  					Int64 count = originalfs.Length;  					using (GZipStream gzip = new GZipStream (newfs' CompressionMode.Compress)) {  						Int32 leftover = (Int32)count % lohsize;  						Int32 buckets = (Int32)count / lohsize;  						if (leftover > 0)  							buckets++;  						for (Int32 x = 0; x < buckets; x++) {  							Int32 size;  							if (count >= lohsize)  								size = lohsize;  							else  								size = (Int32)count;  							Byte[] buffer = new Byte[size];  							//Bucket buffer = new Bucket(originalfs.Length);  							originalfs.Read (buffer' 0' size);  							gzip.Write (buffer' 0' size);  							count -= size;  						}  					}  					if (count != 0) {  						Logger.Instance.Log (this.GetType ()' LogType.Wtf' "Mismatch of buffer sizes - zipped log file likely corrupt: " + fi.Directory.FullName + @"\" + fi.CreationTime.ToString ("yyyy'-'MM'-'dd' 'HH' 'mm") + " to " + datetime + ".zip");  					}  				}  			}  			fi.Delete ();  		}  		catch (Exception ex) {  			Logger.Instance.LogException (this.GetType ()' ex);  		}  	}  }  
Magic Number,RemoteMon_Lib,Logger,C:\repos\fronn_win-net-mon\WinNetMon\RemoteMon Lib\Logger.cs,PushLog,The following statement contains a magic number: if (fi.Length > 52428800)//50MB   {  	try {  		const Int32 lohsize = 10000;  		using (FileStream originalfs = fi.OpenRead ())//new FileStream(fi.FullName' FileMode.Open' FileAccess.Read))  		 {  			String datetime = DateTime.Now.ToString ("yyyy'-'MM'-'dd' 'HH' 'mm");  			using (FileStream newfs = new FileStream (fi.Directory.FullName + @"\" + fi.CreationTime.ToString ("yyyy'-'MM'-'dd' 'HH' 'mm") + " to " + datetime + ".zip"' FileMode.OpenOrCreate)) {  				Int64 count = originalfs.Length;  				using (GZipStream gzip = new GZipStream (newfs' CompressionMode.Compress)) {  					Int32 leftover = (Int32)count % lohsize;  					Int32 buckets = (Int32)count / lohsize;  					if (leftover > 0)  						buckets++;  					for (Int32 x = 0; x < buckets; x++) {  						Int32 size;  						if (count >= lohsize)  							size = lohsize;  						else  							size = (Int32)count;  						Byte[] buffer = new Byte[size];  						//Bucket buffer = new Bucket(originalfs.Length);  						originalfs.Read (buffer' 0' size);  						gzip.Write (buffer' 0' size);  						count -= size;  					}  				}  				if (count != 0) {  					Logger.Instance.Log (this.GetType ()' LogType.Wtf' "Mismatch of buffer sizes - zipped log file likely corrupt: " + fi.Directory.FullName + @"\" + fi.CreationTime.ToString ("yyyy'-'MM'-'dd' 'HH' 'mm") + " to " + datetime + ".zip");  				}  			}  		}  		fi.Delete ();  	}  	catch (Exception ex) {  		Logger.Instance.LogException (this.GetType ()' ex);  	}  }  
Magic Number,RemoteMon_Lib,Logger,C:\repos\fronn_win-net-mon\WinNetMon\RemoteMon Lib\Logger.cs,PushLog,The following statement contains a magic number: if (fi.Length > 52428800)//50MB   {  	try {  		const Int32 lohsize = 10000;  		using (FileStream originalfs = fi.OpenRead ())//new FileStream(fi.FullName' FileMode.Open' FileAccess.Read))  		 {  			String datetime = DateTime.Now.ToString ("yyyy'-'MM'-'dd' 'HH' 'mm");  			using (FileStream newfs = new FileStream (fi.Directory.FullName + @"\" + fi.CreationTime.ToString ("yyyy'-'MM'-'dd' 'HH' 'mm") + " to " + datetime + ".zip"' FileMode.OpenOrCreate)) {  				Int64 count = originalfs.Length;  				using (GZipStream gzip = new GZipStream (newfs' CompressionMode.Compress)) {  					Int32 leftover = (Int32)count % lohsize;  					Int32 buckets = (Int32)count / lohsize;  					if (leftover > 0)  						buckets++;  					for (Int32 x = 0; x < buckets; x++) {  						Int32 size;  						if (count >= lohsize)  							size = lohsize;  						else  							size = (Int32)count;  						Byte[] buffer = new Byte[size];  						//Bucket buffer = new Bucket(originalfs.Length);  						originalfs.Read (buffer' 0' size);  						gzip.Write (buffer' 0' size);  						count -= size;  					}  				}  				if (count != 0) {  					Logger.Instance.Log (this.GetType ()' LogType.Wtf' "Mismatch of buffer sizes - zipped log file likely corrupt: " + fi.Directory.FullName + @"\" + fi.CreationTime.ToString ("yyyy'-'MM'-'dd' 'HH' 'mm") + " to " + datetime + ".zip");  				}  			}  		}  		fi.Delete ();  	}  	catch (Exception ex) {  		Logger.Instance.LogException (this.GetType ()' ex);  	}  }  
Magic Number,RemoteMon_Lib,Logger,C:\repos\fronn_win-net-mon\WinNetMon\RemoteMon Lib\Logger.cs,PushLog,The following statement contains a magic number: try {  	const Int32 lohsize = 10000;  	using (FileStream originalfs = fi.OpenRead ())//new FileStream(fi.FullName' FileMode.Open' FileAccess.Read))  	 {  		String datetime = DateTime.Now.ToString ("yyyy'-'MM'-'dd' 'HH' 'mm");  		using (FileStream newfs = new FileStream (fi.Directory.FullName + @"\" + fi.CreationTime.ToString ("yyyy'-'MM'-'dd' 'HH' 'mm") + " to " + datetime + ".zip"' FileMode.OpenOrCreate)) {  			Int64 count = originalfs.Length;  			using (GZipStream gzip = new GZipStream (newfs' CompressionMode.Compress)) {  				Int32 leftover = (Int32)count % lohsize;  				Int32 buckets = (Int32)count / lohsize;  				if (leftover > 0)  					buckets++;  				for (Int32 x = 0; x < buckets; x++) {  					Int32 size;  					if (count >= lohsize)  						size = lohsize;  					else  						size = (Int32)count;  					Byte[] buffer = new Byte[size];  					//Bucket buffer = new Bucket(originalfs.Length);  					originalfs.Read (buffer' 0' size);  					gzip.Write (buffer' 0' size);  					count -= size;  				}  			}  			if (count != 0) {  				Logger.Instance.Log (this.GetType ()' LogType.Wtf' "Mismatch of buffer sizes - zipped log file likely corrupt: " + fi.Directory.FullName + @"\" + fi.CreationTime.ToString ("yyyy'-'MM'-'dd' 'HH' 'mm") + " to " + datetime + ".zip");  			}  		}  	}  	fi.Delete ();  }  catch (Exception ex) {  	Logger.Instance.LogException (this.GetType ()' ex);  }  
Magic Number,RemoteMon_Lib,MonitorScheduler,C:\repos\fronn_win-net-mon\WinNetMon\RemoteMon Lib\MonitorScheduler.cs,Kill,The following statement contains a magic number: _timer.Join (25);  
Magic Number,RemoteMon_Lib,ServiceMonitor,C:\repos\fronn_win-net-mon\WinNetMon\RemoteMon Lib\ServiceMonitors.cs,ToString,The following statement contains a magic number: if (slist.Count > 3)  	return String.Join ("; "' slist.ToArray ()' 0' 3) + "...";  
Magic Number,RemoteMon_Lib,ServiceMonitor,C:\repos\fronn_win-net-mon\WinNetMon\RemoteMon Lib\ServiceMonitors.cs,ToString,The following statement contains a magic number: if (slist.Count > 3)  	return String.Join ("; "' slist.ToArray ()' 0' 3) + "...";  
Magic Number,RemoteMon_Lib,ServiceMonitor,C:\repos\fronn_win-net-mon\WinNetMon\RemoteMon Lib\ServiceMonitors.cs,ToString,The following statement contains a magic number: return String.Join ("; "' slist.ToArray ()' 0' 3) + "...";  
Magic Number,RemoteMon_Lib,ServiceMonitor,C:\repos\fronn_win-net-mon\WinNetMon\RemoteMon Lib\ServiceMonitors.cs,ToString,The following statement contains a magic number: return String.Join ("; "' slist.ToArray ()' 0' slist.Count < 3 ? slist.Count : 3);  
Magic Number,RemoteMon_Lib,ServiceMonitor,C:\repos\fronn_win-net-mon\WinNetMon\RemoteMon Lib\ServiceMonitors.cs,ToString,The following statement contains a magic number: return String.Join ("; "' slist.ToArray ()' 0' slist.Count < 3 ? slist.Count : 3);  
Magic Number,RemoteMon_Lib,ServiceResultStatuses,C:\repos\fronn_win-net-mon\WinNetMon\RemoteMon Lib\ServiceMonitors.cs,ToStringFull,The following statement contains a magic number: return String.Join ("; "' slist.ToArray ()' 0' 3);  
Magic Number,RemoteMon_Lib,Listener,C:\repos\fronn_win-net-mon\WinNetMon\RemoteMon Lib\TcpStuff.cs,GetConnections,The following statement contains a magic number: while (true) {  	TcpClient client = null;  	try {  		client = _listener.AcceptTcpClient ();  		client.ReceiveTimeout = 100000;  		client.SendTimeout = 100000;  	}  	catch (Exception) {  		/*eat the quit exception*/}  	if (client != null) {  		String ip = ((IPEndPoint)client.Client.RemoteEndPoint).Address.ToString ();  		if (_connections.ContainsKey (ip))  			lock (connections_locker)  				_connections [ip].Dispose ();  		lock (connections_locker)  			_connections [ip] = new TcpTalker (client);  	}  	Thread.Sleep (1000);  }  
Magic Number,RemoteMon_Lib,Listener,C:\repos\fronn_win-net-mon\WinNetMon\RemoteMon Lib\TcpStuff.cs,GetConnections,The following statement contains a magic number: while (true) {  	TcpClient client = null;  	try {  		client = _listener.AcceptTcpClient ();  		client.ReceiveTimeout = 100000;  		client.SendTimeout = 100000;  	}  	catch (Exception) {  		/*eat the quit exception*/}  	if (client != null) {  		String ip = ((IPEndPoint)client.Client.RemoteEndPoint).Address.ToString ();  		if (_connections.ContainsKey (ip))  			lock (connections_locker)  				_connections [ip].Dispose ();  		lock (connections_locker)  			_connections [ip] = new TcpTalker (client);  	}  	Thread.Sleep (1000);  }  
Magic Number,RemoteMon_Lib,Listener,C:\repos\fronn_win-net-mon\WinNetMon\RemoteMon Lib\TcpStuff.cs,GetConnections,The following statement contains a magic number: while (true) {  	TcpClient client = null;  	try {  		client = _listener.AcceptTcpClient ();  		client.ReceiveTimeout = 100000;  		client.SendTimeout = 100000;  	}  	catch (Exception) {  		/*eat the quit exception*/}  	if (client != null) {  		String ip = ((IPEndPoint)client.Client.RemoteEndPoint).Address.ToString ();  		if (_connections.ContainsKey (ip))  			lock (connections_locker)  				_connections [ip].Dispose ();  		lock (connections_locker)  			_connections [ip] = new TcpTalker (client);  	}  	Thread.Sleep (1000);  }  
Magic Number,RemoteMon_Lib,Listener,C:\repos\fronn_win-net-mon\WinNetMon\RemoteMon Lib\TcpStuff.cs,GetConnections,The following statement contains a magic number: try {  	client = _listener.AcceptTcpClient ();  	client.ReceiveTimeout = 100000;  	client.SendTimeout = 100000;  }  catch (Exception) {  	/*eat the quit exception*/}  
Magic Number,RemoteMon_Lib,Listener,C:\repos\fronn_win-net-mon\WinNetMon\RemoteMon Lib\TcpStuff.cs,GetConnections,The following statement contains a magic number: try {  	client = _listener.AcceptTcpClient ();  	client.ReceiveTimeout = 100000;  	client.SendTimeout = 100000;  }  catch (Exception) {  	/*eat the quit exception*/}  
Magic Number,RemoteMon_Lib,Listener,C:\repos\fronn_win-net-mon\WinNetMon\RemoteMon Lib\TcpStuff.cs,GetConnections,The following statement contains a magic number: client.ReceiveTimeout = 100000;  
Magic Number,RemoteMon_Lib,Listener,C:\repos\fronn_win-net-mon\WinNetMon\RemoteMon Lib\TcpStuff.cs,GetConnections,The following statement contains a magic number: client.SendTimeout = 100000;  
Magic Number,RemoteMon_Lib,Listener,C:\repos\fronn_win-net-mon\WinNetMon\RemoteMon Lib\TcpStuff.cs,GetConnections,The following statement contains a magic number: Thread.Sleep (1000);  
Magic Number,RemoteMon_Lib,Listener,C:\repos\fronn_win-net-mon\WinNetMon\RemoteMon Lib\TcpStuff.cs,Dispose,The following statement contains a magic number: if (_acceptConnections != null && _acceptConnections.IsAlive)  	_acceptConnections.Join (100);  
Magic Number,RemoteMon_Lib,Listener,C:\repos\fronn_win-net-mon\WinNetMon\RemoteMon Lib\TcpStuff.cs,Dispose,The following statement contains a magic number: _acceptConnections.Join (100);  
Magic Number,RemoteMon_Lib,TcpTalker,C:\repos\fronn_win-net-mon\WinNetMon\RemoteMon Lib\TcpStuff.cs,TcpTalker,The following statement contains a magic number: _client = new TcpClient {  	ExclusiveAddressUse = false'  	ReceiveTimeout = 100000'  	SendTimeout = 100000'  	LingerState = new LingerOption (true' 100)  };  
Magic Number,RemoteMon_Lib,TcpTalker,C:\repos\fronn_win-net-mon\WinNetMon\RemoteMon Lib\TcpStuff.cs,TcpTalker,The following statement contains a magic number: _client = new TcpClient {  	ExclusiveAddressUse = false'  	ReceiveTimeout = 100000'  	SendTimeout = 100000'  	LingerState = new LingerOption (true' 100)  };  
Magic Number,RemoteMon_Lib,TcpTalker,C:\repos\fronn_win-net-mon\WinNetMon\RemoteMon Lib\TcpStuff.cs,TcpTalker,The following statement contains a magic number: _client = new TcpClient {  	ExclusiveAddressUse = false'  	ReceiveTimeout = 100000'  	SendTimeout = 100000'  	LingerState = new LingerOption (true' 100)  };  
Magic Number,RemoteMon_Lib,TcpTalker,C:\repos\fronn_win-net-mon\WinNetMon\RemoteMon Lib\TcpStuff.cs,TcpTalker,The following statement contains a magic number: _client.LingerState = new LingerOption (true' 100);  
Missing Default,RemoteMon_Lib,Alert,C:\repos\fronn_win-net-mon\WinNetMon\RemoteMon Lib\Alerts.cs,GetSend,The following switch statement is missing a default case: switch (ca.Type) {  case AlertType.Email:  	EmailAlert ea = (EmailAlert)ca;  	using (MailMessage message = new MailMessage (ea.EmailAddressFrom' ea.Info' "MONITOR ALERT: Type: " + result.Type + "' Named: " + ((IMonitor)result.Monitor).FriendlyName' "The Monitor: " + ((IMonitor)result.Monitor).FriendlyName + "\r\n\r\nDescription: " + ((IMonitor)result.Monitor).ToString () + "\r\n\r\nValue: " + result.Value + "\r\n\r\nResult: " + result.ToString () + "\r\n\r\nRan at: " + result.RunTime)) {  		message.IsBodyHtml = false;  		SmtpClient client = new SmtpClient (ea.EmailServerHostName) {  			EnableSsl = ea.UseSsl'  			UseDefaultCredentials = false'  			DeliveryMethod = SmtpDeliveryMethod.Network  		};  		if (ea.EmailUserName == "" && ea.EmailUserPass == "")  			client.UseDefaultCredentials = true;  		else  			client.Credentials = new System.Net.NetworkCredential (ea.EmailUserName' ea.EmailUserPass);  		if (ea.EmailServerPort > 0)  			client.Port = ea.EmailServerPort;  		try {  			client.Send (message);  			Logger.Instance.Log (typeof(Alert)' LogType.Info' "Alert Email successfully sent for: " + ((IMonitor)result.Monitor).FriendlyName);  		}  		catch (Exception ex) {  			Logger.Instance.Log (typeof(Alert)' LogType.Info' "Alert Email for: " + ((IMonitor)result.Monitor).FriendlyName + " failed to send.");  			Logger.Instance.LogException (typeof(Alert)' ex);  			send = false;  		}  	}  	break;  case AlertType.Phone:  	break;  case AlertType.LocalPopup:  	break;  }  
Missing Default,RemoteMon_Lib,BasicMonitor,C:\repos\fronn_win-net-mon\WinNetMon\RemoteMon Lib\BasicMonitors.cs,Check,The following switch statement is missing a default case: switch (_basicMonitorType) {  case BasicMonitorType.Ftp:  	FtpWebRequest ftp = (FtpWebRequest)WebRequest.Create (_data.UrlUncIp);  	ftp.EnableSsl = _credential.UseSecure;  	ftp.Method = WebRequestMethods.Ftp.PrintWorkingDirectory;  	if (_credential.Username != "")  		if (_credential.Domain != "")  			ftp.Credentials = new NetworkCredential (_credential.Username' _credential.Password' _credential.Domain);  		else  			ftp.Credentials = new NetworkCredential (_credential.Username' _credential.Password);  	using (response = ftp.GetResponse ()) {  		if (response != null) {  			using (Stream str = response.GetResponseStream ()) {  				if (((FtpWebResponse)response).StatusCode == FtpStatusCode.PathnameCreated) {  					br.Ok = true;  					br.Value = "OK";  					//ftpresponse.StatusDescription;  				}  				else {  					br.Ok = false;  					br.Value = "OK";  					//ftpresponse.StatusDescription;  				}  			}  		}  	}  	break;  case BasicMonitorType.Http:  	HttpWebRequest http = (HttpWebRequest)WebRequest.Create (_data.UrlUncIp);  	http.AllowAutoRedirect = true;  	http.UserAgent = "Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.1; WOW64; Trident/4.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; MDDC)";  	using (response = http.GetResponse ()) {  		using (Stream str = response.GetResponseStream ()) {  			if (((HttpWebResponse)response).StatusCode == HttpStatusCode.OK) {  				br.Ok = true;  				br.Value = ((HttpWebResponse)response).StatusDescription;  			}  			else {  				br.Ok = false;  				br.Value = ((HttpWebResponse)response).StatusDescription;  			}  		}  	}  	break;  case BasicMonitorType.Ping:  	using (ping = new Ping ()) {  		PingReply pr = ping.Send (_data.UrlUncIp);  		if (pr != null) {  			br.Ok = pr.Status == IPStatus.Success ? true : false;  			br.Value = pr.Status.ToString () + ": " + pr.RoundtripTime.ToString () + "ms";  		}  		else {  			br.Ok = false;  			br.Value = "Failure: null response.";  		}  	}  	break;  }  
Missing Default,RemoteMon_Lib,WmiMonitor,C:\repos\fronn_win-net-mon\WinNetMon\RemoteMon Lib\WmiMonitors.cs,Check,The following switch statement is missing a default case: switch (_wmiType) {  case WmiType.MemoryFree:  	ManagementScope scopeAvailable = new ManagementScope (@"\\" + _server);  	//' new ConnectionOptions());  	scopeAvailable.Connect ();  	ObjectQuery objectQueryAvailable = new ObjectQuery ("SELECT FreePhysicalMemory FROM Win32_OperatingSystem");  	using (ManagementObjectSearcher searcher = new ManagementObjectSearcher (scopeAvailable' objectQueryAvailable)) {  		using (ManagementObjectCollection moc = searcher.Get ()) {  			using (ManagementObjectCollection.ManagementObjectEnumerator moe = moc.GetEnumerator ()) {  				while (moe.MoveNext ()) {  					using (ManagementBaseObject mbo = moe.Current)  						wr.Value = Convert.ToSingle (mbo ["FreePhysicalMemory"]);  				}  			}  		}  	}  	if ((Single)wr.Value < _thresholdWarningFloat) {  		if ((Single)wr.Value < _thresholdPanicFloat) {  			wr.Ok = false;  			wr.Critical = true;  		}  		else {  			wr.Ok = false;  			wr.Critical = false;  		}  	}  	else {  		wr.Ok = true;  	}  	break;  case WmiType.MemoryUsage:  	ManagementScope scopeInUse = new ManagementScope (@"\\" + _server);  	//' new ConnectionOptions());  	scopeInUse.Connect ();  	ObjectQuery objectQueryInUse = new ObjectQuery ("SELECT TotalVisibleMemorySize' FreePhysicalMemory FROM Win32_OperatingSystem");  	using (ManagementObjectSearcher searcher = new ManagementObjectSearcher (scopeInUse' objectQueryInUse)) {  		using (ManagementObjectCollection moc = searcher.Get ()) {  			using (ManagementObjectCollection.ManagementObjectEnumerator moe = moc.GetEnumerator ()) {  				while (moe.MoveNext ()) {  					using (ManagementBaseObject mbo = moe.Current) {  						Single total = Convert.ToSingle (mbo ["TotalVisibleMemorySize"]);  						Single free = Convert.ToSingle (mbo ["FreePhysicalMemory"]);  						wr.Value = ((total - free) / total) * 100f;  					}  				}  			}  		}  	}  	if ((Single)wr.Value > _thresholdWarningFloat) {  		if ((Single)wr.Value > _thresholdPanicFloat) {  			wr.Ok = false;  			wr.Critical = true;  		}  		else {  			wr.Ok = false;  			wr.Critical = false;  		}  	}  	else {  		wr.Ok = true;  	}  	break;  }  
