Implementation smell,Namespace,Class,File,Method,Description
Long Method,MathNet.Numerics,Fn,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions.cs,IntLog2,The method has 128 lines of code.
Long Method,MathNet.Numerics.Interpolation.Algorithms,CubicSplineInterpolation,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\CubicSplineInterpolation.cs,Init,The method has 107 lines of code.
Long Method,MathNet.Numerics.LinearAlgebra,EigenvalueDecomposition,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\LinearAlgebra\EigenvalueDecomposition.cs,SymmetricTridiagonalize,The method has 128 lines of code.
Long Method,MathNet.Numerics.LinearAlgebra,EigenvalueDecomposition,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\LinearAlgebra\EigenvalueDecomposition.cs,SymmetricDiagonalize,The method has 128 lines of code.
Long Method,MathNet.Numerics.LinearAlgebra,EigenvalueDecomposition,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\LinearAlgebra\EigenvalueDecomposition.cs,NonsymmetricReduceToHessenberg,The method has 101 lines of code.
Long Method,MathNet.Numerics.LinearAlgebra,EigenvalueDecomposition,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\LinearAlgebra\EigenvalueDecomposition.cs,NonsymmetricReduceHessenberToRealSchur,The method has 472 lines of code.
Long Method,MathNet.Numerics.LinearAlgebra,SingularValueDecomposition,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\LinearAlgebra\SingularValueDecomposition.cs,SingularValueDecomposition,The method has 469 lines of code.
Long Method,MathNet.Numerics.SpecialFunctions.Algorithms,GammaRegularizedAlgorithm,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\GammaRegularizedAlgorithm.cs,GammaRegularizedInverse,The method has 155 lines of code.
Complex Method,MathNet.Numerics,Complex,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Complex.cs,ToString,Cyclomatic complexity of the method is 11
Complex Method,MathNet.Numerics,ComplexPolynomial,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\ComplexPolynomial.cs,ToString,Cyclomatic complexity of the method is 10
Complex Method,MathNet.Numerics,Sorting,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Sorting.cs,Sort,Cyclomatic complexity of the method is 8
Complex Method,MathNet.Numerics,Sorting,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Sorting.cs,Sort,Cyclomatic complexity of the method is 10
Complex Method,MathNet.Numerics,Polynomial,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Polynomial.cs,ToString,Cyclomatic complexity of the method is 9
Complex Method,MathNet.Numerics,SampleList,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SampleList.cs,Locate,Cyclomatic complexity of the method is 9
Complex Method,MathNet.Numerics,Fn,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions.cs,IntLog2,Cyclomatic complexity of the method is 32
Complex Method,MathNet.Numerics.Interpolation.Algorithms,AkimaSplineInterpolation,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\AkimaSplineInterpolation.cs,Init,Cyclomatic complexity of the method is 9
Complex Method,MathNet.Numerics.Interpolation.Algorithms,BarycentricInterpolation,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\BarycentricInterpolation.cs,Interpolate,Cyclomatic complexity of the method is 8
Complex Method,MathNet.Numerics.Interpolation.Algorithms,CubicSplineInterpolation,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\CubicSplineInterpolation.cs,Init,Cyclomatic complexity of the method is 15
Complex Method,MathNet.Numerics.Interpolation.Algorithms,RationalPoleFreeInterpolation,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\RationalPoleFreeInterpolation.cs,Init,Cyclomatic complexity of the method is 15
Complex Method,MathNet.Numerics.LinearAlgebra,CholeskyDecomposition,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\LinearAlgebra\CholeskyDecomposition.cs,Solve,Cyclomatic complexity of the method is 9
Complex Method,MathNet.Numerics.LinearAlgebra,EigenvalueDecomposition,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\LinearAlgebra\EigenvalueDecomposition.cs,EigenvalueDecomposition,Cyclomatic complexity of the method is 8
Complex Method,MathNet.Numerics.LinearAlgebra,EigenvalueDecomposition,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\LinearAlgebra\EigenvalueDecomposition.cs,SymmetricTridiagonalize,Cyclomatic complexity of the method is 23
Complex Method,MathNet.Numerics.LinearAlgebra,EigenvalueDecomposition,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\LinearAlgebra\EigenvalueDecomposition.cs,SymmetricDiagonalize,Cyclomatic complexity of the method is 11
Complex Method,MathNet.Numerics.LinearAlgebra,EigenvalueDecomposition,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\LinearAlgebra\EigenvalueDecomposition.cs,NonsymmetricReduceToHessenberg,Cyclomatic complexity of the method is 20
Complex Method,MathNet.Numerics.LinearAlgebra,EigenvalueDecomposition,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\LinearAlgebra\EigenvalueDecomposition.cs,NonsymmetricReduceHessenberToRealSchur,Cyclomatic complexity of the method is 69
Complex Method,MathNet.Numerics.LinearAlgebra,LUDecomposition,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\LinearAlgebra\LUDecomposition.cs,LUDecomposition,Cyclomatic complexity of the method is 12
Complex Method,MathNet.Numerics.LinearAlgebra,LUDecomposition,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\LinearAlgebra\LUDecomposition.cs,Solve,Cyclomatic complexity of the method is 10
Complex Method,MathNet.Numerics.LinearAlgebra,Matrix,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\LinearAlgebra\Matrix.cs,SolveRobust,Cyclomatic complexity of the method is 8
Complex Method,MathNet.Numerics.LinearAlgebra,QRDecomposition,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\LinearAlgebra\QRDecomposition.cs,QRDecomposition,Cyclomatic complexity of the method is 9
Complex Method,MathNet.Numerics.LinearAlgebra,QRDecomposition,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\LinearAlgebra\QRDecomposition.cs,Solve,Cyclomatic complexity of the method is 11
Complex Method,MathNet.Numerics.LinearAlgebra,SingularValueDecomposition,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\LinearAlgebra\SingularValueDecomposition.cs,SingularValueDecomposition,Cyclomatic complexity of the method is 78
Complex Method,MathNet.Numerics.RandomSources,AdditiveLaggedFibonacciRandomSource,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\AdditiveLaggedFibonacciRandomSource.cs,NextBytes,Cyclomatic complexity of the method is 9
Complex Method,MathNet.Numerics.RandomSources,MersenneTwisterRandomSource,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\MersenneTwisterRandomSource.cs,NextBytes,Cyclomatic complexity of the method is 9
Complex Method,MathNet.Numerics.SpecialFunctions.Algorithms,BetaRegularizedAlgorithm,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\BetaRegularizedAlgorithm.cs,BetaRegularized,Cyclomatic complexity of the method is 10
Complex Method,MathNet.Numerics.SpecialFunctions.Algorithms,DigammaAlgorithm,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\DigammaAlgorithm.cs,Digamma,Cyclomatic complexity of the method is 10
Complex Method,MathNet.Numerics.SpecialFunctions.Algorithms,GammaRegularizedAlgorithm,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\GammaRegularizedAlgorithm.cs,GammaRegularizedInverse,Cyclomatic complexity of the method is 24
Complex Method,MathNet.Numerics.Statistics,Histogram,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Statistics\Histogram.cs,OptimalDispersion,Cyclomatic complexity of the method is 12
Complex Method,MathNet.Numerics.Statistics,Histogram,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Statistics\Histogram.cs,OptimalVariance,Cyclomatic complexity of the method is 10
Complex Method,MathNet.Numerics.Statistics,Histogram,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Statistics\Histogram.cs,OptimalFreedom,Cyclomatic complexity of the method is 9
Complex Method,MathNet.Numerics.Statistics,Histogram,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Statistics\Histogram.cs,OptimalSquaredFreedom,Cyclomatic complexity of the method is 9
Long Parameter List,MathNet.Numerics,ComplexPolynomial,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\ComplexPolynomial.cs,MultiplyKaratsuba,The method has 6 parameters. Parameters: leftCoefficients' rightCoefficients' leftOrder' rightOrder' n' offset
Long Parameter List,MathNet.Numerics,Sorting,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Sorting.cs,QuickSort,The method has 5 parameters. Parameters: keys' items' comparer' left' right
Long Parameter List,MathNet.Numerics,Sorting,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Sorting.cs,QuickSort,The method has 6 parameters. Parameters: keys' items1' items2' comparer' left' right
Long Parameter List,MathNet.Numerics,Polynomial,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Polynomial.cs,MultiplyKaratsuba,The method has 6 parameters. Parameters: leftCoefficients' rightCoefficients' leftOrder' rightOrder' n' offset
Long Parameter List,MathNet.Numerics,Quaternion,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Quaternion.cs,Quaternion,The method has 7 parameters. Parameters: real' imagX' imagY' imagZ' abs' norm' arg
Long Parameter List,MathNet.Numerics.Integration.Algorithms,TrapeziumRule,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Integration\Algorithms\TrapeziumRule.cs,IntegrateAdaptiveTransformedOdd,The method has 7 parameters. Parameters: f' intervalBegin' intervalEnd' levelAbscissas' levelWeights' levelOneStep' targetRelativeError
Long Parameter List,MathNet.Numerics.Interpolation.Algorithms,AkimaSplineInterpolation,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\AkimaSplineInterpolation.cs,DifferentiateThreePoint,The method has 7 parameters. Parameters: t' t0' x0' t1' x1' t2' x2
Long Parameter List,MathNet.Numerics.Interpolation.Algorithms,CubicSplineInterpolation,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\CubicSplineInterpolation.cs,Init,The method has 6 parameters. Parameters: t' x' leftBoundaryCondition' leftBoundary' rightBoundaryCondition' rightBoundary
Long Parameter List,MathNet.Numerics.Interpolation,Interpolation,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Interpolation.cs,CreateCubicSpline,The method has 6 parameters. Parameters: points' values' leftBoundaryCondition' leftBoundary' rightBoundaryCondition' rightBoundary
Long Parameter List,MathNet.Numerics.LinearAlgebra,ComplexMatrix,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\LinearAlgebra\ComplexMatrix.cs,SetMatrix,The method has 5 parameters. Parameters: i0' i1' j0' j1' x
Long Parameter List,MathNet.Numerics.LinearAlgebra,Matrix,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\LinearAlgebra\Matrix.cs,SetMatrix,The method has 5 parameters. Parameters: i0' i1' j0' j1' x
Long Parameter List,MathNet.Numerics.Transformations,InternalFFT,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Transformations\InternalFFT.cs,DanielsonLanczosTransformMultiDim,The method has 5 parameters. Parameters: samples' stride' step' forward' convention
Long Parameter List,MathNet.Numerics.Transformations,RealFourierTransformation,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Transformations\RealFourierTransformation.cs,TransformForward,The method has 6 parameters. Parameters: samples1' samples2' fftReal1' fftImag1' fftReal2' fftImag2
Long Parameter List,MathNet.Numerics.Transformations,RealFourierTransformation,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Transformations\RealFourierTransformation.cs,TransformBackward,The method has 6 parameters. Parameters: fftReal1' fftImag1' fftReal2' fftImag2' samples1' samples2
Long Identifier,MathNet.Numerics,SiConstants,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SiConstants.cs,,The length of the parameter ShieldedProtonGyromagneticRatio is 31.
Long Identifier,MathNet.Numerics.LinearAlgebra,LUDecomposition,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\LinearAlgebra\LUDecomposition.cs,,The length of the parameter _lowerTriangularFactorOnDemand is 30.
Long Identifier,MathNet.Numerics.LinearAlgebra,LUDecomposition,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\LinearAlgebra\LUDecomposition.cs,,The length of the parameter _upperTriangularFactorOnDemand is 30.
Long Identifier,MathNet.Numerics.LinearAlgebra,Matrix,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\LinearAlgebra\Matrix.cs,,The length of the parameter _choleskyDecompositionOnDemand is 30.
Long Identifier,MathNet.Numerics.LinearAlgebra,Matrix,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\LinearAlgebra\Matrix.cs,,The length of the parameter _singularValueDecompositionOnDemand is 35.
Long Identifier,MathNet.Numerics.LinearAlgebra,Matrix,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\LinearAlgebra\Matrix.cs,,The length of the parameter _eigenValueDecompositionOnDemand is 32.
Long Identifier,MathNet.Numerics.LinearAlgebra,QRDecomposition,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\LinearAlgebra\QRDecomposition.cs,,The length of the parameter _upperTriangularFactorOnDemand is 30.
Long Identifier,MathNet.Numerics.LinearAlgebra,SingularValueDecomposition,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\LinearAlgebra\SingularValueDecomposition.cs,,The length of the parameter _diagonalSingularValuesOnDemand is 31.
Long Statement,MathNet.Numerics,ComplexPolynomial,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\ComplexPolynomial.cs,MultiplyKaratsuba,The length of the statement  "                        (leftCoefficients[offset] * rightCoefficients[offset + 1]) + (leftCoefficients[offset + 1] * rightCoefficients[offset])' " is 120.
Long Statement,MathNet.Numerics,Polynomial,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Polynomial.cs,MultiplyKaratsuba,The length of the statement  "                        (leftCoefficients[offset] * rightCoefficients[offset + 1]) + (leftCoefficients[offset + 1] * rightCoefficients[offset])' " is 120.
Long Statement,MathNet.Numerics.Distributions,BinomialDistribution,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Distributions\Discrete\BinomialDistribution.cs,NextInt32,The length of the statement  "                    tmp = 1.2 * root * (1.0 + yangle * yangle) * System.Math.Exp(oldGamma - Fn.GammaLn(em + 1.0) - Fn.GammaLn(en - em + 1.0) + em * probabilityLog + (en - em) * pclog); " is 164.
Long Statement,MathNet.Numerics.Integration.Algorithms,TrapeziumRule,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Integration\Algorithms\TrapeziumRule.cs,IntegrateAdaptiveTransformedOdd,The length of the statement  "                sum += weightsL1[i] * (f((linearSlope * abcissasL1[i]) + linearOffset) + f(-(linearSlope * abcissasL1[i]) + linearOffset)); " is 123.
Long Statement,MathNet.Numerics.Integration.Algorithms,TrapeziumRule,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Integration\Algorithms\TrapeziumRule.cs,IntegrateAdaptiveTransformedOdd,The length of the statement  "                    midpointsum += weights[i] * (f((linearSlope * abcissas[i]) + linearOffset) + f(-(linearSlope * abcissas[i]) + linearOffset)); " is 125.
Long Statement,MathNet.Numerics.Interpolation.Algorithms,CubicSplineInterpolation,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\CubicSplineInterpolation.cs,Init,The length of the statement  "                b[i] = (3 * (xx[i] - xx[i - 1]) / (tt[i] - tt[i - 1]) * (tt[i + 1] - tt[i])) + (3 * (xx[i + 1] - xx[i]) / (tt[i + 1] - tt[i]) * (tt[i] - tt[i - 1])); " is 149.
Long Statement,MathNet.Numerics.LinearAlgebra,EigenvalueDecomposition,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\LinearAlgebra\EigenvalueDecomposition.cs,NonsymmetricReduceHessenberToRealSchur,The length of the statement  "                        if(Math.Abs(_h[m][m - 1]) * (Math.Abs(q) + Math.Abs(r)) < eps * (Math.Abs(p) * (Math.Abs(_h[m - 1][m - 1]) + Math.Abs(z) + Math.Abs(_h[m + 1][m + 1])))) " is 152.
Long Statement,MathNet.Numerics.LinearAlgebra,Matrix,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\LinearAlgebra\Matrix.cs,InitOnDemandComputations,The length of the statement  "            _singularValueDecompositionOnDemand = new OnDemandComputation<SingularValueDecomposition>(ComputeSingularValueDecomposition); " is 125.
Long Statement,MathNet.Numerics.RandomSources,AdditiveLaggedFibonacciRandomSource,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\AdditiveLaggedFibonacciRandomSource.cs,Next,The length of the statement  "            // 31 random bits (int) will suffice which allows us to shift and cast to an int before the first multiplication and gain better performance. " is 141.
Long Statement,MathNet.Numerics.RandomSources,MersenneTwisterRandomSource,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\MersenneTwisterRandomSource.cs,Next,The length of the statement  "            // 31 random bits (int) will suffice which allows us to shift and cast to an int before the first multiplication and gain better performance. " is 141.
Long Statement,MathNet.Numerics.RandomSources,XorShiftRandomSource,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\XorShiftRandomSource.cs,Next,The length of the statement  "            // 31 random bits (int) will suffice which allows us to shift and cast to an int before the first multiplication and gain better performance. " is 141.
Long Statement,MathNet.Numerics.RandomSources.ObjectModel,RandomByteSourceAdapter,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\ObjectModel\RandomByteSourceAdapter.cs,Next,The length of the statement  "            // 31 random bits (int) will suffice which allows us to shift and cast to an int before the first multiplication and gain better performance. " is 141.
Long Statement,MathNet.Numerics.SpecialFunctions.Algorithms,BetaRegularizedAlgorithm,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\BetaRegularizedAlgorithm.cs,BetaRegularized,The length of the statement  "                : Math.Exp(GammaAlgorithm.GammaLn(a + b) - GammaAlgorithm.GammaLn(a) - GammaAlgorithm.GammaLn(b) + (a * Math.Log(x)) + (b * Math.Log(1.0 - x))); " is 144.
Long Statement,MathNet.Numerics.SpecialFunctions.Algorithms,ErrorFunctionAlgorithm,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\ErrorFunctionAlgorithm.cs,ErfInverse,The length of the statement  "                return ((((((((((ErfInvC[0] * q) + ErfInvC[1]) * q) + ErfInvC[2]) * q) + ErfInvC[3]) * q) + ErfInvC[4]) * q) + ErfInvC[5]) / " is 124.
Long Statement,MathNet.Numerics.SpecialFunctions.Algorithms,ErrorFunctionAlgorithm,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\ErrorFunctionAlgorithm.cs,ErfInverse,The length of the statement  "                return -((((((((((ErfInvC[0] * q) + ErfInvC[1]) * q) + ErfInvC[2]) * q) + ErfInvC[3]) * q) + ErfInvC[4]) * q) + ErfInvC[5]) / " is 125.
Long Statement,MathNet.Numerics.SpecialFunctions.Algorithms,ErrorFunctionAlgorithm,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\ErrorFunctionAlgorithm.cs,ErfInverse,The length of the statement  "            return ((((((((((ErfInvA[0] * r) + ErfInvA[1]) * r) + ErfInvA[2]) * r) + ErfInvA[3]) * r) + ErfInvA[4]) * r) + ErfInvA[5]) * q / " is 128.
Complex Conditional,MathNet.Numerics,Combinatorics,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Combinatorics.cs,CombinationsWithRepetition,The conditional expression  "k < 0 || n < 0 || (n == 0 && k > 0)"  is complex.
Complex Conditional,MathNet.Numerics,Number,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Number.cs,AlmostEqualNorm,The conditional expression  "(a == 0 && Math.Abs(b) < maximumRelativeError)                  || (b == 0 && Math.Abs(a) < maximumRelativeError)"  is complex.
Complex Conditional,MathNet.Numerics.NumberTheory,IntegerTheory,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\NumberTheory\IntegerTheory.cs,IsPerfectSquare,The conditional expression  "lastHexDigit == 0 || lastHexDigit == 1 || lastHexDigit == 4 || lastHexDigit == 9"  is complex.
Complex Conditional,MathNet.Numerics.NumberTheory,IntegerTheory,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\NumberTheory\IntegerTheory.cs,IsPerfectSquare,The conditional expression  "lastHexDigit == 0 || lastHexDigit == 1 || lastHexDigit == 4 || lastHexDigit == 9"  is complex.
Complex Conditional,MathNet.Numerics.SpecialFunctions.Algorithms,GammaRegularizedAlgorithm,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\GammaRegularizedAlgorithm.cs,GammaRegularizedInverse,The conditional expression  "a < 0 || Number.AlmostZero(a) || y0 < 0 || y0 > 1"  is complex.
Magic Number,MathNet.Numerics,Combinatorics,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Combinatorics.cs,Variations,The following statement contains a magic number: return Math.Floor(0.5 + Math.Exp(Fn.FactorialLn(n) - Fn.FactorialLn(n - k)));
Magic Number,MathNet.Numerics,Combinatorics,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Combinatorics.cs,CombinationsWithRepetition,The following statement contains a magic number: return Math.Floor(0.5 + Math.Exp(Fn.FactorialLn(n + k - 1) - Fn.FactorialLn(k) - Fn.FactorialLn(n - 1)));
Magic Number,MathNet.Numerics,Combinatorics,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Combinatorics.cs,RandomCombination,The following statement contains a magic number: k * 3 < n
Magic Number,MathNet.Numerics,Complex,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Complex.cs,InverseTangent,The following statement contains a magic number: return new Complex(0' 0.5) * ((1 - iz).NaturalLogarithm() - (1 + iz).NaturalLogarithm());
Magic Number,MathNet.Numerics,Complex,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Complex.cs,InverseCotangent,The following statement contains a magic number: return (new Complex(0' 0.5) * ((1 + iz).NaturalLogarithm() - (1 - iz).NaturalLogarithm())) + (Math.PI / 2);
Magic Number,MathNet.Numerics,Complex,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Complex.cs,InverseCotangent,The following statement contains a magic number: return (new Complex(0' 0.5) * ((1 + iz).NaturalLogarithm() - (1 - iz).NaturalLogarithm())) + (Math.PI / 2);
Magic Number,MathNet.Numerics,Complex,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Complex.cs,HyperbolicSecant,The following statement contains a magic number: return 2 * exp / (exp.Square() + 1);
Magic Number,MathNet.Numerics,Complex,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Complex.cs,HyperbolicCosecant,The following statement contains a magic number: return 2 * exp / (exp.Square() - 1);
Magic Number,MathNet.Numerics,Complex,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Complex.cs,InverseHyperbolicTangent,The following statement contains a magic number: return 0.5 * ((1 + this).NaturalLogarithm() - (1 - this).NaturalLogarithm());
Magic Number,MathNet.Numerics,Complex,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Complex.cs,InverseHyperbolicCotangent,The following statement contains a magic number: return 0.5 * ((this + 1).NaturalLogarithm() - (this - 1).NaturalLogarithm());
Magic Number,MathNet.Numerics,Complex,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Complex.cs,NaturalLogarithm,The following statement contains a magic number: return new Complex(                  0.5d * Math.Log(ModulusSquared)'                  Argument);
Magic Number,MathNet.Numerics,Complex,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Complex.cs,Square,The following statement contains a magic number: return new Complex(                  (_real * _real) - (_imag * _imag)'                  2 * _real * _imag);
Magic Number,MathNet.Numerics,ComplexPolynomial,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\ComplexPolynomial.cs,SizeOfOrder,The following statement contains a magic number: return 1 << (int)Math.Ceiling(Math.Log(order + 1' 2));
Magic Number,MathNet.Numerics,ComplexPolynomial,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\ComplexPolynomial.cs,DivideShiftInplace,The following statement contains a magic number: (n << 2) > _order
Magic Number,MathNet.Numerics,ComplexPolynomial,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\ComplexPolynomial.cs,Multiply,The following statement contains a magic number: orderMin > 3
Magic Number,MathNet.Numerics,ComplexPolynomial,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\ComplexPolynomial.cs,MultiplyKaratsuba,The following statement contains a magic number: n == 2
Magic Number,MathNet.Numerics,Sorting,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Sorting.cs,Sort,The following statement contains a magic number: keys.Count == 2
Magic Number,MathNet.Numerics,Sorting,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Sorting.cs,Sort,The following statement contains a magic number: count == 2
Magic Number,MathNet.Numerics,Natural,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Natural.cs,Multiply,The following statement contains a magic number: Math.Max(_bound' number._bound) < 12
Magic Number,MathNet.Numerics,Natural,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Natural.cs,MultiplySmall,The following statement contains a magic number: uint len = _bound + number._bound + 2;
Magic Number,MathNet.Numerics,Natural,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Natural.cs,MultiplyLarge,The following statement contains a magic number: uint k = (uint)Math.Ceiling(0.5 * len);
Magic Number,MathNet.Numerics,Number,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Number.cs,PositiveEpsilonOf,The following statement contains a magic number: return 2 * EpsilonOf(value);
Magic Number,MathNet.Numerics,Number,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Number.cs,Increment,The following statement contains a magic number: signed64 == -9223372036854775808
Magic Number,MathNet.Numerics,Polynomial,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Polynomial.cs,SizeOfOrder,The following statement contains a magic number: return 1 << (int)Math.Ceiling(Math.Log(order + 1' 2));
Magic Number,MathNet.Numerics,Polynomial,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Polynomial.cs,DivideShiftInplace,The following statement contains a magic number: (n << 2) > _order
Magic Number,MathNet.Numerics,Polynomial,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Polynomial.cs,Multiply,The following statement contains a magic number: orderMin > 3
Magic Number,MathNet.Numerics,Polynomial,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Polynomial.cs,MultiplyKaratsuba,The following statement contains a magic number: n == 2
Magic Number,MathNet.Numerics,Quaternion,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Quaternion.cs,Lg,The following statement contains a magic number: return Ln().Divide(Math.Log(10));
Magic Number,MathNet.Numerics,Quaternion,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Quaternion.cs,Sqr,The following statement contains a magic number: double arg = _arg * 2;
Magic Number,MathNet.Numerics,Quaternion,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Quaternion.cs,Sqrt,The following statement contains a magic number: double arg = _arg * 0.5;
Magic Number,MathNet.Numerics,Ratios,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Ratios.cs,RatioToDecibel,The following statement contains a magic number: return 10 * Math.Log10(ratio);
Magic Number,MathNet.Numerics,Ratios,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Ratios.cs,RatioToDecibel,The following statement contains a magic number: return 10 * (Math.Log10(value) - Math.Log10(baseValue));
Magic Number,MathNet.Numerics,Ratios,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Ratios.cs,DecibelToRatio,The following statement contains a magic number: return Math.Pow(10' 0.1 * decibel);
Magic Number,MathNet.Numerics,Ratios,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Ratios.cs,DecibelToRatio,The following statement contains a magic number: return Math.Pow(10' 0.1 * decibel);
Magic Number,MathNet.Numerics,Ratios,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Ratios.cs,DecibelToValue,The following statement contains a magic number: return Math.Pow(10' 0.1 * decibel) * baseValue;
Magic Number,MathNet.Numerics,Ratios,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Ratios.cs,DecibelToValue,The following statement contains a magic number: return Math.Pow(10' 0.1 * decibel) * baseValue;
Magic Number,MathNet.Numerics,Ratios,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Ratios.cs,RatioToPowerDecibel,The following statement contains a magic number: return 20 * Math.Log10(ratio);
Magic Number,MathNet.Numerics,Ratios,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Ratios.cs,RatioToPowerDecibel,The following statement contains a magic number: return 20 * (Math.Log10(value) - Math.Log10(baseValue));
Magic Number,MathNet.Numerics,Ratios,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Ratios.cs,PowerDecibelToRatio,The following statement contains a magic number: return Math.Pow(10' 0.05 * decibel);
Magic Number,MathNet.Numerics,Ratios,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Ratios.cs,PowerDecibelToRatio,The following statement contains a magic number: return Math.Pow(10' 0.05 * decibel);
Magic Number,MathNet.Numerics,Ratios,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Ratios.cs,PowerDecibelToValue,The following statement contains a magic number: return Math.Pow(10' 0.05 * decibel) * baseValue;
Magic Number,MathNet.Numerics,Ratios,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Ratios.cs,PowerDecibelToValue,The following statement contains a magic number: return Math.Pow(10' 0.05 * decibel) * baseValue;
Magic Number,MathNet.Numerics,SampleList,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SampleList.cs,SampleList,The following statement contains a magic number: _sampleCount = new int[16];
Magic Number,MathNet.Numerics,SampleList,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SampleList.cs,SampleList,The following statement contains a magic number: _sampleT = new double[16];
Magic Number,MathNet.Numerics,SampleList,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SampleList.cs,SampleList,The following statement contains a magic number: _sampleX = new double[16];
Magic Number,MathNet.Numerics,SampleList,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SampleList.cs,EnsureCapacity,The following statement contains a magic number: int capacitySuggestion = (_sampleCount.Length < 8) ? 16 : (_sampleCount.Length << 1);
Magic Number,MathNet.Numerics,SampleList,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SampleList.cs,EnsureCapacity,The following statement contains a magic number: int capacitySuggestion = (_sampleCount.Length < 8) ? 16 : (_sampleCount.Length << 1);
Magic Number,MathNet.Numerics,SampleList,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SampleList.cs,LocateBisection,The following statement contains a magic number: return _size - 2;
Magic Number,MathNet.Numerics,Fn,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions.cs,IntPow2,The following statement contains a magic number: exponent < 0 || exponent >= 31
Magic Number,MathNet.Numerics,Fn,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions.cs,IntLog2,The following statement contains a magic number: x <= 2
Magic Number,MathNet.Numerics,Fn,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions.cs,IntLog2,The following statement contains a magic number: return 2;
Magic Number,MathNet.Numerics,Fn,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions.cs,IntLog2,The following statement contains a magic number: x <= 4
Magic Number,MathNet.Numerics,Fn,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions.cs,IntLog2,The following statement contains a magic number: return 3;
Magic Number,MathNet.Numerics,Fn,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions.cs,IntLog2,The following statement contains a magic number: x <= 8
Magic Number,MathNet.Numerics,Fn,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions.cs,IntLog2,The following statement contains a magic number: return 4;
Magic Number,MathNet.Numerics,Fn,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions.cs,IntLog2,The following statement contains a magic number: x <= 16
Magic Number,MathNet.Numerics,Fn,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions.cs,IntLog2,The following statement contains a magic number: return 5;
Magic Number,MathNet.Numerics,Fn,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions.cs,IntLog2,The following statement contains a magic number: x <= 32
Magic Number,MathNet.Numerics,Fn,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions.cs,IntLog2,The following statement contains a magic number: return 6;
Magic Number,MathNet.Numerics,Fn,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions.cs,IntLog2,The following statement contains a magic number: x <= 64
Magic Number,MathNet.Numerics,Fn,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions.cs,IntLog2,The following statement contains a magic number: return 7;
Magic Number,MathNet.Numerics,Fn,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions.cs,IntLog2,The following statement contains a magic number: x <= 128
Magic Number,MathNet.Numerics,Fn,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions.cs,IntLog2,The following statement contains a magic number: return 8;
Magic Number,MathNet.Numerics,Fn,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions.cs,IntLog2,The following statement contains a magic number: x <= 256
Magic Number,MathNet.Numerics,Fn,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions.cs,IntLog2,The following statement contains a magic number: return 9;
Magic Number,MathNet.Numerics,Fn,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions.cs,IntLog2,The following statement contains a magic number: x <= 512
Magic Number,MathNet.Numerics,Fn,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions.cs,IntLog2,The following statement contains a magic number: return 10;
Magic Number,MathNet.Numerics,Fn,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions.cs,IntLog2,The following statement contains a magic number: x <= 1024
Magic Number,MathNet.Numerics,Fn,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions.cs,IntLog2,The following statement contains a magic number: return 11;
Magic Number,MathNet.Numerics,Fn,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions.cs,IntLog2,The following statement contains a magic number: x <= 2048
Magic Number,MathNet.Numerics,Fn,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions.cs,IntLog2,The following statement contains a magic number: return 12;
Magic Number,MathNet.Numerics,Fn,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions.cs,IntLog2,The following statement contains a magic number: x <= 4096
Magic Number,MathNet.Numerics,Fn,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions.cs,IntLog2,The following statement contains a magic number: return 13;
Magic Number,MathNet.Numerics,Fn,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions.cs,IntLog2,The following statement contains a magic number: x <= 8192
Magic Number,MathNet.Numerics,Fn,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions.cs,IntLog2,The following statement contains a magic number: return 14;
Magic Number,MathNet.Numerics,Fn,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions.cs,IntLog2,The following statement contains a magic number: x <= 16384
Magic Number,MathNet.Numerics,Fn,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions.cs,IntLog2,The following statement contains a magic number: return 15;
Magic Number,MathNet.Numerics,Fn,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions.cs,IntLog2,The following statement contains a magic number: x <= 32768
Magic Number,MathNet.Numerics,Fn,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions.cs,IntLog2,The following statement contains a magic number: return 16;
Magic Number,MathNet.Numerics,Fn,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions.cs,IntLog2,The following statement contains a magic number: x <= 65536
Magic Number,MathNet.Numerics,Fn,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions.cs,IntLog2,The following statement contains a magic number: return 17;
Magic Number,MathNet.Numerics,Fn,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions.cs,IntLog2,The following statement contains a magic number: x <= 131072
Magic Number,MathNet.Numerics,Fn,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions.cs,IntLog2,The following statement contains a magic number: return 18;
Magic Number,MathNet.Numerics,Fn,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions.cs,IntLog2,The following statement contains a magic number: x <= 262144
Magic Number,MathNet.Numerics,Fn,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions.cs,IntLog2,The following statement contains a magic number: return 19;
Magic Number,MathNet.Numerics,Fn,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions.cs,IntLog2,The following statement contains a magic number: x <= 524288
Magic Number,MathNet.Numerics,Fn,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions.cs,IntLog2,The following statement contains a magic number: return 20;
Magic Number,MathNet.Numerics,Fn,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions.cs,IntLog2,The following statement contains a magic number: x <= 1048576
Magic Number,MathNet.Numerics,Fn,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions.cs,IntLog2,The following statement contains a magic number: return 21;
Magic Number,MathNet.Numerics,Fn,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions.cs,IntLog2,The following statement contains a magic number: x <= 2097152
Magic Number,MathNet.Numerics,Fn,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions.cs,IntLog2,The following statement contains a magic number: return 22;
Magic Number,MathNet.Numerics,Fn,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions.cs,IntLog2,The following statement contains a magic number: x <= 4194304
Magic Number,MathNet.Numerics,Fn,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions.cs,IntLog2,The following statement contains a magic number: return 23;
Magic Number,MathNet.Numerics,Fn,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions.cs,IntLog2,The following statement contains a magic number: x <= 8388608
Magic Number,MathNet.Numerics,Fn,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions.cs,IntLog2,The following statement contains a magic number: return 24;
Magic Number,MathNet.Numerics,Fn,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions.cs,IntLog2,The following statement contains a magic number: x <= 16777216
Magic Number,MathNet.Numerics,Fn,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions.cs,IntLog2,The following statement contains a magic number: return 25;
Magic Number,MathNet.Numerics,Fn,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions.cs,IntLog2,The following statement contains a magic number: x <= 33554432
Magic Number,MathNet.Numerics,Fn,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions.cs,IntLog2,The following statement contains a magic number: return 26;
Magic Number,MathNet.Numerics,Fn,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions.cs,IntLog2,The following statement contains a magic number: x <= 67108864
Magic Number,MathNet.Numerics,Fn,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions.cs,IntLog2,The following statement contains a magic number: return 27;
Magic Number,MathNet.Numerics,Fn,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions.cs,IntLog2,The following statement contains a magic number: x <= 134217728
Magic Number,MathNet.Numerics,Fn,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions.cs,IntLog2,The following statement contains a magic number: return 28;
Magic Number,MathNet.Numerics,Fn,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions.cs,IntLog2,The following statement contains a magic number: x <= 268435456
Magic Number,MathNet.Numerics,Fn,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions.cs,IntLog2,The following statement contains a magic number: return 29;
Magic Number,MathNet.Numerics,Fn,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions.cs,IntLog2,The following statement contains a magic number: x <= 536870912
Magic Number,MathNet.Numerics,Fn,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions.cs,IntLog2,The following statement contains a magic number: return 30;
Magic Number,MathNet.Numerics,Fn,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions.cs,IntLog2,The following statement contains a magic number: x <= 1073741824
Magic Number,MathNet.Numerics,Fn,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions.cs,IntLog2,The following statement contains a magic number: return 31;
Magic Number,MathNet.Numerics,Fn,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions.cs,BinomialCoefficient,The following statement contains a magic number: return Math.Floor(0.5 + Math.Exp(FactorialLn(n) - FactorialLn(k) - FactorialLn(n - k)));
Magic Number,MathNet.Numerics,Fn,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions.cs,HarmonicNumber,The following statement contains a magic number: return Constants.EulerGamma                      + Math.Log(n)                      + (0.5 / n)                      - (1.0 / (12.0 * n2))                      + (1.0 / (120.0 * n4));
Magic Number,MathNet.Numerics,Fn,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions.cs,HarmonicNumber,The following statement contains a magic number: return Constants.EulerGamma                      + Math.Log(n)                      + (0.5 / n)                      - (1.0 / (12.0 * n2))                      + (1.0 / (120.0 * n4));
Magic Number,MathNet.Numerics,Fn,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions.cs,HarmonicNumber,The following statement contains a magic number: return Constants.EulerGamma                      + Math.Log(n)                      + (0.5 / n)                      - (1.0 / (12.0 * n2))                      + (1.0 / (120.0 * n4));
Magic Number,MathNet.Numerics,Trig,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Trigonometry.cs,DegreeToGrad,The following statement contains a magic number: return degree / 9 * 10;
Magic Number,MathNet.Numerics,Trig,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Trigonometry.cs,DegreeToGrad,The following statement contains a magic number: return degree / 9 * 10;
Magic Number,MathNet.Numerics,Trig,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Trigonometry.cs,GradToDegree,The following statement contains a magic number: return newgrad / 10 * 9;
Magic Number,MathNet.Numerics,Trig,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Trigonometry.cs,GradToDegree,The following statement contains a magic number: return newgrad / 10 * 9;
Magic Number,MathNet.Numerics,Trig,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Trigonometry.cs,HyperbolicSine,The following statement contains a magic number: return (Math.Exp(radian) - Math.Exp(-radian)) / 2;
Magic Number,MathNet.Numerics,Trig,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Trigonometry.cs,HyperbolicCosine,The following statement contains a magic number: return (Math.Exp(radian) + Math.Exp(-radian)) / 2;
Magic Number,MathNet.Numerics,Trig,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Trigonometry.cs,InverseHyperbolicTangent,The following statement contains a magic number: return 0.5 * Math.Log(                  (1 + real) / (1 - real)'                  Math.E);
Magic Number,MathNet.Numerics,Trig,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Trigonometry.cs,InverseHyperbolicCotangent,The following statement contains a magic number: return 0.5 * Math.Log(                  (real + 1) / (real - 1)'                  Math.E);
Magic Number,MathNet.Numerics.Distributions,CauchyLorentzDistribution,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Distributions\Continuous\CauchyLorentzDistribution.cs,CumulativeDistribution,The following statement contains a magic number: return (Constants.InvPi * Trig.InverseTangent((x - _location) / _scale)) + 0.5;
Magic Number,MathNet.Numerics.Distributions,CauchyLorentzDistribution,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Distributions\Continuous\CauchyLorentzDistribution.cs,NextDouble,The following statement contains a magic number: return _location + (_scale * Trig.Tangent(Constants.Pi * (RandomSource.NextDouble() - 0.5)));
Magic Number,MathNet.Numerics.Distributions,ChiSquareDistribution,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Distributions\Continuous\ChiSquareDistribution.cs,SetDistributionParameters,The following statement contains a magic number: _lngammaDegreesOfFreedomHalf = Fn.GammaLn(0.5 * degreesOfFreedom);
Magic Number,MathNet.Numerics.Distributions,ChiSquareDistribution,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Distributions\Continuous\ChiSquareDistribution.cs,ProbabilityDensity,The following statement contains a magic number: return Math.Exp(                  ((-0.5 * _degreesOfFreedom) * Constants.Ln2)                  + (((0.5 * _degreesOfFreedom) + 1.0) * Math.Log(x))                  - (0.5 * x)                  - _lngammaDegreesOfFreedomHalf);
Magic Number,MathNet.Numerics.Distributions,ChiSquareDistribution,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Distributions\Continuous\ChiSquareDistribution.cs,ProbabilityDensity,The following statement contains a magic number: return Math.Exp(                  ((-0.5 * _degreesOfFreedom) * Constants.Ln2)                  + (((0.5 * _degreesOfFreedom) + 1.0) * Math.Log(x))                  - (0.5 * x)                  - _lngammaDegreesOfFreedomHalf);
Magic Number,MathNet.Numerics.Distributions,ChiSquareDistribution,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Distributions\Continuous\ChiSquareDistribution.cs,ProbabilityDensity,The following statement contains a magic number: return Math.Exp(                  ((-0.5 * _degreesOfFreedom) * Constants.Ln2)                  + (((0.5 * _degreesOfFreedom) + 1.0) * Math.Log(x))                  - (0.5 * x)                  - _lngammaDegreesOfFreedomHalf);
Magic Number,MathNet.Numerics.Distributions,ChiSquareDistribution,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Distributions\Continuous\ChiSquareDistribution.cs,CumulativeDistribution,The following statement contains a magic number: return Fn.GammaRegularized(0.5 * _degreesOfFreedom' 0.5 * x);
Magic Number,MathNet.Numerics.Distributions,ChiSquareDistribution,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Distributions\Continuous\ChiSquareDistribution.cs,CumulativeDistribution,The following statement contains a magic number: return Fn.GammaRegularized(0.5 * _degreesOfFreedom' 0.5 * x);
Magic Number,MathNet.Numerics.Distributions,ChiSquareDistribution,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Distributions\Continuous\ChiSquareDistribution.cs,InverseCumulativeDistribution,The following statement contains a magic number: return 2 * Fn.GammaRegularizedInverse(0.5 * _degreesOfFreedom' x);
Magic Number,MathNet.Numerics.Distributions,ChiSquareDistribution,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Distributions\Continuous\ChiSquareDistribution.cs,InverseCumulativeDistribution,The following statement contains a magic number: return 2 * Fn.GammaRegularizedInverse(0.5 * _degreesOfFreedom' x);
Magic Number,MathNet.Numerics.Distributions,ChiDistribution,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Distributions\Continuous\ChiDistribution.cs,SetDistributionParameters,The following statement contains a magic number: _lngammaDegreesOfFreedomHalf = Fn.GammaLn(0.5 * degreesOfFreedom);
Magic Number,MathNet.Numerics.Distributions,ChiDistribution,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Distributions\Continuous\ChiDistribution.cs,ProbabilityDensity,The following statement contains a magic number: return Math.Exp(                  ((1.0 - (0.5 * _degreesOfFreedom)) * Constants.Ln2)                  + ((_degreesOfFreedom - 1) * Math.Log(x))                  - (0.5 * x * x)                  - _lngammaDegreesOfFreedomHalf);
Magic Number,MathNet.Numerics.Distributions,ChiDistribution,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Distributions\Continuous\ChiDistribution.cs,ProbabilityDensity,The following statement contains a magic number: return Math.Exp(                  ((1.0 - (0.5 * _degreesOfFreedom)) * Constants.Ln2)                  + ((_degreesOfFreedom - 1) * Math.Log(x))                  - (0.5 * x * x)                  - _lngammaDegreesOfFreedomHalf);
Magic Number,MathNet.Numerics.Distributions,ChiDistribution,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Distributions\Continuous\ChiDistribution.cs,CumulativeDistribution,The following statement contains a magic number: return Fn.GammaRegularized(0.5 * _degreesOfFreedom' 0.5 * x * x);
Magic Number,MathNet.Numerics.Distributions,ChiDistribution,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Distributions\Continuous\ChiDistribution.cs,CumulativeDistribution,The following statement contains a magic number: return Fn.GammaRegularized(0.5 * _degreesOfFreedom' 0.5 * x * x);
Magic Number,MathNet.Numerics.Distributions,ChiDistribution,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Distributions\Continuous\ChiDistribution.cs,InverseCumulativeDistribution,The following statement contains a magic number: return Math.Sqrt(2 * Fn.GammaRegularizedInverse(0.5 * _degreesOfFreedom' x));
Magic Number,MathNet.Numerics.Distributions,ChiDistribution,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Distributions\Continuous\ChiDistribution.cs,InverseCumulativeDistribution,The following statement contains a magic number: return Math.Sqrt(2 * Fn.GammaRegularizedInverse(0.5 * _degreesOfFreedom' x));
Magic Number,MathNet.Numerics.Distributions,RayleighDistribution,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Distributions\Continuous\RayleighDistribution.cs,SetDistributionParameters,The following statement contains a magic number: _helper = 1 / (2 * sigma * sigma);
Magic Number,MathNet.Numerics.Distributions,RayleighDistribution,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Distributions\Continuous\RayleighDistribution.cs,EstimateDistributionParameters,The following statement contains a magic number: SetDistributionParameters(Math.Sqrt(sumOfSquares / (2 * n)));
Magic Number,MathNet.Numerics.Distributions,RayleighDistribution,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Distributions\Continuous\RayleighDistribution.cs,ProbabilityDensity,The following statement contains a magic number: return x * Math.Exp(-(x * x * _helper)) * (2 * _helper);
Magic Number,MathNet.Numerics.Distributions,RayleighDistribution,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Distributions\Continuous\RayleighDistribution.cs,NextDouble,The following statement contains a magic number: return _sigma * Math.Sqrt(-2 * Math.Log(1 - RandomSource.NextDouble()));
Magic Number,MathNet.Numerics.Distributions,StudentsTDistribution,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Distributions\Continuous\StudentsTDistribution.cs,SetDistributionParameters,The following statement contains a magic number: double a = 0.5 * (_degreesOfFreedom + 1);
Magic Number,MathNet.Numerics.Distributions,StudentsTDistribution,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Distributions\Continuous\StudentsTDistribution.cs,SetDistributionParameters,The following statement contains a magic number: double dLn2 = Fn.GammaLn(0.5 * _degreesOfFreedom);
Magic Number,MathNet.Numerics.Distributions,StudentsTDistribution,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Distributions\Continuous\StudentsTDistribution.cs,SetDistributionParameters,The following statement contains a magic number: _summand = Fn.BetaRegularized(0.5 * _degreesOfFreedom' 0.5' 1);
Magic Number,MathNet.Numerics.Distributions,StudentsTDistribution,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Distributions\Continuous\StudentsTDistribution.cs,SetDistributionParameters,The following statement contains a magic number: _summand = Fn.BetaRegularized(0.5 * _degreesOfFreedom' 0.5' 1);
Magic Number,MathNet.Numerics.Distributions,StudentsTDistribution,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Distributions\Continuous\StudentsTDistribution.cs,CumulativeDistribution,The following statement contains a magic number: double beta = Fn.BetaRegularized(                  0.5 * _degreesOfFreedom'                  0.5'                  _degreesOfFreedom / (_degreesOfFreedom + (x * x)));
Magic Number,MathNet.Numerics.Distributions,StudentsTDistribution,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Distributions\Continuous\StudentsTDistribution.cs,CumulativeDistribution,The following statement contains a magic number: double beta = Fn.BetaRegularized(                  0.5 * _degreesOfFreedom'                  0.5'                  _degreesOfFreedom / (_degreesOfFreedom + (x * x)));
Magic Number,MathNet.Numerics.Distributions,StudentsTDistribution,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Distributions\Continuous\StudentsTDistribution.cs,CumulativeDistribution,The following statement contains a magic number: return 0.5 + (0.5 * Math.Sign(x) * (_summand - beta));
Magic Number,MathNet.Numerics.Distributions,StudentsTDistribution,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Distributions\Continuous\StudentsTDistribution.cs,CumulativeDistribution,The following statement contains a magic number: return 0.5 + (0.5 * Math.Sign(x) * (_summand - beta));
Magic Number,MathNet.Numerics.Distributions,FisherSnedecorDistribution,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Distributions\Continuous\FisherSnedecorDistribution.cs,SetDistributionParameters,The following statement contains a magic number: double alphaHalf = 0.5 * alpha;
Magic Number,MathNet.Numerics.Distributions,FisherSnedecorDistribution,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Distributions\Continuous\FisherSnedecorDistribution.cs,SetDistributionParameters,The following statement contains a magic number: double betaHalf = 0.5 * beta;
Magic Number,MathNet.Numerics.Distributions,FisherSnedecorDistribution,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Distributions\Continuous\FisherSnedecorDistribution.cs,ProbabilityDensity,The following statement contains a magic number: 2 == _alpha
Magic Number,MathNet.Numerics.Distributions,FisherSnedecorDistribution,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Distributions\Continuous\FisherSnedecorDistribution.cs,CumulativeDistribution,The following statement contains a magic number: return Fn.BetaRegularized(0.5 * _alpha' 0.5 * _beta' m);
Magic Number,MathNet.Numerics.Distributions,FisherSnedecorDistribution,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Distributions\Continuous\FisherSnedecorDistribution.cs,CumulativeDistribution,The following statement contains a magic number: return Fn.BetaRegularized(0.5 * _alpha' 0.5 * _beta' m);
Magic Number,MathNet.Numerics.Distributions,LaplaceDistribution,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Distributions\Continuous\LaplaceDistribution.cs,ProbabilityDensity,The following statement contains a magic number: return 1.0 / (2.0 * _scale) * Math.Exp(-Math.Abs(x - _location) / _scale);
Magic Number,MathNet.Numerics.Distributions,LaplaceDistribution,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Distributions\Continuous\LaplaceDistribution.cs,CumulativeDistribution,The following statement contains a magic number: return 0.5 * Math.Exp((x - _location) / _scale);
Magic Number,MathNet.Numerics.Distributions,LaplaceDistribution,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Distributions\Continuous\LaplaceDistribution.cs,CumulativeDistribution,The following statement contains a magic number: return 1.0 - (0.5 * Math.Exp((_location - x) / _scale));
Magic Number,MathNet.Numerics.Distributions,LaplaceDistribution,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Distributions\Continuous\LaplaceDistribution.cs,NextDouble,The following statement contains a magic number: double rand = 0.5 - RandomSource.NextDouble();
Magic Number,MathNet.Numerics.Distributions,LaplaceDistribution,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Distributions\Continuous\LaplaceDistribution.cs,NextDouble,The following statement contains a magic number: return _location - (_scale * Math.Sign(rand) * Math.Log(2.0 * Math.Abs(rand)));
Magic Number,MathNet.Numerics.Distributions,LognormalDistribution,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Distributions\Continuous\LognormalDistribution.cs,ProbabilityDensity,The following statement contains a magic number: return Math.Exp(-0.5 * a * a) / (x * _sigma * Constants.Sqrt2Pi);
Magic Number,MathNet.Numerics.Distributions,LognormalDistribution,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Distributions\Continuous\LognormalDistribution.cs,CumulativeDistribution,The following statement contains a magic number: return 0.5 * (1.0 + Fn.Erf((Math.Log(x) - _mu) / (_sigma * Constants.Sqrt2)));
Magic Number,MathNet.Numerics.Distributions,LognormalDistribution,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Distributions\Continuous\LognormalDistribution.cs,InverseCumulativeDistribution,The following statement contains a magic number: return Math.Exp((_sigma * Constants.Sqrt2 * Fn.ErfInverse((2.0 * x) - 1.0)) + _mu);
Magic Number,MathNet.Numerics.Distributions,NormalDistribution,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Distributions\Continuous\NormalDistribution.cs,ProbabilityDensity,The following statement contains a magic number: return Constants.InvSqrt2Pi / _sigma * Math.Exp(xmu * xmu / (-2.0 * _sigma * _sigma));
Magic Number,MathNet.Numerics.Distributions,NormalDistribution,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Distributions\Continuous\NormalDistribution.cs,CumulativeDistribution,The following statement contains a magic number: return 0.5 * (1.0 + Fn.Erf((x - _mu) / (_sigma * Constants.Sqrt2)));
Magic Number,MathNet.Numerics.Distributions,NormalDistribution,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Distributions\Continuous\NormalDistribution.cs,InverseCumulativeDistribution,The following statement contains a magic number: return (_sigma * Constants.Sqrt2 * Fn.ErfInverse((2.0 * x) - 1.0)) + _mu;
Magic Number,MathNet.Numerics.Distributions,StableDistribution,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Distributions\Continuous\StableDistribution.cs,SetDistributionParameters,The following statement contains a magic number: _factor = Math.Pow(1.0 + (part1 * part1)' 1.0 / (2.0 * exponent));
Magic Number,MathNet.Numerics.Distributions,StableDistribution,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Distributions\Continuous\StableDistribution.cs,IsValidParameterSet,The following statement contains a magic number: return scale >= 0                  && skewness <= 1.0                  && skewness >= -1.0                  && exponent > 0                  && exponent <= 2;
Magic Number,MathNet.Numerics.Distributions,StableDistribution,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Distributions\Continuous\StableDistribution.cs,NextDouble,The following statement contains a magic number: return (2.0 / Math.PI) * (summand - subtrahend);
Magic Number,MathNet.Numerics.Distributions,StandardDistribution,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Distributions\Continuous\StandardDistribution.cs,ProbabilityDensity,The following statement contains a magic number: return Constants.InvSqrt2Pi * Math.Exp(x * x / -2.0);
Magic Number,MathNet.Numerics.Distributions,StandardDistribution,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Distributions\Continuous\StandardDistribution.cs,CumulativeDistribution,The following statement contains a magic number: return 0.5 * (1.0 + Fn.Erf(x * Constants.Sqrt1_2));
Magic Number,MathNet.Numerics.Distributions,StandardDistribution,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Distributions\Continuous\StandardDistribution.cs,InverseCumulativeDistribution,The following statement contains a magic number: return Constants.Sqrt1_2 * Fn.ErfInverse((2.0 * x) - 1.0);
Magic Number,MathNet.Numerics.Distributions,StandardDistribution,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Distributions\Continuous\StandardDistribution.cs,NextDouble,The following statement contains a magic number: v1 = (2.0 * RandomSource.NextDouble()) - 1.0;
Magic Number,MathNet.Numerics.Distributions,StandardDistribution,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Distributions\Continuous\StandardDistribution.cs,NextDouble,The following statement contains a magic number: v2 = (2.0 * RandomSource.NextDouble()) - 1.0;
Magic Number,MathNet.Numerics.Distributions,StandardDistribution,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Distributions\Continuous\StandardDistribution.cs,NextDouble,The following statement contains a magic number: double fac = Math.Sqrt(-2.0 * Math.Log(rsq) / rsq);
Magic Number,MathNet.Numerics.Distributions,TriangularDistribution,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Distributions\Continuous\TriangularDistribution.cs,TriangularDistribution,The following statement contains a magic number: SetDistributionParameters(0.0' 1.0' 0.5);
Magic Number,MathNet.Numerics.Distributions,TriangularDistribution,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Distributions\Continuous\TriangularDistribution.cs,TriangularDistribution,The following statement contains a magic number: SetDistributionParameters(0.0' 1.0' 0.5);
Magic Number,MathNet.Numerics.Distributions,TriangularDistribution,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Distributions\Continuous\TriangularDistribution.cs,ProbabilityDensity,The following statement contains a magic number: return 2 * (x - _a) / (_diff * _lowerPart);
Magic Number,MathNet.Numerics.Distributions,TriangularDistribution,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Distributions\Continuous\TriangularDistribution.cs,ProbabilityDensity,The following statement contains a magic number: return 2 * (_b - x) / (_diff * _upperPart);
Magic Number,MathNet.Numerics.Distributions,ArbitraryDistribution,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Distributions\Discrete\ArbitraryDistribution.cs,SetDistributionParameters,The following statement contains a magic number: _pmf == null || _pmf.Length < _n || _pmf.Length >= 4 * _n
Magic Number,MathNet.Numerics.Distributions,ArbitraryDistribution,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Distributions\Discrete\ArbitraryDistribution.cs,IsValidParameterSet,The following statement contains a magic number: return Number.AlmostEqual(1.0' sum' 10 + (2 * probabilityMass.Length));
Magic Number,MathNet.Numerics.Distributions,ArbitraryDistribution,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Distributions\Discrete\ArbitraryDistribution.cs,IsValidParameterSet,The following statement contains a magic number: return Number.AlmostEqual(1.0' sum' 10 + (2 * probabilityMass.Length));
Magic Number,MathNet.Numerics.Distributions,BernoulliDistribution,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Distributions\Discrete\BernoulliDistribution.cs,BernoulliDistribution,The following statement contains a magic number: SetDistributionParameters(0.5);
Magic Number,MathNet.Numerics.Distributions,BernoulliDistribution,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Distributions\Discrete\BernoulliDistribution.cs,BernoulliDistribution,The following statement contains a magic number: SetDistributionParameters(0.5);
Magic Number,MathNet.Numerics.Distributions,BinomialDistribution,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Distributions\Discrete\BinomialDistribution.cs,BinomialDistribution,The following statement contains a magic number: SetDistributionParameters(0.5' 1);
Magic Number,MathNet.Numerics.Distributions,BinomialDistribution,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Distributions\Discrete\BinomialDistribution.cs,BinomialDistribution,The following statement contains a magic number: SetDistributionParameters(0.5' 1);
Magic Number,MathNet.Numerics.Distributions,HypergeometricDistribution,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Distributions\Discrete\HypergeometricDistribution.cs,HypergeometricDistribution,The following statement contains a magic number: SetDistributionParameters(2' 1' 1);
Magic Number,MathNet.Numerics.Distributions,HypergeometricDistribution,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Distributions\Discrete\HypergeometricDistribution.cs,HypergeometricDistribution,The following statement contains a magic number: SetDistributionParameters(2' 1' 1);
Magic Number,MathNet.Numerics.Distributions,GeometricDistribution,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Distributions\Discrete\GeometricDistribution.cs,GeometricDistribution,The following statement contains a magic number: SetDistributionParameters(0.5);
Magic Number,MathNet.Numerics.Distributions,GeometricDistribution,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Distributions\Discrete\GeometricDistribution.cs,GeometricDistribution,The following statement contains a magic number: SetDistributionParameters(0.5);
Magic Number,MathNet.Numerics.Distributions,ZipfDistribution,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Distributions\Discrete\ZipfDistribution.cs,ZipfDistribution,The following statement contains a magic number: _skew = 2d;
Magic Number,MathNet.Numerics.Distributions,ZipfDistribution,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Distributions\Discrete\ZipfDistribution.cs,ZipfDistribution,The following statement contains a magic number: _skew = 2d;
Magic Number,MathNet.Numerics.Integration.Algorithms,DoubleExponentialTransformation,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Integration\Algorithms\DoubleExponentialTransformation.cs,EvaluateAbcissas,The following statement contains a magic number: double step = level <= 1 ? 1.0 : (1.0 / (2 << (level - 2)));
Magic Number,MathNet.Numerics.Integration.Algorithms,DoubleExponentialTransformation,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Integration\Algorithms\DoubleExponentialTransformation.cs,EvaluateAbcissas,The following statement contains a magic number: double step = level <= 1 ? 1.0 : (1.0 / (2 << (level - 2)));
Magic Number,MathNet.Numerics.Integration.Algorithms,DoubleExponentialTransformation,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Integration\Algorithms\DoubleExponentialTransformation.cs,EvaluateAbcissas,The following statement contains a magic number: double offset = level == 0 ? 0.0 : (1.0 / (2 << (level - 1)));
Magic Number,MathNet.Numerics.Integration.Algorithms,DoubleExponentialTransformation,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Integration\Algorithms\DoubleExponentialTransformation.cs,EvaluateAbcissas,The following statement contains a magic number: int length = level == 0 ? 4 : (3 << (level - 1));
Magic Number,MathNet.Numerics.Integration.Algorithms,DoubleExponentialTransformation,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Integration\Algorithms\DoubleExponentialTransformation.cs,EvaluateAbcissas,The following statement contains a magic number: int length = level == 0 ? 4 : (3 << (level - 1));
Magic Number,MathNet.Numerics.Integration.Algorithms,DoubleExponentialTransformation,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Integration\Algorithms\DoubleExponentialTransformation.cs,EvaluateWeights,The following statement contains a magic number: double step = level <= 1 ? 1.0 : (1.0 / (2 << (level - 2)));
Magic Number,MathNet.Numerics.Integration.Algorithms,DoubleExponentialTransformation,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Integration\Algorithms\DoubleExponentialTransformation.cs,EvaluateWeights,The following statement contains a magic number: double step = level <= 1 ? 1.0 : (1.0 / (2 << (level - 2)));
Magic Number,MathNet.Numerics.Integration.Algorithms,DoubleExponentialTransformation,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Integration\Algorithms\DoubleExponentialTransformation.cs,EvaluateWeights,The following statement contains a magic number: double offset = level == 0 ? 0.0 : (1.0 / (2 << (level - 1)));
Magic Number,MathNet.Numerics.Integration.Algorithms,DoubleExponentialTransformation,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Integration\Algorithms\DoubleExponentialTransformation.cs,EvaluateWeights,The following statement contains a magic number: int length = level == 0 ? 4 : (3 << (level - 1));
Magic Number,MathNet.Numerics.Integration.Algorithms,DoubleExponentialTransformation,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Integration\Algorithms\DoubleExponentialTransformation.cs,EvaluateWeights,The following statement contains a magic number: int length = level == 0 ? 4 : (3 << (level - 1));
Magic Number,MathNet.Numerics.Integration.Algorithms,SimpsonRule,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Integration\Algorithms\SimpsonRule.cs,IntegrateThreePoint,The following statement contains a magic number: double midpoint = (intervalEnd + intervalBegin) / 2;
Magic Number,MathNet.Numerics.Integration.Algorithms,SimpsonRule,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Integration\Algorithms\SimpsonRule.cs,IntegrateThreePoint,The following statement contains a magic number: return (intervalEnd - intervalBegin) / 6 * (f(intervalBegin) + f(intervalEnd) + (4 * f(midpoint)));
Magic Number,MathNet.Numerics.Integration.Algorithms,SimpsonRule,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Integration\Algorithms\SimpsonRule.cs,IntegrateThreePoint,The following statement contains a magic number: return (intervalEnd - intervalBegin) / 6 * (f(intervalBegin) + f(intervalEnd) + (4 * f(midpoint)));
Magic Number,MathNet.Numerics.Integration.Algorithms,SimpsonRule,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Integration\Algorithms\SimpsonRule.cs,IntegrateComposite,The following statement contains a magic number: double factor = step / 3;
Magic Number,MathNet.Numerics.Integration.Algorithms,SimpsonRule,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Integration\Algorithms\SimpsonRule.cs,IntegrateComposite,The following statement contains a magic number: int m = 4;
Magic Number,MathNet.Numerics.Integration.Algorithms,SimpsonRule,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Integration\Algorithms\SimpsonRule.cs,IntegrateComposite,The following statement contains a magic number: m = 6 - m;
Magic Number,MathNet.Numerics.Integration.Algorithms,TrapeziumRule,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Integration\Algorithms\TrapeziumRule.cs,IntegrateTwoPoint,The following statement contains a magic number: return (intervalEnd - intervalBegin) / 2 * (f(intervalBegin) + f(intervalEnd));
Magic Number,MathNet.Numerics.Integration.Algorithms,TrapeziumRule,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Integration\Algorithms\TrapeziumRule.cs,IntegrateComposite,The following statement contains a magic number: double sum = 0.5 * (f(intervalBegin) + f(intervalEnd));
Magic Number,MathNet.Numerics.Integration.Algorithms,TrapeziumRule,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Integration\Algorithms\TrapeziumRule.cs,IntegrateAdaptive,The following statement contains a magic number: double sum = 0.5 * step * (f(intervalBegin) + f(intervalEnd));
Magic Number,MathNet.Numerics.Integration.Algorithms,TrapeziumRule,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Integration\Algorithms\TrapeziumRule.cs,IntegrateAdaptive,The following statement contains a magic number: midpointsum += f(intervalBegin + ((i + 0.5) * step));
Magic Number,MathNet.Numerics.Integration.Algorithms,TrapeziumRule,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Integration\Algorithms\TrapeziumRule.cs,IntegrateAdaptive,The following statement contains a magic number: sum = 0.5 * (sum + midpointsum);
Magic Number,MathNet.Numerics.Integration.Algorithms,TrapeziumRule,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Integration\Algorithms\TrapeziumRule.cs,IntegrateAdaptive,The following statement contains a magic number: step *= 0.5;
Magic Number,MathNet.Numerics.Integration.Algorithms,TrapeziumRule,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Integration\Algorithms\TrapeziumRule.cs,IntegrateAdaptive,The following statement contains a magic number: numberOfPartitions *= 2;
Magic Number,MathNet.Numerics.Integration.Algorithms,TrapeziumRule,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Integration\Algorithms\TrapeziumRule.cs,IntegrateAdaptive,The following statement contains a magic number: k < 20
Magic Number,MathNet.Numerics.Integration.Algorithms,TrapeziumRule,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Integration\Algorithms\TrapeziumRule.cs,IntegrateAdaptiveTransformedOdd,The following statement contains a magic number: double linearSlope = 0.5 * (intervalEnd - intervalBegin);
Magic Number,MathNet.Numerics.Integration.Algorithms,TrapeziumRule,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Integration\Algorithms\TrapeziumRule.cs,IntegrateAdaptiveTransformedOdd,The following statement contains a magic number: double linearOffset = 0.5 * (intervalEnd + intervalBegin);
Magic Number,MathNet.Numerics.Integration.Algorithms,TrapeziumRule,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Integration\Algorithms\TrapeziumRule.cs,IntegrateAdaptiveTransformedOdd,The following statement contains a magic number: targetRelativeError /= (5 * linearSlope);
Magic Number,MathNet.Numerics.Integration.Algorithms,TrapeziumRule,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Integration\Algorithms\TrapeziumRule.cs,IntegrateAdaptiveTransformedOdd,The following statement contains a magic number: sum = 0.5 * (sum + midpointsum);
Magic Number,MathNet.Numerics.Integration.Algorithms,TrapeziumRule,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Integration\Algorithms\TrapeziumRule.cs,IntegrateAdaptiveTransformedOdd,The following statement contains a magic number: step *= 0.5;
Magic Number,MathNet.Numerics.Integration.Algorithms,TrapeziumRule,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Integration\Algorithms\TrapeziumRule.cs,IntegrateAdaptiveTransformedOdd,The following statement contains a magic number: r > 1.9 && r < 2.1
Magic Number,MathNet.Numerics.Integration.Algorithms,TrapeziumRule,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Integration\Algorithms\TrapeziumRule.cs,IntegrateAdaptiveTransformedOdd,The following statement contains a magic number: r > 1.9 && r < 2.1
Magic Number,MathNet.Numerics.Integration,Integrate,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Integration\Integrate.cs,OnClosedInterval,The following statement contains a magic number: return Det.Integrate(                  f'                  intervalBegin'                  intervalEnd'                  1e-8);
Magic Number,MathNet.Numerics.Interpolation.Algorithms,AkimaSplineInterpolation,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\AkimaSplineInterpolation.cs,Init,The following statement contains a magic number: t.Count < 5
Magic Number,MathNet.Numerics.Interpolation.Algorithms,AkimaSplineInterpolation,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\AkimaSplineInterpolation.cs,Init,The following statement contains a magic number: i < d.Length - 2
Magic Number,MathNet.Numerics.Interpolation.Algorithms,AkimaSplineInterpolation,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\AkimaSplineInterpolation.cs,Init,The following statement contains a magic number: d[0] = DifferentiateThreePoint(tt[0]' tt[0]' xx[0]' tt[1]' xx[1]' tt[2]' xx[2]);
Magic Number,MathNet.Numerics.Interpolation.Algorithms,AkimaSplineInterpolation,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\AkimaSplineInterpolation.cs,Init,The following statement contains a magic number: d[0] = DifferentiateThreePoint(tt[0]' tt[0]' xx[0]' tt[1]' xx[1]' tt[2]' xx[2]);
Magic Number,MathNet.Numerics.Interpolation.Algorithms,AkimaSplineInterpolation,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\AkimaSplineInterpolation.cs,Init,The following statement contains a magic number: d[1] = DifferentiateThreePoint(tt[1]' tt[0]' xx[0]' tt[1]' xx[1]' tt[2]' xx[2]);
Magic Number,MathNet.Numerics.Interpolation.Algorithms,AkimaSplineInterpolation,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\AkimaSplineInterpolation.cs,Init,The following statement contains a magic number: d[1] = DifferentiateThreePoint(tt[1]' tt[0]' xx[0]' tt[1]' xx[1]' tt[2]' xx[2]);
Magic Number,MathNet.Numerics.Interpolation.Algorithms,AkimaSplineInterpolation,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\AkimaSplineInterpolation.cs,Init,The following statement contains a magic number: d[n - 2] = DifferentiateThreePoint(tt[n - 2]' tt[n - 3]' xx[n - 3]' tt[n - 2]' xx[n - 2]' tt[n - 1]' xx[n - 1]);
Magic Number,MathNet.Numerics.Interpolation.Algorithms,AkimaSplineInterpolation,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\AkimaSplineInterpolation.cs,Init,The following statement contains a magic number: d[n - 2] = DifferentiateThreePoint(tt[n - 2]' tt[n - 3]' xx[n - 3]' tt[n - 2]' xx[n - 2]' tt[n - 1]' xx[n - 1]);
Magic Number,MathNet.Numerics.Interpolation.Algorithms,AkimaSplineInterpolation,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\AkimaSplineInterpolation.cs,Init,The following statement contains a magic number: d[n - 2] = DifferentiateThreePoint(tt[n - 2]' tt[n - 3]' xx[n - 3]' tt[n - 2]' xx[n - 2]' tt[n - 1]' xx[n - 1]);
Magic Number,MathNet.Numerics.Interpolation.Algorithms,AkimaSplineInterpolation,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\AkimaSplineInterpolation.cs,Init,The following statement contains a magic number: d[n - 2] = DifferentiateThreePoint(tt[n - 2]' tt[n - 3]' xx[n - 3]' tt[n - 2]' xx[n - 2]' tt[n - 1]' xx[n - 1]);
Magic Number,MathNet.Numerics.Interpolation.Algorithms,AkimaSplineInterpolation,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\AkimaSplineInterpolation.cs,Init,The following statement contains a magic number: d[n - 2] = DifferentiateThreePoint(tt[n - 2]' tt[n - 3]' xx[n - 3]' tt[n - 2]' xx[n - 2]' tt[n - 1]' xx[n - 1]);
Magic Number,MathNet.Numerics.Interpolation.Algorithms,AkimaSplineInterpolation,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\AkimaSplineInterpolation.cs,Init,The following statement contains a magic number: d[n - 2] = DifferentiateThreePoint(tt[n - 2]' tt[n - 3]' xx[n - 3]' tt[n - 2]' xx[n - 2]' tt[n - 1]' xx[n - 1]);
Magic Number,MathNet.Numerics.Interpolation.Algorithms,AkimaSplineInterpolation,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\AkimaSplineInterpolation.cs,Init,The following statement contains a magic number: d[n - 1] = DifferentiateThreePoint(tt[n - 1]' tt[n - 3]' xx[n - 3]' tt[n - 2]' xx[n - 2]' tt[n - 1]' xx[n - 1]);
Magic Number,MathNet.Numerics.Interpolation.Algorithms,AkimaSplineInterpolation,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\AkimaSplineInterpolation.cs,Init,The following statement contains a magic number: d[n - 1] = DifferentiateThreePoint(tt[n - 1]' tt[n - 3]' xx[n - 3]' tt[n - 2]' xx[n - 2]' tt[n - 1]' xx[n - 1]);
Magic Number,MathNet.Numerics.Interpolation.Algorithms,AkimaSplineInterpolation,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\AkimaSplineInterpolation.cs,Init,The following statement contains a magic number: d[n - 1] = DifferentiateThreePoint(tt[n - 1]' tt[n - 3]' xx[n - 3]' tt[n - 2]' xx[n - 2]' tt[n - 1]' xx[n - 1]);
Magic Number,MathNet.Numerics.Interpolation.Algorithms,AkimaSplineInterpolation,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\AkimaSplineInterpolation.cs,Init,The following statement contains a magic number: d[n - 1] = DifferentiateThreePoint(tt[n - 1]' tt[n - 3]' xx[n - 3]' tt[n - 2]' xx[n - 2]' tt[n - 1]' xx[n - 1]);
Magic Number,MathNet.Numerics.Interpolation.Algorithms,AkimaSplineInterpolation,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\AkimaSplineInterpolation.cs,DifferentiateThreePoint,The following statement contains a magic number: return (2 * a * t) + b;
Magic Number,MathNet.Numerics.Interpolation.Algorithms,BarycentricInterpolation,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\BarycentricInterpolation.cs,Interpolate,The following statement contains a magic number: Math.Abs(s) > 1e-150
Magic Number,MathNet.Numerics.Interpolation.Algorithms,ChebyshevFirstKindPolynomialInterpolation,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\ChebyshevFirstKindPolynomialInterpolation.cs,Init,The following statement contains a magic number: _transformSummand = -0.5 * (a + b);
Magic Number,MathNet.Numerics.Interpolation.Algorithms,ChebyshevFirstKindPolynomialInterpolation,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\ChebyshevFirstKindPolynomialInterpolation.cs,Init,The following statement contains a magic number: _transformFactor = 2.0 / (b - a);
Magic Number,MathNet.Numerics.Interpolation.Algorithms,ChebyshevFirstKindPolynomialInterpolation,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\ChebyshevFirstKindPolynomialInterpolation.cs,Init,The following statement contains a magic number: double a0 = Math.PI / ((2 * (x.Count - 1)) + 2);
Magic Number,MathNet.Numerics.Interpolation.Algorithms,ChebyshevFirstKindPolynomialInterpolation,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\ChebyshevFirstKindPolynomialInterpolation.cs,Init,The following statement contains a magic number: double a0 = Math.PI / ((2 * (x.Count - 1)) + 2);
Magic Number,MathNet.Numerics.Interpolation.Algorithms,ChebyshevFirstKindPolynomialInterpolation,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\ChebyshevFirstKindPolynomialInterpolation.cs,Init,The following statement contains a magic number: double delta = 2 * Math.PI / ((2 * (x.Count - 1)) + 2);
Magic Number,MathNet.Numerics.Interpolation.Algorithms,ChebyshevFirstKindPolynomialInterpolation,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\ChebyshevFirstKindPolynomialInterpolation.cs,Init,The following statement contains a magic number: double delta = 2 * Math.PI / ((2 * (x.Count - 1)) + 2);
Magic Number,MathNet.Numerics.Interpolation.Algorithms,ChebyshevFirstKindPolynomialInterpolation,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\ChebyshevFirstKindPolynomialInterpolation.cs,Init,The following statement contains a magic number: double delta = 2 * Math.PI / ((2 * (x.Count - 1)) + 2);
Magic Number,MathNet.Numerics.Interpolation.Algorithms,ChebyshevFirstKindPolynomialInterpolation,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\ChebyshevFirstKindPolynomialInterpolation.cs,Init,The following statement contains a magic number: double alpha = Math.Sin(delta / 2);
Magic Number,MathNet.Numerics.Interpolation.Algorithms,ChebyshevFirstKindPolynomialInterpolation,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\ChebyshevFirstKindPolynomialInterpolation.cs,Init,The following statement contains a magic number: alpha = 2 * alpha * alpha;
Magic Number,MathNet.Numerics.Interpolation.Algorithms,ChebyshevFirstKindPolynomialInterpolation,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\ChebyshevFirstKindPolynomialInterpolation.cs,GenerateSamplePoints,The following statement contains a magic number: double transformSummand = 0.5 * (a + b);
Magic Number,MathNet.Numerics.Interpolation.Algorithms,ChebyshevFirstKindPolynomialInterpolation,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\ChebyshevFirstKindPolynomialInterpolation.cs,GenerateSamplePoints,The following statement contains a magic number: double transformFactor = (b - a) / 2.0;
Magic Number,MathNet.Numerics.Interpolation.Algorithms,ChebyshevFirstKindPolynomialInterpolation,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\ChebyshevFirstKindPolynomialInterpolation.cs,GenerateSamplePoints,The following statement contains a magic number: double angleFactor = Math.PI / ((2 * (numberOfPoints - 1)) + 2);
Magic Number,MathNet.Numerics.Interpolation.Algorithms,ChebyshevFirstKindPolynomialInterpolation,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\ChebyshevFirstKindPolynomialInterpolation.cs,GenerateSamplePoints,The following statement contains a magic number: double angleFactor = Math.PI / ((2 * (numberOfPoints - 1)) + 2);
Magic Number,MathNet.Numerics.Interpolation.Algorithms,ChebyshevFirstKindPolynomialInterpolation,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\ChebyshevFirstKindPolynomialInterpolation.cs,GenerateSamplePoints,The following statement contains a magic number: nodes[i] = transformSummand + (transformFactor * Math.Cos(((2 * i) + 1) * angleFactor));
Magic Number,MathNet.Numerics.Interpolation.Algorithms,ChebyshevSecondKindPolynomialInterpolation,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\ChebyshevSecondKindPolynomialInterpolation.cs,Init,The following statement contains a magic number: _transformSummand = -0.5 * (a + b);
Magic Number,MathNet.Numerics.Interpolation.Algorithms,ChebyshevSecondKindPolynomialInterpolation,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\ChebyshevSecondKindPolynomialInterpolation.cs,Init,The following statement contains a magic number: _transformFactor = 2.0 / (b - a);
Magic Number,MathNet.Numerics.Interpolation.Algorithms,ChebyshevSecondKindPolynomialInterpolation,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\ChebyshevSecondKindPolynomialInterpolation.cs,Init,The following statement contains a magic number: double alpha = Math.Sin(delta / 2);
Magic Number,MathNet.Numerics.Interpolation.Algorithms,ChebyshevSecondKindPolynomialInterpolation,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\ChebyshevSecondKindPolynomialInterpolation.cs,Init,The following statement contains a magic number: alpha = 2 * alpha * alpha;
Magic Number,MathNet.Numerics.Interpolation.Algorithms,ChebyshevSecondKindPolynomialInterpolation,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\ChebyshevSecondKindPolynomialInterpolation.cs,Init,The following statement contains a magic number: w[0] = 0.5;
Magic Number,MathNet.Numerics.Interpolation.Algorithms,ChebyshevSecondKindPolynomialInterpolation,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\ChebyshevSecondKindPolynomialInterpolation.cs,Init,The following statement contains a magic number: w[w.Length - 1] *= 0.5;
Magic Number,MathNet.Numerics.Interpolation.Algorithms,ChebyshevSecondKindPolynomialInterpolation,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\ChebyshevSecondKindPolynomialInterpolation.cs,GenerateSamplePoints,The following statement contains a magic number: double transformSummand = 0.5 * (a + b);
Magic Number,MathNet.Numerics.Interpolation.Algorithms,ChebyshevSecondKindPolynomialInterpolation,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\ChebyshevSecondKindPolynomialInterpolation.cs,GenerateSamplePoints,The following statement contains a magic number: double transformFactor = (b - a) / 2.0;
Magic Number,MathNet.Numerics.Interpolation.Algorithms,CubicHermiteSplineInterpolation,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\CubicHermiteSplineInterpolation.cs,Init,The following statement contains a magic number: t.Count < 2
Magic Number,MathNet.Numerics.Interpolation.Algorithms,CubicHermiteSplineInterpolation,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\CubicHermiteSplineInterpolation.cs,InitInternal,The following statement contains a magic number: double[] c = new double[4 * (t.Length - 1)];
Magic Number,MathNet.Numerics.Interpolation.Algorithms,CubicHermiteSplineInterpolation,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\CubicHermiteSplineInterpolation.cs,InitInternal,The following statement contains a magic number: c[j + 2] = ((3 * (x[i + 1] - x[i])) - (2 * d[i] * delta) - (d[i + 1] * delta)) / delta2;
Magic Number,MathNet.Numerics.Interpolation.Algorithms,CubicHermiteSplineInterpolation,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\CubicHermiteSplineInterpolation.cs,InitInternal,The following statement contains a magic number: c[j + 2] = ((3 * (x[i + 1] - x[i])) - (2 * d[i] * delta) - (d[i + 1] * delta)) / delta2;
Magic Number,MathNet.Numerics.Interpolation.Algorithms,CubicHermiteSplineInterpolation,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\CubicHermiteSplineInterpolation.cs,InitInternal,The following statement contains a magic number: c[j + 2] = ((3 * (x[i + 1] - x[i])) - (2 * d[i] * delta) - (d[i + 1] * delta)) / delta2;
Magic Number,MathNet.Numerics.Interpolation.Algorithms,CubicHermiteSplineInterpolation,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\CubicHermiteSplineInterpolation.cs,InitInternal,The following statement contains a magic number: c[j + 3] = ((2 * (x[i] - x[i + 1])) + (d[i] * delta) + (d[i + 1] * delta)) / delta3;
Magic Number,MathNet.Numerics.Interpolation.Algorithms,CubicHermiteSplineInterpolation,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\CubicHermiteSplineInterpolation.cs,InitInternal,The following statement contains a magic number: c[j + 3] = ((2 * (x[i] - x[i + 1])) + (d[i] * delta) + (d[i + 1] * delta)) / delta3;
Magic Number,MathNet.Numerics.Interpolation.Algorithms,CubicSplineInterpolation,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\CubicSplineInterpolation.cs,Init,The following statement contains a magic number: t.Count < 2
Magic Number,MathNet.Numerics.Interpolation.Algorithms,CubicSplineInterpolation,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\CubicSplineInterpolation.cs,Init,The following statement contains a magic number: (n == 2)                  && (leftBoundaryCondition == SplineBoundaryCondition.ParabolicallyTerminated)                  && (rightBoundaryCondition == SplineBoundaryCondition.ParabolicallyTerminated)
Magic Number,MathNet.Numerics.Interpolation.Algorithms,CubicSplineInterpolation,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\CubicSplineInterpolation.cs,Init,The following statement contains a magic number: switch(leftBoundaryCondition)              {                  case SplineBoundaryCondition.ParabolicallyTerminated:                      a1[0] = 0;                      a2[0] = 1;                      a3[0] = 1;                      b[0] = 2 * (xx[1] - xx[0]) / (tt[1] - tt[0]);                      break;                  case SplineBoundaryCondition.FirstDerivative:                      a1[0] = 0;                      a2[0] = 1;                      a3[0] = 0;                      b[0] = leftBoundary;                      break;                  case SplineBoundaryCondition.SecondDerivative:                      a1[0] = 0;                      a2[0] = 2;                      a3[0] = 1;                      b[0] = (3 * ((xx[1] - xx[0]) / (tt[1] - tt[0]))) - (0.5 * leftBoundary * (tt[1] - tt[0]));                      break;                  default:                      throw new NotSupportedException(Properties.LocalStrings.InvalidLeftBoundaryCondition);              }
Magic Number,MathNet.Numerics.Interpolation.Algorithms,CubicSplineInterpolation,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\CubicSplineInterpolation.cs,Init,The following statement contains a magic number: switch(leftBoundaryCondition)              {                  case SplineBoundaryCondition.ParabolicallyTerminated:                      a1[0] = 0;                      a2[0] = 1;                      a3[0] = 1;                      b[0] = 2 * (xx[1] - xx[0]) / (tt[1] - tt[0]);                      break;                  case SplineBoundaryCondition.FirstDerivative:                      a1[0] = 0;                      a2[0] = 1;                      a3[0] = 0;                      b[0] = leftBoundary;                      break;                  case SplineBoundaryCondition.SecondDerivative:                      a1[0] = 0;                      a2[0] = 2;                      a3[0] = 1;                      b[0] = (3 * ((xx[1] - xx[0]) / (tt[1] - tt[0]))) - (0.5 * leftBoundary * (tt[1] - tt[0]));                      break;                  default:                      throw new NotSupportedException(Properties.LocalStrings.InvalidLeftBoundaryCondition);              }
Magic Number,MathNet.Numerics.Interpolation.Algorithms,CubicSplineInterpolation,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\CubicSplineInterpolation.cs,Init,The following statement contains a magic number: switch(leftBoundaryCondition)              {                  case SplineBoundaryCondition.ParabolicallyTerminated:                      a1[0] = 0;                      a2[0] = 1;                      a3[0] = 1;                      b[0] = 2 * (xx[1] - xx[0]) / (tt[1] - tt[0]);                      break;                  case SplineBoundaryCondition.FirstDerivative:                      a1[0] = 0;                      a2[0] = 1;                      a3[0] = 0;                      b[0] = leftBoundary;                      break;                  case SplineBoundaryCondition.SecondDerivative:                      a1[0] = 0;                      a2[0] = 2;                      a3[0] = 1;                      b[0] = (3 * ((xx[1] - xx[0]) / (tt[1] - tt[0]))) - (0.5 * leftBoundary * (tt[1] - tt[0]));                      break;                  default:                      throw new NotSupportedException(Properties.LocalStrings.InvalidLeftBoundaryCondition);              }
Magic Number,MathNet.Numerics.Interpolation.Algorithms,CubicSplineInterpolation,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\CubicSplineInterpolation.cs,Init,The following statement contains a magic number: switch(leftBoundaryCondition)              {                  case SplineBoundaryCondition.ParabolicallyTerminated:                      a1[0] = 0;                      a2[0] = 1;                      a3[0] = 1;                      b[0] = 2 * (xx[1] - xx[0]) / (tt[1] - tt[0]);                      break;                  case SplineBoundaryCondition.FirstDerivative:                      a1[0] = 0;                      a2[0] = 1;                      a3[0] = 0;                      b[0] = leftBoundary;                      break;                  case SplineBoundaryCondition.SecondDerivative:                      a1[0] = 0;                      a2[0] = 2;                      a3[0] = 1;                      b[0] = (3 * ((xx[1] - xx[0]) / (tt[1] - tt[0]))) - (0.5 * leftBoundary * (tt[1] - tt[0]));                      break;                  default:                      throw new NotSupportedException(Properties.LocalStrings.InvalidLeftBoundaryCondition);              }
Magic Number,MathNet.Numerics.Interpolation.Algorithms,CubicSplineInterpolation,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\CubicSplineInterpolation.cs,Init,The following statement contains a magic number: a2[i] = 2 * (tt[i + 1] - tt[i - 1]);
Magic Number,MathNet.Numerics.Interpolation.Algorithms,CubicSplineInterpolation,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\CubicSplineInterpolation.cs,Init,The following statement contains a magic number: b[i] = (3 * (xx[i] - xx[i - 1]) / (tt[i] - tt[i - 1]) * (tt[i + 1] - tt[i])) + (3 * (xx[i + 1] - xx[i]) / (tt[i + 1] - tt[i]) * (tt[i] - tt[i - 1]));
Magic Number,MathNet.Numerics.Interpolation.Algorithms,CubicSplineInterpolation,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\CubicSplineInterpolation.cs,Init,The following statement contains a magic number: b[i] = (3 * (xx[i] - xx[i - 1]) / (tt[i] - tt[i - 1]) * (tt[i + 1] - tt[i])) + (3 * (xx[i + 1] - xx[i]) / (tt[i + 1] - tt[i]) * (tt[i] - tt[i - 1]));
Magic Number,MathNet.Numerics.Interpolation.Algorithms,CubicSplineInterpolation,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\CubicSplineInterpolation.cs,Init,The following statement contains a magic number: switch(rightBoundaryCondition)              {                  case SplineBoundaryCondition.ParabolicallyTerminated:                      a1[n - 1] = 1;                      a2[n - 1] = 1;                      a3[n - 1] = 0;                      b[n - 1] = 2 * (xx[n - 1] - xx[n - 2]) / (tt[n - 1] - tt[n - 2]);                      break;                  case SplineBoundaryCondition.FirstDerivative:                      a1[n - 1] = 0;                      a2[n - 1] = 1;                      a3[n - 1] = 0;                      b[n - 1] = rightBoundary;                      break;                  case SplineBoundaryCondition.SecondDerivative:                      a1[n - 1] = 1;                      a2[n - 1] = 2;                      a3[n - 1] = 0;                      b[n - 1] = (3 * (xx[n - 1] - xx[n - 2]) / (tt[n - 1] - tt[n - 2])) + (0.5 * rightBoundary * (tt[n - 1] - tt[n - 2]));                      break;                  default:                      throw new NotSupportedException(Properties.LocalStrings.InvalidRightBoundaryCondition);              }
Magic Number,MathNet.Numerics.Interpolation.Algorithms,CubicSplineInterpolation,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\CubicSplineInterpolation.cs,Init,The following statement contains a magic number: switch(rightBoundaryCondition)              {                  case SplineBoundaryCondition.ParabolicallyTerminated:                      a1[n - 1] = 1;                      a2[n - 1] = 1;                      a3[n - 1] = 0;                      b[n - 1] = 2 * (xx[n - 1] - xx[n - 2]) / (tt[n - 1] - tt[n - 2]);                      break;                  case SplineBoundaryCondition.FirstDerivative:                      a1[n - 1] = 0;                      a2[n - 1] = 1;                      a3[n - 1] = 0;                      b[n - 1] = rightBoundary;                      break;                  case SplineBoundaryCondition.SecondDerivative:                      a1[n - 1] = 1;                      a2[n - 1] = 2;                      a3[n - 1] = 0;                      b[n - 1] = (3 * (xx[n - 1] - xx[n - 2]) / (tt[n - 1] - tt[n - 2])) + (0.5 * rightBoundary * (tt[n - 1] - tt[n - 2]));                      break;                  default:                      throw new NotSupportedException(Properties.LocalStrings.InvalidRightBoundaryCondition);              }
Magic Number,MathNet.Numerics.Interpolation.Algorithms,CubicSplineInterpolation,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\CubicSplineInterpolation.cs,Init,The following statement contains a magic number: switch(rightBoundaryCondition)              {                  case SplineBoundaryCondition.ParabolicallyTerminated:                      a1[n - 1] = 1;                      a2[n - 1] = 1;                      a3[n - 1] = 0;                      b[n - 1] = 2 * (xx[n - 1] - xx[n - 2]) / (tt[n - 1] - tt[n - 2]);                      break;                  case SplineBoundaryCondition.FirstDerivative:                      a1[n - 1] = 0;                      a2[n - 1] = 1;                      a3[n - 1] = 0;                      b[n - 1] = rightBoundary;                      break;                  case SplineBoundaryCondition.SecondDerivative:                      a1[n - 1] = 1;                      a2[n - 1] = 2;                      a3[n - 1] = 0;                      b[n - 1] = (3 * (xx[n - 1] - xx[n - 2]) / (tt[n - 1] - tt[n - 2])) + (0.5 * rightBoundary * (tt[n - 1] - tt[n - 2]));                      break;                  default:                      throw new NotSupportedException(Properties.LocalStrings.InvalidRightBoundaryCondition);              }
Magic Number,MathNet.Numerics.Interpolation.Algorithms,CubicSplineInterpolation,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\CubicSplineInterpolation.cs,Init,The following statement contains a magic number: switch(rightBoundaryCondition)              {                  case SplineBoundaryCondition.ParabolicallyTerminated:                      a1[n - 1] = 1;                      a2[n - 1] = 1;                      a3[n - 1] = 0;                      b[n - 1] = 2 * (xx[n - 1] - xx[n - 2]) / (tt[n - 1] - tt[n - 2]);                      break;                  case SplineBoundaryCondition.FirstDerivative:                      a1[n - 1] = 0;                      a2[n - 1] = 1;                      a3[n - 1] = 0;                      b[n - 1] = rightBoundary;                      break;                  case SplineBoundaryCondition.SecondDerivative:                      a1[n - 1] = 1;                      a2[n - 1] = 2;                      a3[n - 1] = 0;                      b[n - 1] = (3 * (xx[n - 1] - xx[n - 2]) / (tt[n - 1] - tt[n - 2])) + (0.5 * rightBoundary * (tt[n - 1] - tt[n - 2]));                      break;                  default:                      throw new NotSupportedException(Properties.LocalStrings.InvalidRightBoundaryCondition);              }
Magic Number,MathNet.Numerics.Interpolation.Algorithms,CubicSplineInterpolation,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\CubicSplineInterpolation.cs,Init,The following statement contains a magic number: switch(rightBoundaryCondition)              {                  case SplineBoundaryCondition.ParabolicallyTerminated:                      a1[n - 1] = 1;                      a2[n - 1] = 1;                      a3[n - 1] = 0;                      b[n - 1] = 2 * (xx[n - 1] - xx[n - 2]) / (tt[n - 1] - tt[n - 2]);                      break;                  case SplineBoundaryCondition.FirstDerivative:                      a1[n - 1] = 0;                      a2[n - 1] = 1;                      a3[n - 1] = 0;                      b[n - 1] = rightBoundary;                      break;                  case SplineBoundaryCondition.SecondDerivative:                      a1[n - 1] = 1;                      a2[n - 1] = 2;                      a3[n - 1] = 0;                      b[n - 1] = (3 * (xx[n - 1] - xx[n - 2]) / (tt[n - 1] - tt[n - 2])) + (0.5 * rightBoundary * (tt[n - 1] - tt[n - 2]));                      break;                  default:                      throw new NotSupportedException(Properties.LocalStrings.InvalidRightBoundaryCondition);              }
Magic Number,MathNet.Numerics.Interpolation.Algorithms,CubicSplineInterpolation,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\CubicSplineInterpolation.cs,Init,The following statement contains a magic number: switch(rightBoundaryCondition)              {                  case SplineBoundaryCondition.ParabolicallyTerminated:                      a1[n - 1] = 1;                      a2[n - 1] = 1;                      a3[n - 1] = 0;                      b[n - 1] = 2 * (xx[n - 1] - xx[n - 2]) / (tt[n - 1] - tt[n - 2]);                      break;                  case SplineBoundaryCondition.FirstDerivative:                      a1[n - 1] = 0;                      a2[n - 1] = 1;                      a3[n - 1] = 0;                      b[n - 1] = rightBoundary;                      break;                  case SplineBoundaryCondition.SecondDerivative:                      a1[n - 1] = 1;                      a2[n - 1] = 2;                      a3[n - 1] = 0;                      b[n - 1] = (3 * (xx[n - 1] - xx[n - 2]) / (tt[n - 1] - tt[n - 2])) + (0.5 * rightBoundary * (tt[n - 1] - tt[n - 2]));                      break;                  default:                      throw new NotSupportedException(Properties.LocalStrings.InvalidRightBoundaryCondition);              }
Magic Number,MathNet.Numerics.Interpolation.Algorithms,CubicSplineInterpolation,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\CubicSplineInterpolation.cs,Init,The following statement contains a magic number: switch(rightBoundaryCondition)              {                  case SplineBoundaryCondition.ParabolicallyTerminated:                      a1[n - 1] = 1;                      a2[n - 1] = 1;                      a3[n - 1] = 0;                      b[n - 1] = 2 * (xx[n - 1] - xx[n - 2]) / (tt[n - 1] - tt[n - 2]);                      break;                  case SplineBoundaryCondition.FirstDerivative:                      a1[n - 1] = 0;                      a2[n - 1] = 1;                      a3[n - 1] = 0;                      b[n - 1] = rightBoundary;                      break;                  case SplineBoundaryCondition.SecondDerivative:                      a1[n - 1] = 1;                      a2[n - 1] = 2;                      a3[n - 1] = 0;                      b[n - 1] = (3 * (xx[n - 1] - xx[n - 2]) / (tt[n - 1] - tt[n - 2])) + (0.5 * rightBoundary * (tt[n - 1] - tt[n - 2]));                      break;                  default:                      throw new NotSupportedException(Properties.LocalStrings.InvalidRightBoundaryCondition);              }
Magic Number,MathNet.Numerics.Interpolation.Algorithms,CubicSplineInterpolation,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\CubicSplineInterpolation.cs,Init,The following statement contains a magic number: switch(rightBoundaryCondition)              {                  case SplineBoundaryCondition.ParabolicallyTerminated:                      a1[n - 1] = 1;                      a2[n - 1] = 1;                      a3[n - 1] = 0;                      b[n - 1] = 2 * (xx[n - 1] - xx[n - 2]) / (tt[n - 1] - tt[n - 2]);                      break;                  case SplineBoundaryCondition.FirstDerivative:                      a1[n - 1] = 0;                      a2[n - 1] = 1;                      a3[n - 1] = 0;                      b[n - 1] = rightBoundary;                      break;                  case SplineBoundaryCondition.SecondDerivative:                      a1[n - 1] = 1;                      a2[n - 1] = 2;                      a3[n - 1] = 0;                      b[n - 1] = (3 * (xx[n - 1] - xx[n - 2]) / (tt[n - 1] - tt[n - 2])) + (0.5 * rightBoundary * (tt[n - 1] - tt[n - 2]));                      break;                  default:                      throw new NotSupportedException(Properties.LocalStrings.InvalidRightBoundaryCondition);              }
Magic Number,MathNet.Numerics.Interpolation.Algorithms,CubicSplineInterpolation,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\CubicSplineInterpolation.cs,Init,The following statement contains a magic number: switch(rightBoundaryCondition)              {                  case SplineBoundaryCondition.ParabolicallyTerminated:                      a1[n - 1] = 1;                      a2[n - 1] = 1;                      a3[n - 1] = 0;                      b[n - 1] = 2 * (xx[n - 1] - xx[n - 2]) / (tt[n - 1] - tt[n - 2]);                      break;                  case SplineBoundaryCondition.FirstDerivative:                      a1[n - 1] = 0;                      a2[n - 1] = 1;                      a3[n - 1] = 0;                      b[n - 1] = rightBoundary;                      break;                  case SplineBoundaryCondition.SecondDerivative:                      a1[n - 1] = 1;                      a2[n - 1] = 2;                      a3[n - 1] = 0;                      b[n - 1] = (3 * (xx[n - 1] - xx[n - 2]) / (tt[n - 1] - tt[n - 2])) + (0.5 * rightBoundary * (tt[n - 1] - tt[n - 2]));                      break;                  default:                      throw new NotSupportedException(Properties.LocalStrings.InvalidRightBoundaryCondition);              }
Magic Number,MathNet.Numerics.Interpolation.Algorithms,LimitedOrderPolynomialInterpolation,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\LimitedOrderPolynomialInterpolation.cs,Interpolate,The following statement contains a magic number: x += (2 * (ns + 1) < (_effectiveOrder - level) ? c[ns + 1] : d[ns--]);
Magic Number,MathNet.Numerics.Interpolation.Algorithms,LimitedOrderPolynomialInterpolation,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\LimitedOrderPolynomialInterpolation.cs,SuggestOffset,The following statement contains a magic number: int ret = Math.Min(                  Math.Max(                      closestIndex - ((_effectiveOrder - 1) / 2)'                      0)'                  _samples.Count - _effectiveOrder);
Magic Number,MathNet.Numerics.Interpolation.Algorithms,LimitedOrderRationalInterpolation,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\LimitedOrderRationalInterpolation.cs,Interpolate,The following statement contains a magic number: const double Tiny = 1.0e-15;
Magic Number,MathNet.Numerics.Interpolation.Algorithms,LimitedOrderRationalInterpolation,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\LimitedOrderRationalInterpolation.cs,Interpolate,The following statement contains a magic number: x += (2 * (ns + 1) < (_effectiveOrder - level) ? c[ns + 1] : d[ns--]);
Magic Number,MathNet.Numerics.Interpolation.Algorithms,LimitedOrderRationalInterpolation,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\LimitedOrderRationalInterpolation.cs,SuggestOffset,The following statement contains a magic number: int ret = Math.Min(                  Math.Max(                      closestIndex - ((_effectiveOrder - 1) / 2)'                      0)'                  _samples.Count - _effectiveOrder);
Magic Number,MathNet.Numerics.Interpolation.Algorithms,LinearSplineInterpolation,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\LinearSplineInterpolation.cs,Init,The following statement contains a magic number: t.Count < 2
Magic Number,MathNet.Numerics.Interpolation.Algorithms,LinearSplineInterpolation,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\LinearSplineInterpolation.cs,Init,The following statement contains a magic number: double[] c = new double[4 * (t.Count - 1)];
Magic Number,MathNet.Numerics.Interpolation.Algorithms,LinearSplineInterpolation,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\LinearSplineInterpolation.cs,Init,The following statement contains a magic number: c[j + 2] = 0;
Magic Number,MathNet.Numerics.Interpolation.Algorithms,LinearSplineInterpolation,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\LinearSplineInterpolation.cs,Init,The following statement contains a magic number: c[j + 3] = 0;
Magic Number,MathNet.Numerics.Interpolation.Algorithms,PolynomialInterpolation,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\PolynomialInterpolation.cs,Differentiate,The following statement contains a magic number: d2x[i] = ((hp * d2x[i]) + (ho * d2x[i + 1]) + (2 * dx[i]) - (2 * dx[i + 1])) / den;
Magic Number,MathNet.Numerics.Interpolation.Algorithms,PolynomialInterpolation,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\PolynomialInterpolation.cs,Differentiate,The following statement contains a magic number: d2x[i] = ((hp * d2x[i]) + (ho * d2x[i + 1]) + (2 * dx[i]) - (2 * dx[i + 1])) / den;
Magic Number,MathNet.Numerics.Interpolation.Algorithms,RationalPoleFreeInterpolation,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\RationalPoleFreeInterpolation.cs,Init,The following statement contains a magic number: Init(t' x' Math.Min(3' t.Count - 1));
Magic Number,MathNet.Numerics.Interpolation.Algorithms,RationalInterpolation,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\RationalInterpolation.cs,Interpolate,The following statement contains a magic number: const double Tiny = 1.0e-25;
Magic Number,MathNet.Numerics.Interpolation.Algorithms,RationalInterpolation,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\RationalInterpolation.cs,Interpolate,The following statement contains a magic number: x += (2 * nearestIndex) < (n - level)                      ? c[nearestIndex]                      : d[--nearestIndex];
Magic Number,MathNet.Numerics.Interpolation.Algorithms,SplineInterpolation,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\SplineInterpolation.cs,Init,The following statement contains a magic number: c.Count != 4 * (t.Count - 1)
Magic Number,MathNet.Numerics.Interpolation.Algorithms,SplineInterpolation,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\SplineInterpolation.cs,Interpolate,The following statement contains a magic number: int middle = (low + high) / 2;
Magic Number,MathNet.Numerics.Interpolation.Algorithms,SplineInterpolation,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\SplineInterpolation.cs,Interpolate,The following statement contains a magic number: int k = low << 2;
Magic Number,MathNet.Numerics.Interpolation.Algorithms,SplineInterpolation,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\SplineInterpolation.cs,Interpolate,The following statement contains a magic number: return _c[k] + (t * (_c[k + 1] + (t * (_c[k + 2] + (t * _c[k + 3])))));
Magic Number,MathNet.Numerics.Interpolation.Algorithms,SplineInterpolation,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\SplineInterpolation.cs,Interpolate,The following statement contains a magic number: return _c[k] + (t * (_c[k + 1] + (t * (_c[k + 2] + (t * _c[k + 3])))));
Magic Number,MathNet.Numerics.Interpolation.Algorithms,SplineInterpolation,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\SplineInterpolation.cs,Differentiate,The following statement contains a magic number: int middle = (low + high) / 2;
Magic Number,MathNet.Numerics.Interpolation.Algorithms,SplineInterpolation,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\SplineInterpolation.cs,Differentiate,The following statement contains a magic number: int k = low << 2;
Magic Number,MathNet.Numerics.Interpolation.Algorithms,SplineInterpolation,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\SplineInterpolation.cs,Differentiate,The following statement contains a magic number: first = _c[k + 1] + (2 * t * _c[k + 2]) + (3 * t * t * _c[k + 3]);
Magic Number,MathNet.Numerics.Interpolation.Algorithms,SplineInterpolation,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\SplineInterpolation.cs,Differentiate,The following statement contains a magic number: first = _c[k + 1] + (2 * t * _c[k + 2]) + (3 * t * t * _c[k + 3]);
Magic Number,MathNet.Numerics.Interpolation.Algorithms,SplineInterpolation,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\SplineInterpolation.cs,Differentiate,The following statement contains a magic number: first = _c[k + 1] + (2 * t * _c[k + 2]) + (3 * t * t * _c[k + 3]);
Magic Number,MathNet.Numerics.Interpolation.Algorithms,SplineInterpolation,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\SplineInterpolation.cs,Differentiate,The following statement contains a magic number: first = _c[k + 1] + (2 * t * _c[k + 2]) + (3 * t * t * _c[k + 3]);
Magic Number,MathNet.Numerics.Interpolation.Algorithms,SplineInterpolation,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\SplineInterpolation.cs,Differentiate,The following statement contains a magic number: second = (2 * _c[k + 2]) + (6 * t * _c[k + 3]);
Magic Number,MathNet.Numerics.Interpolation.Algorithms,SplineInterpolation,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\SplineInterpolation.cs,Differentiate,The following statement contains a magic number: second = (2 * _c[k + 2]) + (6 * t * _c[k + 3]);
Magic Number,MathNet.Numerics.Interpolation.Algorithms,SplineInterpolation,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\SplineInterpolation.cs,Differentiate,The following statement contains a magic number: second = (2 * _c[k + 2]) + (6 * t * _c[k + 3]);
Magic Number,MathNet.Numerics.Interpolation.Algorithms,SplineInterpolation,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\SplineInterpolation.cs,Differentiate,The following statement contains a magic number: second = (2 * _c[k + 2]) + (6 * t * _c[k + 3]);
Magic Number,MathNet.Numerics.Interpolation.Algorithms,SplineInterpolation,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\SplineInterpolation.cs,Differentiate,The following statement contains a magic number: return _c[k] + (t * (_c[k + 1] + (t * (_c[k + 2] + (t * _c[k + 3])))));
Magic Number,MathNet.Numerics.Interpolation.Algorithms,SplineInterpolation,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\SplineInterpolation.cs,Differentiate,The following statement contains a magic number: return _c[k] + (t * (_c[k + 1] + (t * (_c[k + 2] + (t * _c[k + 3])))));
Magic Number,MathNet.Numerics.Interpolation.Algorithms,SplineInterpolation,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\SplineInterpolation.cs,Integrate,The following statement contains a magic number: int middle = (low + high) / 2;
Magic Number,MathNet.Numerics.Interpolation.Algorithms,SplineInterpolation,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\SplineInterpolation.cs,Integrate,The following statement contains a magic number: result += w * (_c[j] + ((w * (_c[j + 1] * 0.5)) + (w * ((_c[j + 2] / 3) + (w * _c[j + 3] * 0.25)))));
Magic Number,MathNet.Numerics.Interpolation.Algorithms,SplineInterpolation,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\SplineInterpolation.cs,Integrate,The following statement contains a magic number: result += w * (_c[j] + ((w * (_c[j + 1] * 0.5)) + (w * ((_c[j + 2] / 3) + (w * _c[j + 3] * 0.25)))));
Magic Number,MathNet.Numerics.Interpolation.Algorithms,SplineInterpolation,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\SplineInterpolation.cs,Integrate,The following statement contains a magic number: result += w * (_c[j] + ((w * (_c[j + 1] * 0.5)) + (w * ((_c[j + 2] / 3) + (w * _c[j + 3] * 0.25)))));
Magic Number,MathNet.Numerics.Interpolation.Algorithms,SplineInterpolation,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\SplineInterpolation.cs,Integrate,The following statement contains a magic number: result += w * (_c[j] + ((w * (_c[j + 1] * 0.5)) + (w * ((_c[j + 2] / 3) + (w * _c[j + 3] * 0.25)))));
Magic Number,MathNet.Numerics.Interpolation.Algorithms,SplineInterpolation,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\SplineInterpolation.cs,Integrate,The following statement contains a magic number: result += w * (_c[j] + ((w * (_c[j + 1] * 0.5)) + (w * ((_c[j + 2] / 3) + (w * _c[j + 3] * 0.25)))));
Magic Number,MathNet.Numerics.Interpolation.Algorithms,SplineInterpolation,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\SplineInterpolation.cs,Integrate,The following statement contains a magic number: int k = low << 2;
Magic Number,MathNet.Numerics.Interpolation.Algorithms,SplineInterpolation,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\SplineInterpolation.cs,Integrate,The following statement contains a magic number: return result + (t * (_c[k] + ((t * (_c[k + 1] * 0.5)) + (t * (_c[k + 2] / 3)) + (t * _c[k + 3] * 0.25))));
Magic Number,MathNet.Numerics.Interpolation.Algorithms,SplineInterpolation,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\SplineInterpolation.cs,Integrate,The following statement contains a magic number: return result + (t * (_c[k] + ((t * (_c[k + 1] * 0.5)) + (t * (_c[k + 2] / 3)) + (t * _c[k + 3] * 0.25))));
Magic Number,MathNet.Numerics.Interpolation.Algorithms,SplineInterpolation,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\SplineInterpolation.cs,Integrate,The following statement contains a magic number: return result + (t * (_c[k] + ((t * (_c[k + 1] * 0.5)) + (t * (_c[k + 2] / 3)) + (t * _c[k + 3] * 0.25))));
Magic Number,MathNet.Numerics.Interpolation.Algorithms,SplineInterpolation,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\SplineInterpolation.cs,Integrate,The following statement contains a magic number: return result + (t * (_c[k] + ((t * (_c[k + 1] * 0.5)) + (t * (_c[k + 2] / 3)) + (t * _c[k + 3] * 0.25))));
Magic Number,MathNet.Numerics.Interpolation.Algorithms,SplineInterpolation,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\SplineInterpolation.cs,Integrate,The following statement contains a magic number: return result + (t * (_c[k] + ((t * (_c[k + 1] * 0.5)) + (t * (_c[k + 2] / 3)) + (t * _c[k + 3] * 0.25))));
Magic Number,MathNet.Numerics.Interpolation,PolynomialInterpolationAlgorithm,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\PolynomialInterpolationAlgorithm.cs,Interpolate,The following statement contains a magic number: error = (2 * (ns + 1) < (_effectiveOrder - level) ? c[ns + 1] : d[ns--]);
Magic Number,MathNet.Numerics.Interpolation,PolynomialInterpolationAlgorithm,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\PolynomialInterpolationAlgorithm.cs,SuggestOffset,The following statement contains a magic number: int ret = Math.Min(                  Math.Max(                      closestIndex - ((_effectiveOrder - 1) / 2)'                      0)'                  _samples.Count - _effectiveOrder);
Magic Number,MathNet.Numerics.Interpolation,RationalInterpolationAlgorithm,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\RationalInterpolationAlgorithm.cs,Interpolate,The following statement contains a magic number: const double Tiny = 1.0e-15;
Magic Number,MathNet.Numerics.Interpolation,RationalInterpolationAlgorithm,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\RationalInterpolationAlgorithm.cs,Interpolate,The following statement contains a magic number: error = (2 * (ns + 1) < (_effectiveOrder - level) ? c[ns + 1] : d[ns--]);
Magic Number,MathNet.Numerics.Interpolation,RationalInterpolationAlgorithm,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\RationalInterpolationAlgorithm.cs,SuggestOffset,The following statement contains a magic number: int ret = Math.Min(                  Math.Max(                      closestIndex - ((_effectiveOrder - 1) / 2)'                      0)'                  _samples.Count - _effectiveOrder);
Magic Number,MathNet.Numerics.LinearAlgebra.Algorithms,Orthogonal,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\LinearAlgebra\Algorithms\Orthogonal.cs,Rotation,The following statement contains a magic number: double[][] m = Matrix.CreateMatrixData(2' 2);
Magic Number,MathNet.Numerics.LinearAlgebra.Algorithms,Orthogonal,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\LinearAlgebra\Algorithms\Orthogonal.cs,Rotation,The following statement contains a magic number: double[][] m = Matrix.CreateMatrixData(2' 2);
Magic Number,MathNet.Numerics.LinearAlgebra.Algorithms,Orthogonal,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\LinearAlgebra\Algorithms\Orthogonal.cs,Rotation,The following statement contains a magic number: Complex[][] m = ComplexMatrix.CreateMatrixData(2' 2);
Magic Number,MathNet.Numerics.LinearAlgebra.Algorithms,Orthogonal,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\LinearAlgebra\Algorithms\Orthogonal.cs,Rotation,The following statement contains a magic number: Complex[][] m = ComplexMatrix.CreateMatrixData(2' 2);
Magic Number,MathNet.Numerics.LinearAlgebra.Algorithms,Orthogonal,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\LinearAlgebra\Algorithms\Orthogonal.cs,Reflection,The following statement contains a magic number: m.MultiplyAccumulateInplace(u.TensorMultiply(u)' -2d / u.ScalarMultiply(u));
Magic Number,MathNet.Numerics.LinearAlgebra.Algorithms,Orthogonal,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\LinearAlgebra\Algorithms\Orthogonal.cs,Reflection,The following statement contains a magic number: m.MultiplyAccumulateInplace(u.TensorMultiply(u)' -2d / u.ScalarMultiply(u));
Magic Number,MathNet.Numerics.LinearAlgebra,ComplexMatrix,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\LinearAlgebra\ComplexMatrix.cs,GetHashCode,The following statement contains a magic number: result = (result * 397) ^ _columnCount;
Magic Number,MathNet.Numerics.LinearAlgebra,ComplexMatrix,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\LinearAlgebra\ComplexMatrix.cs,GetHashCode,The following statement contains a magic number: result = (result * 397) ^ _data.GetHashCode();
Magic Number,MathNet.Numerics.LinearAlgebra,ComplexVector,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\LinearAlgebra\ComplexVector.cs,CrossProduct,The following statement contains a magic number: 3 != u.Length
Magic Number,MathNet.Numerics.LinearAlgebra,ComplexVector,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\LinearAlgebra\ComplexVector.cs,CrossProduct,The following statement contains a magic number: ComplexVector product = new ComplexVector(new Complex[] {                  (u[1] * v[2]) - (u[2] * v[1])'                  (u[2] * v[0]) - (u[0] * v[2])'                  (u[0] * v[1]) - (u[1] * v[0])                  });
Magic Number,MathNet.Numerics.LinearAlgebra,ComplexVector,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\LinearAlgebra\ComplexVector.cs,CrossProduct,The following statement contains a magic number: ComplexVector product = new ComplexVector(new Complex[] {                  (u[1] * v[2]) - (u[2] * v[1])'                  (u[2] * v[0]) - (u[0] * v[2])'                  (u[0] * v[1]) - (u[1] * v[0])                  });
Magic Number,MathNet.Numerics.LinearAlgebra,ComplexVector,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\LinearAlgebra\ComplexVector.cs,CrossProduct,The following statement contains a magic number: ComplexVector product = new ComplexVector(new Complex[] {                  (u[1] * v[2]) - (u[2] * v[1])'                  (u[2] * v[0]) - (u[0] * v[2])'                  (u[0] * v[1]) - (u[1] * v[0])                  });
Magic Number,MathNet.Numerics.LinearAlgebra,ComplexVector,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\LinearAlgebra\ComplexVector.cs,CrossProduct,The following statement contains a magic number: ComplexVector product = new ComplexVector(new Complex[] {                  (u[1] * v[2]) - (u[2] * v[1])'                  (u[2] * v[0]) - (u[0] * v[2])'                  (u[0] * v[1]) - (u[1] * v[0])                  });
Magic Number,MathNet.Numerics.LinearAlgebra,ComplexVector,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\LinearAlgebra\ComplexVector.cs,GetHashCode,The following statement contains a magic number: return (_data.GetHashCode() * 397) ^ _length;
Magic Number,MathNet.Numerics.LinearAlgebra,Vector,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\LinearAlgebra\Vector.cs,CrossProduct,The following statement contains a magic number: 3 != u.Length
Magic Number,MathNet.Numerics.LinearAlgebra,Vector,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\LinearAlgebra\Vector.cs,CrossProduct,The following statement contains a magic number: Vector product = new Vector(new double[] {                  (u[1] * v[2]) - (u[2] * v[1])'                  (u[2] * v[0]) - (u[0] * v[2])'                  (u[0] * v[1]) - (u[1] * v[0])                  });
Magic Number,MathNet.Numerics.LinearAlgebra,Vector,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\LinearAlgebra\Vector.cs,CrossProduct,The following statement contains a magic number: Vector product = new Vector(new double[] {                  (u[1] * v[2]) - (u[2] * v[1])'                  (u[2] * v[0]) - (u[0] * v[2])'                  (u[0] * v[1]) - (u[1] * v[0])                  });
Magic Number,MathNet.Numerics.LinearAlgebra,Vector,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\LinearAlgebra\Vector.cs,CrossProduct,The following statement contains a magic number: Vector product = new Vector(new double[] {                  (u[1] * v[2]) - (u[2] * v[1])'                  (u[2] * v[0]) - (u[0] * v[2])'                  (u[0] * v[1]) - (u[1] * v[0])                  });
Magic Number,MathNet.Numerics.LinearAlgebra,Vector,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\LinearAlgebra\Vector.cs,CrossProduct,The following statement contains a magic number: Vector product = new Vector(new double[] {                  (u[1] * v[2]) - (u[2] * v[1])'                  (u[2] * v[0]) - (u[0] * v[2])'                  (u[0] * v[1]) - (u[1] * v[0])                  });
Magic Number,MathNet.Numerics.LinearAlgebra,Vector,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\LinearAlgebra\Vector.cs,NormP,The following statement contains a magic number: 2 == p
Magic Number,MathNet.Numerics.LinearAlgebra,Vector,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\LinearAlgebra\Vector.cs,GetHashCode,The following statement contains a magic number: return (_data.GetHashCode() * 397) ^ _length;
Magic Number,MathNet.Numerics.LinearAlgebra,EigenvalueDecomposition,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\LinearAlgebra\EigenvalueDecomposition.cs,SymmetricDiagonalize,The following statement contains a magic number: double p = (_d[l + 1] - g) / (2.0 * _e[l]);
Magic Number,MathNet.Numerics.LinearAlgebra,Matrix,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\LinearAlgebra\Matrix.cs,SolveRobust,The following statement contains a magic number: const double Eta = 1.0e-12;
Magic Number,MathNet.Numerics.LinearAlgebra,Matrix,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\LinearAlgebra\Matrix.cs,SolveRobust,The following statement contains a magic number: const double Epsilon = 1.0e-6;
Magic Number,MathNet.Numerics.LinearAlgebra,Matrix,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\LinearAlgebra\Matrix.cs,SolveRobust,The following statement contains a magic number: const int MaxIteration = 100;
Magic Number,MathNet.Numerics.LinearAlgebra,Matrix,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\LinearAlgebra\Matrix.cs,GetHashCode,The following statement contains a magic number: result = (result * 397) ^ _columnCount;
Magic Number,MathNet.Numerics.LinearAlgebra,Matrix,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\LinearAlgebra\Matrix.cs,GetHashCode,The following statement contains a magic number: result = (result * 397) ^ _data.GetHashCode();
Magic Number,MathNet.Numerics.LinearAlgebra,SingularValueDecomposition,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\LinearAlgebra\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: int nrt = Math.Max(0' Math.Min(_n - 2' _m));
Magic Number,MathNet.Numerics.LinearAlgebra,SingularValueDecomposition,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\LinearAlgebra\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: k == p - 2
Magic Number,MathNet.Numerics.LinearAlgebra,SingularValueDecomposition,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\LinearAlgebra\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: switch(step)                  {                      // Deflate negligible s(p).                      case IterationStep.DeflateNeglible:                          {                              double f = e[p - 2];                              e[p - 2] = 0.0;                              for(int j = p - 2; j >= k; j--)                              {                                  double t = Fn.Hypot(s[j]' f);                                  double cs = s[j] / t;                                  double sn = f / t;                                  s[j] = t;                                    if(j != k)                                  {                                      f = (-sn) * e[j - 1];                                      e[j - 1] = cs * e[j - 1];                                  }                                    for(int i = 0; i < _n; i++)                                  {                                      t = (cs * v[i][j]) + (sn * v[i][p - 1]);                                      v[i][p - 1] = ((-sn) * v[i][j]) + (cs * v[i][p - 1]);                                      v[i][j] = t;                                  }                              }                          }                            break;                        // Split at negligible s(k)                      case IterationStep.SplitAtNeglible:                          {                              double f = e[k - 1];                              e[k - 1] = 0.0;                              for(int j = k; j < p; j++)                              {                                  double t = Fn.Hypot(s[j]' f);                                  double cs = s[j] / t;                                  double sn = f / t;                                  s[j] = t;                                  f = (-sn) * e[j];                                  e[j] = cs * e[j];                                    for(int i = 0; i < _m; i++)                                  {                                      t = (cs * u[i][j]) + (sn * u[i][k - 1]);                                      u[i][k - 1] = ((-sn) * u[i][j]) + (cs * u[i][k - 1]);                                      u[i][j] = t;                                  }                              }                          }                            break;                        // Perform one qr step.                      case IterationStep.QR:                          {                              /* Calculate the shift */                                double scale = Math.Max(Math.Max(Math.Max(Math.Max(Math.Abs(s[p - 1])' Math.Abs(s[p - 2]))' Math.Abs(e[p - 2]))' Math.Abs(s[k]))' Math.Abs(e[k]));                              double sp = s[p - 1] / scale;                              double spm1 = s[p - 2] / scale;                              double epm1 = e[p - 2] / scale;                              double sk = s[k] / scale;                              double ek = e[k] / scale;                              double b = (((spm1 + sp) * (spm1 - sp)) + (epm1 * epm1)) / 2.0;                              double c = (sp * epm1) * (sp * epm1);                              double shift = 0.0;                              if((b != 0.0) | (c != 0.0))                              {                                  shift = Math.Sqrt((b * b) + c);                                    if(b < 0.0)                                  {                                      shift = -shift;                                  }                                    shift = c / (b + shift);                              }                                double f = ((sk + sp) * (sk - sp)) + shift;                              double g = sk * ek;                                /* Chase zeros */                                for(int j = k; j < p - 1; j++)                              {                                  double t = Fn.Hypot(f' g);                                  double cs = f / t;                                  double sn = g / t;                                    if(j != k)                                  {                                      e[j - 1] = t;                                  }                                    f = (cs * s[j]) + (sn * e[j]);                                  e[j] = (cs * e[j]) - (sn * s[j]);                                  g = sn * s[j + 1];                                  s[j + 1] = cs * s[j + 1];                                    for(int i = 0; i < _n; i++)                                  {                                      t = (cs * v[i][j]) + (sn * v[i][j + 1]);                                      v[i][j + 1] = ((-sn) * v[i][j]) + (cs * v[i][j + 1]);                                      v[i][j] = t;                                  }                                    t = Fn.Hypot(f' g);                                  cs = f / t;                                  sn = g / t;                                  s[j] = t;                                  f = (cs * e[j]) + (sn * s[j + 1]);                                  s[j + 1] = ((-sn) * e[j]) + (cs * s[j + 1]);                                  g = sn * e[j + 1];                                  e[j + 1] = cs * e[j + 1];                                    if(j < _m - 1)                                  {                                      for(int i = 0; i < _m; i++)                                      {                                          t = (cs * u[i][j]) + (sn * u[i][j + 1]);                                          u[i][j + 1] = ((-sn) * u[i][j]) + (cs * u[i][j + 1]);                                          u[i][j] = t;                                      }                                  }                              }                                e[p - 2] = f;                              iter = iter + 1;                          }                            break;                        // Convergence.                      case IterationStep.Convergence:                          {                              /* Make the singular values positive */                                if(s[k] <= 0.0)                              {                                  s[k] = (s[k] < 0.0 ? -s[k] : 0.0);                                    for(int i = 0; i <= pp; i++)                                  {                                      v[i][k] = -v[i][k];                                  }                              }                                /* Order the singular values */                                while(k < pp)                              {                                  if(s[k] >= s[k + 1])                                  {                                      break;                                  }                                    double t = s[k];                                  s[k] = s[k + 1];                                  s[k + 1] = t;                                    if(k < _n - 1)                                  {                                      for(int i = 0; i < _n; i++)                                      {                                          t = v[i][k + 1];                                          v[i][k + 1] = v[i][k];                                          v[i][k] = t;                                      }                                  }                                    if(k < _m - 1)                                  {                                      for(int i = 0; i < _m; i++)                                      {                                          t = u[i][k + 1];                                          u[i][k + 1] = u[i][k];                                          u[i][k] = t;                                      }                                  }                                    k++;                              }                                iter = 0;                              p--;                          }                            break;                  }
Magic Number,MathNet.Numerics.LinearAlgebra,SingularValueDecomposition,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\LinearAlgebra\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: switch(step)                  {                      // Deflate negligible s(p).                      case IterationStep.DeflateNeglible:                          {                              double f = e[p - 2];                              e[p - 2] = 0.0;                              for(int j = p - 2; j >= k; j--)                              {                                  double t = Fn.Hypot(s[j]' f);                                  double cs = s[j] / t;                                  double sn = f / t;                                  s[j] = t;                                    if(j != k)                                  {                                      f = (-sn) * e[j - 1];                                      e[j - 1] = cs * e[j - 1];                                  }                                    for(int i = 0; i < _n; i++)                                  {                                      t = (cs * v[i][j]) + (sn * v[i][p - 1]);                                      v[i][p - 1] = ((-sn) * v[i][j]) + (cs * v[i][p - 1]);                                      v[i][j] = t;                                  }                              }                          }                            break;                        // Split at negligible s(k)                      case IterationStep.SplitAtNeglible:                          {                              double f = e[k - 1];                              e[k - 1] = 0.0;                              for(int j = k; j < p; j++)                              {                                  double t = Fn.Hypot(s[j]' f);                                  double cs = s[j] / t;                                  double sn = f / t;                                  s[j] = t;                                  f = (-sn) * e[j];                                  e[j] = cs * e[j];                                    for(int i = 0; i < _m; i++)                                  {                                      t = (cs * u[i][j]) + (sn * u[i][k - 1]);                                      u[i][k - 1] = ((-sn) * u[i][j]) + (cs * u[i][k - 1]);                                      u[i][j] = t;                                  }                              }                          }                            break;                        // Perform one qr step.                      case IterationStep.QR:                          {                              /* Calculate the shift */                                double scale = Math.Max(Math.Max(Math.Max(Math.Max(Math.Abs(s[p - 1])' Math.Abs(s[p - 2]))' Math.Abs(e[p - 2]))' Math.Abs(s[k]))' Math.Abs(e[k]));                              double sp = s[p - 1] / scale;                              double spm1 = s[p - 2] / scale;                              double epm1 = e[p - 2] / scale;                              double sk = s[k] / scale;                              double ek = e[k] / scale;                              double b = (((spm1 + sp) * (spm1 - sp)) + (epm1 * epm1)) / 2.0;                              double c = (sp * epm1) * (sp * epm1);                              double shift = 0.0;                              if((b != 0.0) | (c != 0.0))                              {                                  shift = Math.Sqrt((b * b) + c);                                    if(b < 0.0)                                  {                                      shift = -shift;                                  }                                    shift = c / (b + shift);                              }                                double f = ((sk + sp) * (sk - sp)) + shift;                              double g = sk * ek;                                /* Chase zeros */                                for(int j = k; j < p - 1; j++)                              {                                  double t = Fn.Hypot(f' g);                                  double cs = f / t;                                  double sn = g / t;                                    if(j != k)                                  {                                      e[j - 1] = t;                                  }                                    f = (cs * s[j]) + (sn * e[j]);                                  e[j] = (cs * e[j]) - (sn * s[j]);                                  g = sn * s[j + 1];                                  s[j + 1] = cs * s[j + 1];                                    for(int i = 0; i < _n; i++)                                  {                                      t = (cs * v[i][j]) + (sn * v[i][j + 1]);                                      v[i][j + 1] = ((-sn) * v[i][j]) + (cs * v[i][j + 1]);                                      v[i][j] = t;                                  }                                    t = Fn.Hypot(f' g);                                  cs = f / t;                                  sn = g / t;                                  s[j] = t;                                  f = (cs * e[j]) + (sn * s[j + 1]);                                  s[j + 1] = ((-sn) * e[j]) + (cs * s[j + 1]);                                  g = sn * e[j + 1];                                  e[j + 1] = cs * e[j + 1];                                    if(j < _m - 1)                                  {                                      for(int i = 0; i < _m; i++)                                      {                                          t = (cs * u[i][j]) + (sn * u[i][j + 1]);                                          u[i][j + 1] = ((-sn) * u[i][j]) + (cs * u[i][j + 1]);                                          u[i][j] = t;                                      }                                  }                              }                                e[p - 2] = f;                              iter = iter + 1;                          }                            break;                        // Convergence.                      case IterationStep.Convergence:                          {                              /* Make the singular values positive */                                if(s[k] <= 0.0)                              {                                  s[k] = (s[k] < 0.0 ? -s[k] : 0.0);                                    for(int i = 0; i <= pp; i++)                                  {                                      v[i][k] = -v[i][k];                                  }                              }                                /* Order the singular values */                                while(k < pp)                              {                                  if(s[k] >= s[k + 1])                                  {                                      break;                                  }                                    double t = s[k];                                  s[k] = s[k + 1];                                  s[k + 1] = t;                                    if(k < _n - 1)                                  {                                      for(int i = 0; i < _n; i++)                                      {                                          t = v[i][k + 1];                                          v[i][k + 1] = v[i][k];                                          v[i][k] = t;                                      }                                  }                                    if(k < _m - 1)                                  {                                      for(int i = 0; i < _m; i++)                                      {                                          t = u[i][k + 1];                                          u[i][k + 1] = u[i][k];                                          u[i][k] = t;                                      }                                  }                                    k++;                              }                                iter = 0;                              p--;                          }                            break;                  }
Magic Number,MathNet.Numerics.LinearAlgebra,SingularValueDecomposition,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\LinearAlgebra\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: switch(step)                  {                      // Deflate negligible s(p).                      case IterationStep.DeflateNeglible:                          {                              double f = e[p - 2];                              e[p - 2] = 0.0;                              for(int j = p - 2; j >= k; j--)                              {                                  double t = Fn.Hypot(s[j]' f);                                  double cs = s[j] / t;                                  double sn = f / t;                                  s[j] = t;                                    if(j != k)                                  {                                      f = (-sn) * e[j - 1];                                      e[j - 1] = cs * e[j - 1];                                  }                                    for(int i = 0; i < _n; i++)                                  {                                      t = (cs * v[i][j]) + (sn * v[i][p - 1]);                                      v[i][p - 1] = ((-sn) * v[i][j]) + (cs * v[i][p - 1]);                                      v[i][j] = t;                                  }                              }                          }                            break;                        // Split at negligible s(k)                      case IterationStep.SplitAtNeglible:                          {                              double f = e[k - 1];                              e[k - 1] = 0.0;                              for(int j = k; j < p; j++)                              {                                  double t = Fn.Hypot(s[j]' f);                                  double cs = s[j] / t;                                  double sn = f / t;                                  s[j] = t;                                  f = (-sn) * e[j];                                  e[j] = cs * e[j];                                    for(int i = 0; i < _m; i++)                                  {                                      t = (cs * u[i][j]) + (sn * u[i][k - 1]);                                      u[i][k - 1] = ((-sn) * u[i][j]) + (cs * u[i][k - 1]);                                      u[i][j] = t;                                  }                              }                          }                            break;                        // Perform one qr step.                      case IterationStep.QR:                          {                              /* Calculate the shift */                                double scale = Math.Max(Math.Max(Math.Max(Math.Max(Math.Abs(s[p - 1])' Math.Abs(s[p - 2]))' Math.Abs(e[p - 2]))' Math.Abs(s[k]))' Math.Abs(e[k]));                              double sp = s[p - 1] / scale;                              double spm1 = s[p - 2] / scale;                              double epm1 = e[p - 2] / scale;                              double sk = s[k] / scale;                              double ek = e[k] / scale;                              double b = (((spm1 + sp) * (spm1 - sp)) + (epm1 * epm1)) / 2.0;                              double c = (sp * epm1) * (sp * epm1);                              double shift = 0.0;                              if((b != 0.0) | (c != 0.0))                              {                                  shift = Math.Sqrt((b * b) + c);                                    if(b < 0.0)                                  {                                      shift = -shift;                                  }                                    shift = c / (b + shift);                              }                                double f = ((sk + sp) * (sk - sp)) + shift;                              double g = sk * ek;                                /* Chase zeros */                                for(int j = k; j < p - 1; j++)                              {                                  double t = Fn.Hypot(f' g);                                  double cs = f / t;                                  double sn = g / t;                                    if(j != k)                                  {                                      e[j - 1] = t;                                  }                                    f = (cs * s[j]) + (sn * e[j]);                                  e[j] = (cs * e[j]) - (sn * s[j]);                                  g = sn * s[j + 1];                                  s[j + 1] = cs * s[j + 1];                                    for(int i = 0; i < _n; i++)                                  {                                      t = (cs * v[i][j]) + (sn * v[i][j + 1]);                                      v[i][j + 1] = ((-sn) * v[i][j]) + (cs * v[i][j + 1]);                                      v[i][j] = t;                                  }                                    t = Fn.Hypot(f' g);                                  cs = f / t;                                  sn = g / t;                                  s[j] = t;                                  f = (cs * e[j]) + (sn * s[j + 1]);                                  s[j + 1] = ((-sn) * e[j]) + (cs * s[j + 1]);                                  g = sn * e[j + 1];                                  e[j + 1] = cs * e[j + 1];                                    if(j < _m - 1)                                  {                                      for(int i = 0; i < _m; i++)                                      {                                          t = (cs * u[i][j]) + (sn * u[i][j + 1]);                                          u[i][j + 1] = ((-sn) * u[i][j]) + (cs * u[i][j + 1]);                                          u[i][j] = t;                                      }                                  }                              }                                e[p - 2] = f;                              iter = iter + 1;                          }                            break;                        // Convergence.                      case IterationStep.Convergence:                          {                              /* Make the singular values positive */                                if(s[k] <= 0.0)                              {                                  s[k] = (s[k] < 0.0 ? -s[k] : 0.0);                                    for(int i = 0; i <= pp; i++)                                  {                                      v[i][k] = -v[i][k];                                  }                              }                                /* Order the singular values */                                while(k < pp)                              {                                  if(s[k] >= s[k + 1])                                  {                                      break;                                  }                                    double t = s[k];                                  s[k] = s[k + 1];                                  s[k + 1] = t;                                    if(k < _n - 1)                                  {                                      for(int i = 0; i < _n; i++)                                      {                                          t = v[i][k + 1];                                          v[i][k + 1] = v[i][k];                                          v[i][k] = t;                                      }                                  }                                    if(k < _m - 1)                                  {                                      for(int i = 0; i < _m; i++)                                      {                                          t = u[i][k + 1];                                          u[i][k + 1] = u[i][k];                                          u[i][k] = t;                                      }                                  }                                    k++;                              }                                iter = 0;                              p--;                          }                            break;                  }
Magic Number,MathNet.Numerics.LinearAlgebra,SingularValueDecomposition,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\LinearAlgebra\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: switch(step)                  {                      // Deflate negligible s(p).                      case IterationStep.DeflateNeglible:                          {                              double f = e[p - 2];                              e[p - 2] = 0.0;                              for(int j = p - 2; j >= k; j--)                              {                                  double t = Fn.Hypot(s[j]' f);                                  double cs = s[j] / t;                                  double sn = f / t;                                  s[j] = t;                                    if(j != k)                                  {                                      f = (-sn) * e[j - 1];                                      e[j - 1] = cs * e[j - 1];                                  }                                    for(int i = 0; i < _n; i++)                                  {                                      t = (cs * v[i][j]) + (sn * v[i][p - 1]);                                      v[i][p - 1] = ((-sn) * v[i][j]) + (cs * v[i][p - 1]);                                      v[i][j] = t;                                  }                              }                          }                            break;                        // Split at negligible s(k)                      case IterationStep.SplitAtNeglible:                          {                              double f = e[k - 1];                              e[k - 1] = 0.0;                              for(int j = k; j < p; j++)                              {                                  double t = Fn.Hypot(s[j]' f);                                  double cs = s[j] / t;                                  double sn = f / t;                                  s[j] = t;                                  f = (-sn) * e[j];                                  e[j] = cs * e[j];                                    for(int i = 0; i < _m; i++)                                  {                                      t = (cs * u[i][j]) + (sn * u[i][k - 1]);                                      u[i][k - 1] = ((-sn) * u[i][j]) + (cs * u[i][k - 1]);                                      u[i][j] = t;                                  }                              }                          }                            break;                        // Perform one qr step.                      case IterationStep.QR:                          {                              /* Calculate the shift */                                double scale = Math.Max(Math.Max(Math.Max(Math.Max(Math.Abs(s[p - 1])' Math.Abs(s[p - 2]))' Math.Abs(e[p - 2]))' Math.Abs(s[k]))' Math.Abs(e[k]));                              double sp = s[p - 1] / scale;                              double spm1 = s[p - 2] / scale;                              double epm1 = e[p - 2] / scale;                              double sk = s[k] / scale;                              double ek = e[k] / scale;                              double b = (((spm1 + sp) * (spm1 - sp)) + (epm1 * epm1)) / 2.0;                              double c = (sp * epm1) * (sp * epm1);                              double shift = 0.0;                              if((b != 0.0) | (c != 0.0))                              {                                  shift = Math.Sqrt((b * b) + c);                                    if(b < 0.0)                                  {                                      shift = -shift;                                  }                                    shift = c / (b + shift);                              }                                double f = ((sk + sp) * (sk - sp)) + shift;                              double g = sk * ek;                                /* Chase zeros */                                for(int j = k; j < p - 1; j++)                              {                                  double t = Fn.Hypot(f' g);                                  double cs = f / t;                                  double sn = g / t;                                    if(j != k)                                  {                                      e[j - 1] = t;                                  }                                    f = (cs * s[j]) + (sn * e[j]);                                  e[j] = (cs * e[j]) - (sn * s[j]);                                  g = sn * s[j + 1];                                  s[j + 1] = cs * s[j + 1];                                    for(int i = 0; i < _n; i++)                                  {                                      t = (cs * v[i][j]) + (sn * v[i][j + 1]);                                      v[i][j + 1] = ((-sn) * v[i][j]) + (cs * v[i][j + 1]);                                      v[i][j] = t;                                  }                                    t = Fn.Hypot(f' g);                                  cs = f / t;                                  sn = g / t;                                  s[j] = t;                                  f = (cs * e[j]) + (sn * s[j + 1]);                                  s[j + 1] = ((-sn) * e[j]) + (cs * s[j + 1]);                                  g = sn * e[j + 1];                                  e[j + 1] = cs * e[j + 1];                                    if(j < _m - 1)                                  {                                      for(int i = 0; i < _m; i++)                                      {                                          t = (cs * u[i][j]) + (sn * u[i][j + 1]);                                          u[i][j + 1] = ((-sn) * u[i][j]) + (cs * u[i][j + 1]);                                          u[i][j] = t;                                      }                                  }                              }                                e[p - 2] = f;                              iter = iter + 1;                          }                            break;                        // Convergence.                      case IterationStep.Convergence:                          {                              /* Make the singular values positive */                                if(s[k] <= 0.0)                              {                                  s[k] = (s[k] < 0.0 ? -s[k] : 0.0);                                    for(int i = 0; i <= pp; i++)                                  {                                      v[i][k] = -v[i][k];                                  }                              }                                /* Order the singular values */                                while(k < pp)                              {                                  if(s[k] >= s[k + 1])                                  {                                      break;                                  }                                    double t = s[k];                                  s[k] = s[k + 1];                                  s[k + 1] = t;                                    if(k < _n - 1)                                  {                                      for(int i = 0; i < _n; i++)                                      {                                          t = v[i][k + 1];                                          v[i][k + 1] = v[i][k];                                          v[i][k] = t;                                      }                                  }                                    if(k < _m - 1)                                  {                                      for(int i = 0; i < _m; i++)                                      {                                          t = u[i][k + 1];                                          u[i][k + 1] = u[i][k];                                          u[i][k] = t;                                      }                                  }                                    k++;                              }                                iter = 0;                              p--;                          }                            break;                  }
Magic Number,MathNet.Numerics.LinearAlgebra,SingularValueDecomposition,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\LinearAlgebra\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: switch(step)                  {                      // Deflate negligible s(p).                      case IterationStep.DeflateNeglible:                          {                              double f = e[p - 2];                              e[p - 2] = 0.0;                              for(int j = p - 2; j >= k; j--)                              {                                  double t = Fn.Hypot(s[j]' f);                                  double cs = s[j] / t;                                  double sn = f / t;                                  s[j] = t;                                    if(j != k)                                  {                                      f = (-sn) * e[j - 1];                                      e[j - 1] = cs * e[j - 1];                                  }                                    for(int i = 0; i < _n; i++)                                  {                                      t = (cs * v[i][j]) + (sn * v[i][p - 1]);                                      v[i][p - 1] = ((-sn) * v[i][j]) + (cs * v[i][p - 1]);                                      v[i][j] = t;                                  }                              }                          }                            break;                        // Split at negligible s(k)                      case IterationStep.SplitAtNeglible:                          {                              double f = e[k - 1];                              e[k - 1] = 0.0;                              for(int j = k; j < p; j++)                              {                                  double t = Fn.Hypot(s[j]' f);                                  double cs = s[j] / t;                                  double sn = f / t;                                  s[j] = t;                                  f = (-sn) * e[j];                                  e[j] = cs * e[j];                                    for(int i = 0; i < _m; i++)                                  {                                      t = (cs * u[i][j]) + (sn * u[i][k - 1]);                                      u[i][k - 1] = ((-sn) * u[i][j]) + (cs * u[i][k - 1]);                                      u[i][j] = t;                                  }                              }                          }                            break;                        // Perform one qr step.                      case IterationStep.QR:                          {                              /* Calculate the shift */                                double scale = Math.Max(Math.Max(Math.Max(Math.Max(Math.Abs(s[p - 1])' Math.Abs(s[p - 2]))' Math.Abs(e[p - 2]))' Math.Abs(s[k]))' Math.Abs(e[k]));                              double sp = s[p - 1] / scale;                              double spm1 = s[p - 2] / scale;                              double epm1 = e[p - 2] / scale;                              double sk = s[k] / scale;                              double ek = e[k] / scale;                              double b = (((spm1 + sp) * (spm1 - sp)) + (epm1 * epm1)) / 2.0;                              double c = (sp * epm1) * (sp * epm1);                              double shift = 0.0;                              if((b != 0.0) | (c != 0.0))                              {                                  shift = Math.Sqrt((b * b) + c);                                    if(b < 0.0)                                  {                                      shift = -shift;                                  }                                    shift = c / (b + shift);                              }                                double f = ((sk + sp) * (sk - sp)) + shift;                              double g = sk * ek;                                /* Chase zeros */                                for(int j = k; j < p - 1; j++)                              {                                  double t = Fn.Hypot(f' g);                                  double cs = f / t;                                  double sn = g / t;                                    if(j != k)                                  {                                      e[j - 1] = t;                                  }                                    f = (cs * s[j]) + (sn * e[j]);                                  e[j] = (cs * e[j]) - (sn * s[j]);                                  g = sn * s[j + 1];                                  s[j + 1] = cs * s[j + 1];                                    for(int i = 0; i < _n; i++)                                  {                                      t = (cs * v[i][j]) + (sn * v[i][j + 1]);                                      v[i][j + 1] = ((-sn) * v[i][j]) + (cs * v[i][j + 1]);                                      v[i][j] = t;                                  }                                    t = Fn.Hypot(f' g);                                  cs = f / t;                                  sn = g / t;                                  s[j] = t;                                  f = (cs * e[j]) + (sn * s[j + 1]);                                  s[j + 1] = ((-sn) * e[j]) + (cs * s[j + 1]);                                  g = sn * e[j + 1];                                  e[j + 1] = cs * e[j + 1];                                    if(j < _m - 1)                                  {                                      for(int i = 0; i < _m; i++)                                      {                                          t = (cs * u[i][j]) + (sn * u[i][j + 1]);                                          u[i][j + 1] = ((-sn) * u[i][j]) + (cs * u[i][j + 1]);                                          u[i][j] = t;                                      }                                  }                              }                                e[p - 2] = f;                              iter = iter + 1;                          }                            break;                        // Convergence.                      case IterationStep.Convergence:                          {                              /* Make the singular values positive */                                if(s[k] <= 0.0)                              {                                  s[k] = (s[k] < 0.0 ? -s[k] : 0.0);                                    for(int i = 0; i <= pp; i++)                                  {                                      v[i][k] = -v[i][k];                                  }                              }                                /* Order the singular values */                                while(k < pp)                              {                                  if(s[k] >= s[k + 1])                                  {                                      break;                                  }                                    double t = s[k];                                  s[k] = s[k + 1];                                  s[k + 1] = t;                                    if(k < _n - 1)                                  {                                      for(int i = 0; i < _n; i++)                                      {                                          t = v[i][k + 1];                                          v[i][k + 1] = v[i][k];                                          v[i][k] = t;                                      }                                  }                                    if(k < _m - 1)                                  {                                      for(int i = 0; i < _m; i++)                                      {                                          t = u[i][k + 1];                                          u[i][k + 1] = u[i][k];                                          u[i][k] = t;                                      }                                  }                                    k++;                              }                                iter = 0;                              p--;                          }                            break;                  }
Magic Number,MathNet.Numerics.LinearAlgebra,SingularValueDecomposition,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\LinearAlgebra\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: switch(step)                  {                      // Deflate negligible s(p).                      case IterationStep.DeflateNeglible:                          {                              double f = e[p - 2];                              e[p - 2] = 0.0;                              for(int j = p - 2; j >= k; j--)                              {                                  double t = Fn.Hypot(s[j]' f);                                  double cs = s[j] / t;                                  double sn = f / t;                                  s[j] = t;                                    if(j != k)                                  {                                      f = (-sn) * e[j - 1];                                      e[j - 1] = cs * e[j - 1];                                  }                                    for(int i = 0; i < _n; i++)                                  {                                      t = (cs * v[i][j]) + (sn * v[i][p - 1]);                                      v[i][p - 1] = ((-sn) * v[i][j]) + (cs * v[i][p - 1]);                                      v[i][j] = t;                                  }                              }                          }                            break;                        // Split at negligible s(k)                      case IterationStep.SplitAtNeglible:                          {                              double f = e[k - 1];                              e[k - 1] = 0.0;                              for(int j = k; j < p; j++)                              {                                  double t = Fn.Hypot(s[j]' f);                                  double cs = s[j] / t;                                  double sn = f / t;                                  s[j] = t;                                  f = (-sn) * e[j];                                  e[j] = cs * e[j];                                    for(int i = 0; i < _m; i++)                                  {                                      t = (cs * u[i][j]) + (sn * u[i][k - 1]);                                      u[i][k - 1] = ((-sn) * u[i][j]) + (cs * u[i][k - 1]);                                      u[i][j] = t;                                  }                              }                          }                            break;                        // Perform one qr step.                      case IterationStep.QR:                          {                              /* Calculate the shift */                                double scale = Math.Max(Math.Max(Math.Max(Math.Max(Math.Abs(s[p - 1])' Math.Abs(s[p - 2]))' Math.Abs(e[p - 2]))' Math.Abs(s[k]))' Math.Abs(e[k]));                              double sp = s[p - 1] / scale;                              double spm1 = s[p - 2] / scale;                              double epm1 = e[p - 2] / scale;                              double sk = s[k] / scale;                              double ek = e[k] / scale;                              double b = (((spm1 + sp) * (spm1 - sp)) + (epm1 * epm1)) / 2.0;                              double c = (sp * epm1) * (sp * epm1);                              double shift = 0.0;                              if((b != 0.0) | (c != 0.0))                              {                                  shift = Math.Sqrt((b * b) + c);                                    if(b < 0.0)                                  {                                      shift = -shift;                                  }                                    shift = c / (b + shift);                              }                                double f = ((sk + sp) * (sk - sp)) + shift;                              double g = sk * ek;                                /* Chase zeros */                                for(int j = k; j < p - 1; j++)                              {                                  double t = Fn.Hypot(f' g);                                  double cs = f / t;                                  double sn = g / t;                                    if(j != k)                                  {                                      e[j - 1] = t;                                  }                                    f = (cs * s[j]) + (sn * e[j]);                                  e[j] = (cs * e[j]) - (sn * s[j]);                                  g = sn * s[j + 1];                                  s[j + 1] = cs * s[j + 1];                                    for(int i = 0; i < _n; i++)                                  {                                      t = (cs * v[i][j]) + (sn * v[i][j + 1]);                                      v[i][j + 1] = ((-sn) * v[i][j]) + (cs * v[i][j + 1]);                                      v[i][j] = t;                                  }                                    t = Fn.Hypot(f' g);                                  cs = f / t;                                  sn = g / t;                                  s[j] = t;                                  f = (cs * e[j]) + (sn * s[j + 1]);                                  s[j + 1] = ((-sn) * e[j]) + (cs * s[j + 1]);                                  g = sn * e[j + 1];                                  e[j + 1] = cs * e[j + 1];                                    if(j < _m - 1)                                  {                                      for(int i = 0; i < _m; i++)                                      {                                          t = (cs * u[i][j]) + (sn * u[i][j + 1]);                                          u[i][j + 1] = ((-sn) * u[i][j]) + (cs * u[i][j + 1]);                                          u[i][j] = t;                                      }                                  }                              }                                e[p - 2] = f;                              iter = iter + 1;                          }                            break;                        // Convergence.                      case IterationStep.Convergence:                          {                              /* Make the singular values positive */                                if(s[k] <= 0.0)                              {                                  s[k] = (s[k] < 0.0 ? -s[k] : 0.0);                                    for(int i = 0; i <= pp; i++)                                  {                                      v[i][k] = -v[i][k];                                  }                              }                                /* Order the singular values */                                while(k < pp)                              {                                  if(s[k] >= s[k + 1])                                  {                                      break;                                  }                                    double t = s[k];                                  s[k] = s[k + 1];                                  s[k + 1] = t;                                    if(k < _n - 1)                                  {                                      for(int i = 0; i < _n; i++)                                      {                                          t = v[i][k + 1];                                          v[i][k + 1] = v[i][k];                                          v[i][k] = t;                                      }                                  }                                    if(k < _m - 1)                                  {                                      for(int i = 0; i < _m; i++)                                      {                                          t = u[i][k + 1];                                          u[i][k + 1] = u[i][k];                                          u[i][k] = t;                                      }                                  }                                    k++;                              }                                iter = 0;                              p--;                          }                            break;                  }
Magic Number,MathNet.Numerics.LinearAlgebra,SingularValueDecomposition,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\LinearAlgebra\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: switch(step)                  {                      // Deflate negligible s(p).                      case IterationStep.DeflateNeglible:                          {                              double f = e[p - 2];                              e[p - 2] = 0.0;                              for(int j = p - 2; j >= k; j--)                              {                                  double t = Fn.Hypot(s[j]' f);                                  double cs = s[j] / t;                                  double sn = f / t;                                  s[j] = t;                                    if(j != k)                                  {                                      f = (-sn) * e[j - 1];                                      e[j - 1] = cs * e[j - 1];                                  }                                    for(int i = 0; i < _n; i++)                                  {                                      t = (cs * v[i][j]) + (sn * v[i][p - 1]);                                      v[i][p - 1] = ((-sn) * v[i][j]) + (cs * v[i][p - 1]);                                      v[i][j] = t;                                  }                              }                          }                            break;                        // Split at negligible s(k)                      case IterationStep.SplitAtNeglible:                          {                              double f = e[k - 1];                              e[k - 1] = 0.0;                              for(int j = k; j < p; j++)                              {                                  double t = Fn.Hypot(s[j]' f);                                  double cs = s[j] / t;                                  double sn = f / t;                                  s[j] = t;                                  f = (-sn) * e[j];                                  e[j] = cs * e[j];                                    for(int i = 0; i < _m; i++)                                  {                                      t = (cs * u[i][j]) + (sn * u[i][k - 1]);                                      u[i][k - 1] = ((-sn) * u[i][j]) + (cs * u[i][k - 1]);                                      u[i][j] = t;                                  }                              }                          }                            break;                        // Perform one qr step.                      case IterationStep.QR:                          {                              /* Calculate the shift */                                double scale = Math.Max(Math.Max(Math.Max(Math.Max(Math.Abs(s[p - 1])' Math.Abs(s[p - 2]))' Math.Abs(e[p - 2]))' Math.Abs(s[k]))' Math.Abs(e[k]));                              double sp = s[p - 1] / scale;                              double spm1 = s[p - 2] / scale;                              double epm1 = e[p - 2] / scale;                              double sk = s[k] / scale;                              double ek = e[k] / scale;                              double b = (((spm1 + sp) * (spm1 - sp)) + (epm1 * epm1)) / 2.0;                              double c = (sp * epm1) * (sp * epm1);                              double shift = 0.0;                              if((b != 0.0) | (c != 0.0))                              {                                  shift = Math.Sqrt((b * b) + c);                                    if(b < 0.0)                                  {                                      shift = -shift;                                  }                                    shift = c / (b + shift);                              }                                double f = ((sk + sp) * (sk - sp)) + shift;                              double g = sk * ek;                                /* Chase zeros */                                for(int j = k; j < p - 1; j++)                              {                                  double t = Fn.Hypot(f' g);                                  double cs = f / t;                                  double sn = g / t;                                    if(j != k)                                  {                                      e[j - 1] = t;                                  }                                    f = (cs * s[j]) + (sn * e[j]);                                  e[j] = (cs * e[j]) - (sn * s[j]);                                  g = sn * s[j + 1];                                  s[j + 1] = cs * s[j + 1];                                    for(int i = 0; i < _n; i++)                                  {                                      t = (cs * v[i][j]) + (sn * v[i][j + 1]);                                      v[i][j + 1] = ((-sn) * v[i][j]) + (cs * v[i][j + 1]);                                      v[i][j] = t;                                  }                                    t = Fn.Hypot(f' g);                                  cs = f / t;                                  sn = g / t;                                  s[j] = t;                                  f = (cs * e[j]) + (sn * s[j + 1]);                                  s[j + 1] = ((-sn) * e[j]) + (cs * s[j + 1]);                                  g = sn * e[j + 1];                                  e[j + 1] = cs * e[j + 1];                                    if(j < _m - 1)                                  {                                      for(int i = 0; i < _m; i++)                                      {                                          t = (cs * u[i][j]) + (sn * u[i][j + 1]);                                          u[i][j + 1] = ((-sn) * u[i][j]) + (cs * u[i][j + 1]);                                          u[i][j] = t;                                      }                                  }                              }                                e[p - 2] = f;                              iter = iter + 1;                          }                            break;                        // Convergence.                      case IterationStep.Convergence:                          {                              /* Make the singular values positive */                                if(s[k] <= 0.0)                              {                                  s[k] = (s[k] < 0.0 ? -s[k] : 0.0);                                    for(int i = 0; i <= pp; i++)                                  {                                      v[i][k] = -v[i][k];                                  }                              }                                /* Order the singular values */                                while(k < pp)                              {                                  if(s[k] >= s[k + 1])                                  {                                      break;                                  }                                    double t = s[k];                                  s[k] = s[k + 1];                                  s[k + 1] = t;                                    if(k < _n - 1)                                  {                                      for(int i = 0; i < _n; i++)                                      {                                          t = v[i][k + 1];                                          v[i][k + 1] = v[i][k];                                          v[i][k] = t;                                      }                                  }                                    if(k < _m - 1)                                  {                                      for(int i = 0; i < _m; i++)                                      {                                          t = u[i][k + 1];                                          u[i][k + 1] = u[i][k];                                          u[i][k] = t;                                      }                                  }                                    k++;                              }                                iter = 0;                              p--;                          }                            break;                  }
Magic Number,MathNet.Numerics.LinearAlgebra,SingularValueDecomposition,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\LinearAlgebra\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: switch(step)                  {                      // Deflate negligible s(p).                      case IterationStep.DeflateNeglible:                          {                              double f = e[p - 2];                              e[p - 2] = 0.0;                              for(int j = p - 2; j >= k; j--)                              {                                  double t = Fn.Hypot(s[j]' f);                                  double cs = s[j] / t;                                  double sn = f / t;                                  s[j] = t;                                    if(j != k)                                  {                                      f = (-sn) * e[j - 1];                                      e[j - 1] = cs * e[j - 1];                                  }                                    for(int i = 0; i < _n; i++)                                  {                                      t = (cs * v[i][j]) + (sn * v[i][p - 1]);                                      v[i][p - 1] = ((-sn) * v[i][j]) + (cs * v[i][p - 1]);                                      v[i][j] = t;                                  }                              }                          }                            break;                        // Split at negligible s(k)                      case IterationStep.SplitAtNeglible:                          {                              double f = e[k - 1];                              e[k - 1] = 0.0;                              for(int j = k; j < p; j++)                              {                                  double t = Fn.Hypot(s[j]' f);                                  double cs = s[j] / t;                                  double sn = f / t;                                  s[j] = t;                                  f = (-sn) * e[j];                                  e[j] = cs * e[j];                                    for(int i = 0; i < _m; i++)                                  {                                      t = (cs * u[i][j]) + (sn * u[i][k - 1]);                                      u[i][k - 1] = ((-sn) * u[i][j]) + (cs * u[i][k - 1]);                                      u[i][j] = t;                                  }                              }                          }                            break;                        // Perform one qr step.                      case IterationStep.QR:                          {                              /* Calculate the shift */                                double scale = Math.Max(Math.Max(Math.Max(Math.Max(Math.Abs(s[p - 1])' Math.Abs(s[p - 2]))' Math.Abs(e[p - 2]))' Math.Abs(s[k]))' Math.Abs(e[k]));                              double sp = s[p - 1] / scale;                              double spm1 = s[p - 2] / scale;                              double epm1 = e[p - 2] / scale;                              double sk = s[k] / scale;                              double ek = e[k] / scale;                              double b = (((spm1 + sp) * (spm1 - sp)) + (epm1 * epm1)) / 2.0;                              double c = (sp * epm1) * (sp * epm1);                              double shift = 0.0;                              if((b != 0.0) | (c != 0.0))                              {                                  shift = Math.Sqrt((b * b) + c);                                    if(b < 0.0)                                  {                                      shift = -shift;                                  }                                    shift = c / (b + shift);                              }                                double f = ((sk + sp) * (sk - sp)) + shift;                              double g = sk * ek;                                /* Chase zeros */                                for(int j = k; j < p - 1; j++)                              {                                  double t = Fn.Hypot(f' g);                                  double cs = f / t;                                  double sn = g / t;                                    if(j != k)                                  {                                      e[j - 1] = t;                                  }                                    f = (cs * s[j]) + (sn * e[j]);                                  e[j] = (cs * e[j]) - (sn * s[j]);                                  g = sn * s[j + 1];                                  s[j + 1] = cs * s[j + 1];                                    for(int i = 0; i < _n; i++)                                  {                                      t = (cs * v[i][j]) + (sn * v[i][j + 1]);                                      v[i][j + 1] = ((-sn) * v[i][j]) + (cs * v[i][j + 1]);                                      v[i][j] = t;                                  }                                    t = Fn.Hypot(f' g);                                  cs = f / t;                                  sn = g / t;                                  s[j] = t;                                  f = (cs * e[j]) + (sn * s[j + 1]);                                  s[j + 1] = ((-sn) * e[j]) + (cs * s[j + 1]);                                  g = sn * e[j + 1];                                  e[j + 1] = cs * e[j + 1];                                    if(j < _m - 1)                                  {                                      for(int i = 0; i < _m; i++)                                      {                                          t = (cs * u[i][j]) + (sn * u[i][j + 1]);                                          u[i][j + 1] = ((-sn) * u[i][j]) + (cs * u[i][j + 1]);                                          u[i][j] = t;                                      }                                  }                              }                                e[p - 2] = f;                              iter = iter + 1;                          }                            break;                        // Convergence.                      case IterationStep.Convergence:                          {                              /* Make the singular values positive */                                if(s[k] <= 0.0)                              {                                  s[k] = (s[k] < 0.0 ? -s[k] : 0.0);                                    for(int i = 0; i <= pp; i++)                                  {                                      v[i][k] = -v[i][k];                                  }                              }                                /* Order the singular values */                                while(k < pp)                              {                                  if(s[k] >= s[k + 1])                                  {                                      break;                                  }                                    double t = s[k];                                  s[k] = s[k + 1];                                  s[k + 1] = t;                                    if(k < _n - 1)                                  {                                      for(int i = 0; i < _n; i++)                                      {                                          t = v[i][k + 1];                                          v[i][k + 1] = v[i][k];                                          v[i][k] = t;                                      }                                  }                                    if(k < _m - 1)                                  {                                      for(int i = 0; i < _m; i++)                                      {                                          t = u[i][k + 1];                                          u[i][k + 1] = u[i][k];                                          u[i][k] = t;                                      }                                  }                                    k++;                              }                                iter = 0;                              p--;                          }                            break;                  }
Magic Number,MathNet.Numerics.LinearAlgebra,SingularValueDecomposition,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\LinearAlgebra\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: switch(step)                  {                      // Deflate negligible s(p).                      case IterationStep.DeflateNeglible:                          {                              double f = e[p - 2];                              e[p - 2] = 0.0;                              for(int j = p - 2; j >= k; j--)                              {                                  double t = Fn.Hypot(s[j]' f);                                  double cs = s[j] / t;                                  double sn = f / t;                                  s[j] = t;                                    if(j != k)                                  {                                      f = (-sn) * e[j - 1];                                      e[j - 1] = cs * e[j - 1];                                  }                                    for(int i = 0; i < _n; i++)                                  {                                      t = (cs * v[i][j]) + (sn * v[i][p - 1]);                                      v[i][p - 1] = ((-sn) * v[i][j]) + (cs * v[i][p - 1]);                                      v[i][j] = t;                                  }                              }                          }                            break;                        // Split at negligible s(k)                      case IterationStep.SplitAtNeglible:                          {                              double f = e[k - 1];                              e[k - 1] = 0.0;                              for(int j = k; j < p; j++)                              {                                  double t = Fn.Hypot(s[j]' f);                                  double cs = s[j] / t;                                  double sn = f / t;                                  s[j] = t;                                  f = (-sn) * e[j];                                  e[j] = cs * e[j];                                    for(int i = 0; i < _m; i++)                                  {                                      t = (cs * u[i][j]) + (sn * u[i][k - 1]);                                      u[i][k - 1] = ((-sn) * u[i][j]) + (cs * u[i][k - 1]);                                      u[i][j] = t;                                  }                              }                          }                            break;                        // Perform one qr step.                      case IterationStep.QR:                          {                              /* Calculate the shift */                                double scale = Math.Max(Math.Max(Math.Max(Math.Max(Math.Abs(s[p - 1])' Math.Abs(s[p - 2]))' Math.Abs(e[p - 2]))' Math.Abs(s[k]))' Math.Abs(e[k]));                              double sp = s[p - 1] / scale;                              double spm1 = s[p - 2] / scale;                              double epm1 = e[p - 2] / scale;                              double sk = s[k] / scale;                              double ek = e[k] / scale;                              double b = (((spm1 + sp) * (spm1 - sp)) + (epm1 * epm1)) / 2.0;                              double c = (sp * epm1) * (sp * epm1);                              double shift = 0.0;                              if((b != 0.0) | (c != 0.0))                              {                                  shift = Math.Sqrt((b * b) + c);                                    if(b < 0.0)                                  {                                      shift = -shift;                                  }                                    shift = c / (b + shift);                              }                                double f = ((sk + sp) * (sk - sp)) + shift;                              double g = sk * ek;                                /* Chase zeros */                                for(int j = k; j < p - 1; j++)                              {                                  double t = Fn.Hypot(f' g);                                  double cs = f / t;                                  double sn = g / t;                                    if(j != k)                                  {                                      e[j - 1] = t;                                  }                                    f = (cs * s[j]) + (sn * e[j]);                                  e[j] = (cs * e[j]) - (sn * s[j]);                                  g = sn * s[j + 1];                                  s[j + 1] = cs * s[j + 1];                                    for(int i = 0; i < _n; i++)                                  {                                      t = (cs * v[i][j]) + (sn * v[i][j + 1]);                                      v[i][j + 1] = ((-sn) * v[i][j]) + (cs * v[i][j + 1]);                                      v[i][j] = t;                                  }                                    t = Fn.Hypot(f' g);                                  cs = f / t;                                  sn = g / t;                                  s[j] = t;                                  f = (cs * e[j]) + (sn * s[j + 1]);                                  s[j + 1] = ((-sn) * e[j]) + (cs * s[j + 1]);                                  g = sn * e[j + 1];                                  e[j + 1] = cs * e[j + 1];                                    if(j < _m - 1)                                  {                                      for(int i = 0; i < _m; i++)                                      {                                          t = (cs * u[i][j]) + (sn * u[i][j + 1]);                                          u[i][j + 1] = ((-sn) * u[i][j]) + (cs * u[i][j + 1]);                                          u[i][j] = t;                                      }                                  }                              }                                e[p - 2] = f;                              iter = iter + 1;                          }                            break;                        // Convergence.                      case IterationStep.Convergence:                          {                              /* Make the singular values positive */                                if(s[k] <= 0.0)                              {                                  s[k] = (s[k] < 0.0 ? -s[k] : 0.0);                                    for(int i = 0; i <= pp; i++)                                  {                                      v[i][k] = -v[i][k];                                  }                              }                                /* Order the singular values */                                while(k < pp)                              {                                  if(s[k] >= s[k + 1])                                  {                                      break;                                  }                                    double t = s[k];                                  s[k] = s[k + 1];                                  s[k + 1] = t;                                    if(k < _n - 1)                                  {                                      for(int i = 0; i < _n; i++)                                      {                                          t = v[i][k + 1];                                          v[i][k + 1] = v[i][k];                                          v[i][k] = t;                                      }                                  }                                    if(k < _m - 1)                                  {                                      for(int i = 0; i < _m; i++)                                      {                                          t = u[i][k + 1];                                          u[i][k + 1] = u[i][k];                                          u[i][k] = t;                                      }                                  }                                    k++;                              }                                iter = 0;                              p--;                          }                            break;                  }
Magic Number,MathNet.Numerics.NumberTheory,IntegerTheory,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\NumberTheory\IntegerTheory.cs,IsPerfectSquare,The following statement contains a magic number: lastHexDigit > 9
Magic Number,MathNet.Numerics.NumberTheory,IntegerTheory,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\NumberTheory\IntegerTheory.cs,IsPerfectSquare,The following statement contains a magic number: int t = (int)Math.Floor(Math.Sqrt(number) + 0.5);
Magic Number,MathNet.Numerics.NumberTheory,IntegerTheory,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\NumberTheory\IntegerTheory.cs,IsPerfectSquare,The following statement contains a magic number: lastHexDigit == 0 || lastHexDigit == 1 || lastHexDigit == 4 || lastHexDigit == 9
Magic Number,MathNet.Numerics.NumberTheory,IntegerTheory,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\NumberTheory\IntegerTheory.cs,IsPerfectSquare,The following statement contains a magic number: lastHexDigit == 0 || lastHexDigit == 1 || lastHexDigit == 4 || lastHexDigit == 9
Magic Number,MathNet.Numerics.NumberTheory,IntegerTheory,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\NumberTheory\IntegerTheory.cs,IsPerfectSquare,The following statement contains a magic number: lastHexDigit > 9
Magic Number,MathNet.Numerics.NumberTheory,IntegerTheory,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\NumberTheory\IntegerTheory.cs,IsPerfectSquare,The following statement contains a magic number: long t = (long)Math.Floor(Math.Sqrt(number) + 0.5);
Magic Number,MathNet.Numerics.NumberTheory,IntegerTheory,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\NumberTheory\IntegerTheory.cs,IsPerfectSquare,The following statement contains a magic number: lastHexDigit == 0 || lastHexDigit == 1 || lastHexDigit == 4 || lastHexDigit == 9
Magic Number,MathNet.Numerics.NumberTheory,IntegerTheory,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\NumberTheory\IntegerTheory.cs,IsPerfectSquare,The following statement contains a magic number: lastHexDigit == 0 || lastHexDigit == 1 || lastHexDigit == 4 || lastHexDigit == 9
Magic Number,MathNet.Numerics.RandomSources,AdditiveLaggedFibonacciRandomSource,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\AdditiveLaggedFibonacciRandomSource.cs,AdditiveLaggedFibonacciRandomSource,The following statement contains a magic number: _shortLag = 418;
Magic Number,MathNet.Numerics.RandomSources,AdditiveLaggedFibonacciRandomSource,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\AdditiveLaggedFibonacciRandomSource.cs,AdditiveLaggedFibonacciRandomSource,The following statement contains a magic number: _longLag = 1279;
Magic Number,MathNet.Numerics.RandomSources,AdditiveLaggedFibonacciRandomSource,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\AdditiveLaggedFibonacciRandomSource.cs,NextBoolean,The following statement contains a magic number: _bitCount = 31;
Magic Number,MathNet.Numerics.RandomSources,AdditiveLaggedFibonacciRandomSource,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\AdditiveLaggedFibonacciRandomSource.cs,NextBytes,The following statement contains a magic number: buffer[i++] = (byte)(w >> 8);
Magic Number,MathNet.Numerics.RandomSources,AdditiveLaggedFibonacciRandomSource,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\AdditiveLaggedFibonacciRandomSource.cs,NextBytes,The following statement contains a magic number: buffer[i++] = (byte)(w >> 16);
Magic Number,MathNet.Numerics.RandomSources,AdditiveLaggedFibonacciRandomSource,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\AdditiveLaggedFibonacciRandomSource.cs,NextBytes,The following statement contains a magic number: buffer[i++] = (byte)(w >> 24);
Magic Number,MathNet.Numerics.RandomSources,AdditiveLaggedFibonacciRandomSource,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\AdditiveLaggedFibonacciRandomSource.cs,NextBytes,The following statement contains a magic number: i < buffer.Length - 3
Magic Number,MathNet.Numerics.RandomSources,AdditiveLaggedFibonacciRandomSource,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\AdditiveLaggedFibonacciRandomSource.cs,NextBytes,The following statement contains a magic number: buffer[i++] = (byte)(w >> 8);
Magic Number,MathNet.Numerics.RandomSources,AdditiveLaggedFibonacciRandomSource,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\AdditiveLaggedFibonacciRandomSource.cs,NextBytes,The following statement contains a magic number: buffer[i++] = (byte)(w >> 16);
Magic Number,MathNet.Numerics.RandomSources,AdditiveLaggedFibonacciRandomSource,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\AdditiveLaggedFibonacciRandomSource.cs,NextBytes,The following statement contains a magic number: buffer[i] = (byte)(w >> 24);
Magic Number,MathNet.Numerics.RandomSources,MersenneTwisterRandomSource,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\MersenneTwisterRandomSource.cs,MersenneTwisterRandomSource,The following statement contains a magic number: _seed = 19650218U;
Magic Number,MathNet.Numerics.RandomSources,MersenneTwisterRandomSource,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\MersenneTwisterRandomSource.cs,MersenneTwisterRandomSource,The following statement contains a magic number: _seed = 19650218U;
Magic Number,MathNet.Numerics.RandomSources,MersenneTwisterRandomSource,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\MersenneTwisterRandomSource.cs,ResetGenerator,The following statement contains a magic number: _mt[_mti] = (1812433253U * (_mt[_mti - 1] ^ (_mt[_mti - 1] >> 30))) + _mti;
Magic Number,MathNet.Numerics.RandomSources,MersenneTwisterRandomSource,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\MersenneTwisterRandomSource.cs,ResetGenerator,The following statement contains a magic number: _mt[_mti] = (1812433253U * (_mt[_mti - 1] ^ (_mt[_mti - 1] >> 30))) + _mti;
Magic Number,MathNet.Numerics.RandomSources,MersenneTwisterRandomSource,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\MersenneTwisterRandomSource.cs,ResetGenerator,The following statement contains a magic number: _bitCount = 32;
Magic Number,MathNet.Numerics.RandomSources,MersenneTwisterRandomSource,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\MersenneTwisterRandomSource.cs,ResetBySeedArray,The following statement contains a magic number: _mt[i] = (_mt[i] ^ ((_mt[i - 1] ^ (_mt[i - 1] >> 30)) * 1664525U)) + _seedArray[j] + j;
Magic Number,MathNet.Numerics.RandomSources,MersenneTwisterRandomSource,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\MersenneTwisterRandomSource.cs,ResetBySeedArray,The following statement contains a magic number: _mt[i] = (_mt[i] ^ ((_mt[i - 1] ^ (_mt[i - 1] >> 30)) * 1664525U)) + _seedArray[j] + j;
Magic Number,MathNet.Numerics.RandomSources,MersenneTwisterRandomSource,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\MersenneTwisterRandomSource.cs,ResetBySeedArray,The following statement contains a magic number: _mt[i] = (_mt[i] ^ ((_mt[i - 1] ^ (_mt[i - 1] >> 30)) * 1566083941U)) - i;
Magic Number,MathNet.Numerics.RandomSources,MersenneTwisterRandomSource,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\MersenneTwisterRandomSource.cs,ResetBySeedArray,The following statement contains a magic number: _mt[i] = (_mt[i] ^ ((_mt[i - 1] ^ (_mt[i - 1] >> 30)) * 1566083941U)) - i;
Magic Number,MathNet.Numerics.RandomSources,MersenneTwisterRandomSource,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\MersenneTwisterRandomSource.cs,NextFullRangeInt32,The following statement contains a magic number: y ^= (y >> 11);
Magic Number,MathNet.Numerics.RandomSources,MersenneTwisterRandomSource,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\MersenneTwisterRandomSource.cs,NextFullRangeInt32,The following statement contains a magic number: y ^= (y << 7) & 0x9d2c5680U;
Magic Number,MathNet.Numerics.RandomSources,MersenneTwisterRandomSource,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\MersenneTwisterRandomSource.cs,NextFullRangeInt32,The following statement contains a magic number: y ^= (y << 15) & 0xefc60000U;
Magic Number,MathNet.Numerics.RandomSources,MersenneTwisterRandomSource,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\MersenneTwisterRandomSource.cs,NextFullRangeInt32,The following statement contains a magic number: return (int)(y ^ (y >> 18));
Magic Number,MathNet.Numerics.RandomSources,MersenneTwisterRandomSource,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\MersenneTwisterRandomSource.cs,NextFullRangeUInt32,The following statement contains a magic number: y ^= (y >> 11);
Magic Number,MathNet.Numerics.RandomSources,MersenneTwisterRandomSource,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\MersenneTwisterRandomSource.cs,NextFullRangeUInt32,The following statement contains a magic number: y ^= (y << 7) & 0x9d2c5680U;
Magic Number,MathNet.Numerics.RandomSources,MersenneTwisterRandomSource,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\MersenneTwisterRandomSource.cs,NextFullRangeUInt32,The following statement contains a magic number: y ^= (y << 15) & 0xefc60000U;
Magic Number,MathNet.Numerics.RandomSources,MersenneTwisterRandomSource,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\MersenneTwisterRandomSource.cs,NextFullRangeUInt32,The following statement contains a magic number: return y ^ (y >> 18);
Magic Number,MathNet.Numerics.RandomSources,MersenneTwisterRandomSource,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\MersenneTwisterRandomSource.cs,NextInclusiveMaxValue,The following statement contains a magic number: y ^= (y >> 11);
Magic Number,MathNet.Numerics.RandomSources,MersenneTwisterRandomSource,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\MersenneTwisterRandomSource.cs,NextInclusiveMaxValue,The following statement contains a magic number: y ^= (y << 7) & 0x9d2c5680U;
Magic Number,MathNet.Numerics.RandomSources,MersenneTwisterRandomSource,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\MersenneTwisterRandomSource.cs,NextInclusiveMaxValue,The following statement contains a magic number: y ^= (y << 15) & 0xefc60000U;
Magic Number,MathNet.Numerics.RandomSources,MersenneTwisterRandomSource,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\MersenneTwisterRandomSource.cs,NextInclusiveMaxValue,The following statement contains a magic number: y ^= (y >> 18);
Magic Number,MathNet.Numerics.RandomSources,MersenneTwisterRandomSource,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\MersenneTwisterRandomSource.cs,Next,The following statement contains a magic number: y ^= (y >> 11);
Magic Number,MathNet.Numerics.RandomSources,MersenneTwisterRandomSource,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\MersenneTwisterRandomSource.cs,Next,The following statement contains a magic number: y ^= (y << 7) & 0x9d2c5680U;
Magic Number,MathNet.Numerics.RandomSources,MersenneTwisterRandomSource,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\MersenneTwisterRandomSource.cs,Next,The following statement contains a magic number: y ^= (y << 15) & 0xefc60000U;
Magic Number,MathNet.Numerics.RandomSources,MersenneTwisterRandomSource,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\MersenneTwisterRandomSource.cs,Next,The following statement contains a magic number: y ^= (y >> 18);
Magic Number,MathNet.Numerics.RandomSources,MersenneTwisterRandomSource,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\MersenneTwisterRandomSource.cs,Next,The following statement contains a magic number: y ^= (y >> 11);
Magic Number,MathNet.Numerics.RandomSources,MersenneTwisterRandomSource,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\MersenneTwisterRandomSource.cs,Next,The following statement contains a magic number: y ^= (y << 7) & 0x9d2c5680U;
Magic Number,MathNet.Numerics.RandomSources,MersenneTwisterRandomSource,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\MersenneTwisterRandomSource.cs,Next,The following statement contains a magic number: y ^= (y << 15) & 0xefc60000U;
Magic Number,MathNet.Numerics.RandomSources,MersenneTwisterRandomSource,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\MersenneTwisterRandomSource.cs,Next,The following statement contains a magic number: y ^= (y >> 18);
Magic Number,MathNet.Numerics.RandomSources,MersenneTwisterRandomSource,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\MersenneTwisterRandomSource.cs,Next,The following statement contains a magic number: y ^= (y >> 11);
Magic Number,MathNet.Numerics.RandomSources,MersenneTwisterRandomSource,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\MersenneTwisterRandomSource.cs,Next,The following statement contains a magic number: y ^= (y << 7) & 0x9d2c5680U;
Magic Number,MathNet.Numerics.RandomSources,MersenneTwisterRandomSource,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\MersenneTwisterRandomSource.cs,Next,The following statement contains a magic number: y ^= (y << 15) & 0xefc60000U;
Magic Number,MathNet.Numerics.RandomSources,MersenneTwisterRandomSource,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\MersenneTwisterRandomSource.cs,Next,The following statement contains a magic number: y ^= (y >> 18);
Magic Number,MathNet.Numerics.RandomSources,MersenneTwisterRandomSource,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\MersenneTwisterRandomSource.cs,NextDouble,The following statement contains a magic number: y ^= (y >> 11);
Magic Number,MathNet.Numerics.RandomSources,MersenneTwisterRandomSource,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\MersenneTwisterRandomSource.cs,NextDouble,The following statement contains a magic number: y ^= (y << 7) & 0x9d2c5680U;
Magic Number,MathNet.Numerics.RandomSources,MersenneTwisterRandomSource,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\MersenneTwisterRandomSource.cs,NextDouble,The following statement contains a magic number: y ^= (y << 15) & 0xefc60000U;
Magic Number,MathNet.Numerics.RandomSources,MersenneTwisterRandomSource,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\MersenneTwisterRandomSource.cs,NextDouble,The following statement contains a magic number: y ^= (y >> 18);
Magic Number,MathNet.Numerics.RandomSources,MersenneTwisterRandomSource,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\MersenneTwisterRandomSource.cs,NextDouble,The following statement contains a magic number: y ^= (y >> 11);
Magic Number,MathNet.Numerics.RandomSources,MersenneTwisterRandomSource,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\MersenneTwisterRandomSource.cs,NextDouble,The following statement contains a magic number: y ^= (y << 7) & 0x9d2c5680U;
Magic Number,MathNet.Numerics.RandomSources,MersenneTwisterRandomSource,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\MersenneTwisterRandomSource.cs,NextDouble,The following statement contains a magic number: y ^= (y << 15) & 0xefc60000U;
Magic Number,MathNet.Numerics.RandomSources,MersenneTwisterRandomSource,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\MersenneTwisterRandomSource.cs,NextDouble,The following statement contains a magic number: y ^= (y >> 18);
Magic Number,MathNet.Numerics.RandomSources,MersenneTwisterRandomSource,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\MersenneTwisterRandomSource.cs,NextDouble,The following statement contains a magic number: y ^= (y >> 11);
Magic Number,MathNet.Numerics.RandomSources,MersenneTwisterRandomSource,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\MersenneTwisterRandomSource.cs,NextDouble,The following statement contains a magic number: y ^= (y << 7) & 0x9d2c5680U;
Magic Number,MathNet.Numerics.RandomSources,MersenneTwisterRandomSource,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\MersenneTwisterRandomSource.cs,NextDouble,The following statement contains a magic number: y ^= (y << 15) & 0xefc60000U;
Magic Number,MathNet.Numerics.RandomSources,MersenneTwisterRandomSource,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\MersenneTwisterRandomSource.cs,NextDouble,The following statement contains a magic number: y ^= (y >> 18);
Magic Number,MathNet.Numerics.RandomSources,MersenneTwisterRandomSource,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\MersenneTwisterRandomSource.cs,NextBoolean,The following statement contains a magic number: y ^= (y >> 11);
Magic Number,MathNet.Numerics.RandomSources,MersenneTwisterRandomSource,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\MersenneTwisterRandomSource.cs,NextBoolean,The following statement contains a magic number: y ^= (y << 7) & 0x9d2c5680U;
Magic Number,MathNet.Numerics.RandomSources,MersenneTwisterRandomSource,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\MersenneTwisterRandomSource.cs,NextBoolean,The following statement contains a magic number: y ^= (y << 15) & 0xefc60000U;
Magic Number,MathNet.Numerics.RandomSources,MersenneTwisterRandomSource,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\MersenneTwisterRandomSource.cs,NextBoolean,The following statement contains a magic number: _bitBuffer = (y ^ (y >> 18));
Magic Number,MathNet.Numerics.RandomSources,MersenneTwisterRandomSource,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\MersenneTwisterRandomSource.cs,NextBoolean,The following statement contains a magic number: _bitCount == 32
Magic Number,MathNet.Numerics.RandomSources,MersenneTwisterRandomSource,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\MersenneTwisterRandomSource.cs,NextBytes,The following statement contains a magic number: y ^= (y >> 11);
Magic Number,MathNet.Numerics.RandomSources,MersenneTwisterRandomSource,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\MersenneTwisterRandomSource.cs,NextBytes,The following statement contains a magic number: y ^= (y << 7) & 0x9d2c5680U;
Magic Number,MathNet.Numerics.RandomSources,MersenneTwisterRandomSource,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\MersenneTwisterRandomSource.cs,NextBytes,The following statement contains a magic number: y ^= (y << 15) & 0xefc60000U;
Magic Number,MathNet.Numerics.RandomSources,MersenneTwisterRandomSource,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\MersenneTwisterRandomSource.cs,NextBytes,The following statement contains a magic number: y ^= (y >> 18);
Magic Number,MathNet.Numerics.RandomSources,MersenneTwisterRandomSource,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\MersenneTwisterRandomSource.cs,NextBytes,The following statement contains a magic number: buffer[i++] = (byte)(y >> 8);
Magic Number,MathNet.Numerics.RandomSources,MersenneTwisterRandomSource,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\MersenneTwisterRandomSource.cs,NextBytes,The following statement contains a magic number: buffer[i++] = (byte)(y >> 16);
Magic Number,MathNet.Numerics.RandomSources,MersenneTwisterRandomSource,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\MersenneTwisterRandomSource.cs,NextBytes,The following statement contains a magic number: buffer[i++] = (byte)(y >> 24);
Magic Number,MathNet.Numerics.RandomSources,MersenneTwisterRandomSource,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\MersenneTwisterRandomSource.cs,NextBytes,The following statement contains a magic number: i < buffer.Length - 3
Magic Number,MathNet.Numerics.RandomSources,MersenneTwisterRandomSource,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\MersenneTwisterRandomSource.cs,NextBytes,The following statement contains a magic number: y ^= (y >> 11);
Magic Number,MathNet.Numerics.RandomSources,MersenneTwisterRandomSource,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\MersenneTwisterRandomSource.cs,NextBytes,The following statement contains a magic number: y ^= (y << 7) & 0x9d2c5680U;
Magic Number,MathNet.Numerics.RandomSources,MersenneTwisterRandomSource,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\MersenneTwisterRandomSource.cs,NextBytes,The following statement contains a magic number: y ^= (y << 15) & 0xefc60000U;
Magic Number,MathNet.Numerics.RandomSources,MersenneTwisterRandomSource,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\MersenneTwisterRandomSource.cs,NextBytes,The following statement contains a magic number: y ^= (y >> 18);
Magic Number,MathNet.Numerics.RandomSources,MersenneTwisterRandomSource,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\MersenneTwisterRandomSource.cs,NextBytes,The following statement contains a magic number: buffer[i++] = (byte)(y >> 8);
Magic Number,MathNet.Numerics.RandomSources,MersenneTwisterRandomSource,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\MersenneTwisterRandomSource.cs,NextBytes,The following statement contains a magic number: buffer[i++] = (byte)(y >> 16);
Magic Number,MathNet.Numerics.RandomSources,MersenneTwisterRandomSource,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\MersenneTwisterRandomSource.cs,NextBytes,The following statement contains a magic number: buffer[i] = (byte)(y >> 24);
Magic Number,MathNet.Numerics.RandomSources,RandomSource,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\RandomSource.cs,NextDecimal,The following statement contains a magic number: candidate = new decimal(                      NextFullRangeInt32()'                      NextFullRangeInt32()'                      NextFullRangeInt32()'                      false'                      28);
Magic Number,MathNet.Numerics.RandomSources,SystemRandomSource,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\SystemRandomSource.cs,NextBoolean,The following statement contains a magic number: _bitCount = 30;
Magic Number,MathNet.Numerics.RandomSources,XorShiftRandomSource,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\XorShiftRandomSource.cs,NextFullRangeInt32,The following statement contains a magic number: uint t = (_x ^ (_x << 11));
Magic Number,MathNet.Numerics.RandomSources,XorShiftRandomSource,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\XorShiftRandomSource.cs,NextFullRangeInt32,The following statement contains a magic number: _w = (_w ^ (_w >> 19)) ^ (t ^ (t >> 8));
Magic Number,MathNet.Numerics.RandomSources,XorShiftRandomSource,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\XorShiftRandomSource.cs,NextFullRangeInt32,The following statement contains a magic number: _w = (_w ^ (_w >> 19)) ^ (t ^ (t >> 8));
Magic Number,MathNet.Numerics.RandomSources,XorShiftRandomSource,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\XorShiftRandomSource.cs,NextFullRangeUInt32,The following statement contains a magic number: uint t = (_x ^ (_x << 11));
Magic Number,MathNet.Numerics.RandomSources,XorShiftRandomSource,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\XorShiftRandomSource.cs,NextFullRangeUInt32,The following statement contains a magic number: return _w = (_w ^ (_w >> 19)) ^ (t ^ (t >> 8));
Magic Number,MathNet.Numerics.RandomSources,XorShiftRandomSource,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\XorShiftRandomSource.cs,NextFullRangeUInt32,The following statement contains a magic number: return _w = (_w ^ (_w >> 19)) ^ (t ^ (t >> 8));
Magic Number,MathNet.Numerics.RandomSources,XorShiftRandomSource,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\XorShiftRandomSource.cs,NextInclusiveMaxValue,The following statement contains a magic number: uint t = (_x ^ (_x << 11));
Magic Number,MathNet.Numerics.RandomSources,XorShiftRandomSource,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\XorShiftRandomSource.cs,NextInclusiveMaxValue,The following statement contains a magic number: uint w = (_w = (_w ^ (_w >> 19)) ^ (t ^ (t >> 8)));
Magic Number,MathNet.Numerics.RandomSources,XorShiftRandomSource,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\XorShiftRandomSource.cs,NextInclusiveMaxValue,The following statement contains a magic number: uint w = (_w = (_w ^ (_w >> 19)) ^ (t ^ (t >> 8)));
Magic Number,MathNet.Numerics.RandomSources,XorShiftRandomSource,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\XorShiftRandomSource.cs,Next,The following statement contains a magic number: uint t = (_x ^ (_x << 11));
Magic Number,MathNet.Numerics.RandomSources,XorShiftRandomSource,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\XorShiftRandomSource.cs,Next,The following statement contains a magic number: uint w = (_w = (_w ^ (_w >> 19)) ^ (t ^ (t >> 8)));
Magic Number,MathNet.Numerics.RandomSources,XorShiftRandomSource,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\XorShiftRandomSource.cs,Next,The following statement contains a magic number: uint w = (_w = (_w ^ (_w >> 19)) ^ (t ^ (t >> 8)));
Magic Number,MathNet.Numerics.RandomSources,XorShiftRandomSource,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\XorShiftRandomSource.cs,Next,The following statement contains a magic number: uint t = (_x ^ (_x << 11));
Magic Number,MathNet.Numerics.RandomSources,XorShiftRandomSource,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\XorShiftRandomSource.cs,Next,The following statement contains a magic number: uint w = (_w = (_w ^ (_w >> 19)) ^ (t ^ (t >> 8)));
Magic Number,MathNet.Numerics.RandomSources,XorShiftRandomSource,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\XorShiftRandomSource.cs,Next,The following statement contains a magic number: uint w = (_w = (_w ^ (_w >> 19)) ^ (t ^ (t >> 8)));
Magic Number,MathNet.Numerics.RandomSources,XorShiftRandomSource,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\XorShiftRandomSource.cs,Next,The following statement contains a magic number: uint t = (_x ^ (_x << 11));
Magic Number,MathNet.Numerics.RandomSources,XorShiftRandomSource,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\XorShiftRandomSource.cs,Next,The following statement contains a magic number: uint w = (_w = (_w ^ (_w >> 19)) ^ (t ^ (t >> 8)));
Magic Number,MathNet.Numerics.RandomSources,XorShiftRandomSource,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\XorShiftRandomSource.cs,Next,The following statement contains a magic number: uint w = (_w = (_w ^ (_w >> 19)) ^ (t ^ (t >> 8)));
Magic Number,MathNet.Numerics.RandomSources,XorShiftRandomSource,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\XorShiftRandomSource.cs,NextDouble,The following statement contains a magic number: uint t = (_x ^ (_x << 11));
Magic Number,MathNet.Numerics.RandomSources,XorShiftRandomSource,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\XorShiftRandomSource.cs,NextDouble,The following statement contains a magic number: uint w = (_w = (_w ^ (_w >> 19)) ^ (t ^ (t >> 8)));
Magic Number,MathNet.Numerics.RandomSources,XorShiftRandomSource,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\XorShiftRandomSource.cs,NextDouble,The following statement contains a magic number: uint w = (_w = (_w ^ (_w >> 19)) ^ (t ^ (t >> 8)));
Magic Number,MathNet.Numerics.RandomSources,XorShiftRandomSource,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\XorShiftRandomSource.cs,NextDouble,The following statement contains a magic number: uint t = (_x ^ (_x << 11));
Magic Number,MathNet.Numerics.RandomSources,XorShiftRandomSource,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\XorShiftRandomSource.cs,NextDouble,The following statement contains a magic number: uint w = (_w = (_w ^ (_w >> 19)) ^ (t ^ (t >> 8)));
Magic Number,MathNet.Numerics.RandomSources,XorShiftRandomSource,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\XorShiftRandomSource.cs,NextDouble,The following statement contains a magic number: uint w = (_w = (_w ^ (_w >> 19)) ^ (t ^ (t >> 8)));
Magic Number,MathNet.Numerics.RandomSources,XorShiftRandomSource,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\XorShiftRandomSource.cs,NextDouble,The following statement contains a magic number: uint t = (_x ^ (_x << 11));
Magic Number,MathNet.Numerics.RandomSources,XorShiftRandomSource,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\XorShiftRandomSource.cs,NextDouble,The following statement contains a magic number: uint w = (_w = (_w ^ (_w >> 19)) ^ (t ^ (t >> 8)));
Magic Number,MathNet.Numerics.RandomSources,XorShiftRandomSource,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\XorShiftRandomSource.cs,NextDouble,The following statement contains a magic number: uint w = (_w = (_w ^ (_w >> 19)) ^ (t ^ (t >> 8)));
Magic Number,MathNet.Numerics.RandomSources,XorShiftRandomSource,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\XorShiftRandomSource.cs,NextBoolean,The following statement contains a magic number: uint t = (_x ^ (_x << 11));
Magic Number,MathNet.Numerics.RandomSources,XorShiftRandomSource,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\XorShiftRandomSource.cs,NextBoolean,The following statement contains a magic number: _bitBuffer = (_w = (_w ^ (_w >> 19)) ^ (t ^ (t >> 8)));
Magic Number,MathNet.Numerics.RandomSources,XorShiftRandomSource,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\XorShiftRandomSource.cs,NextBoolean,The following statement contains a magic number: _bitBuffer = (_w = (_w ^ (_w >> 19)) ^ (t ^ (t >> 8)));
Magic Number,MathNet.Numerics.RandomSources,XorShiftRandomSource,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\XorShiftRandomSource.cs,NextBoolean,The following statement contains a magic number: _bitCount = 31;
Magic Number,MathNet.Numerics.RandomSources,XorShiftRandomSource,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\XorShiftRandomSource.cs,NextBytes,The following statement contains a magic number: t = (x ^ (x << 11));
Magic Number,MathNet.Numerics.RandomSources,XorShiftRandomSource,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\XorShiftRandomSource.cs,NextBytes,The following statement contains a magic number: w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));
Magic Number,MathNet.Numerics.RandomSources,XorShiftRandomSource,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\XorShiftRandomSource.cs,NextBytes,The following statement contains a magic number: w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));
Magic Number,MathNet.Numerics.RandomSources,XorShiftRandomSource,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\XorShiftRandomSource.cs,NextBytes,The following statement contains a magic number: buffer[i++] = (byte)(w >> 8);
Magic Number,MathNet.Numerics.RandomSources,XorShiftRandomSource,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\XorShiftRandomSource.cs,NextBytes,The following statement contains a magic number: buffer[i++] = (byte)(w >> 16);
Magic Number,MathNet.Numerics.RandomSources,XorShiftRandomSource,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\XorShiftRandomSource.cs,NextBytes,The following statement contains a magic number: buffer[i++] = (byte)(w >> 24);
Magic Number,MathNet.Numerics.RandomSources,XorShiftRandomSource,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\XorShiftRandomSource.cs,NextBytes,The following statement contains a magic number: i < buffer.Length - 3
Magic Number,MathNet.Numerics.RandomSources,XorShiftRandomSource,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\XorShiftRandomSource.cs,NextBytes,The following statement contains a magic number: t = (x ^ (x << 11));
Magic Number,MathNet.Numerics.RandomSources,XorShiftRandomSource,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\XorShiftRandomSource.cs,NextBytes,The following statement contains a magic number: w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));
Magic Number,MathNet.Numerics.RandomSources,XorShiftRandomSource,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\XorShiftRandomSource.cs,NextBytes,The following statement contains a magic number: w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));
Magic Number,MathNet.Numerics.RandomSources,XorShiftRandomSource,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\XorShiftRandomSource.cs,NextBytes,The following statement contains a magic number: buffer[i++] = (byte)(w >> 8);
Magic Number,MathNet.Numerics.RandomSources,XorShiftRandomSource,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\XorShiftRandomSource.cs,NextBytes,The following statement contains a magic number: buffer[i++] = (byte)(w >> 16);
Magic Number,MathNet.Numerics.RandomSources,XorShiftRandomSource,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\XorShiftRandomSource.cs,NextBytes,The following statement contains a magic number: buffer[i] = (byte)(w >> 24);
Magic Number,MathNet.Numerics.RandomSources.ObjectModel,RandomByteSourceAdapter,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\ObjectModel\RandomByteSourceAdapter.cs,NextBoolean,The following statement contains a magic number: _bitCount = 30;
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,BetaRegularizedAlgorithm,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\BetaRegularizedAlgorithm.cs,BetaRegularized,The following statement contains a magic number: bool symmetryTransformation = (x >= (a + 1.0) / (a + b + 2.0));
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,BetaRegularizedAlgorithm,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\BetaRegularizedAlgorithm.cs,BetaRegularized,The following statement contains a magic number: const int MaxIterations = 100;
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,DigammaAlgorithm,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\DigammaAlgorithm.cs,Digamma,The following statement contains a magic number: nz > 0.5
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,DigammaAlgorithm,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\DigammaAlgorithm.cs,Digamma,The following statement contains a magic number: nz != 0.5
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,DigammaAlgorithm,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\DigammaAlgorithm.cs,Digamma,The following statement contains a magic number: (x <= 10.0) && (x == Math.Floor(x))
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,ErrorFunctionAlgorithm,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\ErrorFunctionAlgorithm.cs,Erf,The following statement contains a magic number: return x < 0.0                  ? -GammaRegularizedAlgorithm.GammaRegularized(0.5' x * x)                  : GammaRegularizedAlgorithm.GammaRegularized(0.5' x * x);
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,ErrorFunctionAlgorithm,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\ErrorFunctionAlgorithm.cs,Erf,The following statement contains a magic number: return x < 0.0                  ? -GammaRegularizedAlgorithm.GammaRegularized(0.5' x * x)                  : GammaRegularizedAlgorithm.GammaRegularized(0.5' x * x);
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,ErrorFunctionAlgorithm,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\ErrorFunctionAlgorithm.cs,ErfInverse,The following statement contains a magic number: x = 0.5 * (x + 1.0);
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,ErrorFunctionAlgorithm,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\ErrorFunctionAlgorithm.cs,ErfInverse,The following statement contains a magic number: const double Plow = 0.02425;
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,ErrorFunctionAlgorithm,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\ErrorFunctionAlgorithm.cs,ErfInverse,The following statement contains a magic number: q = Math.Sqrt(-2 * Math.Log(x));
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,ErrorFunctionAlgorithm,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\ErrorFunctionAlgorithm.cs,ErfInverse,The following statement contains a magic number: return ((((((((((ErfInvC[0] * q) + ErfInvC[1]) * q) + ErfInvC[2]) * q) + ErfInvC[3]) * q) + ErfInvC[4]) * q) + ErfInvC[5]) /                      ((((((((ErfInvD[0] * q) + ErfInvD[1]) * q) + ErfInvD[2]) * q) + ErfInvD[3]) * q) + 1)                      * Constants.Sqrt1_2;
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,ErrorFunctionAlgorithm,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\ErrorFunctionAlgorithm.cs,ErfInverse,The following statement contains a magic number: return ((((((((((ErfInvC[0] * q) + ErfInvC[1]) * q) + ErfInvC[2]) * q) + ErfInvC[3]) * q) + ErfInvC[4]) * q) + ErfInvC[5]) /                      ((((((((ErfInvD[0] * q) + ErfInvD[1]) * q) + ErfInvD[2]) * q) + ErfInvD[3]) * q) + 1)                      * Constants.Sqrt1_2;
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,ErrorFunctionAlgorithm,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\ErrorFunctionAlgorithm.cs,ErfInverse,The following statement contains a magic number: return ((((((((((ErfInvC[0] * q) + ErfInvC[1]) * q) + ErfInvC[2]) * q) + ErfInvC[3]) * q) + ErfInvC[4]) * q) + ErfInvC[5]) /                      ((((((((ErfInvD[0] * q) + ErfInvD[1]) * q) + ErfInvD[2]) * q) + ErfInvD[3]) * q) + 1)                      * Constants.Sqrt1_2;
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,ErrorFunctionAlgorithm,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\ErrorFunctionAlgorithm.cs,ErfInverse,The following statement contains a magic number: return ((((((((((ErfInvC[0] * q) + ErfInvC[1]) * q) + ErfInvC[2]) * q) + ErfInvC[3]) * q) + ErfInvC[4]) * q) + ErfInvC[5]) /                      ((((((((ErfInvD[0] * q) + ErfInvD[1]) * q) + ErfInvD[2]) * q) + ErfInvD[3]) * q) + 1)                      * Constants.Sqrt1_2;
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,ErrorFunctionAlgorithm,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\ErrorFunctionAlgorithm.cs,ErfInverse,The following statement contains a magic number: return ((((((((((ErfInvC[0] * q) + ErfInvC[1]) * q) + ErfInvC[2]) * q) + ErfInvC[3]) * q) + ErfInvC[4]) * q) + ErfInvC[5]) /                      ((((((((ErfInvD[0] * q) + ErfInvD[1]) * q) + ErfInvD[2]) * q) + ErfInvD[3]) * q) + 1)                      * Constants.Sqrt1_2;
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,ErrorFunctionAlgorithm,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\ErrorFunctionAlgorithm.cs,ErfInverse,The following statement contains a magic number: return ((((((((((ErfInvC[0] * q) + ErfInvC[1]) * q) + ErfInvC[2]) * q) + ErfInvC[3]) * q) + ErfInvC[4]) * q) + ErfInvC[5]) /                      ((((((((ErfInvD[0] * q) + ErfInvD[1]) * q) + ErfInvD[2]) * q) + ErfInvD[3]) * q) + 1)                      * Constants.Sqrt1_2;
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,ErrorFunctionAlgorithm,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\ErrorFunctionAlgorithm.cs,ErfInverse,The following statement contains a magic number: q = Math.Sqrt(-2 * Math.Log(1 - x));
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,ErrorFunctionAlgorithm,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\ErrorFunctionAlgorithm.cs,ErfInverse,The following statement contains a magic number: return -((((((((((ErfInvC[0] * q) + ErfInvC[1]) * q) + ErfInvC[2]) * q) + ErfInvC[3]) * q) + ErfInvC[4]) * q) + ErfInvC[5]) /                      ((((((((ErfInvD[0] * q) + ErfInvD[1]) * q) + ErfInvD[2]) * q) + ErfInvD[3]) * q) + 1)                      * Constants.Sqrt1_2;
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,ErrorFunctionAlgorithm,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\ErrorFunctionAlgorithm.cs,ErfInverse,The following statement contains a magic number: return -((((((((((ErfInvC[0] * q) + ErfInvC[1]) * q) + ErfInvC[2]) * q) + ErfInvC[3]) * q) + ErfInvC[4]) * q) + ErfInvC[5]) /                      ((((((((ErfInvD[0] * q) + ErfInvD[1]) * q) + ErfInvD[2]) * q) + ErfInvD[3]) * q) + 1)                      * Constants.Sqrt1_2;
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,ErrorFunctionAlgorithm,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\ErrorFunctionAlgorithm.cs,ErfInverse,The following statement contains a magic number: return -((((((((((ErfInvC[0] * q) + ErfInvC[1]) * q) + ErfInvC[2]) * q) + ErfInvC[3]) * q) + ErfInvC[4]) * q) + ErfInvC[5]) /                      ((((((((ErfInvD[0] * q) + ErfInvD[1]) * q) + ErfInvD[2]) * q) + ErfInvD[3]) * q) + 1)                      * Constants.Sqrt1_2;
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,ErrorFunctionAlgorithm,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\ErrorFunctionAlgorithm.cs,ErfInverse,The following statement contains a magic number: return -((((((((((ErfInvC[0] * q) + ErfInvC[1]) * q) + ErfInvC[2]) * q) + ErfInvC[3]) * q) + ErfInvC[4]) * q) + ErfInvC[5]) /                      ((((((((ErfInvD[0] * q) + ErfInvD[1]) * q) + ErfInvD[2]) * q) + ErfInvD[3]) * q) + 1)                      * Constants.Sqrt1_2;
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,ErrorFunctionAlgorithm,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\ErrorFunctionAlgorithm.cs,ErfInverse,The following statement contains a magic number: return -((((((((((ErfInvC[0] * q) + ErfInvC[1]) * q) + ErfInvC[2]) * q) + ErfInvC[3]) * q) + ErfInvC[4]) * q) + ErfInvC[5]) /                      ((((((((ErfInvD[0] * q) + ErfInvD[1]) * q) + ErfInvD[2]) * q) + ErfInvD[3]) * q) + 1)                      * Constants.Sqrt1_2;
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,ErrorFunctionAlgorithm,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\ErrorFunctionAlgorithm.cs,ErfInverse,The following statement contains a magic number: return -((((((((((ErfInvC[0] * q) + ErfInvC[1]) * q) + ErfInvC[2]) * q) + ErfInvC[3]) * q) + ErfInvC[4]) * q) + ErfInvC[5]) /                      ((((((((ErfInvD[0] * q) + ErfInvD[1]) * q) + ErfInvD[2]) * q) + ErfInvD[3]) * q) + 1)                      * Constants.Sqrt1_2;
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,ErrorFunctionAlgorithm,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\ErrorFunctionAlgorithm.cs,ErfInverse,The following statement contains a magic number: q = x - 0.5;
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,ErrorFunctionAlgorithm,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\ErrorFunctionAlgorithm.cs,ErfInverse,The following statement contains a magic number: return ((((((((((ErfInvA[0] * r) + ErfInvA[1]) * r) + ErfInvA[2]) * r) + ErfInvA[3]) * r) + ErfInvA[4]) * r) + ErfInvA[5]) * q /                  ((((((((((ErfInvB[0] * r) + ErfInvB[1]) * r) + ErfInvB[2]) * r) + ErfInvB[3]) * r) + ErfInvB[4]) * r) + 1)                  * Constants.Sqrt1_2;
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,ErrorFunctionAlgorithm,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\ErrorFunctionAlgorithm.cs,ErfInverse,The following statement contains a magic number: return ((((((((((ErfInvA[0] * r) + ErfInvA[1]) * r) + ErfInvA[2]) * r) + ErfInvA[3]) * r) + ErfInvA[4]) * r) + ErfInvA[5]) * q /                  ((((((((((ErfInvB[0] * r) + ErfInvB[1]) * r) + ErfInvB[2]) * r) + ErfInvB[3]) * r) + ErfInvB[4]) * r) + 1)                  * Constants.Sqrt1_2;
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,ErrorFunctionAlgorithm,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\ErrorFunctionAlgorithm.cs,ErfInverse,The following statement contains a magic number: return ((((((((((ErfInvA[0] * r) + ErfInvA[1]) * r) + ErfInvA[2]) * r) + ErfInvA[3]) * r) + ErfInvA[4]) * r) + ErfInvA[5]) * q /                  ((((((((((ErfInvB[0] * r) + ErfInvB[1]) * r) + ErfInvB[2]) * r) + ErfInvB[3]) * r) + ErfInvB[4]) * r) + 1)                  * Constants.Sqrt1_2;
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,ErrorFunctionAlgorithm,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\ErrorFunctionAlgorithm.cs,ErfInverse,The following statement contains a magic number: return ((((((((((ErfInvA[0] * r) + ErfInvA[1]) * r) + ErfInvA[2]) * r) + ErfInvA[3]) * r) + ErfInvA[4]) * r) + ErfInvA[5]) * q /                  ((((((((((ErfInvB[0] * r) + ErfInvB[1]) * r) + ErfInvB[2]) * r) + ErfInvB[3]) * r) + ErfInvB[4]) * r) + 1)                  * Constants.Sqrt1_2;
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,ErrorFunctionAlgorithm,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\ErrorFunctionAlgorithm.cs,ErfInverse,The following statement contains a magic number: return ((((((((((ErfInvA[0] * r) + ErfInvA[1]) * r) + ErfInvA[2]) * r) + ErfInvA[3]) * r) + ErfInvA[4]) * r) + ErfInvA[5]) * q /                  ((((((((((ErfInvB[0] * r) + ErfInvB[1]) * r) + ErfInvB[2]) * r) + ErfInvB[3]) * r) + ErfInvB[4]) * r) + 1)                  * Constants.Sqrt1_2;
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,ErrorFunctionAlgorithm,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\ErrorFunctionAlgorithm.cs,ErfInverse,The following statement contains a magic number: return ((((((((((ErfInvA[0] * r) + ErfInvA[1]) * r) + ErfInvA[2]) * r) + ErfInvA[3]) * r) + ErfInvA[4]) * r) + ErfInvA[5]) * q /                  ((((((((((ErfInvB[0] * r) + ErfInvB[1]) * r) + ErfInvB[2]) * r) + ErfInvB[3]) * r) + ErfInvB[4]) * r) + 1)                  * Constants.Sqrt1_2;
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,ErrorFunctionAlgorithm,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\ErrorFunctionAlgorithm.cs,ErfInverse,The following statement contains a magic number: return ((((((((((ErfInvA[0] * r) + ErfInvA[1]) * r) + ErfInvA[2]) * r) + ErfInvA[3]) * r) + ErfInvA[4]) * r) + ErfInvA[5]) * q /                  ((((((((((ErfInvB[0] * r) + ErfInvB[1]) * r) + ErfInvB[2]) * r) + ErfInvB[3]) * r) + ErfInvB[4]) * r) + 1)                  * Constants.Sqrt1_2;
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,GammaAlgorithm,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\GammaAlgorithm.cs,GammaLn,The following statement contains a magic number: x < -34.0
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,GammaAlgorithm,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\GammaAlgorithm.cs,GammaLn,The following statement contains a magic number: x < 13
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,GammaAlgorithm,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\GammaAlgorithm.cs,GammaLnSmall,The following statement contains a magic number: normalized >= 3
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,GammaAlgorithm,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\GammaAlgorithm.cs,GammaLnSmall,The following statement contains a magic number: normalized < 2
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,GammaAlgorithm,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\GammaAlgorithm.cs,GammaLnSmall,The following statement contains a magic number: normalized == 2
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,GammaAlgorithm,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\GammaAlgorithm.cs,GammaLnSmall,The following statement contains a magic number: x = x + offset - 2;
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,GammaAlgorithm,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\GammaAlgorithm.cs,GammaLnSmall,The following statement contains a magic number: double b = -1378.25152569120859100;
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,GammaAlgorithm,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\GammaAlgorithm.cs,GammaLnSmall,The following statement contains a magic number: b = -38801.6315134637840924 + (x * b);
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,GammaAlgorithm,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\GammaAlgorithm.cs,GammaLnSmall,The following statement contains a magic number: b = -331612.992738871184744 + (x * b);
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,GammaAlgorithm,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\GammaAlgorithm.cs,GammaLnSmall,The following statement contains a magic number: b = -1162370.97492762307383 + (x * b);
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,GammaAlgorithm,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\GammaAlgorithm.cs,GammaLnSmall,The following statement contains a magic number: b = -1721737.00820839662146 + (x * b);
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,GammaAlgorithm,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\GammaAlgorithm.cs,GammaLnSmall,The following statement contains a magic number: b = -853555.664245765465627 + (x * b);
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,GammaAlgorithm,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\GammaAlgorithm.cs,GammaLnSmall,The following statement contains a magic number: c = -351.815701436523470549 + (x * c);
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,GammaAlgorithm,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\GammaAlgorithm.cs,GammaLnSmall,The following statement contains a magic number: c = -17064.2106651881159223 + (x * c);
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,GammaAlgorithm,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\GammaAlgorithm.cs,GammaLnSmall,The following statement contains a magic number: c = -220528.590553854454839 + (x * c);
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,GammaAlgorithm,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\GammaAlgorithm.cs,GammaLnSmall,The following statement contains a magic number: c = -1139334.44367982507207 + (x * c);
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,GammaAlgorithm,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\GammaAlgorithm.cs,GammaLnSmall,The following statement contains a magic number: c = -2532523.07177582951285 + (x * c);
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,GammaAlgorithm,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\GammaAlgorithm.cs,GammaLnSmall,The following statement contains a magic number: c = -2018891.41433532773231 + (x * c);
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,GammaAlgorithm,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\GammaAlgorithm.cs,GammaLnLargePositive,The following statement contains a magic number: double q = ((x - 0.5) * Math.Log(x)) - x + Constants.Ln2Pi_2;
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,GammaAlgorithm,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\GammaAlgorithm.cs,GammaLnLargePositive,The following statement contains a magic number: x > 100000000
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,GammaAlgorithm,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\GammaAlgorithm.cs,GammaLnLargePositive,The following statement contains a magic number: double a = 7.9365079365079365079365e-4;
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,GammaAlgorithm,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\GammaAlgorithm.cs,GammaLnLargePositive,The following statement contains a magic number: a = -2.7777777777777777777778e-3 + (p * a);
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,GammaAlgorithm,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\GammaAlgorithm.cs,GammaLnLargePositive,The following statement contains a magic number: a = 0.0833333333333333333333 + (p * a);
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,GammaAlgorithm,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\GammaAlgorithm.cs,GammaLnLargePositive,The following statement contains a magic number: x >= 1000.0
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,GammaAlgorithm,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\GammaAlgorithm.cs,GammaLnLargePositive,The following statement contains a magic number: double b = 8.11614167470508450300e-4;
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,GammaAlgorithm,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\GammaAlgorithm.cs,GammaLnLargePositive,The following statement contains a magic number: b = -5.95061904284301438324e-4 + (p * b);
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,GammaAlgorithm,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\GammaAlgorithm.cs,GammaLnLargePositive,The following statement contains a magic number: b = 7.93650340457716943945e-4 + (p * b);
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,GammaAlgorithm,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\GammaAlgorithm.cs,GammaLnLargePositive,The following statement contains a magic number: b = -2.77777777730099687205e-3 + (p * b);
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,GammaAlgorithm,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\GammaAlgorithm.cs,GammaLnLargePositive,The following statement contains a magic number: b = 8.33333333333331927722e-2 + (p * b);
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,GammaRegularizedAlgorithm,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\GammaRegularizedAlgorithm.cs,GammaRegularized,The following statement contains a magic number: const double Epsilon = 0.000000000000001;
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,GammaRegularizedAlgorithm,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\GammaRegularizedAlgorithm.cs,GammaRegularized,The following statement contains a magic number: const double BigNumber = 4503599627370496.0;
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,GammaRegularizedAlgorithm,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\GammaRegularizedAlgorithm.cs,GammaRegularized,The following statement contains a magic number: const double BigNumberInverse = 2.22044604925031308085e-16;
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,GammaRegularizedAlgorithm,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\GammaRegularizedAlgorithm.cs,GammaRegularized,The following statement contains a magic number: ax < -709.78271289338399
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,GammaRegularizedAlgorithm,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\GammaRegularizedAlgorithm.cs,GammaRegularized,The following statement contains a magic number: z += 2;
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,GammaRegularizedAlgorithm,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\GammaRegularizedAlgorithm.cs,GammaRegularizedInverse,The following statement contains a magic number: const double Epsilon = 0.000000000000001;
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,GammaRegularizedAlgorithm,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\GammaRegularizedAlgorithm.cs,GammaRegularizedInverse,The following statement contains a magic number: const double BigNumber = 4503599627370496.0;
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,GammaRegularizedAlgorithm,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\GammaRegularizedAlgorithm.cs,GammaRegularizedInverse,The following statement contains a magic number: const double Threshold = 5 * Epsilon;
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,GammaRegularizedAlgorithm,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\GammaRegularizedAlgorithm.cs,GammaRegularizedInverse,The following statement contains a magic number: double d = 1 / (9 * a);
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,GammaRegularizedAlgorithm,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\GammaRegularizedAlgorithm.cs,GammaRegularizedInverse,The following statement contains a magic number: double y = 1 - d - (0.98 * Constants.Sqrt2 * ErrorFunctionAlgorithm.ErfInverse((2.0 * y0) - 1.0) * Math.Sqrt(d));
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,GammaRegularizedAlgorithm,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\GammaRegularizedAlgorithm.cs,GammaRegularizedInverse,The following statement contains a magic number: double y = 1 - d - (0.98 * Constants.Sqrt2 * ErrorFunctionAlgorithm.ErfInverse((2.0 * y0) - 1.0) * Math.Sqrt(d));
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,GammaRegularizedAlgorithm,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\GammaRegularizedAlgorithm.cs,GammaRegularizedInverse,The following statement contains a magic number: d = 0.0625;
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,GammaRegularizedAlgorithm,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\GammaRegularizedAlgorithm.cs,GammaRegularizedInverse,The following statement contains a magic number: d = 0.0625;
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,GammaRegularizedAlgorithm,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\GammaRegularizedAlgorithm.cs,GammaRegularizedInverse,The following statement contains a magic number: d = 0.0625;
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,GammaRegularizedAlgorithm,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\GammaRegularizedAlgorithm.cs,GammaRegularizedInverse,The following statement contains a magic number: d < -709.78271289338399
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,GammaRegularizedAlgorithm,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\GammaRegularizedAlgorithm.cs,GammaRegularizedInverse,The following statement contains a magic number: d = x / 10;
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,GammaRegularizedAlgorithm,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\GammaRegularizedAlgorithm.cs,GammaRegularizedInverse,The following statement contains a magic number: (d > (x / 4)) && (y0 < 0.05)
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,GammaRegularizedAlgorithm,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\GammaRegularizedAlgorithm.cs,GammaRegularizedInverse,The following statement contains a magic number: (d > (x / 4)) && (y0 < 0.05)
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,GammaRegularizedAlgorithm,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\GammaRegularizedAlgorithm.cs,GammaRegularizedInverse,The following statement contains a magic number: i < 10
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,GammaRegularizedAlgorithm,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\GammaRegularizedAlgorithm.cs,GammaRegularizedInverse,The following statement contains a magic number: d = 0.5;
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,GammaRegularizedAlgorithm,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\GammaRegularizedAlgorithm.cs,GammaRegularizedInverse,The following statement contains a magic number: d = 0.5;
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,GammaRegularizedAlgorithm,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\GammaRegularizedAlgorithm.cs,GammaRegularizedInverse,The following statement contains a magic number: i < 400
Magic Number,MathNet.Numerics.Statistics,DescriptiveStatistics,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Statistics\DescriptiveStatistics.cs,Median,The following statement contains a magic number: int lowerMidpoint = list.Count / 2;
Magic Number,MathNet.Numerics.Statistics,DescriptiveStatistics,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Statistics\DescriptiveStatistics.cs,UpperMedian,The following statement contains a magic number: int lowerMidpoint = IntegerTheory.IsEven(list.Count) ? ((list.Count / 2) + 1) : (list.Count / 2);
Magic Number,MathNet.Numerics.Statistics,DescriptiveStatistics,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Statistics\DescriptiveStatistics.cs,UpperMedian,The following statement contains a magic number: int lowerMidpoint = IntegerTheory.IsEven(list.Count) ? ((list.Count / 2) + 1) : (list.Count / 2);
Magic Number,MathNet.Numerics.Statistics,Histogram,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Statistics\Histogram.cs,JoinBuckets,The following statement contains a magic number: u.UpperBound = v.LowerBound = (u.UpperBound + v.LowerBound) / 2;
Magic Number,MathNet.Numerics.Statistics,Histogram,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Statistics\Histogram.cs,JoinBuckets,The following statement contains a magic number: i < _buckets.Count - 2
Magic Number,MathNet.Numerics.Statistics,Histogram,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Statistics\Histogram.cs,OptimalDispersion,The following statement contains a magic number: distribution.Count < Math.Max(bucketCount' 2)
Magic Number,MathNet.Numerics.Statistics,Histogram,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Statistics\Histogram.cs,OptimalDispersion,The following statement contains a magic number: optimalCost[i' 0] =                      prefixSum[i + 1]                      - (2 * prefixSum[avg + 1])                      + (((2 * avg) - i + 1) * (prefixSum[i + 1] / (i + 1)));
Magic Number,MathNet.Numerics.Statistics,Histogram,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Statistics\Histogram.cs,OptimalDispersion,The following statement contains a magic number: optimalCost[i' 0] =                      prefixSum[i + 1]                      - (2 * prefixSum[avg + 1])                      + (((2 * avg) - i + 1) * (prefixSum[i + 1] / (i + 1)));
Magic Number,MathNet.Numerics.Statistics,Histogram,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Statistics\Histogram.cs,OptimalDispersion,The following statement contains a magic number: double currentCost =                              optimalCost[j' k - 1]                              + prefixSum[i + 1]                              + prefixSum[j + 1]                              - (2 * prefixSum[avg + 1])                              + (((2 * avg) - i - j) * (prefixSum[i + 1] - prefixSum[j + 1]) / (i - j));
Magic Number,MathNet.Numerics.Statistics,Histogram,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Statistics\Histogram.cs,OptimalDispersion,The following statement contains a magic number: double currentCost =                              optimalCost[j' k - 1]                              + prefixSum[i + 1]                              + prefixSum[j + 1]                              - (2 * prefixSum[avg + 1])                              + (((2 * avg) - i - j) * (prefixSum[i + 1] - prefixSum[j + 1]) / (i - j));
Magic Number,MathNet.Numerics.Statistics,Histogram,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Statistics\Histogram.cs,OptimalFreedom,The following statement contains a magic number: distribution.Count < Math.Max(bucketCount' 2)
Magic Number,MathNet.Numerics.Statistics,Histogram,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Statistics\Histogram.cs,OptimalSquaredFreedom,The following statement contains a magic number: distribution.Count < Math.Max(histSize' 2)
Magic Number,MathNet.Numerics.Transformations,ComplexFourierTransformation,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Transformations\ComplexFourierTransformation.cs,GenerateFrequencyScale,The following statement contains a magic number: f = -step * (secondHalf - 2);
Magic Number,MathNet.Numerics.Transformations,InternalFFT,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Transformations\InternalFFT.cs,ReorderSamples,The following statement contains a magic number: int a = 2 * i' b = 2 * swap;
Magic Number,MathNet.Numerics.Transformations,InternalFFT,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Transformations\InternalFFT.cs,ReorderSamples,The following statement contains a magic number: int a = 2 * i' b = 2 * swap;
Magic Number,MathNet.Numerics.Transformations,InternalFFT,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Transformations\InternalFFT.cs,DanielsonLanczosTransform,The following statement contains a magic number: int n = 2;
Magic Number,MathNet.Numerics.Transformations,InternalFFT,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Transformations\InternalFFT.cs,Rescale,The following statement contains a magic number: double factor = 2.0 / samples.Length;
Magic Number,MathNet.Numerics.Transformations,RealFourierTransformation,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Transformations\RealFourierTransformation.cs,GenerateFrequencyScale,The following statement contains a magic number: f = -step * (secondHalf - 2);
Magic Number,MathNet.Numerics.Transformations,RealFourierTransformation,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Transformations\RealFourierTransformation.cs,TransformForward,The following statement contains a magic number: double h1Real = 0.5 * (complex[j] + complex[length - j]);
Magic Number,MathNet.Numerics.Transformations,RealFourierTransformation,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Transformations\RealFourierTransformation.cs,TransformForward,The following statement contains a magic number: double h1Imag = 0.5 * (complex[j + 1] - complex[length + 1 - j]);
Magic Number,MathNet.Numerics.Transformations,RealFourierTransformation,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Transformations\RealFourierTransformation.cs,TransformForward,The following statement contains a magic number: double h2Real = 0.5 * (complex[j + 1] + complex[length + 1 - j]);
Magic Number,MathNet.Numerics.Transformations,RealFourierTransformation,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Transformations\RealFourierTransformation.cs,TransformForward,The following statement contains a magic number: double h2Imag = -0.5 * (complex[j] - complex[length - j]);
Magic Number,MathNet.Numerics.Transformations,RealFourierTransformation,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Transformations\RealFourierTransformation.cs,TransformForward,The following statement contains a magic number: double wtemp = Trig.Sine(0.5 * theta);
Magic Number,MathNet.Numerics.Transformations,RealFourierTransformation,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Transformations\RealFourierTransformation.cs,TransformForward,The following statement contains a magic number: double wpr = -2.0 * wtemp * wtemp;
Magic Number,MathNet.Numerics.Transformations,RealFourierTransformation,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Transformations\RealFourierTransformation.cs,TransformForward,The following statement contains a magic number: double h1Real = 0.5 * (complex[j] + complex[length - j]);
Magic Number,MathNet.Numerics.Transformations,RealFourierTransformation,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Transformations\RealFourierTransformation.cs,TransformForward,The following statement contains a magic number: double h1Imag = 0.5 * (complex[j + 1] - complex[length + 1 - j]);
Magic Number,MathNet.Numerics.Transformations,RealFourierTransformation,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Transformations\RealFourierTransformation.cs,TransformForward,The following statement contains a magic number: double h2Real = 0.5 * (complex[j + 1] + complex[length + 1 - j]);
Magic Number,MathNet.Numerics.Transformations,RealFourierTransformation,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Transformations\RealFourierTransformation.cs,TransformForward,The following statement contains a magic number: double h2Imag = -0.5 * (complex[j] - complex[length - j]);
Magic Number,MathNet.Numerics.Transformations,RealFourierTransformation,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Transformations\RealFourierTransformation.cs,TransformBackward,The following statement contains a magic number: double wtemp = Trig.Sine(0.5 * theta);
Magic Number,MathNet.Numerics.Transformations,RealFourierTransformation,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Transformations\RealFourierTransformation.cs,TransformBackward,The following statement contains a magic number: double wpr = -2.0 * wtemp * wtemp;
Magic Number,MathNet.Numerics.Transformations,RealFourierTransformation,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Transformations\RealFourierTransformation.cs,TransformBackward,The following statement contains a magic number: samples[1] = 0.5 * (fftReal[0] - fftReal[numSamples]);
Magic Number,MathNet.Numerics.Transformations,RealFourierTransformation,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Transformations\RealFourierTransformation.cs,TransformBackward,The following statement contains a magic number: samples[0] = 0.5 * (fftReal[0] + fftReal[numSamples]);
Magic Number,MathNet.Numerics.Transformations,RealFourierTransformation,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Transformations\RealFourierTransformation.cs,TransformBackward,The following statement contains a magic number: double h1Real = 0.5 * (fftReal[i] + fftReal[numSamples - i]);
Magic Number,MathNet.Numerics.Transformations,RealFourierTransformation,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Transformations\RealFourierTransformation.cs,TransformBackward,The following statement contains a magic number: double h1Imag = 0.5 * (fftImag[i] - fftImag[numSamples - i]);
Magic Number,MathNet.Numerics.Transformations,RealFourierTransformation,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Transformations\RealFourierTransformation.cs,TransformBackward,The following statement contains a magic number: double h2Real = -0.5 * (fftImag[i] + fftImag[numSamples - i]);
Magic Number,MathNet.Numerics.Transformations,RealFourierTransformation,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Transformations\RealFourierTransformation.cs,TransformBackward,The following statement contains a magic number: double h2Imag = 0.5 * (fftReal[i] - fftReal[numSamples - i]);
Missing Default,MathNet.Numerics.LinearAlgebra,SingularValueDecomposition,D:\research\architectureSmells\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\LinearAlgebra\SingularValueDecomposition.cs,SingularValueDecomposition,The following switch statement is missing a default case: switch(step)                  {                      // Deflate negligible s(p).                      case IterationStep.DeflateNeglible:                          {                              double f = e[p - 2];                              e[p - 2] = 0.0;                              for(int j = p - 2; j >= k; j--)                              {                                  double t = Fn.Hypot(s[j]' f);                                  double cs = s[j] / t;                                  double sn = f / t;                                  s[j] = t;                                    if(j != k)                                  {                                      f = (-sn) * e[j - 1];                                      e[j - 1] = cs * e[j - 1];                                  }                                    for(int i = 0; i < _n; i++)                                  {                                      t = (cs * v[i][j]) + (sn * v[i][p - 1]);                                      v[i][p - 1] = ((-sn) * v[i][j]) + (cs * v[i][p - 1]);                                      v[i][j] = t;                                  }                              }                          }                            break;                        // Split at negligible s(k)                      case IterationStep.SplitAtNeglible:                          {                              double f = e[k - 1];                              e[k - 1] = 0.0;                              for(int j = k; j < p; j++)                              {                                  double t = Fn.Hypot(s[j]' f);                                  double cs = s[j] / t;                                  double sn = f / t;                                  s[j] = t;                                  f = (-sn) * e[j];                                  e[j] = cs * e[j];                                    for(int i = 0; i < _m; i++)                                  {                                      t = (cs * u[i][j]) + (sn * u[i][k - 1]);                                      u[i][k - 1] = ((-sn) * u[i][j]) + (cs * u[i][k - 1]);                                      u[i][j] = t;                                  }                              }                          }                            break;                        // Perform one qr step.                      case IterationStep.QR:                          {                              /* Calculate the shift */                                double scale = Math.Max(Math.Max(Math.Max(Math.Max(Math.Abs(s[p - 1])' Math.Abs(s[p - 2]))' Math.Abs(e[p - 2]))' Math.Abs(s[k]))' Math.Abs(e[k]));                              double sp = s[p - 1] / scale;                              double spm1 = s[p - 2] / scale;                              double epm1 = e[p - 2] / scale;                              double sk = s[k] / scale;                              double ek = e[k] / scale;                              double b = (((spm1 + sp) * (spm1 - sp)) + (epm1 * epm1)) / 2.0;                              double c = (sp * epm1) * (sp * epm1);                              double shift = 0.0;                              if((b != 0.0) | (c != 0.0))                              {                                  shift = Math.Sqrt((b * b) + c);                                    if(b < 0.0)                                  {                                      shift = -shift;                                  }                                    shift = c / (b + shift);                              }                                double f = ((sk + sp) * (sk - sp)) + shift;                              double g = sk * ek;                                /* Chase zeros */                                for(int j = k; j < p - 1; j++)                              {                                  double t = Fn.Hypot(f' g);                                  double cs = f / t;                                  double sn = g / t;                                    if(j != k)                                  {                                      e[j - 1] = t;                                  }                                    f = (cs * s[j]) + (sn * e[j]);                                  e[j] = (cs * e[j]) - (sn * s[j]);                                  g = sn * s[j + 1];                                  s[j + 1] = cs * s[j + 1];                                    for(int i = 0; i < _n; i++)                                  {                                      t = (cs * v[i][j]) + (sn * v[i][j + 1]);                                      v[i][j + 1] = ((-sn) * v[i][j]) + (cs * v[i][j + 1]);                                      v[i][j] = t;                                  }                                    t = Fn.Hypot(f' g);                                  cs = f / t;                                  sn = g / t;                                  s[j] = t;                                  f = (cs * e[j]) + (sn * s[j + 1]);                                  s[j + 1] = ((-sn) * e[j]) + (cs * s[j + 1]);                                  g = sn * e[j + 1];                                  e[j + 1] = cs * e[j + 1];                                    if(j < _m - 1)                                  {                                      for(int i = 0; i < _m; i++)                                      {                                          t = (cs * u[i][j]) + (sn * u[i][j + 1]);                                          u[i][j + 1] = ((-sn) * u[i][j]) + (cs * u[i][j + 1]);                                          u[i][j] = t;                                      }                                  }                              }                                e[p - 2] = f;                              iter = iter + 1;                          }                            break;                        // Convergence.                      case IterationStep.Convergence:                          {                              /* Make the singular values positive */                                if(s[k] <= 0.0)                              {                                  s[k] = (s[k] < 0.0 ? -s[k] : 0.0);                                    for(int i = 0; i <= pp; i++)                                  {                                      v[i][k] = -v[i][k];                                  }                              }                                /* Order the singular values */                                while(k < pp)                              {                                  if(s[k] >= s[k + 1])                                  {                                      break;                                  }                                    double t = s[k];                                  s[k] = s[k + 1];                                  s[k + 1] = t;                                    if(k < _n - 1)                                  {                                      for(int i = 0; i < _n; i++)                                      {                                          t = v[i][k + 1];                                          v[i][k + 1] = v[i][k];                                          v[i][k] = t;                                      }                                  }                                    if(k < _m - 1)                                  {                                      for(int i = 0; i < _m; i++)                                      {                                          t = u[i][k + 1];                                          u[i][k + 1] = u[i][k];                                          u[i][k] = t;                                      }                                  }                                    k++;                              }                                iter = 0;                              p--;                          }                            break;                  }
