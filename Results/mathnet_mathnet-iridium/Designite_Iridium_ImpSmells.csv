Implementation smell,Namespace,Class,File,Method,Description
Long Method,MathNet.Numerics,Fn,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions.cs,IntLog2,The method has 128 lines of code.
Long Method,MathNet.Numerics.Interpolation.Algorithms,CubicSplineInterpolation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\CubicSplineInterpolation.cs,Init,The method has 107 lines of code.
Long Method,MathNet.Numerics.LinearAlgebra,EigenvalueDecomposition,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\LinearAlgebra\EigenvalueDecomposition.cs,SymmetricTridiagonalize,The method has 128 lines of code.
Long Method,MathNet.Numerics.LinearAlgebra,EigenvalueDecomposition,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\LinearAlgebra\EigenvalueDecomposition.cs,SymmetricDiagonalize,The method has 128 lines of code.
Long Method,MathNet.Numerics.LinearAlgebra,EigenvalueDecomposition,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\LinearAlgebra\EigenvalueDecomposition.cs,NonsymmetricReduceToHessenberg,The method has 101 lines of code.
Long Method,MathNet.Numerics.LinearAlgebra,EigenvalueDecomposition,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\LinearAlgebra\EigenvalueDecomposition.cs,NonsymmetricReduceHessenberToRealSchur,The method has 472 lines of code.
Long Method,MathNet.Numerics.LinearAlgebra,SingularValueDecomposition,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\LinearAlgebra\SingularValueDecomposition.cs,SingularValueDecomposition,The method has 469 lines of code.
Long Method,MathNet.Numerics.SpecialFunctions.Algorithms,GammaRegularizedAlgorithm,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\GammaRegularizedAlgorithm.cs,GammaRegularizedInverse,The method has 155 lines of code.
Complex Method,MathNet.Numerics,Complex,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Complex.cs,ToString,Cyclomatic complexity of the method is 11
Complex Method,MathNet.Numerics,Sorting,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Sorting.cs,Sort,Cyclomatic complexity of the method is 8
Complex Method,MathNet.Numerics,Sorting,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Sorting.cs,Sort,Cyclomatic complexity of the method is 10
Complex Method,MathNet.Numerics,Polynomial,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Polynomial.cs,ToString,Cyclomatic complexity of the method is 8
Complex Method,MathNet.Numerics,Fn,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions.cs,IntLog2,Cyclomatic complexity of the method is 32
Complex Method,MathNet.Numerics.Interpolation.Algorithms,AkimaSplineInterpolation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\AkimaSplineInterpolation.cs,Init,Cyclomatic complexity of the method is 9
Complex Method,MathNet.Numerics.Interpolation.Algorithms,BarycentricInterpolation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\BarycentricInterpolation.cs,Interpolate,Cyclomatic complexity of the method is 8
Complex Method,MathNet.Numerics.Interpolation.Algorithms,CubicSplineInterpolation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\CubicSplineInterpolation.cs,Init,Cyclomatic complexity of the method is 11
Complex Method,MathNet.Numerics.Interpolation.Algorithms,RationalPoleFreeInterpolation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\RationalPoleFreeInterpolation.cs,Init,Cyclomatic complexity of the method is 15
Complex Method,MathNet.Numerics.LinearAlgebra,CholeskyDecomposition,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\LinearAlgebra\CholeskyDecomposition.cs,Solve,Cyclomatic complexity of the method is 9
Complex Method,MathNet.Numerics.LinearAlgebra,EigenvalueDecomposition,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\LinearAlgebra\EigenvalueDecomposition.cs,SymmetricTridiagonalize,Cyclomatic complexity of the method is 14
Complex Method,MathNet.Numerics.LinearAlgebra,EigenvalueDecomposition,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\LinearAlgebra\EigenvalueDecomposition.cs,SymmetricDiagonalize,Cyclomatic complexity of the method is 11
Complex Method,MathNet.Numerics.LinearAlgebra,EigenvalueDecomposition,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\LinearAlgebra\EigenvalueDecomposition.cs,NonsymmetricReduceToHessenberg,Cyclomatic complexity of the method is 20
Complex Method,MathNet.Numerics.LinearAlgebra,EigenvalueDecomposition,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\LinearAlgebra\EigenvalueDecomposition.cs,NonsymmetricReduceHessenberToRealSchur,Cyclomatic complexity of the method is 21
Complex Method,MathNet.Numerics.LinearAlgebra,LUDecomposition,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\LinearAlgebra\LUDecomposition.cs,LUDecomposition,Cyclomatic complexity of the method is 12
Complex Method,MathNet.Numerics.LinearAlgebra,LUDecomposition,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\LinearAlgebra\LUDecomposition.cs,Solve,Cyclomatic complexity of the method is 10
Complex Method,MathNet.Numerics.LinearAlgebra,Matrix,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\LinearAlgebra\Matrix.cs,SolveRobust,Cyclomatic complexity of the method is 8
Complex Method,MathNet.Numerics.LinearAlgebra,QRDecomposition,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\LinearAlgebra\QRDecomposition.cs,QRDecomposition,Cyclomatic complexity of the method is 9
Complex Method,MathNet.Numerics.LinearAlgebra,QRDecomposition,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\LinearAlgebra\QRDecomposition.cs,Solve,Cyclomatic complexity of the method is 11
Complex Method,MathNet.Numerics.LinearAlgebra,SingularValueDecomposition,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\LinearAlgebra\SingularValueDecomposition.cs,SingularValueDecomposition,Cyclomatic complexity of the method is 50
Complex Method,MathNet.Numerics.RandomSources,AdditiveLaggedFibonacciRandomSource,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\AdditiveLaggedFibonacciRandomSource.cs,NextBytes,Cyclomatic complexity of the method is 9
Complex Method,MathNet.Numerics.RandomSources,MersenneTwisterRandomSource,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\MersenneTwisterRandomSource.cs,NextBytes,Cyclomatic complexity of the method is 9
Complex Method,MathNet.Numerics.SpecialFunctions.Algorithms,BetaRegularizedAlgorithm,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\BetaRegularizedAlgorithm.cs,BetaRegularized,Cyclomatic complexity of the method is 10
Complex Method,MathNet.Numerics.SpecialFunctions.Algorithms,DigammaAlgorithm,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\DigammaAlgorithm.cs,Digamma,Cyclomatic complexity of the method is 8
Complex Method,MathNet.Numerics.SpecialFunctions.Algorithms,GammaRegularizedAlgorithm,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\GammaRegularizedAlgorithm.cs,GammaRegularizedInverse,Cyclomatic complexity of the method is 21
Complex Method,MathNet.Numerics.Statistics,Histogram,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Statistics\Histogram.cs,OptimalDispersion,Cyclomatic complexity of the method is 12
Complex Method,MathNet.Numerics.Statistics,Histogram,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Statistics\Histogram.cs,OptimalVariance,Cyclomatic complexity of the method is 10
Complex Method,MathNet.Numerics.Statistics,Histogram,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Statistics\Histogram.cs,OptimalFreedom,Cyclomatic complexity of the method is 9
Complex Method,MathNet.Numerics.Statistics,Histogram,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Statistics\Histogram.cs,OptimalSquaredFreedom,Cyclomatic complexity of the method is 9
Long Parameter List,MathNet.Numerics,ComplexPolynomial,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\ComplexPolynomial.cs,MultiplyKaratsuba,The method has 6 parameters. Parameters: leftCoefficients' rightCoefficients' leftOrder' rightOrder' n' offset
Long Parameter List,MathNet.Numerics,Sorting,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Sorting.cs,QuickSort,The method has 5 parameters. Parameters: keys' items' comparer' left' right
Long Parameter List,MathNet.Numerics,Sorting,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Sorting.cs,QuickSort,The method has 6 parameters. Parameters: keys' items1' items2' comparer' left' right
Long Parameter List,MathNet.Numerics,Polynomial,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Polynomial.cs,MultiplyKaratsuba,The method has 6 parameters. Parameters: leftCoefficients' rightCoefficients' leftOrder' rightOrder' n' offset
Long Parameter List,MathNet.Numerics,Quaternion,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Quaternion.cs,Quaternion,The method has 7 parameters. Parameters: real' imagX' imagY' imagZ' abs' norm' arg
Long Parameter List,MathNet.Numerics.Integration.Algorithms,TrapeziumRule,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Integration\Algorithms\TrapeziumRule.cs,IntegrateAdaptiveTransformedOdd,The method has 7 parameters. Parameters: f' intervalBegin' intervalEnd' levelAbscissas' levelWeights' levelOneStep' targetRelativeError
Long Parameter List,MathNet.Numerics.Interpolation.Algorithms,AkimaSplineInterpolation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\AkimaSplineInterpolation.cs,DifferentiateThreePoint,The method has 7 parameters. Parameters: t' t0' x0' t1' x1' t2' x2
Long Parameter List,MathNet.Numerics.Interpolation.Algorithms,CubicSplineInterpolation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\CubicSplineInterpolation.cs,Init,The method has 6 parameters. Parameters: t' x' leftBoundaryCondition' leftBoundary' rightBoundaryCondition' rightBoundary
Long Parameter List,MathNet.Numerics.Interpolation,Interpolation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Interpolation.cs,CreateCubicSpline,The method has 6 parameters. Parameters: points' values' leftBoundaryCondition' leftBoundary' rightBoundaryCondition' rightBoundary
Long Parameter List,MathNet.Numerics.LinearAlgebra,ComplexMatrix,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\LinearAlgebra\ComplexMatrix.cs,SetMatrix,The method has 5 parameters. Parameters: i0' i1' j0' j1' x
Long Parameter List,MathNet.Numerics.LinearAlgebra,Matrix,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\LinearAlgebra\Matrix.cs,SetMatrix,The method has 5 parameters. Parameters: i0' i1' j0' j1' x
Long Parameter List,MathNet.Numerics.Transformations,InternalFFT,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Transformations\InternalFFT.cs,DanielsonLanczosTransformMultiDim,The method has 5 parameters. Parameters: samples' stride' step' forward' convention
Long Parameter List,MathNet.Numerics.Transformations,RealFourierTransformation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Transformations\RealFourierTransformation.cs,TransformForward,The method has 6 parameters. Parameters: samples1' samples2' fftReal1' fftImag1' fftReal2' fftImag2
Long Parameter List,MathNet.Numerics.Transformations,RealFourierTransformation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Transformations\RealFourierTransformation.cs,TransformBackward,The method has 6 parameters. Parameters: fftReal1' fftImag1' fftReal2' fftImag2' samples1' samples2
Long Identifier,MathNet.Numerics,SiConstants,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SiConstants.cs,,The length of the parameter ShieldedProtonGyromagneticRatio is 31.
Long Identifier,MathNet.Numerics.LinearAlgebra,LUDecomposition,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\LinearAlgebra\LUDecomposition.cs,,The length of the parameter _lowerTriangularFactorOnDemand is 30.
Long Identifier,MathNet.Numerics.LinearAlgebra,LUDecomposition,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\LinearAlgebra\LUDecomposition.cs,,The length of the parameter _upperTriangularFactorOnDemand is 30.
Long Identifier,MathNet.Numerics.LinearAlgebra,Matrix,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\LinearAlgebra\Matrix.cs,,The length of the parameter _choleskyDecompositionOnDemand is 30.
Long Identifier,MathNet.Numerics.LinearAlgebra,Matrix,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\LinearAlgebra\Matrix.cs,,The length of the parameter _singularValueDecompositionOnDemand is 35.
Long Identifier,MathNet.Numerics.LinearAlgebra,Matrix,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\LinearAlgebra\Matrix.cs,,The length of the parameter _eigenValueDecompositionOnDemand is 32.
Long Identifier,MathNet.Numerics.LinearAlgebra,QRDecomposition,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\LinearAlgebra\QRDecomposition.cs,,The length of the parameter _upperTriangularFactorOnDemand is 30.
Long Identifier,MathNet.Numerics.LinearAlgebra,SingularValueDecomposition,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\LinearAlgebra\SingularValueDecomposition.cs,,The length of the parameter _diagonalSingularValuesOnDemand is 31.
Long Statement,MathNet.Numerics,ComplexPolynomial,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\ComplexPolynomial.cs,MultiplyKaratsuba,The length of the statement  "                        (leftCoefficients[offset] * rightCoefficients[offset + 1]) + (leftCoefficients[offset + 1] * rightCoefficients[offset])' " is 120.
Long Statement,MathNet.Numerics,Polynomial,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Polynomial.cs,MultiplyKaratsuba,The length of the statement  "                        (leftCoefficients[offset] * rightCoefficients[offset + 1]) + (leftCoefficients[offset + 1] * rightCoefficients[offset])' " is 120.
Long Statement,MathNet.Numerics.Distributions,BinomialDistribution,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Distributions\Discrete\BinomialDistribution.cs,NextInt32,The length of the statement  "                    tmp = 1.2 * root * (1.0 + yangle * yangle) * System.Math.Exp(oldGamma - Fn.GammaLn(em + 1.0) - Fn.GammaLn(en - em + 1.0) + em * probabilityLog + (en - em) * pclog); " is 164.
Long Statement,MathNet.Numerics.Integration.Algorithms,TrapeziumRule,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Integration\Algorithms\TrapeziumRule.cs,IntegrateAdaptiveTransformedOdd,The length of the statement  "                sum += weightsL1[i] * (f((linearSlope * abcissasL1[i]) + linearOffset) + f(-(linearSlope * abcissasL1[i]) + linearOffset)); " is 123.
Long Statement,MathNet.Numerics.Integration.Algorithms,TrapeziumRule,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Integration\Algorithms\TrapeziumRule.cs,IntegrateAdaptiveTransformedOdd,The length of the statement  "                    midpointsum += weights[i] * (f((linearSlope * abcissas[i]) + linearOffset) + f(-(linearSlope * abcissas[i]) + linearOffset)); " is 125.
Long Statement,MathNet.Numerics.Interpolation.Algorithms,CubicSplineInterpolation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\CubicSplineInterpolation.cs,Init,The length of the statement  "                b[i] = (3 * (xx[i] - xx[i - 1]) / (tt[i] - tt[i - 1]) * (tt[i + 1] - tt[i])) + (3 * (xx[i + 1] - xx[i]) / (tt[i + 1] - tt[i]) * (tt[i] - tt[i - 1])); " is 149.
Long Statement,MathNet.Numerics.LinearAlgebra,EigenvalueDecomposition,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\LinearAlgebra\EigenvalueDecomposition.cs,NonsymmetricReduceHessenberToRealSchur,The length of the statement  "                        if(Math.Abs(_h[m][m - 1]) * (Math.Abs(q) + Math.Abs(r)) < eps * (Math.Abs(p) * (Math.Abs(_h[m - 1][m - 1]) + Math.Abs(z) + Math.Abs(_h[m + 1][m + 1])))) " is 152.
Long Statement,MathNet.Numerics.LinearAlgebra,Matrix,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\LinearAlgebra\Matrix.cs,InitOnDemandComputations,The length of the statement  "            _singularValueDecompositionOnDemand = new OnDemandComputation<SingularValueDecomposition>(ComputeSingularValueDecomposition); " is 125.
Long Statement,MathNet.Numerics.RandomSources,AdditiveLaggedFibonacciRandomSource,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\AdditiveLaggedFibonacciRandomSource.cs,Next,The length of the statement  "            // 31 random bits (int) will suffice which allows us to shift and cast to an int before the first multiplication and gain better performance. " is 141.
Long Statement,MathNet.Numerics.RandomSources,MersenneTwisterRandomSource,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\MersenneTwisterRandomSource.cs,Next,The length of the statement  "            // 31 random bits (int) will suffice which allows us to shift and cast to an int before the first multiplication and gain better performance. " is 141.
Long Statement,MathNet.Numerics.RandomSources,XorShiftRandomSource,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\XorShiftRandomSource.cs,Next,The length of the statement  "            // 31 random bits (int) will suffice which allows us to shift and cast to an int before the first multiplication and gain better performance. " is 141.
Long Statement,MathNet.Numerics.RandomSources.ObjectModel,RandomByteSourceAdapter,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\ObjectModel\RandomByteSourceAdapter.cs,Next,The length of the statement  "            // 31 random bits (int) will suffice which allows us to shift and cast to an int before the first multiplication and gain better performance. " is 141.
Long Statement,MathNet.Numerics.SpecialFunctions.Algorithms,BetaRegularizedAlgorithm,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\BetaRegularizedAlgorithm.cs,BetaRegularized,The length of the statement  "                : Math.Exp(GammaAlgorithm.GammaLn(a + b) - GammaAlgorithm.GammaLn(a) - GammaAlgorithm.GammaLn(b) + (a * Math.Log(x)) + (b * Math.Log(1.0 - x))); " is 144.
Long Statement,MathNet.Numerics.SpecialFunctions.Algorithms,ErrorFunctionAlgorithm,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\ErrorFunctionAlgorithm.cs,ErfInverse,The length of the statement  "                return ((((((((((ErfInvC[0] * q) + ErfInvC[1]) * q) + ErfInvC[2]) * q) + ErfInvC[3]) * q) + ErfInvC[4]) * q) + ErfInvC[5]) / " is 124.
Long Statement,MathNet.Numerics.SpecialFunctions.Algorithms,ErrorFunctionAlgorithm,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\ErrorFunctionAlgorithm.cs,ErfInverse,The length of the statement  "                return -((((((((((ErfInvC[0] * q) + ErfInvC[1]) * q) + ErfInvC[2]) * q) + ErfInvC[3]) * q) + ErfInvC[4]) * q) + ErfInvC[5]) / " is 125.
Long Statement,MathNet.Numerics.SpecialFunctions.Algorithms,ErrorFunctionAlgorithm,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\ErrorFunctionAlgorithm.cs,ErfInverse,The length of the statement  "            return ((((((((((ErfInvA[0] * r) + ErfInvA[1]) * r) + ErfInvA[2]) * r) + ErfInvA[3]) * r) + ErfInvA[4]) * r) + ErfInvA[5]) * q / " is 128.
Complex Conditional,MathNet.Numerics,Combinatorics,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Combinatorics.cs,CombinationsWithRepetition,The conditional expression  "k < 0 || n < 0 || (n == 0 && k > 0)"  is complex.
Complex Conditional,MathNet.Numerics,Number,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Number.cs,AlmostEqualNorm,The conditional expression  "(a == 0 && Math.Abs(b) < maximumRelativeError)                  || (b == 0 && Math.Abs(a) < maximumRelativeError)"  is complex.
Complex Conditional,MathNet.Numerics.NumberTheory,IntegerTheory,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\NumberTheory\IntegerTheory.cs,IsPerfectSquare,The conditional expression  "lastHexDigit == 0 || lastHexDigit == 1 || lastHexDigit == 4 || lastHexDigit == 9"  is complex.
Complex Conditional,MathNet.Numerics.NumberTheory,IntegerTheory,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\NumberTheory\IntegerTheory.cs,IsPerfectSquare,The conditional expression  "lastHexDigit == 0 || lastHexDigit == 1 || lastHexDigit == 4 || lastHexDigit == 9"  is complex.
Complex Conditional,MathNet.Numerics.SpecialFunctions.Algorithms,GammaRegularizedAlgorithm,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\GammaRegularizedAlgorithm.cs,GammaRegularizedInverse,The conditional expression  "a < 0 || Number.AlmostZero(a) || y0 < 0 || y0 > 1"  is complex.
Magic Number,MathNet.Numerics,Combinatorics,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Combinatorics.cs,Variations,The following statement contains a magic number: return Math.Floor(0.5 + Math.Exp(Fn.FactorialLn(n) - Fn.FactorialLn(n - k)));
Magic Number,MathNet.Numerics,Combinatorics,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Combinatorics.cs,CombinationsWithRepetition,The following statement contains a magic number: return Math.Floor(0.5 + Math.Exp(Fn.FactorialLn(n + k - 1) - Fn.FactorialLn(k) - Fn.FactorialLn(n - 1)));
Magic Number,MathNet.Numerics,Combinatorics,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Combinatorics.cs,RandomCombination,The following statement contains a magic number: if(k * 3 < n)               {                  // just pick and try                  int selectionCount = 0;                  while(selectionCount < k)                  {                      int index = _random.Next(n);                      if(!selection[index])                      {                          selection[index] = true;                          selectionCount++;                      }                  }                    return selection;              }
Magic Number,MathNet.Numerics,Complex,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Complex.cs,InverseTangent,The following statement contains a magic number: return new Complex(0' 0.5) * ((1 - iz).NaturalLogarithm() - (1 + iz).NaturalLogarithm());
Magic Number,MathNet.Numerics,Complex,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Complex.cs,InverseCotangent,The following statement contains a magic number: return (new Complex(0' 0.5) * ((1 + iz).NaturalLogarithm() - (1 - iz).NaturalLogarithm())) + (Math.PI / 2);
Magic Number,MathNet.Numerics,Complex,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Complex.cs,InverseCotangent,The following statement contains a magic number: return (new Complex(0' 0.5) * ((1 + iz).NaturalLogarithm() - (1 - iz).NaturalLogarithm())) + (Math.PI / 2);
Magic Number,MathNet.Numerics,Complex,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Complex.cs,HyperbolicSecant,The following statement contains a magic number: return 2 * exp / (exp.Square() + 1);
Magic Number,MathNet.Numerics,Complex,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Complex.cs,HyperbolicCosecant,The following statement contains a magic number: return 2 * exp / (exp.Square() - 1);
Magic Number,MathNet.Numerics,Complex,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Complex.cs,InverseHyperbolicTangent,The following statement contains a magic number: return 0.5 * ((1 + this).NaturalLogarithm() - (1 - this).NaturalLogarithm());
Magic Number,MathNet.Numerics,Complex,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Complex.cs,InverseHyperbolicCotangent,The following statement contains a magic number: return 0.5 * ((this + 1).NaturalLogarithm() - (this - 1).NaturalLogarithm());
Magic Number,MathNet.Numerics,Complex,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Complex.cs,Square,The following statement contains a magic number: return new Complex(                  (_real * _real) - (_imag * _imag)'                  2 * _real * _imag);
Magic Number,MathNet.Numerics,ComplexPolynomial,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\ComplexPolynomial.cs,SizeOfOrder,The following statement contains a magic number: return 1 << (int)Math.Ceiling(Math.Log(order + 1' 2));
Magic Number,MathNet.Numerics,ComplexPolynomial,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\ComplexPolynomial.cs,DivideShiftInplace,The following statement contains a magic number: if((n << 2) > _order)              {                  Normalize();              }
Magic Number,MathNet.Numerics,ComplexPolynomial,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\ComplexPolynomial.cs,Multiply,The following statement contains a magic number: if(orderMin > 3)              {                  int orderMax = Math.Max(Order' polynomial.Order);                  EnsureSupportForOrder(orderMax);                  polynomial.EnsureSupportForOrder(orderMax);                    return MultiplyKaratsuba(                      _coefficients'                      polynomial._coefficients'                      _order'                      polynomial._order'                      SizeOfOrder(orderMax)'                      0);              }
Magic Number,MathNet.Numerics,ComplexPolynomial,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\ComplexPolynomial.cs,MultiplyKaratsuba,The following statement contains a magic number: if(n == 2)              {                  return new ComplexPolynomial(                      new Complex[] {                          leftCoefficients[offset] * rightCoefficients[offset]'                          (leftCoefficients[offset] * rightCoefficients[offset + 1]) + (leftCoefficients[offset + 1] * rightCoefficients[offset])'                          leftCoefficients[offset + 1] * rightCoefficients[offset + 1]                      });              }
Magic Number,MathNet.Numerics,ComplexPolynomial,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\ComplexPolynomial.cs,Evaluate,The following statement contains a magic number: for(int i = 2; i < ret.Length; i++)              {                  factorial *= i;                  ret[i] *= factorial;              }
Magic Number,MathNet.Numerics,Sorting,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Sorting.cs,Sort,The following statement contains a magic number: if(keys.Count == 2)              {                  if(comparer.Compare(keys[0]' keys[1]) > 0)                  {                      Swap(keys' 0' 1);                  }                    return;              }
Magic Number,MathNet.Numerics,Sorting,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Sorting.cs,Sort,The following statement contains a magic number: if(count == 2)              {                  if(comparer.Compare(keys[index]' keys[index + 1]) > 0)                  {                      Swap(keys' index' index + 1);                  }                    return;              }
Magic Number,MathNet.Numerics,Natural,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Natural.cs,Multiply,The following statement contains a magic number: if(Math.Max(_bound' number._bound) < 12)              {                  return MultiplySmall(number);              }
Magic Number,MathNet.Numerics,Natural,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Natural.cs,MultiplySmall,The following statement contains a magic number: uint len = _bound + number._bound + 2;
Magic Number,MathNet.Numerics,Natural,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Natural.cs,MultiplyLarge,The following statement contains a magic number: uint k = (uint)Math.Ceiling(0.5 * len);
Magic Number,MathNet.Numerics,Number,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Number.cs,PositiveEpsilonOf,The following statement contains a magic number: return 2 * EpsilonOf(value);
Magic Number,MathNet.Numerics,Number,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Number.cs,Increment,The following statement contains a magic number: if(signed64 == -9223372036854775808)              {                  /* = "-0"' make it "+0" */                    return 0;              }
Magic Number,MathNet.Numerics,Polynomial,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Polynomial.cs,SizeOfOrder,The following statement contains a magic number: return 1 << (int)Math.Ceiling(Math.Log(order + 1' 2));
Magic Number,MathNet.Numerics,Polynomial,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Polynomial.cs,DivideShiftInplace,The following statement contains a magic number: if((n << 2) > _order)              {                  Normalize();              }
Magic Number,MathNet.Numerics,Polynomial,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Polynomial.cs,Multiply,The following statement contains a magic number: if(orderMin > 3)              {                  int orderMax = Math.Max(Order' polynomial.Order);                  EnsureSupportForOrder(orderMax);                  polynomial.EnsureSupportForOrder(orderMax);                    return MultiplyKaratsuba(                      _coefficients'                      polynomial._coefficients'                      _order'                      polynomial._order'                      SizeOfOrder(orderMax)'                      0);              }
Magic Number,MathNet.Numerics,Polynomial,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Polynomial.cs,MultiplyKaratsuba,The following statement contains a magic number: if(n == 2)              {                  return new Polynomial(                      new double[] {                          leftCoefficients[offset] * rightCoefficients[offset]'                          (leftCoefficients[offset] * rightCoefficients[offset + 1]) + (leftCoefficients[offset + 1] * rightCoefficients[offset])'                          leftCoefficients[offset + 1] * rightCoefficients[offset + 1]                      });              }
Magic Number,MathNet.Numerics,Polynomial,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Polynomial.cs,Evaluate,The following statement contains a magic number: for(int i = 2; i < ret.Length; i++)              {                  factorial *= i;                  ret[i] *= factorial;              }
Magic Number,MathNet.Numerics,Quaternion,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Quaternion.cs,Lg,The following statement contains a magic number: return Ln().Divide(Math.Log(10));
Magic Number,MathNet.Numerics,Quaternion,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Quaternion.cs,Sqr,The following statement contains a magic number: double arg = _arg * 2;
Magic Number,MathNet.Numerics,Quaternion,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Quaternion.cs,Sqrt,The following statement contains a magic number: double arg = _arg * 0.5;
Magic Number,MathNet.Numerics,Ratios,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Ratios.cs,RatioToDecibel,The following statement contains a magic number: return 10 * Math.Log10(ratio);
Magic Number,MathNet.Numerics,Ratios,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Ratios.cs,RatioToDecibel,The following statement contains a magic number: return 10 * (Math.Log10(value) - Math.Log10(baseValue));
Magic Number,MathNet.Numerics,Ratios,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Ratios.cs,DecibelToRatio,The following statement contains a magic number: return Math.Pow(10' 0.1 * decibel);
Magic Number,MathNet.Numerics,Ratios,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Ratios.cs,DecibelToRatio,The following statement contains a magic number: return Math.Pow(10' 0.1 * decibel);
Magic Number,MathNet.Numerics,Ratios,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Ratios.cs,DecibelToValue,The following statement contains a magic number: return Math.Pow(10' 0.1 * decibel) * baseValue;
Magic Number,MathNet.Numerics,Ratios,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Ratios.cs,DecibelToValue,The following statement contains a magic number: return Math.Pow(10' 0.1 * decibel) * baseValue;
Magic Number,MathNet.Numerics,Ratios,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Ratios.cs,RatioToPowerDecibel,The following statement contains a magic number: return 20 * Math.Log10(ratio);
Magic Number,MathNet.Numerics,Ratios,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Ratios.cs,RatioToPowerDecibel,The following statement contains a magic number: return 20 * (Math.Log10(value) - Math.Log10(baseValue));
Magic Number,MathNet.Numerics,Ratios,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Ratios.cs,PowerDecibelToRatio,The following statement contains a magic number: return Math.Pow(10' 0.05 * decibel);
Magic Number,MathNet.Numerics,Ratios,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Ratios.cs,PowerDecibelToRatio,The following statement contains a magic number: return Math.Pow(10' 0.05 * decibel);
Magic Number,MathNet.Numerics,Ratios,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Ratios.cs,PowerDecibelToValue,The following statement contains a magic number: return Math.Pow(10' 0.05 * decibel) * baseValue;
Magic Number,MathNet.Numerics,Ratios,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Ratios.cs,PowerDecibelToValue,The following statement contains a magic number: return Math.Pow(10' 0.05 * decibel) * baseValue;
Magic Number,MathNet.Numerics,SampleList,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SampleList.cs,SampleList,The following statement contains a magic number: _sampleCount = new int[16];
Magic Number,MathNet.Numerics,SampleList,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SampleList.cs,SampleList,The following statement contains a magic number: _sampleT = new double[16];
Magic Number,MathNet.Numerics,SampleList,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SampleList.cs,SampleList,The following statement contains a magic number: _sampleX = new double[16];
Magic Number,MathNet.Numerics,SampleList,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SampleList.cs,EnsureCapacity,The following statement contains a magic number: int capacitySuggestion = (_sampleCount.Length < 8) ? 16 : (_sampleCount.Length << 1);
Magic Number,MathNet.Numerics,SampleList,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SampleList.cs,EnsureCapacity,The following statement contains a magic number: int capacitySuggestion = (_sampleCount.Length < 8) ? 16 : (_sampleCount.Length << 1);
Magic Number,MathNet.Numerics,SampleList,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SampleList.cs,LocateBisection,The following statement contains a magic number: if(_size > 0 && Number.AlmostEqual(t' _sampleT[_size - 1]))              {                  return _size - 2;              }
Magic Number,MathNet.Numerics,Fn,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions.cs,IntPow2,The following statement contains a magic number: if(exponent < 0 || exponent >= 31)              {                  throw new ArgumentOutOfRangeException("exponent");              }
Magic Number,MathNet.Numerics,Fn,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions.cs,IntLog2,The following statement contains a magic number: if(x <= 65536)              {                  if(x <= 256)                  {                      if(x <= 16)                      {                          if(x <= 4)                          {                              if(x <= 2)                              {                                  if(x <= 1)                                  {                                      return 0;                                  }                                    return 1;                              }                                return 2;                          }                            if(x <= 8)                          {                              return 3;                          }                            return 4;                      }                        if(x <= 64)                      {                          if(x <= 32)                          {                              return 5;                          }                            return 6;                      }                        if(x <= 128)                      {                          return 7;                      }                        return 8;                  }                    if(x <= 4096)                  {                      if(x <= 1024)                      {                          if(x <= 512)                          {                              return 9;                          }                            return 10;                      }                        if(x <= 2048)                      {                          return 11;                      }                        return 12;                  }                    if(x <= 16384)                  {                      if(x <= 8192)                      {                          return 13;                      }                        return 14;                  }                    if(x <= 32768)                  {                      return 15;                  }                    return 16;              }
Magic Number,MathNet.Numerics,Fn,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions.cs,IntLog2,The following statement contains a magic number: if(x <= 65536)              {                  if(x <= 256)                  {                      if(x <= 16)                      {                          if(x <= 4)                          {                              if(x <= 2)                              {                                  if(x <= 1)                                  {                                      return 0;                                  }                                    return 1;                              }                                return 2;                          }                            if(x <= 8)                          {                              return 3;                          }                            return 4;                      }                        if(x <= 64)                      {                          if(x <= 32)                          {                              return 5;                          }                            return 6;                      }                        if(x <= 128)                      {                          return 7;                      }                        return 8;                  }                    if(x <= 4096)                  {                      if(x <= 1024)                      {                          if(x <= 512)                          {                              return 9;                          }                            return 10;                      }                        if(x <= 2048)                      {                          return 11;                      }                        return 12;                  }                    if(x <= 16384)                  {                      if(x <= 8192)                      {                          return 13;                      }                        return 14;                  }                    if(x <= 32768)                  {                      return 15;                  }                    return 16;              }
Magic Number,MathNet.Numerics,Fn,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions.cs,IntLog2,The following statement contains a magic number: if(x <= 65536)              {                  if(x <= 256)                  {                      if(x <= 16)                      {                          if(x <= 4)                          {                              if(x <= 2)                              {                                  if(x <= 1)                                  {                                      return 0;                                  }                                    return 1;                              }                                return 2;                          }                            if(x <= 8)                          {                              return 3;                          }                            return 4;                      }                        if(x <= 64)                      {                          if(x <= 32)                          {                              return 5;                          }                            return 6;                      }                        if(x <= 128)                      {                          return 7;                      }                        return 8;                  }                    if(x <= 4096)                  {                      if(x <= 1024)                      {                          if(x <= 512)                          {                              return 9;                          }                            return 10;                      }                        if(x <= 2048)                      {                          return 11;                      }                        return 12;                  }                    if(x <= 16384)                  {                      if(x <= 8192)                      {                          return 13;                      }                        return 14;                  }                    if(x <= 32768)                  {                      return 15;                  }                    return 16;              }
Magic Number,MathNet.Numerics,Fn,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions.cs,IntLog2,The following statement contains a magic number: if(x <= 65536)              {                  if(x <= 256)                  {                      if(x <= 16)                      {                          if(x <= 4)                          {                              if(x <= 2)                              {                                  if(x <= 1)                                  {                                      return 0;                                  }                                    return 1;                              }                                return 2;                          }                            if(x <= 8)                          {                              return 3;                          }                            return 4;                      }                        if(x <= 64)                      {                          if(x <= 32)                          {                              return 5;                          }                            return 6;                      }                        if(x <= 128)                      {                          return 7;                      }                        return 8;                  }                    if(x <= 4096)                  {                      if(x <= 1024)                      {                          if(x <= 512)                          {                              return 9;                          }                            return 10;                      }                        if(x <= 2048)                      {                          return 11;                      }                        return 12;                  }                    if(x <= 16384)                  {                      if(x <= 8192)                      {                          return 13;                      }                        return 14;                  }                    if(x <= 32768)                  {                      return 15;                  }                    return 16;              }
Magic Number,MathNet.Numerics,Fn,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions.cs,IntLog2,The following statement contains a magic number: if(x <= 65536)              {                  if(x <= 256)                  {                      if(x <= 16)                      {                          if(x <= 4)                          {                              if(x <= 2)                              {                                  if(x <= 1)                                  {                                      return 0;                                  }                                    return 1;                              }                                return 2;                          }                            if(x <= 8)                          {                              return 3;                          }                            return 4;                      }                        if(x <= 64)                      {                          if(x <= 32)                          {                              return 5;                          }                            return 6;                      }                        if(x <= 128)                      {                          return 7;                      }                        return 8;                  }                    if(x <= 4096)                  {                      if(x <= 1024)                      {                          if(x <= 512)                          {                              return 9;                          }                            return 10;                      }                        if(x <= 2048)                      {                          return 11;                      }                        return 12;                  }                    if(x <= 16384)                  {                      if(x <= 8192)                      {                          return 13;                      }                        return 14;                  }                    if(x <= 32768)                  {                      return 15;                  }                    return 16;              }
Magic Number,MathNet.Numerics,Fn,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions.cs,IntLog2,The following statement contains a magic number: if(x <= 65536)              {                  if(x <= 256)                  {                      if(x <= 16)                      {                          if(x <= 4)                          {                              if(x <= 2)                              {                                  if(x <= 1)                                  {                                      return 0;                                  }                                    return 1;                              }                                return 2;                          }                            if(x <= 8)                          {                              return 3;                          }                            return 4;                      }                        if(x <= 64)                      {                          if(x <= 32)                          {                              return 5;                          }                            return 6;                      }                        if(x <= 128)                      {                          return 7;                      }                        return 8;                  }                    if(x <= 4096)                  {                      if(x <= 1024)                      {                          if(x <= 512)                          {                              return 9;                          }                            return 10;                      }                        if(x <= 2048)                      {                          return 11;                      }                        return 12;                  }                    if(x <= 16384)                  {                      if(x <= 8192)                      {                          return 13;                      }                        return 14;                  }                    if(x <= 32768)                  {                      return 15;                  }                    return 16;              }
Magic Number,MathNet.Numerics,Fn,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions.cs,IntLog2,The following statement contains a magic number: if(x <= 65536)              {                  if(x <= 256)                  {                      if(x <= 16)                      {                          if(x <= 4)                          {                              if(x <= 2)                              {                                  if(x <= 1)                                  {                                      return 0;                                  }                                    return 1;                              }                                return 2;                          }                            if(x <= 8)                          {                              return 3;                          }                            return 4;                      }                        if(x <= 64)                      {                          if(x <= 32)                          {                              return 5;                          }                            return 6;                      }                        if(x <= 128)                      {                          return 7;                      }                        return 8;                  }                    if(x <= 4096)                  {                      if(x <= 1024)                      {                          if(x <= 512)                          {                              return 9;                          }                            return 10;                      }                        if(x <= 2048)                      {                          return 11;                      }                        return 12;                  }                    if(x <= 16384)                  {                      if(x <= 8192)                      {                          return 13;                      }                        return 14;                  }                    if(x <= 32768)                  {                      return 15;                  }                    return 16;              }
Magic Number,MathNet.Numerics,Fn,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions.cs,IntLog2,The following statement contains a magic number: if(x <= 65536)              {                  if(x <= 256)                  {                      if(x <= 16)                      {                          if(x <= 4)                          {                              if(x <= 2)                              {                                  if(x <= 1)                                  {                                      return 0;                                  }                                    return 1;                              }                                return 2;                          }                            if(x <= 8)                          {                              return 3;                          }                            return 4;                      }                        if(x <= 64)                      {                          if(x <= 32)                          {                              return 5;                          }                            return 6;                      }                        if(x <= 128)                      {                          return 7;                      }                        return 8;                  }                    if(x <= 4096)                  {                      if(x <= 1024)                      {                          if(x <= 512)                          {                              return 9;                          }                            return 10;                      }                        if(x <= 2048)                      {                          return 11;                      }                        return 12;                  }                    if(x <= 16384)                  {                      if(x <= 8192)                      {                          return 13;                      }                        return 14;                  }                    if(x <= 32768)                  {                      return 15;                  }                    return 16;              }
Magic Number,MathNet.Numerics,Fn,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions.cs,IntLog2,The following statement contains a magic number: if(x <= 65536)              {                  if(x <= 256)                  {                      if(x <= 16)                      {                          if(x <= 4)                          {                              if(x <= 2)                              {                                  if(x <= 1)                                  {                                      return 0;                                  }                                    return 1;                              }                                return 2;                          }                            if(x <= 8)                          {                              return 3;                          }                            return 4;                      }                        if(x <= 64)                      {                          if(x <= 32)                          {                              return 5;                          }                            return 6;                      }                        if(x <= 128)                      {                          return 7;                      }                        return 8;                  }                    if(x <= 4096)                  {                      if(x <= 1024)                      {                          if(x <= 512)                          {                              return 9;                          }                            return 10;                      }                        if(x <= 2048)                      {                          return 11;                      }                        return 12;                  }                    if(x <= 16384)                  {                      if(x <= 8192)                      {                          return 13;                      }                        return 14;                  }                    if(x <= 32768)                  {                      return 15;                  }                    return 16;              }
Magic Number,MathNet.Numerics,Fn,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions.cs,IntLog2,The following statement contains a magic number: if(x <= 65536)              {                  if(x <= 256)                  {                      if(x <= 16)                      {                          if(x <= 4)                          {                              if(x <= 2)                              {                                  if(x <= 1)                                  {                                      return 0;                                  }                                    return 1;                              }                                return 2;                          }                            if(x <= 8)                          {                              return 3;                          }                            return 4;                      }                        if(x <= 64)                      {                          if(x <= 32)                          {                              return 5;                          }                            return 6;                      }                        if(x <= 128)                      {                          return 7;                      }                        return 8;                  }                    if(x <= 4096)                  {                      if(x <= 1024)                      {                          if(x <= 512)                          {                              return 9;                          }                            return 10;                      }                        if(x <= 2048)                      {                          return 11;                      }                        return 12;                  }                    if(x <= 16384)                  {                      if(x <= 8192)                      {                          return 13;                      }                        return 14;                  }                    if(x <= 32768)                  {                      return 15;                  }                    return 16;              }
Magic Number,MathNet.Numerics,Fn,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions.cs,IntLog2,The following statement contains a magic number: if(x <= 65536)              {                  if(x <= 256)                  {                      if(x <= 16)                      {                          if(x <= 4)                          {                              if(x <= 2)                              {                                  if(x <= 1)                                  {                                      return 0;                                  }                                    return 1;                              }                                return 2;                          }                            if(x <= 8)                          {                              return 3;                          }                            return 4;                      }                        if(x <= 64)                      {                          if(x <= 32)                          {                              return 5;                          }                            return 6;                      }                        if(x <= 128)                      {                          return 7;                      }                        return 8;                  }                    if(x <= 4096)                  {                      if(x <= 1024)                      {                          if(x <= 512)                          {                              return 9;                          }                            return 10;                      }                        if(x <= 2048)                      {                          return 11;                      }                        return 12;                  }                    if(x <= 16384)                  {                      if(x <= 8192)                      {                          return 13;                      }                        return 14;                  }                    if(x <= 32768)                  {                      return 15;                  }                    return 16;              }
Magic Number,MathNet.Numerics,Fn,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions.cs,IntLog2,The following statement contains a magic number: if(x <= 65536)              {                  if(x <= 256)                  {                      if(x <= 16)                      {                          if(x <= 4)                          {                              if(x <= 2)                              {                                  if(x <= 1)                                  {                                      return 0;                                  }                                    return 1;                              }                                return 2;                          }                            if(x <= 8)                          {                              return 3;                          }                            return 4;                      }                        if(x <= 64)                      {                          if(x <= 32)                          {                              return 5;                          }                            return 6;                      }                        if(x <= 128)                      {                          return 7;                      }                        return 8;                  }                    if(x <= 4096)                  {                      if(x <= 1024)                      {                          if(x <= 512)                          {                              return 9;                          }                            return 10;                      }                        if(x <= 2048)                      {                          return 11;                      }                        return 12;                  }                    if(x <= 16384)                  {                      if(x <= 8192)                      {                          return 13;                      }                        return 14;                  }                    if(x <= 32768)                  {                      return 15;                  }                    return 16;              }
Magic Number,MathNet.Numerics,Fn,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions.cs,IntLog2,The following statement contains a magic number: if(x <= 65536)              {                  if(x <= 256)                  {                      if(x <= 16)                      {                          if(x <= 4)                          {                              if(x <= 2)                              {                                  if(x <= 1)                                  {                                      return 0;                                  }                                    return 1;                              }                                return 2;                          }                            if(x <= 8)                          {                              return 3;                          }                            return 4;                      }                        if(x <= 64)                      {                          if(x <= 32)                          {                              return 5;                          }                            return 6;                      }                        if(x <= 128)                      {                          return 7;                      }                        return 8;                  }                    if(x <= 4096)                  {                      if(x <= 1024)                      {                          if(x <= 512)                          {                              return 9;                          }                            return 10;                      }                        if(x <= 2048)                      {                          return 11;                      }                        return 12;                  }                    if(x <= 16384)                  {                      if(x <= 8192)                      {                          return 13;                      }                        return 14;                  }                    if(x <= 32768)                  {                      return 15;                  }                    return 16;              }
Magic Number,MathNet.Numerics,Fn,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions.cs,IntLog2,The following statement contains a magic number: if(x <= 65536)              {                  if(x <= 256)                  {                      if(x <= 16)                      {                          if(x <= 4)                          {                              if(x <= 2)                              {                                  if(x <= 1)                                  {                                      return 0;                                  }                                    return 1;                              }                                return 2;                          }                            if(x <= 8)                          {                              return 3;                          }                            return 4;                      }                        if(x <= 64)                      {                          if(x <= 32)                          {                              return 5;                          }                            return 6;                      }                        if(x <= 128)                      {                          return 7;                      }                        return 8;                  }                    if(x <= 4096)                  {                      if(x <= 1024)                      {                          if(x <= 512)                          {                              return 9;                          }                            return 10;                      }                        if(x <= 2048)                      {                          return 11;                      }                        return 12;                  }                    if(x <= 16384)                  {                      if(x <= 8192)                      {                          return 13;                      }                        return 14;                  }                    if(x <= 32768)                  {                      return 15;                  }                    return 16;              }
Magic Number,MathNet.Numerics,Fn,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions.cs,IntLog2,The following statement contains a magic number: if(x <= 65536)              {                  if(x <= 256)                  {                      if(x <= 16)                      {                          if(x <= 4)                          {                              if(x <= 2)                              {                                  if(x <= 1)                                  {                                      return 0;                                  }                                    return 1;                              }                                return 2;                          }                            if(x <= 8)                          {                              return 3;                          }                            return 4;                      }                        if(x <= 64)                      {                          if(x <= 32)                          {                              return 5;                          }                            return 6;                      }                        if(x <= 128)                      {                          return 7;                      }                        return 8;                  }                    if(x <= 4096)                  {                      if(x <= 1024)                      {                          if(x <= 512)                          {                              return 9;                          }                            return 10;                      }                        if(x <= 2048)                      {                          return 11;                      }                        return 12;                  }                    if(x <= 16384)                  {                      if(x <= 8192)                      {                          return 13;                      }                        return 14;                  }                    if(x <= 32768)                  {                      return 15;                  }                    return 16;              }
Magic Number,MathNet.Numerics,Fn,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions.cs,IntLog2,The following statement contains a magic number: if(x <= 65536)              {                  if(x <= 256)                  {                      if(x <= 16)                      {                          if(x <= 4)                          {                              if(x <= 2)                              {                                  if(x <= 1)                                  {                                      return 0;                                  }                                    return 1;                              }                                return 2;                          }                            if(x <= 8)                          {                              return 3;                          }                            return 4;                      }                        if(x <= 64)                      {                          if(x <= 32)                          {                              return 5;                          }                            return 6;                      }                        if(x <= 128)                      {                          return 7;                      }                        return 8;                  }                    if(x <= 4096)                  {                      if(x <= 1024)                      {                          if(x <= 512)                          {                              return 9;                          }                            return 10;                      }                        if(x <= 2048)                      {                          return 11;                      }                        return 12;                  }                    if(x <= 16384)                  {                      if(x <= 8192)                      {                          return 13;                      }                        return 14;                  }                    if(x <= 32768)                  {                      return 15;                  }                    return 16;              }
Magic Number,MathNet.Numerics,Fn,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions.cs,IntLog2,The following statement contains a magic number: if(x <= 65536)              {                  if(x <= 256)                  {                      if(x <= 16)                      {                          if(x <= 4)                          {                              if(x <= 2)                              {                                  if(x <= 1)                                  {                                      return 0;                                  }                                    return 1;                              }                                return 2;                          }                            if(x <= 8)                          {                              return 3;                          }                            return 4;                      }                        if(x <= 64)                      {                          if(x <= 32)                          {                              return 5;                          }                            return 6;                      }                        if(x <= 128)                      {                          return 7;                      }                        return 8;                  }                    if(x <= 4096)                  {                      if(x <= 1024)                      {                          if(x <= 512)                          {                              return 9;                          }                            return 10;                      }                        if(x <= 2048)                      {                          return 11;                      }                        return 12;                  }                    if(x <= 16384)                  {                      if(x <= 8192)                      {                          return 13;                      }                        return 14;                  }                    if(x <= 32768)                  {                      return 15;                  }                    return 16;              }
Magic Number,MathNet.Numerics,Fn,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions.cs,IntLog2,The following statement contains a magic number: if(x <= 65536)              {                  if(x <= 256)                  {                      if(x <= 16)                      {                          if(x <= 4)                          {                              if(x <= 2)                              {                                  if(x <= 1)                                  {                                      return 0;                                  }                                    return 1;                              }                                return 2;                          }                            if(x <= 8)                          {                              return 3;                          }                            return 4;                      }                        if(x <= 64)                      {                          if(x <= 32)                          {                              return 5;                          }                            return 6;                      }                        if(x <= 128)                      {                          return 7;                      }                        return 8;                  }                    if(x <= 4096)                  {                      if(x <= 1024)                      {                          if(x <= 512)                          {                              return 9;                          }                            return 10;                      }                        if(x <= 2048)                      {                          return 11;                      }                        return 12;                  }                    if(x <= 16384)                  {                      if(x <= 8192)                      {                          return 13;                      }                        return 14;                  }                    if(x <= 32768)                  {                      return 15;                  }                    return 16;              }
Magic Number,MathNet.Numerics,Fn,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions.cs,IntLog2,The following statement contains a magic number: if(x <= 65536)              {                  if(x <= 256)                  {                      if(x <= 16)                      {                          if(x <= 4)                          {                              if(x <= 2)                              {                                  if(x <= 1)                                  {                                      return 0;                                  }                                    return 1;                              }                                return 2;                          }                            if(x <= 8)                          {                              return 3;                          }                            return 4;                      }                        if(x <= 64)                      {                          if(x <= 32)                          {                              return 5;                          }                            return 6;                      }                        if(x <= 128)                      {                          return 7;                      }                        return 8;                  }                    if(x <= 4096)                  {                      if(x <= 1024)                      {                          if(x <= 512)                          {                              return 9;                          }                            return 10;                      }                        if(x <= 2048)                      {                          return 11;                      }                        return 12;                  }                    if(x <= 16384)                  {                      if(x <= 8192)                      {                          return 13;                      }                        return 14;                  }                    if(x <= 32768)                  {                      return 15;                  }                    return 16;              }
Magic Number,MathNet.Numerics,Fn,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions.cs,IntLog2,The following statement contains a magic number: if(x <= 65536)              {                  if(x <= 256)                  {                      if(x <= 16)                      {                          if(x <= 4)                          {                              if(x <= 2)                              {                                  if(x <= 1)                                  {                                      return 0;                                  }                                    return 1;                              }                                return 2;                          }                            if(x <= 8)                          {                              return 3;                          }                            return 4;                      }                        if(x <= 64)                      {                          if(x <= 32)                          {                              return 5;                          }                            return 6;                      }                        if(x <= 128)                      {                          return 7;                      }                        return 8;                  }                    if(x <= 4096)                  {                      if(x <= 1024)                      {                          if(x <= 512)                          {                              return 9;                          }                            return 10;                      }                        if(x <= 2048)                      {                          return 11;                      }                        return 12;                  }                    if(x <= 16384)                  {                      if(x <= 8192)                      {                          return 13;                      }                        return 14;                  }                    if(x <= 32768)                  {                      return 15;                  }                    return 16;              }
Magic Number,MathNet.Numerics,Fn,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions.cs,IntLog2,The following statement contains a magic number: if(x <= 65536)              {                  if(x <= 256)                  {                      if(x <= 16)                      {                          if(x <= 4)                          {                              if(x <= 2)                              {                                  if(x <= 1)                                  {                                      return 0;                                  }                                    return 1;                              }                                return 2;                          }                            if(x <= 8)                          {                              return 3;                          }                            return 4;                      }                        if(x <= 64)                      {                          if(x <= 32)                          {                              return 5;                          }                            return 6;                      }                        if(x <= 128)                      {                          return 7;                      }                        return 8;                  }                    if(x <= 4096)                  {                      if(x <= 1024)                      {                          if(x <= 512)                          {                              return 9;                          }                            return 10;                      }                        if(x <= 2048)                      {                          return 11;                      }                        return 12;                  }                    if(x <= 16384)                  {                      if(x <= 8192)                      {                          return 13;                      }                        return 14;                  }                    if(x <= 32768)                  {                      return 15;                  }                    return 16;              }
Magic Number,MathNet.Numerics,Fn,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions.cs,IntLog2,The following statement contains a magic number: if(x <= 65536)              {                  if(x <= 256)                  {                      if(x <= 16)                      {                          if(x <= 4)                          {                              if(x <= 2)                              {                                  if(x <= 1)                                  {                                      return 0;                                  }                                    return 1;                              }                                return 2;                          }                            if(x <= 8)                          {                              return 3;                          }                            return 4;                      }                        if(x <= 64)                      {                          if(x <= 32)                          {                              return 5;                          }                            return 6;                      }                        if(x <= 128)                      {                          return 7;                      }                        return 8;                  }                    if(x <= 4096)                  {                      if(x <= 1024)                      {                          if(x <= 512)                          {                              return 9;                          }                            return 10;                      }                        if(x <= 2048)                      {                          return 11;                      }                        return 12;                  }                    if(x <= 16384)                  {                      if(x <= 8192)                      {                          return 13;                      }                        return 14;                  }                    if(x <= 32768)                  {                      return 15;                  }                    return 16;              }
Magic Number,MathNet.Numerics,Fn,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions.cs,IntLog2,The following statement contains a magic number: if(x <= 65536)              {                  if(x <= 256)                  {                      if(x <= 16)                      {                          if(x <= 4)                          {                              if(x <= 2)                              {                                  if(x <= 1)                                  {                                      return 0;                                  }                                    return 1;                              }                                return 2;                          }                            if(x <= 8)                          {                              return 3;                          }                            return 4;                      }                        if(x <= 64)                      {                          if(x <= 32)                          {                              return 5;                          }                            return 6;                      }                        if(x <= 128)                      {                          return 7;                      }                        return 8;                  }                    if(x <= 4096)                  {                      if(x <= 1024)                      {                          if(x <= 512)                          {                              return 9;                          }                            return 10;                      }                        if(x <= 2048)                      {                          return 11;                      }                        return 12;                  }                    if(x <= 16384)                  {                      if(x <= 8192)                      {                          return 13;                      }                        return 14;                  }                    if(x <= 32768)                  {                      return 15;                  }                    return 16;              }
Magic Number,MathNet.Numerics,Fn,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions.cs,IntLog2,The following statement contains a magic number: if(x <= 65536)              {                  if(x <= 256)                  {                      if(x <= 16)                      {                          if(x <= 4)                          {                              if(x <= 2)                              {                                  if(x <= 1)                                  {                                      return 0;                                  }                                    return 1;                              }                                return 2;                          }                            if(x <= 8)                          {                              return 3;                          }                            return 4;                      }                        if(x <= 64)                      {                          if(x <= 32)                          {                              return 5;                          }                            return 6;                      }                        if(x <= 128)                      {                          return 7;                      }                        return 8;                  }                    if(x <= 4096)                  {                      if(x <= 1024)                      {                          if(x <= 512)                          {                              return 9;                          }                            return 10;                      }                        if(x <= 2048)                      {                          return 11;                      }                        return 12;                  }                    if(x <= 16384)                  {                      if(x <= 8192)                      {                          return 13;                      }                        return 14;                  }                    if(x <= 32768)                  {                      return 15;                  }                    return 16;              }
Magic Number,MathNet.Numerics,Fn,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions.cs,IntLog2,The following statement contains a magic number: if(x <= 65536)              {                  if(x <= 256)                  {                      if(x <= 16)                      {                          if(x <= 4)                          {                              if(x <= 2)                              {                                  if(x <= 1)                                  {                                      return 0;                                  }                                    return 1;                              }                                return 2;                          }                            if(x <= 8)                          {                              return 3;                          }                            return 4;                      }                        if(x <= 64)                      {                          if(x <= 32)                          {                              return 5;                          }                            return 6;                      }                        if(x <= 128)                      {                          return 7;                      }                        return 8;                  }                    if(x <= 4096)                  {                      if(x <= 1024)                      {                          if(x <= 512)                          {                              return 9;                          }                            return 10;                      }                        if(x <= 2048)                      {                          return 11;                      }                        return 12;                  }                    if(x <= 16384)                  {                      if(x <= 8192)                      {                          return 13;                      }                        return 14;                  }                    if(x <= 32768)                  {                      return 15;                  }                    return 16;              }
Magic Number,MathNet.Numerics,Fn,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions.cs,IntLog2,The following statement contains a magic number: if(x <= 65536)              {                  if(x <= 256)                  {                      if(x <= 16)                      {                          if(x <= 4)                          {                              if(x <= 2)                              {                                  if(x <= 1)                                  {                                      return 0;                                  }                                    return 1;                              }                                return 2;                          }                            if(x <= 8)                          {                              return 3;                          }                            return 4;                      }                        if(x <= 64)                      {                          if(x <= 32)                          {                              return 5;                          }                            return 6;                      }                        if(x <= 128)                      {                          return 7;                      }                        return 8;                  }                    if(x <= 4096)                  {                      if(x <= 1024)                      {                          if(x <= 512)                          {                              return 9;                          }                            return 10;                      }                        if(x <= 2048)                      {                          return 11;                      }                        return 12;                  }                    if(x <= 16384)                  {                      if(x <= 8192)                      {                          return 13;                      }                        return 14;                  }                    if(x <= 32768)                  {                      return 15;                  }                    return 16;              }
Magic Number,MathNet.Numerics,Fn,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions.cs,IntLog2,The following statement contains a magic number: if(x <= 65536)              {                  if(x <= 256)                  {                      if(x <= 16)                      {                          if(x <= 4)                          {                              if(x <= 2)                              {                                  if(x <= 1)                                  {                                      return 0;                                  }                                    return 1;                              }                                return 2;                          }                            if(x <= 8)                          {                              return 3;                          }                            return 4;                      }                        if(x <= 64)                      {                          if(x <= 32)                          {                              return 5;                          }                            return 6;                      }                        if(x <= 128)                      {                          return 7;                      }                        return 8;                  }                    if(x <= 4096)                  {                      if(x <= 1024)                      {                          if(x <= 512)                          {                              return 9;                          }                            return 10;                      }                        if(x <= 2048)                      {                          return 11;                      }                        return 12;                  }                    if(x <= 16384)                  {                      if(x <= 8192)                      {                          return 13;                      }                        return 14;                  }                    if(x <= 32768)                  {                      return 15;                  }                    return 16;              }
Magic Number,MathNet.Numerics,Fn,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions.cs,IntLog2,The following statement contains a magic number: if(x <= 65536)              {                  if(x <= 256)                  {                      if(x <= 16)                      {                          if(x <= 4)                          {                              if(x <= 2)                              {                                  if(x <= 1)                                  {                                      return 0;                                  }                                    return 1;                              }                                return 2;                          }                            if(x <= 8)                          {                              return 3;                          }                            return 4;                      }                        if(x <= 64)                      {                          if(x <= 32)                          {                              return 5;                          }                            return 6;                      }                        if(x <= 128)                      {                          return 7;                      }                        return 8;                  }                    if(x <= 4096)                  {                      if(x <= 1024)                      {                          if(x <= 512)                          {                              return 9;                          }                            return 10;                      }                        if(x <= 2048)                      {                          return 11;                      }                        return 12;                  }                    if(x <= 16384)                  {                      if(x <= 8192)                      {                          return 13;                      }                        return 14;                  }                    if(x <= 32768)                  {                      return 15;                  }                    return 16;              }
Magic Number,MathNet.Numerics,Fn,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions.cs,IntLog2,The following statement contains a magic number: if(x <= 65536)              {                  if(x <= 256)                  {                      if(x <= 16)                      {                          if(x <= 4)                          {                              if(x <= 2)                              {                                  if(x <= 1)                                  {                                      return 0;                                  }                                    return 1;                              }                                return 2;                          }                            if(x <= 8)                          {                              return 3;                          }                            return 4;                      }                        if(x <= 64)                      {                          if(x <= 32)                          {                              return 5;                          }                            return 6;                      }                        if(x <= 128)                      {                          return 7;                      }                        return 8;                  }                    if(x <= 4096)                  {                      if(x <= 1024)                      {                          if(x <= 512)                          {                              return 9;                          }                            return 10;                      }                        if(x <= 2048)                      {                          return 11;                      }                        return 12;                  }                    if(x <= 16384)                  {                      if(x <= 8192)                      {                          return 13;                      }                        return 14;                  }                    if(x <= 32768)                  {                      return 15;                  }                    return 16;              }
Magic Number,MathNet.Numerics,Fn,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions.cs,IntLog2,The following statement contains a magic number: if(x <= 65536)              {                  if(x <= 256)                  {                      if(x <= 16)                      {                          if(x <= 4)                          {                              if(x <= 2)                              {                                  if(x <= 1)                                  {                                      return 0;                                  }                                    return 1;                              }                                return 2;                          }                            if(x <= 8)                          {                              return 3;                          }                            return 4;                      }                        if(x <= 64)                      {                          if(x <= 32)                          {                              return 5;                          }                            return 6;                      }                        if(x <= 128)                      {                          return 7;                      }                        return 8;                  }                    if(x <= 4096)                  {                      if(x <= 1024)                      {                          if(x <= 512)                          {                              return 9;                          }                            return 10;                      }                        if(x <= 2048)                      {                          return 11;                      }                        return 12;                  }                    if(x <= 16384)                  {                      if(x <= 8192)                      {                          return 13;                      }                        return 14;                  }                    if(x <= 32768)                  {                      return 15;                  }                    return 16;              }
Magic Number,MathNet.Numerics,Fn,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions.cs,IntLog2,The following statement contains a magic number: if(x <= 65536)              {                  if(x <= 256)                  {                      if(x <= 16)                      {                          if(x <= 4)                          {                              if(x <= 2)                              {                                  if(x <= 1)                                  {                                      return 0;                                  }                                    return 1;                              }                                return 2;                          }                            if(x <= 8)                          {                              return 3;                          }                            return 4;                      }                        if(x <= 64)                      {                          if(x <= 32)                          {                              return 5;                          }                            return 6;                      }                        if(x <= 128)                      {                          return 7;                      }                        return 8;                  }                    if(x <= 4096)                  {                      if(x <= 1024)                      {                          if(x <= 512)                          {                              return 9;                          }                            return 10;                      }                        if(x <= 2048)                      {                          return 11;                      }                        return 12;                  }                    if(x <= 16384)                  {                      if(x <= 8192)                      {                          return 13;                      }                        return 14;                  }                    if(x <= 32768)                  {                      return 15;                  }                    return 16;              }
Magic Number,MathNet.Numerics,Fn,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions.cs,IntLog2,The following statement contains a magic number: if(x <= 16777216)              {                  if(x <= 1048576)                  {                      if(x <= 262144)                      {                          if(x <= 131072)                          {                              return 17;                          }                            return 18;                      }                        if(x <= 524288)                      {                          return 19;                      }                        return 20;                  }                    if(x <= 4194304)                  {                      if(x <= 2097152)                      {                          return 21;                      }                        return 22;                  }                    if(x <= 8388608)                  {                      return 23;                  }                    return 24;              }
Magic Number,MathNet.Numerics,Fn,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions.cs,IntLog2,The following statement contains a magic number: if(x <= 16777216)              {                  if(x <= 1048576)                  {                      if(x <= 262144)                      {                          if(x <= 131072)                          {                              return 17;                          }                            return 18;                      }                        if(x <= 524288)                      {                          return 19;                      }                        return 20;                  }                    if(x <= 4194304)                  {                      if(x <= 2097152)                      {                          return 21;                      }                        return 22;                  }                    if(x <= 8388608)                  {                      return 23;                  }                    return 24;              }
Magic Number,MathNet.Numerics,Fn,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions.cs,IntLog2,The following statement contains a magic number: if(x <= 16777216)              {                  if(x <= 1048576)                  {                      if(x <= 262144)                      {                          if(x <= 131072)                          {                              return 17;                          }                            return 18;                      }                        if(x <= 524288)                      {                          return 19;                      }                        return 20;                  }                    if(x <= 4194304)                  {                      if(x <= 2097152)                      {                          return 21;                      }                        return 22;                  }                    if(x <= 8388608)                  {                      return 23;                  }                    return 24;              }
Magic Number,MathNet.Numerics,Fn,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions.cs,IntLog2,The following statement contains a magic number: if(x <= 16777216)              {                  if(x <= 1048576)                  {                      if(x <= 262144)                      {                          if(x <= 131072)                          {                              return 17;                          }                            return 18;                      }                        if(x <= 524288)                      {                          return 19;                      }                        return 20;                  }                    if(x <= 4194304)                  {                      if(x <= 2097152)                      {                          return 21;                      }                        return 22;                  }                    if(x <= 8388608)                  {                      return 23;                  }                    return 24;              }
Magic Number,MathNet.Numerics,Fn,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions.cs,IntLog2,The following statement contains a magic number: if(x <= 16777216)              {                  if(x <= 1048576)                  {                      if(x <= 262144)                      {                          if(x <= 131072)                          {                              return 17;                          }                            return 18;                      }                        if(x <= 524288)                      {                          return 19;                      }                        return 20;                  }                    if(x <= 4194304)                  {                      if(x <= 2097152)                      {                          return 21;                      }                        return 22;                  }                    if(x <= 8388608)                  {                      return 23;                  }                    return 24;              }
Magic Number,MathNet.Numerics,Fn,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions.cs,IntLog2,The following statement contains a magic number: if(x <= 16777216)              {                  if(x <= 1048576)                  {                      if(x <= 262144)                      {                          if(x <= 131072)                          {                              return 17;                          }                            return 18;                      }                        if(x <= 524288)                      {                          return 19;                      }                        return 20;                  }                    if(x <= 4194304)                  {                      if(x <= 2097152)                      {                          return 21;                      }                        return 22;                  }                    if(x <= 8388608)                  {                      return 23;                  }                    return 24;              }
Magic Number,MathNet.Numerics,Fn,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions.cs,IntLog2,The following statement contains a magic number: if(x <= 16777216)              {                  if(x <= 1048576)                  {                      if(x <= 262144)                      {                          if(x <= 131072)                          {                              return 17;                          }                            return 18;                      }                        if(x <= 524288)                      {                          return 19;                      }                        return 20;                  }                    if(x <= 4194304)                  {                      if(x <= 2097152)                      {                          return 21;                      }                        return 22;                  }                    if(x <= 8388608)                  {                      return 23;                  }                    return 24;              }
Magic Number,MathNet.Numerics,Fn,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions.cs,IntLog2,The following statement contains a magic number: if(x <= 16777216)              {                  if(x <= 1048576)                  {                      if(x <= 262144)                      {                          if(x <= 131072)                          {                              return 17;                          }                            return 18;                      }                        if(x <= 524288)                      {                          return 19;                      }                        return 20;                  }                    if(x <= 4194304)                  {                      if(x <= 2097152)                      {                          return 21;                      }                        return 22;                  }                    if(x <= 8388608)                  {                      return 23;                  }                    return 24;              }
Magic Number,MathNet.Numerics,Fn,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions.cs,IntLog2,The following statement contains a magic number: if(x <= 16777216)              {                  if(x <= 1048576)                  {                      if(x <= 262144)                      {                          if(x <= 131072)                          {                              return 17;                          }                            return 18;                      }                        if(x <= 524288)                      {                          return 19;                      }                        return 20;                  }                    if(x <= 4194304)                  {                      if(x <= 2097152)                      {                          return 21;                      }                        return 22;                  }                    if(x <= 8388608)                  {                      return 23;                  }                    return 24;              }
Magic Number,MathNet.Numerics,Fn,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions.cs,IntLog2,The following statement contains a magic number: if(x <= 16777216)              {                  if(x <= 1048576)                  {                      if(x <= 262144)                      {                          if(x <= 131072)                          {                              return 17;                          }                            return 18;                      }                        if(x <= 524288)                      {                          return 19;                      }                        return 20;                  }                    if(x <= 4194304)                  {                      if(x <= 2097152)                      {                          return 21;                      }                        return 22;                  }                    if(x <= 8388608)                  {                      return 23;                  }                    return 24;              }
Magic Number,MathNet.Numerics,Fn,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions.cs,IntLog2,The following statement contains a magic number: if(x <= 16777216)              {                  if(x <= 1048576)                  {                      if(x <= 262144)                      {                          if(x <= 131072)                          {                              return 17;                          }                            return 18;                      }                        if(x <= 524288)                      {                          return 19;                      }                        return 20;                  }                    if(x <= 4194304)                  {                      if(x <= 2097152)                      {                          return 21;                      }                        return 22;                  }                    if(x <= 8388608)                  {                      return 23;                  }                    return 24;              }
Magic Number,MathNet.Numerics,Fn,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions.cs,IntLog2,The following statement contains a magic number: if(x <= 16777216)              {                  if(x <= 1048576)                  {                      if(x <= 262144)                      {                          if(x <= 131072)                          {                              return 17;                          }                            return 18;                      }                        if(x <= 524288)                      {                          return 19;                      }                        return 20;                  }                    if(x <= 4194304)                  {                      if(x <= 2097152)                      {                          return 21;                      }                        return 22;                  }                    if(x <= 8388608)                  {                      return 23;                  }                    return 24;              }
Magic Number,MathNet.Numerics,Fn,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions.cs,IntLog2,The following statement contains a magic number: if(x <= 16777216)              {                  if(x <= 1048576)                  {                      if(x <= 262144)                      {                          if(x <= 131072)                          {                              return 17;                          }                            return 18;                      }                        if(x <= 524288)                      {                          return 19;                      }                        return 20;                  }                    if(x <= 4194304)                  {                      if(x <= 2097152)                      {                          return 21;                      }                        return 22;                  }                    if(x <= 8388608)                  {                      return 23;                  }                    return 24;              }
Magic Number,MathNet.Numerics,Fn,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions.cs,IntLog2,The following statement contains a magic number: if(x <= 16777216)              {                  if(x <= 1048576)                  {                      if(x <= 262144)                      {                          if(x <= 131072)                          {                              return 17;                          }                            return 18;                      }                        if(x <= 524288)                      {                          return 19;                      }                        return 20;                  }                    if(x <= 4194304)                  {                      if(x <= 2097152)                      {                          return 21;                      }                        return 22;                  }                    if(x <= 8388608)                  {                      return 23;                  }                    return 24;              }
Magic Number,MathNet.Numerics,Fn,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions.cs,IntLog2,The following statement contains a magic number: if(x <= 16777216)              {                  if(x <= 1048576)                  {                      if(x <= 262144)                      {                          if(x <= 131072)                          {                              return 17;                          }                            return 18;                      }                        if(x <= 524288)                      {                          return 19;                      }                        return 20;                  }                    if(x <= 4194304)                  {                      if(x <= 2097152)                      {                          return 21;                      }                        return 22;                  }                    if(x <= 8388608)                  {                      return 23;                  }                    return 24;              }
Magic Number,MathNet.Numerics,Fn,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions.cs,IntLog2,The following statement contains a magic number: if(x <= 16777216)              {                  if(x <= 1048576)                  {                      if(x <= 262144)                      {                          if(x <= 131072)                          {                              return 17;                          }                            return 18;                      }                        if(x <= 524288)                      {                          return 19;                      }                        return 20;                  }                    if(x <= 4194304)                  {                      if(x <= 2097152)                      {                          return 21;                      }                        return 22;                  }                    if(x <= 8388608)                  {                      return 23;                  }                    return 24;              }
Magic Number,MathNet.Numerics,Fn,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions.cs,IntLog2,The following statement contains a magic number: if(x <= 268435456)              {                  if(x <= 67108864)                  {                      if(x <= 33554432)                      {                          return 25;                      }                        return 26;                  }                    if(x <= 134217728)                  {                      return 27;                  }                    return 28;              }
Magic Number,MathNet.Numerics,Fn,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions.cs,IntLog2,The following statement contains a magic number: if(x <= 268435456)              {                  if(x <= 67108864)                  {                      if(x <= 33554432)                      {                          return 25;                      }                        return 26;                  }                    if(x <= 134217728)                  {                      return 27;                  }                    return 28;              }
Magic Number,MathNet.Numerics,Fn,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions.cs,IntLog2,The following statement contains a magic number: if(x <= 268435456)              {                  if(x <= 67108864)                  {                      if(x <= 33554432)                      {                          return 25;                      }                        return 26;                  }                    if(x <= 134217728)                  {                      return 27;                  }                    return 28;              }
Magic Number,MathNet.Numerics,Fn,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions.cs,IntLog2,The following statement contains a magic number: if(x <= 268435456)              {                  if(x <= 67108864)                  {                      if(x <= 33554432)                      {                          return 25;                      }                        return 26;                  }                    if(x <= 134217728)                  {                      return 27;                  }                    return 28;              }
Magic Number,MathNet.Numerics,Fn,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions.cs,IntLog2,The following statement contains a magic number: if(x <= 268435456)              {                  if(x <= 67108864)                  {                      if(x <= 33554432)                      {                          return 25;                      }                        return 26;                  }                    if(x <= 134217728)                  {                      return 27;                  }                    return 28;              }
Magic Number,MathNet.Numerics,Fn,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions.cs,IntLog2,The following statement contains a magic number: if(x <= 268435456)              {                  if(x <= 67108864)                  {                      if(x <= 33554432)                      {                          return 25;                      }                        return 26;                  }                    if(x <= 134217728)                  {                      return 27;                  }                    return 28;              }
Magic Number,MathNet.Numerics,Fn,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions.cs,IntLog2,The following statement contains a magic number: if(x <= 268435456)              {                  if(x <= 67108864)                  {                      if(x <= 33554432)                      {                          return 25;                      }                        return 26;                  }                    if(x <= 134217728)                  {                      return 27;                  }                    return 28;              }
Magic Number,MathNet.Numerics,Fn,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions.cs,IntLog2,The following statement contains a magic number: if(x <= 268435456)              {                  if(x <= 67108864)                  {                      if(x <= 33554432)                      {                          return 25;                      }                        return 26;                  }                    if(x <= 134217728)                  {                      return 27;                  }                    return 28;              }
Magic Number,MathNet.Numerics,Fn,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions.cs,IntLog2,The following statement contains a magic number: if(x <= 1073741824)              {                  if(x <= 536870912)                  {                      return 29;                  }                    return 30;              }
Magic Number,MathNet.Numerics,Fn,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions.cs,IntLog2,The following statement contains a magic number: if(x <= 1073741824)              {                  if(x <= 536870912)                  {                      return 29;                  }                    return 30;              }
Magic Number,MathNet.Numerics,Fn,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions.cs,IntLog2,The following statement contains a magic number: if(x <= 1073741824)              {                  if(x <= 536870912)                  {                      return 29;                  }                    return 30;              }
Magic Number,MathNet.Numerics,Fn,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions.cs,IntLog2,The following statement contains a magic number: if(x <= 1073741824)              {                  if(x <= 536870912)                  {                      return 29;                  }                    return 30;              }
Magic Number,MathNet.Numerics,Fn,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions.cs,IntLog2,The following statement contains a magic number: return 31;
Magic Number,MathNet.Numerics,Fn,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions.cs,BinomialCoefficient,The following statement contains a magic number: return Math.Floor(0.5 + Math.Exp(FactorialLn(n) - FactorialLn(k) - FactorialLn(n - k)));
Magic Number,MathNet.Numerics,Fn,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions.cs,HarmonicNumber,The following statement contains a magic number: if(n >= HarmonicPrecompSize)              {                  double n2 = n * (double)n;                  double n4 = n2 * n2;                  return Constants.EulerGamma                      + Math.Log(n)                      + (0.5 / n)                      - (1.0 / (12.0 * n2))                      + (1.0 / (120.0 * n4));              }
Magic Number,MathNet.Numerics,Fn,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions.cs,HarmonicNumber,The following statement contains a magic number: if(n >= HarmonicPrecompSize)              {                  double n2 = n * (double)n;                  double n4 = n2 * n2;                  return Constants.EulerGamma                      + Math.Log(n)                      + (0.5 / n)                      - (1.0 / (12.0 * n2))                      + (1.0 / (120.0 * n4));              }
Magic Number,MathNet.Numerics,Fn,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions.cs,HarmonicNumber,The following statement contains a magic number: if(n >= HarmonicPrecompSize)              {                  double n2 = n * (double)n;                  double n4 = n2 * n2;                  return Constants.EulerGamma                      + Math.Log(n)                      + (0.5 / n)                      - (1.0 / (12.0 * n2))                      + (1.0 / (120.0 * n4));              }
Magic Number,MathNet.Numerics,Trig,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Trigonometry.cs,DegreeToGrad,The following statement contains a magic number: return degree / 9 * 10;
Magic Number,MathNet.Numerics,Trig,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Trigonometry.cs,DegreeToGrad,The following statement contains a magic number: return degree / 9 * 10;
Magic Number,MathNet.Numerics,Trig,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Trigonometry.cs,GradToDegree,The following statement contains a magic number: return newgrad / 10 * 9;
Magic Number,MathNet.Numerics,Trig,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Trigonometry.cs,GradToDegree,The following statement contains a magic number: return newgrad / 10 * 9;
Magic Number,MathNet.Numerics,Trig,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Trigonometry.cs,HyperbolicSine,The following statement contains a magic number: return (Math.Exp(radian) - Math.Exp(-radian)) / 2;
Magic Number,MathNet.Numerics,Trig,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Trigonometry.cs,HyperbolicCosine,The following statement contains a magic number: return (Math.Exp(radian) + Math.Exp(-radian)) / 2;
Magic Number,MathNet.Numerics,Trig,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Trigonometry.cs,InverseHyperbolicTangent,The following statement contains a magic number: return 0.5 * Math.Log(                  (1 + real) / (1 - real)'                  Math.E);
Magic Number,MathNet.Numerics,Trig,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Trigonometry.cs,InverseHyperbolicCotangent,The following statement contains a magic number: return 0.5 * Math.Log(                  (real + 1) / (real - 1)'                  Math.E);
Magic Number,MathNet.Numerics.Distributions,CauchyLorentzDistribution,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Distributions\Continuous\CauchyLorentzDistribution.cs,CumulativeDistribution,The following statement contains a magic number: return (Constants.InvPi * Trig.InverseTangent((x - _location) / _scale)) + 0.5;
Magic Number,MathNet.Numerics.Distributions,CauchyLorentzDistribution,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Distributions\Continuous\CauchyLorentzDistribution.cs,NextDouble,The following statement contains a magic number: return _location + (_scale * Trig.Tangent(Constants.Pi * (RandomSource.NextDouble() - 0.5)));
Magic Number,MathNet.Numerics.Distributions,ChiSquareDistribution,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Distributions\Continuous\ChiSquareDistribution.cs,SetDistributionParameters,The following statement contains a magic number: _lngammaDegreesOfFreedomHalf = Fn.GammaLn(0.5 * degreesOfFreedom);
Magic Number,MathNet.Numerics.Distributions,ChiSquareDistribution,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Distributions\Continuous\ChiSquareDistribution.cs,ProbabilityDensity,The following statement contains a magic number: return Math.Exp(                  ((-0.5 * _degreesOfFreedom) * Constants.Ln2)                  + (((0.5 * _degreesOfFreedom) + 1.0) * Math.Log(x))                  - (0.5 * x)                  - _lngammaDegreesOfFreedomHalf);
Magic Number,MathNet.Numerics.Distributions,ChiSquareDistribution,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Distributions\Continuous\ChiSquareDistribution.cs,ProbabilityDensity,The following statement contains a magic number: return Math.Exp(                  ((-0.5 * _degreesOfFreedom) * Constants.Ln2)                  + (((0.5 * _degreesOfFreedom) + 1.0) * Math.Log(x))                  - (0.5 * x)                  - _lngammaDegreesOfFreedomHalf);
Magic Number,MathNet.Numerics.Distributions,ChiSquareDistribution,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Distributions\Continuous\ChiSquareDistribution.cs,ProbabilityDensity,The following statement contains a magic number: return Math.Exp(                  ((-0.5 * _degreesOfFreedom) * Constants.Ln2)                  + (((0.5 * _degreesOfFreedom) + 1.0) * Math.Log(x))                  - (0.5 * x)                  - _lngammaDegreesOfFreedomHalf);
Magic Number,MathNet.Numerics.Distributions,ChiSquareDistribution,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Distributions\Continuous\ChiSquareDistribution.cs,CumulativeDistribution,The following statement contains a magic number: return Fn.GammaRegularized(0.5 * _degreesOfFreedom' 0.5 * x);
Magic Number,MathNet.Numerics.Distributions,ChiSquareDistribution,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Distributions\Continuous\ChiSquareDistribution.cs,CumulativeDistribution,The following statement contains a magic number: return Fn.GammaRegularized(0.5 * _degreesOfFreedom' 0.5 * x);
Magic Number,MathNet.Numerics.Distributions,ChiSquareDistribution,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Distributions\Continuous\ChiSquareDistribution.cs,InverseCumulativeDistribution,The following statement contains a magic number: return 2 * Fn.GammaRegularizedInverse(0.5 * _degreesOfFreedom' x);
Magic Number,MathNet.Numerics.Distributions,ChiSquareDistribution,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Distributions\Continuous\ChiSquareDistribution.cs,InverseCumulativeDistribution,The following statement contains a magic number: return 2 * Fn.GammaRegularizedInverse(0.5 * _degreesOfFreedom' x);
Magic Number,MathNet.Numerics.Distributions,ChiDistribution,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Distributions\Continuous\ChiDistribution.cs,SetDistributionParameters,The following statement contains a magic number: _lngammaDegreesOfFreedomHalf = Fn.GammaLn(0.5 * degreesOfFreedom);
Magic Number,MathNet.Numerics.Distributions,ChiDistribution,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Distributions\Continuous\ChiDistribution.cs,ProbabilityDensity,The following statement contains a magic number: return Math.Exp(                  ((1.0 - (0.5 * _degreesOfFreedom)) * Constants.Ln2)                  + ((_degreesOfFreedom - 1) * Math.Log(x))                  - (0.5 * x * x)                  - _lngammaDegreesOfFreedomHalf);
Magic Number,MathNet.Numerics.Distributions,ChiDistribution,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Distributions\Continuous\ChiDistribution.cs,ProbabilityDensity,The following statement contains a magic number: return Math.Exp(                  ((1.0 - (0.5 * _degreesOfFreedom)) * Constants.Ln2)                  + ((_degreesOfFreedom - 1) * Math.Log(x))                  - (0.5 * x * x)                  - _lngammaDegreesOfFreedomHalf);
Magic Number,MathNet.Numerics.Distributions,ChiDistribution,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Distributions\Continuous\ChiDistribution.cs,CumulativeDistribution,The following statement contains a magic number: return Fn.GammaRegularized(0.5 * _degreesOfFreedom' 0.5 * x * x);
Magic Number,MathNet.Numerics.Distributions,ChiDistribution,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Distributions\Continuous\ChiDistribution.cs,CumulativeDistribution,The following statement contains a magic number: return Fn.GammaRegularized(0.5 * _degreesOfFreedom' 0.5 * x * x);
Magic Number,MathNet.Numerics.Distributions,ChiDistribution,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Distributions\Continuous\ChiDistribution.cs,InverseCumulativeDistribution,The following statement contains a magic number: return Math.Sqrt(2 * Fn.GammaRegularizedInverse(0.5 * _degreesOfFreedom' x));
Magic Number,MathNet.Numerics.Distributions,ChiDistribution,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Distributions\Continuous\ChiDistribution.cs,InverseCumulativeDistribution,The following statement contains a magic number: return Math.Sqrt(2 * Fn.GammaRegularizedInverse(0.5 * _degreesOfFreedom' x));
Magic Number,MathNet.Numerics.Distributions,RayleighDistribution,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Distributions\Continuous\RayleighDistribution.cs,SetDistributionParameters,The following statement contains a magic number: _helper = 1 / (2 * sigma * sigma);
Magic Number,MathNet.Numerics.Distributions,RayleighDistribution,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Distributions\Continuous\RayleighDistribution.cs,EstimateDistributionParameters,The following statement contains a magic number: SetDistributionParameters(Math.Sqrt(sumOfSquares / (2 * n)));
Magic Number,MathNet.Numerics.Distributions,RayleighDistribution,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Distributions\Continuous\RayleighDistribution.cs,ProbabilityDensity,The following statement contains a magic number: return x * Math.Exp(-(x * x * _helper)) * (2 * _helper);
Magic Number,MathNet.Numerics.Distributions,RayleighDistribution,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Distributions\Continuous\RayleighDistribution.cs,NextDouble,The following statement contains a magic number: return _sigma * Math.Sqrt(-2 * Math.Log(1 - RandomSource.NextDouble()));
Magic Number,MathNet.Numerics.Distributions,StudentsTDistribution,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Distributions\Continuous\StudentsTDistribution.cs,SetDistributionParameters,The following statement contains a magic number: double a = 0.5 * (_degreesOfFreedom + 1);
Magic Number,MathNet.Numerics.Distributions,StudentsTDistribution,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Distributions\Continuous\StudentsTDistribution.cs,SetDistributionParameters,The following statement contains a magic number: double dLn2 = Fn.GammaLn(0.5 * _degreesOfFreedom);
Magic Number,MathNet.Numerics.Distributions,StudentsTDistribution,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Distributions\Continuous\StudentsTDistribution.cs,SetDistributionParameters,The following statement contains a magic number: _summand = Fn.BetaRegularized(0.5 * _degreesOfFreedom' 0.5' 1);
Magic Number,MathNet.Numerics.Distributions,StudentsTDistribution,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Distributions\Continuous\StudentsTDistribution.cs,SetDistributionParameters,The following statement contains a magic number: _summand = Fn.BetaRegularized(0.5 * _degreesOfFreedom' 0.5' 1);
Magic Number,MathNet.Numerics.Distributions,StudentsTDistribution,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Distributions\Continuous\StudentsTDistribution.cs,CumulativeDistribution,The following statement contains a magic number: double beta = Fn.BetaRegularized(                  0.5 * _degreesOfFreedom'                  0.5'                  _degreesOfFreedom / (_degreesOfFreedom + (x * x)));
Magic Number,MathNet.Numerics.Distributions,StudentsTDistribution,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Distributions\Continuous\StudentsTDistribution.cs,CumulativeDistribution,The following statement contains a magic number: double beta = Fn.BetaRegularized(                  0.5 * _degreesOfFreedom'                  0.5'                  _degreesOfFreedom / (_degreesOfFreedom + (x * x)));
Magic Number,MathNet.Numerics.Distributions,StudentsTDistribution,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Distributions\Continuous\StudentsTDistribution.cs,CumulativeDistribution,The following statement contains a magic number: return 0.5 + (0.5 * Math.Sign(x) * (_summand - beta));
Magic Number,MathNet.Numerics.Distributions,StudentsTDistribution,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Distributions\Continuous\StudentsTDistribution.cs,CumulativeDistribution,The following statement contains a magic number: return 0.5 + (0.5 * Math.Sign(x) * (_summand - beta));
Magic Number,MathNet.Numerics.Distributions,FisherSnedecorDistribution,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Distributions\Continuous\FisherSnedecorDistribution.cs,SetDistributionParameters,The following statement contains a magic number: double alphaHalf = 0.5 * alpha;
Magic Number,MathNet.Numerics.Distributions,FisherSnedecorDistribution,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Distributions\Continuous\FisherSnedecorDistribution.cs,SetDistributionParameters,The following statement contains a magic number: double betaHalf = 0.5 * beta;
Magic Number,MathNet.Numerics.Distributions,FisherSnedecorDistribution,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Distributions\Continuous\FisherSnedecorDistribution.cs,ProbabilityDensity,The following statement contains a magic number: if(Number.AlmostEqual(0.0' x))              {                  if(1 == _alpha)                  {                      return double.PositiveInfinity;                  }                    if(2 == _alpha)                  {                      return 1.0;                  }                    return 0.0;              }
Magic Number,MathNet.Numerics.Distributions,FisherSnedecorDistribution,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Distributions\Continuous\FisherSnedecorDistribution.cs,CumulativeDistribution,The following statement contains a magic number: return Fn.BetaRegularized(0.5 * _alpha' 0.5 * _beta' m);
Magic Number,MathNet.Numerics.Distributions,FisherSnedecorDistribution,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Distributions\Continuous\FisherSnedecorDistribution.cs,CumulativeDistribution,The following statement contains a magic number: return Fn.BetaRegularized(0.5 * _alpha' 0.5 * _beta' m);
Magic Number,MathNet.Numerics.Distributions,LaplaceDistribution,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Distributions\Continuous\LaplaceDistribution.cs,ProbabilityDensity,The following statement contains a magic number: return 1.0 / (2.0 * _scale) * Math.Exp(-Math.Abs(x - _location) / _scale);
Magic Number,MathNet.Numerics.Distributions,LaplaceDistribution,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Distributions\Continuous\LaplaceDistribution.cs,CumulativeDistribution,The following statement contains a magic number: if(x < _location)              {                  return 0.5 * Math.Exp((x - _location) / _scale);              }
Magic Number,MathNet.Numerics.Distributions,LaplaceDistribution,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Distributions\Continuous\LaplaceDistribution.cs,CumulativeDistribution,The following statement contains a magic number: return 1.0 - (0.5 * Math.Exp((_location - x) / _scale));
Magic Number,MathNet.Numerics.Distributions,LaplaceDistribution,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Distributions\Continuous\LaplaceDistribution.cs,NextDouble,The following statement contains a magic number: double rand = 0.5 - RandomSource.NextDouble();
Magic Number,MathNet.Numerics.Distributions,LaplaceDistribution,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Distributions\Continuous\LaplaceDistribution.cs,NextDouble,The following statement contains a magic number: return _location - (_scale * Math.Sign(rand) * Math.Log(2.0 * Math.Abs(rand)));
Magic Number,MathNet.Numerics.Distributions,LognormalDistribution,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Distributions\Continuous\LognormalDistribution.cs,ProbabilityDensity,The following statement contains a magic number: return Math.Exp(-0.5 * a * a) / (x * _sigma * Constants.Sqrt2Pi);
Magic Number,MathNet.Numerics.Distributions,LognormalDistribution,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Distributions\Continuous\LognormalDistribution.cs,CumulativeDistribution,The following statement contains a magic number: return 0.5 * (1.0 + Fn.Erf((Math.Log(x) - _mu) / (_sigma * Constants.Sqrt2)));
Magic Number,MathNet.Numerics.Distributions,LognormalDistribution,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Distributions\Continuous\LognormalDistribution.cs,InverseCumulativeDistribution,The following statement contains a magic number: return Math.Exp((_sigma * Constants.Sqrt2 * Fn.ErfInverse((2.0 * x) - 1.0)) + _mu);
Magic Number,MathNet.Numerics.Distributions,NormalDistribution,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Distributions\Continuous\NormalDistribution.cs,ProbabilityDensity,The following statement contains a magic number: return Constants.InvSqrt2Pi / _sigma * Math.Exp(xmu * xmu / (-2.0 * _sigma * _sigma));
Magic Number,MathNet.Numerics.Distributions,NormalDistribution,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Distributions\Continuous\NormalDistribution.cs,CumulativeDistribution,The following statement contains a magic number: return 0.5 * (1.0 + Fn.Erf((x - _mu) / (_sigma * Constants.Sqrt2)));
Magic Number,MathNet.Numerics.Distributions,NormalDistribution,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Distributions\Continuous\NormalDistribution.cs,InverseCumulativeDistribution,The following statement contains a magic number: return (_sigma * Constants.Sqrt2 * Fn.ErfInverse((2.0 * x) - 1.0)) + _mu;
Magic Number,MathNet.Numerics.Distributions,StableDistribution,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Distributions\Continuous\StableDistribution.cs,SetDistributionParameters,The following statement contains a magic number: _factor = Math.Pow(1.0 + (part1 * part1)' 1.0 / (2.0 * exponent));
Magic Number,MathNet.Numerics.Distributions,StableDistribution,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Distributions\Continuous\StableDistribution.cs,IsValidParameterSet,The following statement contains a magic number: return scale >= 0                  && skewness <= 1.0                  && skewness >= -1.0                  && exponent > 0                  && exponent <= 2;
Magic Number,MathNet.Numerics.Distributions,StableDistribution,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Distributions\Continuous\StableDistribution.cs,NextDouble,The following statement contains a magic number: return (2.0 / Math.PI) * (summand - subtrahend);
Magic Number,MathNet.Numerics.Distributions,StandardDistribution,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Distributions\Continuous\StandardDistribution.cs,ProbabilityDensity,The following statement contains a magic number: return Constants.InvSqrt2Pi * Math.Exp(x * x / -2.0);
Magic Number,MathNet.Numerics.Distributions,StandardDistribution,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Distributions\Continuous\StandardDistribution.cs,CumulativeDistribution,The following statement contains a magic number: return 0.5 * (1.0 + Fn.Erf(x * Constants.Sqrt1_2));
Magic Number,MathNet.Numerics.Distributions,StandardDistribution,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Distributions\Continuous\StandardDistribution.cs,InverseCumulativeDistribution,The following statement contains a magic number: return Constants.Sqrt1_2 * Fn.ErfInverse((2.0 * x) - 1.0);
Magic Number,MathNet.Numerics.Distributions,StandardDistribution,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Distributions\Continuous\StandardDistribution.cs,NextDouble,The following statement contains a magic number: do              {                  v1 = (2.0 * RandomSource.NextDouble()) - 1.0;                  v2 = (2.0 * RandomSource.NextDouble()) - 1.0;                  rsq = (v1 * v1) + (v2 * v2);              }              while(rsq > 1.0 || rsq == 0);
Magic Number,MathNet.Numerics.Distributions,StandardDistribution,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Distributions\Continuous\StandardDistribution.cs,NextDouble,The following statement contains a magic number: do              {                  v1 = (2.0 * RandomSource.NextDouble()) - 1.0;                  v2 = (2.0 * RandomSource.NextDouble()) - 1.0;                  rsq = (v1 * v1) + (v2 * v2);              }              while(rsq > 1.0 || rsq == 0);
Magic Number,MathNet.Numerics.Distributions,StandardDistribution,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Distributions\Continuous\StandardDistribution.cs,NextDouble,The following statement contains a magic number: double fac = Math.Sqrt(-2.0 * Math.Log(rsq) / rsq);
Magic Number,MathNet.Numerics.Distributions,TriangularDistribution,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Distributions\Continuous\TriangularDistribution.cs,TriangularDistribution,The following statement contains a magic number: SetDistributionParameters(0.0' 1.0' 0.5);
Magic Number,MathNet.Numerics.Distributions,TriangularDistribution,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Distributions\Continuous\TriangularDistribution.cs,TriangularDistribution,The following statement contains a magic number: SetDistributionParameters(0.0' 1.0' 0.5);
Magic Number,MathNet.Numerics.Distributions,TriangularDistribution,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Distributions\Continuous\TriangularDistribution.cs,ProbabilityDensity,The following statement contains a magic number: if(x <= _c)              {                  return 2 * (x - _a) / (_diff * _lowerPart);              }
Magic Number,MathNet.Numerics.Distributions,TriangularDistribution,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Distributions\Continuous\TriangularDistribution.cs,ProbabilityDensity,The following statement contains a magic number: if(x < _b)              {                  return 2 * (_b - x) / (_diff * _upperPart);              }
Magic Number,MathNet.Numerics.Distributions,ArbitraryDistribution,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Distributions\Discrete\ArbitraryDistribution.cs,SetDistributionParameters,The following statement contains a magic number: if(_pmf == null || _pmf.Length < _n || _pmf.Length >= 4 * _n)              {                  _pmf = new double[_n];                  _cdf = new double[_n];              }
Magic Number,MathNet.Numerics.Distributions,ArbitraryDistribution,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Distributions\Discrete\ArbitraryDistribution.cs,IsValidParameterSet,The following statement contains a magic number: return Number.AlmostEqual(1.0' sum' 10 + (2 * probabilityMass.Length));
Magic Number,MathNet.Numerics.Distributions,ArbitraryDistribution,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Distributions\Discrete\ArbitraryDistribution.cs,IsValidParameterSet,The following statement contains a magic number: return Number.AlmostEqual(1.0' sum' 10 + (2 * probabilityMass.Length));
Magic Number,MathNet.Numerics.Distributions,BernoulliDistribution,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Distributions\Discrete\BernoulliDistribution.cs,BernoulliDistribution,The following statement contains a magic number: SetDistributionParameters(0.5);
Magic Number,MathNet.Numerics.Distributions,BernoulliDistribution,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Distributions\Discrete\BernoulliDistribution.cs,BernoulliDistribution,The following statement contains a magic number: SetDistributionParameters(0.5);
Magic Number,MathNet.Numerics.Distributions,BinomialDistribution,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Distributions\Discrete\BinomialDistribution.cs,BinomialDistribution,The following statement contains a magic number: SetDistributionParameters(0.5' 1);
Magic Number,MathNet.Numerics.Distributions,BinomialDistribution,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Distributions\Discrete\BinomialDistribution.cs,BinomialDistribution,The following statement contains a magic number: SetDistributionParameters(0.5' 1);
Magic Number,MathNet.Numerics.Distributions,HypergeometricDistribution,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Distributions\Discrete\HypergeometricDistribution.cs,HypergeometricDistribution,The following statement contains a magic number: SetDistributionParameters(2' 1' 1);
Magic Number,MathNet.Numerics.Distributions,HypergeometricDistribution,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Distributions\Discrete\HypergeometricDistribution.cs,HypergeometricDistribution,The following statement contains a magic number: SetDistributionParameters(2' 1' 1);
Magic Number,MathNet.Numerics.Distributions,GeometricDistribution,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Distributions\Discrete\GeometricDistribution.cs,GeometricDistribution,The following statement contains a magic number: SetDistributionParameters(0.5);
Magic Number,MathNet.Numerics.Distributions,GeometricDistribution,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Distributions\Discrete\GeometricDistribution.cs,GeometricDistribution,The following statement contains a magic number: SetDistributionParameters(0.5);
Magic Number,MathNet.Numerics.Integration.Algorithms,DoubleExponentialTransformation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Integration\Algorithms\DoubleExponentialTransformation.cs,EvaluateAbcissas,The following statement contains a magic number: double step = level <= 1 ? 1.0 : (1.0 / (2 << (level - 2)));
Magic Number,MathNet.Numerics.Integration.Algorithms,DoubleExponentialTransformation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Integration\Algorithms\DoubleExponentialTransformation.cs,EvaluateAbcissas,The following statement contains a magic number: double step = level <= 1 ? 1.0 : (1.0 / (2 << (level - 2)));
Magic Number,MathNet.Numerics.Integration.Algorithms,DoubleExponentialTransformation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Integration\Algorithms\DoubleExponentialTransformation.cs,EvaluateAbcissas,The following statement contains a magic number: double offset = level == 0 ? 0.0 : (1.0 / (2 << (level - 1)));
Magic Number,MathNet.Numerics.Integration.Algorithms,DoubleExponentialTransformation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Integration\Algorithms\DoubleExponentialTransformation.cs,EvaluateAbcissas,The following statement contains a magic number: int length = level == 0 ? 4 : (3 << (level - 1));
Magic Number,MathNet.Numerics.Integration.Algorithms,DoubleExponentialTransformation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Integration\Algorithms\DoubleExponentialTransformation.cs,EvaluateAbcissas,The following statement contains a magic number: int length = level == 0 ? 4 : (3 << (level - 1));
Magic Number,MathNet.Numerics.Integration.Algorithms,DoubleExponentialTransformation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Integration\Algorithms\DoubleExponentialTransformation.cs,EvaluateWeights,The following statement contains a magic number: double step = level <= 1 ? 1.0 : (1.0 / (2 << (level - 2)));
Magic Number,MathNet.Numerics.Integration.Algorithms,DoubleExponentialTransformation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Integration\Algorithms\DoubleExponentialTransformation.cs,EvaluateWeights,The following statement contains a magic number: double step = level <= 1 ? 1.0 : (1.0 / (2 << (level - 2)));
Magic Number,MathNet.Numerics.Integration.Algorithms,DoubleExponentialTransformation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Integration\Algorithms\DoubleExponentialTransformation.cs,EvaluateWeights,The following statement contains a magic number: double offset = level == 0 ? 0.0 : (1.0 / (2 << (level - 1)));
Magic Number,MathNet.Numerics.Integration.Algorithms,DoubleExponentialTransformation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Integration\Algorithms\DoubleExponentialTransformation.cs,EvaluateWeights,The following statement contains a magic number: int length = level == 0 ? 4 : (3 << (level - 1));
Magic Number,MathNet.Numerics.Integration.Algorithms,DoubleExponentialTransformation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Integration\Algorithms\DoubleExponentialTransformation.cs,EvaluateWeights,The following statement contains a magic number: int length = level == 0 ? 4 : (3 << (level - 1));
Magic Number,MathNet.Numerics.Integration.Algorithms,SimpsonRule,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Integration\Algorithms\SimpsonRule.cs,IntegrateThreePoint,The following statement contains a magic number: double midpoint = (intervalEnd + intervalBegin) / 2;
Magic Number,MathNet.Numerics.Integration.Algorithms,SimpsonRule,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Integration\Algorithms\SimpsonRule.cs,IntegrateThreePoint,The following statement contains a magic number: return (intervalEnd - intervalBegin) / 6 * (f(intervalBegin) + f(intervalEnd) + (4 * f(midpoint)));
Magic Number,MathNet.Numerics.Integration.Algorithms,SimpsonRule,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Integration\Algorithms\SimpsonRule.cs,IntegrateThreePoint,The following statement contains a magic number: return (intervalEnd - intervalBegin) / 6 * (f(intervalBegin) + f(intervalEnd) + (4 * f(midpoint)));
Magic Number,MathNet.Numerics.Integration.Algorithms,SimpsonRule,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Integration\Algorithms\SimpsonRule.cs,IntegrateComposite,The following statement contains a magic number: double factor = step / 3;
Magic Number,MathNet.Numerics.Integration.Algorithms,SimpsonRule,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Integration\Algorithms\SimpsonRule.cs,IntegrateComposite,The following statement contains a magic number: int m = 4;
Magic Number,MathNet.Numerics.Integration.Algorithms,SimpsonRule,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Integration\Algorithms\SimpsonRule.cs,IntegrateComposite,The following statement contains a magic number: for(int i = 0; i < numberOfPartitions - 1; i++)              {                  // NOTE (ruegg' 2009-01-07): Do not combine intervalBegin and offset (numerical stability!)                  sum += m * f(intervalBegin + offset);                  m = 6 - m;                  offset += step;              }
Magic Number,MathNet.Numerics.Integration.Algorithms,TrapeziumRule,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Integration\Algorithms\TrapeziumRule.cs,IntegrateTwoPoint,The following statement contains a magic number: return (intervalEnd - intervalBegin) / 2 * (f(intervalBegin) + f(intervalEnd));
Magic Number,MathNet.Numerics.Integration.Algorithms,TrapeziumRule,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Integration\Algorithms\TrapeziumRule.cs,IntegrateComposite,The following statement contains a magic number: double sum = 0.5 * (f(intervalBegin) + f(intervalEnd));
Magic Number,MathNet.Numerics.Integration.Algorithms,TrapeziumRule,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Integration\Algorithms\TrapeziumRule.cs,IntegrateAdaptive,The following statement contains a magic number: double sum = 0.5 * step * (f(intervalBegin) + f(intervalEnd));
Magic Number,MathNet.Numerics.Integration.Algorithms,TrapeziumRule,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Integration\Algorithms\TrapeziumRule.cs,IntegrateAdaptive,The following statement contains a magic number: for(int k = 0; k < 20; k++)              {                  double midpointsum = 0;                  for(int i = 0; i < numberOfPartitions; i++)                  {                      midpointsum += f(intervalBegin + ((i + 0.5) * step));                  }                    midpointsum *= step;                  sum = 0.5 * (sum + midpointsum);                  step *= 0.5;                  numberOfPartitions *= 2;                    if(Number.AlmostEqual(sum' midpointsum' targetRelativeError))                  {                      break;                  }              }
Magic Number,MathNet.Numerics.Integration.Algorithms,TrapeziumRule,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Integration\Algorithms\TrapeziumRule.cs,IntegrateAdaptive,The following statement contains a magic number: for(int k = 0; k < 20; k++)              {                  double midpointsum = 0;                  for(int i = 0; i < numberOfPartitions; i++)                  {                      midpointsum += f(intervalBegin + ((i + 0.5) * step));                  }                    midpointsum *= step;                  sum = 0.5 * (sum + midpointsum);                  step *= 0.5;                  numberOfPartitions *= 2;                    if(Number.AlmostEqual(sum' midpointsum' targetRelativeError))                  {                      break;                  }              }
Magic Number,MathNet.Numerics.Integration.Algorithms,TrapeziumRule,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Integration\Algorithms\TrapeziumRule.cs,IntegrateAdaptive,The following statement contains a magic number: for(int k = 0; k < 20; k++)              {                  double midpointsum = 0;                  for(int i = 0; i < numberOfPartitions; i++)                  {                      midpointsum += f(intervalBegin + ((i + 0.5) * step));                  }                    midpointsum *= step;                  sum = 0.5 * (sum + midpointsum);                  step *= 0.5;                  numberOfPartitions *= 2;                    if(Number.AlmostEqual(sum' midpointsum' targetRelativeError))                  {                      break;                  }              }
Magic Number,MathNet.Numerics.Integration.Algorithms,TrapeziumRule,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Integration\Algorithms\TrapeziumRule.cs,IntegrateAdaptive,The following statement contains a magic number: for(int k = 0; k < 20; k++)              {                  double midpointsum = 0;                  for(int i = 0; i < numberOfPartitions; i++)                  {                      midpointsum += f(intervalBegin + ((i + 0.5) * step));                  }                    midpointsum *= step;                  sum = 0.5 * (sum + midpointsum);                  step *= 0.5;                  numberOfPartitions *= 2;                    if(Number.AlmostEqual(sum' midpointsum' targetRelativeError))                  {                      break;                  }              }
Magic Number,MathNet.Numerics.Integration.Algorithms,TrapeziumRule,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Integration\Algorithms\TrapeziumRule.cs,IntegrateAdaptive,The following statement contains a magic number: for(int k = 0; k < 20; k++)              {                  double midpointsum = 0;                  for(int i = 0; i < numberOfPartitions; i++)                  {                      midpointsum += f(intervalBegin + ((i + 0.5) * step));                  }                    midpointsum *= step;                  sum = 0.5 * (sum + midpointsum);                  step *= 0.5;                  numberOfPartitions *= 2;                    if(Number.AlmostEqual(sum' midpointsum' targetRelativeError))                  {                      break;                  }              }
Magic Number,MathNet.Numerics.Integration.Algorithms,TrapeziumRule,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Integration\Algorithms\TrapeziumRule.cs,IntegrateAdaptiveTransformedOdd,The following statement contains a magic number: double linearSlope = 0.5 * (intervalEnd - intervalBegin);
Magic Number,MathNet.Numerics.Integration.Algorithms,TrapeziumRule,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Integration\Algorithms\TrapeziumRule.cs,IntegrateAdaptiveTransformedOdd,The following statement contains a magic number: double linearOffset = 0.5 * (intervalEnd + intervalBegin);
Magic Number,MathNet.Numerics.Integration.Algorithms,TrapeziumRule,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Integration\Algorithms\TrapeziumRule.cs,IntegrateAdaptiveTransformedOdd,The following statement contains a magic number: targetRelativeError /= (5 * linearSlope);
Magic Number,MathNet.Numerics.Integration.Algorithms,TrapeziumRule,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Integration\Algorithms\TrapeziumRule.cs,IntegrateAdaptiveTransformedOdd,The following statement contains a magic number: for(int level = 1; abcissasIterator.MoveNext() && weightsIterator.MoveNext(); level++)              {                  double[] abcissas = abcissasIterator.Current;                  double[] weights = weightsIterator.Current;                    double midpointsum = 0;                  for(int i = 0; i < abcissas.Length; i++)                  {                      midpointsum += weights[i] * (f((linearSlope * abcissas[i]) + linearOffset) + f(-(linearSlope * abcissas[i]) + linearOffset));                  }                    midpointsum *= step;                  sum = 0.5 * (sum + midpointsum);                  step *= 0.5;                    double delta = Math.Abs(sum - midpointsum);                    if(level == 1)                  {                      previousDelta = delta;                      continue;                  }                    double r = Math.Log(delta) / Math.Log(previousDelta);                  previousDelta = delta;                    if(r > 1.9 && r < 2.1)                  {                      // convergence region                      delta = Math.Sqrt(delta);                  }                    if(Number.AlmostEqualNorm(sum' midpointsum' delta' targetRelativeError))                  {                      break;                  }              }
Magic Number,MathNet.Numerics.Integration.Algorithms,TrapeziumRule,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Integration\Algorithms\TrapeziumRule.cs,IntegrateAdaptiveTransformedOdd,The following statement contains a magic number: for(int level = 1; abcissasIterator.MoveNext() && weightsIterator.MoveNext(); level++)              {                  double[] abcissas = abcissasIterator.Current;                  double[] weights = weightsIterator.Current;                    double midpointsum = 0;                  for(int i = 0; i < abcissas.Length; i++)                  {                      midpointsum += weights[i] * (f((linearSlope * abcissas[i]) + linearOffset) + f(-(linearSlope * abcissas[i]) + linearOffset));                  }                    midpointsum *= step;                  sum = 0.5 * (sum + midpointsum);                  step *= 0.5;                    double delta = Math.Abs(sum - midpointsum);                    if(level == 1)                  {                      previousDelta = delta;                      continue;                  }                    double r = Math.Log(delta) / Math.Log(previousDelta);                  previousDelta = delta;                    if(r > 1.9 && r < 2.1)                  {                      // convergence region                      delta = Math.Sqrt(delta);                  }                    if(Number.AlmostEqualNorm(sum' midpointsum' delta' targetRelativeError))                  {                      break;                  }              }
Magic Number,MathNet.Numerics.Integration.Algorithms,TrapeziumRule,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Integration\Algorithms\TrapeziumRule.cs,IntegrateAdaptiveTransformedOdd,The following statement contains a magic number: for(int level = 1; abcissasIterator.MoveNext() && weightsIterator.MoveNext(); level++)              {                  double[] abcissas = abcissasIterator.Current;                  double[] weights = weightsIterator.Current;                    double midpointsum = 0;                  for(int i = 0; i < abcissas.Length; i++)                  {                      midpointsum += weights[i] * (f((linearSlope * abcissas[i]) + linearOffset) + f(-(linearSlope * abcissas[i]) + linearOffset));                  }                    midpointsum *= step;                  sum = 0.5 * (sum + midpointsum);                  step *= 0.5;                    double delta = Math.Abs(sum - midpointsum);                    if(level == 1)                  {                      previousDelta = delta;                      continue;                  }                    double r = Math.Log(delta) / Math.Log(previousDelta);                  previousDelta = delta;                    if(r > 1.9 && r < 2.1)                  {                      // convergence region                      delta = Math.Sqrt(delta);                  }                    if(Number.AlmostEqualNorm(sum' midpointsum' delta' targetRelativeError))                  {                      break;                  }              }
Magic Number,MathNet.Numerics.Integration.Algorithms,TrapeziumRule,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Integration\Algorithms\TrapeziumRule.cs,IntegrateAdaptiveTransformedOdd,The following statement contains a magic number: for(int level = 1; abcissasIterator.MoveNext() && weightsIterator.MoveNext(); level++)              {                  double[] abcissas = abcissasIterator.Current;                  double[] weights = weightsIterator.Current;                    double midpointsum = 0;                  for(int i = 0; i < abcissas.Length; i++)                  {                      midpointsum += weights[i] * (f((linearSlope * abcissas[i]) + linearOffset) + f(-(linearSlope * abcissas[i]) + linearOffset));                  }                    midpointsum *= step;                  sum = 0.5 * (sum + midpointsum);                  step *= 0.5;                    double delta = Math.Abs(sum - midpointsum);                    if(level == 1)                  {                      previousDelta = delta;                      continue;                  }                    double r = Math.Log(delta) / Math.Log(previousDelta);                  previousDelta = delta;                    if(r > 1.9 && r < 2.1)                  {                      // convergence region                      delta = Math.Sqrt(delta);                  }                    if(Number.AlmostEqualNorm(sum' midpointsum' delta' targetRelativeError))                  {                      break;                  }              }
Magic Number,MathNet.Numerics.Integration,Integrate,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Integration\Integrate.cs,OnClosedInterval,The following statement contains a magic number: return Det.Integrate(                  f'                  intervalBegin'                  intervalEnd'                  1e-8);
Magic Number,MathNet.Numerics.Interpolation.Algorithms,AkimaSplineInterpolation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\AkimaSplineInterpolation.cs,Init,The following statement contains a magic number: if(t.Count < 5)              {                  throw new ArgumentOutOfRangeException("t");              }
Magic Number,MathNet.Numerics.Interpolation.Algorithms,AkimaSplineInterpolation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\AkimaSplineInterpolation.cs,Init,The following statement contains a magic number: for(int i = 2; i < d.Length - 2; i++)              {                  if(!Number.AlmostZero(w[i - 1]) || !Number.AlmostZero(w[i + 1]))                  {                      d[i] = ((w[i + 1] * diff[i - 1]) + (w[i - 1] * diff[i])) / (w[i + 1] + w[i - 1]);                  }                  else                  {                      d[i] = (((tt[i + 1] - tt[i]) * diff[i - 1]) + ((tt[i] - tt[i - 1]) * diff[i])) / (tt[i + 1] - tt[i - 1]);                  }              }
Magic Number,MathNet.Numerics.Interpolation.Algorithms,AkimaSplineInterpolation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\AkimaSplineInterpolation.cs,Init,The following statement contains a magic number: for(int i = 2; i < d.Length - 2; i++)              {                  if(!Number.AlmostZero(w[i - 1]) || !Number.AlmostZero(w[i + 1]))                  {                      d[i] = ((w[i + 1] * diff[i - 1]) + (w[i - 1] * diff[i])) / (w[i + 1] + w[i - 1]);                  }                  else                  {                      d[i] = (((tt[i + 1] - tt[i]) * diff[i - 1]) + ((tt[i] - tt[i - 1]) * diff[i])) / (tt[i + 1] - tt[i - 1]);                  }              }
Magic Number,MathNet.Numerics.Interpolation.Algorithms,AkimaSplineInterpolation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\AkimaSplineInterpolation.cs,Init,The following statement contains a magic number: d[0] = DifferentiateThreePoint(tt[0]' tt[0]' xx[0]' tt[1]' xx[1]' tt[2]' xx[2]);
Magic Number,MathNet.Numerics.Interpolation.Algorithms,AkimaSplineInterpolation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\AkimaSplineInterpolation.cs,Init,The following statement contains a magic number: d[0] = DifferentiateThreePoint(tt[0]' tt[0]' xx[0]' tt[1]' xx[1]' tt[2]' xx[2]);
Magic Number,MathNet.Numerics.Interpolation.Algorithms,AkimaSplineInterpolation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\AkimaSplineInterpolation.cs,Init,The following statement contains a magic number: d[1] = DifferentiateThreePoint(tt[1]' tt[0]' xx[0]' tt[1]' xx[1]' tt[2]' xx[2]);
Magic Number,MathNet.Numerics.Interpolation.Algorithms,AkimaSplineInterpolation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\AkimaSplineInterpolation.cs,Init,The following statement contains a magic number: d[1] = DifferentiateThreePoint(tt[1]' tt[0]' xx[0]' tt[1]' xx[1]' tt[2]' xx[2]);
Magic Number,MathNet.Numerics.Interpolation.Algorithms,AkimaSplineInterpolation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\AkimaSplineInterpolation.cs,Init,The following statement contains a magic number: d[n - 2] = DifferentiateThreePoint(tt[n - 2]' tt[n - 3]' xx[n - 3]' tt[n - 2]' xx[n - 2]' tt[n - 1]' xx[n - 1]);
Magic Number,MathNet.Numerics.Interpolation.Algorithms,AkimaSplineInterpolation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\AkimaSplineInterpolation.cs,Init,The following statement contains a magic number: d[n - 2] = DifferentiateThreePoint(tt[n - 2]' tt[n - 3]' xx[n - 3]' tt[n - 2]' xx[n - 2]' tt[n - 1]' xx[n - 1]);
Magic Number,MathNet.Numerics.Interpolation.Algorithms,AkimaSplineInterpolation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\AkimaSplineInterpolation.cs,Init,The following statement contains a magic number: d[n - 2] = DifferentiateThreePoint(tt[n - 2]' tt[n - 3]' xx[n - 3]' tt[n - 2]' xx[n - 2]' tt[n - 1]' xx[n - 1]);
Magic Number,MathNet.Numerics.Interpolation.Algorithms,AkimaSplineInterpolation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\AkimaSplineInterpolation.cs,Init,The following statement contains a magic number: d[n - 2] = DifferentiateThreePoint(tt[n - 2]' tt[n - 3]' xx[n - 3]' tt[n - 2]' xx[n - 2]' tt[n - 1]' xx[n - 1]);
Magic Number,MathNet.Numerics.Interpolation.Algorithms,AkimaSplineInterpolation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\AkimaSplineInterpolation.cs,Init,The following statement contains a magic number: d[n - 2] = DifferentiateThreePoint(tt[n - 2]' tt[n - 3]' xx[n - 3]' tt[n - 2]' xx[n - 2]' tt[n - 1]' xx[n - 1]);
Magic Number,MathNet.Numerics.Interpolation.Algorithms,AkimaSplineInterpolation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\AkimaSplineInterpolation.cs,Init,The following statement contains a magic number: d[n - 2] = DifferentiateThreePoint(tt[n - 2]' tt[n - 3]' xx[n - 3]' tt[n - 2]' xx[n - 2]' tt[n - 1]' xx[n - 1]);
Magic Number,MathNet.Numerics.Interpolation.Algorithms,AkimaSplineInterpolation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\AkimaSplineInterpolation.cs,Init,The following statement contains a magic number: d[n - 1] = DifferentiateThreePoint(tt[n - 1]' tt[n - 3]' xx[n - 3]' tt[n - 2]' xx[n - 2]' tt[n - 1]' xx[n - 1]);
Magic Number,MathNet.Numerics.Interpolation.Algorithms,AkimaSplineInterpolation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\AkimaSplineInterpolation.cs,Init,The following statement contains a magic number: d[n - 1] = DifferentiateThreePoint(tt[n - 1]' tt[n - 3]' xx[n - 3]' tt[n - 2]' xx[n - 2]' tt[n - 1]' xx[n - 1]);
Magic Number,MathNet.Numerics.Interpolation.Algorithms,AkimaSplineInterpolation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\AkimaSplineInterpolation.cs,Init,The following statement contains a magic number: d[n - 1] = DifferentiateThreePoint(tt[n - 1]' tt[n - 3]' xx[n - 3]' tt[n - 2]' xx[n - 2]' tt[n - 1]' xx[n - 1]);
Magic Number,MathNet.Numerics.Interpolation.Algorithms,AkimaSplineInterpolation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\AkimaSplineInterpolation.cs,Init,The following statement contains a magic number: d[n - 1] = DifferentiateThreePoint(tt[n - 1]' tt[n - 3]' xx[n - 3]' tt[n - 2]' xx[n - 2]' tt[n - 1]' xx[n - 1]);
Magic Number,MathNet.Numerics.Interpolation.Algorithms,AkimaSplineInterpolation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\AkimaSplineInterpolation.cs,DifferentiateThreePoint,The following statement contains a magic number: return (2 * a * t) + b;
Magic Number,MathNet.Numerics.Interpolation.Algorithms,BarycentricInterpolation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\BarycentricInterpolation.cs,Interpolate,The following statement contains a magic number: if(Math.Abs(s) > 1e-150)              {                  // use fast formula                  j = -1;                  s = 1.0;              }
Magic Number,MathNet.Numerics.Interpolation.Algorithms,ChebyshevFirstKindPolynomialInterpolation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\ChebyshevFirstKindPolynomialInterpolation.cs,Init,The following statement contains a magic number: _transformSummand = -0.5 * (a + b);
Magic Number,MathNet.Numerics.Interpolation.Algorithms,ChebyshevFirstKindPolynomialInterpolation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\ChebyshevFirstKindPolynomialInterpolation.cs,Init,The following statement contains a magic number: _transformFactor = 2.0 / (b - a);
Magic Number,MathNet.Numerics.Interpolation.Algorithms,ChebyshevFirstKindPolynomialInterpolation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\ChebyshevFirstKindPolynomialInterpolation.cs,Init,The following statement contains a magic number: double a0 = Math.PI / ((2 * (x.Count - 1)) + 2);
Magic Number,MathNet.Numerics.Interpolation.Algorithms,ChebyshevFirstKindPolynomialInterpolation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\ChebyshevFirstKindPolynomialInterpolation.cs,Init,The following statement contains a magic number: double a0 = Math.PI / ((2 * (x.Count - 1)) + 2);
Magic Number,MathNet.Numerics.Interpolation.Algorithms,ChebyshevFirstKindPolynomialInterpolation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\ChebyshevFirstKindPolynomialInterpolation.cs,Init,The following statement contains a magic number: double delta = 2 * Math.PI / ((2 * (x.Count - 1)) + 2);
Magic Number,MathNet.Numerics.Interpolation.Algorithms,ChebyshevFirstKindPolynomialInterpolation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\ChebyshevFirstKindPolynomialInterpolation.cs,Init,The following statement contains a magic number: double delta = 2 * Math.PI / ((2 * (x.Count - 1)) + 2);
Magic Number,MathNet.Numerics.Interpolation.Algorithms,ChebyshevFirstKindPolynomialInterpolation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\ChebyshevFirstKindPolynomialInterpolation.cs,Init,The following statement contains a magic number: double delta = 2 * Math.PI / ((2 * (x.Count - 1)) + 2);
Magic Number,MathNet.Numerics.Interpolation.Algorithms,ChebyshevFirstKindPolynomialInterpolation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\ChebyshevFirstKindPolynomialInterpolation.cs,Init,The following statement contains a magic number: double alpha = Math.Sin(delta / 2);
Magic Number,MathNet.Numerics.Interpolation.Algorithms,ChebyshevFirstKindPolynomialInterpolation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\ChebyshevFirstKindPolynomialInterpolation.cs,Init,The following statement contains a magic number: alpha = 2 * alpha * alpha;
Magic Number,MathNet.Numerics.Interpolation.Algorithms,ChebyshevFirstKindPolynomialInterpolation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\ChebyshevFirstKindPolynomialInterpolation.cs,GenerateSamplePoints,The following statement contains a magic number: double transformSummand = 0.5 * (a + b);
Magic Number,MathNet.Numerics.Interpolation.Algorithms,ChebyshevFirstKindPolynomialInterpolation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\ChebyshevFirstKindPolynomialInterpolation.cs,GenerateSamplePoints,The following statement contains a magic number: double transformFactor = (b - a) / 2.0;
Magic Number,MathNet.Numerics.Interpolation.Algorithms,ChebyshevFirstKindPolynomialInterpolation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\ChebyshevFirstKindPolynomialInterpolation.cs,GenerateSamplePoints,The following statement contains a magic number: double angleFactor = Math.PI / ((2 * (numberOfPoints - 1)) + 2);
Magic Number,MathNet.Numerics.Interpolation.Algorithms,ChebyshevFirstKindPolynomialInterpolation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\ChebyshevFirstKindPolynomialInterpolation.cs,GenerateSamplePoints,The following statement contains a magic number: double angleFactor = Math.PI / ((2 * (numberOfPoints - 1)) + 2);
Magic Number,MathNet.Numerics.Interpolation.Algorithms,ChebyshevFirstKindPolynomialInterpolation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\ChebyshevFirstKindPolynomialInterpolation.cs,GenerateSamplePoints,The following statement contains a magic number: for(int i = 0; i < numberOfPoints; i++)              {                  nodes[i] = transformSummand + (transformFactor * Math.Cos(((2 * i) + 1) * angleFactor));              }
Magic Number,MathNet.Numerics.Interpolation.Algorithms,ChebyshevSecondKindPolynomialInterpolation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\ChebyshevSecondKindPolynomialInterpolation.cs,Init,The following statement contains a magic number: _transformSummand = -0.5 * (a + b);
Magic Number,MathNet.Numerics.Interpolation.Algorithms,ChebyshevSecondKindPolynomialInterpolation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\ChebyshevSecondKindPolynomialInterpolation.cs,Init,The following statement contains a magic number: _transformFactor = 2.0 / (b - a);
Magic Number,MathNet.Numerics.Interpolation.Algorithms,ChebyshevSecondKindPolynomialInterpolation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\ChebyshevSecondKindPolynomialInterpolation.cs,Init,The following statement contains a magic number: double alpha = Math.Sin(delta / 2);
Magic Number,MathNet.Numerics.Interpolation.Algorithms,ChebyshevSecondKindPolynomialInterpolation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\ChebyshevSecondKindPolynomialInterpolation.cs,Init,The following statement contains a magic number: alpha = 2 * alpha * alpha;
Magic Number,MathNet.Numerics.Interpolation.Algorithms,ChebyshevSecondKindPolynomialInterpolation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\ChebyshevSecondKindPolynomialInterpolation.cs,Init,The following statement contains a magic number: w[0] = 0.5;
Magic Number,MathNet.Numerics.Interpolation.Algorithms,ChebyshevSecondKindPolynomialInterpolation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\ChebyshevSecondKindPolynomialInterpolation.cs,Init,The following statement contains a magic number: w[w.Length - 1] *= 0.5;
Magic Number,MathNet.Numerics.Interpolation.Algorithms,ChebyshevSecondKindPolynomialInterpolation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\ChebyshevSecondKindPolynomialInterpolation.cs,GenerateSamplePoints,The following statement contains a magic number: double transformSummand = 0.5 * (a + b);
Magic Number,MathNet.Numerics.Interpolation.Algorithms,ChebyshevSecondKindPolynomialInterpolation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\ChebyshevSecondKindPolynomialInterpolation.cs,GenerateSamplePoints,The following statement contains a magic number: double transformFactor = (b - a) / 2.0;
Magic Number,MathNet.Numerics.Interpolation.Algorithms,CubicHermiteSplineInterpolation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\CubicHermiteSplineInterpolation.cs,Init,The following statement contains a magic number: if(t.Count < 2)              {                  throw new ArgumentOutOfRangeException("t");              }
Magic Number,MathNet.Numerics.Interpolation.Algorithms,CubicHermiteSplineInterpolation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\CubicHermiteSplineInterpolation.cs,InitInternal,The following statement contains a magic number: double[] c = new double[4 * (t.Length - 1)];
Magic Number,MathNet.Numerics.Interpolation.Algorithms,CubicHermiteSplineInterpolation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\CubicHermiteSplineInterpolation.cs,InitInternal,The following statement contains a magic number: for(int i = 0' j = 0; i < t.Length - 1; i++' j += 4)              {                  double delta = t[i + 1] - t[i];                  double delta2 = delta * delta;                  double delta3 = delta * delta2;                  c[j] = x[i];                  c[j + 1] = d[i];                  c[j + 2] = ((3 * (x[i + 1] - x[i])) - (2 * d[i] * delta) - (d[i + 1] * delta)) / delta2;                  c[j + 3] = ((2 * (x[i] - x[i + 1])) + (d[i] * delta) + (d[i + 1] * delta)) / delta3;              }
Magic Number,MathNet.Numerics.Interpolation.Algorithms,CubicHermiteSplineInterpolation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\CubicHermiteSplineInterpolation.cs,InitInternal,The following statement contains a magic number: for(int i = 0' j = 0; i < t.Length - 1; i++' j += 4)              {                  double delta = t[i + 1] - t[i];                  double delta2 = delta * delta;                  double delta3 = delta * delta2;                  c[j] = x[i];                  c[j + 1] = d[i];                  c[j + 2] = ((3 * (x[i + 1] - x[i])) - (2 * d[i] * delta) - (d[i + 1] * delta)) / delta2;                  c[j + 3] = ((2 * (x[i] - x[i + 1])) + (d[i] * delta) + (d[i + 1] * delta)) / delta3;              }
Magic Number,MathNet.Numerics.Interpolation.Algorithms,CubicHermiteSplineInterpolation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\CubicHermiteSplineInterpolation.cs,InitInternal,The following statement contains a magic number: for(int i = 0' j = 0; i < t.Length - 1; i++' j += 4)              {                  double delta = t[i + 1] - t[i];                  double delta2 = delta * delta;                  double delta3 = delta * delta2;                  c[j] = x[i];                  c[j + 1] = d[i];                  c[j + 2] = ((3 * (x[i + 1] - x[i])) - (2 * d[i] * delta) - (d[i + 1] * delta)) / delta2;                  c[j + 3] = ((2 * (x[i] - x[i + 1])) + (d[i] * delta) + (d[i + 1] * delta)) / delta3;              }
Magic Number,MathNet.Numerics.Interpolation.Algorithms,CubicHermiteSplineInterpolation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\CubicHermiteSplineInterpolation.cs,InitInternal,The following statement contains a magic number: for(int i = 0' j = 0; i < t.Length - 1; i++' j += 4)              {                  double delta = t[i + 1] - t[i];                  double delta2 = delta * delta;                  double delta3 = delta * delta2;                  c[j] = x[i];                  c[j + 1] = d[i];                  c[j + 2] = ((3 * (x[i + 1] - x[i])) - (2 * d[i] * delta) - (d[i + 1] * delta)) / delta2;                  c[j + 3] = ((2 * (x[i] - x[i + 1])) + (d[i] * delta) + (d[i + 1] * delta)) / delta3;              }
Magic Number,MathNet.Numerics.Interpolation.Algorithms,CubicHermiteSplineInterpolation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\CubicHermiteSplineInterpolation.cs,InitInternal,The following statement contains a magic number: for(int i = 0' j = 0; i < t.Length - 1; i++' j += 4)              {                  double delta = t[i + 1] - t[i];                  double delta2 = delta * delta;                  double delta3 = delta * delta2;                  c[j] = x[i];                  c[j + 1] = d[i];                  c[j + 2] = ((3 * (x[i + 1] - x[i])) - (2 * d[i] * delta) - (d[i + 1] * delta)) / delta2;                  c[j + 3] = ((2 * (x[i] - x[i + 1])) + (d[i] * delta) + (d[i + 1] * delta)) / delta3;              }
Magic Number,MathNet.Numerics.Interpolation.Algorithms,CubicHermiteSplineInterpolation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\CubicHermiteSplineInterpolation.cs,InitInternal,The following statement contains a magic number: for(int i = 0' j = 0; i < t.Length - 1; i++' j += 4)              {                  double delta = t[i + 1] - t[i];                  double delta2 = delta * delta;                  double delta3 = delta * delta2;                  c[j] = x[i];                  c[j + 1] = d[i];                  c[j + 2] = ((3 * (x[i + 1] - x[i])) - (2 * d[i] * delta) - (d[i + 1] * delta)) / delta2;                  c[j + 3] = ((2 * (x[i] - x[i + 1])) + (d[i] * delta) + (d[i + 1] * delta)) / delta3;              }
Magic Number,MathNet.Numerics.Interpolation.Algorithms,CubicSplineInterpolation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\CubicSplineInterpolation.cs,Init,The following statement contains a magic number: if(t.Count < 2)              {                  throw new ArgumentOutOfRangeException("t");              }
Magic Number,MathNet.Numerics.Interpolation.Algorithms,CubicSplineInterpolation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\CubicSplineInterpolation.cs,Init,The following statement contains a magic number: if((n == 2)                  && (leftBoundaryCondition == SplineBoundaryCondition.ParabolicallyTerminated)                  && (rightBoundaryCondition == SplineBoundaryCondition.ParabolicallyTerminated))              {                  leftBoundaryCondition = SplineBoundaryCondition.SecondDerivative;                  leftBoundary = 0d;                  rightBoundaryCondition = SplineBoundaryCondition.SecondDerivative;                  rightBoundary = 0d;              }
Magic Number,MathNet.Numerics.Interpolation.Algorithms,CubicSplineInterpolation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\CubicSplineInterpolation.cs,Init,The following statement contains a magic number: switch(leftBoundaryCondition)              {                  case SplineBoundaryCondition.ParabolicallyTerminated:                      a1[0] = 0;                      a2[0] = 1;                      a3[0] = 1;                      b[0] = 2 * (xx[1] - xx[0]) / (tt[1] - tt[0]);                      break;                  case SplineBoundaryCondition.FirstDerivative:                      a1[0] = 0;                      a2[0] = 1;                      a3[0] = 0;                      b[0] = leftBoundary;                      break;                  case SplineBoundaryCondition.SecondDerivative:                      a1[0] = 0;                      a2[0] = 2;                      a3[0] = 1;                      b[0] = (3 * ((xx[1] - xx[0]) / (tt[1] - tt[0]))) - (0.5 * leftBoundary * (tt[1] - tt[0]));                      break;                  default:                      throw new NotSupportedException(Properties.LocalStrings.InvalidLeftBoundaryCondition);              }
Magic Number,MathNet.Numerics.Interpolation.Algorithms,CubicSplineInterpolation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\CubicSplineInterpolation.cs,Init,The following statement contains a magic number: switch(leftBoundaryCondition)              {                  case SplineBoundaryCondition.ParabolicallyTerminated:                      a1[0] = 0;                      a2[0] = 1;                      a3[0] = 1;                      b[0] = 2 * (xx[1] - xx[0]) / (tt[1] - tt[0]);                      break;                  case SplineBoundaryCondition.FirstDerivative:                      a1[0] = 0;                      a2[0] = 1;                      a3[0] = 0;                      b[0] = leftBoundary;                      break;                  case SplineBoundaryCondition.SecondDerivative:                      a1[0] = 0;                      a2[0] = 2;                      a3[0] = 1;                      b[0] = (3 * ((xx[1] - xx[0]) / (tt[1] - tt[0]))) - (0.5 * leftBoundary * (tt[1] - tt[0]));                      break;                  default:                      throw new NotSupportedException(Properties.LocalStrings.InvalidLeftBoundaryCondition);              }
Magic Number,MathNet.Numerics.Interpolation.Algorithms,CubicSplineInterpolation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\CubicSplineInterpolation.cs,Init,The following statement contains a magic number: switch(leftBoundaryCondition)              {                  case SplineBoundaryCondition.ParabolicallyTerminated:                      a1[0] = 0;                      a2[0] = 1;                      a3[0] = 1;                      b[0] = 2 * (xx[1] - xx[0]) / (tt[1] - tt[0]);                      break;                  case SplineBoundaryCondition.FirstDerivative:                      a1[0] = 0;                      a2[0] = 1;                      a3[0] = 0;                      b[0] = leftBoundary;                      break;                  case SplineBoundaryCondition.SecondDerivative:                      a1[0] = 0;                      a2[0] = 2;                      a3[0] = 1;                      b[0] = (3 * ((xx[1] - xx[0]) / (tt[1] - tt[0]))) - (0.5 * leftBoundary * (tt[1] - tt[0]));                      break;                  default:                      throw new NotSupportedException(Properties.LocalStrings.InvalidLeftBoundaryCondition);              }
Magic Number,MathNet.Numerics.Interpolation.Algorithms,CubicSplineInterpolation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\CubicSplineInterpolation.cs,Init,The following statement contains a magic number: switch(leftBoundaryCondition)              {                  case SplineBoundaryCondition.ParabolicallyTerminated:                      a1[0] = 0;                      a2[0] = 1;                      a3[0] = 1;                      b[0] = 2 * (xx[1] - xx[0]) / (tt[1] - tt[0]);                      break;                  case SplineBoundaryCondition.FirstDerivative:                      a1[0] = 0;                      a2[0] = 1;                      a3[0] = 0;                      b[0] = leftBoundary;                      break;                  case SplineBoundaryCondition.SecondDerivative:                      a1[0] = 0;                      a2[0] = 2;                      a3[0] = 1;                      b[0] = (3 * ((xx[1] - xx[0]) / (tt[1] - tt[0]))) - (0.5 * leftBoundary * (tt[1] - tt[0]));                      break;                  default:                      throw new NotSupportedException(Properties.LocalStrings.InvalidLeftBoundaryCondition);              }
Magic Number,MathNet.Numerics.Interpolation.Algorithms,CubicSplineInterpolation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\CubicSplineInterpolation.cs,Init,The following statement contains a magic number: for(int i = 1; i < tt.Length - 1; i++)              {                  a1[i] = tt[i + 1] - tt[i];                  a2[i] = 2 * (tt[i + 1] - tt[i - 1]);                  a3[i] = tt[i] - tt[i - 1];                  b[i] = (3 * (xx[i] - xx[i - 1]) / (tt[i] - tt[i - 1]) * (tt[i + 1] - tt[i])) + (3 * (xx[i + 1] - xx[i]) / (tt[i + 1] - tt[i]) * (tt[i] - tt[i - 1]));              }
Magic Number,MathNet.Numerics.Interpolation.Algorithms,CubicSplineInterpolation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\CubicSplineInterpolation.cs,Init,The following statement contains a magic number: for(int i = 1; i < tt.Length - 1; i++)              {                  a1[i] = tt[i + 1] - tt[i];                  a2[i] = 2 * (tt[i + 1] - tt[i - 1]);                  a3[i] = tt[i] - tt[i - 1];                  b[i] = (3 * (xx[i] - xx[i - 1]) / (tt[i] - tt[i - 1]) * (tt[i + 1] - tt[i])) + (3 * (xx[i + 1] - xx[i]) / (tt[i + 1] - tt[i]) * (tt[i] - tt[i - 1]));              }
Magic Number,MathNet.Numerics.Interpolation.Algorithms,CubicSplineInterpolation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\CubicSplineInterpolation.cs,Init,The following statement contains a magic number: for(int i = 1; i < tt.Length - 1; i++)              {                  a1[i] = tt[i + 1] - tt[i];                  a2[i] = 2 * (tt[i + 1] - tt[i - 1]);                  a3[i] = tt[i] - tt[i - 1];                  b[i] = (3 * (xx[i] - xx[i - 1]) / (tt[i] - tt[i - 1]) * (tt[i + 1] - tt[i])) + (3 * (xx[i + 1] - xx[i]) / (tt[i + 1] - tt[i]) * (tt[i] - tt[i - 1]));              }
Magic Number,MathNet.Numerics.Interpolation.Algorithms,CubicSplineInterpolation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\CubicSplineInterpolation.cs,Init,The following statement contains a magic number: switch(rightBoundaryCondition)              {                  case SplineBoundaryCondition.ParabolicallyTerminated:                      a1[n - 1] = 1;                      a2[n - 1] = 1;                      a3[n - 1] = 0;                      b[n - 1] = 2 * (xx[n - 1] - xx[n - 2]) / (tt[n - 1] - tt[n - 2]);                      break;                  case SplineBoundaryCondition.FirstDerivative:                      a1[n - 1] = 0;                      a2[n - 1] = 1;                      a3[n - 1] = 0;                      b[n - 1] = rightBoundary;                      break;                  case SplineBoundaryCondition.SecondDerivative:                      a1[n - 1] = 1;                      a2[n - 1] = 2;                      a3[n - 1] = 0;                      b[n - 1] = (3 * (xx[n - 1] - xx[n - 2]) / (tt[n - 1] - tt[n - 2])) + (0.5 * rightBoundary * (tt[n - 1] - tt[n - 2]));                      break;                  default:                      throw new NotSupportedException(Properties.LocalStrings.InvalidRightBoundaryCondition);              }
Magic Number,MathNet.Numerics.Interpolation.Algorithms,CubicSplineInterpolation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\CubicSplineInterpolation.cs,Init,The following statement contains a magic number: switch(rightBoundaryCondition)              {                  case SplineBoundaryCondition.ParabolicallyTerminated:                      a1[n - 1] = 1;                      a2[n - 1] = 1;                      a3[n - 1] = 0;                      b[n - 1] = 2 * (xx[n - 1] - xx[n - 2]) / (tt[n - 1] - tt[n - 2]);                      break;                  case SplineBoundaryCondition.FirstDerivative:                      a1[n - 1] = 0;                      a2[n - 1] = 1;                      a3[n - 1] = 0;                      b[n - 1] = rightBoundary;                      break;                  case SplineBoundaryCondition.SecondDerivative:                      a1[n - 1] = 1;                      a2[n - 1] = 2;                      a3[n - 1] = 0;                      b[n - 1] = (3 * (xx[n - 1] - xx[n - 2]) / (tt[n - 1] - tt[n - 2])) + (0.5 * rightBoundary * (tt[n - 1] - tt[n - 2]));                      break;                  default:                      throw new NotSupportedException(Properties.LocalStrings.InvalidRightBoundaryCondition);              }
Magic Number,MathNet.Numerics.Interpolation.Algorithms,CubicSplineInterpolation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\CubicSplineInterpolation.cs,Init,The following statement contains a magic number: switch(rightBoundaryCondition)              {                  case SplineBoundaryCondition.ParabolicallyTerminated:                      a1[n - 1] = 1;                      a2[n - 1] = 1;                      a3[n - 1] = 0;                      b[n - 1] = 2 * (xx[n - 1] - xx[n - 2]) / (tt[n - 1] - tt[n - 2]);                      break;                  case SplineBoundaryCondition.FirstDerivative:                      a1[n - 1] = 0;                      a2[n - 1] = 1;                      a3[n - 1] = 0;                      b[n - 1] = rightBoundary;                      break;                  case SplineBoundaryCondition.SecondDerivative:                      a1[n - 1] = 1;                      a2[n - 1] = 2;                      a3[n - 1] = 0;                      b[n - 1] = (3 * (xx[n - 1] - xx[n - 2]) / (tt[n - 1] - tt[n - 2])) + (0.5 * rightBoundary * (tt[n - 1] - tt[n - 2]));                      break;                  default:                      throw new NotSupportedException(Properties.LocalStrings.InvalidRightBoundaryCondition);              }
Magic Number,MathNet.Numerics.Interpolation.Algorithms,CubicSplineInterpolation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\CubicSplineInterpolation.cs,Init,The following statement contains a magic number: switch(rightBoundaryCondition)              {                  case SplineBoundaryCondition.ParabolicallyTerminated:                      a1[n - 1] = 1;                      a2[n - 1] = 1;                      a3[n - 1] = 0;                      b[n - 1] = 2 * (xx[n - 1] - xx[n - 2]) / (tt[n - 1] - tt[n - 2]);                      break;                  case SplineBoundaryCondition.FirstDerivative:                      a1[n - 1] = 0;                      a2[n - 1] = 1;                      a3[n - 1] = 0;                      b[n - 1] = rightBoundary;                      break;                  case SplineBoundaryCondition.SecondDerivative:                      a1[n - 1] = 1;                      a2[n - 1] = 2;                      a3[n - 1] = 0;                      b[n - 1] = (3 * (xx[n - 1] - xx[n - 2]) / (tt[n - 1] - tt[n - 2])) + (0.5 * rightBoundary * (tt[n - 1] - tt[n - 2]));                      break;                  default:                      throw new NotSupportedException(Properties.LocalStrings.InvalidRightBoundaryCondition);              }
Magic Number,MathNet.Numerics.Interpolation.Algorithms,CubicSplineInterpolation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\CubicSplineInterpolation.cs,Init,The following statement contains a magic number: switch(rightBoundaryCondition)              {                  case SplineBoundaryCondition.ParabolicallyTerminated:                      a1[n - 1] = 1;                      a2[n - 1] = 1;                      a3[n - 1] = 0;                      b[n - 1] = 2 * (xx[n - 1] - xx[n - 2]) / (tt[n - 1] - tt[n - 2]);                      break;                  case SplineBoundaryCondition.FirstDerivative:                      a1[n - 1] = 0;                      a2[n - 1] = 1;                      a3[n - 1] = 0;                      b[n - 1] = rightBoundary;                      break;                  case SplineBoundaryCondition.SecondDerivative:                      a1[n - 1] = 1;                      a2[n - 1] = 2;                      a3[n - 1] = 0;                      b[n - 1] = (3 * (xx[n - 1] - xx[n - 2]) / (tt[n - 1] - tt[n - 2])) + (0.5 * rightBoundary * (tt[n - 1] - tt[n - 2]));                      break;                  default:                      throw new NotSupportedException(Properties.LocalStrings.InvalidRightBoundaryCondition);              }
Magic Number,MathNet.Numerics.Interpolation.Algorithms,CubicSplineInterpolation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\CubicSplineInterpolation.cs,Init,The following statement contains a magic number: switch(rightBoundaryCondition)              {                  case SplineBoundaryCondition.ParabolicallyTerminated:                      a1[n - 1] = 1;                      a2[n - 1] = 1;                      a3[n - 1] = 0;                      b[n - 1] = 2 * (xx[n - 1] - xx[n - 2]) / (tt[n - 1] - tt[n - 2]);                      break;                  case SplineBoundaryCondition.FirstDerivative:                      a1[n - 1] = 0;                      a2[n - 1] = 1;                      a3[n - 1] = 0;                      b[n - 1] = rightBoundary;                      break;                  case SplineBoundaryCondition.SecondDerivative:                      a1[n - 1] = 1;                      a2[n - 1] = 2;                      a3[n - 1] = 0;                      b[n - 1] = (3 * (xx[n - 1] - xx[n - 2]) / (tt[n - 1] - tt[n - 2])) + (0.5 * rightBoundary * (tt[n - 1] - tt[n - 2]));                      break;                  default:                      throw new NotSupportedException(Properties.LocalStrings.InvalidRightBoundaryCondition);              }
Magic Number,MathNet.Numerics.Interpolation.Algorithms,CubicSplineInterpolation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\CubicSplineInterpolation.cs,Init,The following statement contains a magic number: switch(rightBoundaryCondition)              {                  case SplineBoundaryCondition.ParabolicallyTerminated:                      a1[n - 1] = 1;                      a2[n - 1] = 1;                      a3[n - 1] = 0;                      b[n - 1] = 2 * (xx[n - 1] - xx[n - 2]) / (tt[n - 1] - tt[n - 2]);                      break;                  case SplineBoundaryCondition.FirstDerivative:                      a1[n - 1] = 0;                      a2[n - 1] = 1;                      a3[n - 1] = 0;                      b[n - 1] = rightBoundary;                      break;                  case SplineBoundaryCondition.SecondDerivative:                      a1[n - 1] = 1;                      a2[n - 1] = 2;                      a3[n - 1] = 0;                      b[n - 1] = (3 * (xx[n - 1] - xx[n - 2]) / (tt[n - 1] - tt[n - 2])) + (0.5 * rightBoundary * (tt[n - 1] - tt[n - 2]));                      break;                  default:                      throw new NotSupportedException(Properties.LocalStrings.InvalidRightBoundaryCondition);              }
Magic Number,MathNet.Numerics.Interpolation.Algorithms,CubicSplineInterpolation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\CubicSplineInterpolation.cs,Init,The following statement contains a magic number: switch(rightBoundaryCondition)              {                  case SplineBoundaryCondition.ParabolicallyTerminated:                      a1[n - 1] = 1;                      a2[n - 1] = 1;                      a3[n - 1] = 0;                      b[n - 1] = 2 * (xx[n - 1] - xx[n - 2]) / (tt[n - 1] - tt[n - 2]);                      break;                  case SplineBoundaryCondition.FirstDerivative:                      a1[n - 1] = 0;                      a2[n - 1] = 1;                      a3[n - 1] = 0;                      b[n - 1] = rightBoundary;                      break;                  case SplineBoundaryCondition.SecondDerivative:                      a1[n - 1] = 1;                      a2[n - 1] = 2;                      a3[n - 1] = 0;                      b[n - 1] = (3 * (xx[n - 1] - xx[n - 2]) / (tt[n - 1] - tt[n - 2])) + (0.5 * rightBoundary * (tt[n - 1] - tt[n - 2]));                      break;                  default:                      throw new NotSupportedException(Properties.LocalStrings.InvalidRightBoundaryCondition);              }
Magic Number,MathNet.Numerics.Interpolation.Algorithms,CubicSplineInterpolation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\CubicSplineInterpolation.cs,Init,The following statement contains a magic number: switch(rightBoundaryCondition)              {                  case SplineBoundaryCondition.ParabolicallyTerminated:                      a1[n - 1] = 1;                      a2[n - 1] = 1;                      a3[n - 1] = 0;                      b[n - 1] = 2 * (xx[n - 1] - xx[n - 2]) / (tt[n - 1] - tt[n - 2]);                      break;                  case SplineBoundaryCondition.FirstDerivative:                      a1[n - 1] = 0;                      a2[n - 1] = 1;                      a3[n - 1] = 0;                      b[n - 1] = rightBoundary;                      break;                  case SplineBoundaryCondition.SecondDerivative:                      a1[n - 1] = 1;                      a2[n - 1] = 2;                      a3[n - 1] = 0;                      b[n - 1] = (3 * (xx[n - 1] - xx[n - 2]) / (tt[n - 1] - tt[n - 2])) + (0.5 * rightBoundary * (tt[n - 1] - tt[n - 2]));                      break;                  default:                      throw new NotSupportedException(Properties.LocalStrings.InvalidRightBoundaryCondition);              }
Magic Number,MathNet.Numerics.Interpolation.Algorithms,CubicSplineInterpolation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\CubicSplineInterpolation.cs,SolveTridiagonal,The following statement contains a magic number: for(int k = x.Length - 2; k >= 0; k--)              {                  x[k] = (d[k] - (c[k] * x[k + 1])) / b[k];              }
Magic Number,MathNet.Numerics.Interpolation.Algorithms,LimitedOrderPolynomialInterpolation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\LimitedOrderPolynomialInterpolation.cs,Interpolate,The following statement contains a magic number: for(int level = 1; level < _effectiveOrder; level++)              {                  for(int i = 0; i < _effectiveOrder - level; i++)                  {                      double ho = _samples.GetT(offset + i) - t;                      double hp = _samples.GetT(offset + i + level) - t;                      double den = (c[i + 1] - d[i]) / (ho - hp);                      d[i] = hp * den;                      c[i] = ho * den;                  }                    x += (2 * (ns + 1) < (_effectiveOrder - level) ? c[ns + 1] : d[ns--]);              }
Magic Number,MathNet.Numerics.Interpolation.Algorithms,LimitedOrderPolynomialInterpolation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\LimitedOrderPolynomialInterpolation.cs,SuggestOffset,The following statement contains a magic number: int ret = Math.Min(                  Math.Max(                      closestIndex - ((_effectiveOrder - 1) / 2)'                      0)'                  _samples.Count - _effectiveOrder);
Magic Number,MathNet.Numerics.Interpolation.Algorithms,LimitedOrderRationalInterpolation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\LimitedOrderRationalInterpolation.cs,Interpolate,The following statement contains a magic number: const double Tiny = 1.0e-15;
Magic Number,MathNet.Numerics.Interpolation.Algorithms,LimitedOrderRationalInterpolation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\LimitedOrderRationalInterpolation.cs,Interpolate,The following statement contains a magic number: for(int level = 1; level < _effectiveOrder; level++)              {                  for(int i = 0; i < _effectiveOrder - level; i++)                  {                      double hp = _samples.GetT(offset + i + level) - t;                      double ho = (_samples.GetT(offset + i) - t) * d[i] / hp;                                            double den = ho - c[i + 1];                      if(Number.AlmostZero(den))                      {                          // BUGBUG: check - positive or negative infinity?                          return double.PositiveInfinity;                      }                        den = (c[i + 1] - d[i]) / den;                      d[i] = c[i + 1] * den;                      c[i] = ho * den;                  }                    x += (2 * (ns + 1) < (_effectiveOrder - level) ? c[ns + 1] : d[ns--]);              }
Magic Number,MathNet.Numerics.Interpolation.Algorithms,LimitedOrderRationalInterpolation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\LimitedOrderRationalInterpolation.cs,SuggestOffset,The following statement contains a magic number: int ret = Math.Min(                  Math.Max(                      closestIndex - ((_effectiveOrder - 1) / 2)'                      0)'                  _samples.Count - _effectiveOrder);
Magic Number,MathNet.Numerics.Interpolation.Algorithms,LinearSplineInterpolation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\LinearSplineInterpolation.cs,Init,The following statement contains a magic number: if(t.Count < 2)              {                  throw new ArgumentOutOfRangeException("t");              }
Magic Number,MathNet.Numerics.Interpolation.Algorithms,LinearSplineInterpolation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\LinearSplineInterpolation.cs,Init,The following statement contains a magic number: double[] c = new double[4 * (t.Count - 1)];
Magic Number,MathNet.Numerics.Interpolation.Algorithms,LinearSplineInterpolation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\LinearSplineInterpolation.cs,Init,The following statement contains a magic number: for(int i = 0' j = 0; i < tt.Length - 1; i++' j += 4)              {                  c[j] = xx[i];                  c[j + 1] = (xx[i + 1] - xx[i]) / (tt[i + 1] - tt[i]);                  c[j + 2] = 0;                  c[j + 3] = 0;              }
Magic Number,MathNet.Numerics.Interpolation.Algorithms,LinearSplineInterpolation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\LinearSplineInterpolation.cs,Init,The following statement contains a magic number: for(int i = 0' j = 0; i < tt.Length - 1; i++' j += 4)              {                  c[j] = xx[i];                  c[j + 1] = (xx[i + 1] - xx[i]) / (tt[i + 1] - tt[i]);                  c[j + 2] = 0;                  c[j + 3] = 0;              }
Magic Number,MathNet.Numerics.Interpolation.Algorithms,LinearSplineInterpolation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\LinearSplineInterpolation.cs,Init,The following statement contains a magic number: for(int i = 0' j = 0; i < tt.Length - 1; i++' j += 4)              {                  c[j] = xx[i];                  c[j + 1] = (xx[i + 1] - xx[i]) / (tt[i + 1] - tt[i]);                  c[j + 2] = 0;                  c[j + 3] = 0;              }
Magic Number,MathNet.Numerics.Interpolation.Algorithms,PolynomialInterpolation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\PolynomialInterpolation.cs,Differentiate,The following statement contains a magic number: for(int level = 1; level < x.Length; level++)              {                  for(int i = 0; i < x.Length - level; i++)                  {                      double hp = t - _t[i + level];                      double ho = _t[i] - t;                      double den = _t[i] - _t[i + level];                      d2x[i] = ((hp * d2x[i]) + (ho * d2x[i + 1]) + (2 * dx[i]) - (2 * dx[i + 1])) / den;                      dx[i] = ((hp * dx[i]) + x[i] + (ho * dx[i + 1]) - x[i + 1]) / den;                      x[i] = ((hp * x[i]) + (ho * x[i + 1])) / den;                  }              }
Magic Number,MathNet.Numerics.Interpolation.Algorithms,PolynomialInterpolation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\PolynomialInterpolation.cs,Differentiate,The following statement contains a magic number: for(int level = 1; level < x.Length; level++)              {                  for(int i = 0; i < x.Length - level; i++)                  {                      double hp = t - _t[i + level];                      double ho = _t[i] - t;                      double den = _t[i] - _t[i + level];                      d2x[i] = ((hp * d2x[i]) + (ho * d2x[i + 1]) + (2 * dx[i]) - (2 * dx[i + 1])) / den;                      dx[i] = ((hp * dx[i]) + x[i] + (ho * dx[i + 1]) - x[i + 1]) / den;                      x[i] = ((hp * x[i]) + (ho * x[i + 1])) / den;                  }              }
Magic Number,MathNet.Numerics.Interpolation.Algorithms,RationalPoleFreeInterpolation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\RationalPoleFreeInterpolation.cs,Init,The following statement contains a magic number: Init(t' x' Math.Min(3' t.Count - 1));
Magic Number,MathNet.Numerics.Interpolation.Algorithms,RationalInterpolation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\RationalInterpolation.cs,Interpolate,The following statement contains a magic number: const double Tiny = 1.0e-25;
Magic Number,MathNet.Numerics.Interpolation.Algorithms,RationalInterpolation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\RationalInterpolation.cs,Interpolate,The following statement contains a magic number: for(int level = 1; level < n; level++)              {                  for(int i = 0; i < n - level; i++)                  {                      double hp = _t[i + level] - t;                      double ho = (_t[i] - t) * d[i] / hp;                        double den = ho - c[i + 1];                      if(Number.AlmostZero(den))                      {                          return double.NaN; // zero-div' singularity                      }                        den = (c[i + 1] - d[i]) / den;                      d[i] = c[i + 1] * den;                      c[i] = ho * den;                  }                    x += (2 * nearestIndex) < (n - level)                      ? c[nearestIndex]                      : d[--nearestIndex];              }
Magic Number,MathNet.Numerics.Interpolation.Algorithms,SplineInterpolation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\SplineInterpolation.cs,Init,The following statement contains a magic number: if(c.Count != 4 * (t.Count - 1))              {                  throw new ArgumentOutOfRangeException("c");              }
Magic Number,MathNet.Numerics.Interpolation.Algorithms,SplineInterpolation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\SplineInterpolation.cs,Interpolate,The following statement contains a magic number: while(low != high - 1)              {                  int middle = (low + high) / 2;                  if(_t[middle] > t)                  {                      high = middle;                  }                  else                  {                      low = middle;                  }              }
Magic Number,MathNet.Numerics.Interpolation.Algorithms,SplineInterpolation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\SplineInterpolation.cs,Interpolate,The following statement contains a magic number: int k = low << 2;
Magic Number,MathNet.Numerics.Interpolation.Algorithms,SplineInterpolation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\SplineInterpolation.cs,Interpolate,The following statement contains a magic number: return _c[k] + (t * (_c[k + 1] + (t * (_c[k + 2] + (t * _c[k + 3])))));
Magic Number,MathNet.Numerics.Interpolation.Algorithms,SplineInterpolation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\SplineInterpolation.cs,Interpolate,The following statement contains a magic number: return _c[k] + (t * (_c[k + 1] + (t * (_c[k + 2] + (t * _c[k + 3])))));
Magic Number,MathNet.Numerics.Interpolation.Algorithms,SplineInterpolation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\SplineInterpolation.cs,Differentiate,The following statement contains a magic number: while(low != high - 1)              {                  int middle = (low + high) / 2;                  if(_t[middle] > t)                  {                      high = middle;                  }                  else                  {                      low = middle;                  }              }
Magic Number,MathNet.Numerics.Interpolation.Algorithms,SplineInterpolation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\SplineInterpolation.cs,Differentiate,The following statement contains a magic number: int k = low << 2;
Magic Number,MathNet.Numerics.Interpolation.Algorithms,SplineInterpolation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\SplineInterpolation.cs,Differentiate,The following statement contains a magic number: first = _c[k + 1] + (2 * t * _c[k + 2]) + (3 * t * t * _c[k + 3]);
Magic Number,MathNet.Numerics.Interpolation.Algorithms,SplineInterpolation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\SplineInterpolation.cs,Differentiate,The following statement contains a magic number: first = _c[k + 1] + (2 * t * _c[k + 2]) + (3 * t * t * _c[k + 3]);
Magic Number,MathNet.Numerics.Interpolation.Algorithms,SplineInterpolation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\SplineInterpolation.cs,Differentiate,The following statement contains a magic number: first = _c[k + 1] + (2 * t * _c[k + 2]) + (3 * t * t * _c[k + 3]);
Magic Number,MathNet.Numerics.Interpolation.Algorithms,SplineInterpolation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\SplineInterpolation.cs,Differentiate,The following statement contains a magic number: first = _c[k + 1] + (2 * t * _c[k + 2]) + (3 * t * t * _c[k + 3]);
Magic Number,MathNet.Numerics.Interpolation.Algorithms,SplineInterpolation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\SplineInterpolation.cs,Differentiate,The following statement contains a magic number: second = (2 * _c[k + 2]) + (6 * t * _c[k + 3]);
Magic Number,MathNet.Numerics.Interpolation.Algorithms,SplineInterpolation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\SplineInterpolation.cs,Differentiate,The following statement contains a magic number: second = (2 * _c[k + 2]) + (6 * t * _c[k + 3]);
Magic Number,MathNet.Numerics.Interpolation.Algorithms,SplineInterpolation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\SplineInterpolation.cs,Differentiate,The following statement contains a magic number: second = (2 * _c[k + 2]) + (6 * t * _c[k + 3]);
Magic Number,MathNet.Numerics.Interpolation.Algorithms,SplineInterpolation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\SplineInterpolation.cs,Differentiate,The following statement contains a magic number: second = (2 * _c[k + 2]) + (6 * t * _c[k + 3]);
Magic Number,MathNet.Numerics.Interpolation.Algorithms,SplineInterpolation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\SplineInterpolation.cs,Differentiate,The following statement contains a magic number: return _c[k] + (t * (_c[k + 1] + (t * (_c[k + 2] + (t * _c[k + 3])))));
Magic Number,MathNet.Numerics.Interpolation.Algorithms,SplineInterpolation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\SplineInterpolation.cs,Differentiate,The following statement contains a magic number: return _c[k] + (t * (_c[k + 1] + (t * (_c[k + 2] + (t * _c[k + 3])))));
Magic Number,MathNet.Numerics.Interpolation.Algorithms,SplineInterpolation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\SplineInterpolation.cs,Integrate,The following statement contains a magic number: while(low != high - 1)              {                  int middle = (low + high) / 2;                  if(_t[middle] > t)                  {                      high = middle;                  }                  else                  {                      low = middle;                  }              }
Magic Number,MathNet.Numerics.Interpolation.Algorithms,SplineInterpolation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\SplineInterpolation.cs,Integrate,The following statement contains a magic number: for(int i = 0' j = 0; i < low; i++' j += 4)              {                  double w = _t[i + 1] - _t[i];                  result += w * (_c[j] + ((w * (_c[j + 1] * 0.5)) + (w * ((_c[j + 2] / 3) + (w * _c[j + 3] * 0.25)))));              }
Magic Number,MathNet.Numerics.Interpolation.Algorithms,SplineInterpolation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\SplineInterpolation.cs,Integrate,The following statement contains a magic number: for(int i = 0' j = 0; i < low; i++' j += 4)              {                  double w = _t[i + 1] - _t[i];                  result += w * (_c[j] + ((w * (_c[j + 1] * 0.5)) + (w * ((_c[j + 2] / 3) + (w * _c[j + 3] * 0.25)))));              }
Magic Number,MathNet.Numerics.Interpolation.Algorithms,SplineInterpolation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\SplineInterpolation.cs,Integrate,The following statement contains a magic number: for(int i = 0' j = 0; i < low; i++' j += 4)              {                  double w = _t[i + 1] - _t[i];                  result += w * (_c[j] + ((w * (_c[j + 1] * 0.5)) + (w * ((_c[j + 2] / 3) + (w * _c[j + 3] * 0.25)))));              }
Magic Number,MathNet.Numerics.Interpolation.Algorithms,SplineInterpolation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\SplineInterpolation.cs,Integrate,The following statement contains a magic number: for(int i = 0' j = 0; i < low; i++' j += 4)              {                  double w = _t[i + 1] - _t[i];                  result += w * (_c[j] + ((w * (_c[j + 1] * 0.5)) + (w * ((_c[j + 2] / 3) + (w * _c[j + 3] * 0.25)))));              }
Magic Number,MathNet.Numerics.Interpolation.Algorithms,SplineInterpolation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\SplineInterpolation.cs,Integrate,The following statement contains a magic number: for(int i = 0' j = 0; i < low; i++' j += 4)              {                  double w = _t[i + 1] - _t[i];                  result += w * (_c[j] + ((w * (_c[j + 1] * 0.5)) + (w * ((_c[j + 2] / 3) + (w * _c[j + 3] * 0.25)))));              }
Magic Number,MathNet.Numerics.Interpolation.Algorithms,SplineInterpolation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\SplineInterpolation.cs,Integrate,The following statement contains a magic number: for(int i = 0' j = 0; i < low; i++' j += 4)              {                  double w = _t[i + 1] - _t[i];                  result += w * (_c[j] + ((w * (_c[j + 1] * 0.5)) + (w * ((_c[j + 2] / 3) + (w * _c[j + 3] * 0.25)))));              }
Magic Number,MathNet.Numerics.Interpolation.Algorithms,SplineInterpolation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\SplineInterpolation.cs,Integrate,The following statement contains a magic number: int k = low << 2;
Magic Number,MathNet.Numerics.Interpolation.Algorithms,SplineInterpolation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\SplineInterpolation.cs,Integrate,The following statement contains a magic number: return result + (t * (_c[k] + ((t * (_c[k + 1] * 0.5)) + (t * (_c[k + 2] / 3)) + (t * _c[k + 3] * 0.25))));
Magic Number,MathNet.Numerics.Interpolation.Algorithms,SplineInterpolation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\SplineInterpolation.cs,Integrate,The following statement contains a magic number: return result + (t * (_c[k] + ((t * (_c[k + 1] * 0.5)) + (t * (_c[k + 2] / 3)) + (t * _c[k + 3] * 0.25))));
Magic Number,MathNet.Numerics.Interpolation.Algorithms,SplineInterpolation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\SplineInterpolation.cs,Integrate,The following statement contains a magic number: return result + (t * (_c[k] + ((t * (_c[k + 1] * 0.5)) + (t * (_c[k + 2] / 3)) + (t * _c[k + 3] * 0.25))));
Magic Number,MathNet.Numerics.Interpolation.Algorithms,SplineInterpolation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\SplineInterpolation.cs,Integrate,The following statement contains a magic number: return result + (t * (_c[k] + ((t * (_c[k + 1] * 0.5)) + (t * (_c[k + 2] / 3)) + (t * _c[k + 3] * 0.25))));
Magic Number,MathNet.Numerics.Interpolation.Algorithms,SplineInterpolation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\Algorithms\SplineInterpolation.cs,Integrate,The following statement contains a magic number: return result + (t * (_c[k] + ((t * (_c[k + 1] * 0.5)) + (t * (_c[k + 2] / 3)) + (t * _c[k + 3] * 0.25))));
Magic Number,MathNet.Numerics.Interpolation,PolynomialInterpolationAlgorithm,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\PolynomialInterpolationAlgorithm.cs,Interpolate,The following statement contains a magic number: for(int level = 1; level < _effectiveOrder; level++)              {                  for(int i = 0; i < _effectiveOrder - level; i++)                  {                      double ho = _samples.GetT(offset + i) - t;                      double hp = _samples.GetT(offset + i + level) - t;                      double den = (c[i + 1] - d[i]) / (ho - hp);                      d[i] = hp * den;                      c[i] = ho * den;                  }                    error = (2 * (ns + 1) < (_effectiveOrder - level) ? c[ns + 1] : d[ns--]);                  x += error;              }
Magic Number,MathNet.Numerics.Interpolation,PolynomialInterpolationAlgorithm,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\PolynomialInterpolationAlgorithm.cs,SuggestOffset,The following statement contains a magic number: int ret = Math.Min(                  Math.Max(                      closestIndex - ((_effectiveOrder - 1) / 2)'                      0)'                  _samples.Count - _effectiveOrder);
Magic Number,MathNet.Numerics.Interpolation,RationalInterpolationAlgorithm,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\RationalInterpolationAlgorithm.cs,Interpolate,The following statement contains a magic number: const double Tiny = 1.0e-15;
Magic Number,MathNet.Numerics.Interpolation,RationalInterpolationAlgorithm,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\RationalInterpolationAlgorithm.cs,Interpolate,The following statement contains a magic number: for(int level = 1; level < _effectiveOrder; level++)              {                  for(int i = 0; i < _effectiveOrder - level; i++)                  {                      double hp = _samples.GetT(offset + i + level) - t;                      double ho = (_samples.GetT(offset + i) - t) * d[i] / hp;                        double den = ho - c[i + 1];                      if(den == 0)                      {                          // TODO (ruegg' 2006-06-09): Check sign (positive or negative infinity?)                          error = 0;                          return double.PositiveInfinity; // or is it NegativeInfinity?                      }                        den = (c[i + 1] - d[i]) / den;                      d[i] = c[i + 1] * den;                      c[i] = ho * den;                  }                    error = (2 * (ns + 1) < (_effectiveOrder - level) ? c[ns + 1] : d[ns--]);                  x += error;              }
Magic Number,MathNet.Numerics.Interpolation,RationalInterpolationAlgorithm,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Interpolation\RationalInterpolationAlgorithm.cs,SuggestOffset,The following statement contains a magic number: int ret = Math.Min(                  Math.Max(                      closestIndex - ((_effectiveOrder - 1) / 2)'                      0)'                  _samples.Count - _effectiveOrder);
Magic Number,MathNet.Numerics.LinearAlgebra.Algorithms,Orthogonal,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\LinearAlgebra\Algorithms\Orthogonal.cs,Rotation,The following statement contains a magic number: double[][] m = Matrix.CreateMatrixData(2' 2);
Magic Number,MathNet.Numerics.LinearAlgebra.Algorithms,Orthogonal,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\LinearAlgebra\Algorithms\Orthogonal.cs,Rotation,The following statement contains a magic number: double[][] m = Matrix.CreateMatrixData(2' 2);
Magic Number,MathNet.Numerics.LinearAlgebra.Algorithms,Orthogonal,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\LinearAlgebra\Algorithms\Orthogonal.cs,Rotation,The following statement contains a magic number: Complex[][] m = ComplexMatrix.CreateMatrixData(2' 2);
Magic Number,MathNet.Numerics.LinearAlgebra.Algorithms,Orthogonal,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\LinearAlgebra\Algorithms\Orthogonal.cs,Rotation,The following statement contains a magic number: Complex[][] m = ComplexMatrix.CreateMatrixData(2' 2);
Magic Number,MathNet.Numerics.LinearAlgebra,ComplexMatrix,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\LinearAlgebra\ComplexMatrix.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  int result = _rowCount;                  result = (result * 397) ^ _columnCount;                  result = (result * 397) ^ _data.GetHashCode();                  return result;              }
Magic Number,MathNet.Numerics.LinearAlgebra,ComplexMatrix,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\LinearAlgebra\ComplexMatrix.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  int result = _rowCount;                  result = (result * 397) ^ _columnCount;                  result = (result * 397) ^ _data.GetHashCode();                  return result;              }
Magic Number,MathNet.Numerics.LinearAlgebra,ComplexVector,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\LinearAlgebra\ComplexVector.cs,CrossProduct,The following statement contains a magic number: if(3 != u.Length)              {                  throw new ArgumentOutOfRangeException("u"' Properties.LocalStrings.ArgumentVectorThreeDimensional);              }
Magic Number,MathNet.Numerics.LinearAlgebra,ComplexVector,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\LinearAlgebra\ComplexVector.cs,CrossProduct,The following statement contains a magic number: ComplexVector product = new ComplexVector(new Complex[] {                  (u[1] * v[2]) - (u[2] * v[1])'                  (u[2] * v[0]) - (u[0] * v[2])'                  (u[0] * v[1]) - (u[1] * v[0])                  });
Magic Number,MathNet.Numerics.LinearAlgebra,ComplexVector,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\LinearAlgebra\ComplexVector.cs,CrossProduct,The following statement contains a magic number: ComplexVector product = new ComplexVector(new Complex[] {                  (u[1] * v[2]) - (u[2] * v[1])'                  (u[2] * v[0]) - (u[0] * v[2])'                  (u[0] * v[1]) - (u[1] * v[0])                  });
Magic Number,MathNet.Numerics.LinearAlgebra,ComplexVector,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\LinearAlgebra\ComplexVector.cs,CrossProduct,The following statement contains a magic number: ComplexVector product = new ComplexVector(new Complex[] {                  (u[1] * v[2]) - (u[2] * v[1])'                  (u[2] * v[0]) - (u[0] * v[2])'                  (u[0] * v[1]) - (u[1] * v[0])                  });
Magic Number,MathNet.Numerics.LinearAlgebra,ComplexVector,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\LinearAlgebra\ComplexVector.cs,CrossProduct,The following statement contains a magic number: ComplexVector product = new ComplexVector(new Complex[] {                  (u[1] * v[2]) - (u[2] * v[1])'                  (u[2] * v[0]) - (u[0] * v[2])'                  (u[0] * v[1]) - (u[1] * v[0])                  });
Magic Number,MathNet.Numerics.LinearAlgebra,ComplexVector,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\LinearAlgebra\ComplexVector.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  return (_data.GetHashCode() * 397) ^ _length;              }
Magic Number,MathNet.Numerics.LinearAlgebra,Vector,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\LinearAlgebra\Vector.cs,CrossProduct,The following statement contains a magic number: if(3 != u.Length)              {                  throw new ArgumentOutOfRangeException("u"' Properties.LocalStrings.ArgumentVectorThreeDimensional);              }
Magic Number,MathNet.Numerics.LinearAlgebra,Vector,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\LinearAlgebra\Vector.cs,CrossProduct,The following statement contains a magic number: Vector product = new Vector(new double[] {                  (u[1] * v[2]) - (u[2] * v[1])'                  (u[2] * v[0]) - (u[0] * v[2])'                  (u[0] * v[1]) - (u[1] * v[0])                  });
Magic Number,MathNet.Numerics.LinearAlgebra,Vector,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\LinearAlgebra\Vector.cs,CrossProduct,The following statement contains a magic number: Vector product = new Vector(new double[] {                  (u[1] * v[2]) - (u[2] * v[1])'                  (u[2] * v[0]) - (u[0] * v[2])'                  (u[0] * v[1]) - (u[1] * v[0])                  });
Magic Number,MathNet.Numerics.LinearAlgebra,Vector,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\LinearAlgebra\Vector.cs,CrossProduct,The following statement contains a magic number: Vector product = new Vector(new double[] {                  (u[1] * v[2]) - (u[2] * v[1])'                  (u[2] * v[0]) - (u[0] * v[2])'                  (u[0] * v[1]) - (u[1] * v[0])                  });
Magic Number,MathNet.Numerics.LinearAlgebra,Vector,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\LinearAlgebra\Vector.cs,CrossProduct,The following statement contains a magic number: Vector product = new Vector(new double[] {                  (u[1] * v[2]) - (u[2] * v[1])'                  (u[2] * v[0]) - (u[0] * v[2])'                  (u[0] * v[1]) - (u[1] * v[0])                  });
Magic Number,MathNet.Numerics.LinearAlgebra,Vector,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\LinearAlgebra\Vector.cs,NormP,The following statement contains a magic number: if(2 == p)              {                  return Norm();              }
Magic Number,MathNet.Numerics.LinearAlgebra,Vector,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\LinearAlgebra\Vector.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  return (_data.GetHashCode() * 397) ^ _length;              }
Magic Number,MathNet.Numerics.LinearAlgebra,EigenvalueDecomposition,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\LinearAlgebra\EigenvalueDecomposition.cs,SymmetricDiagonalize,The following statement contains a magic number: for(int l = 0; l < _n; l++)              {                  /* Find small subdiagonal element */                    tst1 = Math.Max(tst1' Math.Abs(_d[l]) + Math.Abs(_e[l]));                  int m = l;                  while(m < _n)                  {                      if(Math.Abs(_e[m]) <= eps * tst1)                      {                          break;                      }                        m++;                  }                    /*                  If m == l' d[l] is an eigenvalue'                  otherwise' iterate.                  */                    if(m > l)                  {                      int iter = 0;                      do                      {                          iter = iter + 1; // (Could check iteration count here.)                            /* Compute implicit shift */                            double g = _d[l];                          double p = (_d[l + 1] - g) / (2.0 * _e[l]);                          double r = Fn.Hypot(p' 1.0);                          if(p < 0)                          {                              r = -r;                          }                            _d[l] = _e[l] / (p + r);                          _d[l + 1] = _e[l] * (p + r);                            double dl1 = _d[l + 1];                          double h = g - _d[l];                          for(int i = l + 2; i < _n; i++)                          {                              _d[i] -= h;                          }                            f = f + h;                            /* Implicit QL transformation */                            p = _d[m];                          double c = 1.0;                          double c2 = c;                          double c3 = c;                          double el1 = _e[l + 1];                          double s = 0.0;                          double s2 = 0.0;                          for(int i = m - 1; i >= l; i--)                          {                              c3 = c2;                              c2 = c;                              s2 = s;                              g = c * _e[i];                              h = c * p;                              r = Fn.Hypot(p' _e[i]);                              if(r == 0)                              {                                  _e[i + 1] = 0;                                  _d[i + 1] = 0;                              }                              else                              {                                  _e[i + 1] = s * r;                                  s = _e[i] / r;                                  c = p / r;                                  p = (c * _d[i]) - (s * g);                                  _d[i + 1] = h + (s * ((c * g) + (s * _d[i])));                              }                                /* Accumulate transformation */                                for(int k = 0; k < _n; k++)                              {                                  h = _v[k][i + 1];                                  _v[k][i + 1] = (s * _v[k][i]) + (c * h);                                  _v[k][i] = (c * _v[k][i]) - (s * h);                              }                          }                            p = (-s) * s2 * c3 * el1 * _e[l] / dl1;                          _e[l] = s * p;                          _d[l] = c * p;                            /* Check for convergence */                      }                      while(Math.Abs(_e[l]) > eps * tst1);                  }                    _d[l] = _d[l] + f;                  _e[l] = 0.0;              }
Magic Number,MathNet.Numerics.LinearAlgebra,EigenvalueDecomposition,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\LinearAlgebra\EigenvalueDecomposition.cs,SymmetricDiagonalize,The following statement contains a magic number: for(int l = 0; l < _n; l++)              {                  /* Find small subdiagonal element */                    tst1 = Math.Max(tst1' Math.Abs(_d[l]) + Math.Abs(_e[l]));                  int m = l;                  while(m < _n)                  {                      if(Math.Abs(_e[m]) <= eps * tst1)                      {                          break;                      }                        m++;                  }                    /*                  If m == l' d[l] is an eigenvalue'                  otherwise' iterate.                  */                    if(m > l)                  {                      int iter = 0;                      do                      {                          iter = iter + 1; // (Could check iteration count here.)                            /* Compute implicit shift */                            double g = _d[l];                          double p = (_d[l + 1] - g) / (2.0 * _e[l]);                          double r = Fn.Hypot(p' 1.0);                          if(p < 0)                          {                              r = -r;                          }                            _d[l] = _e[l] / (p + r);                          _d[l + 1] = _e[l] * (p + r);                            double dl1 = _d[l + 1];                          double h = g - _d[l];                          for(int i = l + 2; i < _n; i++)                          {                              _d[i] -= h;                          }                            f = f + h;                            /* Implicit QL transformation */                            p = _d[m];                          double c = 1.0;                          double c2 = c;                          double c3 = c;                          double el1 = _e[l + 1];                          double s = 0.0;                          double s2 = 0.0;                          for(int i = m - 1; i >= l; i--)                          {                              c3 = c2;                              c2 = c;                              s2 = s;                              g = c * _e[i];                              h = c * p;                              r = Fn.Hypot(p' _e[i]);                              if(r == 0)                              {                                  _e[i + 1] = 0;                                  _d[i + 1] = 0;                              }                              else                              {                                  _e[i + 1] = s * r;                                  s = _e[i] / r;                                  c = p / r;                                  p = (c * _d[i]) - (s * g);                                  _d[i + 1] = h + (s * ((c * g) + (s * _d[i])));                              }                                /* Accumulate transformation */                                for(int k = 0; k < _n; k++)                              {                                  h = _v[k][i + 1];                                  _v[k][i + 1] = (s * _v[k][i]) + (c * h);                                  _v[k][i] = (c * _v[k][i]) - (s * h);                              }                          }                            p = (-s) * s2 * c3 * el1 * _e[l] / dl1;                          _e[l] = s * p;                          _d[l] = c * p;                            /* Check for convergence */                      }                      while(Math.Abs(_e[l]) > eps * tst1);                  }                    _d[l] = _d[l] + f;                  _e[l] = 0.0;              }
Magic Number,MathNet.Numerics.LinearAlgebra,EigenvalueDecomposition,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\LinearAlgebra\EigenvalueDecomposition.cs,NonsymmetricReduceHessenberToRealSchur,The following statement contains a magic number: while(n >= low)              {                  /* Look for single small sub-diagonal element */                    int l = n;                  while(l > low)                  {                      s = Math.Abs(_h[l - 1][l - 1]) + Math.Abs(_h[l][l]);                        if(s == 0.0)                      {                          s = norm;                      }                        if(Math.Abs(_h[l][l - 1]) < eps * s)                      {                          break;                      }                        l--;                  }                    /*                  Check for convergence                  One root found                  */                    if(l == n)                  {                      _h[n][n] = _h[n][n] + exshift;                      _d[n] = _h[n][n];                      _e[n] = 0.0;                      n--;                      iter = 0;                        // Two roots found                  }                  else if(l == n - 1)                  {                      w = _h[n][n - 1] * _h[n - 1][n];                      p = (_h[n - 1][n - 1] - _h[n][n]) / 2.0;                      q = (p * p) + w;                      z = Math.Sqrt(Math.Abs(q));                      _h[n][n] = _h[n][n] + exshift;                      _h[n - 1][n - 1] = _h[n - 1][n - 1] + exshift;                      x = _h[n][n];                        /* Real pair */                        if(q >= 0)                      {                          if(p >= 0)                          {                              z = p + z;                          }                          else                          {                              z = p - z;                          }                            _d[n - 1] = x + z;                            _d[n] = _d[n - 1];                          if(z != 0.0)                          {                              _d[n] = x - (w / z);                          }                            _e[n - 1] = 0.0;                          _e[n] = 0.0;                          x = _h[n][n - 1];                          s = Math.Abs(x) + Math.Abs(z);                          p = x / s;                          q = z / s;                          r = Math.Sqrt((p * p) + (q * q));                          p = p / r;                          q = q / r;                            /* Row modification */                            for(int j = n - 1; j < nn; j++)                          {                              z = _h[n - 1][j];                              _h[n - 1][j] = (q * z) + (p * _h[n][j]);                              _h[n][j] = (q * _h[n][j]) - (p * z);                          }                            /* Column modification */                            for(int i = 0; i <= n; i++)                          {                              z = _h[i][n - 1];                              _h[i][n - 1] = (q * z) + (p * _h[i][n]);                              _h[i][n] = (q * _h[i][n]) - (p * z);                          }                            /* Accumulate transformations */                            for(int i = low; i <= high; i++)                          {                              z = _v[i][n - 1];                              _v[i][n - 1] = (q * z) + (p * _v[i][n]);                              _v[i][n] = (q * _v[i][n]) - (p * z);                          }                            // Complex pair                      }                      else                      {                          _d[n - 1] = x + p;                          _d[n] = x + p;                          _e[n - 1] = z;                          _e[n] = -z;                      }                        n = n - 2;                      iter = 0;                        // No convergence yet                  }                  else                  {                      /* Form shift */                        x = _h[n][n];                      y = 0.0;                      w = 0.0;                      if(l < n)                      {                          y = _h[n - 1][n - 1];                          w = _h[n][n - 1] * _h[n - 1][n];                      }                        /* Wilkinson's original ad hoc shift */                        if(iter == 10)                      {                          exshift += x;                          for(int i = low; i <= n; i++)                          {                              _h[i][i] -= x;                          }                            s = Math.Abs(_h[n][n - 1]) + Math.Abs(_h[n - 1][n - 2]);                          x = y = 0.75 * s;                          w = (-0.4375) * s * s;                      }                        /* MATLAB's new ad hoc shift */                        if(iter == 30)                      {                          s = (y - x) / 2.0;                          s = (s * s) + w;                          if(s > 0)                          {                              s = Math.Sqrt(s);                              if(y < x)                              {                                  s = -s;                              }                                s = x - (w / (((y - x) / 2.0) + s));                              for(int i = low; i <= n; i++)                              {                                  _h[i][i] -= s;                              }                                exshift += s;                              x = y = w = 0.964;                          }                      }                        iter = iter + 1; // (Could check iteration count here.)                        /* Look for two consecutive small sub-diagonal elements */                        int m = n - 2;                      while(m >= l)                      {                          z = _h[m][m];                          r = x - z;                          s = y - z;                          p = (((r * s) - w) / _h[m + 1][m]) + _h[m][m + 1];                          q = _h[m + 1][m + 1] - z - r - s;                          r = _h[m + 2][m + 1];                          s = Math.Abs(p) + Math.Abs(q) + Math.Abs(r);                          p = p / s;                          q = q / s;                          r = r / s;                            if(m == l)                          {                              break;                          }                            if(Math.Abs(_h[m][m - 1]) * (Math.Abs(q) + Math.Abs(r)) < eps * (Math.Abs(p) * (Math.Abs(_h[m - 1][m - 1]) + Math.Abs(z) + Math.Abs(_h[m + 1][m + 1]))))                          {                              break;                          }                            m--;                      }                        for(int i = m + 2; i <= n; i++)                      {                          _h[i][i - 2] = 0.0;                          if(i > m + 2)                          {                              _h[i][i - 3] = 0.0;                          }                      }                        /* Double QR step involving rows l:n and columns m:n */                        for(int k = m; k <= n - 1; k++)                      {                          bool notlast = (k != n - 1);                            if(k != m)                          {                              p = _h[k][k - 1];                              q = _h[k + 1][k - 1];                              r = (notlast ? _h[k + 2][k - 1] : 0.0);                              x = Math.Abs(p) + Math.Abs(q) + Math.Abs(r);                              if(x != 0.0)                              {                                  p = p / x;                                  q = q / x;                                  r = r / x;                              }                          }                            if(x == 0.0)                          {                              break;                          }                            s = Math.Sqrt((p * p) + (q * q) + (r * r));                          if(p < 0)                          {                              s = -s;                          }                            if(s != 0.0)                          {                              if(k != m)                              {                                  _h[k][k - 1] = (-s) * x;                              }                              else if(l != m)                              {                                  _h[k][k - 1] = -_h[k][k - 1];                              }                                p = p + s;                              x = p / s;                              y = q / s;                              z = r / s;                              q = q / p;                              r = r / p;                                /* Row modification */                                for(int j = k; j < nn; j++)                              {                                  p = _h[k][j] + (q * _h[k + 1][j]);                                    if(notlast)                                  {                                      p = p + (r * _h[k + 2][j]);                                      _h[k + 2][j] = _h[k + 2][j] - (p * z);                                  }                                    _h[k][j] = _h[k][j] - (p * x);                                  _h[k + 1][j] = _h[k + 1][j] - (p * y);                              }                                /* Column modification */                                for(int i = 0; i <= Math.Min(n' k + 3); i++)                              {                                  double[] hi = _h[i];                                  p = (x * hi[k]) + (y * hi[k + 1]);                                    if(notlast)                                  {                                      p = p + (z * hi[k + 2]);                                      hi[k + 2] = hi[k + 2] - (p * r);                                  }                                    hi[k] = hi[k] - p;                                  hi[k + 1] = hi[k + 1] - (p * q);                              }                                /* Accumulate transformations */                                for(int i = low; i <= high; i++)                              {                                  double[] vi = _v[i];                                  p = (x * vi[k]) + (y * vi[k + 1]);                                    if(notlast)                                  {                                      p = p + (z * vi[k + 2]);                                      vi[k + 2] = vi[k + 2] - (p * r);                                  }                                    vi[k] = vi[k] - p;                                  vi[k + 1] = vi[k + 1] - (p * q);                              }                          } // (s != 0)                      } // k loop                  } // check convergence              }
Magic Number,MathNet.Numerics.LinearAlgebra,EigenvalueDecomposition,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\LinearAlgebra\EigenvalueDecomposition.cs,NonsymmetricReduceHessenberToRealSchur,The following statement contains a magic number: while(n >= low)              {                  /* Look for single small sub-diagonal element */                    int l = n;                  while(l > low)                  {                      s = Math.Abs(_h[l - 1][l - 1]) + Math.Abs(_h[l][l]);                        if(s == 0.0)                      {                          s = norm;                      }                        if(Math.Abs(_h[l][l - 1]) < eps * s)                      {                          break;                      }                        l--;                  }                    /*                  Check for convergence                  One root found                  */                    if(l == n)                  {                      _h[n][n] = _h[n][n] + exshift;                      _d[n] = _h[n][n];                      _e[n] = 0.0;                      n--;                      iter = 0;                        // Two roots found                  }                  else if(l == n - 1)                  {                      w = _h[n][n - 1] * _h[n - 1][n];                      p = (_h[n - 1][n - 1] - _h[n][n]) / 2.0;                      q = (p * p) + w;                      z = Math.Sqrt(Math.Abs(q));                      _h[n][n] = _h[n][n] + exshift;                      _h[n - 1][n - 1] = _h[n - 1][n - 1] + exshift;                      x = _h[n][n];                        /* Real pair */                        if(q >= 0)                      {                          if(p >= 0)                          {                              z = p + z;                          }                          else                          {                              z = p - z;                          }                            _d[n - 1] = x + z;                            _d[n] = _d[n - 1];                          if(z != 0.0)                          {                              _d[n] = x - (w / z);                          }                            _e[n - 1] = 0.0;                          _e[n] = 0.0;                          x = _h[n][n - 1];                          s = Math.Abs(x) + Math.Abs(z);                          p = x / s;                          q = z / s;                          r = Math.Sqrt((p * p) + (q * q));                          p = p / r;                          q = q / r;                            /* Row modification */                            for(int j = n - 1; j < nn; j++)                          {                              z = _h[n - 1][j];                              _h[n - 1][j] = (q * z) + (p * _h[n][j]);                              _h[n][j] = (q * _h[n][j]) - (p * z);                          }                            /* Column modification */                            for(int i = 0; i <= n; i++)                          {                              z = _h[i][n - 1];                              _h[i][n - 1] = (q * z) + (p * _h[i][n]);                              _h[i][n] = (q * _h[i][n]) - (p * z);                          }                            /* Accumulate transformations */                            for(int i = low; i <= high; i++)                          {                              z = _v[i][n - 1];                              _v[i][n - 1] = (q * z) + (p * _v[i][n]);                              _v[i][n] = (q * _v[i][n]) - (p * z);                          }                            // Complex pair                      }                      else                      {                          _d[n - 1] = x + p;                          _d[n] = x + p;                          _e[n - 1] = z;                          _e[n] = -z;                      }                        n = n - 2;                      iter = 0;                        // No convergence yet                  }                  else                  {                      /* Form shift */                        x = _h[n][n];                      y = 0.0;                      w = 0.0;                      if(l < n)                      {                          y = _h[n - 1][n - 1];                          w = _h[n][n - 1] * _h[n - 1][n];                      }                        /* Wilkinson's original ad hoc shift */                        if(iter == 10)                      {                          exshift += x;                          for(int i = low; i <= n; i++)                          {                              _h[i][i] -= x;                          }                            s = Math.Abs(_h[n][n - 1]) + Math.Abs(_h[n - 1][n - 2]);                          x = y = 0.75 * s;                          w = (-0.4375) * s * s;                      }                        /* MATLAB's new ad hoc shift */                        if(iter == 30)                      {                          s = (y - x) / 2.0;                          s = (s * s) + w;                          if(s > 0)                          {                              s = Math.Sqrt(s);                              if(y < x)                              {                                  s = -s;                              }                                s = x - (w / (((y - x) / 2.0) + s));                              for(int i = low; i <= n; i++)                              {                                  _h[i][i] -= s;                              }                                exshift += s;                              x = y = w = 0.964;                          }                      }                        iter = iter + 1; // (Could check iteration count here.)                        /* Look for two consecutive small sub-diagonal elements */                        int m = n - 2;                      while(m >= l)                      {                          z = _h[m][m];                          r = x - z;                          s = y - z;                          p = (((r * s) - w) / _h[m + 1][m]) + _h[m][m + 1];                          q = _h[m + 1][m + 1] - z - r - s;                          r = _h[m + 2][m + 1];                          s = Math.Abs(p) + Math.Abs(q) + Math.Abs(r);                          p = p / s;                          q = q / s;                          r = r / s;                            if(m == l)                          {                              break;                          }                            if(Math.Abs(_h[m][m - 1]) * (Math.Abs(q) + Math.Abs(r)) < eps * (Math.Abs(p) * (Math.Abs(_h[m - 1][m - 1]) + Math.Abs(z) + Math.Abs(_h[m + 1][m + 1]))))                          {                              break;                          }                            m--;                      }                        for(int i = m + 2; i <= n; i++)                      {                          _h[i][i - 2] = 0.0;                          if(i > m + 2)                          {                              _h[i][i - 3] = 0.0;                          }                      }                        /* Double QR step involving rows l:n and columns m:n */                        for(int k = m; k <= n - 1; k++)                      {                          bool notlast = (k != n - 1);                            if(k != m)                          {                              p = _h[k][k - 1];                              q = _h[k + 1][k - 1];                              r = (notlast ? _h[k + 2][k - 1] : 0.0);                              x = Math.Abs(p) + Math.Abs(q) + Math.Abs(r);                              if(x != 0.0)                              {                                  p = p / x;                                  q = q / x;                                  r = r / x;                              }                          }                            if(x == 0.0)                          {                              break;                          }                            s = Math.Sqrt((p * p) + (q * q) + (r * r));                          if(p < 0)                          {                              s = -s;                          }                            if(s != 0.0)                          {                              if(k != m)                              {                                  _h[k][k - 1] = (-s) * x;                              }                              else if(l != m)                              {                                  _h[k][k - 1] = -_h[k][k - 1];                              }                                p = p + s;                              x = p / s;                              y = q / s;                              z = r / s;                              q = q / p;                              r = r / p;                                /* Row modification */                                for(int j = k; j < nn; j++)                              {                                  p = _h[k][j] + (q * _h[k + 1][j]);                                    if(notlast)                                  {                                      p = p + (r * _h[k + 2][j]);                                      _h[k + 2][j] = _h[k + 2][j] - (p * z);                                  }                                    _h[k][j] = _h[k][j] - (p * x);                                  _h[k + 1][j] = _h[k + 1][j] - (p * y);                              }                                /* Column modification */                                for(int i = 0; i <= Math.Min(n' k + 3); i++)                              {                                  double[] hi = _h[i];                                  p = (x * hi[k]) + (y * hi[k + 1]);                                    if(notlast)                                  {                                      p = p + (z * hi[k + 2]);                                      hi[k + 2] = hi[k + 2] - (p * r);                                  }                                    hi[k] = hi[k] - p;                                  hi[k + 1] = hi[k + 1] - (p * q);                              }                                /* Accumulate transformations */                                for(int i = low; i <= high; i++)                              {                                  double[] vi = _v[i];                                  p = (x * vi[k]) + (y * vi[k + 1]);                                    if(notlast)                                  {                                      p = p + (z * vi[k + 2]);                                      vi[k + 2] = vi[k + 2] - (p * r);                                  }                                    vi[k] = vi[k] - p;                                  vi[k + 1] = vi[k + 1] - (p * q);                              }                          } // (s != 0)                      } // k loop                  } // check convergence              }
Magic Number,MathNet.Numerics.LinearAlgebra,EigenvalueDecomposition,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\LinearAlgebra\EigenvalueDecomposition.cs,NonsymmetricReduceHessenberToRealSchur,The following statement contains a magic number: while(n >= low)              {                  /* Look for single small sub-diagonal element */                    int l = n;                  while(l > low)                  {                      s = Math.Abs(_h[l - 1][l - 1]) + Math.Abs(_h[l][l]);                        if(s == 0.0)                      {                          s = norm;                      }                        if(Math.Abs(_h[l][l - 1]) < eps * s)                      {                          break;                      }                        l--;                  }                    /*                  Check for convergence                  One root found                  */                    if(l == n)                  {                      _h[n][n] = _h[n][n] + exshift;                      _d[n] = _h[n][n];                      _e[n] = 0.0;                      n--;                      iter = 0;                        // Two roots found                  }                  else if(l == n - 1)                  {                      w = _h[n][n - 1] * _h[n - 1][n];                      p = (_h[n - 1][n - 1] - _h[n][n]) / 2.0;                      q = (p * p) + w;                      z = Math.Sqrt(Math.Abs(q));                      _h[n][n] = _h[n][n] + exshift;                      _h[n - 1][n - 1] = _h[n - 1][n - 1] + exshift;                      x = _h[n][n];                        /* Real pair */                        if(q >= 0)                      {                          if(p >= 0)                          {                              z = p + z;                          }                          else                          {                              z = p - z;                          }                            _d[n - 1] = x + z;                            _d[n] = _d[n - 1];                          if(z != 0.0)                          {                              _d[n] = x - (w / z);                          }                            _e[n - 1] = 0.0;                          _e[n] = 0.0;                          x = _h[n][n - 1];                          s = Math.Abs(x) + Math.Abs(z);                          p = x / s;                          q = z / s;                          r = Math.Sqrt((p * p) + (q * q));                          p = p / r;                          q = q / r;                            /* Row modification */                            for(int j = n - 1; j < nn; j++)                          {                              z = _h[n - 1][j];                              _h[n - 1][j] = (q * z) + (p * _h[n][j]);                              _h[n][j] = (q * _h[n][j]) - (p * z);                          }                            /* Column modification */                            for(int i = 0; i <= n; i++)                          {                              z = _h[i][n - 1];                              _h[i][n - 1] = (q * z) + (p * _h[i][n]);                              _h[i][n] = (q * _h[i][n]) - (p * z);                          }                            /* Accumulate transformations */                            for(int i = low; i <= high; i++)                          {                              z = _v[i][n - 1];                              _v[i][n - 1] = (q * z) + (p * _v[i][n]);                              _v[i][n] = (q * _v[i][n]) - (p * z);                          }                            // Complex pair                      }                      else                      {                          _d[n - 1] = x + p;                          _d[n] = x + p;                          _e[n - 1] = z;                          _e[n] = -z;                      }                        n = n - 2;                      iter = 0;                        // No convergence yet                  }                  else                  {                      /* Form shift */                        x = _h[n][n];                      y = 0.0;                      w = 0.0;                      if(l < n)                      {                          y = _h[n - 1][n - 1];                          w = _h[n][n - 1] * _h[n - 1][n];                      }                        /* Wilkinson's original ad hoc shift */                        if(iter == 10)                      {                          exshift += x;                          for(int i = low; i <= n; i++)                          {                              _h[i][i] -= x;                          }                            s = Math.Abs(_h[n][n - 1]) + Math.Abs(_h[n - 1][n - 2]);                          x = y = 0.75 * s;                          w = (-0.4375) * s * s;                      }                        /* MATLAB's new ad hoc shift */                        if(iter == 30)                      {                          s = (y - x) / 2.0;                          s = (s * s) + w;                          if(s > 0)                          {                              s = Math.Sqrt(s);                              if(y < x)                              {                                  s = -s;                              }                                s = x - (w / (((y - x) / 2.0) + s));                              for(int i = low; i <= n; i++)                              {                                  _h[i][i] -= s;                              }                                exshift += s;                              x = y = w = 0.964;                          }                      }                        iter = iter + 1; // (Could check iteration count here.)                        /* Look for two consecutive small sub-diagonal elements */                        int m = n - 2;                      while(m >= l)                      {                          z = _h[m][m];                          r = x - z;                          s = y - z;                          p = (((r * s) - w) / _h[m + 1][m]) + _h[m][m + 1];                          q = _h[m + 1][m + 1] - z - r - s;                          r = _h[m + 2][m + 1];                          s = Math.Abs(p) + Math.Abs(q) + Math.Abs(r);                          p = p / s;                          q = q / s;                          r = r / s;                            if(m == l)                          {                              break;                          }                            if(Math.Abs(_h[m][m - 1]) * (Math.Abs(q) + Math.Abs(r)) < eps * (Math.Abs(p) * (Math.Abs(_h[m - 1][m - 1]) + Math.Abs(z) + Math.Abs(_h[m + 1][m + 1]))))                          {                              break;                          }                            m--;                      }                        for(int i = m + 2; i <= n; i++)                      {                          _h[i][i - 2] = 0.0;                          if(i > m + 2)                          {                              _h[i][i - 3] = 0.0;                          }                      }                        /* Double QR step involving rows l:n and columns m:n */                        for(int k = m; k <= n - 1; k++)                      {                          bool notlast = (k != n - 1);                            if(k != m)                          {                              p = _h[k][k - 1];                              q = _h[k + 1][k - 1];                              r = (notlast ? _h[k + 2][k - 1] : 0.0);                              x = Math.Abs(p) + Math.Abs(q) + Math.Abs(r);                              if(x != 0.0)                              {                                  p = p / x;                                  q = q / x;                                  r = r / x;                              }                          }                            if(x == 0.0)                          {                              break;                          }                            s = Math.Sqrt((p * p) + (q * q) + (r * r));                          if(p < 0)                          {                              s = -s;                          }                            if(s != 0.0)                          {                              if(k != m)                              {                                  _h[k][k - 1] = (-s) * x;                              }                              else if(l != m)                              {                                  _h[k][k - 1] = -_h[k][k - 1];                              }                                p = p + s;                              x = p / s;                              y = q / s;                              z = r / s;                              q = q / p;                              r = r / p;                                /* Row modification */                                for(int j = k; j < nn; j++)                              {                                  p = _h[k][j] + (q * _h[k + 1][j]);                                    if(notlast)                                  {                                      p = p + (r * _h[k + 2][j]);                                      _h[k + 2][j] = _h[k + 2][j] - (p * z);                                  }                                    _h[k][j] = _h[k][j] - (p * x);                                  _h[k + 1][j] = _h[k + 1][j] - (p * y);                              }                                /* Column modification */                                for(int i = 0; i <= Math.Min(n' k + 3); i++)                              {                                  double[] hi = _h[i];                                  p = (x * hi[k]) + (y * hi[k + 1]);                                    if(notlast)                                  {                                      p = p + (z * hi[k + 2]);                                      hi[k + 2] = hi[k + 2] - (p * r);                                  }                                    hi[k] = hi[k] - p;                                  hi[k + 1] = hi[k + 1] - (p * q);                              }                                /* Accumulate transformations */                                for(int i = low; i <= high; i++)                              {                                  double[] vi = _v[i];                                  p = (x * vi[k]) + (y * vi[k + 1]);                                    if(notlast)                                  {                                      p = p + (z * vi[k + 2]);                                      vi[k + 2] = vi[k + 2] - (p * r);                                  }                                    vi[k] = vi[k] - p;                                  vi[k + 1] = vi[k + 1] - (p * q);                              }                          } // (s != 0)                      } // k loop                  } // check convergence              }
Magic Number,MathNet.Numerics.LinearAlgebra,EigenvalueDecomposition,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\LinearAlgebra\EigenvalueDecomposition.cs,NonsymmetricReduceHessenberToRealSchur,The following statement contains a magic number: while(n >= low)              {                  /* Look for single small sub-diagonal element */                    int l = n;                  while(l > low)                  {                      s = Math.Abs(_h[l - 1][l - 1]) + Math.Abs(_h[l][l]);                        if(s == 0.0)                      {                          s = norm;                      }                        if(Math.Abs(_h[l][l - 1]) < eps * s)                      {                          break;                      }                        l--;                  }                    /*                  Check for convergence                  One root found                  */                    if(l == n)                  {                      _h[n][n] = _h[n][n] + exshift;                      _d[n] = _h[n][n];                      _e[n] = 0.0;                      n--;                      iter = 0;                        // Two roots found                  }                  else if(l == n - 1)                  {                      w = _h[n][n - 1] * _h[n - 1][n];                      p = (_h[n - 1][n - 1] - _h[n][n]) / 2.0;                      q = (p * p) + w;                      z = Math.Sqrt(Math.Abs(q));                      _h[n][n] = _h[n][n] + exshift;                      _h[n - 1][n - 1] = _h[n - 1][n - 1] + exshift;                      x = _h[n][n];                        /* Real pair */                        if(q >= 0)                      {                          if(p >= 0)                          {                              z = p + z;                          }                          else                          {                              z = p - z;                          }                            _d[n - 1] = x + z;                            _d[n] = _d[n - 1];                          if(z != 0.0)                          {                              _d[n] = x - (w / z);                          }                            _e[n - 1] = 0.0;                          _e[n] = 0.0;                          x = _h[n][n - 1];                          s = Math.Abs(x) + Math.Abs(z);                          p = x / s;                          q = z / s;                          r = Math.Sqrt((p * p) + (q * q));                          p = p / r;                          q = q / r;                            /* Row modification */                            for(int j = n - 1; j < nn; j++)                          {                              z = _h[n - 1][j];                              _h[n - 1][j] = (q * z) + (p * _h[n][j]);                              _h[n][j] = (q * _h[n][j]) - (p * z);                          }                            /* Column modification */                            for(int i = 0; i <= n; i++)                          {                              z = _h[i][n - 1];                              _h[i][n - 1] = (q * z) + (p * _h[i][n]);                              _h[i][n] = (q * _h[i][n]) - (p * z);                          }                            /* Accumulate transformations */                            for(int i = low; i <= high; i++)                          {                              z = _v[i][n - 1];                              _v[i][n - 1] = (q * z) + (p * _v[i][n]);                              _v[i][n] = (q * _v[i][n]) - (p * z);                          }                            // Complex pair                      }                      else                      {                          _d[n - 1] = x + p;                          _d[n] = x + p;                          _e[n - 1] = z;                          _e[n] = -z;                      }                        n = n - 2;                      iter = 0;                        // No convergence yet                  }                  else                  {                      /* Form shift */                        x = _h[n][n];                      y = 0.0;                      w = 0.0;                      if(l < n)                      {                          y = _h[n - 1][n - 1];                          w = _h[n][n - 1] * _h[n - 1][n];                      }                        /* Wilkinson's original ad hoc shift */                        if(iter == 10)                      {                          exshift += x;                          for(int i = low; i <= n; i++)                          {                              _h[i][i] -= x;                          }                            s = Math.Abs(_h[n][n - 1]) + Math.Abs(_h[n - 1][n - 2]);                          x = y = 0.75 * s;                          w = (-0.4375) * s * s;                      }                        /* MATLAB's new ad hoc shift */                        if(iter == 30)                      {                          s = (y - x) / 2.0;                          s = (s * s) + w;                          if(s > 0)                          {                              s = Math.Sqrt(s);                              if(y < x)                              {                                  s = -s;                              }                                s = x - (w / (((y - x) / 2.0) + s));                              for(int i = low; i <= n; i++)                              {                                  _h[i][i] -= s;                              }                                exshift += s;                              x = y = w = 0.964;                          }                      }                        iter = iter + 1; // (Could check iteration count here.)                        /* Look for two consecutive small sub-diagonal elements */                        int m = n - 2;                      while(m >= l)                      {                          z = _h[m][m];                          r = x - z;                          s = y - z;                          p = (((r * s) - w) / _h[m + 1][m]) + _h[m][m + 1];                          q = _h[m + 1][m + 1] - z - r - s;                          r = _h[m + 2][m + 1];                          s = Math.Abs(p) + Math.Abs(q) + Math.Abs(r);                          p = p / s;                          q = q / s;                          r = r / s;                            if(m == l)                          {                              break;                          }                            if(Math.Abs(_h[m][m - 1]) * (Math.Abs(q) + Math.Abs(r)) < eps * (Math.Abs(p) * (Math.Abs(_h[m - 1][m - 1]) + Math.Abs(z) + Math.Abs(_h[m + 1][m + 1]))))                          {                              break;                          }                            m--;                      }                        for(int i = m + 2; i <= n; i++)                      {                          _h[i][i - 2] = 0.0;                          if(i > m + 2)                          {                              _h[i][i - 3] = 0.0;                          }                      }                        /* Double QR step involving rows l:n and columns m:n */                        for(int k = m; k <= n - 1; k++)                      {                          bool notlast = (k != n - 1);                            if(k != m)                          {                              p = _h[k][k - 1];                              q = _h[k + 1][k - 1];                              r = (notlast ? _h[k + 2][k - 1] : 0.0);                              x = Math.Abs(p) + Math.Abs(q) + Math.Abs(r);                              if(x != 0.0)                              {                                  p = p / x;                                  q = q / x;                                  r = r / x;                              }                          }                            if(x == 0.0)                          {                              break;                          }                            s = Math.Sqrt((p * p) + (q * q) + (r * r));                          if(p < 0)                          {                              s = -s;                          }                            if(s != 0.0)                          {                              if(k != m)                              {                                  _h[k][k - 1] = (-s) * x;                              }                              else if(l != m)                              {                                  _h[k][k - 1] = -_h[k][k - 1];                              }                                p = p + s;                              x = p / s;                              y = q / s;                              z = r / s;                              q = q / p;                              r = r / p;                                /* Row modification */                                for(int j = k; j < nn; j++)                              {                                  p = _h[k][j] + (q * _h[k + 1][j]);                                    if(notlast)                                  {                                      p = p + (r * _h[k + 2][j]);                                      _h[k + 2][j] = _h[k + 2][j] - (p * z);                                  }                                    _h[k][j] = _h[k][j] - (p * x);                                  _h[k + 1][j] = _h[k + 1][j] - (p * y);                              }                                /* Column modification */                                for(int i = 0; i <= Math.Min(n' k + 3); i++)                              {                                  double[] hi = _h[i];                                  p = (x * hi[k]) + (y * hi[k + 1]);                                    if(notlast)                                  {                                      p = p + (z * hi[k + 2]);                                      hi[k + 2] = hi[k + 2] - (p * r);                                  }                                    hi[k] = hi[k] - p;                                  hi[k + 1] = hi[k + 1] - (p * q);                              }                                /* Accumulate transformations */                                for(int i = low; i <= high; i++)                              {                                  double[] vi = _v[i];                                  p = (x * vi[k]) + (y * vi[k + 1]);                                    if(notlast)                                  {                                      p = p + (z * vi[k + 2]);                                      vi[k + 2] = vi[k + 2] - (p * r);                                  }                                    vi[k] = vi[k] - p;                                  vi[k + 1] = vi[k + 1] - (p * q);                              }                          } // (s != 0)                      } // k loop                  } // check convergence              }
Magic Number,MathNet.Numerics.LinearAlgebra,EigenvalueDecomposition,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\LinearAlgebra\EigenvalueDecomposition.cs,NonsymmetricReduceHessenberToRealSchur,The following statement contains a magic number: while(n >= low)              {                  /* Look for single small sub-diagonal element */                    int l = n;                  while(l > low)                  {                      s = Math.Abs(_h[l - 1][l - 1]) + Math.Abs(_h[l][l]);                        if(s == 0.0)                      {                          s = norm;                      }                        if(Math.Abs(_h[l][l - 1]) < eps * s)                      {                          break;                      }                        l--;                  }                    /*                  Check for convergence                  One root found                  */                    if(l == n)                  {                      _h[n][n] = _h[n][n] + exshift;                      _d[n] = _h[n][n];                      _e[n] = 0.0;                      n--;                      iter = 0;                        // Two roots found                  }                  else if(l == n - 1)                  {                      w = _h[n][n - 1] * _h[n - 1][n];                      p = (_h[n - 1][n - 1] - _h[n][n]) / 2.0;                      q = (p * p) + w;                      z = Math.Sqrt(Math.Abs(q));                      _h[n][n] = _h[n][n] + exshift;                      _h[n - 1][n - 1] = _h[n - 1][n - 1] + exshift;                      x = _h[n][n];                        /* Real pair */                        if(q >= 0)                      {                          if(p >= 0)                          {                              z = p + z;                          }                          else                          {                              z = p - z;                          }                            _d[n - 1] = x + z;                            _d[n] = _d[n - 1];                          if(z != 0.0)                          {                              _d[n] = x - (w / z);                          }                            _e[n - 1] = 0.0;                          _e[n] = 0.0;                          x = _h[n][n - 1];                          s = Math.Abs(x) + Math.Abs(z);                          p = x / s;                          q = z / s;                          r = Math.Sqrt((p * p) + (q * q));                          p = p / r;                          q = q / r;                            /* Row modification */                            for(int j = n - 1; j < nn; j++)                          {                              z = _h[n - 1][j];                              _h[n - 1][j] = (q * z) + (p * _h[n][j]);                              _h[n][j] = (q * _h[n][j]) - (p * z);                          }                            /* Column modification */                            for(int i = 0; i <= n; i++)                          {                              z = _h[i][n - 1];                              _h[i][n - 1] = (q * z) + (p * _h[i][n]);                              _h[i][n] = (q * _h[i][n]) - (p * z);                          }                            /* Accumulate transformations */                            for(int i = low; i <= high; i++)                          {                              z = _v[i][n - 1];                              _v[i][n - 1] = (q * z) + (p * _v[i][n]);                              _v[i][n] = (q * _v[i][n]) - (p * z);                          }                            // Complex pair                      }                      else                      {                          _d[n - 1] = x + p;                          _d[n] = x + p;                          _e[n - 1] = z;                          _e[n] = -z;                      }                        n = n - 2;                      iter = 0;                        // No convergence yet                  }                  else                  {                      /* Form shift */                        x = _h[n][n];                      y = 0.0;                      w = 0.0;                      if(l < n)                      {                          y = _h[n - 1][n - 1];                          w = _h[n][n - 1] * _h[n - 1][n];                      }                        /* Wilkinson's original ad hoc shift */                        if(iter == 10)                      {                          exshift += x;                          for(int i = low; i <= n; i++)                          {                              _h[i][i] -= x;                          }                            s = Math.Abs(_h[n][n - 1]) + Math.Abs(_h[n - 1][n - 2]);                          x = y = 0.75 * s;                          w = (-0.4375) * s * s;                      }                        /* MATLAB's new ad hoc shift */                        if(iter == 30)                      {                          s = (y - x) / 2.0;                          s = (s * s) + w;                          if(s > 0)                          {                              s = Math.Sqrt(s);                              if(y < x)                              {                                  s = -s;                              }                                s = x - (w / (((y - x) / 2.0) + s));                              for(int i = low; i <= n; i++)                              {                                  _h[i][i] -= s;                              }                                exshift += s;                              x = y = w = 0.964;                          }                      }                        iter = iter + 1; // (Could check iteration count here.)                        /* Look for two consecutive small sub-diagonal elements */                        int m = n - 2;                      while(m >= l)                      {                          z = _h[m][m];                          r = x - z;                          s = y - z;                          p = (((r * s) - w) / _h[m + 1][m]) + _h[m][m + 1];                          q = _h[m + 1][m + 1] - z - r - s;                          r = _h[m + 2][m + 1];                          s = Math.Abs(p) + Math.Abs(q) + Math.Abs(r);                          p = p / s;                          q = q / s;                          r = r / s;                            if(m == l)                          {                              break;                          }                            if(Math.Abs(_h[m][m - 1]) * (Math.Abs(q) + Math.Abs(r)) < eps * (Math.Abs(p) * (Math.Abs(_h[m - 1][m - 1]) + Math.Abs(z) + Math.Abs(_h[m + 1][m + 1]))))                          {                              break;                          }                            m--;                      }                        for(int i = m + 2; i <= n; i++)                      {                          _h[i][i - 2] = 0.0;                          if(i > m + 2)                          {                              _h[i][i - 3] = 0.0;                          }                      }                        /* Double QR step involving rows l:n and columns m:n */                        for(int k = m; k <= n - 1; k++)                      {                          bool notlast = (k != n - 1);                            if(k != m)                          {                              p = _h[k][k - 1];                              q = _h[k + 1][k - 1];                              r = (notlast ? _h[k + 2][k - 1] : 0.0);                              x = Math.Abs(p) + Math.Abs(q) + Math.Abs(r);                              if(x != 0.0)                              {                                  p = p / x;                                  q = q / x;                                  r = r / x;                              }                          }                            if(x == 0.0)                          {                              break;                          }                            s = Math.Sqrt((p * p) + (q * q) + (r * r));                          if(p < 0)                          {                              s = -s;                          }                            if(s != 0.0)                          {                              if(k != m)                              {                                  _h[k][k - 1] = (-s) * x;                              }                              else if(l != m)                              {                                  _h[k][k - 1] = -_h[k][k - 1];                              }                                p = p + s;                              x = p / s;                              y = q / s;                              z = r / s;                              q = q / p;                              r = r / p;                                /* Row modification */                                for(int j = k; j < nn; j++)                              {                                  p = _h[k][j] + (q * _h[k + 1][j]);                                    if(notlast)                                  {                                      p = p + (r * _h[k + 2][j]);                                      _h[k + 2][j] = _h[k + 2][j] - (p * z);                                  }                                    _h[k][j] = _h[k][j] - (p * x);                                  _h[k + 1][j] = _h[k + 1][j] - (p * y);                              }                                /* Column modification */                                for(int i = 0; i <= Math.Min(n' k + 3); i++)                              {                                  double[] hi = _h[i];                                  p = (x * hi[k]) + (y * hi[k + 1]);                                    if(notlast)                                  {                                      p = p + (z * hi[k + 2]);                                      hi[k + 2] = hi[k + 2] - (p * r);                                  }                                    hi[k] = hi[k] - p;                                  hi[k + 1] = hi[k + 1] - (p * q);                              }                                /* Accumulate transformations */                                for(int i = low; i <= high; i++)                              {                                  double[] vi = _v[i];                                  p = (x * vi[k]) + (y * vi[k + 1]);                                    if(notlast)                                  {                                      p = p + (z * vi[k + 2]);                                      vi[k + 2] = vi[k + 2] - (p * r);                                  }                                    vi[k] = vi[k] - p;                                  vi[k + 1] = vi[k + 1] - (p * q);                              }                          } // (s != 0)                      } // k loop                  } // check convergence              }
Magic Number,MathNet.Numerics.LinearAlgebra,EigenvalueDecomposition,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\LinearAlgebra\EigenvalueDecomposition.cs,NonsymmetricReduceHessenberToRealSchur,The following statement contains a magic number: while(n >= low)              {                  /* Look for single small sub-diagonal element */                    int l = n;                  while(l > low)                  {                      s = Math.Abs(_h[l - 1][l - 1]) + Math.Abs(_h[l][l]);                        if(s == 0.0)                      {                          s = norm;                      }                        if(Math.Abs(_h[l][l - 1]) < eps * s)                      {                          break;                      }                        l--;                  }                    /*                  Check for convergence                  One root found                  */                    if(l == n)                  {                      _h[n][n] = _h[n][n] + exshift;                      _d[n] = _h[n][n];                      _e[n] = 0.0;                      n--;                      iter = 0;                        // Two roots found                  }                  else if(l == n - 1)                  {                      w = _h[n][n - 1] * _h[n - 1][n];                      p = (_h[n - 1][n - 1] - _h[n][n]) / 2.0;                      q = (p * p) + w;                      z = Math.Sqrt(Math.Abs(q));                      _h[n][n] = _h[n][n] + exshift;                      _h[n - 1][n - 1] = _h[n - 1][n - 1] + exshift;                      x = _h[n][n];                        /* Real pair */                        if(q >= 0)                      {                          if(p >= 0)                          {                              z = p + z;                          }                          else                          {                              z = p - z;                          }                            _d[n - 1] = x + z;                            _d[n] = _d[n - 1];                          if(z != 0.0)                          {                              _d[n] = x - (w / z);                          }                            _e[n - 1] = 0.0;                          _e[n] = 0.0;                          x = _h[n][n - 1];                          s = Math.Abs(x) + Math.Abs(z);                          p = x / s;                          q = z / s;                          r = Math.Sqrt((p * p) + (q * q));                          p = p / r;                          q = q / r;                            /* Row modification */                            for(int j = n - 1; j < nn; j++)                          {                              z = _h[n - 1][j];                              _h[n - 1][j] = (q * z) + (p * _h[n][j]);                              _h[n][j] = (q * _h[n][j]) - (p * z);                          }                            /* Column modification */                            for(int i = 0; i <= n; i++)                          {                              z = _h[i][n - 1];                              _h[i][n - 1] = (q * z) + (p * _h[i][n]);                              _h[i][n] = (q * _h[i][n]) - (p * z);                          }                            /* Accumulate transformations */                            for(int i = low; i <= high; i++)                          {                              z = _v[i][n - 1];                              _v[i][n - 1] = (q * z) + (p * _v[i][n]);                              _v[i][n] = (q * _v[i][n]) - (p * z);                          }                            // Complex pair                      }                      else                      {                          _d[n - 1] = x + p;                          _d[n] = x + p;                          _e[n - 1] = z;                          _e[n] = -z;                      }                        n = n - 2;                      iter = 0;                        // No convergence yet                  }                  else                  {                      /* Form shift */                        x = _h[n][n];                      y = 0.0;                      w = 0.0;                      if(l < n)                      {                          y = _h[n - 1][n - 1];                          w = _h[n][n - 1] * _h[n - 1][n];                      }                        /* Wilkinson's original ad hoc shift */                        if(iter == 10)                      {                          exshift += x;                          for(int i = low; i <= n; i++)                          {                              _h[i][i] -= x;                          }                            s = Math.Abs(_h[n][n - 1]) + Math.Abs(_h[n - 1][n - 2]);                          x = y = 0.75 * s;                          w = (-0.4375) * s * s;                      }                        /* MATLAB's new ad hoc shift */                        if(iter == 30)                      {                          s = (y - x) / 2.0;                          s = (s * s) + w;                          if(s > 0)                          {                              s = Math.Sqrt(s);                              if(y < x)                              {                                  s = -s;                              }                                s = x - (w / (((y - x) / 2.0) + s));                              for(int i = low; i <= n; i++)                              {                                  _h[i][i] -= s;                              }                                exshift += s;                              x = y = w = 0.964;                          }                      }                        iter = iter + 1; // (Could check iteration count here.)                        /* Look for two consecutive small sub-diagonal elements */                        int m = n - 2;                      while(m >= l)                      {                          z = _h[m][m];                          r = x - z;                          s = y - z;                          p = (((r * s) - w) / _h[m + 1][m]) + _h[m][m + 1];                          q = _h[m + 1][m + 1] - z - r - s;                          r = _h[m + 2][m + 1];                          s = Math.Abs(p) + Math.Abs(q) + Math.Abs(r);                          p = p / s;                          q = q / s;                          r = r / s;                            if(m == l)                          {                              break;                          }                            if(Math.Abs(_h[m][m - 1]) * (Math.Abs(q) + Math.Abs(r)) < eps * (Math.Abs(p) * (Math.Abs(_h[m - 1][m - 1]) + Math.Abs(z) + Math.Abs(_h[m + 1][m + 1]))))                          {                              break;                          }                            m--;                      }                        for(int i = m + 2; i <= n; i++)                      {                          _h[i][i - 2] = 0.0;                          if(i > m + 2)                          {                              _h[i][i - 3] = 0.0;                          }                      }                        /* Double QR step involving rows l:n and columns m:n */                        for(int k = m; k <= n - 1; k++)                      {                          bool notlast = (k != n - 1);                            if(k != m)                          {                              p = _h[k][k - 1];                              q = _h[k + 1][k - 1];                              r = (notlast ? _h[k + 2][k - 1] : 0.0);                              x = Math.Abs(p) + Math.Abs(q) + Math.Abs(r);                              if(x != 0.0)                              {                                  p = p / x;                                  q = q / x;                                  r = r / x;                              }                          }                            if(x == 0.0)                          {                              break;                          }                            s = Math.Sqrt((p * p) + (q * q) + (r * r));                          if(p < 0)                          {                              s = -s;                          }                            if(s != 0.0)                          {                              if(k != m)                              {                                  _h[k][k - 1] = (-s) * x;                              }                              else if(l != m)                              {                                  _h[k][k - 1] = -_h[k][k - 1];                              }                                p = p + s;                              x = p / s;                              y = q / s;                              z = r / s;                              q = q / p;                              r = r / p;                                /* Row modification */                                for(int j = k; j < nn; j++)                              {                                  p = _h[k][j] + (q * _h[k + 1][j]);                                    if(notlast)                                  {                                      p = p + (r * _h[k + 2][j]);                                      _h[k + 2][j] = _h[k + 2][j] - (p * z);                                  }                                    _h[k][j] = _h[k][j] - (p * x);                                  _h[k + 1][j] = _h[k + 1][j] - (p * y);                              }                                /* Column modification */                                for(int i = 0; i <= Math.Min(n' k + 3); i++)                              {                                  double[] hi = _h[i];                                  p = (x * hi[k]) + (y * hi[k + 1]);                                    if(notlast)                                  {                                      p = p + (z * hi[k + 2]);                                      hi[k + 2] = hi[k + 2] - (p * r);                                  }                                    hi[k] = hi[k] - p;                                  hi[k + 1] = hi[k + 1] - (p * q);                              }                                /* Accumulate transformations */                                for(int i = low; i <= high; i++)                              {                                  double[] vi = _v[i];                                  p = (x * vi[k]) + (y * vi[k + 1]);                                    if(notlast)                                  {                                      p = p + (z * vi[k + 2]);                                      vi[k + 2] = vi[k + 2] - (p * r);                                  }                                    vi[k] = vi[k] - p;                                  vi[k + 1] = vi[k + 1] - (p * q);                              }                          } // (s != 0)                      } // k loop                  } // check convergence              }
Magic Number,MathNet.Numerics.LinearAlgebra,EigenvalueDecomposition,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\LinearAlgebra\EigenvalueDecomposition.cs,NonsymmetricReduceHessenberToRealSchur,The following statement contains a magic number: while(n >= low)              {                  /* Look for single small sub-diagonal element */                    int l = n;                  while(l > low)                  {                      s = Math.Abs(_h[l - 1][l - 1]) + Math.Abs(_h[l][l]);                        if(s == 0.0)                      {                          s = norm;                      }                        if(Math.Abs(_h[l][l - 1]) < eps * s)                      {                          break;                      }                        l--;                  }                    /*                  Check for convergence                  One root found                  */                    if(l == n)                  {                      _h[n][n] = _h[n][n] + exshift;                      _d[n] = _h[n][n];                      _e[n] = 0.0;                      n--;                      iter = 0;                        // Two roots found                  }                  else if(l == n - 1)                  {                      w = _h[n][n - 1] * _h[n - 1][n];                      p = (_h[n - 1][n - 1] - _h[n][n]) / 2.0;                      q = (p * p) + w;                      z = Math.Sqrt(Math.Abs(q));                      _h[n][n] = _h[n][n] + exshift;                      _h[n - 1][n - 1] = _h[n - 1][n - 1] + exshift;                      x = _h[n][n];                        /* Real pair */                        if(q >= 0)                      {                          if(p >= 0)                          {                              z = p + z;                          }                          else                          {                              z = p - z;                          }                            _d[n - 1] = x + z;                            _d[n] = _d[n - 1];                          if(z != 0.0)                          {                              _d[n] = x - (w / z);                          }                            _e[n - 1] = 0.0;                          _e[n] = 0.0;                          x = _h[n][n - 1];                          s = Math.Abs(x) + Math.Abs(z);                          p = x / s;                          q = z / s;                          r = Math.Sqrt((p * p) + (q * q));                          p = p / r;                          q = q / r;                            /* Row modification */                            for(int j = n - 1; j < nn; j++)                          {                              z = _h[n - 1][j];                              _h[n - 1][j] = (q * z) + (p * _h[n][j]);                              _h[n][j] = (q * _h[n][j]) - (p * z);                          }                            /* Column modification */                            for(int i = 0; i <= n; i++)                          {                              z = _h[i][n - 1];                              _h[i][n - 1] = (q * z) + (p * _h[i][n]);                              _h[i][n] = (q * _h[i][n]) - (p * z);                          }                            /* Accumulate transformations */                            for(int i = low; i <= high; i++)                          {                              z = _v[i][n - 1];                              _v[i][n - 1] = (q * z) + (p * _v[i][n]);                              _v[i][n] = (q * _v[i][n]) - (p * z);                          }                            // Complex pair                      }                      else                      {                          _d[n - 1] = x + p;                          _d[n] = x + p;                          _e[n - 1] = z;                          _e[n] = -z;                      }                        n = n - 2;                      iter = 0;                        // No convergence yet                  }                  else                  {                      /* Form shift */                        x = _h[n][n];                      y = 0.0;                      w = 0.0;                      if(l < n)                      {                          y = _h[n - 1][n - 1];                          w = _h[n][n - 1] * _h[n - 1][n];                      }                        /* Wilkinson's original ad hoc shift */                        if(iter == 10)                      {                          exshift += x;                          for(int i = low; i <= n; i++)                          {                              _h[i][i] -= x;                          }                            s = Math.Abs(_h[n][n - 1]) + Math.Abs(_h[n - 1][n - 2]);                          x = y = 0.75 * s;                          w = (-0.4375) * s * s;                      }                        /* MATLAB's new ad hoc shift */                        if(iter == 30)                      {                          s = (y - x) / 2.0;                          s = (s * s) + w;                          if(s > 0)                          {                              s = Math.Sqrt(s);                              if(y < x)                              {                                  s = -s;                              }                                s = x - (w / (((y - x) / 2.0) + s));                              for(int i = low; i <= n; i++)                              {                                  _h[i][i] -= s;                              }                                exshift += s;                              x = y = w = 0.964;                          }                      }                        iter = iter + 1; // (Could check iteration count here.)                        /* Look for two consecutive small sub-diagonal elements */                        int m = n - 2;                      while(m >= l)                      {                          z = _h[m][m];                          r = x - z;                          s = y - z;                          p = (((r * s) - w) / _h[m + 1][m]) + _h[m][m + 1];                          q = _h[m + 1][m + 1] - z - r - s;                          r = _h[m + 2][m + 1];                          s = Math.Abs(p) + Math.Abs(q) + Math.Abs(r);                          p = p / s;                          q = q / s;                          r = r / s;                            if(m == l)                          {                              break;                          }                            if(Math.Abs(_h[m][m - 1]) * (Math.Abs(q) + Math.Abs(r)) < eps * (Math.Abs(p) * (Math.Abs(_h[m - 1][m - 1]) + Math.Abs(z) + Math.Abs(_h[m + 1][m + 1]))))                          {                              break;                          }                            m--;                      }                        for(int i = m + 2; i <= n; i++)                      {                          _h[i][i - 2] = 0.0;                          if(i > m + 2)                          {                              _h[i][i - 3] = 0.0;                          }                      }                        /* Double QR step involving rows l:n and columns m:n */                        for(int k = m; k <= n - 1; k++)                      {                          bool notlast = (k != n - 1);                            if(k != m)                          {                              p = _h[k][k - 1];                              q = _h[k + 1][k - 1];                              r = (notlast ? _h[k + 2][k - 1] : 0.0);                              x = Math.Abs(p) + Math.Abs(q) + Math.Abs(r);                              if(x != 0.0)                              {                                  p = p / x;                                  q = q / x;                                  r = r / x;                              }                          }                            if(x == 0.0)                          {                              break;                          }                            s = Math.Sqrt((p * p) + (q * q) + (r * r));                          if(p < 0)                          {                              s = -s;                          }                            if(s != 0.0)                          {                              if(k != m)                              {                                  _h[k][k - 1] = (-s) * x;                              }                              else if(l != m)                              {                                  _h[k][k - 1] = -_h[k][k - 1];                              }                                p = p + s;                              x = p / s;                              y = q / s;                              z = r / s;                              q = q / p;                              r = r / p;                                /* Row modification */                                for(int j = k; j < nn; j++)                              {                                  p = _h[k][j] + (q * _h[k + 1][j]);                                    if(notlast)                                  {                                      p = p + (r * _h[k + 2][j]);                                      _h[k + 2][j] = _h[k + 2][j] - (p * z);                                  }                                    _h[k][j] = _h[k][j] - (p * x);                                  _h[k + 1][j] = _h[k + 1][j] - (p * y);                              }                                /* Column modification */                                for(int i = 0; i <= Math.Min(n' k + 3); i++)                              {                                  double[] hi = _h[i];                                  p = (x * hi[k]) + (y * hi[k + 1]);                                    if(notlast)                                  {                                      p = p + (z * hi[k + 2]);                                      hi[k + 2] = hi[k + 2] - (p * r);                                  }                                    hi[k] = hi[k] - p;                                  hi[k + 1] = hi[k + 1] - (p * q);                              }                                /* Accumulate transformations */                                for(int i = low; i <= high; i++)                              {                                  double[] vi = _v[i];                                  p = (x * vi[k]) + (y * vi[k + 1]);                                    if(notlast)                                  {                                      p = p + (z * vi[k + 2]);                                      vi[k + 2] = vi[k + 2] - (p * r);                                  }                                    vi[k] = vi[k] - p;                                  vi[k + 1] = vi[k + 1] - (p * q);                              }                          } // (s != 0)                      } // k loop                  } // check convergence              }
Magic Number,MathNet.Numerics.LinearAlgebra,EigenvalueDecomposition,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\LinearAlgebra\EigenvalueDecomposition.cs,NonsymmetricReduceHessenberToRealSchur,The following statement contains a magic number: while(n >= low)              {                  /* Look for single small sub-diagonal element */                    int l = n;                  while(l > low)                  {                      s = Math.Abs(_h[l - 1][l - 1]) + Math.Abs(_h[l][l]);                        if(s == 0.0)                      {                          s = norm;                      }                        if(Math.Abs(_h[l][l - 1]) < eps * s)                      {                          break;                      }                        l--;                  }                    /*                  Check for convergence                  One root found                  */                    if(l == n)                  {                      _h[n][n] = _h[n][n] + exshift;                      _d[n] = _h[n][n];                      _e[n] = 0.0;                      n--;                      iter = 0;                        // Two roots found                  }                  else if(l == n - 1)                  {                      w = _h[n][n - 1] * _h[n - 1][n];                      p = (_h[n - 1][n - 1] - _h[n][n]) / 2.0;                      q = (p * p) + w;                      z = Math.Sqrt(Math.Abs(q));                      _h[n][n] = _h[n][n] + exshift;                      _h[n - 1][n - 1] = _h[n - 1][n - 1] + exshift;                      x = _h[n][n];                        /* Real pair */                        if(q >= 0)                      {                          if(p >= 0)                          {                              z = p + z;                          }                          else                          {                              z = p - z;                          }                            _d[n - 1] = x + z;                            _d[n] = _d[n - 1];                          if(z != 0.0)                          {                              _d[n] = x - (w / z);                          }                            _e[n - 1] = 0.0;                          _e[n] = 0.0;                          x = _h[n][n - 1];                          s = Math.Abs(x) + Math.Abs(z);                          p = x / s;                          q = z / s;                          r = Math.Sqrt((p * p) + (q * q));                          p = p / r;                          q = q / r;                            /* Row modification */                            for(int j = n - 1; j < nn; j++)                          {                              z = _h[n - 1][j];                              _h[n - 1][j] = (q * z) + (p * _h[n][j]);                              _h[n][j] = (q * _h[n][j]) - (p * z);                          }                            /* Column modification */                            for(int i = 0; i <= n; i++)                          {                              z = _h[i][n - 1];                              _h[i][n - 1] = (q * z) + (p * _h[i][n]);                              _h[i][n] = (q * _h[i][n]) - (p * z);                          }                            /* Accumulate transformations */                            for(int i = low; i <= high; i++)                          {                              z = _v[i][n - 1];                              _v[i][n - 1] = (q * z) + (p * _v[i][n]);                              _v[i][n] = (q * _v[i][n]) - (p * z);                          }                            // Complex pair                      }                      else                      {                          _d[n - 1] = x + p;                          _d[n] = x + p;                          _e[n - 1] = z;                          _e[n] = -z;                      }                        n = n - 2;                      iter = 0;                        // No convergence yet                  }                  else                  {                      /* Form shift */                        x = _h[n][n];                      y = 0.0;                      w = 0.0;                      if(l < n)                      {                          y = _h[n - 1][n - 1];                          w = _h[n][n - 1] * _h[n - 1][n];                      }                        /* Wilkinson's original ad hoc shift */                        if(iter == 10)                      {                          exshift += x;                          for(int i = low; i <= n; i++)                          {                              _h[i][i] -= x;                          }                            s = Math.Abs(_h[n][n - 1]) + Math.Abs(_h[n - 1][n - 2]);                          x = y = 0.75 * s;                          w = (-0.4375) * s * s;                      }                        /* MATLAB's new ad hoc shift */                        if(iter == 30)                      {                          s = (y - x) / 2.0;                          s = (s * s) + w;                          if(s > 0)                          {                              s = Math.Sqrt(s);                              if(y < x)                              {                                  s = -s;                              }                                s = x - (w / (((y - x) / 2.0) + s));                              for(int i = low; i <= n; i++)                              {                                  _h[i][i] -= s;                              }                                exshift += s;                              x = y = w = 0.964;                          }                      }                        iter = iter + 1; // (Could check iteration count here.)                        /* Look for two consecutive small sub-diagonal elements */                        int m = n - 2;                      while(m >= l)                      {                          z = _h[m][m];                          r = x - z;                          s = y - z;                          p = (((r * s) - w) / _h[m + 1][m]) + _h[m][m + 1];                          q = _h[m + 1][m + 1] - z - r - s;                          r = _h[m + 2][m + 1];                          s = Math.Abs(p) + Math.Abs(q) + Math.Abs(r);                          p = p / s;                          q = q / s;                          r = r / s;                            if(m == l)                          {                              break;                          }                            if(Math.Abs(_h[m][m - 1]) * (Math.Abs(q) + Math.Abs(r)) < eps * (Math.Abs(p) * (Math.Abs(_h[m - 1][m - 1]) + Math.Abs(z) + Math.Abs(_h[m + 1][m + 1]))))                          {                              break;                          }                            m--;                      }                        for(int i = m + 2; i <= n; i++)                      {                          _h[i][i - 2] = 0.0;                          if(i > m + 2)                          {                              _h[i][i - 3] = 0.0;                          }                      }                        /* Double QR step involving rows l:n and columns m:n */                        for(int k = m; k <= n - 1; k++)                      {                          bool notlast = (k != n - 1);                            if(k != m)                          {                              p = _h[k][k - 1];                              q = _h[k + 1][k - 1];                              r = (notlast ? _h[k + 2][k - 1] : 0.0);                              x = Math.Abs(p) + Math.Abs(q) + Math.Abs(r);                              if(x != 0.0)                              {                                  p = p / x;                                  q = q / x;                                  r = r / x;                              }                          }                            if(x == 0.0)                          {                              break;                          }                            s = Math.Sqrt((p * p) + (q * q) + (r * r));                          if(p < 0)                          {                              s = -s;                          }                            if(s != 0.0)                          {                              if(k != m)                              {                                  _h[k][k - 1] = (-s) * x;                              }                              else if(l != m)                              {                                  _h[k][k - 1] = -_h[k][k - 1];                              }                                p = p + s;                              x = p / s;                              y = q / s;                              z = r / s;                              q = q / p;                              r = r / p;                                /* Row modification */                                for(int j = k; j < nn; j++)                              {                                  p = _h[k][j] + (q * _h[k + 1][j]);                                    if(notlast)                                  {                                      p = p + (r * _h[k + 2][j]);                                      _h[k + 2][j] = _h[k + 2][j] - (p * z);                                  }                                    _h[k][j] = _h[k][j] - (p * x);                                  _h[k + 1][j] = _h[k + 1][j] - (p * y);                              }                                /* Column modification */                                for(int i = 0; i <= Math.Min(n' k + 3); i++)                              {                                  double[] hi = _h[i];                                  p = (x * hi[k]) + (y * hi[k + 1]);                                    if(notlast)                                  {                                      p = p + (z * hi[k + 2]);                                      hi[k + 2] = hi[k + 2] - (p * r);                                  }                                    hi[k] = hi[k] - p;                                  hi[k + 1] = hi[k + 1] - (p * q);                              }                                /* Accumulate transformations */                                for(int i = low; i <= high; i++)                              {                                  double[] vi = _v[i];                                  p = (x * vi[k]) + (y * vi[k + 1]);                                    if(notlast)                                  {                                      p = p + (z * vi[k + 2]);                                      vi[k + 2] = vi[k + 2] - (p * r);                                  }                                    vi[k] = vi[k] - p;                                  vi[k + 1] = vi[k + 1] - (p * q);                              }                          } // (s != 0)                      } // k loop                  } // check convergence              }
Magic Number,MathNet.Numerics.LinearAlgebra,EigenvalueDecomposition,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\LinearAlgebra\EigenvalueDecomposition.cs,NonsymmetricReduceHessenberToRealSchur,The following statement contains a magic number: while(n >= low)              {                  /* Look for single small sub-diagonal element */                    int l = n;                  while(l > low)                  {                      s = Math.Abs(_h[l - 1][l - 1]) + Math.Abs(_h[l][l]);                        if(s == 0.0)                      {                          s = norm;                      }                        if(Math.Abs(_h[l][l - 1]) < eps * s)                      {                          break;                      }                        l--;                  }                    /*                  Check for convergence                  One root found                  */                    if(l == n)                  {                      _h[n][n] = _h[n][n] + exshift;                      _d[n] = _h[n][n];                      _e[n] = 0.0;                      n--;                      iter = 0;                        // Two roots found                  }                  else if(l == n - 1)                  {                      w = _h[n][n - 1] * _h[n - 1][n];                      p = (_h[n - 1][n - 1] - _h[n][n]) / 2.0;                      q = (p * p) + w;                      z = Math.Sqrt(Math.Abs(q));                      _h[n][n] = _h[n][n] + exshift;                      _h[n - 1][n - 1] = _h[n - 1][n - 1] + exshift;                      x = _h[n][n];                        /* Real pair */                        if(q >= 0)                      {                          if(p >= 0)                          {                              z = p + z;                          }                          else                          {                              z = p - z;                          }                            _d[n - 1] = x + z;                            _d[n] = _d[n - 1];                          if(z != 0.0)                          {                              _d[n] = x - (w / z);                          }                            _e[n - 1] = 0.0;                          _e[n] = 0.0;                          x = _h[n][n - 1];                          s = Math.Abs(x) + Math.Abs(z);                          p = x / s;                          q = z / s;                          r = Math.Sqrt((p * p) + (q * q));                          p = p / r;                          q = q / r;                            /* Row modification */                            for(int j = n - 1; j < nn; j++)                          {                              z = _h[n - 1][j];                              _h[n - 1][j] = (q * z) + (p * _h[n][j]);                              _h[n][j] = (q * _h[n][j]) - (p * z);                          }                            /* Column modification */                            for(int i = 0; i <= n; i++)                          {                              z = _h[i][n - 1];                              _h[i][n - 1] = (q * z) + (p * _h[i][n]);                              _h[i][n] = (q * _h[i][n]) - (p * z);                          }                            /* Accumulate transformations */                            for(int i = low; i <= high; i++)                          {                              z = _v[i][n - 1];                              _v[i][n - 1] = (q * z) + (p * _v[i][n]);                              _v[i][n] = (q * _v[i][n]) - (p * z);                          }                            // Complex pair                      }                      else                      {                          _d[n - 1] = x + p;                          _d[n] = x + p;                          _e[n - 1] = z;                          _e[n] = -z;                      }                        n = n - 2;                      iter = 0;                        // No convergence yet                  }                  else                  {                      /* Form shift */                        x = _h[n][n];                      y = 0.0;                      w = 0.0;                      if(l < n)                      {                          y = _h[n - 1][n - 1];                          w = _h[n][n - 1] * _h[n - 1][n];                      }                        /* Wilkinson's original ad hoc shift */                        if(iter == 10)                      {                          exshift += x;                          for(int i = low; i <= n; i++)                          {                              _h[i][i] -= x;                          }                            s = Math.Abs(_h[n][n - 1]) + Math.Abs(_h[n - 1][n - 2]);                          x = y = 0.75 * s;                          w = (-0.4375) * s * s;                      }                        /* MATLAB's new ad hoc shift */                        if(iter == 30)                      {                          s = (y - x) / 2.0;                          s = (s * s) + w;                          if(s > 0)                          {                              s = Math.Sqrt(s);                              if(y < x)                              {                                  s = -s;                              }                                s = x - (w / (((y - x) / 2.0) + s));                              for(int i = low; i <= n; i++)                              {                                  _h[i][i] -= s;                              }                                exshift += s;                              x = y = w = 0.964;                          }                      }                        iter = iter + 1; // (Could check iteration count here.)                        /* Look for two consecutive small sub-diagonal elements */                        int m = n - 2;                      while(m >= l)                      {                          z = _h[m][m];                          r = x - z;                          s = y - z;                          p = (((r * s) - w) / _h[m + 1][m]) + _h[m][m + 1];                          q = _h[m + 1][m + 1] - z - r - s;                          r = _h[m + 2][m + 1];                          s = Math.Abs(p) + Math.Abs(q) + Math.Abs(r);                          p = p / s;                          q = q / s;                          r = r / s;                            if(m == l)                          {                              break;                          }                            if(Math.Abs(_h[m][m - 1]) * (Math.Abs(q) + Math.Abs(r)) < eps * (Math.Abs(p) * (Math.Abs(_h[m - 1][m - 1]) + Math.Abs(z) + Math.Abs(_h[m + 1][m + 1]))))                          {                              break;                          }                            m--;                      }                        for(int i = m + 2; i <= n; i++)                      {                          _h[i][i - 2] = 0.0;                          if(i > m + 2)                          {                              _h[i][i - 3] = 0.0;                          }                      }                        /* Double QR step involving rows l:n and columns m:n */                        for(int k = m; k <= n - 1; k++)                      {                          bool notlast = (k != n - 1);                            if(k != m)                          {                              p = _h[k][k - 1];                              q = _h[k + 1][k - 1];                              r = (notlast ? _h[k + 2][k - 1] : 0.0);                              x = Math.Abs(p) + Math.Abs(q) + Math.Abs(r);                              if(x != 0.0)                              {                                  p = p / x;                                  q = q / x;                                  r = r / x;                              }                          }                            if(x == 0.0)                          {                              break;                          }                            s = Math.Sqrt((p * p) + (q * q) + (r * r));                          if(p < 0)                          {                              s = -s;                          }                            if(s != 0.0)                          {                              if(k != m)                              {                                  _h[k][k - 1] = (-s) * x;                              }                              else if(l != m)                              {                                  _h[k][k - 1] = -_h[k][k - 1];                              }                                p = p + s;                              x = p / s;                              y = q / s;                              z = r / s;                              q = q / p;                              r = r / p;                                /* Row modification */                                for(int j = k; j < nn; j++)                              {                                  p = _h[k][j] + (q * _h[k + 1][j]);                                    if(notlast)                                  {                                      p = p + (r * _h[k + 2][j]);                                      _h[k + 2][j] = _h[k + 2][j] - (p * z);                                  }                                    _h[k][j] = _h[k][j] - (p * x);                                  _h[k + 1][j] = _h[k + 1][j] - (p * y);                              }                                /* Column modification */                                for(int i = 0; i <= Math.Min(n' k + 3); i++)                              {                                  double[] hi = _h[i];                                  p = (x * hi[k]) + (y * hi[k + 1]);                                    if(notlast)                                  {                                      p = p + (z * hi[k + 2]);                                      hi[k + 2] = hi[k + 2] - (p * r);                                  }                                    hi[k] = hi[k] - p;                                  hi[k + 1] = hi[k + 1] - (p * q);                              }                                /* Accumulate transformations */                                for(int i = low; i <= high; i++)                              {                                  double[] vi = _v[i];                                  p = (x * vi[k]) + (y * vi[k + 1]);                                    if(notlast)                                  {                                      p = p + (z * vi[k + 2]);                                      vi[k + 2] = vi[k + 2] - (p * r);                                  }                                    vi[k] = vi[k] - p;                                  vi[k + 1] = vi[k + 1] - (p * q);                              }                          } // (s != 0)                      } // k loop                  } // check convergence              }
Magic Number,MathNet.Numerics.LinearAlgebra,EigenvalueDecomposition,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\LinearAlgebra\EigenvalueDecomposition.cs,NonsymmetricReduceHessenberToRealSchur,The following statement contains a magic number: while(n >= low)              {                  /* Look for single small sub-diagonal element */                    int l = n;                  while(l > low)                  {                      s = Math.Abs(_h[l - 1][l - 1]) + Math.Abs(_h[l][l]);                        if(s == 0.0)                      {                          s = norm;                      }                        if(Math.Abs(_h[l][l - 1]) < eps * s)                      {                          break;                      }                        l--;                  }                    /*                  Check for convergence                  One root found                  */                    if(l == n)                  {                      _h[n][n] = _h[n][n] + exshift;                      _d[n] = _h[n][n];                      _e[n] = 0.0;                      n--;                      iter = 0;                        // Two roots found                  }                  else if(l == n - 1)                  {                      w = _h[n][n - 1] * _h[n - 1][n];                      p = (_h[n - 1][n - 1] - _h[n][n]) / 2.0;                      q = (p * p) + w;                      z = Math.Sqrt(Math.Abs(q));                      _h[n][n] = _h[n][n] + exshift;                      _h[n - 1][n - 1] = _h[n - 1][n - 1] + exshift;                      x = _h[n][n];                        /* Real pair */                        if(q >= 0)                      {                          if(p >= 0)                          {                              z = p + z;                          }                          else                          {                              z = p - z;                          }                            _d[n - 1] = x + z;                            _d[n] = _d[n - 1];                          if(z != 0.0)                          {                              _d[n] = x - (w / z);                          }                            _e[n - 1] = 0.0;                          _e[n] = 0.0;                          x = _h[n][n - 1];                          s = Math.Abs(x) + Math.Abs(z);                          p = x / s;                          q = z / s;                          r = Math.Sqrt((p * p) + (q * q));                          p = p / r;                          q = q / r;                            /* Row modification */                            for(int j = n - 1; j < nn; j++)                          {                              z = _h[n - 1][j];                              _h[n - 1][j] = (q * z) + (p * _h[n][j]);                              _h[n][j] = (q * _h[n][j]) - (p * z);                          }                            /* Column modification */                            for(int i = 0; i <= n; i++)                          {                              z = _h[i][n - 1];                              _h[i][n - 1] = (q * z) + (p * _h[i][n]);                              _h[i][n] = (q * _h[i][n]) - (p * z);                          }                            /* Accumulate transformations */                            for(int i = low; i <= high; i++)                          {                              z = _v[i][n - 1];                              _v[i][n - 1] = (q * z) + (p * _v[i][n]);                              _v[i][n] = (q * _v[i][n]) - (p * z);                          }                            // Complex pair                      }                      else                      {                          _d[n - 1] = x + p;                          _d[n] = x + p;                          _e[n - 1] = z;                          _e[n] = -z;                      }                        n = n - 2;                      iter = 0;                        // No convergence yet                  }                  else                  {                      /* Form shift */                        x = _h[n][n];                      y = 0.0;                      w = 0.0;                      if(l < n)                      {                          y = _h[n - 1][n - 1];                          w = _h[n][n - 1] * _h[n - 1][n];                      }                        /* Wilkinson's original ad hoc shift */                        if(iter == 10)                      {                          exshift += x;                          for(int i = low; i <= n; i++)                          {                              _h[i][i] -= x;                          }                            s = Math.Abs(_h[n][n - 1]) + Math.Abs(_h[n - 1][n - 2]);                          x = y = 0.75 * s;                          w = (-0.4375) * s * s;                      }                        /* MATLAB's new ad hoc shift */                        if(iter == 30)                      {                          s = (y - x) / 2.0;                          s = (s * s) + w;                          if(s > 0)                          {                              s = Math.Sqrt(s);                              if(y < x)                              {                                  s = -s;                              }                                s = x - (w / (((y - x) / 2.0) + s));                              for(int i = low; i <= n; i++)                              {                                  _h[i][i] -= s;                              }                                exshift += s;                              x = y = w = 0.964;                          }                      }                        iter = iter + 1; // (Could check iteration count here.)                        /* Look for two consecutive small sub-diagonal elements */                        int m = n - 2;                      while(m >= l)                      {                          z = _h[m][m];                          r = x - z;                          s = y - z;                          p = (((r * s) - w) / _h[m + 1][m]) + _h[m][m + 1];                          q = _h[m + 1][m + 1] - z - r - s;                          r = _h[m + 2][m + 1];                          s = Math.Abs(p) + Math.Abs(q) + Math.Abs(r);                          p = p / s;                          q = q / s;                          r = r / s;                            if(m == l)                          {                              break;                          }                            if(Math.Abs(_h[m][m - 1]) * (Math.Abs(q) + Math.Abs(r)) < eps * (Math.Abs(p) * (Math.Abs(_h[m - 1][m - 1]) + Math.Abs(z) + Math.Abs(_h[m + 1][m + 1]))))                          {                              break;                          }                            m--;                      }                        for(int i = m + 2; i <= n; i++)                      {                          _h[i][i - 2] = 0.0;                          if(i > m + 2)                          {                              _h[i][i - 3] = 0.0;                          }                      }                        /* Double QR step involving rows l:n and columns m:n */                        for(int k = m; k <= n - 1; k++)                      {                          bool notlast = (k != n - 1);                            if(k != m)                          {                              p = _h[k][k - 1];                              q = _h[k + 1][k - 1];                              r = (notlast ? _h[k + 2][k - 1] : 0.0);                              x = Math.Abs(p) + Math.Abs(q) + Math.Abs(r);                              if(x != 0.0)                              {                                  p = p / x;                                  q = q / x;                                  r = r / x;                              }                          }                            if(x == 0.0)                          {                              break;                          }                            s = Math.Sqrt((p * p) + (q * q) + (r * r));                          if(p < 0)                          {                              s = -s;                          }                            if(s != 0.0)                          {                              if(k != m)                              {                                  _h[k][k - 1] = (-s) * x;                              }                              else if(l != m)                              {                                  _h[k][k - 1] = -_h[k][k - 1];                              }                                p = p + s;                              x = p / s;                              y = q / s;                              z = r / s;                              q = q / p;                              r = r / p;                                /* Row modification */                                for(int j = k; j < nn; j++)                              {                                  p = _h[k][j] + (q * _h[k + 1][j]);                                    if(notlast)                                  {                                      p = p + (r * _h[k + 2][j]);                                      _h[k + 2][j] = _h[k + 2][j] - (p * z);                                  }                                    _h[k][j] = _h[k][j] - (p * x);                                  _h[k + 1][j] = _h[k + 1][j] - (p * y);                              }                                /* Column modification */                                for(int i = 0; i <= Math.Min(n' k + 3); i++)                              {                                  double[] hi = _h[i];                                  p = (x * hi[k]) + (y * hi[k + 1]);                                    if(notlast)                                  {                                      p = p + (z * hi[k + 2]);                                      hi[k + 2] = hi[k + 2] - (p * r);                                  }                                    hi[k] = hi[k] - p;                                  hi[k + 1] = hi[k + 1] - (p * q);                              }                                /* Accumulate transformations */                                for(int i = low; i <= high; i++)                              {                                  double[] vi = _v[i];                                  p = (x * vi[k]) + (y * vi[k + 1]);                                    if(notlast)                                  {                                      p = p + (z * vi[k + 2]);                                      vi[k + 2] = vi[k + 2] - (p * r);                                  }                                    vi[k] = vi[k] - p;                                  vi[k + 1] = vi[k + 1] - (p * q);                              }                          } // (s != 0)                      } // k loop                  } // check convergence              }
Magic Number,MathNet.Numerics.LinearAlgebra,EigenvalueDecomposition,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\LinearAlgebra\EigenvalueDecomposition.cs,NonsymmetricReduceHessenberToRealSchur,The following statement contains a magic number: while(n >= low)              {                  /* Look for single small sub-diagonal element */                    int l = n;                  while(l > low)                  {                      s = Math.Abs(_h[l - 1][l - 1]) + Math.Abs(_h[l][l]);                        if(s == 0.0)                      {                          s = norm;                      }                        if(Math.Abs(_h[l][l - 1]) < eps * s)                      {                          break;                      }                        l--;                  }                    /*                  Check for convergence                  One root found                  */                    if(l == n)                  {                      _h[n][n] = _h[n][n] + exshift;                      _d[n] = _h[n][n];                      _e[n] = 0.0;                      n--;                      iter = 0;                        // Two roots found                  }                  else if(l == n - 1)                  {                      w = _h[n][n - 1] * _h[n - 1][n];                      p = (_h[n - 1][n - 1] - _h[n][n]) / 2.0;                      q = (p * p) + w;                      z = Math.Sqrt(Math.Abs(q));                      _h[n][n] = _h[n][n] + exshift;                      _h[n - 1][n - 1] = _h[n - 1][n - 1] + exshift;                      x = _h[n][n];                        /* Real pair */                        if(q >= 0)                      {                          if(p >= 0)                          {                              z = p + z;                          }                          else                          {                              z = p - z;                          }                            _d[n - 1] = x + z;                            _d[n] = _d[n - 1];                          if(z != 0.0)                          {                              _d[n] = x - (w / z);                          }                            _e[n - 1] = 0.0;                          _e[n] = 0.0;                          x = _h[n][n - 1];                          s = Math.Abs(x) + Math.Abs(z);                          p = x / s;                          q = z / s;                          r = Math.Sqrt((p * p) + (q * q));                          p = p / r;                          q = q / r;                            /* Row modification */                            for(int j = n - 1; j < nn; j++)                          {                              z = _h[n - 1][j];                              _h[n - 1][j] = (q * z) + (p * _h[n][j]);                              _h[n][j] = (q * _h[n][j]) - (p * z);                          }                            /* Column modification */                            for(int i = 0; i <= n; i++)                          {                              z = _h[i][n - 1];                              _h[i][n - 1] = (q * z) + (p * _h[i][n]);                              _h[i][n] = (q * _h[i][n]) - (p * z);                          }                            /* Accumulate transformations */                            for(int i = low; i <= high; i++)                          {                              z = _v[i][n - 1];                              _v[i][n - 1] = (q * z) + (p * _v[i][n]);                              _v[i][n] = (q * _v[i][n]) - (p * z);                          }                            // Complex pair                      }                      else                      {                          _d[n - 1] = x + p;                          _d[n] = x + p;                          _e[n - 1] = z;                          _e[n] = -z;                      }                        n = n - 2;                      iter = 0;                        // No convergence yet                  }                  else                  {                      /* Form shift */                        x = _h[n][n];                      y = 0.0;                      w = 0.0;                      if(l < n)                      {                          y = _h[n - 1][n - 1];                          w = _h[n][n - 1] * _h[n - 1][n];                      }                        /* Wilkinson's original ad hoc shift */                        if(iter == 10)                      {                          exshift += x;                          for(int i = low; i <= n; i++)                          {                              _h[i][i] -= x;                          }                            s = Math.Abs(_h[n][n - 1]) + Math.Abs(_h[n - 1][n - 2]);                          x = y = 0.75 * s;                          w = (-0.4375) * s * s;                      }                        /* MATLAB's new ad hoc shift */                        if(iter == 30)                      {                          s = (y - x) / 2.0;                          s = (s * s) + w;                          if(s > 0)                          {                              s = Math.Sqrt(s);                              if(y < x)                              {                                  s = -s;                              }                                s = x - (w / (((y - x) / 2.0) + s));                              for(int i = low; i <= n; i++)                              {                                  _h[i][i] -= s;                              }                                exshift += s;                              x = y = w = 0.964;                          }                      }                        iter = iter + 1; // (Could check iteration count here.)                        /* Look for two consecutive small sub-diagonal elements */                        int m = n - 2;                      while(m >= l)                      {                          z = _h[m][m];                          r = x - z;                          s = y - z;                          p = (((r * s) - w) / _h[m + 1][m]) + _h[m][m + 1];                          q = _h[m + 1][m + 1] - z - r - s;                          r = _h[m + 2][m + 1];                          s = Math.Abs(p) + Math.Abs(q) + Math.Abs(r);                          p = p / s;                          q = q / s;                          r = r / s;                            if(m == l)                          {                              break;                          }                            if(Math.Abs(_h[m][m - 1]) * (Math.Abs(q) + Math.Abs(r)) < eps * (Math.Abs(p) * (Math.Abs(_h[m - 1][m - 1]) + Math.Abs(z) + Math.Abs(_h[m + 1][m + 1]))))                          {                              break;                          }                            m--;                      }                        for(int i = m + 2; i <= n; i++)                      {                          _h[i][i - 2] = 0.0;                          if(i > m + 2)                          {                              _h[i][i - 3] = 0.0;                          }                      }                        /* Double QR step involving rows l:n and columns m:n */                        for(int k = m; k <= n - 1; k++)                      {                          bool notlast = (k != n - 1);                            if(k != m)                          {                              p = _h[k][k - 1];                              q = _h[k + 1][k - 1];                              r = (notlast ? _h[k + 2][k - 1] : 0.0);                              x = Math.Abs(p) + Math.Abs(q) + Math.Abs(r);                              if(x != 0.0)                              {                                  p = p / x;                                  q = q / x;                                  r = r / x;                              }                          }                            if(x == 0.0)                          {                              break;                          }                            s = Math.Sqrt((p * p) + (q * q) + (r * r));                          if(p < 0)                          {                              s = -s;                          }                            if(s != 0.0)                          {                              if(k != m)                              {                                  _h[k][k - 1] = (-s) * x;                              }                              else if(l != m)                              {                                  _h[k][k - 1] = -_h[k][k - 1];                              }                                p = p + s;                              x = p / s;                              y = q / s;                              z = r / s;                              q = q / p;                              r = r / p;                                /* Row modification */                                for(int j = k; j < nn; j++)                              {                                  p = _h[k][j] + (q * _h[k + 1][j]);                                    if(notlast)                                  {                                      p = p + (r * _h[k + 2][j]);                                      _h[k + 2][j] = _h[k + 2][j] - (p * z);                                  }                                    _h[k][j] = _h[k][j] - (p * x);                                  _h[k + 1][j] = _h[k + 1][j] - (p * y);                              }                                /* Column modification */                                for(int i = 0; i <= Math.Min(n' k + 3); i++)                              {                                  double[] hi = _h[i];                                  p = (x * hi[k]) + (y * hi[k + 1]);                                    if(notlast)                                  {                                      p = p + (z * hi[k + 2]);                                      hi[k + 2] = hi[k + 2] - (p * r);                                  }                                    hi[k] = hi[k] - p;                                  hi[k + 1] = hi[k + 1] - (p * q);                              }                                /* Accumulate transformations */                                for(int i = low; i <= high; i++)                              {                                  double[] vi = _v[i];                                  p = (x * vi[k]) + (y * vi[k + 1]);                                    if(notlast)                                  {                                      p = p + (z * vi[k + 2]);                                      vi[k + 2] = vi[k + 2] - (p * r);                                  }                                    vi[k] = vi[k] - p;                                  vi[k + 1] = vi[k + 1] - (p * q);                              }                          } // (s != 0)                      } // k loop                  } // check convergence              }
Magic Number,MathNet.Numerics.LinearAlgebra,EigenvalueDecomposition,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\LinearAlgebra\EigenvalueDecomposition.cs,NonsymmetricReduceHessenberToRealSchur,The following statement contains a magic number: while(n >= low)              {                  /* Look for single small sub-diagonal element */                    int l = n;                  while(l > low)                  {                      s = Math.Abs(_h[l - 1][l - 1]) + Math.Abs(_h[l][l]);                        if(s == 0.0)                      {                          s = norm;                      }                        if(Math.Abs(_h[l][l - 1]) < eps * s)                      {                          break;                      }                        l--;                  }                    /*                  Check for convergence                  One root found                  */                    if(l == n)                  {                      _h[n][n] = _h[n][n] + exshift;                      _d[n] = _h[n][n];                      _e[n] = 0.0;                      n--;                      iter = 0;                        // Two roots found                  }                  else if(l == n - 1)                  {                      w = _h[n][n - 1] * _h[n - 1][n];                      p = (_h[n - 1][n - 1] - _h[n][n]) / 2.0;                      q = (p * p) + w;                      z = Math.Sqrt(Math.Abs(q));                      _h[n][n] = _h[n][n] + exshift;                      _h[n - 1][n - 1] = _h[n - 1][n - 1] + exshift;                      x = _h[n][n];                        /* Real pair */                        if(q >= 0)                      {                          if(p >= 0)                          {                              z = p + z;                          }                          else                          {                              z = p - z;                          }                            _d[n - 1] = x + z;                            _d[n] = _d[n - 1];                          if(z != 0.0)                          {                              _d[n] = x - (w / z);                          }                            _e[n - 1] = 0.0;                          _e[n] = 0.0;                          x = _h[n][n - 1];                          s = Math.Abs(x) + Math.Abs(z);                          p = x / s;                          q = z / s;                          r = Math.Sqrt((p * p) + (q * q));                          p = p / r;                          q = q / r;                            /* Row modification */                            for(int j = n - 1; j < nn; j++)                          {                              z = _h[n - 1][j];                              _h[n - 1][j] = (q * z) + (p * _h[n][j]);                              _h[n][j] = (q * _h[n][j]) - (p * z);                          }                            /* Column modification */                            for(int i = 0; i <= n; i++)                          {                              z = _h[i][n - 1];                              _h[i][n - 1] = (q * z) + (p * _h[i][n]);                              _h[i][n] = (q * _h[i][n]) - (p * z);                          }                            /* Accumulate transformations */                            for(int i = low; i <= high; i++)                          {                              z = _v[i][n - 1];                              _v[i][n - 1] = (q * z) + (p * _v[i][n]);                              _v[i][n] = (q * _v[i][n]) - (p * z);                          }                            // Complex pair                      }                      else                      {                          _d[n - 1] = x + p;                          _d[n] = x + p;                          _e[n - 1] = z;                          _e[n] = -z;                      }                        n = n - 2;                      iter = 0;                        // No convergence yet                  }                  else                  {                      /* Form shift */                        x = _h[n][n];                      y = 0.0;                      w = 0.0;                      if(l < n)                      {                          y = _h[n - 1][n - 1];                          w = _h[n][n - 1] * _h[n - 1][n];                      }                        /* Wilkinson's original ad hoc shift */                        if(iter == 10)                      {                          exshift += x;                          for(int i = low; i <= n; i++)                          {                              _h[i][i] -= x;                          }                            s = Math.Abs(_h[n][n - 1]) + Math.Abs(_h[n - 1][n - 2]);                          x = y = 0.75 * s;                          w = (-0.4375) * s * s;                      }                        /* MATLAB's new ad hoc shift */                        if(iter == 30)                      {                          s = (y - x) / 2.0;                          s = (s * s) + w;                          if(s > 0)                          {                              s = Math.Sqrt(s);                              if(y < x)                              {                                  s = -s;                              }                                s = x - (w / (((y - x) / 2.0) + s));                              for(int i = low; i <= n; i++)                              {                                  _h[i][i] -= s;                              }                                exshift += s;                              x = y = w = 0.964;                          }                      }                        iter = iter + 1; // (Could check iteration count here.)                        /* Look for two consecutive small sub-diagonal elements */                        int m = n - 2;                      while(m >= l)                      {                          z = _h[m][m];                          r = x - z;                          s = y - z;                          p = (((r * s) - w) / _h[m + 1][m]) + _h[m][m + 1];                          q = _h[m + 1][m + 1] - z - r - s;                          r = _h[m + 2][m + 1];                          s = Math.Abs(p) + Math.Abs(q) + Math.Abs(r);                          p = p / s;                          q = q / s;                          r = r / s;                            if(m == l)                          {                              break;                          }                            if(Math.Abs(_h[m][m - 1]) * (Math.Abs(q) + Math.Abs(r)) < eps * (Math.Abs(p) * (Math.Abs(_h[m - 1][m - 1]) + Math.Abs(z) + Math.Abs(_h[m + 1][m + 1]))))                          {                              break;                          }                            m--;                      }                        for(int i = m + 2; i <= n; i++)                      {                          _h[i][i - 2] = 0.0;                          if(i > m + 2)                          {                              _h[i][i - 3] = 0.0;                          }                      }                        /* Double QR step involving rows l:n and columns m:n */                        for(int k = m; k <= n - 1; k++)                      {                          bool notlast = (k != n - 1);                            if(k != m)                          {                              p = _h[k][k - 1];                              q = _h[k + 1][k - 1];                              r = (notlast ? _h[k + 2][k - 1] : 0.0);                              x = Math.Abs(p) + Math.Abs(q) + Math.Abs(r);                              if(x != 0.0)                              {                                  p = p / x;                                  q = q / x;                                  r = r / x;                              }                          }                            if(x == 0.0)                          {                              break;                          }                            s = Math.Sqrt((p * p) + (q * q) + (r * r));                          if(p < 0)                          {                              s = -s;                          }                            if(s != 0.0)                          {                              if(k != m)                              {                                  _h[k][k - 1] = (-s) * x;                              }                              else if(l != m)                              {                                  _h[k][k - 1] = -_h[k][k - 1];                              }                                p = p + s;                              x = p / s;                              y = q / s;                              z = r / s;                              q = q / p;                              r = r / p;                                /* Row modification */                                for(int j = k; j < nn; j++)                              {                                  p = _h[k][j] + (q * _h[k + 1][j]);                                    if(notlast)                                  {                                      p = p + (r * _h[k + 2][j]);                                      _h[k + 2][j] = _h[k + 2][j] - (p * z);                                  }                                    _h[k][j] = _h[k][j] - (p * x);                                  _h[k + 1][j] = _h[k + 1][j] - (p * y);                              }                                /* Column modification */                                for(int i = 0; i <= Math.Min(n' k + 3); i++)                              {                                  double[] hi = _h[i];                                  p = (x * hi[k]) + (y * hi[k + 1]);                                    if(notlast)                                  {                                      p = p + (z * hi[k + 2]);                                      hi[k + 2] = hi[k + 2] - (p * r);                                  }                                    hi[k] = hi[k] - p;                                  hi[k + 1] = hi[k + 1] - (p * q);                              }                                /* Accumulate transformations */                                for(int i = low; i <= high; i++)                              {                                  double[] vi = _v[i];                                  p = (x * vi[k]) + (y * vi[k + 1]);                                    if(notlast)                                  {                                      p = p + (z * vi[k + 2]);                                      vi[k + 2] = vi[k + 2] - (p * r);                                  }                                    vi[k] = vi[k] - p;                                  vi[k + 1] = vi[k + 1] - (p * q);                              }                          } // (s != 0)                      } // k loop                  } // check convergence              }
Magic Number,MathNet.Numerics.LinearAlgebra,EigenvalueDecomposition,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\LinearAlgebra\EigenvalueDecomposition.cs,NonsymmetricReduceHessenberToRealSchur,The following statement contains a magic number: while(n >= low)              {                  /* Look for single small sub-diagonal element */                    int l = n;                  while(l > low)                  {                      s = Math.Abs(_h[l - 1][l - 1]) + Math.Abs(_h[l][l]);                        if(s == 0.0)                      {                          s = norm;                      }                        if(Math.Abs(_h[l][l - 1]) < eps * s)                      {                          break;                      }                        l--;                  }                    /*                  Check for convergence                  One root found                  */                    if(l == n)                  {                      _h[n][n] = _h[n][n] + exshift;                      _d[n] = _h[n][n];                      _e[n] = 0.0;                      n--;                      iter = 0;                        // Two roots found                  }                  else if(l == n - 1)                  {                      w = _h[n][n - 1] * _h[n - 1][n];                      p = (_h[n - 1][n - 1] - _h[n][n]) / 2.0;                      q = (p * p) + w;                      z = Math.Sqrt(Math.Abs(q));                      _h[n][n] = _h[n][n] + exshift;                      _h[n - 1][n - 1] = _h[n - 1][n - 1] + exshift;                      x = _h[n][n];                        /* Real pair */                        if(q >= 0)                      {                          if(p >= 0)                          {                              z = p + z;                          }                          else                          {                              z = p - z;                          }                            _d[n - 1] = x + z;                            _d[n] = _d[n - 1];                          if(z != 0.0)                          {                              _d[n] = x - (w / z);                          }                            _e[n - 1] = 0.0;                          _e[n] = 0.0;                          x = _h[n][n - 1];                          s = Math.Abs(x) + Math.Abs(z);                          p = x / s;                          q = z / s;                          r = Math.Sqrt((p * p) + (q * q));                          p = p / r;                          q = q / r;                            /* Row modification */                            for(int j = n - 1; j < nn; j++)                          {                              z = _h[n - 1][j];                              _h[n - 1][j] = (q * z) + (p * _h[n][j]);                              _h[n][j] = (q * _h[n][j]) - (p * z);                          }                            /* Column modification */                            for(int i = 0; i <= n; i++)                          {                              z = _h[i][n - 1];                              _h[i][n - 1] = (q * z) + (p * _h[i][n]);                              _h[i][n] = (q * _h[i][n]) - (p * z);                          }                            /* Accumulate transformations */                            for(int i = low; i <= high; i++)                          {                              z = _v[i][n - 1];                              _v[i][n - 1] = (q * z) + (p * _v[i][n]);                              _v[i][n] = (q * _v[i][n]) - (p * z);                          }                            // Complex pair                      }                      else                      {                          _d[n - 1] = x + p;                          _d[n] = x + p;                          _e[n - 1] = z;                          _e[n] = -z;                      }                        n = n - 2;                      iter = 0;                        // No convergence yet                  }                  else                  {                      /* Form shift */                        x = _h[n][n];                      y = 0.0;                      w = 0.0;                      if(l < n)                      {                          y = _h[n - 1][n - 1];                          w = _h[n][n - 1] * _h[n - 1][n];                      }                        /* Wilkinson's original ad hoc shift */                        if(iter == 10)                      {                          exshift += x;                          for(int i = low; i <= n; i++)                          {                              _h[i][i] -= x;                          }                            s = Math.Abs(_h[n][n - 1]) + Math.Abs(_h[n - 1][n - 2]);                          x = y = 0.75 * s;                          w = (-0.4375) * s * s;                      }                        /* MATLAB's new ad hoc shift */                        if(iter == 30)                      {                          s = (y - x) / 2.0;                          s = (s * s) + w;                          if(s > 0)                          {                              s = Math.Sqrt(s);                              if(y < x)                              {                                  s = -s;                              }                                s = x - (w / (((y - x) / 2.0) + s));                              for(int i = low; i <= n; i++)                              {                                  _h[i][i] -= s;                              }                                exshift += s;                              x = y = w = 0.964;                          }                      }                        iter = iter + 1; // (Could check iteration count here.)                        /* Look for two consecutive small sub-diagonal elements */                        int m = n - 2;                      while(m >= l)                      {                          z = _h[m][m];                          r = x - z;                          s = y - z;                          p = (((r * s) - w) / _h[m + 1][m]) + _h[m][m + 1];                          q = _h[m + 1][m + 1] - z - r - s;                          r = _h[m + 2][m + 1];                          s = Math.Abs(p) + Math.Abs(q) + Math.Abs(r);                          p = p / s;                          q = q / s;                          r = r / s;                            if(m == l)                          {                              break;                          }                            if(Math.Abs(_h[m][m - 1]) * (Math.Abs(q) + Math.Abs(r)) < eps * (Math.Abs(p) * (Math.Abs(_h[m - 1][m - 1]) + Math.Abs(z) + Math.Abs(_h[m + 1][m + 1]))))                          {                              break;                          }                            m--;                      }                        for(int i = m + 2; i <= n; i++)                      {                          _h[i][i - 2] = 0.0;                          if(i > m + 2)                          {                              _h[i][i - 3] = 0.0;                          }                      }                        /* Double QR step involving rows l:n and columns m:n */                        for(int k = m; k <= n - 1; k++)                      {                          bool notlast = (k != n - 1);                            if(k != m)                          {                              p = _h[k][k - 1];                              q = _h[k + 1][k - 1];                              r = (notlast ? _h[k + 2][k - 1] : 0.0);                              x = Math.Abs(p) + Math.Abs(q) + Math.Abs(r);                              if(x != 0.0)                              {                                  p = p / x;                                  q = q / x;                                  r = r / x;                              }                          }                            if(x == 0.0)                          {                              break;                          }                            s = Math.Sqrt((p * p) + (q * q) + (r * r));                          if(p < 0)                          {                              s = -s;                          }                            if(s != 0.0)                          {                              if(k != m)                              {                                  _h[k][k - 1] = (-s) * x;                              }                              else if(l != m)                              {                                  _h[k][k - 1] = -_h[k][k - 1];                              }                                p = p + s;                              x = p / s;                              y = q / s;                              z = r / s;                              q = q / p;                              r = r / p;                                /* Row modification */                                for(int j = k; j < nn; j++)                              {                                  p = _h[k][j] + (q * _h[k + 1][j]);                                    if(notlast)                                  {                                      p = p + (r * _h[k + 2][j]);                                      _h[k + 2][j] = _h[k + 2][j] - (p * z);                                  }                                    _h[k][j] = _h[k][j] - (p * x);                                  _h[k + 1][j] = _h[k + 1][j] - (p * y);                              }                                /* Column modification */                                for(int i = 0; i <= Math.Min(n' k + 3); i++)                              {                                  double[] hi = _h[i];                                  p = (x * hi[k]) + (y * hi[k + 1]);                                    if(notlast)                                  {                                      p = p + (z * hi[k + 2]);                                      hi[k + 2] = hi[k + 2] - (p * r);                                  }                                    hi[k] = hi[k] - p;                                  hi[k + 1] = hi[k + 1] - (p * q);                              }                                /* Accumulate transformations */                                for(int i = low; i <= high; i++)                              {                                  double[] vi = _v[i];                                  p = (x * vi[k]) + (y * vi[k + 1]);                                    if(notlast)                                  {                                      p = p + (z * vi[k + 2]);                                      vi[k + 2] = vi[k + 2] - (p * r);                                  }                                    vi[k] = vi[k] - p;                                  vi[k + 1] = vi[k + 1] - (p * q);                              }                          } // (s != 0)                      } // k loop                  } // check convergence              }
Magic Number,MathNet.Numerics.LinearAlgebra,EigenvalueDecomposition,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\LinearAlgebra\EigenvalueDecomposition.cs,NonsymmetricReduceHessenberToRealSchur,The following statement contains a magic number: while(n >= low)              {                  /* Look for single small sub-diagonal element */                    int l = n;                  while(l > low)                  {                      s = Math.Abs(_h[l - 1][l - 1]) + Math.Abs(_h[l][l]);                        if(s == 0.0)                      {                          s = norm;                      }                        if(Math.Abs(_h[l][l - 1]) < eps * s)                      {                          break;                      }                        l--;                  }                    /*                  Check for convergence                  One root found                  */                    if(l == n)                  {                      _h[n][n] = _h[n][n] + exshift;                      _d[n] = _h[n][n];                      _e[n] = 0.0;                      n--;                      iter = 0;                        // Two roots found                  }                  else if(l == n - 1)                  {                      w = _h[n][n - 1] * _h[n - 1][n];                      p = (_h[n - 1][n - 1] - _h[n][n]) / 2.0;                      q = (p * p) + w;                      z = Math.Sqrt(Math.Abs(q));                      _h[n][n] = _h[n][n] + exshift;                      _h[n - 1][n - 1] = _h[n - 1][n - 1] + exshift;                      x = _h[n][n];                        /* Real pair */                        if(q >= 0)                      {                          if(p >= 0)                          {                              z = p + z;                          }                          else                          {                              z = p - z;                          }                            _d[n - 1] = x + z;                            _d[n] = _d[n - 1];                          if(z != 0.0)                          {                              _d[n] = x - (w / z);                          }                            _e[n - 1] = 0.0;                          _e[n] = 0.0;                          x = _h[n][n - 1];                          s = Math.Abs(x) + Math.Abs(z);                          p = x / s;                          q = z / s;                          r = Math.Sqrt((p * p) + (q * q));                          p = p / r;                          q = q / r;                            /* Row modification */                            for(int j = n - 1; j < nn; j++)                          {                              z = _h[n - 1][j];                              _h[n - 1][j] = (q * z) + (p * _h[n][j]);                              _h[n][j] = (q * _h[n][j]) - (p * z);                          }                            /* Column modification */                            for(int i = 0; i <= n; i++)                          {                              z = _h[i][n - 1];                              _h[i][n - 1] = (q * z) + (p * _h[i][n]);                              _h[i][n] = (q * _h[i][n]) - (p * z);                          }                            /* Accumulate transformations */                            for(int i = low; i <= high; i++)                          {                              z = _v[i][n - 1];                              _v[i][n - 1] = (q * z) + (p * _v[i][n]);                              _v[i][n] = (q * _v[i][n]) - (p * z);                          }                            // Complex pair                      }                      else                      {                          _d[n - 1] = x + p;                          _d[n] = x + p;                          _e[n - 1] = z;                          _e[n] = -z;                      }                        n = n - 2;                      iter = 0;                        // No convergence yet                  }                  else                  {                      /* Form shift */                        x = _h[n][n];                      y = 0.0;                      w = 0.0;                      if(l < n)                      {                          y = _h[n - 1][n - 1];                          w = _h[n][n - 1] * _h[n - 1][n];                      }                        /* Wilkinson's original ad hoc shift */                        if(iter == 10)                      {                          exshift += x;                          for(int i = low; i <= n; i++)                          {                              _h[i][i] -= x;                          }                            s = Math.Abs(_h[n][n - 1]) + Math.Abs(_h[n - 1][n - 2]);                          x = y = 0.75 * s;                          w = (-0.4375) * s * s;                      }                        /* MATLAB's new ad hoc shift */                        if(iter == 30)                      {                          s = (y - x) / 2.0;                          s = (s * s) + w;                          if(s > 0)                          {                              s = Math.Sqrt(s);                              if(y < x)                              {                                  s = -s;                              }                                s = x - (w / (((y - x) / 2.0) + s));                              for(int i = low; i <= n; i++)                              {                                  _h[i][i] -= s;                              }                                exshift += s;                              x = y = w = 0.964;                          }                      }                        iter = iter + 1; // (Could check iteration count here.)                        /* Look for two consecutive small sub-diagonal elements */                        int m = n - 2;                      while(m >= l)                      {                          z = _h[m][m];                          r = x - z;                          s = y - z;                          p = (((r * s) - w) / _h[m + 1][m]) + _h[m][m + 1];                          q = _h[m + 1][m + 1] - z - r - s;                          r = _h[m + 2][m + 1];                          s = Math.Abs(p) + Math.Abs(q) + Math.Abs(r);                          p = p / s;                          q = q / s;                          r = r / s;                            if(m == l)                          {                              break;                          }                            if(Math.Abs(_h[m][m - 1]) * (Math.Abs(q) + Math.Abs(r)) < eps * (Math.Abs(p) * (Math.Abs(_h[m - 1][m - 1]) + Math.Abs(z) + Math.Abs(_h[m + 1][m + 1]))))                          {                              break;                          }                            m--;                      }                        for(int i = m + 2; i <= n; i++)                      {                          _h[i][i - 2] = 0.0;                          if(i > m + 2)                          {                              _h[i][i - 3] = 0.0;                          }                      }                        /* Double QR step involving rows l:n and columns m:n */                        for(int k = m; k <= n - 1; k++)                      {                          bool notlast = (k != n - 1);                            if(k != m)                          {                              p = _h[k][k - 1];                              q = _h[k + 1][k - 1];                              r = (notlast ? _h[k + 2][k - 1] : 0.0);                              x = Math.Abs(p) + Math.Abs(q) + Math.Abs(r);                              if(x != 0.0)                              {                                  p = p / x;                                  q = q / x;                                  r = r / x;                              }                          }                            if(x == 0.0)                          {                              break;                          }                            s = Math.Sqrt((p * p) + (q * q) + (r * r));                          if(p < 0)                          {                              s = -s;                          }                            if(s != 0.0)                          {                              if(k != m)                              {                                  _h[k][k - 1] = (-s) * x;                              }                              else if(l != m)                              {                                  _h[k][k - 1] = -_h[k][k - 1];                              }                                p = p + s;                              x = p / s;                              y = q / s;                              z = r / s;                              q = q / p;                              r = r / p;                                /* Row modification */                                for(int j = k; j < nn; j++)                              {                                  p = _h[k][j] + (q * _h[k + 1][j]);                                    if(notlast)                                  {                                      p = p + (r * _h[k + 2][j]);                                      _h[k + 2][j] = _h[k + 2][j] - (p * z);                                  }                                    _h[k][j] = _h[k][j] - (p * x);                                  _h[k + 1][j] = _h[k + 1][j] - (p * y);                              }                                /* Column modification */                                for(int i = 0; i <= Math.Min(n' k + 3); i++)                              {                                  double[] hi = _h[i];                                  p = (x * hi[k]) + (y * hi[k + 1]);                                    if(notlast)                                  {                                      p = p + (z * hi[k + 2]);                                      hi[k + 2] = hi[k + 2] - (p * r);                                  }                                    hi[k] = hi[k] - p;                                  hi[k + 1] = hi[k + 1] - (p * q);                              }                                /* Accumulate transformations */                                for(int i = low; i <= high; i++)                              {                                  double[] vi = _v[i];                                  p = (x * vi[k]) + (y * vi[k + 1]);                                    if(notlast)                                  {                                      p = p + (z * vi[k + 2]);                                      vi[k + 2] = vi[k + 2] - (p * r);                                  }                                    vi[k] = vi[k] - p;                                  vi[k + 1] = vi[k + 1] - (p * q);                              }                          } // (s != 0)                      } // k loop                  } // check convergence              }
Magic Number,MathNet.Numerics.LinearAlgebra,EigenvalueDecomposition,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\LinearAlgebra\EigenvalueDecomposition.cs,NonsymmetricReduceHessenberToRealSchur,The following statement contains a magic number: while(n >= low)              {                  /* Look for single small sub-diagonal element */                    int l = n;                  while(l > low)                  {                      s = Math.Abs(_h[l - 1][l - 1]) + Math.Abs(_h[l][l]);                        if(s == 0.0)                      {                          s = norm;                      }                        if(Math.Abs(_h[l][l - 1]) < eps * s)                      {                          break;                      }                        l--;                  }                    /*                  Check for convergence                  One root found                  */                    if(l == n)                  {                      _h[n][n] = _h[n][n] + exshift;                      _d[n] = _h[n][n];                      _e[n] = 0.0;                      n--;                      iter = 0;                        // Two roots found                  }                  else if(l == n - 1)                  {                      w = _h[n][n - 1] * _h[n - 1][n];                      p = (_h[n - 1][n - 1] - _h[n][n]) / 2.0;                      q = (p * p) + w;                      z = Math.Sqrt(Math.Abs(q));                      _h[n][n] = _h[n][n] + exshift;                      _h[n - 1][n - 1] = _h[n - 1][n - 1] + exshift;                      x = _h[n][n];                        /* Real pair */                        if(q >= 0)                      {                          if(p >= 0)                          {                              z = p + z;                          }                          else                          {                              z = p - z;                          }                            _d[n - 1] = x + z;                            _d[n] = _d[n - 1];                          if(z != 0.0)                          {                              _d[n] = x - (w / z);                          }                            _e[n - 1] = 0.0;                          _e[n] = 0.0;                          x = _h[n][n - 1];                          s = Math.Abs(x) + Math.Abs(z);                          p = x / s;                          q = z / s;                          r = Math.Sqrt((p * p) + (q * q));                          p = p / r;                          q = q / r;                            /* Row modification */                            for(int j = n - 1; j < nn; j++)                          {                              z = _h[n - 1][j];                              _h[n - 1][j] = (q * z) + (p * _h[n][j]);                              _h[n][j] = (q * _h[n][j]) - (p * z);                          }                            /* Column modification */                            for(int i = 0; i <= n; i++)                          {                              z = _h[i][n - 1];                              _h[i][n - 1] = (q * z) + (p * _h[i][n]);                              _h[i][n] = (q * _h[i][n]) - (p * z);                          }                            /* Accumulate transformations */                            for(int i = low; i <= high; i++)                          {                              z = _v[i][n - 1];                              _v[i][n - 1] = (q * z) + (p * _v[i][n]);                              _v[i][n] = (q * _v[i][n]) - (p * z);                          }                            // Complex pair                      }                      else                      {                          _d[n - 1] = x + p;                          _d[n] = x + p;                          _e[n - 1] = z;                          _e[n] = -z;                      }                        n = n - 2;                      iter = 0;                        // No convergence yet                  }                  else                  {                      /* Form shift */                        x = _h[n][n];                      y = 0.0;                      w = 0.0;                      if(l < n)                      {                          y = _h[n - 1][n - 1];                          w = _h[n][n - 1] * _h[n - 1][n];                      }                        /* Wilkinson's original ad hoc shift */                        if(iter == 10)                      {                          exshift += x;                          for(int i = low; i <= n; i++)                          {                              _h[i][i] -= x;                          }                            s = Math.Abs(_h[n][n - 1]) + Math.Abs(_h[n - 1][n - 2]);                          x = y = 0.75 * s;                          w = (-0.4375) * s * s;                      }                        /* MATLAB's new ad hoc shift */                        if(iter == 30)                      {                          s = (y - x) / 2.0;                          s = (s * s) + w;                          if(s > 0)                          {                              s = Math.Sqrt(s);                              if(y < x)                              {                                  s = -s;                              }                                s = x - (w / (((y - x) / 2.0) + s));                              for(int i = low; i <= n; i++)                              {                                  _h[i][i] -= s;                              }                                exshift += s;                              x = y = w = 0.964;                          }                      }                        iter = iter + 1; // (Could check iteration count here.)                        /* Look for two consecutive small sub-diagonal elements */                        int m = n - 2;                      while(m >= l)                      {                          z = _h[m][m];                          r = x - z;                          s = y - z;                          p = (((r * s) - w) / _h[m + 1][m]) + _h[m][m + 1];                          q = _h[m + 1][m + 1] - z - r - s;                          r = _h[m + 2][m + 1];                          s = Math.Abs(p) + Math.Abs(q) + Math.Abs(r);                          p = p / s;                          q = q / s;                          r = r / s;                            if(m == l)                          {                              break;                          }                            if(Math.Abs(_h[m][m - 1]) * (Math.Abs(q) + Math.Abs(r)) < eps * (Math.Abs(p) * (Math.Abs(_h[m - 1][m - 1]) + Math.Abs(z) + Math.Abs(_h[m + 1][m + 1]))))                          {                              break;                          }                            m--;                      }                        for(int i = m + 2; i <= n; i++)                      {                          _h[i][i - 2] = 0.0;                          if(i > m + 2)                          {                              _h[i][i - 3] = 0.0;                          }                      }                        /* Double QR step involving rows l:n and columns m:n */                        for(int k = m; k <= n - 1; k++)                      {                          bool notlast = (k != n - 1);                            if(k != m)                          {                              p = _h[k][k - 1];                              q = _h[k + 1][k - 1];                              r = (notlast ? _h[k + 2][k - 1] : 0.0);                              x = Math.Abs(p) + Math.Abs(q) + Math.Abs(r);                              if(x != 0.0)                              {                                  p = p / x;                                  q = q / x;                                  r = r / x;                              }                          }                            if(x == 0.0)                          {                              break;                          }                            s = Math.Sqrt((p * p) + (q * q) + (r * r));                          if(p < 0)                          {                              s = -s;                          }                            if(s != 0.0)                          {                              if(k != m)                              {                                  _h[k][k - 1] = (-s) * x;                              }                              else if(l != m)                              {                                  _h[k][k - 1] = -_h[k][k - 1];                              }                                p = p + s;                              x = p / s;                              y = q / s;                              z = r / s;                              q = q / p;                              r = r / p;                                /* Row modification */                                for(int j = k; j < nn; j++)                              {                                  p = _h[k][j] + (q * _h[k + 1][j]);                                    if(notlast)                                  {                                      p = p + (r * _h[k + 2][j]);                                      _h[k + 2][j] = _h[k + 2][j] - (p * z);                                  }                                    _h[k][j] = _h[k][j] - (p * x);                                  _h[k + 1][j] = _h[k + 1][j] - (p * y);                              }                                /* Column modification */                                for(int i = 0; i <= Math.Min(n' k + 3); i++)                              {                                  double[] hi = _h[i];                                  p = (x * hi[k]) + (y * hi[k + 1]);                                    if(notlast)                                  {                                      p = p + (z * hi[k + 2]);                                      hi[k + 2] = hi[k + 2] - (p * r);                                  }                                    hi[k] = hi[k] - p;                                  hi[k + 1] = hi[k + 1] - (p * q);                              }                                /* Accumulate transformations */                                for(int i = low; i <= high; i++)                              {                                  double[] vi = _v[i];                                  p = (x * vi[k]) + (y * vi[k + 1]);                                    if(notlast)                                  {                                      p = p + (z * vi[k + 2]);                                      vi[k + 2] = vi[k + 2] - (p * r);                                  }                                    vi[k] = vi[k] - p;                                  vi[k + 1] = vi[k + 1] - (p * q);                              }                          } // (s != 0)                      } // k loop                  } // check convergence              }
Magic Number,MathNet.Numerics.LinearAlgebra,EigenvalueDecomposition,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\LinearAlgebra\EigenvalueDecomposition.cs,NonsymmetricReduceHessenberToRealSchur,The following statement contains a magic number: while(n >= low)              {                  /* Look for single small sub-diagonal element */                    int l = n;                  while(l > low)                  {                      s = Math.Abs(_h[l - 1][l - 1]) + Math.Abs(_h[l][l]);                        if(s == 0.0)                      {                          s = norm;                      }                        if(Math.Abs(_h[l][l - 1]) < eps * s)                      {                          break;                      }                        l--;                  }                    /*                  Check for convergence                  One root found                  */                    if(l == n)                  {                      _h[n][n] = _h[n][n] + exshift;                      _d[n] = _h[n][n];                      _e[n] = 0.0;                      n--;                      iter = 0;                        // Two roots found                  }                  else if(l == n - 1)                  {                      w = _h[n][n - 1] * _h[n - 1][n];                      p = (_h[n - 1][n - 1] - _h[n][n]) / 2.0;                      q = (p * p) + w;                      z = Math.Sqrt(Math.Abs(q));                      _h[n][n] = _h[n][n] + exshift;                      _h[n - 1][n - 1] = _h[n - 1][n - 1] + exshift;                      x = _h[n][n];                        /* Real pair */                        if(q >= 0)                      {                          if(p >= 0)                          {                              z = p + z;                          }                          else                          {                              z = p - z;                          }                            _d[n - 1] = x + z;                            _d[n] = _d[n - 1];                          if(z != 0.0)                          {                              _d[n] = x - (w / z);                          }                            _e[n - 1] = 0.0;                          _e[n] = 0.0;                          x = _h[n][n - 1];                          s = Math.Abs(x) + Math.Abs(z);                          p = x / s;                          q = z / s;                          r = Math.Sqrt((p * p) + (q * q));                          p = p / r;                          q = q / r;                            /* Row modification */                            for(int j = n - 1; j < nn; j++)                          {                              z = _h[n - 1][j];                              _h[n - 1][j] = (q * z) + (p * _h[n][j]);                              _h[n][j] = (q * _h[n][j]) - (p * z);                          }                            /* Column modification */                            for(int i = 0; i <= n; i++)                          {                              z = _h[i][n - 1];                              _h[i][n - 1] = (q * z) + (p * _h[i][n]);                              _h[i][n] = (q * _h[i][n]) - (p * z);                          }                            /* Accumulate transformations */                            for(int i = low; i <= high; i++)                          {                              z = _v[i][n - 1];                              _v[i][n - 1] = (q * z) + (p * _v[i][n]);                              _v[i][n] = (q * _v[i][n]) - (p * z);                          }                            // Complex pair                      }                      else                      {                          _d[n - 1] = x + p;                          _d[n] = x + p;                          _e[n - 1] = z;                          _e[n] = -z;                      }                        n = n - 2;                      iter = 0;                        // No convergence yet                  }                  else                  {                      /* Form shift */                        x = _h[n][n];                      y = 0.0;                      w = 0.0;                      if(l < n)                      {                          y = _h[n - 1][n - 1];                          w = _h[n][n - 1] * _h[n - 1][n];                      }                        /* Wilkinson's original ad hoc shift */                        if(iter == 10)                      {                          exshift += x;                          for(int i = low; i <= n; i++)                          {                              _h[i][i] -= x;                          }                            s = Math.Abs(_h[n][n - 1]) + Math.Abs(_h[n - 1][n - 2]);                          x = y = 0.75 * s;                          w = (-0.4375) * s * s;                      }                        /* MATLAB's new ad hoc shift */                        if(iter == 30)                      {                          s = (y - x) / 2.0;                          s = (s * s) + w;                          if(s > 0)                          {                              s = Math.Sqrt(s);                              if(y < x)                              {                                  s = -s;                              }                                s = x - (w / (((y - x) / 2.0) + s));                              for(int i = low; i <= n; i++)                              {                                  _h[i][i] -= s;                              }                                exshift += s;                              x = y = w = 0.964;                          }                      }                        iter = iter + 1; // (Could check iteration count here.)                        /* Look for two consecutive small sub-diagonal elements */                        int m = n - 2;                      while(m >= l)                      {                          z = _h[m][m];                          r = x - z;                          s = y - z;                          p = (((r * s) - w) / _h[m + 1][m]) + _h[m][m + 1];                          q = _h[m + 1][m + 1] - z - r - s;                          r = _h[m + 2][m + 1];                          s = Math.Abs(p) + Math.Abs(q) + Math.Abs(r);                          p = p / s;                          q = q / s;                          r = r / s;                            if(m == l)                          {                              break;                          }                            if(Math.Abs(_h[m][m - 1]) * (Math.Abs(q) + Math.Abs(r)) < eps * (Math.Abs(p) * (Math.Abs(_h[m - 1][m - 1]) + Math.Abs(z) + Math.Abs(_h[m + 1][m + 1]))))                          {                              break;                          }                            m--;                      }                        for(int i = m + 2; i <= n; i++)                      {                          _h[i][i - 2] = 0.0;                          if(i > m + 2)                          {                              _h[i][i - 3] = 0.0;                          }                      }                        /* Double QR step involving rows l:n and columns m:n */                        for(int k = m; k <= n - 1; k++)                      {                          bool notlast = (k != n - 1);                            if(k != m)                          {                              p = _h[k][k - 1];                              q = _h[k + 1][k - 1];                              r = (notlast ? _h[k + 2][k - 1] : 0.0);                              x = Math.Abs(p) + Math.Abs(q) + Math.Abs(r);                              if(x != 0.0)                              {                                  p = p / x;                                  q = q / x;                                  r = r / x;                              }                          }                            if(x == 0.0)                          {                              break;                          }                            s = Math.Sqrt((p * p) + (q * q) + (r * r));                          if(p < 0)                          {                              s = -s;                          }                            if(s != 0.0)                          {                              if(k != m)                              {                                  _h[k][k - 1] = (-s) * x;                              }                              else if(l != m)                              {                                  _h[k][k - 1] = -_h[k][k - 1];                              }                                p = p + s;                              x = p / s;                              y = q / s;                              z = r / s;                              q = q / p;                              r = r / p;                                /* Row modification */                                for(int j = k; j < nn; j++)                              {                                  p = _h[k][j] + (q * _h[k + 1][j]);                                    if(notlast)                                  {                                      p = p + (r * _h[k + 2][j]);                                      _h[k + 2][j] = _h[k + 2][j] - (p * z);                                  }                                    _h[k][j] = _h[k][j] - (p * x);                                  _h[k + 1][j] = _h[k + 1][j] - (p * y);                              }                                /* Column modification */                                for(int i = 0; i <= Math.Min(n' k + 3); i++)                              {                                  double[] hi = _h[i];                                  p = (x * hi[k]) + (y * hi[k + 1]);                                    if(notlast)                                  {                                      p = p + (z * hi[k + 2]);                                      hi[k + 2] = hi[k + 2] - (p * r);                                  }                                    hi[k] = hi[k] - p;                                  hi[k + 1] = hi[k + 1] - (p * q);                              }                                /* Accumulate transformations */                                for(int i = low; i <= high; i++)                              {                                  double[] vi = _v[i];                                  p = (x * vi[k]) + (y * vi[k + 1]);                                    if(notlast)                                  {                                      p = p + (z * vi[k + 2]);                                      vi[k + 2] = vi[k + 2] - (p * r);                                  }                                    vi[k] = vi[k] - p;                                  vi[k + 1] = vi[k + 1] - (p * q);                              }                          } // (s != 0)                      } // k loop                  } // check convergence              }
Magic Number,MathNet.Numerics.LinearAlgebra,EigenvalueDecomposition,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\LinearAlgebra\EigenvalueDecomposition.cs,NonsymmetricReduceHessenberToRealSchur,The following statement contains a magic number: while(n >= low)              {                  /* Look for single small sub-diagonal element */                    int l = n;                  while(l > low)                  {                      s = Math.Abs(_h[l - 1][l - 1]) + Math.Abs(_h[l][l]);                        if(s == 0.0)                      {                          s = norm;                      }                        if(Math.Abs(_h[l][l - 1]) < eps * s)                      {                          break;                      }                        l--;                  }                    /*                  Check for convergence                  One root found                  */                    if(l == n)                  {                      _h[n][n] = _h[n][n] + exshift;                      _d[n] = _h[n][n];                      _e[n] = 0.0;                      n--;                      iter = 0;                        // Two roots found                  }                  else if(l == n - 1)                  {                      w = _h[n][n - 1] * _h[n - 1][n];                      p = (_h[n - 1][n - 1] - _h[n][n]) / 2.0;                      q = (p * p) + w;                      z = Math.Sqrt(Math.Abs(q));                      _h[n][n] = _h[n][n] + exshift;                      _h[n - 1][n - 1] = _h[n - 1][n - 1] + exshift;                      x = _h[n][n];                        /* Real pair */                        if(q >= 0)                      {                          if(p >= 0)                          {                              z = p + z;                          }                          else                          {                              z = p - z;                          }                            _d[n - 1] = x + z;                            _d[n] = _d[n - 1];                          if(z != 0.0)                          {                              _d[n] = x - (w / z);                          }                            _e[n - 1] = 0.0;                          _e[n] = 0.0;                          x = _h[n][n - 1];                          s = Math.Abs(x) + Math.Abs(z);                          p = x / s;                          q = z / s;                          r = Math.Sqrt((p * p) + (q * q));                          p = p / r;                          q = q / r;                            /* Row modification */                            for(int j = n - 1; j < nn; j++)                          {                              z = _h[n - 1][j];                              _h[n - 1][j] = (q * z) + (p * _h[n][j]);                              _h[n][j] = (q * _h[n][j]) - (p * z);                          }                            /* Column modification */                            for(int i = 0; i <= n; i++)                          {                              z = _h[i][n - 1];                              _h[i][n - 1] = (q * z) + (p * _h[i][n]);                              _h[i][n] = (q * _h[i][n]) - (p * z);                          }                            /* Accumulate transformations */                            for(int i = low; i <= high; i++)                          {                              z = _v[i][n - 1];                              _v[i][n - 1] = (q * z) + (p * _v[i][n]);                              _v[i][n] = (q * _v[i][n]) - (p * z);                          }                            // Complex pair                      }                      else                      {                          _d[n - 1] = x + p;                          _d[n] = x + p;                          _e[n - 1] = z;                          _e[n] = -z;                      }                        n = n - 2;                      iter = 0;                        // No convergence yet                  }                  else                  {                      /* Form shift */                        x = _h[n][n];                      y = 0.0;                      w = 0.0;                      if(l < n)                      {                          y = _h[n - 1][n - 1];                          w = _h[n][n - 1] * _h[n - 1][n];                      }                        /* Wilkinson's original ad hoc shift */                        if(iter == 10)                      {                          exshift += x;                          for(int i = low; i <= n; i++)                          {                              _h[i][i] -= x;                          }                            s = Math.Abs(_h[n][n - 1]) + Math.Abs(_h[n - 1][n - 2]);                          x = y = 0.75 * s;                          w = (-0.4375) * s * s;                      }                        /* MATLAB's new ad hoc shift */                        if(iter == 30)                      {                          s = (y - x) / 2.0;                          s = (s * s) + w;                          if(s > 0)                          {                              s = Math.Sqrt(s);                              if(y < x)                              {                                  s = -s;                              }                                s = x - (w / (((y - x) / 2.0) + s));                              for(int i = low; i <= n; i++)                              {                                  _h[i][i] -= s;                              }                                exshift += s;                              x = y = w = 0.964;                          }                      }                        iter = iter + 1; // (Could check iteration count here.)                        /* Look for two consecutive small sub-diagonal elements */                        int m = n - 2;                      while(m >= l)                      {                          z = _h[m][m];                          r = x - z;                          s = y - z;                          p = (((r * s) - w) / _h[m + 1][m]) + _h[m][m + 1];                          q = _h[m + 1][m + 1] - z - r - s;                          r = _h[m + 2][m + 1];                          s = Math.Abs(p) + Math.Abs(q) + Math.Abs(r);                          p = p / s;                          q = q / s;                          r = r / s;                            if(m == l)                          {                              break;                          }                            if(Math.Abs(_h[m][m - 1]) * (Math.Abs(q) + Math.Abs(r)) < eps * (Math.Abs(p) * (Math.Abs(_h[m - 1][m - 1]) + Math.Abs(z) + Math.Abs(_h[m + 1][m + 1]))))                          {                              break;                          }                            m--;                      }                        for(int i = m + 2; i <= n; i++)                      {                          _h[i][i - 2] = 0.0;                          if(i > m + 2)                          {                              _h[i][i - 3] = 0.0;                          }                      }                        /* Double QR step involving rows l:n and columns m:n */                        for(int k = m; k <= n - 1; k++)                      {                          bool notlast = (k != n - 1);                            if(k != m)                          {                              p = _h[k][k - 1];                              q = _h[k + 1][k - 1];                              r = (notlast ? _h[k + 2][k - 1] : 0.0);                              x = Math.Abs(p) + Math.Abs(q) + Math.Abs(r);                              if(x != 0.0)                              {                                  p = p / x;                                  q = q / x;                                  r = r / x;                              }                          }                            if(x == 0.0)                          {                              break;                          }                            s = Math.Sqrt((p * p) + (q * q) + (r * r));                          if(p < 0)                          {                              s = -s;                          }                            if(s != 0.0)                          {                              if(k != m)                              {                                  _h[k][k - 1] = (-s) * x;                              }                              else if(l != m)                              {                                  _h[k][k - 1] = -_h[k][k - 1];                              }                                p = p + s;                              x = p / s;                              y = q / s;                              z = r / s;                              q = q / p;                              r = r / p;                                /* Row modification */                                for(int j = k; j < nn; j++)                              {                                  p = _h[k][j] + (q * _h[k + 1][j]);                                    if(notlast)                                  {                                      p = p + (r * _h[k + 2][j]);                                      _h[k + 2][j] = _h[k + 2][j] - (p * z);                                  }                                    _h[k][j] = _h[k][j] - (p * x);                                  _h[k + 1][j] = _h[k + 1][j] - (p * y);                              }                                /* Column modification */                                for(int i = 0; i <= Math.Min(n' k + 3); i++)                              {                                  double[] hi = _h[i];                                  p = (x * hi[k]) + (y * hi[k + 1]);                                    if(notlast)                                  {                                      p = p + (z * hi[k + 2]);                                      hi[k + 2] = hi[k + 2] - (p * r);                                  }                                    hi[k] = hi[k] - p;                                  hi[k + 1] = hi[k + 1] - (p * q);                              }                                /* Accumulate transformations */                                for(int i = low; i <= high; i++)                              {                                  double[] vi = _v[i];                                  p = (x * vi[k]) + (y * vi[k + 1]);                                    if(notlast)                                  {                                      p = p + (z * vi[k + 2]);                                      vi[k + 2] = vi[k + 2] - (p * r);                                  }                                    vi[k] = vi[k] - p;                                  vi[k + 1] = vi[k + 1] - (p * q);                              }                          } // (s != 0)                      } // k loop                  } // check convergence              }
Magic Number,MathNet.Numerics.LinearAlgebra,EigenvalueDecomposition,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\LinearAlgebra\EigenvalueDecomposition.cs,NonsymmetricReduceHessenberToRealSchur,The following statement contains a magic number: while(n >= low)              {                  /* Look for single small sub-diagonal element */                    int l = n;                  while(l > low)                  {                      s = Math.Abs(_h[l - 1][l - 1]) + Math.Abs(_h[l][l]);                        if(s == 0.0)                      {                          s = norm;                      }                        if(Math.Abs(_h[l][l - 1]) < eps * s)                      {                          break;                      }                        l--;                  }                    /*                  Check for convergence                  One root found                  */                    if(l == n)                  {                      _h[n][n] = _h[n][n] + exshift;                      _d[n] = _h[n][n];                      _e[n] = 0.0;                      n--;                      iter = 0;                        // Two roots found                  }                  else if(l == n - 1)                  {                      w = _h[n][n - 1] * _h[n - 1][n];                      p = (_h[n - 1][n - 1] - _h[n][n]) / 2.0;                      q = (p * p) + w;                      z = Math.Sqrt(Math.Abs(q));                      _h[n][n] = _h[n][n] + exshift;                      _h[n - 1][n - 1] = _h[n - 1][n - 1] + exshift;                      x = _h[n][n];                        /* Real pair */                        if(q >= 0)                      {                          if(p >= 0)                          {                              z = p + z;                          }                          else                          {                              z = p - z;                          }                            _d[n - 1] = x + z;                            _d[n] = _d[n - 1];                          if(z != 0.0)                          {                              _d[n] = x - (w / z);                          }                            _e[n - 1] = 0.0;                          _e[n] = 0.0;                          x = _h[n][n - 1];                          s = Math.Abs(x) + Math.Abs(z);                          p = x / s;                          q = z / s;                          r = Math.Sqrt((p * p) + (q * q));                          p = p / r;                          q = q / r;                            /* Row modification */                            for(int j = n - 1; j < nn; j++)                          {                              z = _h[n - 1][j];                              _h[n - 1][j] = (q * z) + (p * _h[n][j]);                              _h[n][j] = (q * _h[n][j]) - (p * z);                          }                            /* Column modification */                            for(int i = 0; i <= n; i++)                          {                              z = _h[i][n - 1];                              _h[i][n - 1] = (q * z) + (p * _h[i][n]);                              _h[i][n] = (q * _h[i][n]) - (p * z);                          }                            /* Accumulate transformations */                            for(int i = low; i <= high; i++)                          {                              z = _v[i][n - 1];                              _v[i][n - 1] = (q * z) + (p * _v[i][n]);                              _v[i][n] = (q * _v[i][n]) - (p * z);                          }                            // Complex pair                      }                      else                      {                          _d[n - 1] = x + p;                          _d[n] = x + p;                          _e[n - 1] = z;                          _e[n] = -z;                      }                        n = n - 2;                      iter = 0;                        // No convergence yet                  }                  else                  {                      /* Form shift */                        x = _h[n][n];                      y = 0.0;                      w = 0.0;                      if(l < n)                      {                          y = _h[n - 1][n - 1];                          w = _h[n][n - 1] * _h[n - 1][n];                      }                        /* Wilkinson's original ad hoc shift */                        if(iter == 10)                      {                          exshift += x;                          for(int i = low; i <= n; i++)                          {                              _h[i][i] -= x;                          }                            s = Math.Abs(_h[n][n - 1]) + Math.Abs(_h[n - 1][n - 2]);                          x = y = 0.75 * s;                          w = (-0.4375) * s * s;                      }                        /* MATLAB's new ad hoc shift */                        if(iter == 30)                      {                          s = (y - x) / 2.0;                          s = (s * s) + w;                          if(s > 0)                          {                              s = Math.Sqrt(s);                              if(y < x)                              {                                  s = -s;                              }                                s = x - (w / (((y - x) / 2.0) + s));                              for(int i = low; i <= n; i++)                              {                                  _h[i][i] -= s;                              }                                exshift += s;                              x = y = w = 0.964;                          }                      }                        iter = iter + 1; // (Could check iteration count here.)                        /* Look for two consecutive small sub-diagonal elements */                        int m = n - 2;                      while(m >= l)                      {                          z = _h[m][m];                          r = x - z;                          s = y - z;                          p = (((r * s) - w) / _h[m + 1][m]) + _h[m][m + 1];                          q = _h[m + 1][m + 1] - z - r - s;                          r = _h[m + 2][m + 1];                          s = Math.Abs(p) + Math.Abs(q) + Math.Abs(r);                          p = p / s;                          q = q / s;                          r = r / s;                            if(m == l)                          {                              break;                          }                            if(Math.Abs(_h[m][m - 1]) * (Math.Abs(q) + Math.Abs(r)) < eps * (Math.Abs(p) * (Math.Abs(_h[m - 1][m - 1]) + Math.Abs(z) + Math.Abs(_h[m + 1][m + 1]))))                          {                              break;                          }                            m--;                      }                        for(int i = m + 2; i <= n; i++)                      {                          _h[i][i - 2] = 0.0;                          if(i > m + 2)                          {                              _h[i][i - 3] = 0.0;                          }                      }                        /* Double QR step involving rows l:n and columns m:n */                        for(int k = m; k <= n - 1; k++)                      {                          bool notlast = (k != n - 1);                            if(k != m)                          {                              p = _h[k][k - 1];                              q = _h[k + 1][k - 1];                              r = (notlast ? _h[k + 2][k - 1] : 0.0);                              x = Math.Abs(p) + Math.Abs(q) + Math.Abs(r);                              if(x != 0.0)                              {                                  p = p / x;                                  q = q / x;                                  r = r / x;                              }                          }                            if(x == 0.0)                          {                              break;                          }                            s = Math.Sqrt((p * p) + (q * q) + (r * r));                          if(p < 0)                          {                              s = -s;                          }                            if(s != 0.0)                          {                              if(k != m)                              {                                  _h[k][k - 1] = (-s) * x;                              }                              else if(l != m)                              {                                  _h[k][k - 1] = -_h[k][k - 1];                              }                                p = p + s;                              x = p / s;                              y = q / s;                              z = r / s;                              q = q / p;                              r = r / p;                                /* Row modification */                                for(int j = k; j < nn; j++)                              {                                  p = _h[k][j] + (q * _h[k + 1][j]);                                    if(notlast)                                  {                                      p = p + (r * _h[k + 2][j]);                                      _h[k + 2][j] = _h[k + 2][j] - (p * z);                                  }                                    _h[k][j] = _h[k][j] - (p * x);                                  _h[k + 1][j] = _h[k + 1][j] - (p * y);                              }                                /* Column modification */                                for(int i = 0; i <= Math.Min(n' k + 3); i++)                              {                                  double[] hi = _h[i];                                  p = (x * hi[k]) + (y * hi[k + 1]);                                    if(notlast)                                  {                                      p = p + (z * hi[k + 2]);                                      hi[k + 2] = hi[k + 2] - (p * r);                                  }                                    hi[k] = hi[k] - p;                                  hi[k + 1] = hi[k + 1] - (p * q);                              }                                /* Accumulate transformations */                                for(int i = low; i <= high; i++)                              {                                  double[] vi = _v[i];                                  p = (x * vi[k]) + (y * vi[k + 1]);                                    if(notlast)                                  {                                      p = p + (z * vi[k + 2]);                                      vi[k + 2] = vi[k + 2] - (p * r);                                  }                                    vi[k] = vi[k] - p;                                  vi[k + 1] = vi[k + 1] - (p * q);                              }                          } // (s != 0)                      } // k loop                  } // check convergence              }
Magic Number,MathNet.Numerics.LinearAlgebra,EigenvalueDecomposition,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\LinearAlgebra\EigenvalueDecomposition.cs,NonsymmetricReduceHessenberToRealSchur,The following statement contains a magic number: while(n >= low)              {                  /* Look for single small sub-diagonal element */                    int l = n;                  while(l > low)                  {                      s = Math.Abs(_h[l - 1][l - 1]) + Math.Abs(_h[l][l]);                        if(s == 0.0)                      {                          s = norm;                      }                        if(Math.Abs(_h[l][l - 1]) < eps * s)                      {                          break;                      }                        l--;                  }                    /*                  Check for convergence                  One root found                  */                    if(l == n)                  {                      _h[n][n] = _h[n][n] + exshift;                      _d[n] = _h[n][n];                      _e[n] = 0.0;                      n--;                      iter = 0;                        // Two roots found                  }                  else if(l == n - 1)                  {                      w = _h[n][n - 1] * _h[n - 1][n];                      p = (_h[n - 1][n - 1] - _h[n][n]) / 2.0;                      q = (p * p) + w;                      z = Math.Sqrt(Math.Abs(q));                      _h[n][n] = _h[n][n] + exshift;                      _h[n - 1][n - 1] = _h[n - 1][n - 1] + exshift;                      x = _h[n][n];                        /* Real pair */                        if(q >= 0)                      {                          if(p >= 0)                          {                              z = p + z;                          }                          else                          {                              z = p - z;                          }                            _d[n - 1] = x + z;                            _d[n] = _d[n - 1];                          if(z != 0.0)                          {                              _d[n] = x - (w / z);                          }                            _e[n - 1] = 0.0;                          _e[n] = 0.0;                          x = _h[n][n - 1];                          s = Math.Abs(x) + Math.Abs(z);                          p = x / s;                          q = z / s;                          r = Math.Sqrt((p * p) + (q * q));                          p = p / r;                          q = q / r;                            /* Row modification */                            for(int j = n - 1; j < nn; j++)                          {                              z = _h[n - 1][j];                              _h[n - 1][j] = (q * z) + (p * _h[n][j]);                              _h[n][j] = (q * _h[n][j]) - (p * z);                          }                            /* Column modification */                            for(int i = 0; i <= n; i++)                          {                              z = _h[i][n - 1];                              _h[i][n - 1] = (q * z) + (p * _h[i][n]);                              _h[i][n] = (q * _h[i][n]) - (p * z);                          }                            /* Accumulate transformations */                            for(int i = low; i <= high; i++)                          {                              z = _v[i][n - 1];                              _v[i][n - 1] = (q * z) + (p * _v[i][n]);                              _v[i][n] = (q * _v[i][n]) - (p * z);                          }                            // Complex pair                      }                      else                      {                          _d[n - 1] = x + p;                          _d[n] = x + p;                          _e[n - 1] = z;                          _e[n] = -z;                      }                        n = n - 2;                      iter = 0;                        // No convergence yet                  }                  else                  {                      /* Form shift */                        x = _h[n][n];                      y = 0.0;                      w = 0.0;                      if(l < n)                      {                          y = _h[n - 1][n - 1];                          w = _h[n][n - 1] * _h[n - 1][n];                      }                        /* Wilkinson's original ad hoc shift */                        if(iter == 10)                      {                          exshift += x;                          for(int i = low; i <= n; i++)                          {                              _h[i][i] -= x;                          }                            s = Math.Abs(_h[n][n - 1]) + Math.Abs(_h[n - 1][n - 2]);                          x = y = 0.75 * s;                          w = (-0.4375) * s * s;                      }                        /* MATLAB's new ad hoc shift */                        if(iter == 30)                      {                          s = (y - x) / 2.0;                          s = (s * s) + w;                          if(s > 0)                          {                              s = Math.Sqrt(s);                              if(y < x)                              {                                  s = -s;                              }                                s = x - (w / (((y - x) / 2.0) + s));                              for(int i = low; i <= n; i++)                              {                                  _h[i][i] -= s;                              }                                exshift += s;                              x = y = w = 0.964;                          }                      }                        iter = iter + 1; // (Could check iteration count here.)                        /* Look for two consecutive small sub-diagonal elements */                        int m = n - 2;                      while(m >= l)                      {                          z = _h[m][m];                          r = x - z;                          s = y - z;                          p = (((r * s) - w) / _h[m + 1][m]) + _h[m][m + 1];                          q = _h[m + 1][m + 1] - z - r - s;                          r = _h[m + 2][m + 1];                          s = Math.Abs(p) + Math.Abs(q) + Math.Abs(r);                          p = p / s;                          q = q / s;                          r = r / s;                            if(m == l)                          {                              break;                          }                            if(Math.Abs(_h[m][m - 1]) * (Math.Abs(q) + Math.Abs(r)) < eps * (Math.Abs(p) * (Math.Abs(_h[m - 1][m - 1]) + Math.Abs(z) + Math.Abs(_h[m + 1][m + 1]))))                          {                              break;                          }                            m--;                      }                        for(int i = m + 2; i <= n; i++)                      {                          _h[i][i - 2] = 0.0;                          if(i > m + 2)                          {                              _h[i][i - 3] = 0.0;                          }                      }                        /* Double QR step involving rows l:n and columns m:n */                        for(int k = m; k <= n - 1; k++)                      {                          bool notlast = (k != n - 1);                            if(k != m)                          {                              p = _h[k][k - 1];                              q = _h[k + 1][k - 1];                              r = (notlast ? _h[k + 2][k - 1] : 0.0);                              x = Math.Abs(p) + Math.Abs(q) + Math.Abs(r);                              if(x != 0.0)                              {                                  p = p / x;                                  q = q / x;                                  r = r / x;                              }                          }                            if(x == 0.0)                          {                              break;                          }                            s = Math.Sqrt((p * p) + (q * q) + (r * r));                          if(p < 0)                          {                              s = -s;                          }                            if(s != 0.0)                          {                              if(k != m)                              {                                  _h[k][k - 1] = (-s) * x;                              }                              else if(l != m)                              {                                  _h[k][k - 1] = -_h[k][k - 1];                              }                                p = p + s;                              x = p / s;                              y = q / s;                              z = r / s;                              q = q / p;                              r = r / p;                                /* Row modification */                                for(int j = k; j < nn; j++)                              {                                  p = _h[k][j] + (q * _h[k + 1][j]);                                    if(notlast)                                  {                                      p = p + (r * _h[k + 2][j]);                                      _h[k + 2][j] = _h[k + 2][j] - (p * z);                                  }                                    _h[k][j] = _h[k][j] - (p * x);                                  _h[k + 1][j] = _h[k + 1][j] - (p * y);                              }                                /* Column modification */                                for(int i = 0; i <= Math.Min(n' k + 3); i++)                              {                                  double[] hi = _h[i];                                  p = (x * hi[k]) + (y * hi[k + 1]);                                    if(notlast)                                  {                                      p = p + (z * hi[k + 2]);                                      hi[k + 2] = hi[k + 2] - (p * r);                                  }                                    hi[k] = hi[k] - p;                                  hi[k + 1] = hi[k + 1] - (p * q);                              }                                /* Accumulate transformations */                                for(int i = low; i <= high; i++)                              {                                  double[] vi = _v[i];                                  p = (x * vi[k]) + (y * vi[k + 1]);                                    if(notlast)                                  {                                      p = p + (z * vi[k + 2]);                                      vi[k + 2] = vi[k + 2] - (p * r);                                  }                                    vi[k] = vi[k] - p;                                  vi[k + 1] = vi[k + 1] - (p * q);                              }                          } // (s != 0)                      } // k loop                  } // check convergence              }
Magic Number,MathNet.Numerics.LinearAlgebra,EigenvalueDecomposition,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\LinearAlgebra\EigenvalueDecomposition.cs,NonsymmetricReduceHessenberToRealSchur,The following statement contains a magic number: while(n >= low)              {                  /* Look for single small sub-diagonal element */                    int l = n;                  while(l > low)                  {                      s = Math.Abs(_h[l - 1][l - 1]) + Math.Abs(_h[l][l]);                        if(s == 0.0)                      {                          s = norm;                      }                        if(Math.Abs(_h[l][l - 1]) < eps * s)                      {                          break;                      }                        l--;                  }                    /*                  Check for convergence                  One root found                  */                    if(l == n)                  {                      _h[n][n] = _h[n][n] + exshift;                      _d[n] = _h[n][n];                      _e[n] = 0.0;                      n--;                      iter = 0;                        // Two roots found                  }                  else if(l == n - 1)                  {                      w = _h[n][n - 1] * _h[n - 1][n];                      p = (_h[n - 1][n - 1] - _h[n][n]) / 2.0;                      q = (p * p) + w;                      z = Math.Sqrt(Math.Abs(q));                      _h[n][n] = _h[n][n] + exshift;                      _h[n - 1][n - 1] = _h[n - 1][n - 1] + exshift;                      x = _h[n][n];                        /* Real pair */                        if(q >= 0)                      {                          if(p >= 0)                          {                              z = p + z;                          }                          else                          {                              z = p - z;                          }                            _d[n - 1] = x + z;                            _d[n] = _d[n - 1];                          if(z != 0.0)                          {                              _d[n] = x - (w / z);                          }                            _e[n - 1] = 0.0;                          _e[n] = 0.0;                          x = _h[n][n - 1];                          s = Math.Abs(x) + Math.Abs(z);                          p = x / s;                          q = z / s;                          r = Math.Sqrt((p * p) + (q * q));                          p = p / r;                          q = q / r;                            /* Row modification */                            for(int j = n - 1; j < nn; j++)                          {                              z = _h[n - 1][j];                              _h[n - 1][j] = (q * z) + (p * _h[n][j]);                              _h[n][j] = (q * _h[n][j]) - (p * z);                          }                            /* Column modification */                            for(int i = 0; i <= n; i++)                          {                              z = _h[i][n - 1];                              _h[i][n - 1] = (q * z) + (p * _h[i][n]);                              _h[i][n] = (q * _h[i][n]) - (p * z);                          }                            /* Accumulate transformations */                            for(int i = low; i <= high; i++)                          {                              z = _v[i][n - 1];                              _v[i][n - 1] = (q * z) + (p * _v[i][n]);                              _v[i][n] = (q * _v[i][n]) - (p * z);                          }                            // Complex pair                      }                      else                      {                          _d[n - 1] = x + p;                          _d[n] = x + p;                          _e[n - 1] = z;                          _e[n] = -z;                      }                        n = n - 2;                      iter = 0;                        // No convergence yet                  }                  else                  {                      /* Form shift */                        x = _h[n][n];                      y = 0.0;                      w = 0.0;                      if(l < n)                      {                          y = _h[n - 1][n - 1];                          w = _h[n][n - 1] * _h[n - 1][n];                      }                        /* Wilkinson's original ad hoc shift */                        if(iter == 10)                      {                          exshift += x;                          for(int i = low; i <= n; i++)                          {                              _h[i][i] -= x;                          }                            s = Math.Abs(_h[n][n - 1]) + Math.Abs(_h[n - 1][n - 2]);                          x = y = 0.75 * s;                          w = (-0.4375) * s * s;                      }                        /* MATLAB's new ad hoc shift */                        if(iter == 30)                      {                          s = (y - x) / 2.0;                          s = (s * s) + w;                          if(s > 0)                          {                              s = Math.Sqrt(s);                              if(y < x)                              {                                  s = -s;                              }                                s = x - (w / (((y - x) / 2.0) + s));                              for(int i = low; i <= n; i++)                              {                                  _h[i][i] -= s;                              }                                exshift += s;                              x = y = w = 0.964;                          }                      }                        iter = iter + 1; // (Could check iteration count here.)                        /* Look for two consecutive small sub-diagonal elements */                        int m = n - 2;                      while(m >= l)                      {                          z = _h[m][m];                          r = x - z;                          s = y - z;                          p = (((r * s) - w) / _h[m + 1][m]) + _h[m][m + 1];                          q = _h[m + 1][m + 1] - z - r - s;                          r = _h[m + 2][m + 1];                          s = Math.Abs(p) + Math.Abs(q) + Math.Abs(r);                          p = p / s;                          q = q / s;                          r = r / s;                            if(m == l)                          {                              break;                          }                            if(Math.Abs(_h[m][m - 1]) * (Math.Abs(q) + Math.Abs(r)) < eps * (Math.Abs(p) * (Math.Abs(_h[m - 1][m - 1]) + Math.Abs(z) + Math.Abs(_h[m + 1][m + 1]))))                          {                              break;                          }                            m--;                      }                        for(int i = m + 2; i <= n; i++)                      {                          _h[i][i - 2] = 0.0;                          if(i > m + 2)                          {                              _h[i][i - 3] = 0.0;                          }                      }                        /* Double QR step involving rows l:n and columns m:n */                        for(int k = m; k <= n - 1; k++)                      {                          bool notlast = (k != n - 1);                            if(k != m)                          {                              p = _h[k][k - 1];                              q = _h[k + 1][k - 1];                              r = (notlast ? _h[k + 2][k - 1] : 0.0);                              x = Math.Abs(p) + Math.Abs(q) + Math.Abs(r);                              if(x != 0.0)                              {                                  p = p / x;                                  q = q / x;                                  r = r / x;                              }                          }                            if(x == 0.0)                          {                              break;                          }                            s = Math.Sqrt((p * p) + (q * q) + (r * r));                          if(p < 0)                          {                              s = -s;                          }                            if(s != 0.0)                          {                              if(k != m)                              {                                  _h[k][k - 1] = (-s) * x;                              }                              else if(l != m)                              {                                  _h[k][k - 1] = -_h[k][k - 1];                              }                                p = p + s;                              x = p / s;                              y = q / s;                              z = r / s;                              q = q / p;                              r = r / p;                                /* Row modification */                                for(int j = k; j < nn; j++)                              {                                  p = _h[k][j] + (q * _h[k + 1][j]);                                    if(notlast)                                  {                                      p = p + (r * _h[k + 2][j]);                                      _h[k + 2][j] = _h[k + 2][j] - (p * z);                                  }                                    _h[k][j] = _h[k][j] - (p * x);                                  _h[k + 1][j] = _h[k + 1][j] - (p * y);                              }                                /* Column modification */                                for(int i = 0; i <= Math.Min(n' k + 3); i++)                              {                                  double[] hi = _h[i];                                  p = (x * hi[k]) + (y * hi[k + 1]);                                    if(notlast)                                  {                                      p = p + (z * hi[k + 2]);                                      hi[k + 2] = hi[k + 2] - (p * r);                                  }                                    hi[k] = hi[k] - p;                                  hi[k + 1] = hi[k + 1] - (p * q);                              }                                /* Accumulate transformations */                                for(int i = low; i <= high; i++)                              {                                  double[] vi = _v[i];                                  p = (x * vi[k]) + (y * vi[k + 1]);                                    if(notlast)                                  {                                      p = p + (z * vi[k + 2]);                                      vi[k + 2] = vi[k + 2] - (p * r);                                  }                                    vi[k] = vi[k] - p;                                  vi[k + 1] = vi[k + 1] - (p * q);                              }                          } // (s != 0)                      } // k loop                  } // check convergence              }
Magic Number,MathNet.Numerics.LinearAlgebra,EigenvalueDecomposition,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\LinearAlgebra\EigenvalueDecomposition.cs,NonsymmetricReduceHessenberToRealSchur,The following statement contains a magic number: while(n >= low)              {                  /* Look for single small sub-diagonal element */                    int l = n;                  while(l > low)                  {                      s = Math.Abs(_h[l - 1][l - 1]) + Math.Abs(_h[l][l]);                        if(s == 0.0)                      {                          s = norm;                      }                        if(Math.Abs(_h[l][l - 1]) < eps * s)                      {                          break;                      }                        l--;                  }                    /*                  Check for convergence                  One root found                  */                    if(l == n)                  {                      _h[n][n] = _h[n][n] + exshift;                      _d[n] = _h[n][n];                      _e[n] = 0.0;                      n--;                      iter = 0;                        // Two roots found                  }                  else if(l == n - 1)                  {                      w = _h[n][n - 1] * _h[n - 1][n];                      p = (_h[n - 1][n - 1] - _h[n][n]) / 2.0;                      q = (p * p) + w;                      z = Math.Sqrt(Math.Abs(q));                      _h[n][n] = _h[n][n] + exshift;                      _h[n - 1][n - 1] = _h[n - 1][n - 1] + exshift;                      x = _h[n][n];                        /* Real pair */                        if(q >= 0)                      {                          if(p >= 0)                          {                              z = p + z;                          }                          else                          {                              z = p - z;                          }                            _d[n - 1] = x + z;                            _d[n] = _d[n - 1];                          if(z != 0.0)                          {                              _d[n] = x - (w / z);                          }                            _e[n - 1] = 0.0;                          _e[n] = 0.0;                          x = _h[n][n - 1];                          s = Math.Abs(x) + Math.Abs(z);                          p = x / s;                          q = z / s;                          r = Math.Sqrt((p * p) + (q * q));                          p = p / r;                          q = q / r;                            /* Row modification */                            for(int j = n - 1; j < nn; j++)                          {                              z = _h[n - 1][j];                              _h[n - 1][j] = (q * z) + (p * _h[n][j]);                              _h[n][j] = (q * _h[n][j]) - (p * z);                          }                            /* Column modification */                            for(int i = 0; i <= n; i++)                          {                              z = _h[i][n - 1];                              _h[i][n - 1] = (q * z) + (p * _h[i][n]);                              _h[i][n] = (q * _h[i][n]) - (p * z);                          }                            /* Accumulate transformations */                            for(int i = low; i <= high; i++)                          {                              z = _v[i][n - 1];                              _v[i][n - 1] = (q * z) + (p * _v[i][n]);                              _v[i][n] = (q * _v[i][n]) - (p * z);                          }                            // Complex pair                      }                      else                      {                          _d[n - 1] = x + p;                          _d[n] = x + p;                          _e[n - 1] = z;                          _e[n] = -z;                      }                        n = n - 2;                      iter = 0;                        // No convergence yet                  }                  else                  {                      /* Form shift */                        x = _h[n][n];                      y = 0.0;                      w = 0.0;                      if(l < n)                      {                          y = _h[n - 1][n - 1];                          w = _h[n][n - 1] * _h[n - 1][n];                      }                        /* Wilkinson's original ad hoc shift */                        if(iter == 10)                      {                          exshift += x;                          for(int i = low; i <= n; i++)                          {                              _h[i][i] -= x;                          }                            s = Math.Abs(_h[n][n - 1]) + Math.Abs(_h[n - 1][n - 2]);                          x = y = 0.75 * s;                          w = (-0.4375) * s * s;                      }                        /* MATLAB's new ad hoc shift */                        if(iter == 30)                      {                          s = (y - x) / 2.0;                          s = (s * s) + w;                          if(s > 0)                          {                              s = Math.Sqrt(s);                              if(y < x)                              {                                  s = -s;                              }                                s = x - (w / (((y - x) / 2.0) + s));                              for(int i = low; i <= n; i++)                              {                                  _h[i][i] -= s;                              }                                exshift += s;                              x = y = w = 0.964;                          }                      }                        iter = iter + 1; // (Could check iteration count here.)                        /* Look for two consecutive small sub-diagonal elements */                        int m = n - 2;                      while(m >= l)                      {                          z = _h[m][m];                          r = x - z;                          s = y - z;                          p = (((r * s) - w) / _h[m + 1][m]) + _h[m][m + 1];                          q = _h[m + 1][m + 1] - z - r - s;                          r = _h[m + 2][m + 1];                          s = Math.Abs(p) + Math.Abs(q) + Math.Abs(r);                          p = p / s;                          q = q / s;                          r = r / s;                            if(m == l)                          {                              break;                          }                            if(Math.Abs(_h[m][m - 1]) * (Math.Abs(q) + Math.Abs(r)) < eps * (Math.Abs(p) * (Math.Abs(_h[m - 1][m - 1]) + Math.Abs(z) + Math.Abs(_h[m + 1][m + 1]))))                          {                              break;                          }                            m--;                      }                        for(int i = m + 2; i <= n; i++)                      {                          _h[i][i - 2] = 0.0;                          if(i > m + 2)                          {                              _h[i][i - 3] = 0.0;                          }                      }                        /* Double QR step involving rows l:n and columns m:n */                        for(int k = m; k <= n - 1; k++)                      {                          bool notlast = (k != n - 1);                            if(k != m)                          {                              p = _h[k][k - 1];                              q = _h[k + 1][k - 1];                              r = (notlast ? _h[k + 2][k - 1] : 0.0);                              x = Math.Abs(p) + Math.Abs(q) + Math.Abs(r);                              if(x != 0.0)                              {                                  p = p / x;                                  q = q / x;                                  r = r / x;                              }                          }                            if(x == 0.0)                          {                              break;                          }                            s = Math.Sqrt((p * p) + (q * q) + (r * r));                          if(p < 0)                          {                              s = -s;                          }                            if(s != 0.0)                          {                              if(k != m)                              {                                  _h[k][k - 1] = (-s) * x;                              }                              else if(l != m)                              {                                  _h[k][k - 1] = -_h[k][k - 1];                              }                                p = p + s;                              x = p / s;                              y = q / s;                              z = r / s;                              q = q / p;                              r = r / p;                                /* Row modification */                                for(int j = k; j < nn; j++)                              {                                  p = _h[k][j] + (q * _h[k + 1][j]);                                    if(notlast)                                  {                                      p = p + (r * _h[k + 2][j]);                                      _h[k + 2][j] = _h[k + 2][j] - (p * z);                                  }                                    _h[k][j] = _h[k][j] - (p * x);                                  _h[k + 1][j] = _h[k + 1][j] - (p * y);                              }                                /* Column modification */                                for(int i = 0; i <= Math.Min(n' k + 3); i++)                              {                                  double[] hi = _h[i];                                  p = (x * hi[k]) + (y * hi[k + 1]);                                    if(notlast)                                  {                                      p = p + (z * hi[k + 2]);                                      hi[k + 2] = hi[k + 2] - (p * r);                                  }                                    hi[k] = hi[k] - p;                                  hi[k + 1] = hi[k + 1] - (p * q);                              }                                /* Accumulate transformations */                                for(int i = low; i <= high; i++)                              {                                  double[] vi = _v[i];                                  p = (x * vi[k]) + (y * vi[k + 1]);                                    if(notlast)                                  {                                      p = p + (z * vi[k + 2]);                                      vi[k + 2] = vi[k + 2] - (p * r);                                  }                                    vi[k] = vi[k] - p;                                  vi[k + 1] = vi[k + 1] - (p * q);                              }                          } // (s != 0)                      } // k loop                  } // check convergence              }
Magic Number,MathNet.Numerics.LinearAlgebra,EigenvalueDecomposition,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\LinearAlgebra\EigenvalueDecomposition.cs,NonsymmetricReduceHessenberToRealSchur,The following statement contains a magic number: while(n >= low)              {                  /* Look for single small sub-diagonal element */                    int l = n;                  while(l > low)                  {                      s = Math.Abs(_h[l - 1][l - 1]) + Math.Abs(_h[l][l]);                        if(s == 0.0)                      {                          s = norm;                      }                        if(Math.Abs(_h[l][l - 1]) < eps * s)                      {                          break;                      }                        l--;                  }                    /*                  Check for convergence                  One root found                  */                    if(l == n)                  {                      _h[n][n] = _h[n][n] + exshift;                      _d[n] = _h[n][n];                      _e[n] = 0.0;                      n--;                      iter = 0;                        // Two roots found                  }                  else if(l == n - 1)                  {                      w = _h[n][n - 1] * _h[n - 1][n];                      p = (_h[n - 1][n - 1] - _h[n][n]) / 2.0;                      q = (p * p) + w;                      z = Math.Sqrt(Math.Abs(q));                      _h[n][n] = _h[n][n] + exshift;                      _h[n - 1][n - 1] = _h[n - 1][n - 1] + exshift;                      x = _h[n][n];                        /* Real pair */                        if(q >= 0)                      {                          if(p >= 0)                          {                              z = p + z;                          }                          else                          {                              z = p - z;                          }                            _d[n - 1] = x + z;                            _d[n] = _d[n - 1];                          if(z != 0.0)                          {                              _d[n] = x - (w / z);                          }                            _e[n - 1] = 0.0;                          _e[n] = 0.0;                          x = _h[n][n - 1];                          s = Math.Abs(x) + Math.Abs(z);                          p = x / s;                          q = z / s;                          r = Math.Sqrt((p * p) + (q * q));                          p = p / r;                          q = q / r;                            /* Row modification */                            for(int j = n - 1; j < nn; j++)                          {                              z = _h[n - 1][j];                              _h[n - 1][j] = (q * z) + (p * _h[n][j]);                              _h[n][j] = (q * _h[n][j]) - (p * z);                          }                            /* Column modification */                            for(int i = 0; i <= n; i++)                          {                              z = _h[i][n - 1];                              _h[i][n - 1] = (q * z) + (p * _h[i][n]);                              _h[i][n] = (q * _h[i][n]) - (p * z);                          }                            /* Accumulate transformations */                            for(int i = low; i <= high; i++)                          {                              z = _v[i][n - 1];                              _v[i][n - 1] = (q * z) + (p * _v[i][n]);                              _v[i][n] = (q * _v[i][n]) - (p * z);                          }                            // Complex pair                      }                      else                      {                          _d[n - 1] = x + p;                          _d[n] = x + p;                          _e[n - 1] = z;                          _e[n] = -z;                      }                        n = n - 2;                      iter = 0;                        // No convergence yet                  }                  else                  {                      /* Form shift */                        x = _h[n][n];                      y = 0.0;                      w = 0.0;                      if(l < n)                      {                          y = _h[n - 1][n - 1];                          w = _h[n][n - 1] * _h[n - 1][n];                      }                        /* Wilkinson's original ad hoc shift */                        if(iter == 10)                      {                          exshift += x;                          for(int i = low; i <= n; i++)                          {                              _h[i][i] -= x;                          }                            s = Math.Abs(_h[n][n - 1]) + Math.Abs(_h[n - 1][n - 2]);                          x = y = 0.75 * s;                          w = (-0.4375) * s * s;                      }                        /* MATLAB's new ad hoc shift */                        if(iter == 30)                      {                          s = (y - x) / 2.0;                          s = (s * s) + w;                          if(s > 0)                          {                              s = Math.Sqrt(s);                              if(y < x)                              {                                  s = -s;                              }                                s = x - (w / (((y - x) / 2.0) + s));                              for(int i = low; i <= n; i++)                              {                                  _h[i][i] -= s;                              }                                exshift += s;                              x = y = w = 0.964;                          }                      }                        iter = iter + 1; // (Could check iteration count here.)                        /* Look for two consecutive small sub-diagonal elements */                        int m = n - 2;                      while(m >= l)                      {                          z = _h[m][m];                          r = x - z;                          s = y - z;                          p = (((r * s) - w) / _h[m + 1][m]) + _h[m][m + 1];                          q = _h[m + 1][m + 1] - z - r - s;                          r = _h[m + 2][m + 1];                          s = Math.Abs(p) + Math.Abs(q) + Math.Abs(r);                          p = p / s;                          q = q / s;                          r = r / s;                            if(m == l)                          {                              break;                          }                            if(Math.Abs(_h[m][m - 1]) * (Math.Abs(q) + Math.Abs(r)) < eps * (Math.Abs(p) * (Math.Abs(_h[m - 1][m - 1]) + Math.Abs(z) + Math.Abs(_h[m + 1][m + 1]))))                          {                              break;                          }                            m--;                      }                        for(int i = m + 2; i <= n; i++)                      {                          _h[i][i - 2] = 0.0;                          if(i > m + 2)                          {                              _h[i][i - 3] = 0.0;                          }                      }                        /* Double QR step involving rows l:n and columns m:n */                        for(int k = m; k <= n - 1; k++)                      {                          bool notlast = (k != n - 1);                            if(k != m)                          {                              p = _h[k][k - 1];                              q = _h[k + 1][k - 1];                              r = (notlast ? _h[k + 2][k - 1] : 0.0);                              x = Math.Abs(p) + Math.Abs(q) + Math.Abs(r);                              if(x != 0.0)                              {                                  p = p / x;                                  q = q / x;                                  r = r / x;                              }                          }                            if(x == 0.0)                          {                              break;                          }                            s = Math.Sqrt((p * p) + (q * q) + (r * r));                          if(p < 0)                          {                              s = -s;                          }                            if(s != 0.0)                          {                              if(k != m)                              {                                  _h[k][k - 1] = (-s) * x;                              }                              else if(l != m)                              {                                  _h[k][k - 1] = -_h[k][k - 1];                              }                                p = p + s;                              x = p / s;                              y = q / s;                              z = r / s;                              q = q / p;                              r = r / p;                                /* Row modification */                                for(int j = k; j < nn; j++)                              {                                  p = _h[k][j] + (q * _h[k + 1][j]);                                    if(notlast)                                  {                                      p = p + (r * _h[k + 2][j]);                                      _h[k + 2][j] = _h[k + 2][j] - (p * z);                                  }                                    _h[k][j] = _h[k][j] - (p * x);                                  _h[k + 1][j] = _h[k + 1][j] - (p * y);                              }                                /* Column modification */                                for(int i = 0; i <= Math.Min(n' k + 3); i++)                              {                                  double[] hi = _h[i];                                  p = (x * hi[k]) + (y * hi[k + 1]);                                    if(notlast)                                  {                                      p = p + (z * hi[k + 2]);                                      hi[k + 2] = hi[k + 2] - (p * r);                                  }                                    hi[k] = hi[k] - p;                                  hi[k + 1] = hi[k + 1] - (p * q);                              }                                /* Accumulate transformations */                                for(int i = low; i <= high; i++)                              {                                  double[] vi = _v[i];                                  p = (x * vi[k]) + (y * vi[k + 1]);                                    if(notlast)                                  {                                      p = p + (z * vi[k + 2]);                                      vi[k + 2] = vi[k + 2] - (p * r);                                  }                                    vi[k] = vi[k] - p;                                  vi[k + 1] = vi[k + 1] - (p * q);                              }                          } // (s != 0)                      } // k loop                  } // check convergence              }
Magic Number,MathNet.Numerics.LinearAlgebra,EigenvalueDecomposition,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\LinearAlgebra\EigenvalueDecomposition.cs,NonsymmetricReduceHessenberToRealSchur,The following statement contains a magic number: while(n >= low)              {                  /* Look for single small sub-diagonal element */                    int l = n;                  while(l > low)                  {                      s = Math.Abs(_h[l - 1][l - 1]) + Math.Abs(_h[l][l]);                        if(s == 0.0)                      {                          s = norm;                      }                        if(Math.Abs(_h[l][l - 1]) < eps * s)                      {                          break;                      }                        l--;                  }                    /*                  Check for convergence                  One root found                  */                    if(l == n)                  {                      _h[n][n] = _h[n][n] + exshift;                      _d[n] = _h[n][n];                      _e[n] = 0.0;                      n--;                      iter = 0;                        // Two roots found                  }                  else if(l == n - 1)                  {                      w = _h[n][n - 1] * _h[n - 1][n];                      p = (_h[n - 1][n - 1] - _h[n][n]) / 2.0;                      q = (p * p) + w;                      z = Math.Sqrt(Math.Abs(q));                      _h[n][n] = _h[n][n] + exshift;                      _h[n - 1][n - 1] = _h[n - 1][n - 1] + exshift;                      x = _h[n][n];                        /* Real pair */                        if(q >= 0)                      {                          if(p >= 0)                          {                              z = p + z;                          }                          else                          {                              z = p - z;                          }                            _d[n - 1] = x + z;                            _d[n] = _d[n - 1];                          if(z != 0.0)                          {                              _d[n] = x - (w / z);                          }                            _e[n - 1] = 0.0;                          _e[n] = 0.0;                          x = _h[n][n - 1];                          s = Math.Abs(x) + Math.Abs(z);                          p = x / s;                          q = z / s;                          r = Math.Sqrt((p * p) + (q * q));                          p = p / r;                          q = q / r;                            /* Row modification */                            for(int j = n - 1; j < nn; j++)                          {                              z = _h[n - 1][j];                              _h[n - 1][j] = (q * z) + (p * _h[n][j]);                              _h[n][j] = (q * _h[n][j]) - (p * z);                          }                            /* Column modification */                            for(int i = 0; i <= n; i++)                          {                              z = _h[i][n - 1];                              _h[i][n - 1] = (q * z) + (p * _h[i][n]);                              _h[i][n] = (q * _h[i][n]) - (p * z);                          }                            /* Accumulate transformations */                            for(int i = low; i <= high; i++)                          {                              z = _v[i][n - 1];                              _v[i][n - 1] = (q * z) + (p * _v[i][n]);                              _v[i][n] = (q * _v[i][n]) - (p * z);                          }                            // Complex pair                      }                      else                      {                          _d[n - 1] = x + p;                          _d[n] = x + p;                          _e[n - 1] = z;                          _e[n] = -z;                      }                        n = n - 2;                      iter = 0;                        // No convergence yet                  }                  else                  {                      /* Form shift */                        x = _h[n][n];                      y = 0.0;                      w = 0.0;                      if(l < n)                      {                          y = _h[n - 1][n - 1];                          w = _h[n][n - 1] * _h[n - 1][n];                      }                        /* Wilkinson's original ad hoc shift */                        if(iter == 10)                      {                          exshift += x;                          for(int i = low; i <= n; i++)                          {                              _h[i][i] -= x;                          }                            s = Math.Abs(_h[n][n - 1]) + Math.Abs(_h[n - 1][n - 2]);                          x = y = 0.75 * s;                          w = (-0.4375) * s * s;                      }                        /* MATLAB's new ad hoc shift */                        if(iter == 30)                      {                          s = (y - x) / 2.0;                          s = (s * s) + w;                          if(s > 0)                          {                              s = Math.Sqrt(s);                              if(y < x)                              {                                  s = -s;                              }                                s = x - (w / (((y - x) / 2.0) + s));                              for(int i = low; i <= n; i++)                              {                                  _h[i][i] -= s;                              }                                exshift += s;                              x = y = w = 0.964;                          }                      }                        iter = iter + 1; // (Could check iteration count here.)                        /* Look for two consecutive small sub-diagonal elements */                        int m = n - 2;                      while(m >= l)                      {                          z = _h[m][m];                          r = x - z;                          s = y - z;                          p = (((r * s) - w) / _h[m + 1][m]) + _h[m][m + 1];                          q = _h[m + 1][m + 1] - z - r - s;                          r = _h[m + 2][m + 1];                          s = Math.Abs(p) + Math.Abs(q) + Math.Abs(r);                          p = p / s;                          q = q / s;                          r = r / s;                            if(m == l)                          {                              break;                          }                            if(Math.Abs(_h[m][m - 1]) * (Math.Abs(q) + Math.Abs(r)) < eps * (Math.Abs(p) * (Math.Abs(_h[m - 1][m - 1]) + Math.Abs(z) + Math.Abs(_h[m + 1][m + 1]))))                          {                              break;                          }                            m--;                      }                        for(int i = m + 2; i <= n; i++)                      {                          _h[i][i - 2] = 0.0;                          if(i > m + 2)                          {                              _h[i][i - 3] = 0.0;                          }                      }                        /* Double QR step involving rows l:n and columns m:n */                        for(int k = m; k <= n - 1; k++)                      {                          bool notlast = (k != n - 1);                            if(k != m)                          {                              p = _h[k][k - 1];                              q = _h[k + 1][k - 1];                              r = (notlast ? _h[k + 2][k - 1] : 0.0);                              x = Math.Abs(p) + Math.Abs(q) + Math.Abs(r);                              if(x != 0.0)                              {                                  p = p / x;                                  q = q / x;                                  r = r / x;                              }                          }                            if(x == 0.0)                          {                              break;                          }                            s = Math.Sqrt((p * p) + (q * q) + (r * r));                          if(p < 0)                          {                              s = -s;                          }                            if(s != 0.0)                          {                              if(k != m)                              {                                  _h[k][k - 1] = (-s) * x;                              }                              else if(l != m)                              {                                  _h[k][k - 1] = -_h[k][k - 1];                              }                                p = p + s;                              x = p / s;                              y = q / s;                              z = r / s;                              q = q / p;                              r = r / p;                                /* Row modification */                                for(int j = k; j < nn; j++)                              {                                  p = _h[k][j] + (q * _h[k + 1][j]);                                    if(notlast)                                  {                                      p = p + (r * _h[k + 2][j]);                                      _h[k + 2][j] = _h[k + 2][j] - (p * z);                                  }                                    _h[k][j] = _h[k][j] - (p * x);                                  _h[k + 1][j] = _h[k + 1][j] - (p * y);                              }                                /* Column modification */                                for(int i = 0; i <= Math.Min(n' k + 3); i++)                              {                                  double[] hi = _h[i];                                  p = (x * hi[k]) + (y * hi[k + 1]);                                    if(notlast)                                  {                                      p = p + (z * hi[k + 2]);                                      hi[k + 2] = hi[k + 2] - (p * r);                                  }                                    hi[k] = hi[k] - p;                                  hi[k + 1] = hi[k + 1] - (p * q);                              }                                /* Accumulate transformations */                                for(int i = low; i <= high; i++)                              {                                  double[] vi = _v[i];                                  p = (x * vi[k]) + (y * vi[k + 1]);                                    if(notlast)                                  {                                      p = p + (z * vi[k + 2]);                                      vi[k + 2] = vi[k + 2] - (p * r);                                  }                                    vi[k] = vi[k] - p;                                  vi[k + 1] = vi[k + 1] - (p * q);                              }                          } // (s != 0)                      } // k loop                  } // check convergence              }
Magic Number,MathNet.Numerics.LinearAlgebra,EigenvalueDecomposition,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\LinearAlgebra\EigenvalueDecomposition.cs,NonsymmetricReduceHessenberToRealSchur,The following statement contains a magic number: while(n >= low)              {                  /* Look for single small sub-diagonal element */                    int l = n;                  while(l > low)                  {                      s = Math.Abs(_h[l - 1][l - 1]) + Math.Abs(_h[l][l]);                        if(s == 0.0)                      {                          s = norm;                      }                        if(Math.Abs(_h[l][l - 1]) < eps * s)                      {                          break;                      }                        l--;                  }                    /*                  Check for convergence                  One root found                  */                    if(l == n)                  {                      _h[n][n] = _h[n][n] + exshift;                      _d[n] = _h[n][n];                      _e[n] = 0.0;                      n--;                      iter = 0;                        // Two roots found                  }                  else if(l == n - 1)                  {                      w = _h[n][n - 1] * _h[n - 1][n];                      p = (_h[n - 1][n - 1] - _h[n][n]) / 2.0;                      q = (p * p) + w;                      z = Math.Sqrt(Math.Abs(q));                      _h[n][n] = _h[n][n] + exshift;                      _h[n - 1][n - 1] = _h[n - 1][n - 1] + exshift;                      x = _h[n][n];                        /* Real pair */                        if(q >= 0)                      {                          if(p >= 0)                          {                              z = p + z;                          }                          else                          {                              z = p - z;                          }                            _d[n - 1] = x + z;                            _d[n] = _d[n - 1];                          if(z != 0.0)                          {                              _d[n] = x - (w / z);                          }                            _e[n - 1] = 0.0;                          _e[n] = 0.0;                          x = _h[n][n - 1];                          s = Math.Abs(x) + Math.Abs(z);                          p = x / s;                          q = z / s;                          r = Math.Sqrt((p * p) + (q * q));                          p = p / r;                          q = q / r;                            /* Row modification */                            for(int j = n - 1; j < nn; j++)                          {                              z = _h[n - 1][j];                              _h[n - 1][j] = (q * z) + (p * _h[n][j]);                              _h[n][j] = (q * _h[n][j]) - (p * z);                          }                            /* Column modification */                            for(int i = 0; i <= n; i++)                          {                              z = _h[i][n - 1];                              _h[i][n - 1] = (q * z) + (p * _h[i][n]);                              _h[i][n] = (q * _h[i][n]) - (p * z);                          }                            /* Accumulate transformations */                            for(int i = low; i <= high; i++)                          {                              z = _v[i][n - 1];                              _v[i][n - 1] = (q * z) + (p * _v[i][n]);                              _v[i][n] = (q * _v[i][n]) - (p * z);                          }                            // Complex pair                      }                      else                      {                          _d[n - 1] = x + p;                          _d[n] = x + p;                          _e[n - 1] = z;                          _e[n] = -z;                      }                        n = n - 2;                      iter = 0;                        // No convergence yet                  }                  else                  {                      /* Form shift */                        x = _h[n][n];                      y = 0.0;                      w = 0.0;                      if(l < n)                      {                          y = _h[n - 1][n - 1];                          w = _h[n][n - 1] * _h[n - 1][n];                      }                        /* Wilkinson's original ad hoc shift */                        if(iter == 10)                      {                          exshift += x;                          for(int i = low; i <= n; i++)                          {                              _h[i][i] -= x;                          }                            s = Math.Abs(_h[n][n - 1]) + Math.Abs(_h[n - 1][n - 2]);                          x = y = 0.75 * s;                          w = (-0.4375) * s * s;                      }                        /* MATLAB's new ad hoc shift */                        if(iter == 30)                      {                          s = (y - x) / 2.0;                          s = (s * s) + w;                          if(s > 0)                          {                              s = Math.Sqrt(s);                              if(y < x)                              {                                  s = -s;                              }                                s = x - (w / (((y - x) / 2.0) + s));                              for(int i = low; i <= n; i++)                              {                                  _h[i][i] -= s;                              }                                exshift += s;                              x = y = w = 0.964;                          }                      }                        iter = iter + 1; // (Could check iteration count here.)                        /* Look for two consecutive small sub-diagonal elements */                        int m = n - 2;                      while(m >= l)                      {                          z = _h[m][m];                          r = x - z;                          s = y - z;                          p = (((r * s) - w) / _h[m + 1][m]) + _h[m][m + 1];                          q = _h[m + 1][m + 1] - z - r - s;                          r = _h[m + 2][m + 1];                          s = Math.Abs(p) + Math.Abs(q) + Math.Abs(r);                          p = p / s;                          q = q / s;                          r = r / s;                            if(m == l)                          {                              break;                          }                            if(Math.Abs(_h[m][m - 1]) * (Math.Abs(q) + Math.Abs(r)) < eps * (Math.Abs(p) * (Math.Abs(_h[m - 1][m - 1]) + Math.Abs(z) + Math.Abs(_h[m + 1][m + 1]))))                          {                              break;                          }                            m--;                      }                        for(int i = m + 2; i <= n; i++)                      {                          _h[i][i - 2] = 0.0;                          if(i > m + 2)                          {                              _h[i][i - 3] = 0.0;                          }                      }                        /* Double QR step involving rows l:n and columns m:n */                        for(int k = m; k <= n - 1; k++)                      {                          bool notlast = (k != n - 1);                            if(k != m)                          {                              p = _h[k][k - 1];                              q = _h[k + 1][k - 1];                              r = (notlast ? _h[k + 2][k - 1] : 0.0);                              x = Math.Abs(p) + Math.Abs(q) + Math.Abs(r);                              if(x != 0.0)                              {                                  p = p / x;                                  q = q / x;                                  r = r / x;                              }                          }                            if(x == 0.0)                          {                              break;                          }                            s = Math.Sqrt((p * p) + (q * q) + (r * r));                          if(p < 0)                          {                              s = -s;                          }                            if(s != 0.0)                          {                              if(k != m)                              {                                  _h[k][k - 1] = (-s) * x;                              }                              else if(l != m)                              {                                  _h[k][k - 1] = -_h[k][k - 1];                              }                                p = p + s;                              x = p / s;                              y = q / s;                              z = r / s;                              q = q / p;                              r = r / p;                                /* Row modification */                                for(int j = k; j < nn; j++)                              {                                  p = _h[k][j] + (q * _h[k + 1][j]);                                    if(notlast)                                  {                                      p = p + (r * _h[k + 2][j]);                                      _h[k + 2][j] = _h[k + 2][j] - (p * z);                                  }                                    _h[k][j] = _h[k][j] - (p * x);                                  _h[k + 1][j] = _h[k + 1][j] - (p * y);                              }                                /* Column modification */                                for(int i = 0; i <= Math.Min(n' k + 3); i++)                              {                                  double[] hi = _h[i];                                  p = (x * hi[k]) + (y * hi[k + 1]);                                    if(notlast)                                  {                                      p = p + (z * hi[k + 2]);                                      hi[k + 2] = hi[k + 2] - (p * r);                                  }                                    hi[k] = hi[k] - p;                                  hi[k + 1] = hi[k + 1] - (p * q);                              }                                /* Accumulate transformations */                                for(int i = low; i <= high; i++)                              {                                  double[] vi = _v[i];                                  p = (x * vi[k]) + (y * vi[k + 1]);                                    if(notlast)                                  {                                      p = p + (z * vi[k + 2]);                                      vi[k + 2] = vi[k + 2] - (p * r);                                  }                                    vi[k] = vi[k] - p;                                  vi[k + 1] = vi[k + 1] - (p * q);                              }                          } // (s != 0)                      } // k loop                  } // check convergence              }
Magic Number,MathNet.Numerics.LinearAlgebra,EigenvalueDecomposition,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\LinearAlgebra\EigenvalueDecomposition.cs,NonsymmetricReduceHessenberToRealSchur,The following statement contains a magic number: while(n >= low)              {                  /* Look for single small sub-diagonal element */                    int l = n;                  while(l > low)                  {                      s = Math.Abs(_h[l - 1][l - 1]) + Math.Abs(_h[l][l]);                        if(s == 0.0)                      {                          s = norm;                      }                        if(Math.Abs(_h[l][l - 1]) < eps * s)                      {                          break;                      }                        l--;                  }                    /*                  Check for convergence                  One root found                  */                    if(l == n)                  {                      _h[n][n] = _h[n][n] + exshift;                      _d[n] = _h[n][n];                      _e[n] = 0.0;                      n--;                      iter = 0;                        // Two roots found                  }                  else if(l == n - 1)                  {                      w = _h[n][n - 1] * _h[n - 1][n];                      p = (_h[n - 1][n - 1] - _h[n][n]) / 2.0;                      q = (p * p) + w;                      z = Math.Sqrt(Math.Abs(q));                      _h[n][n] = _h[n][n] + exshift;                      _h[n - 1][n - 1] = _h[n - 1][n - 1] + exshift;                      x = _h[n][n];                        /* Real pair */                        if(q >= 0)                      {                          if(p >= 0)                          {                              z = p + z;                          }                          else                          {                              z = p - z;                          }                            _d[n - 1] = x + z;                            _d[n] = _d[n - 1];                          if(z != 0.0)                          {                              _d[n] = x - (w / z);                          }                            _e[n - 1] = 0.0;                          _e[n] = 0.0;                          x = _h[n][n - 1];                          s = Math.Abs(x) + Math.Abs(z);                          p = x / s;                          q = z / s;                          r = Math.Sqrt((p * p) + (q * q));                          p = p / r;                          q = q / r;                            /* Row modification */                            for(int j = n - 1; j < nn; j++)                          {                              z = _h[n - 1][j];                              _h[n - 1][j] = (q * z) + (p * _h[n][j]);                              _h[n][j] = (q * _h[n][j]) - (p * z);                          }                            /* Column modification */                            for(int i = 0; i <= n; i++)                          {                              z = _h[i][n - 1];                              _h[i][n - 1] = (q * z) + (p * _h[i][n]);                              _h[i][n] = (q * _h[i][n]) - (p * z);                          }                            /* Accumulate transformations */                            for(int i = low; i <= high; i++)                          {                              z = _v[i][n - 1];                              _v[i][n - 1] = (q * z) + (p * _v[i][n]);                              _v[i][n] = (q * _v[i][n]) - (p * z);                          }                            // Complex pair                      }                      else                      {                          _d[n - 1] = x + p;                          _d[n] = x + p;                          _e[n - 1] = z;                          _e[n] = -z;                      }                        n = n - 2;                      iter = 0;                        // No convergence yet                  }                  else                  {                      /* Form shift */                        x = _h[n][n];                      y = 0.0;                      w = 0.0;                      if(l < n)                      {                          y = _h[n - 1][n - 1];                          w = _h[n][n - 1] * _h[n - 1][n];                      }                        /* Wilkinson's original ad hoc shift */                        if(iter == 10)                      {                          exshift += x;                          for(int i = low; i <= n; i++)                          {                              _h[i][i] -= x;                          }                            s = Math.Abs(_h[n][n - 1]) + Math.Abs(_h[n - 1][n - 2]);                          x = y = 0.75 * s;                          w = (-0.4375) * s * s;                      }                        /* MATLAB's new ad hoc shift */                        if(iter == 30)                      {                          s = (y - x) / 2.0;                          s = (s * s) + w;                          if(s > 0)                          {                              s = Math.Sqrt(s);                              if(y < x)                              {                                  s = -s;                              }                                s = x - (w / (((y - x) / 2.0) + s));                              for(int i = low; i <= n; i++)                              {                                  _h[i][i] -= s;                              }                                exshift += s;                              x = y = w = 0.964;                          }                      }                        iter = iter + 1; // (Could check iteration count here.)                        /* Look for two consecutive small sub-diagonal elements */                        int m = n - 2;                      while(m >= l)                      {                          z = _h[m][m];                          r = x - z;                          s = y - z;                          p = (((r * s) - w) / _h[m + 1][m]) + _h[m][m + 1];                          q = _h[m + 1][m + 1] - z - r - s;                          r = _h[m + 2][m + 1];                          s = Math.Abs(p) + Math.Abs(q) + Math.Abs(r);                          p = p / s;                          q = q / s;                          r = r / s;                            if(m == l)                          {                              break;                          }                            if(Math.Abs(_h[m][m - 1]) * (Math.Abs(q) + Math.Abs(r)) < eps * (Math.Abs(p) * (Math.Abs(_h[m - 1][m - 1]) + Math.Abs(z) + Math.Abs(_h[m + 1][m + 1]))))                          {                              break;                          }                            m--;                      }                        for(int i = m + 2; i <= n; i++)                      {                          _h[i][i - 2] = 0.0;                          if(i > m + 2)                          {                              _h[i][i - 3] = 0.0;                          }                      }                        /* Double QR step involving rows l:n and columns m:n */                        for(int k = m; k <= n - 1; k++)                      {                          bool notlast = (k != n - 1);                            if(k != m)                          {                              p = _h[k][k - 1];                              q = _h[k + 1][k - 1];                              r = (notlast ? _h[k + 2][k - 1] : 0.0);                              x = Math.Abs(p) + Math.Abs(q) + Math.Abs(r);                              if(x != 0.0)                              {                                  p = p / x;                                  q = q / x;                                  r = r / x;                              }                          }                            if(x == 0.0)                          {                              break;                          }                            s = Math.Sqrt((p * p) + (q * q) + (r * r));                          if(p < 0)                          {                              s = -s;                          }                            if(s != 0.0)                          {                              if(k != m)                              {                                  _h[k][k - 1] = (-s) * x;                              }                              else if(l != m)                              {                                  _h[k][k - 1] = -_h[k][k - 1];                              }                                p = p + s;                              x = p / s;                              y = q / s;                              z = r / s;                              q = q / p;                              r = r / p;                                /* Row modification */                                for(int j = k; j < nn; j++)                              {                                  p = _h[k][j] + (q * _h[k + 1][j]);                                    if(notlast)                                  {                                      p = p + (r * _h[k + 2][j]);                                      _h[k + 2][j] = _h[k + 2][j] - (p * z);                                  }                                    _h[k][j] = _h[k][j] - (p * x);                                  _h[k + 1][j] = _h[k + 1][j] - (p * y);                              }                                /* Column modification */                                for(int i = 0; i <= Math.Min(n' k + 3); i++)                              {                                  double[] hi = _h[i];                                  p = (x * hi[k]) + (y * hi[k + 1]);                                    if(notlast)                                  {                                      p = p + (z * hi[k + 2]);                                      hi[k + 2] = hi[k + 2] - (p * r);                                  }                                    hi[k] = hi[k] - p;                                  hi[k + 1] = hi[k + 1] - (p * q);                              }                                /* Accumulate transformations */                                for(int i = low; i <= high; i++)                              {                                  double[] vi = _v[i];                                  p = (x * vi[k]) + (y * vi[k + 1]);                                    if(notlast)                                  {                                      p = p + (z * vi[k + 2]);                                      vi[k + 2] = vi[k + 2] - (p * r);                                  }                                    vi[k] = vi[k] - p;                                  vi[k + 1] = vi[k + 1] - (p * q);                              }                          } // (s != 0)                      } // k loop                  } // check convergence              }
Magic Number,MathNet.Numerics.LinearAlgebra,EigenvalueDecomposition,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\LinearAlgebra\EigenvalueDecomposition.cs,NonsymmetricReduceHessenberToRealSchur,The following statement contains a magic number: while(n >= low)              {                  /* Look for single small sub-diagonal element */                    int l = n;                  while(l > low)                  {                      s = Math.Abs(_h[l - 1][l - 1]) + Math.Abs(_h[l][l]);                        if(s == 0.0)                      {                          s = norm;                      }                        if(Math.Abs(_h[l][l - 1]) < eps * s)                      {                          break;                      }                        l--;                  }                    /*                  Check for convergence                  One root found                  */                    if(l == n)                  {                      _h[n][n] = _h[n][n] + exshift;                      _d[n] = _h[n][n];                      _e[n] = 0.0;                      n--;                      iter = 0;                        // Two roots found                  }                  else if(l == n - 1)                  {                      w = _h[n][n - 1] * _h[n - 1][n];                      p = (_h[n - 1][n - 1] - _h[n][n]) / 2.0;                      q = (p * p) + w;                      z = Math.Sqrt(Math.Abs(q));                      _h[n][n] = _h[n][n] + exshift;                      _h[n - 1][n - 1] = _h[n - 1][n - 1] + exshift;                      x = _h[n][n];                        /* Real pair */                        if(q >= 0)                      {                          if(p >= 0)                          {                              z = p + z;                          }                          else                          {                              z = p - z;                          }                            _d[n - 1] = x + z;                            _d[n] = _d[n - 1];                          if(z != 0.0)                          {                              _d[n] = x - (w / z);                          }                            _e[n - 1] = 0.0;                          _e[n] = 0.0;                          x = _h[n][n - 1];                          s = Math.Abs(x) + Math.Abs(z);                          p = x / s;                          q = z / s;                          r = Math.Sqrt((p * p) + (q * q));                          p = p / r;                          q = q / r;                            /* Row modification */                            for(int j = n - 1; j < nn; j++)                          {                              z = _h[n - 1][j];                              _h[n - 1][j] = (q * z) + (p * _h[n][j]);                              _h[n][j] = (q * _h[n][j]) - (p * z);                          }                            /* Column modification */                            for(int i = 0; i <= n; i++)                          {                              z = _h[i][n - 1];                              _h[i][n - 1] = (q * z) + (p * _h[i][n]);                              _h[i][n] = (q * _h[i][n]) - (p * z);                          }                            /* Accumulate transformations */                            for(int i = low; i <= high; i++)                          {                              z = _v[i][n - 1];                              _v[i][n - 1] = (q * z) + (p * _v[i][n]);                              _v[i][n] = (q * _v[i][n]) - (p * z);                          }                            // Complex pair                      }                      else                      {                          _d[n - 1] = x + p;                          _d[n] = x + p;                          _e[n - 1] = z;                          _e[n] = -z;                      }                        n = n - 2;                      iter = 0;                        // No convergence yet                  }                  else                  {                      /* Form shift */                        x = _h[n][n];                      y = 0.0;                      w = 0.0;                      if(l < n)                      {                          y = _h[n - 1][n - 1];                          w = _h[n][n - 1] * _h[n - 1][n];                      }                        /* Wilkinson's original ad hoc shift */                        if(iter == 10)                      {                          exshift += x;                          for(int i = low; i <= n; i++)                          {                              _h[i][i] -= x;                          }                            s = Math.Abs(_h[n][n - 1]) + Math.Abs(_h[n - 1][n - 2]);                          x = y = 0.75 * s;                          w = (-0.4375) * s * s;                      }                        /* MATLAB's new ad hoc shift */                        if(iter == 30)                      {                          s = (y - x) / 2.0;                          s = (s * s) + w;                          if(s > 0)                          {                              s = Math.Sqrt(s);                              if(y < x)                              {                                  s = -s;                              }                                s = x - (w / (((y - x) / 2.0) + s));                              for(int i = low; i <= n; i++)                              {                                  _h[i][i] -= s;                              }                                exshift += s;                              x = y = w = 0.964;                          }                      }                        iter = iter + 1; // (Could check iteration count here.)                        /* Look for two consecutive small sub-diagonal elements */                        int m = n - 2;                      while(m >= l)                      {                          z = _h[m][m];                          r = x - z;                          s = y - z;                          p = (((r * s) - w) / _h[m + 1][m]) + _h[m][m + 1];                          q = _h[m + 1][m + 1] - z - r - s;                          r = _h[m + 2][m + 1];                          s = Math.Abs(p) + Math.Abs(q) + Math.Abs(r);                          p = p / s;                          q = q / s;                          r = r / s;                            if(m == l)                          {                              break;                          }                            if(Math.Abs(_h[m][m - 1]) * (Math.Abs(q) + Math.Abs(r)) < eps * (Math.Abs(p) * (Math.Abs(_h[m - 1][m - 1]) + Math.Abs(z) + Math.Abs(_h[m + 1][m + 1]))))                          {                              break;                          }                            m--;                      }                        for(int i = m + 2; i <= n; i++)                      {                          _h[i][i - 2] = 0.0;                          if(i > m + 2)                          {                              _h[i][i - 3] = 0.0;                          }                      }                        /* Double QR step involving rows l:n and columns m:n */                        for(int k = m; k <= n - 1; k++)                      {                          bool notlast = (k != n - 1);                            if(k != m)                          {                              p = _h[k][k - 1];                              q = _h[k + 1][k - 1];                              r = (notlast ? _h[k + 2][k - 1] : 0.0);                              x = Math.Abs(p) + Math.Abs(q) + Math.Abs(r);                              if(x != 0.0)                              {                                  p = p / x;                                  q = q / x;                                  r = r / x;                              }                          }                            if(x == 0.0)                          {                              break;                          }                            s = Math.Sqrt((p * p) + (q * q) + (r * r));                          if(p < 0)                          {                              s = -s;                          }                            if(s != 0.0)                          {                              if(k != m)                              {                                  _h[k][k - 1] = (-s) * x;                              }                              else if(l != m)                              {                                  _h[k][k - 1] = -_h[k][k - 1];                              }                                p = p + s;                              x = p / s;                              y = q / s;                              z = r / s;                              q = q / p;                              r = r / p;                                /* Row modification */                                for(int j = k; j < nn; j++)                              {                                  p = _h[k][j] + (q * _h[k + 1][j]);                                    if(notlast)                                  {                                      p = p + (r * _h[k + 2][j]);                                      _h[k + 2][j] = _h[k + 2][j] - (p * z);                                  }                                    _h[k][j] = _h[k][j] - (p * x);                                  _h[k + 1][j] = _h[k + 1][j] - (p * y);                              }                                /* Column modification */                                for(int i = 0; i <= Math.Min(n' k + 3); i++)                              {                                  double[] hi = _h[i];                                  p = (x * hi[k]) + (y * hi[k + 1]);                                    if(notlast)                                  {                                      p = p + (z * hi[k + 2]);                                      hi[k + 2] = hi[k + 2] - (p * r);                                  }                                    hi[k] = hi[k] - p;                                  hi[k + 1] = hi[k + 1] - (p * q);                              }                                /* Accumulate transformations */                                for(int i = low; i <= high; i++)                              {                                  double[] vi = _v[i];                                  p = (x * vi[k]) + (y * vi[k + 1]);                                    if(notlast)                                  {                                      p = p + (z * vi[k + 2]);                                      vi[k + 2] = vi[k + 2] - (p * r);                                  }                                    vi[k] = vi[k] - p;                                  vi[k + 1] = vi[k + 1] - (p * q);                              }                          } // (s != 0)                      } // k loop                  } // check convergence              }
Magic Number,MathNet.Numerics.LinearAlgebra,EigenvalueDecomposition,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\LinearAlgebra\EigenvalueDecomposition.cs,NonsymmetricReduceHessenberToRealSchur,The following statement contains a magic number: while(n >= low)              {                  /* Look for single small sub-diagonal element */                    int l = n;                  while(l > low)                  {                      s = Math.Abs(_h[l - 1][l - 1]) + Math.Abs(_h[l][l]);                        if(s == 0.0)                      {                          s = norm;                      }                        if(Math.Abs(_h[l][l - 1]) < eps * s)                      {                          break;                      }                        l--;                  }                    /*                  Check for convergence                  One root found                  */                    if(l == n)                  {                      _h[n][n] = _h[n][n] + exshift;                      _d[n] = _h[n][n];                      _e[n] = 0.0;                      n--;                      iter = 0;                        // Two roots found                  }                  else if(l == n - 1)                  {                      w = _h[n][n - 1] * _h[n - 1][n];                      p = (_h[n - 1][n - 1] - _h[n][n]) / 2.0;                      q = (p * p) + w;                      z = Math.Sqrt(Math.Abs(q));                      _h[n][n] = _h[n][n] + exshift;                      _h[n - 1][n - 1] = _h[n - 1][n - 1] + exshift;                      x = _h[n][n];                        /* Real pair */                        if(q >= 0)                      {                          if(p >= 0)                          {                              z = p + z;                          }                          else                          {                              z = p - z;                          }                            _d[n - 1] = x + z;                            _d[n] = _d[n - 1];                          if(z != 0.0)                          {                              _d[n] = x - (w / z);                          }                            _e[n - 1] = 0.0;                          _e[n] = 0.0;                          x = _h[n][n - 1];                          s = Math.Abs(x) + Math.Abs(z);                          p = x / s;                          q = z / s;                          r = Math.Sqrt((p * p) + (q * q));                          p = p / r;                          q = q / r;                            /* Row modification */                            for(int j = n - 1; j < nn; j++)                          {                              z = _h[n - 1][j];                              _h[n - 1][j] = (q * z) + (p * _h[n][j]);                              _h[n][j] = (q * _h[n][j]) - (p * z);                          }                            /* Column modification */                            for(int i = 0; i <= n; i++)                          {                              z = _h[i][n - 1];                              _h[i][n - 1] = (q * z) + (p * _h[i][n]);                              _h[i][n] = (q * _h[i][n]) - (p * z);                          }                            /* Accumulate transformations */                            for(int i = low; i <= high; i++)                          {                              z = _v[i][n - 1];                              _v[i][n - 1] = (q * z) + (p * _v[i][n]);                              _v[i][n] = (q * _v[i][n]) - (p * z);                          }                            // Complex pair                      }                      else                      {                          _d[n - 1] = x + p;                          _d[n] = x + p;                          _e[n - 1] = z;                          _e[n] = -z;                      }                        n = n - 2;                      iter = 0;                        // No convergence yet                  }                  else                  {                      /* Form shift */                        x = _h[n][n];                      y = 0.0;                      w = 0.0;                      if(l < n)                      {                          y = _h[n - 1][n - 1];                          w = _h[n][n - 1] * _h[n - 1][n];                      }                        /* Wilkinson's original ad hoc shift */                        if(iter == 10)                      {                          exshift += x;                          for(int i = low; i <= n; i++)                          {                              _h[i][i] -= x;                          }                            s = Math.Abs(_h[n][n - 1]) + Math.Abs(_h[n - 1][n - 2]);                          x = y = 0.75 * s;                          w = (-0.4375) * s * s;                      }                        /* MATLAB's new ad hoc shift */                        if(iter == 30)                      {                          s = (y - x) / 2.0;                          s = (s * s) + w;                          if(s > 0)                          {                              s = Math.Sqrt(s);                              if(y < x)                              {                                  s = -s;                              }                                s = x - (w / (((y - x) / 2.0) + s));                              for(int i = low; i <= n; i++)                              {                                  _h[i][i] -= s;                              }                                exshift += s;                              x = y = w = 0.964;                          }                      }                        iter = iter + 1; // (Could check iteration count here.)                        /* Look for two consecutive small sub-diagonal elements */                        int m = n - 2;                      while(m >= l)                      {                          z = _h[m][m];                          r = x - z;                          s = y - z;                          p = (((r * s) - w) / _h[m + 1][m]) + _h[m][m + 1];                          q = _h[m + 1][m + 1] - z - r - s;                          r = _h[m + 2][m + 1];                          s = Math.Abs(p) + Math.Abs(q) + Math.Abs(r);                          p = p / s;                          q = q / s;                          r = r / s;                            if(m == l)                          {                              break;                          }                            if(Math.Abs(_h[m][m - 1]) * (Math.Abs(q) + Math.Abs(r)) < eps * (Math.Abs(p) * (Math.Abs(_h[m - 1][m - 1]) + Math.Abs(z) + Math.Abs(_h[m + 1][m + 1]))))                          {                              break;                          }                            m--;                      }                        for(int i = m + 2; i <= n; i++)                      {                          _h[i][i - 2] = 0.0;                          if(i > m + 2)                          {                              _h[i][i - 3] = 0.0;                          }                      }                        /* Double QR step involving rows l:n and columns m:n */                        for(int k = m; k <= n - 1; k++)                      {                          bool notlast = (k != n - 1);                            if(k != m)                          {                              p = _h[k][k - 1];                              q = _h[k + 1][k - 1];                              r = (notlast ? _h[k + 2][k - 1] : 0.0);                              x = Math.Abs(p) + Math.Abs(q) + Math.Abs(r);                              if(x != 0.0)                              {                                  p = p / x;                                  q = q / x;                                  r = r / x;                              }                          }                            if(x == 0.0)                          {                              break;                          }                            s = Math.Sqrt((p * p) + (q * q) + (r * r));                          if(p < 0)                          {                              s = -s;                          }                            if(s != 0.0)                          {                              if(k != m)                              {                                  _h[k][k - 1] = (-s) * x;                              }                              else if(l != m)                              {                                  _h[k][k - 1] = -_h[k][k - 1];                              }                                p = p + s;                              x = p / s;                              y = q / s;                              z = r / s;                              q = q / p;                              r = r / p;                                /* Row modification */                                for(int j = k; j < nn; j++)                              {                                  p = _h[k][j] + (q * _h[k + 1][j]);                                    if(notlast)                                  {                                      p = p + (r * _h[k + 2][j]);                                      _h[k + 2][j] = _h[k + 2][j] - (p * z);                                  }                                    _h[k][j] = _h[k][j] - (p * x);                                  _h[k + 1][j] = _h[k + 1][j] - (p * y);                              }                                /* Column modification */                                for(int i = 0; i <= Math.Min(n' k + 3); i++)                              {                                  double[] hi = _h[i];                                  p = (x * hi[k]) + (y * hi[k + 1]);                                    if(notlast)                                  {                                      p = p + (z * hi[k + 2]);                                      hi[k + 2] = hi[k + 2] - (p * r);                                  }                                    hi[k] = hi[k] - p;                                  hi[k + 1] = hi[k + 1] - (p * q);                              }                                /* Accumulate transformations */                                for(int i = low; i <= high; i++)                              {                                  double[] vi = _v[i];                                  p = (x * vi[k]) + (y * vi[k + 1]);                                    if(notlast)                                  {                                      p = p + (z * vi[k + 2]);                                      vi[k + 2] = vi[k + 2] - (p * r);                                  }                                    vi[k] = vi[k] - p;                                  vi[k + 1] = vi[k + 1] - (p * q);                              }                          } // (s != 0)                      } // k loop                  } // check convergence              }
Magic Number,MathNet.Numerics.LinearAlgebra,EigenvalueDecomposition,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\LinearAlgebra\EigenvalueDecomposition.cs,NonsymmetricReduceHessenberToRealSchur,The following statement contains a magic number: for(n = nn - 1; n >= 0; n--)              {                  p = _d[n];                  q = _e[n];                    /* Real vector */                    double t;                  if(q == 0.0)                  {                      int l = n;                      _h[n][n] = 1.0;                      for(int i = n - 1; i >= 0; i--)                      {                          w = _h[i][i] - p;                          r = 0.0;                          for(int j = l; j <= n; j++)                          {                              r = r + (_h[i][j] * _h[j][n]);                          }                            if(_e[i] < 0.0)                          {                              z = w;                              s = r;                          }                          else                          {                              l = i;                              if(_e[i] == 0.0)                              {                                  if(w != 0.0)                                  {                                      _h[i][n] = (-r) / w;                                  }                                  else                                  {                                      _h[i][n] = (-r) / (eps * norm);                                  }                                    // Solve real equations                              }                              else                              {                                  x = _h[i][i + 1];                                  y = _h[i + 1][i];                                  q = ((_d[i] - p) * (_d[i] - p)) + (_e[i] * _e[i]);                                  t = ((x * s) - (z * r)) / q;                                  _h[i][n] = t;                                  if(Math.Abs(x) > Math.Abs(z))                                  {                                      _h[i + 1][n] = (-r - (w * t)) / x;                                  }                                  else                                  {                                      _h[i + 1][n] = (-s - (y * t)) / z;                                  }                              }                                /* Overflow control */                                t = Math.Abs(_h[i][n]);                              if((eps * t) * t > 1)                              {                                  for(int j = i; j <= n; j++)                                  {                                      _h[j][n] = _h[j][n] / t;                                  }                              }                          }                      }                        // Complex vector                  }                  else if(q < 0)                  {                      int l = n - 1;                        /* Last vector component imaginary so matrix is triangular */                        if(Math.Abs(_h[n][n - 1]) > Math.Abs(_h[n - 1][n]))                      {                          _h[n - 1][n - 1] = q / _h[n][n - 1];                          _h[n - 1][n] = (-(_h[n][n] - p)) / _h[n][n - 1];                      }                      else                      {                          ComplexScalarDivide(0.0' -_h[n - 1][n]' _h[n - 1][n - 1] - p' q);                          _h[n - 1][n - 1] = _cdivr;                          _h[n - 1][n] = _cdivi;                      }                        _h[n][n - 1] = 0.0;                      _h[n][n] = 1.0;                      for(int i = n - 2; i >= 0; i--)                      {                          double ra = 0.0;                          double sa = 0.0;                          for(int j = l; j <= n; j++)                          {                              ra = ra + (_h[i][j] * _h[j][n - 1]);                              sa = sa + (_h[i][j] * _h[j][n]);                          }                            w = _h[i][i] - p;                            if(_e[i] < 0.0)                          {                              z = w;                              r = ra;                              s = sa;                          }                          else                          {                              l = i;                              if(_e[i] == 0.0)                              {                                  ComplexScalarDivide(-ra' -sa' w' q);                                  _h[i][n - 1] = _cdivr;                                  _h[i][n] = _cdivi;                              }                              else                              {                                  /* Solve complex equations */                                    x = _h[i][i + 1];                                  y = _h[i + 1][i];                                                                    double vr = ((_d[i] - p) * (_d[i] - p)) + (_e[i] * _e[i]) - (q * q);                                  double vi = (_d[i] - p) * 2.0 * q;                                  if((vr == 0.0) && (vi == 0.0))                                  {                                      vr = eps * norm * (Math.Abs(w) + Math.Abs(q) + Math.Abs(x) + Math.Abs(y) + Math.Abs(z));                                  }                                    ComplexScalarDivide((x * r) - (z * ra) + (q * sa)' (x * s) - (z * sa) - (q * ra)' vr' vi);                                  _h[i][n - 1] = _cdivr;                                  _h[i][n] = _cdivi;                                  if(Math.Abs(x) > (Math.Abs(z) + Math.Abs(q)))                                  {                                      _h[i + 1][n - 1] = (-ra - (w * _h[i][n - 1]) + (q * _h[i][n])) / x;                                      _h[i + 1][n] = (-sa - (w * _h[i][n]) - (q * _h[i][n - 1])) / x;                                  }                                  else                                  {                                      ComplexScalarDivide(-r - (y * _h[i][n - 1])' -s - (y * _h[i][n])' z' q);                                      _h[i + 1][n - 1] = _cdivr;                                      _h[i + 1][n] = _cdivi;                                  }                              }                                /* Overflow control */                                t = Math.Max(Math.Abs(_h[i][n - 1])' Math.Abs(_h[i][n]));                              if((eps * t) * t > 1)                              {                                  for(int j = i; j <= n; j++)                                  {                                      _h[j][n - 1] = _h[j][n - 1] / t;                                      _h[j][n] = _h[j][n] / t;                                  }                              }                          }                      }                  }              }
Magic Number,MathNet.Numerics.LinearAlgebra,EigenvalueDecomposition,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\LinearAlgebra\EigenvalueDecomposition.cs,NonsymmetricReduceHessenberToRealSchur,The following statement contains a magic number: for(n = nn - 1; n >= 0; n--)              {                  p = _d[n];                  q = _e[n];                    /* Real vector */                    double t;                  if(q == 0.0)                  {                      int l = n;                      _h[n][n] = 1.0;                      for(int i = n - 1; i >= 0; i--)                      {                          w = _h[i][i] - p;                          r = 0.0;                          for(int j = l; j <= n; j++)                          {                              r = r + (_h[i][j] * _h[j][n]);                          }                            if(_e[i] < 0.0)                          {                              z = w;                              s = r;                          }                          else                          {                              l = i;                              if(_e[i] == 0.0)                              {                                  if(w != 0.0)                                  {                                      _h[i][n] = (-r) / w;                                  }                                  else                                  {                                      _h[i][n] = (-r) / (eps * norm);                                  }                                    // Solve real equations                              }                              else                              {                                  x = _h[i][i + 1];                                  y = _h[i + 1][i];                                  q = ((_d[i] - p) * (_d[i] - p)) + (_e[i] * _e[i]);                                  t = ((x * s) - (z * r)) / q;                                  _h[i][n] = t;                                  if(Math.Abs(x) > Math.Abs(z))                                  {                                      _h[i + 1][n] = (-r - (w * t)) / x;                                  }                                  else                                  {                                      _h[i + 1][n] = (-s - (y * t)) / z;                                  }                              }                                /* Overflow control */                                t = Math.Abs(_h[i][n]);                              if((eps * t) * t > 1)                              {                                  for(int j = i; j <= n; j++)                                  {                                      _h[j][n] = _h[j][n] / t;                                  }                              }                          }                      }                        // Complex vector                  }                  else if(q < 0)                  {                      int l = n - 1;                        /* Last vector component imaginary so matrix is triangular */                        if(Math.Abs(_h[n][n - 1]) > Math.Abs(_h[n - 1][n]))                      {                          _h[n - 1][n - 1] = q / _h[n][n - 1];                          _h[n - 1][n] = (-(_h[n][n] - p)) / _h[n][n - 1];                      }                      else                      {                          ComplexScalarDivide(0.0' -_h[n - 1][n]' _h[n - 1][n - 1] - p' q);                          _h[n - 1][n - 1] = _cdivr;                          _h[n - 1][n] = _cdivi;                      }                        _h[n][n - 1] = 0.0;                      _h[n][n] = 1.0;                      for(int i = n - 2; i >= 0; i--)                      {                          double ra = 0.0;                          double sa = 0.0;                          for(int j = l; j <= n; j++)                          {                              ra = ra + (_h[i][j] * _h[j][n - 1]);                              sa = sa + (_h[i][j] * _h[j][n]);                          }                            w = _h[i][i] - p;                            if(_e[i] < 0.0)                          {                              z = w;                              r = ra;                              s = sa;                          }                          else                          {                              l = i;                              if(_e[i] == 0.0)                              {                                  ComplexScalarDivide(-ra' -sa' w' q);                                  _h[i][n - 1] = _cdivr;                                  _h[i][n] = _cdivi;                              }                              else                              {                                  /* Solve complex equations */                                    x = _h[i][i + 1];                                  y = _h[i + 1][i];                                                                    double vr = ((_d[i] - p) * (_d[i] - p)) + (_e[i] * _e[i]) - (q * q);                                  double vi = (_d[i] - p) * 2.0 * q;                                  if((vr == 0.0) && (vi == 0.0))                                  {                                      vr = eps * norm * (Math.Abs(w) + Math.Abs(q) + Math.Abs(x) + Math.Abs(y) + Math.Abs(z));                                  }                                    ComplexScalarDivide((x * r) - (z * ra) + (q * sa)' (x * s) - (z * sa) - (q * ra)' vr' vi);                                  _h[i][n - 1] = _cdivr;                                  _h[i][n] = _cdivi;                                  if(Math.Abs(x) > (Math.Abs(z) + Math.Abs(q)))                                  {                                      _h[i + 1][n - 1] = (-ra - (w * _h[i][n - 1]) + (q * _h[i][n])) / x;                                      _h[i + 1][n] = (-sa - (w * _h[i][n]) - (q * _h[i][n - 1])) / x;                                  }                                  else                                  {                                      ComplexScalarDivide(-r - (y * _h[i][n - 1])' -s - (y * _h[i][n])' z' q);                                      _h[i + 1][n - 1] = _cdivr;                                      _h[i + 1][n] = _cdivi;                                  }                              }                                /* Overflow control */                                t = Math.Max(Math.Abs(_h[i][n - 1])' Math.Abs(_h[i][n]));                              if((eps * t) * t > 1)                              {                                  for(int j = i; j <= n; j++)                                  {                                      _h[j][n - 1] = _h[j][n - 1] / t;                                      _h[j][n] = _h[j][n] / t;                                  }                              }                          }                      }                  }              }
Magic Number,MathNet.Numerics.LinearAlgebra,Matrix,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\LinearAlgebra\Matrix.cs,SolveRobust,The following statement contains a magic number: const double Eta = 1.0e-12;
Magic Number,MathNet.Numerics.LinearAlgebra,Matrix,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\LinearAlgebra\Matrix.cs,SolveRobust,The following statement contains a magic number: const double Epsilon = 1.0e-6;
Magic Number,MathNet.Numerics.LinearAlgebra,Matrix,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\LinearAlgebra\Matrix.cs,SolveRobust,The following statement contains a magic number: const int MaxIteration = 100;
Magic Number,MathNet.Numerics.LinearAlgebra,Matrix,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\LinearAlgebra\Matrix.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  int result = _rowCount;                  result = (result * 397) ^ _columnCount;                  result = (result * 397) ^ _data.GetHashCode();                  return result;              }
Magic Number,MathNet.Numerics.LinearAlgebra,Matrix,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\LinearAlgebra\Matrix.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  int result = _rowCount;                  result = (result * 397) ^ _columnCount;                  result = (result * 397) ^ _data.GetHashCode();                  return result;              }
Magic Number,MathNet.Numerics.LinearAlgebra,SingularValueDecomposition,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\LinearAlgebra\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: int nrt = Math.Max(0' Math.Min(_n - 2' _m));
Magic Number,MathNet.Numerics.LinearAlgebra,SingularValueDecomposition,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\LinearAlgebra\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: while(p > 0)              {                  int k;                  IterationStep step;                    /* Here is where a test for too many iterations would go */                    /*                  This section of the program inspects for                  negligible elements in the s and e arrays.  On                  completion the variables kase and k are set as follows.                    DeflateNeglible:  if s[p] and e[k-1] are negligible and k<p                  SplitAtNeglible:  if s[k] is negligible and k<p                  QR:               if e[k-1] is negligible' k<p' and s[k]' ...' s[p] are not negligible.                  Convergence:      if e[p-1] is negligible.                  */                    for(k = p - 2; k >= 0; k--)                  {                      if(Math.Abs(e[k]) <= eps * (Math.Abs(s[k]) + Math.Abs(s[k + 1])))                      {                          e[k] = 0.0;                          break;                      }                  }                    if(k == p - 2)                  {                      step = IterationStep.Convergence;                  }                  else                  {                      int ks;                      for(ks = p - 1; ks >= k; ks--)                      {                          if(ks == k)                          {                              break;                          }                            double t = (ks != p ? Math.Abs(e[ks]) : 0.0) + (ks != k + 1 ? Math.Abs(e[ks - 1]) : 0.0);                          if(Math.Abs(s[ks]) <= eps * t)                          {                              s[ks] = 0.0;                              break;                          }                      }                        if(ks == k)                      {                          step = IterationStep.QR;                      }                      else if(ks == p - 1)                      {                          step = IterationStep.DeflateNeglible;                      }                      else                      {                          step = IterationStep.SplitAtNeglible;                          k = ks;                      }                  }                    k++;                    /* Perform the task indicated by 'step'. */                    switch(step)                  {                      // Deflate negligible s(p).                      case IterationStep.DeflateNeglible:                          {                              double f = e[p - 2];                              e[p - 2] = 0.0;                              for(int j = p - 2; j >= k; j--)                              {                                  double t = Fn.Hypot(s[j]' f);                                  double cs = s[j] / t;                                  double sn = f / t;                                  s[j] = t;                                    if(j != k)                                  {                                      f = (-sn) * e[j - 1];                                      e[j - 1] = cs * e[j - 1];                                  }                                    for(int i = 0; i < _n; i++)                                  {                                      t = (cs * v[i][j]) + (sn * v[i][p - 1]);                                      v[i][p - 1] = ((-sn) * v[i][j]) + (cs * v[i][p - 1]);                                      v[i][j] = t;                                  }                              }                          }                            break;                        // Split at negligible s(k)                      case IterationStep.SplitAtNeglible:                          {                              double f = e[k - 1];                              e[k - 1] = 0.0;                              for(int j = k; j < p; j++)                              {                                  double t = Fn.Hypot(s[j]' f);                                  double cs = s[j] / t;                                  double sn = f / t;                                  s[j] = t;                                  f = (-sn) * e[j];                                  e[j] = cs * e[j];                                    for(int i = 0; i < _m; i++)                                  {                                      t = (cs * u[i][j]) + (sn * u[i][k - 1]);                                      u[i][k - 1] = ((-sn) * u[i][j]) + (cs * u[i][k - 1]);                                      u[i][j] = t;                                  }                              }                          }                            break;                        // Perform one qr step.                      case IterationStep.QR:                          {                              /* Calculate the shift */                                double scale = Math.Max(Math.Max(Math.Max(Math.Max(Math.Abs(s[p - 1])' Math.Abs(s[p - 2]))' Math.Abs(e[p - 2]))' Math.Abs(s[k]))' Math.Abs(e[k]));                              double sp = s[p - 1] / scale;                              double spm1 = s[p - 2] / scale;                              double epm1 = e[p - 2] / scale;                              double sk = s[k] / scale;                              double ek = e[k] / scale;                              double b = (((spm1 + sp) * (spm1 - sp)) + (epm1 * epm1)) / 2.0;                              double c = (sp * epm1) * (sp * epm1);                              double shift = 0.0;                              if((b != 0.0) | (c != 0.0))                              {                                  shift = Math.Sqrt((b * b) + c);                                    if(b < 0.0)                                  {                                      shift = -shift;                                  }                                    shift = c / (b + shift);                              }                                double f = ((sk + sp) * (sk - sp)) + shift;                              double g = sk * ek;                                /* Chase zeros */                                for(int j = k; j < p - 1; j++)                              {                                  double t = Fn.Hypot(f' g);                                  double cs = f / t;                                  double sn = g / t;                                    if(j != k)                                  {                                      e[j - 1] = t;                                  }                                    f = (cs * s[j]) + (sn * e[j]);                                  e[j] = (cs * e[j]) - (sn * s[j]);                                  g = sn * s[j + 1];                                  s[j + 1] = cs * s[j + 1];                                    for(int i = 0; i < _n; i++)                                  {                                      t = (cs * v[i][j]) + (sn * v[i][j + 1]);                                      v[i][j + 1] = ((-sn) * v[i][j]) + (cs * v[i][j + 1]);                                      v[i][j] = t;                                  }                                    t = Fn.Hypot(f' g);                                  cs = f / t;                                  sn = g / t;                                  s[j] = t;                                  f = (cs * e[j]) + (sn * s[j + 1]);                                  s[j + 1] = ((-sn) * e[j]) + (cs * s[j + 1]);                                  g = sn * e[j + 1];                                  e[j + 1] = cs * e[j + 1];                                    if(j < _m - 1)                                  {                                      for(int i = 0; i < _m; i++)                                      {                                          t = (cs * u[i][j]) + (sn * u[i][j + 1]);                                          u[i][j + 1] = ((-sn) * u[i][j]) + (cs * u[i][j + 1]);                                          u[i][j] = t;                                      }                                  }                              }                                e[p - 2] = f;                              iter = iter + 1;                          }                            break;                        // Convergence.                      case IterationStep.Convergence:                          {                              /* Make the singular values positive */                                if(s[k] <= 0.0)                              {                                  s[k] = (s[k] < 0.0 ? -s[k] : 0.0);                                    for(int i = 0; i <= pp; i++)                                  {                                      v[i][k] = -v[i][k];                                  }                              }                                /* Order the singular values */                                while(k < pp)                              {                                  if(s[k] >= s[k + 1])                                  {                                      break;                                  }                                    double t = s[k];                                  s[k] = s[k + 1];                                  s[k + 1] = t;                                    if(k < _n - 1)                                  {                                      for(int i = 0; i < _n; i++)                                      {                                          t = v[i][k + 1];                                          v[i][k + 1] = v[i][k];                                          v[i][k] = t;                                      }                                  }                                    if(k < _m - 1)                                  {                                      for(int i = 0; i < _m; i++)                                      {                                          t = u[i][k + 1];                                          u[i][k + 1] = u[i][k];                                          u[i][k] = t;                                      }                                  }                                    k++;                              }                                iter = 0;                              p--;                          }                            break;                  }              }
Magic Number,MathNet.Numerics.LinearAlgebra,SingularValueDecomposition,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\LinearAlgebra\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: while(p > 0)              {                  int k;                  IterationStep step;                    /* Here is where a test for too many iterations would go */                    /*                  This section of the program inspects for                  negligible elements in the s and e arrays.  On                  completion the variables kase and k are set as follows.                    DeflateNeglible:  if s[p] and e[k-1] are negligible and k<p                  SplitAtNeglible:  if s[k] is negligible and k<p                  QR:               if e[k-1] is negligible' k<p' and s[k]' ...' s[p] are not negligible.                  Convergence:      if e[p-1] is negligible.                  */                    for(k = p - 2; k >= 0; k--)                  {                      if(Math.Abs(e[k]) <= eps * (Math.Abs(s[k]) + Math.Abs(s[k + 1])))                      {                          e[k] = 0.0;                          break;                      }                  }                    if(k == p - 2)                  {                      step = IterationStep.Convergence;                  }                  else                  {                      int ks;                      for(ks = p - 1; ks >= k; ks--)                      {                          if(ks == k)                          {                              break;                          }                            double t = (ks != p ? Math.Abs(e[ks]) : 0.0) + (ks != k + 1 ? Math.Abs(e[ks - 1]) : 0.0);                          if(Math.Abs(s[ks]) <= eps * t)                          {                              s[ks] = 0.0;                              break;                          }                      }                        if(ks == k)                      {                          step = IterationStep.QR;                      }                      else if(ks == p - 1)                      {                          step = IterationStep.DeflateNeglible;                      }                      else                      {                          step = IterationStep.SplitAtNeglible;                          k = ks;                      }                  }                    k++;                    /* Perform the task indicated by 'step'. */                    switch(step)                  {                      // Deflate negligible s(p).                      case IterationStep.DeflateNeglible:                          {                              double f = e[p - 2];                              e[p - 2] = 0.0;                              for(int j = p - 2; j >= k; j--)                              {                                  double t = Fn.Hypot(s[j]' f);                                  double cs = s[j] / t;                                  double sn = f / t;                                  s[j] = t;                                    if(j != k)                                  {                                      f = (-sn) * e[j - 1];                                      e[j - 1] = cs * e[j - 1];                                  }                                    for(int i = 0; i < _n; i++)                                  {                                      t = (cs * v[i][j]) + (sn * v[i][p - 1]);                                      v[i][p - 1] = ((-sn) * v[i][j]) + (cs * v[i][p - 1]);                                      v[i][j] = t;                                  }                              }                          }                            break;                        // Split at negligible s(k)                      case IterationStep.SplitAtNeglible:                          {                              double f = e[k - 1];                              e[k - 1] = 0.0;                              for(int j = k; j < p; j++)                              {                                  double t = Fn.Hypot(s[j]' f);                                  double cs = s[j] / t;                                  double sn = f / t;                                  s[j] = t;                                  f = (-sn) * e[j];                                  e[j] = cs * e[j];                                    for(int i = 0; i < _m; i++)                                  {                                      t = (cs * u[i][j]) + (sn * u[i][k - 1]);                                      u[i][k - 1] = ((-sn) * u[i][j]) + (cs * u[i][k - 1]);                                      u[i][j] = t;                                  }                              }                          }                            break;                        // Perform one qr step.                      case IterationStep.QR:                          {                              /* Calculate the shift */                                double scale = Math.Max(Math.Max(Math.Max(Math.Max(Math.Abs(s[p - 1])' Math.Abs(s[p - 2]))' Math.Abs(e[p - 2]))' Math.Abs(s[k]))' Math.Abs(e[k]));                              double sp = s[p - 1] / scale;                              double spm1 = s[p - 2] / scale;                              double epm1 = e[p - 2] / scale;                              double sk = s[k] / scale;                              double ek = e[k] / scale;                              double b = (((spm1 + sp) * (spm1 - sp)) + (epm1 * epm1)) / 2.0;                              double c = (sp * epm1) * (sp * epm1);                              double shift = 0.0;                              if((b != 0.0) | (c != 0.0))                              {                                  shift = Math.Sqrt((b * b) + c);                                    if(b < 0.0)                                  {                                      shift = -shift;                                  }                                    shift = c / (b + shift);                              }                                double f = ((sk + sp) * (sk - sp)) + shift;                              double g = sk * ek;                                /* Chase zeros */                                for(int j = k; j < p - 1; j++)                              {                                  double t = Fn.Hypot(f' g);                                  double cs = f / t;                                  double sn = g / t;                                    if(j != k)                                  {                                      e[j - 1] = t;                                  }                                    f = (cs * s[j]) + (sn * e[j]);                                  e[j] = (cs * e[j]) - (sn * s[j]);                                  g = sn * s[j + 1];                                  s[j + 1] = cs * s[j + 1];                                    for(int i = 0; i < _n; i++)                                  {                                      t = (cs * v[i][j]) + (sn * v[i][j + 1]);                                      v[i][j + 1] = ((-sn) * v[i][j]) + (cs * v[i][j + 1]);                                      v[i][j] = t;                                  }                                    t = Fn.Hypot(f' g);                                  cs = f / t;                                  sn = g / t;                                  s[j] = t;                                  f = (cs * e[j]) + (sn * s[j + 1]);                                  s[j + 1] = ((-sn) * e[j]) + (cs * s[j + 1]);                                  g = sn * e[j + 1];                                  e[j + 1] = cs * e[j + 1];                                    if(j < _m - 1)                                  {                                      for(int i = 0; i < _m; i++)                                      {                                          t = (cs * u[i][j]) + (sn * u[i][j + 1]);                                          u[i][j + 1] = ((-sn) * u[i][j]) + (cs * u[i][j + 1]);                                          u[i][j] = t;                                      }                                  }                              }                                e[p - 2] = f;                              iter = iter + 1;                          }                            break;                        // Convergence.                      case IterationStep.Convergence:                          {                              /* Make the singular values positive */                                if(s[k] <= 0.0)                              {                                  s[k] = (s[k] < 0.0 ? -s[k] : 0.0);                                    for(int i = 0; i <= pp; i++)                                  {                                      v[i][k] = -v[i][k];                                  }                              }                                /* Order the singular values */                                while(k < pp)                              {                                  if(s[k] >= s[k + 1])                                  {                                      break;                                  }                                    double t = s[k];                                  s[k] = s[k + 1];                                  s[k + 1] = t;                                    if(k < _n - 1)                                  {                                      for(int i = 0; i < _n; i++)                                      {                                          t = v[i][k + 1];                                          v[i][k + 1] = v[i][k];                                          v[i][k] = t;                                      }                                  }                                    if(k < _m - 1)                                  {                                      for(int i = 0; i < _m; i++)                                      {                                          t = u[i][k + 1];                                          u[i][k + 1] = u[i][k];                                          u[i][k] = t;                                      }                                  }                                    k++;                              }                                iter = 0;                              p--;                          }                            break;                  }              }
Magic Number,MathNet.Numerics.LinearAlgebra,SingularValueDecomposition,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\LinearAlgebra\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: while(p > 0)              {                  int k;                  IterationStep step;                    /* Here is where a test for too many iterations would go */                    /*                  This section of the program inspects for                  negligible elements in the s and e arrays.  On                  completion the variables kase and k are set as follows.                    DeflateNeglible:  if s[p] and e[k-1] are negligible and k<p                  SplitAtNeglible:  if s[k] is negligible and k<p                  QR:               if e[k-1] is negligible' k<p' and s[k]' ...' s[p] are not negligible.                  Convergence:      if e[p-1] is negligible.                  */                    for(k = p - 2; k >= 0; k--)                  {                      if(Math.Abs(e[k]) <= eps * (Math.Abs(s[k]) + Math.Abs(s[k + 1])))                      {                          e[k] = 0.0;                          break;                      }                  }                    if(k == p - 2)                  {                      step = IterationStep.Convergence;                  }                  else                  {                      int ks;                      for(ks = p - 1; ks >= k; ks--)                      {                          if(ks == k)                          {                              break;                          }                            double t = (ks != p ? Math.Abs(e[ks]) : 0.0) + (ks != k + 1 ? Math.Abs(e[ks - 1]) : 0.0);                          if(Math.Abs(s[ks]) <= eps * t)                          {                              s[ks] = 0.0;                              break;                          }                      }                        if(ks == k)                      {                          step = IterationStep.QR;                      }                      else if(ks == p - 1)                      {                          step = IterationStep.DeflateNeglible;                      }                      else                      {                          step = IterationStep.SplitAtNeglible;                          k = ks;                      }                  }                    k++;                    /* Perform the task indicated by 'step'. */                    switch(step)                  {                      // Deflate negligible s(p).                      case IterationStep.DeflateNeglible:                          {                              double f = e[p - 2];                              e[p - 2] = 0.0;                              for(int j = p - 2; j >= k; j--)                              {                                  double t = Fn.Hypot(s[j]' f);                                  double cs = s[j] / t;                                  double sn = f / t;                                  s[j] = t;                                    if(j != k)                                  {                                      f = (-sn) * e[j - 1];                                      e[j - 1] = cs * e[j - 1];                                  }                                    for(int i = 0; i < _n; i++)                                  {                                      t = (cs * v[i][j]) + (sn * v[i][p - 1]);                                      v[i][p - 1] = ((-sn) * v[i][j]) + (cs * v[i][p - 1]);                                      v[i][j] = t;                                  }                              }                          }                            break;                        // Split at negligible s(k)                      case IterationStep.SplitAtNeglible:                          {                              double f = e[k - 1];                              e[k - 1] = 0.0;                              for(int j = k; j < p; j++)                              {                                  double t = Fn.Hypot(s[j]' f);                                  double cs = s[j] / t;                                  double sn = f / t;                                  s[j] = t;                                  f = (-sn) * e[j];                                  e[j] = cs * e[j];                                    for(int i = 0; i < _m; i++)                                  {                                      t = (cs * u[i][j]) + (sn * u[i][k - 1]);                                      u[i][k - 1] = ((-sn) * u[i][j]) + (cs * u[i][k - 1]);                                      u[i][j] = t;                                  }                              }                          }                            break;                        // Perform one qr step.                      case IterationStep.QR:                          {                              /* Calculate the shift */                                double scale = Math.Max(Math.Max(Math.Max(Math.Max(Math.Abs(s[p - 1])' Math.Abs(s[p - 2]))' Math.Abs(e[p - 2]))' Math.Abs(s[k]))' Math.Abs(e[k]));                              double sp = s[p - 1] / scale;                              double spm1 = s[p - 2] / scale;                              double epm1 = e[p - 2] / scale;                              double sk = s[k] / scale;                              double ek = e[k] / scale;                              double b = (((spm1 + sp) * (spm1 - sp)) + (epm1 * epm1)) / 2.0;                              double c = (sp * epm1) * (sp * epm1);                              double shift = 0.0;                              if((b != 0.0) | (c != 0.0))                              {                                  shift = Math.Sqrt((b * b) + c);                                    if(b < 0.0)                                  {                                      shift = -shift;                                  }                                    shift = c / (b + shift);                              }                                double f = ((sk + sp) * (sk - sp)) + shift;                              double g = sk * ek;                                /* Chase zeros */                                for(int j = k; j < p - 1; j++)                              {                                  double t = Fn.Hypot(f' g);                                  double cs = f / t;                                  double sn = g / t;                                    if(j != k)                                  {                                      e[j - 1] = t;                                  }                                    f = (cs * s[j]) + (sn * e[j]);                                  e[j] = (cs * e[j]) - (sn * s[j]);                                  g = sn * s[j + 1];                                  s[j + 1] = cs * s[j + 1];                                    for(int i = 0; i < _n; i++)                                  {                                      t = (cs * v[i][j]) + (sn * v[i][j + 1]);                                      v[i][j + 1] = ((-sn) * v[i][j]) + (cs * v[i][j + 1]);                                      v[i][j] = t;                                  }                                    t = Fn.Hypot(f' g);                                  cs = f / t;                                  sn = g / t;                                  s[j] = t;                                  f = (cs * e[j]) + (sn * s[j + 1]);                                  s[j + 1] = ((-sn) * e[j]) + (cs * s[j + 1]);                                  g = sn * e[j + 1];                                  e[j + 1] = cs * e[j + 1];                                    if(j < _m - 1)                                  {                                      for(int i = 0; i < _m; i++)                                      {                                          t = (cs * u[i][j]) + (sn * u[i][j + 1]);                                          u[i][j + 1] = ((-sn) * u[i][j]) + (cs * u[i][j + 1]);                                          u[i][j] = t;                                      }                                  }                              }                                e[p - 2] = f;                              iter = iter + 1;                          }                            break;                        // Convergence.                      case IterationStep.Convergence:                          {                              /* Make the singular values positive */                                if(s[k] <= 0.0)                              {                                  s[k] = (s[k] < 0.0 ? -s[k] : 0.0);                                    for(int i = 0; i <= pp; i++)                                  {                                      v[i][k] = -v[i][k];                                  }                              }                                /* Order the singular values */                                while(k < pp)                              {                                  if(s[k] >= s[k + 1])                                  {                                      break;                                  }                                    double t = s[k];                                  s[k] = s[k + 1];                                  s[k + 1] = t;                                    if(k < _n - 1)                                  {                                      for(int i = 0; i < _n; i++)                                      {                                          t = v[i][k + 1];                                          v[i][k + 1] = v[i][k];                                          v[i][k] = t;                                      }                                  }                                    if(k < _m - 1)                                  {                                      for(int i = 0; i < _m; i++)                                      {                                          t = u[i][k + 1];                                          u[i][k + 1] = u[i][k];                                          u[i][k] = t;                                      }                                  }                                    k++;                              }                                iter = 0;                              p--;                          }                            break;                  }              }
Magic Number,MathNet.Numerics.LinearAlgebra,SingularValueDecomposition,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\LinearAlgebra\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: while(p > 0)              {                  int k;                  IterationStep step;                    /* Here is where a test for too many iterations would go */                    /*                  This section of the program inspects for                  negligible elements in the s and e arrays.  On                  completion the variables kase and k are set as follows.                    DeflateNeglible:  if s[p] and e[k-1] are negligible and k<p                  SplitAtNeglible:  if s[k] is negligible and k<p                  QR:               if e[k-1] is negligible' k<p' and s[k]' ...' s[p] are not negligible.                  Convergence:      if e[p-1] is negligible.                  */                    for(k = p - 2; k >= 0; k--)                  {                      if(Math.Abs(e[k]) <= eps * (Math.Abs(s[k]) + Math.Abs(s[k + 1])))                      {                          e[k] = 0.0;                          break;                      }                  }                    if(k == p - 2)                  {                      step = IterationStep.Convergence;                  }                  else                  {                      int ks;                      for(ks = p - 1; ks >= k; ks--)                      {                          if(ks == k)                          {                              break;                          }                            double t = (ks != p ? Math.Abs(e[ks]) : 0.0) + (ks != k + 1 ? Math.Abs(e[ks - 1]) : 0.0);                          if(Math.Abs(s[ks]) <= eps * t)                          {                              s[ks] = 0.0;                              break;                          }                      }                        if(ks == k)                      {                          step = IterationStep.QR;                      }                      else if(ks == p - 1)                      {                          step = IterationStep.DeflateNeglible;                      }                      else                      {                          step = IterationStep.SplitAtNeglible;                          k = ks;                      }                  }                    k++;                    /* Perform the task indicated by 'step'. */                    switch(step)                  {                      // Deflate negligible s(p).                      case IterationStep.DeflateNeglible:                          {                              double f = e[p - 2];                              e[p - 2] = 0.0;                              for(int j = p - 2; j >= k; j--)                              {                                  double t = Fn.Hypot(s[j]' f);                                  double cs = s[j] / t;                                  double sn = f / t;                                  s[j] = t;                                    if(j != k)                                  {                                      f = (-sn) * e[j - 1];                                      e[j - 1] = cs * e[j - 1];                                  }                                    for(int i = 0; i < _n; i++)                                  {                                      t = (cs * v[i][j]) + (sn * v[i][p - 1]);                                      v[i][p - 1] = ((-sn) * v[i][j]) + (cs * v[i][p - 1]);                                      v[i][j] = t;                                  }                              }                          }                            break;                        // Split at negligible s(k)                      case IterationStep.SplitAtNeglible:                          {                              double f = e[k - 1];                              e[k - 1] = 0.0;                              for(int j = k; j < p; j++)                              {                                  double t = Fn.Hypot(s[j]' f);                                  double cs = s[j] / t;                                  double sn = f / t;                                  s[j] = t;                                  f = (-sn) * e[j];                                  e[j] = cs * e[j];                                    for(int i = 0; i < _m; i++)                                  {                                      t = (cs * u[i][j]) + (sn * u[i][k - 1]);                                      u[i][k - 1] = ((-sn) * u[i][j]) + (cs * u[i][k - 1]);                                      u[i][j] = t;                                  }                              }                          }                            break;                        // Perform one qr step.                      case IterationStep.QR:                          {                              /* Calculate the shift */                                double scale = Math.Max(Math.Max(Math.Max(Math.Max(Math.Abs(s[p - 1])' Math.Abs(s[p - 2]))' Math.Abs(e[p - 2]))' Math.Abs(s[k]))' Math.Abs(e[k]));                              double sp = s[p - 1] / scale;                              double spm1 = s[p - 2] / scale;                              double epm1 = e[p - 2] / scale;                              double sk = s[k] / scale;                              double ek = e[k] / scale;                              double b = (((spm1 + sp) * (spm1 - sp)) + (epm1 * epm1)) / 2.0;                              double c = (sp * epm1) * (sp * epm1);                              double shift = 0.0;                              if((b != 0.0) | (c != 0.0))                              {                                  shift = Math.Sqrt((b * b) + c);                                    if(b < 0.0)                                  {                                      shift = -shift;                                  }                                    shift = c / (b + shift);                              }                                double f = ((sk + sp) * (sk - sp)) + shift;                              double g = sk * ek;                                /* Chase zeros */                                for(int j = k; j < p - 1; j++)                              {                                  double t = Fn.Hypot(f' g);                                  double cs = f / t;                                  double sn = g / t;                                    if(j != k)                                  {                                      e[j - 1] = t;                                  }                                    f = (cs * s[j]) + (sn * e[j]);                                  e[j] = (cs * e[j]) - (sn * s[j]);                                  g = sn * s[j + 1];                                  s[j + 1] = cs * s[j + 1];                                    for(int i = 0; i < _n; i++)                                  {                                      t = (cs * v[i][j]) + (sn * v[i][j + 1]);                                      v[i][j + 1] = ((-sn) * v[i][j]) + (cs * v[i][j + 1]);                                      v[i][j] = t;                                  }                                    t = Fn.Hypot(f' g);                                  cs = f / t;                                  sn = g / t;                                  s[j] = t;                                  f = (cs * e[j]) + (sn * s[j + 1]);                                  s[j + 1] = ((-sn) * e[j]) + (cs * s[j + 1]);                                  g = sn * e[j + 1];                                  e[j + 1] = cs * e[j + 1];                                    if(j < _m - 1)                                  {                                      for(int i = 0; i < _m; i++)                                      {                                          t = (cs * u[i][j]) + (sn * u[i][j + 1]);                                          u[i][j + 1] = ((-sn) * u[i][j]) + (cs * u[i][j + 1]);                                          u[i][j] = t;                                      }                                  }                              }                                e[p - 2] = f;                              iter = iter + 1;                          }                            break;                        // Convergence.                      case IterationStep.Convergence:                          {                              /* Make the singular values positive */                                if(s[k] <= 0.0)                              {                                  s[k] = (s[k] < 0.0 ? -s[k] : 0.0);                                    for(int i = 0; i <= pp; i++)                                  {                                      v[i][k] = -v[i][k];                                  }                              }                                /* Order the singular values */                                while(k < pp)                              {                                  if(s[k] >= s[k + 1])                                  {                                      break;                                  }                                    double t = s[k];                                  s[k] = s[k + 1];                                  s[k + 1] = t;                                    if(k < _n - 1)                                  {                                      for(int i = 0; i < _n; i++)                                      {                                          t = v[i][k + 1];                                          v[i][k + 1] = v[i][k];                                          v[i][k] = t;                                      }                                  }                                    if(k < _m - 1)                                  {                                      for(int i = 0; i < _m; i++)                                      {                                          t = u[i][k + 1];                                          u[i][k + 1] = u[i][k];                                          u[i][k] = t;                                      }                                  }                                    k++;                              }                                iter = 0;                              p--;                          }                            break;                  }              }
Magic Number,MathNet.Numerics.LinearAlgebra,SingularValueDecomposition,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\LinearAlgebra\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: while(p > 0)              {                  int k;                  IterationStep step;                    /* Here is where a test for too many iterations would go */                    /*                  This section of the program inspects for                  negligible elements in the s and e arrays.  On                  completion the variables kase and k are set as follows.                    DeflateNeglible:  if s[p] and e[k-1] are negligible and k<p                  SplitAtNeglible:  if s[k] is negligible and k<p                  QR:               if e[k-1] is negligible' k<p' and s[k]' ...' s[p] are not negligible.                  Convergence:      if e[p-1] is negligible.                  */                    for(k = p - 2; k >= 0; k--)                  {                      if(Math.Abs(e[k]) <= eps * (Math.Abs(s[k]) + Math.Abs(s[k + 1])))                      {                          e[k] = 0.0;                          break;                      }                  }                    if(k == p - 2)                  {                      step = IterationStep.Convergence;                  }                  else                  {                      int ks;                      for(ks = p - 1; ks >= k; ks--)                      {                          if(ks == k)                          {                              break;                          }                            double t = (ks != p ? Math.Abs(e[ks]) : 0.0) + (ks != k + 1 ? Math.Abs(e[ks - 1]) : 0.0);                          if(Math.Abs(s[ks]) <= eps * t)                          {                              s[ks] = 0.0;                              break;                          }                      }                        if(ks == k)                      {                          step = IterationStep.QR;                      }                      else if(ks == p - 1)                      {                          step = IterationStep.DeflateNeglible;                      }                      else                      {                          step = IterationStep.SplitAtNeglible;                          k = ks;                      }                  }                    k++;                    /* Perform the task indicated by 'step'. */                    switch(step)                  {                      // Deflate negligible s(p).                      case IterationStep.DeflateNeglible:                          {                              double f = e[p - 2];                              e[p - 2] = 0.0;                              for(int j = p - 2; j >= k; j--)                              {                                  double t = Fn.Hypot(s[j]' f);                                  double cs = s[j] / t;                                  double sn = f / t;                                  s[j] = t;                                    if(j != k)                                  {                                      f = (-sn) * e[j - 1];                                      e[j - 1] = cs * e[j - 1];                                  }                                    for(int i = 0; i < _n; i++)                                  {                                      t = (cs * v[i][j]) + (sn * v[i][p - 1]);                                      v[i][p - 1] = ((-sn) * v[i][j]) + (cs * v[i][p - 1]);                                      v[i][j] = t;                                  }                              }                          }                            break;                        // Split at negligible s(k)                      case IterationStep.SplitAtNeglible:                          {                              double f = e[k - 1];                              e[k - 1] = 0.0;                              for(int j = k; j < p; j++)                              {                                  double t = Fn.Hypot(s[j]' f);                                  double cs = s[j] / t;                                  double sn = f / t;                                  s[j] = t;                                  f = (-sn) * e[j];                                  e[j] = cs * e[j];                                    for(int i = 0; i < _m; i++)                                  {                                      t = (cs * u[i][j]) + (sn * u[i][k - 1]);                                      u[i][k - 1] = ((-sn) * u[i][j]) + (cs * u[i][k - 1]);                                      u[i][j] = t;                                  }                              }                          }                            break;                        // Perform one qr step.                      case IterationStep.QR:                          {                              /* Calculate the shift */                                double scale = Math.Max(Math.Max(Math.Max(Math.Max(Math.Abs(s[p - 1])' Math.Abs(s[p - 2]))' Math.Abs(e[p - 2]))' Math.Abs(s[k]))' Math.Abs(e[k]));                              double sp = s[p - 1] / scale;                              double spm1 = s[p - 2] / scale;                              double epm1 = e[p - 2] / scale;                              double sk = s[k] / scale;                              double ek = e[k] / scale;                              double b = (((spm1 + sp) * (spm1 - sp)) + (epm1 * epm1)) / 2.0;                              double c = (sp * epm1) * (sp * epm1);                              double shift = 0.0;                              if((b != 0.0) | (c != 0.0))                              {                                  shift = Math.Sqrt((b * b) + c);                                    if(b < 0.0)                                  {                                      shift = -shift;                                  }                                    shift = c / (b + shift);                              }                                double f = ((sk + sp) * (sk - sp)) + shift;                              double g = sk * ek;                                /* Chase zeros */                                for(int j = k; j < p - 1; j++)                              {                                  double t = Fn.Hypot(f' g);                                  double cs = f / t;                                  double sn = g / t;                                    if(j != k)                                  {                                      e[j - 1] = t;                                  }                                    f = (cs * s[j]) + (sn * e[j]);                                  e[j] = (cs * e[j]) - (sn * s[j]);                                  g = sn * s[j + 1];                                  s[j + 1] = cs * s[j + 1];                                    for(int i = 0; i < _n; i++)                                  {                                      t = (cs * v[i][j]) + (sn * v[i][j + 1]);                                      v[i][j + 1] = ((-sn) * v[i][j]) + (cs * v[i][j + 1]);                                      v[i][j] = t;                                  }                                    t = Fn.Hypot(f' g);                                  cs = f / t;                                  sn = g / t;                                  s[j] = t;                                  f = (cs * e[j]) + (sn * s[j + 1]);                                  s[j + 1] = ((-sn) * e[j]) + (cs * s[j + 1]);                                  g = sn * e[j + 1];                                  e[j + 1] = cs * e[j + 1];                                    if(j < _m - 1)                                  {                                      for(int i = 0; i < _m; i++)                                      {                                          t = (cs * u[i][j]) + (sn * u[i][j + 1]);                                          u[i][j + 1] = ((-sn) * u[i][j]) + (cs * u[i][j + 1]);                                          u[i][j] = t;                                      }                                  }                              }                                e[p - 2] = f;                              iter = iter + 1;                          }                            break;                        // Convergence.                      case IterationStep.Convergence:                          {                              /* Make the singular values positive */                                if(s[k] <= 0.0)                              {                                  s[k] = (s[k] < 0.0 ? -s[k] : 0.0);                                    for(int i = 0; i <= pp; i++)                                  {                                      v[i][k] = -v[i][k];                                  }                              }                                /* Order the singular values */                                while(k < pp)                              {                                  if(s[k] >= s[k + 1])                                  {                                      break;                                  }                                    double t = s[k];                                  s[k] = s[k + 1];                                  s[k + 1] = t;                                    if(k < _n - 1)                                  {                                      for(int i = 0; i < _n; i++)                                      {                                          t = v[i][k + 1];                                          v[i][k + 1] = v[i][k];                                          v[i][k] = t;                                      }                                  }                                    if(k < _m - 1)                                  {                                      for(int i = 0; i < _m; i++)                                      {                                          t = u[i][k + 1];                                          u[i][k + 1] = u[i][k];                                          u[i][k] = t;                                      }                                  }                                    k++;                              }                                iter = 0;                              p--;                          }                            break;                  }              }
Magic Number,MathNet.Numerics.LinearAlgebra,SingularValueDecomposition,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\LinearAlgebra\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: while(p > 0)              {                  int k;                  IterationStep step;                    /* Here is where a test for too many iterations would go */                    /*                  This section of the program inspects for                  negligible elements in the s and e arrays.  On                  completion the variables kase and k are set as follows.                    DeflateNeglible:  if s[p] and e[k-1] are negligible and k<p                  SplitAtNeglible:  if s[k] is negligible and k<p                  QR:               if e[k-1] is negligible' k<p' and s[k]' ...' s[p] are not negligible.                  Convergence:      if e[p-1] is negligible.                  */                    for(k = p - 2; k >= 0; k--)                  {                      if(Math.Abs(e[k]) <= eps * (Math.Abs(s[k]) + Math.Abs(s[k + 1])))                      {                          e[k] = 0.0;                          break;                      }                  }                    if(k == p - 2)                  {                      step = IterationStep.Convergence;                  }                  else                  {                      int ks;                      for(ks = p - 1; ks >= k; ks--)                      {                          if(ks == k)                          {                              break;                          }                            double t = (ks != p ? Math.Abs(e[ks]) : 0.0) + (ks != k + 1 ? Math.Abs(e[ks - 1]) : 0.0);                          if(Math.Abs(s[ks]) <= eps * t)                          {                              s[ks] = 0.0;                              break;                          }                      }                        if(ks == k)                      {                          step = IterationStep.QR;                      }                      else if(ks == p - 1)                      {                          step = IterationStep.DeflateNeglible;                      }                      else                      {                          step = IterationStep.SplitAtNeglible;                          k = ks;                      }                  }                    k++;                    /* Perform the task indicated by 'step'. */                    switch(step)                  {                      // Deflate negligible s(p).                      case IterationStep.DeflateNeglible:                          {                              double f = e[p - 2];                              e[p - 2] = 0.0;                              for(int j = p - 2; j >= k; j--)                              {                                  double t = Fn.Hypot(s[j]' f);                                  double cs = s[j] / t;                                  double sn = f / t;                                  s[j] = t;                                    if(j != k)                                  {                                      f = (-sn) * e[j - 1];                                      e[j - 1] = cs * e[j - 1];                                  }                                    for(int i = 0; i < _n; i++)                                  {                                      t = (cs * v[i][j]) + (sn * v[i][p - 1]);                                      v[i][p - 1] = ((-sn) * v[i][j]) + (cs * v[i][p - 1]);                                      v[i][j] = t;                                  }                              }                          }                            break;                        // Split at negligible s(k)                      case IterationStep.SplitAtNeglible:                          {                              double f = e[k - 1];                              e[k - 1] = 0.0;                              for(int j = k; j < p; j++)                              {                                  double t = Fn.Hypot(s[j]' f);                                  double cs = s[j] / t;                                  double sn = f / t;                                  s[j] = t;                                  f = (-sn) * e[j];                                  e[j] = cs * e[j];                                    for(int i = 0; i < _m; i++)                                  {                                      t = (cs * u[i][j]) + (sn * u[i][k - 1]);                                      u[i][k - 1] = ((-sn) * u[i][j]) + (cs * u[i][k - 1]);                                      u[i][j] = t;                                  }                              }                          }                            break;                        // Perform one qr step.                      case IterationStep.QR:                          {                              /* Calculate the shift */                                double scale = Math.Max(Math.Max(Math.Max(Math.Max(Math.Abs(s[p - 1])' Math.Abs(s[p - 2]))' Math.Abs(e[p - 2]))' Math.Abs(s[k]))' Math.Abs(e[k]));                              double sp = s[p - 1] / scale;                              double spm1 = s[p - 2] / scale;                              double epm1 = e[p - 2] / scale;                              double sk = s[k] / scale;                              double ek = e[k] / scale;                              double b = (((spm1 + sp) * (spm1 - sp)) + (epm1 * epm1)) / 2.0;                              double c = (sp * epm1) * (sp * epm1);                              double shift = 0.0;                              if((b != 0.0) | (c != 0.0))                              {                                  shift = Math.Sqrt((b * b) + c);                                    if(b < 0.0)                                  {                                      shift = -shift;                                  }                                    shift = c / (b + shift);                              }                                double f = ((sk + sp) * (sk - sp)) + shift;                              double g = sk * ek;                                /* Chase zeros */                                for(int j = k; j < p - 1; j++)                              {                                  double t = Fn.Hypot(f' g);                                  double cs = f / t;                                  double sn = g / t;                                    if(j != k)                                  {                                      e[j - 1] = t;                                  }                                    f = (cs * s[j]) + (sn * e[j]);                                  e[j] = (cs * e[j]) - (sn * s[j]);                                  g = sn * s[j + 1];                                  s[j + 1] = cs * s[j + 1];                                    for(int i = 0; i < _n; i++)                                  {                                      t = (cs * v[i][j]) + (sn * v[i][j + 1]);                                      v[i][j + 1] = ((-sn) * v[i][j]) + (cs * v[i][j + 1]);                                      v[i][j] = t;                                  }                                    t = Fn.Hypot(f' g);                                  cs = f / t;                                  sn = g / t;                                  s[j] = t;                                  f = (cs * e[j]) + (sn * s[j + 1]);                                  s[j + 1] = ((-sn) * e[j]) + (cs * s[j + 1]);                                  g = sn * e[j + 1];                                  e[j + 1] = cs * e[j + 1];                                    if(j < _m - 1)                                  {                                      for(int i = 0; i < _m; i++)                                      {                                          t = (cs * u[i][j]) + (sn * u[i][j + 1]);                                          u[i][j + 1] = ((-sn) * u[i][j]) + (cs * u[i][j + 1]);                                          u[i][j] = t;                                      }                                  }                              }                                e[p - 2] = f;                              iter = iter + 1;                          }                            break;                        // Convergence.                      case IterationStep.Convergence:                          {                              /* Make the singular values positive */                                if(s[k] <= 0.0)                              {                                  s[k] = (s[k] < 0.0 ? -s[k] : 0.0);                                    for(int i = 0; i <= pp; i++)                                  {                                      v[i][k] = -v[i][k];                                  }                              }                                /* Order the singular values */                                while(k < pp)                              {                                  if(s[k] >= s[k + 1])                                  {                                      break;                                  }                                    double t = s[k];                                  s[k] = s[k + 1];                                  s[k + 1] = t;                                    if(k < _n - 1)                                  {                                      for(int i = 0; i < _n; i++)                                      {                                          t = v[i][k + 1];                                          v[i][k + 1] = v[i][k];                                          v[i][k] = t;                                      }                                  }                                    if(k < _m - 1)                                  {                                      for(int i = 0; i < _m; i++)                                      {                                          t = u[i][k + 1];                                          u[i][k + 1] = u[i][k];                                          u[i][k] = t;                                      }                                  }                                    k++;                              }                                iter = 0;                              p--;                          }                            break;                  }              }
Magic Number,MathNet.Numerics.LinearAlgebra,SingularValueDecomposition,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\LinearAlgebra\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: while(p > 0)              {                  int k;                  IterationStep step;                    /* Here is where a test for too many iterations would go */                    /*                  This section of the program inspects for                  negligible elements in the s and e arrays.  On                  completion the variables kase and k are set as follows.                    DeflateNeglible:  if s[p] and e[k-1] are negligible and k<p                  SplitAtNeglible:  if s[k] is negligible and k<p                  QR:               if e[k-1] is negligible' k<p' and s[k]' ...' s[p] are not negligible.                  Convergence:      if e[p-1] is negligible.                  */                    for(k = p - 2; k >= 0; k--)                  {                      if(Math.Abs(e[k]) <= eps * (Math.Abs(s[k]) + Math.Abs(s[k + 1])))                      {                          e[k] = 0.0;                          break;                      }                  }                    if(k == p - 2)                  {                      step = IterationStep.Convergence;                  }                  else                  {                      int ks;                      for(ks = p - 1; ks >= k; ks--)                      {                          if(ks == k)                          {                              break;                          }                            double t = (ks != p ? Math.Abs(e[ks]) : 0.0) + (ks != k + 1 ? Math.Abs(e[ks - 1]) : 0.0);                          if(Math.Abs(s[ks]) <= eps * t)                          {                              s[ks] = 0.0;                              break;                          }                      }                        if(ks == k)                      {                          step = IterationStep.QR;                      }                      else if(ks == p - 1)                      {                          step = IterationStep.DeflateNeglible;                      }                      else                      {                          step = IterationStep.SplitAtNeglible;                          k = ks;                      }                  }                    k++;                    /* Perform the task indicated by 'step'. */                    switch(step)                  {                      // Deflate negligible s(p).                      case IterationStep.DeflateNeglible:                          {                              double f = e[p - 2];                              e[p - 2] = 0.0;                              for(int j = p - 2; j >= k; j--)                              {                                  double t = Fn.Hypot(s[j]' f);                                  double cs = s[j] / t;                                  double sn = f / t;                                  s[j] = t;                                    if(j != k)                                  {                                      f = (-sn) * e[j - 1];                                      e[j - 1] = cs * e[j - 1];                                  }                                    for(int i = 0; i < _n; i++)                                  {                                      t = (cs * v[i][j]) + (sn * v[i][p - 1]);                                      v[i][p - 1] = ((-sn) * v[i][j]) + (cs * v[i][p - 1]);                                      v[i][j] = t;                                  }                              }                          }                            break;                        // Split at negligible s(k)                      case IterationStep.SplitAtNeglible:                          {                              double f = e[k - 1];                              e[k - 1] = 0.0;                              for(int j = k; j < p; j++)                              {                                  double t = Fn.Hypot(s[j]' f);                                  double cs = s[j] / t;                                  double sn = f / t;                                  s[j] = t;                                  f = (-sn) * e[j];                                  e[j] = cs * e[j];                                    for(int i = 0; i < _m; i++)                                  {                                      t = (cs * u[i][j]) + (sn * u[i][k - 1]);                                      u[i][k - 1] = ((-sn) * u[i][j]) + (cs * u[i][k - 1]);                                      u[i][j] = t;                                  }                              }                          }                            break;                        // Perform one qr step.                      case IterationStep.QR:                          {                              /* Calculate the shift */                                double scale = Math.Max(Math.Max(Math.Max(Math.Max(Math.Abs(s[p - 1])' Math.Abs(s[p - 2]))' Math.Abs(e[p - 2]))' Math.Abs(s[k]))' Math.Abs(e[k]));                              double sp = s[p - 1] / scale;                              double spm1 = s[p - 2] / scale;                              double epm1 = e[p - 2] / scale;                              double sk = s[k] / scale;                              double ek = e[k] / scale;                              double b = (((spm1 + sp) * (spm1 - sp)) + (epm1 * epm1)) / 2.0;                              double c = (sp * epm1) * (sp * epm1);                              double shift = 0.0;                              if((b != 0.0) | (c != 0.0))                              {                                  shift = Math.Sqrt((b * b) + c);                                    if(b < 0.0)                                  {                                      shift = -shift;                                  }                                    shift = c / (b + shift);                              }                                double f = ((sk + sp) * (sk - sp)) + shift;                              double g = sk * ek;                                /* Chase zeros */                                for(int j = k; j < p - 1; j++)                              {                                  double t = Fn.Hypot(f' g);                                  double cs = f / t;                                  double sn = g / t;                                    if(j != k)                                  {                                      e[j - 1] = t;                                  }                                    f = (cs * s[j]) + (sn * e[j]);                                  e[j] = (cs * e[j]) - (sn * s[j]);                                  g = sn * s[j + 1];                                  s[j + 1] = cs * s[j + 1];                                    for(int i = 0; i < _n; i++)                                  {                                      t = (cs * v[i][j]) + (sn * v[i][j + 1]);                                      v[i][j + 1] = ((-sn) * v[i][j]) + (cs * v[i][j + 1]);                                      v[i][j] = t;                                  }                                    t = Fn.Hypot(f' g);                                  cs = f / t;                                  sn = g / t;                                  s[j] = t;                                  f = (cs * e[j]) + (sn * s[j + 1]);                                  s[j + 1] = ((-sn) * e[j]) + (cs * s[j + 1]);                                  g = sn * e[j + 1];                                  e[j + 1] = cs * e[j + 1];                                    if(j < _m - 1)                                  {                                      for(int i = 0; i < _m; i++)                                      {                                          t = (cs * u[i][j]) + (sn * u[i][j + 1]);                                          u[i][j + 1] = ((-sn) * u[i][j]) + (cs * u[i][j + 1]);                                          u[i][j] = t;                                      }                                  }                              }                                e[p - 2] = f;                              iter = iter + 1;                          }                            break;                        // Convergence.                      case IterationStep.Convergence:                          {                              /* Make the singular values positive */                                if(s[k] <= 0.0)                              {                                  s[k] = (s[k] < 0.0 ? -s[k] : 0.0);                                    for(int i = 0; i <= pp; i++)                                  {                                      v[i][k] = -v[i][k];                                  }                              }                                /* Order the singular values */                                while(k < pp)                              {                                  if(s[k] >= s[k + 1])                                  {                                      break;                                  }                                    double t = s[k];                                  s[k] = s[k + 1];                                  s[k + 1] = t;                                    if(k < _n - 1)                                  {                                      for(int i = 0; i < _n; i++)                                      {                                          t = v[i][k + 1];                                          v[i][k + 1] = v[i][k];                                          v[i][k] = t;                                      }                                  }                                    if(k < _m - 1)                                  {                                      for(int i = 0; i < _m; i++)                                      {                                          t = u[i][k + 1];                                          u[i][k + 1] = u[i][k];                                          u[i][k] = t;                                      }                                  }                                    k++;                              }                                iter = 0;                              p--;                          }                            break;                  }              }
Magic Number,MathNet.Numerics.LinearAlgebra,SingularValueDecomposition,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\LinearAlgebra\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: while(p > 0)              {                  int k;                  IterationStep step;                    /* Here is where a test for too many iterations would go */                    /*                  This section of the program inspects for                  negligible elements in the s and e arrays.  On                  completion the variables kase and k are set as follows.                    DeflateNeglible:  if s[p] and e[k-1] are negligible and k<p                  SplitAtNeglible:  if s[k] is negligible and k<p                  QR:               if e[k-1] is negligible' k<p' and s[k]' ...' s[p] are not negligible.                  Convergence:      if e[p-1] is negligible.                  */                    for(k = p - 2; k >= 0; k--)                  {                      if(Math.Abs(e[k]) <= eps * (Math.Abs(s[k]) + Math.Abs(s[k + 1])))                      {                          e[k] = 0.0;                          break;                      }                  }                    if(k == p - 2)                  {                      step = IterationStep.Convergence;                  }                  else                  {                      int ks;                      for(ks = p - 1; ks >= k; ks--)                      {                          if(ks == k)                          {                              break;                          }                            double t = (ks != p ? Math.Abs(e[ks]) : 0.0) + (ks != k + 1 ? Math.Abs(e[ks - 1]) : 0.0);                          if(Math.Abs(s[ks]) <= eps * t)                          {                              s[ks] = 0.0;                              break;                          }                      }                        if(ks == k)                      {                          step = IterationStep.QR;                      }                      else if(ks == p - 1)                      {                          step = IterationStep.DeflateNeglible;                      }                      else                      {                          step = IterationStep.SplitAtNeglible;                          k = ks;                      }                  }                    k++;                    /* Perform the task indicated by 'step'. */                    switch(step)                  {                      // Deflate negligible s(p).                      case IterationStep.DeflateNeglible:                          {                              double f = e[p - 2];                              e[p - 2] = 0.0;                              for(int j = p - 2; j >= k; j--)                              {                                  double t = Fn.Hypot(s[j]' f);                                  double cs = s[j] / t;                                  double sn = f / t;                                  s[j] = t;                                    if(j != k)                                  {                                      f = (-sn) * e[j - 1];                                      e[j - 1] = cs * e[j - 1];                                  }                                    for(int i = 0; i < _n; i++)                                  {                                      t = (cs * v[i][j]) + (sn * v[i][p - 1]);                                      v[i][p - 1] = ((-sn) * v[i][j]) + (cs * v[i][p - 1]);                                      v[i][j] = t;                                  }                              }                          }                            break;                        // Split at negligible s(k)                      case IterationStep.SplitAtNeglible:                          {                              double f = e[k - 1];                              e[k - 1] = 0.0;                              for(int j = k; j < p; j++)                              {                                  double t = Fn.Hypot(s[j]' f);                                  double cs = s[j] / t;                                  double sn = f / t;                                  s[j] = t;                                  f = (-sn) * e[j];                                  e[j] = cs * e[j];                                    for(int i = 0; i < _m; i++)                                  {                                      t = (cs * u[i][j]) + (sn * u[i][k - 1]);                                      u[i][k - 1] = ((-sn) * u[i][j]) + (cs * u[i][k - 1]);                                      u[i][j] = t;                                  }                              }                          }                            break;                        // Perform one qr step.                      case IterationStep.QR:                          {                              /* Calculate the shift */                                double scale = Math.Max(Math.Max(Math.Max(Math.Max(Math.Abs(s[p - 1])' Math.Abs(s[p - 2]))' Math.Abs(e[p - 2]))' Math.Abs(s[k]))' Math.Abs(e[k]));                              double sp = s[p - 1] / scale;                              double spm1 = s[p - 2] / scale;                              double epm1 = e[p - 2] / scale;                              double sk = s[k] / scale;                              double ek = e[k] / scale;                              double b = (((spm1 + sp) * (spm1 - sp)) + (epm1 * epm1)) / 2.0;                              double c = (sp * epm1) * (sp * epm1);                              double shift = 0.0;                              if((b != 0.0) | (c != 0.0))                              {                                  shift = Math.Sqrt((b * b) + c);                                    if(b < 0.0)                                  {                                      shift = -shift;                                  }                                    shift = c / (b + shift);                              }                                double f = ((sk + sp) * (sk - sp)) + shift;                              double g = sk * ek;                                /* Chase zeros */                                for(int j = k; j < p - 1; j++)                              {                                  double t = Fn.Hypot(f' g);                                  double cs = f / t;                                  double sn = g / t;                                    if(j != k)                                  {                                      e[j - 1] = t;                                  }                                    f = (cs * s[j]) + (sn * e[j]);                                  e[j] = (cs * e[j]) - (sn * s[j]);                                  g = sn * s[j + 1];                                  s[j + 1] = cs * s[j + 1];                                    for(int i = 0; i < _n; i++)                                  {                                      t = (cs * v[i][j]) + (sn * v[i][j + 1]);                                      v[i][j + 1] = ((-sn) * v[i][j]) + (cs * v[i][j + 1]);                                      v[i][j] = t;                                  }                                    t = Fn.Hypot(f' g);                                  cs = f / t;                                  sn = g / t;                                  s[j] = t;                                  f = (cs * e[j]) + (sn * s[j + 1]);                                  s[j + 1] = ((-sn) * e[j]) + (cs * s[j + 1]);                                  g = sn * e[j + 1];                                  e[j + 1] = cs * e[j + 1];                                    if(j < _m - 1)                                  {                                      for(int i = 0; i < _m; i++)                                      {                                          t = (cs * u[i][j]) + (sn * u[i][j + 1]);                                          u[i][j + 1] = ((-sn) * u[i][j]) + (cs * u[i][j + 1]);                                          u[i][j] = t;                                      }                                  }                              }                                e[p - 2] = f;                              iter = iter + 1;                          }                            break;                        // Convergence.                      case IterationStep.Convergence:                          {                              /* Make the singular values positive */                                if(s[k] <= 0.0)                              {                                  s[k] = (s[k] < 0.0 ? -s[k] : 0.0);                                    for(int i = 0; i <= pp; i++)                                  {                                      v[i][k] = -v[i][k];                                  }                              }                                /* Order the singular values */                                while(k < pp)                              {                                  if(s[k] >= s[k + 1])                                  {                                      break;                                  }                                    double t = s[k];                                  s[k] = s[k + 1];                                  s[k + 1] = t;                                    if(k < _n - 1)                                  {                                      for(int i = 0; i < _n; i++)                                      {                                          t = v[i][k + 1];                                          v[i][k + 1] = v[i][k];                                          v[i][k] = t;                                      }                                  }                                    if(k < _m - 1)                                  {                                      for(int i = 0; i < _m; i++)                                      {                                          t = u[i][k + 1];                                          u[i][k + 1] = u[i][k];                                          u[i][k] = t;                                      }                                  }                                    k++;                              }                                iter = 0;                              p--;                          }                            break;                  }              }
Magic Number,MathNet.Numerics.LinearAlgebra,SingularValueDecomposition,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\LinearAlgebra\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: while(p > 0)              {                  int k;                  IterationStep step;                    /* Here is where a test for too many iterations would go */                    /*                  This section of the program inspects for                  negligible elements in the s and e arrays.  On                  completion the variables kase and k are set as follows.                    DeflateNeglible:  if s[p] and e[k-1] are negligible and k<p                  SplitAtNeglible:  if s[k] is negligible and k<p                  QR:               if e[k-1] is negligible' k<p' and s[k]' ...' s[p] are not negligible.                  Convergence:      if e[p-1] is negligible.                  */                    for(k = p - 2; k >= 0; k--)                  {                      if(Math.Abs(e[k]) <= eps * (Math.Abs(s[k]) + Math.Abs(s[k + 1])))                      {                          e[k] = 0.0;                          break;                      }                  }                    if(k == p - 2)                  {                      step = IterationStep.Convergence;                  }                  else                  {                      int ks;                      for(ks = p - 1; ks >= k; ks--)                      {                          if(ks == k)                          {                              break;                          }                            double t = (ks != p ? Math.Abs(e[ks]) : 0.0) + (ks != k + 1 ? Math.Abs(e[ks - 1]) : 0.0);                          if(Math.Abs(s[ks]) <= eps * t)                          {                              s[ks] = 0.0;                              break;                          }                      }                        if(ks == k)                      {                          step = IterationStep.QR;                      }                      else if(ks == p - 1)                      {                          step = IterationStep.DeflateNeglible;                      }                      else                      {                          step = IterationStep.SplitAtNeglible;                          k = ks;                      }                  }                    k++;                    /* Perform the task indicated by 'step'. */                    switch(step)                  {                      // Deflate negligible s(p).                      case IterationStep.DeflateNeglible:                          {                              double f = e[p - 2];                              e[p - 2] = 0.0;                              for(int j = p - 2; j >= k; j--)                              {                                  double t = Fn.Hypot(s[j]' f);                                  double cs = s[j] / t;                                  double sn = f / t;                                  s[j] = t;                                    if(j != k)                                  {                                      f = (-sn) * e[j - 1];                                      e[j - 1] = cs * e[j - 1];                                  }                                    for(int i = 0; i < _n; i++)                                  {                                      t = (cs * v[i][j]) + (sn * v[i][p - 1]);                                      v[i][p - 1] = ((-sn) * v[i][j]) + (cs * v[i][p - 1]);                                      v[i][j] = t;                                  }                              }                          }                            break;                        // Split at negligible s(k)                      case IterationStep.SplitAtNeglible:                          {                              double f = e[k - 1];                              e[k - 1] = 0.0;                              for(int j = k; j < p; j++)                              {                                  double t = Fn.Hypot(s[j]' f);                                  double cs = s[j] / t;                                  double sn = f / t;                                  s[j] = t;                                  f = (-sn) * e[j];                                  e[j] = cs * e[j];                                    for(int i = 0; i < _m; i++)                                  {                                      t = (cs * u[i][j]) + (sn * u[i][k - 1]);                                      u[i][k - 1] = ((-sn) * u[i][j]) + (cs * u[i][k - 1]);                                      u[i][j] = t;                                  }                              }                          }                            break;                        // Perform one qr step.                      case IterationStep.QR:                          {                              /* Calculate the shift */                                double scale = Math.Max(Math.Max(Math.Max(Math.Max(Math.Abs(s[p - 1])' Math.Abs(s[p - 2]))' Math.Abs(e[p - 2]))' Math.Abs(s[k]))' Math.Abs(e[k]));                              double sp = s[p - 1] / scale;                              double spm1 = s[p - 2] / scale;                              double epm1 = e[p - 2] / scale;                              double sk = s[k] / scale;                              double ek = e[k] / scale;                              double b = (((spm1 + sp) * (spm1 - sp)) + (epm1 * epm1)) / 2.0;                              double c = (sp * epm1) * (sp * epm1);                              double shift = 0.0;                              if((b != 0.0) | (c != 0.0))                              {                                  shift = Math.Sqrt((b * b) + c);                                    if(b < 0.0)                                  {                                      shift = -shift;                                  }                                    shift = c / (b + shift);                              }                                double f = ((sk + sp) * (sk - sp)) + shift;                              double g = sk * ek;                                /* Chase zeros */                                for(int j = k; j < p - 1; j++)                              {                                  double t = Fn.Hypot(f' g);                                  double cs = f / t;                                  double sn = g / t;                                    if(j != k)                                  {                                      e[j - 1] = t;                                  }                                    f = (cs * s[j]) + (sn * e[j]);                                  e[j] = (cs * e[j]) - (sn * s[j]);                                  g = sn * s[j + 1];                                  s[j + 1] = cs * s[j + 1];                                    for(int i = 0; i < _n; i++)                                  {                                      t = (cs * v[i][j]) + (sn * v[i][j + 1]);                                      v[i][j + 1] = ((-sn) * v[i][j]) + (cs * v[i][j + 1]);                                      v[i][j] = t;                                  }                                    t = Fn.Hypot(f' g);                                  cs = f / t;                                  sn = g / t;                                  s[j] = t;                                  f = (cs * e[j]) + (sn * s[j + 1]);                                  s[j + 1] = ((-sn) * e[j]) + (cs * s[j + 1]);                                  g = sn * e[j + 1];                                  e[j + 1] = cs * e[j + 1];                                    if(j < _m - 1)                                  {                                      for(int i = 0; i < _m; i++)                                      {                                          t = (cs * u[i][j]) + (sn * u[i][j + 1]);                                          u[i][j + 1] = ((-sn) * u[i][j]) + (cs * u[i][j + 1]);                                          u[i][j] = t;                                      }                                  }                              }                                e[p - 2] = f;                              iter = iter + 1;                          }                            break;                        // Convergence.                      case IterationStep.Convergence:                          {                              /* Make the singular values positive */                                if(s[k] <= 0.0)                              {                                  s[k] = (s[k] < 0.0 ? -s[k] : 0.0);                                    for(int i = 0; i <= pp; i++)                                  {                                      v[i][k] = -v[i][k];                                  }                              }                                /* Order the singular values */                                while(k < pp)                              {                                  if(s[k] >= s[k + 1])                                  {                                      break;                                  }                                    double t = s[k];                                  s[k] = s[k + 1];                                  s[k + 1] = t;                                    if(k < _n - 1)                                  {                                      for(int i = 0; i < _n; i++)                                      {                                          t = v[i][k + 1];                                          v[i][k + 1] = v[i][k];                                          v[i][k] = t;                                      }                                  }                                    if(k < _m - 1)                                  {                                      for(int i = 0; i < _m; i++)                                      {                                          t = u[i][k + 1];                                          u[i][k + 1] = u[i][k];                                          u[i][k] = t;                                      }                                  }                                    k++;                              }                                iter = 0;                              p--;                          }                            break;                  }              }
Magic Number,MathNet.Numerics.LinearAlgebra,SingularValueDecomposition,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\LinearAlgebra\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: while(p > 0)              {                  int k;                  IterationStep step;                    /* Here is where a test for too many iterations would go */                    /*                  This section of the program inspects for                  negligible elements in the s and e arrays.  On                  completion the variables kase and k are set as follows.                    DeflateNeglible:  if s[p] and e[k-1] are negligible and k<p                  SplitAtNeglible:  if s[k] is negligible and k<p                  QR:               if e[k-1] is negligible' k<p' and s[k]' ...' s[p] are not negligible.                  Convergence:      if e[p-1] is negligible.                  */                    for(k = p - 2; k >= 0; k--)                  {                      if(Math.Abs(e[k]) <= eps * (Math.Abs(s[k]) + Math.Abs(s[k + 1])))                      {                          e[k] = 0.0;                          break;                      }                  }                    if(k == p - 2)                  {                      step = IterationStep.Convergence;                  }                  else                  {                      int ks;                      for(ks = p - 1; ks >= k; ks--)                      {                          if(ks == k)                          {                              break;                          }                            double t = (ks != p ? Math.Abs(e[ks]) : 0.0) + (ks != k + 1 ? Math.Abs(e[ks - 1]) : 0.0);                          if(Math.Abs(s[ks]) <= eps * t)                          {                              s[ks] = 0.0;                              break;                          }                      }                        if(ks == k)                      {                          step = IterationStep.QR;                      }                      else if(ks == p - 1)                      {                          step = IterationStep.DeflateNeglible;                      }                      else                      {                          step = IterationStep.SplitAtNeglible;                          k = ks;                      }                  }                    k++;                    /* Perform the task indicated by 'step'. */                    switch(step)                  {                      // Deflate negligible s(p).                      case IterationStep.DeflateNeglible:                          {                              double f = e[p - 2];                              e[p - 2] = 0.0;                              for(int j = p - 2; j >= k; j--)                              {                                  double t = Fn.Hypot(s[j]' f);                                  double cs = s[j] / t;                                  double sn = f / t;                                  s[j] = t;                                    if(j != k)                                  {                                      f = (-sn) * e[j - 1];                                      e[j - 1] = cs * e[j - 1];                                  }                                    for(int i = 0; i < _n; i++)                                  {                                      t = (cs * v[i][j]) + (sn * v[i][p - 1]);                                      v[i][p - 1] = ((-sn) * v[i][j]) + (cs * v[i][p - 1]);                                      v[i][j] = t;                                  }                              }                          }                            break;                        // Split at negligible s(k)                      case IterationStep.SplitAtNeglible:                          {                              double f = e[k - 1];                              e[k - 1] = 0.0;                              for(int j = k; j < p; j++)                              {                                  double t = Fn.Hypot(s[j]' f);                                  double cs = s[j] / t;                                  double sn = f / t;                                  s[j] = t;                                  f = (-sn) * e[j];                                  e[j] = cs * e[j];                                    for(int i = 0; i < _m; i++)                                  {                                      t = (cs * u[i][j]) + (sn * u[i][k - 1]);                                      u[i][k - 1] = ((-sn) * u[i][j]) + (cs * u[i][k - 1]);                                      u[i][j] = t;                                  }                              }                          }                            break;                        // Perform one qr step.                      case IterationStep.QR:                          {                              /* Calculate the shift */                                double scale = Math.Max(Math.Max(Math.Max(Math.Max(Math.Abs(s[p - 1])' Math.Abs(s[p - 2]))' Math.Abs(e[p - 2]))' Math.Abs(s[k]))' Math.Abs(e[k]));                              double sp = s[p - 1] / scale;                              double spm1 = s[p - 2] / scale;                              double epm1 = e[p - 2] / scale;                              double sk = s[k] / scale;                              double ek = e[k] / scale;                              double b = (((spm1 + sp) * (spm1 - sp)) + (epm1 * epm1)) / 2.0;                              double c = (sp * epm1) * (sp * epm1);                              double shift = 0.0;                              if((b != 0.0) | (c != 0.0))                              {                                  shift = Math.Sqrt((b * b) + c);                                    if(b < 0.0)                                  {                                      shift = -shift;                                  }                                    shift = c / (b + shift);                              }                                double f = ((sk + sp) * (sk - sp)) + shift;                              double g = sk * ek;                                /* Chase zeros */                                for(int j = k; j < p - 1; j++)                              {                                  double t = Fn.Hypot(f' g);                                  double cs = f / t;                                  double sn = g / t;                                    if(j != k)                                  {                                      e[j - 1] = t;                                  }                                    f = (cs * s[j]) + (sn * e[j]);                                  e[j] = (cs * e[j]) - (sn * s[j]);                                  g = sn * s[j + 1];                                  s[j + 1] = cs * s[j + 1];                                    for(int i = 0; i < _n; i++)                                  {                                      t = (cs * v[i][j]) + (sn * v[i][j + 1]);                                      v[i][j + 1] = ((-sn) * v[i][j]) + (cs * v[i][j + 1]);                                      v[i][j] = t;                                  }                                    t = Fn.Hypot(f' g);                                  cs = f / t;                                  sn = g / t;                                  s[j] = t;                                  f = (cs * e[j]) + (sn * s[j + 1]);                                  s[j + 1] = ((-sn) * e[j]) + (cs * s[j + 1]);                                  g = sn * e[j + 1];                                  e[j + 1] = cs * e[j + 1];                                    if(j < _m - 1)                                  {                                      for(int i = 0; i < _m; i++)                                      {                                          t = (cs * u[i][j]) + (sn * u[i][j + 1]);                                          u[i][j + 1] = ((-sn) * u[i][j]) + (cs * u[i][j + 1]);                                          u[i][j] = t;                                      }                                  }                              }                                e[p - 2] = f;                              iter = iter + 1;                          }                            break;                        // Convergence.                      case IterationStep.Convergence:                          {                              /* Make the singular values positive */                                if(s[k] <= 0.0)                              {                                  s[k] = (s[k] < 0.0 ? -s[k] : 0.0);                                    for(int i = 0; i <= pp; i++)                                  {                                      v[i][k] = -v[i][k];                                  }                              }                                /* Order the singular values */                                while(k < pp)                              {                                  if(s[k] >= s[k + 1])                                  {                                      break;                                  }                                    double t = s[k];                                  s[k] = s[k + 1];                                  s[k + 1] = t;                                    if(k < _n - 1)                                  {                                      for(int i = 0; i < _n; i++)                                      {                                          t = v[i][k + 1];                                          v[i][k + 1] = v[i][k];                                          v[i][k] = t;                                      }                                  }                                    if(k < _m - 1)                                  {                                      for(int i = 0; i < _m; i++)                                      {                                          t = u[i][k + 1];                                          u[i][k + 1] = u[i][k];                                          u[i][k] = t;                                      }                                  }                                    k++;                              }                                iter = 0;                              p--;                          }                            break;                  }              }
Magic Number,MathNet.Numerics.LinearAlgebra,SingularValueDecomposition,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\LinearAlgebra\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: while(p > 0)              {                  int k;                  IterationStep step;                    /* Here is where a test for too many iterations would go */                    /*                  This section of the program inspects for                  negligible elements in the s and e arrays.  On                  completion the variables kase and k are set as follows.                    DeflateNeglible:  if s[p] and e[k-1] are negligible and k<p                  SplitAtNeglible:  if s[k] is negligible and k<p                  QR:               if e[k-1] is negligible' k<p' and s[k]' ...' s[p] are not negligible.                  Convergence:      if e[p-1] is negligible.                  */                    for(k = p - 2; k >= 0; k--)                  {                      if(Math.Abs(e[k]) <= eps * (Math.Abs(s[k]) + Math.Abs(s[k + 1])))                      {                          e[k] = 0.0;                          break;                      }                  }                    if(k == p - 2)                  {                      step = IterationStep.Convergence;                  }                  else                  {                      int ks;                      for(ks = p - 1; ks >= k; ks--)                      {                          if(ks == k)                          {                              break;                          }                            double t = (ks != p ? Math.Abs(e[ks]) : 0.0) + (ks != k + 1 ? Math.Abs(e[ks - 1]) : 0.0);                          if(Math.Abs(s[ks]) <= eps * t)                          {                              s[ks] = 0.0;                              break;                          }                      }                        if(ks == k)                      {                          step = IterationStep.QR;                      }                      else if(ks == p - 1)                      {                          step = IterationStep.DeflateNeglible;                      }                      else                      {                          step = IterationStep.SplitAtNeglible;                          k = ks;                      }                  }                    k++;                    /* Perform the task indicated by 'step'. */                    switch(step)                  {                      // Deflate negligible s(p).                      case IterationStep.DeflateNeglible:                          {                              double f = e[p - 2];                              e[p - 2] = 0.0;                              for(int j = p - 2; j >= k; j--)                              {                                  double t = Fn.Hypot(s[j]' f);                                  double cs = s[j] / t;                                  double sn = f / t;                                  s[j] = t;                                    if(j != k)                                  {                                      f = (-sn) * e[j - 1];                                      e[j - 1] = cs * e[j - 1];                                  }                                    for(int i = 0; i < _n; i++)                                  {                                      t = (cs * v[i][j]) + (sn * v[i][p - 1]);                                      v[i][p - 1] = ((-sn) * v[i][j]) + (cs * v[i][p - 1]);                                      v[i][j] = t;                                  }                              }                          }                            break;                        // Split at negligible s(k)                      case IterationStep.SplitAtNeglible:                          {                              double f = e[k - 1];                              e[k - 1] = 0.0;                              for(int j = k; j < p; j++)                              {                                  double t = Fn.Hypot(s[j]' f);                                  double cs = s[j] / t;                                  double sn = f / t;                                  s[j] = t;                                  f = (-sn) * e[j];                                  e[j] = cs * e[j];                                    for(int i = 0; i < _m; i++)                                  {                                      t = (cs * u[i][j]) + (sn * u[i][k - 1]);                                      u[i][k - 1] = ((-sn) * u[i][j]) + (cs * u[i][k - 1]);                                      u[i][j] = t;                                  }                              }                          }                            break;                        // Perform one qr step.                      case IterationStep.QR:                          {                              /* Calculate the shift */                                double scale = Math.Max(Math.Max(Math.Max(Math.Max(Math.Abs(s[p - 1])' Math.Abs(s[p - 2]))' Math.Abs(e[p - 2]))' Math.Abs(s[k]))' Math.Abs(e[k]));                              double sp = s[p - 1] / scale;                              double spm1 = s[p - 2] / scale;                              double epm1 = e[p - 2] / scale;                              double sk = s[k] / scale;                              double ek = e[k] / scale;                              double b = (((spm1 + sp) * (spm1 - sp)) + (epm1 * epm1)) / 2.0;                              double c = (sp * epm1) * (sp * epm1);                              double shift = 0.0;                              if((b != 0.0) | (c != 0.0))                              {                                  shift = Math.Sqrt((b * b) + c);                                    if(b < 0.0)                                  {                                      shift = -shift;                                  }                                    shift = c / (b + shift);                              }                                double f = ((sk + sp) * (sk - sp)) + shift;                              double g = sk * ek;                                /* Chase zeros */                                for(int j = k; j < p - 1; j++)                              {                                  double t = Fn.Hypot(f' g);                                  double cs = f / t;                                  double sn = g / t;                                    if(j != k)                                  {                                      e[j - 1] = t;                                  }                                    f = (cs * s[j]) + (sn * e[j]);                                  e[j] = (cs * e[j]) - (sn * s[j]);                                  g = sn * s[j + 1];                                  s[j + 1] = cs * s[j + 1];                                    for(int i = 0; i < _n; i++)                                  {                                      t = (cs * v[i][j]) + (sn * v[i][j + 1]);                                      v[i][j + 1] = ((-sn) * v[i][j]) + (cs * v[i][j + 1]);                                      v[i][j] = t;                                  }                                    t = Fn.Hypot(f' g);                                  cs = f / t;                                  sn = g / t;                                  s[j] = t;                                  f = (cs * e[j]) + (sn * s[j + 1]);                                  s[j + 1] = ((-sn) * e[j]) + (cs * s[j + 1]);                                  g = sn * e[j + 1];                                  e[j + 1] = cs * e[j + 1];                                    if(j < _m - 1)                                  {                                      for(int i = 0; i < _m; i++)                                      {                                          t = (cs * u[i][j]) + (sn * u[i][j + 1]);                                          u[i][j + 1] = ((-sn) * u[i][j]) + (cs * u[i][j + 1]);                                          u[i][j] = t;                                      }                                  }                              }                                e[p - 2] = f;                              iter = iter + 1;                          }                            break;                        // Convergence.                      case IterationStep.Convergence:                          {                              /* Make the singular values positive */                                if(s[k] <= 0.0)                              {                                  s[k] = (s[k] < 0.0 ? -s[k] : 0.0);                                    for(int i = 0; i <= pp; i++)                                  {                                      v[i][k] = -v[i][k];                                  }                              }                                /* Order the singular values */                                while(k < pp)                              {                                  if(s[k] >= s[k + 1])                                  {                                      break;                                  }                                    double t = s[k];                                  s[k] = s[k + 1];                                  s[k + 1] = t;                                    if(k < _n - 1)                                  {                                      for(int i = 0; i < _n; i++)                                      {                                          t = v[i][k + 1];                                          v[i][k + 1] = v[i][k];                                          v[i][k] = t;                                      }                                  }                                    if(k < _m - 1)                                  {                                      for(int i = 0; i < _m; i++)                                      {                                          t = u[i][k + 1];                                          u[i][k + 1] = u[i][k];                                          u[i][k] = t;                                      }                                  }                                    k++;                              }                                iter = 0;                              p--;                          }                            break;                  }              }
Magic Number,MathNet.Numerics.NumberTheory,IntegerTheory,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\NumberTheory\IntegerTheory.cs,IsPerfectSquare,The following statement contains a magic number: if(lastHexDigit > 9)              {                  return false; // return immediately in 6 cases out of 16.              }
Magic Number,MathNet.Numerics.NumberTheory,IntegerTheory,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\NumberTheory\IntegerTheory.cs,IsPerfectSquare,The following statement contains a magic number: if(lastHexDigit == 0 || lastHexDigit == 1 || lastHexDigit == 4 || lastHexDigit == 9)              {                  int t = (int)Math.Floor(Math.Sqrt(number) + 0.5);                  return (t * t) == number;              }
Magic Number,MathNet.Numerics.NumberTheory,IntegerTheory,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\NumberTheory\IntegerTheory.cs,IsPerfectSquare,The following statement contains a magic number: if(lastHexDigit == 0 || lastHexDigit == 1 || lastHexDigit == 4 || lastHexDigit == 9)              {                  int t = (int)Math.Floor(Math.Sqrt(number) + 0.5);                  return (t * t) == number;              }
Magic Number,MathNet.Numerics.NumberTheory,IntegerTheory,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\NumberTheory\IntegerTheory.cs,IsPerfectSquare,The following statement contains a magic number: if(lastHexDigit == 0 || lastHexDigit == 1 || lastHexDigit == 4 || lastHexDigit == 9)              {                  int t = (int)Math.Floor(Math.Sqrt(number) + 0.5);                  return (t * t) == number;              }
Magic Number,MathNet.Numerics.NumberTheory,IntegerTheory,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\NumberTheory\IntegerTheory.cs,IsPerfectSquare,The following statement contains a magic number: if(lastHexDigit > 9)              {                  return false; // return immediately in 6 cases out of 16.              }
Magic Number,MathNet.Numerics.NumberTheory,IntegerTheory,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\NumberTheory\IntegerTheory.cs,IsPerfectSquare,The following statement contains a magic number: if(lastHexDigit == 0 || lastHexDigit == 1 || lastHexDigit == 4 || lastHexDigit == 9)              {                  long t = (long)Math.Floor(Math.Sqrt(number) + 0.5);                  return (t * t) == number;              }
Magic Number,MathNet.Numerics.NumberTheory,IntegerTheory,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\NumberTheory\IntegerTheory.cs,IsPerfectSquare,The following statement contains a magic number: if(lastHexDigit == 0 || lastHexDigit == 1 || lastHexDigit == 4 || lastHexDigit == 9)              {                  long t = (long)Math.Floor(Math.Sqrt(number) + 0.5);                  return (t * t) == number;              }
Magic Number,MathNet.Numerics.NumberTheory,IntegerTheory,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\NumberTheory\IntegerTheory.cs,IsPerfectSquare,The following statement contains a magic number: if(lastHexDigit == 0 || lastHexDigit == 1 || lastHexDigit == 4 || lastHexDigit == 9)              {                  long t = (long)Math.Floor(Math.Sqrt(number) + 0.5);                  return (t * t) == number;              }
Magic Number,MathNet.Numerics.RandomSources,AdditiveLaggedFibonacciRandomSource,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\AdditiveLaggedFibonacciRandomSource.cs,AdditiveLaggedFibonacciRandomSource,The following statement contains a magic number: _shortLag = 418;
Magic Number,MathNet.Numerics.RandomSources,AdditiveLaggedFibonacciRandomSource,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\AdditiveLaggedFibonacciRandomSource.cs,AdditiveLaggedFibonacciRandomSource,The following statement contains a magic number: _longLag = 1279;
Magic Number,MathNet.Numerics.RandomSources,AdditiveLaggedFibonacciRandomSource,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\AdditiveLaggedFibonacciRandomSource.cs,NextBoolean,The following statement contains a magic number: if(_bitCount == 0)              {                  // Generate 32 more bits (1 uint) and store it for future calls.                  // Its faster to explicitly calculate the unsigned random number than simply call NextUInt().                  if(_i >= _longLag)                  {                      Fill();                  }                    _bitBuffer = _x[_i++];                    // Reset the bitCount and use rightmost bit of buffer to generate random bool.                  _bitCount = 31;                  return (_bitBuffer & 0x1) == 1;              }
Magic Number,MathNet.Numerics.RandomSources,AdditiveLaggedFibonacciRandomSource,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\AdditiveLaggedFibonacciRandomSource.cs,NextBytes,The following statement contains a magic number: while(i < buffer.Length - 3)              {                  // Its faster to explicitly calculate the unsigned random number than simply call NextUInt().                  if(_i >= _longLag)                  {                      Fill();                  }                    w = _x[_i++];                    buffer[i++] = (byte)w;                  buffer[i++] = (byte)(w >> 8);                  buffer[i++] = (byte)(w >> 16);                  buffer[i++] = (byte)(w >> 24);              }
Magic Number,MathNet.Numerics.RandomSources,AdditiveLaggedFibonacciRandomSource,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\AdditiveLaggedFibonacciRandomSource.cs,NextBytes,The following statement contains a magic number: while(i < buffer.Length - 3)              {                  // Its faster to explicitly calculate the unsigned random number than simply call NextUInt().                  if(_i >= _longLag)                  {                      Fill();                  }                    w = _x[_i++];                    buffer[i++] = (byte)w;                  buffer[i++] = (byte)(w >> 8);                  buffer[i++] = (byte)(w >> 16);                  buffer[i++] = (byte)(w >> 24);              }
Magic Number,MathNet.Numerics.RandomSources,AdditiveLaggedFibonacciRandomSource,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\AdditiveLaggedFibonacciRandomSource.cs,NextBytes,The following statement contains a magic number: while(i < buffer.Length - 3)              {                  // Its faster to explicitly calculate the unsigned random number than simply call NextUInt().                  if(_i >= _longLag)                  {                      Fill();                  }                    w = _x[_i++];                    buffer[i++] = (byte)w;                  buffer[i++] = (byte)(w >> 8);                  buffer[i++] = (byte)(w >> 16);                  buffer[i++] = (byte)(w >> 24);              }
Magic Number,MathNet.Numerics.RandomSources,AdditiveLaggedFibonacciRandomSource,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\AdditiveLaggedFibonacciRandomSource.cs,NextBytes,The following statement contains a magic number: while(i < buffer.Length - 3)              {                  // Its faster to explicitly calculate the unsigned random number than simply call NextUInt().                  if(_i >= _longLag)                  {                      Fill();                  }                    w = _x[_i++];                    buffer[i++] = (byte)w;                  buffer[i++] = (byte)(w >> 8);                  buffer[i++] = (byte)(w >> 16);                  buffer[i++] = (byte)(w >> 24);              }
Magic Number,MathNet.Numerics.RandomSources,AdditiveLaggedFibonacciRandomSource,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\AdditiveLaggedFibonacciRandomSource.cs,NextBytes,The following statement contains a magic number: if(i < buffer.Length)              {                  // Its faster to explicitly calculate the unsigned random number than simply call NextUInt().                  if(_i >= _longLag)                  {                      Fill();                  }                    w = _x[_i++];                    buffer[i++] = (byte)w;                  if(i < buffer.Length)                  {                      buffer[i++] = (byte)(w >> 8);                      if(i < buffer.Length)                      {                          buffer[i++] = (byte)(w >> 16);                          if(i < buffer.Length)                          {                              buffer[i] = (byte)(w >> 24);                          }                      }                  }              }
Magic Number,MathNet.Numerics.RandomSources,AdditiveLaggedFibonacciRandomSource,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\AdditiveLaggedFibonacciRandomSource.cs,NextBytes,The following statement contains a magic number: if(i < buffer.Length)              {                  // Its faster to explicitly calculate the unsigned random number than simply call NextUInt().                  if(_i >= _longLag)                  {                      Fill();                  }                    w = _x[_i++];                    buffer[i++] = (byte)w;                  if(i < buffer.Length)                  {                      buffer[i++] = (byte)(w >> 8);                      if(i < buffer.Length)                      {                          buffer[i++] = (byte)(w >> 16);                          if(i < buffer.Length)                          {                              buffer[i] = (byte)(w >> 24);                          }                      }                  }              }
Magic Number,MathNet.Numerics.RandomSources,AdditiveLaggedFibonacciRandomSource,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\AdditiveLaggedFibonacciRandomSource.cs,NextBytes,The following statement contains a magic number: if(i < buffer.Length)              {                  // Its faster to explicitly calculate the unsigned random number than simply call NextUInt().                  if(_i >= _longLag)                  {                      Fill();                  }                    w = _x[_i++];                    buffer[i++] = (byte)w;                  if(i < buffer.Length)                  {                      buffer[i++] = (byte)(w >> 8);                      if(i < buffer.Length)                      {                          buffer[i++] = (byte)(w >> 16);                          if(i < buffer.Length)                          {                              buffer[i] = (byte)(w >> 24);                          }                      }                  }              }
Magic Number,MathNet.Numerics.RandomSources,MersenneTwisterRandomSource,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\MersenneTwisterRandomSource.cs,ResetGenerator,The following statement contains a magic number: for(_mti = 1; _mti < N; _mti++)              {                  _mt[_mti] = (1812433253U * (_mt[_mti - 1] ^ (_mt[_mti - 1] >> 30))) + _mti;                    // See Knuth TAOCP Vol2. 3rd Ed. P.106 for multiplier.                  // In the previous versions' MSBs of the seed affect only MSBs of the array mt[].                  // 2002/01/09 modified by Makoto Matsumoto              }
Magic Number,MathNet.Numerics.RandomSources,MersenneTwisterRandomSource,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\MersenneTwisterRandomSource.cs,ResetGenerator,The following statement contains a magic number: _bitCount = 32;
Magic Number,MathNet.Numerics.RandomSources,MersenneTwisterRandomSource,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\MersenneTwisterRandomSource.cs,ResetBySeedArray,The following statement contains a magic number: for(; k > 0; k--)              {                  _mt[i] = (_mt[i] ^ ((_mt[i - 1] ^ (_mt[i - 1] >> 30)) * 1664525U)) + _seedArray[j] + j; // non linear                  i++;                  j++;                    if(i >= N)                  {                      _mt[0] = _mt[N - 1];                      i = 1;                  }                    if(j >= _seedArray.Length)                  {                      j = 0;                  }              }
Magic Number,MathNet.Numerics.RandomSources,MersenneTwisterRandomSource,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\MersenneTwisterRandomSource.cs,ResetBySeedArray,The following statement contains a magic number: for(k = N - 1; k > 0; k--)              {                  _mt[i] = (_mt[i] ^ ((_mt[i - 1] ^ (_mt[i - 1] >> 30)) * 1566083941U)) - i; // non linear                  i++;                  if(i >= N)                  {                      _mt[0] = _mt[N - 1];                      i = 1;                  }              }
Magic Number,MathNet.Numerics.RandomSources,MersenneTwisterRandomSource,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\MersenneTwisterRandomSource.cs,NextFullRangeInt32,The following statement contains a magic number: y ^= (y >> 11);
Magic Number,MathNet.Numerics.RandomSources,MersenneTwisterRandomSource,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\MersenneTwisterRandomSource.cs,NextFullRangeInt32,The following statement contains a magic number: y ^= (y << 7) & 0x9d2c5680U;
Magic Number,MathNet.Numerics.RandomSources,MersenneTwisterRandomSource,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\MersenneTwisterRandomSource.cs,NextFullRangeInt32,The following statement contains a magic number: y ^= (y << 15) & 0xefc60000U;
Magic Number,MathNet.Numerics.RandomSources,MersenneTwisterRandomSource,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\MersenneTwisterRandomSource.cs,NextFullRangeInt32,The following statement contains a magic number: return (int)(y ^ (y >> 18));
Magic Number,MathNet.Numerics.RandomSources,MersenneTwisterRandomSource,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\MersenneTwisterRandomSource.cs,NextFullRangeUInt32,The following statement contains a magic number: y ^= (y >> 11);
Magic Number,MathNet.Numerics.RandomSources,MersenneTwisterRandomSource,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\MersenneTwisterRandomSource.cs,NextFullRangeUInt32,The following statement contains a magic number: y ^= (y << 7) & 0x9d2c5680U;
Magic Number,MathNet.Numerics.RandomSources,MersenneTwisterRandomSource,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\MersenneTwisterRandomSource.cs,NextFullRangeUInt32,The following statement contains a magic number: y ^= (y << 15) & 0xefc60000U;
Magic Number,MathNet.Numerics.RandomSources,MersenneTwisterRandomSource,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\MersenneTwisterRandomSource.cs,NextFullRangeUInt32,The following statement contains a magic number: return y ^ (y >> 18);
Magic Number,MathNet.Numerics.RandomSources,MersenneTwisterRandomSource,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\MersenneTwisterRandomSource.cs,NextInclusiveMaxValue,The following statement contains a magic number: y ^= (y >> 11);
Magic Number,MathNet.Numerics.RandomSources,MersenneTwisterRandomSource,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\MersenneTwisterRandomSource.cs,NextInclusiveMaxValue,The following statement contains a magic number: y ^= (y << 7) & 0x9d2c5680U;
Magic Number,MathNet.Numerics.RandomSources,MersenneTwisterRandomSource,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\MersenneTwisterRandomSource.cs,NextInclusiveMaxValue,The following statement contains a magic number: y ^= (y << 15) & 0xefc60000U;
Magic Number,MathNet.Numerics.RandomSources,MersenneTwisterRandomSource,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\MersenneTwisterRandomSource.cs,NextInclusiveMaxValue,The following statement contains a magic number: y ^= (y >> 18);
Magic Number,MathNet.Numerics.RandomSources,MersenneTwisterRandomSource,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\MersenneTwisterRandomSource.cs,Next,The following statement contains a magic number: y ^= (y >> 11);
Magic Number,MathNet.Numerics.RandomSources,MersenneTwisterRandomSource,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\MersenneTwisterRandomSource.cs,Next,The following statement contains a magic number: y ^= (y << 7) & 0x9d2c5680U;
Magic Number,MathNet.Numerics.RandomSources,MersenneTwisterRandomSource,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\MersenneTwisterRandomSource.cs,Next,The following statement contains a magic number: y ^= (y << 15) & 0xefc60000U;
Magic Number,MathNet.Numerics.RandomSources,MersenneTwisterRandomSource,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\MersenneTwisterRandomSource.cs,Next,The following statement contains a magic number: y ^= (y >> 18);
Magic Number,MathNet.Numerics.RandomSources,MersenneTwisterRandomSource,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\MersenneTwisterRandomSource.cs,Next,The following statement contains a magic number: y ^= (y >> 11);
Magic Number,MathNet.Numerics.RandomSources,MersenneTwisterRandomSource,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\MersenneTwisterRandomSource.cs,Next,The following statement contains a magic number: y ^= (y << 7) & 0x9d2c5680U;
Magic Number,MathNet.Numerics.RandomSources,MersenneTwisterRandomSource,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\MersenneTwisterRandomSource.cs,Next,The following statement contains a magic number: y ^= (y << 15) & 0xefc60000U;
Magic Number,MathNet.Numerics.RandomSources,MersenneTwisterRandomSource,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\MersenneTwisterRandomSource.cs,Next,The following statement contains a magic number: y ^= (y >> 18);
Magic Number,MathNet.Numerics.RandomSources,MersenneTwisterRandomSource,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\MersenneTwisterRandomSource.cs,Next,The following statement contains a magic number: y ^= (y >> 11);
Magic Number,MathNet.Numerics.RandomSources,MersenneTwisterRandomSource,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\MersenneTwisterRandomSource.cs,Next,The following statement contains a magic number: y ^= (y << 7) & 0x9d2c5680U;
Magic Number,MathNet.Numerics.RandomSources,MersenneTwisterRandomSource,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\MersenneTwisterRandomSource.cs,Next,The following statement contains a magic number: y ^= (y << 15) & 0xefc60000U;
Magic Number,MathNet.Numerics.RandomSources,MersenneTwisterRandomSource,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\MersenneTwisterRandomSource.cs,Next,The following statement contains a magic number: y ^= (y >> 18);
Magic Number,MathNet.Numerics.RandomSources,MersenneTwisterRandomSource,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\MersenneTwisterRandomSource.cs,NextDouble,The following statement contains a magic number: y ^= (y >> 11);
Magic Number,MathNet.Numerics.RandomSources,MersenneTwisterRandomSource,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\MersenneTwisterRandomSource.cs,NextDouble,The following statement contains a magic number: y ^= (y << 7) & 0x9d2c5680U;
Magic Number,MathNet.Numerics.RandomSources,MersenneTwisterRandomSource,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\MersenneTwisterRandomSource.cs,NextDouble,The following statement contains a magic number: y ^= (y << 15) & 0xefc60000U;
Magic Number,MathNet.Numerics.RandomSources,MersenneTwisterRandomSource,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\MersenneTwisterRandomSource.cs,NextDouble,The following statement contains a magic number: y ^= (y >> 18);
Magic Number,MathNet.Numerics.RandomSources,MersenneTwisterRandomSource,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\MersenneTwisterRandomSource.cs,NextDouble,The following statement contains a magic number: y ^= (y >> 11);
Magic Number,MathNet.Numerics.RandomSources,MersenneTwisterRandomSource,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\MersenneTwisterRandomSource.cs,NextDouble,The following statement contains a magic number: y ^= (y << 7) & 0x9d2c5680U;
Magic Number,MathNet.Numerics.RandomSources,MersenneTwisterRandomSource,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\MersenneTwisterRandomSource.cs,NextDouble,The following statement contains a magic number: y ^= (y << 15) & 0xefc60000U;
Magic Number,MathNet.Numerics.RandomSources,MersenneTwisterRandomSource,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\MersenneTwisterRandomSource.cs,NextDouble,The following statement contains a magic number: y ^= (y >> 18);
Magic Number,MathNet.Numerics.RandomSources,MersenneTwisterRandomSource,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\MersenneTwisterRandomSource.cs,NextDouble,The following statement contains a magic number: y ^= (y >> 11);
Magic Number,MathNet.Numerics.RandomSources,MersenneTwisterRandomSource,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\MersenneTwisterRandomSource.cs,NextDouble,The following statement contains a magic number: y ^= (y << 7) & 0x9d2c5680U;
Magic Number,MathNet.Numerics.RandomSources,MersenneTwisterRandomSource,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\MersenneTwisterRandomSource.cs,NextDouble,The following statement contains a magic number: y ^= (y << 15) & 0xefc60000U;
Magic Number,MathNet.Numerics.RandomSources,MersenneTwisterRandomSource,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\MersenneTwisterRandomSource.cs,NextDouble,The following statement contains a magic number: y ^= (y >> 18);
Magic Number,MathNet.Numerics.RandomSources,MersenneTwisterRandomSource,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\MersenneTwisterRandomSource.cs,NextBoolean,The following statement contains a magic number: if(_bitCount == 32)              {                  // Generate 32 more bits (1 uint) and store it for future calls.                  // Its faster to explicitly calculate the unsigned random number than simply call NextUInt().                  if(_mti >= N)                  {                      // generate N words at one time                      GenerateUInts();                  }                    uint y = _mt[_mti++];                    // Tempering                  y ^= (y >> 11);                  y ^= (y << 7) & 0x9d2c5680U;                  y ^= (y << 15) & 0xefc60000U;                  _bitBuffer = (y ^ (y >> 18));                    // Reset the bitCount and use rightmost bit of buffer to generate random bool.                  _bitCount = 1;                  return (_bitBuffer & 0x1) == 1;              }
Magic Number,MathNet.Numerics.RandomSources,MersenneTwisterRandomSource,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\MersenneTwisterRandomSource.cs,NextBoolean,The following statement contains a magic number: if(_bitCount == 32)              {                  // Generate 32 more bits (1 uint) and store it for future calls.                  // Its faster to explicitly calculate the unsigned random number than simply call NextUInt().                  if(_mti >= N)                  {                      // generate N words at one time                      GenerateUInts();                  }                    uint y = _mt[_mti++];                    // Tempering                  y ^= (y >> 11);                  y ^= (y << 7) & 0x9d2c5680U;                  y ^= (y << 15) & 0xefc60000U;                  _bitBuffer = (y ^ (y >> 18));                    // Reset the bitCount and use rightmost bit of buffer to generate random bool.                  _bitCount = 1;                  return (_bitBuffer & 0x1) == 1;              }
Magic Number,MathNet.Numerics.RandomSources,MersenneTwisterRandomSource,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\MersenneTwisterRandomSource.cs,NextBoolean,The following statement contains a magic number: if(_bitCount == 32)              {                  // Generate 32 more bits (1 uint) and store it for future calls.                  // Its faster to explicitly calculate the unsigned random number than simply call NextUInt().                  if(_mti >= N)                  {                      // generate N words at one time                      GenerateUInts();                  }                    uint y = _mt[_mti++];                    // Tempering                  y ^= (y >> 11);                  y ^= (y << 7) & 0x9d2c5680U;                  y ^= (y << 15) & 0xefc60000U;                  _bitBuffer = (y ^ (y >> 18));                    // Reset the bitCount and use rightmost bit of buffer to generate random bool.                  _bitCount = 1;                  return (_bitBuffer & 0x1) == 1;              }
Magic Number,MathNet.Numerics.RandomSources,MersenneTwisterRandomSource,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\MersenneTwisterRandomSource.cs,NextBoolean,The following statement contains a magic number: if(_bitCount == 32)              {                  // Generate 32 more bits (1 uint) and store it for future calls.                  // Its faster to explicitly calculate the unsigned random number than simply call NextUInt().                  if(_mti >= N)                  {                      // generate N words at one time                      GenerateUInts();                  }                    uint y = _mt[_mti++];                    // Tempering                  y ^= (y >> 11);                  y ^= (y << 7) & 0x9d2c5680U;                  y ^= (y << 15) & 0xefc60000U;                  _bitBuffer = (y ^ (y >> 18));                    // Reset the bitCount and use rightmost bit of buffer to generate random bool.                  _bitCount = 1;                  return (_bitBuffer & 0x1) == 1;              }
Magic Number,MathNet.Numerics.RandomSources,MersenneTwisterRandomSource,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\MersenneTwisterRandomSource.cs,NextBoolean,The following statement contains a magic number: if(_bitCount == 32)              {                  // Generate 32 more bits (1 uint) and store it for future calls.                  // Its faster to explicitly calculate the unsigned random number than simply call NextUInt().                  if(_mti >= N)                  {                      // generate N words at one time                      GenerateUInts();                  }                    uint y = _mt[_mti++];                    // Tempering                  y ^= (y >> 11);                  y ^= (y << 7) & 0x9d2c5680U;                  y ^= (y << 15) & 0xefc60000U;                  _bitBuffer = (y ^ (y >> 18));                    // Reset the bitCount and use rightmost bit of buffer to generate random bool.                  _bitCount = 1;                  return (_bitBuffer & 0x1) == 1;              }
Magic Number,MathNet.Numerics.RandomSources,MersenneTwisterRandomSource,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\MersenneTwisterRandomSource.cs,NextBytes,The following statement contains a magic number: while(i < buffer.Length - 3)              {                  // Its faster to explicitly calculate the unsigned random number than simply call NextUInt().                  if(_mti >= N)                  {                      // generate N words at one time                      GenerateUInts();                  }                    y = _mt[_mti++];                    // Tempering                  y ^= (y >> 11);                  y ^= (y << 7) & 0x9d2c5680U;                  y ^= (y << 15) & 0xefc60000U;                  y ^= (y >> 18);                    buffer[i++] = (byte)y;                  buffer[i++] = (byte)(y >> 8);                  buffer[i++] = (byte)(y >> 16);                  buffer[i++] = (byte)(y >> 24);              }
Magic Number,MathNet.Numerics.RandomSources,MersenneTwisterRandomSource,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\MersenneTwisterRandomSource.cs,NextBytes,The following statement contains a magic number: while(i < buffer.Length - 3)              {                  // Its faster to explicitly calculate the unsigned random number than simply call NextUInt().                  if(_mti >= N)                  {                      // generate N words at one time                      GenerateUInts();                  }                    y = _mt[_mti++];                    // Tempering                  y ^= (y >> 11);                  y ^= (y << 7) & 0x9d2c5680U;                  y ^= (y << 15) & 0xefc60000U;                  y ^= (y >> 18);                    buffer[i++] = (byte)y;                  buffer[i++] = (byte)(y >> 8);                  buffer[i++] = (byte)(y >> 16);                  buffer[i++] = (byte)(y >> 24);              }
Magic Number,MathNet.Numerics.RandomSources,MersenneTwisterRandomSource,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\MersenneTwisterRandomSource.cs,NextBytes,The following statement contains a magic number: while(i < buffer.Length - 3)              {                  // Its faster to explicitly calculate the unsigned random number than simply call NextUInt().                  if(_mti >= N)                  {                      // generate N words at one time                      GenerateUInts();                  }                    y = _mt[_mti++];                    // Tempering                  y ^= (y >> 11);                  y ^= (y << 7) & 0x9d2c5680U;                  y ^= (y << 15) & 0xefc60000U;                  y ^= (y >> 18);                    buffer[i++] = (byte)y;                  buffer[i++] = (byte)(y >> 8);                  buffer[i++] = (byte)(y >> 16);                  buffer[i++] = (byte)(y >> 24);              }
Magic Number,MathNet.Numerics.RandomSources,MersenneTwisterRandomSource,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\MersenneTwisterRandomSource.cs,NextBytes,The following statement contains a magic number: while(i < buffer.Length - 3)              {                  // Its faster to explicitly calculate the unsigned random number than simply call NextUInt().                  if(_mti >= N)                  {                      // generate N words at one time                      GenerateUInts();                  }                    y = _mt[_mti++];                    // Tempering                  y ^= (y >> 11);                  y ^= (y << 7) & 0x9d2c5680U;                  y ^= (y << 15) & 0xefc60000U;                  y ^= (y >> 18);                    buffer[i++] = (byte)y;                  buffer[i++] = (byte)(y >> 8);                  buffer[i++] = (byte)(y >> 16);                  buffer[i++] = (byte)(y >> 24);              }
Magic Number,MathNet.Numerics.RandomSources,MersenneTwisterRandomSource,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\MersenneTwisterRandomSource.cs,NextBytes,The following statement contains a magic number: while(i < buffer.Length - 3)              {                  // Its faster to explicitly calculate the unsigned random number than simply call NextUInt().                  if(_mti >= N)                  {                      // generate N words at one time                      GenerateUInts();                  }                    y = _mt[_mti++];                    // Tempering                  y ^= (y >> 11);                  y ^= (y << 7) & 0x9d2c5680U;                  y ^= (y << 15) & 0xefc60000U;                  y ^= (y >> 18);                    buffer[i++] = (byte)y;                  buffer[i++] = (byte)(y >> 8);                  buffer[i++] = (byte)(y >> 16);                  buffer[i++] = (byte)(y >> 24);              }
Magic Number,MathNet.Numerics.RandomSources,MersenneTwisterRandomSource,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\MersenneTwisterRandomSource.cs,NextBytes,The following statement contains a magic number: while(i < buffer.Length - 3)              {                  // Its faster to explicitly calculate the unsigned random number than simply call NextUInt().                  if(_mti >= N)                  {                      // generate N words at one time                      GenerateUInts();                  }                    y = _mt[_mti++];                    // Tempering                  y ^= (y >> 11);                  y ^= (y << 7) & 0x9d2c5680U;                  y ^= (y << 15) & 0xefc60000U;                  y ^= (y >> 18);                    buffer[i++] = (byte)y;                  buffer[i++] = (byte)(y >> 8);                  buffer[i++] = (byte)(y >> 16);                  buffer[i++] = (byte)(y >> 24);              }
Magic Number,MathNet.Numerics.RandomSources,MersenneTwisterRandomSource,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\MersenneTwisterRandomSource.cs,NextBytes,The following statement contains a magic number: while(i < buffer.Length - 3)              {                  // Its faster to explicitly calculate the unsigned random number than simply call NextUInt().                  if(_mti >= N)                  {                      // generate N words at one time                      GenerateUInts();                  }                    y = _mt[_mti++];                    // Tempering                  y ^= (y >> 11);                  y ^= (y << 7) & 0x9d2c5680U;                  y ^= (y << 15) & 0xefc60000U;                  y ^= (y >> 18);                    buffer[i++] = (byte)y;                  buffer[i++] = (byte)(y >> 8);                  buffer[i++] = (byte)(y >> 16);                  buffer[i++] = (byte)(y >> 24);              }
Magic Number,MathNet.Numerics.RandomSources,MersenneTwisterRandomSource,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\MersenneTwisterRandomSource.cs,NextBytes,The following statement contains a magic number: while(i < buffer.Length - 3)              {                  // Its faster to explicitly calculate the unsigned random number than simply call NextUInt().                  if(_mti >= N)                  {                      // generate N words at one time                      GenerateUInts();                  }                    y = _mt[_mti++];                    // Tempering                  y ^= (y >> 11);                  y ^= (y << 7) & 0x9d2c5680U;                  y ^= (y << 15) & 0xefc60000U;                  y ^= (y >> 18);                    buffer[i++] = (byte)y;                  buffer[i++] = (byte)(y >> 8);                  buffer[i++] = (byte)(y >> 16);                  buffer[i++] = (byte)(y >> 24);              }
Magic Number,MathNet.Numerics.RandomSources,MersenneTwisterRandomSource,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\MersenneTwisterRandomSource.cs,NextBytes,The following statement contains a magic number: if(i < buffer.Length)              {                  // Its faster to explicitly calculate the unsigned random number than simply call NextUInt().                  if(_mti >= N)                  {                      // generate N words at one time                      GenerateUInts();                  }                    y = _mt[_mti++];                    // Tempering                  y ^= (y >> 11);                  y ^= (y << 7) & 0x9d2c5680U;                  y ^= (y << 15) & 0xefc60000U;                  y ^= (y >> 18);                    buffer[i++] = (byte)y;                  if(i < buffer.Length)                  {                      buffer[i++] = (byte)(y >> 8);                      if(i < buffer.Length)                      {                          buffer[i++] = (byte)(y >> 16);                          if(i < buffer.Length)                          {                              buffer[i] = (byte)(y >> 24);                          }                      }                  }              }
Magic Number,MathNet.Numerics.RandomSources,MersenneTwisterRandomSource,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\MersenneTwisterRandomSource.cs,NextBytes,The following statement contains a magic number: if(i < buffer.Length)              {                  // Its faster to explicitly calculate the unsigned random number than simply call NextUInt().                  if(_mti >= N)                  {                      // generate N words at one time                      GenerateUInts();                  }                    y = _mt[_mti++];                    // Tempering                  y ^= (y >> 11);                  y ^= (y << 7) & 0x9d2c5680U;                  y ^= (y << 15) & 0xefc60000U;                  y ^= (y >> 18);                    buffer[i++] = (byte)y;                  if(i < buffer.Length)                  {                      buffer[i++] = (byte)(y >> 8);                      if(i < buffer.Length)                      {                          buffer[i++] = (byte)(y >> 16);                          if(i < buffer.Length)                          {                              buffer[i] = (byte)(y >> 24);                          }                      }                  }              }
Magic Number,MathNet.Numerics.RandomSources,MersenneTwisterRandomSource,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\MersenneTwisterRandomSource.cs,NextBytes,The following statement contains a magic number: if(i < buffer.Length)              {                  // Its faster to explicitly calculate the unsigned random number than simply call NextUInt().                  if(_mti >= N)                  {                      // generate N words at one time                      GenerateUInts();                  }                    y = _mt[_mti++];                    // Tempering                  y ^= (y >> 11);                  y ^= (y << 7) & 0x9d2c5680U;                  y ^= (y << 15) & 0xefc60000U;                  y ^= (y >> 18);                    buffer[i++] = (byte)y;                  if(i < buffer.Length)                  {                      buffer[i++] = (byte)(y >> 8);                      if(i < buffer.Length)                      {                          buffer[i++] = (byte)(y >> 16);                          if(i < buffer.Length)                          {                              buffer[i] = (byte)(y >> 24);                          }                      }                  }              }
Magic Number,MathNet.Numerics.RandomSources,MersenneTwisterRandomSource,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\MersenneTwisterRandomSource.cs,NextBytes,The following statement contains a magic number: if(i < buffer.Length)              {                  // Its faster to explicitly calculate the unsigned random number than simply call NextUInt().                  if(_mti >= N)                  {                      // generate N words at one time                      GenerateUInts();                  }                    y = _mt[_mti++];                    // Tempering                  y ^= (y >> 11);                  y ^= (y << 7) & 0x9d2c5680U;                  y ^= (y << 15) & 0xefc60000U;                  y ^= (y >> 18);                    buffer[i++] = (byte)y;                  if(i < buffer.Length)                  {                      buffer[i++] = (byte)(y >> 8);                      if(i < buffer.Length)                      {                          buffer[i++] = (byte)(y >> 16);                          if(i < buffer.Length)                          {                              buffer[i] = (byte)(y >> 24);                          }                      }                  }              }
Magic Number,MathNet.Numerics.RandomSources,MersenneTwisterRandomSource,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\MersenneTwisterRandomSource.cs,NextBytes,The following statement contains a magic number: if(i < buffer.Length)              {                  // Its faster to explicitly calculate the unsigned random number than simply call NextUInt().                  if(_mti >= N)                  {                      // generate N words at one time                      GenerateUInts();                  }                    y = _mt[_mti++];                    // Tempering                  y ^= (y >> 11);                  y ^= (y << 7) & 0x9d2c5680U;                  y ^= (y << 15) & 0xefc60000U;                  y ^= (y >> 18);                    buffer[i++] = (byte)y;                  if(i < buffer.Length)                  {                      buffer[i++] = (byte)(y >> 8);                      if(i < buffer.Length)                      {                          buffer[i++] = (byte)(y >> 16);                          if(i < buffer.Length)                          {                              buffer[i] = (byte)(y >> 24);                          }                      }                  }              }
Magic Number,MathNet.Numerics.RandomSources,MersenneTwisterRandomSource,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\MersenneTwisterRandomSource.cs,NextBytes,The following statement contains a magic number: if(i < buffer.Length)              {                  // Its faster to explicitly calculate the unsigned random number than simply call NextUInt().                  if(_mti >= N)                  {                      // generate N words at one time                      GenerateUInts();                  }                    y = _mt[_mti++];                    // Tempering                  y ^= (y >> 11);                  y ^= (y << 7) & 0x9d2c5680U;                  y ^= (y << 15) & 0xefc60000U;                  y ^= (y >> 18);                    buffer[i++] = (byte)y;                  if(i < buffer.Length)                  {                      buffer[i++] = (byte)(y >> 8);                      if(i < buffer.Length)                      {                          buffer[i++] = (byte)(y >> 16);                          if(i < buffer.Length)                          {                              buffer[i] = (byte)(y >> 24);                          }                      }                  }              }
Magic Number,MathNet.Numerics.RandomSources,MersenneTwisterRandomSource,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\MersenneTwisterRandomSource.cs,NextBytes,The following statement contains a magic number: if(i < buffer.Length)              {                  // Its faster to explicitly calculate the unsigned random number than simply call NextUInt().                  if(_mti >= N)                  {                      // generate N words at one time                      GenerateUInts();                  }                    y = _mt[_mti++];                    // Tempering                  y ^= (y >> 11);                  y ^= (y << 7) & 0x9d2c5680U;                  y ^= (y << 15) & 0xefc60000U;                  y ^= (y >> 18);                    buffer[i++] = (byte)y;                  if(i < buffer.Length)                  {                      buffer[i++] = (byte)(y >> 8);                      if(i < buffer.Length)                      {                          buffer[i++] = (byte)(y >> 16);                          if(i < buffer.Length)                          {                              buffer[i] = (byte)(y >> 24);                          }                      }                  }              }
Magic Number,MathNet.Numerics.RandomSources,RandomSource,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\RandomSource.cs,NextDecimal,The following statement contains a magic number: do              {                  candidate = new decimal(                      NextFullRangeInt32()'                      NextFullRangeInt32()'                      NextFullRangeInt32()'                      false'                      28);              }              while(candidate >= 1.0m);
Magic Number,MathNet.Numerics.RandomSources,SystemRandomSource,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\SystemRandomSource.cs,NextBoolean,The following statement contains a magic number: if(_bitCount == 0)              {                  // Generate 31 more bits (1 int) and store it for future calls.                  _bitBuffer = _generator.Next();                    // Reset the bitCount and use rightmost bit of buffer to generate random bool.                  _bitCount = 30;                  return (_bitBuffer & 0x1) == 1;              }
Magic Number,MathNet.Numerics.RandomSources,XorShiftRandomSource,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\XorShiftRandomSource.cs,NextFullRangeInt32,The following statement contains a magic number: uint t = (_x ^ (_x << 11));
Magic Number,MathNet.Numerics.RandomSources,XorShiftRandomSource,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\XorShiftRandomSource.cs,NextFullRangeInt32,The following statement contains a magic number: _w = (_w ^ (_w >> 19)) ^ (t ^ (t >> 8));
Magic Number,MathNet.Numerics.RandomSources,XorShiftRandomSource,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\XorShiftRandomSource.cs,NextFullRangeInt32,The following statement contains a magic number: _w = (_w ^ (_w >> 19)) ^ (t ^ (t >> 8));
Magic Number,MathNet.Numerics.RandomSources,XorShiftRandomSource,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\XorShiftRandomSource.cs,NextFullRangeUInt32,The following statement contains a magic number: uint t = (_x ^ (_x << 11));
Magic Number,MathNet.Numerics.RandomSources,XorShiftRandomSource,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\XorShiftRandomSource.cs,NextFullRangeUInt32,The following statement contains a magic number: return _w = (_w ^ (_w >> 19)) ^ (t ^ (t >> 8));
Magic Number,MathNet.Numerics.RandomSources,XorShiftRandomSource,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\XorShiftRandomSource.cs,NextFullRangeUInt32,The following statement contains a magic number: return _w = (_w ^ (_w >> 19)) ^ (t ^ (t >> 8));
Magic Number,MathNet.Numerics.RandomSources,XorShiftRandomSource,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\XorShiftRandomSource.cs,NextInclusiveMaxValue,The following statement contains a magic number: uint t = (_x ^ (_x << 11));
Magic Number,MathNet.Numerics.RandomSources,XorShiftRandomSource,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\XorShiftRandomSource.cs,NextInclusiveMaxValue,The following statement contains a magic number: uint w = (_w = (_w ^ (_w >> 19)) ^ (t ^ (t >> 8)));
Magic Number,MathNet.Numerics.RandomSources,XorShiftRandomSource,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\XorShiftRandomSource.cs,NextInclusiveMaxValue,The following statement contains a magic number: uint w = (_w = (_w ^ (_w >> 19)) ^ (t ^ (t >> 8)));
Magic Number,MathNet.Numerics.RandomSources,XorShiftRandomSource,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\XorShiftRandomSource.cs,Next,The following statement contains a magic number: uint t = (_x ^ (_x << 11));
Magic Number,MathNet.Numerics.RandomSources,XorShiftRandomSource,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\XorShiftRandomSource.cs,Next,The following statement contains a magic number: uint w = (_w = (_w ^ (_w >> 19)) ^ (t ^ (t >> 8)));
Magic Number,MathNet.Numerics.RandomSources,XorShiftRandomSource,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\XorShiftRandomSource.cs,Next,The following statement contains a magic number: uint w = (_w = (_w ^ (_w >> 19)) ^ (t ^ (t >> 8)));
Magic Number,MathNet.Numerics.RandomSources,XorShiftRandomSource,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\XorShiftRandomSource.cs,Next,The following statement contains a magic number: uint t = (_x ^ (_x << 11));
Magic Number,MathNet.Numerics.RandomSources,XorShiftRandomSource,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\XorShiftRandomSource.cs,Next,The following statement contains a magic number: uint w = (_w = (_w ^ (_w >> 19)) ^ (t ^ (t >> 8)));
Magic Number,MathNet.Numerics.RandomSources,XorShiftRandomSource,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\XorShiftRandomSource.cs,Next,The following statement contains a magic number: uint w = (_w = (_w ^ (_w >> 19)) ^ (t ^ (t >> 8)));
Magic Number,MathNet.Numerics.RandomSources,XorShiftRandomSource,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\XorShiftRandomSource.cs,Next,The following statement contains a magic number: uint t = (_x ^ (_x << 11));
Magic Number,MathNet.Numerics.RandomSources,XorShiftRandomSource,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\XorShiftRandomSource.cs,Next,The following statement contains a magic number: uint w = (_w = (_w ^ (_w >> 19)) ^ (t ^ (t >> 8)));
Magic Number,MathNet.Numerics.RandomSources,XorShiftRandomSource,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\XorShiftRandomSource.cs,Next,The following statement contains a magic number: uint w = (_w = (_w ^ (_w >> 19)) ^ (t ^ (t >> 8)));
Magic Number,MathNet.Numerics.RandomSources,XorShiftRandomSource,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\XorShiftRandomSource.cs,NextDouble,The following statement contains a magic number: uint t = (_x ^ (_x << 11));
Magic Number,MathNet.Numerics.RandomSources,XorShiftRandomSource,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\XorShiftRandomSource.cs,NextDouble,The following statement contains a magic number: uint w = (_w = (_w ^ (_w >> 19)) ^ (t ^ (t >> 8)));
Magic Number,MathNet.Numerics.RandomSources,XorShiftRandomSource,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\XorShiftRandomSource.cs,NextDouble,The following statement contains a magic number: uint w = (_w = (_w ^ (_w >> 19)) ^ (t ^ (t >> 8)));
Magic Number,MathNet.Numerics.RandomSources,XorShiftRandomSource,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\XorShiftRandomSource.cs,NextDouble,The following statement contains a magic number: uint t = (_x ^ (_x << 11));
Magic Number,MathNet.Numerics.RandomSources,XorShiftRandomSource,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\XorShiftRandomSource.cs,NextDouble,The following statement contains a magic number: uint w = (_w = (_w ^ (_w >> 19)) ^ (t ^ (t >> 8)));
Magic Number,MathNet.Numerics.RandomSources,XorShiftRandomSource,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\XorShiftRandomSource.cs,NextDouble,The following statement contains a magic number: uint w = (_w = (_w ^ (_w >> 19)) ^ (t ^ (t >> 8)));
Magic Number,MathNet.Numerics.RandomSources,XorShiftRandomSource,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\XorShiftRandomSource.cs,NextDouble,The following statement contains a magic number: uint t = (_x ^ (_x << 11));
Magic Number,MathNet.Numerics.RandomSources,XorShiftRandomSource,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\XorShiftRandomSource.cs,NextDouble,The following statement contains a magic number: uint w = (_w = (_w ^ (_w >> 19)) ^ (t ^ (t >> 8)));
Magic Number,MathNet.Numerics.RandomSources,XorShiftRandomSource,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\XorShiftRandomSource.cs,NextDouble,The following statement contains a magic number: uint w = (_w = (_w ^ (_w >> 19)) ^ (t ^ (t >> 8)));
Magic Number,MathNet.Numerics.RandomSources,XorShiftRandomSource,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\XorShiftRandomSource.cs,NextBoolean,The following statement contains a magic number: if(_bitCount == 0)              {                  // Generate 32 more bits (1 uint) and store it for future calls.                  // Its faster to explicitly calculate the unsigned random number than simply call NextFullRangeUInt32().                  uint t = (_x ^ (_x << 11));                  _x = _y;                  _y = _z;                  _z = _w;                  _bitBuffer = (_w = (_w ^ (_w >> 19)) ^ (t ^ (t >> 8)));                    // Reset the bitCount and use rightmost bit of buffer to generate random bool.                  _bitCount = 31;                  return (_bitBuffer & 0x1) == 1;              }
Magic Number,MathNet.Numerics.RandomSources,XorShiftRandomSource,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\XorShiftRandomSource.cs,NextBoolean,The following statement contains a magic number: if(_bitCount == 0)              {                  // Generate 32 more bits (1 uint) and store it for future calls.                  // Its faster to explicitly calculate the unsigned random number than simply call NextFullRangeUInt32().                  uint t = (_x ^ (_x << 11));                  _x = _y;                  _y = _z;                  _z = _w;                  _bitBuffer = (_w = (_w ^ (_w >> 19)) ^ (t ^ (t >> 8)));                    // Reset the bitCount and use rightmost bit of buffer to generate random bool.                  _bitCount = 31;                  return (_bitBuffer & 0x1) == 1;              }
Magic Number,MathNet.Numerics.RandomSources,XorShiftRandomSource,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\XorShiftRandomSource.cs,NextBoolean,The following statement contains a magic number: if(_bitCount == 0)              {                  // Generate 32 more bits (1 uint) and store it for future calls.                  // Its faster to explicitly calculate the unsigned random number than simply call NextFullRangeUInt32().                  uint t = (_x ^ (_x << 11));                  _x = _y;                  _y = _z;                  _z = _w;                  _bitBuffer = (_w = (_w ^ (_w >> 19)) ^ (t ^ (t >> 8)));                    // Reset the bitCount and use rightmost bit of buffer to generate random bool.                  _bitCount = 31;                  return (_bitBuffer & 0x1) == 1;              }
Magic Number,MathNet.Numerics.RandomSources,XorShiftRandomSource,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\XorShiftRandomSource.cs,NextBoolean,The following statement contains a magic number: if(_bitCount == 0)              {                  // Generate 32 more bits (1 uint) and store it for future calls.                  // Its faster to explicitly calculate the unsigned random number than simply call NextFullRangeUInt32().                  uint t = (_x ^ (_x << 11));                  _x = _y;                  _y = _z;                  _z = _w;                  _bitBuffer = (_w = (_w ^ (_w >> 19)) ^ (t ^ (t >> 8)));                    // Reset the bitCount and use rightmost bit of buffer to generate random bool.                  _bitCount = 31;                  return (_bitBuffer & 0x1) == 1;              }
Magic Number,MathNet.Numerics.RandomSources,XorShiftRandomSource,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\XorShiftRandomSource.cs,NextBytes,The following statement contains a magic number: while(i < buffer.Length - 3)              {                  // Its faster to explicitly calculate the unsigned random number than simply call NextFullRangeUInt32().                  t = (x ^ (x << 11));                  x = y;                  y = z;                  z = w;                  w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));                    buffer[i++] = (byte)w;                  buffer[i++] = (byte)(w >> 8);                  buffer[i++] = (byte)(w >> 16);                  buffer[i++] = (byte)(w >> 24);              }
Magic Number,MathNet.Numerics.RandomSources,XorShiftRandomSource,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\XorShiftRandomSource.cs,NextBytes,The following statement contains a magic number: while(i < buffer.Length - 3)              {                  // Its faster to explicitly calculate the unsigned random number than simply call NextFullRangeUInt32().                  t = (x ^ (x << 11));                  x = y;                  y = z;                  z = w;                  w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));                    buffer[i++] = (byte)w;                  buffer[i++] = (byte)(w >> 8);                  buffer[i++] = (byte)(w >> 16);                  buffer[i++] = (byte)(w >> 24);              }
Magic Number,MathNet.Numerics.RandomSources,XorShiftRandomSource,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\XorShiftRandomSource.cs,NextBytes,The following statement contains a magic number: while(i < buffer.Length - 3)              {                  // Its faster to explicitly calculate the unsigned random number than simply call NextFullRangeUInt32().                  t = (x ^ (x << 11));                  x = y;                  y = z;                  z = w;                  w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));                    buffer[i++] = (byte)w;                  buffer[i++] = (byte)(w >> 8);                  buffer[i++] = (byte)(w >> 16);                  buffer[i++] = (byte)(w >> 24);              }
Magic Number,MathNet.Numerics.RandomSources,XorShiftRandomSource,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\XorShiftRandomSource.cs,NextBytes,The following statement contains a magic number: while(i < buffer.Length - 3)              {                  // Its faster to explicitly calculate the unsigned random number than simply call NextFullRangeUInt32().                  t = (x ^ (x << 11));                  x = y;                  y = z;                  z = w;                  w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));                    buffer[i++] = (byte)w;                  buffer[i++] = (byte)(w >> 8);                  buffer[i++] = (byte)(w >> 16);                  buffer[i++] = (byte)(w >> 24);              }
Magic Number,MathNet.Numerics.RandomSources,XorShiftRandomSource,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\XorShiftRandomSource.cs,NextBytes,The following statement contains a magic number: while(i < buffer.Length - 3)              {                  // Its faster to explicitly calculate the unsigned random number than simply call NextFullRangeUInt32().                  t = (x ^ (x << 11));                  x = y;                  y = z;                  z = w;                  w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));                    buffer[i++] = (byte)w;                  buffer[i++] = (byte)(w >> 8);                  buffer[i++] = (byte)(w >> 16);                  buffer[i++] = (byte)(w >> 24);              }
Magic Number,MathNet.Numerics.RandomSources,XorShiftRandomSource,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\XorShiftRandomSource.cs,NextBytes,The following statement contains a magic number: while(i < buffer.Length - 3)              {                  // Its faster to explicitly calculate the unsigned random number than simply call NextFullRangeUInt32().                  t = (x ^ (x << 11));                  x = y;                  y = z;                  z = w;                  w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));                    buffer[i++] = (byte)w;                  buffer[i++] = (byte)(w >> 8);                  buffer[i++] = (byte)(w >> 16);                  buffer[i++] = (byte)(w >> 24);              }
Magic Number,MathNet.Numerics.RandomSources,XorShiftRandomSource,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\XorShiftRandomSource.cs,NextBytes,The following statement contains a magic number: while(i < buffer.Length - 3)              {                  // Its faster to explicitly calculate the unsigned random number than simply call NextFullRangeUInt32().                  t = (x ^ (x << 11));                  x = y;                  y = z;                  z = w;                  w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));                    buffer[i++] = (byte)w;                  buffer[i++] = (byte)(w >> 8);                  buffer[i++] = (byte)(w >> 16);                  buffer[i++] = (byte)(w >> 24);              }
Magic Number,MathNet.Numerics.RandomSources,XorShiftRandomSource,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\XorShiftRandomSource.cs,NextBytes,The following statement contains a magic number: if(i < buffer.Length)              {                  // Its faster to explicitly calculate the unsigned random number than simply call NextFullRangeUInt32().                  t = (x ^ (x << 11));                  x = y;                  y = z;                  z = w;                  w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));                    buffer[i++] = (byte)w;                  if(i < buffer.Length)                  {                      buffer[i++] = (byte)(w >> 8);                      if(i < buffer.Length)                      {                          buffer[i++] = (byte)(w >> 16);                          if(i < buffer.Length)                          {                              buffer[i] = (byte)(w >> 24);                          }                      }                  }              }
Magic Number,MathNet.Numerics.RandomSources,XorShiftRandomSource,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\XorShiftRandomSource.cs,NextBytes,The following statement contains a magic number: if(i < buffer.Length)              {                  // Its faster to explicitly calculate the unsigned random number than simply call NextFullRangeUInt32().                  t = (x ^ (x << 11));                  x = y;                  y = z;                  z = w;                  w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));                    buffer[i++] = (byte)w;                  if(i < buffer.Length)                  {                      buffer[i++] = (byte)(w >> 8);                      if(i < buffer.Length)                      {                          buffer[i++] = (byte)(w >> 16);                          if(i < buffer.Length)                          {                              buffer[i] = (byte)(w >> 24);                          }                      }                  }              }
Magic Number,MathNet.Numerics.RandomSources,XorShiftRandomSource,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\XorShiftRandomSource.cs,NextBytes,The following statement contains a magic number: if(i < buffer.Length)              {                  // Its faster to explicitly calculate the unsigned random number than simply call NextFullRangeUInt32().                  t = (x ^ (x << 11));                  x = y;                  y = z;                  z = w;                  w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));                    buffer[i++] = (byte)w;                  if(i < buffer.Length)                  {                      buffer[i++] = (byte)(w >> 8);                      if(i < buffer.Length)                      {                          buffer[i++] = (byte)(w >> 16);                          if(i < buffer.Length)                          {                              buffer[i] = (byte)(w >> 24);                          }                      }                  }              }
Magic Number,MathNet.Numerics.RandomSources,XorShiftRandomSource,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\XorShiftRandomSource.cs,NextBytes,The following statement contains a magic number: if(i < buffer.Length)              {                  // Its faster to explicitly calculate the unsigned random number than simply call NextFullRangeUInt32().                  t = (x ^ (x << 11));                  x = y;                  y = z;                  z = w;                  w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));                    buffer[i++] = (byte)w;                  if(i < buffer.Length)                  {                      buffer[i++] = (byte)(w >> 8);                      if(i < buffer.Length)                      {                          buffer[i++] = (byte)(w >> 16);                          if(i < buffer.Length)                          {                              buffer[i] = (byte)(w >> 24);                          }                      }                  }              }
Magic Number,MathNet.Numerics.RandomSources,XorShiftRandomSource,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\XorShiftRandomSource.cs,NextBytes,The following statement contains a magic number: if(i < buffer.Length)              {                  // Its faster to explicitly calculate the unsigned random number than simply call NextFullRangeUInt32().                  t = (x ^ (x << 11));                  x = y;                  y = z;                  z = w;                  w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));                    buffer[i++] = (byte)w;                  if(i < buffer.Length)                  {                      buffer[i++] = (byte)(w >> 8);                      if(i < buffer.Length)                      {                          buffer[i++] = (byte)(w >> 16);                          if(i < buffer.Length)                          {                              buffer[i] = (byte)(w >> 24);                          }                      }                  }              }
Magic Number,MathNet.Numerics.RandomSources,XorShiftRandomSource,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\XorShiftRandomSource.cs,NextBytes,The following statement contains a magic number: if(i < buffer.Length)              {                  // Its faster to explicitly calculate the unsigned random number than simply call NextFullRangeUInt32().                  t = (x ^ (x << 11));                  x = y;                  y = z;                  z = w;                  w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));                    buffer[i++] = (byte)w;                  if(i < buffer.Length)                  {                      buffer[i++] = (byte)(w >> 8);                      if(i < buffer.Length)                      {                          buffer[i++] = (byte)(w >> 16);                          if(i < buffer.Length)                          {                              buffer[i] = (byte)(w >> 24);                          }                      }                  }              }
Magic Number,MathNet.Numerics.RandomSources.ObjectModel,RandomByteSourceAdapter,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\RandomSources\ObjectModel\RandomByteSourceAdapter.cs,NextBoolean,The following statement contains a magic number: if(_bitCount == 0)              {                  // Generate 31 more bits (1 int) and store it for future calls.                  _bitBuffer = NextFullRangeInt32();                    // Reset the bitCount and use rightmost bit of buffer to generate random bool.                  _bitCount = 30;                  return (_bitBuffer & 0x1) == 1;              }
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,BetaRegularizedAlgorithm,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\BetaRegularizedAlgorithm.cs,BetaRegularized,The following statement contains a magic number: bool symmetryTransformation = (x >= (a + 1.0) / (a + b + 2.0));
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,BetaRegularizedAlgorithm,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\BetaRegularizedAlgorithm.cs,BetaRegularized,The following statement contains a magic number: const int MaxIterations = 100;
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,BetaRegularizedAlgorithm,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\BetaRegularizedAlgorithm.cs,BetaRegularized,The following statement contains a magic number: for(int m = 1' m2 = 2; m <= MaxIterations; m++' m2 += 2)              {                  double aa = m * (b - m) * x / ((qam + m2) * (a + m2));                  d = 1.0 + (aa * d);                    if(Math.Abs(d) < fpmin)                  {                      d = fpmin;                  }                    c = 1.0 + (aa / c);                  if(Math.Abs(c) < fpmin)                  {                      c = fpmin;                  }                    d = 1.0 / d;                  h *= d * c;                  aa = -(a + m) * (qab + m) * x / ((a + m2) * (qap + m2));                  d = 1.0 + (aa * d);                    if(Math.Abs(d) < fpmin)                  {                      d = fpmin;                  }                    c = 1.0 + (aa / c);                    if(Math.Abs(c) < fpmin)                  {                      c = fpmin;                  }                    d = 1.0 / d;                  double del = d * c;                  h *= del;                    if(Math.Abs(del - 1.0) <= eps)                  {                      if(symmetryTransformation)                      {                          return 1.0 - (bt * h / a);                      }                        return bt * h / a;                  }              }
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,BetaRegularizedAlgorithm,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\BetaRegularizedAlgorithm.cs,BetaRegularized,The following statement contains a magic number: for(int m = 1' m2 = 2; m <= MaxIterations; m++' m2 += 2)              {                  double aa = m * (b - m) * x / ((qam + m2) * (a + m2));                  d = 1.0 + (aa * d);                    if(Math.Abs(d) < fpmin)                  {                      d = fpmin;                  }                    c = 1.0 + (aa / c);                  if(Math.Abs(c) < fpmin)                  {                      c = fpmin;                  }                    d = 1.0 / d;                  h *= d * c;                  aa = -(a + m) * (qab + m) * x / ((a + m2) * (qap + m2));                  d = 1.0 + (aa * d);                    if(Math.Abs(d) < fpmin)                  {                      d = fpmin;                  }                    c = 1.0 + (aa / c);                    if(Math.Abs(c) < fpmin)                  {                      c = fpmin;                  }                    d = 1.0 / d;                  double del = d * c;                  h *= del;                    if(Math.Abs(del - 1.0) <= eps)                  {                      if(symmetryTransformation)                      {                          return 1.0 - (bt * h / a);                      }                        return bt * h / a;                  }              }
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,DigammaAlgorithm,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\DigammaAlgorithm.cs,Digamma,The following statement contains a magic number: if(negative)              {                  double q = x;                  double p = Math.Floor(q);                    if(Number.AlmostEqual(p' q))                  {                      return double.NaN; // singularity' undefined                  }                    nz = q - p;                    if(nz != 0.5)                  {                      if(nz > 0.5)                      {                          p = p + 1.0;                          nz = q - p;                      }                        nz = Math.PI / Math.Tan(Math.PI * nz);                  }                  else                  {                      nz = 0.0;                  }                    x = 1.0 - x;              }
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,DigammaAlgorithm,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\DigammaAlgorithm.cs,Digamma,The following statement contains a magic number: if(negative)              {                  double q = x;                  double p = Math.Floor(q);                    if(Number.AlmostEqual(p' q))                  {                      return double.NaN; // singularity' undefined                  }                    nz = q - p;                    if(nz != 0.5)                  {                      if(nz > 0.5)                      {                          p = p + 1.0;                          nz = q - p;                      }                        nz = Math.PI / Math.Tan(Math.PI * nz);                  }                  else                  {                      nz = 0.0;                  }                    x = 1.0 - x;              }
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,DigammaAlgorithm,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\DigammaAlgorithm.cs,Digamma,The following statement contains a magic number: if((x <= 10.0) && (x == Math.Floor(x)))              {                  y = 0.0;                  int n = (int)Math.Floor(x);                    for(int i = 1; i <= n - 1; i++)                  {                      y = y + (1.0 / i);                  }                    y = y - Constants.EulerGamma;              }              else              {                  double s = x;                  double w = 0.0;                    while(s < 10.0)                  {                      w = w + (1.0 / s);                      s = s + 1.0;                  }                    if(s < 1.0e17)                  {                      double z = 1.0 / (s * s);                      double polv = 8.33333333333333333333e-2;                      polv = (polv * z) - 2.10927960927960927961e-2;                      polv = (polv * z) + 7.57575757575757575758e-3;                      polv = (polv * z) - 4.16666666666666666667e-3;                      polv = (polv * z) + 3.96825396825396825397e-3;                      polv = (polv * z) - 8.33333333333333333333e-3;                      polv = (polv * z) + 8.33333333333333333333e-2;                      y = z * polv;                  }                  else                  {                      y = 0.0;                  }                    y = Math.Log(s) - (0.5 / s) - y - w;              }
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,DigammaAlgorithm,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\DigammaAlgorithm.cs,Digamma,The following statement contains a magic number: if((x <= 10.0) && (x == Math.Floor(x)))              {                  y = 0.0;                  int n = (int)Math.Floor(x);                    for(int i = 1; i <= n - 1; i++)                  {                      y = y + (1.0 / i);                  }                    y = y - Constants.EulerGamma;              }              else              {                  double s = x;                  double w = 0.0;                    while(s < 10.0)                  {                      w = w + (1.0 / s);                      s = s + 1.0;                  }                    if(s < 1.0e17)                  {                      double z = 1.0 / (s * s);                      double polv = 8.33333333333333333333e-2;                      polv = (polv * z) - 2.10927960927960927961e-2;                      polv = (polv * z) + 7.57575757575757575758e-3;                      polv = (polv * z) - 4.16666666666666666667e-3;                      polv = (polv * z) + 3.96825396825396825397e-3;                      polv = (polv * z) - 8.33333333333333333333e-3;                      polv = (polv * z) + 8.33333333333333333333e-2;                      y = z * polv;                  }                  else                  {                      y = 0.0;                  }                    y = Math.Log(s) - (0.5 / s) - y - w;              }
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,DigammaAlgorithm,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\DigammaAlgorithm.cs,Digamma,The following statement contains a magic number: if((x <= 10.0) && (x == Math.Floor(x)))              {                  y = 0.0;                  int n = (int)Math.Floor(x);                    for(int i = 1; i <= n - 1; i++)                  {                      y = y + (1.0 / i);                  }                    y = y - Constants.EulerGamma;              }              else              {                  double s = x;                  double w = 0.0;                    while(s < 10.0)                  {                      w = w + (1.0 / s);                      s = s + 1.0;                  }                    if(s < 1.0e17)                  {                      double z = 1.0 / (s * s);                      double polv = 8.33333333333333333333e-2;                      polv = (polv * z) - 2.10927960927960927961e-2;                      polv = (polv * z) + 7.57575757575757575758e-3;                      polv = (polv * z) - 4.16666666666666666667e-3;                      polv = (polv * z) + 3.96825396825396825397e-3;                      polv = (polv * z) - 8.33333333333333333333e-3;                      polv = (polv * z) + 8.33333333333333333333e-2;                      y = z * polv;                  }                  else                  {                      y = 0.0;                  }                    y = Math.Log(s) - (0.5 / s) - y - w;              }
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,DigammaAlgorithm,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\DigammaAlgorithm.cs,Digamma,The following statement contains a magic number: if((x <= 10.0) && (x == Math.Floor(x)))              {                  y = 0.0;                  int n = (int)Math.Floor(x);                    for(int i = 1; i <= n - 1; i++)                  {                      y = y + (1.0 / i);                  }                    y = y - Constants.EulerGamma;              }              else              {                  double s = x;                  double w = 0.0;                    while(s < 10.0)                  {                      w = w + (1.0 / s);                      s = s + 1.0;                  }                    if(s < 1.0e17)                  {                      double z = 1.0 / (s * s);                      double polv = 8.33333333333333333333e-2;                      polv = (polv * z) - 2.10927960927960927961e-2;                      polv = (polv * z) + 7.57575757575757575758e-3;                      polv = (polv * z) - 4.16666666666666666667e-3;                      polv = (polv * z) + 3.96825396825396825397e-3;                      polv = (polv * z) - 8.33333333333333333333e-3;                      polv = (polv * z) + 8.33333333333333333333e-2;                      y = z * polv;                  }                  else                  {                      y = 0.0;                  }                    y = Math.Log(s) - (0.5 / s) - y - w;              }
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,DigammaAlgorithm,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\DigammaAlgorithm.cs,Digamma,The following statement contains a magic number: if((x <= 10.0) && (x == Math.Floor(x)))              {                  y = 0.0;                  int n = (int)Math.Floor(x);                    for(int i = 1; i <= n - 1; i++)                  {                      y = y + (1.0 / i);                  }                    y = y - Constants.EulerGamma;              }              else              {                  double s = x;                  double w = 0.0;                    while(s < 10.0)                  {                      w = w + (1.0 / s);                      s = s + 1.0;                  }                    if(s < 1.0e17)                  {                      double z = 1.0 / (s * s);                      double polv = 8.33333333333333333333e-2;                      polv = (polv * z) - 2.10927960927960927961e-2;                      polv = (polv * z) + 7.57575757575757575758e-3;                      polv = (polv * z) - 4.16666666666666666667e-3;                      polv = (polv * z) + 3.96825396825396825397e-3;                      polv = (polv * z) - 8.33333333333333333333e-3;                      polv = (polv * z) + 8.33333333333333333333e-2;                      y = z * polv;                  }                  else                  {                      y = 0.0;                  }                    y = Math.Log(s) - (0.5 / s) - y - w;              }
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,DigammaAlgorithm,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\DigammaAlgorithm.cs,Digamma,The following statement contains a magic number: if((x <= 10.0) && (x == Math.Floor(x)))              {                  y = 0.0;                  int n = (int)Math.Floor(x);                    for(int i = 1; i <= n - 1; i++)                  {                      y = y + (1.0 / i);                  }                    y = y - Constants.EulerGamma;              }              else              {                  double s = x;                  double w = 0.0;                    while(s < 10.0)                  {                      w = w + (1.0 / s);                      s = s + 1.0;                  }                    if(s < 1.0e17)                  {                      double z = 1.0 / (s * s);                      double polv = 8.33333333333333333333e-2;                      polv = (polv * z) - 2.10927960927960927961e-2;                      polv = (polv * z) + 7.57575757575757575758e-3;                      polv = (polv * z) - 4.16666666666666666667e-3;                      polv = (polv * z) + 3.96825396825396825397e-3;                      polv = (polv * z) - 8.33333333333333333333e-3;                      polv = (polv * z) + 8.33333333333333333333e-2;                      y = z * polv;                  }                  else                  {                      y = 0.0;                  }                    y = Math.Log(s) - (0.5 / s) - y - w;              }
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,DigammaAlgorithm,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\DigammaAlgorithm.cs,Digamma,The following statement contains a magic number: if((x <= 10.0) && (x == Math.Floor(x)))              {                  y = 0.0;                  int n = (int)Math.Floor(x);                    for(int i = 1; i <= n - 1; i++)                  {                      y = y + (1.0 / i);                  }                    y = y - Constants.EulerGamma;              }              else              {                  double s = x;                  double w = 0.0;                    while(s < 10.0)                  {                      w = w + (1.0 / s);                      s = s + 1.0;                  }                    if(s < 1.0e17)                  {                      double z = 1.0 / (s * s);                      double polv = 8.33333333333333333333e-2;                      polv = (polv * z) - 2.10927960927960927961e-2;                      polv = (polv * z) + 7.57575757575757575758e-3;                      polv = (polv * z) - 4.16666666666666666667e-3;                      polv = (polv * z) + 3.96825396825396825397e-3;                      polv = (polv * z) - 8.33333333333333333333e-3;                      polv = (polv * z) + 8.33333333333333333333e-2;                      y = z * polv;                  }                  else                  {                      y = 0.0;                  }                    y = Math.Log(s) - (0.5 / s) - y - w;              }
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,DigammaAlgorithm,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\DigammaAlgorithm.cs,Digamma,The following statement contains a magic number: if((x <= 10.0) && (x == Math.Floor(x)))              {                  y = 0.0;                  int n = (int)Math.Floor(x);                    for(int i = 1; i <= n - 1; i++)                  {                      y = y + (1.0 / i);                  }                    y = y - Constants.EulerGamma;              }              else              {                  double s = x;                  double w = 0.0;                    while(s < 10.0)                  {                      w = w + (1.0 / s);                      s = s + 1.0;                  }                    if(s < 1.0e17)                  {                      double z = 1.0 / (s * s);                      double polv = 8.33333333333333333333e-2;                      polv = (polv * z) - 2.10927960927960927961e-2;                      polv = (polv * z) + 7.57575757575757575758e-3;                      polv = (polv * z) - 4.16666666666666666667e-3;                      polv = (polv * z) + 3.96825396825396825397e-3;                      polv = (polv * z) - 8.33333333333333333333e-3;                      polv = (polv * z) + 8.33333333333333333333e-2;                      y = z * polv;                  }                  else                  {                      y = 0.0;                  }                    y = Math.Log(s) - (0.5 / s) - y - w;              }
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,DigammaAlgorithm,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\DigammaAlgorithm.cs,Digamma,The following statement contains a magic number: if((x <= 10.0) && (x == Math.Floor(x)))              {                  y = 0.0;                  int n = (int)Math.Floor(x);                    for(int i = 1; i <= n - 1; i++)                  {                      y = y + (1.0 / i);                  }                    y = y - Constants.EulerGamma;              }              else              {                  double s = x;                  double w = 0.0;                    while(s < 10.0)                  {                      w = w + (1.0 / s);                      s = s + 1.0;                  }                    if(s < 1.0e17)                  {                      double z = 1.0 / (s * s);                      double polv = 8.33333333333333333333e-2;                      polv = (polv * z) - 2.10927960927960927961e-2;                      polv = (polv * z) + 7.57575757575757575758e-3;                      polv = (polv * z) - 4.16666666666666666667e-3;                      polv = (polv * z) + 3.96825396825396825397e-3;                      polv = (polv * z) - 8.33333333333333333333e-3;                      polv = (polv * z) + 8.33333333333333333333e-2;                      y = z * polv;                  }                  else                  {                      y = 0.0;                  }                    y = Math.Log(s) - (0.5 / s) - y - w;              }
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,DigammaAlgorithm,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\DigammaAlgorithm.cs,Digamma,The following statement contains a magic number: if((x <= 10.0) && (x == Math.Floor(x)))              {                  y = 0.0;                  int n = (int)Math.Floor(x);                    for(int i = 1; i <= n - 1; i++)                  {                      y = y + (1.0 / i);                  }                    y = y - Constants.EulerGamma;              }              else              {                  double s = x;                  double w = 0.0;                    while(s < 10.0)                  {                      w = w + (1.0 / s);                      s = s + 1.0;                  }                    if(s < 1.0e17)                  {                      double z = 1.0 / (s * s);                      double polv = 8.33333333333333333333e-2;                      polv = (polv * z) - 2.10927960927960927961e-2;                      polv = (polv * z) + 7.57575757575757575758e-3;                      polv = (polv * z) - 4.16666666666666666667e-3;                      polv = (polv * z) + 3.96825396825396825397e-3;                      polv = (polv * z) - 8.33333333333333333333e-3;                      polv = (polv * z) + 8.33333333333333333333e-2;                      y = z * polv;                  }                  else                  {                      y = 0.0;                  }                    y = Math.Log(s) - (0.5 / s) - y - w;              }
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,DigammaAlgorithm,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\DigammaAlgorithm.cs,Digamma,The following statement contains a magic number: if((x <= 10.0) && (x == Math.Floor(x)))              {                  y = 0.0;                  int n = (int)Math.Floor(x);                    for(int i = 1; i <= n - 1; i++)                  {                      y = y + (1.0 / i);                  }                    y = y - Constants.EulerGamma;              }              else              {                  double s = x;                  double w = 0.0;                    while(s < 10.0)                  {                      w = w + (1.0 / s);                      s = s + 1.0;                  }                    if(s < 1.0e17)                  {                      double z = 1.0 / (s * s);                      double polv = 8.33333333333333333333e-2;                      polv = (polv * z) - 2.10927960927960927961e-2;                      polv = (polv * z) + 7.57575757575757575758e-3;                      polv = (polv * z) - 4.16666666666666666667e-3;                      polv = (polv * z) + 3.96825396825396825397e-3;                      polv = (polv * z) - 8.33333333333333333333e-3;                      polv = (polv * z) + 8.33333333333333333333e-2;                      y = z * polv;                  }                  else                  {                      y = 0.0;                  }                    y = Math.Log(s) - (0.5 / s) - y - w;              }
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,ErrorFunctionAlgorithm,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\ErrorFunctionAlgorithm.cs,Erf,The following statement contains a magic number: return x < 0.0                  ? -GammaRegularizedAlgorithm.GammaRegularized(0.5' x * x)                  : GammaRegularizedAlgorithm.GammaRegularized(0.5' x * x);
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,ErrorFunctionAlgorithm,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\ErrorFunctionAlgorithm.cs,Erf,The following statement contains a magic number: return x < 0.0                  ? -GammaRegularizedAlgorithm.GammaRegularized(0.5' x * x)                  : GammaRegularizedAlgorithm.GammaRegularized(0.5' x * x);
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,ErrorFunctionAlgorithm,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\ErrorFunctionAlgorithm.cs,ErfInverse,The following statement contains a magic number: x = 0.5 * (x + 1.0);
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,ErrorFunctionAlgorithm,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\ErrorFunctionAlgorithm.cs,ErfInverse,The following statement contains a magic number: const double Plow = 0.02425;
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,ErrorFunctionAlgorithm,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\ErrorFunctionAlgorithm.cs,ErfInverse,The following statement contains a magic number: if(x < Plow)              {                  q = Math.Sqrt(-2 * Math.Log(x));                  return ((((((((((ErfInvC[0] * q) + ErfInvC[1]) * q) + ErfInvC[2]) * q) + ErfInvC[3]) * q) + ErfInvC[4]) * q) + ErfInvC[5]) /                      ((((((((ErfInvD[0] * q) + ErfInvD[1]) * q) + ErfInvD[2]) * q) + ErfInvD[3]) * q) + 1)                      * Constants.Sqrt1_2;              }
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,ErrorFunctionAlgorithm,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\ErrorFunctionAlgorithm.cs,ErfInverse,The following statement contains a magic number: if(x < Plow)              {                  q = Math.Sqrt(-2 * Math.Log(x));                  return ((((((((((ErfInvC[0] * q) + ErfInvC[1]) * q) + ErfInvC[2]) * q) + ErfInvC[3]) * q) + ErfInvC[4]) * q) + ErfInvC[5]) /                      ((((((((ErfInvD[0] * q) + ErfInvD[1]) * q) + ErfInvD[2]) * q) + ErfInvD[3]) * q) + 1)                      * Constants.Sqrt1_2;              }
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,ErrorFunctionAlgorithm,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\ErrorFunctionAlgorithm.cs,ErfInverse,The following statement contains a magic number: if(x < Plow)              {                  q = Math.Sqrt(-2 * Math.Log(x));                  return ((((((((((ErfInvC[0] * q) + ErfInvC[1]) * q) + ErfInvC[2]) * q) + ErfInvC[3]) * q) + ErfInvC[4]) * q) + ErfInvC[5]) /                      ((((((((ErfInvD[0] * q) + ErfInvD[1]) * q) + ErfInvD[2]) * q) + ErfInvD[3]) * q) + 1)                      * Constants.Sqrt1_2;              }
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,ErrorFunctionAlgorithm,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\ErrorFunctionAlgorithm.cs,ErfInverse,The following statement contains a magic number: if(x < Plow)              {                  q = Math.Sqrt(-2 * Math.Log(x));                  return ((((((((((ErfInvC[0] * q) + ErfInvC[1]) * q) + ErfInvC[2]) * q) + ErfInvC[3]) * q) + ErfInvC[4]) * q) + ErfInvC[5]) /                      ((((((((ErfInvD[0] * q) + ErfInvD[1]) * q) + ErfInvD[2]) * q) + ErfInvD[3]) * q) + 1)                      * Constants.Sqrt1_2;              }
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,ErrorFunctionAlgorithm,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\ErrorFunctionAlgorithm.cs,ErfInverse,The following statement contains a magic number: if(x < Plow)              {                  q = Math.Sqrt(-2 * Math.Log(x));                  return ((((((((((ErfInvC[0] * q) + ErfInvC[1]) * q) + ErfInvC[2]) * q) + ErfInvC[3]) * q) + ErfInvC[4]) * q) + ErfInvC[5]) /                      ((((((((ErfInvD[0] * q) + ErfInvD[1]) * q) + ErfInvD[2]) * q) + ErfInvD[3]) * q) + 1)                      * Constants.Sqrt1_2;              }
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,ErrorFunctionAlgorithm,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\ErrorFunctionAlgorithm.cs,ErfInverse,The following statement contains a magic number: if(x < Plow)              {                  q = Math.Sqrt(-2 * Math.Log(x));                  return ((((((((((ErfInvC[0] * q) + ErfInvC[1]) * q) + ErfInvC[2]) * q) + ErfInvC[3]) * q) + ErfInvC[4]) * q) + ErfInvC[5]) /                      ((((((((ErfInvD[0] * q) + ErfInvD[1]) * q) + ErfInvD[2]) * q) + ErfInvD[3]) * q) + 1)                      * Constants.Sqrt1_2;              }
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,ErrorFunctionAlgorithm,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\ErrorFunctionAlgorithm.cs,ErfInverse,The following statement contains a magic number: if(x < Plow)              {                  q = Math.Sqrt(-2 * Math.Log(x));                  return ((((((((((ErfInvC[0] * q) + ErfInvC[1]) * q) + ErfInvC[2]) * q) + ErfInvC[3]) * q) + ErfInvC[4]) * q) + ErfInvC[5]) /                      ((((((((ErfInvD[0] * q) + ErfInvD[1]) * q) + ErfInvD[2]) * q) + ErfInvD[3]) * q) + 1)                      * Constants.Sqrt1_2;              }
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,ErrorFunctionAlgorithm,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\ErrorFunctionAlgorithm.cs,ErfInverse,The following statement contains a magic number: if(Phigh < x)              {                  q = Math.Sqrt(-2 * Math.Log(1 - x));                  return -((((((((((ErfInvC[0] * q) + ErfInvC[1]) * q) + ErfInvC[2]) * q) + ErfInvC[3]) * q) + ErfInvC[4]) * q) + ErfInvC[5]) /                      ((((((((ErfInvD[0] * q) + ErfInvD[1]) * q) + ErfInvD[2]) * q) + ErfInvD[3]) * q) + 1)                      * Constants.Sqrt1_2;              }
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,ErrorFunctionAlgorithm,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\ErrorFunctionAlgorithm.cs,ErfInverse,The following statement contains a magic number: if(Phigh < x)              {                  q = Math.Sqrt(-2 * Math.Log(1 - x));                  return -((((((((((ErfInvC[0] * q) + ErfInvC[1]) * q) + ErfInvC[2]) * q) + ErfInvC[3]) * q) + ErfInvC[4]) * q) + ErfInvC[5]) /                      ((((((((ErfInvD[0] * q) + ErfInvD[1]) * q) + ErfInvD[2]) * q) + ErfInvD[3]) * q) + 1)                      * Constants.Sqrt1_2;              }
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,ErrorFunctionAlgorithm,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\ErrorFunctionAlgorithm.cs,ErfInverse,The following statement contains a magic number: if(Phigh < x)              {                  q = Math.Sqrt(-2 * Math.Log(1 - x));                  return -((((((((((ErfInvC[0] * q) + ErfInvC[1]) * q) + ErfInvC[2]) * q) + ErfInvC[3]) * q) + ErfInvC[4]) * q) + ErfInvC[5]) /                      ((((((((ErfInvD[0] * q) + ErfInvD[1]) * q) + ErfInvD[2]) * q) + ErfInvD[3]) * q) + 1)                      * Constants.Sqrt1_2;              }
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,ErrorFunctionAlgorithm,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\ErrorFunctionAlgorithm.cs,ErfInverse,The following statement contains a magic number: if(Phigh < x)              {                  q = Math.Sqrt(-2 * Math.Log(1 - x));                  return -((((((((((ErfInvC[0] * q) + ErfInvC[1]) * q) + ErfInvC[2]) * q) + ErfInvC[3]) * q) + ErfInvC[4]) * q) + ErfInvC[5]) /                      ((((((((ErfInvD[0] * q) + ErfInvD[1]) * q) + ErfInvD[2]) * q) + ErfInvD[3]) * q) + 1)                      * Constants.Sqrt1_2;              }
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,ErrorFunctionAlgorithm,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\ErrorFunctionAlgorithm.cs,ErfInverse,The following statement contains a magic number: if(Phigh < x)              {                  q = Math.Sqrt(-2 * Math.Log(1 - x));                  return -((((((((((ErfInvC[0] * q) + ErfInvC[1]) * q) + ErfInvC[2]) * q) + ErfInvC[3]) * q) + ErfInvC[4]) * q) + ErfInvC[5]) /                      ((((((((ErfInvD[0] * q) + ErfInvD[1]) * q) + ErfInvD[2]) * q) + ErfInvD[3]) * q) + 1)                      * Constants.Sqrt1_2;              }
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,ErrorFunctionAlgorithm,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\ErrorFunctionAlgorithm.cs,ErfInverse,The following statement contains a magic number: if(Phigh < x)              {                  q = Math.Sqrt(-2 * Math.Log(1 - x));                  return -((((((((((ErfInvC[0] * q) + ErfInvC[1]) * q) + ErfInvC[2]) * q) + ErfInvC[3]) * q) + ErfInvC[4]) * q) + ErfInvC[5]) /                      ((((((((ErfInvD[0] * q) + ErfInvD[1]) * q) + ErfInvD[2]) * q) + ErfInvD[3]) * q) + 1)                      * Constants.Sqrt1_2;              }
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,ErrorFunctionAlgorithm,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\ErrorFunctionAlgorithm.cs,ErfInverse,The following statement contains a magic number: if(Phigh < x)              {                  q = Math.Sqrt(-2 * Math.Log(1 - x));                  return -((((((((((ErfInvC[0] * q) + ErfInvC[1]) * q) + ErfInvC[2]) * q) + ErfInvC[3]) * q) + ErfInvC[4]) * q) + ErfInvC[5]) /                      ((((((((ErfInvD[0] * q) + ErfInvD[1]) * q) + ErfInvD[2]) * q) + ErfInvD[3]) * q) + 1)                      * Constants.Sqrt1_2;              }
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,ErrorFunctionAlgorithm,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\ErrorFunctionAlgorithm.cs,ErfInverse,The following statement contains a magic number: q = x - 0.5;
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,ErrorFunctionAlgorithm,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\ErrorFunctionAlgorithm.cs,ErfInverse,The following statement contains a magic number: return ((((((((((ErfInvA[0] * r) + ErfInvA[1]) * r) + ErfInvA[2]) * r) + ErfInvA[3]) * r) + ErfInvA[4]) * r) + ErfInvA[5]) * q /                  ((((((((((ErfInvB[0] * r) + ErfInvB[1]) * r) + ErfInvB[2]) * r) + ErfInvB[3]) * r) + ErfInvB[4]) * r) + 1)                  * Constants.Sqrt1_2;
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,ErrorFunctionAlgorithm,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\ErrorFunctionAlgorithm.cs,ErfInverse,The following statement contains a magic number: return ((((((((((ErfInvA[0] * r) + ErfInvA[1]) * r) + ErfInvA[2]) * r) + ErfInvA[3]) * r) + ErfInvA[4]) * r) + ErfInvA[5]) * q /                  ((((((((((ErfInvB[0] * r) + ErfInvB[1]) * r) + ErfInvB[2]) * r) + ErfInvB[3]) * r) + ErfInvB[4]) * r) + 1)                  * Constants.Sqrt1_2;
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,ErrorFunctionAlgorithm,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\ErrorFunctionAlgorithm.cs,ErfInverse,The following statement contains a magic number: return ((((((((((ErfInvA[0] * r) + ErfInvA[1]) * r) + ErfInvA[2]) * r) + ErfInvA[3]) * r) + ErfInvA[4]) * r) + ErfInvA[5]) * q /                  ((((((((((ErfInvB[0] * r) + ErfInvB[1]) * r) + ErfInvB[2]) * r) + ErfInvB[3]) * r) + ErfInvB[4]) * r) + 1)                  * Constants.Sqrt1_2;
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,ErrorFunctionAlgorithm,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\ErrorFunctionAlgorithm.cs,ErfInverse,The following statement contains a magic number: return ((((((((((ErfInvA[0] * r) + ErfInvA[1]) * r) + ErfInvA[2]) * r) + ErfInvA[3]) * r) + ErfInvA[4]) * r) + ErfInvA[5]) * q /                  ((((((((((ErfInvB[0] * r) + ErfInvB[1]) * r) + ErfInvB[2]) * r) + ErfInvB[3]) * r) + ErfInvB[4]) * r) + 1)                  * Constants.Sqrt1_2;
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,ErrorFunctionAlgorithm,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\ErrorFunctionAlgorithm.cs,ErfInverse,The following statement contains a magic number: return ((((((((((ErfInvA[0] * r) + ErfInvA[1]) * r) + ErfInvA[2]) * r) + ErfInvA[3]) * r) + ErfInvA[4]) * r) + ErfInvA[5]) * q /                  ((((((((((ErfInvB[0] * r) + ErfInvB[1]) * r) + ErfInvB[2]) * r) + ErfInvB[3]) * r) + ErfInvB[4]) * r) + 1)                  * Constants.Sqrt1_2;
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,ErrorFunctionAlgorithm,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\ErrorFunctionAlgorithm.cs,ErfInverse,The following statement contains a magic number: return ((((((((((ErfInvA[0] * r) + ErfInvA[1]) * r) + ErfInvA[2]) * r) + ErfInvA[3]) * r) + ErfInvA[4]) * r) + ErfInvA[5]) * q /                  ((((((((((ErfInvB[0] * r) + ErfInvB[1]) * r) + ErfInvB[2]) * r) + ErfInvB[3]) * r) + ErfInvB[4]) * r) + 1)                  * Constants.Sqrt1_2;
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,ErrorFunctionAlgorithm,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\ErrorFunctionAlgorithm.cs,ErfInverse,The following statement contains a magic number: return ((((((((((ErfInvA[0] * r) + ErfInvA[1]) * r) + ErfInvA[2]) * r) + ErfInvA[3]) * r) + ErfInvA[4]) * r) + ErfInvA[5]) * q /                  ((((((((((ErfInvB[0] * r) + ErfInvB[1]) * r) + ErfInvB[2]) * r) + ErfInvB[3]) * r) + ErfInvB[4]) * r) + 1)                  * Constants.Sqrt1_2;
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,GammaAlgorithm,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\GammaAlgorithm.cs,GammaLn,The following statement contains a magic number: if(x < -34.0)              {                  // Reflection to positive range                  double y = -x;                  double decimalPart = y - Math.Floor(y);                  double z = y * Math.Sin(Math.PI * decimalPart);                  return Constants.LnPi - Math.Log(z) - GammaLnLargePositive(y);              }
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,GammaAlgorithm,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\GammaAlgorithm.cs,GammaLn,The following statement contains a magic number: if(x < 13)              {                  return GammaLnSmall(x);              }
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,GammaAlgorithm,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\GammaAlgorithm.cs,GammaLnSmall,The following statement contains a magic number: while(normalized >= 3)              {                  offset--;                  normalized = x + offset;                  z *= normalized;              }
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,GammaAlgorithm,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\GammaAlgorithm.cs,GammaLnSmall,The following statement contains a magic number: while(normalized < 2)              {                  z /= normalized;                  offset++;                  normalized = x + offset;              }
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,GammaAlgorithm,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\GammaAlgorithm.cs,GammaLnSmall,The following statement contains a magic number: if(normalized == 2)              {                  return Math.Log(z);              }
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,GammaAlgorithm,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\GammaAlgorithm.cs,GammaLnSmall,The following statement contains a magic number: x = x + offset - 2;
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,GammaAlgorithm,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\GammaAlgorithm.cs,GammaLnSmall,The following statement contains a magic number: double b = -1378.25152569120859100;
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,GammaAlgorithm,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\GammaAlgorithm.cs,GammaLnSmall,The following statement contains a magic number: b = -38801.6315134637840924 + (x * b);
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,GammaAlgorithm,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\GammaAlgorithm.cs,GammaLnSmall,The following statement contains a magic number: b = -331612.992738871184744 + (x * b);
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,GammaAlgorithm,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\GammaAlgorithm.cs,GammaLnSmall,The following statement contains a magic number: b = -1162370.97492762307383 + (x * b);
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,GammaAlgorithm,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\GammaAlgorithm.cs,GammaLnSmall,The following statement contains a magic number: b = -1721737.00820839662146 + (x * b);
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,GammaAlgorithm,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\GammaAlgorithm.cs,GammaLnSmall,The following statement contains a magic number: b = -853555.664245765465627 + (x * b);
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,GammaAlgorithm,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\GammaAlgorithm.cs,GammaLnSmall,The following statement contains a magic number: c = -351.815701436523470549 + (x * c);
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,GammaAlgorithm,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\GammaAlgorithm.cs,GammaLnSmall,The following statement contains a magic number: c = -17064.2106651881159223 + (x * c);
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,GammaAlgorithm,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\GammaAlgorithm.cs,GammaLnSmall,The following statement contains a magic number: c = -220528.590553854454839 + (x * c);
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,GammaAlgorithm,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\GammaAlgorithm.cs,GammaLnSmall,The following statement contains a magic number: c = -1139334.44367982507207 + (x * c);
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,GammaAlgorithm,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\GammaAlgorithm.cs,GammaLnSmall,The following statement contains a magic number: c = -2532523.07177582951285 + (x * c);
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,GammaAlgorithm,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\GammaAlgorithm.cs,GammaLnSmall,The following statement contains a magic number: c = -2018891.41433532773231 + (x * c);
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,GammaAlgorithm,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\GammaAlgorithm.cs,GammaLnLargePositive,The following statement contains a magic number: double q = ((x - 0.5) * Math.Log(x)) - x + Constants.Ln2Pi_2;
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,GammaAlgorithm,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\GammaAlgorithm.cs,GammaLnLargePositive,The following statement contains a magic number: if(x > 100000000)              {                  return q;              }
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,GammaAlgorithm,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\GammaAlgorithm.cs,GammaLnLargePositive,The following statement contains a magic number: if(x >= 1000.0)              {                  double a = 7.9365079365079365079365e-4;                  a = -2.7777777777777777777778e-3 + (p * a);                  a = 0.0833333333333333333333 + (p * a);                    return q + (a / x);              }
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,GammaAlgorithm,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\GammaAlgorithm.cs,GammaLnLargePositive,The following statement contains a magic number: if(x >= 1000.0)              {                  double a = 7.9365079365079365079365e-4;                  a = -2.7777777777777777777778e-3 + (p * a);                  a = 0.0833333333333333333333 + (p * a);                    return q + (a / x);              }
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,GammaAlgorithm,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\GammaAlgorithm.cs,GammaLnLargePositive,The following statement contains a magic number: if(x >= 1000.0)              {                  double a = 7.9365079365079365079365e-4;                  a = -2.7777777777777777777778e-3 + (p * a);                  a = 0.0833333333333333333333 + (p * a);                    return q + (a / x);              }
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,GammaAlgorithm,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\GammaAlgorithm.cs,GammaLnLargePositive,The following statement contains a magic number: if(x >= 1000.0)              {                  double a = 7.9365079365079365079365e-4;                  a = -2.7777777777777777777778e-3 + (p * a);                  a = 0.0833333333333333333333 + (p * a);                    return q + (a / x);              }
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,GammaAlgorithm,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\GammaAlgorithm.cs,GammaLnLargePositive,The following statement contains a magic number: double b = 8.11614167470508450300e-4;
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,GammaAlgorithm,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\GammaAlgorithm.cs,GammaLnLargePositive,The following statement contains a magic number: b = -5.95061904284301438324e-4 + (p * b);
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,GammaAlgorithm,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\GammaAlgorithm.cs,GammaLnLargePositive,The following statement contains a magic number: b = 7.93650340457716943945e-4 + (p * b);
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,GammaAlgorithm,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\GammaAlgorithm.cs,GammaLnLargePositive,The following statement contains a magic number: b = -2.77777777730099687205e-3 + (p * b);
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,GammaAlgorithm,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\GammaAlgorithm.cs,GammaLnLargePositive,The following statement contains a magic number: b = 8.33333333333331927722e-2 + (p * b);
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,GammaRegularizedAlgorithm,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\GammaRegularizedAlgorithm.cs,GammaRegularized,The following statement contains a magic number: const double Epsilon = 0.000000000000001;
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,GammaRegularizedAlgorithm,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\GammaRegularizedAlgorithm.cs,GammaRegularized,The following statement contains a magic number: const double BigNumber = 4503599627370496.0;
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,GammaRegularizedAlgorithm,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\GammaRegularizedAlgorithm.cs,GammaRegularized,The following statement contains a magic number: const double BigNumberInverse = 2.22044604925031308085e-16;
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,GammaRegularizedAlgorithm,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\GammaRegularizedAlgorithm.cs,GammaRegularized,The following statement contains a magic number: if(ax < -709.78271289338399)              {                  return 1d;              }
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,GammaRegularizedAlgorithm,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\GammaRegularizedAlgorithm.cs,GammaRegularized,The following statement contains a magic number: do              {                  c++;                  y += 1;                  z += 2;                  double yc = y * c;                    double p = (p2 * z) - (p3 * yc);                  double q = (q2 * z) - (q3 * yc);                    if(q != 0)                  {                      double nextans = p / q;                      error = Math.Abs((ans - nextans) / nextans);                      ans = nextans;                  }                  else                  {                      // zero div' skip                      error = 1;                  }                    // shift                  p3 = p2;                  p2 = p;                  q3 = q2;                  q2 = q;                    // normalize fraction when the numerator becomes large                  if(Math.Abs(p) > BigNumber)                  {                      p3 *= BigNumberInverse;                      p2 *= BigNumberInverse;                      q3 *= BigNumberInverse;                      q2 *= BigNumberInverse;                  }              }              while(error > Epsilon);
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,GammaRegularizedAlgorithm,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\GammaRegularizedAlgorithm.cs,GammaRegularizedInverse,The following statement contains a magic number: const double Epsilon = 0.000000000000001;
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,GammaRegularizedAlgorithm,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\GammaRegularizedAlgorithm.cs,GammaRegularizedInverse,The following statement contains a magic number: const double BigNumber = 4503599627370496.0;
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,GammaRegularizedAlgorithm,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\GammaRegularizedAlgorithm.cs,GammaRegularizedInverse,The following statement contains a magic number: const double Threshold = 5 * Epsilon;
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,GammaRegularizedAlgorithm,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\GammaRegularizedAlgorithm.cs,GammaRegularizedInverse,The following statement contains a magic number: double d = 1 / (9 * a);
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,GammaRegularizedAlgorithm,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\GammaRegularizedAlgorithm.cs,GammaRegularizedInverse,The following statement contains a magic number: double y = 1 - d - (0.98 * Constants.Sqrt2 * ErrorFunctionAlgorithm.ErfInverse((2.0 * y0) - 1.0) * Math.Sqrt(d));
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,GammaRegularizedAlgorithm,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\GammaRegularizedAlgorithm.cs,GammaRegularizedInverse,The following statement contains a magic number: double y = 1 - d - (0.98 * Constants.Sqrt2 * ErrorFunctionAlgorithm.ErfInverse((2.0 * y0) - 1.0) * Math.Sqrt(d));
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,GammaRegularizedAlgorithm,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\GammaRegularizedAlgorithm.cs,GammaRegularizedInverse,The following statement contains a magic number: for(int i = 0; i < 10; i++)              {                  if(x < xLower || x > xUpper)                  {                      d = 0.0625;                      break;                  }                    y = 1 - GammaRegularized(a' x);                  if(y < yLower || y > yUpper)                  {                      d = 0.0625;                      break;                  }                    if(y < y0)                  {                      xUpper = x;                      yLower = y;                  }                  else                  {                      xLower = x;                      yUpper = y;                  }                    d = ((a - 1) * Math.Log(x)) - x - lgm;                  if(d < -709.78271289338399)                  {                      d = 0.0625;                      break;                  }                    d = -Math.Exp(d);                  d = (y - y0) / d;                  if(Math.Abs(d / x) < Epsilon)                  {                      return x;                  }                    if((d > (x / 4)) && (y0 < 0.05))                  {                      // Naive heuristics for cases near the singularity                      d = x / 10;                  }                    x -= d;              }
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,GammaRegularizedAlgorithm,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\GammaRegularizedAlgorithm.cs,GammaRegularizedInverse,The following statement contains a magic number: for(int i = 0; i < 10; i++)              {                  if(x < xLower || x > xUpper)                  {                      d = 0.0625;                      break;                  }                    y = 1 - GammaRegularized(a' x);                  if(y < yLower || y > yUpper)                  {                      d = 0.0625;                      break;                  }                    if(y < y0)                  {                      xUpper = x;                      yLower = y;                  }                  else                  {                      xLower = x;                      yUpper = y;                  }                    d = ((a - 1) * Math.Log(x)) - x - lgm;                  if(d < -709.78271289338399)                  {                      d = 0.0625;                      break;                  }                    d = -Math.Exp(d);                  d = (y - y0) / d;                  if(Math.Abs(d / x) < Epsilon)                  {                      return x;                  }                    if((d > (x / 4)) && (y0 < 0.05))                  {                      // Naive heuristics for cases near the singularity                      d = x / 10;                  }                    x -= d;              }
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,GammaRegularizedAlgorithm,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\GammaRegularizedAlgorithm.cs,GammaRegularizedInverse,The following statement contains a magic number: for(int i = 0; i < 10; i++)              {                  if(x < xLower || x > xUpper)                  {                      d = 0.0625;                      break;                  }                    y = 1 - GammaRegularized(a' x);                  if(y < yLower || y > yUpper)                  {                      d = 0.0625;                      break;                  }                    if(y < y0)                  {                      xUpper = x;                      yLower = y;                  }                  else                  {                      xLower = x;                      yUpper = y;                  }                    d = ((a - 1) * Math.Log(x)) - x - lgm;                  if(d < -709.78271289338399)                  {                      d = 0.0625;                      break;                  }                    d = -Math.Exp(d);                  d = (y - y0) / d;                  if(Math.Abs(d / x) < Epsilon)                  {                      return x;                  }                    if((d > (x / 4)) && (y0 < 0.05))                  {                      // Naive heuristics for cases near the singularity                      d = x / 10;                  }                    x -= d;              }
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,GammaRegularizedAlgorithm,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\GammaRegularizedAlgorithm.cs,GammaRegularizedInverse,The following statement contains a magic number: for(int i = 0; i < 10; i++)              {                  if(x < xLower || x > xUpper)                  {                      d = 0.0625;                      break;                  }                    y = 1 - GammaRegularized(a' x);                  if(y < yLower || y > yUpper)                  {                      d = 0.0625;                      break;                  }                    if(y < y0)                  {                      xUpper = x;                      yLower = y;                  }                  else                  {                      xLower = x;                      yUpper = y;                  }                    d = ((a - 1) * Math.Log(x)) - x - lgm;                  if(d < -709.78271289338399)                  {                      d = 0.0625;                      break;                  }                    d = -Math.Exp(d);                  d = (y - y0) / d;                  if(Math.Abs(d / x) < Epsilon)                  {                      return x;                  }                    if((d > (x / 4)) && (y0 < 0.05))                  {                      // Naive heuristics for cases near the singularity                      d = x / 10;                  }                    x -= d;              }
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,GammaRegularizedAlgorithm,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\GammaRegularizedAlgorithm.cs,GammaRegularizedInverse,The following statement contains a magic number: for(int i = 0; i < 10; i++)              {                  if(x < xLower || x > xUpper)                  {                      d = 0.0625;                      break;                  }                    y = 1 - GammaRegularized(a' x);                  if(y < yLower || y > yUpper)                  {                      d = 0.0625;                      break;                  }                    if(y < y0)                  {                      xUpper = x;                      yLower = y;                  }                  else                  {                      xLower = x;                      yUpper = y;                  }                    d = ((a - 1) * Math.Log(x)) - x - lgm;                  if(d < -709.78271289338399)                  {                      d = 0.0625;                      break;                  }                    d = -Math.Exp(d);                  d = (y - y0) / d;                  if(Math.Abs(d / x) < Epsilon)                  {                      return x;                  }                    if((d > (x / 4)) && (y0 < 0.05))                  {                      // Naive heuristics for cases near the singularity                      d = x / 10;                  }                    x -= d;              }
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,GammaRegularizedAlgorithm,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\GammaRegularizedAlgorithm.cs,GammaRegularizedInverse,The following statement contains a magic number: for(int i = 0; i < 10; i++)              {                  if(x < xLower || x > xUpper)                  {                      d = 0.0625;                      break;                  }                    y = 1 - GammaRegularized(a' x);                  if(y < yLower || y > yUpper)                  {                      d = 0.0625;                      break;                  }                    if(y < y0)                  {                      xUpper = x;                      yLower = y;                  }                  else                  {                      xLower = x;                      yUpper = y;                  }                    d = ((a - 1) * Math.Log(x)) - x - lgm;                  if(d < -709.78271289338399)                  {                      d = 0.0625;                      break;                  }                    d = -Math.Exp(d);                  d = (y - y0) / d;                  if(Math.Abs(d / x) < Epsilon)                  {                      return x;                  }                    if((d > (x / 4)) && (y0 < 0.05))                  {                      // Naive heuristics for cases near the singularity                      d = x / 10;                  }                    x -= d;              }
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,GammaRegularizedAlgorithm,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\GammaRegularizedAlgorithm.cs,GammaRegularizedInverse,The following statement contains a magic number: for(int i = 0; i < 10; i++)              {                  if(x < xLower || x > xUpper)                  {                      d = 0.0625;                      break;                  }                    y = 1 - GammaRegularized(a' x);                  if(y < yLower || y > yUpper)                  {                      d = 0.0625;                      break;                  }                    if(y < y0)                  {                      xUpper = x;                      yLower = y;                  }                  else                  {                      xLower = x;                      yUpper = y;                  }                    d = ((a - 1) * Math.Log(x)) - x - lgm;                  if(d < -709.78271289338399)                  {                      d = 0.0625;                      break;                  }                    d = -Math.Exp(d);                  d = (y - y0) / d;                  if(Math.Abs(d / x) < Epsilon)                  {                      return x;                  }                    if((d > (x / 4)) && (y0 < 0.05))                  {                      // Naive heuristics for cases near the singularity                      d = x / 10;                  }                    x -= d;              }
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,GammaRegularizedAlgorithm,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\GammaRegularizedAlgorithm.cs,GammaRegularizedInverse,The following statement contains a magic number: for(int i = 0; i < 10; i++)              {                  if(x < xLower || x > xUpper)                  {                      d = 0.0625;                      break;                  }                    y = 1 - GammaRegularized(a' x);                  if(y < yLower || y > yUpper)                  {                      d = 0.0625;                      break;                  }                    if(y < y0)                  {                      xUpper = x;                      yLower = y;                  }                  else                  {                      xLower = x;                      yUpper = y;                  }                    d = ((a - 1) * Math.Log(x)) - x - lgm;                  if(d < -709.78271289338399)                  {                      d = 0.0625;                      break;                  }                    d = -Math.Exp(d);                  d = (y - y0) / d;                  if(Math.Abs(d / x) < Epsilon)                  {                      return x;                  }                    if((d > (x / 4)) && (y0 < 0.05))                  {                      // Naive heuristics for cases near the singularity                      d = x / 10;                  }                    x -= d;              }
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,GammaRegularizedAlgorithm,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\GammaRegularizedAlgorithm.cs,GammaRegularizedInverse,The following statement contains a magic number: d = 0.5;
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,GammaRegularizedAlgorithm,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\GammaRegularizedAlgorithm.cs,GammaRegularizedInverse,The following statement contains a magic number: for(int i = 0; i < 400; i++)              {                  x = xLower + (d * (xUpper - xLower));                  y = 1 - GammaRegularized(a' x);                  lgm = (xUpper - xLower) / (xLower + xUpper);                  if(Math.Abs(lgm) < Threshold)                  {                      return x;                  }                    lgm = (y - y0) / y0;                  if(Math.Abs(lgm) < Threshold)                  {                      return x;                  }                    if(x <= 0d)                  {                      return 0d;                  }                    if(y >= y0)                  {                      xLower = x;                      yUpper = y;                      if(dir < 0)                      {                          dir = 0;                          d = 0.5;                      }                      else                      {                          if(dir > 1)                          {                              d = (0.5 * d) + 0.5;                          }                          else                          {                              d = (y0 - yLower) / (yUpper - yLower);                          }                      }                        dir = dir + 1;                  }                  else                  {                      xUpper = x;                      yLower = y;                      if(dir > 0)                      {                          dir = 0;                          d = 0.5;                      }                      else                      {                          if(dir < -1)                          {                              d = 0.5 * d;                          }                          else                          {                              d = (y0 - yLower) / (yUpper - yLower);                          }                      }                        dir = dir - 1;                  }              }
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,GammaRegularizedAlgorithm,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\GammaRegularizedAlgorithm.cs,GammaRegularizedInverse,The following statement contains a magic number: for(int i = 0; i < 400; i++)              {                  x = xLower + (d * (xUpper - xLower));                  y = 1 - GammaRegularized(a' x);                  lgm = (xUpper - xLower) / (xLower + xUpper);                  if(Math.Abs(lgm) < Threshold)                  {                      return x;                  }                    lgm = (y - y0) / y0;                  if(Math.Abs(lgm) < Threshold)                  {                      return x;                  }                    if(x <= 0d)                  {                      return 0d;                  }                    if(y >= y0)                  {                      xLower = x;                      yUpper = y;                      if(dir < 0)                      {                          dir = 0;                          d = 0.5;                      }                      else                      {                          if(dir > 1)                          {                              d = (0.5 * d) + 0.5;                          }                          else                          {                              d = (y0 - yLower) / (yUpper - yLower);                          }                      }                        dir = dir + 1;                  }                  else                  {                      xUpper = x;                      yLower = y;                      if(dir > 0)                      {                          dir = 0;                          d = 0.5;                      }                      else                      {                          if(dir < -1)                          {                              d = 0.5 * d;                          }                          else                          {                              d = (y0 - yLower) / (yUpper - yLower);                          }                      }                        dir = dir - 1;                  }              }
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,GammaRegularizedAlgorithm,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\GammaRegularizedAlgorithm.cs,GammaRegularizedInverse,The following statement contains a magic number: for(int i = 0; i < 400; i++)              {                  x = xLower + (d * (xUpper - xLower));                  y = 1 - GammaRegularized(a' x);                  lgm = (xUpper - xLower) / (xLower + xUpper);                  if(Math.Abs(lgm) < Threshold)                  {                      return x;                  }                    lgm = (y - y0) / y0;                  if(Math.Abs(lgm) < Threshold)                  {                      return x;                  }                    if(x <= 0d)                  {                      return 0d;                  }                    if(y >= y0)                  {                      xLower = x;                      yUpper = y;                      if(dir < 0)                      {                          dir = 0;                          d = 0.5;                      }                      else                      {                          if(dir > 1)                          {                              d = (0.5 * d) + 0.5;                          }                          else                          {                              d = (y0 - yLower) / (yUpper - yLower);                          }                      }                        dir = dir + 1;                  }                  else                  {                      xUpper = x;                      yLower = y;                      if(dir > 0)                      {                          dir = 0;                          d = 0.5;                      }                      else                      {                          if(dir < -1)                          {                              d = 0.5 * d;                          }                          else                          {                              d = (y0 - yLower) / (yUpper - yLower);                          }                      }                        dir = dir - 1;                  }              }
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,GammaRegularizedAlgorithm,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\GammaRegularizedAlgorithm.cs,GammaRegularizedInverse,The following statement contains a magic number: for(int i = 0; i < 400; i++)              {                  x = xLower + (d * (xUpper - xLower));                  y = 1 - GammaRegularized(a' x);                  lgm = (xUpper - xLower) / (xLower + xUpper);                  if(Math.Abs(lgm) < Threshold)                  {                      return x;                  }                    lgm = (y - y0) / y0;                  if(Math.Abs(lgm) < Threshold)                  {                      return x;                  }                    if(x <= 0d)                  {                      return 0d;                  }                    if(y >= y0)                  {                      xLower = x;                      yUpper = y;                      if(dir < 0)                      {                          dir = 0;                          d = 0.5;                      }                      else                      {                          if(dir > 1)                          {                              d = (0.5 * d) + 0.5;                          }                          else                          {                              d = (y0 - yLower) / (yUpper - yLower);                          }                      }                        dir = dir + 1;                  }                  else                  {                      xUpper = x;                      yLower = y;                      if(dir > 0)                      {                          dir = 0;                          d = 0.5;                      }                      else                      {                          if(dir < -1)                          {                              d = 0.5 * d;                          }                          else                          {                              d = (y0 - yLower) / (yUpper - yLower);                          }                      }                        dir = dir - 1;                  }              }
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,GammaRegularizedAlgorithm,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\GammaRegularizedAlgorithm.cs,GammaRegularizedInverse,The following statement contains a magic number: for(int i = 0; i < 400; i++)              {                  x = xLower + (d * (xUpper - xLower));                  y = 1 - GammaRegularized(a' x);                  lgm = (xUpper - xLower) / (xLower + xUpper);                  if(Math.Abs(lgm) < Threshold)                  {                      return x;                  }                    lgm = (y - y0) / y0;                  if(Math.Abs(lgm) < Threshold)                  {                      return x;                  }                    if(x <= 0d)                  {                      return 0d;                  }                    if(y >= y0)                  {                      xLower = x;                      yUpper = y;                      if(dir < 0)                      {                          dir = 0;                          d = 0.5;                      }                      else                      {                          if(dir > 1)                          {                              d = (0.5 * d) + 0.5;                          }                          else                          {                              d = (y0 - yLower) / (yUpper - yLower);                          }                      }                        dir = dir + 1;                  }                  else                  {                      xUpper = x;                      yLower = y;                      if(dir > 0)                      {                          dir = 0;                          d = 0.5;                      }                      else                      {                          if(dir < -1)                          {                              d = 0.5 * d;                          }                          else                          {                              d = (y0 - yLower) / (yUpper - yLower);                          }                      }                        dir = dir - 1;                  }              }
Magic Number,MathNet.Numerics.SpecialFunctions.Algorithms,GammaRegularizedAlgorithm,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\SpecialFunctions\Algorithms\GammaRegularizedAlgorithm.cs,GammaRegularizedInverse,The following statement contains a magic number: for(int i = 0; i < 400; i++)              {                  x = xLower + (d * (xUpper - xLower));                  y = 1 - GammaRegularized(a' x);                  lgm = (xUpper - xLower) / (xLower + xUpper);                  if(Math.Abs(lgm) < Threshold)                  {                      return x;                  }                    lgm = (y - y0) / y0;                  if(Math.Abs(lgm) < Threshold)                  {                      return x;                  }                    if(x <= 0d)                  {                      return 0d;                  }                    if(y >= y0)                  {                      xLower = x;                      yUpper = y;                      if(dir < 0)                      {                          dir = 0;                          d = 0.5;                      }                      else                      {                          if(dir > 1)                          {                              d = (0.5 * d) + 0.5;                          }                          else                          {                              d = (y0 - yLower) / (yUpper - yLower);                          }                      }                        dir = dir + 1;                  }                  else                  {                      xUpper = x;                      yLower = y;                      if(dir > 0)                      {                          dir = 0;                          d = 0.5;                      }                      else                      {                          if(dir < -1)                          {                              d = 0.5 * d;                          }                          else                          {                              d = (y0 - yLower) / (yUpper - yLower);                          }                      }                        dir = dir - 1;                  }              }
Magic Number,MathNet.Numerics.Statistics,DescriptiveStatistics,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Statistics\DescriptiveStatistics.cs,Median,The following statement contains a magic number: int lowerMidpoint = list.Count / 2;
Magic Number,MathNet.Numerics.Statistics,DescriptiveStatistics,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Statistics\DescriptiveStatistics.cs,UpperMedian,The following statement contains a magic number: int lowerMidpoint = IntegerTheory.IsEven(list.Count) ? ((list.Count / 2) + 1) : (list.Count / 2);
Magic Number,MathNet.Numerics.Statistics,DescriptiveStatistics,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Statistics\DescriptiveStatistics.cs,UpperMedian,The following statement contains a magic number: int lowerMidpoint = IntegerTheory.IsEven(list.Count) ? ((list.Count / 2) + 1) : (list.Count / 2);
Magic Number,MathNet.Numerics.Statistics,Histogram,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Statistics\Histogram.cs,JoinBuckets,The following statement contains a magic number: for(int i = 0; i < _buckets.Count - 2; i++)              {                  Bucket u = _buckets[i];                  Bucket v = _buckets[i + 1];                  u.UpperBound = v.LowerBound = (u.UpperBound + v.LowerBound) / 2;              }
Magic Number,MathNet.Numerics.Statistics,Histogram,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Statistics\Histogram.cs,JoinBuckets,The following statement contains a magic number: for(int i = 0; i < _buckets.Count - 2; i++)              {                  Bucket u = _buckets[i];                  Bucket v = _buckets[i + 1];                  u.UpperBound = v.LowerBound = (u.UpperBound + v.LowerBound) / 2;              }
Magic Number,MathNet.Numerics.Statistics,Histogram,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Statistics\Histogram.cs,OptimalDispersion,The following statement contains a magic number: if(distribution.Count < Math.Max(bucketCount' 2))              {                  throw new ArgumentException(Properties.LocalStrings.InvalidOperationHistogramNotEnoughPoints);              }
Magic Number,MathNet.Numerics.Statistics,Histogram,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Statistics\Histogram.cs,OptimalDispersion,The following statement contains a magic number: for(int i = 0' avg = 0; i < values.Length; i++)              {                  while((avg + 1) < values.Length &&                      values[avg + 1] < prefixSum[i + 1] / (i + 1))                  {                      avg++;                  }                    optimalCost[i' 0] =                      prefixSum[i + 1]                      - (2 * prefixSum[avg + 1])                      + (((2 * avg) - i + 1) * (prefixSum[i + 1] / (i + 1)));              }
Magic Number,MathNet.Numerics.Statistics,Histogram,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Statistics\Histogram.cs,OptimalDispersion,The following statement contains a magic number: for(int i = 0' avg = 0; i < values.Length; i++)              {                  while((avg + 1) < values.Length &&                      values[avg + 1] < prefixSum[i + 1] / (i + 1))                  {                      avg++;                  }                    optimalCost[i' 0] =                      prefixSum[i + 1]                      - (2 * prefixSum[avg + 1])                      + (((2 * avg) - i + 1) * (prefixSum[i + 1] / (i + 1)));              }
Magic Number,MathNet.Numerics.Statistics,Histogram,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Statistics\Histogram.cs,OptimalDispersion,The following statement contains a magic number: for(int k = 1; k < bucketCount; k++)              {                  // Loop on the number of considered values                  // (note that there are 'i+1' considered values)                  for(int i = k; i < values.Length; i++)                  {                      optimalCost[i' k] = double.PositiveInfinity;                        // Loop for finding the optimal boundary of the last bucket                      // ('j+1' is the index of the first value in the last bucket)                      for(int j = (k - 1)' avg = (k - 1); j < i; j++)                      {                          while((avg + 1) < values.Length &&                              values[avg + 1] < (prefixSum[i + 1] - prefixSum[j + 1]) / (i - j))                          {                              avg++;                          }                            double currentCost =                              optimalCost[j' k - 1]                              + prefixSum[i + 1]                              + prefixSum[j + 1]                              - (2 * prefixSum[avg + 1])                              + (((2 * avg) - i - j) * (prefixSum[i + 1] - prefixSum[j + 1]) / (i - j));                            if(currentCost < optimalCost[i' k])                          {                              optimalCost[i' k] = currentCost;                              lastBucketIndex[i' k] = j + 1;                          }                      }                  }              }
Magic Number,MathNet.Numerics.Statistics,Histogram,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Statistics\Histogram.cs,OptimalDispersion,The following statement contains a magic number: for(int k = 1; k < bucketCount; k++)              {                  // Loop on the number of considered values                  // (note that there are 'i+1' considered values)                  for(int i = k; i < values.Length; i++)                  {                      optimalCost[i' k] = double.PositiveInfinity;                        // Loop for finding the optimal boundary of the last bucket                      // ('j+1' is the index of the first value in the last bucket)                      for(int j = (k - 1)' avg = (k - 1); j < i; j++)                      {                          while((avg + 1) < values.Length &&                              values[avg + 1] < (prefixSum[i + 1] - prefixSum[j + 1]) / (i - j))                          {                              avg++;                          }                            double currentCost =                              optimalCost[j' k - 1]                              + prefixSum[i + 1]                              + prefixSum[j + 1]                              - (2 * prefixSum[avg + 1])                              + (((2 * avg) - i - j) * (prefixSum[i + 1] - prefixSum[j + 1]) / (i - j));                            if(currentCost < optimalCost[i' k])                          {                              optimalCost[i' k] = currentCost;                              lastBucketIndex[i' k] = j + 1;                          }                      }                  }              }
Magic Number,MathNet.Numerics.Statistics,Histogram,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Statistics\Histogram.cs,OptimalFreedom,The following statement contains a magic number: if(distribution.Count < Math.Max(bucketCount' 2))              {                  throw new ArgumentException(Properties.LocalStrings.InvalidOperationHistogramNotEnoughPoints);              }
Magic Number,MathNet.Numerics.Statistics,Histogram,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Statistics\Histogram.cs,OptimalSquaredFreedom,The following statement contains a magic number: if(distribution.Count < Math.Max(histSize' 2))              {                  throw new ArgumentException(Properties.LocalStrings.InvalidOperationHistogramNotEnoughPoints);              }
Magic Number,MathNet.Numerics.Transformations,ComplexFourierTransformation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Transformations\ComplexFourierTransformation.cs,GenerateFrequencyScale,The following statement contains a magic number: f = -step * (secondHalf - 2);
Magic Number,MathNet.Numerics.Transformations,ComplexFourierTransformation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Transformations\ComplexFourierTransformation.cs,TransformForward,The following statement contains a magic number: for(int i = 0' j = 0; i < samples.Length; i++' j += 2)              {                  samplePairs[j] = samples[i].Real;                  samplePairs[j + 1] = samples[i].Imag;              }
Magic Number,MathNet.Numerics.Transformations,ComplexFourierTransformation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Transformations\ComplexFourierTransformation.cs,TransformForward,The following statement contains a magic number: for(int i = 0' j = 0; i < samples.Length; i++' j += 2)              {                  samples[i].Real = samplePairs[j];                  samples[i].Imag = samplePairs[j + 1];              }
Magic Number,MathNet.Numerics.Transformations,ComplexFourierTransformation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Transformations\ComplexFourierTransformation.cs,TransformBackward,The following statement contains a magic number: for(int i = 0' j = 0; i < samples.Length; i++' j += 2)              {                  samplePairs[j] = samples[i].Real;                  samplePairs[j + 1] = samples[i].Imag;              }
Magic Number,MathNet.Numerics.Transformations,ComplexFourierTransformation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Transformations\ComplexFourierTransformation.cs,TransformBackward,The following statement contains a magic number: for(int i = 0' j = 0; i < samples.Length; i++' j += 2)              {                  samples[i].Real = samplePairs[j];                  samples[i].Imag = samplePairs[j + 1];              }
Magic Number,MathNet.Numerics.Transformations,ComplexFourierTransformation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Transformations\ComplexFourierTransformation.cs,TransformForward,The following statement contains a magic number: for(int i = 0' j = 0; i < samples.Length; i++' j += 2)              {                  samplePairs[j] = samples[i].Real;                  samplePairs[j + 1] = samples[i].Imag;              }
Magic Number,MathNet.Numerics.Transformations,ComplexFourierTransformation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Transformations\ComplexFourierTransformation.cs,TransformForward,The following statement contains a magic number: for(int i = 0' j = 0; i < samples.Length; i++' j += 2)              {                  samples[i].Real = samplePairs[j];                  samples[i].Imag = samplePairs[j + 1];              }
Magic Number,MathNet.Numerics.Transformations,ComplexFourierTransformation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Transformations\ComplexFourierTransformation.cs,TransformBackward,The following statement contains a magic number: for(int i = 0' j = 0; i < samples.Length; i++' j += 2)              {                  samplePairs[j] = samples[i].Real;                  samplePairs[j + 1] = samples[i].Imag;              }
Magic Number,MathNet.Numerics.Transformations,ComplexFourierTransformation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Transformations\ComplexFourierTransformation.cs,TransformBackward,The following statement contains a magic number: for(int i = 0' j = 0; i < samples.Length; i++' j += 2)              {                  samples[i].Real = samplePairs[j];                  samples[i].Imag = samplePairs[j + 1];              }
Magic Number,MathNet.Numerics.Transformations,InternalFFT,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Transformations\InternalFFT.cs,ReorderSamples,The following statement contains a magic number: for(int i = 0; i < numSamplePairs; i++)              {                  int swap = reversedBits[i];                  if(swap > i)                  {                      int a = 2 * i' b = 2 * swap;                        double tmp = samples[a];                      samples[a] = samples[b];                      samples[b] = tmp;                        tmp = samples[a + 1];                      samples[a + 1] = samples[b + 1];                      samples[b + 1] = tmp;                  }              }
Magic Number,MathNet.Numerics.Transformations,InternalFFT,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Transformations\InternalFFT.cs,ReorderSamples,The following statement contains a magic number: for(int i = 0; i < numSamplePairs; i++)              {                  int swap = reversedBits[i];                  if(swap > i)                  {                      int a = 2 * i' b = 2 * swap;                        double tmp = samples[a];                      samples[a] = samples[b];                      samples[b] = tmp;                        tmp = samples[a + 1];                      samples[a + 1] = samples[b + 1];                      samples[b + 1] = tmp;                  }              }
Magic Number,MathNet.Numerics.Transformations,InternalFFT,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Transformations\InternalFFT.cs,ReorderSamplesMultiDim,The following statement contains a magic number: for(int i2 = 0' i = 0; i2 < stride; i2 += step' i++)              {                  int swap = reversedBits[i] * step;                  if(swap > i2)                  {                      for(int i1 = i2; i1 < i2 + step; i1 += 2)                      {                          for(int i3 = i1; i3 < samples.Length; i3 += stride)                          {                              int swap3 = swap + i3 - i2;                                double tmp = samples[swap3];                              samples[swap3] = samples[i3];                              samples[i3] = tmp;                                tmp = samples[swap3 + 1];                              samples[swap3 + 1] = samples[i3 + 1];                              samples[i3 + 1] = tmp;                          }                      }                  }              }
Magic Number,MathNet.Numerics.Transformations,InternalFFT,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Transformations\InternalFFT.cs,DanielsonLanczosTransform,The following statement contains a magic number: int n = 2;
Magic Number,MathNet.Numerics.Transformations,InternalFFT,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Transformations\InternalFFT.cs,DanielsonLanczosTransform,The following statement contains a magic number: for(int level = 1; level <= levels; level++)              {                  int m = n;                  n <<= 1;                    double[] realCosine = RealCosineCoefficients(level' forward);                  double[] imagSine = ImaginarySineCoefficients(level' forward);                    for(int j = 0' jj = 0; jj < m; j++' jj += 2)                  {                      double uR = realCosine[j];                      double uI = expSignConvention * imagSine[j];                        for(int even = jj; even < samples.Length; even += n)                      {                          int odd = even + m;                            double re = samples[odd];                          double im = samples[odd + 1];                            double tmpr = (re * uR) - (im * uI);                          double tmpi = (re * uI) + (im * uR);                            re = samples[even];                          im = samples[even + 1];                            samples[even] = re + tmpr;                          samples[even + 1] = im + tmpi;                            samples[odd] = re - tmpr;                          samples[odd + 1] = im - tmpi;                      }                  }              }
Magic Number,MathNet.Numerics.Transformations,InternalFFT,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Transformations\InternalFFT.cs,DanielsonLanczosTransformMultiDim,The following statement contains a magic number: for(int level = 1; level <= levels; level++)              {                  int m = n;                  n <<= 1;                    double[] realCosine = RealCosineCoefficients(level' forward);                  double[] imagSine = ImaginarySineCoefficients(level' forward);                    for(int j = 0' jj = 0; jj < m; j++' jj += step)                  {                      double uR = realCosine[j];                      double uI = expSignConvention * imagSine[j];                        for(int i = jj; i < jj + step; i += 2)                      {                          for(int even = i; even < samples.Length; even += n)                          {                              int odd = even + m;                                double re = samples[odd];                              double im = samples[odd + 1];                                double tmpr = (re * uR) - (im * uI);                              double tmpi = (re * uI) + (im * uR);                                re = samples[even];                              im = samples[even + 1];                                samples[even] = re + tmpr;                              samples[even + 1] = im + tmpi;                                samples[odd] = re - tmpr;                              samples[odd + 1] = im - tmpi;                          }                      }                  }              }
Magic Number,MathNet.Numerics.Transformations,InternalFFT,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Transformations\InternalFFT.cs,Rescale,The following statement contains a magic number: double factor = 2.0 / samples.Length;
Magic Number,MathNet.Numerics.Transformations,RealFourierTransformation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Transformations\RealFourierTransformation.cs,GenerateFrequencyScale,The following statement contains a magic number: f = -step * (secondHalf - 2);
Magic Number,MathNet.Numerics.Transformations,RealFourierTransformation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Transformations\RealFourierTransformation.cs,TransformForward,The following statement contains a magic number: for(int i = 0' j = 0; i < numSamples; i++' j += 2)              {                  complex[j] = samples1[i];                  complex[j + 1] = samples2[i];              }
Magic Number,MathNet.Numerics.Transformations,RealFourierTransformation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Transformations\RealFourierTransformation.cs,TransformForward,The following statement contains a magic number: for(int i = 1' j = 2; j <= numSamples; i++' j += 2)              {                  double h1Real = 0.5 * (complex[j] + complex[length - j]);                  double h1Imag = 0.5 * (complex[j + 1] - complex[length + 1 - j]);                  double h2Real = 0.5 * (complex[j + 1] + complex[length + 1 - j]);                  double h2Imag = -0.5 * (complex[j] - complex[length - j]);                    fftReal1[i] = h1Real;                  fftImag1[i] = h1Imag;                  fftReal1[numSamples - i] = h1Real;                  fftImag1[numSamples - i] = -h1Imag;                    fftReal2[i] = h2Real;                  fftImag2[i] = h2Imag;                  fftReal2[numSamples - i] = h2Real;                  fftImag2[numSamples - i] = -h2Imag;              }
Magic Number,MathNet.Numerics.Transformations,RealFourierTransformation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Transformations\RealFourierTransformation.cs,TransformForward,The following statement contains a magic number: for(int i = 1' j = 2; j <= numSamples; i++' j += 2)              {                  double h1Real = 0.5 * (complex[j] + complex[length - j]);                  double h1Imag = 0.5 * (complex[j + 1] - complex[length + 1 - j]);                  double h2Real = 0.5 * (complex[j + 1] + complex[length + 1 - j]);                  double h2Imag = -0.5 * (complex[j] - complex[length - j]);                    fftReal1[i] = h1Real;                  fftImag1[i] = h1Imag;                  fftReal1[numSamples - i] = h1Real;                  fftImag1[numSamples - i] = -h1Imag;                    fftReal2[i] = h2Real;                  fftImag2[i] = h2Imag;                  fftReal2[numSamples - i] = h2Real;                  fftImag2[numSamples - i] = -h2Imag;              }
Magic Number,MathNet.Numerics.Transformations,RealFourierTransformation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Transformations\RealFourierTransformation.cs,TransformForward,The following statement contains a magic number: for(int i = 1' j = 2; j <= numSamples; i++' j += 2)              {                  double h1Real = 0.5 * (complex[j] + complex[length - j]);                  double h1Imag = 0.5 * (complex[j + 1] - complex[length + 1 - j]);                  double h2Real = 0.5 * (complex[j + 1] + complex[length + 1 - j]);                  double h2Imag = -0.5 * (complex[j] - complex[length - j]);                    fftReal1[i] = h1Real;                  fftImag1[i] = h1Imag;                  fftReal1[numSamples - i] = h1Real;                  fftImag1[numSamples - i] = -h1Imag;                    fftReal2[i] = h2Real;                  fftImag2[i] = h2Imag;                  fftReal2[numSamples - i] = h2Real;                  fftImag2[numSamples - i] = -h2Imag;              }
Magic Number,MathNet.Numerics.Transformations,RealFourierTransformation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Transformations\RealFourierTransformation.cs,TransformForward,The following statement contains a magic number: for(int i = 1' j = 2; j <= numSamples; i++' j += 2)              {                  double h1Real = 0.5 * (complex[j] + complex[length - j]);                  double h1Imag = 0.5 * (complex[j + 1] - complex[length + 1 - j]);                  double h2Real = 0.5 * (complex[j + 1] + complex[length + 1 - j]);                  double h2Imag = -0.5 * (complex[j] - complex[length - j]);                    fftReal1[i] = h1Real;                  fftImag1[i] = h1Imag;                  fftReal1[numSamples - i] = h1Real;                  fftImag1[numSamples - i] = -h1Imag;                    fftReal2[i] = h2Real;                  fftImag2[i] = h2Imag;                  fftReal2[numSamples - i] = h2Real;                  fftImag2[numSamples - i] = -h2Imag;              }
Magic Number,MathNet.Numerics.Transformations,RealFourierTransformation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Transformations\RealFourierTransformation.cs,TransformForward,The following statement contains a magic number: for(int i = 1' j = 2; j <= numSamples; i++' j += 2)              {                  double h1Real = 0.5 * (complex[j] + complex[length - j]);                  double h1Imag = 0.5 * (complex[j + 1] - complex[length + 1 - j]);                  double h2Real = 0.5 * (complex[j + 1] + complex[length + 1 - j]);                  double h2Imag = -0.5 * (complex[j] - complex[length - j]);                    fftReal1[i] = h1Real;                  fftImag1[i] = h1Imag;                  fftReal1[numSamples - i] = h1Real;                  fftImag1[numSamples - i] = -h1Imag;                    fftReal2[i] = h2Real;                  fftImag2[i] = h2Imag;                  fftReal2[numSamples - i] = h2Real;                  fftImag2[numSamples - i] = -h2Imag;              }
Magic Number,MathNet.Numerics.Transformations,RealFourierTransformation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Transformations\RealFourierTransformation.cs,TransformForward,The following statement contains a magic number: for(int i = 1' j = 2; j <= numSamples; i++' j += 2)              {                  double h1Real = 0.5 * (complex[j] + complex[length - j]);                  double h1Imag = 0.5 * (complex[j + 1] - complex[length + 1 - j]);                  double h2Real = 0.5 * (complex[j + 1] + complex[length + 1 - j]);                  double h2Imag = -0.5 * (complex[j] - complex[length - j]);                    fftReal1[i] = h1Real;                  fftImag1[i] = h1Imag;                  fftReal1[numSamples - i] = h1Real;                  fftImag1[numSamples - i] = -h1Imag;                    fftReal2[i] = h2Real;                  fftImag2[i] = h2Imag;                  fftReal2[numSamples - i] = h2Real;                  fftImag2[numSamples - i] = -h2Imag;              }
Magic Number,MathNet.Numerics.Transformations,RealFourierTransformation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Transformations\RealFourierTransformation.cs,TransformBackward,The following statement contains a magic number: for(int i = 0' j = 0; i < numSamples; i++' j += 2)              {                  complex[j] = fftReal1[i] - fftImag2[i];                  complex[j + 1] = fftImag1[i] + fftReal2[i];              }
Magic Number,MathNet.Numerics.Transformations,RealFourierTransformation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Transformations\RealFourierTransformation.cs,TransformBackward,The following statement contains a magic number: for(int i = 0' j = 0; i < numSamples; i++' j += 2)              {                  samples1[i] = complex[j];                  samples2[i] = complex[j + 1];              }
Magic Number,MathNet.Numerics.Transformations,RealFourierTransformation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Transformations\RealFourierTransformation.cs,TransformForward,The following statement contains a magic number: double wtemp = Trig.Sine(0.5 * theta);
Magic Number,MathNet.Numerics.Transformations,RealFourierTransformation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Transformations\RealFourierTransformation.cs,TransformForward,The following statement contains a magic number: double wpr = -2.0 * wtemp * wtemp;
Magic Number,MathNet.Numerics.Transformations,RealFourierTransformation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Transformations\RealFourierTransformation.cs,TransformForward,The following statement contains a magic number: for(int i = 1' j = 2; j <= numSamples; i++' j += 2)              {                  double h1Real = 0.5 * (complex[j] + complex[length - j]);                  double h1Imag = 0.5 * (complex[j + 1] - complex[length + 1 - j]);                  double h2Real = 0.5 * (complex[j + 1] + complex[length + 1 - j]);                  double h2Imag = -0.5 * (complex[j] - complex[length - j]);                    fftReal[i] = h1Real + (wr * h2Real) + (wi * h2Imag);                  fftImag[i] = h1Imag + (wr * h2Imag) - (wi * h2Real);                  fftReal[numSamples - i] = h1Real - (wr * h2Real) - (wi * h2Imag);                  fftImag[numSamples - i] = -h1Imag + (wr * h2Imag) - (wi * h2Real);                    // For consistency and completeness we also provide the                  // negative spectrum' even though it's redundant in the real case.                  fftReal[numSamples + i] = fftReal[numSamples - i];                  fftImag[numSamples + i] = -fftImag[numSamples - i];                  fftReal[length - i] = fftReal[i];                  fftImag[length - i] = -fftImag[i];                    wr = ((wtemp = wr) * wpr) - (wi * wpi) + wr;                  wi = (wi * wpr) + (wtemp * wpi) + wi;              }
Magic Number,MathNet.Numerics.Transformations,RealFourierTransformation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Transformations\RealFourierTransformation.cs,TransformForward,The following statement contains a magic number: for(int i = 1' j = 2; j <= numSamples; i++' j += 2)              {                  double h1Real = 0.5 * (complex[j] + complex[length - j]);                  double h1Imag = 0.5 * (complex[j + 1] - complex[length + 1 - j]);                  double h2Real = 0.5 * (complex[j + 1] + complex[length + 1 - j]);                  double h2Imag = -0.5 * (complex[j] - complex[length - j]);                    fftReal[i] = h1Real + (wr * h2Real) + (wi * h2Imag);                  fftImag[i] = h1Imag + (wr * h2Imag) - (wi * h2Real);                  fftReal[numSamples - i] = h1Real - (wr * h2Real) - (wi * h2Imag);                  fftImag[numSamples - i] = -h1Imag + (wr * h2Imag) - (wi * h2Real);                    // For consistency and completeness we also provide the                  // negative spectrum' even though it's redundant in the real case.                  fftReal[numSamples + i] = fftReal[numSamples - i];                  fftImag[numSamples + i] = -fftImag[numSamples - i];                  fftReal[length - i] = fftReal[i];                  fftImag[length - i] = -fftImag[i];                    wr = ((wtemp = wr) * wpr) - (wi * wpi) + wr;                  wi = (wi * wpr) + (wtemp * wpi) + wi;              }
Magic Number,MathNet.Numerics.Transformations,RealFourierTransformation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Transformations\RealFourierTransformation.cs,TransformForward,The following statement contains a magic number: for(int i = 1' j = 2; j <= numSamples; i++' j += 2)              {                  double h1Real = 0.5 * (complex[j] + complex[length - j]);                  double h1Imag = 0.5 * (complex[j + 1] - complex[length + 1 - j]);                  double h2Real = 0.5 * (complex[j + 1] + complex[length + 1 - j]);                  double h2Imag = -0.5 * (complex[j] - complex[length - j]);                    fftReal[i] = h1Real + (wr * h2Real) + (wi * h2Imag);                  fftImag[i] = h1Imag + (wr * h2Imag) - (wi * h2Real);                  fftReal[numSamples - i] = h1Real - (wr * h2Real) - (wi * h2Imag);                  fftImag[numSamples - i] = -h1Imag + (wr * h2Imag) - (wi * h2Real);                    // For consistency and completeness we also provide the                  // negative spectrum' even though it's redundant in the real case.                  fftReal[numSamples + i] = fftReal[numSamples - i];                  fftImag[numSamples + i] = -fftImag[numSamples - i];                  fftReal[length - i] = fftReal[i];                  fftImag[length - i] = -fftImag[i];                    wr = ((wtemp = wr) * wpr) - (wi * wpi) + wr;                  wi = (wi * wpr) + (wtemp * wpi) + wi;              }
Magic Number,MathNet.Numerics.Transformations,RealFourierTransformation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Transformations\RealFourierTransformation.cs,TransformForward,The following statement contains a magic number: for(int i = 1' j = 2; j <= numSamples; i++' j += 2)              {                  double h1Real = 0.5 * (complex[j] + complex[length - j]);                  double h1Imag = 0.5 * (complex[j + 1] - complex[length + 1 - j]);                  double h2Real = 0.5 * (complex[j + 1] + complex[length + 1 - j]);                  double h2Imag = -0.5 * (complex[j] - complex[length - j]);                    fftReal[i] = h1Real + (wr * h2Real) + (wi * h2Imag);                  fftImag[i] = h1Imag + (wr * h2Imag) - (wi * h2Real);                  fftReal[numSamples - i] = h1Real - (wr * h2Real) - (wi * h2Imag);                  fftImag[numSamples - i] = -h1Imag + (wr * h2Imag) - (wi * h2Real);                    // For consistency and completeness we also provide the                  // negative spectrum' even though it's redundant in the real case.                  fftReal[numSamples + i] = fftReal[numSamples - i];                  fftImag[numSamples + i] = -fftImag[numSamples - i];                  fftReal[length - i] = fftReal[i];                  fftImag[length - i] = -fftImag[i];                    wr = ((wtemp = wr) * wpr) - (wi * wpi) + wr;                  wi = (wi * wpr) + (wtemp * wpi) + wi;              }
Magic Number,MathNet.Numerics.Transformations,RealFourierTransformation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Transformations\RealFourierTransformation.cs,TransformForward,The following statement contains a magic number: for(int i = 1' j = 2; j <= numSamples; i++' j += 2)              {                  double h1Real = 0.5 * (complex[j] + complex[length - j]);                  double h1Imag = 0.5 * (complex[j + 1] - complex[length + 1 - j]);                  double h2Real = 0.5 * (complex[j + 1] + complex[length + 1 - j]);                  double h2Imag = -0.5 * (complex[j] - complex[length - j]);                    fftReal[i] = h1Real + (wr * h2Real) + (wi * h2Imag);                  fftImag[i] = h1Imag + (wr * h2Imag) - (wi * h2Real);                  fftReal[numSamples - i] = h1Real - (wr * h2Real) - (wi * h2Imag);                  fftImag[numSamples - i] = -h1Imag + (wr * h2Imag) - (wi * h2Real);                    // For consistency and completeness we also provide the                  // negative spectrum' even though it's redundant in the real case.                  fftReal[numSamples + i] = fftReal[numSamples - i];                  fftImag[numSamples + i] = -fftImag[numSamples - i];                  fftReal[length - i] = fftReal[i];                  fftImag[length - i] = -fftImag[i];                    wr = ((wtemp = wr) * wpr) - (wi * wpi) + wr;                  wi = (wi * wpr) + (wtemp * wpi) + wi;              }
Magic Number,MathNet.Numerics.Transformations,RealFourierTransformation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Transformations\RealFourierTransformation.cs,TransformForward,The following statement contains a magic number: for(int i = 1' j = 2; j <= numSamples; i++' j += 2)              {                  double h1Real = 0.5 * (complex[j] + complex[length - j]);                  double h1Imag = 0.5 * (complex[j + 1] - complex[length + 1 - j]);                  double h2Real = 0.5 * (complex[j + 1] + complex[length + 1 - j]);                  double h2Imag = -0.5 * (complex[j] - complex[length - j]);                    fftReal[i] = h1Real + (wr * h2Real) + (wi * h2Imag);                  fftImag[i] = h1Imag + (wr * h2Imag) - (wi * h2Real);                  fftReal[numSamples - i] = h1Real - (wr * h2Real) - (wi * h2Imag);                  fftImag[numSamples - i] = -h1Imag + (wr * h2Imag) - (wi * h2Real);                    // For consistency and completeness we also provide the                  // negative spectrum' even though it's redundant in the real case.                  fftReal[numSamples + i] = fftReal[numSamples - i];                  fftImag[numSamples + i] = -fftImag[numSamples - i];                  fftReal[length - i] = fftReal[i];                  fftImag[length - i] = -fftImag[i];                    wr = ((wtemp = wr) * wpr) - (wi * wpi) + wr;                  wi = (wi * wpr) + (wtemp * wpi) + wi;              }
Magic Number,MathNet.Numerics.Transformations,RealFourierTransformation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Transformations\RealFourierTransformation.cs,TransformBackward,The following statement contains a magic number: double wtemp = Trig.Sine(0.5 * theta);
Magic Number,MathNet.Numerics.Transformations,RealFourierTransformation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Transformations\RealFourierTransformation.cs,TransformBackward,The following statement contains a magic number: double wpr = -2.0 * wtemp * wtemp;
Magic Number,MathNet.Numerics.Transformations,RealFourierTransformation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Transformations\RealFourierTransformation.cs,TransformBackward,The following statement contains a magic number: samples[1] = 0.5 * (fftReal[0] - fftReal[numSamples]);
Magic Number,MathNet.Numerics.Transformations,RealFourierTransformation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Transformations\RealFourierTransformation.cs,TransformBackward,The following statement contains a magic number: samples[0] = 0.5 * (fftReal[0] + fftReal[numSamples]);
Magic Number,MathNet.Numerics.Transformations,RealFourierTransformation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Transformations\RealFourierTransformation.cs,TransformBackward,The following statement contains a magic number: for(int i = 1' j = 2; j <= numSamples; i++' j += 2)              {                  double h1Real = 0.5 * (fftReal[i] + fftReal[numSamples - i]);                  double h1Imag = 0.5 * (fftImag[i] - fftImag[numSamples - i]);                  double h2Real = -0.5 * (fftImag[i] + fftImag[numSamples - i]);                  double h2Imag = 0.5 * (fftReal[i] - fftReal[numSamples - i]);                    samples[j] = h1Real + (wr * h2Real) + (wi * h2Imag);                  samples[j + 1] = h1Imag + (wr * h2Imag) - (wi * h2Real);                  samples[length - j] = h1Real - (wr * h2Real) - (wi * h2Imag);                  samples[length + 1 - j] = -h1Imag + (wr * h2Imag) - (wi * h2Real);                    wr = ((wtemp = wr) * wpr) - (wi * wpi) + wr;                  wi = (wi * wpr) + (wtemp * wpi) + wi;              }
Magic Number,MathNet.Numerics.Transformations,RealFourierTransformation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Transformations\RealFourierTransformation.cs,TransformBackward,The following statement contains a magic number: for(int i = 1' j = 2; j <= numSamples; i++' j += 2)              {                  double h1Real = 0.5 * (fftReal[i] + fftReal[numSamples - i]);                  double h1Imag = 0.5 * (fftImag[i] - fftImag[numSamples - i]);                  double h2Real = -0.5 * (fftImag[i] + fftImag[numSamples - i]);                  double h2Imag = 0.5 * (fftReal[i] - fftReal[numSamples - i]);                    samples[j] = h1Real + (wr * h2Real) + (wi * h2Imag);                  samples[j + 1] = h1Imag + (wr * h2Imag) - (wi * h2Real);                  samples[length - j] = h1Real - (wr * h2Real) - (wi * h2Imag);                  samples[length + 1 - j] = -h1Imag + (wr * h2Imag) - (wi * h2Real);                    wr = ((wtemp = wr) * wpr) - (wi * wpi) + wr;                  wi = (wi * wpr) + (wtemp * wpi) + wi;              }
Magic Number,MathNet.Numerics.Transformations,RealFourierTransformation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Transformations\RealFourierTransformation.cs,TransformBackward,The following statement contains a magic number: for(int i = 1' j = 2; j <= numSamples; i++' j += 2)              {                  double h1Real = 0.5 * (fftReal[i] + fftReal[numSamples - i]);                  double h1Imag = 0.5 * (fftImag[i] - fftImag[numSamples - i]);                  double h2Real = -0.5 * (fftImag[i] + fftImag[numSamples - i]);                  double h2Imag = 0.5 * (fftReal[i] - fftReal[numSamples - i]);                    samples[j] = h1Real + (wr * h2Real) + (wi * h2Imag);                  samples[j + 1] = h1Imag + (wr * h2Imag) - (wi * h2Real);                  samples[length - j] = h1Real - (wr * h2Real) - (wi * h2Imag);                  samples[length + 1 - j] = -h1Imag + (wr * h2Imag) - (wi * h2Real);                    wr = ((wtemp = wr) * wpr) - (wi * wpi) + wr;                  wi = (wi * wpr) + (wtemp * wpi) + wi;              }
Magic Number,MathNet.Numerics.Transformations,RealFourierTransformation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Transformations\RealFourierTransformation.cs,TransformBackward,The following statement contains a magic number: for(int i = 1' j = 2; j <= numSamples; i++' j += 2)              {                  double h1Real = 0.5 * (fftReal[i] + fftReal[numSamples - i]);                  double h1Imag = 0.5 * (fftImag[i] - fftImag[numSamples - i]);                  double h2Real = -0.5 * (fftImag[i] + fftImag[numSamples - i]);                  double h2Imag = 0.5 * (fftReal[i] - fftReal[numSamples - i]);                    samples[j] = h1Real + (wr * h2Real) + (wi * h2Imag);                  samples[j + 1] = h1Imag + (wr * h2Imag) - (wi * h2Real);                  samples[length - j] = h1Real - (wr * h2Real) - (wi * h2Imag);                  samples[length + 1 - j] = -h1Imag + (wr * h2Imag) - (wi * h2Real);                    wr = ((wtemp = wr) * wpr) - (wi * wpi) + wr;                  wi = (wi * wpr) + (wtemp * wpi) + wi;              }
Magic Number,MathNet.Numerics.Transformations,RealFourierTransformation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Transformations\RealFourierTransformation.cs,TransformBackward,The following statement contains a magic number: for(int i = 1' j = 2; j <= numSamples; i++' j += 2)              {                  double h1Real = 0.5 * (fftReal[i] + fftReal[numSamples - i]);                  double h1Imag = 0.5 * (fftImag[i] - fftImag[numSamples - i]);                  double h2Real = -0.5 * (fftImag[i] + fftImag[numSamples - i]);                  double h2Imag = 0.5 * (fftReal[i] - fftReal[numSamples - i]);                    samples[j] = h1Real + (wr * h2Real) + (wi * h2Imag);                  samples[j + 1] = h1Imag + (wr * h2Imag) - (wi * h2Real);                  samples[length - j] = h1Real - (wr * h2Real) - (wi * h2Imag);                  samples[length + 1 - j] = -h1Imag + (wr * h2Imag) - (wi * h2Real);                    wr = ((wtemp = wr) * wpr) - (wi * wpi) + wr;                  wi = (wi * wpr) + (wtemp * wpi) + wi;              }
Magic Number,MathNet.Numerics.Transformations,RealFourierTransformation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Transformations\RealFourierTransformation.cs,TransformBackward,The following statement contains a magic number: for(int i = 1' j = 2; j <= numSamples; i++' j += 2)              {                  double h1Real = 0.5 * (fftReal[i] + fftReal[numSamples - i]);                  double h1Imag = 0.5 * (fftImag[i] - fftImag[numSamples - i]);                  double h2Real = -0.5 * (fftImag[i] + fftImag[numSamples - i]);                  double h2Imag = 0.5 * (fftReal[i] - fftReal[numSamples - i]);                    samples[j] = h1Real + (wr * h2Real) + (wi * h2Imag);                  samples[j + 1] = h1Imag + (wr * h2Imag) - (wi * h2Real);                  samples[length - j] = h1Real - (wr * h2Real) - (wi * h2Imag);                  samples[length + 1 - j] = -h1Imag + (wr * h2Imag) - (wi * h2Real);                    wr = ((wtemp = wr) * wpr) - (wi * wpi) + wr;                  wi = (wi * wpr) + (wtemp * wpi) + wi;              }
Magic Number,MathNet.Numerics.Transformations,RealFourierTransformation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Transformations\RealFourierTransformation.cs,TransformForward,The following statement contains a magic number: for(int i = 0' j = 0; i < samples.Length; i++' j += 2)              {                  samplePairs[j] = samples[i];              }
Magic Number,MathNet.Numerics.Transformations,RealFourierTransformation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Transformations\RealFourierTransformation.cs,TransformForward,The following statement contains a magic number: for(int i = 0' j = 0; i < samples.Length; i++' j += 2)              {                  fftReal[i] = samplePairs[j];                  fftImag[i] = samplePairs[j + 1];              }
Magic Number,MathNet.Numerics.Transformations,RealFourierTransformation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Transformations\RealFourierTransformation.cs,TransformBackward,The following statement contains a magic number: for(int i = 0' j = 0; i < fftReal.Length; i++' j += 2)              {                  samplePairs[j] = fftReal[i];                  samplePairs[j + 1] = fftImag[i];              }
Magic Number,MathNet.Numerics.Transformations,RealFourierTransformation,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\Transformations\RealFourierTransformation.cs,TransformBackward,The following statement contains a magic number: for(int i = 0' j = 0; i < samples.Length; i++' j += 2)              {                  samples[i] = samplePairs[j];              }
Missing Default,MathNet.Numerics.LinearAlgebra,SingularValueDecomposition,C:\repos\mathnet_mathnet-iridium\src\app\MathNet.Iridium\Library\LinearAlgebra\SingularValueDecomposition.cs,SingularValueDecomposition,The following switch statement is missing a default case: switch(step)                  {                      // Deflate negligible s(p).                      case IterationStep.DeflateNeglible:                          {                              double f = e[p - 2];                              e[p - 2] = 0.0;                              for(int j = p - 2; j >= k; j--)                              {                                  double t = Fn.Hypot(s[j]' f);                                  double cs = s[j] / t;                                  double sn = f / t;                                  s[j] = t;                                    if(j != k)                                  {                                      f = (-sn) * e[j - 1];                                      e[j - 1] = cs * e[j - 1];                                  }                                    for(int i = 0; i < _n; i++)                                  {                                      t = (cs * v[i][j]) + (sn * v[i][p - 1]);                                      v[i][p - 1] = ((-sn) * v[i][j]) + (cs * v[i][p - 1]);                                      v[i][j] = t;                                  }                              }                          }                            break;                        // Split at negligible s(k)                      case IterationStep.SplitAtNeglible:                          {                              double f = e[k - 1];                              e[k - 1] = 0.0;                              for(int j = k; j < p; j++)                              {                                  double t = Fn.Hypot(s[j]' f);                                  double cs = s[j] / t;                                  double sn = f / t;                                  s[j] = t;                                  f = (-sn) * e[j];                                  e[j] = cs * e[j];                                    for(int i = 0; i < _m; i++)                                  {                                      t = (cs * u[i][j]) + (sn * u[i][k - 1]);                                      u[i][k - 1] = ((-sn) * u[i][j]) + (cs * u[i][k - 1]);                                      u[i][j] = t;                                  }                              }                          }                            break;                        // Perform one qr step.                      case IterationStep.QR:                          {                              /* Calculate the shift */                                double scale = Math.Max(Math.Max(Math.Max(Math.Max(Math.Abs(s[p - 1])' Math.Abs(s[p - 2]))' Math.Abs(e[p - 2]))' Math.Abs(s[k]))' Math.Abs(e[k]));                              double sp = s[p - 1] / scale;                              double spm1 = s[p - 2] / scale;                              double epm1 = e[p - 2] / scale;                              double sk = s[k] / scale;                              double ek = e[k] / scale;                              double b = (((spm1 + sp) * (spm1 - sp)) + (epm1 * epm1)) / 2.0;                              double c = (sp * epm1) * (sp * epm1);                              double shift = 0.0;                              if((b != 0.0) | (c != 0.0))                              {                                  shift = Math.Sqrt((b * b) + c);                                    if(b < 0.0)                                  {                                      shift = -shift;                                  }                                    shift = c / (b + shift);                              }                                double f = ((sk + sp) * (sk - sp)) + shift;                              double g = sk * ek;                                /* Chase zeros */                                for(int j = k; j < p - 1; j++)                              {                                  double t = Fn.Hypot(f' g);                                  double cs = f / t;                                  double sn = g / t;                                    if(j != k)                                  {                                      e[j - 1] = t;                                  }                                    f = (cs * s[j]) + (sn * e[j]);                                  e[j] = (cs * e[j]) - (sn * s[j]);                                  g = sn * s[j + 1];                                  s[j + 1] = cs * s[j + 1];                                    for(int i = 0; i < _n; i++)                                  {                                      t = (cs * v[i][j]) + (sn * v[i][j + 1]);                                      v[i][j + 1] = ((-sn) * v[i][j]) + (cs * v[i][j + 1]);                                      v[i][j] = t;                                  }                                    t = Fn.Hypot(f' g);                                  cs = f / t;                                  sn = g / t;                                  s[j] = t;                                  f = (cs * e[j]) + (sn * s[j + 1]);                                  s[j + 1] = ((-sn) * e[j]) + (cs * s[j + 1]);                                  g = sn * e[j + 1];                                  e[j + 1] = cs * e[j + 1];                                    if(j < _m - 1)                                  {                                      for(int i = 0; i < _m; i++)                                      {                                          t = (cs * u[i][j]) + (sn * u[i][j + 1]);                                          u[i][j + 1] = ((-sn) * u[i][j]) + (cs * u[i][j + 1]);                                          u[i][j] = t;                                      }                                  }                              }                                e[p - 2] = f;                              iter = iter + 1;                          }                            break;                        // Convergence.                      case IterationStep.Convergence:                          {                              /* Make the singular values positive */                                if(s[k] <= 0.0)                              {                                  s[k] = (s[k] < 0.0 ? -s[k] : 0.0);                                    for(int i = 0; i <= pp; i++)                                  {                                      v[i][k] = -v[i][k];                                  }                              }                                /* Order the singular values */                                while(k < pp)                              {                                  if(s[k] >= s[k + 1])                                  {                                      break;                                  }                                    double t = s[k];                                  s[k] = s[k + 1];                                  s[k + 1] = t;                                    if(k < _n - 1)                                  {                                      for(int i = 0; i < _n; i++)                                      {                                          t = v[i][k + 1];                                          v[i][k + 1] = v[i][k];                                          v[i][k] = t;                                      }                                  }                                    if(k < _m - 1)                                  {                                      for(int i = 0; i < _m; i++)                                      {                                          t = u[i][k + 1];                                          u[i][k + 1] = u[i][k];                                          u[i][k] = t;                                      }                                  }                                    k++;                              }                                iter = 0;                              p--;                          }                            break;                  }
